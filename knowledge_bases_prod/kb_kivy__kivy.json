[
  "def ver_equal(self, other):\n    return self.version == other",
  "def get_description():\n    with open(join(dirname(__file__), 'README.md'), 'rb') as fileh:\n        return fileh.read().decode(\"utf8\").replace('\\r\\n', '\\n')",
  "def getoutput(cmd, env=None):\n    import subprocess\n    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE, env=env)\n    p.wait()\n    if p.returncode:  # if not returncode == 0\n        print('WARNING: A problem occurred while running {0} (code {1})\\n'\n              .format(cmd, p.returncode))\n        stderr_content = p.stderr.read()\n        if stderr_content:\n            print('{0}\\n'.format(stderr_content))\n        return \"\"\n    return p.stdout.read()",
  "def pkgconfig(*packages, **kw):\n    flag_map = {'-I': 'include_dirs', '-L': 'library_dirs', '-l': 'libraries'}\n    lenviron = None\n\n    if platform == 'win32':\n        pconfig = join(sys.prefix, 'libs', 'pkgconfig')\n        if isdir(pconfig):\n            lenviron = environ.copy()\n            lenviron['PKG_CONFIG_PATH'] = '{};{}'.format(\n                environ.get('PKG_CONFIG_PATH', ''), pconfig)\n\n    if KIVY_DEPS_ROOT and platform != 'win32':\n        lenviron = environ.copy()\n        lenviron[\"PKG_CONFIG_PATH\"] = \"{}:{}:{}\".format(\n            environ.get(\"PKG_CONFIG_PATH\", \"\"),\n            join(\n                KIVY_DEPS_ROOT, \"dist\", \"lib\", \"pkgconfig\"\n            ),\n            join(\n                KIVY_DEPS_ROOT, \"dist\", \"lib64\", \"pkgconfig\"\n            ),\n        )\n\n    cmd = 'pkg-config --libs --cflags {}'.format(' '.join(packages))\n    results = getoutput(cmd, lenviron).split()\n    for token in results:\n        ext = token[:2].decode('utf-8')\n        flag = flag_map.get(ext)\n        if not flag:\n            continue\n        kw.setdefault(flag, []).append(token[2:].decode('utf-8'))\n    return kw",
  "def get_isolated_env_paths():\n    try:\n        # sdl2_dev is installed before setup.py is run, when installing from\n        # source due to pyproject.toml. However, it is installed to a\n        # pip isolated env, which we need to add to compiler\n        import kivy_deps.sdl2_dev as sdl2_dev\n    except ImportError:\n        return [], []\n\n    root = os.path.abspath(join(sdl2_dev.__path__[0], '../../../..'))\n    includes = [join(root, 'Include')] if isdir(join(root, 'Include')) else []\n    libs = [join(root, 'libs')] if isdir(join(root, 'libs')) else []\n    return includes, libs",
  "def check_c_source_compiles(code, include_dirs=None):\n    \"\"\"Check if C code compiles.\n    This function can be used to check if a specific feature is available on\n    the current platform, and therefore enable or disable some modules.\n    \"\"\"\n\n    def get_compiler():\n        \"\"\"Get the compiler instance used by setuptools.\n        This is a bit hacky, but seems the only way to get the compiler instance\n        used by setuptools, without using private APIs or the deprecated\n        distutils module. (See: https://github.com/pypa/setuptools/issues/2806)\n        \"\"\"\n        fake_dist_build_ext = Distribution().get_command_obj(\"build_ext\")\n        fake_dist_build_ext.finalize_options()\n        # register an extension to ensure a compiler is created\n        fake_dist_build_ext.extensions = [Extension(\"ignored\", [\"ignored.c\"])]\n        # disable building fake extensions\n        fake_dist_build_ext.build_extensions = lambda: None\n        # run to populate self.compiler\n        fake_dist_build_ext.run()\n        return fake_dist_build_ext.compiler\n\n    # Create a temporary file which contains the code\n    with tempfile.TemporaryDirectory() as tmpdir:\n        temp_file = os.path.join(tmpdir, \"test.c\")\n        with open(temp_file, \"w\", encoding=\"utf-8\") as tf:\n            tf.write(code)\n        try:\n            get_compiler().compile(\n                [temp_file], extra_postargs=[], include_dirs=include_dirs\n            )\n        except Exception as ex:\n            print(ex)\n            return False\n    return True",
  "class KivyBuildExt(build_ext, object):\n\n    def finalize_options(self):\n        super().finalize_options()\n\n        # Build the extensions in parallel if the options has not been set\n        if hasattr(self, 'parallel') and self.parallel is None:\n            # Use a maximum of 4 cores. If cpu_count returns None, then parallel\n            # build will be disabled\n            self.parallel = min(4, os.cpu_count() or 0)\n            if self.parallel:\n                print('Building extensions in parallel using {} cores'.format(\n                    self.parallel))\n\n        global build_path\n        if (self.build_lib is not None and exists(self.build_lib) and\n                not self.inplace):\n            build_path = self.build_lib\n            print(\"Updated build directory to: {}\".format(build_path))\n\n    def build_extensions(self):\n        # build files\n        config_h_fn = ('include', 'config.h')\n        config_pxi_fn = ('include', 'config.pxi')\n        config_py_fn = ('setupconfig.py', )\n\n        # generate headers\n        config_h = '// Autogenerated file for Kivy C configuration\\n'\n        config_h += '#define __PY3 1\\n'\n        config_pxi = '# Autogenerated file for Kivy Cython configuration\\n'\n        config_pxi += 'DEF PY3 = 1\\n'\n        config_py = '# Autogenerated file for Kivy configuration\\n'\n        config_py += 'PY3 = 1\\n'\n        config_py += 'CYTHON_MIN = {0}\\nCYTHON_MAX = {1}\\n'.format(\n            repr(MIN_CYTHON_STRING), repr(MAX_CYTHON_STRING))\n        config_py += 'CYTHON_BAD = {0}\\n'.format(repr(', '.join(map(\n            str, CYTHON_UNSUPPORTED))))\n\n        # generate content\n        print('Build configuration is:')\n        for opt, value in c_options.items():\n            # kivy_sdl_gl_alpha_size is already an integer\n            if opt != 'kivy_sdl_gl_alpha_size':\n                value = int(bool(value))\n            print(' * {0} = {1}'.format(opt, value))\n            opt = opt.upper()\n            config_h += '#define __{0} {1}\\n'.format(opt, value)\n            config_pxi += 'DEF {0} = {1}\\n'.format(opt, value)\n            config_py += '{0} = {1}\\n'.format(opt, value)\n        debug = bool(self.debug)\n        print(' * debug = {0}'.format(debug))\n\n        config_pxi += 'DEF DEBUG = {0}\\n'.format(debug)\n        config_py += 'DEBUG = {0}\\n'.format(debug)\n        config_pxi += 'DEF PLATFORM = \"{0}\"\\n'.format(platform)\n        config_py += 'PLATFORM = \"{0}\"\\n'.format(platform)\n        for fn, content in (\n                (config_h_fn, config_h), (config_pxi_fn, config_pxi),\n                (config_py_fn, config_py)):\n            build_fn = expand(build_path, *fn)\n            if self.update_if_changed(build_fn, content):\n                print('Updated {}'.format(build_fn))\n            src_fn = expand(src_path, *fn)\n            if src_fn != build_fn and self.update_if_changed(src_fn, content):\n                print('Updated {}'.format(src_fn))\n\n        c = self.compiler.compiler_type\n        print('Detected compiler is {}'.format(c))\n        if c != 'msvc':\n            for e in self.extensions:\n                e.extra_link_args += ['-lm']\n\n        super().build_extensions()\n\n    def update_if_changed(self, fn, content):\n        need_update = True\n        if exists(fn):\n            with open(fn) as fd:\n                need_update = fd.read() != content\n        if need_update:\n            directory_name = dirname(fn)\n            if not exists(directory_name):\n                makedirs(directory_name)\n            with open(fn, 'w') as fd:\n                fd.write(content)\n        return need_update",
  "def _check_and_fix_sdl2_mixer(f_path):\n    # Between SDL_mixer 2.0.1 and 2.0.4, the included frameworks changed\n    # smpeg2 have been replaced with mpg123, but there is no need to fix.\n    smpeg2_path = (\"{}/Versions/A/Frameworks/smpeg2.framework\"\n                   \"/Versions/A/smpeg2\").format(f_path)\n    if not exists(smpeg2_path):\n        return\n\n    print(\"Check if SDL2_mixer smpeg2 have an @executable_path\")\n    rpath_from = (\"@executable_path/../Frameworks/SDL2.framework\"\n                  \"/Versions/A/SDL2\")\n    rpath_to = \"@rpath/../../../../SDL2.framework/Versions/A/SDL2\"\n    output = getoutput((\"otool -L '{}'\").format(smpeg2_path)).decode('utf-8')\n    if \"@executable_path\" not in output:\n        return\n\n    print(\"WARNING: Your SDL2_mixer version is invalid\")\n    print(\"WARNING: The smpeg2 framework embedded in SDL2_mixer contains a\")\n    print(\"WARNING: reference to @executable_path that will fail the\")\n    print(\"WARNING: execution of your application.\")\n    print(\"WARNING: We are going to change:\")\n    print(\"WARNING: from: {}\".format(rpath_from))\n    print(\"WARNING: to: {}\".format(rpath_to))\n    getoutput(\"install_name_tool -change {} {} {}\".format(\n        rpath_from, rpath_to, smpeg2_path))\n\n    output = getoutput((\"otool -L '{}'\").format(smpeg2_path))\n    if b\"@executable_path\" not in output:\n        print(\"WARNING: Change successfully applied!\")\n        print(\"WARNING: You'll never see this message again.\")\n    else:\n        print(\"WARNING: Unable to apply the changes, sorry.\")",
  "def expand(root, *args):\n    return join(root, 'kivy', *args)",
  "class CythonExtension(Extension):\n\n    def __init__(self, *args, **kwargs):\n        Extension.__init__(self, *args, **kwargs)\n        self.cython_directives = {\n            'c_string_encoding': 'utf-8',\n            'profile': 'USE_PROFILE' in environ,\n            'embedsignature': use_embed_signature,\n            'language_level': 3,\n            'unraisable_tracebacks': True,\n        }",
  "def merge(d1, *args):\n    d1 = deepcopy(d1)\n    for d2 in args:\n        for key, value in d2.items():\n            value = deepcopy(value)\n            if key in d1:\n                d1[key].extend(value)\n            else:\n                d1[key] = value\n    return d1",
  "def determine_base_flags():\n    includes, libs = get_isolated_env_paths()\n\n    flags = {\n        'libraries': [],\n        'include_dirs': [join(src_path, 'kivy', 'include')] + includes,\n        'library_dirs': [] + libs,\n        'extra_link_args': [],\n        'extra_compile_args': []}\n    if c_options['use_ios']:\n        sysroot = environ.get('IOSSDKROOT', environ.get('SDKROOT'))\n        if not sysroot:\n            raise Exception('IOSSDKROOT is not set')\n        flags['include_dirs'] += [sysroot]\n        flags['extra_compile_args'] += ['-isysroot', sysroot]\n        flags['extra_link_args'] += ['-isysroot', sysroot]\n    elif platform.startswith('freebsd'):\n        flags['include_dirs'] += [join(\n            environ.get('LOCALBASE', '/usr/local'), 'include')]\n        flags['library_dirs'] += [join(\n            environ.get('LOCALBASE', '/usr/local'), 'lib')]\n    elif platform == 'darwin' and c_options['use_osx_frameworks']:\n        v = os.uname()\n        if v[2] >= '13.0.0':\n            if 'SDKROOT' in environ:\n                sysroot = join(environ['SDKROOT'], 'System/Library/Frameworks')\n            else:\n                # use xcode-select to search on the right Xcode path\n                # XXX use the best SDK available instead of a specific one\n                import platform as _platform\n                xcode_dev = getoutput('xcode-select -p').splitlines()[0]\n                sdk_mac_ver = '.'.join(_platform.mac_ver()[0].split('.')[:2])\n                print('Xcode detected at {}, and using OS X{} sdk'.format(\n                    xcode_dev, sdk_mac_ver))\n                sysroot = join(\n                    xcode_dev.decode('utf-8'),\n                    'Platforms/MacOSX.platform/Developer/SDKs',\n                    'MacOSX{}.sdk'.format(sdk_mac_ver),\n                    'System/Library/Frameworks')\n        else:\n            sysroot = ('/System/Library/Frameworks/'\n                       'ApplicationServices.framework/Frameworks')\n        flags['extra_compile_args'] += ['-F%s' % sysroot]\n        flags['extra_link_args'] += ['-F%s' % sysroot]\n    elif platform == 'win32':\n        flags['include_dirs'] += [sysconfig.get_path('include')]\n        flags['library_dirs'] += [join(sys.prefix, \"libs\")]\n    return flags",
  "def determine_gl_flags():\n    kivy_graphics_include = join(src_path, 'kivy', 'include')\n    flags = {'include_dirs': [kivy_graphics_include], 'libraries': []}\n    base_flags = {'include_dirs': [kivy_graphics_include], 'libraries': []}\n    cross_sysroot = environ.get('KIVY_CROSS_SYSROOT')\n\n    if c_options['use_opengl_mock']:\n        return flags, base_flags\n    if platform == 'win32':\n        flags['libraries'] = ['opengl32', 'glew32']\n    elif platform == 'ios':\n        flags['libraries'] = ['GLESv2']\n        flags['extra_link_args'] = ['-framework', 'OpenGLES']\n    elif platform == 'darwin':\n        flags['extra_link_args'] = ['-framework', 'OpenGL']\n    elif platform.startswith('freebsd'):\n        flags['libraries'] = ['GL']\n    elif platform.startswith('openbsd'):\n        flags['include_dirs'] = ['/usr/X11R6/include']\n        flags['library_dirs'] = ['/usr/X11R6/lib']\n        flags['libraries'] = ['GL']\n    elif platform == 'android':\n        flags['include_dirs'] = [join(ndkplatform, 'usr', 'include')]\n        flags['library_dirs'] = [join(ndkplatform, 'usr', 'lib')]\n        flags['libraries'] = ['GLESv2']\n    elif platform == 'rpi':\n\n        if not cross_sysroot:\n            flags['include_dirs'] = [\n                '/opt/vc/include',\n                '/opt/vc/include/interface/vcos/pthreads',\n                '/opt/vc/include/interface/vmcs_host/linux']\n            flags['library_dirs'] = ['/opt/vc/lib']\n            brcm_lib_files = (\n                '/opt/vc/lib/libbrcmEGL.so',\n                '/opt/vc/lib/libbrcmGLESv2.so')\n\n        else:\n            print(\"KIVY_CROSS_SYSROOT: \" + cross_sysroot)\n            flags['include_dirs'] = [\n                cross_sysroot + '/usr/include',\n                cross_sysroot + '/usr/include/interface/vcos/pthreads',\n                cross_sysroot + '/usr/include/interface/vmcs_host/linux']\n            flags['library_dirs'] = [cross_sysroot + '/usr/lib']\n            brcm_lib_files = (\n                cross_sysroot + '/usr/lib/libbrcmEGL.so',\n                cross_sysroot + '/usr/lib/libbrcmGLESv2.so')\n\n        if all((exists(lib) for lib in brcm_lib_files)):\n            print('Found brcmEGL and brcmGLES library files '\n                  'for rpi platform at ' + dirname(brcm_lib_files[0]))\n            gl_libs = ['brcmEGL', 'brcmGLESv2']\n        else:\n            print(\n                'Failed to find brcmEGL and brcmGLESv2 library files '\n                'for rpi platform, falling back to EGL and GLESv2.')\n            gl_libs = ['EGL', 'GLESv2']\n        flags['libraries'] = ['bcm_host'] + gl_libs\n    elif platform in ['mali', 'vc']:\n        flags['include_dirs'] = ['/usr/include/']\n        flags['library_dirs'] = ['/usr/lib/arm-linux-gnueabihf']\n        flags['libraries'] = ['GLESv2']\n        c_options['use_x11'] = True\n        c_options['use_egl'] = True\n    else:\n        flags['libraries'] = ['GL']\n    return flags, base_flags",
  "def determine_sdl2():\n    flags = {}\n    if not c_options['use_sdl2']:\n        return flags\n\n    # If darwin has already been configured with frameworks, don't\n    # configure sdl2 via libs.\n    # TODO: Move framework configuration here.\n    if sdl2_source == \"macos-frameworks\":\n        return sdl2_flags\n\n    default_sdl2_path = None\n\n    if KIVY_DEPS_ROOT:\n\n        default_sdl2_path = os.pathsep.join(\n            [\n                join(KIVY_DEPS_ROOT, \"dist\", \"lib\"),\n                join(KIVY_DEPS_ROOT, \"dist\", \"lib64\"),\n                join(KIVY_DEPS_ROOT, \"dist\", \"include\", \"SDL2\"),\n            ]\n        )\n\n    kivy_sdl2_path = environ.get('KIVY_SDL2_PATH', default_sdl2_path)\n\n    includes, _ = get_isolated_env_paths()\n\n    # no pkgconfig info, or we want to use a specific sdl2 path, so perform\n    # manual configuration\n    flags['libraries'] = ['SDL2', 'SDL2_ttf', 'SDL2_image', 'SDL2_mixer']\n\n    sdl2_paths = kivy_sdl2_path.split(os.pathsep) if kivy_sdl2_path else []\n\n    if not sdl2_paths:\n        # Try to find sdl2 in default locations if we don't have a custom path\n        sdl2_paths = []\n        for include in includes + [join(sys.prefix, 'include')]:\n            sdl_inc = join(include, 'SDL2')\n            if isdir(sdl_inc):\n                sdl2_paths.append(sdl_inc)\n        sdl2_paths.extend(['/usr/local/include/SDL2', '/usr/include/SDL2'])\n\n    flags['include_dirs'] = sdl2_paths\n    flags['extra_link_args'] = []\n    flags['extra_compile_args'] = []\n    flags['library_dirs'] = (\n        sdl2_paths if sdl2_paths else\n        ['/usr/local/lib/'])\n\n    if kivy_sdl2_path:\n        # If we have a custom path, we need to add the rpath to the linker\n        # so that the libraries can be found and loaded without having to\n        # set LD_LIBRARY_PATH every time.\n        flags[\"extra_link_args\"] = [\n            f\"-Wl,-rpath,{l_path}\"\n            for l_path in sdl2_paths\n            if l_path.endswith(\"lib\")\n        ]\n\n    if sdl2_flags:\n        flags = merge(flags, sdl2_flags)\n\n    # ensure headers for all the SDL2 and sub libraries are available\n    libs_to_check = ['SDL', 'SDL_mixer', 'SDL_ttf', 'SDL_image']\n    can_compile = True\n    for lib in libs_to_check:\n        found = False\n        for d in flags['include_dirs']:\n            fn = join(d, '{}.h'.format(lib))\n            if exists(fn):\n                found = True\n                print('SDL2: found {} header at {}'.format(lib, fn))\n                break\n\n        if not found:\n            print('SDL2: missing sub library {}'.format(lib))\n            can_compile = False\n\n    if not can_compile:\n        c_options['use_sdl2'] = False\n        return {}\n\n    return flags",
  "def get_dependencies(name, deps=None):\n    if deps is None:\n        deps = []\n    for dep in graphics_dependencies.get(name, []):\n        if dep not in deps:\n            deps.append(dep)\n            get_dependencies(dep, deps)\n    return deps",
  "def resolve_dependencies(fn, depends):\n    fn = basename(fn)\n    deps = []\n    get_dependencies(fn, deps)\n    get_dependencies(fn.replace('.pyx', '.pxd'), deps)\n\n    deps_final = []\n    paths_to_test = ['graphics', 'include']\n    for dep in deps:\n        found = False\n        for path in paths_to_test:\n            filename = expand(src_path, path, dep)\n            if exists(filename):\n                deps_final.append(filename)\n                found = True\n                break\n        if not found:\n            print('ERROR: Dependency for {} not resolved: {}'.format(\n                fn, dep\n            ))\n\n    return deps_final",
  "def get_extensions_from_sources(sources):\n    ext_modules = []\n    if environ.get('KIVY_FAKE_BUILDEXT'):\n        print('Fake build_ext asked, will generate only .h/.c')\n        return ext_modules\n    for pyx, flags in sources.items():\n        is_graphics = pyx.startswith('graphics')\n        pyx_path = expand(src_path, pyx)\n        depends = [expand(src_path, x) for x in flags.pop('depends', [])]\n        c_depends = [expand(src_path, x) for x in flags.pop('c_depends', [])]\n        if not can_use_cython:\n            # can't use cython, so use the .c files instead.\n            pyx_path = '%s.c' % pyx_path[:-4]\n        if is_graphics:\n            depends = resolve_dependencies(pyx_path, depends)\n        f_depends = [x for x in depends if x.rsplit('.', 1)[-1] in (\n            'c', 'cpp', 'm')]\n        module_name = '.'.join(['kivy'] + pyx[:-4].split('/'))\n        flags_clean = {'depends': depends}\n        for key, value in flags.items():\n            if len(value):\n                flags_clean[key] = value\n        ext_modules.append(CythonExtension(\n            module_name, [pyx_path] + f_depends + c_depends, **flags_clean))\n    return ext_modules",
  "def glob_paths(*patterns, excludes=('.pyc', )):\n    files = []\n    base = Path(join(src_path, 'kivy'))\n\n    for pat in patterns:\n        for f in base.glob(pat):\n            if f.suffix in excludes:\n                continue\n            files.append(str(f.relative_to(base)))\n    return files",
  "def get_compiler():\n        \"\"\"Get the compiler instance used by setuptools.\n        This is a bit hacky, but seems the only way to get the compiler instance\n        used by setuptools, without using private APIs or the deprecated\n        distutils module. (See: https://github.com/pypa/setuptools/issues/2806)\n        \"\"\"\n        fake_dist_build_ext = Distribution().get_command_obj(\"build_ext\")\n        fake_dist_build_ext.finalize_options()\n        # register an extension to ensure a compiler is created\n        fake_dist_build_ext.extensions = [Extension(\"ignored\", [\"ignored.c\"])]\n        # disable building fake extensions\n        fake_dist_build_ext.build_extensions = lambda: None\n        # run to populate self.compiler\n        fake_dist_build_ext.run()\n        return fake_dist_build_ext.compiler",
  "def finalize_options(self):\n        super().finalize_options()\n\n        # Build the extensions in parallel if the options has not been set\n        if hasattr(self, 'parallel') and self.parallel is None:\n            # Use a maximum of 4 cores. If cpu_count returns None, then parallel\n            # build will be disabled\n            self.parallel = min(4, os.cpu_count() or 0)\n            if self.parallel:\n                print('Building extensions in parallel using {} cores'.format(\n                    self.parallel))\n\n        global build_path\n        if (self.build_lib is not None and exists(self.build_lib) and\n                not self.inplace):\n            build_path = self.build_lib\n            print(\"Updated build directory to: {}\".format(build_path))",
  "def build_extensions(self):\n        # build files\n        config_h_fn = ('include', 'config.h')\n        config_pxi_fn = ('include', 'config.pxi')\n        config_py_fn = ('setupconfig.py', )\n\n        # generate headers\n        config_h = '// Autogenerated file for Kivy C configuration\\n'\n        config_h += '#define __PY3 1\\n'\n        config_pxi = '# Autogenerated file for Kivy Cython configuration\\n'\n        config_pxi += 'DEF PY3 = 1\\n'\n        config_py = '# Autogenerated file for Kivy configuration\\n'\n        config_py += 'PY3 = 1\\n'\n        config_py += 'CYTHON_MIN = {0}\\nCYTHON_MAX = {1}\\n'.format(\n            repr(MIN_CYTHON_STRING), repr(MAX_CYTHON_STRING))\n        config_py += 'CYTHON_BAD = {0}\\n'.format(repr(', '.join(map(\n            str, CYTHON_UNSUPPORTED))))\n\n        # generate content\n        print('Build configuration is:')\n        for opt, value in c_options.items():\n            # kivy_sdl_gl_alpha_size is already an integer\n            if opt != 'kivy_sdl_gl_alpha_size':\n                value = int(bool(value))\n            print(' * {0} = {1}'.format(opt, value))\n            opt = opt.upper()\n            config_h += '#define __{0} {1}\\n'.format(opt, value)\n            config_pxi += 'DEF {0} = {1}\\n'.format(opt, value)\n            config_py += '{0} = {1}\\n'.format(opt, value)\n        debug = bool(self.debug)\n        print(' * debug = {0}'.format(debug))\n\n        config_pxi += 'DEF DEBUG = {0}\\n'.format(debug)\n        config_py += 'DEBUG = {0}\\n'.format(debug)\n        config_pxi += 'DEF PLATFORM = \"{0}\"\\n'.format(platform)\n        config_py += 'PLATFORM = \"{0}\"\\n'.format(platform)\n        for fn, content in (\n                (config_h_fn, config_h), (config_pxi_fn, config_pxi),\n                (config_py_fn, config_py)):\n            build_fn = expand(build_path, *fn)\n            if self.update_if_changed(build_fn, content):\n                print('Updated {}'.format(build_fn))\n            src_fn = expand(src_path, *fn)\n            if src_fn != build_fn and self.update_if_changed(src_fn, content):\n                print('Updated {}'.format(src_fn))\n\n        c = self.compiler.compiler_type\n        print('Detected compiler is {}'.format(c))\n        if c != 'msvc':\n            for e in self.extensions:\n                e.extra_link_args += ['-lm']\n\n        super().build_extensions()",
  "def update_if_changed(self, fn, content):\n        need_update = True\n        if exists(fn):\n            with open(fn) as fd:\n                need_update = fd.read() != content\n        if need_update:\n            directory_name = dirname(fn)\n            if not exists(directory_name):\n                makedirs(directory_name)\n            with open(fn, 'w') as fd:\n                fd.write(content)\n        return need_update",
  "def __init__(self, *args, **kwargs):\n        Extension.__init__(self, *args, **kwargs)\n        self.cython_directives = {\n            'c_string_encoding': 'utf-8',\n            'profile': 'USE_PROFILE' in environ,\n            'embedsignature': use_embed_signature,\n            'language_level': 3,\n            'unraisable_tracebacks': True,\n        }",
  "class Atlas(EventDispatcher):\n    '''Manage texture atlas. See module documentation for more information.\n    '''\n\n    original_textures = ListProperty([])\n    '''List of original atlas textures (which contain the :attr:`textures`).\n\n    :attr:`original_textures` is a :class:`~kivy.properties.ListProperty` and\n    defaults to [].\n\n    .. versionadded:: 1.9.1\n    '''\n\n    textures = DictProperty({})\n    '''List of available textures within the atlas.\n\n    :attr:`textures` is a :class:`~kivy.properties.DictProperty` and defaults\n    to {}.\n    '''\n\n    def _get_filename(self):\n        return self._filename\n\n    filename = AliasProperty(_get_filename, None)\n    '''Filename of the current Atlas.\n\n    :attr:`filename` is an :class:`~kivy.properties.AliasProperty` and defaults\n    to None.\n    '''\n\n    def __init__(self, filename):\n        self._filename = filename\n        super(Atlas, self).__init__()\n        self._load()\n\n    def __getitem__(self, key):\n        return self.textures[key]\n\n    def _load(self):\n        # late import to prevent recursive import.\n        global CoreImage\n        if CoreImage is None:\n            from kivy.core.image import Image as CoreImage\n\n        # must be a name finished by .atlas ?\n        filename = self._filename\n        assert filename.endswith('.atlas')\n        filename = filename.replace('/', os.sep)\n\n        Logger.debug('Atlas: Load <%s>' % filename)\n        with open(filename, 'r') as fd:\n            meta = json.load(fd)\n\n        Logger.debug('Atlas: Need to load %d images' % len(meta))\n        d = dirname(filename)\n        textures = {}\n        for subfilename, ids in meta.items():\n            subfilename = join(d, subfilename)\n            Logger.debug('Atlas: Load <%s>' % subfilename)\n\n            # load the image\n            ci = CoreImage(subfilename)\n            atlas_texture = ci.texture\n            self.original_textures.append(atlas_texture)\n\n            # for all the uid, load the image, get the region, and put\n            # it in our dict.\n            for meta_id, meta_coords in ids.items():\n                x, y, w, h = meta_coords\n                textures[meta_id] = atlas_texture.get_region(*meta_coords)\n\n        self.textures = textures\n\n    @staticmethod\n    def create(outname, filenames, size, padding=2, use_path=False):\n        '''This method can be used to create an atlas manually from a set of\n        images.\n\n        :Parameters:\n            `outname`: str\n                Basename to use for ``.atlas`` creation and ``-<idx>.png``\n                associated images.\n            `filenames`: list\n                List of filenames to put in the atlas.\n            `size`: int or list (width, height)\n                Size of the atlas image. If the size is not large enough to\n                fit all of the source images, more atlas images will created\n                as required.\n            `padding`: int, defaults to 2\n                Padding to put around each image.\n\n                Be careful. If you're using a padding < 2, you might have\n                issues with the borders of the images. Because of the OpenGL\n                linearization, it might use the pixels of the adjacent image.\n\n                If you're using a padding >= 2, we'll automatically generate a\n                \"border\" of 1px around your image. If you look at\n                the result, don't be scared if the image inside is not\n                exactly the same as yours :).\n\n            `use_path`: bool, defaults to False\n                If True, the relative path of the source png\n                file names will be included in the atlas ids rather\n                that just in the file names. Leading dots and slashes will be\n                excluded and all other slashes in the path will be replaced\n                with underscores. For example, if `use_path` is False\n                (the default) and the file name is\n                ``../data/tiles/green_grass.png``, the id will be\n                ``green_grass``. If `use_path` is True, it will be\n                ``data_tiles_green_grass``.\n\n            .. versionchanged:: 1.8.0\n                Parameter use_path added\n        '''\n        # Thanks to\n        # omnisaurusgames.com/2011/06/texture-atlas-generation-using-python/\n        # for its initial implementation.\n        try:\n            from PIL import Image\n        except ImportError:\n            Logger.critical('Atlas: Imaging/PIL are missing')\n            raise\n\n        if isinstance(size, (tuple, list)):\n            size_w, size_h = list(map(int, size))\n        else:\n            size_w = size_h = int(size)\n\n        # open all of the images\n        ims = list()\n        for f in filenames:\n            fp = open(f, 'rb')\n            im = Image.open(fp)\n            im.load()\n            fp.close()\n            ims.append((f, im))\n\n        # sort by image area\n        ims = sorted(ims, key=lambda im: im[1].size[0] * im[1].size[1],\n                     reverse=True)\n\n        # free boxes are empty space in our output image set\n        # the freebox tuple format is: outidx, x, y, w, h\n        freeboxes = [(0, 0, 0, size_w, size_h)]\n        numoutimages = 1\n\n        # full boxes are areas where we have placed images in the atlas\n        # the full box tuple format is: image, outidx, x, y, w, h, filename\n        fullboxes = []\n\n        # do the actual atlasing by sticking the largest images we can\n        # have into the smallest valid free boxes\n        for imageinfo in ims:\n            im = imageinfo[1]\n            imw, imh = im.size\n            imw += padding\n            imh += padding\n            if imw > size_w or imh > size_h:\n                Logger.error(\n                    'Atlas: image %s (%d by %d) is larger than the atlas size!'\n                    % (imageinfo[0], imw, imh))\n                return\n\n            inserted = False\n            while not inserted:\n                for idx, fb in enumerate(freeboxes):\n                    # find the smallest free box that will contain this image\n                    if fb[3] >= imw and fb[4] >= imh:\n                        # we found a valid spot! Remove the current\n                        # freebox, and split the leftover space into (up to)\n                        # two new freeboxes\n                        del freeboxes[idx]\n                        if fb[3] > imw:\n                            freeboxes.append((\n                                fb[0], fb[1] + imw, fb[2],\n                                fb[3] - imw, imh))\n\n                        if fb[4] > imh:\n                            freeboxes.append((\n                                fb[0], fb[1], fb[2] + imh,\n                                fb[3], fb[4] - imh))\n\n                        # keep this sorted!\n                        freeboxes = sorted(freeboxes,\n                                           key=lambda fb: fb[3] * fb[4])\n                        fullboxes.append((im,\n                                          fb[0], fb[1] + padding,\n                                          fb[2] + padding, imw - padding,\n                                          imh - padding, imageinfo[0]))\n                        inserted = True\n                        break\n\n                if not inserted:\n                    # oh crap - there isn't room in any of our free\n                    # boxes, so we have to add a new output image\n                    freeboxes.append((numoutimages, 0, 0, size_w, size_h))\n                    numoutimages += 1\n\n        # now that we've figured out where everything goes, make the output\n        # images and blit the source images to the appropriate locations\n        Logger.info('Atlas: create an {0}x{1} rgba image'.format(size_w,\n                                                                 size_h))\n        outimages = [Image.new('RGBA', (size_w, size_h))\n                     for i in range(0, int(numoutimages))]\n        for fb in fullboxes:\n            x, y = fb[2], fb[3]\n            out = outimages[fb[1]]\n            out.paste(fb[0], (fb[2], fb[3]))\n            w, h = fb[0].size\n            if padding > 1:\n                out.paste(fb[0].crop((0, 0, w, 1)), (x, y - 1))\n                out.paste(fb[0].crop((0, h - 1, w, h)), (x, y + h))\n                out.paste(fb[0].crop((0, 0, 1, h)), (x - 1, y))\n                out.paste(fb[0].crop((w - 1, 0, w, h)), (x + w, y))\n\n        # save the output images\n        for idx, outimage in enumerate(outimages):\n            outimage.save('%s-%d.png' % (outname, idx))\n\n        # write out an json file that says where everything ended up\n        meta = {}\n        for fb in fullboxes:\n            fn = '%s-%d.png' % (basename(outname), fb[1])\n            if fn not in meta:\n                d = meta[fn] = {}\n            else:\n                d = meta[fn]\n\n            # fb[6] contain the filename\n            if use_path:\n                # use the path with separators replaced by _\n                # example '../data/tiles/green_grass.png' becomes\n                # 'data_tiles_green_grass'\n                uid = splitext(fb[6])[0]\n                # remove leading dots and slashes\n                uid = uid.lstrip('./\\\\')\n                # replace remaining slashes with _\n                uid = uid.replace('/', '_').replace('\\\\', '_')\n            else:\n                # for example, '../data/tiles/green_grass.png'\n                # just get only 'green_grass' as the uniq id.\n                uid = splitext(basename(fb[6]))[0]\n\n            x, y, w, h = fb[2:6]\n            d[uid] = x, size_h - y - h, w, h\n\n        outfn = '%s.atlas' % outname\n        with open(outfn, 'w') as fd:\n            json.dump(meta, fd)\n\n        return outfn, meta",
  "def _get_filename(self):\n        return self._filename",
  "def __init__(self, filename):\n        self._filename = filename\n        super(Atlas, self).__init__()\n        self._load()",
  "def __getitem__(self, key):\n        return self.textures[key]",
  "def _load(self):\n        # late import to prevent recursive import.\n        global CoreImage\n        if CoreImage is None:\n            from kivy.core.image import Image as CoreImage\n\n        # must be a name finished by .atlas ?\n        filename = self._filename\n        assert filename.endswith('.atlas')\n        filename = filename.replace('/', os.sep)\n\n        Logger.debug('Atlas: Load <%s>' % filename)\n        with open(filename, 'r') as fd:\n            meta = json.load(fd)\n\n        Logger.debug('Atlas: Need to load %d images' % len(meta))\n        d = dirname(filename)\n        textures = {}\n        for subfilename, ids in meta.items():\n            subfilename = join(d, subfilename)\n            Logger.debug('Atlas: Load <%s>' % subfilename)\n\n            # load the image\n            ci = CoreImage(subfilename)\n            atlas_texture = ci.texture\n            self.original_textures.append(atlas_texture)\n\n            # for all the uid, load the image, get the region, and put\n            # it in our dict.\n            for meta_id, meta_coords in ids.items():\n                x, y, w, h = meta_coords\n                textures[meta_id] = atlas_texture.get_region(*meta_coords)\n\n        self.textures = textures",
  "def create(outname, filenames, size, padding=2, use_path=False):\n        '''This method can be used to create an atlas manually from a set of\n        images.\n\n        :Parameters:\n            `outname`: str\n                Basename to use for ``.atlas`` creation and ``-<idx>.png``\n                associated images.\n            `filenames`: list\n                List of filenames to put in the atlas.\n            `size`: int or list (width, height)\n                Size of the atlas image. If the size is not large enough to\n                fit all of the source images, more atlas images will created\n                as required.\n            `padding`: int, defaults to 2\n                Padding to put around each image.\n\n                Be careful. If you're using a padding < 2, you might have\n                issues with the borders of the images. Because of the OpenGL\n                linearization, it might use the pixels of the adjacent image.\n\n                If you're using a padding >= 2, we'll automatically generate a\n                \"border\" of 1px around your image. If you look at\n                the result, don't be scared if the image inside is not\n                exactly the same as yours :).\n\n            `use_path`: bool, defaults to False\n                If True, the relative path of the source png\n                file names will be included in the atlas ids rather\n                that just in the file names. Leading dots and slashes will be\n                excluded and all other slashes in the path will be replaced\n                with underscores. For example, if `use_path` is False\n                (the default) and the file name is\n                ``../data/tiles/green_grass.png``, the id will be\n                ``green_grass``. If `use_path` is True, it will be\n                ``data_tiles_green_grass``.\n\n            .. versionchanged:: 1.8.0\n                Parameter use_path added\n        '''\n        # Thanks to\n        # omnisaurusgames.com/2011/06/texture-atlas-generation-using-python/\n        # for its initial implementation.\n        try:\n            from PIL import Image\n        except ImportError:\n            Logger.critical('Atlas: Imaging/PIL are missing')\n            raise\n\n        if isinstance(size, (tuple, list)):\n            size_w, size_h = list(map(int, size))\n        else:\n            size_w = size_h = int(size)\n\n        # open all of the images\n        ims = list()\n        for f in filenames:\n            fp = open(f, 'rb')\n            im = Image.open(fp)\n            im.load()\n            fp.close()\n            ims.append((f, im))\n\n        # sort by image area\n        ims = sorted(ims, key=lambda im: im[1].size[0] * im[1].size[1],\n                     reverse=True)\n\n        # free boxes are empty space in our output image set\n        # the freebox tuple format is: outidx, x, y, w, h\n        freeboxes = [(0, 0, 0, size_w, size_h)]\n        numoutimages = 1\n\n        # full boxes are areas where we have placed images in the atlas\n        # the full box tuple format is: image, outidx, x, y, w, h, filename\n        fullboxes = []\n\n        # do the actual atlasing by sticking the largest images we can\n        # have into the smallest valid free boxes\n        for imageinfo in ims:\n            im = imageinfo[1]\n            imw, imh = im.size\n            imw += padding\n            imh += padding\n            if imw > size_w or imh > size_h:\n                Logger.error(\n                    'Atlas: image %s (%d by %d) is larger than the atlas size!'\n                    % (imageinfo[0], imw, imh))\n                return\n\n            inserted = False\n            while not inserted:\n                for idx, fb in enumerate(freeboxes):\n                    # find the smallest free box that will contain this image\n                    if fb[3] >= imw and fb[4] >= imh:\n                        # we found a valid spot! Remove the current\n                        # freebox, and split the leftover space into (up to)\n                        # two new freeboxes\n                        del freeboxes[idx]\n                        if fb[3] > imw:\n                            freeboxes.append((\n                                fb[0], fb[1] + imw, fb[2],\n                                fb[3] - imw, imh))\n\n                        if fb[4] > imh:\n                            freeboxes.append((\n                                fb[0], fb[1], fb[2] + imh,\n                                fb[3], fb[4] - imh))\n\n                        # keep this sorted!\n                        freeboxes = sorted(freeboxes,\n                                           key=lambda fb: fb[3] * fb[4])\n                        fullboxes.append((im,\n                                          fb[0], fb[1] + padding,\n                                          fb[2] + padding, imw - padding,\n                                          imh - padding, imageinfo[0]))\n                        inserted = True\n                        break\n\n                if not inserted:\n                    # oh crap - there isn't room in any of our free\n                    # boxes, so we have to add a new output image\n                    freeboxes.append((numoutimages, 0, 0, size_w, size_h))\n                    numoutimages += 1\n\n        # now that we've figured out where everything goes, make the output\n        # images and blit the source images to the appropriate locations\n        Logger.info('Atlas: create an {0}x{1} rgba image'.format(size_w,\n                                                                 size_h))\n        outimages = [Image.new('RGBA', (size_w, size_h))\n                     for i in range(0, int(numoutimages))]\n        for fb in fullboxes:\n            x, y = fb[2], fb[3]\n            out = outimages[fb[1]]\n            out.paste(fb[0], (fb[2], fb[3]))\n            w, h = fb[0].size\n            if padding > 1:\n                out.paste(fb[0].crop((0, 0, w, 1)), (x, y - 1))\n                out.paste(fb[0].crop((0, h - 1, w, h)), (x, y + h))\n                out.paste(fb[0].crop((0, 0, 1, h)), (x - 1, y))\n                out.paste(fb[0].crop((w - 1, 0, w, h)), (x + w, y))\n\n        # save the output images\n        for idx, outimage in enumerate(outimages):\n            outimage.save('%s-%d.png' % (outname, idx))\n\n        # write out an json file that says where everything ended up\n        meta = {}\n        for fb in fullboxes:\n            fn = '%s-%d.png' % (basename(outname), fb[1])\n            if fn not in meta:\n                d = meta[fn] = {}\n            else:\n                d = meta[fn]\n\n            # fb[6] contain the filename\n            if use_path:\n                # use the path with separators replaced by _\n                # example '../data/tiles/green_grass.png' becomes\n                # 'data_tiles_green_grass'\n                uid = splitext(fb[6])[0]\n                # remove leading dots and slashes\n                uid = uid.lstrip('./\\\\')\n                # replace remaining slashes with _\n                uid = uid.replace('/', '_').replace('\\\\', '_')\n            else:\n                # for example, '../data/tiles/green_grass.png'\n                # just get only 'green_grass' as the uniq id.\n                uid = splitext(basename(fb[6]))[0]\n\n            x, y, w, h = fb[2:6]\n            d[uid] = x, size_h - y - h, w, h\n\n        outfn = '%s.atlas' % outname\n        with open(outfn, 'w') as fd:\n            json.dump(meta, fd)\n\n        return outfn, meta",
  "class ProxyContext(object):\n\n    __slots__ = ['_obj']\n\n    def __init__(self, obj):\n        object.__init__(self)\n        object.__setattr__(self, '_obj', obj)\n\n    def __getattribute__(self, name):\n        return getattr(object.__getattribute__(self, '_obj'), name)\n\n    def __delattr__(self, name):\n        delattr(object.__getattribute__(self, '_obj'), name)\n\n    def __setattr__(self, name, value):\n        setattr(object.__getattribute__(self, '_obj'), name, value)\n\n    def __bool__(self):\n        return bool(object.__getattribute__(self, '_obj'))\n\n    def __str__(self):\n        return str(object.__getattribute__(self, '_obj'))\n\n    def __repr__(self):\n        return repr(object.__getattribute__(self, '_obj'))",
  "class Context(dict):\n\n    def __init__(self, init=False):\n        dict.__init__(self)\n        self.sandbox = None\n        if not init:\n            return\n\n        for name in _contexts:\n            context = _contexts[name]\n            instance = context['cls'](*context['args'], **context['kwargs'])\n            self[name] = instance\n\n    def push(self):\n        _context_stack.append(self)\n        for name, instance in self.items():\n            object.__setattr__(_contexts[name]['proxy'], '_obj', instance)\n\n    def pop(self):\n        # After popping context from stack. Update proxy's _obj with\n        # instances in current context\n        _context_stack.pop(-1)\n        for name, instance in get_current_context().items():\n            object.__setattr__(_contexts[name]['proxy'], '_obj', instance)",
  "def register_context(name, cls, *args, **kwargs):\n    '''Register a new context.\n    '''\n    instance = cls(*args, **kwargs)\n    proxy = ProxyContext(instance)\n    _contexts[name] = {\n        'cls': cls,\n        'args': args,\n        'kwargs': kwargs,\n        'proxy': proxy}\n    _default_context[name] = instance\n    return proxy",
  "def get_current_context():\n    '''Return the current context.\n    '''\n    if not _context_stack:\n        return _default_context\n    return _context_stack[-1]",
  "def __init__(self, obj):\n        object.__init__(self)\n        object.__setattr__(self, '_obj', obj)",
  "def __getattribute__(self, name):\n        return getattr(object.__getattribute__(self, '_obj'), name)",
  "def __delattr__(self, name):\n        delattr(object.__getattribute__(self, '_obj'), name)",
  "def __setattr__(self, name, value):\n        setattr(object.__getattribute__(self, '_obj'), name, value)",
  "def __bool__(self):\n        return bool(object.__getattribute__(self, '_obj'))",
  "def __str__(self):\n        return str(object.__getattribute__(self, '_obj'))",
  "def __repr__(self):\n        return repr(object.__getattribute__(self, '_obj'))",
  "def __init__(self, init=False):\n        dict.__init__(self)\n        self.sandbox = None\n        if not init:\n            return\n\n        for name in _contexts:\n            context = _contexts[name]\n            instance = context['cls'](*context['args'], **context['kwargs'])\n            self[name] = instance",
  "def push(self):\n        _context_stack.append(self)\n        for name, instance in self.items():\n            object.__setattr__(_contexts[name]['proxy'], '_obj', instance)",
  "def pop(self):\n        # After popping context from stack. Update proxy's _obj with\n        # instances in current context\n        _context_stack.pop(-1)\n        for name, instance in get_current_context().items():\n            object.__setattr__(_contexts[name]['proxy'], '_obj', instance)",
  "class FileHandler(logging.Handler):\n    history = []\n    filename = 'log.txt'\n    fd = None\n    log_dir = ''\n    encoding = 'utf-8'\n\n    def purge_logs(self):\n        \"\"\"Purge logs which exceed the maximum amount of log files,\n        starting with the oldest creation timestamp (or edit-timestamp on Linux)\n        \"\"\"\n\n        if not self.log_dir:\n            return\n\n        from kivy.config import Config\n        maxfiles = Config.getint(\"kivy\", \"log_maxfiles\")\n\n        # Get path to log directory\n        log_dir = pathlib.Path(self.log_dir)\n\n        if maxfiles < 0:  # No log file limit set\n            return\n\n        Logger.info(\"Logger: Purge log fired. Processing...\")\n\n        # Get all files from log directory and corresponding creation timestamps\n        files = [(item, item.stat().st_ctime)\n                 for item in log_dir.iterdir() if item.is_file()]\n        # Sort files by ascending timestamp\n        files.sort(key=lambda x: x[1])\n\n        for file, _ in files[:(-maxfiles or len(files))]:\n            # More log files than allowed maximum,\n            # delete files, starting with oldest creation timestamp\n            # (or edit-timestamp on Linux)\n            try:\n                file.unlink()\n            except (PermissionError, FileNotFoundError) as e:\n                Logger.info(f\"Logger: Skipped file {file}, {repr(e)}\")\n\n        Logger.info(\"Logger: Purge finished!\")\n\n    def _configure(self, *largs, **kwargs):\n        from time import strftime\n        from kivy.config import Config\n        log_dir = Config.get('kivy', 'log_dir')\n        log_name = Config.get('kivy', 'log_name')\n\n        _dir = kivy.kivy_home_dir\n        if log_dir and os.path.isabs(log_dir):\n            _dir = log_dir\n        else:\n            _dir = os.path.join(_dir, log_dir)\n        if not os.path.exists(_dir):\n            os.makedirs(_dir)\n        self.log_dir = _dir\n\n        pattern = log_name.replace('%_', '@@NUMBER@@')\n        pattern = os.path.join(_dir, strftime(pattern))\n        n = 0\n        while True:\n            filename = pattern.replace('@@NUMBER@@', str(n))\n            if not os.path.exists(filename):\n                break\n            n += 1\n            if n > 10000:  # prevent maybe flooding ?\n                raise Exception('Too many logfile, remove them')\n\n        if FileHandler.filename == filename and FileHandler.fd is not None:\n            return\n\n        FileHandler.filename = filename\n        if FileHandler.fd not in (None, False):\n            FileHandler.fd.close()\n        FileHandler.fd = open(filename, 'w', encoding=FileHandler.encoding)\n        Logger.info('Logger: Record log in %s' % filename)\n\n    def _write_message(self, record):\n        if FileHandler.fd in (None, False):\n            return\n\n        msg = self.format(record)\n        stream = FileHandler.fd\n        fs = \"%s\\n\"\n        stream.write('[%-7s] ' % record.levelname)\n        stream.write(fs % msg)\n        stream.flush()\n\n    def emit(self, message):\n        # during the startup, store the message in the history\n        if Logger.logfile_activated is None:\n            FileHandler.history += [message]\n            return\n\n        # startup done, if the logfile is not activated, avoid history.\n        if Logger.logfile_activated is False:\n            FileHandler.history = []\n            return\n\n        if FileHandler.fd is None:\n            try:\n                self._configure()\n                from kivy.config import Config\n                Config.add_callback(self._configure, 'kivy', 'log_dir')\n                Config.add_callback(self._configure, 'kivy', 'log_name')\n            except Exception:\n                # deactivate filehandler...\n                if FileHandler.fd not in (None, False):\n                    FileHandler.fd.close()\n                FileHandler.fd = False\n                Logger.exception('Error while activating FileHandler logger')\n                return\n            while FileHandler.history:\n                _message = FileHandler.history.pop()\n                self._write_message(_message)\n\n        self._write_message(message)",
  "class LoggerHistory(logging.Handler):\n\n    history = []\n\n    def emit(self, message):\n        LoggerHistory.history = [message] + LoggerHistory.history[:100]\n\n    @classmethod\n    def clear_history(cls):\n        del cls.history[:]\n\n    def flush(self):\n        super(LoggerHistory, self).flush()\n        self.clear_history()",
  "class ConsoleHandler(logging.StreamHandler):\n    \"\"\"\n        Emits records to a stream (by default, stderr).\n\n        However, if the msg starts with \"stderr:\" it is not formatted, but\n        written straight to the stream.\n\n        .. versionadded:: 2.2.0\n    \"\"\"\n\n    def filter(self, record):\n        try:\n            msg = record.msg\n            k = msg.split(':', 1)\n            if k[0] == 'stderr' and len(k) == 2:\n                # This message was scraped from stderr.\n                # Emit it without formatting.\n                self.stream.write(k[1] + '\\n')\n                # Don't pass it to the formatted emitter.\n                return False\n        except Exception:\n            pass\n        return True",
  "class ProcessingStream(object):\n    \"\"\"\n        Stream-like object that takes each completed line written to it,\n        adds a given prefix, and applies the given function to it.\n\n        .. versionadded:: 2.2.0\n    \"\"\"\n\n    def __init__(self, channel, func):\n        self.buffer = \"\"\n        self.func = func\n        self.channel = channel\n        self.errors = \"\"\n\n    def write(self, s):\n        s = self.buffer + s\n        self.flush()\n        f = self.func\n        channel = self.channel\n        lines = s.split('\\n')\n        for line in lines[:-1]:\n            f('%s: %s' % (channel, line))\n        self.buffer = lines[-1]\n\n    def flush(self):\n        return\n\n    def isatty(self):\n        return False",
  "def logger_config_update(section, key, value):\n    if KIVY_LOG_MODE != \"PYTHON\":\n        if LOG_LEVELS.get(value) is None:\n            raise AttributeError('Loglevel {0!r} doesn\\'t exists'.format(value))\n        Logger.setLevel(level=LOG_LEVELS.get(value))",
  "class ColonSplittingLogRecord(logging.LogRecord):\n    \"\"\"Clones an existing logRecord, but reformats the message field\n    if it contains a colon.\n\n    .. versionadded:: 2.2.0\n    \"\"\"\n\n    def __init__(self, logrecord):\n        try:\n            parts = logrecord.msg.split(\":\", 1)\n            if len(parts) == 2:\n                new_msg = \"[%-12s]%s\" % (parts[0], parts[1])\n            else:\n                new_msg = parts[0]\n        except Exception:\n            new_msg = logrecord.msg\n\n        super().__init__(\n            name=logrecord.name,\n            level=logrecord.levelno,\n            pathname=logrecord.pathname,\n            lineno=logrecord.lineno,\n            msg=new_msg,\n            args=logrecord.args,\n            exc_info=logrecord.exc_info,\n            func=logrecord.funcName,\n            sinfo=logrecord.stack_info,\n        )",
  "class ColoredLogRecord(logging.LogRecord):\n    \"\"\"Clones an existing logRecord, but reformats the levelname to add\n    color, and the message to add bolding (where indicated by $BOLD\n    and $RESET in the message).\n\n    .. versionadded:: 2.2.0\"\"\"\n\n    BLACK = 0\n    RED = 1\n    GREEN = 2\n    YELLOW = 3\n    BLUE = 4\n    MAGENTA = 5\n    CYAN = 6\n    WHITE = 7\n    RESET_SEQ = \"\\033[0m\"\n    COLOR_SEQ = \"\\033[1;%dm\"\n    BOLD_SEQ = \"\\033[1m\"\n\n    LEVEL_COLORS = {\n        \"TRACE\": MAGENTA,\n        \"WARNING\": YELLOW,\n        \"INFO\": GREEN,\n        \"DEBUG\": CYAN,\n        \"CRITICAL\": RED,\n        \"ERROR\": RED,\n    }\n\n    @classmethod\n    def _format_message(cls, message):\n        return str(message).replace(\n            \"$RESET\", cls.RESET_SEQ).replace(\"$BOLD\", cls.BOLD_SEQ)\n\n    @classmethod\n    def _format_levelname(cls, levelname):\n        if levelname in cls.LEVEL_COLORS:\n            return (\n                cls.COLOR_SEQ % (30 + cls.LEVEL_COLORS[levelname])\n                + levelname\n                + cls.RESET_SEQ\n            )\n        return levelname\n\n    def __init__(self, logrecord):\n        super().__init__(\n            name=logrecord.name,\n            level=logrecord.levelno,\n            pathname=logrecord.pathname,\n            lineno=logrecord.lineno,\n            msg=logrecord.msg,\n            args=logrecord.args,\n            exc_info=logrecord.exc_info,\n            func=logrecord.funcName,\n            sinfo=logrecord.stack_info,\n        )\n        self.levelname = self._format_levelname(self.levelname)\n        self.msg = self._format_message(self.msg)",
  "class UncoloredLogRecord(logging.LogRecord):\n    \"\"\"Clones an existing logRecord, but reformats the message\n    to remove $BOLD/$RESET markup.\n\n    .. versionadded:: 2.2.0\"\"\"\n\n    @classmethod\n    def _format_message(cls, message):\n        return str(message).replace(\"$RESET\", \"\").replace(\"$BOLD\", \"\")\n\n    def __init__(self, logrecord):\n        super().__init__(\n            name=logrecord.name,\n            level=logrecord.levelno,\n            pathname=logrecord.pathname,\n            lineno=logrecord.lineno,\n            msg=logrecord.msg,\n            args=logrecord.args,\n            exc_info=logrecord.exc_info,\n            func=logrecord.funcName,\n            sinfo=logrecord.stack_info,\n        )\n        self.msg = self._format_message(self.msg)",
  "class KivyFormatter(logging.Formatter):\n    \"\"\"Split out first field in message marked with a colon,\n    and either apply terminal color codes to the record, or strip\n    out color markup if colored logging is not available.\n\n    .. versionadded:: 2.2.0\"\"\"\n\n    def __init__(self, *args, use_color=True, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._coloring_cls = (\n            ColoredLogRecord if use_color else UncoloredLogRecord)\n\n    def format(self, record):\n        return super().format(\n            self._coloring_cls(ColonSplittingLogRecord(record)))",
  "def is_color_terminal():\n    \"\"\" Detect whether the environment supports color codes in output.\n\n    .. versionadded:: 2.2.0\n    \"\"\"\n\n    return (\n            (\n                    os.environ.get(\"WT_SESSION\") or\n                    os.environ.get(\"COLORTERM\") == 'truecolor' or\n                    os.environ.get('PYCHARM_HOSTED') == '1' or\n                    os.environ.get('TERM') in (\n                        'rxvt',\n                        'rxvt-256color',\n                        'rxvt-unicode',\n                        'rxvt-unicode-256color',\n                        'xterm',\n                        'xterm-256color',\n                    )\n            )\n            and platform not in ('android', 'ios')\n    )",
  "def add_kivy_handlers(logger):\n    \"\"\" Add Kivy-specific handlers to a logger.\n\n    .. versionadded:: 2.2.0\n    \"\"\"\n    # add default kivy logger\n    logger.addHandler(LoggerHistory())\n    if file_log_handler:\n        logger.addHandler(file_log_handler)\n\n    # Use the custom handler instead of streaming one.\n    if 'KIVY_NO_CONSOLELOG' not in os.environ:\n        use_color = is_color_terminal()\n        if not use_color:\n            # No additional control characters will be inserted inside the\n            # levelname field, 7 chars will fit \"WARNING\"\n            fmt = \"[%(levelname)-7s] %(message)s\"\n        else:\n            # levelname field width need to take into account the length of\n            # the color control codes (7+4 chars for bold+color, and reset)\n            fmt = \"[%(levelname)-18s] %(message)s\"\n        formatter = KivyFormatter(fmt, use_color=use_color)\n        console = ConsoleHandler()\n        console.setFormatter(formatter)\n        logger.addHandler(console)",
  "def purge_logs(self):\n        \"\"\"Purge logs which exceed the maximum amount of log files,\n        starting with the oldest creation timestamp (or edit-timestamp on Linux)\n        \"\"\"\n\n        if not self.log_dir:\n            return\n\n        from kivy.config import Config\n        maxfiles = Config.getint(\"kivy\", \"log_maxfiles\")\n\n        # Get path to log directory\n        log_dir = pathlib.Path(self.log_dir)\n\n        if maxfiles < 0:  # No log file limit set\n            return\n\n        Logger.info(\"Logger: Purge log fired. Processing...\")\n\n        # Get all files from log directory and corresponding creation timestamps\n        files = [(item, item.stat().st_ctime)\n                 for item in log_dir.iterdir() if item.is_file()]\n        # Sort files by ascending timestamp\n        files.sort(key=lambda x: x[1])\n\n        for file, _ in files[:(-maxfiles or len(files))]:\n            # More log files than allowed maximum,\n            # delete files, starting with oldest creation timestamp\n            # (or edit-timestamp on Linux)\n            try:\n                file.unlink()\n            except (PermissionError, FileNotFoundError) as e:\n                Logger.info(f\"Logger: Skipped file {file}, {repr(e)}\")\n\n        Logger.info(\"Logger: Purge finished!\")",
  "def _configure(self, *largs, **kwargs):\n        from time import strftime\n        from kivy.config import Config\n        log_dir = Config.get('kivy', 'log_dir')\n        log_name = Config.get('kivy', 'log_name')\n\n        _dir = kivy.kivy_home_dir\n        if log_dir and os.path.isabs(log_dir):\n            _dir = log_dir\n        else:\n            _dir = os.path.join(_dir, log_dir)\n        if not os.path.exists(_dir):\n            os.makedirs(_dir)\n        self.log_dir = _dir\n\n        pattern = log_name.replace('%_', '@@NUMBER@@')\n        pattern = os.path.join(_dir, strftime(pattern))\n        n = 0\n        while True:\n            filename = pattern.replace('@@NUMBER@@', str(n))\n            if not os.path.exists(filename):\n                break\n            n += 1\n            if n > 10000:  # prevent maybe flooding ?\n                raise Exception('Too many logfile, remove them')\n\n        if FileHandler.filename == filename and FileHandler.fd is not None:\n            return\n\n        FileHandler.filename = filename\n        if FileHandler.fd not in (None, False):\n            FileHandler.fd.close()\n        FileHandler.fd = open(filename, 'w', encoding=FileHandler.encoding)\n        Logger.info('Logger: Record log in %s' % filename)",
  "def _write_message(self, record):\n        if FileHandler.fd in (None, False):\n            return\n\n        msg = self.format(record)\n        stream = FileHandler.fd\n        fs = \"%s\\n\"\n        stream.write('[%-7s] ' % record.levelname)\n        stream.write(fs % msg)\n        stream.flush()",
  "def emit(self, message):\n        # during the startup, store the message in the history\n        if Logger.logfile_activated is None:\n            FileHandler.history += [message]\n            return\n\n        # startup done, if the logfile is not activated, avoid history.\n        if Logger.logfile_activated is False:\n            FileHandler.history = []\n            return\n\n        if FileHandler.fd is None:\n            try:\n                self._configure()\n                from kivy.config import Config\n                Config.add_callback(self._configure, 'kivy', 'log_dir')\n                Config.add_callback(self._configure, 'kivy', 'log_name')\n            except Exception:\n                # deactivate filehandler...\n                if FileHandler.fd not in (None, False):\n                    FileHandler.fd.close()\n                FileHandler.fd = False\n                Logger.exception('Error while activating FileHandler logger')\n                return\n            while FileHandler.history:\n                _message = FileHandler.history.pop()\n                self._write_message(_message)\n\n        self._write_message(message)",
  "def emit(self, message):\n        LoggerHistory.history = [message] + LoggerHistory.history[:100]",
  "def clear_history(cls):\n        del cls.history[:]",
  "def flush(self):\n        super(LoggerHistory, self).flush()\n        self.clear_history()",
  "def filter(self, record):\n        try:\n            msg = record.msg\n            k = msg.split(':', 1)\n            if k[0] == 'stderr' and len(k) == 2:\n                # This message was scraped from stderr.\n                # Emit it without formatting.\n                self.stream.write(k[1] + '\\n')\n                # Don't pass it to the formatted emitter.\n                return False\n        except Exception:\n            pass\n        return True",
  "def __init__(self, channel, func):\n        self.buffer = \"\"\n        self.func = func\n        self.channel = channel\n        self.errors = \"\"",
  "def write(self, s):\n        s = self.buffer + s\n        self.flush()\n        f = self.func\n        channel = self.channel\n        lines = s.split('\\n')\n        for line in lines[:-1]:\n            f('%s: %s' % (channel, line))\n        self.buffer = lines[-1]",
  "def flush(self):\n        return",
  "def isatty(self):\n        return False",
  "def __init__(self, logrecord):\n        try:\n            parts = logrecord.msg.split(\":\", 1)\n            if len(parts) == 2:\n                new_msg = \"[%-12s]%s\" % (parts[0], parts[1])\n            else:\n                new_msg = parts[0]\n        except Exception:\n            new_msg = logrecord.msg\n\n        super().__init__(\n            name=logrecord.name,\n            level=logrecord.levelno,\n            pathname=logrecord.pathname,\n            lineno=logrecord.lineno,\n            msg=new_msg,\n            args=logrecord.args,\n            exc_info=logrecord.exc_info,\n            func=logrecord.funcName,\n            sinfo=logrecord.stack_info,\n        )",
  "def _format_message(cls, message):\n        return str(message).replace(\n            \"$RESET\", cls.RESET_SEQ).replace(\"$BOLD\", cls.BOLD_SEQ)",
  "def _format_levelname(cls, levelname):\n        if levelname in cls.LEVEL_COLORS:\n            return (\n                cls.COLOR_SEQ % (30 + cls.LEVEL_COLORS[levelname])\n                + levelname\n                + cls.RESET_SEQ\n            )\n        return levelname",
  "def __init__(self, logrecord):\n        super().__init__(\n            name=logrecord.name,\n            level=logrecord.levelno,\n            pathname=logrecord.pathname,\n            lineno=logrecord.lineno,\n            msg=logrecord.msg,\n            args=logrecord.args,\n            exc_info=logrecord.exc_info,\n            func=logrecord.funcName,\n            sinfo=logrecord.stack_info,\n        )\n        self.levelname = self._format_levelname(self.levelname)\n        self.msg = self._format_message(self.msg)",
  "def _format_message(cls, message):\n        return str(message).replace(\"$RESET\", \"\").replace(\"$BOLD\", \"\")",
  "def __init__(self, logrecord):\n        super().__init__(\n            name=logrecord.name,\n            level=logrecord.levelno,\n            pathname=logrecord.pathname,\n            lineno=logrecord.lineno,\n            msg=logrecord.msg,\n            args=logrecord.args,\n            exc_info=logrecord.exc_info,\n            func=logrecord.funcName,\n            sinfo=logrecord.stack_info,\n        )\n        self.msg = self._format_message(self.msg)",
  "def __init__(self, *args, use_color=True, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._coloring_cls = (\n            ColoredLogRecord if use_color else UncoloredLogRecord)",
  "def format(self, record):\n        return super().format(\n            self._coloring_cls(ColonSplittingLogRecord(record)))",
  "def boundary(value, minvalue, maxvalue):\n    '''Limit a value between a minvalue and maxvalue.'''\n    return min(max(value, minvalue), maxvalue)",
  "def intersection(set1, set2):\n    '''Return the intersection of 2 lists.'''\n    return [s for s in set1 if s in set2]",
  "def difference(set1, set2):\n    '''Return the difference between 2 lists.'''\n    return [s for s in set1 if s not in set2]",
  "def interpolate(value_from, value_to, step=10):\n    '''Interpolate between two values. This can be useful for smoothing some\n    transitions. For example::\n\n        # instead of setting directly\n        self.pos = pos\n\n        # use interpolate, and you'll have a nicer transition\n        self.pos = interpolate(self.pos, new_pos)\n\n    .. warning::\n        These interpolations work only on lists/tuples/doubles with the same\n        dimensions. No test is done to check the dimensions are the same.\n    '''\n    if type(value_from) in (list, tuple):\n        out = []\n        for x, y in zip(value_from, value_to):\n            out.append(interpolate(x, y, step))\n        return out\n    else:\n        return value_from + (value_to - value_from) / float(step)",
  "def strtotuple(s):\n    '''Convert a tuple string into a tuple\n    with some security checks. Designed to be used\n    with the eval() function::\n\n        a = (12, 54, 68)\n        b = str(a)         # return '(12, 54, 68)'\n        c = strtotuple(b)  # return (12, 54, 68)\n\n    '''\n    # security\n    if not match(r'^[,.0-9 ()\\[\\]]*$', s):\n        raise Exception('Invalid characters in string for tuple conversion')\n    # fast syntax check\n    if s.count('(') != s.count(')'):\n        raise Exception('Invalid count of ( and )')\n    if s.count('[') != s.count(']'):\n        raise Exception('Invalid count of [ and ]')\n    r = eval(s)\n    if type(r) not in (list, tuple):\n        raise Exception('Conversion failed')\n    return r",
  "def rgba(s, *args):\n    '''Return a Kivy color (4 value from 0-1 range) from either a hex string or\n    a list of 0-255 values.\n\n    .. versionadded:: 1.10.0\n    '''\n    if isinstance(s, string_types):\n        return get_color_from_hex(s)\n    if isinstance(s, (list, tuple)):\n        s = [x / 255. for x in s]\n        if len(s) == 3:\n            s.append(1)\n        return s\n    if isinstance(s, (int, float)):\n        s = [s / 255.]\n        s.extend(x / 255. for x in args)\n        if len(s) == 3:\n            s.append(1)\n        return s\n    raise Exception('Invalid value (not a string / list / tuple)')",
  "def get_color_from_hex(s):\n    '''Transform a hex string color to a kivy\n    :class:`~kivy.graphics.Color`.\n    '''\n    if s.startswith('#'):\n        return get_color_from_hex(s[1:])\n\n    value = [int(x, 16) / 255.\n             for x in split('([0-9a-f]{2})', s.lower()) if x != '']\n    if len(value) == 3:\n        value.append(1.0)\n    return value",
  "def get_hex_from_color(color):\n    '''Transform a kivy :class:`~kivy.graphics.Color` to a hex value::\n\n        >>> get_hex_from_color((0, 1, 0))\n        '#00ff00'\n        >>> get_hex_from_color((.25, .77, .90, .5))\n        '#3fc4e57f'\n\n    .. versionadded:: 1.5.0\n    '''\n    return '#' + ''.join(['{0:02x}'.format(int(x * 255)) for x in color])",
  "def get_random_color(alpha=1.0):\n    '''Returns a random color (4 tuple).\n\n    :Parameters:\n        `alpha`: float, defaults to 1.0\n            If alpha == 'random', a random alpha value is generated.\n    '''\n    from random import random\n    if alpha == 'random':\n        return [random(), random(), random(), random()]\n    else:\n        return [random(), random(), random(), alpha]",
  "def is_color_transparent(c):\n    '''Return True if the alpha channel is 0.'''\n    if len(c) < 4:\n        return False\n    if float(c[3]) == 0.:\n        return True\n    return False",
  "def deprecated(func=None, msg=''):\n    '''This is a decorator which can be used to mark functions\n    as deprecated. It will result in a warning being emitted the first time\n    the function is used.'''\n\n    import inspect\n    import functools\n\n    if func is None:\n        return functools.partial(deprecated, msg=msg)\n\n    @functools.wraps(func)\n    def new_func(*args, **kwargs):\n        file, line, caller = inspect.stack()[1][1:4]\n        caller_id = \"%s:%s:%s\" % (file, line, caller)\n        # We want to print deprecated warnings only once:\n        if caller_id not in DEPRECATED_CALLERS:\n            DEPRECATED_CALLERS.append(caller_id)\n            warning = (\n                'Call to deprecated function %s in %s line %d.'\n                'Called from %s line %d'\n                ' by %s().' % (\n                    func.__name__,\n                    func.__code__.co_filename,\n                    func.__code__.co_firstlineno + 1,\n                    file, line, caller))\n\n            if msg:\n                warning = '{}: {}'.format(msg, warning)\n            warning = 'Deprecated: ' + warning\n\n            from kivy.logger import Logger\n            Logger.warning(warning)\n            if func.__doc__:\n                Logger.warning(func.__doc__)\n        return func(*args, **kwargs)\n    return new_func",
  "class SafeList(list):\n    '''List with a clear() method.\n\n    .. warning::\n        Usage of the iterate() function will decrease your performance.\n    '''\n\n    @deprecated\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def clear(self):\n        del self[:]\n\n    @deprecated\n    def iterate(self, reverse=False):\n        if reverse:\n            return iter(reversed(self))\n        return iter(self)",
  "class QueryDict(dict):\n    '''QueryDict is a dict() that can be queried with dot.\n\n    ::\n\n        d = QueryDict()\n        # create a key named toto, with the value 1\n        d.toto = 1\n        # it's the same as\n        d['toto'] = 1\n\n    .. versionadded:: 1.0.4\n    '''\n\n    def __getattr__(self, attr):\n        try:\n            return self.__getitem__(attr)\n        except KeyError:\n            return super(QueryDict, self).__getattr__(attr)\n\n    def __setattr__(self, attr, value):\n        self.__setitem__(attr, value)",
  "def format_bytes_to_human(size, precision=2):\n    '''Format a byte value to a human readable representation (B, KB, MB...).\n\n    .. versionadded:: 1.0.8\n\n    :Parameters:\n        `size`: int\n            Number that represents the bytes value\n        `precision`: int, defaults to 2\n            Precision after the comma\n\n    Examples::\n\n        >>> format_bytes_to_human(6463)\n        '6.31 KB'\n        >>> format_bytes_to_human(646368746541)\n        '601.98 GB'\n\n    '''\n    size = int(size)\n    fmt = '%%1.%df %%s' % precision\n    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:\n        if size < 1024.0:\n            return fmt % (size, unit)\n        size /= 1024.0",
  "def _get_platform():\n    # On Android sys.platform returns 'linux2', so prefer to check the\n    # existence of environ variables set during Python initialization\n    kivy_build = environ.get('KIVY_BUILD', '')\n    if kivy_build in {'android', 'ios'}:\n        return kivy_build\n    elif 'P4A_BOOTSTRAP' in environ:\n        return 'android'\n    elif 'ANDROID_ARGUMENT' in environ:\n        # We used to use this method to detect android platform,\n        # leaving it here to be backwards compatible with `pydroid3`\n        # and similar tools outside kivy's ecosystem\n        return 'android'\n    elif _sys_platform in ('win32', 'cygwin'):\n        return 'win'\n    elif _sys_platform == 'darwin':\n        return 'macosx'\n    elif _sys_platform.startswith('linux'):\n        return 'linux'\n    elif _sys_platform.startswith('freebsd'):\n        return 'linux'\n    return 'unknown'",
  "def escape_markup(text):\n    '''\n    Escape markup characters found in the text. Intended to be used when markup\n    text is activated on the Label::\n\n        untrusted_text = escape_markup('Look at the example [1]')\n        text = '[color=ff0000]' + untrusted_text + '[/color]'\n        w = Label(text=text, markup=True)\n\n    .. versionadded:: 1.3.0\n    '''\n    return text.replace('&', '&amp;').replace('[', '&bl;').replace(']', '&br;')",
  "class reify(object):\n    '''\n    Put the result of a method which uses this (non-data) descriptor decorator\n    in the instance dict after the first call, effectively replacing the\n    decorator with an instance variable.\n\n    It acts like @property, except that the function is only ever called once;\n    after that, the value is cached as a regular attribute. This gives you lazy\n    attribute creation on objects that are meant to be immutable.\n\n    Taken from the `Pyramid project <https://pypi.python.org/pypi/pyramid/>`_.\n\n    To use this as a decorator::\n\n         @reify\n         def lazy(self):\n              ...\n              return hard_to_compute_int\n         first_time = self.lazy   # lazy is reify obj, reify.__get__() runs\n         second_time = self.lazy  # lazy is hard_to_compute_int\n    '''\n\n    def __init__(self, func):\n        self.func = func\n        self.__doc__ = func.__doc__\n\n    def __get__(self, inst, cls):\n        if inst is None:\n            return self\n        retval = self.func(inst)\n        setattr(inst, self.func.__name__, retval)\n        return retval",
  "def _get_pi_version():\n    \"\"\"Detect the version of the Raspberry Pi by reading the revision field value from '/proc/cpuinfo'\n    See: https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md\n    Based on: https://github.com/adafruit/Adafruit_Python_GPIO/blob/master/Adafruit_GPIO/Platform.py\n    \"\"\"  # noqa\n    # Check if file exist\n    if not path.isfile('/proc/cpuinfo'):\n        return None\n\n    with open('/proc/cpuinfo', 'r') as f:\n        cpuinfo = f.read()\n\n    # Match a line like 'Revision   : a01041'\n    revision = search(r'^Revision\\s+:\\s+(\\w+)$', cpuinfo,\n                      flags=MULTILINE | IGNORECASE)\n    if not revision:\n        # Couldn't find the hardware revision, assume it is not a Pi\n        return None\n\n    # Determine the Pi version using the processor bits using the new-style\n    # revision format\n    revision = int(revision.group(1), base=16)\n    if revision & 0x800000:\n        return ((revision & 0xF000) >> 12) + 1\n\n    # If it is not using the new style revision format,\n    # then it must be a Raspberry Pi 1\n    return 1",
  "def new_func(*args, **kwargs):\n        file, line, caller = inspect.stack()[1][1:4]\n        caller_id = \"%s:%s:%s\" % (file, line, caller)\n        # We want to print deprecated warnings only once:\n        if caller_id not in DEPRECATED_CALLERS:\n            DEPRECATED_CALLERS.append(caller_id)\n            warning = (\n                'Call to deprecated function %s in %s line %d.'\n                'Called from %s line %d'\n                ' by %s().' % (\n                    func.__name__,\n                    func.__code__.co_filename,\n                    func.__code__.co_firstlineno + 1,\n                    file, line, caller))\n\n            if msg:\n                warning = '{}: {}'.format(msg, warning)\n            warning = 'Deprecated: ' + warning\n\n            from kivy.logger import Logger\n            Logger.warning(warning)\n            if func.__doc__:\n                Logger.warning(func.__doc__)\n        return func(*args, **kwargs)",
  "def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)",
  "def clear(self):\n        del self[:]",
  "def iterate(self, reverse=False):\n        if reverse:\n            return iter(reversed(self))\n        return iter(self)",
  "def __getattr__(self, attr):\n        try:\n            return self.__getitem__(attr)\n        except KeyError:\n            return super(QueryDict, self).__getattr__(attr)",
  "def __setattr__(self, attr, value):\n        self.__setitem__(attr, value)",
  "def __init__(self, func):\n        self.func = func\n        self.__doc__ = func.__doc__",
  "def __get__(self, inst, cls):\n        if inst is None:\n            return self\n        retval = self.func(inst)\n        setattr(inst, self.func.__name__, retval)\n        return retval",
  "class ExceptionHandler(object):\n    '''Base handler that catches exceptions in :func:`runTouchApp`.\n    You can subclass and extend it as follows::\n\n        class E(ExceptionHandler):\n            def handle_exception(self, inst):\n                Logger.exception('Exception caught by ExceptionHandler')\n                return ExceptionManager.PASS\n\n        ExceptionManager.add_handler(E())\n\n    Then, all exceptions will be set to PASS, and logged to the console!\n    '''\n\n    def handle_exception(self, exception):\n        '''Called by :class:`ExceptionManagerBase` to handle a exception.\n\n        Defaults to returning :attr:`ExceptionManager.RAISE` that re-raises the\n        exception. Return :attr:`ExceptionManager.PASS` to indicate that the\n        exception was handled and should be ignored.\n\n        This may be called multiple times with the same exception, if\n        :attr:`ExceptionManager.RAISE` is returned as the exception bubbles\n        through multiple kivy exception handling levels.\n        '''\n        return ExceptionManager.RAISE",
  "class ExceptionManagerBase:\n    '''ExceptionManager manages exceptions handlers.'''\n\n    RAISE = 0\n    \"\"\"The exception should be re-raised.\n    \"\"\"\n    PASS = 1\n    \"\"\"The exception should be ignored as it was handled by the handler.\n    \"\"\"\n\n    def __init__(self):\n        self.handlers = []\n        self.policy = ExceptionManagerBase.RAISE\n\n    def add_handler(self, cls):\n        '''Add a new exception handler to the stack.'''\n        if cls not in self.handlers:\n            self.handlers.append(cls)\n\n    def remove_handler(self, cls):\n        '''Remove the exception handler from the stack.'''\n        if cls in self.handlers:\n            self.handlers.remove(cls)\n\n    def handle_exception(self, inst):\n        '''Called when an exception occurred in the :func:`runTouchApp`\n        main loop.'''\n        ret = self.policy\n        for handler in self.handlers:\n            r = handler.handle_exception(inst)\n            if r == ExceptionManagerBase.PASS:\n                ret = r\n        return ret",
  "class EventLoopBase(EventDispatcher):\n    '''Main event loop. This loop handles the updating of input and\n    dispatching events.\n    '''\n\n    __events__ = ('on_start', 'on_pause', 'on_stop')\n\n    def __init__(self):\n        super(EventLoopBase, self).__init__()\n        self.quit = False\n        self.input_events = []\n        self.postproc_modules = []\n        self.status = 'idle'\n        self.stopping = False\n        self.input_providers = []\n        self.input_providers_autoremove = []\n        self.event_listeners = []\n        self.window = None\n        self.me_list = []\n\n    @property\n    def touches(self):\n        '''Return the list of all touches currently in down or move states.\n        '''\n        return self.me_list\n\n    def ensure_window(self):\n        '''Ensure that we have a window.\n        '''\n        import kivy.core.window  # NOQA\n        if not self.window:\n            Logger.critical('App: Unable to get a Window, abort.')\n            sys.exit(1)\n\n    def set_window(self, window):\n        '''Set the window used for the event loop.\n        '''\n        self.window = window\n\n    def add_input_provider(self, provider, auto_remove=False):\n        '''Add a new input provider to listen for touch events.\n        '''\n        if provider not in self.input_providers:\n            self.input_providers.append(provider)\n            if auto_remove:\n                self.input_providers_autoremove.append(provider)\n\n    def remove_input_provider(self, provider):\n        '''Remove an input provider.\n\n        .. versionchanged:: 2.1.0\n            Provider will be also removed if it exist in auto-remove list.\n        '''\n        if provider in self.input_providers:\n            self.input_providers.remove(provider)\n            if provider in self.input_providers_autoremove:\n                self.input_providers_autoremove.remove(provider)\n\n    def add_event_listener(self, listener):\n        '''Add a new event listener for getting touch events.\n        '''\n        if listener not in self.event_listeners:\n            self.event_listeners.append(listener)\n\n    def remove_event_listener(self, listener):\n        '''Remove an event listener from the list.\n        '''\n        if listener in self.event_listeners:\n            self.event_listeners.remove(listener)\n\n    def start(self):\n        '''Must be called before :meth:`EventLoopBase.run()`. This starts all\n        configured input providers.\n\n        .. versionchanged:: 2.1.0\n            Method can be called multiple times, but event loop will start only\n            once.\n        '''\n        if self.status == 'started':\n            return\n        self.status = 'started'\n        self.quit = False\n        Clock.start_clock()\n        for provider in self.input_providers:\n            provider.start()\n        self.dispatch('on_start')\n\n    def close(self):\n        '''Exit from the main loop and stop all configured\n        input providers.'''\n        self.quit = True\n        self.stop()\n        self.status = 'closed'\n\n    def stop(self):\n        '''Stop all input providers and call callbacks registered using\n        `EventLoop.add_stop_callback()`.\n\n        .. versionchanged:: 2.1.0\n            Method can be called multiple times, but event loop will stop only\n            once.\n        '''\n        if self.status != 'started':\n            return\n        # XXX stop in reverse order that we started them!! (like push\n        # pop), very important because e.g. wm_touch and WM_PEN both\n        # store old window proc and the restore, if order is messed big\n        # problem happens, crashing badly without error\n        for provider in reversed(self.input_providers[:]):\n            provider.stop()\n            self.remove_input_provider(provider)\n\n        # ensure any restart will not break anything later.\n        self.input_events = []\n\n        Clock.stop_clock()\n        self.stopping = False\n        self.status = 'stopped'\n        self.dispatch('on_stop')\n\n    def add_postproc_module(self, mod):\n        '''Add a postproc input module (DoubleTap, TripleTap, DeJitter\n        RetainTouch are defaults).'''\n        if mod not in self.postproc_modules:\n            self.postproc_modules.append(mod)\n\n    def remove_postproc_module(self, mod):\n        '''Remove a postproc module.'''\n        if mod in self.postproc_modules:\n            self.postproc_modules.remove(mod)\n\n    def remove_android_splash(self, *args):\n        '''Remove android presplash in SDL2 bootstrap.'''\n        try:\n            from android import remove_presplash\n            remove_presplash()\n        except ImportError:\n            Logger.warning(\n                'Base: Failed to import \"android\" module. '\n                'Could not remove android presplash.')\n            return\n\n    def post_dispatch_input(self, etype, me):\n        '''This function is called by :meth:`EventLoopBase.dispatch_input()`\n        when we want to dispatch an input event. The event is dispatched to\n        all listeners and if grabbed, it's dispatched to grabbed widgets.\n        '''\n        # update available list\n        if etype == 'begin':\n            self.me_list.append(me)\n        elif etype == 'end':\n            if me in self.me_list:\n                self.me_list.remove(me)\n        # dispatch to listeners\n        if not me.grab_exclusive_class:\n            for listener in self.event_listeners:\n                listener.dispatch('on_motion', etype, me)\n        # dispatch grabbed touch\n        if not me.is_touch:\n            # Non-touch event must be handled by the event manager\n            return\n        me.grab_state = True\n        for weak_widget in me.grab_list[:]:\n            # weak_widget is a weak reference to widget\n            wid = weak_widget()\n            if wid is None:\n                # object is gone, stop.\n                me.grab_list.remove(weak_widget)\n                continue\n            root_window = wid.get_root_window()\n            if wid != root_window and root_window is not None:\n                me.push()\n                try:\n                    root_window.transform_motion_event_2d(me, wid)\n                except AttributeError:\n                    me.pop()\n                    continue\n            me.grab_current = wid\n            wid._context.push()\n            if etype == 'begin':\n                # don't dispatch again touch in on_touch_down\n                # a down event are nearly uniq here.\n                # wid.dispatch('on_touch_down', touch)\n                pass\n            elif etype == 'update':\n                if wid._context.sandbox:\n                    with wid._context.sandbox:\n                        wid.dispatch('on_touch_move', me)\n                else:\n                    wid.dispatch('on_touch_move', me)\n            elif etype == 'end':\n                if wid._context.sandbox:\n                    with wid._context.sandbox:\n                        wid.dispatch('on_touch_up', me)\n                else:\n                    wid.dispatch('on_touch_up', me)\n            wid._context.pop()\n            me.grab_current = None\n            if wid != root_window and root_window is not None:\n                me.pop()\n        me.grab_state = False\n        me.dispatch_done()\n\n    def _dispatch_input(self, *ev):\n        # remove the save event for the touch if exist\n        if ev in self.input_events:\n            self.input_events.remove(ev)\n        self.input_events.append(ev)\n\n    def dispatch_input(self):\n        '''Called by :meth:`EventLoopBase.idle()` to read events from input\n        providers, pass events to postproc, and dispatch final events.\n        '''\n\n        # first, acquire input events\n        for provider in self.input_providers:\n            provider.update(dispatch_fn=self._dispatch_input)\n\n        # execute post-processing modules\n        for mod in self.postproc_modules:\n            self.input_events = mod.process(events=self.input_events)\n\n        # real dispatch input\n        input_events = self.input_events\n        pop = input_events.pop\n        post_dispatch_input = self.post_dispatch_input\n        while input_events:\n            post_dispatch_input(*pop(0))\n\n    def mainloop(self):\n        while not self.quit and self.status == 'started':\n            try:\n                self.idle()\n                if self.window:\n                    self.window.mainloop()\n            except BaseException as inst:\n                # use exception manager first\n                r = ExceptionManager.handle_exception(inst)\n                if r == ExceptionManager.RAISE:\n                    stopTouchApp()\n                    raise\n                else:\n                    pass\n\n    async def async_mainloop(self):\n        while not self.quit and self.status == 'started':\n            try:\n                await self.async_idle()\n                if self.window:\n                    self.window.mainloop()\n            except BaseException as inst:\n                # use exception manager first\n                r = ExceptionManager.handle_exception(inst)\n                if r == ExceptionManager.RAISE:\n                    stopTouchApp()\n                    raise\n                else:\n                    pass\n\n        Logger.info(\"Window: exiting mainloop and closing.\")\n        self.close()\n\n    def idle(self):\n        '''This function is called after every frame. By default:\n\n           * it \"ticks\" the clock to the next frame.\n           * it reads all input and dispatches events.\n           * it dispatches `on_update`, `on_draw` and `on_flip` events to the\n             window.\n        '''\n\n        # update dt\n        Clock.tick()\n\n        # read and dispatch input from providers\n        if not self.quit:\n            self.dispatch_input()\n\n        # flush all the canvas operation\n        if not self.quit:\n            Builder.sync()\n\n        # tick before draw\n        if not self.quit:\n            Clock.tick_draw()\n\n        # flush all the canvas operation\n        if not self.quit:\n            Builder.sync()\n\n        if not self.quit:\n            window = self.window\n            if window and window.canvas.needs_redraw:\n                window.dispatch('on_draw')\n                window.dispatch('on_flip')\n\n        # don't loop if we don't have listeners !\n        if len(self.event_listeners) == 0:\n            Logger.error('Base: No event listeners have been created')\n            Logger.error('Base: Application will leave')\n            self.exit()\n            return False\n\n        return self.quit\n\n    async def async_idle(self):\n        '''Identical to :meth:`idle`, but instead used when running\n        within an async event loop.\n        '''\n\n        # update dt\n        await Clock.async_tick()\n\n        # read and dispatch input from providers\n        if not self.quit:\n            self.dispatch_input()\n\n        # flush all the canvas operation\n        if not self.quit:\n            Builder.sync()\n\n        # tick before draw\n        if not self.quit:\n            Clock.tick_draw()\n\n        # flush all the canvas operation\n        if not self.quit:\n            Builder.sync()\n\n        if not self.quit:\n            window = self.window\n            if window and window.canvas.needs_redraw:\n                window.dispatch('on_draw')\n                window.dispatch('on_flip')\n\n        # don't loop if we don't have listeners !\n        if len(self.event_listeners) == 0:\n            Logger.error('Base: No event listeners have been created')\n            Logger.error('Base: Application will leave')\n            self.exit()\n            return False\n\n        return self.quit\n\n    def run(self):\n        '''Main loop'''\n        while not self.quit:\n            self.idle()\n        self.exit()\n\n    def exit(self):\n        '''Close the main loop and close the window.'''\n        self.close()\n        if self.window:\n            self.window.close()\n\n    def on_stop(self):\n        '''Event handler for `on_stop` events which will be fired right\n        after all input providers have been stopped.'''\n        pass\n\n    def on_pause(self):\n        '''Event handler for `on_pause` which will be fired when\n        the event loop is paused.'''\n        pass\n\n    def on_start(self):\n        '''Event handler for `on_start` which will be fired right\n        after all input providers have been started.'''\n        pass",
  "def _runTouchApp_prepare(widget=None):\n    from kivy.input import MotionEventFactory, kivy_postproc_modules\n\n    # Ok, we got one widget, and we are not in embedded mode\n    # so, user don't create the window, let's create it for him !\n    if widget:\n        EventLoop.ensure_window()\n\n    # Instance all configured input\n    for key, value in Config.items('input'):\n        Logger.debug('Base: Create provider from %s' % (str(value)))\n\n        # split value\n        args = str(value).split(',', 1)\n        if len(args) == 1:\n            args.append('')\n        provider_id, args = args\n        provider = MotionEventFactory.get(provider_id)\n        if provider is None:\n            Logger.warning('Base: Unknown <%s> provider' % str(provider_id))\n            continue\n\n        # create provider\n        p = provider(key, args)\n        if p:\n            EventLoop.add_input_provider(p, True)\n\n    # add postproc modules\n    for mod in list(kivy_postproc_modules.values()):\n        EventLoop.add_postproc_module(mod)\n\n    # add main widget\n    if widget and EventLoop.window:\n        if widget not in EventLoop.window.children:\n            EventLoop.window.add_widget(widget)\n\n    # start event loop\n    Logger.info('Base: Start application main loop')\n    EventLoop.start()\n\n    # remove presplash on the next frame\n    if platform == 'android':\n        Clock.schedule_once(EventLoop.remove_android_splash)",
  "def runTouchApp(widget=None, embedded=False):\n    '''Static main function that starts the application loop.\n    You can access some magic via the following arguments:\n\n    See :mod:`kivy.app` for example usage.\n\n    :Parameters:\n        `<empty>`\n            To make dispatching work, you need at least one\n            input listener. If not, application will leave.\n            (MTWindow act as an input listener)\n\n        `widget`\n            If you pass only a widget, a MTWindow will be created\n            and your widget will be added to the window as the root\n            widget.\n\n        `embedded`\n            No event dispatching is done. This will be your job.\n\n        `widget + embedded`\n            No event dispatching is done. This will be your job but\n            we try to get the window (must be created by you beforehand)\n            and add the widget to it. Very useful for embedding Kivy\n            in another toolkit. (like Qt, check kivy-designed)\n\n    '''\n    _runTouchApp_prepare(widget=widget)\n\n    # we are in embedded mode, don't do dispatching.\n    if embedded:\n        return\n\n    try:\n        EventLoop.mainloop()\n    finally:\n        stopTouchApp()",
  "async def async_runTouchApp(widget=None, embedded=False, async_lib=None):\n    '''Identical to :func:`runTouchApp` but instead it is a coroutine\n    that can be run in an existing async event loop.\n\n    ``async_lib`` is the async library to use. See :mod:`kivy.app` for details\n    and example usage.\n\n    .. versionadded:: 2.0.0\n    '''\n    if async_lib is not None:\n        Clock.init_async_lib(async_lib)\n    _runTouchApp_prepare(widget=widget)\n\n    # we are in embedded mode, don't do dispatching.\n    if embedded:\n        return\n\n    try:\n        await EventLoop.async_mainloop()\n    finally:\n        stopTouchApp()",
  "def stopTouchApp():\n    '''Stop the current application by leaving the main loop.\n\n    See :mod:`kivy.app` for example usage.\n    '''\n    if EventLoop is None:\n        return\n    if EventLoop.status in ('stopped', 'closed'):\n        return\n    if EventLoop.status != 'started':\n        if not EventLoop.stopping:\n            EventLoop.stopping = True\n            Clock.schedule_once(lambda dt: stopTouchApp(), 0)\n        return\n    Logger.info('Base: Leaving application in progress...')\n    EventLoop.close()",
  "def handle_exception(self, exception):\n        '''Called by :class:`ExceptionManagerBase` to handle a exception.\n\n        Defaults to returning :attr:`ExceptionManager.RAISE` that re-raises the\n        exception. Return :attr:`ExceptionManager.PASS` to indicate that the\n        exception was handled and should be ignored.\n\n        This may be called multiple times with the same exception, if\n        :attr:`ExceptionManager.RAISE` is returned as the exception bubbles\n        through multiple kivy exception handling levels.\n        '''\n        return ExceptionManager.RAISE",
  "def __init__(self):\n        self.handlers = []\n        self.policy = ExceptionManagerBase.RAISE",
  "def add_handler(self, cls):\n        '''Add a new exception handler to the stack.'''\n        if cls not in self.handlers:\n            self.handlers.append(cls)",
  "def remove_handler(self, cls):\n        '''Remove the exception handler from the stack.'''\n        if cls in self.handlers:\n            self.handlers.remove(cls)",
  "def handle_exception(self, inst):\n        '''Called when an exception occurred in the :func:`runTouchApp`\n        main loop.'''\n        ret = self.policy\n        for handler in self.handlers:\n            r = handler.handle_exception(inst)\n            if r == ExceptionManagerBase.PASS:\n                ret = r\n        return ret",
  "def __init__(self):\n        super(EventLoopBase, self).__init__()\n        self.quit = False\n        self.input_events = []\n        self.postproc_modules = []\n        self.status = 'idle'\n        self.stopping = False\n        self.input_providers = []\n        self.input_providers_autoremove = []\n        self.event_listeners = []\n        self.window = None\n        self.me_list = []",
  "def touches(self):\n        '''Return the list of all touches currently in down or move states.\n        '''\n        return self.me_list",
  "def ensure_window(self):\n        '''Ensure that we have a window.\n        '''\n        import kivy.core.window  # NOQA\n        if not self.window:\n            Logger.critical('App: Unable to get a Window, abort.')\n            sys.exit(1)",
  "def set_window(self, window):\n        '''Set the window used for the event loop.\n        '''\n        self.window = window",
  "def add_input_provider(self, provider, auto_remove=False):\n        '''Add a new input provider to listen for touch events.\n        '''\n        if provider not in self.input_providers:\n            self.input_providers.append(provider)\n            if auto_remove:\n                self.input_providers_autoremove.append(provider)",
  "def remove_input_provider(self, provider):\n        '''Remove an input provider.\n\n        .. versionchanged:: 2.1.0\n            Provider will be also removed if it exist in auto-remove list.\n        '''\n        if provider in self.input_providers:\n            self.input_providers.remove(provider)\n            if provider in self.input_providers_autoremove:\n                self.input_providers_autoremove.remove(provider)",
  "def add_event_listener(self, listener):\n        '''Add a new event listener for getting touch events.\n        '''\n        if listener not in self.event_listeners:\n            self.event_listeners.append(listener)",
  "def remove_event_listener(self, listener):\n        '''Remove an event listener from the list.\n        '''\n        if listener in self.event_listeners:\n            self.event_listeners.remove(listener)",
  "def start(self):\n        '''Must be called before :meth:`EventLoopBase.run()`. This starts all\n        configured input providers.\n\n        .. versionchanged:: 2.1.0\n            Method can be called multiple times, but event loop will start only\n            once.\n        '''\n        if self.status == 'started':\n            return\n        self.status = 'started'\n        self.quit = False\n        Clock.start_clock()\n        for provider in self.input_providers:\n            provider.start()\n        self.dispatch('on_start')",
  "def close(self):\n        '''Exit from the main loop and stop all configured\n        input providers.'''\n        self.quit = True\n        self.stop()\n        self.status = 'closed'",
  "def stop(self):\n        '''Stop all input providers and call callbacks registered using\n        `EventLoop.add_stop_callback()`.\n\n        .. versionchanged:: 2.1.0\n            Method can be called multiple times, but event loop will stop only\n            once.\n        '''\n        if self.status != 'started':\n            return\n        # XXX stop in reverse order that we started them!! (like push\n        # pop), very important because e.g. wm_touch and WM_PEN both\n        # store old window proc and the restore, if order is messed big\n        # problem happens, crashing badly without error\n        for provider in reversed(self.input_providers[:]):\n            provider.stop()\n            self.remove_input_provider(provider)\n\n        # ensure any restart will not break anything later.\n        self.input_events = []\n\n        Clock.stop_clock()\n        self.stopping = False\n        self.status = 'stopped'\n        self.dispatch('on_stop')",
  "def add_postproc_module(self, mod):\n        '''Add a postproc input module (DoubleTap, TripleTap, DeJitter\n        RetainTouch are defaults).'''\n        if mod not in self.postproc_modules:\n            self.postproc_modules.append(mod)",
  "def remove_postproc_module(self, mod):\n        '''Remove a postproc module.'''\n        if mod in self.postproc_modules:\n            self.postproc_modules.remove(mod)",
  "def remove_android_splash(self, *args):\n        '''Remove android presplash in SDL2 bootstrap.'''\n        try:\n            from android import remove_presplash\n            remove_presplash()\n        except ImportError:\n            Logger.warning(\n                'Base: Failed to import \"android\" module. '\n                'Could not remove android presplash.')\n            return",
  "def post_dispatch_input(self, etype, me):\n        '''This function is called by :meth:`EventLoopBase.dispatch_input()`\n        when we want to dispatch an input event. The event is dispatched to\n        all listeners and if grabbed, it's dispatched to grabbed widgets.\n        '''\n        # update available list\n        if etype == 'begin':\n            self.me_list.append(me)\n        elif etype == 'end':\n            if me in self.me_list:\n                self.me_list.remove(me)\n        # dispatch to listeners\n        if not me.grab_exclusive_class:\n            for listener in self.event_listeners:\n                listener.dispatch('on_motion', etype, me)\n        # dispatch grabbed touch\n        if not me.is_touch:\n            # Non-touch event must be handled by the event manager\n            return\n        me.grab_state = True\n        for weak_widget in me.grab_list[:]:\n            # weak_widget is a weak reference to widget\n            wid = weak_widget()\n            if wid is None:\n                # object is gone, stop.\n                me.grab_list.remove(weak_widget)\n                continue\n            root_window = wid.get_root_window()\n            if wid != root_window and root_window is not None:\n                me.push()\n                try:\n                    root_window.transform_motion_event_2d(me, wid)\n                except AttributeError:\n                    me.pop()\n                    continue\n            me.grab_current = wid\n            wid._context.push()\n            if etype == 'begin':\n                # don't dispatch again touch in on_touch_down\n                # a down event are nearly uniq here.\n                # wid.dispatch('on_touch_down', touch)\n                pass\n            elif etype == 'update':\n                if wid._context.sandbox:\n                    with wid._context.sandbox:\n                        wid.dispatch('on_touch_move', me)\n                else:\n                    wid.dispatch('on_touch_move', me)\n            elif etype == 'end':\n                if wid._context.sandbox:\n                    with wid._context.sandbox:\n                        wid.dispatch('on_touch_up', me)\n                else:\n                    wid.dispatch('on_touch_up', me)\n            wid._context.pop()\n            me.grab_current = None\n            if wid != root_window and root_window is not None:\n                me.pop()\n        me.grab_state = False\n        me.dispatch_done()",
  "def _dispatch_input(self, *ev):\n        # remove the save event for the touch if exist\n        if ev in self.input_events:\n            self.input_events.remove(ev)\n        self.input_events.append(ev)",
  "def dispatch_input(self):\n        '''Called by :meth:`EventLoopBase.idle()` to read events from input\n        providers, pass events to postproc, and dispatch final events.\n        '''\n\n        # first, acquire input events\n        for provider in self.input_providers:\n            provider.update(dispatch_fn=self._dispatch_input)\n\n        # execute post-processing modules\n        for mod in self.postproc_modules:\n            self.input_events = mod.process(events=self.input_events)\n\n        # real dispatch input\n        input_events = self.input_events\n        pop = input_events.pop\n        post_dispatch_input = self.post_dispatch_input\n        while input_events:\n            post_dispatch_input(*pop(0))",
  "def mainloop(self):\n        while not self.quit and self.status == 'started':\n            try:\n                self.idle()\n                if self.window:\n                    self.window.mainloop()\n            except BaseException as inst:\n                # use exception manager first\n                r = ExceptionManager.handle_exception(inst)\n                if r == ExceptionManager.RAISE:\n                    stopTouchApp()\n                    raise\n                else:\n                    pass",
  "async def async_mainloop(self):\n        while not self.quit and self.status == 'started':\n            try:\n                await self.async_idle()\n                if self.window:\n                    self.window.mainloop()\n            except BaseException as inst:\n                # use exception manager first\n                r = ExceptionManager.handle_exception(inst)\n                if r == ExceptionManager.RAISE:\n                    stopTouchApp()\n                    raise\n                else:\n                    pass\n\n        Logger.info(\"Window: exiting mainloop and closing.\")\n        self.close()",
  "def idle(self):\n        '''This function is called after every frame. By default:\n\n           * it \"ticks\" the clock to the next frame.\n           * it reads all input and dispatches events.\n           * it dispatches `on_update`, `on_draw` and `on_flip` events to the\n             window.\n        '''\n\n        # update dt\n        Clock.tick()\n\n        # read and dispatch input from providers\n        if not self.quit:\n            self.dispatch_input()\n\n        # flush all the canvas operation\n        if not self.quit:\n            Builder.sync()\n\n        # tick before draw\n        if not self.quit:\n            Clock.tick_draw()\n\n        # flush all the canvas operation\n        if not self.quit:\n            Builder.sync()\n\n        if not self.quit:\n            window = self.window\n            if window and window.canvas.needs_redraw:\n                window.dispatch('on_draw')\n                window.dispatch('on_flip')\n\n        # don't loop if we don't have listeners !\n        if len(self.event_listeners) == 0:\n            Logger.error('Base: No event listeners have been created')\n            Logger.error('Base: Application will leave')\n            self.exit()\n            return False\n\n        return self.quit",
  "async def async_idle(self):\n        '''Identical to :meth:`idle`, but instead used when running\n        within an async event loop.\n        '''\n\n        # update dt\n        await Clock.async_tick()\n\n        # read and dispatch input from providers\n        if not self.quit:\n            self.dispatch_input()\n\n        # flush all the canvas operation\n        if not self.quit:\n            Builder.sync()\n\n        # tick before draw\n        if not self.quit:\n            Clock.tick_draw()\n\n        # flush all the canvas operation\n        if not self.quit:\n            Builder.sync()\n\n        if not self.quit:\n            window = self.window\n            if window and window.canvas.needs_redraw:\n                window.dispatch('on_draw')\n                window.dispatch('on_flip')\n\n        # don't loop if we don't have listeners !\n        if len(self.event_listeners) == 0:\n            Logger.error('Base: No event listeners have been created')\n            Logger.error('Base: Application will leave')\n            self.exit()\n            return False\n\n        return self.quit",
  "def run(self):\n        '''Main loop'''\n        while not self.quit:\n            self.idle()\n        self.exit()",
  "def exit(self):\n        '''Close the main loop and close the window.'''\n        self.close()\n        if self.window:\n            self.window.close()",
  "def on_stop(self):\n        '''Event handler for `on_stop` events which will be fired right\n        after all input providers have been stopped.'''\n        pass",
  "def on_pause(self):\n        '''Event handler for `on_pause` which will be fired when\n        the event loop is paused.'''\n        pass",
  "def on_start(self):\n        '''Event handler for `on_start` which will be fired right\n        after all input providers have been started.'''\n        pass",
  "def pt(value) -> float:\n    '''Convert from points to pixels\n    '''\n    return dpi2px(value, 'pt')",
  "def inch(value) -> float:\n    '''Convert from inches to pixels\n    '''\n    return dpi2px(value, 'in')",
  "def cm(value) -> float:\n    '''Convert from centimeters to pixels\n    '''\n    return dpi2px(value, 'cm')",
  "def mm(value) -> float:\n    '''Convert from millimeters to pixels\n    '''\n    return dpi2px(value, 'mm')",
  "def dp(value) -> float:\n    '''Convert from density-independent pixels to pixels\n    '''\n    return dpi2px(value, 'dp')",
  "def sp(value) -> float:\n    '''Convert from scale-independent pixels to pixels\n    '''\n    return dpi2px(value, 'sp')",
  "class MetricsBase(EventDispatcher):\n    '''Class that contains the default attributes for Metrics. Don't use this\n    class directly, but use the `Metrics` instance.\n    '''\n\n    _dpi = _default_dpi\n\n    _density = _default_density\n\n    _fontscale = _default_fontscale\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.fbind('dpi', dispatch_pixel_scale)\n        self.fbind('density', dispatch_pixel_scale)\n        self.fbind('fontscale', dispatch_pixel_scale)\n\n    def get_dpi(self, force_recompute=False):\n        if not force_recompute and self._dpi is not None:\n            return self._dpi\n\n        if platform == 'android':\n            if USE_SDL2:\n                import jnius\n                Hardware = jnius.autoclass('org.renpy.android.Hardware')\n                value = Hardware.getDPI()\n            else:\n                import android\n                value = android.get_dpi()\n        elif platform == 'ios':\n            import ios\n            value = ios.get_dpi()\n        else:\n            # for all other platforms..\n            from kivy.base import EventLoop\n            EventLoop.ensure_window()\n            value = EventLoop.window.dpi\n\n        # because dp prop binds to dpi etc. its getter will be executed\n        # before dispatch_pixel_scale bound to dpi was called, so we need to\n        # call this to make sure it's updated\n        sync_pixel_scale(dpi=value)\n        return value\n\n    def set_dpi(self, value):\n        self._dpi = value\n        sync_pixel_scale(dpi=value)\n        return True\n\n    dpi: float = AliasProperty(get_dpi, set_dpi, cache=True)\n    '''The DPI of the screen.\n\n    Depending on the platform, the DPI can be taken from the Window provider\n    (Desktop mainly) or from a platform-specific module (like android/ios).\n\n    :attr:`dpi` is a :class:`~kivy.properties.AliasProperty` and can be\n    set to change the value. But, the :attr:`density` is reloaded and reset if\n    we got it from the Window and the Window ``dpi`` changed.\n    '''\n\n    def get_dpi_rounded(self):\n        dpi = self.dpi\n        if dpi < 140:\n            return 120\n        elif dpi < 200:\n            return 160\n        elif dpi < 280:\n            return 240\n        return 320\n\n    dpi_rounded: int = AliasProperty(\n        get_dpi_rounded, None, bind=('dpi', ), cache=True)\n    '''Return the :attr:`dpi` of the screen, rounded to the nearest of 120,\n    160, 240 or 320.\n\n    :attr:`dpi_rounded` is a :class:`~kivy.properties.AliasProperty` and\n    updates when :attr:`dpi` changes.\n    '''\n\n    def get_density(self, force_recompute=False):\n        if not force_recompute and self._density is not None:\n            return self._density\n\n        value = 1.0\n        if platform == 'android':\n            import jnius\n            Hardware = jnius.autoclass('org.renpy.android.Hardware')\n            value = Hardware.metrics.scaledDensity\n        elif platform == 'ios':\n            import ios\n            value = ios.get_scale()\n        elif platform in ('macosx', 'win'):\n            value = self.dpi / 96.\n\n        sync_pixel_scale(density=value)\n        return value\n\n    def set_density(self, value):\n        self._density = value\n        sync_pixel_scale(density=value)\n        return True\n\n    density: float = AliasProperty(\n        get_density, set_density, bind=('dpi', ), cache=True)\n    '''The density of the screen.\n\n    This value is 1 by default on desktops but varies on android depending on\n    the screen.\n\n    :attr:`density` is a :class:`~kivy.properties.AliasProperty` and can be\n    set to change the value. But, the :attr:`density` is reloaded and reset if\n    we got it from the Window and the Window ``density`` changed.\n    '''\n\n    def get_fontscale(self, force_recompute=False):\n        if not force_recompute and self._fontscale is not None:\n            return self._fontscale\n\n        value = 1.0\n        if platform == 'android':\n            from jnius import autoclass\n            if USE_SDL2:\n                PythonActivity = autoclass('org.kivy.android.PythonActivity')\n            else:\n                PythonActivity = autoclass('org.renpy.android.PythonActivity')\n            config = PythonActivity.mActivity.getResources().getConfiguration()\n            value = config.fontScale\n\n        sync_pixel_scale(fontscale=value)\n        return value\n\n    def set_fontscale(self, value):\n        self._fontscale = value\n        sync_pixel_scale(fontscale=value)\n        return True\n\n    fontscale: float = AliasProperty(get_fontscale, set_fontscale, cache=True)\n    '''The fontscale user preference.\n\n    This value is 1 by default but can vary between 0.8 and 1.2.\n\n    :attr:`fontscale` is a :class:`~kivy.properties.AliasProperty` and can be\n    set to change the value.\n    '''\n\n    def get_in(self):\n        # we bind to all dpi, density, fontscale, even though not all may be\n        # used for a specific suffix, because we don't want to rely on the\n        # internal details of dpi2px. But it will be one of the three. But it's\n        # an issue, since it won't trigger the prop if the value doesn't change\n        return dpi2px(1, 'in')\n\n    inch: float = AliasProperty(\n        get_in, None, bind=('dpi', 'density', 'fontscale'), cache=True)\n    \"\"\"The scaling factor that converts from inches to pixels.\n\n    :attr:`inch` is a :class:`~kivy.properties.AliasProperty` containing the\n    factor. E.g in KV: ``width: self.texture_size[0] + 10 * Metrics.inch`` will\n    update width when :attr:`inch` changes from a screen configuration change.\n    \"\"\"\n\n    def get_dp(self):\n        return dpi2px(1, 'dp')\n\n    dp: float = AliasProperty(\n        get_dp, None, bind=('dpi', 'density', 'fontscale'), cache=True)\n    \"\"\"The scaling factor that converts from density-independent pixels to\n    pixels.\n\n    :attr:`dp` is a :class:`~kivy.properties.AliasProperty` containing the\n    factor. E.g in KV: ``width: self.texture_size[0] + 10 * Metrics.dp`` will\n    update width when :attr:`dp` changes from a screen configuration change.\n    \"\"\"\n\n    def get_sp(self):\n        return dpi2px(1, 'sp')\n\n    sp: float = AliasProperty(\n        get_sp, None, bind=('dpi', 'density', 'fontscale'), cache=True)\n    \"\"\"The scaling factor that converts from scale-independent pixels to\n    pixels.\n\n    :attr:`sp` is a :class:`~kivy.properties.AliasProperty` containing the\n    factor. E.g in KV: ``width: self.texture_size[0] + 10 * Metrics.sp`` will\n    update width when :attr:`sp` changes from a screen configuration change.\n    \"\"\"\n\n    def get_pt(self):\n        return dpi2px(1, 'pt')\n\n    pt: float = AliasProperty(\n        get_pt, None, bind=('dpi', 'density', 'fontscale'), cache=True)\n    \"\"\"The scaling factor that converts from points to pixels.\n\n    :attr:`pt` is a :class:`~kivy.properties.AliasProperty` containing the\n    factor. E.g in KV: ``width: self.texture_size[0] + 10 * Metrics.pt`` will\n    update width when :attr:`pt` changes from a screen configuration change.\n    \"\"\"\n\n    def get_cm(self):\n        return dpi2px(1, 'cm')\n\n    cm: float = AliasProperty(\n        get_cm, None, bind=('dpi', 'density', 'fontscale'), cache=True)\n    \"\"\"The scaling factor that converts from centimeters to pixels.\n\n    :attr:`cm` is a :class:`~kivy.properties.AliasProperty` containing the\n    factor. E.g in KV: ``width: self.texture_size[0] + 10 * Metrics.cm`` will\n    update width when :attr:`cm` changes from a screen configuration change.\n    \"\"\"\n\n    def get_mm(self):\n        return dpi2px(1, 'mm')\n\n    mm: float = AliasProperty(\n        get_mm, None, bind=('dpi', 'density', 'fontscale'), cache=True)\n    \"\"\"The scaling factor that converts from millimeters to pixels.\n\n    :attr:`mm` is a :class:`~kivy.properties.AliasProperty` containing the\n    factor. E.g in KV: ``width: self.texture_size[0] + 10 * Metrics.mm`` will\n    update width when :attr:`mm` changes from a screen configuration change.\n    \"\"\"\n\n    def reset_metrics(self):\n        \"\"\"Resets the dpi/density/fontscale to the platform values, overwriting\n        any manually set values.\n        \"\"\"\n        self.dpi = self.get_dpi(force_recompute=True)\n        self.density = self.get_density(force_recompute=True)\n        self.fontscale = self.get_fontscale(force_recompute=True)\n\n    def reset_dpi(self, *args):\n        \"\"\"Resets the dpi (and possibly density) to the platform values,\n        overwriting any manually set values.\n        \"\"\"\n        self.dpi = self.get_dpi(force_recompute=True)\n\n    def _set_cached_scaling(self):\n        dispatch_pixel_scale()",
  "def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.fbind('dpi', dispatch_pixel_scale)\n        self.fbind('density', dispatch_pixel_scale)\n        self.fbind('fontscale', dispatch_pixel_scale)",
  "def get_dpi(self, force_recompute=False):\n        if not force_recompute and self._dpi is not None:\n            return self._dpi\n\n        if platform == 'android':\n            if USE_SDL2:\n                import jnius\n                Hardware = jnius.autoclass('org.renpy.android.Hardware')\n                value = Hardware.getDPI()\n            else:\n                import android\n                value = android.get_dpi()\n        elif platform == 'ios':\n            import ios\n            value = ios.get_dpi()\n        else:\n            # for all other platforms..\n            from kivy.base import EventLoop\n            EventLoop.ensure_window()\n            value = EventLoop.window.dpi\n\n        # because dp prop binds to dpi etc. its getter will be executed\n        # before dispatch_pixel_scale bound to dpi was called, so we need to\n        # call this to make sure it's updated\n        sync_pixel_scale(dpi=value)\n        return value",
  "def set_dpi(self, value):\n        self._dpi = value\n        sync_pixel_scale(dpi=value)\n        return True",
  "def get_dpi_rounded(self):\n        dpi = self.dpi\n        if dpi < 140:\n            return 120\n        elif dpi < 200:\n            return 160\n        elif dpi < 280:\n            return 240\n        return 320",
  "def get_density(self, force_recompute=False):\n        if not force_recompute and self._density is not None:\n            return self._density\n\n        value = 1.0\n        if platform == 'android':\n            import jnius\n            Hardware = jnius.autoclass('org.renpy.android.Hardware')\n            value = Hardware.metrics.scaledDensity\n        elif platform == 'ios':\n            import ios\n            value = ios.get_scale()\n        elif platform in ('macosx', 'win'):\n            value = self.dpi / 96.\n\n        sync_pixel_scale(density=value)\n        return value",
  "def set_density(self, value):\n        self._density = value\n        sync_pixel_scale(density=value)\n        return True",
  "def get_fontscale(self, force_recompute=False):\n        if not force_recompute and self._fontscale is not None:\n            return self._fontscale\n\n        value = 1.0\n        if platform == 'android':\n            from jnius import autoclass\n            if USE_SDL2:\n                PythonActivity = autoclass('org.kivy.android.PythonActivity')\n            else:\n                PythonActivity = autoclass('org.renpy.android.PythonActivity')\n            config = PythonActivity.mActivity.getResources().getConfiguration()\n            value = config.fontScale\n\n        sync_pixel_scale(fontscale=value)\n        return value",
  "def set_fontscale(self, value):\n        self._fontscale = value\n        sync_pixel_scale(fontscale=value)\n        return True",
  "def get_in(self):\n        # we bind to all dpi, density, fontscale, even though not all may be\n        # used for a specific suffix, because we don't want to rely on the\n        # internal details of dpi2px. But it will be one of the three. But it's\n        # an issue, since it won't trigger the prop if the value doesn't change\n        return dpi2px(1, 'in')",
  "def get_dp(self):\n        return dpi2px(1, 'dp')",
  "def get_sp(self):\n        return dpi2px(1, 'sp')",
  "def get_pt(self):\n        return dpi2px(1, 'pt')",
  "def get_cm(self):\n        return dpi2px(1, 'cm')",
  "def get_mm(self):\n        return dpi2px(1, 'mm')",
  "def reset_metrics(self):\n        \"\"\"Resets the dpi/density/fontscale to the platform values, overwriting\n        any manually set values.\n        \"\"\"\n        self.dpi = self.get_dpi(force_recompute=True)\n        self.density = self.get_density(force_recompute=True)\n        self.fontscale = self.get_fontscale(force_recompute=True)",
  "def reset_dpi(self, *args):\n        \"\"\"Resets the dpi (and possibly density) to the platform values,\n        overwriting any manually set values.\n        \"\"\"\n        self.dpi = self.get_dpi(force_recompute=True)",
  "def _set_cached_scaling(self):\n        dispatch_pixel_scale()",
  "class FactoryException(Exception):\n    pass",
  "class FactoryBase(object):\n\n    def __init__(self):\n        super(FactoryBase, self).__init__()\n        self.classes = {}\n\n    @classmethod\n    def create_from(cls, factory):\n        \"\"\"Creates a instance of the class, and initializes to the state of\n        ``factory``.\n\n        :param factory: The factory to initialize from.\n        :return: A new instance of this class.\n        \"\"\"\n        obj = cls()\n        obj.classes = copy.copy(factory.classes)\n        return obj\n\n    def is_template(self, classname):\n        '''Return True if the classname is a template from the\n        :class:`~kivy.lang.Builder`.\n\n        .. versionadded:: 1.0.5\n        '''\n        if classname in self.classes:\n            return self.classes[classname]['is_template']\n        else:\n            return False\n\n    def register(self, classname, cls=None, module=None, is_template=False,\n                 baseclasses=None, filename=None, warn=False):\n        '''Register a new classname referring to a real class or\n        class definition in a module. Warn, if True will emit a warning message\n        when a class is re-declared.\n\n        .. versionchanged:: 1.9.0\n            `warn` was added.\n\n        .. versionchanged:: 1.7.0\n            :attr:`baseclasses` and :attr:`filename` added\n\n        .. versionchanged:: 1.0.5\n            :attr:`is_template` has been added in 1.0.5.\n        '''\n        if cls is None and module is None and baseclasses is None:\n            raise ValueError(\n                'You must specify either cls= or module= or baseclasses =')\n        if classname in self.classes:\n            if warn:\n                info = self.classes[classname]\n                Logger.warning('Factory: Ignored class \"{}\" re-declaration. '\n                'Current -  module: {}, cls: {}, baseclass: {}, filename: {}. '\n                'Ignored -  module: {}, cls: {}, baseclass: {}, filename: {}.'.\n                format(classname, info['module'], info['cls'],\n                       info['baseclasses'], info['filename'], module, cls,\n                       baseclasses, filename))\n            return\n        self.classes[classname] = {\n            'module': module,\n            'cls': cls,\n            'is_template': is_template,\n            'baseclasses': baseclasses,\n            'filename': filename}\n\n    def unregister(self, *classnames):\n        '''Unregisters the classnames previously registered via the\n        register method. This allows the same classnames to be re-used in\n        different contexts.\n\n        .. versionadded:: 1.7.1\n        '''\n        for classname in classnames:\n            if classname in self.classes:\n                self.classes.pop(classname)\n\n    def unregister_from_filename(self, filename):\n        '''Unregister all the factory objects related to the filename passed in\n        the parameter.\n\n        .. versionadded:: 1.7.0\n        '''\n        to_remove = [x for x in self.classes\n                     if self.classes[x]['filename'] == filename]\n        for name in to_remove:\n            del self.classes[name]\n\n    def __getattr__(self, name):\n        classes = self.classes\n        if name not in classes:\n            if name[0] == name[0].lower():\n                # if trying to access attributes like checking for `bind`\n                # then raise AttributeError\n                raise AttributeError(\n                    'First letter of class name <%s> is in lowercase' % name)\n            raise FactoryException('Unknown class <%s>' % name)\n\n        item = classes[name]\n        cls = item['cls']\n\n        # No class to return, import the module\n        if cls is None:\n            if item['module']:\n                module = importlib.__import__(\n                    name=item['module'],\n                    fromlist='*',\n                    level=0  # force absolute\n                )\n                if not hasattr(module, name):\n                    raise FactoryException(\n                        'No class named <%s> in module <%s>' % (\n                            name, item['module']))\n                cls = item['cls'] = getattr(module, name)\n\n            elif item['baseclasses']:\n                rootwidgets = []\n                for basecls in item['baseclasses'].split('+'):\n                    rootwidgets.append(Factory.get(basecls))\n                cls = item['cls'] = type(str(name), tuple(rootwidgets), {})\n\n            else:\n                raise FactoryException('No information to create the class')\n\n        return cls\n\n    get = __getattr__",
  "def __init__(self):\n        super(FactoryBase, self).__init__()\n        self.classes = {}",
  "def create_from(cls, factory):\n        \"\"\"Creates a instance of the class, and initializes to the state of\n        ``factory``.\n\n        :param factory: The factory to initialize from.\n        :return: A new instance of this class.\n        \"\"\"\n        obj = cls()\n        obj.classes = copy.copy(factory.classes)\n        return obj",
  "def is_template(self, classname):\n        '''Return True if the classname is a template from the\n        :class:`~kivy.lang.Builder`.\n\n        .. versionadded:: 1.0.5\n        '''\n        if classname in self.classes:\n            return self.classes[classname]['is_template']\n        else:\n            return False",
  "def register(self, classname, cls=None, module=None, is_template=False,\n                 baseclasses=None, filename=None, warn=False):\n        '''Register a new classname referring to a real class or\n        class definition in a module. Warn, if True will emit a warning message\n        when a class is re-declared.\n\n        .. versionchanged:: 1.9.0\n            `warn` was added.\n\n        .. versionchanged:: 1.7.0\n            :attr:`baseclasses` and :attr:`filename` added\n\n        .. versionchanged:: 1.0.5\n            :attr:`is_template` has been added in 1.0.5.\n        '''\n        if cls is None and module is None and baseclasses is None:\n            raise ValueError(\n                'You must specify either cls= or module= or baseclasses =')\n        if classname in self.classes:\n            if warn:\n                info = self.classes[classname]\n                Logger.warning('Factory: Ignored class \"{}\" re-declaration. '\n                'Current -  module: {}, cls: {}, baseclass: {}, filename: {}. '\n                'Ignored -  module: {}, cls: {}, baseclass: {}, filename: {}.'.\n                format(classname, info['module'], info['cls'],\n                       info['baseclasses'], info['filename'], module, cls,\n                       baseclasses, filename))\n            return\n        self.classes[classname] = {\n            'module': module,\n            'cls': cls,\n            'is_template': is_template,\n            'baseclasses': baseclasses,\n            'filename': filename}",
  "def unregister(self, *classnames):\n        '''Unregisters the classnames previously registered via the\n        register method. This allows the same classnames to be re-used in\n        different contexts.\n\n        .. versionadded:: 1.7.1\n        '''\n        for classname in classnames:\n            if classname in self.classes:\n                self.classes.pop(classname)",
  "def unregister_from_filename(self, filename):\n        '''Unregister all the factory objects related to the filename passed in\n        the parameter.\n\n        .. versionadded:: 1.7.0\n        '''\n        to_remove = [x for x in self.classes\n                     if self.classes[x]['filename'] == filename]\n        for name in to_remove:\n            del self.classes[name]",
  "def __getattr__(self, name):\n        classes = self.classes\n        if name not in classes:\n            if name[0] == name[0].lower():\n                # if trying to access attributes like checking for `bind`\n                # then raise AttributeError\n                raise AttributeError(\n                    'First letter of class name <%s> is in lowercase' % name)\n            raise FactoryException('Unknown class <%s>' % name)\n\n        item = classes[name]\n        cls = item['cls']\n\n        # No class to return, import the module\n        if cls is None:\n            if item['module']:\n                module = importlib.__import__(\n                    name=item['module'],\n                    fromlist='*',\n                    level=0  # force absolute\n                )\n                if not hasattr(module, name):\n                    raise FactoryException(\n                        'No class named <%s> in module <%s>' % (\n                            name, item['module']))\n                cls = item['cls'] = getattr(module, name)\n\n            elif item['baseclasses']:\n                rootwidgets = []\n                for basecls in item['baseclasses'].split('+'):\n                    rootwidgets.append(Factory.get(basecls))\n                cls = item['cls'] = type(str(name), tuple(rootwidgets), {})\n\n            else:\n                raise FactoryException('No information to create the class')\n\n        return cls",
  "class App(EventDispatcher):\n    ''' Application class, see module documentation for more information.\n\n    :Events:\n        `on_start`:\n            Fired when the application is being started (before the\n            :func:`~kivy.base.runTouchApp` call.\n        `on_stop`:\n            Fired when the application stops.\n        `on_pause`:\n            Fired when the application is paused by the OS.\n        `on_resume`:\n            Fired when the application is resumed from pause by the OS. Beware:\n            you have no guarantee that this event will be fired after the\n            `on_pause` event has been called.\n\n    .. versionchanged:: 1.7.0\n        Parameter `kv_file` added.\n\n    .. versionchanged:: 1.8.0\n        Parameters `kv_file` and `kv_directory` are now properties of App.\n    '''\n\n    title = StringProperty(None)\n    '''\n    Title of your application. You can set this as follows::\n\n        class MyApp(App):\n            def build(self):\n                self.title = 'Hello world'\n\n    .. versionadded:: 1.0.5\n\n    .. versionchanged:: 1.8.0\n        `title` is now a :class:`~kivy.properties.StringProperty`. Don't\n        set the title in the class as previously stated in the documentation.\n\n    .. note::\n\n        For Kivy < 1.8.0, you can set this as follows::\n\n            class MyApp(App):\n                title = 'Custom title'\n\n        If you want to dynamically change the title, you can do::\n\n            from kivy.base import EventLoop\n            EventLoop.window.title = 'New title'\n\n    '''\n\n    icon = StringProperty(None)\n    '''Icon of your application.\n    The icon can be located in the same directory as your main file. You can\n    set this as follows::\n\n        class MyApp(App):\n            def build(self):\n                self.icon = 'myicon.png'\n\n    .. versionadded:: 1.0.5\n\n    .. versionchanged:: 1.8.0\n        `icon` is now a :class:`~kivy.properties.StringProperty`. Don't set the\n        icon in the class as previously stated in the documentation.\n\n    .. note::\n\n        For Kivy prior to 1.8.0, you need to set this as follows::\n\n            class MyApp(App):\n                icon = 'customicon.png'\n\n        Recommended 256x256 or 1024x1024? for GNU/Linux and Mac OSX\n        32x32 for Windows7 or less. <= 256x256 for windows 8\n        256x256 does work (on Windows 8 at least), but is scaled\n        down and doesn't look as good as a 32x32 icon.\n    '''\n\n    use_kivy_settings = True\n    '''.. versionadded:: 1.0.7\n\n    If True, the application settings will also include the Kivy settings. If\n    you don't want the user to change any kivy settings from your settings UI,\n    change this to False.\n    '''\n\n    settings_cls = ObjectProperty(None)\n    '''.. versionadded:: 1.8.0\n\n    The class used to construct the settings panel and\n    the instance passed to :meth:`build_config`. You should\n    use either :class:`~kivy.uix.settings.Settings` or one of the provided\n    subclasses with different layouts\n    (:class:`~kivy.uix.settings.SettingsWithSidebar`,\n    :class:`~kivy.uix.settings.SettingsWithSpinner`,\n    :class:`~kivy.uix.settings.SettingsWithTabbedPanel`,\n    :class:`~kivy.uix.settings.SettingsWithNoMenu`). You can also create your\n    own Settings subclass. See the documentation\n    of :mod:`~kivy.uix.settings.Settings` for more information.\n\n    :attr:`~App.settings_cls` is an :class:`~kivy.properties.ObjectProperty`\n    and defaults to :class:`~kivy.uix.settings.SettingsWithSpinner` which\n    displays settings panels with a spinner to switch between them. If you set\n    a string, the :class:`~kivy.factory.Factory` will be used to resolve the\n    class.\n\n    '''\n\n    kv_directory = StringProperty(None)\n    '''Path of the directory where application kv is stored, defaults to None\n\n    .. versionadded:: 1.8.0\n\n    If a kv_directory is set, it will be used to get the initial kv file. By\n    default, the file is assumed to be in the same directory as the current App\n    definition file.\n    '''\n\n    kv_file = StringProperty(None)\n    '''Filename of the Kv file to load, defaults to None.\n\n    .. versionadded:: 1.8.0\n\n    If a kv_file is set, it will be loaded when the application starts. The\n    loading of the \"default\" kv file will be prevented.\n    '''\n\n    # Return the current running App instance\n    _running_app = None\n\n    __events__ = ('on_start', 'on_stop', 'on_pause', 'on_resume',\n                  'on_config_change', )\n\n    # Stored so that we only need to determine this once\n    _user_data_dir = \"\"\n\n    def __init__(self, **kwargs):\n        App._running_app = self\n        self._app_directory = None\n        self._app_name = None\n        self._app_settings = None\n        self._app_window = None\n        super(App, self).__init__(**kwargs)\n        self.built = False\n\n        #: Options passed to the __init__ of the App\n        self.options = kwargs\n\n        #: Returns an instance of the :class:`~kivy.config.ConfigParser` for\n        #: the application configuration. You can use this to query some config\n        #: tokens in the :meth:`build` method.\n        self.config = None\n\n        #: The *root* widget returned by the :meth:`build` method or by the\n        #: :meth:`load_kv` method if the kv file contains a root widget.\n        self.root = None\n\n    def build(self):\n        '''Initializes the application; it will be called only once.\n        If this method returns a widget (tree), it will be used as the root\n        widget and added to the window.\n\n        :return:\n            None or a root :class:`~kivy.uix.widget.Widget` instance\n            if no self.root exists.'''\n\n        if not self.root:\n            return Widget()\n\n    def build_config(self, config):\n        '''.. versionadded:: 1.0.7\n\n        This method is called before the application is initialized to\n        construct your :class:`~kivy.config.ConfigParser` object. This\n        is where you can put any default section / key / value for your\n        config. If anything is set, the configuration will be\n        automatically saved in the file returned by\n        :meth:`get_application_config`.\n\n        :Parameters:\n            `config`: :class:`~kivy.config.ConfigParser`\n                Use this to add default section / key / value items\n\n        '''\n\n    def build_settings(self, settings):\n        '''.. versionadded:: 1.0.7\n\n        This method is called when the user (or you) want to show the\n        application settings. It is called once when the settings panel\n        is first opened, after which the panel is cached. It may be\n        called again if the cached settings panel is removed by\n        :meth:`destroy_settings`.\n\n        You can use this method to add settings panels and to\n        customise the settings widget e.g. by changing the sidebar\n        width. See the module documentation for full details.\n\n        :Parameters:\n            `settings`: :class:`~kivy.uix.settings.Settings`\n                Settings instance for adding panels\n\n        '''\n\n    def load_kv(self, filename=None):\n        '''This method is invoked the first time the app is being run if no\n        widget tree has been constructed before for this app.\n        This method then looks for a matching kv file in the same directory as\n        the file that contains the application class.\n\n        For example, say you have a file named main.py that contains::\n\n            class ShowcaseApp(App):\n                pass\n\n        This method will search for a file named `showcase.kv` in\n        the directory that contains main.py. The name of the kv file has to be\n        the lowercase name of the class, without the 'App' postfix at the end\n        if it exists.\n\n        You can define rules and a root widget in your kv file::\n\n            <ClassName>: # this is a rule\n                ...\n\n            ClassName: # this is a root widget\n                ...\n\n        There must be only one root widget. See the :doc:`api-kivy.lang`\n        documentation for more information on how to create kv files. If your\n        kv file contains a root widget, it will be used as self.root, the root\n        widget for the application.\n\n        .. note::\n\n            This function is called from :meth:`run`, therefore, any widget\n            whose styling is defined in this kv file and is created before\n            :meth:`run` is called (e.g. in `__init__`), won't have its styling\n            applied. Note that :meth:`build` is called after :attr:`load_kv`\n            has been called.\n        '''\n        # Detect filename automatically if it was not specified.\n        if filename:\n            filename = resource_find(filename)\n        else:\n            try:\n                default_kv_directory = dirname(getfile(self.__class__))\n                if default_kv_directory == '':\n                    default_kv_directory = '.'\n            except TypeError:\n                # if it's a builtin module.. use the current dir.\n                default_kv_directory = '.'\n\n            kv_directory = self.kv_directory or default_kv_directory\n            clsname = self.__class__.__name__.lower()\n            if (clsname.endswith('app') and\n                    not isfile(join(kv_directory, '%s.kv' % clsname))):\n                clsname = clsname[:-3]\n            filename = join(kv_directory, '%s.kv' % clsname)\n\n        # Load KV file\n        Logger.debug('App: Loading kv <{0}>'.format(filename))\n        rfilename = resource_find(filename)\n        if rfilename is None or not exists(rfilename):\n            Logger.debug('App: kv <%s> not found' % filename)\n            return False\n        root = Builder.load_file(rfilename)\n        if root:\n            self.root = root\n        return True\n\n    def get_application_name(self):\n        '''Return the name of the application.\n        '''\n        if self.title is not None:\n            return self.title\n        clsname = self.__class__.__name__\n        if clsname.endswith('App'):\n            clsname = clsname[:-3]\n        return clsname\n\n    def get_application_icon(self):\n        '''Return the icon of the application.\n        '''\n        if not resource_find(self.icon):\n            return ''\n        else:\n            return resource_find(self.icon)\n\n    def get_application_config(self, defaultpath='%(appdir)s/%(appname)s.ini'):\n        '''\n        Return the filename of your application configuration. Depending\n        on the platform, the application file will be stored in\n        different locations:\n\n            - on iOS: <appdir>/Documents/.<appname>.ini\n            - on Android: <user_data_dir>/.<appname>.ini\n            - otherwise: <appdir>/<appname>.ini\n\n        When you are distributing your application on Desktops, please\n        note that if the application is meant to be installed\n        system-wide, the user might not have write-access to the\n        application directory. If you want to store user settings, you\n        should overload this method and change the default behavior to\n        save the configuration file in the user directory. ::\n\n            class TestApp(App):\n                def get_application_config(self):\n                    return super(TestApp, self).get_application_config(\n                        '~/.%(appname)s.ini')\n\n        Some notes:\n\n        - The tilda '~' will be expanded to the user directory.\n        - %(appdir)s will be replaced with the application :attr:`directory`\n        - %(appname)s will be replaced with the application :attr:`name`\n\n        .. versionadded:: 1.0.7\n\n        .. versionchanged:: 1.4.0\n            Customized the defaultpath for iOS and Android platforms. Added a\n            defaultpath parameter for desktop OS's (not applicable to iOS\n            and Android.)\n\n        .. versionchanged:: 1.11.0\n            Changed the Android version to make use of the\n            :attr:`~App.user_data_dir` and added a missing dot to the iOS\n            config file name.\n        '''\n\n        if platform == 'android':\n            return join(self.user_data_dir, '.{0}.ini'.format(self.name))\n        elif platform == 'ios':\n            defaultpath = '~/Documents/.%(appname)s.ini'\n        elif platform == 'win':\n            defaultpath = defaultpath.replace('/', sep)\n        return expanduser(defaultpath) % {\n            'appname': self.name, 'appdir': self.directory}\n\n    @property\n    def root_window(self):\n        '''.. versionadded:: 1.9.0\n\n        Returns the root window instance used by :meth:`run`.\n        '''\n        return self._app_window\n\n    def load_config(self):\n        '''(internal) This function is used for returning a ConfigParser with\n        the application configuration. It's doing 3 things:\n\n            #. Creating an instance of a ConfigParser\n            #. Loading the default configuration by calling\n               :meth:`build_config`, then\n            #. If it exists, it loads the application configuration file,\n               otherwise it creates one.\n\n        :return:\n            :class:`~kivy.config.ConfigParser` instance\n        '''\n        try:\n            config = ConfigParser.get_configparser('app')\n        except KeyError:\n            config = None\n        if config is None:\n            config = ConfigParser(name='app')\n        self.config = config\n        self.build_config(config)\n        # if no sections are created, that's mean the user don't have\n        # configuration.\n        if len(config.sections()) == 0:\n            return\n        # ok, the user have some sections, read the default file if exist\n        # or write it !\n        filename = self.get_application_config()\n        if filename is None:\n            return config\n        Logger.debug('App: Loading configuration <{0}>'.format(filename))\n        if exists(filename):\n            try:\n                config.read(filename)\n            except:\n                Logger.error('App: Corrupted config file, ignored.')\n                config.name = ''\n                try:\n                    config = ConfigParser.get_configparser('app')\n                except KeyError:\n                    config = None\n                if config is None:\n                    config = ConfigParser(name='app')\n                self.config = config\n                self.build_config(config)\n                pass\n        else:\n            Logger.debug('App: First configuration, create <{0}>'.format(\n                filename))\n            config.filename = filename\n            config.write()\n        return config\n\n    @property\n    def directory(self):\n        '''.. versionadded:: 1.0.7\n\n        Return the directory where the application lives.\n        '''\n        if self._app_directory is None:\n            try:\n                self._app_directory = dirname(getfile(self.__class__))\n                if self._app_directory == '':\n                    self._app_directory = '.'\n            except TypeError:\n                # if it's a builtin module.. use the current dir.\n                self._app_directory = '.'\n        return self._app_directory\n\n    def _get_user_data_dir(self):\n        # Determine and return the user_data_dir.\n        data_dir = \"\"\n        if platform == 'ios':\n            data_dir = expanduser(join('~/Documents', self.name))\n        elif platform == 'android':\n            from jnius import autoclass, cast\n            PythonActivity = autoclass('org.kivy.android.PythonActivity')\n            context = cast('android.content.Context', PythonActivity.mActivity)\n            file_p = cast('java.io.File', context.getFilesDir())\n            data_dir = file_p.getAbsolutePath()\n        elif platform == 'win':\n            data_dir = os.path.join(os.environ['APPDATA'], self.name)\n        elif platform == 'macosx':\n            data_dir = '~/Library/Application Support/{}'.format(self.name)\n            data_dir = expanduser(data_dir)\n        else:  # _platform == 'linux' or anything else...:\n            data_dir = os.environ.get('XDG_CONFIG_HOME', '~/.config')\n            data_dir = expanduser(join(data_dir, self.name))\n        if not exists(data_dir):\n            os.mkdir(data_dir)\n        return data_dir\n\n    @property\n    def user_data_dir(self):\n        '''\n        .. versionadded:: 1.7.0\n\n        Returns the path to the directory in the users file system which the\n        application can use to store additional data.\n\n        Different platforms have different conventions with regards to where\n        the user can store data such as preferences, saved games and settings.\n        This function implements these conventions. The <app_name> directory\n        is created when the property is called, unless it already exists.\n\n        On iOS, `~/Documents/<app_name>` is returned (which is inside the\n        app's sandbox).\n\n        On Windows, `%APPDATA%/<app_name>` is returned.\n\n        On OS X, `~/Library/Application Support/<app_name>` is returned.\n\n        On Linux, `$XDG_CONFIG_HOME/<app_name>` is returned.\n\n        On Android, `Context.GetFilesDir\n        <https://developer.android.com/reference/android/content/\\\nContext.html#getFilesDir()>`_ is returned.\n\n        .. versionchanged:: 1.11.0\n\n            On Android, this function previously returned\n            `/sdcard/<app_name>`. This folder became read-only by default\n            in Android API 26 and the user_data_dir has therefore been moved\n            to a writeable location.\n\n        '''\n        if self._user_data_dir == \"\":\n            self._user_data_dir = self._get_user_data_dir()\n        return self._user_data_dir\n\n    @property\n    def name(self):\n        '''.. versionadded:: 1.0.7\n\n        Return the name of the application based on the class name.\n        '''\n        if self._app_name is None:\n            clsname = self.__class__.__name__\n            if clsname.endswith('App'):\n                clsname = clsname[:-3]\n            self._app_name = clsname.lower()\n        return self._app_name\n\n    def _run_prepare(self):\n        if not self.built:\n            self.load_config()\n            self.load_kv(filename=self.kv_file)\n            root = self.build()\n            if root:\n                self.root = root\n        if self.root:\n            if not isinstance(self.root, Widget):\n                Logger.critical('App.root must be an _instance_ of Widget')\n                raise Exception('Invalid instance in App.root')\n            from kivy.core.window import Window\n            Window.add_widget(self.root)\n\n        # Check if the window is already created\n        from kivy.base import EventLoop\n        window = EventLoop.window\n        if window:\n            self._app_window = window\n            window.set_title(self.get_application_name())\n            icon = self.get_application_icon()\n            if icon:\n                window.set_icon(icon)\n            self._install_settings_keys(window)\n        else:\n            Logger.critical(\"Application: No window is created.\"\n                            \" Terminating application run.\")\n            return\n\n        self.dispatch('on_start')\n\n    def run(self):\n        '''Launches the app in standalone mode.\n        '''\n        self._run_prepare()\n        runTouchApp()\n        self._stop()\n\n    async def async_run(self, async_lib=None):\n        '''Identical to :meth:`run`, but is a coroutine and can be\n        scheduled in a running async event loop.\n\n        See :mod:`kivy.app` for example usage.\n\n        .. versionadded:: 2.0.0\n        '''\n        self._run_prepare()\n        await async_runTouchApp(async_lib=async_lib)\n        self._stop()\n\n    def stop(self, *largs):\n        '''Stop the application.\n\n        If you use this method, the whole application will stop by issuing\n        a call to :func:`~kivy.base.stopTouchApp`.\n        Except on Android, set Android state to stop, Kivy state then follows.\n        '''\n        if platform == 'android':\n            from android import mActivity\n            mActivity.finishAndRemoveTask()\n        else:\n            self._stop()\n\n    def _stop(self, *largs):\n        self.dispatch('on_stop')\n        stopTouchApp()\n\n        # Clear the window children\n        if self._app_window:\n            for child in self._app_window.children:\n                self._app_window.remove_widget(child)\n        App._running_app = None\n\n    def pause(self, *largs):\n        '''Pause the application.\n\n        On Android set OS state to pause, Kivy app state follows.\n        No functionality on other OS.\n        .. versionadded:: 2.2.0\n        '''\n        if platform == 'android':\n            from android import mActivity\n            mActivity.moveTaskToBack(True)\n        else:\n            Logger.info('App.pause() is not available on this OS.')\n\n    def on_start(self):\n        '''Event handler for the `on_start` event which is fired after\n        initialization (after build() has been called) but before the\n        application has started running.\n        '''\n        pass\n\n    def on_stop(self):\n        '''Event handler for the `on_stop` event which is fired when the\n        application has finished running (i.e. the window is about to be\n        closed).\n        '''\n        pass\n\n    def on_pause(self):\n        '''Event handler called when Pause mode is requested. You should\n        return True if your app can go into Pause mode, otherwise\n        return False and your application will be stopped.\n\n        You cannot control when the application is going to go into this mode.\n        It's determined by the Operating System and mostly used for mobile\n        devices (android/ios) and for resizing.\n\n        The default return value is True.\n\n        .. versionadded:: 1.1.0\n        .. versionchanged:: 1.10.0\n            The default return value is now True.\n        '''\n        return True\n\n    def on_resume(self):\n        '''Event handler called when your application is resuming from\n        the Pause mode.\n\n        .. versionadded:: 1.1.0\n\n        .. warning::\n\n            When resuming, the OpenGL Context might have been damaged / freed.\n            This is where you can reconstruct some of your OpenGL state\n            e.g. FBO content.\n        '''\n        pass\n\n    @staticmethod\n    def get_running_app():\n        '''Return the currently running application instance.\n\n        .. versionadded:: 1.1.0\n        '''\n        return App._running_app\n\n    def on_config_change(self, config, section, key, value):\n        '''Event handler fired when a configuration token has been changed by\n        the settings page.\n\n        .. versionchanged:: 1.10.1\n           Added corresponding ``on_config_change`` event.\n        '''\n        pass\n\n    def open_settings(self, *largs):\n        '''Open the application settings panel. It will be created the very\n        first time, or recreated if the previously cached panel has been\n        removed by :meth:`destroy_settings`. The settings panel will be\n        displayed with the\n        :meth:`display_settings` method, which by default adds the\n        settings panel to the Window attached to your application. You\n        should override that method if you want to display the\n        settings panel differently.\n\n        :return:\n            True if the settings has been opened.\n\n        '''\n        if self._app_settings is None:\n            self._app_settings = self.create_settings()\n        displayed = self.display_settings(self._app_settings)\n        if displayed:\n            return True\n        return False\n\n    def display_settings(self, settings):\n        '''.. versionadded:: 1.8.0\n\n        Display the settings panel. By default, the panel is drawn directly\n        on top of the window. You can define other behavior by overriding\n        this method, such as adding it to a ScreenManager or Popup.\n\n        You should return True if the display is successful, otherwise False.\n\n        :Parameters:\n            `settings`: :class:`~kivy.uix.settings.Settings`\n                You can modify this object in order to modify the settings\n                display.\n\n        '''\n        win = self._app_window\n        if not win:\n            raise Exception('No windows are set on the application, you cannot'\n                            ' open settings yet.')\n        if settings not in win.children:\n            win.add_widget(settings)\n            return True\n        return False\n\n    def close_settings(self, *largs):\n        '''Close the previously opened settings panel.\n\n        :return:\n            True if the settings has been closed.\n        '''\n        win = self._app_window\n        settings = self._app_settings\n        if win is None or settings is None:\n            return\n        if settings in win.children:\n            win.remove_widget(settings)\n            return True\n        return False\n\n    def create_settings(self):\n        '''Create the settings panel. This method will normally\n        be called only one time per\n        application life-time and the result is cached internally,\n        but it may be called again if the cached panel is removed\n        by :meth:`destroy_settings`.\n\n        By default, it will build a settings panel according to\n        :attr:`settings_cls`, call :meth:`build_settings`, add a Kivy panel if\n        :attr:`use_kivy_settings` is True, and bind to\n        on_close/on_config_change.\n\n        If you want to plug your own way of doing settings, without the Kivy\n        panel or close/config change events, this is the method you want to\n        overload.\n\n        .. versionadded:: 1.8.0\n        '''\n        if self.settings_cls is None:\n            from kivy.uix.settings import SettingsWithSpinner\n            self.settings_cls = SettingsWithSpinner\n        elif isinstance(self.settings_cls, string_types):\n            self.settings_cls = Factory.get(self.settings_cls)\n        s = self.settings_cls()\n        self.build_settings(s)\n        if self.use_kivy_settings:\n            s.add_kivy_panel()\n        s.bind(on_close=self.close_settings,\n               on_config_change=self._on_config_change)\n        return s\n\n    def destroy_settings(self):\n        '''.. versionadded:: 1.8.0\n\n        Dereferences the current settings panel if one\n        exists. This means that when :meth:`App.open_settings` is next\n        run, a new panel will be created and displayed. It doesn't\n        affect any of the contents of the panel, but lets you (for\n        instance) refresh the settings panel layout if you have\n        changed the settings widget in response to a screen size\n        change.\n\n        If you have modified :meth:`~App.open_settings` or\n        :meth:`~App.display_settings`, you should be careful to\n        correctly detect if the previous settings widget has been\n        destroyed.\n\n        '''\n        if self._app_settings is not None:\n            self._app_settings = None\n\n    #\n    # privates\n    #\n\n    def _on_config_change(self, *largs):\n        self.dispatch('on_config_change', *largs[1:])\n\n    def _install_settings_keys(self, window):\n        window.bind(on_keyboard=self._on_keyboard_settings)\n\n    def _on_keyboard_settings(self, window, *largs):\n        key = largs[0]\n        setting_key = 282  # F1\n\n        # android hack, if settings key is pygame K_MENU\n        if platform == 'android' and not USE_SDL2:\n            import pygame\n            setting_key = pygame.K_MENU\n\n        if key == setting_key:\n            # toggle settings panel\n            if not self.open_settings():\n                self.close_settings()\n            return True\n        if key == 27:\n            return self.close_settings()\n\n    def on_title(self, instance, title):\n        if self._app_window:\n            self._app_window.set_title(title)\n\n    def on_icon(self, instance, icon):\n        if self._app_window:\n            self._app_window.set_icon(self.get_application_icon())",
  "def __init__(self, **kwargs):\n        App._running_app = self\n        self._app_directory = None\n        self._app_name = None\n        self._app_settings = None\n        self._app_window = None\n        super(App, self).__init__(**kwargs)\n        self.built = False\n\n        #: Options passed to the __init__ of the App\n        self.options = kwargs\n\n        #: Returns an instance of the :class:`~kivy.config.ConfigParser` for\n        #: the application configuration. You can use this to query some config\n        #: tokens in the :meth:`build` method.\n        self.config = None\n\n        #: The *root* widget returned by the :meth:`build` method or by the\n        #: :meth:`load_kv` method if the kv file contains a root widget.\n        self.root = None",
  "def build(self):\n        '''Initializes the application; it will be called only once.\n        If this method returns a widget (tree), it will be used as the root\n        widget and added to the window.\n\n        :return:\n            None or a root :class:`~kivy.uix.widget.Widget` instance\n            if no self.root exists.'''\n\n        if not self.root:\n            return Widget()",
  "def build_config(self, config):\n        '''.. versionadded:: 1.0.7\n\n        This method is called before the application is initialized to\n        construct your :class:`~kivy.config.ConfigParser` object. This\n        is where you can put any default section / key / value for your\n        config. If anything is set, the configuration will be\n        automatically saved in the file returned by\n        :meth:`get_application_config`.\n\n        :Parameters:\n            `config`: :class:`~kivy.config.ConfigParser`\n                Use this to add default section / key / value items\n\n        '''",
  "def build_settings(self, settings):\n        '''.. versionadded:: 1.0.7\n\n        This method is called when the user (or you) want to show the\n        application settings. It is called once when the settings panel\n        is first opened, after which the panel is cached. It may be\n        called again if the cached settings panel is removed by\n        :meth:`destroy_settings`.\n\n        You can use this method to add settings panels and to\n        customise the settings widget e.g. by changing the sidebar\n        width. See the module documentation for full details.\n\n        :Parameters:\n            `settings`: :class:`~kivy.uix.settings.Settings`\n                Settings instance for adding panels\n\n        '''",
  "def load_kv(self, filename=None):\n        '''This method is invoked the first time the app is being run if no\n        widget tree has been constructed before for this app.\n        This method then looks for a matching kv file in the same directory as\n        the file that contains the application class.\n\n        For example, say you have a file named main.py that contains::\n\n            class ShowcaseApp(App):\n                pass\n\n        This method will search for a file named `showcase.kv` in\n        the directory that contains main.py. The name of the kv file has to be\n        the lowercase name of the class, without the 'App' postfix at the end\n        if it exists.\n\n        You can define rules and a root widget in your kv file::\n\n            <ClassName>: # this is a rule\n                ...\n\n            ClassName: # this is a root widget\n                ...\n\n        There must be only one root widget. See the :doc:`api-kivy.lang`\n        documentation for more information on how to create kv files. If your\n        kv file contains a root widget, it will be used as self.root, the root\n        widget for the application.\n\n        .. note::\n\n            This function is called from :meth:`run`, therefore, any widget\n            whose styling is defined in this kv file and is created before\n            :meth:`run` is called (e.g. in `__init__`), won't have its styling\n            applied. Note that :meth:`build` is called after :attr:`load_kv`\n            has been called.\n        '''\n        # Detect filename automatically if it was not specified.\n        if filename:\n            filename = resource_find(filename)\n        else:\n            try:\n                default_kv_directory = dirname(getfile(self.__class__))\n                if default_kv_directory == '':\n                    default_kv_directory = '.'\n            except TypeError:\n                # if it's a builtin module.. use the current dir.\n                default_kv_directory = '.'\n\n            kv_directory = self.kv_directory or default_kv_directory\n            clsname = self.__class__.__name__.lower()\n            if (clsname.endswith('app') and\n                    not isfile(join(kv_directory, '%s.kv' % clsname))):\n                clsname = clsname[:-3]\n            filename = join(kv_directory, '%s.kv' % clsname)\n\n        # Load KV file\n        Logger.debug('App: Loading kv <{0}>'.format(filename))\n        rfilename = resource_find(filename)\n        if rfilename is None or not exists(rfilename):\n            Logger.debug('App: kv <%s> not found' % filename)\n            return False\n        root = Builder.load_file(rfilename)\n        if root:\n            self.root = root\n        return True",
  "def get_application_name(self):\n        '''Return the name of the application.\n        '''\n        if self.title is not None:\n            return self.title\n        clsname = self.__class__.__name__\n        if clsname.endswith('App'):\n            clsname = clsname[:-3]\n        return clsname",
  "def get_application_icon(self):\n        '''Return the icon of the application.\n        '''\n        if not resource_find(self.icon):\n            return ''\n        else:\n            return resource_find(self.icon)",
  "def get_application_config(self, defaultpath='%(appdir)s/%(appname)s.ini'):\n        '''\n        Return the filename of your application configuration. Depending\n        on the platform, the application file will be stored in\n        different locations:\n\n            - on iOS: <appdir>/Documents/.<appname>.ini\n            - on Android: <user_data_dir>/.<appname>.ini\n            - otherwise: <appdir>/<appname>.ini\n\n        When you are distributing your application on Desktops, please\n        note that if the application is meant to be installed\n        system-wide, the user might not have write-access to the\n        application directory. If you want to store user settings, you\n        should overload this method and change the default behavior to\n        save the configuration file in the user directory. ::\n\n            class TestApp(App):\n                def get_application_config(self):\n                    return super(TestApp, self).get_application_config(\n                        '~/.%(appname)s.ini')\n\n        Some notes:\n\n        - The tilda '~' will be expanded to the user directory.\n        - %(appdir)s will be replaced with the application :attr:`directory`\n        - %(appname)s will be replaced with the application :attr:`name`\n\n        .. versionadded:: 1.0.7\n\n        .. versionchanged:: 1.4.0\n            Customized the defaultpath for iOS and Android platforms. Added a\n            defaultpath parameter for desktop OS's (not applicable to iOS\n            and Android.)\n\n        .. versionchanged:: 1.11.0\n            Changed the Android version to make use of the\n            :attr:`~App.user_data_dir` and added a missing dot to the iOS\n            config file name.\n        '''\n\n        if platform == 'android':\n            return join(self.user_data_dir, '.{0}.ini'.format(self.name))\n        elif platform == 'ios':\n            defaultpath = '~/Documents/.%(appname)s.ini'\n        elif platform == 'win':\n            defaultpath = defaultpath.replace('/', sep)\n        return expanduser(defaultpath) % {\n            'appname': self.name, 'appdir': self.directory}",
  "def root_window(self):\n        '''.. versionadded:: 1.9.0\n\n        Returns the root window instance used by :meth:`run`.\n        '''\n        return self._app_window",
  "def load_config(self):\n        '''(internal) This function is used for returning a ConfigParser with\n        the application configuration. It's doing 3 things:\n\n            #. Creating an instance of a ConfigParser\n            #. Loading the default configuration by calling\n               :meth:`build_config`, then\n            #. If it exists, it loads the application configuration file,\n               otherwise it creates one.\n\n        :return:\n            :class:`~kivy.config.ConfigParser` instance\n        '''\n        try:\n            config = ConfigParser.get_configparser('app')\n        except KeyError:\n            config = None\n        if config is None:\n            config = ConfigParser(name='app')\n        self.config = config\n        self.build_config(config)\n        # if no sections are created, that's mean the user don't have\n        # configuration.\n        if len(config.sections()) == 0:\n            return\n        # ok, the user have some sections, read the default file if exist\n        # or write it !\n        filename = self.get_application_config()\n        if filename is None:\n            return config\n        Logger.debug('App: Loading configuration <{0}>'.format(filename))\n        if exists(filename):\n            try:\n                config.read(filename)\n            except:\n                Logger.error('App: Corrupted config file, ignored.')\n                config.name = ''\n                try:\n                    config = ConfigParser.get_configparser('app')\n                except KeyError:\n                    config = None\n                if config is None:\n                    config = ConfigParser(name='app')\n                self.config = config\n                self.build_config(config)\n                pass\n        else:\n            Logger.debug('App: First configuration, create <{0}>'.format(\n                filename))\n            config.filename = filename\n            config.write()\n        return config",
  "def directory(self):\n        '''.. versionadded:: 1.0.7\n\n        Return the directory where the application lives.\n        '''\n        if self._app_directory is None:\n            try:\n                self._app_directory = dirname(getfile(self.__class__))\n                if self._app_directory == '':\n                    self._app_directory = '.'\n            except TypeError:\n                # if it's a builtin module.. use the current dir.\n                self._app_directory = '.'\n        return self._app_directory",
  "def _get_user_data_dir(self):\n        # Determine and return the user_data_dir.\n        data_dir = \"\"\n        if platform == 'ios':\n            data_dir = expanduser(join('~/Documents', self.name))\n        elif platform == 'android':\n            from jnius import autoclass, cast\n            PythonActivity = autoclass('org.kivy.android.PythonActivity')\n            context = cast('android.content.Context', PythonActivity.mActivity)\n            file_p = cast('java.io.File', context.getFilesDir())\n            data_dir = file_p.getAbsolutePath()\n        elif platform == 'win':\n            data_dir = os.path.join(os.environ['APPDATA'], self.name)\n        elif platform == 'macosx':\n            data_dir = '~/Library/Application Support/{}'.format(self.name)\n            data_dir = expanduser(data_dir)\n        else:  # _platform == 'linux' or anything else...:\n            data_dir = os.environ.get('XDG_CONFIG_HOME', '~/.config')\n            data_dir = expanduser(join(data_dir, self.name))\n        if not exists(data_dir):\n            os.mkdir(data_dir)\n        return data_dir",
  "def user_data_dir(self):\n        '''\n        .. versionadded:: 1.7.0\n\n        Returns the path to the directory in the users file system which the\n        application can use to store additional data.\n\n        Different platforms have different conventions with regards to where\n        the user can store data such as preferences, saved games and settings.\n        This function implements these conventions. The <app_name> directory\n        is created when the property is called, unless it already exists.\n\n        On iOS, `~/Documents/<app_name>` is returned (which is inside the\n        app's sandbox).\n\n        On Windows, `%APPDATA%/<app_name>` is returned.\n\n        On OS X, `~/Library/Application Support/<app_name>` is returned.\n\n        On Linux, `$XDG_CONFIG_HOME/<app_name>` is returned.\n\n        On Android, `Context.GetFilesDir\n        <https://developer.android.com/reference/android/content/\\\nContext.html#getFilesDir()>`_ is returned.\n\n        .. versionchanged:: 1.11.0\n\n            On Android, this function previously returned\n            `/sdcard/<app_name>`. This folder became read-only by default\n            in Android API 26 and the user_data_dir has therefore been moved\n            to a writeable location.\n\n        '''\n        if self._user_data_dir == \"\":\n            self._user_data_dir = self._get_user_data_dir()\n        return self._user_data_dir",
  "def name(self):\n        '''.. versionadded:: 1.0.7\n\n        Return the name of the application based on the class name.\n        '''\n        if self._app_name is None:\n            clsname = self.__class__.__name__\n            if clsname.endswith('App'):\n                clsname = clsname[:-3]\n            self._app_name = clsname.lower()\n        return self._app_name",
  "def _run_prepare(self):\n        if not self.built:\n            self.load_config()\n            self.load_kv(filename=self.kv_file)\n            root = self.build()\n            if root:\n                self.root = root\n        if self.root:\n            if not isinstance(self.root, Widget):\n                Logger.critical('App.root must be an _instance_ of Widget')\n                raise Exception('Invalid instance in App.root')\n            from kivy.core.window import Window\n            Window.add_widget(self.root)\n\n        # Check if the window is already created\n        from kivy.base import EventLoop\n        window = EventLoop.window\n        if window:\n            self._app_window = window\n            window.set_title(self.get_application_name())\n            icon = self.get_application_icon()\n            if icon:\n                window.set_icon(icon)\n            self._install_settings_keys(window)\n        else:\n            Logger.critical(\"Application: No window is created.\"\n                            \" Terminating application run.\")\n            return\n\n        self.dispatch('on_start')",
  "def run(self):\n        '''Launches the app in standalone mode.\n        '''\n        self._run_prepare()\n        runTouchApp()\n        self._stop()",
  "async def async_run(self, async_lib=None):\n        '''Identical to :meth:`run`, but is a coroutine and can be\n        scheduled in a running async event loop.\n\n        See :mod:`kivy.app` for example usage.\n\n        .. versionadded:: 2.0.0\n        '''\n        self._run_prepare()\n        await async_runTouchApp(async_lib=async_lib)\n        self._stop()",
  "def stop(self, *largs):\n        '''Stop the application.\n\n        If you use this method, the whole application will stop by issuing\n        a call to :func:`~kivy.base.stopTouchApp`.\n        Except on Android, set Android state to stop, Kivy state then follows.\n        '''\n        if platform == 'android':\n            from android import mActivity\n            mActivity.finishAndRemoveTask()\n        else:\n            self._stop()",
  "def _stop(self, *largs):\n        self.dispatch('on_stop')\n        stopTouchApp()\n\n        # Clear the window children\n        if self._app_window:\n            for child in self._app_window.children:\n                self._app_window.remove_widget(child)\n        App._running_app = None",
  "def pause(self, *largs):\n        '''Pause the application.\n\n        On Android set OS state to pause, Kivy app state follows.\n        No functionality on other OS.\n        .. versionadded:: 2.2.0\n        '''\n        if platform == 'android':\n            from android import mActivity\n            mActivity.moveTaskToBack(True)\n        else:\n            Logger.info('App.pause() is not available on this OS.')",
  "def on_start(self):\n        '''Event handler for the `on_start` event which is fired after\n        initialization (after build() has been called) but before the\n        application has started running.\n        '''\n        pass",
  "def on_stop(self):\n        '''Event handler for the `on_stop` event which is fired when the\n        application has finished running (i.e. the window is about to be\n        closed).\n        '''\n        pass",
  "def on_pause(self):\n        '''Event handler called when Pause mode is requested. You should\n        return True if your app can go into Pause mode, otherwise\n        return False and your application will be stopped.\n\n        You cannot control when the application is going to go into this mode.\n        It's determined by the Operating System and mostly used for mobile\n        devices (android/ios) and for resizing.\n\n        The default return value is True.\n\n        .. versionadded:: 1.1.0\n        .. versionchanged:: 1.10.0\n            The default return value is now True.\n        '''\n        return True",
  "def on_resume(self):\n        '''Event handler called when your application is resuming from\n        the Pause mode.\n\n        .. versionadded:: 1.1.0\n\n        .. warning::\n\n            When resuming, the OpenGL Context might have been damaged / freed.\n            This is where you can reconstruct some of your OpenGL state\n            e.g. FBO content.\n        '''\n        pass",
  "def get_running_app():\n        '''Return the currently running application instance.\n\n        .. versionadded:: 1.1.0\n        '''\n        return App._running_app",
  "def on_config_change(self, config, section, key, value):\n        '''Event handler fired when a configuration token has been changed by\n        the settings page.\n\n        .. versionchanged:: 1.10.1\n           Added corresponding ``on_config_change`` event.\n        '''\n        pass",
  "def open_settings(self, *largs):\n        '''Open the application settings panel. It will be created the very\n        first time, or recreated if the previously cached panel has been\n        removed by :meth:`destroy_settings`. The settings panel will be\n        displayed with the\n        :meth:`display_settings` method, which by default adds the\n        settings panel to the Window attached to your application. You\n        should override that method if you want to display the\n        settings panel differently.\n\n        :return:\n            True if the settings has been opened.\n\n        '''\n        if self._app_settings is None:\n            self._app_settings = self.create_settings()\n        displayed = self.display_settings(self._app_settings)\n        if displayed:\n            return True\n        return False",
  "def display_settings(self, settings):\n        '''.. versionadded:: 1.8.0\n\n        Display the settings panel. By default, the panel is drawn directly\n        on top of the window. You can define other behavior by overriding\n        this method, such as adding it to a ScreenManager or Popup.\n\n        You should return True if the display is successful, otherwise False.\n\n        :Parameters:\n            `settings`: :class:`~kivy.uix.settings.Settings`\n                You can modify this object in order to modify the settings\n                display.\n\n        '''\n        win = self._app_window\n        if not win:\n            raise Exception('No windows are set on the application, you cannot'\n                            ' open settings yet.')\n        if settings not in win.children:\n            win.add_widget(settings)\n            return True\n        return False",
  "def close_settings(self, *largs):\n        '''Close the previously opened settings panel.\n\n        :return:\n            True if the settings has been closed.\n        '''\n        win = self._app_window\n        settings = self._app_settings\n        if win is None or settings is None:\n            return\n        if settings in win.children:\n            win.remove_widget(settings)\n            return True\n        return False",
  "def create_settings(self):\n        '''Create the settings panel. This method will normally\n        be called only one time per\n        application life-time and the result is cached internally,\n        but it may be called again if the cached panel is removed\n        by :meth:`destroy_settings`.\n\n        By default, it will build a settings panel according to\n        :attr:`settings_cls`, call :meth:`build_settings`, add a Kivy panel if\n        :attr:`use_kivy_settings` is True, and bind to\n        on_close/on_config_change.\n\n        If you want to plug your own way of doing settings, without the Kivy\n        panel or close/config change events, this is the method you want to\n        overload.\n\n        .. versionadded:: 1.8.0\n        '''\n        if self.settings_cls is None:\n            from kivy.uix.settings import SettingsWithSpinner\n            self.settings_cls = SettingsWithSpinner\n        elif isinstance(self.settings_cls, string_types):\n            self.settings_cls = Factory.get(self.settings_cls)\n        s = self.settings_cls()\n        self.build_settings(s)\n        if self.use_kivy_settings:\n            s.add_kivy_panel()\n        s.bind(on_close=self.close_settings,\n               on_config_change=self._on_config_change)\n        return s",
  "def destroy_settings(self):\n        '''.. versionadded:: 1.8.0\n\n        Dereferences the current settings panel if one\n        exists. This means that when :meth:`App.open_settings` is next\n        run, a new panel will be created and displayed. It doesn't\n        affect any of the contents of the panel, but lets you (for\n        instance) refresh the settings panel layout if you have\n        changed the settings widget in response to a screen size\n        change.\n\n        If you have modified :meth:`~App.open_settings` or\n        :meth:`~App.display_settings`, you should be careful to\n        correctly detect if the previous settings widget has been\n        destroyed.\n\n        '''\n        if self._app_settings is not None:\n            self._app_settings = None",
  "def _on_config_change(self, *largs):\n        self.dispatch('on_config_change', *largs[1:])",
  "def _install_settings_keys(self, window):\n        window.bind(on_keyboard=self._on_keyboard_settings)",
  "def _on_keyboard_settings(self, window, *largs):\n        key = largs[0]\n        setting_key = 282  # F1\n\n        # android hack, if settings key is pygame K_MENU\n        if platform == 'android' and not USE_SDL2:\n            import pygame\n            setting_key = pygame.K_MENU\n\n        if key == setting_key:\n            # toggle settings panel\n            if not self.open_settings():\n                self.close_settings()\n            return True\n        if key == 27:\n            return self.close_settings()",
  "def on_title(self, instance, title):\n        if self._app_window:\n            self._app_window.set_title(title)",
  "def on_icon(self, instance, icon):\n        if self._app_window:\n            self._app_window.set_icon(self.get_application_icon())",
  "class Vector(list):\n    '''Vector class. See module documentation for more information.\n    '''\n\n    def __init__(self, *largs):\n        if len(largs) == 1:\n            super(Vector, self).__init__(largs[0])\n        elif len(largs) == 2:\n            super(Vector, self).__init__(largs)\n        else:\n            raise Exception('Invalid vector')\n\n    def _get_x(self):\n        return self[0]\n\n    def _set_x(self, x):\n        self[0] = x\n\n    x = property(_get_x, _set_x)\n    ''':attr:`x` represents the first element in the list.\n\n    >>> v = Vector(12, 23)\n    >>> v[0]\n    12\n    >>> v.x\n    12\n    '''\n\n    def _get_y(self):\n        return self[1]\n\n    def _set_y(self, y):\n        self[1] = y\n\n    y = property(_get_y, _set_y)\n    ''':attr:`y` represents the second element in the list.\n\n    >>> v = Vector(12, 23)\n    >>> v[1]\n    23\n    >>> v.y\n    23\n\n    '''\n\n    def __getslice__(self, i, j):\n        try:\n            # use the list __getslice__ method and convert\n            # result to vector\n            return Vector(super(Vector, self).__getslice__(i, j))\n        except Exception:\n            raise TypeError('vector::FAILURE in __getslice__')\n\n    def __add__(self, val):\n        return Vector(list(map(lambda x, y: x + y, self, val)))\n\n    def __iadd__(self, val):\n        if type(val) in (int, float):\n            self.x += val\n            self.y += val\n        else:\n            self.x += val.x\n            self.y += val.y\n        return self\n\n    def __neg__(self):\n        return Vector([-x for x in self])\n\n    def __sub__(self, val):\n        return Vector(list(map(lambda x, y: x - y, self, val)))\n\n    def __isub__(self, val):\n        if type(val) in (int, float):\n            self.x -= val\n            self.y -= val\n        else:\n            self.x -= val.x\n            self.y -= val.y\n        return self\n\n    def __mul__(self, val):\n        try:\n            return Vector(list(map(lambda x, y: x * y, self, val)))\n        except Exception:\n            return Vector([x * val for x in self])\n\n    def __imul__(self, val):\n        if type(val) in (int, float):\n            self.x *= val\n            self.y *= val\n        else:\n            self.x *= val.x\n            self.y *= val.y\n        return self\n\n    def __rmul__(self, val):\n        return (self * val)\n\n    def __truediv__(self, val):\n        try:\n            return Vector(list(map(lambda x, y: x / y, self, val)))\n        except Exception:\n            return Vector([x / val for x in self])\n\n    def __div__(self, val):\n        try:\n            return Vector(list(map(lambda x, y: x / y, self, val)))\n        except Exception:\n            return Vector([x / val for x in self])\n\n    def __rtruediv__(self, val):\n        try:\n            return Vector(*val) / self\n        except Exception:\n            return Vector(val, val) / self\n\n    def __rdiv__(self, val):\n        try:\n            return Vector(*val) / self\n        except Exception:\n            return Vector(val, val) / self\n\n    def __idiv__(self, val):\n        if type(val) in (int, float):\n            self.x /= val\n            self.y /= val\n        else:\n            self.x /= val.x\n            self.y /= val.y\n        return self\n\n    def length(self):\n        '''Returns the length of a vector.\n\n        >>> Vector(10, 10).length()\n        14.142135623730951\n        >>> pos = (10, 10)\n        >>> Vector(pos).length()\n        14.142135623730951\n\n        '''\n        return math.sqrt(self[0] ** 2 + self[1] ** 2)\n\n    def length2(self):\n        '''Returns the length of a vector squared.\n\n        >>> Vector(10, 10).length2()\n        200\n        >>> pos = (10, 10)\n        >>> Vector(pos).length2()\n        200\n\n        '''\n        return self[0] ** 2 + self[1] ** 2\n\n    def distance(self, to):\n        '''Returns the distance between two points.\n\n        >>> Vector(10, 10).distance((5, 10))\n        5.\n        >>> a = (90, 33)\n        >>> b = (76, 34)\n        >>> Vector(a).distance(b)\n        14.035668847618199\n\n        '''\n        return math.sqrt((self[0] - to[0]) ** 2 + (self[1] - to[1]) ** 2)\n\n    def distance2(self, to):\n        '''Returns the distance between two points squared.\n\n        >>> Vector(10, 10).distance2((5, 10))\n        25\n\n        '''\n        return (self[0] - to[0]) ** 2 + (self[1] - to[1]) ** 2\n\n    def normalize(self):\n        '''Returns a new vector that has the same direction as vec,\n        but has a length of one.\n\n        >>> v = Vector(88, 33).normalize()\n        >>> v\n        [0.93632917756904444, 0.3511234415883917]\n        >>> v.length()\n        1.0\n\n        '''\n        if self[0] == 0. and self[1] == 0.:\n            return Vector(0., 0.)\n        return self / self.length()\n\n    def dot(self, a):\n        '''Computes the dot product of a and b.\n\n        >>> Vector(2, 4).dot((2, 2))\n        12\n\n        '''\n        return self[0] * a[0] + self[1] * a[1]\n\n    def angle(self, a):\n        '''Computes the angle between a and b, and returns the angle in\n        degrees.\n\n        >>> Vector(100, 0).angle((0, 100))\n        -90.0\n        >>> Vector(87, 23).angle((-77, 10))\n        -157.7920283010705\n\n        '''\n        angle = -(180 / math.pi) * math.atan2(\n            self[0] * a[1] - self[1] * a[0],\n            self[0] * a[0] + self[1] * a[1])\n        return angle\n\n    def rotate(self, angle):\n        '''Rotate the vector with an angle in degrees.\n\n        >>> v = Vector(100, 0)\n        >>> v.rotate(45)\n        [70.71067811865476, 70.71067811865474]\n\n        '''\n        angle = math.radians(angle)\n        return Vector(\n            (self[0] * math.cos(angle)) - (self[1] * math.sin(angle)),\n            (self[1] * math.cos(angle)) + (self[0] * math.sin(angle)))\n\n    @staticmethod\n    def line_intersection(v1, v2, v3, v4):\n        '''\n        Finds the intersection point between the lines (1)v1->v2 and (2)v3->v4\n        and returns it as a vector object.\n\n        >>> a = (98, 28)\n        >>> b = (72, 33)\n        >>> c = (10, -5)\n        >>> d = (20, 88)\n        >>> Vector.line_intersection(a, b, c, d)\n        [15.25931928687196, 43.911669367909241]\n\n        .. warning::\n\n            This is a line intersection method, not a segment intersection.\n\n        For math see: http://en.wikipedia.org/wiki/Line-line_intersection\n        '''\n        # linear algebar sucks...seriously!!\n        x1, x2, x3, x4 = float(v1[0]), float(v2[0]), float(v3[0]), float(v4[0])\n        y1, y2, y3, y4 = float(v1[1]), float(v2[1]), float(v3[1]), float(v4[1])\n\n        u = (x1 * y2 - y1 * x2)\n        v = (x3 * y4 - y3 * x4)\n        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if denom == 0:\n            return None\n\n        px = (u * (x3 - x4) - (x1 - x2) * v) / denom\n        py = (u * (y3 - y4) - (y1 - y2) * v) / denom\n\n        return Vector(px, py)\n\n    @staticmethod\n    def segment_intersection(v1, v2, v3, v4):\n        '''\n        Finds the intersection point between segments (1)v1->v2 and (2)v3->v4\n        and returns it as a vector object.\n\n        >>> a = (98, 28)\n        >>> b = (72, 33)\n        >>> c = (10, -5)\n        >>> d = (20, 88)\n        >>> Vector.segment_intersection(a, b, c, d)\n        None\n\n        >>> a = (0, 0)\n        >>> b = (10, 10)\n        >>> c = (0, 10)\n        >>> d = (10, 0)\n        >>> Vector.segment_intersection(a, b, c, d)\n        [5, 5]\n        '''\n\n        # Yaaay! I love linear algebra applied within the realms of geometry.\n        x1, x2, x3, x4 = float(v1[0]), float(v2[0]), float(v3[0]), float(v4[0])\n        y1, y2, y3, y4 = float(v1[1]), float(v2[1]), float(v3[1]), float(v4[1])\n\n        # This is mostly the same as the line_intersection\n        u = (x1 * y2 - y1 * x2)\n        v = (x3 * y4 - y3 * x4)\n        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if denom == 0:\n            return None\n\n        px = (u * (x3 - x4) - (x1 - x2) * v) / denom\n        py = (u * (y3 - y4) - (y1 - y2) * v) / denom\n        # Here are the new bits\n        c1 = (x1 <= px <= x2) or (x2 <= px <= x1) or (x1 == x2)\n        c2 = (y1 <= py <= y2) or (y2 <= py <= y1) or (y1 == y2)\n        c3 = (x3 <= px <= x4) or (x4 <= px <= x3) or (x3 == x4)\n        c4 = (y3 <= py <= y4) or (y4 <= py <= y3) or (y3 == y4)\n\n        if (c1 and c2) and (c3 and c4):\n            return Vector(px, py)\n        else:\n            return None\n\n    @staticmethod\n    def in_bbox(point, a, b):\n        '''Return True if `point` is in the bounding box defined by `a`\n        and `b`.\n\n        >>> bmin = (0, 0)\n        >>> bmax = (100, 100)\n        >>> Vector.in_bbox((50, 50), bmin, bmax)\n        True\n        >>> Vector.in_bbox((647, -10), bmin, bmax)\n        False\n\n        '''\n        return ((point[0] <= a[0] and point[0] >= b[0] or\n                 point[0] <= b[0] and point[0] >= a[0]) and\n                (point[1] <= a[1] and point[1] >= b[1] or\n                 point[1] <= b[1] and point[1] >= a[1]))",
  "def __init__(self, *largs):\n        if len(largs) == 1:\n            super(Vector, self).__init__(largs[0])\n        elif len(largs) == 2:\n            super(Vector, self).__init__(largs)\n        else:\n            raise Exception('Invalid vector')",
  "def _get_x(self):\n        return self[0]",
  "def _set_x(self, x):\n        self[0] = x",
  "def _get_y(self):\n        return self[1]",
  "def _set_y(self, y):\n        self[1] = y",
  "def __getslice__(self, i, j):\n        try:\n            # use the list __getslice__ method and convert\n            # result to vector\n            return Vector(super(Vector, self).__getslice__(i, j))\n        except Exception:\n            raise TypeError('vector::FAILURE in __getslice__')",
  "def __add__(self, val):\n        return Vector(list(map(lambda x, y: x + y, self, val)))",
  "def __iadd__(self, val):\n        if type(val) in (int, float):\n            self.x += val\n            self.y += val\n        else:\n            self.x += val.x\n            self.y += val.y\n        return self",
  "def __neg__(self):\n        return Vector([-x for x in self])",
  "def __sub__(self, val):\n        return Vector(list(map(lambda x, y: x - y, self, val)))",
  "def __isub__(self, val):\n        if type(val) in (int, float):\n            self.x -= val\n            self.y -= val\n        else:\n            self.x -= val.x\n            self.y -= val.y\n        return self",
  "def __mul__(self, val):\n        try:\n            return Vector(list(map(lambda x, y: x * y, self, val)))\n        except Exception:\n            return Vector([x * val for x in self])",
  "def __imul__(self, val):\n        if type(val) in (int, float):\n            self.x *= val\n            self.y *= val\n        else:\n            self.x *= val.x\n            self.y *= val.y\n        return self",
  "def __rmul__(self, val):\n        return (self * val)",
  "def __truediv__(self, val):\n        try:\n            return Vector(list(map(lambda x, y: x / y, self, val)))\n        except Exception:\n            return Vector([x / val for x in self])",
  "def __div__(self, val):\n        try:\n            return Vector(list(map(lambda x, y: x / y, self, val)))\n        except Exception:\n            return Vector([x / val for x in self])",
  "def __rtruediv__(self, val):\n        try:\n            return Vector(*val) / self\n        except Exception:\n            return Vector(val, val) / self",
  "def __rdiv__(self, val):\n        try:\n            return Vector(*val) / self\n        except Exception:\n            return Vector(val, val) / self",
  "def __idiv__(self, val):\n        if type(val) in (int, float):\n            self.x /= val\n            self.y /= val\n        else:\n            self.x /= val.x\n            self.y /= val.y\n        return self",
  "def length(self):\n        '''Returns the length of a vector.\n\n        >>> Vector(10, 10).length()\n        14.142135623730951\n        >>> pos = (10, 10)\n        >>> Vector(pos).length()\n        14.142135623730951\n\n        '''\n        return math.sqrt(self[0] ** 2 + self[1] ** 2)",
  "def length2(self):\n        '''Returns the length of a vector squared.\n\n        >>> Vector(10, 10).length2()\n        200\n        >>> pos = (10, 10)\n        >>> Vector(pos).length2()\n        200\n\n        '''\n        return self[0] ** 2 + self[1] ** 2",
  "def distance(self, to):\n        '''Returns the distance between two points.\n\n        >>> Vector(10, 10).distance((5, 10))\n        5.\n        >>> a = (90, 33)\n        >>> b = (76, 34)\n        >>> Vector(a).distance(b)\n        14.035668847618199\n\n        '''\n        return math.sqrt((self[0] - to[0]) ** 2 + (self[1] - to[1]) ** 2)",
  "def distance2(self, to):\n        '''Returns the distance between two points squared.\n\n        >>> Vector(10, 10).distance2((5, 10))\n        25\n\n        '''\n        return (self[0] - to[0]) ** 2 + (self[1] - to[1]) ** 2",
  "def normalize(self):\n        '''Returns a new vector that has the same direction as vec,\n        but has a length of one.\n\n        >>> v = Vector(88, 33).normalize()\n        >>> v\n        [0.93632917756904444, 0.3511234415883917]\n        >>> v.length()\n        1.0\n\n        '''\n        if self[0] == 0. and self[1] == 0.:\n            return Vector(0., 0.)\n        return self / self.length()",
  "def dot(self, a):\n        '''Computes the dot product of a and b.\n\n        >>> Vector(2, 4).dot((2, 2))\n        12\n\n        '''\n        return self[0] * a[0] + self[1] * a[1]",
  "def angle(self, a):\n        '''Computes the angle between a and b, and returns the angle in\n        degrees.\n\n        >>> Vector(100, 0).angle((0, 100))\n        -90.0\n        >>> Vector(87, 23).angle((-77, 10))\n        -157.7920283010705\n\n        '''\n        angle = -(180 / math.pi) * math.atan2(\n            self[0] * a[1] - self[1] * a[0],\n            self[0] * a[0] + self[1] * a[1])\n        return angle",
  "def rotate(self, angle):\n        '''Rotate the vector with an angle in degrees.\n\n        >>> v = Vector(100, 0)\n        >>> v.rotate(45)\n        [70.71067811865476, 70.71067811865474]\n\n        '''\n        angle = math.radians(angle)\n        return Vector(\n            (self[0] * math.cos(angle)) - (self[1] * math.sin(angle)),\n            (self[1] * math.cos(angle)) + (self[0] * math.sin(angle)))",
  "def line_intersection(v1, v2, v3, v4):\n        '''\n        Finds the intersection point between the lines (1)v1->v2 and (2)v3->v4\n        and returns it as a vector object.\n\n        >>> a = (98, 28)\n        >>> b = (72, 33)\n        >>> c = (10, -5)\n        >>> d = (20, 88)\n        >>> Vector.line_intersection(a, b, c, d)\n        [15.25931928687196, 43.911669367909241]\n\n        .. warning::\n\n            This is a line intersection method, not a segment intersection.\n\n        For math see: http://en.wikipedia.org/wiki/Line-line_intersection\n        '''\n        # linear algebar sucks...seriously!!\n        x1, x2, x3, x4 = float(v1[0]), float(v2[0]), float(v3[0]), float(v4[0])\n        y1, y2, y3, y4 = float(v1[1]), float(v2[1]), float(v3[1]), float(v4[1])\n\n        u = (x1 * y2 - y1 * x2)\n        v = (x3 * y4 - y3 * x4)\n        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if denom == 0:\n            return None\n\n        px = (u * (x3 - x4) - (x1 - x2) * v) / denom\n        py = (u * (y3 - y4) - (y1 - y2) * v) / denom\n\n        return Vector(px, py)",
  "def segment_intersection(v1, v2, v3, v4):\n        '''\n        Finds the intersection point between segments (1)v1->v2 and (2)v3->v4\n        and returns it as a vector object.\n\n        >>> a = (98, 28)\n        >>> b = (72, 33)\n        >>> c = (10, -5)\n        >>> d = (20, 88)\n        >>> Vector.segment_intersection(a, b, c, d)\n        None\n\n        >>> a = (0, 0)\n        >>> b = (10, 10)\n        >>> c = (0, 10)\n        >>> d = (10, 0)\n        >>> Vector.segment_intersection(a, b, c, d)\n        [5, 5]\n        '''\n\n        # Yaaay! I love linear algebra applied within the realms of geometry.\n        x1, x2, x3, x4 = float(v1[0]), float(v2[0]), float(v3[0]), float(v4[0])\n        y1, y2, y3, y4 = float(v1[1]), float(v2[1]), float(v3[1]), float(v4[1])\n\n        # This is mostly the same as the line_intersection\n        u = (x1 * y2 - y1 * x2)\n        v = (x3 * y4 - y3 * x4)\n        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if denom == 0:\n            return None\n\n        px = (u * (x3 - x4) - (x1 - x2) * v) / denom\n        py = (u * (y3 - y4) - (y1 - y2) * v) / denom\n        # Here are the new bits\n        c1 = (x1 <= px <= x2) or (x2 <= px <= x1) or (x1 == x2)\n        c2 = (y1 <= py <= y2) or (y2 <= py <= y1) or (y1 == y2)\n        c3 = (x3 <= px <= x4) or (x4 <= px <= x3) or (x3 == x4)\n        c4 = (y3 <= py <= y4) or (y4 <= py <= y3) or (y3 == y4)\n\n        if (c1 and c2) and (c3 and c4):\n            return Vector(px, py)\n        else:\n            return None",
  "def in_bbox(point, a, b):\n        '''Return True if `point` is in the bounding box defined by `a`\n        and `b`.\n\n        >>> bmin = (0, 0)\n        >>> bmax = (100, 100)\n        >>> Vector.in_bbox((50, 50), bmin, bmax)\n        True\n        >>> Vector.in_bbox((647, -10), bmin, bmax)\n        False\n\n        '''\n        return ((point[0] <= a[0] and point[0] >= b[0] or\n                 point[0] <= b[0] and point[0] >= a[0]) and\n                (point[1] <= a[1] and point[1] >= b[1] or\n                 point[1] <= b[1] and point[1] >= a[1]))",
  "class ColorException(Exception):\n    pass",
  "def parse_filename(filename):\n    '''Parse a filename and search for it using `resource_find()`.\n    If found, the resource path is returned, otherwise return the unmodified\n    filename (as specified by the caller).'''\n    filename = parse_string(filename)\n    result = resource_find(filename)\n    if result is None:\n        Logger.error('Resource: unable to find <%s>' % filename)\n    return result or filename",
  "def color_error(text):\n    # show warning and return a sane value\n    Logger.warning(text)\n    return (0, 0, 0, 1)",
  "def parse_color(text):\n    '''Parse a string to a kivy color. Supported formats:\n\n        * rgb(r, g, b)\n        * rgba(r, g, b, a)\n        * rgb\n        * rgba\n        * rrggbb\n        * rrggbbaa\n\n    For hexadecimal values, you case also use:\n\n        * #rgb\n        * #rgba\n        * #rrggbb\n        * #rrggbbaa\n    '''\n    value = [1, 1, 1, 1]\n    if text.startswith('rgb'):\n        res = re.match(r'rgba?\\((.*)\\)', text)\n        if res:\n            try:\n                # default r/g/b values to 1 if greater than 255 else x/255\n                value = [1 if int(x) > 255. else (int(x) / 255.)\n                         for x in re.split(', ?', res.groups()[0])]\n                if len(value) < 3:\n                    # in case of invalid input like rgb()/rgb(r)/rgb(r, g)\n                    raise ValueError\n            except ValueError:\n                return color_error('ColorParser: Invalid color for %r' % text)\n            except AttributeError:\n                return color_error('ColorParser: Invalid color for %r' % text)\n        else:\n            return color_error('ColorParser: Invalid color for %r' % text)\n        if len(value) == 3:\n            value.append(1.)\n    elif len(text):\n        res = text\n        if text[0] == '#':\n            res = text[1:]\n        lres = len(res)\n        if lres == 3 or lres == 4:\n            res = ''.join([x + x for x in res])\n        elif lres != 6 and lres != 8:\n            # raise ColorException('Invalid color format for %r' % text)\n            return color_error(\n                'ColorParser: Invalid color format for %r' % text)\n        try:\n            value = [int(res[i:i + 2], 16) / 255.\n                     for i in range(0, len(res), 2)]\n        except ValueError:\n            return color_error('ColorParser: Invalid color for %r' % text)\n        if lres == 6 or lres == 3:\n            value.append(1.)\n    return value",
  "def parse_bool(text):\n    '''Parse a string to a boolean, ignoring case. \"true\"/\"1\" is True,\n    \"false\"/\"0\" is False. Anything else throws an exception.'''\n    if text.lower() in ('true', '1'):\n        return True\n    elif text.lower() in ('false', '0'):\n        return False\n    raise Exception('Invalid boolean: %s' % text)",
  "def parse_string(text):\n    '''Parse a string to a string (removing single and double quotes).'''\n    if len(text) >= 2 and text[0] in ('\"', \"'\") and text[-1] in ('\"', \"'\"):\n        text = text[1:-1]\n    return text.strip()",
  "def parse_int2(text):\n    '''Parse a string to a list of exactly 2 integers.\n\n        >>> print(parse_int2(\"12 54\"))\n        12, 54\n\n    '''\n    texts = [x for x in text.split(' ') if x.strip() != '']\n    value = list(map(parse_int, texts))\n    if len(value) < 1:\n        raise Exception('Invalid int2 format: %s' % text)\n    elif len(value) == 1:\n        return [value[0], value[0]]\n    elif len(value) > 2:\n        raise Exception('Too many values in %s: %s' % (text, str(value)))\n    return value",
  "def parse_float4(text):\n    '''Parse a string to a list of exactly 4 floats.\n\n        >>> parse_float4('54 87. 35 0')\n        54, 87., 35, 0\n\n    '''\n    texts = [x for x in text.split(' ') if x.strip() != '']\n    value = list(map(parse_float, texts))\n    if len(value) < 1:\n        raise Exception('Invalid float4 format: %s' % text)\n    elif len(value) == 1:\n        return [value[0] for x in range(4)]\n    elif len(value) == 2:\n        return [value[0], value[1], value[0], value[1]]\n    elif len(value) == 3:\n        # ambiguous case!\n        return [value[0], value[1], value[0], value[2]]\n    elif len(value) > 4:\n        raise Exception('Too many values in %s' % text)\n    return value",
  "def _isclose(a, b, rel_tol=1e-9, abs_tol=0.0):\n    '''Measures whether two floats are \"close\" to each other. Identical to\n    https://docs.python.org/3.6/library/math.html#math.isclose, for older\n    versions of python.\n    '''\n\n    if a == b:  # short-circuit exact equality\n        return True\n\n    if rel_tol < 0.0 or abs_tol < 0.0:\n        raise ValueError('error tolerances must be non-negative')\n\n    # use cmath so it will work with complex or float\n    if isinf(abs(a)) or isinf(abs(b)):\n        # This includes the case of two infinities of opposite sign, or\n        # one infinity and one finite number. Two infinities of opposite sign\n        # would otherwise have an infinite relative tolerance.\n        return False\n    diff = fabs(b - a)\n\n    return (((diff <= fabs(rel_tol * b)) or\n             (diff <= fabs(rel_tol * a))) or\n            (diff <= abs_tol))",
  "def _get_sleep_obj():\n    pass",
  "class ClockBaseBehavior(object):\n    '''The base of the kivy clock.\n\n    :parameters:\n\n        `async_lib`: string\n            The async library to use when the clock is run asynchronously.\n            Can be one of, `\"asyncio\"` when the standard library asyncio\n            should be used, or `\"trio\"` if the trio library should be used.\n\n            It defaults to `'asyncio'` or the value in the environmental\n            variable `KIVY_EVENTLOOP` if set. :meth:`init_async_lib` can also\n            be called directly to set the library.\n    '''\n\n    _dt = 0.0001\n    _last_fps_tick = None\n    _start_tick = 0\n    _fps = 0\n    _rfps = 0\n    _fps_counter = 0\n    _rfps_counter = 0\n    _frames = 0\n    _frames_displayed = 0\n    _events_duration = 0\n    '''The measured time that it takes to process all the events etc, excepting\n    any sleep or waiting time. It is the average and is updated every 5\n    seconds.\n    '''\n\n    _duration_count = 0\n    _sleep_time = 0\n    _duration_ts0 = 0\n\n    MIN_SLEEP = 0.005\n    '''The minimum time to sleep. If the remaining time is less than this,\n    the event loop will continue.\n    '''\n    SLEEP_UNDERSHOOT = MIN_SLEEP - 0.001\n\n    _async_lib = None\n\n    _async_wait_for = None\n\n    def __init__(self, async_lib='asyncio', **kwargs):\n        self.init_async_lib(async_lib)\n        super(ClockBaseBehavior, self).__init__(**kwargs)\n        self._duration_ts0 = self._start_tick = self._last_tick = self.time()\n        self._max_fps = float(Config.getint('graphics', 'maxfps'))\n\n    def init_async_lib(self, lib):\n        \"\"\"Manually sets the async library to use internally, when running in\n        a asynchronous manner.\n\n        This can be called anytime before the kivy event loop has started,\n        but not once the kivy App is running.\n\n        :parameters:\n\n            `lib`: string\n                The async library to use when the clock is run asynchronously.\n                Can be one of, `\"asyncio\"` when the standard library asyncio\n                should be used, or `\"trio\"` if the trio library should be used.\n        \"\"\"\n        if lib == 'trio':\n            import trio\n            self._async_lib = trio\n\n            async def wait_for(coro, t):\n                with trio.move_on_after(t):\n                    await coro\n            self._async_wait_for = wait_for\n        elif lib == 'asyncio':\n            import asyncio\n            self._async_lib = asyncio\n            self._async_wait_for = asyncio.wait_for\n        else:\n            raise ValueError('async library {} not recognized'.format(lib))\n\n    @property\n    def frametime(self):\n        '''Time spent between the last frame and the current frame\n        (in seconds).\n\n        .. versionadded:: 1.8.0\n        '''\n        return self._dt\n\n    @property\n    def frames(self):\n        '''Number of internal frames (not necessarily drawn) from the start of\n        the clock.\n\n        .. versionadded:: 1.8.0\n        '''\n        return self._frames\n\n    @property\n    def frames_displayed(self):\n        '''Number of displayed frames from the start of the clock.\n        '''\n        return self._frames_displayed\n\n    def usleep(self, microseconds):\n        '''Sleeps for the number of microseconds.\n        '''\n        pass\n\n    def idle(self):\n        '''(internal) waits here until the next frame.\n        '''\n        fps = self._max_fps\n        if fps > 0:\n            min_sleep = self.get_resolution()\n            undershoot = 4 / 5. * min_sleep\n            usleep = self.usleep\n            ready = self._check_ready\n\n            done, sleeptime = ready(fps, min_sleep, undershoot)\n            while not done:\n                usleep(1000000 * sleeptime)\n                done, sleeptime = ready(fps, min_sleep, undershoot)\n\n        current = self.time()\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        return current\n\n    async def async_idle(self):\n        '''(internal) async version of :meth:`idle`.\n        '''\n        fps = self._max_fps\n        if fps > 0:\n            min_sleep = self.get_resolution()\n            undershoot = 4 / 5. * min_sleep\n            ready = self._check_ready\n\n            slept = False\n            done, sleeptime = ready(fps, min_sleep, undershoot)\n            while not done:\n                slept = True\n                await self._async_lib.sleep(sleeptime)\n                done, sleeptime = ready(fps, min_sleep, undershoot)\n\n            if not slept:\n                await self._async_lib.sleep(0)\n        else:\n            await self._async_lib.sleep(0)\n\n        current = self.time()\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        return current\n\n    def _check_ready(self, fps, min_sleep, undershoot):\n        sleeptime = 1 / fps - (self.time() - self._last_tick)\n        return sleeptime - undershoot <= min_sleep, sleeptime - undershoot\n\n    def tick(self):\n        '''Advance the clock to the next step. Must be called every frame.\n        The default clock has a tick() function called by the core Kivy\n        framework.'''\n        self.pre_idle()\n        ts = self.time()\n        self.post_idle(ts, self.idle())\n\n    async def async_tick(self):\n        '''async version of :meth:`tick`. '''\n        self.pre_idle()\n        ts = self.time()\n        current = await self.async_idle()\n        self.post_idle(ts, current)\n\n    def pre_idle(self):\n        '''Called before :meth:`idle` by :meth:`tick`.\n        '''\n        self._release_references()\n\n    def post_idle(self, ts, current):\n        '''Called after :meth:`idle` by :meth:`tick`.\n        '''\n        # tick the current time\n        self._frames += 1\n        self._fps_counter += 1\n\n        # compute how long the event processing takes\n        self._duration_count += 1\n        self._sleep_time += current - ts\n        t_tot = current - self._duration_ts0\n        if t_tot >= 1.:\n            self._events_duration = \\\n                (t_tot - self._sleep_time) / float(self._duration_count)\n            self._duration_ts0 = current\n            self._sleep_time = self._duration_count = 0\n\n        # calculate fps things\n        if self._last_fps_tick is None:\n            self._last_fps_tick = current\n        elif current - self._last_fps_tick > 1:\n            d = float(current - self._last_fps_tick)\n            self._fps = self._fps_counter / d\n            self._rfps = self._rfps_counter\n            self._last_fps_tick = current\n            self._fps_counter = 0\n            self._rfps_counter = 0\n\n        # process event\n        self._process_events()\n\n        return self._dt\n\n    def tick_draw(self):\n        '''Tick the drawing counter.\n        '''\n        self._process_events_before_frame()\n        self._rfps_counter += 1\n        self._frames_displayed += 1\n\n    def get_fps(self):\n        '''Get the current average FPS calculated by the clock.\n        '''\n        return self._fps\n\n    def get_rfps(self):\n        '''Get the current \"real\" FPS calculated by the clock.\n        This counter reflects the real framerate displayed on the screen.\n\n        In contrast to get_fps(), this function returns a counter of the\n        number of frames, not the average of frames per second.\n        '''\n        return self._rfps\n\n    def get_time(self):\n        '''Get the last tick made by the clock.'''\n        return self._last_tick\n\n    def get_boottime(self):\n        '''Get the time in seconds from the application start.'''\n        return self._last_tick - self._start_tick\n\n    time = staticmethod(partial(_default_time))\n\n    def handle_exception(self, e):\n        from kivy.base import ExceptionManager\n\n        if ExceptionManager.handle_exception(e) == ExceptionManager.RAISE:\n            raise",
  "class ClockBaseInterruptBehavior(ClockBaseBehavior):\n    '''A kivy clock which can be interrupted during a frame to execute events.\n    '''\n\n    interupt_next_only = False\n    _event = None\n    _async_event = None\n    _get_min_timeout_func = None\n\n    def __init__(self, interupt_next_only=False, **kwargs):\n        super(ClockBaseInterruptBehavior, self).__init__(**kwargs)\n        self._event = ThreadingEvent()\n        self.interupt_next_only = interupt_next_only\n        self._get_min_timeout_func = self.get_min_timeout\n\n    def init_async_lib(self, lib):\n        super(ClockBaseInterruptBehavior, self).init_async_lib(lib)\n        if lib == 'trio':\n            import trio\n            self._async_event = trio.Event()\n            # we don't know if this is called after things have already been\n            # scheduled, so don't delay for a full frame before processing\n            # events\n            self._async_event.set()\n        elif lib == 'asyncio':\n            import asyncio\n            self._async_event = asyncio.Event()\n            self._async_event.set()\n\n    def usleep(self, microseconds):\n        self._event.clear()\n        self._event.wait(microseconds / 1000000.)\n\n    async def async_usleep(self, microseconds):\n        self._async_event.clear()\n        await self._async_wait_for(\n            self._async_event.wait(), microseconds / 1000000.)\n\n    def on_schedule(self, event):\n        fps = self._max_fps\n        if not fps:\n            return\n\n        if not event.timeout or (\n                not self.interupt_next_only and event.timeout <=\n                1 / fps -  # remaining time\n                (self.time() - self._last_tick) +  # elapsed time\n                4 / 5. * self.get_resolution()):  # resolution fudge factor\n            self._event.set()\n            if self._async_event:\n                self._async_event.set()\n\n    def idle(self):\n        fps = self._max_fps\n        event = self._event\n        resolution = self.get_resolution()\n        if fps > 0:\n            done, sleeptime = self._check_ready(\n                fps, resolution, 4 / 5. * resolution, event)\n            if not done:\n                event.wait(sleeptime)\n\n        current = self.time()\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        event.clear()\n        # anything scheduled from now on, if scheduled for the upcoming frame\n        # will cause a timeout of the event on the next idle due to on_schedule\n        # `self._last_tick = current` must happen before clear, otherwise the\n        # on_schedule computation is wrong when exec between the clear and\n        # the `self._last_tick = current` bytecode.\n        return current\n\n    async def async_idle(self):\n        fps = self._max_fps\n        event = self._async_event\n        resolution = self.get_resolution()\n        if fps > 0:\n            done, sleeptime = self._check_ready(\n                fps, resolution, 4 / 5. * resolution, event)\n            if not done:\n                await self._async_wait_for(event.wait(), sleeptime)\n            else:\n                await self._async_lib.sleep(0)\n        else:\n            await self._async_lib.sleep(0)\n\n        current = self.time()\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        event.clear()\n        # anything scheduled from now on, if scheduled for the upcoming frame\n        # will cause a timeout of the event on the next idle due to on_schedule\n        # `self._last_tick = current` must happen before clear, otherwise the\n        # on_schedule computation is wrong when exec between the clear and\n        # the `self._last_tick = current` bytecode.\n        return current\n\n    def _check_ready(self, fps, min_sleep, undershoot, event):\n        if event.is_set():\n            return True, 0\n\n        t = self._get_min_timeout_func()\n        if not t:\n            return True, 0\n\n        if not self.interupt_next_only:\n            curr_t = self.time()\n            sleeptime = min(1 / fps - (curr_t - self._last_tick), t - curr_t)\n        else:\n            sleeptime = 1 / fps - (self.time() - self._last_tick)\n        return sleeptime - undershoot <= min_sleep, sleeptime - undershoot",
  "class ClockBaseInterruptFreeBehavior(ClockBaseInterruptBehavior):\n    '''A base class for the clock that interrupts the sleep interval for\n    free events.\n    '''\n\n    def __init__(self, **kwargs):\n        super(ClockBaseInterruptFreeBehavior, self).__init__(**kwargs)\n        self._get_min_timeout_func = self.get_min_free_timeout\n\n    def on_schedule(self, event):\n        if not event.free:  # only wake up for free events\n            return\n        # free events should use real time not frame time\n        event._last_dt = self.time()\n        return super(ClockBaseInterruptFreeBehavior,\n                     self).on_schedule(event)",
  "class ClockBase(ClockBaseBehavior, CyClockBase):\n    '''The ``default`` kivy clock. See module for details.\n    '''\n\n    _sleep_obj = None\n\n    def __init__(self, **kwargs):\n        super(ClockBase, self).__init__(**kwargs)\n        self._sleep_obj = _get_sleep_obj()\n\n    def usleep(self, microseconds):\n        _usleep(microseconds, self._sleep_obj)",
  "class ClockBaseInterrupt(ClockBaseInterruptBehavior, CyClockBase):\n    '''The ``interrupt`` kivy clock. See module for details.\n    '''\n\n    pass",
  "class ClockBaseFreeInterruptAll(\n        ClockBaseInterruptFreeBehavior, CyClockBaseFree):\n    '''The ``free_all`` kivy clock. See module for details.\n    '''\n\n    pass",
  "class ClockBaseFreeInterruptOnly(\n        ClockBaseInterruptFreeBehavior, CyClockBaseFree):\n    '''The ``free_only`` kivy clock. See module for details.\n    '''\n\n    def idle(self):\n        fps = self._max_fps\n        current = self.time()\n        event = self._event\n        if fps > 0:\n            min_sleep = self.get_resolution()\n            usleep = self.usleep\n            undershoot = 4 / 5. * min_sleep\n            min_t = self.get_min_free_timeout\n            interupt_next_only = self.interupt_next_only\n\n            sleeptime = 1 / fps - (current - self._last_tick)\n            while sleeptime - undershoot > min_sleep:\n                if event.is_set():\n                    do_free = True\n                else:\n                    t = min_t()\n                    if not t:\n                        do_free = True\n                    elif interupt_next_only:\n                        do_free = False\n                    else:\n                        sleeptime = min(sleeptime, t - current)\n                        do_free = sleeptime - undershoot <= min_sleep\n\n                if do_free:\n                    event.clear()\n                    self._process_free_events(current)\n                else:\n                    event.wait(sleeptime - undershoot)\n                current = self.time()\n                sleeptime = 1 / fps - (current - self._last_tick)\n\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        event.clear()  # this needs to stay after _last_tick\n        return current\n\n    async def async_idle(self):\n        fps = self._max_fps\n        current = self.time()\n        event = self._async_event\n        if fps > 0:\n            min_sleep = self.get_resolution()\n            usleep = self.usleep\n            undershoot = 4 / 5. * min_sleep\n            min_t = self.get_min_free_timeout\n            interupt_next_only = self.interupt_next_only\n\n            sleeptime = 1 / fps - (current - self._last_tick)\n            slept = False\n            while sleeptime - undershoot > min_sleep:\n                if event.is_set():\n                    do_free = True\n                else:\n                    t = min_t()\n                    if not t:\n                        do_free = True\n                    elif interupt_next_only:\n                        do_free = False\n                    else:\n                        sleeptime = min(sleeptime, t - current)\n                        do_free = sleeptime - undershoot <= min_sleep\n\n                if do_free:\n                    event.clear()\n                    self._process_free_events(current)\n                else:\n                    slept = True\n                    await self._async_wait_for(\n                        event.wait(), sleeptime - undershoot)\n                current = self.time()\n                sleeptime = 1 / fps - (current - self._last_tick)\n\n            if not slept:\n                await self._async_lib.sleep(0)\n        else:\n            await self._async_lib.sleep(0)\n\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        event.clear()  # this needs to stay after _last_tick\n        return current",
  "def mainthread(func):\n    '''Decorator that will schedule the call of the function for the next\n    available frame in the mainthread. It can be useful when you use\n    :class:`~kivy.network.urlrequest.UrlRequest` or when you do Thread\n    programming: you cannot do any OpenGL-related work in a thread.\n\n    Please note that this method will return directly and no result can be\n    returned::\n\n        @mainthread\n        def callback(self, *args):\n            print('The request succeeded!',\n                  'This callback is called in the main thread.')\n\n\n        self.req = UrlRequest(url='http://...', on_success=callback)\n\n    .. versionadded:: 1.8.0\n    '''\n    @wraps(func)\n    def delayed_func(*args, **kwargs):\n        def callback_func(dt):\n            func(*args, **kwargs)\n        Clock.schedule_once(callback_func, 0)\n    return delayed_func",
  "def triggered(timeout=0, interval=False):\n    '''Decorator that will trigger the call of the function at the specified\n    timeout, through the method :meth:`CyClockBase.create_trigger`. Subsequent\n    calls to the decorated function (while the timeout is active) are ignored.\n\n    It can be helpful when an expensive function (i.e. call to a server) can be\n    triggered by different methods. Setting a proper timeout will delay the\n    calling and only one of them will be triggered.\n\n        @triggered(timeout, interval=False)\n        def callback(id):\n            print('The callback has been called with id=%d' % id)\n\n        >> callback(id=1)\n        >> callback(id=2)\n        The callback has been called with id=2\n\n    The decorated callback can also be unscheduled using:\n\n        >> callback.cancel()\n\n    .. versionadded:: 1.10.1\n    '''\n\n    def wrapper_triggered(func):\n\n        _args = []\n        _kwargs = {}\n\n        def cb_function(dt):\n            func(*tuple(_args), **_kwargs)\n\n        cb_trigger = Clock.create_trigger(\n            cb_function,\n            timeout=timeout,\n            interval=interval)\n\n        @wraps(func)\n        def trigger_function(*args, **kwargs):\n            _args[:] = []\n            _args.extend(list(args))\n            _kwargs.clear()\n            _kwargs.update(kwargs)\n            cb_trigger()\n\n        def trigger_cancel():\n            cb_trigger.cancel()\n\n        setattr(trigger_function, 'cancel', trigger_cancel)\n\n        return trigger_function\n\n    return wrapper_triggered",
  "def __init__(self, async_lib='asyncio', **kwargs):\n        self.init_async_lib(async_lib)\n        super(ClockBaseBehavior, self).__init__(**kwargs)\n        self._duration_ts0 = self._start_tick = self._last_tick = self.time()\n        self._max_fps = float(Config.getint('graphics', 'maxfps'))",
  "def init_async_lib(self, lib):\n        \"\"\"Manually sets the async library to use internally, when running in\n        a asynchronous manner.\n\n        This can be called anytime before the kivy event loop has started,\n        but not once the kivy App is running.\n\n        :parameters:\n\n            `lib`: string\n                The async library to use when the clock is run asynchronously.\n                Can be one of, `\"asyncio\"` when the standard library asyncio\n                should be used, or `\"trio\"` if the trio library should be used.\n        \"\"\"\n        if lib == 'trio':\n            import trio\n            self._async_lib = trio\n\n            async def wait_for(coro, t):\n                with trio.move_on_after(t):\n                    await coro\n            self._async_wait_for = wait_for\n        elif lib == 'asyncio':\n            import asyncio\n            self._async_lib = asyncio\n            self._async_wait_for = asyncio.wait_for\n        else:\n            raise ValueError('async library {} not recognized'.format(lib))",
  "def frametime(self):\n        '''Time spent between the last frame and the current frame\n        (in seconds).\n\n        .. versionadded:: 1.8.0\n        '''\n        return self._dt",
  "def frames(self):\n        '''Number of internal frames (not necessarily drawn) from the start of\n        the clock.\n\n        .. versionadded:: 1.8.0\n        '''\n        return self._frames",
  "def frames_displayed(self):\n        '''Number of displayed frames from the start of the clock.\n        '''\n        return self._frames_displayed",
  "def usleep(self, microseconds):\n        '''Sleeps for the number of microseconds.\n        '''\n        pass",
  "def idle(self):\n        '''(internal) waits here until the next frame.\n        '''\n        fps = self._max_fps\n        if fps > 0:\n            min_sleep = self.get_resolution()\n            undershoot = 4 / 5. * min_sleep\n            usleep = self.usleep\n            ready = self._check_ready\n\n            done, sleeptime = ready(fps, min_sleep, undershoot)\n            while not done:\n                usleep(1000000 * sleeptime)\n                done, sleeptime = ready(fps, min_sleep, undershoot)\n\n        current = self.time()\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        return current",
  "async def async_idle(self):\n        '''(internal) async version of :meth:`idle`.\n        '''\n        fps = self._max_fps\n        if fps > 0:\n            min_sleep = self.get_resolution()\n            undershoot = 4 / 5. * min_sleep\n            ready = self._check_ready\n\n            slept = False\n            done, sleeptime = ready(fps, min_sleep, undershoot)\n            while not done:\n                slept = True\n                await self._async_lib.sleep(sleeptime)\n                done, sleeptime = ready(fps, min_sleep, undershoot)\n\n            if not slept:\n                await self._async_lib.sleep(0)\n        else:\n            await self._async_lib.sleep(0)\n\n        current = self.time()\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        return current",
  "def _check_ready(self, fps, min_sleep, undershoot):\n        sleeptime = 1 / fps - (self.time() - self._last_tick)\n        return sleeptime - undershoot <= min_sleep, sleeptime - undershoot",
  "def tick(self):\n        '''Advance the clock to the next step. Must be called every frame.\n        The default clock has a tick() function called by the core Kivy\n        framework.'''\n        self.pre_idle()\n        ts = self.time()\n        self.post_idle(ts, self.idle())",
  "async def async_tick(self):\n        '''async version of :meth:`tick`. '''\n        self.pre_idle()\n        ts = self.time()\n        current = await self.async_idle()\n        self.post_idle(ts, current)",
  "def pre_idle(self):\n        '''Called before :meth:`idle` by :meth:`tick`.\n        '''\n        self._release_references()",
  "def post_idle(self, ts, current):\n        '''Called after :meth:`idle` by :meth:`tick`.\n        '''\n        # tick the current time\n        self._frames += 1\n        self._fps_counter += 1\n\n        # compute how long the event processing takes\n        self._duration_count += 1\n        self._sleep_time += current - ts\n        t_tot = current - self._duration_ts0\n        if t_tot >= 1.:\n            self._events_duration = \\\n                (t_tot - self._sleep_time) / float(self._duration_count)\n            self._duration_ts0 = current\n            self._sleep_time = self._duration_count = 0\n\n        # calculate fps things\n        if self._last_fps_tick is None:\n            self._last_fps_tick = current\n        elif current - self._last_fps_tick > 1:\n            d = float(current - self._last_fps_tick)\n            self._fps = self._fps_counter / d\n            self._rfps = self._rfps_counter\n            self._last_fps_tick = current\n            self._fps_counter = 0\n            self._rfps_counter = 0\n\n        # process event\n        self._process_events()\n\n        return self._dt",
  "def tick_draw(self):\n        '''Tick the drawing counter.\n        '''\n        self._process_events_before_frame()\n        self._rfps_counter += 1\n        self._frames_displayed += 1",
  "def get_fps(self):\n        '''Get the current average FPS calculated by the clock.\n        '''\n        return self._fps",
  "def get_rfps(self):\n        '''Get the current \"real\" FPS calculated by the clock.\n        This counter reflects the real framerate displayed on the screen.\n\n        In contrast to get_fps(), this function returns a counter of the\n        number of frames, not the average of frames per second.\n        '''\n        return self._rfps",
  "def get_time(self):\n        '''Get the last tick made by the clock.'''\n        return self._last_tick",
  "def get_boottime(self):\n        '''Get the time in seconds from the application start.'''\n        return self._last_tick - self._start_tick",
  "def handle_exception(self, e):\n        from kivy.base import ExceptionManager\n\n        if ExceptionManager.handle_exception(e) == ExceptionManager.RAISE:\n            raise",
  "def __init__(self, interupt_next_only=False, **kwargs):\n        super(ClockBaseInterruptBehavior, self).__init__(**kwargs)\n        self._event = ThreadingEvent()\n        self.interupt_next_only = interupt_next_only\n        self._get_min_timeout_func = self.get_min_timeout",
  "def init_async_lib(self, lib):\n        super(ClockBaseInterruptBehavior, self).init_async_lib(lib)\n        if lib == 'trio':\n            import trio\n            self._async_event = trio.Event()\n            # we don't know if this is called after things have already been\n            # scheduled, so don't delay for a full frame before processing\n            # events\n            self._async_event.set()\n        elif lib == 'asyncio':\n            import asyncio\n            self._async_event = asyncio.Event()\n            self._async_event.set()",
  "def usleep(self, microseconds):\n        self._event.clear()\n        self._event.wait(microseconds / 1000000.)",
  "async def async_usleep(self, microseconds):\n        self._async_event.clear()\n        await self._async_wait_for(\n            self._async_event.wait(), microseconds / 1000000.)",
  "def on_schedule(self, event):\n        fps = self._max_fps\n        if not fps:\n            return\n\n        if not event.timeout or (\n                not self.interupt_next_only and event.timeout <=\n                1 / fps -  # remaining time\n                (self.time() - self._last_tick) +  # elapsed time\n                4 / 5. * self.get_resolution()):  # resolution fudge factor\n            self._event.set()\n            if self._async_event:\n                self._async_event.set()",
  "def idle(self):\n        fps = self._max_fps\n        event = self._event\n        resolution = self.get_resolution()\n        if fps > 0:\n            done, sleeptime = self._check_ready(\n                fps, resolution, 4 / 5. * resolution, event)\n            if not done:\n                event.wait(sleeptime)\n\n        current = self.time()\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        event.clear()\n        # anything scheduled from now on, if scheduled for the upcoming frame\n        # will cause a timeout of the event on the next idle due to on_schedule\n        # `self._last_tick = current` must happen before clear, otherwise the\n        # on_schedule computation is wrong when exec between the clear and\n        # the `self._last_tick = current` bytecode.\n        return current",
  "async def async_idle(self):\n        fps = self._max_fps\n        event = self._async_event\n        resolution = self.get_resolution()\n        if fps > 0:\n            done, sleeptime = self._check_ready(\n                fps, resolution, 4 / 5. * resolution, event)\n            if not done:\n                await self._async_wait_for(event.wait(), sleeptime)\n            else:\n                await self._async_lib.sleep(0)\n        else:\n            await self._async_lib.sleep(0)\n\n        current = self.time()\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        event.clear()\n        # anything scheduled from now on, if scheduled for the upcoming frame\n        # will cause a timeout of the event on the next idle due to on_schedule\n        # `self._last_tick = current` must happen before clear, otherwise the\n        # on_schedule computation is wrong when exec between the clear and\n        # the `self._last_tick = current` bytecode.\n        return current",
  "def _check_ready(self, fps, min_sleep, undershoot, event):\n        if event.is_set():\n            return True, 0\n\n        t = self._get_min_timeout_func()\n        if not t:\n            return True, 0\n\n        if not self.interupt_next_only:\n            curr_t = self.time()\n            sleeptime = min(1 / fps - (curr_t - self._last_tick), t - curr_t)\n        else:\n            sleeptime = 1 / fps - (self.time() - self._last_tick)\n        return sleeptime - undershoot <= min_sleep, sleeptime - undershoot",
  "def __init__(self, **kwargs):\n        super(ClockBaseInterruptFreeBehavior, self).__init__(**kwargs)\n        self._get_min_timeout_func = self.get_min_free_timeout",
  "def on_schedule(self, event):\n        if not event.free:  # only wake up for free events\n            return\n        # free events should use real time not frame time\n        event._last_dt = self.time()\n        return super(ClockBaseInterruptFreeBehavior,\n                     self).on_schedule(event)",
  "def __init__(self, **kwargs):\n        super(ClockBase, self).__init__(**kwargs)\n        self._sleep_obj = _get_sleep_obj()",
  "def usleep(self, microseconds):\n        _usleep(microseconds, self._sleep_obj)",
  "def idle(self):\n        fps = self._max_fps\n        current = self.time()\n        event = self._event\n        if fps > 0:\n            min_sleep = self.get_resolution()\n            usleep = self.usleep\n            undershoot = 4 / 5. * min_sleep\n            min_t = self.get_min_free_timeout\n            interupt_next_only = self.interupt_next_only\n\n            sleeptime = 1 / fps - (current - self._last_tick)\n            while sleeptime - undershoot > min_sleep:\n                if event.is_set():\n                    do_free = True\n                else:\n                    t = min_t()\n                    if not t:\n                        do_free = True\n                    elif interupt_next_only:\n                        do_free = False\n                    else:\n                        sleeptime = min(sleeptime, t - current)\n                        do_free = sleeptime - undershoot <= min_sleep\n\n                if do_free:\n                    event.clear()\n                    self._process_free_events(current)\n                else:\n                    event.wait(sleeptime - undershoot)\n                current = self.time()\n                sleeptime = 1 / fps - (current - self._last_tick)\n\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        event.clear()  # this needs to stay after _last_tick\n        return current",
  "async def async_idle(self):\n        fps = self._max_fps\n        current = self.time()\n        event = self._async_event\n        if fps > 0:\n            min_sleep = self.get_resolution()\n            usleep = self.usleep\n            undershoot = 4 / 5. * min_sleep\n            min_t = self.get_min_free_timeout\n            interupt_next_only = self.interupt_next_only\n\n            sleeptime = 1 / fps - (current - self._last_tick)\n            slept = False\n            while sleeptime - undershoot > min_sleep:\n                if event.is_set():\n                    do_free = True\n                else:\n                    t = min_t()\n                    if not t:\n                        do_free = True\n                    elif interupt_next_only:\n                        do_free = False\n                    else:\n                        sleeptime = min(sleeptime, t - current)\n                        do_free = sleeptime - undershoot <= min_sleep\n\n                if do_free:\n                    event.clear()\n                    self._process_free_events(current)\n                else:\n                    slept = True\n                    await self._async_wait_for(\n                        event.wait(), sleeptime - undershoot)\n                current = self.time()\n                sleeptime = 1 / fps - (current - self._last_tick)\n\n            if not slept:\n                await self._async_lib.sleep(0)\n        else:\n            await self._async_lib.sleep(0)\n\n        self._dt = current - self._last_tick\n        self._last_tick = current\n        event.clear()  # this needs to stay after _last_tick\n        return current",
  "def delayed_func(*args, **kwargs):\n        def callback_func(dt):\n            func(*args, **kwargs)\n        Clock.schedule_once(callback_func, 0)",
  "def wrapper_triggered(func):\n\n        _args = []\n        _kwargs = {}\n\n        def cb_function(dt):\n            func(*tuple(_args), **_kwargs)\n\n        cb_trigger = Clock.create_trigger(\n            cb_function,\n            timeout=timeout,\n            interval=interval)\n\n        @wraps(func)\n        def trigger_function(*args, **kwargs):\n            _args[:] = []\n            _args.extend(list(args))\n            _kwargs.clear()\n            _kwargs.update(kwargs)\n            cb_trigger()\n\n        def trigger_cancel():\n            cb_trigger.cancel()\n\n        setattr(trigger_function, 'cancel', trigger_cancel)\n\n        return trigger_function",
  "def _get_sleep_obj():  # noqa: F811\n            return _kernel32.CreateWaitableTimerA(None, True, None)",
  "def _usleep(microseconds, obj=None):\n            delay = ctypes.c_longlong(int(-microseconds * 10))\n            _kernel32.SetWaitableTimer(\n                obj, ctypes.byref(delay), 0,\n                ctypes.c_void_p(), ctypes.c_void_p(), False)\n            _kernel32.WaitForSingleObject(obj, 0xffffffff)",
  "def _usleep(microseconds, obj=None):\n            _libc_usleep(int(microseconds))",
  "def _usleep(microseconds, obj=None):\n        time.sleep(microseconds / 1000000.)",
  "def callback_func(dt):\n            func(*args, **kwargs)",
  "def cb_function(dt):\n            func(*tuple(_args), **_kwargs)",
  "def trigger_function(*args, **kwargs):\n            _args[:] = []\n            _args.extend(list(args))\n            _kwargs.clear()\n            _kwargs.update(kwargs)\n            cb_trigger()",
  "def trigger_cancel():\n            cb_trigger.cancel()",
  "def _libc_clock_gettime_wrapper():\n                from os import strerror\n\n                class struct_tv(ctypes.Structure):\n                    _fields_ = [('tv_sec', ctypes.c_long),\n                                ('tv_usec', ctypes.c_long)]\n\n                _clock_gettime = _libc.clock_gettime\n                _clock_gettime.argtypes = [ctypes.c_long,\n                                           ctypes.POINTER(struct_tv)]\n\n                if 'linux' in platform:\n                    _clockid = 4  # CLOCK_MONOTONIC_RAW (Linux specific)\n                elif 'freebsd' in platform:\n                    # clockid constants from sys/time.h\n                    # _clockid = 4 # CLOCK_MONOTONIC (FreeBSD specific)\n                    # 11: CLOCK_MONOTONIC_PRECISE (FreeBSD known OK for 10.2)\n                    _clockid = 11\n                    # _clockid = 12\n                    # 12: CLOCK_MONOTONIC_FAST (FreeBSD specific)\n                    Logger.debug('clock.py: {{{:s}}} clock ID {:d}'.format(\n                        platform, _clockid))\n                elif 'openbsd' in platform:\n                    _clockid = 3  # CLOCK_MONOTONIC\n                else:\n                    _clockid = 1  # CLOCK_MONOTONIC\n\n                tv = struct_tv()\n\n                def _time():\n                    if _clock_gettime(ctypes.c_long(_clockid),\n                                      ctypes.pointer(tv)) != 0:\n                        _ernno = ctypes.get_errno()\n                        raise OSError(_ernno, strerror(_ernno))\n                    return tv.tv_sec + (tv.tv_usec * 0.000000001)\n\n                return _time",
  "async def wait_for(coro, t):\n                with trio.move_on_after(t):\n                    await coro",
  "class struct_tv(ctypes.Structure):\n                    _fields_ = [('tv_sec', ctypes.c_long),\n                                ('tv_usec', ctypes.c_long)]",
  "def _time():\n                    if _clock_gettime(ctypes.c_long(_clockid),\n                                      ctypes.pointer(tv)) != 0:\n                        _ernno = ctypes.get_errno()\n                        raise OSError(_ernno, strerror(_ernno))\n                    return tv.tv_sec + (tv.tv_usec * 0.000000001)",
  "class ConfigParser(PythonConfigParser, object):\n    '''Enhanced ConfigParser class that supports the addition of default\n    sections and default values.\n\n    By default, the kivy ConfigParser instance, :attr:`~kivy.config.Config`,\n    is named `'kivy'` and the ConfigParser instance used by the\n    :meth:`App.build_settings <~kivy.app.App.build_settings>` method is named\n    `'app'`.\n\n    :Parameters:\n        `name`: string\n            The name of the instance. See :attr:`name`. Defaults to `''`.\n\n    .. versionchanged:: 1.9.0\n        Each ConfigParser can now be :attr:`named <name>`. You can get the\n        ConfigParser associated with a name using :meth:`get_configparser`.\n        In addition, you can now control the config values with\n        :class:`~kivy.properties.ConfigParserProperty`.\n\n    .. versionadded:: 1.0.7\n    '''\n\n    def __init__(self, name='', **kwargs):\n        PythonConfigParser.__init__(self, **kwargs)\n        self._sections = OrderedDict()\n        self.filename = None\n        self._callbacks = []\n        self.name = name\n\n    def add_callback(self, callback, section=None, key=None):\n        '''Add a callback to be called when a specific section or key has\n        changed. If you don't specify a section or key, it will call the\n        callback for all section/key changes.\n\n        Callbacks will receive 3 arguments: the section, key and value.\n\n        .. versionadded:: 1.4.1\n        '''\n        if section is None and key is not None:\n            raise Exception('You cannot specify a key without a section')\n        self._callbacks.append((callback, section, key))\n\n    def remove_callback(self, callback, section=None, key=None):\n        '''Removes a callback added with :meth:`add_callback`.\n        :meth:`remove_callback` must be called with the same parameters as\n        :meth:`add_callback`.\n\n        Raises a `ValueError` if not found.\n\n        .. versionadded:: 1.9.0\n        '''\n        self._callbacks.remove((callback, section, key))\n\n    def _do_callbacks(self, section, key, value):\n        for callback, csection, ckey in self._callbacks:\n            if csection is not None and csection != section:\n                continue\n            elif ckey is not None and ckey != key:\n                continue\n            callback(section, key, value)\n\n    def read(self, filename):\n        '''Read only one filename. In contrast to the original ConfigParser of\n        Python, this one is able to read only one file at a time. The last\n        read file will be used for the :meth:`write` method.\n\n        .. versionchanged:: 1.9.0\n            :meth:`read` now calls the callbacks if read changed any values.\n\n        '''\n        if not isinstance(filename, string_types):\n            raise Exception('Only one filename is accepted ({})'.format(\n                string_types.__name__))\n        self.filename = filename\n        # If we try to open directly the configuration file in utf-8,\n        # we correctly get the unicode value by default.\n        # But, when we try to save it again, all the values we didn't changed\n        # are still unicode, and then the PythonConfigParser internal do\n        # a str() conversion -> fail.\n        # Instead we currently to the conversion to utf-8 when value are\n        # \"get()\", but we internally store them in ascii.\n        # with codecs.open(filename, 'r', encoding='utf-8') as f:\n        #    self.readfp(f)\n        old_vals = {sect: {k: v for k, v in self.items(sect)} for sect in\n                    self.sections()}\n        PythonConfigParser.read(self, filename, encoding=\"utf-8-sig\")\n\n        # when reading new file, sections/keys are only increased, not removed\n        f = self._do_callbacks\n        for section in self.sections():\n            if section not in old_vals:  # new section\n                for k, v in self.items(section):\n                    f(section, k, v)\n                continue\n\n            old_keys = old_vals[section]\n            for k, v in self.items(section):  # just update new/changed keys\n                if k not in old_keys or v != old_keys[k]:\n                    f(section, k, v)\n\n    def set(self, section, option, value):\n        '''Functions similarly to PythonConfigParser's set method, except that\n        the value is implicitly converted to a string.\n        '''\n        e_value = value\n        if not isinstance(value, string_types):\n            # might be boolean, int, etc.\n            e_value = str(value)\n        ret = PythonConfigParser.set(self, section, option, e_value)\n        self._do_callbacks(section, option, value)\n        return ret\n\n    def setall(self, section, keyvalues):\n        '''Sets multiple key-value pairs in a section. keyvalues should be a\n        dictionary containing the key-value pairs to be set.\n        '''\n        for key, value in keyvalues.items():\n            self.set(section, key, value)\n\n    def get(self, section, option, **kwargs):\n        value = PythonConfigParser.get(self, section, option, **kwargs)\n        if PY2:\n            if type(value) is str:\n                return value.decode('utf-8')\n        return value\n\n    def setdefaults(self, section, keyvalues):\n        '''Set multiple key-value defaults in a section. keyvalues should be\n        a dictionary containing the new key-value defaults.\n        '''\n        self.adddefaultsection(section)\n        for key, value in keyvalues.items():\n            self.setdefault(section, key, value)\n\n    def setdefault(self, section, option, value):\n        '''Set the default value for an option in the specified section.\n        '''\n        if self.has_option(section, option):\n            return\n        self.set(section, option, value)\n\n    def getdefault(self, section, option, defaultvalue):\n        '''Get the value of an option in the specified section. If not found,\n        it will return the default value.\n        '''\n        if not self.has_section(section):\n            return defaultvalue\n        if not self.has_option(section, option):\n            return defaultvalue\n        return self.get(section, option)\n\n    def getdefaultint(self, section, option, defaultvalue):\n        '''Get the value of an option in the specified section. If not found,\n        it will return the default value. The value will always be\n        returned as an integer.\n\n        .. versionadded:: 1.6.0\n        '''\n        return int(self.getdefault(section, option, defaultvalue))\n\n    def adddefaultsection(self, section):\n        '''Add a section if the section is missing.\n        '''\n        assert \"_\" not in section\n        if self.has_section(section):\n            return\n        self.add_section(section)\n\n    def write(self):\n        '''Write the configuration to the last file opened using the\n        :meth:`read` method.\n\n        Return True if the write finished successfully, False otherwise.\n        '''\n        if self.filename is None:\n            return False\n        try:\n            with open(self.filename, 'w', encoding=\"utf-8\") as fd:\n                PythonConfigParser.write(self, fd)\n        except IOError:\n            Logger.exception('Unable to write the config <%s>' % self.filename)\n            return False\n        return True\n\n    def update_config(self, filename, overwrite=False):\n        '''Upgrade the configuration based on a new default config file.\n        Overwrite any existing values if overwrite is True.\n        '''\n        pcp = PythonConfigParser()\n        pcp.read(filename)\n        confset = self.setall if overwrite else self.setdefaults\n        for section in pcp.sections():\n            confset(section, dict(pcp.items(section)))\n        self.write()\n\n    @staticmethod\n    def _register_named_property(name, widget_ref, *largs):\n        ''' Called by the ConfigParserProperty to register a property which\n        was created with a config name instead of a config object.\n\n        When a ConfigParser with this name is later created, the properties\n        are then notified that this parser now exists so they can use it.\n        If the parser already exists, the property is notified here. See\n        :meth:`~kivy.properties.ConfigParserProperty.set_config`.\n\n        :Parameters:\n            `name`: a non-empty string\n                The name of the ConfigParser that is associated with the\n                property. See :attr:`name`.\n            `widget_ref`: 2-tuple.\n                The first element is a reference to the widget containing the\n                property, the second element is the name of the property. E.g.:\n\n                    class House(Widget):\n                        address = ConfigParserProperty('', 'info', 'street',\n                            'directory')\n\n                Then, the first element is a ref to a House instance, and the\n                second is `'address'`.\n        '''\n        configs = ConfigParser._named_configs\n        try:\n            config, props = configs[name]\n        except KeyError:\n            configs[name] = (None, [widget_ref])\n            return\n\n        props.append(widget_ref)\n        if config:\n            config = config()\n        widget = widget_ref[0]()\n\n        if config and widget:  # associate this config with property\n            widget.property(widget_ref[1]).set_config(config)\n\n    @staticmethod\n    def get_configparser(name):\n        '''Returns the :class:`ConfigParser` instance whose name is `name`, or\n        None if not found.\n\n        :Parameters:\n            `name`: string\n                The name of the :class:`ConfigParser` instance to return.\n        '''\n        try:\n            config = ConfigParser._named_configs[name][0]\n            if config is not None:\n                config = config()\n                if config is not None:\n                    return config\n            del ConfigParser._named_configs[name]\n        except KeyError:\n            return None\n\n    # keys are configparser names, values are 2-tuple of (ref(configparser),\n    # widget_ref), where widget_ref is same as in _register_named_property\n    _named_configs = {}\n    _name = ''\n\n    @property\n    def name(self):\n        ''' The name associated with this ConfigParser instance, if not `''`.\n        Defaults to `''`. It can be safely changed dynamically or set to `''`.\n\n        When a ConfigParser is given a name, that config object can be\n        retrieved using :meth:`get_configparser`. In addition, that config\n        instance can also be used with a\n        :class:`~kivy.properties.ConfigParserProperty` instance that set its\n        `config` value to this name.\n\n        Setting more than one ConfigParser with the same name will raise a\n        `ValueError`.\n        '''\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        old_name = self._name\n        if value is old_name:\n            return\n        self._name = value\n        configs = ConfigParser._named_configs\n\n        if old_name:  # disconnect this parser from previously connected props\n            _, props = configs.get(old_name, (None, []))\n            for widget, prop in props:\n                widget = widget()\n                if widget:\n                    widget.property(prop).set_config(None)\n            configs[old_name] = (None, props)\n\n        if not value:\n            return\n\n        # if given new name, connect it with property that used this name\n        try:\n            config, props = configs[value]\n        except KeyError:\n            configs[value] = (ref(self), [])\n            return\n\n        if config is not None and config() is not None:\n            raise ValueError('A parser named {} already exists'.format(value))\n        for widget, prop in props:\n            widget = widget()\n            if widget:\n                widget.property(prop).set_config(self)\n        configs[value] = (ref(self), props)",
  "def __init__(self, name='', **kwargs):\n        PythonConfigParser.__init__(self, **kwargs)\n        self._sections = OrderedDict()\n        self.filename = None\n        self._callbacks = []\n        self.name = name",
  "def add_callback(self, callback, section=None, key=None):\n        '''Add a callback to be called when a specific section or key has\n        changed. If you don't specify a section or key, it will call the\n        callback for all section/key changes.\n\n        Callbacks will receive 3 arguments: the section, key and value.\n\n        .. versionadded:: 1.4.1\n        '''\n        if section is None and key is not None:\n            raise Exception('You cannot specify a key without a section')\n        self._callbacks.append((callback, section, key))",
  "def remove_callback(self, callback, section=None, key=None):\n        '''Removes a callback added with :meth:`add_callback`.\n        :meth:`remove_callback` must be called with the same parameters as\n        :meth:`add_callback`.\n\n        Raises a `ValueError` if not found.\n\n        .. versionadded:: 1.9.0\n        '''\n        self._callbacks.remove((callback, section, key))",
  "def _do_callbacks(self, section, key, value):\n        for callback, csection, ckey in self._callbacks:\n            if csection is not None and csection != section:\n                continue\n            elif ckey is not None and ckey != key:\n                continue\n            callback(section, key, value)",
  "def read(self, filename):\n        '''Read only one filename. In contrast to the original ConfigParser of\n        Python, this one is able to read only one file at a time. The last\n        read file will be used for the :meth:`write` method.\n\n        .. versionchanged:: 1.9.0\n            :meth:`read` now calls the callbacks if read changed any values.\n\n        '''\n        if not isinstance(filename, string_types):\n            raise Exception('Only one filename is accepted ({})'.format(\n                string_types.__name__))\n        self.filename = filename\n        # If we try to open directly the configuration file in utf-8,\n        # we correctly get the unicode value by default.\n        # But, when we try to save it again, all the values we didn't changed\n        # are still unicode, and then the PythonConfigParser internal do\n        # a str() conversion -> fail.\n        # Instead we currently to the conversion to utf-8 when value are\n        # \"get()\", but we internally store them in ascii.\n        # with codecs.open(filename, 'r', encoding='utf-8') as f:\n        #    self.readfp(f)\n        old_vals = {sect: {k: v for k, v in self.items(sect)} for sect in\n                    self.sections()}\n        PythonConfigParser.read(self, filename, encoding=\"utf-8-sig\")\n\n        # when reading new file, sections/keys are only increased, not removed\n        f = self._do_callbacks\n        for section in self.sections():\n            if section not in old_vals:  # new section\n                for k, v in self.items(section):\n                    f(section, k, v)\n                continue\n\n            old_keys = old_vals[section]\n            for k, v in self.items(section):  # just update new/changed keys\n                if k not in old_keys or v != old_keys[k]:\n                    f(section, k, v)",
  "def set(self, section, option, value):\n        '''Functions similarly to PythonConfigParser's set method, except that\n        the value is implicitly converted to a string.\n        '''\n        e_value = value\n        if not isinstance(value, string_types):\n            # might be boolean, int, etc.\n            e_value = str(value)\n        ret = PythonConfigParser.set(self, section, option, e_value)\n        self._do_callbacks(section, option, value)\n        return ret",
  "def setall(self, section, keyvalues):\n        '''Sets multiple key-value pairs in a section. keyvalues should be a\n        dictionary containing the key-value pairs to be set.\n        '''\n        for key, value in keyvalues.items():\n            self.set(section, key, value)",
  "def get(self, section, option, **kwargs):\n        value = PythonConfigParser.get(self, section, option, **kwargs)\n        if PY2:\n            if type(value) is str:\n                return value.decode('utf-8')\n        return value",
  "def setdefaults(self, section, keyvalues):\n        '''Set multiple key-value defaults in a section. keyvalues should be\n        a dictionary containing the new key-value defaults.\n        '''\n        self.adddefaultsection(section)\n        for key, value in keyvalues.items():\n            self.setdefault(section, key, value)",
  "def setdefault(self, section, option, value):\n        '''Set the default value for an option in the specified section.\n        '''\n        if self.has_option(section, option):\n            return\n        self.set(section, option, value)",
  "def getdefault(self, section, option, defaultvalue):\n        '''Get the value of an option in the specified section. If not found,\n        it will return the default value.\n        '''\n        if not self.has_section(section):\n            return defaultvalue\n        if not self.has_option(section, option):\n            return defaultvalue\n        return self.get(section, option)",
  "def getdefaultint(self, section, option, defaultvalue):\n        '''Get the value of an option in the specified section. If not found,\n        it will return the default value. The value will always be\n        returned as an integer.\n\n        .. versionadded:: 1.6.0\n        '''\n        return int(self.getdefault(section, option, defaultvalue))",
  "def adddefaultsection(self, section):\n        '''Add a section if the section is missing.\n        '''\n        assert \"_\" not in section\n        if self.has_section(section):\n            return\n        self.add_section(section)",
  "def write(self):\n        '''Write the configuration to the last file opened using the\n        :meth:`read` method.\n\n        Return True if the write finished successfully, False otherwise.\n        '''\n        if self.filename is None:\n            return False\n        try:\n            with open(self.filename, 'w', encoding=\"utf-8\") as fd:\n                PythonConfigParser.write(self, fd)\n        except IOError:\n            Logger.exception('Unable to write the config <%s>' % self.filename)\n            return False\n        return True",
  "def update_config(self, filename, overwrite=False):\n        '''Upgrade the configuration based on a new default config file.\n        Overwrite any existing values if overwrite is True.\n        '''\n        pcp = PythonConfigParser()\n        pcp.read(filename)\n        confset = self.setall if overwrite else self.setdefaults\n        for section in pcp.sections():\n            confset(section, dict(pcp.items(section)))\n        self.write()",
  "def _register_named_property(name, widget_ref, *largs):\n        ''' Called by the ConfigParserProperty to register a property which\n        was created with a config name instead of a config object.\n\n        When a ConfigParser with this name is later created, the properties\n        are then notified that this parser now exists so they can use it.\n        If the parser already exists, the property is notified here. See\n        :meth:`~kivy.properties.ConfigParserProperty.set_config`.\n\n        :Parameters:\n            `name`: a non-empty string\n                The name of the ConfigParser that is associated with the\n                property. See :attr:`name`.\n            `widget_ref`: 2-tuple.\n                The first element is a reference to the widget containing the\n                property, the second element is the name of the property. E.g.:\n\n                    class House(Widget):\n                        address = ConfigParserProperty('', 'info', 'street',\n                            'directory')\n\n                Then, the first element is a ref to a House instance, and the\n                second is `'address'`.\n        '''\n        configs = ConfigParser._named_configs\n        try:\n            config, props = configs[name]\n        except KeyError:\n            configs[name] = (None, [widget_ref])\n            return\n\n        props.append(widget_ref)\n        if config:\n            config = config()\n        widget = widget_ref[0]()\n\n        if config and widget:  # associate this config with property\n            widget.property(widget_ref[1]).set_config(config)",
  "def get_configparser(name):\n        '''Returns the :class:`ConfigParser` instance whose name is `name`, or\n        None if not found.\n\n        :Parameters:\n            `name`: string\n                The name of the :class:`ConfigParser` instance to return.\n        '''\n        try:\n            config = ConfigParser._named_configs[name][0]\n            if config is not None:\n                config = config()\n                if config is not None:\n                    return config\n            del ConfigParser._named_configs[name]\n        except KeyError:\n            return None",
  "def name(self):\n        ''' The name associated with this ConfigParser instance, if not `''`.\n        Defaults to `''`. It can be safely changed dynamically or set to `''`.\n\n        When a ConfigParser is given a name, that config object can be\n        retrieved using :meth:`get_configparser`. In addition, that config\n        instance can also be used with a\n        :class:`~kivy.properties.ConfigParserProperty` instance that set its\n        `config` value to this name.\n\n        Setting more than one ConfigParser with the same name will raise a\n        `ValueError`.\n        '''\n        return self._name",
  "def name(self, value):\n        old_name = self._name\n        if value is old_name:\n            return\n        self._name = value\n        configs = ConfigParser._named_configs\n\n        if old_name:  # disconnect this parser from previously connected props\n            _, props = configs.get(old_name, (None, []))\n            for widget, prop in props:\n                widget = widget()\n                if widget:\n                    widget.property(prop).set_config(None)\n            configs[old_name] = (None, props)\n\n        if not value:\n            return\n\n        # if given new name, connect it with property that used this name\n        try:\n            config, props = configs[value]\n        except KeyError:\n            configs[value] = (ref(self), [])\n            return\n\n        if config is not None and config() is not None:\n            raise ValueError('A parser named {} already exists'.format(value))\n        for widget, prop in props:\n            widget = widget()\n            if widget:\n                widget.property(prop).set_config(self)\n        configs[value] = (ref(self), props)",
  "class Animation(EventDispatcher):\n    '''Create an animation definition that can be used to animate a Widget.\n\n    :Parameters:\n        `duration` or `d`: float, defaults to 1.\n            Duration of the animation, in seconds.\n        `transition` or `t`: str or func\n            Transition function for animate properties. It can be the name of a\n            method from :class:`AnimationTransition`.\n        `step` or `s`: float\n            Step in milliseconds of the animation. Defaults to 0, which means\n            the animation is updated for every frame.\n\n            To update the animation less often, set the step value to a float.\n            For example, if you want to animate at 30 FPS, use s=1/30.\n\n    :Events:\n        `on_start`: animation, widget\n            Fired when the animation is started on a widget.\n        `on_complete`: animation, widget\n            Fired when the animation is completed or stopped on a widget.\n        `on_progress`: animation, widget, progression\n            Fired when the progression of the animation is changing.\n\n    .. versionchanged:: 1.4.0\n        Added s/step parameter.\n\n    .. versionchanged:: 1.10.0\n        The default value of the step parameter was changed from 1/60. to 0.\n    '''\n\n    _update_ev = None\n\n    _instances = set()\n\n    __events__ = ('on_start', 'on_progress', 'on_complete')\n\n    def __init__(self, **kw):\n        super().__init__()\n        # Initialize\n        self._clock_installed = False\n        self._duration = kw.pop('d', kw.pop('duration', 1.))\n        self._transition = kw.pop('t', kw.pop('transition', 'linear'))\n        self._step = kw.pop('s', kw.pop('step', 0))\n        if isinstance(self._transition, string_types):\n            self._transition = getattr(AnimationTransition, self._transition)\n        self._animated_properties = kw\n        self._widgets = {}\n\n    @property\n    def duration(self):\n        '''Return the duration of the animation.\n        '''\n        return self._duration\n\n    @property\n    def transition(self):\n        '''Return the transition of the animation.\n        '''\n        return self._transition\n\n    @property\n    def animated_properties(self):\n        '''Return the properties used to animate.\n        '''\n        return self._animated_properties\n\n    @staticmethod\n    def stop_all(widget, *largs):\n        '''Stop all animations that concern a specific widget / list of\n        properties.\n\n        Example::\n\n            anim = Animation(x=50)\n            anim.start(widget)\n\n            # and later\n            Animation.stop_all(widget, 'x')\n        '''\n        if len(largs):\n            for animation in list(Animation._instances):\n                for x in largs:\n                    animation.stop_property(widget, x)\n        else:\n            for animation in set(Animation._instances):\n                animation.stop(widget)\n\n    @staticmethod\n    def cancel_all(widget, *largs):\n        '''Cancel all animations that concern a specific widget / list of\n        properties. See :attr:`cancel`.\n\n        Example::\n\n            anim = Animation(x=50)\n            anim.start(widget)\n\n            # and later\n            Animation.cancel_all(widget, 'x')\n\n        .. versionadded:: 1.4.0\n\n        .. versionchanged:: 2.1.0\n            If the parameter ``widget`` is None, all animated widgets will be\n            the target and cancelled. If ``largs`` is also given, animation of\n            these properties will be canceled for all animated widgets.\n        '''\n        if widget is None:\n            if largs:\n                for animation in Animation._instances.copy():\n                    for info in tuple(animation._widgets.values()):\n                        widget = info['widget']\n                        for x in largs:\n                            animation.cancel_property(widget, x)\n            else:\n                for animation in Animation._instances:\n                    animation._widgets.clear()\n                    animation._clock_uninstall()\n                Animation._instances.clear()\n            return\n        if len(largs):\n            for animation in list(Animation._instances):\n                for x in largs:\n                    animation.cancel_property(widget, x)\n        else:\n            for animation in set(Animation._instances):\n                animation.cancel(widget)\n\n    def start(self, widget):\n        '''Start the animation on a widget.\n        '''\n        self.stop(widget)\n        self._initialize(widget)\n        self._register()\n        self.dispatch('on_start', widget)\n\n    def stop(self, widget):\n        '''Stop the animation previously applied to a widget, triggering the\n        `on_complete` event.'''\n        props = self._widgets.pop(widget.uid, None)\n        if props:\n            self.dispatch('on_complete', widget)\n        self.cancel(widget)\n\n    def cancel(self, widget):\n        '''Cancel the animation previously applied to a widget. Same\n        effect as :attr:`stop`, except the `on_complete` event will\n        *not* be triggered!\n\n        .. versionadded:: 1.4.0\n        '''\n        self._widgets.pop(widget.uid, None)\n        self._clock_uninstall()\n        if not self._widgets:\n            self._unregister()\n\n    def stop_property(self, widget, prop):\n        '''Even if an animation is running, remove a property. It will not be\n        animated further. If it was the only/last property being animated,\n        the animation will be stopped (see :attr:`stop`).\n        '''\n        props = self._widgets.get(widget.uid, None)\n        if not props:\n            return\n        props['properties'].pop(prop, None)\n\n        # no more properties to animation ? kill the animation.\n        if not props['properties']:\n            self.stop(widget)\n\n    def cancel_property(self, widget, prop):\n        '''Even if an animation is running, remove a property. It will not be\n        animated further. If it was the only/last property being animated,\n        the animation will be canceled (see :attr:`cancel`)\n\n        .. versionadded:: 1.4.0\n        '''\n        props = self._widgets.get(widget.uid, None)\n        if not props:\n            return\n        props['properties'].pop(prop, None)\n\n        # no more properties to animation ? kill the animation.\n        if not props['properties']:\n            self.cancel(widget)\n\n    def have_properties_to_animate(self, widget):\n        '''Return True if a widget still has properties to animate.\n\n        .. versionadded:: 1.8.0\n        '''\n        props = self._widgets.get(widget.uid, None)\n        if props and props['properties']:\n            return True\n\n    #\n    # Private\n    #\n    def _register(self):\n        Animation._instances.add(self)\n\n    def _unregister(self):\n        Animation._instances.discard(self)\n\n    def _initialize(self, widget):\n        d = self._widgets[widget.uid] = {\n            'widget': widget,\n            'properties': {},\n            'time': None}\n\n        # get current values\n        p = d['properties']\n        for key, value in self._animated_properties.items():\n            original_value = getattr(widget, key)\n            if isinstance(original_value, (tuple, list)):\n                original_value = original_value[:]\n            elif isinstance(original_value, dict):\n                original_value = original_value.copy()\n            p[key] = (original_value, value)\n\n        # install clock\n        self._clock_install()\n\n    def _clock_install(self):\n        if self._clock_installed:\n            return\n        self._update_ev = Clock.schedule_interval(self._update, self._step)\n        self._clock_installed = True\n\n    def _clock_uninstall(self):\n        if self._widgets or not self._clock_installed:\n            return\n        self._clock_installed = False\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n            self._update_ev = None\n\n    def _update(self, dt):\n        widgets = self._widgets\n        transition = self._transition\n        calculate = self._calculate\n        for uid in list(widgets.keys()):\n            anim = widgets[uid]\n            widget = anim['widget']\n\n            if isinstance(widget, WeakProxy) and not len(dir(widget)):\n                # empty proxy, widget is gone. ref: #2458\n                self._widgets.pop(uid, None)\n                self._clock_uninstall()\n                if not self._widgets:\n                    self._unregister()\n                continue\n\n            if anim['time'] is None:\n                anim['time'] = 0.\n            else:\n                anim['time'] += dt\n\n            # calculate progression\n            if self._duration:\n                progress = min(1., anim['time'] / self._duration)\n            else:\n                progress = 1\n            t = transition(progress)\n\n            # apply progression on widget\n            for key, values in anim['properties'].items():\n                a, b = values\n                value = calculate(a, b, t)\n                setattr(widget, key, value)\n\n            self.dispatch('on_progress', widget, progress)\n\n            # time to stop ?\n            if progress >= 1.:\n                self.stop(widget)\n\n    def _calculate(self, a, b, t):\n        _calculate = self._calculate\n        if isinstance(a, list) or isinstance(a, tuple):\n            if isinstance(a, list):\n                tp = list\n            else:\n                tp = tuple\n            return tp([_calculate(a[x], b[x], t) for x in range(len(a))])\n        elif isinstance(a, dict):\n            d = {}\n            for x in iterkeys(a):\n                if x not in b:\n                    # User requested to animate only part of the dict.\n                    # Copy the rest\n                    d[x] = a[x]\n                else:\n                    d[x] = _calculate(a[x], b[x], t)\n            return d\n        else:\n            return (a * (1. - t)) + (b * t)\n\n    #\n    # Default handlers\n    #\n    def on_start(self, widget):\n        pass\n\n    def on_progress(self, widget, progress):\n        pass\n\n    def on_complete(self, widget):\n        pass\n\n    def __add__(self, animation):\n        return Sequence(self, animation)\n\n    def __and__(self, animation):\n        return Parallel(self, animation)",
  "class CompoundAnimation(Animation):\n\n    def stop_property(self, widget, prop):\n        self.anim1.stop_property(widget, prop)\n        self.anim2.stop_property(widget, prop)\n        if (not self.anim1.have_properties_to_animate(widget) and\n                not self.anim2.have_properties_to_animate(widget)):\n            self.stop(widget)\n\n    def cancel(self, widget):\n        self.anim1.cancel(widget)\n        self.anim2.cancel(widget)\n        super().cancel(widget)\n\n    def cancel_property(self, widget, prop):\n        '''Even if an animation is running, remove a property. It will not be\n        animated further. If it was the only/last property being animated,\n        the animation will be canceled (see :attr:`cancel`)\n\n        This method overrides `:class:kivy.animation.Animation`'s\n        version, to cancel it on all animations of the Sequence.\n\n        .. versionadded:: 1.10.0\n        '''\n        self.anim1.cancel_property(widget, prop)\n        self.anim2.cancel_property(widget, prop)\n        if (not self.anim1.have_properties_to_animate(widget) and\n                not self.anim2.have_properties_to_animate(widget)):\n            self.cancel(widget)\n\n    def have_properties_to_animate(self, widget):\n        return (self.anim1.have_properties_to_animate(widget) or\n                self.anim2.have_properties_to_animate(widget))\n\n    @property\n    def animated_properties(self):\n        return ChainMap({},\n                        self.anim2.animated_properties,\n                        self.anim1.animated_properties)\n\n    @property\n    def transition(self):\n        # This property is impossible to implement\n        raise AttributeError(\n            \"Can't lookup transition attribute of a CompoundAnimation\")",
  "class Sequence(CompoundAnimation):\n\n    def __init__(self, anim1, anim2):\n        super().__init__()\n\n        #: Repeat the sequence. See 'Repeating animation' in the header\n        #: documentation.\n        self.repeat = False\n\n        self.anim1 = anim1\n        self.anim2 = anim2\n\n        self.anim1.bind(on_complete=self.on_anim1_complete,\n                        on_progress=self.on_anim1_progress)\n        self.anim2.bind(on_complete=self.on_anim2_complete,\n                        on_progress=self.on_anim2_progress)\n\n    @property\n    def duration(self):\n        return self.anim1.duration + self.anim2.duration\n\n    def stop(self, widget):\n        props = self._widgets.pop(widget.uid, None)\n        self.anim1.stop(widget)\n        self.anim2.stop(widget)\n        if props:\n            self.dispatch('on_complete', widget)\n        super().cancel(widget)\n\n    def start(self, widget):\n        self.stop(widget)\n        self._widgets[widget.uid] = True\n        self._register()\n        self.dispatch('on_start', widget)\n        self.anim1.start(widget)\n\n    def on_anim1_complete(self, instance, widget):\n        if widget.uid not in self._widgets:\n            return\n        self.anim2.start(widget)\n\n    def on_anim1_progress(self, instance, widget, progress):\n        self.dispatch('on_progress', widget, progress / 2.)\n\n    def on_anim2_complete(self, instance, widget):\n        '''Repeating logic used with boolean variable \"repeat\".\n\n        .. versionadded:: 1.7.1\n        '''\n        if widget.uid not in self._widgets:\n            return\n        if self.repeat:\n            self.anim1.start(widget)\n        else:\n            self.dispatch('on_complete', widget)\n            self.cancel(widget)\n\n    def on_anim2_progress(self, instance, widget, progress):\n        self.dispatch('on_progress', widget, .5 + progress / 2.)",
  "class Parallel(CompoundAnimation):\n\n    def __init__(self, anim1, anim2):\n        super().__init__()\n        self.anim1 = anim1\n        self.anim2 = anim2\n\n        self.anim1.bind(on_complete=self.on_anim_complete)\n        self.anim2.bind(on_complete=self.on_anim_complete)\n\n    @property\n    def duration(self):\n        return max(self.anim1.duration, self.anim2.duration)\n\n    def stop(self, widget):\n        self.anim1.stop(widget)\n        self.anim2.stop(widget)\n        if self._widgets.pop(widget.uid, None):\n            self.dispatch('on_complete', widget)\n        super().cancel(widget)\n\n    def start(self, widget):\n        self.stop(widget)\n        self.anim1.start(widget)\n        self.anim2.start(widget)\n        self._widgets[widget.uid] = {'complete': 0}\n        self._register()\n        self.dispatch('on_start', widget)\n\n    def on_anim_complete(self, instance, widget):\n        self._widgets[widget.uid]['complete'] += 1\n        if self._widgets[widget.uid]['complete'] == 2:\n            self.stop(widget)",
  "class AnimationTransition:\n    '''Collection of animation functions to be used with the Animation object.\n    Easing Functions ported to Kivy from the Clutter Project\n    https://developer.gnome.org/clutter/stable/ClutterAlpha.html\n\n    The `progress` parameter in each animation function is in the range 0-1.\n    '''\n\n    @staticmethod\n    def linear(progress):\n        '''.. image:: images/anim_linear.png'''\n        return progress\n\n    @staticmethod\n    def in_quad(progress):\n        '''.. image:: images/anim_in_quad.png\n        '''\n        return progress * progress\n\n    @staticmethod\n    def out_quad(progress):\n        '''.. image:: images/anim_out_quad.png\n        '''\n        return -1.0 * progress * (progress - 2.0)\n\n    @staticmethod\n    def in_out_quad(progress):\n        '''.. image:: images/anim_in_out_quad.png\n        '''\n        p = progress * 2\n        if p < 1:\n            return 0.5 * p * p\n        p -= 1.0\n        return -0.5 * (p * (p - 2.0) - 1.0)\n\n    @staticmethod\n    def in_cubic(progress):\n        '''.. image:: images/anim_in_cubic.png\n        '''\n        return progress * progress * progress\n\n    @staticmethod\n    def out_cubic(progress):\n        '''.. image:: images/anim_out_cubic.png\n        '''\n        p = progress - 1.0\n        return p * p * p + 1.0\n\n    @staticmethod\n    def in_out_cubic(progress):\n        '''.. image:: images/anim_in_out_cubic.png\n        '''\n        p = progress * 2\n        if p < 1:\n            return 0.5 * p * p * p\n        p -= 2\n        return 0.5 * (p * p * p + 2.0)\n\n    @staticmethod\n    def in_quart(progress):\n        '''.. image:: images/anim_in_quart.png\n        '''\n        return progress * progress * progress * progress\n\n    @staticmethod\n    def out_quart(progress):\n        '''.. image:: images/anim_out_quart.png\n        '''\n        p = progress - 1.0\n        return -1.0 * (p * p * p * p - 1.0)\n\n    @staticmethod\n    def in_out_quart(progress):\n        '''.. image:: images/anim_in_out_quart.png\n        '''\n        p = progress * 2\n        if p < 1:\n            return 0.5 * p * p * p * p\n        p -= 2\n        return -0.5 * (p * p * p * p - 2.0)\n\n    @staticmethod\n    def in_quint(progress):\n        '''.. image:: images/anim_in_quint.png\n        '''\n        return progress * progress * progress * progress * progress\n\n    @staticmethod\n    def out_quint(progress):\n        '''.. image:: images/anim_out_quint.png\n        '''\n        p = progress - 1.0\n        return p * p * p * p * p + 1.0\n\n    @staticmethod\n    def in_out_quint(progress):\n        '''.. image:: images/anim_in_out_quint.png\n        '''\n        p = progress * 2\n        if p < 1:\n            return 0.5 * p * p * p * p * p\n        p -= 2.0\n        return 0.5 * (p * p * p * p * p + 2.0)\n\n    @staticmethod\n    def in_sine(progress):\n        '''.. image:: images/anim_in_sine.png\n        '''\n        return -1.0 * cos(progress * (pi / 2.0)) + 1.0\n\n    @staticmethod\n    def out_sine(progress):\n        '''.. image:: images/anim_out_sine.png\n        '''\n        return sin(progress * (pi / 2.0))\n\n    @staticmethod\n    def in_out_sine(progress):\n        '''.. image:: images/anim_in_out_sine.png\n        '''\n        return -0.5 * (cos(pi * progress) - 1.0)\n\n    @staticmethod\n    def in_expo(progress):\n        '''.. image:: images/anim_in_expo.png\n        '''\n        if progress == 0:\n            return 0.0\n        return pow(2, 10 * (progress - 1.0))\n\n    @staticmethod\n    def out_expo(progress):\n        '''.. image:: images/anim_out_expo.png\n        '''\n        if progress == 1.0:\n            return 1.0\n        return -pow(2, -10 * progress) + 1.0\n\n    @staticmethod\n    def in_out_expo(progress):\n        '''.. image:: images/anim_in_out_expo.png\n        '''\n        if progress == 0:\n            return 0.0\n        if progress == 1.:\n            return 1.0\n        p = progress * 2\n        if p < 1:\n            return 0.5 * pow(2, 10 * (p - 1.0))\n        p -= 1.0\n        return 0.5 * (-pow(2, -10 * p) + 2.0)\n\n    @staticmethod\n    def in_circ(progress):\n        '''.. image:: images/anim_in_circ.png\n        '''\n        return -1.0 * (sqrt(1.0 - progress * progress) - 1.0)\n\n    @staticmethod\n    def out_circ(progress):\n        '''.. image:: images/anim_out_circ.png\n        '''\n        p = progress - 1.0\n        return sqrt(1.0 - p * p)\n\n    @staticmethod\n    def in_out_circ(progress):\n        '''.. image:: images/anim_in_out_circ.png\n        '''\n        p = progress * 2\n        if p < 1:\n            return -0.5 * (sqrt(1.0 - p * p) - 1.0)\n        p -= 2.0\n        return 0.5 * (sqrt(1.0 - p * p) + 1.0)\n\n    @staticmethod\n    def in_elastic(progress):\n        '''.. image:: images/anim_in_elastic.png\n        '''\n        p = .3\n        s = p / 4.0\n        q = progress\n        if q == 1:\n            return 1.0\n        q -= 1.0\n        return -(pow(2, 10 * q) * sin((q - s) * (2 * pi) / p))\n\n    @staticmethod\n    def out_elastic(progress):\n        '''.. image:: images/anim_out_elastic.png\n        '''\n        p = .3\n        s = p / 4.0\n        q = progress\n        if q == 1:\n            return 1.0\n        return pow(2, -10 * q) * sin((q - s) * (2 * pi) / p) + 1.0\n\n    @staticmethod\n    def in_out_elastic(progress):\n        '''.. image:: images/anim_in_out_elastic.png\n        '''\n        p = .3 * 1.5\n        s = p / 4.0\n        q = progress * 2\n        if q == 2:\n            return 1.0\n        if q < 1:\n            q -= 1.0\n            return -.5 * (pow(2, 10 * q) * sin((q - s) * (2.0 * pi) / p))\n        else:\n            q -= 1.0\n            return pow(2, -10 * q) * sin((q - s) * (2.0 * pi) / p) * .5 + 1.0\n\n    @staticmethod\n    def in_back(progress):\n        '''.. image:: images/anim_in_back.png\n        '''\n        return progress * progress * ((1.70158 + 1.0) * progress - 1.70158)\n\n    @staticmethod\n    def out_back(progress):\n        '''.. image:: images/anim_out_back.png\n        '''\n        p = progress - 1.0\n        return p * p * ((1.70158 + 1) * p + 1.70158) + 1.0\n\n    @staticmethod\n    def in_out_back(progress):\n        '''.. image:: images/anim_in_out_back.png\n        '''\n        p = progress * 2.\n        s = 1.70158 * 1.525\n        if p < 1:\n            return 0.5 * (p * p * ((s + 1.0) * p - s))\n        p -= 2.0\n        return 0.5 * (p * p * ((s + 1.0) * p + s) + 2.0)\n\n    @staticmethod\n    def _out_bounce_internal(t, d):\n        p = t / d\n        if p < (1.0 / 2.75):\n            return 7.5625 * p * p\n        elif p < (2.0 / 2.75):\n            p -= (1.5 / 2.75)\n            return 7.5625 * p * p + .75\n        elif p < (2.5 / 2.75):\n            p -= (2.25 / 2.75)\n            return 7.5625 * p * p + .9375\n        else:\n            p -= (2.625 / 2.75)\n            return 7.5625 * p * p + .984375\n\n    @staticmethod\n    def _in_bounce_internal(t, d):\n        return 1.0 - AnimationTransition._out_bounce_internal(d - t, d)\n\n    @staticmethod\n    def in_bounce(progress):\n        '''.. image:: images/anim_in_bounce.png\n        '''\n        return AnimationTransition._in_bounce_internal(progress, 1.)\n\n    @staticmethod\n    def out_bounce(progress):\n        '''.. image:: images/anim_out_bounce.png\n        '''\n        return AnimationTransition._out_bounce_internal(progress, 1.)\n\n    @staticmethod\n    def in_out_bounce(progress):\n        '''.. image:: images/anim_in_out_bounce.png\n        '''\n        p = progress * 2.\n        if p < 1.:\n            return AnimationTransition._in_bounce_internal(p, 1.) * .5\n        return AnimationTransition._out_bounce_internal(p - 1., 1.) * .5 + .5",
  "def __init__(self, **kw):\n        super().__init__()\n        # Initialize\n        self._clock_installed = False\n        self._duration = kw.pop('d', kw.pop('duration', 1.))\n        self._transition = kw.pop('t', kw.pop('transition', 'linear'))\n        self._step = kw.pop('s', kw.pop('step', 0))\n        if isinstance(self._transition, string_types):\n            self._transition = getattr(AnimationTransition, self._transition)\n        self._animated_properties = kw\n        self._widgets = {}",
  "def duration(self):\n        '''Return the duration of the animation.\n        '''\n        return self._duration",
  "def transition(self):\n        '''Return the transition of the animation.\n        '''\n        return self._transition",
  "def animated_properties(self):\n        '''Return the properties used to animate.\n        '''\n        return self._animated_properties",
  "def stop_all(widget, *largs):\n        '''Stop all animations that concern a specific widget / list of\n        properties.\n\n        Example::\n\n            anim = Animation(x=50)\n            anim.start(widget)\n\n            # and later\n            Animation.stop_all(widget, 'x')\n        '''\n        if len(largs):\n            for animation in list(Animation._instances):\n                for x in largs:\n                    animation.stop_property(widget, x)\n        else:\n            for animation in set(Animation._instances):\n                animation.stop(widget)",
  "def cancel_all(widget, *largs):\n        '''Cancel all animations that concern a specific widget / list of\n        properties. See :attr:`cancel`.\n\n        Example::\n\n            anim = Animation(x=50)\n            anim.start(widget)\n\n            # and later\n            Animation.cancel_all(widget, 'x')\n\n        .. versionadded:: 1.4.0\n\n        .. versionchanged:: 2.1.0\n            If the parameter ``widget`` is None, all animated widgets will be\n            the target and cancelled. If ``largs`` is also given, animation of\n            these properties will be canceled for all animated widgets.\n        '''\n        if widget is None:\n            if largs:\n                for animation in Animation._instances.copy():\n                    for info in tuple(animation._widgets.values()):\n                        widget = info['widget']\n                        for x in largs:\n                            animation.cancel_property(widget, x)\n            else:\n                for animation in Animation._instances:\n                    animation._widgets.clear()\n                    animation._clock_uninstall()\n                Animation._instances.clear()\n            return\n        if len(largs):\n            for animation in list(Animation._instances):\n                for x in largs:\n                    animation.cancel_property(widget, x)\n        else:\n            for animation in set(Animation._instances):\n                animation.cancel(widget)",
  "def start(self, widget):\n        '''Start the animation on a widget.\n        '''\n        self.stop(widget)\n        self._initialize(widget)\n        self._register()\n        self.dispatch('on_start', widget)",
  "def stop(self, widget):\n        '''Stop the animation previously applied to a widget, triggering the\n        `on_complete` event.'''\n        props = self._widgets.pop(widget.uid, None)\n        if props:\n            self.dispatch('on_complete', widget)\n        self.cancel(widget)",
  "def cancel(self, widget):\n        '''Cancel the animation previously applied to a widget. Same\n        effect as :attr:`stop`, except the `on_complete` event will\n        *not* be triggered!\n\n        .. versionadded:: 1.4.0\n        '''\n        self._widgets.pop(widget.uid, None)\n        self._clock_uninstall()\n        if not self._widgets:\n            self._unregister()",
  "def stop_property(self, widget, prop):\n        '''Even if an animation is running, remove a property. It will not be\n        animated further. If it was the only/last property being animated,\n        the animation will be stopped (see :attr:`stop`).\n        '''\n        props = self._widgets.get(widget.uid, None)\n        if not props:\n            return\n        props['properties'].pop(prop, None)\n\n        # no more properties to animation ? kill the animation.\n        if not props['properties']:\n            self.stop(widget)",
  "def cancel_property(self, widget, prop):\n        '''Even if an animation is running, remove a property. It will not be\n        animated further. If it was the only/last property being animated,\n        the animation will be canceled (see :attr:`cancel`)\n\n        .. versionadded:: 1.4.0\n        '''\n        props = self._widgets.get(widget.uid, None)\n        if not props:\n            return\n        props['properties'].pop(prop, None)\n\n        # no more properties to animation ? kill the animation.\n        if not props['properties']:\n            self.cancel(widget)",
  "def have_properties_to_animate(self, widget):\n        '''Return True if a widget still has properties to animate.\n\n        .. versionadded:: 1.8.0\n        '''\n        props = self._widgets.get(widget.uid, None)\n        if props and props['properties']:\n            return True",
  "def _register(self):\n        Animation._instances.add(self)",
  "def _unregister(self):\n        Animation._instances.discard(self)",
  "def _initialize(self, widget):\n        d = self._widgets[widget.uid] = {\n            'widget': widget,\n            'properties': {},\n            'time': None}\n\n        # get current values\n        p = d['properties']\n        for key, value in self._animated_properties.items():\n            original_value = getattr(widget, key)\n            if isinstance(original_value, (tuple, list)):\n                original_value = original_value[:]\n            elif isinstance(original_value, dict):\n                original_value = original_value.copy()\n            p[key] = (original_value, value)\n\n        # install clock\n        self._clock_install()",
  "def _clock_install(self):\n        if self._clock_installed:\n            return\n        self._update_ev = Clock.schedule_interval(self._update, self._step)\n        self._clock_installed = True",
  "def _clock_uninstall(self):\n        if self._widgets or not self._clock_installed:\n            return\n        self._clock_installed = False\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n            self._update_ev = None",
  "def _update(self, dt):\n        widgets = self._widgets\n        transition = self._transition\n        calculate = self._calculate\n        for uid in list(widgets.keys()):\n            anim = widgets[uid]\n            widget = anim['widget']\n\n            if isinstance(widget, WeakProxy) and not len(dir(widget)):\n                # empty proxy, widget is gone. ref: #2458\n                self._widgets.pop(uid, None)\n                self._clock_uninstall()\n                if not self._widgets:\n                    self._unregister()\n                continue\n\n            if anim['time'] is None:\n                anim['time'] = 0.\n            else:\n                anim['time'] += dt\n\n            # calculate progression\n            if self._duration:\n                progress = min(1., anim['time'] / self._duration)\n            else:\n                progress = 1\n            t = transition(progress)\n\n            # apply progression on widget\n            for key, values in anim['properties'].items():\n                a, b = values\n                value = calculate(a, b, t)\n                setattr(widget, key, value)\n\n            self.dispatch('on_progress', widget, progress)\n\n            # time to stop ?\n            if progress >= 1.:\n                self.stop(widget)",
  "def _calculate(self, a, b, t):\n        _calculate = self._calculate\n        if isinstance(a, list) or isinstance(a, tuple):\n            if isinstance(a, list):\n                tp = list\n            else:\n                tp = tuple\n            return tp([_calculate(a[x], b[x], t) for x in range(len(a))])\n        elif isinstance(a, dict):\n            d = {}\n            for x in iterkeys(a):\n                if x not in b:\n                    # User requested to animate only part of the dict.\n                    # Copy the rest\n                    d[x] = a[x]\n                else:\n                    d[x] = _calculate(a[x], b[x], t)\n            return d\n        else:\n            return (a * (1. - t)) + (b * t)",
  "def on_start(self, widget):\n        pass",
  "def on_progress(self, widget, progress):\n        pass",
  "def on_complete(self, widget):\n        pass",
  "def __add__(self, animation):\n        return Sequence(self, animation)",
  "def __and__(self, animation):\n        return Parallel(self, animation)",
  "def stop_property(self, widget, prop):\n        self.anim1.stop_property(widget, prop)\n        self.anim2.stop_property(widget, prop)\n        if (not self.anim1.have_properties_to_animate(widget) and\n                not self.anim2.have_properties_to_animate(widget)):\n            self.stop(widget)",
  "def cancel(self, widget):\n        self.anim1.cancel(widget)\n        self.anim2.cancel(widget)\n        super().cancel(widget)",
  "def cancel_property(self, widget, prop):\n        '''Even if an animation is running, remove a property. It will not be\n        animated further. If it was the only/last property being animated,\n        the animation will be canceled (see :attr:`cancel`)\n\n        This method overrides `:class:kivy.animation.Animation`'s\n        version, to cancel it on all animations of the Sequence.\n\n        .. versionadded:: 1.10.0\n        '''\n        self.anim1.cancel_property(widget, prop)\n        self.anim2.cancel_property(widget, prop)\n        if (not self.anim1.have_properties_to_animate(widget) and\n                not self.anim2.have_properties_to_animate(widget)):\n            self.cancel(widget)",
  "def have_properties_to_animate(self, widget):\n        return (self.anim1.have_properties_to_animate(widget) or\n                self.anim2.have_properties_to_animate(widget))",
  "def animated_properties(self):\n        return ChainMap({},\n                        self.anim2.animated_properties,\n                        self.anim1.animated_properties)",
  "def transition(self):\n        # This property is impossible to implement\n        raise AttributeError(\n            \"Can't lookup transition attribute of a CompoundAnimation\")",
  "def __init__(self, anim1, anim2):\n        super().__init__()\n\n        #: Repeat the sequence. See 'Repeating animation' in the header\n        #: documentation.\n        self.repeat = False\n\n        self.anim1 = anim1\n        self.anim2 = anim2\n\n        self.anim1.bind(on_complete=self.on_anim1_complete,\n                        on_progress=self.on_anim1_progress)\n        self.anim2.bind(on_complete=self.on_anim2_complete,\n                        on_progress=self.on_anim2_progress)",
  "def duration(self):\n        return self.anim1.duration + self.anim2.duration",
  "def stop(self, widget):\n        props = self._widgets.pop(widget.uid, None)\n        self.anim1.stop(widget)\n        self.anim2.stop(widget)\n        if props:\n            self.dispatch('on_complete', widget)\n        super().cancel(widget)",
  "def start(self, widget):\n        self.stop(widget)\n        self._widgets[widget.uid] = True\n        self._register()\n        self.dispatch('on_start', widget)\n        self.anim1.start(widget)",
  "def on_anim1_complete(self, instance, widget):\n        if widget.uid not in self._widgets:\n            return\n        self.anim2.start(widget)",
  "def on_anim1_progress(self, instance, widget, progress):\n        self.dispatch('on_progress', widget, progress / 2.)",
  "def on_anim2_complete(self, instance, widget):\n        '''Repeating logic used with boolean variable \"repeat\".\n\n        .. versionadded:: 1.7.1\n        '''\n        if widget.uid not in self._widgets:\n            return\n        if self.repeat:\n            self.anim1.start(widget)\n        else:\n            self.dispatch('on_complete', widget)\n            self.cancel(widget)",
  "def on_anim2_progress(self, instance, widget, progress):\n        self.dispatch('on_progress', widget, .5 + progress / 2.)",
  "def __init__(self, anim1, anim2):\n        super().__init__()\n        self.anim1 = anim1\n        self.anim2 = anim2\n\n        self.anim1.bind(on_complete=self.on_anim_complete)\n        self.anim2.bind(on_complete=self.on_anim_complete)",
  "def duration(self):\n        return max(self.anim1.duration, self.anim2.duration)",
  "def stop(self, widget):\n        self.anim1.stop(widget)\n        self.anim2.stop(widget)\n        if self._widgets.pop(widget.uid, None):\n            self.dispatch('on_complete', widget)\n        super().cancel(widget)",
  "def start(self, widget):\n        self.stop(widget)\n        self.anim1.start(widget)\n        self.anim2.start(widget)\n        self._widgets[widget.uid] = {'complete': 0}\n        self._register()\n        self.dispatch('on_start', widget)",
  "def on_anim_complete(self, instance, widget):\n        self._widgets[widget.uid]['complete'] += 1\n        if self._widgets[widget.uid]['complete'] == 2:\n            self.stop(widget)",
  "def linear(progress):\n        '''.. image:: images/anim_linear.png'''\n        return progress",
  "def in_quad(progress):\n        '''.. image:: images/anim_in_quad.png\n        '''\n        return progress * progress",
  "def out_quad(progress):\n        '''.. image:: images/anim_out_quad.png\n        '''\n        return -1.0 * progress * (progress - 2.0)",
  "def in_out_quad(progress):\n        '''.. image:: images/anim_in_out_quad.png\n        '''\n        p = progress * 2\n        if p < 1:\n            return 0.5 * p * p\n        p -= 1.0\n        return -0.5 * (p * (p - 2.0) - 1.0)",
  "def in_cubic(progress):\n        '''.. image:: images/anim_in_cubic.png\n        '''\n        return progress * progress * progress",
  "def out_cubic(progress):\n        '''.. image:: images/anim_out_cubic.png\n        '''\n        p = progress - 1.0\n        return p * p * p + 1.0",
  "def in_out_cubic(progress):\n        '''.. image:: images/anim_in_out_cubic.png\n        '''\n        p = progress * 2\n        if p < 1:\n            return 0.5 * p * p * p\n        p -= 2\n        return 0.5 * (p * p * p + 2.0)",
  "def in_quart(progress):\n        '''.. image:: images/anim_in_quart.png\n        '''\n        return progress * progress * progress * progress",
  "def out_quart(progress):\n        '''.. image:: images/anim_out_quart.png\n        '''\n        p = progress - 1.0\n        return -1.0 * (p * p * p * p - 1.0)",
  "def in_out_quart(progress):\n        '''.. image:: images/anim_in_out_quart.png\n        '''\n        p = progress * 2\n        if p < 1:\n            return 0.5 * p * p * p * p\n        p -= 2\n        return -0.5 * (p * p * p * p - 2.0)",
  "def in_quint(progress):\n        '''.. image:: images/anim_in_quint.png\n        '''\n        return progress * progress * progress * progress * progress",
  "def out_quint(progress):\n        '''.. image:: images/anim_out_quint.png\n        '''\n        p = progress - 1.0\n        return p * p * p * p * p + 1.0",
  "def in_out_quint(progress):\n        '''.. image:: images/anim_in_out_quint.png\n        '''\n        p = progress * 2\n        if p < 1:\n            return 0.5 * p * p * p * p * p\n        p -= 2.0\n        return 0.5 * (p * p * p * p * p + 2.0)",
  "def in_sine(progress):\n        '''.. image:: images/anim_in_sine.png\n        '''\n        return -1.0 * cos(progress * (pi / 2.0)) + 1.0",
  "def out_sine(progress):\n        '''.. image:: images/anim_out_sine.png\n        '''\n        return sin(progress * (pi / 2.0))",
  "def in_out_sine(progress):\n        '''.. image:: images/anim_in_out_sine.png\n        '''\n        return -0.5 * (cos(pi * progress) - 1.0)",
  "def in_expo(progress):\n        '''.. image:: images/anim_in_expo.png\n        '''\n        if progress == 0:\n            return 0.0\n        return pow(2, 10 * (progress - 1.0))",
  "def out_expo(progress):\n        '''.. image:: images/anim_out_expo.png\n        '''\n        if progress == 1.0:\n            return 1.0\n        return -pow(2, -10 * progress) + 1.0",
  "def in_out_expo(progress):\n        '''.. image:: images/anim_in_out_expo.png\n        '''\n        if progress == 0:\n            return 0.0\n        if progress == 1.:\n            return 1.0\n        p = progress * 2\n        if p < 1:\n            return 0.5 * pow(2, 10 * (p - 1.0))\n        p -= 1.0\n        return 0.5 * (-pow(2, -10 * p) + 2.0)",
  "def in_circ(progress):\n        '''.. image:: images/anim_in_circ.png\n        '''\n        return -1.0 * (sqrt(1.0 - progress * progress) - 1.0)",
  "def out_circ(progress):\n        '''.. image:: images/anim_out_circ.png\n        '''\n        p = progress - 1.0\n        return sqrt(1.0 - p * p)",
  "def in_out_circ(progress):\n        '''.. image:: images/anim_in_out_circ.png\n        '''\n        p = progress * 2\n        if p < 1:\n            return -0.5 * (sqrt(1.0 - p * p) - 1.0)\n        p -= 2.0\n        return 0.5 * (sqrt(1.0 - p * p) + 1.0)",
  "def in_elastic(progress):\n        '''.. image:: images/anim_in_elastic.png\n        '''\n        p = .3\n        s = p / 4.0\n        q = progress\n        if q == 1:\n            return 1.0\n        q -= 1.0\n        return -(pow(2, 10 * q) * sin((q - s) * (2 * pi) / p))",
  "def out_elastic(progress):\n        '''.. image:: images/anim_out_elastic.png\n        '''\n        p = .3\n        s = p / 4.0\n        q = progress\n        if q == 1:\n            return 1.0\n        return pow(2, -10 * q) * sin((q - s) * (2 * pi) / p) + 1.0",
  "def in_out_elastic(progress):\n        '''.. image:: images/anim_in_out_elastic.png\n        '''\n        p = .3 * 1.5\n        s = p / 4.0\n        q = progress * 2\n        if q == 2:\n            return 1.0\n        if q < 1:\n            q -= 1.0\n            return -.5 * (pow(2, 10 * q) * sin((q - s) * (2.0 * pi) / p))\n        else:\n            q -= 1.0\n            return pow(2, -10 * q) * sin((q - s) * (2.0 * pi) / p) * .5 + 1.0",
  "def in_back(progress):\n        '''.. image:: images/anim_in_back.png\n        '''\n        return progress * progress * ((1.70158 + 1.0) * progress - 1.70158)",
  "def out_back(progress):\n        '''.. image:: images/anim_out_back.png\n        '''\n        p = progress - 1.0\n        return p * p * ((1.70158 + 1) * p + 1.70158) + 1.0",
  "def in_out_back(progress):\n        '''.. image:: images/anim_in_out_back.png\n        '''\n        p = progress * 2.\n        s = 1.70158 * 1.525\n        if p < 1:\n            return 0.5 * (p * p * ((s + 1.0) * p - s))\n        p -= 2.0\n        return 0.5 * (p * p * ((s + 1.0) * p + s) + 2.0)",
  "def _out_bounce_internal(t, d):\n        p = t / d\n        if p < (1.0 / 2.75):\n            return 7.5625 * p * p\n        elif p < (2.0 / 2.75):\n            p -= (1.5 / 2.75)\n            return 7.5625 * p * p + .75\n        elif p < (2.5 / 2.75):\n            p -= (2.25 / 2.75)\n            return 7.5625 * p * p + .9375\n        else:\n            p -= (2.625 / 2.75)\n            return 7.5625 * p * p + .984375",
  "def _in_bounce_internal(t, d):\n        return 1.0 - AnimationTransition._out_bounce_internal(d - t, d)",
  "def in_bounce(progress):\n        '''.. image:: images/anim_in_bounce.png\n        '''\n        return AnimationTransition._in_bounce_internal(progress, 1.)",
  "def out_bounce(progress):\n        '''.. image:: images/anim_out_bounce.png\n        '''\n        return AnimationTransition._out_bounce_internal(progress, 1.)",
  "def in_out_bounce(progress):\n        '''.. image:: images/anim_in_out_bounce.png\n        '''\n        p = progress * 2.\n        if p < 1.:\n            return AnimationTransition._in_bounce_internal(p, 1.) * .5\n        return AnimationTransition._out_bounce_internal(p - 1., 1.) * .5 + .5",
  "def safeWait(dt):\n    EventLoop.confirmed.set()\n    EventLoop.safe.wait()\n    EventLoop.confirmed.clear()",
  "def unwrap(ob):\n    while isinstance(ob, SafeMembrane):\n        ob = ob._ref\n    return ob",
  "class SafeMembrane(object):\n    '''\n    This help is for a proxy object. Did you want help on the proxy's referent\n    instead? Try using help(<instance>._ref)\n\n    The SafeMembrane is a threadsafe proxy that also returns attributes as new\n    thread-safe objects\n    and makes thread-safe method calls, preventing thread-unsafe objects\n    from leaking into the user's environment.\n    '''\n\n    __slots__ = ('_ref', 'safe', 'confirmed')\n\n    def __init__(self, ob, *args, **kwargs):\n        self.confirmed = EventLoop.confirmed\n        self.safe = EventLoop.safe\n        self._ref = ob\n\n    def safeIn(self):\n        \"\"\"Provides a thread-safe entry point for interactive launching.\"\"\"\n        self.safe.clear()\n        Clock.schedule_once(safeWait, -1)\n        self.confirmed.wait()\n\n    def safeOut(self):\n        \"\"\"Provides a thread-safe exit point for interactive launching.\"\"\"\n        self.safe.set()\n\n    def isMethod(self, fn):\n        return inspect.ismethod(fn)\n\n    # Everything from this point on is just a series of thread-safing proxy\n    # methods that make calls against _ref and threadsafe whenever data will be\n    # written to or if a method will be called. SafeMembrane instances should\n    # be unwrapped whenever passing them into the thread\n    # use type() to determine if an object is a SafeMembrane while debugging\n    def __repr__(self):\n        return self._ref.__repr__()\n\n    def __call__(self, *args, **kw):\n        self.safeIn()\n        args = list(map(unwrap, args))\n        for k in list(kw.keys()):\n            kw[k] = unwrap(kw[k])\n        r = self._ref(*args, **kw)\n        self.safeOut()\n        if r is not None:\n            return SafeMembrane(r)\n\n    def __getattribute__(self, attr, oga=object.__getattribute__):\n        if attr.startswith('__') or attr == '_ref':\n            subject = oga(self, '_ref')\n            if attr == '_ref':\n                return subject\n            return getattr(subject, attr)\n        return oga(self, attr)\n\n    def __getattr__(self, attr, oga=object.__getattribute__):\n        r = getattr(oga(self, '_ref'), attr)\n        return SafeMembrane(r)\n\n    def __setattr__(self, attr, val, osa=object.__setattr__):\n        if (attr == '_ref' or\n                hasattr(type(self), attr) and not attr.startswith('__')):\n            osa(self, attr, val)\n        else:\n            self.safeIn()\n            val = unwrap(val)\n            setattr(self._ref, attr, val)\n            self.safeOut()\n\n    def __delattr__(self, attr, oda=object.__delattr__):\n        self.safeIn()\n        delattr(self._ref, attr)\n        self.safeOut()\n\n    def __bool__(self):\n        return bool(self._ref)\n\n    def __getitem__(self, arg):\n        return SafeMembrane(self._ref[arg])\n\n    def __setitem__(self, arg, val):\n        self.safeIn()\n        val = unwrap(val)\n        self._ref[arg] = val\n        self.safeOut()\n\n    def __delitem__(self, arg):\n        self.safeIn()\n        del self._ref[arg]\n        self.safeOut()\n\n    def __getslice__(self, i, j):\n        return SafeMembrane(self._ref[i:j])\n\n    def __setslice__(self, i, j, val):\n        self.safeIn()\n        val = unwrap(val)\n        self._ref[i:j] = val\n        self.safeOut()\n\n    def __delslice__(self, i, j):\n        self.safeIn()\n        del self._ref[i:j]\n        self.safeOut()\n\n    def __enter__(self, *args, **kwargs):\n        self.safeIn()\n        self._ref.__enter__(*args, **kwargs)\n\n    def __exit__(self, *args, **kwargs):\n        self._ref.__exit__(*args, **kwargs)\n        self.safeOut()",
  "class InteractiveLauncher(SafeMembrane):\n    '''\n    Proxy to an application instance that launches it in a thread and\n    then returns and acts as a proxy to the application in the thread.\n    '''\n\n    __slots__ = ('_ref', 'safe', 'confirmed', 'thread', 'app')\n\n    @deprecated\n    def __init__(self, app=None, *args, **kwargs):\n        if app is None:\n            app = App()\n        EventLoop.safe = Event()\n        self.safe = EventLoop.safe\n        self.safe.set()\n        EventLoop.confirmed = Event()\n        self.confirmed = EventLoop.confirmed\n        self.app = app\n\n        def startApp(app=app, *args, **kwargs):\n            app.run(*args, **kwargs)\n\n        self.thread = Thread(target=startApp, *args, **kwargs)\n\n    def run(self):\n        self.thread.start()\n        # Proxy behavior starts after this is set. Before this point, attaching\n        # widgets etc can only be done through the Launcher's app attribute\n        self._ref = self.app\n\n    def stop(self):\n        EventLoop.quit = True\n        self.thread.join()\n\n    # Act like the app instance even before _ref is set\n    def __repr__(self):\n        return self.app.__repr__()",
  "def __init__(self, ob, *args, **kwargs):\n        self.confirmed = EventLoop.confirmed\n        self.safe = EventLoop.safe\n        self._ref = ob",
  "def safeIn(self):\n        \"\"\"Provides a thread-safe entry point for interactive launching.\"\"\"\n        self.safe.clear()\n        Clock.schedule_once(safeWait, -1)\n        self.confirmed.wait()",
  "def safeOut(self):\n        \"\"\"Provides a thread-safe exit point for interactive launching.\"\"\"\n        self.safe.set()",
  "def isMethod(self, fn):\n        return inspect.ismethod(fn)",
  "def __repr__(self):\n        return self._ref.__repr__()",
  "def __call__(self, *args, **kw):\n        self.safeIn()\n        args = list(map(unwrap, args))\n        for k in list(kw.keys()):\n            kw[k] = unwrap(kw[k])\n        r = self._ref(*args, **kw)\n        self.safeOut()\n        if r is not None:\n            return SafeMembrane(r)",
  "def __getattribute__(self, attr, oga=object.__getattribute__):\n        if attr.startswith('__') or attr == '_ref':\n            subject = oga(self, '_ref')\n            if attr == '_ref':\n                return subject\n            return getattr(subject, attr)\n        return oga(self, attr)",
  "def __getattr__(self, attr, oga=object.__getattribute__):\n        r = getattr(oga(self, '_ref'), attr)\n        return SafeMembrane(r)",
  "def __setattr__(self, attr, val, osa=object.__setattr__):\n        if (attr == '_ref' or\n                hasattr(type(self), attr) and not attr.startswith('__')):\n            osa(self, attr, val)\n        else:\n            self.safeIn()\n            val = unwrap(val)\n            setattr(self._ref, attr, val)\n            self.safeOut()",
  "def __delattr__(self, attr, oda=object.__delattr__):\n        self.safeIn()\n        delattr(self._ref, attr)\n        self.safeOut()",
  "def __bool__(self):\n        return bool(self._ref)",
  "def __getitem__(self, arg):\n        return SafeMembrane(self._ref[arg])",
  "def __setitem__(self, arg, val):\n        self.safeIn()\n        val = unwrap(val)\n        self._ref[arg] = val\n        self.safeOut()",
  "def __delitem__(self, arg):\n        self.safeIn()\n        del self._ref[arg]\n        self.safeOut()",
  "def __getslice__(self, i, j):\n        return SafeMembrane(self._ref[i:j])",
  "def __setslice__(self, i, j, val):\n        self.safeIn()\n        val = unwrap(val)\n        self._ref[i:j] = val\n        self.safeOut()",
  "def __delslice__(self, i, j):\n        self.safeIn()\n        del self._ref[i:j]\n        self.safeOut()",
  "def __enter__(self, *args, **kwargs):\n        self.safeIn()\n        self._ref.__enter__(*args, **kwargs)",
  "def __exit__(self, *args, **kwargs):\n        self._ref.__exit__(*args, **kwargs)\n        self.safeOut()",
  "def __init__(self, app=None, *args, **kwargs):\n        if app is None:\n            app = App()\n        EventLoop.safe = Event()\n        self.safe = EventLoop.safe\n        self.safe.set()\n        EventLoop.confirmed = Event()\n        self.confirmed = EventLoop.confirmed\n        self.app = app\n\n        def startApp(app=app, *args, **kwargs):\n            app.run(*args, **kwargs)\n\n        self.thread = Thread(target=startApp, *args, **kwargs)",
  "def run(self):\n        self.thread.start()\n        # Proxy behavior starts after this is set. Before this point, attaching\n        # widgets etc can only be done through the Launcher's app attribute\n        self._ref = self.app",
  "def stop(self):\n        EventLoop.quit = True\n        self.thread.join()",
  "def __repr__(self):\n        return self.app.__repr__()",
  "def startApp(app=app, *args, **kwargs):\n            app.run(*args, **kwargs)",
  "class ProxyImage(Image):\n    '''Image returned by the Loader.image() function.\n\n    :Properties:\n        `loaded`: bool, defaults to False\n            This value may be True if the image is already cached.\n\n    :Events:\n        `on_load`\n            Fired when the image is loaded or changed.\n        `on_error`\n            Fired when the image cannot be loaded.\n            `error`: Exception data that occurred\n    '''\n\n    __events__ = ('on_load', 'on_error')\n\n    def __init__(self, arg, **kwargs):\n        loaded = kwargs.pop('loaded', False)\n        super(ProxyImage, self).__init__(arg, **kwargs)\n        self.loaded = loaded\n\n    def on_load(self):\n        pass\n\n    def on_error(self, error):\n        pass",
  "class LoaderBase(object):\n    '''Common base for the Loader and specific implementations.\n    By default, the Loader will be the best available loader implementation.\n\n    The _update() function is called every 1 / 25.s or each frame if we have\n    less than 25 FPS.\n    '''\n    _trigger_update = None\n\n    '''Alias for mimetype extensions.\n\n    If you have trouble to have the right extension to be detected,\n    you can either add #.EXT at the end of the url, or use this array\n    to correct the detection.\n    For example, a zip-file on Windows can be detected as pyz.\n\n    By default, '.pyz' is translated to '.zip'\n\n    .. versionadded:: 1.11.0\n    '''\n    EXT_ALIAS = {\n        '.pyz': '.zip'\n    }\n\n    def __init__(self):\n        self._loading_image = None\n        self._error_image = None\n        self._num_workers = 2\n        self._max_upload_per_frame = 2\n        self._paused = False\n        self._resume_cond = threading.Condition()\n\n        self._q_load = deque()\n        self._q_done = deque()\n        self._client = []\n        self._running = False\n        self._start_wanted = False\n        self._trigger_update = Clock.create_trigger(self._update)\n\n    def __del__(self):\n        if self._trigger_update is not None:\n            self._trigger_update.cancel()\n\n    def _set_num_workers(self, num):\n        if num < 2:\n            raise Exception('Must have at least 2 workers')\n        self._num_workers = num\n\n    def _get_num_workers(self):\n        return self._num_workers\n\n    num_workers = property(_get_num_workers, _set_num_workers)\n    '''Number of workers to use while loading (used only if the loader\n    implementation supports it). This setting impacts the loader only on\n    initialization. Once the loader is started, the setting has no impact::\n\n        from kivy.loader import Loader\n        Loader.num_workers = 4\n\n    The default value is 2 for giving a smooth user experience. You could\n    increase the number of workers, then all the images will be loaded faster,\n    but the user will not been able to use the application while loading.\n    Prior to 1.6.0, the default number was 20, and loading many full-hd images\n    was completely blocking the application.\n\n    .. versionadded:: 1.6.0\n    '''\n\n    def _set_max_upload_per_frame(self, num):\n        if num is not None and num < 1:\n            raise Exception('Must have at least 1 image processing per image')\n        self._max_upload_per_frame = num\n\n    def _get_max_upload_per_frame(self):\n        return self._max_upload_per_frame\n\n    max_upload_per_frame = property(_get_max_upload_per_frame,\n                                    _set_max_upload_per_frame)\n    '''The number of images to upload per frame. By default, we'll\n    upload only 2 images to the GPU per frame. If you are uploading many\n    small images, you can easily increase this parameter to 10 or more.\n    If you are loading multiple full HD images, the upload time may have\n    consequences and block the application. If you want a\n    smooth experience, use the default.\n\n    As a matter of fact, a Full-HD RGB image will take ~6MB in memory,\n    so it may take time. If you have activated mipmap=True too, then the\n    GPU must calculate the mipmap of these big images too, in real time.\n    Then it may be best to reduce the :attr:`max_upload_per_frame` to 1\n    or 2. If you want to get rid of that (or reduce it a lot), take a\n    look at the DDS format.\n\n    .. versionadded:: 1.6.0\n    '''\n\n    def _get_loading_image(self):\n        if not self._loading_image:\n            loading_png_fn = join(kivy_data_dir, 'images', 'image-loading.zip')\n            self._loading_image = ImageLoader.load(filename=loading_png_fn)\n        return self._loading_image\n\n    def _set_loading_image(self, image):\n        if isinstance(image, str):\n            self._loading_image = ImageLoader.load(filename=image)\n        else:\n            self._loading_image = image\n\n    loading_image = property(_get_loading_image, _set_loading_image)\n    '''Image used for loading.\n    You can change it by doing::\n\n        Loader.loading_image = 'loading.png'\n\n    .. versionchanged:: 1.6.0\n        Not readonly anymore.\n    '''\n\n    def _get_error_image(self):\n        if not self._error_image:\n            error_png_fn = join(\n                'atlas://data/images/defaulttheme/image-missing')\n            self._error_image = ImageLoader.load(filename=error_png_fn)\n        return self._error_image\n\n    def _set_error_image(self, image):\n        if isinstance(image, str):\n            self._error_image = ImageLoader.load(filename=image)\n        else:\n            self._error_image = image\n\n    error_image = property(_get_error_image, _set_error_image)\n    '''Image used for error.\n    You can change it by doing::\n\n        Loader.error_image = 'error.png'\n\n    .. versionchanged:: 1.6.0\n        Not readonly anymore.\n    '''\n\n    def start(self):\n        '''Start the loader thread/process.'''\n        self._running = True\n\n    def run(self, *largs):\n        '''Main loop for the loader.'''\n        pass\n\n    def stop(self):\n        '''Stop the loader thread/process.'''\n        self._running = False\n\n    def pause(self):\n        '''Pause the loader, can be useful during interactions.\n\n        .. versionadded:: 1.6.0\n        '''\n        self._paused = True\n\n    def resume(self):\n        '''Resume the loader, after a :meth:`pause`.\n\n        .. versionadded:: 1.6.0\n        '''\n        self._paused = False\n        self._resume_cond.acquire()\n        self._resume_cond.notify_all()\n        self._resume_cond.release()\n\n    def _wait_for_resume(self):\n        while self._running and self._paused:\n            self._resume_cond.acquire()\n            self._resume_cond.wait(0.25)\n            self._resume_cond.release()\n\n    def _load(self, kwargs):\n        '''(internal) Loading function, called by the thread.\n        Will call _load_local() if the file is local,\n        or _load_urllib() if the file is on Internet.\n        '''\n\n        while len(self._q_done) >= (\n                self.max_upload_per_frame * self._num_workers):\n            sleep(0.1)\n\n        self._wait_for_resume()\n\n        filename = kwargs['filename']\n        load_callback = kwargs['load_callback']\n        post_callback = kwargs['post_callback']\n        try:\n            proto = filename.split(':', 1)[0]\n        except:\n            # if blank filename then return\n            return\n        if load_callback is not None:\n            data = load_callback(filename)\n        elif proto in ('http', 'https', 'ftp', 'smb'):\n            data = self._load_urllib(filename, kwargs['kwargs'])\n        else:\n            data = self._load_local(filename, kwargs['kwargs'])\n\n        if post_callback:\n            data = post_callback(data)\n\n        self._q_done.appendleft((filename, data))\n        self._trigger_update()\n\n    def _load_local(self, filename, kwargs):\n        '''(internal) Loading a local file'''\n        # With recent changes to CoreImage, we must keep data otherwise,\n        # we might be unable to recreate the texture afterwise.\n        return ImageLoader.load(filename, keep_data=True, **kwargs)\n\n    def _load_urllib(self, filename, kwargs):\n        '''(internal) Loading a network file. First download it, save it to a\n        temporary file, and pass it to _load_local().'''\n        import urllib.request\n        import tempfile\n\n        proto = filename.split(':', 1)[0]\n        if proto == 'smb':\n            try:\n                # note: it's important to load SMBHandler every time\n                # otherwise the data is occasionally not loaded\n                from smb.SMBHandler import SMBHandler\n            except ImportError:\n                Logger.warning(\n                    'Loader: can not load PySMB: make sure it is installed')\n                return\n\n        data = fd = _out_osfd = None\n        try:\n            _out_filename = ''\n\n            if proto == 'smb':\n                # read from samba shares\n                fd = urllib.request.build_opener(SMBHandler).open(filename)\n            else:\n                # read from internet\n                request = urllib.request.Request(filename)\n                if Config.has_option('network', 'useragent'):\n                    useragent = Config.get('network', 'useragent')\n                    if useragent:\n                        request.add_header('User-Agent', useragent)\n\n                # A custom context is only needed on Android and iOS\n                # as we need to use the certs provided via certifi.\n                ssl_ctx = None\n                if platform in ['android', 'ios']:\n                    import certifi\n                    import ssl\n                    ssl_ctx = ssl.create_default_context(cafile=certifi.where())\n                    ssl_ctx.verify_mode = ssl.CERT_REQUIRED\n\n                fd = urllib.request.urlopen(request, context=ssl_ctx)\n\n            if '#.' in filename:\n                # allow extension override from URL fragment\n                suffix = '.' + filename.split('#.')[-1]\n            else:\n                ctype = fd.info().get_content_type()\n                suffix = mimetypes.guess_extension(ctype)\n                suffix = LoaderBase.EXT_ALIAS.get(suffix, suffix)\n                if not suffix:\n                    # strip query string and split on path\n                    parts = filename.split('?')[0].split('/')[1:]\n                    while len(parts) > 1 and not parts[0]:\n                        # strip out blanks from '//'\n                        parts = parts[1:]\n                    if len(parts) > 1 and '.' in parts[-1]:\n                        # we don't want '.com', '.net', etc. as the extension\n                        suffix = '.' + parts[-1].split('.')[-1]\n            _out_osfd, _out_filename = tempfile.mkstemp(\n                prefix='kivyloader', suffix=suffix)\n\n            idata = fd.read()\n            fd.close()\n            fd = None\n\n            # write to local filename\n            write(_out_osfd, idata)\n            close(_out_osfd)\n            _out_osfd = None\n\n            # load data\n            data = self._load_local(_out_filename, kwargs)\n\n            # FIXME create a clean API for that\n            for imdata in data._data:\n                imdata.source = filename\n        except Exception as ex:\n            Logger.exception('Loader: Failed to load image <%s>' % filename)\n            # close file when remote file not found or download error\n            try:\n                if _out_osfd:\n                    close(_out_osfd)\n            except OSError:\n                pass\n\n            # update client\n            for c_filename, client in self._client[:]:\n                if filename != c_filename:\n                    continue\n                # got one client to update\n                client.image = self.error_image\n                client.dispatch('on_error', error=ex)\n                self._client.remove((c_filename, client))\n\n            return self.error_image\n        finally:\n            if fd:\n                fd.close()\n            if _out_osfd:\n                close(_out_osfd)\n            if _out_filename != '':\n                unlink(_out_filename)\n\n        return data\n\n    def _update(self, *largs):\n        '''(internal) Check if a data is loaded, and pass to the client.'''\n        # want to start it ?\n        if self._start_wanted:\n            if not self._running:\n                self.start()\n            self._start_wanted = False\n\n        # in pause mode, don't unqueue anything.\n        if self._paused:\n            self._trigger_update()\n            return\n\n        for x in range(self.max_upload_per_frame):\n            try:\n                filename, data = self._q_done.pop()\n            except IndexError:\n                return\n\n            # create the image\n            image = data  # ProxyImage(data)\n            if not image.nocache:\n                Cache.append('kv.loader', filename, image)\n\n            # update client\n            for c_filename, client in self._client[:]:\n                if filename != c_filename:\n                    continue\n                # got one client to update\n                client.image = image\n                client.loaded = True\n                client.dispatch('on_load')\n                self._client.remove((c_filename, client))\n\n        self._trigger_update()\n\n    def image(self, filename, load_callback=None, post_callback=None,\n              **kwargs):\n        '''Load a image using the Loader. A ProxyImage is returned with a\n        loading image. You can use it as follows::\n\n            from kivy.app import App\n            from kivy.uix.image import Image\n            from kivy.loader import Loader\n\n            class TestApp(App):\n                def _image_loaded(self, proxyImage):\n                    if proxyImage.image.texture:\n                        self.image.texture = proxyImage.image.texture\n\n                def build(self):\n                    proxyImage = Loader.image(\"myPic.jpg\")\n                    proxyImage.bind(on_load=self._image_loaded)\n                    self.image = Image()\n                    return self.image\n\n            TestApp().run()\n\n        In order to cancel all background loading, call *Loader.stop()*.\n        '''\n        data = Cache.get('kv.loader', filename)\n        if data not in (None, False):\n            # found image, if data is not here, need to reload.\n            return ProxyImage(data,\n                              loading_image=self.loading_image,\n                              loaded=True, **kwargs)\n\n        client = ProxyImage(self.loading_image,\n                            loading_image=self.loading_image, **kwargs)\n        self._client.append((filename, client))\n\n        if data is None:\n            # if data is None, this is really the first time\n            self._q_load.appendleft({\n                'filename': filename,\n                'load_callback': load_callback,\n                'post_callback': post_callback,\n                'kwargs': kwargs})\n            if not kwargs.get('nocache', False):\n                Cache.append('kv.loader', filename, False)\n            self._start_wanted = True\n            self._trigger_update()\n        else:\n            # already queued for loading\n            pass\n\n        return client\n\n    def remove_from_cache(self, filename):\n        Cache.remove('kv.loader', filename)",
  "def __init__(self, arg, **kwargs):\n        loaded = kwargs.pop('loaded', False)\n        super(ProxyImage, self).__init__(arg, **kwargs)\n        self.loaded = loaded",
  "def on_load(self):\n        pass",
  "def on_error(self, error):\n        pass",
  "def __init__(self):\n        self._loading_image = None\n        self._error_image = None\n        self._num_workers = 2\n        self._max_upload_per_frame = 2\n        self._paused = False\n        self._resume_cond = threading.Condition()\n\n        self._q_load = deque()\n        self._q_done = deque()\n        self._client = []\n        self._running = False\n        self._start_wanted = False\n        self._trigger_update = Clock.create_trigger(self._update)",
  "def __del__(self):\n        if self._trigger_update is not None:\n            self._trigger_update.cancel()",
  "def _set_num_workers(self, num):\n        if num < 2:\n            raise Exception('Must have at least 2 workers')\n        self._num_workers = num",
  "def _get_num_workers(self):\n        return self._num_workers",
  "def _set_max_upload_per_frame(self, num):\n        if num is not None and num < 1:\n            raise Exception('Must have at least 1 image processing per image')\n        self._max_upload_per_frame = num",
  "def _get_max_upload_per_frame(self):\n        return self._max_upload_per_frame",
  "def _get_loading_image(self):\n        if not self._loading_image:\n            loading_png_fn = join(kivy_data_dir, 'images', 'image-loading.zip')\n            self._loading_image = ImageLoader.load(filename=loading_png_fn)\n        return self._loading_image",
  "def _set_loading_image(self, image):\n        if isinstance(image, str):\n            self._loading_image = ImageLoader.load(filename=image)\n        else:\n            self._loading_image = image",
  "def _get_error_image(self):\n        if not self._error_image:\n            error_png_fn = join(\n                'atlas://data/images/defaulttheme/image-missing')\n            self._error_image = ImageLoader.load(filename=error_png_fn)\n        return self._error_image",
  "def _set_error_image(self, image):\n        if isinstance(image, str):\n            self._error_image = ImageLoader.load(filename=image)\n        else:\n            self._error_image = image",
  "def start(self):\n        '''Start the loader thread/process.'''\n        self._running = True",
  "def run(self, *largs):\n        '''Main loop for the loader.'''\n        pass",
  "def stop(self):\n        '''Stop the loader thread/process.'''\n        self._running = False",
  "def pause(self):\n        '''Pause the loader, can be useful during interactions.\n\n        .. versionadded:: 1.6.0\n        '''\n        self._paused = True",
  "def resume(self):\n        '''Resume the loader, after a :meth:`pause`.\n\n        .. versionadded:: 1.6.0\n        '''\n        self._paused = False\n        self._resume_cond.acquire()\n        self._resume_cond.notify_all()\n        self._resume_cond.release()",
  "def _wait_for_resume(self):\n        while self._running and self._paused:\n            self._resume_cond.acquire()\n            self._resume_cond.wait(0.25)\n            self._resume_cond.release()",
  "def _load(self, kwargs):\n        '''(internal) Loading function, called by the thread.\n        Will call _load_local() if the file is local,\n        or _load_urllib() if the file is on Internet.\n        '''\n\n        while len(self._q_done) >= (\n                self.max_upload_per_frame * self._num_workers):\n            sleep(0.1)\n\n        self._wait_for_resume()\n\n        filename = kwargs['filename']\n        load_callback = kwargs['load_callback']\n        post_callback = kwargs['post_callback']\n        try:\n            proto = filename.split(':', 1)[0]\n        except:\n            # if blank filename then return\n            return\n        if load_callback is not None:\n            data = load_callback(filename)\n        elif proto in ('http', 'https', 'ftp', 'smb'):\n            data = self._load_urllib(filename, kwargs['kwargs'])\n        else:\n            data = self._load_local(filename, kwargs['kwargs'])\n\n        if post_callback:\n            data = post_callback(data)\n\n        self._q_done.appendleft((filename, data))\n        self._trigger_update()",
  "def _load_local(self, filename, kwargs):\n        '''(internal) Loading a local file'''\n        # With recent changes to CoreImage, we must keep data otherwise,\n        # we might be unable to recreate the texture afterwise.\n        return ImageLoader.load(filename, keep_data=True, **kwargs)",
  "def _load_urllib(self, filename, kwargs):\n        '''(internal) Loading a network file. First download it, save it to a\n        temporary file, and pass it to _load_local().'''\n        import urllib.request\n        import tempfile\n\n        proto = filename.split(':', 1)[0]\n        if proto == 'smb':\n            try:\n                # note: it's important to load SMBHandler every time\n                # otherwise the data is occasionally not loaded\n                from smb.SMBHandler import SMBHandler\n            except ImportError:\n                Logger.warning(\n                    'Loader: can not load PySMB: make sure it is installed')\n                return\n\n        data = fd = _out_osfd = None\n        try:\n            _out_filename = ''\n\n            if proto == 'smb':\n                # read from samba shares\n                fd = urllib.request.build_opener(SMBHandler).open(filename)\n            else:\n                # read from internet\n                request = urllib.request.Request(filename)\n                if Config.has_option('network', 'useragent'):\n                    useragent = Config.get('network', 'useragent')\n                    if useragent:\n                        request.add_header('User-Agent', useragent)\n\n                # A custom context is only needed on Android and iOS\n                # as we need to use the certs provided via certifi.\n                ssl_ctx = None\n                if platform in ['android', 'ios']:\n                    import certifi\n                    import ssl\n                    ssl_ctx = ssl.create_default_context(cafile=certifi.where())\n                    ssl_ctx.verify_mode = ssl.CERT_REQUIRED\n\n                fd = urllib.request.urlopen(request, context=ssl_ctx)\n\n            if '#.' in filename:\n                # allow extension override from URL fragment\n                suffix = '.' + filename.split('#.')[-1]\n            else:\n                ctype = fd.info().get_content_type()\n                suffix = mimetypes.guess_extension(ctype)\n                suffix = LoaderBase.EXT_ALIAS.get(suffix, suffix)\n                if not suffix:\n                    # strip query string and split on path\n                    parts = filename.split('?')[0].split('/')[1:]\n                    while len(parts) > 1 and not parts[0]:\n                        # strip out blanks from '//'\n                        parts = parts[1:]\n                    if len(parts) > 1 and '.' in parts[-1]:\n                        # we don't want '.com', '.net', etc. as the extension\n                        suffix = '.' + parts[-1].split('.')[-1]\n            _out_osfd, _out_filename = tempfile.mkstemp(\n                prefix='kivyloader', suffix=suffix)\n\n            idata = fd.read()\n            fd.close()\n            fd = None\n\n            # write to local filename\n            write(_out_osfd, idata)\n            close(_out_osfd)\n            _out_osfd = None\n\n            # load data\n            data = self._load_local(_out_filename, kwargs)\n\n            # FIXME create a clean API for that\n            for imdata in data._data:\n                imdata.source = filename\n        except Exception as ex:\n            Logger.exception('Loader: Failed to load image <%s>' % filename)\n            # close file when remote file not found or download error\n            try:\n                if _out_osfd:\n                    close(_out_osfd)\n            except OSError:\n                pass\n\n            # update client\n            for c_filename, client in self._client[:]:\n                if filename != c_filename:\n                    continue\n                # got one client to update\n                client.image = self.error_image\n                client.dispatch('on_error', error=ex)\n                self._client.remove((c_filename, client))\n\n            return self.error_image\n        finally:\n            if fd:\n                fd.close()\n            if _out_osfd:\n                close(_out_osfd)\n            if _out_filename != '':\n                unlink(_out_filename)\n\n        return data",
  "def _update(self, *largs):\n        '''(internal) Check if a data is loaded, and pass to the client.'''\n        # want to start it ?\n        if self._start_wanted:\n            if not self._running:\n                self.start()\n            self._start_wanted = False\n\n        # in pause mode, don't unqueue anything.\n        if self._paused:\n            self._trigger_update()\n            return\n\n        for x in range(self.max_upload_per_frame):\n            try:\n                filename, data = self._q_done.pop()\n            except IndexError:\n                return\n\n            # create the image\n            image = data  # ProxyImage(data)\n            if not image.nocache:\n                Cache.append('kv.loader', filename, image)\n\n            # update client\n            for c_filename, client in self._client[:]:\n                if filename != c_filename:\n                    continue\n                # got one client to update\n                client.image = image\n                client.loaded = True\n                client.dispatch('on_load')\n                self._client.remove((c_filename, client))\n\n        self._trigger_update()",
  "def image(self, filename, load_callback=None, post_callback=None,\n              **kwargs):\n        '''Load a image using the Loader. A ProxyImage is returned with a\n        loading image. You can use it as follows::\n\n            from kivy.app import App\n            from kivy.uix.image import Image\n            from kivy.loader import Loader\n\n            class TestApp(App):\n                def _image_loaded(self, proxyImage):\n                    if proxyImage.image.texture:\n                        self.image.texture = proxyImage.image.texture\n\n                def build(self):\n                    proxyImage = Loader.image(\"myPic.jpg\")\n                    proxyImage.bind(on_load=self._image_loaded)\n                    self.image = Image()\n                    return self.image\n\n            TestApp().run()\n\n        In order to cancel all background loading, call *Loader.stop()*.\n        '''\n        data = Cache.get('kv.loader', filename)\n        if data not in (None, False):\n            # found image, if data is not here, need to reload.\n            return ProxyImage(data,\n                              loading_image=self.loading_image,\n                              loaded=True, **kwargs)\n\n        client = ProxyImage(self.loading_image,\n                            loading_image=self.loading_image, **kwargs)\n        self._client.append((filename, client))\n\n        if data is None:\n            # if data is None, this is really the first time\n            self._q_load.appendleft({\n                'filename': filename,\n                'load_callback': load_callback,\n                'post_callback': post_callback,\n                'kwargs': kwargs})\n            if not kwargs.get('nocache', False):\n                Cache.append('kv.loader', filename, False)\n            self._start_wanted = True\n            self._trigger_update()\n        else:\n            # already queued for loading\n            pass\n\n        return client",
  "def remove_from_cache(self, filename):\n        Cache.remove('kv.loader', filename)",
  "class _Worker(Thread):\n        '''Thread executing tasks from a given tasks queue\n        '''\n        def __init__(self, pool, tasks):\n            Thread.__init__(self)\n            self.tasks = tasks\n            self.daemon = True\n            self.pool = pool\n            self.start()\n\n        def run(self):\n            while self.pool.running:\n                func, args, kargs = self.tasks.get()\n                try:\n                    func(*args, **kargs)\n                except Exception as e:\n                    print(e)\n                self.tasks.task_done()",
  "class _ThreadPool(object):\n        '''Pool of threads consuming tasks from a queue\n        '''\n        def __init__(self, num_threads):\n            super(_ThreadPool, self).__init__()\n            self.running = True\n            self.tasks = queue.Queue()\n            for _ in range(num_threads):\n                _Worker(self, self.tasks)\n\n        def add_task(self, func, *args, **kargs):\n            '''Add a task to the queue\n            '''\n            self.tasks.put((func, args, kargs))\n\n        def stop(self):\n            self.running = False\n            self.tasks.join()",
  "class LoaderThreadPool(LoaderBase):\n        def __init__(self):\n            super(LoaderThreadPool, self).__init__()\n            self.pool = None\n\n        def start(self):\n            super(LoaderThreadPool, self).start()\n            self.pool = _ThreadPool(self._num_workers)\n            Clock.schedule_interval(self.run, 0)\n\n        def stop(self):\n            super(LoaderThreadPool, self).stop()\n            Clock.unschedule(self.run)\n            self.pool.stop()\n\n        def run(self, *largs):\n            while self._running:\n                try:\n                    parameters = self._q_load.pop()\n                except:\n                    return\n                self.pool.add_task(self._load, parameters)",
  "def __init__(self, pool, tasks):\n            Thread.__init__(self)\n            self.tasks = tasks\n            self.daemon = True\n            self.pool = pool\n            self.start()",
  "def run(self):\n            while self.pool.running:\n                func, args, kargs = self.tasks.get()\n                try:\n                    func(*args, **kargs)\n                except Exception as e:\n                    print(e)\n                self.tasks.task_done()",
  "def __init__(self, num_threads):\n            super(_ThreadPool, self).__init__()\n            self.running = True\n            self.tasks = queue.Queue()\n            for _ in range(num_threads):\n                _Worker(self, self.tasks)",
  "def add_task(self, func, *args, **kargs):\n            '''Add a task to the queue\n            '''\n            self.tasks.put((func, args, kargs))",
  "def stop(self):\n            self.running = False\n            self.tasks.join()",
  "def __init__(self):\n            super(LoaderThreadPool, self).__init__()\n            self.pool = None",
  "def start(self):\n            super(LoaderThreadPool, self).start()\n            self.pool = _ThreadPool(self._num_workers)\n            Clock.schedule_interval(self.run, 0)",
  "def stop(self):\n            super(LoaderThreadPool, self).stop()\n            Clock.unschedule(self.run)\n            self.pool.stop()",
  "def run(self, *largs):\n            while self._running:\n                try:\n                    parameters = self._q_load.pop()\n                except:\n                    return\n                self.pool.add_task(self._load, parameters)",
  "class Cache(object):\n    '''See module documentation for more information.\n    '''\n\n    _categories = {}\n    _objects = {}\n\n    @staticmethod\n    def register(category, limit=None, timeout=None):\n        '''Register a new category in the cache with the specified limit.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `limit`: int (optional)\n                Maximum number of objects allowed in the cache.\n                If None, no limit is applied.\n            `timeout`: double (optional)\n                Time after which to delete the object if it has not been used.\n                If None, no timeout is applied.\n        '''\n        Cache._categories[category] = {\n            'limit': limit,\n            'timeout': timeout}\n        Cache._objects[category] = {}\n        Logger.debug(\n            'Cache: register <%s> with limit=%s, timeout=%s' %\n            (category, str(limit), str(timeout)))\n\n    @staticmethod\n    def append(category, key, obj, timeout=None):\n        '''Add a new object to the cache.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `key`: str\n                Unique identifier of the object to store.\n            `obj`: object\n                Object to store in cache.\n            `timeout`: double (optional)\n                Time after which to delete the object if it has not been used.\n                If None, no timeout is applied.\n\n        :raises:\n            `ValueError`: If `None` is used as `key`.\n\n        .. versionchanged:: 2.0.0\n            Raises `ValueError` if `None` is used as `key`.\n\n        '''\n        # check whether obj should not be cached first\n        if getattr(obj, '_nocache', False):\n            return\n        if key is None:\n            # This check is added because of the case when key is None and\n            # one of purge methods gets called. Then loop in purge method will\n            # call Cache.remove with key None which then clears entire\n            # category from Cache making next iteration of loop to raise a\n            # KeyError because next key will not exist.\n            # See: https://github.com/kivy/kivy/pull/6950\n            raise ValueError('\"None\" cannot be used as key in Cache')\n        try:\n            cat = Cache._categories[category]\n        except KeyError:\n            Logger.warning('Cache: category <%s> does not exist' % category)\n            return\n\n        timeout = timeout or cat['timeout']\n\n        limit = cat['limit']\n\n        if limit is not None and len(Cache._objects[category]) >= limit:\n            Cache._purge_oldest(category)\n\n        Cache._objects[category][key] = {\n            'object': obj,\n            'timeout': timeout,\n            'lastaccess': Clock.get_time(),\n            'timestamp': Clock.get_time()}\n\n    @staticmethod\n    def get(category, key, default=None):\n        '''Get a object from the cache.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `key`: str\n                Unique identifier of the object in the store.\n            `default`: anything, defaults to None\n                Default value to be returned if the key is not found.\n        '''\n        try:\n            Cache._objects[category][key]['lastaccess'] = Clock.get_time()\n            return Cache._objects[category][key]['object']\n        except Exception:\n            return default\n\n    @staticmethod\n    def get_timestamp(category, key, default=None):\n        '''Get the object timestamp in the cache.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `key`: str\n                Unique identifier of the object in the store.\n            `default`: anything, defaults to None\n                Default value to be returned if the key is not found.\n        '''\n        try:\n            return Cache._objects[category][key]['timestamp']\n        except Exception:\n            return default\n\n    @staticmethod\n    def get_lastaccess(category, key, default=None):\n        '''Get the objects last access time in the cache.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `key`: str\n                Unique identifier of the object in the store.\n            `default`: anything, defaults to None\n                Default value to be returned if the key is not found.\n        '''\n        try:\n            return Cache._objects[category][key]['lastaccess']\n        except Exception:\n            return default\n\n    @staticmethod\n    def remove(category, key=None):\n        '''Purge the cache.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `key`: str (optional)\n                Unique identifier of the object in the store. If this\n                argument is not supplied, the entire category will be purged.\n        '''\n        try:\n            if key is not None:\n                del Cache._objects[category][key]\n                Logger.trace('Cache: Removed %s:%s from cache' %\n                             (category, key))\n            else:\n                Cache._objects[category] = {}\n                Logger.trace('Cache: Flushed category %s from cache' %\n                             category)\n        except Exception:\n            pass\n\n    @staticmethod\n    def _purge_oldest(category, maxpurge=1):\n        Logger.trace('Cache: Remove oldest in %s' % category)\n        import heapq\n        time = Clock.get_time()\n        heap_list = []\n        for key in Cache._objects[category]:\n            obj = Cache._objects[category][key]\n            if obj['lastaccess'] == obj['timestamp'] == time:\n                continue\n            heapq.heappush(heap_list, (obj['lastaccess'], key))\n            Logger.trace('Cache: <<< %f' % obj['lastaccess'])\n        n = 0\n        while n <= maxpurge:\n            try:\n                n += 1\n                lastaccess, key = heapq.heappop(heap_list)\n                Logger.trace('Cache: %d => %s %f %f' %\n                             (n, key, lastaccess, Clock.get_time()))\n            except Exception:\n                return\n            Cache.remove(category, key)\n\n    @staticmethod\n    def _purge_by_timeout(dt):\n        curtime = Clock.get_time()\n\n        for category in Cache._objects:\n            if category not in Cache._categories:\n                continue\n            timeout = Cache._categories[category]['timeout']\n            if timeout is not None and dt > timeout:\n                # XXX got a lag ! that may be because the frame take lot of\n                # time to draw. and the timeout is not adapted to the current\n                # framerate. So, increase the timeout by two.\n                # ie: if the timeout is 1 sec, and framerate go to 0.7, newly\n                # object added will be automatically trashed.\n                timeout *= 2\n                Cache._categories[category]['timeout'] = timeout\n                continue\n\n            for key in list(Cache._objects[category].keys()):\n                lastaccess = Cache._objects[category][key]['lastaccess']\n                objtimeout = Cache._objects[category][key]['timeout']\n\n                # take the object timeout if available\n                if objtimeout is not None:\n                    timeout = objtimeout\n\n                # no timeout, cancel\n                if timeout is None:\n                    continue\n\n                if curtime - lastaccess > timeout:\n                    Logger.trace('Cache: Removed %s:%s from cache due to '\n                                 'timeout' % (category, key))\n                    Cache.remove(category, key)\n\n    @staticmethod\n    def print_usage():\n        '''Print the cache usage to the console.'''\n        print('Cache usage :')\n        for category in Cache._categories:\n            print(' * %s : %d / %s, timeout=%s' % (\n                category.capitalize(),\n                len(Cache._objects[category]),\n                str(Cache._categories[category]['limit']),\n                str(Cache._categories[category]['timeout'])))",
  "def register(category, limit=None, timeout=None):\n        '''Register a new category in the cache with the specified limit.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `limit`: int (optional)\n                Maximum number of objects allowed in the cache.\n                If None, no limit is applied.\n            `timeout`: double (optional)\n                Time after which to delete the object if it has not been used.\n                If None, no timeout is applied.\n        '''\n        Cache._categories[category] = {\n            'limit': limit,\n            'timeout': timeout}\n        Cache._objects[category] = {}\n        Logger.debug(\n            'Cache: register <%s> with limit=%s, timeout=%s' %\n            (category, str(limit), str(timeout)))",
  "def append(category, key, obj, timeout=None):\n        '''Add a new object to the cache.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `key`: str\n                Unique identifier of the object to store.\n            `obj`: object\n                Object to store in cache.\n            `timeout`: double (optional)\n                Time after which to delete the object if it has not been used.\n                If None, no timeout is applied.\n\n        :raises:\n            `ValueError`: If `None` is used as `key`.\n\n        .. versionchanged:: 2.0.0\n            Raises `ValueError` if `None` is used as `key`.\n\n        '''\n        # check whether obj should not be cached first\n        if getattr(obj, '_nocache', False):\n            return\n        if key is None:\n            # This check is added because of the case when key is None and\n            # one of purge methods gets called. Then loop in purge method will\n            # call Cache.remove with key None which then clears entire\n            # category from Cache making next iteration of loop to raise a\n            # KeyError because next key will not exist.\n            # See: https://github.com/kivy/kivy/pull/6950\n            raise ValueError('\"None\" cannot be used as key in Cache')\n        try:\n            cat = Cache._categories[category]\n        except KeyError:\n            Logger.warning('Cache: category <%s> does not exist' % category)\n            return\n\n        timeout = timeout or cat['timeout']\n\n        limit = cat['limit']\n\n        if limit is not None and len(Cache._objects[category]) >= limit:\n            Cache._purge_oldest(category)\n\n        Cache._objects[category][key] = {\n            'object': obj,\n            'timeout': timeout,\n            'lastaccess': Clock.get_time(),\n            'timestamp': Clock.get_time()}",
  "def get(category, key, default=None):\n        '''Get a object from the cache.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `key`: str\n                Unique identifier of the object in the store.\n            `default`: anything, defaults to None\n                Default value to be returned if the key is not found.\n        '''\n        try:\n            Cache._objects[category][key]['lastaccess'] = Clock.get_time()\n            return Cache._objects[category][key]['object']\n        except Exception:\n            return default",
  "def get_timestamp(category, key, default=None):\n        '''Get the object timestamp in the cache.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `key`: str\n                Unique identifier of the object in the store.\n            `default`: anything, defaults to None\n                Default value to be returned if the key is not found.\n        '''\n        try:\n            return Cache._objects[category][key]['timestamp']\n        except Exception:\n            return default",
  "def get_lastaccess(category, key, default=None):\n        '''Get the objects last access time in the cache.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `key`: str\n                Unique identifier of the object in the store.\n            `default`: anything, defaults to None\n                Default value to be returned if the key is not found.\n        '''\n        try:\n            return Cache._objects[category][key]['lastaccess']\n        except Exception:\n            return default",
  "def remove(category, key=None):\n        '''Purge the cache.\n\n        :Parameters:\n            `category`: str\n                Identifier of the category.\n            `key`: str (optional)\n                Unique identifier of the object in the store. If this\n                argument is not supplied, the entire category will be purged.\n        '''\n        try:\n            if key is not None:\n                del Cache._objects[category][key]\n                Logger.trace('Cache: Removed %s:%s from cache' %\n                             (category, key))\n            else:\n                Cache._objects[category] = {}\n                Logger.trace('Cache: Flushed category %s from cache' %\n                             category)\n        except Exception:\n            pass",
  "def _purge_oldest(category, maxpurge=1):\n        Logger.trace('Cache: Remove oldest in %s' % category)\n        import heapq\n        time = Clock.get_time()\n        heap_list = []\n        for key in Cache._objects[category]:\n            obj = Cache._objects[category][key]\n            if obj['lastaccess'] == obj['timestamp'] == time:\n                continue\n            heapq.heappush(heap_list, (obj['lastaccess'], key))\n            Logger.trace('Cache: <<< %f' % obj['lastaccess'])\n        n = 0\n        while n <= maxpurge:\n            try:\n                n += 1\n                lastaccess, key = heapq.heappop(heap_list)\n                Logger.trace('Cache: %d => %s %f %f' %\n                             (n, key, lastaccess, Clock.get_time()))\n            except Exception:\n                return\n            Cache.remove(category, key)",
  "def _purge_by_timeout(dt):\n        curtime = Clock.get_time()\n\n        for category in Cache._objects:\n            if category not in Cache._categories:\n                continue\n            timeout = Cache._categories[category]['timeout']\n            if timeout is not None and dt > timeout:\n                # XXX got a lag ! that may be because the frame take lot of\n                # time to draw. and the timeout is not adapted to the current\n                # framerate. So, increase the timeout by two.\n                # ie: if the timeout is 1 sec, and framerate go to 0.7, newly\n                # object added will be automatically trashed.\n                timeout *= 2\n                Cache._categories[category]['timeout'] = timeout\n                continue\n\n            for key in list(Cache._objects[category].keys()):\n                lastaccess = Cache._objects[category][key]['lastaccess']\n                objtimeout = Cache._objects[category][key]['timeout']\n\n                # take the object timeout if available\n                if objtimeout is not None:\n                    timeout = objtimeout\n\n                # no timeout, cancel\n                if timeout is None:\n                    continue\n\n                if curtime - lastaccess > timeout:\n                    Logger.trace('Cache: Removed %s:%s from cache due to '\n                                 'timeout' % (category, key))\n                    Cache.remove(category, key)",
  "def print_usage():\n        '''Print the cache usage to the console.'''\n        print('Cache usage :')\n        for category in Cache._categories:\n            print(' * %s : %d / %s, timeout=%s' % (\n                category.capitalize(),\n                len(Cache._objects[category]),\n                str(Cache._categories[category]['limit']),\n                str(Cache._categories[category]['timeout'])))",
  "def parse_kivy_version(version):\n    \"\"\"Parses the kivy version as described in :func:`require` into a 3-tuple\n    of ([x, y, z], 'rc|a|b|dev|post', 'N') where N is the tag revision. The\n    last two elements may be None.\n    \"\"\"\n    m = re.match(\n        '^([0-9]+)\\\\.([0-9]+)\\\\.([0-9]+?)(rc|a|b|\\\\.dev|\\\\.post)?([0-9]+)?$',\n        version)\n    if m is None:\n        raise Exception('Revision format must be X.Y.Z[-tag]')\n\n    major, minor, micro, tag, tagrev = m.groups()\n    if tag == '.dev':\n        tag = 'dev'\n    if tag == '.post':\n        tag = 'post'\n    return [int(major), int(minor), int(micro)], tag, tagrev",
  "def require(version):\n    '''Require can be used to check the minimum version required to run a Kivy\n    application. For example, you can start your application code like this::\n\n        import kivy\n        kivy.require('1.0.1')\n\n    If a user attempts to run your application with a version of Kivy that is\n    older than the specified version, an Exception is raised.\n\n    The Kivy version string is built like this::\n\n        X.Y.Z[tag[tagrevision]]\n\n        X is the major version\n        Y is the minor version\n        Z is the bugfixes revision\n\n    The tag is optional, but may be one of '.dev', '.post', 'a', 'b', or 'rc'.\n    The tagrevision is the revision number of the tag.\n\n    .. warning::\n\n        You must not ask for a version with a tag, except -dev. Asking for a\n        'dev' version will just warn the user if the current Kivy\n        version is not a -dev, but it will never raise an exception.\n        You must not ask for a version with a tagrevision.\n\n    '''\n\n    # user version\n    revision, tag, tagrev = parse_kivy_version(version)\n    # current version\n    sysrevision, systag, systagrev = parse_kivy_version(__version__)\n\n    if tag and not systag:\n        Logger.warning('Application requested a dev version of Kivy. '\n                       '(You have %s, but the application requires %s)' % (\n                           __version__, version))\n    # not tag rev (-alpha-1, -beta-x) allowed.\n    if tagrev is not None:\n        raise Exception('Revision format must not contain any tagrevision')\n\n    # finally, checking revision\n    if sysrevision < revision:\n        raise Exception('The version of Kivy installed on this system '\n                        'is too old. '\n                        '(You have %s, but the application requires %s)' % (\n                            __version__, version))",
  "def kivy_configure():\n    '''Call post-configuration of Kivy.\n    This function must be called if you create the window yourself.\n    '''\n    for callback in __kivy_post_configuration:\n        callback()",
  "def get_includes():\n    '''Retrieves the directories containing includes needed to build new Cython\n    modules with Kivy as a dependency. Currently returns the location of the\n    kivy.graphics module.\n\n    .. versionadded:: 1.9.1\n    '''\n    root_dir = dirname(__file__)\n    return [join(root_dir, 'graphics'), join(root_dir, 'tools', 'gles_compat'),\n            join(root_dir, 'include')]",
  "def kivy_register_post_configuration(callback):\n    '''Register a function to be called when kivy_configure() is called.\n\n    .. warning::\n        Internal use only.\n    '''\n    __kivy_post_configuration.append(callback)",
  "def kivy_usage():\n    '''Kivy Usage: %s [KIVY OPTION...] [-- PROGRAM OPTIONS]::\n\n            Options placed after a '-- ' separator, will not be touched by kivy,\n            and instead passed to your program.\n\n            Set KIVY_NO_ARGS=1 in your environment or before you import Kivy to\n            disable Kivy's argument parser.\n\n        -h, --help\n            Prints this help message.\n        -d, --debug\n            Shows debug log.\n        -a, --auto-fullscreen\n            Force 'auto' fullscreen mode (no resolution change).\n            Uses your display's resolution. This is most likely what you want.\n        -c, --config section:key[:value]\n            Set a custom [section] key=value in the configuration object.\n        -f, --fullscreen\n            Force running in fullscreen mode.\n        -k, --fake-fullscreen\n            Force 'fake' fullscreen mode (no window border/decoration).\n            Uses the resolution specified by width and height in your config.\n        -w, --windowed\n            Force running in a window.\n        -p, --provider id:provider[,options]\n            Add an input provider (eg: ccvtable1:tuio,192.168.0.1:3333).\n        -m mod, --module=mod\n            Activate a module (use \"list\" to get a list of available modules).\n        -r, --rotation\n            Rotate the window's contents (0, 90, 180, 270).\n        -s, --save\n            Save current Kivy configuration.\n        --size=640x480\n            Size of window geometry.\n        --dpi=96\n            Manually overload the Window DPI (for testing only.)\n    '''\n    print(kivy_usage.__doc__ % (basename(sys.argv[0])))",
  "def _patch_mod_deps_win(dep_mod, mod_name):\n    import site\n    dep_bins = []\n\n    for d in [sys.prefix, site.USER_BASE]:\n        p = join(d, 'share', mod_name, 'bin')\n        if os.path.isdir(p):\n            os.environ[\"PATH\"] = p + os.pathsep + os.environ[\"PATH\"]\n            if hasattr(os, 'add_dll_directory'):\n                os.add_dll_directory(p)\n            dep_bins.append(p)\n\n    dep_mod.dep_bins = dep_bins",
  "def resource_find(filename, use_cache=(\"KIVY_DOC_INCLUDE\" not in os.environ)):\n    '''Search for a resource in the list of paths.\n    Use resource_add_path to add a custom path to the search.\n    By default, results are cached for 60 seconds.\n    This can be disabled using use_cache=False.\n\n    .. versionchanged:: 2.1.0\n        `use_cache` parameter added and made True by default.\n    '''\n    if not filename:\n        return\n    found_filename = None\n    if use_cache:\n        found_filename = Cache.get('kv.resourcefind', filename)\n        if found_filename:\n            return found_filename\n    if filename[:8] == 'atlas://':\n        found_filename = filename\n    else:\n        abspath_filename = abspath(filename)\n        if exists(abspath_filename):\n            found_filename = abspath(filename)\n        else:\n            for path in reversed(resource_paths):\n                abspath_filename = abspath(join(path, filename))\n                if exists(abspath_filename):\n                    found_filename = abspath_filename\n                    break\n        if not found_filename and filename.startswith(\"data:\"):\n            found_filename = filename\n    if use_cache and found_filename:\n        Cache.append('kv.resourcefind', filename, found_filename)\n    return found_filename",
  "def resource_add_path(path):\n    '''Add a custom path to search in.\n    '''\n    if path in resource_paths:\n        return\n    Logger.debug('Resource: add <%s> in path list' % path)\n    resource_paths.append(path)",
  "def resource_remove_path(path):\n    '''Remove a search path.\n\n    .. versionadded:: 1.0.8\n    '''\n    if path not in resource_paths:\n        return\n    Logger.debug('Resource: remove <%s> from path list' % path)\n    resource_paths.remove(path)",
  "def install_gobject_iteration():\n    '''Import and install gobject context iteration inside our event loop.\n    This is used as soon as gobject is used (like gstreamer).\n    '''\n\n    from kivy.clock import Clock\n\n    try:\n        from gi.repository import GObject as gobject\n    except ImportError:\n        import gobject\n\n    if hasattr(gobject, '_gobject_already_installed'):\n        # already installed, don't do it twice.\n        return\n\n    gobject._gobject_already_installed = True\n\n    # get gobject mainloop / context\n    loop = gobject.MainLoop()\n    gobject.threads_init()\n    context = loop.get_context()\n\n    # schedule the iteration each frame\n    def _gobject_iteration(*largs):\n        # XXX we need to loop over context here, otherwise, we might have a lag\n        loop = 0\n        while context.pending() and loop < 10:\n            context.iteration(False)\n            loop += 1\n    Clock.schedule_interval(_gobject_iteration, 0)",
  "def _android_ask_redraw(*largs):\n    # after wakeup, we need to redraw more than once, otherwise we get a\n    # black screen\n    global g_android_redraw_count\n    from kivy.core.window import Window\n    Window.canvas.ask_update()\n    g_android_redraw_count -= 1\n    if g_android_redraw_count < 0:\n        return False",
  "def install_android():\n    '''Install hooks for the android platform.\n\n    * Automatically sleep when the device is paused.\n    * Automatically kill the application when the return key is pressed.\n    '''\n    try:\n        import android\n    except ImportError:\n        print('Android lib is missing, cannot install android hooks')\n        return\n\n    from kivy.clock import Clock\n    from kivy.logger import Logger\n    import pygame\n\n    Logger.info('Support: Android install hooks')\n\n    # Init the library\n    android.init()\n    android.map_key(android.KEYCODE_MENU, pygame.K_MENU)\n    android.map_key(android.KEYCODE_BACK, pygame.K_ESCAPE)\n\n    # Check if android should be paused or not.\n    # If pause is requested, just leave the app.\n    def android_check_pause(*largs):\n        # do nothing until android asks for it.\n        if not android.check_pause():\n            return\n\n        from kivy.app import App\n        from kivy.base import stopTouchApp\n        from kivy.logger import Logger\n        from kivy.core.window import Window\n        global g_android_redraw_count, _redraw_event\n\n        # try to get the current running application\n        Logger.info('Android: Must go into sleep mode, check the app')\n        app = App.get_running_app()\n\n        # no running application, stop our loop.\n        if app is None:\n            Logger.info('Android: No app running, stop everything.')\n            stopTouchApp()\n            return\n\n        # try to go to pause mode\n        if app.dispatch('on_pause'):\n            Logger.info('Android: App paused, now wait for resume.')\n\n            # app goes in pause mode, wait.\n            android.wait_for_resume()\n\n            # is it a stop or resume ?\n            if android.check_stop():\n                # app must stop\n                Logger.info('Android: Android wants to close our app.')\n                stopTouchApp()\n            else:\n                # app resuming now !\n                Logger.info('Android: Android has resumed, resume the app.')\n                app.dispatch('on_resume')\n                Window.canvas.ask_update()\n                g_android_redraw_count = 25  # 5 frames/seconds for 5 seconds\n                if _redraw_event is None:\n                    _redraw_event = Clock.schedule_interval(\n                        _android_ask_redraw, 1 / 5)\n                else:\n                    _redraw_event.cancel()\n                    _redraw_event()\n                Logger.info('Android: App resume completed.')\n\n        # app doesn't support pause mode, just stop it.\n        else:\n            Logger.info('Android: App doesn\\'t support pause mode, stop.')\n            stopTouchApp()\n\n    Clock.schedule_interval(android_check_pause, 0)",
  "def install_twisted_reactor(**kwargs):\n    '''Installs a threaded twisted reactor, which will schedule one\n    reactor iteration before the next frame only when twisted needs\n    to do some work.\n\n    Any arguments or keyword arguments passed to this function will be\n    passed on the threadedselect reactors interleave function. These\n    are the arguments one would usually pass to twisted's reactor.startRunning.\n\n    Unlike the default twisted reactor, the installed reactor will not handle\n    any signals unless you set the 'installSignalHandlers' keyword argument\n    to 1 explicitly. This is done to allow kivy to handle the signals as\n    usual unless you specifically want the twisted reactor to handle the\n    signals (e.g. SIGINT).\n\n    .. note::\n        Twisted is not included in iOS build by default. To use it on iOS,\n        put the twisted distribution (and zope.interface dependency) in your\n        application directory.\n    '''\n\n    import twisted\n\n    # prevent installing more than once\n    if hasattr(twisted, '_kivy_twisted_reactor_installed'):\n        return\n    twisted._kivy_twisted_reactor_installed = True\n\n    # don't let twisted handle signals, unless specifically requested\n    kwargs.setdefault('installSignalHandlers', 0)\n\n    # install threaded-select reactor, to use with own event loop\n    from twisted.internet import _threadedselect\n    _threadedselect.install()\n\n    # now we can import twisted reactor as usual\n    from twisted.internet import reactor\n    from twisted.internet.error import ReactorNotRunning\n\n    from collections import deque\n    from kivy.base import EventLoop\n    from kivy.logger import Logger\n    from kivy.clock import Clock\n\n    # will hold callbacks to twisted callbacks\n    q = deque()\n\n    # twisted will call the wake function when it needs to do work\n    def reactor_wake(twisted_loop_next):\n        '''Wakeup the twisted reactor to start processing the task queue\n        '''\n\n        Logger.trace(\"Support: twisted wakeup call to schedule task\")\n        q.append(twisted_loop_next)\n\n    # called every frame, to process the reactors work in main thread\n    def reactor_work(*args):\n        '''Process the twisted reactor task queue\n        '''\n        Logger.trace(\"Support: processing twisted task queue\")\n        while len(q):\n            q.popleft()()\n    global _twisted_reactor_work\n    _twisted_reactor_work = reactor_work\n\n    # start the reactor, by telling twisted how to wake, and process\n    def reactor_start(*args):\n        '''Start the twisted reactor main loop\n        '''\n        Logger.info(\"Support: Starting twisted reactor\")\n        reactor.interleave(reactor_wake, **kwargs)\n        Clock.schedule_interval(reactor_work, 0)\n\n    # make sure twisted reactor is shutdown if eventloop exists\n    def reactor_stop(*args):\n        '''Shutdown the twisted reactor main loop\n        '''\n        if reactor.threadpool:\n            Logger.info(\"Support: Stopping twisted threads\")\n            reactor.threadpool.stop()\n        Logger.info(\"Support: Shutting down twisted reactor\")\n        reactor._mainLoopShutdown()\n        try:\n            reactor.stop()\n        except ReactorNotRunning:\n            pass\n\n        import sys\n        sys.modules.pop('twisted.internet.reactor', None)\n\n    global _twisted_reactor_stopper\n    _twisted_reactor_stopper = reactor_stop\n\n    # start and stop the reactor along with kivy EventLoop\n    Clock.schedule_once(reactor_start, 0)\n    EventLoop.bind(on_stop=reactor_stop)",
  "def uninstall_twisted_reactor():\n    '''Uninstalls the Kivy's threaded Twisted Reactor. No more Twisted\n    tasks will run after this got called. Use this to clean the\n    `twisted.internet.reactor` .\n\n    .. versionadded:: 1.9.0\n    '''\n\n    import twisted\n\n    # prevent uninstalling more than once\n    if not hasattr(twisted, '_kivy_twisted_reactor_installed'):\n        return\n\n    from kivy.base import EventLoop\n\n    global _twisted_reactor_stopper\n    _twisted_reactor_stopper()\n    EventLoop.unbind(on_stop=_twisted_reactor_stopper)\n\n    del twisted._kivy_twisted_reactor_installed",
  "def _gobject_iteration(*largs):\n        # XXX we need to loop over context here, otherwise, we might have a lag\n        loop = 0\n        while context.pending() and loop < 10:\n            context.iteration(False)\n            loop += 1",
  "def android_check_pause(*largs):\n        # do nothing until android asks for it.\n        if not android.check_pause():\n            return\n\n        from kivy.app import App\n        from kivy.base import stopTouchApp\n        from kivy.logger import Logger\n        from kivy.core.window import Window\n        global g_android_redraw_count, _redraw_event\n\n        # try to get the current running application\n        Logger.info('Android: Must go into sleep mode, check the app')\n        app = App.get_running_app()\n\n        # no running application, stop our loop.\n        if app is None:\n            Logger.info('Android: No app running, stop everything.')\n            stopTouchApp()\n            return\n\n        # try to go to pause mode\n        if app.dispatch('on_pause'):\n            Logger.info('Android: App paused, now wait for resume.')\n\n            # app goes in pause mode, wait.\n            android.wait_for_resume()\n\n            # is it a stop or resume ?\n            if android.check_stop():\n                # app must stop\n                Logger.info('Android: Android wants to close our app.')\n                stopTouchApp()\n            else:\n                # app resuming now !\n                Logger.info('Android: Android has resumed, resume the app.')\n                app.dispatch('on_resume')\n                Window.canvas.ask_update()\n                g_android_redraw_count = 25  # 5 frames/seconds for 5 seconds\n                if _redraw_event is None:\n                    _redraw_event = Clock.schedule_interval(\n                        _android_ask_redraw, 1 / 5)\n                else:\n                    _redraw_event.cancel()\n                    _redraw_event()\n                Logger.info('Android: App resume completed.')\n\n        # app doesn't support pause mode, just stop it.\n        else:\n            Logger.info('Android: App doesn\\'t support pause mode, stop.')\n            stopTouchApp()",
  "def reactor_wake(twisted_loop_next):\n        '''Wakeup the twisted reactor to start processing the task queue\n        '''\n\n        Logger.trace(\"Support: twisted wakeup call to schedule task\")\n        q.append(twisted_loop_next)",
  "def reactor_work(*args):\n        '''Process the twisted reactor task queue\n        '''\n        Logger.trace(\"Support: processing twisted task queue\")\n        while len(q):\n            q.popleft()()",
  "def reactor_start(*args):\n        '''Start the twisted reactor main loop\n        '''\n        Logger.info(\"Support: Starting twisted reactor\")\n        reactor.interleave(reactor_wake, **kwargs)\n        Clock.schedule_interval(reactor_work, 0)",
  "def reactor_stop(*args):\n        '''Shutdown the twisted reactor main loop\n        '''\n        if reactor.threadpool:\n            Logger.info(\"Support: Stopping twisted threads\")\n            reactor.threadpool.stop()\n        Logger.info(\"Support: Shutting down twisted reactor\")\n        reactor._mainLoopShutdown()\n        try:\n            reactor.stop()\n        except ReactorNotRunning:\n            pass\n\n        import sys\n        sys.modules.pop('twisted.internet.reactor', None)",
  "class GestureDatabase(object):\n    '''Class to handle a gesture database.'''\n\n    def __init__(self):\n        self.db = []\n\n    def add_gesture(self, gesture):\n        '''Add a new gesture to the database.'''\n        self.db.append(gesture)\n\n    def find(self, gesture, minscore=0.9, rotation_invariant=True):\n        '''Find a matching gesture in the database.'''\n        if not gesture:\n            return\n\n        best = None\n        bestscore = minscore\n        for g in self.db:\n            score = g.get_score(gesture, rotation_invariant)\n            if score < bestscore:\n                continue\n            bestscore = score\n            best = g\n        if not best:\n            return\n        return (bestscore, best)\n\n    def gesture_to_str(self, gesture):\n        '''Convert a gesture into a unique string.'''\n        io = BytesIO()\n        p = pickle.Pickler(io)\n        p.dump(gesture)\n        data = base64.b64encode(zlib.compress(io.getvalue(), 9))\n        return data\n\n    def str_to_gesture(self, data):\n        '''Convert a unique string to a gesture.'''\n        io = BytesIO(zlib.decompress(base64.b64decode(data)))\n        p = pickle.Unpickler(io)\n        gesture = p.load()\n        return gesture",
  "class GesturePoint:\n\n    def __init__(self, x, y):\n        '''Stores the x,y coordinates of a point in the gesture.'''\n        self.x = float(x)\n        self.y = float(y)\n\n    def scale(self, factor):\n        ''' Scales the point by the given factor.'''\n        self.x *= factor\n        self.y *= factor\n        return self\n\n    def __repr__(self):\n        return 'Mouse_point: %f,%f' % (self.x, self.y)",
  "class GestureStroke:\n    ''' Gestures can be made up of multiple strokes.'''\n\n    def __init__(self):\n        ''' A stroke in the gesture.'''\n        self.points = list()\n        self.screenpoints = list()\n\n    # These return the min and max coordinates of the stroke\n    @property\n    def max_x(self):\n        if len(self.points) == 0:\n            return 0\n        return max(self.points, key=lambda pt: pt.x).x\n\n    @property\n    def min_x(self):\n        if len(self.points) == 0:\n            return 0\n        return min(self.points, key=lambda pt: pt.x).x\n\n    @property\n    def max_y(self):\n        if len(self.points) == 0:\n            return 0\n        return max(self.points, key=lambda pt: pt.y).y\n\n    @property\n    def min_y(self):\n        if len(self.points) == 0:\n            return 0\n        return min(self.points, key=lambda pt: pt.y).y\n\n    def add_point(self, x, y):\n        '''\n        add_point(x=x_pos, y=y_pos)\n        Adds a point to the stroke.\n        '''\n        self.points.append(GesturePoint(x, y))\n        self.screenpoints.append((x, y))\n\n    def scale_stroke(self, scale_factor):\n        '''\n        scale_stroke(scale_factor=float)\n        Scales the stroke down by scale_factor.\n        '''\n        self.points = [pt.scale(scale_factor) for pt in self.points]\n\n    def points_distance(self, point1, point2):\n        '''\n        points_distance(point1=GesturePoint, point2=GesturePoint)\n        Returns the distance between two GesturePoints.\n        '''\n        x = point1.x - point2.x\n        y = point1.y - point2.y\n        return math.sqrt(x * x + y * y)\n\n    def stroke_length(self, point_list=None):\n        '''Finds the length of the stroke. If a point list is given,\n           finds the length of that list.\n        '''\n        if point_list is None:\n            point_list = self.points\n        gesture_length = 0.0\n        if len(point_list) <= 1:  # If there is only one point -> no length\n            return gesture_length\n        for i in range(len(point_list) - 1):\n            gesture_length += self.points_distance(\n                point_list[i], point_list[i + 1])\n        return gesture_length\n\n    def normalize_stroke(self, sample_points=32):\n        '''Normalizes strokes so that every stroke has a standard number of\n           points. Returns True if stroke is normalized, False if it can't be\n           normalized. sample_points controls the resolution of the stroke.\n        '''\n        # If there is only one point or the length is 0, don't normalize\n        if len(self.points) <= 1 or self.stroke_length(self.points) == 0.0:\n            return False\n\n        # Calculate how long each point should be in the stroke\n        target_stroke_size = \\\n            self.stroke_length(self.points) / float(sample_points)\n        new_points = list()\n        new_points.append(self.points[0])\n\n        # We loop on the points\n        prev = self.points[0]\n        src_distance = 0.0\n        dst_distance = target_stroke_size\n        for curr in self.points[1:]:\n            d = self.points_distance(prev, curr)\n            if d > 0:\n                prev = curr\n                src_distance = src_distance + d\n\n                # The new point need to be inserted into the\n                # segment [prev, curr]\n                while dst_distance < src_distance:\n                    x_dir = curr.x - prev.x\n                    y_dir = curr.y - prev.y\n                    ratio = (src_distance - dst_distance) / d\n                    to_x = x_dir * ratio + prev.x\n                    to_y = y_dir * ratio + prev.y\n                    new_points.append(GesturePoint(to_x, to_y))\n                    dst_distance = self.stroke_length(self.points) / \\\n                        float(sample_points) * len(new_points)\n\n        # If this happens, we are into troubles...\n        if not len(new_points) == sample_points:\n            raise ValueError('Invalid number of strokes points; got '\n                             '%d while it should be %d' %\n                             (len(new_points), sample_points))\n\n        self.points = new_points\n        return True\n\n    def center_stroke(self, offset_x, offset_y):\n        '''Centers the stroke by offsetting the points.'''\n        for point in self.points:\n            point.x -= offset_x\n            point.y -= offset_y",
  "class Gesture:\n    '''A python implementation of a gesture recognition algorithm by\n    Oleg Dopertchouk: http://www.gamedev.net/reference/articles/article2039.asp\n\n    Implemented by Jeiel Aranal (chemikhazi@gmail.com),\n    released into the public domain.\n    '''\n\n    # Tolerance for evaluation using the '==' operator\n    DEFAULT_TOLERANCE = 0.1\n\n    def __init__(self, tolerance=None):\n        '''\n        Gesture([tolerance=float])\n        Creates a new gesture with an optional matching tolerance value.\n        '''\n        self.width = 0.\n        self.height = 0.\n        self.gesture_product = 0.\n        self.strokes = list()\n        if tolerance is None:\n            self.tolerance = Gesture.DEFAULT_TOLERANCE\n        else:\n            self.tolerance = tolerance\n\n    def _scale_gesture(self):\n        ''' Scales down the gesture to a unit of 1.'''\n        # map() creates a list of min/max coordinates of the strokes\n        # in the gesture and min()/max() pulls the lowest/highest value\n        min_x = min([stroke.min_x for stroke in self.strokes])\n        max_x = max([stroke.max_x for stroke in self.strokes])\n        min_y = min([stroke.min_y for stroke in self.strokes])\n        max_y = max([stroke.max_y for stroke in self.strokes])\n        x_len = max_x - min_x\n        self.width = x_len\n        y_len = max_y - min_y\n        self.height = y_len\n        scale_factor = max(x_len, y_len)\n        if scale_factor <= 0.0:\n            return False\n        scale_factor = 1.0 / scale_factor\n        for stroke in self.strokes:\n            stroke.scale_stroke(scale_factor)\n        return True\n\n    def _center_gesture(self):\n        ''' Centers the Gesture.points of the gesture.'''\n        total_x = 0.0\n        total_y = 0.0\n        total_points = 0\n\n        for stroke in self.strokes:\n            # adds up all the points inside the stroke\n            stroke_y = sum([pt.y for pt in stroke.points])\n            stroke_x = sum([pt.x for pt in stroke.points])\n            total_y += stroke_y\n            total_x += stroke_x\n            total_points += len(stroke.points)\n        if total_points == 0:\n            return False\n        # Average to get the offset\n        total_x /= total_points\n        total_y /= total_points\n        # Apply the offset to the strokes\n        for stroke in self.strokes:\n            stroke.center_stroke(total_x, total_y)\n        return True\n\n    def add_stroke(self, point_list=None):\n        '''Adds a stroke to the gesture and returns the Stroke instance.\n           Optional point_list argument is a list of the mouse points for\n           the stroke.\n        '''\n        self.strokes.append(GestureStroke())\n        if isinstance(point_list, list) or isinstance(point_list, tuple):\n            for point in point_list:\n                if isinstance(point, GesturePoint):\n                    self.strokes[-1].points.append(point)\n                elif isinstance(point, list) or isinstance(point, tuple):\n                    if len(point) != 2:\n                        raise ValueError(\"Stroke entry must have 2 values max\")\n                    self.strokes[-1].add_point(point[0], point[1])\n                else:\n                    raise TypeError(\"The point list should either be \"\n                                    \"tuples of x and y or a list of \"\n                                    \"GesturePoint objects\")\n        elif point_list is not None:\n            raise ValueError(\"point_list should be a tuple/list\")\n        return self.strokes[-1]\n\n    def normalize(self, stroke_samples=32):\n        '''Runs the gesture normalization algorithm and calculates the dot\n        product with self.\n        '''\n        if not self._scale_gesture() or not self._center_gesture():\n            self.gesture_product = False\n            return False\n        for stroke in self.strokes:\n            stroke.normalize_stroke(stroke_samples)\n        self.gesture_product = self.dot_product(self)\n\n    def get_rigid_rotation(self, dstpts):\n        '''\n        Extract the rotation to apply to a group of points to minimize the\n        distance to a second group of points. The two groups of points are\n        assumed to be centered. This is a simple version that just picks\n        an angle based on the first point of the gesture.\n        '''\n        if len(self.strokes) < 1 or len(self.strokes[0].points) < 1:\n            return 0\n        if len(dstpts.strokes) < 1 or len(dstpts.strokes[0].points) < 1:\n            return 0\n        p = dstpts.strokes[0].points[0]\n        target = Vector([p.x, p.y])\n        source = Vector([p.x, p.y])\n        return source.angle(target)\n\n    def dot_product(self, comparison_gesture):\n        ''' Calculates the dot product of the gesture with another gesture.'''\n        if len(comparison_gesture.strokes) != len(self.strokes):\n            return -1\n        if getattr(comparison_gesture, 'gesture_product', True) is False or \\\n           getattr(self, 'gesture_product', True) is False:\n            return -1\n        dot_product = 0.0\n        for stroke_index, (my_stroke, cmp_stroke) in enumerate(\n                list(zip(self.strokes, comparison_gesture.strokes))):\n            for pt_index, (my_point, cmp_point) in enumerate(\n                    list(zip(my_stroke.points, cmp_stroke.points))):\n                dot_product += (my_point.x * cmp_point.x +\n                                my_point.y * cmp_point.y)\n        return dot_product\n\n    def rotate(self, angle):\n        g = Gesture()\n        for stroke in self.strokes:\n            tmp = []\n            for j in stroke.points:\n                v = Vector([j.x, j.y]).rotate(angle)\n                tmp.append(v)\n            g.add_stroke(tmp)\n        g.gesture_product = g.dot_product(g)\n        return g\n\n    def get_score(self, comparison_gesture, rotation_invariant=True):\n        ''' Returns the matching score of the gesture against another gesture.\n        '''\n        if isinstance(comparison_gesture, Gesture):\n            if rotation_invariant:\n                # get orientation\n                angle = self.get_rigid_rotation(comparison_gesture)\n\n                # rotate the gesture to be in the same frame.\n                comparison_gesture = comparison_gesture.rotate(angle)\n\n            # this is the normal \"orientation\" code.\n            score = self.dot_product(comparison_gesture)\n            if score <= 0:\n                return score\n            score /= math.sqrt(\n                self.gesture_product * comparison_gesture.gesture_product)\n            return score\n\n    def __eq__(self, comparison_gesture):\n        ''' Allows easy comparisons between gesture instances.'''\n        if isinstance(comparison_gesture, Gesture):\n            # If the gestures don't have the same number of strokes, its\n            # definitely not the same gesture\n            score = self.get_score(comparison_gesture)\n            if (score > (1.0 - self.tolerance) and\n                    score < (1.0 + self.tolerance)):\n                return True\n            else:\n                return False\n        else:\n            return NotImplemented\n\n    def __ne__(self, comparison_gesture):\n        result = self.__eq__(comparison_gesture)\n        if result is NotImplemented:\n            return result\n        else:\n            return not result\n\n    def __lt__(self, comparison_gesture):\n        raise TypeError(\"Gesture cannot be evaluated with <\")\n\n    def __gt__(self, comparison_gesture):\n        raise TypeError(\"Gesture cannot be evaluated with >\")\n\n    def __le__(self, comparison_gesture):\n        raise TypeError(\"Gesture cannot be evaluated with <=\")\n\n    def __ge__(self, comparison_gesture):\n        raise TypeError(\"Gesture cannot be evaluated with >=\")",
  "def __init__(self):\n        self.db = []",
  "def add_gesture(self, gesture):\n        '''Add a new gesture to the database.'''\n        self.db.append(gesture)",
  "def find(self, gesture, minscore=0.9, rotation_invariant=True):\n        '''Find a matching gesture in the database.'''\n        if not gesture:\n            return\n\n        best = None\n        bestscore = minscore\n        for g in self.db:\n            score = g.get_score(gesture, rotation_invariant)\n            if score < bestscore:\n                continue\n            bestscore = score\n            best = g\n        if not best:\n            return\n        return (bestscore, best)",
  "def gesture_to_str(self, gesture):\n        '''Convert a gesture into a unique string.'''\n        io = BytesIO()\n        p = pickle.Pickler(io)\n        p.dump(gesture)\n        data = base64.b64encode(zlib.compress(io.getvalue(), 9))\n        return data",
  "def str_to_gesture(self, data):\n        '''Convert a unique string to a gesture.'''\n        io = BytesIO(zlib.decompress(base64.b64decode(data)))\n        p = pickle.Unpickler(io)\n        gesture = p.load()\n        return gesture",
  "def __init__(self, x, y):\n        '''Stores the x,y coordinates of a point in the gesture.'''\n        self.x = float(x)\n        self.y = float(y)",
  "def scale(self, factor):\n        ''' Scales the point by the given factor.'''\n        self.x *= factor\n        self.y *= factor\n        return self",
  "def __repr__(self):\n        return 'Mouse_point: %f,%f' % (self.x, self.y)",
  "def __init__(self):\n        ''' A stroke in the gesture.'''\n        self.points = list()\n        self.screenpoints = list()",
  "def max_x(self):\n        if len(self.points) == 0:\n            return 0\n        return max(self.points, key=lambda pt: pt.x).x",
  "def min_x(self):\n        if len(self.points) == 0:\n            return 0\n        return min(self.points, key=lambda pt: pt.x).x",
  "def max_y(self):\n        if len(self.points) == 0:\n            return 0\n        return max(self.points, key=lambda pt: pt.y).y",
  "def min_y(self):\n        if len(self.points) == 0:\n            return 0\n        return min(self.points, key=lambda pt: pt.y).y",
  "def add_point(self, x, y):\n        '''\n        add_point(x=x_pos, y=y_pos)\n        Adds a point to the stroke.\n        '''\n        self.points.append(GesturePoint(x, y))\n        self.screenpoints.append((x, y))",
  "def scale_stroke(self, scale_factor):\n        '''\n        scale_stroke(scale_factor=float)\n        Scales the stroke down by scale_factor.\n        '''\n        self.points = [pt.scale(scale_factor) for pt in self.points]",
  "def points_distance(self, point1, point2):\n        '''\n        points_distance(point1=GesturePoint, point2=GesturePoint)\n        Returns the distance between two GesturePoints.\n        '''\n        x = point1.x - point2.x\n        y = point1.y - point2.y\n        return math.sqrt(x * x + y * y)",
  "def stroke_length(self, point_list=None):\n        '''Finds the length of the stroke. If a point list is given,\n           finds the length of that list.\n        '''\n        if point_list is None:\n            point_list = self.points\n        gesture_length = 0.0\n        if len(point_list) <= 1:  # If there is only one point -> no length\n            return gesture_length\n        for i in range(len(point_list) - 1):\n            gesture_length += self.points_distance(\n                point_list[i], point_list[i + 1])\n        return gesture_length",
  "def normalize_stroke(self, sample_points=32):\n        '''Normalizes strokes so that every stroke has a standard number of\n           points. Returns True if stroke is normalized, False if it can't be\n           normalized. sample_points controls the resolution of the stroke.\n        '''\n        # If there is only one point or the length is 0, don't normalize\n        if len(self.points) <= 1 or self.stroke_length(self.points) == 0.0:\n            return False\n\n        # Calculate how long each point should be in the stroke\n        target_stroke_size = \\\n            self.stroke_length(self.points) / float(sample_points)\n        new_points = list()\n        new_points.append(self.points[0])\n\n        # We loop on the points\n        prev = self.points[0]\n        src_distance = 0.0\n        dst_distance = target_stroke_size\n        for curr in self.points[1:]:\n            d = self.points_distance(prev, curr)\n            if d > 0:\n                prev = curr\n                src_distance = src_distance + d\n\n                # The new point need to be inserted into the\n                # segment [prev, curr]\n                while dst_distance < src_distance:\n                    x_dir = curr.x - prev.x\n                    y_dir = curr.y - prev.y\n                    ratio = (src_distance - dst_distance) / d\n                    to_x = x_dir * ratio + prev.x\n                    to_y = y_dir * ratio + prev.y\n                    new_points.append(GesturePoint(to_x, to_y))\n                    dst_distance = self.stroke_length(self.points) / \\\n                        float(sample_points) * len(new_points)\n\n        # If this happens, we are into troubles...\n        if not len(new_points) == sample_points:\n            raise ValueError('Invalid number of strokes points; got '\n                             '%d while it should be %d' %\n                             (len(new_points), sample_points))\n\n        self.points = new_points\n        return True",
  "def center_stroke(self, offset_x, offset_y):\n        '''Centers the stroke by offsetting the points.'''\n        for point in self.points:\n            point.x -= offset_x\n            point.y -= offset_y",
  "def __init__(self, tolerance=None):\n        '''\n        Gesture([tolerance=float])\n        Creates a new gesture with an optional matching tolerance value.\n        '''\n        self.width = 0.\n        self.height = 0.\n        self.gesture_product = 0.\n        self.strokes = list()\n        if tolerance is None:\n            self.tolerance = Gesture.DEFAULT_TOLERANCE\n        else:\n            self.tolerance = tolerance",
  "def _scale_gesture(self):\n        ''' Scales down the gesture to a unit of 1.'''\n        # map() creates a list of min/max coordinates of the strokes\n        # in the gesture and min()/max() pulls the lowest/highest value\n        min_x = min([stroke.min_x for stroke in self.strokes])\n        max_x = max([stroke.max_x for stroke in self.strokes])\n        min_y = min([stroke.min_y for stroke in self.strokes])\n        max_y = max([stroke.max_y for stroke in self.strokes])\n        x_len = max_x - min_x\n        self.width = x_len\n        y_len = max_y - min_y\n        self.height = y_len\n        scale_factor = max(x_len, y_len)\n        if scale_factor <= 0.0:\n            return False\n        scale_factor = 1.0 / scale_factor\n        for stroke in self.strokes:\n            stroke.scale_stroke(scale_factor)\n        return True",
  "def _center_gesture(self):\n        ''' Centers the Gesture.points of the gesture.'''\n        total_x = 0.0\n        total_y = 0.0\n        total_points = 0\n\n        for stroke in self.strokes:\n            # adds up all the points inside the stroke\n            stroke_y = sum([pt.y for pt in stroke.points])\n            stroke_x = sum([pt.x for pt in stroke.points])\n            total_y += stroke_y\n            total_x += stroke_x\n            total_points += len(stroke.points)\n        if total_points == 0:\n            return False\n        # Average to get the offset\n        total_x /= total_points\n        total_y /= total_points\n        # Apply the offset to the strokes\n        for stroke in self.strokes:\n            stroke.center_stroke(total_x, total_y)\n        return True",
  "def add_stroke(self, point_list=None):\n        '''Adds a stroke to the gesture and returns the Stroke instance.\n           Optional point_list argument is a list of the mouse points for\n           the stroke.\n        '''\n        self.strokes.append(GestureStroke())\n        if isinstance(point_list, list) or isinstance(point_list, tuple):\n            for point in point_list:\n                if isinstance(point, GesturePoint):\n                    self.strokes[-1].points.append(point)\n                elif isinstance(point, list) or isinstance(point, tuple):\n                    if len(point) != 2:\n                        raise ValueError(\"Stroke entry must have 2 values max\")\n                    self.strokes[-1].add_point(point[0], point[1])\n                else:\n                    raise TypeError(\"The point list should either be \"\n                                    \"tuples of x and y or a list of \"\n                                    \"GesturePoint objects\")\n        elif point_list is not None:\n            raise ValueError(\"point_list should be a tuple/list\")\n        return self.strokes[-1]",
  "def normalize(self, stroke_samples=32):\n        '''Runs the gesture normalization algorithm and calculates the dot\n        product with self.\n        '''\n        if not self._scale_gesture() or not self._center_gesture():\n            self.gesture_product = False\n            return False\n        for stroke in self.strokes:\n            stroke.normalize_stroke(stroke_samples)\n        self.gesture_product = self.dot_product(self)",
  "def get_rigid_rotation(self, dstpts):\n        '''\n        Extract the rotation to apply to a group of points to minimize the\n        distance to a second group of points. The two groups of points are\n        assumed to be centered. This is a simple version that just picks\n        an angle based on the first point of the gesture.\n        '''\n        if len(self.strokes) < 1 or len(self.strokes[0].points) < 1:\n            return 0\n        if len(dstpts.strokes) < 1 or len(dstpts.strokes[0].points) < 1:\n            return 0\n        p = dstpts.strokes[0].points[0]\n        target = Vector([p.x, p.y])\n        source = Vector([p.x, p.y])\n        return source.angle(target)",
  "def dot_product(self, comparison_gesture):\n        ''' Calculates the dot product of the gesture with another gesture.'''\n        if len(comparison_gesture.strokes) != len(self.strokes):\n            return -1\n        if getattr(comparison_gesture, 'gesture_product', True) is False or \\\n           getattr(self, 'gesture_product', True) is False:\n            return -1\n        dot_product = 0.0\n        for stroke_index, (my_stroke, cmp_stroke) in enumerate(\n                list(zip(self.strokes, comparison_gesture.strokes))):\n            for pt_index, (my_point, cmp_point) in enumerate(\n                    list(zip(my_stroke.points, cmp_stroke.points))):\n                dot_product += (my_point.x * cmp_point.x +\n                                my_point.y * cmp_point.y)\n        return dot_product",
  "def rotate(self, angle):\n        g = Gesture()\n        for stroke in self.strokes:\n            tmp = []\n            for j in stroke.points:\n                v = Vector([j.x, j.y]).rotate(angle)\n                tmp.append(v)\n            g.add_stroke(tmp)\n        g.gesture_product = g.dot_product(g)\n        return g",
  "def get_score(self, comparison_gesture, rotation_invariant=True):\n        ''' Returns the matching score of the gesture against another gesture.\n        '''\n        if isinstance(comparison_gesture, Gesture):\n            if rotation_invariant:\n                # get orientation\n                angle = self.get_rigid_rotation(comparison_gesture)\n\n                # rotate the gesture to be in the same frame.\n                comparison_gesture = comparison_gesture.rotate(angle)\n\n            # this is the normal \"orientation\" code.\n            score = self.dot_product(comparison_gesture)\n            if score <= 0:\n                return score\n            score /= math.sqrt(\n                self.gesture_product * comparison_gesture.gesture_product)\n            return score",
  "def __eq__(self, comparison_gesture):\n        ''' Allows easy comparisons between gesture instances.'''\n        if isinstance(comparison_gesture, Gesture):\n            # If the gestures don't have the same number of strokes, its\n            # definitely not the same gesture\n            score = self.get_score(comparison_gesture)\n            if (score > (1.0 - self.tolerance) and\n                    score < (1.0 + self.tolerance)):\n                return True\n            else:\n                return False\n        else:\n            return NotImplemented",
  "def __ne__(self, comparison_gesture):\n        result = self.__eq__(comparison_gesture)\n        if result is NotImplemented:\n            return result\n        else:\n            return not result",
  "def __lt__(self, comparison_gesture):\n        raise TypeError(\"Gesture cannot be evaluated with <\")",
  "def __gt__(self, comparison_gesture):\n        raise TypeError(\"Gesture cannot be evaluated with >\")",
  "def __le__(self, comparison_gesture):\n        raise TypeError(\"Gesture cannot be evaluated with <=\")",
  "def __ge__(self, comparison_gesture):\n        raise TypeError(\"Gesture cannot be evaluated with >=\")",
  "def circumcircle(a, b, c):\n    '''\n    Computes the circumcircle of a triangle defined by a, b, c.\n    See: http://en.wikipedia.org/wiki/Circumscribed_circle\n\n    :Parameters:\n        `a`: iterable containing at least 2 values (for x and y)\n            The 1st point of the triangle.\n        `b`: iterable containing at least 2 values (for x and y)\n            The 2nd point of the triangle.\n        `c`: iterable containing at least 2 values (for x and y)\n            The 3rd point of the triangle.\n\n    :Return:\n        A tuple that defines the circle :\n         * The first element in the returned tuple is the center as (x, y)\n         * The second is the radius (float)\n    '''\n    P = Vector(a[0], a[1])\n    Q = Vector(b[0], b[1])\n    R = Vector(c[0], c[1])\n\n    mPQ = (P + Q) * .5\n    mQR = (Q + R) * .5\n\n    numer = -(- mPQ.y * R.y + mPQ.y * Q.y + mQR.y * R.y - mQR.y * Q.y -\n              mPQ.x * R.x + mPQ.x * Q.x + mQR.x * R.x - mQR.x * Q.x)\n    denom = (-Q.x * R.y + P.x * R.y - P.x * Q.y +\n             Q.y * R.x - P.y * R.x + P.y * Q.x)\n\n    t = numer / denom\n\n    cx = -t * (Q.y - P.y) + mPQ.x\n    cy = t * (Q.x - P.x) + mPQ.y\n\n    return ((cx, cy), (P - (cx, cy)).length())",
  "def minimum_bounding_circle(points):\n    '''\n    Returns the minimum bounding circle for a set of points.\n\n    For a description of the problem being solved, see the `Smallest Circle\n    Problem <http://en.wikipedia.org/wiki/Smallest_circle_problem>`_.\n\n    The function uses Applet's Algorithm, the runtime is ``O(h^3, *n)``,\n    where h is the number of points in the convex hull of the set of points.\n    **But** it runs in linear time in almost all real world cases.\n    See: http://tinyurl.com/6e4n5yb\n\n    :Parameters:\n        `points`: iterable\n            A list of points (2 tuple with x,y coordinates)\n\n    :Return:\n        A tuple that defines the circle:\n            * The first element in the returned tuple is the center (x, y)\n            * The second the radius (float)\n\n    '''\n    points = [Vector(p[0], p[1]) for p in points]\n\n    if len(points) == 1:\n        return (points[0].x, points[0].y), 0.0\n\n    if len(points) == 2:\n        p1, p2 = points\n        return (p1 + p2) * .5, ((p1 - p2) * .5).length()\n\n    # determine a point P with the smallest y value\n    P = min(points, key=lambda p: p.y)\n\n    # find a point Q such that the angle of the line segment\n    # PQ with the x axis is minimal\n    def x_axis_angle(q):\n        if q == P:\n            return 1e10  # max val if the same, to skip\n        return abs((q - P).angle((1, 0)))\n    Q = min(points, key=x_axis_angle)\n\n    for p in points:\n        # find R such that angle PRQ is minimal\n        def angle_pq(r):\n            if r in (P, Q):\n                return 1e10  # max val if the same, to skip\n            return abs((r - P).angle(r - Q))\n        R = min(points, key=angle_pq)\n\n        # check for case 1 (angle PRQ is obtuse), the circle is determined\n        # by two points, P and Q. radius = |(P-Q)/2|, center = (P+Q)/2\n        if angle_pq(R) > 90.0:\n            return (P + Q) * .5, ((P - Q) * .5).length()\n\n        # if angle RPQ is obtuse, make P = R, and try again\n        if abs((R - P).angle(Q - P)) > 90:\n            P = R\n            continue\n\n        # if angle PQR is obtuse, make Q = R, and try again\n        if abs((P - Q).angle(R - Q)) > 90:\n            Q = R\n            continue\n\n        # all angles were acute..we just need the circle through the\n        # two points furthest apart!\n        break\n\n    # find the circumcenter for triangle given by P,Q,R\n    return circumcircle(P, Q, R)",
  "def x_axis_angle(q):\n        if q == P:\n            return 1e10  # max val if the same, to skip\n        return abs((q - P).angle((1, 0)))",
  "def angle_pq(r):\n            if r in (P, Q):\n                return 1e10  # max val if the same, to skip\n            return abs((r - P).angle(r - Q))",
  "class WeakMethod:\n    '''Implementation of a\n    `weakref <http://en.wikipedia.org/wiki/Weak_reference>`_\n    for functions and bound methods.\n    '''\n    def __init__(self, method):\n        self.method = None\n        self.method_name = None\n        try:\n            if method.__self__ is not None:\n                self.method_name = method.__func__.__name__\n                self.proxy = weakref.proxy(method.__self__)\n            else:\n                self.method = method\n                self.proxy = None\n        except AttributeError:\n            self.method = method\n            self.proxy = None\n\n    def __call__(self):\n        '''Return a new bound-method like the original, or the\n        original function if it was just a function or unbound\n        method.\n        Returns None if the original object doesn't exist.\n        '''\n        if self.proxy is not None:\n            try:\n                return getattr(self.proxy, self.method_name)\n            except ReferenceError:\n                return None\n\n        return self.method\n\n    def is_dead(self):\n        '''Returns True if the referenced callable was a bound method and\n        the instance no longer exists. Otherwise, return False.\n        '''\n        if self.proxy is None:\n            return False\n\n        try:\n            getattr(self.proxy, self.method_name)\n            return False\n        except ReferenceError:\n            return True\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n        s = self()\n        return s is not None and s == other()\n\n    def __repr__(self):\n        return '<WeakMethod proxy={} method={} method_name={}>'.format(\n               self.proxy, self.method, self.method_name)",
  "def __init__(self, method):\n        self.method = None\n        self.method_name = None\n        try:\n            if method.__self__ is not None:\n                self.method_name = method.__func__.__name__\n                self.proxy = weakref.proxy(method.__self__)\n            else:\n                self.method = method\n                self.proxy = None\n        except AttributeError:\n            self.method = method\n            self.proxy = None",
  "def __call__(self):\n        '''Return a new bound-method like the original, or the\n        original function if it was just a function or unbound\n        method.\n        Returns None if the original object doesn't exist.\n        '''\n        if self.proxy is not None:\n            try:\n                return getattr(self.proxy, self.method_name)\n            except ReferenceError:\n                return None\n\n        return self.method",
  "def is_dead(self):\n        '''Returns True if the referenced callable was a bound method and\n        the instance no longer exists. Otherwise, return False.\n        '''\n        if self.proxy is None:\n            return False\n\n        try:\n            getattr(self.proxy, self.method_name)\n            return False\n        except ReferenceError:\n            return True",
  "def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n        s = self()\n        return s is not None and s == other()",
  "def __repr__(self):\n        return '<WeakMethod proxy={} method={} method_name={}>'.format(\n               self.proxy, self.method, self.method_name)",
  "class MultistrokeError(Exception):\n    pass",
  "class Recognizer(EventDispatcher):\n    ''':class:`Recognizer` provides a gesture database with matching\n    facilities.\n\n    :Events:\n        `on_search_start`\n            Fired when a new search is started using this Recognizer.\n\n        `on_search_complete`\n            Fired when a running search ends, for whatever reason.\n            (use :data:`ProgressTracker.status` to find out)\n\n    :Properties:\n        `db`\n            A :class:`ListProperty` that contains the available\n            :class:`MultistrokeGesture` objects.\n\n            :attr:`db` is a\n            :class:`~kivy.properties.ListProperty` and defaults to []\n    '''\n\n    db = ListProperty([])\n\n    def __init__(self, **kwargs):\n        super(Recognizer, self).__init__(**kwargs)\n        self.register_event_type('on_search_start')\n        self.register_event_type('on_search_complete')\n\n    def filter(self, **kwargs):\n        ''':meth:`filter` returns a subset of objects in :attr:`self.db`,\n        according to given criteria. This is used by many other methods of\n        the :class:`Recognizer`; the arguments below can for example be\n        used when calling :meth:`Recognizer.recognize` or\n        :meth:`Recognizer.export_gesture`. You normally don't need to call\n        this directly.\n\n        :Arguments:\n\n            `name`\n                Limits the returned list to gestures where\n                :attr:`MultistrokeGesture.name` matches given regular\n                expression(s). If re.match(name, MultistrokeGesture.name)\n                tests true, the gesture is included in the returned list.\n                Can be a string or an array of strings ::\n\n                    gdb = Recognizer()\n\n                    # Will match all names that start with a capital N\n                    # (ie Next, New, N, Nebraska etc, but not \"n\" or \"next\")\n                    gdb.filter(name='N')\n\n                    # exactly 'N'\n                    gdb.filter(name='N$')\n\n                    # Nebraska, teletubbies, France, fraggle, N, n, etc\n                    gdb.filter(name=['[Nn]', '(?i)T', '(?i)F'])\n\n            `priority`\n                Limits the returned list to gestures with certain\n                :attr:`MultistrokeGesture.priority` values. If specified as an\n                integer, only gestures with a lower priority are returned. If\n                specified as a list (min/max) ::\n\n                    # Max priority 50\n                    gdb.filter(priority=50)\n\n                    # Max priority 50 (same result as above)\n                    gdb.filter(priority=[0, 50])\n\n                    # Min priority 50, max 100\n                    gdb.filter(priority=[50, 100])\n\n                When this option is used, :attr:`Recognizer.db` is\n                automatically sorted according to priority, incurring extra\n                cost. You can use `force_priority_sort` to override this\n                behavior if your gestures are already sorted according to\n                priority.\n\n            `orientation_sensitive`\n                Limits the returned list to gestures that are\n                orientation sensitive (True), gestures that are not orientation\n                sensitive (False) or None (ignore template sensitivity, this is\n                the default).\n\n            `numstrokes`\n                Limits the returned list to gestures that have the specified\n                number of strokes (in :attr:`MultistrokeGesture.strokes`).\n                Can be a single integer or a list of integers.\n\n            `numpoints`\n                Limits the returned list to gestures that have specific\n                :attr:`MultistrokeGesture.numpoints` values. This is provided\n                for flexibility, do not use it unless you understand what it\n                does. Can be a single integer or a list of integers.\n\n            `force_priority_sort`\n                Can be used to override the default sort behavior. Normally\n                :class:`MultistrokeGesture` objects are returned in priority\n                order if the `priority` option is used. Setting this to True\n                will return gestures sorted in priority order, False will\n                return in the order gestures were added. None means decide\n                automatically (the default).\n\n                .. Note ::\n                    For improved performance, you can load your gesture\n                    database in priority order and set this to False when\n                    calling :meth:`Recognizer.recognize`\n\n            `db`\n                Can be set if you want to filter a different list of objects\n                than :attr:`Recognizer.db`. You probably don't want to do this;\n                it is used internally by :meth:`import_gesture`.\n        '''\n        have_filters = False\n\n        kwargs_get = kwargs.get\n\n        name = kwargs_get('name', None)\n        if name is not None:\n            have_filters = True\n            if not isinstance(name, list):\n                name = [name]\n\n        priority = kwargs_get('priority', None)\n        min_p, max_p = None, None\n        if priority is not None:\n            have_filters = True\n            if isinstance(priority, list):\n                min_p, max_p = priority\n            elif isinstance(priority, int):\n                min_p, max_p = None, priority\n\n        numstrokes = kwargs_get('numstrokes', None)\n        if numstrokes is not None:\n            have_filters = True\n            if not isinstance(numstrokes, list):\n                numstrokes = [numstrokes]\n\n        numpoints = kwargs_get('numpoints', None)\n        if numpoints is not None:\n            have_filters = True\n            if not isinstance(numpoints, list):\n                numpoints = [numpoints]\n\n        orientation_sens = kwargs_get('orientation_sensitive', None)\n        if orientation_sens is not None:\n            have_filters = True\n\n        # Prepare a correctly sorted tasklist\n        force_priority_sort = kwargs.get('force_priority_sort', None)\n        force_sort_on = force_priority_sort and True\n        force_sort_off = (force_priority_sort is False) and True\n\n        db = kwargs.get('db', None) or self.db\n        if (force_sort_on or priority) and not force_sort_off:\n            tasklist = sorted(db, key=lambda n: n.priority)\n        else:\n            tasklist = db\n\n        # Now test each gesture in the database against filter criteria\n        out = deque()\n        if not have_filters:\n            out.extend(tasklist)\n            return out\n\n        out_append = out.append\n        for gesture in tasklist:\n\n            if (orientation_sens is not None and\n                    orientation_sens != gesture.orientation_sens):\n                continue\n\n            if numpoints and gesture.numpoints not in numpoints:\n                continue\n\n            if numstrokes and len(gesture.strokes) not in numstrokes:\n                continue\n\n            if min_p is not None and gesture.priority < min_p:\n                continue\n\n            if max_p is not None and gesture.priority > max_p:\n                return out\n\n            if name:\n                for f in name:\n                    if re_match(f, gesture.name):\n                        out_append(gesture)\n                        break\n            else:\n                out_append(gesture)\n\n        return out\n\n    def add_gesture(self, name, strokes, **kwargs):\n        '''Add a new gesture to the database. This will instantiate a new\n        :class:`MultistrokeGesture` with `strokes` and append it to self.db.\n\n        .. Note ::\n            If you already have instantiated a :class:`MultistrokeGesture`\n            object and wish to add it, append it to :attr:`Recognizer.db`\n            manually.\n        '''\n        if not strokes:\n            return False\n        self.db.append(\n            MultistrokeGesture(name=name, strokes=strokes, **kwargs)\n        )\n        return True\n\n    def parse_gesture(self, data):\n        '''Parse data formatted by export_gesture(). Returns a list of\n        :class:`MultistrokeGesture` objects. This is used internally by\n        :meth:`import_gesture`, you normally don't need to call this\n        directly.'''\n        io = BytesIO(zlib.decompress(base64.b64decode(data)))\n\n        p = pickle.Unpickler(io)\n        multistrokes = []\n        ms_append = multistrokes.append\n        for multistroke in p.load():\n            strokes = multistroke['strokes']\n            multistroke['strokes'] = [[Vector(\n                x, y) for x, y in line] for line in strokes]\n            ms_append(MultistrokeGesture(**multistroke))\n        return multistrokes\n\n    # FIXME: use a try block, maybe shelve or something\n    def export_gesture(self, filename=None, **kwargs):\n        '''Export a list of :class:`MultistrokeGesture` objects. Outputs a\n        base64-encoded string that can be decoded to a Python list with\n        the :meth:`parse_gesture` function or imported directly to\n        :attr:`self.db` using :meth:`Recognizer.import_gesture`. If\n        `filename` is specified, the output is written to disk, otherwise\n        returned.\n\n        This method accepts optional :meth:`Recognizer.filter` arguments.\n        '''\n        io = BytesIO()\n        p = pickle.Pickler(io, protocol=0)\n        multistrokes = []\n        defaults = {'priority': 100, 'numpoints': 16, 'stroke_sens': True,\n                    'orientation_sens': False, 'angle_similarity': 30.0}\n        dkeys = defaults.keys()\n\n        for multistroke in self.filter(**kwargs):\n            m = dict(defaults)\n            m = {'name': multistroke.name}\n            for attr in dkeys:\n                m[attr] = getattr(multistroke, attr)\n            m['strokes'] = tuple([(p.x, p.y) for p in line]\n                                 for line in multistroke.strokes)\n            multistrokes.append(m)\n        p.dump(multistrokes)\n\n        if filename:\n            f = open(filename, 'wb')\n            f.write(base64.b64encode(zlib.compress(io.getvalue(), 9)))\n            f.close()\n        else:\n            return base64.b64encode(zlib.compress(io.getvalue(), 9))\n\n    # FIXME: match them all with protractor, and don't load exacts? or\n    # just compare the data or something; seems better to do this on import\n    # than on every subsequent call to recognize(). And fix it in general,\n    # too.\n    def import_gesture(self, data=None, filename=None, **kwargs):\n        '''Import a list of gestures as formatted by :meth:`export_gesture`.\n        One of `data` or `filename` must be specified.\n\n        This method accepts optional :meth:`Recognizer.filter` arguments,\n        if none are specified then all gestures in specified data are\n        imported.'''\n        if filename is not None:\n            with open(filename, \"rb\") as infile:\n                data = infile.read()\n        elif data is None:\n            raise MultistrokeError('import_gesture needs data= or filename=')\n\n        new = self.filter(db=self.parse_gesture(data), **kwargs)\n        if new:\n            self.db.extend(new)\n\n    def transfer_gesture(self, tgt, **kwargs):\n        '''Transfers :class:`MultistrokeGesture` objects from\n        :attr:`Recognizer.db` to another :class:`Recognizer` instance `tgt`.\n\n        This method accepts optional :meth:`Recognizer.filter` arguments.\n        '''\n        if hasattr(tgt, 'db') and isinstance(tgt.db, list):\n            send = self.filter(**kwargs)\n            if send:\n                tgt.db.append(None)\n                tgt.db[-1:] = send\n                return True\n\n    def prepare_templates(self, **kwargs):\n        '''This method is used to prepare :class:`UnistrokeTemplate` objects\n        within the gestures in self.db. This is useful if you want to minimize\n        punishment of lazy resampling by preparing all vectors in advance. If\n        you do this before a call to :meth:`Recognizer.export_gesture`, you\n        will have the vectors computed when you load the data later.\n\n        This method accepts optional :meth:`Recognizer.filter` arguments.\n\n        `force_numpoints`, if specified, will prepare all templates to the\n        given number of points (instead of each template's preferred n; ie\n        :data:`UnistrokeTemplate.numpoints`). You normally don't want to\n        do this.'''\n        for gesture in self.filter(**kwargs):\n            for tpl in gesture:\n                n = kwargs.get('force_numpoints', tpl.numpoints)\n                tpl.prepare(n)\n\n    def recognize(self, strokes, goodscore=None, timeout=0, delay=0, **kwargs):\n        '''Search for gestures matching `strokes`. Returns a\n        :class:`ProgressTracker` instance.\n\n        This method accepts optional :meth:`Recognizer.filter` arguments.\n\n        :Arguments:\n\n            `strokes`\n                A list of stroke paths (list of lists of\n                :class:`~kivy.vector.Vector` objects) that will be matched\n                against gestures in the database. Can also be a\n                :class:`Candidate` instance.\n\n                .. Warning ::\n\n                    If you manually supply a :class:`Candidate` that has a\n                    skip-flag, make sure that the correct filter arguments\n                    are set. Otherwise the system will attempt to load vectors\n                    that have not been computed. For example, if you set\n                    `skip_bounded` and do not set `orientation_sensitive` to\n                    False, it will raise an exception if an\n                    orientation_sensitive :class:`UnistrokeTemplate`\n                    is encountered.\n\n            `goodscore`\n                If this is set (between 0.0 - 1.0) and a gesture score is\n                equal to or higher than the specified value, the search is\n                immediately halted and the on_search_complete event is\n                fired (+ the on_complete event of the associated\n                :class:`ProgressTracker` instance). Default is None (disabled).\n\n            `timeout`\n                Specifies a timeout (in seconds) for when the search is\n                aborted and the results returned. This option applies only\n                when `max_gpf` is not 0. Default value is 0, meaning all\n                gestures in the database will be tested, no matter how long\n                it takes.\n\n            `max_gpf`\n                Specifies the maximum number of :class:`MultistrokeGesture`\n                objects that can be processed per frame. When exceeded, will\n                cause the search to halt and resume work in the next frame.\n                Setting to 0 will complete the search immediately (and block\n                the UI).\n\n                .. Warning ::\n\n                    This does not limit the number of\n                    :class:`UnistrokeTemplate` objects matched! If a single\n                    gesture has a million templates, they will all be\n                    processed in a single frame with max_gpf=1!\n\n            `delay`\n                Sets an optional delay between each run of the recognizer\n                loop. Normally, a run is scheduled for the next frame until\n                the tasklist is exhausted. If you set this, there will be an\n                additional delay between each run (specified in seconds).\n                Default is 0, resume in the next frame.\n\n            `force_numpoints`\n                forces all templates (and candidate) to be prepared to a\n                certain number of points. This can be useful for example if\n                you are evaluating templates for optimal n (do not use this\n                unless you understand what it does).\n        '''\n        GPF = kwargs.get('max_gpf', DEFAULT_GPF)\n\n        # Obtain a list of MultistrokeGesture objects matching filter arguments\n        tasklist = self.filter(**kwargs)\n\n        # Initialize the candidate and result objects\n        cand = self._candidate(strokes)\n        result = ProgressTracker(cand, len(tasklist))\n\n        # This is done to inform caller if they bind to on_complete and there\n        # is nothing to do; perhaps should just return None?\n        if not tasklist:\n            result.status = 'complete'\n            self.dispatch('on_search_complete', result)\n\n            def result_hack(dt):\n                result.dispatch('on_complete')\n            Clock.schedule_once(result_hack)\n            return result\n\n        # This callback is scheduled once per frame until completed\n        def _recognize_tick(dt):\n            start_gc = result._completed\n            stop_now = False\n\n            while not stop_now and (tasklist and not result._break_flag) and \\\n                    (not GPF or (result._completed - start_gc < GPF)):\n\n                if (timeout and\n                        Clock.get_time() - result._start_time >= timeout):\n                    result.status = 'timeout'\n                    stop_now = True\n                    break\n\n                # Get the best distance and number of matching operations done\n                gesture = tasklist.popleft()\n                tpl, d, res, mos = gesture.match_candidate(\n                    cand, **kwargs)\n\n                if tpl is not None:\n                    score = result._add_result(gesture, d, tpl, res)\n                    if goodscore is not None and score >= goodscore:\n                        result.status = 'goodscore'\n                        stop_now = True\n\n                result._match_ops += mos\n                result._completed += 1\n                result.dispatch('on_progress')\n\n            # The loop has ended. Prepare to dispatch 'complete'\n            def _dispatch():\n                result.dispatch('on_complete')\n                self.dispatch('on_search_complete', result)\n                return False\n\n            # Dispatch or reschedule another run\n            if not tasklist:\n                result.status = 'complete'\n                return _dispatch()\n            elif result._break_flag:\n                result.status = 'stop'\n                return _dispatch()\n            elif stop_now:\n                return _dispatch()\n            else:\n                Clock.schedule_once(_recognize_tick, delay)\n                return True\n        # End _recognize_tick()\n\n        self.dispatch('on_search_start', result)\n        if not GPF:\n            _recognize_tick(0)\n        else:\n            Clock.schedule_once(_recognize_tick, 0)\n\n        return result\n\n    def _candidate(self, strokes, **kwargs):\n        # recognize() helper function, do not use directly. Set up a\n        # Candidate object from arguments. Either use a specified object\n        # or make a new one from strokes and apply safe skip_* settings to\n        # use less resources.\n        if isinstance(strokes, Candidate):\n            return strokes\n\n        if (not isinstance(strokes, list) or not len(strokes) or not\n                isinstance(strokes[0], list)):\n            raise MultistrokeError('recognize() needs strokes= '\n                                   'list or Candidate')\n\n        cand = Candidate(strokes)\n        o_filter = kwargs.get('orientation_sensitive', None)\n        if o_filter is False:\n            cand.skip_bounded = True\n        elif o_filter is True:\n            cand.skip_invariant = True\n\n        return cand\n\n    # Default event handlers\n    def on_search_start(self, result):\n        pass\n\n    def on_search_complete(self, result):\n        pass",
  "class ProgressTracker(EventDispatcher):\n    '''Represents an ongoing (or completed) search operation. Instantiated and\n    returned by the :meth:`Recognizer.recognize` method when it is called. The\n    `results` attribute is a dictionary that is  updated as the recognition\n    operation progresses.\n\n    .. Note ::\n        You do not need to instantiate this class.\n\n    :Arguments:\n        `candidate`\n            :class:`Candidate` object to be evaluated\n        `tasks`\n            Total number of gestures in tasklist (to test against)\n\n    :Events:\n        `on_progress`\n            Fired for every gesture that is processed\n        `on_result`\n            Fired when a new result is added, and it is the first match\n            for the `name` so far, or a consecutive match with better score.\n        `on_complete`\n            Fired when the search is completed, for whatever reason.\n            (use `ProgressTracker.status` to find out)\n\n    :Attributes:\n        `results`\n            A dictionary of all results (so far). The key is the name of the\n            gesture (ie :attr:`UnistrokeTemplate.name` usually inherited from\n            :class:`MultistrokeGesture`). Each item in the dictionary is a\n            dict with the following entries:\n\n                `name`\n                    Name of the matched template (redundant)\n                `score`\n                    Computed score from 1.0 (perfect match) to 0.0\n                `dist`\n                    Cosine distance from candidate to template (low=closer)\n                `gesture`\n                    The :class:`MultistrokeGesture` object that was matched\n                `best_template`\n                    Index of the best matching template (in\n                    :attr:`MultistrokeGesture.templates`)\n                `template_results`\n                    List of distances for all templates. The list index\n                    corresponds to a :class:`UnistrokeTemplate` index in\n                    gesture.templates.\n\n        `status`\n            `search`\n                Currently working\n            `stop`\n                Was stopped by the user (:meth:`stop` called)\n            `timeout`\n                A timeout occurred (specified as `timeout=` to recognize())\n            `goodscore`\n                The search was stopped early because a gesture with a high\n                enough score was found (specified as `goodscore=` to\n                recognize())\n            `complete`\n                The search is complete (all gestures matching filters were\n                tested)\n    '''\n    def __init__(self, candidate, tasks, **kwargs):\n        self.status = 'search'\n        self.candidate = candidate\n        self.results = {}\n        self.tasks = tasks\n        self._start_time = Clock.get_time()\n        self._match_ops = 0\n        self._completed = 0\n        self._break_flag = False\n\n        # fired by recognize()\n        self.register_event_type('on_complete')\n        self.register_event_type('on_progress')\n\n        # fired locally\n        self.register_event_type('on_result')\n        super(ProgressTracker, self).__init__(**kwargs)\n\n    @property\n    def progress(self):\n        '''Returns the progress as a float, 0 is 0% done, 1 is 100%. This\n        is a Python property.'''\n        if not self.tasks:\n            return 1\n        return self._completed / float(self.tasks)\n\n    @property\n    def best(self):\n        '''Return the best match found by recognize() so far. It returns a\n        dictionary with three keys, 'name', 'dist' and 'score' representing\n        the template's name, distance (from candidate path) and the\n        computed score value. This is a Python property.'''\n        results = self.results  # to avoid too many self. lookups\n        if not results:\n            return {'name': None, 'dist': None, 'score': 0}\n        b = max(results, key=lambda r: results[r]['score'])\n        return {\n            'name': results[b]['name'],\n            'dist': results[b]['dist'],\n            'score': results[b]['score']\n        }\n\n    def stop(self):\n        '''Raises a stop flag that is checked by the search process. It will\n        be stopped on the next clock tick (if it is still running).'''\n        self._break_flag = True\n\n    def _add_result(self, gesture, dist, tpl, res):\n        # Add a result; used internally by the recognize() function\n        if tpl <= len(res):\n            n = gesture.templates[tpl].name\n        else:\n            return 0.\n\n        if n not in self.results or dist < self.results[n]['dist']:\n            self.results[n] = {\n                'name': n,\n                'dist': dist,\n                'gesture': gesture,\n                'best_template': tpl,\n                'template_results': res\n            }\n\n            if not dist:\n                self.results[n]['score'] = 1.0\n            else:\n                self.results[n]['score'] = 1.0 - (dist / pi)\n\n            self.dispatch('on_result', self.results[n])\n            return self.results[n]['score']\n        else:\n            return 0.\n\n    def on_complete(self):\n        pass\n\n    def on_progress(self):\n        pass\n\n    def on_result(self, result):\n        pass",
  "class MultistrokeGesture(object):\n    ''':class:`MultistrokeGesture` represents a gesture. It maintains a set of\n    `strokes` and generates unistroke (ie :class:`UnistrokeTemplate`)\n    permutations that are used for evaluating candidates against this gesture\n    later.\n\n    :Arguments:\n        `name`\n            Identifies the name of the gesture - it is returned to you in the\n            results of a :meth:`Recognizer.recognize` search. You can have any\n            number of MultistrokeGesture objects with the same name; many\n            definitions of one gesture. The same name is given to all the\n            generated unistroke permutations. Required, no default.\n        `strokes`\n            A list of paths that represents the gesture. A path is a list of\n            Vector objects::\n\n                gesture = MultistrokeGesture('my_gesture', strokes=[\n                  [Vector(x1, y1), Vector(x2, y2), ...... ], # stroke 1\n                  [Vector(), Vector(), Vector(), Vector() ]  # stroke 2\n                  #, [stroke 3], [stroke 4], ...\n                ])\n\n            For template matching purposes, all the strokes are combined to a\n            single list (unistroke). You should still specify the strokes\n            individually, and set `stroke_sensitive` True (whenever possible).\n\n            Once you do this, unistroke permutations are immediately generated\n            and stored in `self.templates` for later, unless you set the\n            `permute` flag to False.\n        `priority`\n            Determines when :func:`Recognizer.recognize` will attempt to match\n            this template, lower priorities are evaluated first (only if\n            a priority `filter` is used). You should use lower priority on\n            gestures that are more likely to match. For example, set user\n            templates at lower number than generic templates. Default is 100.\n        `numpoints`\n            Determines the number of points this gesture should be resampled to\n            (for matching purposes). The default is 16.\n        `stroke_sensitive`\n            Determines if the number of strokes (paths) in this gesture is\n            required to be the same in the candidate (user input) gesture\n            during matching. If this is False, candidates will always be\n            evaluated, disregarding the number of strokes. Default is True.\n        `orientation_sensitive`\n            Determines if this gesture is orientation sensitive. If True,\n            aligns the indicative orientation with the one of eight base\n            orientations that requires least rotation. Default is True.\n        `angle_similarity`\n            This is used by the :func:`Recognizer.recognize` function when a\n            candidate is evaluated against this gesture. If the angles between\n            them are too far off, the template is considered a non-match.\n            Default is 30.0 (degrees)\n        `permute`\n            If False, do not use Heap Permute algorithm to generate different\n            stroke orders when instantiated. If you set this to False, a\n            single UnistrokeTemplate built from `strokes` is used.\n    '''\n    def __init__(self, name, strokes=None, **kwargs):\n        self.name = name\n        self.priority = kwargs.get('priority', 100)\n        self.numpoints = kwargs.get('numpoints', 16)\n        self.stroke_sens = kwargs.get('stroke_sensitive', True)\n        self.orientation_sens = kwargs.get('orientation_sensitive', True)\n        self.angle_similarity = kwargs.get('angle_similarity', 30.0)\n        self.strokes = []\n\n        if strokes is not None:\n            self.strokes = strokes\n            if kwargs.get('permute', True):\n                self.permute()\n            else:\n                self.templates = [UnistrokeTemplate(name,\n                                  points=[i for sub in strokes for i in sub],\n                                  numpoints=self.numpoints,\n                                  orientation_sensitive=self.orientation_sens)]\n\n    def angle_similarity_threshold(self):\n        return radians(self.angle_similarity)\n\n    def add_stroke(self, stroke, permute=False):\n        '''Add a stroke to the self.strokes list. If `permute` is True, the\n        :meth:`permute` method is called to generate new unistroke templates'''\n        self.strokes.append(stroke)\n        if permute:\n            self.permute()\n\n    def get_distance(self, cand, tpl, numpoints=None):\n        '''Compute the distance from this Candidate to a UnistrokeTemplate.\n        Returns the Cosine distance between the stroke paths.\n\n        `numpoints` will prepare both the UnistrokeTemplate and Candidate path\n        to n points (when necessary), you probably don't want to do this.\n        '''\n        n = numpoints\n        if n is None or n < 2:\n            n = self.numpoints\n\n        # optimal_cosine_distance() inlined here for performance\n        v1 = tpl.get_vector(n)\n        v2 = cand.get_protractor_vector(n, tpl.orientation_sens)\n\n        a = 0.0\n        b = 0.0\n\n        for i in xrange(0, len(v1), 2):\n            a += (v1[i] * v2[i]) + (v1[i + 1] * v2[i + 1])\n            b += (v1[i] * v2[i + 1]) - (v1[i + 1] * v2[i])\n\n        angle = atan(b / a)\n\n        # If you put the below directly into math.acos(), you will get a domain\n        # error when a=1.0 and angle=0.0 (ie math_cos(angle)=1.0). It seems to\n        # be because float representation of 1.0*1.0 is >1.0 (ie 1.00000...001)\n        # and this is problematic for math.acos().\n        # If you try math.acos(1.0*1.0) in interpreter it does not happen,\n        # only with exact match at runtime\n        result = a * math_cos(angle) + b * math_sin(angle)\n\n        # FIXME: I'm sure there is a better way to do it but..\n        if result >= 1:\n            result = 1\n        elif result <= -1:  # has not happened to me, but I leave it here.\n            result = -1\n        return acos(result)\n\n    def match_candidate(self, cand, **kwargs):\n        '''Match a given candidate against this MultistrokeGesture object. Will\n        test against all templates and report results as a list of four\n        items:\n\n            `index 0`\n                Best matching template's index (in self.templates)\n            `index 1`\n                Computed distance from the template to the candidate path\n            `index 2`\n                List of distances for all templates. The list index\n                corresponds to a :class:`UnistrokeTemplate` index in\n                self.templates.\n            `index 3`\n                Counter for the number of performed matching operations, ie\n                templates matched against the candidate\n        '''\n        best_d = float('infinity')\n        best_tpl = None\n        mos = 0\n        out = []\n\n        if (self.stroke_sens and len(self.strokes) != len(cand.strokes)):\n            return (best_tpl, best_d, out, mos)\n\n        skip_bounded = cand.skip_bounded\n        skip_invariant = cand.skip_invariant\n        get_distance = self.get_distance\n        ang_sim_threshold = self.angle_similarity_threshold()\n\n        for idx, tpl in enumerate(self.templates):\n            # Handle a theoretical case where a MultistrokeGesture is composed\n            # manually and the orientation_sensitive flag is True, and contains\n            # a UnistrokeTemplate that has orientation_sensitive=False (or vice\n            # versa). This would cause KeyError - requesting nonexistent vector\n            if tpl.orientation_sens:\n                if skip_bounded:\n                    continue\n            elif skip_invariant:\n                continue\n\n            # Count as a match operation now, since the call to get_\n            # angle_similarity below will force vector calculation,\n            # even if it doesn't make it to get_distance\n            mos += 1\n\n            # Note: With this implementation, we always resample the candidate\n            # to *any* encountered UnistrokeTemplate numpoints here, the filter\n            # is only applied to MultistrokeGesture. See theoretical case\n            # above; should not matter normally.\n            n = kwargs.get('force_numpoints', tpl.numpoints)\n\n            # Skip if candidate/gesture angles are too far off\n            ang_sim = cand.get_angle_similarity(tpl, numpoints=n)\n            if ang_sim > ang_sim_threshold:\n                continue\n\n            # Get the distance between cand/tpl paths\n            d = get_distance(cand, tpl, numpoints=n)\n            out.append(d)\n\n            if d < best_d:\n                best_d = d\n                best_tpl = idx\n\n        return (best_tpl, best_d, out, mos)\n\n    def permute(self):\n        '''Generate all possible unistroke permutations from self.strokes and\n        save the resulting list of UnistrokeTemplate objects in self.templates.\n\n        Quote from http://faculty.washington.edu/wobbrock/pubs/gi-10.2.pdf ::\n\n            We use Heap Permute [16] (p. 179) to generate all stroke orders\n            in a multistroke gesture. Then, to generate stroke directions for\n            each order, we treat each component stroke as a dichotomous\n            [0,1] variable. There are 2^N combinations for N strokes, so we\n            convert the decimal values 0 to 2^N-1, inclusive, to binary\n            representations and regard each bit as indicating forward (0) or\n            reverse (1). This algorithm is often used to generate truth tables\n            in propositional logic.\n\n        See section 4.1: \"$N Algorithm\" of the linked paper for details.\n\n        .. Warning ::\n\n            Using heap permute for gestures with more than 3 strokes\n            can result in very large number of templates (a 9-stroke\n            gesture = 38 million templates). If you are dealing with\n            these types of gestures, you should manually compose\n            all the desired stroke orders.\n        '''\n        # Seed with index of each stroke\n        self._order = [i for i in xrange(0, len(self.strokes))]\n\n        # Prepare ._orders\n        self._orders = []\n        self._heap_permute(len(self.strokes))\n        del self._order\n\n        # Generate unistroke permutations\n        self.templates = [UnistrokeTemplate(\n            self.name,\n            points=permutation,\n            numpoints=self.numpoints,\n            orientation_sensitive=self.orientation_sens\n        ) for permutation in self._make_unistrokes()]\n        del self._orders\n\n    def _heap_permute(self, n):\n        # Heap Permute algorithm\n        self_order = self._order\n        if n == 1:\n            self._orders.append(self_order[:])\n        else:\n            i = 0\n            for i in xrange(0, n):\n                self._heap_permute(n - 1)\n                if n % 2 == 1:\n                    tmp = self_order[0]\n                    self_order[0] = self_order[n - 1]\n                    self_order[n - 1] = tmp\n                else:\n                    tmp = self_order[i]\n                    self_order[i] = self_order[n - 1]\n                    self_order[n - 1] = tmp\n\n    def _make_unistrokes(self):\n        # Create unistroke permutations from self.strokes\n        unistrokes = []\n        unistrokes_append = unistrokes.append\n        self_strokes = self.strokes\n        for r in self._orders:\n            b = 0\n            while b < pow(2, len(r)):  # use b's bits for directions\n                unistroke = []\n                unistroke_append = unistroke.append\n                for i in xrange(0, len(r)):\n                    pts = self_strokes[r[i]][:]\n                    if (b >> i) & 1 == 1:  # is b's bit at index i 1?\n                        pts.reverse()\n                    unistroke_append(None)\n                    unistroke[-1:] = pts\n\n                unistrokes_append(unistroke)\n                b += 1\n        return unistrokes",
  "class UnistrokeTemplate(object):\n    '''Represents a (uni)stroke path as a list of Vectors. Normally, this class\n    is instantiated by MultistrokeGesture and not by the programmer directly.\n    However, it is possible to manually compose UnistrokeTemplate objects.\n\n    :Arguments:\n        `name`\n            Identifies the name of the gesture. This is normally inherited from\n            the parent MultistrokeGesture object when a template is generated.\n        `points`\n            A list of points that represents a unistroke path. This is normally\n            one of the possible stroke order permutations from a\n            MultistrokeGesture.\n        `numpoints`\n            The number of points this template should (ideally) be resampled to\n            before the matching process. The default is 16, but you can use a\n            template-specific settings if that improves results.\n        `orientation_sensitive`\n            Determines if this template is orientation sensitive (True) or\n            fully rotation invariant (False). The default is True.\n\n    .. Note::\n        You will get an exception if you set a skip-flag and then attempt to\n        retrieve those vectors.\n    '''\n    def __init__(self, name, points=None, **kwargs):\n        self.name = name\n        self.numpoints = kwargs.get('numpoints', 16)\n        self.orientation_sens = kwargs.get('orientation_sensitive', True)\n\n        self.db = {}\n        self.points = []\n\n        if points is not None:\n            self.points = points\n\n    def add_point(self, p):\n        '''Add a point to the unistroke/path. This invalidates all previously\n        computed vectors.'''\n        self.points.append(p)\n        # All previously computed data is now void.\n        self.db = {}\n\n    # Used to lazily prepare the template\n    def _get_db_key(self, key, numpoints=None):\n        n = numpoints and numpoints or self.numpoints\n        if n not in self.db:\n            self.prepare(n)\n        return self.db[n][key]\n\n    def get_start_unit_vector(self, numpoints=None):\n        return self._get_db_key('startvector', numpoints)\n\n    def get_vector(self, numpoints=None):\n        return self._get_db_key('vector', numpoints)\n\n    def get_points(self, numpoints=None):\n        return self._get_db_key('points', numpoints)\n\n    def prepare(self, numpoints=None):\n        '''This function prepares the UnistrokeTemplate for matching given a\n        target number of points (for resample). 16 is optimal.'''\n\n        if not self.points:\n            raise MultistrokeError('prepare() called without self.points')\n\n        # How many points are we resampling to?\n        n = numpoints or self.numpoints\n        if not n or n < 2:\n            raise MultistrokeError('prepare() called with invalid numpoints')\n\n        p = resample(self.points, n)\n        radians = indicative_angle(p)\n        p = rotate_by(p, -radians)\n        p = scale_dim(p, SQUARESIZE, ONEDTHRESHOLD)\n\n        if self.orientation_sens:\n            p = rotate_by(p, +radians)  # restore\n\n        p = translate_to(p, ORIGIN)\n\n        # Now store it using the number of points in the resampled path as the\n        # dict key. On the next call to get_*, it will be returned instead of\n        # recomputed. Implicitly, you must reset self.db or call prepare() for\n        # all the keys once you manipulate self.points.\n        self.db[n] = {\n            # Compute STARTANGLEINDEX as n/8:\n            'startvector': start_unit_vector(p, (n / 8)),\n            'vector': vectorize(p, self.orientation_sens)\n        }",
  "class Candidate(object):\n    '''Represents a set of unistroke paths of user input, ie data to be matched\n    against a :class:`UnistrokeTemplate` object using the Protractor algorithm.\n    By default, data is precomputed to match both rotation bounded and fully\n    invariant :class:`UnistrokeTemplate` objects.\n\n    :Arguments:\n        `strokes`\n            See :data:`MultistrokeGesture.strokes` for format example. The\n            Candidate strokes are simply combined to a unistroke in the order\n            given. The idea is that this will match one of the unistroke\n            permutations in `MultistrokeGesture.templates`.\n        `numpoints`\n            The Candidate's default N; this is only for a fallback, it is not\n            normally used since n is driven by the UnistrokeTemplate we are\n            being compared to.\n        `skip_bounded`\n            If True, do not generate/store rotation bounded vectors\n        `skip_invariant`\n            If True, do not generate/store rotation invariant vectors\n\n    Note that you WILL get errors if you set a skip-flag and then attempt to\n    retrieve the data.'''\n    def __init__(self, strokes=None, numpoints=16, **kwargs):\n        self.skip_invariant = kwargs.get('skip_invariant', False)\n        self.skip_bounded = kwargs.get('skip_bounded', False)\n\n        self.numpoints = numpoints\n        self.db = {}\n        self.strokes = []\n\n        if strokes is not None:\n            self.strokes = strokes\n\n    def add_stroke(self, stroke):\n        '''Add a stroke to the candidate; this will invalidate all\n        previously computed vectors'''\n        self.points.append(stroke)\n        self.db = {}\n\n    # Used to lazily prepare the candidate\n    def _get_db_key(self, key, numpoints, orientation_sens):\n        n = numpoints and numpoints or self.numpoints\n        if n not in self.db:\n            self.prepare(n)\n\n        prefix = orientation_sens and 'bound_' or 'inv_'\n        return self.db[n][prefix + key]\n\n    def get_start_unit_vector(self, numpoints, orientation_sens):\n        '''(Internal use only) Get the start vector for this Candidate,\n        with the path resampled to `numpoints` points. This is the first\n        step in the matching process. It is compared to a\n        UnistrokeTemplate object's start vector to determine angle\n        similarity.'''\n        return self._get_db_key('startvector', numpoints, orientation_sens)\n\n    def get_protractor_vector(self, numpoints, orientation_sens):\n        '''(Internal use only) Return vector for comparing to a\n        UnistrokeTemplate with Protractor'''\n        return self._get_db_key('vector', numpoints, orientation_sens)\n\n    def get_angle_similarity(self, tpl, **kwargs):\n        '''(Internal use only) Compute the angle similarity between this\n        Candidate and a UnistrokeTemplate object. Returns a number that\n        represents the angle similarity (lower is more similar).'''\n        n = kwargs.get('numpoints', self.numpoints)\n\n        # angle_between_unit_vectors() inlined here for performance\n        v1x, v1y = self.get_start_unit_vector(n, tpl.orientation_sens)\n        v2x, v2y = tpl.get_start_unit_vector(n)\n\n        n = (v1x * v2x + v1y * v2y)\n        # FIXME: Domain error on float representation of 1.0 (exact match)\n        # (see comments in MultistrokeGesture.get_distance())\n        if n >= 1:\n            return 0.0\n        if n <= -1:\n            return pi\n        return acos(n)\n\n    def prepare(self, numpoints=None):\n        '''Prepare the Candidate vectors. self.strokes is combined to a single\n        unistroke (connected end-to-end), resampled to :attr:`numpoints`\n        points, and then the vectors are calculated and stored in self.db (for\n        use by `get_distance` and `get_angle_similarity`)'''\n        n = numpoints and numpoints or self.numpoints\n\n        # Inlined combine_strokes() for performance\n        points = [i for sub in self.strokes for i in sub]\n        points = resample(points, n)\n        radians = indicative_angle(points)\n        points = rotate_by(points, -radians)\n        points = scale_dim(points, SQUARESIZE, ONEDTHRESHOLD)\n\n        # Compute STARTANGLEINDEX as n / 8\n        angidx = n / 8\n        cand = {}\n\n        # full rotation invariance\n        if not self.skip_invariant:\n            inv_points = translate_to(points, ORIGIN)\n            cand['inv_startvector'] = start_unit_vector(inv_points, angidx)\n            cand['inv_vector'] = vectorize(inv_points, False)\n\n        # rotation bounded invariance\n        if not self.skip_bounded:\n            bound_points = rotate_by(points, +radians)  # restore\n            bound_points = translate_to(bound_points, ORIGIN)\n            cand['bound_startvector'] = start_unit_vector(bound_points, angidx)\n            cand['bound_vector'] = vectorize(bound_points, True)\n\n        self.db[n] = cand",
  "def resample(points, n):\n    # Resample a path to `n` points\n    if not len(points) or not n or n < 2:\n        raise MultistrokeError('resample() called with invalid arguments')\n\n    interval = path_length(points) / (n - 1)\n    D = 0.0\n    i = 1\n    newpoints = [points[0]]\n    workpoints = points[:]\n    newpoints_len = 1\n    workpoints_len = len(points)\n\n    new_append = newpoints.append\n    work_insert = workpoints.insert\n    while i < len(workpoints):\n        p1 = workpoints[i - 1]\n        p2 = workpoints[i]\n        d = distance(p1, p2)\n\n        if D + d >= interval:\n            qx = p1[0] + ((interval - D) / d) * (p2[0] - p1[0])\n            qy = p1[1] + ((interval - D) / d) * (p2[1] - p1[1])\n            q = Vector(qx, qy)\n            new_append(q)\n            work_insert(i, q)  # q is the next i\n            newpoints_len += 1\n            workpoints_len += 1\n            D = 0.0\n        else:\n            D += d\n\n        i += 1\n\n    # rounding error; insert the last point\n    if newpoints_len < n:\n        new_append(points[-1])\n\n    return newpoints",
  "def indicative_angle(points):\n    cx, cy = centroid(points)\n    return atan2(cy - points[0][1], cx - points[0][0])",
  "def rotate_by(points, radians):\n    # Rotate points around centroid\n    cx, cy = centroid(points)\n    cos = math_cos(radians)\n    sin = math_sin(radians)\n    newpoints = []\n    newpoints_append = newpoints.append\n\n    for i in xrange(0, len(points)):\n        qx = (points[i][0] - cx) * cos - (points[i][1] - cy) * sin + cx\n        qy = (points[i][0] - cx) * sin + (points[i][1] - cy) * cos + cy\n        newpoints_append(Vector(qx, qy))\n\n    return newpoints",
  "def scale_dim(points, size, oneDratio):\n    bbox_x, bbox_y, bbox_w, bbox_h = bounding_box(points)\n\n    if bbox_h == 0 or bbox_w == 0:\n        raise MultistrokeError(\n            'scale_dim() called with invalid points: h:{}, w:{}'\n            .format(bbox_h, bbox_w))\n\n    # 1D or 2D gesture test\n    uniformly = min(bbox_w / bbox_h, bbox_h / bbox_w) <= oneDratio\n\n    if uniformly:\n        qx_size = size / max(bbox_w, bbox_h)\n        qy_size = size / max(bbox_w, bbox_h)\n    else:\n        qx_size = size / bbox_w\n        qy_size = size / bbox_h\n\n    newpoints = []\n    newpoints_append = newpoints.append\n\n    for p in points:\n        qx = p[0] * qx_size\n        qy = p[1] * qy_size\n        newpoints_append(Vector(qx, qy))\n\n    return newpoints",
  "def translate_to(points, pt):\n    # Translate points around centroid\n    cx, cy = centroid(points)\n    ptx, pty = pt\n    newpoints = []\n    for p in points:\n        qx = p[0] + ptx - cx\n        qy = p[1] + pty - cy\n        newpoints.append(Vector(qx, qy))\n    return newpoints",
  "def vectorize(points, use_bounded_rotation_invariance):\n    # Helper function for the Protractor algorithm\n    cos = 1.0\n    sin = 0.0\n\n    if use_bounded_rotation_invariance:\n        ang = atan2(points[0][1], points[0][0])\n        bo = (pi / 4.) * floor((ang + pi / 8.) / (pi / 4.))\n        cos = math_cos(bo - ang)\n        sin = math_sin(bo - ang)\n\n    sum = 0.0\n    vector = []\n    vector_len = 0\n    vector_append = vector.append\n\n    for px, py in points:\n        newx = px * cos - py * sin\n        newy = py * cos + px * sin\n        vector_append(newx)\n        vector_append(newy)\n        vector_len += 2\n        sum += newx ** 2 + newy ** 2\n\n    magnitude = sqrt(sum)\n    for i in xrange(0, vector_len):\n        vector[i] /= magnitude\n\n    return vector",
  "def centroid(points):\n    x = 0.0\n    y = 0.0\n    points_len = len(points)\n\n    for i in xrange(0, points_len):\n        x += points[i][0]\n        y += points[i][1]\n\n    x /= points_len\n    y /= points_len\n\n    return Vector(x, y)",
  "def bounding_box(points):\n    minx = float('infinity')\n    miny = float('infinity')\n    maxx = float('-infinity')\n    maxy = float('-infinity')\n\n    for px, py in points:\n        if px < minx:\n            minx = px\n        if px > maxx:\n            maxx = px\n        if py < miny:\n            miny = py\n        if py > maxy:\n            maxy = py\n\n    return (minx, miny, maxx - minx + 1, maxy - miny + 1)",
  "def path_length(points):\n    d = 0.0\n    for i in xrange(1, len(points)):\n        d += distance(points[i - 1], points[i])\n    return d",
  "def distance(p1, p2):\n    dx = p2[0] - p1[0]\n    dy = p2[1] - p1[1]\n    return sqrt(dx ** 2 + dy ** 2)",
  "def start_unit_vector(points, index):\n    i = int(index)\n    vx, vy = points[i][0] - points[0][0], points[i][1] - points[0][1]\n    length = sqrt(vx ** 2 + vy ** 2)\n    return Vector(vx / length, vy / length)",
  "def __init__(self, **kwargs):\n        super(Recognizer, self).__init__(**kwargs)\n        self.register_event_type('on_search_start')\n        self.register_event_type('on_search_complete')",
  "def filter(self, **kwargs):\n        ''':meth:`filter` returns a subset of objects in :attr:`self.db`,\n        according to given criteria. This is used by many other methods of\n        the :class:`Recognizer`; the arguments below can for example be\n        used when calling :meth:`Recognizer.recognize` or\n        :meth:`Recognizer.export_gesture`. You normally don't need to call\n        this directly.\n\n        :Arguments:\n\n            `name`\n                Limits the returned list to gestures where\n                :attr:`MultistrokeGesture.name` matches given regular\n                expression(s). If re.match(name, MultistrokeGesture.name)\n                tests true, the gesture is included in the returned list.\n                Can be a string or an array of strings ::\n\n                    gdb = Recognizer()\n\n                    # Will match all names that start with a capital N\n                    # (ie Next, New, N, Nebraska etc, but not \"n\" or \"next\")\n                    gdb.filter(name='N')\n\n                    # exactly 'N'\n                    gdb.filter(name='N$')\n\n                    # Nebraska, teletubbies, France, fraggle, N, n, etc\n                    gdb.filter(name=['[Nn]', '(?i)T', '(?i)F'])\n\n            `priority`\n                Limits the returned list to gestures with certain\n                :attr:`MultistrokeGesture.priority` values. If specified as an\n                integer, only gestures with a lower priority are returned. If\n                specified as a list (min/max) ::\n\n                    # Max priority 50\n                    gdb.filter(priority=50)\n\n                    # Max priority 50 (same result as above)\n                    gdb.filter(priority=[0, 50])\n\n                    # Min priority 50, max 100\n                    gdb.filter(priority=[50, 100])\n\n                When this option is used, :attr:`Recognizer.db` is\n                automatically sorted according to priority, incurring extra\n                cost. You can use `force_priority_sort` to override this\n                behavior if your gestures are already sorted according to\n                priority.\n\n            `orientation_sensitive`\n                Limits the returned list to gestures that are\n                orientation sensitive (True), gestures that are not orientation\n                sensitive (False) or None (ignore template sensitivity, this is\n                the default).\n\n            `numstrokes`\n                Limits the returned list to gestures that have the specified\n                number of strokes (in :attr:`MultistrokeGesture.strokes`).\n                Can be a single integer or a list of integers.\n\n            `numpoints`\n                Limits the returned list to gestures that have specific\n                :attr:`MultistrokeGesture.numpoints` values. This is provided\n                for flexibility, do not use it unless you understand what it\n                does. Can be a single integer or a list of integers.\n\n            `force_priority_sort`\n                Can be used to override the default sort behavior. Normally\n                :class:`MultistrokeGesture` objects are returned in priority\n                order if the `priority` option is used. Setting this to True\n                will return gestures sorted in priority order, False will\n                return in the order gestures were added. None means decide\n                automatically (the default).\n\n                .. Note ::\n                    For improved performance, you can load your gesture\n                    database in priority order and set this to False when\n                    calling :meth:`Recognizer.recognize`\n\n            `db`\n                Can be set if you want to filter a different list of objects\n                than :attr:`Recognizer.db`. You probably don't want to do this;\n                it is used internally by :meth:`import_gesture`.\n        '''\n        have_filters = False\n\n        kwargs_get = kwargs.get\n\n        name = kwargs_get('name', None)\n        if name is not None:\n            have_filters = True\n            if not isinstance(name, list):\n                name = [name]\n\n        priority = kwargs_get('priority', None)\n        min_p, max_p = None, None\n        if priority is not None:\n            have_filters = True\n            if isinstance(priority, list):\n                min_p, max_p = priority\n            elif isinstance(priority, int):\n                min_p, max_p = None, priority\n\n        numstrokes = kwargs_get('numstrokes', None)\n        if numstrokes is not None:\n            have_filters = True\n            if not isinstance(numstrokes, list):\n                numstrokes = [numstrokes]\n\n        numpoints = kwargs_get('numpoints', None)\n        if numpoints is not None:\n            have_filters = True\n            if not isinstance(numpoints, list):\n                numpoints = [numpoints]\n\n        orientation_sens = kwargs_get('orientation_sensitive', None)\n        if orientation_sens is not None:\n            have_filters = True\n\n        # Prepare a correctly sorted tasklist\n        force_priority_sort = kwargs.get('force_priority_sort', None)\n        force_sort_on = force_priority_sort and True\n        force_sort_off = (force_priority_sort is False) and True\n\n        db = kwargs.get('db', None) or self.db\n        if (force_sort_on or priority) and not force_sort_off:\n            tasklist = sorted(db, key=lambda n: n.priority)\n        else:\n            tasklist = db\n\n        # Now test each gesture in the database against filter criteria\n        out = deque()\n        if not have_filters:\n            out.extend(tasklist)\n            return out\n\n        out_append = out.append\n        for gesture in tasklist:\n\n            if (orientation_sens is not None and\n                    orientation_sens != gesture.orientation_sens):\n                continue\n\n            if numpoints and gesture.numpoints not in numpoints:\n                continue\n\n            if numstrokes and len(gesture.strokes) not in numstrokes:\n                continue\n\n            if min_p is not None and gesture.priority < min_p:\n                continue\n\n            if max_p is not None and gesture.priority > max_p:\n                return out\n\n            if name:\n                for f in name:\n                    if re_match(f, gesture.name):\n                        out_append(gesture)\n                        break\n            else:\n                out_append(gesture)\n\n        return out",
  "def add_gesture(self, name, strokes, **kwargs):\n        '''Add a new gesture to the database. This will instantiate a new\n        :class:`MultistrokeGesture` with `strokes` and append it to self.db.\n\n        .. Note ::\n            If you already have instantiated a :class:`MultistrokeGesture`\n            object and wish to add it, append it to :attr:`Recognizer.db`\n            manually.\n        '''\n        if not strokes:\n            return False\n        self.db.append(\n            MultistrokeGesture(name=name, strokes=strokes, **kwargs)\n        )\n        return True",
  "def parse_gesture(self, data):\n        '''Parse data formatted by export_gesture(). Returns a list of\n        :class:`MultistrokeGesture` objects. This is used internally by\n        :meth:`import_gesture`, you normally don't need to call this\n        directly.'''\n        io = BytesIO(zlib.decompress(base64.b64decode(data)))\n\n        p = pickle.Unpickler(io)\n        multistrokes = []\n        ms_append = multistrokes.append\n        for multistroke in p.load():\n            strokes = multistroke['strokes']\n            multistroke['strokes'] = [[Vector(\n                x, y) for x, y in line] for line in strokes]\n            ms_append(MultistrokeGesture(**multistroke))\n        return multistrokes",
  "def export_gesture(self, filename=None, **kwargs):\n        '''Export a list of :class:`MultistrokeGesture` objects. Outputs a\n        base64-encoded string that can be decoded to a Python list with\n        the :meth:`parse_gesture` function or imported directly to\n        :attr:`self.db` using :meth:`Recognizer.import_gesture`. If\n        `filename` is specified, the output is written to disk, otherwise\n        returned.\n\n        This method accepts optional :meth:`Recognizer.filter` arguments.\n        '''\n        io = BytesIO()\n        p = pickle.Pickler(io, protocol=0)\n        multistrokes = []\n        defaults = {'priority': 100, 'numpoints': 16, 'stroke_sens': True,\n                    'orientation_sens': False, 'angle_similarity': 30.0}\n        dkeys = defaults.keys()\n\n        for multistroke in self.filter(**kwargs):\n            m = dict(defaults)\n            m = {'name': multistroke.name}\n            for attr in dkeys:\n                m[attr] = getattr(multistroke, attr)\n            m['strokes'] = tuple([(p.x, p.y) for p in line]\n                                 for line in multistroke.strokes)\n            multistrokes.append(m)\n        p.dump(multistrokes)\n\n        if filename:\n            f = open(filename, 'wb')\n            f.write(base64.b64encode(zlib.compress(io.getvalue(), 9)))\n            f.close()\n        else:\n            return base64.b64encode(zlib.compress(io.getvalue(), 9))",
  "def import_gesture(self, data=None, filename=None, **kwargs):\n        '''Import a list of gestures as formatted by :meth:`export_gesture`.\n        One of `data` or `filename` must be specified.\n\n        This method accepts optional :meth:`Recognizer.filter` arguments,\n        if none are specified then all gestures in specified data are\n        imported.'''\n        if filename is not None:\n            with open(filename, \"rb\") as infile:\n                data = infile.read()\n        elif data is None:\n            raise MultistrokeError('import_gesture needs data= or filename=')\n\n        new = self.filter(db=self.parse_gesture(data), **kwargs)\n        if new:\n            self.db.extend(new)",
  "def transfer_gesture(self, tgt, **kwargs):\n        '''Transfers :class:`MultistrokeGesture` objects from\n        :attr:`Recognizer.db` to another :class:`Recognizer` instance `tgt`.\n\n        This method accepts optional :meth:`Recognizer.filter` arguments.\n        '''\n        if hasattr(tgt, 'db') and isinstance(tgt.db, list):\n            send = self.filter(**kwargs)\n            if send:\n                tgt.db.append(None)\n                tgt.db[-1:] = send\n                return True",
  "def prepare_templates(self, **kwargs):\n        '''This method is used to prepare :class:`UnistrokeTemplate` objects\n        within the gestures in self.db. This is useful if you want to minimize\n        punishment of lazy resampling by preparing all vectors in advance. If\n        you do this before a call to :meth:`Recognizer.export_gesture`, you\n        will have the vectors computed when you load the data later.\n\n        This method accepts optional :meth:`Recognizer.filter` arguments.\n\n        `force_numpoints`, if specified, will prepare all templates to the\n        given number of points (instead of each template's preferred n; ie\n        :data:`UnistrokeTemplate.numpoints`). You normally don't want to\n        do this.'''\n        for gesture in self.filter(**kwargs):\n            for tpl in gesture:\n                n = kwargs.get('force_numpoints', tpl.numpoints)\n                tpl.prepare(n)",
  "def recognize(self, strokes, goodscore=None, timeout=0, delay=0, **kwargs):\n        '''Search for gestures matching `strokes`. Returns a\n        :class:`ProgressTracker` instance.\n\n        This method accepts optional :meth:`Recognizer.filter` arguments.\n\n        :Arguments:\n\n            `strokes`\n                A list of stroke paths (list of lists of\n                :class:`~kivy.vector.Vector` objects) that will be matched\n                against gestures in the database. Can also be a\n                :class:`Candidate` instance.\n\n                .. Warning ::\n\n                    If you manually supply a :class:`Candidate` that has a\n                    skip-flag, make sure that the correct filter arguments\n                    are set. Otherwise the system will attempt to load vectors\n                    that have not been computed. For example, if you set\n                    `skip_bounded` and do not set `orientation_sensitive` to\n                    False, it will raise an exception if an\n                    orientation_sensitive :class:`UnistrokeTemplate`\n                    is encountered.\n\n            `goodscore`\n                If this is set (between 0.0 - 1.0) and a gesture score is\n                equal to or higher than the specified value, the search is\n                immediately halted and the on_search_complete event is\n                fired (+ the on_complete event of the associated\n                :class:`ProgressTracker` instance). Default is None (disabled).\n\n            `timeout`\n                Specifies a timeout (in seconds) for when the search is\n                aborted and the results returned. This option applies only\n                when `max_gpf` is not 0. Default value is 0, meaning all\n                gestures in the database will be tested, no matter how long\n                it takes.\n\n            `max_gpf`\n                Specifies the maximum number of :class:`MultistrokeGesture`\n                objects that can be processed per frame. When exceeded, will\n                cause the search to halt and resume work in the next frame.\n                Setting to 0 will complete the search immediately (and block\n                the UI).\n\n                .. Warning ::\n\n                    This does not limit the number of\n                    :class:`UnistrokeTemplate` objects matched! If a single\n                    gesture has a million templates, they will all be\n                    processed in a single frame with max_gpf=1!\n\n            `delay`\n                Sets an optional delay between each run of the recognizer\n                loop. Normally, a run is scheduled for the next frame until\n                the tasklist is exhausted. If you set this, there will be an\n                additional delay between each run (specified in seconds).\n                Default is 0, resume in the next frame.\n\n            `force_numpoints`\n                forces all templates (and candidate) to be prepared to a\n                certain number of points. This can be useful for example if\n                you are evaluating templates for optimal n (do not use this\n                unless you understand what it does).\n        '''\n        GPF = kwargs.get('max_gpf', DEFAULT_GPF)\n\n        # Obtain a list of MultistrokeGesture objects matching filter arguments\n        tasklist = self.filter(**kwargs)\n\n        # Initialize the candidate and result objects\n        cand = self._candidate(strokes)\n        result = ProgressTracker(cand, len(tasklist))\n\n        # This is done to inform caller if they bind to on_complete and there\n        # is nothing to do; perhaps should just return None?\n        if not tasklist:\n            result.status = 'complete'\n            self.dispatch('on_search_complete', result)\n\n            def result_hack(dt):\n                result.dispatch('on_complete')\n            Clock.schedule_once(result_hack)\n            return result\n\n        # This callback is scheduled once per frame until completed\n        def _recognize_tick(dt):\n            start_gc = result._completed\n            stop_now = False\n\n            while not stop_now and (tasklist and not result._break_flag) and \\\n                    (not GPF or (result._completed - start_gc < GPF)):\n\n                if (timeout and\n                        Clock.get_time() - result._start_time >= timeout):\n                    result.status = 'timeout'\n                    stop_now = True\n                    break\n\n                # Get the best distance and number of matching operations done\n                gesture = tasklist.popleft()\n                tpl, d, res, mos = gesture.match_candidate(\n                    cand, **kwargs)\n\n                if tpl is not None:\n                    score = result._add_result(gesture, d, tpl, res)\n                    if goodscore is not None and score >= goodscore:\n                        result.status = 'goodscore'\n                        stop_now = True\n\n                result._match_ops += mos\n                result._completed += 1\n                result.dispatch('on_progress')\n\n            # The loop has ended. Prepare to dispatch 'complete'\n            def _dispatch():\n                result.dispatch('on_complete')\n                self.dispatch('on_search_complete', result)\n                return False\n\n            # Dispatch or reschedule another run\n            if not tasklist:\n                result.status = 'complete'\n                return _dispatch()\n            elif result._break_flag:\n                result.status = 'stop'\n                return _dispatch()\n            elif stop_now:\n                return _dispatch()\n            else:\n                Clock.schedule_once(_recognize_tick, delay)\n                return True\n        # End _recognize_tick()\n\n        self.dispatch('on_search_start', result)\n        if not GPF:\n            _recognize_tick(0)\n        else:\n            Clock.schedule_once(_recognize_tick, 0)\n\n        return result",
  "def _candidate(self, strokes, **kwargs):\n        # recognize() helper function, do not use directly. Set up a\n        # Candidate object from arguments. Either use a specified object\n        # or make a new one from strokes and apply safe skip_* settings to\n        # use less resources.\n        if isinstance(strokes, Candidate):\n            return strokes\n\n        if (not isinstance(strokes, list) or not len(strokes) or not\n                isinstance(strokes[0], list)):\n            raise MultistrokeError('recognize() needs strokes= '\n                                   'list or Candidate')\n\n        cand = Candidate(strokes)\n        o_filter = kwargs.get('orientation_sensitive', None)\n        if o_filter is False:\n            cand.skip_bounded = True\n        elif o_filter is True:\n            cand.skip_invariant = True\n\n        return cand",
  "def on_search_start(self, result):\n        pass",
  "def on_search_complete(self, result):\n        pass",
  "def __init__(self, candidate, tasks, **kwargs):\n        self.status = 'search'\n        self.candidate = candidate\n        self.results = {}\n        self.tasks = tasks\n        self._start_time = Clock.get_time()\n        self._match_ops = 0\n        self._completed = 0\n        self._break_flag = False\n\n        # fired by recognize()\n        self.register_event_type('on_complete')\n        self.register_event_type('on_progress')\n\n        # fired locally\n        self.register_event_type('on_result')\n        super(ProgressTracker, self).__init__(**kwargs)",
  "def progress(self):\n        '''Returns the progress as a float, 0 is 0% done, 1 is 100%. This\n        is a Python property.'''\n        if not self.tasks:\n            return 1\n        return self._completed / float(self.tasks)",
  "def best(self):\n        '''Return the best match found by recognize() so far. It returns a\n        dictionary with three keys, 'name', 'dist' and 'score' representing\n        the template's name, distance (from candidate path) and the\n        computed score value. This is a Python property.'''\n        results = self.results  # to avoid too many self. lookups\n        if not results:\n            return {'name': None, 'dist': None, 'score': 0}\n        b = max(results, key=lambda r: results[r]['score'])\n        return {\n            'name': results[b]['name'],\n            'dist': results[b]['dist'],\n            'score': results[b]['score']\n        }",
  "def stop(self):\n        '''Raises a stop flag that is checked by the search process. It will\n        be stopped on the next clock tick (if it is still running).'''\n        self._break_flag = True",
  "def _add_result(self, gesture, dist, tpl, res):\n        # Add a result; used internally by the recognize() function\n        if tpl <= len(res):\n            n = gesture.templates[tpl].name\n        else:\n            return 0.\n\n        if n not in self.results or dist < self.results[n]['dist']:\n            self.results[n] = {\n                'name': n,\n                'dist': dist,\n                'gesture': gesture,\n                'best_template': tpl,\n                'template_results': res\n            }\n\n            if not dist:\n                self.results[n]['score'] = 1.0\n            else:\n                self.results[n]['score'] = 1.0 - (dist / pi)\n\n            self.dispatch('on_result', self.results[n])\n            return self.results[n]['score']\n        else:\n            return 0.",
  "def on_complete(self):\n        pass",
  "def on_progress(self):\n        pass",
  "def on_result(self, result):\n        pass",
  "def __init__(self, name, strokes=None, **kwargs):\n        self.name = name\n        self.priority = kwargs.get('priority', 100)\n        self.numpoints = kwargs.get('numpoints', 16)\n        self.stroke_sens = kwargs.get('stroke_sensitive', True)\n        self.orientation_sens = kwargs.get('orientation_sensitive', True)\n        self.angle_similarity = kwargs.get('angle_similarity', 30.0)\n        self.strokes = []\n\n        if strokes is not None:\n            self.strokes = strokes\n            if kwargs.get('permute', True):\n                self.permute()\n            else:\n                self.templates = [UnistrokeTemplate(name,\n                                  points=[i for sub in strokes for i in sub],\n                                  numpoints=self.numpoints,\n                                  orientation_sensitive=self.orientation_sens)]",
  "def angle_similarity_threshold(self):\n        return radians(self.angle_similarity)",
  "def add_stroke(self, stroke, permute=False):\n        '''Add a stroke to the self.strokes list. If `permute` is True, the\n        :meth:`permute` method is called to generate new unistroke templates'''\n        self.strokes.append(stroke)\n        if permute:\n            self.permute()",
  "def get_distance(self, cand, tpl, numpoints=None):\n        '''Compute the distance from this Candidate to a UnistrokeTemplate.\n        Returns the Cosine distance between the stroke paths.\n\n        `numpoints` will prepare both the UnistrokeTemplate and Candidate path\n        to n points (when necessary), you probably don't want to do this.\n        '''\n        n = numpoints\n        if n is None or n < 2:\n            n = self.numpoints\n\n        # optimal_cosine_distance() inlined here for performance\n        v1 = tpl.get_vector(n)\n        v2 = cand.get_protractor_vector(n, tpl.orientation_sens)\n\n        a = 0.0\n        b = 0.0\n\n        for i in xrange(0, len(v1), 2):\n            a += (v1[i] * v2[i]) + (v1[i + 1] * v2[i + 1])\n            b += (v1[i] * v2[i + 1]) - (v1[i + 1] * v2[i])\n\n        angle = atan(b / a)\n\n        # If you put the below directly into math.acos(), you will get a domain\n        # error when a=1.0 and angle=0.0 (ie math_cos(angle)=1.0). It seems to\n        # be because float representation of 1.0*1.0 is >1.0 (ie 1.00000...001)\n        # and this is problematic for math.acos().\n        # If you try math.acos(1.0*1.0) in interpreter it does not happen,\n        # only with exact match at runtime\n        result = a * math_cos(angle) + b * math_sin(angle)\n\n        # FIXME: I'm sure there is a better way to do it but..\n        if result >= 1:\n            result = 1\n        elif result <= -1:  # has not happened to me, but I leave it here.\n            result = -1\n        return acos(result)",
  "def match_candidate(self, cand, **kwargs):\n        '''Match a given candidate against this MultistrokeGesture object. Will\n        test against all templates and report results as a list of four\n        items:\n\n            `index 0`\n                Best matching template's index (in self.templates)\n            `index 1`\n                Computed distance from the template to the candidate path\n            `index 2`\n                List of distances for all templates. The list index\n                corresponds to a :class:`UnistrokeTemplate` index in\n                self.templates.\n            `index 3`\n                Counter for the number of performed matching operations, ie\n                templates matched against the candidate\n        '''\n        best_d = float('infinity')\n        best_tpl = None\n        mos = 0\n        out = []\n\n        if (self.stroke_sens and len(self.strokes) != len(cand.strokes)):\n            return (best_tpl, best_d, out, mos)\n\n        skip_bounded = cand.skip_bounded\n        skip_invariant = cand.skip_invariant\n        get_distance = self.get_distance\n        ang_sim_threshold = self.angle_similarity_threshold()\n\n        for idx, tpl in enumerate(self.templates):\n            # Handle a theoretical case where a MultistrokeGesture is composed\n            # manually and the orientation_sensitive flag is True, and contains\n            # a UnistrokeTemplate that has orientation_sensitive=False (or vice\n            # versa). This would cause KeyError - requesting nonexistent vector\n            if tpl.orientation_sens:\n                if skip_bounded:\n                    continue\n            elif skip_invariant:\n                continue\n\n            # Count as a match operation now, since the call to get_\n            # angle_similarity below will force vector calculation,\n            # even if it doesn't make it to get_distance\n            mos += 1\n\n            # Note: With this implementation, we always resample the candidate\n            # to *any* encountered UnistrokeTemplate numpoints here, the filter\n            # is only applied to MultistrokeGesture. See theoretical case\n            # above; should not matter normally.\n            n = kwargs.get('force_numpoints', tpl.numpoints)\n\n            # Skip if candidate/gesture angles are too far off\n            ang_sim = cand.get_angle_similarity(tpl, numpoints=n)\n            if ang_sim > ang_sim_threshold:\n                continue\n\n            # Get the distance between cand/tpl paths\n            d = get_distance(cand, tpl, numpoints=n)\n            out.append(d)\n\n            if d < best_d:\n                best_d = d\n                best_tpl = idx\n\n        return (best_tpl, best_d, out, mos)",
  "def permute(self):\n        '''Generate all possible unistroke permutations from self.strokes and\n        save the resulting list of UnistrokeTemplate objects in self.templates.\n\n        Quote from http://faculty.washington.edu/wobbrock/pubs/gi-10.2.pdf ::\n\n            We use Heap Permute [16] (p. 179) to generate all stroke orders\n            in a multistroke gesture. Then, to generate stroke directions for\n            each order, we treat each component stroke as a dichotomous\n            [0,1] variable. There are 2^N combinations for N strokes, so we\n            convert the decimal values 0 to 2^N-1, inclusive, to binary\n            representations and regard each bit as indicating forward (0) or\n            reverse (1). This algorithm is often used to generate truth tables\n            in propositional logic.\n\n        See section 4.1: \"$N Algorithm\" of the linked paper for details.\n\n        .. Warning ::\n\n            Using heap permute for gestures with more than 3 strokes\n            can result in very large number of templates (a 9-stroke\n            gesture = 38 million templates). If you are dealing with\n            these types of gestures, you should manually compose\n            all the desired stroke orders.\n        '''\n        # Seed with index of each stroke\n        self._order = [i for i in xrange(0, len(self.strokes))]\n\n        # Prepare ._orders\n        self._orders = []\n        self._heap_permute(len(self.strokes))\n        del self._order\n\n        # Generate unistroke permutations\n        self.templates = [UnistrokeTemplate(\n            self.name,\n            points=permutation,\n            numpoints=self.numpoints,\n            orientation_sensitive=self.orientation_sens\n        ) for permutation in self._make_unistrokes()]\n        del self._orders",
  "def _heap_permute(self, n):\n        # Heap Permute algorithm\n        self_order = self._order\n        if n == 1:\n            self._orders.append(self_order[:])\n        else:\n            i = 0\n            for i in xrange(0, n):\n                self._heap_permute(n - 1)\n                if n % 2 == 1:\n                    tmp = self_order[0]\n                    self_order[0] = self_order[n - 1]\n                    self_order[n - 1] = tmp\n                else:\n                    tmp = self_order[i]\n                    self_order[i] = self_order[n - 1]\n                    self_order[n - 1] = tmp",
  "def _make_unistrokes(self):\n        # Create unistroke permutations from self.strokes\n        unistrokes = []\n        unistrokes_append = unistrokes.append\n        self_strokes = self.strokes\n        for r in self._orders:\n            b = 0\n            while b < pow(2, len(r)):  # use b's bits for directions\n                unistroke = []\n                unistroke_append = unistroke.append\n                for i in xrange(0, len(r)):\n                    pts = self_strokes[r[i]][:]\n                    if (b >> i) & 1 == 1:  # is b's bit at index i 1?\n                        pts.reverse()\n                    unistroke_append(None)\n                    unistroke[-1:] = pts\n\n                unistrokes_append(unistroke)\n                b += 1\n        return unistrokes",
  "def __init__(self, name, points=None, **kwargs):\n        self.name = name\n        self.numpoints = kwargs.get('numpoints', 16)\n        self.orientation_sens = kwargs.get('orientation_sensitive', True)\n\n        self.db = {}\n        self.points = []\n\n        if points is not None:\n            self.points = points",
  "def add_point(self, p):\n        '''Add a point to the unistroke/path. This invalidates all previously\n        computed vectors.'''\n        self.points.append(p)\n        # All previously computed data is now void.\n        self.db = {}",
  "def _get_db_key(self, key, numpoints=None):\n        n = numpoints and numpoints or self.numpoints\n        if n not in self.db:\n            self.prepare(n)\n        return self.db[n][key]",
  "def get_start_unit_vector(self, numpoints=None):\n        return self._get_db_key('startvector', numpoints)",
  "def get_vector(self, numpoints=None):\n        return self._get_db_key('vector', numpoints)",
  "def get_points(self, numpoints=None):\n        return self._get_db_key('points', numpoints)",
  "def prepare(self, numpoints=None):\n        '''This function prepares the UnistrokeTemplate for matching given a\n        target number of points (for resample). 16 is optimal.'''\n\n        if not self.points:\n            raise MultistrokeError('prepare() called without self.points')\n\n        # How many points are we resampling to?\n        n = numpoints or self.numpoints\n        if not n or n < 2:\n            raise MultistrokeError('prepare() called with invalid numpoints')\n\n        p = resample(self.points, n)\n        radians = indicative_angle(p)\n        p = rotate_by(p, -radians)\n        p = scale_dim(p, SQUARESIZE, ONEDTHRESHOLD)\n\n        if self.orientation_sens:\n            p = rotate_by(p, +radians)  # restore\n\n        p = translate_to(p, ORIGIN)\n\n        # Now store it using the number of points in the resampled path as the\n        # dict key. On the next call to get_*, it will be returned instead of\n        # recomputed. Implicitly, you must reset self.db or call prepare() for\n        # all the keys once you manipulate self.points.\n        self.db[n] = {\n            # Compute STARTANGLEINDEX as n/8:\n            'startvector': start_unit_vector(p, (n / 8)),\n            'vector': vectorize(p, self.orientation_sens)\n        }",
  "def __init__(self, strokes=None, numpoints=16, **kwargs):\n        self.skip_invariant = kwargs.get('skip_invariant', False)\n        self.skip_bounded = kwargs.get('skip_bounded', False)\n\n        self.numpoints = numpoints\n        self.db = {}\n        self.strokes = []\n\n        if strokes is not None:\n            self.strokes = strokes",
  "def add_stroke(self, stroke):\n        '''Add a stroke to the candidate; this will invalidate all\n        previously computed vectors'''\n        self.points.append(stroke)\n        self.db = {}",
  "def _get_db_key(self, key, numpoints, orientation_sens):\n        n = numpoints and numpoints or self.numpoints\n        if n not in self.db:\n            self.prepare(n)\n\n        prefix = orientation_sens and 'bound_' or 'inv_'\n        return self.db[n][prefix + key]",
  "def get_start_unit_vector(self, numpoints, orientation_sens):\n        '''(Internal use only) Get the start vector for this Candidate,\n        with the path resampled to `numpoints` points. This is the first\n        step in the matching process. It is compared to a\n        UnistrokeTemplate object's start vector to determine angle\n        similarity.'''\n        return self._get_db_key('startvector', numpoints, orientation_sens)",
  "def get_protractor_vector(self, numpoints, orientation_sens):\n        '''(Internal use only) Return vector for comparing to a\n        UnistrokeTemplate with Protractor'''\n        return self._get_db_key('vector', numpoints, orientation_sens)",
  "def get_angle_similarity(self, tpl, **kwargs):\n        '''(Internal use only) Compute the angle similarity between this\n        Candidate and a UnistrokeTemplate object. Returns a number that\n        represents the angle similarity (lower is more similar).'''\n        n = kwargs.get('numpoints', self.numpoints)\n\n        # angle_between_unit_vectors() inlined here for performance\n        v1x, v1y = self.get_start_unit_vector(n, tpl.orientation_sens)\n        v2x, v2y = tpl.get_start_unit_vector(n)\n\n        n = (v1x * v2x + v1y * v2y)\n        # FIXME: Domain error on float representation of 1.0 (exact match)\n        # (see comments in MultistrokeGesture.get_distance())\n        if n >= 1:\n            return 0.0\n        if n <= -1:\n            return pi\n        return acos(n)",
  "def prepare(self, numpoints=None):\n        '''Prepare the Candidate vectors. self.strokes is combined to a single\n        unistroke (connected end-to-end), resampled to :attr:`numpoints`\n        points, and then the vectors are calculated and stored in self.db (for\n        use by `get_distance` and `get_angle_similarity`)'''\n        n = numpoints and numpoints or self.numpoints\n\n        # Inlined combine_strokes() for performance\n        points = [i for sub in self.strokes for i in sub]\n        points = resample(points, n)\n        radians = indicative_angle(points)\n        points = rotate_by(points, -radians)\n        points = scale_dim(points, SQUARESIZE, ONEDTHRESHOLD)\n\n        # Compute STARTANGLEINDEX as n / 8\n        angidx = n / 8\n        cand = {}\n\n        # full rotation invariance\n        if not self.skip_invariant:\n            inv_points = translate_to(points, ORIGIN)\n            cand['inv_startvector'] = start_unit_vector(inv_points, angidx)\n            cand['inv_vector'] = vectorize(inv_points, False)\n\n        # rotation bounded invariance\n        if not self.skip_bounded:\n            bound_points = rotate_by(points, +radians)  # restore\n            bound_points = translate_to(bound_points, ORIGIN)\n            cand['bound_startvector'] = start_unit_vector(bound_points, angidx)\n            cand['bound_vector'] = vectorize(bound_points, True)\n\n        self.db[n] = cand",
  "def _recognize_tick(dt):\n            start_gc = result._completed\n            stop_now = False\n\n            while not stop_now and (tasklist and not result._break_flag) and \\\n                    (not GPF or (result._completed - start_gc < GPF)):\n\n                if (timeout and\n                        Clock.get_time() - result._start_time >= timeout):\n                    result.status = 'timeout'\n                    stop_now = True\n                    break\n\n                # Get the best distance and number of matching operations done\n                gesture = tasklist.popleft()\n                tpl, d, res, mos = gesture.match_candidate(\n                    cand, **kwargs)\n\n                if tpl is not None:\n                    score = result._add_result(gesture, d, tpl, res)\n                    if goodscore is not None and score >= goodscore:\n                        result.status = 'goodscore'\n                        stop_now = True\n\n                result._match_ops += mos\n                result._completed += 1\n                result.dispatch('on_progress')\n\n            # The loop has ended. Prepare to dispatch 'complete'\n            def _dispatch():\n                result.dispatch('on_complete')\n                self.dispatch('on_search_complete', result)\n                return False\n\n            # Dispatch or reschedule another run\n            if not tasklist:\n                result.status = 'complete'\n                return _dispatch()\n            elif result._break_flag:\n                result.status = 'stop'\n                return _dispatch()\n            elif stop_now:\n                return _dispatch()\n            else:\n                Clock.schedule_once(_recognize_tick, delay)\n                return True",
  "def result_hack(dt):\n                result.dispatch('on_complete')",
  "def _dispatch():\n                result.dispatch('on_complete')\n                self.dispatch('on_search_complete', result)\n                return False",
  "class KivyLexer(RegexLexer):\n    name = 'Kivy'\n    aliases = ['kivy', 'kv']\n    filenames = ['*.kv']\n    tokens = {\n        'root': [\n            (r'#:.*?$', Comment.Preproc),\n            (r'#.*?$', using(PythonLexer)),\n            (r'\\s+', Text),\n            (r'<.+>', Name.Namespace),\n            (r'(\\[)(\\s*)(.*?)(\\s*)(@)',\n                bygroups(Punctuation, Text, Name.Class, Text, Operator),\n                'classList'),\n            (r'[A-Za-z][A-Za-z0-9]*$', Name.Attribute),\n            (r'(.*?)(\\s*)(:)(\\s*)$',\n                bygroups(Name.Class, Text, Punctuation, Text)),\n            (r'(.*?)(\\s*)(:)(\\s*)(.*?)$',\n                bygroups(Name.Attribute, Text, Punctuation, Text,\n                using(PythonLexer))),\n            (r'[^:]+?$', using(PythonLexer))],\n        'classList': [\n            (r'(,)(\\s*)([A-Z][A-Za-z0-9]*)',\n                bygroups(Punctuation, Text, Name.Class)),\n            (r'(\\+)(\\s*)([A-Z][A-Za-z0-9]*)',\n                bygroups(Operator, Text, Name.Class)),\n            (r'\\s+', Text),\n            (r'[A-Z][A-Za-z0-9]*', Name.Class),\n            (r'\\]', Punctuation, '#pop')]}",
  "class UrlRequestBase(Thread):\n    '''A UrlRequest. See module documentation for usage.\n\n    .. versionchanged:: 1.5.1\n        Add `debug` parameter\n\n    .. versionchanged:: 1.0.10\n        Add `method` parameter\n\n    .. versionchanged:: 1.8.0\n\n        Parameter `decode` added.\n        Parameter `file_path` added.\n        Parameter `on_redirect` added.\n        Parameter `on_failure` added.\n\n    .. versionchanged:: 1.9.1\n\n        Parameter `ca_file` added.\n        Parameter `verify` added.\n\n    .. versionchanged:: 1.10.0\n\n        Parameters `proxy_host`, `proxy_port` and `proxy_headers` added.\n\n    .. versionchanged:: 1.11.0\n\n        Parameters `on_cancel` added.\n\n    .. versionchanged:: 2.2.0\n\n        Parameters `on_finish` added.\n        Parameters `auth` added.\n\n    :Parameters:\n        `url`: str\n            Complete url string to call.\n        `on_success`: callback(request, result)\n            Callback function to call when the result has been fetched.\n        `on_redirect`: callback(request, result)\n            Callback function to call if the server returns a Redirect.\n        `on_failure`: callback(request, result)\n            Callback function to call if the server returns a Client or\n            Server Error.\n        `on_error`: callback(request, error)\n            Callback function to call if an error occurs.\n        `on_progress`: callback(request, current_size, total_size)\n            Callback function that will be called to report progression of the\n            download. `total_size` might be -1 if no Content-Length has been\n            reported in the http response.\n            This callback will be called after each `chunk_size` is read.\n        `on_cancel`: callback(request)\n            Callback function to call if user requested to cancel the download\n            operation via the .cancel() method.\n        `on_finish`: callback(request)\n            Additional callback function to call if request is done.\n        `req_body`: str, defaults to None\n            Data to sent in the request. If it's not None, a POST will be done\n            instead of a GET.\n        `req_headers`: dict, defaults to None\n            Custom headers to add to the request.\n        `chunk_size`: int, defaults to 8192\n            Size of each chunk to read, used only when `on_progress` callback\n            has been set. If you decrease it too much, a lot of on_progress\n            callbacks will be fired and will slow down your download. If you\n            want to have the maximum download speed, increase the chunk_size\n            or don't use ``on_progress``.\n        `timeout`: int, defaults to None\n            If set, blocking operations will timeout after this many seconds.\n        `method`: str, defaults to 'GET' (or 'POST' if ``body`` is specified)\n            The HTTP method to use.\n        `decode`: bool, defaults to True\n            If False, skip decoding of the response.\n        `debug`: bool, defaults to False\n            If True, it will use the Logger.debug to print information\n            about url access/progression/errors.\n        `file_path`: str, defaults to None\n            If set, the result of the UrlRequest will be written to this path\n            instead of in memory.\n        `ca_file`: str, defaults to None\n            Indicates a SSL CA certificate file path to validate HTTPS\n            certificates against\n        `verify`: bool, defaults to True\n            If False, disables SSL CA certificate verification\n        `proxy_host`: str, defaults to None\n            If set, the proxy host to use for this connection.\n        `proxy_port`: int, defaults to None\n            If set, and `proxy_host` is also set, the port to use for\n            connecting to the proxy server.\n        `proxy_headers`: dict, defaults to None\n            If set, and `proxy_host` is also set, the headers to send to the\n            proxy server in the ``CONNECT`` request.\n        `auth`: HTTPBasicAuth, defaults to None\n            If set, request will use basicauth to authenticate.\n            Only used in \"Requests\" implementation\n    '''\n\n    def __init__(\n        self, url, on_success=None, on_redirect=None,\n        on_failure=None, on_error=None, on_progress=None,\n        req_body=None, req_headers=None, chunk_size=8192,\n        timeout=None, method=None, decode=True, debug=False,\n        file_path=None, ca_file=None, verify=True, proxy_host=None,\n        proxy_port=None, proxy_headers=None, user_agent=None,\n        on_cancel=None, on_finish=None, cookies=None, auth=None\n    ):\n        super().__init__()\n        self._queue = deque()\n        self._trigger_result = Clock.create_trigger(self._dispatch_result, 0)\n        self.daemon = True\n        self.on_success = WeakMethod(on_success) if on_success else None\n        self.on_redirect = WeakMethod(on_redirect) if on_redirect else None\n        self.on_failure = WeakMethod(on_failure) if on_failure else None\n        self.on_error = WeakMethod(on_error) if on_error else None\n        self.on_progress = WeakMethod(on_progress) if on_progress else None\n        self.on_cancel = WeakMethod(on_cancel) if on_cancel else None\n        self.on_finish = WeakMethod(on_finish) if on_finish else None\n        self.decode = decode\n        self.file_path = file_path\n        self._debug = debug\n        self._result = None\n        self._error = None\n        self._is_finished = False\n        self._resp_status = None\n        self._resp_headers = None\n        self._resp_length = -1\n        self._chunk_size = chunk_size\n        self._timeout = timeout\n        self._method = method\n        self.verify = verify\n        self._proxy_host = proxy_host\n        self._proxy_port = proxy_port\n        self._proxy_headers = proxy_headers\n        self._cancel_event = Event()\n        self._user_agent = user_agent\n        self._cookies = cookies\n        self._requested_url = url\n        self._auth = auth\n\n        if platform in ['android', 'ios']:\n            import certifi\n            self.ca_file = ca_file or certifi.where()\n        else:\n            self.ca_file = ca_file\n\n        #: Url of the request\n        self.url = url\n\n        #: Request body passed in __init__\n        self.req_body = req_body\n\n        #: Request headers passed in __init__\n        self.req_headers = req_headers\n\n        # save our request to prevent GC\n        g_requests.append(self)\n\n        self.start()\n\n    def run(self):\n        q = self._queue.appendleft\n        url = self.url\n        req_body = self.req_body\n        req_headers = self.req_headers or {}\n\n        user_agent = self._user_agent\n        cookies = self._cookies\n\n        if user_agent:\n            req_headers.setdefault('User-Agent', user_agent)\n\n        elif (\n            Config.has_section('network')\n            and 'useragent' in Config.items('network')\n        ):\n            useragent = Config.get('network', 'useragent')\n            req_headers.setdefault('User-Agent', useragent)\n\n        if cookies:\n            req_headers.setdefault(\"Cookie\", cookies)\n\n        try:\n            result, resp = self._fetch_url(url, req_body, req_headers, q)\n            if self.decode:\n                result = self.decode_result(result, resp)\n        except Exception as e:\n            q(('error', None, e))\n        else:\n            if not self._cancel_event.is_set():\n                q(('success', resp, result))\n            else:\n                q(('killed', None, None))\n\n        # using trigger can result in a missed on_success event\n        self._trigger_result()\n\n        # clean ourself when the queue is empty\n        while len(self._queue):\n            sleep(.1)\n            self._trigger_result()\n\n        # ok, authorize the GC to clean us.\n        if self in g_requests:\n            g_requests.remove(self)\n\n    def _fetch_url(self, url, body, headers, q):\n        # Parse and fetch the current url\n        trigger = self._trigger_result\n        chunk_size = self._chunk_size\n        report_progress = self.on_progress is not None\n        file_path = self.file_path\n\n        if self._debug:\n            Logger.debug('UrlRequest: {0} Fetch url <{1}>'.format(\n                id(self), url))\n            Logger.debug('UrlRequest: {0} - body: {1}'.format(\n                id(self), body))\n            Logger.debug('UrlRequest: {0} - headers: {1}'.format(\n                id(self), headers))\n\n        req, resp = self.call_request(body, headers)\n\n        # read content\n        if report_progress or file_path is not None:\n            total_size = self.get_total_size(resp)\n\n            # before starting the download, send a fake progress to permit the\n            # user to initialize his ui\n            if report_progress:\n                q(('progress', resp, (0, total_size)))\n\n            if file_path is not None:\n                with open(file_path, 'wb') as fd:\n                    bytes_so_far, result = self.get_chunks(\n                        resp, chunk_size, total_size, report_progress, q,\n                        trigger, fd=fd\n                    )\n            else:\n                bytes_so_far, result = self.get_chunks(\n                    resp, chunk_size, total_size, report_progress, q, trigger\n                )\n\n            # ensure that results are dispatched for the last chunk,\n            # avoid trigger\n            if report_progress:\n                q(('progress', resp, (bytes_so_far, total_size)))\n                trigger()\n        else:\n            result = self.get_response(resp)\n            try:\n                if isinstance(result, bytes):\n                    result = result.decode('utf-8')\n            except UnicodeDecodeError:\n                # if it's an image? decoding would not work\n                pass\n\n        self.close_connection(req)\n\n        # return everything\n        return result, resp\n\n    def decode_result(self, result, resp):\n        '''Decode the result fetched from url according to his Content-Type.\n        Currently supports only application/json.\n        '''\n        # Entry to decode url from the content type.\n        # For example, if the content type is a json, it will be automatically\n        # decoded.\n        content_type = self.get_content_type(resp)\n        if content_type is not None:\n            ct = content_type.split(';')[0]\n            if ct == 'application/json':\n                if isinstance(result, bytes):\n                    result = result.decode('utf-8')\n                try:\n                    return loads(result)\n                except Exception:\n                    return result\n\n        return result\n\n    def _dispatch_result(self, dt):\n        while True:\n            # Read the result pushed on the queue, and dispatch to the client\n            try:\n                result, resp, data = self._queue.pop()\n            except IndexError:\n                return\n\n            if resp:\n                # Small workaround in order to prevent the situation mentioned\n                # in the comment below\n                final_cookies = \"\"\n                parsed_headers = []\n                for key, value in self.get_all_headers(resp):\n                    if key == \"Set-Cookie\":\n                        final_cookies += \"{};\".format(value)\n                    else:\n                        parsed_headers.append((key, value))\n                parsed_headers.append((\"Set-Cookie\", final_cookies[:-1]))\n\n                # XXX usage of dict can be dangerous if multiple headers\n                # are set even if it's invalid. But it look like it's ok\n                # ?  http://stackoverflow.com/questions/2454494/..\n                # ..urllib2-multiple-set-cookie-headers-in-response\n                self._resp_headers = dict(parsed_headers)\n                self._resp_status = self.get_status_code(resp)\n\n            if result == 'success':\n                status_class = self.get_status_code(resp) // 100\n\n                if status_class in (1, 2):\n                    if self._debug:\n                        Logger.debug(\n                            'UrlRequest: {0} Download finished with '\n                            '{1} datalen'.format(id(self), data)\n                        )\n                    self._is_finished = True\n                    self._result = data\n                    if self.on_success:\n                        func = self.on_success()\n                        if func:\n                            func(self, data)\n\n                elif status_class == 3:\n                    if self._debug:\n                        Logger.debug('UrlRequest: {} Download '\n                                     'redirected'.format(id(self)))\n                    self._is_finished = True\n                    self._result = data\n                    if self.on_redirect:\n                        func = self.on_redirect()\n                        if func:\n                            func(self, data)\n\n                elif status_class in (4, 5):\n                    if self._debug:\n                        Logger.debug(\n                            'UrlRequest: {} Download failed with '\n                            'http error {}'.format(\n                                id(self),\n                                self.get_status_code(resp)\n                            )\n                        )\n                    self._is_finished = True\n                    self._result = data\n                    if self.on_failure:\n                        func = self.on_failure()\n                        if func:\n                            func(self, data)\n\n            elif result == 'error':\n                if self._debug:\n                    Logger.debug('UrlRequest: {0} Download error '\n                                 '<{1}>'.format(id(self), data))\n                self._is_finished = True\n                self._error = data\n                if self.on_error:\n                    func = self.on_error()\n                    if func:\n                        func(self, data)\n\n            elif result == 'progress':\n                if self._debug:\n                    Logger.debug('UrlRequest: {0} Download progress '\n                                 '{1}'.format(id(self), data))\n                if self.on_progress:\n                    func = self.on_progress()\n                    if func:\n                        func(self, data[0], data[1])\n\n            elif result == 'killed':\n                if self._debug:\n                    Logger.debug('UrlRequest: Cancelled by user')\n                if self.on_cancel:\n                    func = self.on_cancel()\n                    if func:\n                        func(self)\n\n            else:\n                assert 0\n\n            if result != \"progress\" and self.on_finish:\n                if self._debug:\n                    Logger.debug('UrlRequest: Request is finished')\n                func = self.on_finish()\n                if func:\n                    func(self)\n\n    @property\n    def is_finished(self):\n        '''Return True if the request has finished, whether it's a\n        success or a failure.\n        '''\n        return self._is_finished\n\n    @property\n    def result(self):\n        '''Return the result of the request.\n        This value is not determined until the request is finished.\n        '''\n        return self._result\n\n    @property\n    def resp_headers(self):\n        '''If the request has been completed, return a dictionary containing\n        the headers of the response. Otherwise, it will return None.\n        '''\n        return self._resp_headers\n\n    @property\n    def resp_status(self):\n        '''Return the status code of the response if the request is complete,\n        otherwise return None.\n        '''\n        return self._resp_status\n\n    @property\n    def error(self):\n        '''Return the error of the request.\n        This value is not determined until the request is completed.\n        '''\n        return self._error\n\n    @property\n    def chunk_size(self):\n        '''Return the size of a chunk, used only in \"progress\" mode (when\n        on_progress callback is set.)\n        '''\n        return self._chunk_size\n\n    def wait(self, delay=0.5):\n        '''Wait for the request to finish (until :attr:`resp_status` is not\n        None)\n\n        .. note::\n            This method is intended to be used in the main thread, and the\n            callback will be dispatched from the same thread\n            from which you're calling.\n\n        .. versionadded:: 1.1.0\n        '''\n        while self.resp_status is None:\n            self._dispatch_result(delay)\n            sleep(delay)\n\n    def cancel(self):\n        '''Cancel the current request. It will be aborted, and the result\n        will not be dispatched. Once cancelled, the callback on_cancel will\n        be called.\n\n        .. versionadded:: 1.11.0\n        '''\n        self._cancel_event.set()",
  "class UrlRequestUrllib(UrlRequestBase):\n\n    def get_chunks(\n        self, resp, chunk_size, total_size, report_progress, q,\n        trigger, fd=None\n    ):\n        bytes_so_far = 0\n        result = b''\n\n        while 1:\n            chunk = resp.read(chunk_size)\n            if not chunk:\n                break\n\n            if fd:\n                fd.write(chunk)\n\n            else:\n                result += chunk\n\n            bytes_so_far += len(chunk)\n\n            if report_progress:\n                q(('progress', resp, (bytes_so_far, total_size)))\n                trigger()\n\n            if self._cancel_event.is_set():\n                break\n\n        return bytes_so_far, result\n\n    def get_response(self, resp):\n        return resp.read()\n\n    def get_total_size(self, resp):\n        try:\n            return int(resp.getheader('content-length'))\n        except Exception:\n            return -1\n\n    def get_content_type(self, resp):\n        return resp.getheader('Content-Type', None)\n\n    def get_status_code(self, resp):\n        return resp.status\n\n    def get_all_headers(self, resp):\n        return resp.getheaders()\n\n    def close_connection(self, req):\n        req.close()\n\n    def _parse_url(self, url):\n        parse = urlparse(url)\n        host = parse.hostname\n        port = parse.port\n        userpass = None\n\n        # append user + pass to hostname if specified\n        if parse.username and parse.password:\n            userpass = {\n                \"Authorization\": \"Basic {}\".format(b64encode(\n                    \"{}:{}\".format(\n                        parse.username,\n                        parse.password\n                    ).encode('utf-8')\n                ).decode('utf-8'))\n            }\n\n        return host, port, userpass, parse\n\n    def _get_connection_for_scheme(self, scheme):\n        '''Return the Connection class for a particular scheme.\n        This is an internal function that can be expanded to support custom\n        schemes.\n\n        Actual supported schemes: http, https.\n        '''\n        if scheme == 'http':\n            return HTTPConnection\n        elif scheme == 'https' and HTTPSConnection is not None:\n            return HTTPSConnection\n        else:\n            raise Exception('No class for scheme %s' % scheme)\n\n    def call_request(self, body, headers):\n        timeout = self._timeout\n        ca_file = self.ca_file\n        verify = self.verify\n        url = self._requested_url\n\n        # parse url\n        host, port, userpass, parse = self._parse_url(url)\n        if userpass and not headers:\n            headers = userpass\n        elif userpass and headers:\n            key = list(userpass.keys())[0]\n            headers[key] = userpass[key]\n\n        # translate scheme to connection class\n        cls = self._get_connection_for_scheme(parse.scheme)\n\n        # reconstruct path to pass on the request\n        path = parse.path\n        if parse.params:\n            path += ';' + parse.params\n        if parse.query:\n            path += '?' + parse.query\n        if parse.fragment:\n            path += '#' + parse.fragment\n\n        # create connection instance\n        args = {}\n        if timeout is not None:\n            args['timeout'] = timeout\n\n        if (ca_file is not None and hasattr(ssl, 'create_default_context') and\n                parse.scheme == 'https'):\n            ctx = ssl.create_default_context(cafile=ca_file)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            args['context'] = ctx\n\n        if not verify and parse.scheme == 'https' and (\n            hasattr(ssl, 'create_default_context')):\n            ctx = ssl.create_default_context()\n            ctx.check_hostname = False\n            ctx.verify_mode = ssl.CERT_NONE\n            args['context'] = ctx\n\n        if self._proxy_host:\n            Logger.debug('UrlRequest: {0} - proxy via {1}:{2}'.format(\n                id(self), self._proxy_host, self._proxy_port\n            ))\n            req = cls(self._proxy_host, self._proxy_port, **args)\n            if parse.scheme == 'https':\n                req.set_tunnel(host, port, self._proxy_headers)\n            else:\n                path = urlunparse(parse)\n        else:\n            req = cls(host, port, **args)\n\n        # send request\n        method = self._method\n        if method is None:\n            method = 'GET' if body is None else 'POST'\n\n        req.request(method, path, body, headers or {})\n\n        # read header\n        return req, req.getresponse()",
  "class UrlRequestRequests(UrlRequestBase):\n\n    def get_chunks(\n        self, resp, chunk_size, total_size, report_progress, q,\n        trigger, fd=None\n    ):\n        bytes_so_far = 0\n        result = b''\n\n        for chunk in resp.iter_content(chunk_size):\n            if not chunk:\n                break\n\n            if fd:\n                fd.write(chunk)\n\n            else:\n                result += chunk\n\n            bytes_so_far += len(chunk)\n\n            if report_progress:\n                q(('progress', resp, (bytes_so_far, total_size)))\n                trigger()\n\n            if self._cancel_event.is_set():\n                break\n\n        return bytes_so_far, result\n\n    def get_response(self, resp):\n        return resp.content\n\n    def get_total_size(self, resp):\n        return int(resp.headers.get('Content-Length', -1))\n\n    def get_content_type(self, resp):\n        return resp.headers.get('Content-Type', None)\n\n    def get_status_code(self, resp):\n        return resp.status_code\n\n    def get_all_headers(self, resp):\n        return resp.headers.items()\n\n    def close_connection(self, req):\n        pass\n\n    def call_request(self, body, headers):\n        timeout = self._timeout\n        ca_file = self.ca_file\n        verify = self.verify\n        url = self._requested_url\n        auth = self._auth\n\n        req = requests\n        kwargs = {}\n\n        # get method\n        if self._method is None:\n            method = 'get' if body is None else 'post'\n        else:\n            method = self._method.lower()\n\n        req_call = getattr(req, method)\n\n        if auth:\n            kwargs[\"auth\"] = auth\n\n        # send request\n        response = req_call(\n            url,\n            data=body,\n            headers=headers,\n            timeout=timeout,\n            verify=verify,\n            cert=ca_file,\n            **kwargs\n        )\n\n        return None, response",
  "def __init__(\n        self, url, on_success=None, on_redirect=None,\n        on_failure=None, on_error=None, on_progress=None,\n        req_body=None, req_headers=None, chunk_size=8192,\n        timeout=None, method=None, decode=True, debug=False,\n        file_path=None, ca_file=None, verify=True, proxy_host=None,\n        proxy_port=None, proxy_headers=None, user_agent=None,\n        on_cancel=None, on_finish=None, cookies=None, auth=None\n    ):\n        super().__init__()\n        self._queue = deque()\n        self._trigger_result = Clock.create_trigger(self._dispatch_result, 0)\n        self.daemon = True\n        self.on_success = WeakMethod(on_success) if on_success else None\n        self.on_redirect = WeakMethod(on_redirect) if on_redirect else None\n        self.on_failure = WeakMethod(on_failure) if on_failure else None\n        self.on_error = WeakMethod(on_error) if on_error else None\n        self.on_progress = WeakMethod(on_progress) if on_progress else None\n        self.on_cancel = WeakMethod(on_cancel) if on_cancel else None\n        self.on_finish = WeakMethod(on_finish) if on_finish else None\n        self.decode = decode\n        self.file_path = file_path\n        self._debug = debug\n        self._result = None\n        self._error = None\n        self._is_finished = False\n        self._resp_status = None\n        self._resp_headers = None\n        self._resp_length = -1\n        self._chunk_size = chunk_size\n        self._timeout = timeout\n        self._method = method\n        self.verify = verify\n        self._proxy_host = proxy_host\n        self._proxy_port = proxy_port\n        self._proxy_headers = proxy_headers\n        self._cancel_event = Event()\n        self._user_agent = user_agent\n        self._cookies = cookies\n        self._requested_url = url\n        self._auth = auth\n\n        if platform in ['android', 'ios']:\n            import certifi\n            self.ca_file = ca_file or certifi.where()\n        else:\n            self.ca_file = ca_file\n\n        #: Url of the request\n        self.url = url\n\n        #: Request body passed in __init__\n        self.req_body = req_body\n\n        #: Request headers passed in __init__\n        self.req_headers = req_headers\n\n        # save our request to prevent GC\n        g_requests.append(self)\n\n        self.start()",
  "def run(self):\n        q = self._queue.appendleft\n        url = self.url\n        req_body = self.req_body\n        req_headers = self.req_headers or {}\n\n        user_agent = self._user_agent\n        cookies = self._cookies\n\n        if user_agent:\n            req_headers.setdefault('User-Agent', user_agent)\n\n        elif (\n            Config.has_section('network')\n            and 'useragent' in Config.items('network')\n        ):\n            useragent = Config.get('network', 'useragent')\n            req_headers.setdefault('User-Agent', useragent)\n\n        if cookies:\n            req_headers.setdefault(\"Cookie\", cookies)\n\n        try:\n            result, resp = self._fetch_url(url, req_body, req_headers, q)\n            if self.decode:\n                result = self.decode_result(result, resp)\n        except Exception as e:\n            q(('error', None, e))\n        else:\n            if not self._cancel_event.is_set():\n                q(('success', resp, result))\n            else:\n                q(('killed', None, None))\n\n        # using trigger can result in a missed on_success event\n        self._trigger_result()\n\n        # clean ourself when the queue is empty\n        while len(self._queue):\n            sleep(.1)\n            self._trigger_result()\n\n        # ok, authorize the GC to clean us.\n        if self in g_requests:\n            g_requests.remove(self)",
  "def _fetch_url(self, url, body, headers, q):\n        # Parse and fetch the current url\n        trigger = self._trigger_result\n        chunk_size = self._chunk_size\n        report_progress = self.on_progress is not None\n        file_path = self.file_path\n\n        if self._debug:\n            Logger.debug('UrlRequest: {0} Fetch url <{1}>'.format(\n                id(self), url))\n            Logger.debug('UrlRequest: {0} - body: {1}'.format(\n                id(self), body))\n            Logger.debug('UrlRequest: {0} - headers: {1}'.format(\n                id(self), headers))\n\n        req, resp = self.call_request(body, headers)\n\n        # read content\n        if report_progress or file_path is not None:\n            total_size = self.get_total_size(resp)\n\n            # before starting the download, send a fake progress to permit the\n            # user to initialize his ui\n            if report_progress:\n                q(('progress', resp, (0, total_size)))\n\n            if file_path is not None:\n                with open(file_path, 'wb') as fd:\n                    bytes_so_far, result = self.get_chunks(\n                        resp, chunk_size, total_size, report_progress, q,\n                        trigger, fd=fd\n                    )\n            else:\n                bytes_so_far, result = self.get_chunks(\n                    resp, chunk_size, total_size, report_progress, q, trigger\n                )\n\n            # ensure that results are dispatched for the last chunk,\n            # avoid trigger\n            if report_progress:\n                q(('progress', resp, (bytes_so_far, total_size)))\n                trigger()\n        else:\n            result = self.get_response(resp)\n            try:\n                if isinstance(result, bytes):\n                    result = result.decode('utf-8')\n            except UnicodeDecodeError:\n                # if it's an image? decoding would not work\n                pass\n\n        self.close_connection(req)\n\n        # return everything\n        return result, resp",
  "def decode_result(self, result, resp):\n        '''Decode the result fetched from url according to his Content-Type.\n        Currently supports only application/json.\n        '''\n        # Entry to decode url from the content type.\n        # For example, if the content type is a json, it will be automatically\n        # decoded.\n        content_type = self.get_content_type(resp)\n        if content_type is not None:\n            ct = content_type.split(';')[0]\n            if ct == 'application/json':\n                if isinstance(result, bytes):\n                    result = result.decode('utf-8')\n                try:\n                    return loads(result)\n                except Exception:\n                    return result\n\n        return result",
  "def _dispatch_result(self, dt):\n        while True:\n            # Read the result pushed on the queue, and dispatch to the client\n            try:\n                result, resp, data = self._queue.pop()\n            except IndexError:\n                return\n\n            if resp:\n                # Small workaround in order to prevent the situation mentioned\n                # in the comment below\n                final_cookies = \"\"\n                parsed_headers = []\n                for key, value in self.get_all_headers(resp):\n                    if key == \"Set-Cookie\":\n                        final_cookies += \"{};\".format(value)\n                    else:\n                        parsed_headers.append((key, value))\n                parsed_headers.append((\"Set-Cookie\", final_cookies[:-1]))\n\n                # XXX usage of dict can be dangerous if multiple headers\n                # are set even if it's invalid. But it look like it's ok\n                # ?  http://stackoverflow.com/questions/2454494/..\n                # ..urllib2-multiple-set-cookie-headers-in-response\n                self._resp_headers = dict(parsed_headers)\n                self._resp_status = self.get_status_code(resp)\n\n            if result == 'success':\n                status_class = self.get_status_code(resp) // 100\n\n                if status_class in (1, 2):\n                    if self._debug:\n                        Logger.debug(\n                            'UrlRequest: {0} Download finished with '\n                            '{1} datalen'.format(id(self), data)\n                        )\n                    self._is_finished = True\n                    self._result = data\n                    if self.on_success:\n                        func = self.on_success()\n                        if func:\n                            func(self, data)\n\n                elif status_class == 3:\n                    if self._debug:\n                        Logger.debug('UrlRequest: {} Download '\n                                     'redirected'.format(id(self)))\n                    self._is_finished = True\n                    self._result = data\n                    if self.on_redirect:\n                        func = self.on_redirect()\n                        if func:\n                            func(self, data)\n\n                elif status_class in (4, 5):\n                    if self._debug:\n                        Logger.debug(\n                            'UrlRequest: {} Download failed with '\n                            'http error {}'.format(\n                                id(self),\n                                self.get_status_code(resp)\n                            )\n                        )\n                    self._is_finished = True\n                    self._result = data\n                    if self.on_failure:\n                        func = self.on_failure()\n                        if func:\n                            func(self, data)\n\n            elif result == 'error':\n                if self._debug:\n                    Logger.debug('UrlRequest: {0} Download error '\n                                 '<{1}>'.format(id(self), data))\n                self._is_finished = True\n                self._error = data\n                if self.on_error:\n                    func = self.on_error()\n                    if func:\n                        func(self, data)\n\n            elif result == 'progress':\n                if self._debug:\n                    Logger.debug('UrlRequest: {0} Download progress '\n                                 '{1}'.format(id(self), data))\n                if self.on_progress:\n                    func = self.on_progress()\n                    if func:\n                        func(self, data[0], data[1])\n\n            elif result == 'killed':\n                if self._debug:\n                    Logger.debug('UrlRequest: Cancelled by user')\n                if self.on_cancel:\n                    func = self.on_cancel()\n                    if func:\n                        func(self)\n\n            else:\n                assert 0\n\n            if result != \"progress\" and self.on_finish:\n                if self._debug:\n                    Logger.debug('UrlRequest: Request is finished')\n                func = self.on_finish()\n                if func:\n                    func(self)",
  "def is_finished(self):\n        '''Return True if the request has finished, whether it's a\n        success or a failure.\n        '''\n        return self._is_finished",
  "def result(self):\n        '''Return the result of the request.\n        This value is not determined until the request is finished.\n        '''\n        return self._result",
  "def resp_headers(self):\n        '''If the request has been completed, return a dictionary containing\n        the headers of the response. Otherwise, it will return None.\n        '''\n        return self._resp_headers",
  "def resp_status(self):\n        '''Return the status code of the response if the request is complete,\n        otherwise return None.\n        '''\n        return self._resp_status",
  "def error(self):\n        '''Return the error of the request.\n        This value is not determined until the request is completed.\n        '''\n        return self._error",
  "def chunk_size(self):\n        '''Return the size of a chunk, used only in \"progress\" mode (when\n        on_progress callback is set.)\n        '''\n        return self._chunk_size",
  "def wait(self, delay=0.5):\n        '''Wait for the request to finish (until :attr:`resp_status` is not\n        None)\n\n        .. note::\n            This method is intended to be used in the main thread, and the\n            callback will be dispatched from the same thread\n            from which you're calling.\n\n        .. versionadded:: 1.1.0\n        '''\n        while self.resp_status is None:\n            self._dispatch_result(delay)\n            sleep(delay)",
  "def cancel(self):\n        '''Cancel the current request. It will be aborted, and the result\n        will not be dispatched. Once cancelled, the callback on_cancel will\n        be called.\n\n        .. versionadded:: 1.11.0\n        '''\n        self._cancel_event.set()",
  "def get_chunks(\n        self, resp, chunk_size, total_size, report_progress, q,\n        trigger, fd=None\n    ):\n        bytes_so_far = 0\n        result = b''\n\n        while 1:\n            chunk = resp.read(chunk_size)\n            if not chunk:\n                break\n\n            if fd:\n                fd.write(chunk)\n\n            else:\n                result += chunk\n\n            bytes_so_far += len(chunk)\n\n            if report_progress:\n                q(('progress', resp, (bytes_so_far, total_size)))\n                trigger()\n\n            if self._cancel_event.is_set():\n                break\n\n        return bytes_so_far, result",
  "def get_response(self, resp):\n        return resp.read()",
  "def get_total_size(self, resp):\n        try:\n            return int(resp.getheader('content-length'))\n        except Exception:\n            return -1",
  "def get_content_type(self, resp):\n        return resp.getheader('Content-Type', None)",
  "def get_status_code(self, resp):\n        return resp.status",
  "def get_all_headers(self, resp):\n        return resp.getheaders()",
  "def close_connection(self, req):\n        req.close()",
  "def _parse_url(self, url):\n        parse = urlparse(url)\n        host = parse.hostname\n        port = parse.port\n        userpass = None\n\n        # append user + pass to hostname if specified\n        if parse.username and parse.password:\n            userpass = {\n                \"Authorization\": \"Basic {}\".format(b64encode(\n                    \"{}:{}\".format(\n                        parse.username,\n                        parse.password\n                    ).encode('utf-8')\n                ).decode('utf-8'))\n            }\n\n        return host, port, userpass, parse",
  "def _get_connection_for_scheme(self, scheme):\n        '''Return the Connection class for a particular scheme.\n        This is an internal function that can be expanded to support custom\n        schemes.\n\n        Actual supported schemes: http, https.\n        '''\n        if scheme == 'http':\n            return HTTPConnection\n        elif scheme == 'https' and HTTPSConnection is not None:\n            return HTTPSConnection\n        else:\n            raise Exception('No class for scheme %s' % scheme)",
  "def call_request(self, body, headers):\n        timeout = self._timeout\n        ca_file = self.ca_file\n        verify = self.verify\n        url = self._requested_url\n\n        # parse url\n        host, port, userpass, parse = self._parse_url(url)\n        if userpass and not headers:\n            headers = userpass\n        elif userpass and headers:\n            key = list(userpass.keys())[0]\n            headers[key] = userpass[key]\n\n        # translate scheme to connection class\n        cls = self._get_connection_for_scheme(parse.scheme)\n\n        # reconstruct path to pass on the request\n        path = parse.path\n        if parse.params:\n            path += ';' + parse.params\n        if parse.query:\n            path += '?' + parse.query\n        if parse.fragment:\n            path += '#' + parse.fragment\n\n        # create connection instance\n        args = {}\n        if timeout is not None:\n            args['timeout'] = timeout\n\n        if (ca_file is not None and hasattr(ssl, 'create_default_context') and\n                parse.scheme == 'https'):\n            ctx = ssl.create_default_context(cafile=ca_file)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            args['context'] = ctx\n\n        if not verify and parse.scheme == 'https' and (\n            hasattr(ssl, 'create_default_context')):\n            ctx = ssl.create_default_context()\n            ctx.check_hostname = False\n            ctx.verify_mode = ssl.CERT_NONE\n            args['context'] = ctx\n\n        if self._proxy_host:\n            Logger.debug('UrlRequest: {0} - proxy via {1}:{2}'.format(\n                id(self), self._proxy_host, self._proxy_port\n            ))\n            req = cls(self._proxy_host, self._proxy_port, **args)\n            if parse.scheme == 'https':\n                req.set_tunnel(host, port, self._proxy_headers)\n            else:\n                path = urlunparse(parse)\n        else:\n            req = cls(host, port, **args)\n\n        # send request\n        method = self._method\n        if method is None:\n            method = 'GET' if body is None else 'POST'\n\n        req.request(method, path, body, headers or {})\n\n        # read header\n        return req, req.getresponse()",
  "def get_chunks(\n        self, resp, chunk_size, total_size, report_progress, q,\n        trigger, fd=None\n    ):\n        bytes_so_far = 0\n        result = b''\n\n        for chunk in resp.iter_content(chunk_size):\n            if not chunk:\n                break\n\n            if fd:\n                fd.write(chunk)\n\n            else:\n                result += chunk\n\n            bytes_so_far += len(chunk)\n\n            if report_progress:\n                q(('progress', resp, (bytes_so_far, total_size)))\n                trigger()\n\n            if self._cancel_event.is_set():\n                break\n\n        return bytes_so_far, result",
  "def get_response(self, resp):\n        return resp.content",
  "def get_total_size(self, resp):\n        return int(resp.headers.get('Content-Length', -1))",
  "def get_content_type(self, resp):\n        return resp.headers.get('Content-Type', None)",
  "def get_status_code(self, resp):\n        return resp.status_code",
  "def get_all_headers(self, resp):\n        return resp.headers.items()",
  "def close_connection(self, req):\n        pass",
  "def call_request(self, body, headers):\n        timeout = self._timeout\n        ca_file = self.ca_file\n        verify = self.verify\n        url = self._requested_url\n        auth = self._auth\n\n        req = requests\n        kwargs = {}\n\n        # get method\n        if self._method is None:\n            method = 'get' if body is None else 'post'\n        else:\n            method = self._method.lower()\n\n        req_call = getattr(req, method)\n\n        if auth:\n            kwargs[\"auth\"] = auth\n\n        # send request\n        response = req_call(\n            url,\n            data=body,\n            headers=headers,\n            timeout=timeout,\n            verify=verify,\n            cert=ca_file,\n            **kwargs\n        )\n\n        return None, response",
  "class CoreCriticalException(Exception):\n    pass",
  "def core_select_lib(category, llist, create_instance=False,\n                    base='kivy.core', basemodule=None):\n    if 'KIVY_DOC' in os.environ:\n        return\n    category = category.lower()\n    basemodule = basemodule or category\n    libs_ignored = []\n    errs = []\n    for option, modulename, classname in llist:\n        try:\n            # module activated in config ?\n            try:\n                if option not in kivy.kivy_options[category]:\n                    libs_ignored.append(modulename)\n                    Logger.debug(\n                        '{0}: Provider <{1}> ignored by config'.format(\n                            category.capitalize(), option))\n                    continue\n            except KeyError:\n                pass\n\n            # import module\n            mod = importlib.__import__(name='{2}.{0}.{1}'.format(\n                basemodule, modulename, base),\n                globals=globals(),\n                locals=locals(),\n                fromlist=[modulename], level=0)\n            cls = mod.__getattribute__(classname)\n\n            # ok !\n            Logger.info('{0}: Provider: {1}{2}'.format(\n                category.capitalize(), option,\n                '({0} ignored)'.format(libs_ignored) if libs_ignored else ''))\n            if create_instance:\n                cls = cls()\n            return cls\n\n        except ImportError as e:\n            errs.append((option, e, sys.exc_info()[2]))\n            libs_ignored.append(modulename)\n            Logger.debug('{0}: Ignored <{1}> (import error)'.format(\n                category.capitalize(), option))\n            Logger.trace('', exc_info=e)\n\n        except CoreCriticalException as e:\n            errs.append((option, e, sys.exc_info()[2]))\n            Logger.error('{0}: Unable to use {1}'.format(\n                category.capitalize(), option))\n            Logger.error(\n                '{0}: The module raised an important error: {1!r}'.format(\n                    category.capitalize(), e.message))\n            raise\n\n        except Exception as e:\n            errs.append((option, e, sys.exc_info()[2]))\n            libs_ignored.append(modulename)\n            Logger.trace('{0}: Unable to use {1}'.format(\n                category.capitalize(), option))\n            Logger.trace('', exc_info=e)\n\n    err = '\\n'.join(['{} - {}: {}\\n{}'.format(opt, e.__class__.__name__, e,\n                   ''.join(traceback.format_tb(tb))) for opt, e, tb in errs])\n    Logger.critical(\n        '{0}: Unable to find any valuable {0} provider. Please enable '\n        'debug logging (e.g. add -d if running from the command line, or '\n        'change the log level in the config) and re-run your app to '\n        'identify potential causes\\n{1}'.format(category.capitalize(), err))",
  "def core_register_libs(category, libs, base='kivy.core'):\n    if 'KIVY_DOC' in os.environ:\n        return\n    category = category.lower()\n    kivy_options = kivy.kivy_options[category]\n    libs_loadable = {}\n    libs_ignored = []\n\n    for option, lib in libs:\n        # module activated in config ?\n        if option not in kivy_options:\n            Logger.debug('{0}: option <{1}> ignored by config'.format(\n                category.capitalize(), option))\n            libs_ignored.append(lib)\n            continue\n        libs_loadable[option] = lib\n\n    libs_loaded = []\n    for item in kivy_options:\n        try:\n            # import module\n            try:\n                lib = libs_loadable[item]\n            except KeyError:\n                continue\n            importlib.__import__(name='{2}.{0}.{1}'.format(category, lib, base),\n                       globals=globals(),\n                       locals=locals(),\n                       fromlist=[lib],\n                       level=0)\n\n            libs_loaded.append(lib)\n\n        except Exception as e:\n            Logger.trace('{0}: Unable to use <{1}> as loader!'.format(\n                category.capitalize(), option))\n            Logger.trace('', exc_info=e)\n            libs_ignored.append(lib)\n\n    Logger.info('{0}: Providers: {1} {2}'.format(\n        category.capitalize(),\n        ', '.join(libs_loaded),\n        '({0} ignored)'.format(\n            ', '.join(libs_ignored)) if libs_ignored else ''))\n    return libs_loaded",
  "def handle_win_lib_import_error(category, provider, mod_name):\n    if sys.platform != 'win32':\n        return\n\n    assert mod_name.startswith('kivy.')\n    kivy_root = os.path.dirname(kivy.__file__)\n    dirs = mod_name[5:].split('.')\n    mod_path = os.path.join(kivy_root, *dirs)\n\n    # get the full expected path to the compiled pyd file\n    # filename is <debug>.cp<major><minor>-<platform>.pyd\n    # https://github.com/python/cpython/blob/master/Doc/whatsnew/3.5.rst\n    if hasattr(sys, 'gettotalrefcount'):  # debug\n        mod_path += '._d'\n    mod_path += '.cp{}{}-{}.pyd'.format(\n        sys.version_info.major, sys.version_info.minor,\n        sysconfig.get_platform().replace('-', '_'))\n\n    # does the compiled pyd exist at all?\n    if not os.path.exists(mod_path):\n        Logger.debug(\n            '{}: Failed trying to import \"{}\" for provider {}. Compiled file '\n            'does not exist. Have you perhaps forgotten to compile Kivy, or '\n            'did not install all required dependencies?'.format(\n                category, provider, mod_path))\n        return\n\n    # tell user to provide dependency walker\n    env_var = 'KIVY_{}_DEPENDENCY_WALKER'.format(provider.upper())\n    if env_var not in os.environ:\n        Logger.debug(\n            '{0}: Failed trying to import the \"{1}\" provider from \"{2}\". '\n            'This error is often encountered when a dependency is missing,'\n            ' or if there are multiple copies of the same dependency dll on '\n            'the Windows PATH and they are incompatible with each other. '\n            'This can occur if you are mixing installations (such as different'\n            ' python installations, like anaconda python and a system python) '\n            'or if another unrelated program added its directory to the PATH. '\n            'Please examine your PATH and python installation for potential '\n            'issues. To further troubleshoot a \"DLL load failed\" error, '\n            'please download '\n            '\"Dependency Walker\" (64 or 32 bit version - matching your python '\n            'bitness) from dependencywalker.com and set the environment '\n            'variable {3} to the full path of the downloaded depends.exe file '\n            'and rerun your application to generate an error report'.\n            format(category, provider, mod_path, env_var))\n        return\n\n    depends_bin = os.environ[env_var]\n    if not os.path.exists(depends_bin):\n        raise ValueError('\"{}\" provided in {} does not exist'.format(\n            depends_bin, env_var))\n\n    # make file for the resultant log\n    fd, temp_file = tempfile.mkstemp(\n        suffix='.dwi', prefix='kivy_depends_{}_log_'.format(provider),\n        dir=os.path.expanduser('~/'))\n    os.close(fd)\n\n    Logger.info(\n        '{}: Running dependency walker \"{}\" on \"{}\" to generate '\n        'troubleshooting log. Please wait for it to complete'.format(\n            category, depends_bin, mod_path))\n    Logger.debug(\n        '{}: Dependency walker command is \"{}\"'.format(\n            category,\n            [depends_bin, '/c', '/od:{}'.format(temp_file), mod_path]))\n\n    try:\n        subprocess.check_output([\n            depends_bin, '/c', '/od:{}'.format(temp_file), mod_path])\n    except subprocess.CalledProcessError as exc:\n        if exc.returncode >= 0x00010000:\n            Logger.error(\n                '{}: Dependency walker failed with error code \"{}\". No '\n                'error report was generated'.\n                format(category, exc.returncode))\n            return\n\n    Logger.info(\n        '{}: dependency walker generated \"{}\" containing troubleshooting '\n        'information about provider {} and its failing file \"{} ({})\". You '\n        'can open the file in dependency walker to view any potential issues '\n        'and troubleshoot it yourself. '\n        'To share the file with the Kivy developers and request support, '\n        'please contact us at our support channels '\n        'https://kivy.org/doc/master/contact.html (not on github, unless '\n        'it\\'s truly a bug). Make sure to provide the generated file as well '\n        'as the *complete* Kivy log being printed here. Keep in mind the '\n        'generated dependency walker log file contains paths to dlls on your '\n        'system used by kivy or its dependencies to help troubleshoot them, '\n        'and these paths may include your name in them. Please view the '\n        'log file in dependency walker before sharing to ensure you are not '\n        'sharing sensitive paths'.format(\n            category, temp_file, provider, mod_name, mod_path))",
  "class WindowPygame(WindowBase):\n\n    @deprecated(\n        msg='Pygame has been deprecated and will be removed after 1.11.0')\n    def __init__(self, *largs, **kwargs):\n        super(WindowPygame, self).__init__(*largs, **kwargs)\n\n    def create_window(self, *largs):\n        # ensure the mouse is still not up after window creation, otherwise, we\n        # have some weird bugs\n        self.dispatch('on_mouse_up', 0, 0, 'all', [])\n\n        # force display to show (available only for fullscreen)\n        displayidx = Config.getint('graphics', 'display')\n        if 'SDL_VIDEO_FULLSCREEN_HEAD' not in environ and displayidx != -1:\n            environ['SDL_VIDEO_FULLSCREEN_HEAD'] = '%d' % displayidx\n\n        # init some opengl, same as before.\n        self.flags = pygame.HWSURFACE | pygame.OPENGL | pygame.DOUBLEBUF\n\n        # right now, activate resizable window only on linux.\n        # on window / macosx, the opengl context is lost, and we need to\n        # reconstruct everything. Check #168 for a state of the work.\n        if platform in ('linux', 'macosx', 'win') and \\\n                Config.getboolean('graphics', 'resizable'):\n            self.flags |= pygame.RESIZABLE\n\n        try:\n            pygame.display.init()\n        except pygame.error as e:\n            raise CoreCriticalException(e.message)\n\n        multisamples = Config.getint('graphics', 'multisamples')\n\n        if multisamples > 0:\n            pygame.display.gl_set_attribute(pygame.GL_MULTISAMPLEBUFFERS, 1)\n            pygame.display.gl_set_attribute(pygame.GL_MULTISAMPLESAMPLES,\n                                            multisamples)\n        pygame.display.gl_set_attribute(pygame.GL_DEPTH_SIZE, 16)\n        pygame.display.gl_set_attribute(pygame.GL_STENCIL_SIZE, 1)\n        pygame.display.set_caption(self.title)\n\n        if self.position == 'auto':\n            self._pos = None\n        elif self.position == 'custom':\n            self._pos = self.left, self.top\n        else:\n            raise ValueError('position token in configuration accept only '\n                             '\"auto\" or \"custom\"')\n\n        if self._fake_fullscreen:\n            if not self.borderless:\n                self.fullscreen = self._fake_fullscreen = False\n            elif not self.fullscreen or self.fullscreen == 'auto':\n                self.borderless = self._fake_fullscreen = False\n\n        if self.fullscreen == 'fake':\n            self.borderless = self._fake_fullscreen = True\n            Logger.warning(\"The 'fake' fullscreen option has been \"\n                            \"deprecated, use Window.borderless or the \"\n                            \"borderless Config option instead.\")\n\n        if self.fullscreen == 'fake' or self.borderless:\n            Logger.debug('WinPygame: Set window to borderless mode.')\n\n            self.flags |= pygame.NOFRAME\n            # If no position set in borderless mode, we always need\n            # to set the position. So use 0, 0.\n            if self._pos is None:\n                self._pos = (0, 0)\n            environ['SDL_VIDEO_WINDOW_POS'] = '%d,%d' % self._pos\n\n        elif self.fullscreen in ('auto', True):\n            Logger.debug('WinPygame: Set window to fullscreen mode')\n            self.flags |= pygame.FULLSCREEN\n\n        elif self._pos is not None:\n            environ['SDL_VIDEO_WINDOW_POS'] = '%d,%d' % self._pos\n\n        # never stay with a None pos, application using w.center will be fired.\n        self._pos = (0, 0)\n\n        # prepare keyboard\n        repeat_delay = int(Config.get('kivy', 'keyboard_repeat_delay'))\n        repeat_rate = float(Config.get('kivy', 'keyboard_repeat_rate'))\n        pygame.key.set_repeat(repeat_delay, int(1000. / repeat_rate))\n\n        # set window icon before calling set_mode\n        try:\n            filename_icon = self.icon or Config.get('kivy', 'window_icon')\n            if filename_icon == '':\n                logo_size = 32\n                if platform == 'macosx':\n                    logo_size = 512\n                elif platform == 'win':\n                    logo_size = 64\n                filename_icon = 'kivy-icon-{}.png'.format(logo_size)\n                filename_icon = resource_find(\n                        join(kivy_data_dir, 'logo', filename_icon))\n            self.set_icon(filename_icon)\n        except:\n            Logger.exception('Window: cannot set icon')\n\n        # try to use mode with multisamples\n        try:\n            self._pygame_set_mode()\n        except pygame.error as e:\n            if multisamples:\n                Logger.warning('WinPygame: Video: failed (multisamples=%d)' %\n                               multisamples)\n                Logger.warning('WinPygame: trying without antialiasing')\n                pygame.display.gl_set_attribute(\n                    pygame.GL_MULTISAMPLEBUFFERS, 0)\n                pygame.display.gl_set_attribute(\n                    pygame.GL_MULTISAMPLESAMPLES, 0)\n                multisamples = 0\n                try:\n                    self._pygame_set_mode()\n                except pygame.error as e:\n                    raise CoreCriticalException(e.message)\n            else:\n                raise CoreCriticalException(e.message)\n\n        if pygame.RESIZABLE & self.flags:\n            self._pygame_set_mode()\n\n        info = pygame.display.Info()\n        self._size = (info.current_w, info.current_h)\n        # self.dispatch('on_resize', *self._size)\n\n        # in order to debug futur issue with pygame/display, let's show\n        # more debug output.\n        Logger.debug('Window: Display driver ' + pygame.display.get_driver())\n        Logger.debug('Window: Actual window size: %dx%d',\n                     info.current_w, info.current_h)\n        if platform != 'android':\n            # unsupported platform, such as android that doesn't support\n            # gl_get_attribute.\n            Logger.debug(\n                'Window: Actual color bits r%d g%d b%d a%d',\n                pygame.display.gl_get_attribute(pygame.GL_RED_SIZE),\n                pygame.display.gl_get_attribute(pygame.GL_GREEN_SIZE),\n                pygame.display.gl_get_attribute(pygame.GL_BLUE_SIZE),\n                pygame.display.gl_get_attribute(pygame.GL_ALPHA_SIZE))\n            Logger.debug(\n                'Window: Actual depth bits: %d',\n                pygame.display.gl_get_attribute(pygame.GL_DEPTH_SIZE))\n            Logger.debug(\n                'Window: Actual stencil bits: %d',\n                pygame.display.gl_get_attribute(pygame.GL_STENCIL_SIZE))\n            Logger.debug(\n                'Window: Actual multisampling samples: %d',\n                pygame.display.gl_get_attribute(pygame.GL_MULTISAMPLESAMPLES))\n        super(WindowPygame, self).create_window()\n\n        # set mouse visibility\n        self._set_cursor_state(self.show_cursor)\n\n        # if we are on android platform, automatically create hooks\n        if android:\n            from kivy.support import install_android\n            install_android()\n\n    def close(self):\n        pygame.display.quit()\n        super(WindowPygame, self).close()\n\n    def on_title(self, instance, value):\n        if self.initialized:\n            pygame.display.set_caption(self.title)\n\n    def set_icon(self, filename):\n        if not exists(filename):\n            return False\n        try:\n            if platform == 'win':\n                try:\n                    if self._set_icon_win(filename):\n                        return True\n                except:\n                    # fallback on standard loading then.\n                    pass\n\n            # for all others platform, or if the ico is not available, use the\n            # default way to set it.\n            self._set_icon_standard(filename)\n            super(WindowPygame, self).set_icon(filename)\n        except:\n            Logger.exception('WinPygame: unable to set icon')\n\n    def _set_icon_standard(self, filename):\n        if PY2:\n            try:\n                im = pygame.image.load(filename)\n            except UnicodeEncodeError:\n                im = pygame.image.load(filename.encode('utf8'))\n        else:\n            im = pygame.image.load(filename)\n        if im is None:\n            raise Exception('Unable to load window icon (not found)')\n        pygame.display.set_icon(im)\n\n    def _set_icon_win(self, filename):\n        # ensure the window ico is ended by ico\n        if not filename.endswith('.ico'):\n            filename = '{}.ico'.format(filename.rsplit('.', 1)[0])\n        if not exists(filename):\n            return False\n\n        import win32api\n        import win32gui\n        import win32con\n        hwnd = pygame.display.get_wm_info()['window']\n        icon_big = win32gui.LoadImage(\n            None, filename, win32con.IMAGE_ICON,\n            48, 48, win32con.LR_LOADFROMFILE)\n        icon_small = win32gui.LoadImage(\n            None, filename, win32con.IMAGE_ICON,\n            16, 16, win32con.LR_LOADFROMFILE)\n        win32api.SendMessage(\n            hwnd, win32con.WM_SETICON, win32con.ICON_SMALL, icon_small)\n        win32api.SendMessage(\n            hwnd, win32con.WM_SETICON, win32con.ICON_BIG, icon_big)\n        return True\n\n    def _set_cursor_state(self, value):\n        pygame.mouse.set_visible(value)\n\n    def screenshot(self, *largs, **kwargs):\n        global glReadPixels, GL_RGBA, GL_UNSIGNED_BYTE\n        filename = super(WindowPygame, self).screenshot(*largs, **kwargs)\n        if filename is None:\n            return None\n        if glReadPixels is None:\n            from kivy.graphics.opengl import (glReadPixels, GL_RGBA,\n                                              GL_UNSIGNED_BYTE)\n        width, height = self.system_size\n        data = glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE)\n        data = bytes(bytearray(data))\n        surface = pygame.image.fromstring(data, (width, height), 'RGBA', True)\n        pygame.image.save(surface, filename)\n        Logger.debug('Window: Screenshot saved at <%s>' % filename)\n        return filename\n\n    def flip(self):\n        pygame.display.flip()\n        super(WindowPygame, self).flip()\n\n    def mainloop(self):\n        for event in pygame.event.get():\n\n            # kill application (SIG_TERM)\n            if event.type == pygame.QUIT:\n                if self.dispatch('on_request_close'):\n                    continue\n                EventLoop.quit = True\n                self.close()\n\n            # mouse move\n            elif event.type == pygame.MOUSEMOTION:\n                x, y = event.pos\n                self.mouse_pos = x, self.system_size[1] - y\n                # don't dispatch motion if no button are pressed\n                if event.buttons == (0, 0, 0):\n                    continue\n                self._mouse_x = x\n                self._mouse_y = y\n                self._mouse_meta = self.modifiers\n                self.dispatch('on_mouse_move', x, y, self.modifiers)\n\n            # mouse action\n            elif event.type in (pygame.MOUSEBUTTONDOWN,\n                                pygame.MOUSEBUTTONUP):\n                self._pygame_update_modifiers()\n                x, y = event.pos\n                btn = 'left'\n                if event.button == 3:\n                    btn = 'right'\n                elif event.button == 2:\n                    btn = 'middle'\n                elif event.button == 4:\n                    btn = 'scrolldown'\n                elif event.button == 5:\n                    btn = 'scrollup'\n                elif event.button == 6:\n                    btn = 'scrollright'\n                elif event.button == 7:\n                    btn = 'scrollleft'\n                eventname = 'on_mouse_down'\n                if event.type == pygame.MOUSEBUTTONUP:\n                    eventname = 'on_mouse_up'\n                self._mouse_x = x\n                self._mouse_y = y\n                self._mouse_meta = self.modifiers\n                self._mouse_btn = btn\n                self._mouse_down = eventname == 'on_mouse_down'\n                self.dispatch(eventname, x, y, btn, self.modifiers)\n\n            # joystick action\n            elif event.type == pygame.JOYAXISMOTION:\n                self.dispatch('on_joy_axis', event.joy, event.axis,\n                                event.value)\n\n            elif event.type == pygame.JOYHATMOTION:\n                self.dispatch('on_joy_hat', event.joy, event.hat, event.value)\n\n            elif event.type == pygame.JOYBALLMOTION:\n                self.dispatch('on_joy_ball', event.joy, event.ballid,\n                            event.rel[0], event.rel[1])\n\n            elif event.type == pygame.JOYBUTTONDOWN:\n                self.dispatch('on_joy_button_down', event.joy, event.button)\n\n            elif event.type == pygame.JOYBUTTONUP:\n                self.dispatch('on_joy_button_up', event.joy, event.button)\n\n            # keyboard action\n            elif event.type in (pygame.KEYDOWN, pygame.KEYUP):\n                self._pygame_update_modifiers(event.mod)\n                # atm, don't handle keyup\n                if event.type == pygame.KEYUP:\n                    self.dispatch('on_key_up', event.key,\n                                  event.scancode)\n                    continue\n\n                # don't dispatch more key if down event is accepted\n                if self.dispatch('on_key_down', event.key,\n                                 event.scancode, event.unicode,\n                                 self.modifiers):\n                    continue\n                self.dispatch('on_keyboard', event.key,\n                              event.scancode, event.unicode,\n                              self.modifiers)\n\n            # video resize\n            elif event.type == pygame.VIDEORESIZE:\n                self._size = event.size\n                self.update_viewport()\n\n            elif event.type == pygame.VIDEOEXPOSE:\n                self.canvas.ask_update()\n\n            # ignored event\n            elif event.type == pygame.ACTIVEEVENT:\n                pass\n\n            # drop file (pygame patch needed)\n            elif event.type == pygame.USEREVENT and \\\n                    hasattr(pygame, 'USEREVENT_DROPFILE') and \\\n                    event.code == pygame.USEREVENT_DROPFILE:\n                drop_x, drop_y = pygame.mouse.get_pos()\n                self.dispatch('on_drop_file', event.filename, drop_x, drop_y)\n\n            '''\n            # unhandled event !\n            else:\n                Logger.debug('WinPygame: Unhandled event %s' % str(event))\n            '''\n        if not pygame.display.get_active():\n            pygame.time.wait(100)\n\n    #\n    # Pygame wrapper\n    #\n    def _pygame_set_mode(self, size=None):\n        if size is None:\n            size = self.size\n        if self.fullscreen == 'auto':\n            pygame.display.set_mode((0, 0), self.flags)\n        else:\n            pygame.display.set_mode(size, self.flags)\n\n    def _pygame_update_modifiers(self, mods=None):\n        # Available mod, from dir(pygame)\n        # 'KMOD_ALT', 'KMOD_CAPS', 'KMOD_CTRL', 'KMOD_LALT',\n        # 'KMOD_LCTRL', 'KMOD_LMETA', 'KMOD_LSHIFT', 'KMOD_META',\n        # 'KMOD_MODE', 'KMOD_NONE'\n        if mods is None:\n            mods = pygame.key.get_mods()\n        self._modifiers = []\n        if mods & (pygame.KMOD_SHIFT | pygame.KMOD_LSHIFT):\n            self._modifiers.append('shift')\n        if mods & (pygame.KMOD_ALT | pygame.KMOD_LALT):\n            self._modifiers.append('alt')\n        if mods & (pygame.KMOD_CTRL | pygame.KMOD_LCTRL):\n            self._modifiers.append('ctrl')\n        if mods & (pygame.KMOD_META | pygame.KMOD_LMETA):\n            self._modifiers.append('meta')\n\n    def request_keyboard(\n            self, callback, target, input_type='text', keyboard_suggestions=True\n    ):\n        keyboard = super(WindowPygame, self).request_keyboard(\n            callback, target, input_type, keyboard_suggestions)\n        if android and not self.allow_vkeyboard:\n            android.show_keyboard(target, input_type)\n        return keyboard\n\n    def release_keyboard(self, *largs):\n        super(WindowPygame, self).release_keyboard(*largs)\n        if android:\n            android.hide_keyboard()\n        return True",
  "def __init__(self, *largs, **kwargs):\n        super(WindowPygame, self).__init__(*largs, **kwargs)",
  "def create_window(self, *largs):\n        # ensure the mouse is still not up after window creation, otherwise, we\n        # have some weird bugs\n        self.dispatch('on_mouse_up', 0, 0, 'all', [])\n\n        # force display to show (available only for fullscreen)\n        displayidx = Config.getint('graphics', 'display')\n        if 'SDL_VIDEO_FULLSCREEN_HEAD' not in environ and displayidx != -1:\n            environ['SDL_VIDEO_FULLSCREEN_HEAD'] = '%d' % displayidx\n\n        # init some opengl, same as before.\n        self.flags = pygame.HWSURFACE | pygame.OPENGL | pygame.DOUBLEBUF\n\n        # right now, activate resizable window only on linux.\n        # on window / macosx, the opengl context is lost, and we need to\n        # reconstruct everything. Check #168 for a state of the work.\n        if platform in ('linux', 'macosx', 'win') and \\\n                Config.getboolean('graphics', 'resizable'):\n            self.flags |= pygame.RESIZABLE\n\n        try:\n            pygame.display.init()\n        except pygame.error as e:\n            raise CoreCriticalException(e.message)\n\n        multisamples = Config.getint('graphics', 'multisamples')\n\n        if multisamples > 0:\n            pygame.display.gl_set_attribute(pygame.GL_MULTISAMPLEBUFFERS, 1)\n            pygame.display.gl_set_attribute(pygame.GL_MULTISAMPLESAMPLES,\n                                            multisamples)\n        pygame.display.gl_set_attribute(pygame.GL_DEPTH_SIZE, 16)\n        pygame.display.gl_set_attribute(pygame.GL_STENCIL_SIZE, 1)\n        pygame.display.set_caption(self.title)\n\n        if self.position == 'auto':\n            self._pos = None\n        elif self.position == 'custom':\n            self._pos = self.left, self.top\n        else:\n            raise ValueError('position token in configuration accept only '\n                             '\"auto\" or \"custom\"')\n\n        if self._fake_fullscreen:\n            if not self.borderless:\n                self.fullscreen = self._fake_fullscreen = False\n            elif not self.fullscreen or self.fullscreen == 'auto':\n                self.borderless = self._fake_fullscreen = False\n\n        if self.fullscreen == 'fake':\n            self.borderless = self._fake_fullscreen = True\n            Logger.warning(\"The 'fake' fullscreen option has been \"\n                            \"deprecated, use Window.borderless or the \"\n                            \"borderless Config option instead.\")\n\n        if self.fullscreen == 'fake' or self.borderless:\n            Logger.debug('WinPygame: Set window to borderless mode.')\n\n            self.flags |= pygame.NOFRAME\n            # If no position set in borderless mode, we always need\n            # to set the position. So use 0, 0.\n            if self._pos is None:\n                self._pos = (0, 0)\n            environ['SDL_VIDEO_WINDOW_POS'] = '%d,%d' % self._pos\n\n        elif self.fullscreen in ('auto', True):\n            Logger.debug('WinPygame: Set window to fullscreen mode')\n            self.flags |= pygame.FULLSCREEN\n\n        elif self._pos is not None:\n            environ['SDL_VIDEO_WINDOW_POS'] = '%d,%d' % self._pos\n\n        # never stay with a None pos, application using w.center will be fired.\n        self._pos = (0, 0)\n\n        # prepare keyboard\n        repeat_delay = int(Config.get('kivy', 'keyboard_repeat_delay'))\n        repeat_rate = float(Config.get('kivy', 'keyboard_repeat_rate'))\n        pygame.key.set_repeat(repeat_delay, int(1000. / repeat_rate))\n\n        # set window icon before calling set_mode\n        try:\n            filename_icon = self.icon or Config.get('kivy', 'window_icon')\n            if filename_icon == '':\n                logo_size = 32\n                if platform == 'macosx':\n                    logo_size = 512\n                elif platform == 'win':\n                    logo_size = 64\n                filename_icon = 'kivy-icon-{}.png'.format(logo_size)\n                filename_icon = resource_find(\n                        join(kivy_data_dir, 'logo', filename_icon))\n            self.set_icon(filename_icon)\n        except:\n            Logger.exception('Window: cannot set icon')\n\n        # try to use mode with multisamples\n        try:\n            self._pygame_set_mode()\n        except pygame.error as e:\n            if multisamples:\n                Logger.warning('WinPygame: Video: failed (multisamples=%d)' %\n                               multisamples)\n                Logger.warning('WinPygame: trying without antialiasing')\n                pygame.display.gl_set_attribute(\n                    pygame.GL_MULTISAMPLEBUFFERS, 0)\n                pygame.display.gl_set_attribute(\n                    pygame.GL_MULTISAMPLESAMPLES, 0)\n                multisamples = 0\n                try:\n                    self._pygame_set_mode()\n                except pygame.error as e:\n                    raise CoreCriticalException(e.message)\n            else:\n                raise CoreCriticalException(e.message)\n\n        if pygame.RESIZABLE & self.flags:\n            self._pygame_set_mode()\n\n        info = pygame.display.Info()\n        self._size = (info.current_w, info.current_h)\n        # self.dispatch('on_resize', *self._size)\n\n        # in order to debug futur issue with pygame/display, let's show\n        # more debug output.\n        Logger.debug('Window: Display driver ' + pygame.display.get_driver())\n        Logger.debug('Window: Actual window size: %dx%d',\n                     info.current_w, info.current_h)\n        if platform != 'android':\n            # unsupported platform, such as android that doesn't support\n            # gl_get_attribute.\n            Logger.debug(\n                'Window: Actual color bits r%d g%d b%d a%d',\n                pygame.display.gl_get_attribute(pygame.GL_RED_SIZE),\n                pygame.display.gl_get_attribute(pygame.GL_GREEN_SIZE),\n                pygame.display.gl_get_attribute(pygame.GL_BLUE_SIZE),\n                pygame.display.gl_get_attribute(pygame.GL_ALPHA_SIZE))\n            Logger.debug(\n                'Window: Actual depth bits: %d',\n                pygame.display.gl_get_attribute(pygame.GL_DEPTH_SIZE))\n            Logger.debug(\n                'Window: Actual stencil bits: %d',\n                pygame.display.gl_get_attribute(pygame.GL_STENCIL_SIZE))\n            Logger.debug(\n                'Window: Actual multisampling samples: %d',\n                pygame.display.gl_get_attribute(pygame.GL_MULTISAMPLESAMPLES))\n        super(WindowPygame, self).create_window()\n\n        # set mouse visibility\n        self._set_cursor_state(self.show_cursor)\n\n        # if we are on android platform, automatically create hooks\n        if android:\n            from kivy.support import install_android\n            install_android()",
  "def close(self):\n        pygame.display.quit()\n        super(WindowPygame, self).close()",
  "def on_title(self, instance, value):\n        if self.initialized:\n            pygame.display.set_caption(self.title)",
  "def set_icon(self, filename):\n        if not exists(filename):\n            return False\n        try:\n            if platform == 'win':\n                try:\n                    if self._set_icon_win(filename):\n                        return True\n                except:\n                    # fallback on standard loading then.\n                    pass\n\n            # for all others platform, or if the ico is not available, use the\n            # default way to set it.\n            self._set_icon_standard(filename)\n            super(WindowPygame, self).set_icon(filename)\n        except:\n            Logger.exception('WinPygame: unable to set icon')",
  "def _set_icon_standard(self, filename):\n        if PY2:\n            try:\n                im = pygame.image.load(filename)\n            except UnicodeEncodeError:\n                im = pygame.image.load(filename.encode('utf8'))\n        else:\n            im = pygame.image.load(filename)\n        if im is None:\n            raise Exception('Unable to load window icon (not found)')\n        pygame.display.set_icon(im)",
  "def _set_icon_win(self, filename):\n        # ensure the window ico is ended by ico\n        if not filename.endswith('.ico'):\n            filename = '{}.ico'.format(filename.rsplit('.', 1)[0])\n        if not exists(filename):\n            return False\n\n        import win32api\n        import win32gui\n        import win32con\n        hwnd = pygame.display.get_wm_info()['window']\n        icon_big = win32gui.LoadImage(\n            None, filename, win32con.IMAGE_ICON,\n            48, 48, win32con.LR_LOADFROMFILE)\n        icon_small = win32gui.LoadImage(\n            None, filename, win32con.IMAGE_ICON,\n            16, 16, win32con.LR_LOADFROMFILE)\n        win32api.SendMessage(\n            hwnd, win32con.WM_SETICON, win32con.ICON_SMALL, icon_small)\n        win32api.SendMessage(\n            hwnd, win32con.WM_SETICON, win32con.ICON_BIG, icon_big)\n        return True",
  "def _set_cursor_state(self, value):\n        pygame.mouse.set_visible(value)",
  "def screenshot(self, *largs, **kwargs):\n        global glReadPixels, GL_RGBA, GL_UNSIGNED_BYTE\n        filename = super(WindowPygame, self).screenshot(*largs, **kwargs)\n        if filename is None:\n            return None\n        if glReadPixels is None:\n            from kivy.graphics.opengl import (glReadPixels, GL_RGBA,\n                                              GL_UNSIGNED_BYTE)\n        width, height = self.system_size\n        data = glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE)\n        data = bytes(bytearray(data))\n        surface = pygame.image.fromstring(data, (width, height), 'RGBA', True)\n        pygame.image.save(surface, filename)\n        Logger.debug('Window: Screenshot saved at <%s>' % filename)\n        return filename",
  "def flip(self):\n        pygame.display.flip()\n        super(WindowPygame, self).flip()",
  "def mainloop(self):\n        for event in pygame.event.get():\n\n            # kill application (SIG_TERM)\n            if event.type == pygame.QUIT:\n                if self.dispatch('on_request_close'):\n                    continue\n                EventLoop.quit = True\n                self.close()\n\n            # mouse move\n            elif event.type == pygame.MOUSEMOTION:\n                x, y = event.pos\n                self.mouse_pos = x, self.system_size[1] - y\n                # don't dispatch motion if no button are pressed\n                if event.buttons == (0, 0, 0):\n                    continue\n                self._mouse_x = x\n                self._mouse_y = y\n                self._mouse_meta = self.modifiers\n                self.dispatch('on_mouse_move', x, y, self.modifiers)\n\n            # mouse action\n            elif event.type in (pygame.MOUSEBUTTONDOWN,\n                                pygame.MOUSEBUTTONUP):\n                self._pygame_update_modifiers()\n                x, y = event.pos\n                btn = 'left'\n                if event.button == 3:\n                    btn = 'right'\n                elif event.button == 2:\n                    btn = 'middle'\n                elif event.button == 4:\n                    btn = 'scrolldown'\n                elif event.button == 5:\n                    btn = 'scrollup'\n                elif event.button == 6:\n                    btn = 'scrollright'\n                elif event.button == 7:\n                    btn = 'scrollleft'\n                eventname = 'on_mouse_down'\n                if event.type == pygame.MOUSEBUTTONUP:\n                    eventname = 'on_mouse_up'\n                self._mouse_x = x\n                self._mouse_y = y\n                self._mouse_meta = self.modifiers\n                self._mouse_btn = btn\n                self._mouse_down = eventname == 'on_mouse_down'\n                self.dispatch(eventname, x, y, btn, self.modifiers)\n\n            # joystick action\n            elif event.type == pygame.JOYAXISMOTION:\n                self.dispatch('on_joy_axis', event.joy, event.axis,\n                                event.value)\n\n            elif event.type == pygame.JOYHATMOTION:\n                self.dispatch('on_joy_hat', event.joy, event.hat, event.value)\n\n            elif event.type == pygame.JOYBALLMOTION:\n                self.dispatch('on_joy_ball', event.joy, event.ballid,\n                            event.rel[0], event.rel[1])\n\n            elif event.type == pygame.JOYBUTTONDOWN:\n                self.dispatch('on_joy_button_down', event.joy, event.button)\n\n            elif event.type == pygame.JOYBUTTONUP:\n                self.dispatch('on_joy_button_up', event.joy, event.button)\n\n            # keyboard action\n            elif event.type in (pygame.KEYDOWN, pygame.KEYUP):\n                self._pygame_update_modifiers(event.mod)\n                # atm, don't handle keyup\n                if event.type == pygame.KEYUP:\n                    self.dispatch('on_key_up', event.key,\n                                  event.scancode)\n                    continue\n\n                # don't dispatch more key if down event is accepted\n                if self.dispatch('on_key_down', event.key,\n                                 event.scancode, event.unicode,\n                                 self.modifiers):\n                    continue\n                self.dispatch('on_keyboard', event.key,\n                              event.scancode, event.unicode,\n                              self.modifiers)\n\n            # video resize\n            elif event.type == pygame.VIDEORESIZE:\n                self._size = event.size\n                self.update_viewport()\n\n            elif event.type == pygame.VIDEOEXPOSE:\n                self.canvas.ask_update()\n\n            # ignored event\n            elif event.type == pygame.ACTIVEEVENT:\n                pass\n\n            # drop file (pygame patch needed)\n            elif event.type == pygame.USEREVENT and \\\n                    hasattr(pygame, 'USEREVENT_DROPFILE') and \\\n                    event.code == pygame.USEREVENT_DROPFILE:\n                drop_x, drop_y = pygame.mouse.get_pos()\n                self.dispatch('on_drop_file', event.filename, drop_x, drop_y)\n\n            '''\n            # unhandled event !\n            else:\n                Logger.debug('WinPygame: Unhandled event %s' % str(event))\n            '''\n        if not pygame.display.get_active():\n            pygame.time.wait(100)",
  "def _pygame_set_mode(self, size=None):\n        if size is None:\n            size = self.size\n        if self.fullscreen == 'auto':\n            pygame.display.set_mode((0, 0), self.flags)\n        else:\n            pygame.display.set_mode(size, self.flags)",
  "def _pygame_update_modifiers(self, mods=None):\n        # Available mod, from dir(pygame)\n        # 'KMOD_ALT', 'KMOD_CAPS', 'KMOD_CTRL', 'KMOD_LALT',\n        # 'KMOD_LCTRL', 'KMOD_LMETA', 'KMOD_LSHIFT', 'KMOD_META',\n        # 'KMOD_MODE', 'KMOD_NONE'\n        if mods is None:\n            mods = pygame.key.get_mods()\n        self._modifiers = []\n        if mods & (pygame.KMOD_SHIFT | pygame.KMOD_LSHIFT):\n            self._modifiers.append('shift')\n        if mods & (pygame.KMOD_ALT | pygame.KMOD_LALT):\n            self._modifiers.append('alt')\n        if mods & (pygame.KMOD_CTRL | pygame.KMOD_LCTRL):\n            self._modifiers.append('ctrl')\n        if mods & (pygame.KMOD_META | pygame.KMOD_LMETA):\n            self._modifiers.append('meta')",
  "def request_keyboard(\n            self, callback, target, input_type='text', keyboard_suggestions=True\n    ):\n        keyboard = super(WindowPygame, self).request_keyboard(\n            callback, target, input_type, keyboard_suggestions)\n        if android and not self.allow_vkeyboard:\n            android.show_keyboard(target, input_type)\n        return keyboard",
  "def release_keyboard(self, *largs):\n        super(WindowPygame, self).release_keyboard(*largs)\n        if android:\n            android.hide_keyboard()\n        return True",
  "class WindowEglRpi(WindowBase):\n\n    _rpi_dispmanx_id = int(environ.get(\"KIVY_BCM_DISPMANX_ID\", \"0\"))\n    _rpi_dispmanx_layer = int(environ.get(\"KIVY_BCM_DISPMANX_LAYER\", \"0\"))\n\n    gl_backends_ignored = ['sdl2']\n\n    def create_window(self):\n        bcm.host_init()\n\n        w, h = bcm.graphics_get_display_size(self._rpi_dispmanx_id)\n        Logger.debug('Window: Actual display size: {}x{}'.format(\n            w, h))\n        self._size = w, h\n        self._create_window(w, h)\n        self._create_egl_context(self.win, 0)\n        super(WindowEglRpi, self).create_window()\n\n    def _create_window(self, w, h):\n        dst = bcm.Rect(0, 0, w, h)\n        src = bcm.Rect(0, 0, w << 16, h << 16)\n        display = egl.bcm_display_open(self._rpi_dispmanx_id)\n        update = egl.bcm_update_start(0)\n        element = egl.bcm_element_add(\n            update, display, self._rpi_dispmanx_layer, dst, src)\n        self.win = egl.NativeWindow(element, w, h)\n        egl.bcm_update_submit_sync(update)\n\n    def _create_egl_context(self, win, flags):\n        api = egl._constants.EGL_OPENGL_ES_API\n        c = egl._constants\n\n        attribs = [\n            c.EGL_RED_SIZE, 8,\n            c.EGL_GREEN_SIZE, 8,\n            c.EGL_BLUE_SIZE, 8,\n            c.EGL_ALPHA_SIZE, 8,\n            c.EGL_DEPTH_SIZE, 16,\n            c.EGL_STENCIL_SIZE, 8,\n            c.EGL_SURFACE_TYPE, c.EGL_WINDOW_BIT,\n            c.EGL_NONE]\n\n        attribs_context = [c.EGL_CONTEXT_CLIENT_VERSION, 2, c.EGL_NONE]\n\n        display = egl.GetDisplay(c.EGL_DEFAULT_DISPLAY)\n        egl.Initialise(display)\n        egl.BindAPI(c.EGL_OPENGL_ES_API)\n        egl.GetConfigs(display)\n        config = egl.ChooseConfig(display, attribs, 1)[0]\n        surface = egl.CreateWindowSurface(display, config, win)\n        context = egl.CreateContext(display, config, None, attribs_context)\n        egl.MakeCurrent(display, surface, surface, context)\n\n        self.egl_info = (display, surface, context)\n        egl.MakeCurrent(display, surface, surface, context)\n\n    def close(self):\n        egl.Terminate(self.egl_info[0])\n\n    def flip(self):\n        if not EventLoop.quit:\n            egl.SwapBuffers(self.egl_info[0], self.egl_info[1])",
  "def create_window(self):\n        bcm.host_init()\n\n        w, h = bcm.graphics_get_display_size(self._rpi_dispmanx_id)\n        Logger.debug('Window: Actual display size: {}x{}'.format(\n            w, h))\n        self._size = w, h\n        self._create_window(w, h)\n        self._create_egl_context(self.win, 0)\n        super(WindowEglRpi, self).create_window()",
  "def _create_window(self, w, h):\n        dst = bcm.Rect(0, 0, w, h)\n        src = bcm.Rect(0, 0, w << 16, h << 16)\n        display = egl.bcm_display_open(self._rpi_dispmanx_id)\n        update = egl.bcm_update_start(0)\n        element = egl.bcm_element_add(\n            update, display, self._rpi_dispmanx_layer, dst, src)\n        self.win = egl.NativeWindow(element, w, h)\n        egl.bcm_update_submit_sync(update)",
  "def _create_egl_context(self, win, flags):\n        api = egl._constants.EGL_OPENGL_ES_API\n        c = egl._constants\n\n        attribs = [\n            c.EGL_RED_SIZE, 8,\n            c.EGL_GREEN_SIZE, 8,\n            c.EGL_BLUE_SIZE, 8,\n            c.EGL_ALPHA_SIZE, 8,\n            c.EGL_DEPTH_SIZE, 16,\n            c.EGL_STENCIL_SIZE, 8,\n            c.EGL_SURFACE_TYPE, c.EGL_WINDOW_BIT,\n            c.EGL_NONE]\n\n        attribs_context = [c.EGL_CONTEXT_CLIENT_VERSION, 2, c.EGL_NONE]\n\n        display = egl.GetDisplay(c.EGL_DEFAULT_DISPLAY)\n        egl.Initialise(display)\n        egl.BindAPI(c.EGL_OPENGL_ES_API)\n        egl.GetConfigs(display)\n        config = egl.ChooseConfig(display, attribs, 1)[0]\n        surface = egl.CreateWindowSurface(display, config, win)\n        context = egl.CreateContext(display, config, None, attribs_context)\n        egl.MakeCurrent(display, surface, surface, context)\n\n        self.egl_info = (display, surface, context)\n        egl.MakeCurrent(display, surface, surface, context)",
  "def close(self):\n        egl.Terminate(self.egl_info[0])",
  "def flip(self):\n        if not EventLoop.quit:\n            egl.SwapBuffers(self.egl_info[0], self.egl_info[1])",
  "class SDL2MotionEvent(MotionEvent):\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ('pos', 'pressure')\n\n    def depack(self, args):\n        self.sx, self.sy, self.pressure = args\n        super().depack(args)",
  "class SDL2MotionEventProvider(MotionEventProvider):\n    win = None\n    q = deque()\n    touchmap = {}\n\n    def update(self, dispatch_fn):\n        touchmap = self.touchmap\n        while True:\n            try:\n                value = self.q.pop()\n            except IndexError:\n                return\n\n            action, fid, x, y, pressure = value\n            y = 1 - y\n            if fid not in touchmap:\n                touchmap[fid] = me = SDL2MotionEvent(\n                    'sdl', fid, (x, y, pressure)\n                )\n            else:\n                me = touchmap[fid]\n                me.move((x, y, pressure))\n            if action == 'fingerdown':\n                dispatch_fn('begin', me)\n            elif action == 'fingerup':\n                me.update_time_end()\n                dispatch_fn('end', me)\n                del touchmap[fid]\n            else:\n                dispatch_fn('update', me)",
  "class WindowSDL(WindowBase):\n\n    _win_dpi_watch: Optional['_WindowsSysDPIWatch'] = None\n\n    _do_resize_ev = None\n\n    managed_textinput = True\n\n    def __init__(self, **kwargs):\n        self._pause_loop = False\n        self._cursor_entered = False\n        self._drop_pos = None\n        self._win = _WindowSDL2Storage()\n        super(WindowSDL, self).__init__()\n        self.titlebar_widget = None\n        self._mouse_x = self._mouse_y = -1\n        self._meta_keys = (\n            KMOD_LCTRL, KMOD_RCTRL, KMOD_RSHIFT,\n            KMOD_LSHIFT, KMOD_RALT, KMOD_LALT, KMOD_LGUI,\n            KMOD_RGUI, KMOD_NUM, KMOD_CAPS, KMOD_MODE)\n        self.command_keys = {\n                    27: 'escape',\n                    9: 'tab',\n                    8: 'backspace',\n                    13: 'enter',\n                    127: 'del',\n                    271: 'enter',\n                    273: 'up',\n                    274: 'down',\n                    275: 'right',\n                    276: 'left',\n                    278: 'home',\n                    279: 'end',\n                    280: 'pgup',\n                    281: 'pgdown'}\n        self._mouse_buttons_down = set()\n        self.key_map = {SDLK_LEFT: 276, SDLK_RIGHT: 275, SDLK_UP: 273,\n                        SDLK_DOWN: 274, SDLK_HOME: 278, SDLK_END: 279,\n                        SDLK_PAGEDOWN: 281, SDLK_PAGEUP: 280, SDLK_SHIFTR: 303,\n                        SDLK_SHIFTL: 304, SDLK_SUPER: 309, SDLK_LCTRL: 305,\n                        SDLK_RCTRL: 306, SDLK_LALT: 308, SDLK_RALT: 307,\n                        SDLK_CAPS: 301, SDLK_INSERT: 277, SDLK_F1: 282,\n                        SDLK_F2: 283, SDLK_F3: 284, SDLK_F4: 285, SDLK_F5: 286,\n                        SDLK_F6: 287, SDLK_F7: 288, SDLK_F8: 289, SDLK_F9: 290,\n                        SDLK_F10: 291, SDLK_F11: 292, SDLK_F12: 293,\n                        SDLK_F13: 294, SDLK_F14: 295, SDLK_F15: 296,\n                        SDLK_KEYPADNUM: 300, SDLK_KP_DIVIDE: 267,\n                        SDLK_KP_MULTIPLY: 268, SDLK_KP_MINUS: 269,\n                        SDLK_KP_PLUS: 270, SDLK_KP_ENTER: 271,\n                        SDLK_KP_DOT: 266, SDLK_KP_0: 256, SDLK_KP_1: 257,\n                        SDLK_KP_2: 258, SDLK_KP_3: 259, SDLK_KP_4: 260,\n                        SDLK_KP_5: 261, SDLK_KP_6: 262, SDLK_KP_7: 263,\n                        SDLK_KP_8: 264, SDLK_KP_9: 265}\n        if platform == 'ios':\n            # XXX ios keyboard suck, when backspace is hit, the delete\n            # keycode is sent. fix it.\n            self.key_map[127] = 8\n        elif platform == 'android':\n            # map android back button to escape\n            self.key_map[1073742094] = 27\n\n        self.bind(minimum_width=self._set_minimum_size,\n                  minimum_height=self._set_minimum_size)\n\n        self.bind(allow_screensaver=self._set_allow_screensaver)\n        self.bind(always_on_top=self._set_always_on_top)\n\n    def get_window_info(self):\n        return self._win.get_window_info()\n\n    def _set_minimum_size(self, *args):\n        minimum_width = self.minimum_width\n        minimum_height = self.minimum_height\n        if minimum_width and minimum_height:\n            self._win.set_minimum_size(minimum_width, minimum_height)\n        elif minimum_width or minimum_height:\n            Logger.warning(\n                'Both Window.minimum_width and Window.minimum_height must be '\n                'bigger than 0 for the size restriction to take effect.')\n\n    def _set_always_on_top(self, *args):\n        self._win.set_always_on_top(self.always_on_top)\n\n    def _set_allow_screensaver(self, *args):\n        self._win.set_allow_screensaver(self.allow_screensaver)\n\n    def _event_filter(self, action, *largs):\n        from kivy.app import App\n        if action == 'app_terminating':\n            EventLoop.quit = True\n\n        elif action == 'app_lowmemory':\n            self.dispatch('on_memorywarning')\n\n        elif action == 'app_willenterbackground':\n            from kivy.base import stopTouchApp\n            app = App.get_running_app()\n            if not app:\n                Logger.info('WindowSDL: No running App found, pause.')\n\n            elif not app.dispatch('on_pause'):\n                if platform == 'android':\n                    Logger.info(\n                        'WindowSDL: App stopped, on_pause() returned False.')\n                    from android import mActivity\n                    mActivity.finishAndRemoveTask()\n                else:\n                    Logger.info(\n                        'WindowSDL: App doesn\\'t support pause mode, stop.')\n                    stopTouchApp()\n                    return 0\n\n            self._pause_loop = True\n\n        elif action == 'app_didenterforeground':\n            # on iOS, the did enter foreground is launched at the start\n            # of the application. in our case, we want it only when the app\n            # is resumed\n            if self._pause_loop:\n                self._pause_loop = False\n                app = App.get_running_app()\n                if app:\n                    app.dispatch('on_resume')\n\n        elif action == 'windowresized':\n            self._size = largs\n            self._win.resize_window(*self._size)\n            # Force kivy to render the frame now, so that the canvas is drawn.\n            EventLoop.idle()\n\n        return 0\n\n    def create_window(self, *largs):\n        if self._fake_fullscreen:\n            if not self.borderless:\n                self.fullscreen = self._fake_fullscreen = False\n            elif not self.fullscreen or self.fullscreen == 'auto':\n                self.custom_titlebar = \\\n                    self.borderless = self._fake_fullscreen = False\n            elif self.custom_titlebar:\n                if platform == 'win':\n                    # use custom behavior\n                    # To handle aero snapping and rounded corners\n                    self.borderless = False\n        if self.fullscreen == 'fake':\n            self.borderless = self._fake_fullscreen = True\n            Logger.warning(\"The 'fake' fullscreen option has been \"\n                           \"deprecated, use Window.borderless or the \"\n                           \"borderless Config option instead.\")\n\n        if not self.initialized:\n            if self.position == 'auto':\n                pos = None, None\n            elif self.position == 'custom':\n                pos = self.left, self.top\n\n            # ensure we have an event filter\n            self._win.set_event_filter(self._event_filter)\n\n            # setup window\n            w, h = self.system_size\n            resizable = Config.getboolean('graphics', 'resizable')\n            state = (Config.get('graphics', 'window_state')\n                     if self._is_desktop else None)\n            self.system_size = self._win.setup_window(\n                pos[0], pos[1], w, h, self.borderless,\n                self.fullscreen, resizable, state,\n                self.get_gl_backend_name())\n\n            # We don't have a density or dpi yet set, so let's ask for an update\n            self._update_density_and_dpi()\n\n            # never stay with a None pos, application using w.center\n            # will be fired.\n            self._pos = (0, 0)\n            self._set_minimum_size()\n            self._set_allow_screensaver()\n            self._set_always_on_top()\n\n            if state == 'hidden':\n                self._focus = False\n        else:\n            w, h = self.system_size\n            self._win.resize_window(w, h)\n            if platform == 'win':\n                if self.custom_titlebar:\n                    # check dragging+resize or just dragging\n                    if Config.getboolean('graphics', 'resizable'):\n                        import win32con\n                        import ctypes\n                        self._win.set_border_state(False)\n                        # make windows dispatch,\n                        # WM_NCCALCSIZE explicitly\n                        ctypes.windll.user32.SetWindowPos(\n                            self._win.get_window_info().window,\n                            win32con.HWND_TOP,\n                            *self._win.get_window_pos(),\n                            *self.system_size,\n                            win32con.SWP_FRAMECHANGED\n                        )\n                    else:\n                        self._win.set_border_state(True)\n                else:\n                    self._win.set_border_state(self.borderless)\n            else:\n                self._win.set_border_state(self.borderless\n                                           or self.custom_titlebar)\n            self._win.set_fullscreen_mode(self.fullscreen)\n\n        super(WindowSDL, self).create_window()\n        # set mouse visibility\n        self._set_cursor_state(self.show_cursor)\n\n        if self.initialized:\n            return\n\n        # auto add input provider\n        Logger.info('Window: auto add sdl2 input provider')\n        from kivy.base import EventLoop\n        SDL2MotionEventProvider.win = self\n        EventLoop.add_input_provider(SDL2MotionEventProvider('sdl', ''))\n\n        # set window icon before calling set_mode\n        try:\n            filename_icon = self.icon or Config.get('kivy', 'window_icon')\n            if filename_icon == '':\n                logo_size = 32\n                if platform == 'macosx':\n                    logo_size = 512\n                elif platform == 'win':\n                    logo_size = 64\n                filename_icon = 'kivy-icon-{}.png'.format(logo_size)\n                filename_icon = resource_find(\n                        join(kivy_data_dir, 'logo', filename_icon))\n            self.set_icon(filename_icon)\n        except:\n            Logger.exception('Window: cannot set icon')\n\n        if platform == 'win' and self._win_dpi_watch is None:\n            self._win_dpi_watch = _WindowsSysDPIWatch(window=self)\n            self._win_dpi_watch.start()\n\n    def _update_density_and_dpi(self):\n        if platform == 'win':\n            from ctypes import windll\n            self._density = 1.\n            try:\n                hwnd = windll.user32.GetActiveWindow()\n                self.dpi = float(windll.user32.GetDpiForWindow(hwnd))\n            except AttributeError:\n                pass\n        else:\n            self._density = self._win._get_gl_size()[0] / self._size[0]\n            if self._is_desktop:\n                self.dpi = self._density * 96.\n\n    def close(self):\n        self._win.teardown_window()\n        super(WindowSDL, self).close()\n        if self._win_dpi_watch is not None:\n            self._win_dpi_watch.stop()\n            self._win_dpi_watch = None\n\n        self.initialized = False\n\n    def maximize(self):\n        if self._is_desktop:\n            self._win.maximize_window()\n        else:\n            Logger.warning('Window: maximize() is used only on desktop OSes.')\n\n    def minimize(self):\n        if self._is_desktop:\n            self._win.minimize_window()\n        else:\n            Logger.warning('Window: minimize() is used only on desktop OSes.')\n\n    def restore(self):\n        if self._is_desktop:\n            self._win.restore_window()\n        else:\n            Logger.warning('Window: restore() is used only on desktop OSes.')\n\n    def hide(self):\n        if self._is_desktop:\n            self._win.hide_window()\n        else:\n            Logger.warning('Window: hide() is used only on desktop OSes.')\n\n    def show(self):\n        if self._is_desktop:\n            self._win.show_window()\n        else:\n            Logger.warning('Window: show() is used only on desktop OSes.')\n\n    def raise_window(self):\n        if self._is_desktop:\n            self._win.raise_window()\n        else:\n            Logger.warning('Window: show() is used only on desktop OSes.')\n\n    def set_title(self, title):\n        self._win.set_window_title(title)\n\n    def set_icon(self, filename):\n        self._win.set_window_icon(str(filename))\n\n    def screenshot(self, *largs, **kwargs):\n        filename = super(WindowSDL, self).screenshot(*largs, **kwargs)\n        if filename is None:\n            return\n\n        from kivy.graphics.opengl import glReadPixels, GL_RGB, GL_UNSIGNED_BYTE\n        width, height = self.size\n        data = glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE)\n        self._win.save_bytes_in_png(filename, data, width, height)\n        Logger.debug('Window: Screenshot saved at <%s>' % filename)\n        return filename\n\n    def flip(self):\n        self._win.flip()\n        super(WindowSDL, self).flip()\n\n    def set_system_cursor(self, cursor_name):\n        result = self._win.set_system_cursor(cursor_name)\n        return result\n\n    def _get_window_pos(self):\n        return self._win.get_window_pos()\n\n    def _set_window_pos(self, x, y):\n        self._win.set_window_pos(x, y)\n\n    # Transparent Window background\n    def _is_shaped(self):\n        return self._win.is_window_shaped()\n\n    def _set_shape(self, shape_image, mode='default',\n                   cutoff=False, color_key=None):\n        modes = ('default', 'binalpha', 'reversebinalpha', 'colorkey')\n        color_key = color_key or (0, 0, 0, 1)\n        if mode not in modes:\n            Logger.warning(\n                'Window: shape mode can be only '\n                '{}'.format(', '.join(modes))\n            )\n            return\n        if not isinstance(color_key, (tuple, list)):\n            return\n        if len(color_key) not in (3, 4):\n            return\n        if len(color_key) == 3:\n            color_key = (color_key[0], color_key[1], color_key[2], 1)\n            Logger.warning(\n                'Window: Shape color_key must be only tuple or list'\n            )\n            return\n        color_key = (\n            color_key[0] * 255,\n            color_key[1] * 255,\n            color_key[2] * 255,\n            color_key[3] * 255\n        )\n\n        assert cutoff in (1, 0)\n        shape_image = shape_image or Config.get('kivy', 'window_shape')\n        shape_image = resource_find(shape_image) or shape_image\n        self._win.set_shape(shape_image, mode, cutoff, color_key)\n\n    def _get_shaped_mode(self):\n        return self._win.get_shaped_mode()\n\n    def _set_shaped_mode(self, value):\n        self._set_shape(\n            shape_image=self.shape_image,\n            mode=value, cutoff=self.shape_cutoff,\n            color_key=self.shape_color_key\n        )\n        return self._win.get_shaped_mode()\n    # twb end\n\n    def _set_cursor_state(self, value):\n        self._win._set_cursor_state(value)\n\n    def _fix_mouse_pos(self, x, y):\n        self.mouse_pos = (\n            x * self._density,\n            (self.system_size[1] - 1 - y) * self._density\n        )\n        return x, y\n\n    def mainloop(self):\n        # for android/iOS, we don't want to have any event nor executing our\n        # main loop while the pause is going on. This loop wait any event (not\n        # handled by the event filter), and remove them from the queue.\n        # Nothing happen during the pause on iOS, except gyroscope value sent\n        # over joystick. So it's safe.\n        while self._pause_loop:\n            self._win.wait_event()\n            if not self._pause_loop:\n                break\n            event = self._win.poll()\n            if event is None:\n                continue\n            # A drop is send while the app is still in pause.loop\n            # we need to dispatch it\n            action, args = event[0], event[1:]\n            if action.startswith('drop'):\n                self._dispatch_drop_event(action, args)\n            # app_terminating event might be received while the app is paused\n            # in this case EventLoop.quit will be set at _event_filter\n            elif EventLoop.quit:\n                return\n\n        while True:\n            event = self._win.poll()\n            if event is False:\n                break\n            if event is None:\n                continue\n\n            action, args = event[0], event[1:]\n            if action == 'quit':\n                if self.dispatch('on_request_close'):\n                    continue\n                EventLoop.quit = True\n                break\n\n            elif action in ('fingermotion', 'fingerdown', 'fingerup'):\n                # for finger, pass the raw event to SDL motion event provider\n                # XXX this is problematic. On OSX, it generates touches with 0,\n                # 0 coordinates, at the same times as mouse. But it works.\n                # We have a conflict of using either the mouse or the finger.\n                # Right now, we have no mechanism that we could use to know\n                # which is the preferred one for the application.\n                if platform in ('ios', 'android'):\n                    SDL2MotionEventProvider.q.appendleft(event)\n                pass\n\n            elif action == 'mousemotion':\n                x, y = args\n                x, y = self._fix_mouse_pos(x, y)\n                self._mouse_x = x\n                self._mouse_y = y\n                if not self._cursor_entered:\n                    self._cursor_entered = True\n                    self.dispatch('on_cursor_enter')\n                # don't dispatch motion if no button are pressed\n                if len(self._mouse_buttons_down) == 0:\n                    continue\n                self._mouse_meta = self.modifiers\n                self.dispatch('on_mouse_move', x, y, self.modifiers)\n\n            elif action in ('mousebuttondown', 'mousebuttonup'):\n                x, y, button = args\n                x, y = self._fix_mouse_pos(x, y)\n                self._mouse_x = x\n                self._mouse_y = y\n                if not self._cursor_entered:\n                    self._cursor_entered = True\n                    self.dispatch('on_cursor_enter')\n                btn = 'left'\n                if button == 3:\n                    btn = 'right'\n                elif button == 2:\n                    btn = 'middle'\n                elif button == 4:\n                    btn = \"mouse4\"\n                elif button == 5:\n                    btn = \"mouse5\"\n                eventname = 'on_mouse_down'\n                self._mouse_buttons_down.add(button)\n                if action == 'mousebuttonup':\n                    eventname = 'on_mouse_up'\n                    self._mouse_buttons_down.remove(button)\n                self.dispatch(eventname, x, y, btn, self.modifiers)\n            elif action.startswith('mousewheel'):\n                x, y = self._win.get_relative_mouse_pos()\n                if not self._collide_and_dispatch_cursor_enter(x, y):\n                    # Ignore if the cursor position is on the window title bar\n                    # or on its edges\n                    continue\n                self._update_modifiers()\n                x, y, button = args\n                btn = 'scrolldown'\n                if action.endswith('up'):\n                    btn = 'scrollup'\n                elif action.endswith('right'):\n                    btn = 'scrollright'\n                elif action.endswith('left'):\n                    btn = 'scrollleft'\n\n                self._mouse_meta = self.modifiers\n                self._mouse_btn = btn\n                # times = x if y == 0 else y\n                # times = min(abs(times), 100)\n                # for k in range(times):\n                self._mouse_down = True\n                self.dispatch('on_mouse_down',\n                    self._mouse_x, self._mouse_y, btn, self.modifiers)\n                self._mouse_down = False\n                self.dispatch('on_mouse_up',\n                    self._mouse_x, self._mouse_y, btn, self.modifiers)\n\n            elif action.startswith('drop'):\n                self._dispatch_drop_event(action, args)\n            # video resize\n            elif action == 'windowresized':\n                self._size = self._win.window_size\n                # don't use trigger here, we want to delay the resize event\n                ev = self._do_resize_ev\n                if ev is None:\n                    ev = Clock.schedule_once(self._do_resize, .1)\n                    self._do_resize_ev = ev\n                else:\n                    ev()\n            elif action == 'windowdisplaychanged':\n                Logger.info(f\"WindowSDL: Window is now on display {args[0]}\")\n\n                # The display has changed, so the density and dpi\n                # may have changed too.\n                self._update_density_and_dpi()\n\n            elif action == 'windowmoved':\n                self.dispatch('on_move')\n\n            elif action == 'windowrestored':\n                self.dispatch('on_restore')\n                self.canvas.ask_update()\n\n            elif action == 'windowexposed':\n                self.canvas.ask_update()\n\n            elif action == 'windowminimized':\n                self.dispatch('on_minimize')\n                if Config.getboolean('kivy', 'pause_on_minimize'):\n                    self.do_pause()\n\n            elif action == 'windowmaximized':\n                self.dispatch('on_maximize')\n\n            elif action == 'windowhidden':\n                self.dispatch('on_hide')\n\n            elif action == 'windowshown':\n                self.dispatch('on_show')\n\n            elif action == 'windowfocusgained':\n                self._focus = True\n\n            elif action == 'windowfocuslost':\n                self._focus = False\n\n            elif action == 'windowenter':\n                x, y = self._win.get_relative_mouse_pos()\n                self._collide_and_dispatch_cursor_enter(x, y)\n\n            elif action == 'windowleave':\n                self._cursor_entered = False\n                self.dispatch('on_cursor_leave')\n\n            elif action == 'joyaxismotion':\n                stickid, axisid, value = args\n                self.dispatch('on_joy_axis', stickid, axisid, value)\n            elif action == 'joyhatmotion':\n                stickid, hatid, value = args\n                self.dispatch('on_joy_hat', stickid, hatid, value)\n            elif action == 'joyballmotion':\n                stickid, ballid, xrel, yrel = args\n                self.dispatch('on_joy_ball', stickid, ballid, xrel, yrel)\n            elif action == 'joybuttondown':\n                stickid, buttonid = args\n                self.dispatch('on_joy_button_down', stickid, buttonid)\n            elif action == 'joybuttonup':\n                stickid, buttonid = args\n                self.dispatch('on_joy_button_up', stickid, buttonid)\n\n            elif action in ('keydown', 'keyup'):\n                mod, key, scancode, kstr = args\n\n                try:\n                    key = self.key_map[key]\n                except KeyError:\n                    pass\n\n                if action == 'keydown':\n                    self._update_modifiers(mod, key)\n                else:\n                    # ignore the key, it has been released\n                    self._update_modifiers(mod)\n\n                # if mod in self._meta_keys:\n                if (key not in self._modifiers and\n                        key not in self.command_keys.keys()):\n                    try:\n                        kstr_chr = unichr(key)\n                        try:\n                            # On android, there is no 'encoding' attribute.\n                            # On other platforms, if stdout is redirected,\n                            # 'encoding' may be None\n                            encoding = getattr(sys.stdout, 'encoding',\n                                               'utf8') or 'utf8'\n                            kstr_chr.encode(encoding)\n                            kstr = kstr_chr\n                        except UnicodeError:\n                            pass\n                    except ValueError:\n                        pass\n                # if 'shift' in self._modifiers and key\\\n                #        not in self.command_keys.keys():\n                #    return\n\n                if action == 'keyup':\n                    self.dispatch('on_key_up', key, scancode)\n                    continue\n\n                # don't dispatch more key if down event is accepted\n                if self.dispatch('on_key_down', key,\n                                 scancode, kstr,\n                                 self.modifiers):\n                    continue\n                self.dispatch('on_keyboard', key,\n                              scancode, kstr,\n                              self.modifiers)\n\n            elif action == 'textinput':\n                text = args[0]\n                self.dispatch('on_textinput', text)\n\n            elif action == 'textedit':\n                text = args[0]\n                self.dispatch('on_textedit', text)\n\n            # unhandled event !\n            else:\n                Logger.trace('WindowSDL: Unhandled event %s' % str(event))\n\n    def _dispatch_drop_event(self, action, args):\n        x, y = (0, 0) if self._drop_pos is None else self._drop_pos\n        if action == 'dropfile':\n            self.dispatch('on_drop_file', args[0], x, y)\n        elif action == 'droptext':\n            self.dispatch('on_drop_text', args[0], x, y)\n        elif action == 'dropbegin':\n            self._drop_pos = x, y = self._win.get_relative_mouse_pos()\n            self._collide_and_dispatch_cursor_enter(x, y)\n            self.dispatch('on_drop_begin', x, y)\n        elif action == 'dropend':\n            self._drop_pos = None\n            self.dispatch('on_drop_end', x, y)\n\n    def _collide_and_dispatch_cursor_enter(self, x, y):\n        # x, y are relative to window left/top position\n        w, h = self._win.window_size\n        if 0 <= x < w and 0 <= y < h:\n            self._mouse_x, self._mouse_y = self._fix_mouse_pos(x, y)\n            if not self._cursor_entered:\n                self._cursor_entered = True\n                self.dispatch('on_cursor_enter')\n            return True\n\n    def _do_resize(self, dt):\n        Logger.debug('Window: Resize window to %s' % str(self.size))\n        self._win.resize_window(*self._size)\n        self.dispatch('on_pre_resize', *self.size)\n\n    def do_pause(self):\n        # should go to app pause mode (desktop style)\n        from kivy.app import App\n        from kivy.base import stopTouchApp\n        app = App.get_running_app()\n        if not app:\n            Logger.info('WindowSDL: No running App found, pause.')\n        elif not app.dispatch('on_pause'):\n            Logger.info('WindowSDL: App doesn\\'t support pause mode, stop.')\n            stopTouchApp()\n            return\n\n        # XXX FIXME wait for sdl resume\n        while True:\n            event = self._win.poll()\n            if event is False:\n                continue\n            if event is None:\n                continue\n\n            action, args = event[0], event[1:]\n            if action == 'quit':\n                EventLoop.quit = True\n                break\n            elif action == 'app_willenterforeground':\n                break\n            elif action == 'windowrestored':\n                break\n\n        if app:\n            app.dispatch('on_resume')\n\n    def _update_modifiers(self, mods=None, key=None):\n        if mods is None and key is None:\n            return\n        modifiers = set()\n\n        if mods is not None:\n            if mods & (KMOD_RSHIFT | KMOD_LSHIFT):\n                modifiers.add('shift')\n            if mods & (KMOD_RALT | KMOD_LALT | KMOD_MODE):\n                modifiers.add('alt')\n            if mods & (KMOD_RCTRL | KMOD_LCTRL):\n                modifiers.add('ctrl')\n            if mods & (KMOD_RGUI | KMOD_LGUI):\n                modifiers.add('meta')\n            if mods & KMOD_NUM:\n                modifiers.add('numlock')\n            if mods & KMOD_CAPS:\n                modifiers.add('capslock')\n\n        if key is not None:\n            if key in (KMOD_RSHIFT, KMOD_LSHIFT):\n                modifiers.add('shift')\n            if key in (KMOD_RALT, KMOD_LALT, KMOD_MODE):\n                modifiers.add('alt')\n            if key in (KMOD_RCTRL, KMOD_LCTRL):\n                modifiers.add('ctrl')\n            if key in (KMOD_RGUI, KMOD_LGUI):\n                modifiers.add('meta')\n            if key == KMOD_NUM:\n                modifiers.add('numlock')\n            if key == KMOD_CAPS:\n                modifiers.add('capslock')\n\n        self._modifiers = list(modifiers)\n        return\n\n    def request_keyboard(\n            self, callback, target, input_type='text', keyboard_suggestions=True\n    ):\n        self._sdl_keyboard = super(WindowSDL, self).\\\n            request_keyboard(\n            callback, target, input_type, keyboard_suggestions\n        )\n        self._win.show_keyboard(\n            self._system_keyboard,\n            self.softinput_mode,\n            input_type,\n            keyboard_suggestions,\n        )\n        Clock.schedule_interval(self._check_keyboard_shown, 1 / 5.)\n        return self._sdl_keyboard\n\n    def release_keyboard(self, *largs):\n        super(WindowSDL, self).release_keyboard(*largs)\n        self._win.hide_keyboard()\n        self._sdl_keyboard = None\n        return True\n\n    def _check_keyboard_shown(self, dt):\n        if self._sdl_keyboard is None:\n            return False\n        if not self._win.is_keyboard_shown():\n            self._sdl_keyboard.release()\n\n    def map_key(self, original_key, new_key):\n        self.key_map[original_key] = new_key\n\n    def unmap_key(self, key):\n        if key in self.key_map:\n            del self.key_map[key]\n\n    def grab_mouse(self):\n        self._win.grab_mouse(True)\n\n    def ungrab_mouse(self):\n        self._win.grab_mouse(False)\n\n    def set_custom_titlebar(self, titlebar_widget):\n        if not self.custom_titlebar:\n            Logger.warning(\"Window: Window.custom_titlebar not set to True\u2026 \"\n                           \"can't set custom titlebar\")\n            return\n        self.titlebar_widget = titlebar_widget\n        return self._win.set_custom_titlebar(self.titlebar_widget) == 0",
  "class _WindowsSysDPIWatch:\n\n    hwnd = None\n\n    new_windProc = None\n\n    old_windProc = None\n\n    window: WindowBase = None\n\n    def __init__(self, window: WindowBase):\n        self.window = window\n\n    def start(self):\n        from kivy.input.providers.wm_common import WNDPROC, \\\n            SetWindowLong_WndProc_wrapper\n        from ctypes import windll\n\n        self.hwnd = windll.user32.GetActiveWindow()\n\n        # inject our own handler to handle messages before window manager\n        self.new_windProc = WNDPROC(self._wnd_proc)\n        self.old_windProc = SetWindowLong_WndProc_wrapper(\n            self.hwnd, self.new_windProc)\n\n    def stop(self):\n        from kivy.input.providers.wm_common import \\\n            SetWindowLong_WndProc_wrapper\n\n        if self.hwnd is None:\n            return\n\n        self.new_windProc = SetWindowLong_WndProc_wrapper(\n            self.hwnd, self.old_windProc)\n        self.hwnd = self.new_windProc = self.old_windProc = None\n\n    def _wnd_proc(self, hwnd, msg, wParam, lParam):\n        from kivy.input.providers.wm_common import WM_DPICHANGED, WM_NCCALCSIZE\n        from ctypes import windll\n\n        if msg == WM_DPICHANGED:\n\n            def clock_callback(*args):\n                if x_dpi != y_dpi:\n                    raise ValueError(\n                        'Can only handle DPI that are same for x and y')\n\n                self.window.dpi = x_dpi\n\n            x_dpi = wParam & 0xFFFF\n            y_dpi = wParam >> 16\n            Clock.schedule_once(clock_callback, -1)\n        elif Config.getboolean('graphics', 'resizable') \\\n                and msg == WM_NCCALCSIZE and self.window.custom_titlebar:\n            return 0\n        return windll.user32.CallWindowProcW(\n            self.old_windProc, hwnd, msg, wParam, lParam)",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ('pos', 'pressure')",
  "def depack(self, args):\n        self.sx, self.sy, self.pressure = args\n        super().depack(args)",
  "def update(self, dispatch_fn):\n        touchmap = self.touchmap\n        while True:\n            try:\n                value = self.q.pop()\n            except IndexError:\n                return\n\n            action, fid, x, y, pressure = value\n            y = 1 - y\n            if fid not in touchmap:\n                touchmap[fid] = me = SDL2MotionEvent(\n                    'sdl', fid, (x, y, pressure)\n                )\n            else:\n                me = touchmap[fid]\n                me.move((x, y, pressure))\n            if action == 'fingerdown':\n                dispatch_fn('begin', me)\n            elif action == 'fingerup':\n                me.update_time_end()\n                dispatch_fn('end', me)\n                del touchmap[fid]\n            else:\n                dispatch_fn('update', me)",
  "def __init__(self, **kwargs):\n        self._pause_loop = False\n        self._cursor_entered = False\n        self._drop_pos = None\n        self._win = _WindowSDL2Storage()\n        super(WindowSDL, self).__init__()\n        self.titlebar_widget = None\n        self._mouse_x = self._mouse_y = -1\n        self._meta_keys = (\n            KMOD_LCTRL, KMOD_RCTRL, KMOD_RSHIFT,\n            KMOD_LSHIFT, KMOD_RALT, KMOD_LALT, KMOD_LGUI,\n            KMOD_RGUI, KMOD_NUM, KMOD_CAPS, KMOD_MODE)\n        self.command_keys = {\n                    27: 'escape',\n                    9: 'tab',\n                    8: 'backspace',\n                    13: 'enter',\n                    127: 'del',\n                    271: 'enter',\n                    273: 'up',\n                    274: 'down',\n                    275: 'right',\n                    276: 'left',\n                    278: 'home',\n                    279: 'end',\n                    280: 'pgup',\n                    281: 'pgdown'}\n        self._mouse_buttons_down = set()\n        self.key_map = {SDLK_LEFT: 276, SDLK_RIGHT: 275, SDLK_UP: 273,\n                        SDLK_DOWN: 274, SDLK_HOME: 278, SDLK_END: 279,\n                        SDLK_PAGEDOWN: 281, SDLK_PAGEUP: 280, SDLK_SHIFTR: 303,\n                        SDLK_SHIFTL: 304, SDLK_SUPER: 309, SDLK_LCTRL: 305,\n                        SDLK_RCTRL: 306, SDLK_LALT: 308, SDLK_RALT: 307,\n                        SDLK_CAPS: 301, SDLK_INSERT: 277, SDLK_F1: 282,\n                        SDLK_F2: 283, SDLK_F3: 284, SDLK_F4: 285, SDLK_F5: 286,\n                        SDLK_F6: 287, SDLK_F7: 288, SDLK_F8: 289, SDLK_F9: 290,\n                        SDLK_F10: 291, SDLK_F11: 292, SDLK_F12: 293,\n                        SDLK_F13: 294, SDLK_F14: 295, SDLK_F15: 296,\n                        SDLK_KEYPADNUM: 300, SDLK_KP_DIVIDE: 267,\n                        SDLK_KP_MULTIPLY: 268, SDLK_KP_MINUS: 269,\n                        SDLK_KP_PLUS: 270, SDLK_KP_ENTER: 271,\n                        SDLK_KP_DOT: 266, SDLK_KP_0: 256, SDLK_KP_1: 257,\n                        SDLK_KP_2: 258, SDLK_KP_3: 259, SDLK_KP_4: 260,\n                        SDLK_KP_5: 261, SDLK_KP_6: 262, SDLK_KP_7: 263,\n                        SDLK_KP_8: 264, SDLK_KP_9: 265}\n        if platform == 'ios':\n            # XXX ios keyboard suck, when backspace is hit, the delete\n            # keycode is sent. fix it.\n            self.key_map[127] = 8\n        elif platform == 'android':\n            # map android back button to escape\n            self.key_map[1073742094] = 27\n\n        self.bind(minimum_width=self._set_minimum_size,\n                  minimum_height=self._set_minimum_size)\n\n        self.bind(allow_screensaver=self._set_allow_screensaver)\n        self.bind(always_on_top=self._set_always_on_top)",
  "def get_window_info(self):\n        return self._win.get_window_info()",
  "def _set_minimum_size(self, *args):\n        minimum_width = self.minimum_width\n        minimum_height = self.minimum_height\n        if minimum_width and minimum_height:\n            self._win.set_minimum_size(minimum_width, minimum_height)\n        elif minimum_width or minimum_height:\n            Logger.warning(\n                'Both Window.minimum_width and Window.minimum_height must be '\n                'bigger than 0 for the size restriction to take effect.')",
  "def _set_always_on_top(self, *args):\n        self._win.set_always_on_top(self.always_on_top)",
  "def _set_allow_screensaver(self, *args):\n        self._win.set_allow_screensaver(self.allow_screensaver)",
  "def _event_filter(self, action, *largs):\n        from kivy.app import App\n        if action == 'app_terminating':\n            EventLoop.quit = True\n\n        elif action == 'app_lowmemory':\n            self.dispatch('on_memorywarning')\n\n        elif action == 'app_willenterbackground':\n            from kivy.base import stopTouchApp\n            app = App.get_running_app()\n            if not app:\n                Logger.info('WindowSDL: No running App found, pause.')\n\n            elif not app.dispatch('on_pause'):\n                if platform == 'android':\n                    Logger.info(\n                        'WindowSDL: App stopped, on_pause() returned False.')\n                    from android import mActivity\n                    mActivity.finishAndRemoveTask()\n                else:\n                    Logger.info(\n                        'WindowSDL: App doesn\\'t support pause mode, stop.')\n                    stopTouchApp()\n                    return 0\n\n            self._pause_loop = True\n\n        elif action == 'app_didenterforeground':\n            # on iOS, the did enter foreground is launched at the start\n            # of the application. in our case, we want it only when the app\n            # is resumed\n            if self._pause_loop:\n                self._pause_loop = False\n                app = App.get_running_app()\n                if app:\n                    app.dispatch('on_resume')\n\n        elif action == 'windowresized':\n            self._size = largs\n            self._win.resize_window(*self._size)\n            # Force kivy to render the frame now, so that the canvas is drawn.\n            EventLoop.idle()\n\n        return 0",
  "def create_window(self, *largs):\n        if self._fake_fullscreen:\n            if not self.borderless:\n                self.fullscreen = self._fake_fullscreen = False\n            elif not self.fullscreen or self.fullscreen == 'auto':\n                self.custom_titlebar = \\\n                    self.borderless = self._fake_fullscreen = False\n            elif self.custom_titlebar:\n                if platform == 'win':\n                    # use custom behavior\n                    # To handle aero snapping and rounded corners\n                    self.borderless = False\n        if self.fullscreen == 'fake':\n            self.borderless = self._fake_fullscreen = True\n            Logger.warning(\"The 'fake' fullscreen option has been \"\n                           \"deprecated, use Window.borderless or the \"\n                           \"borderless Config option instead.\")\n\n        if not self.initialized:\n            if self.position == 'auto':\n                pos = None, None\n            elif self.position == 'custom':\n                pos = self.left, self.top\n\n            # ensure we have an event filter\n            self._win.set_event_filter(self._event_filter)\n\n            # setup window\n            w, h = self.system_size\n            resizable = Config.getboolean('graphics', 'resizable')\n            state = (Config.get('graphics', 'window_state')\n                     if self._is_desktop else None)\n            self.system_size = self._win.setup_window(\n                pos[0], pos[1], w, h, self.borderless,\n                self.fullscreen, resizable, state,\n                self.get_gl_backend_name())\n\n            # We don't have a density or dpi yet set, so let's ask for an update\n            self._update_density_and_dpi()\n\n            # never stay with a None pos, application using w.center\n            # will be fired.\n            self._pos = (0, 0)\n            self._set_minimum_size()\n            self._set_allow_screensaver()\n            self._set_always_on_top()\n\n            if state == 'hidden':\n                self._focus = False\n        else:\n            w, h = self.system_size\n            self._win.resize_window(w, h)\n            if platform == 'win':\n                if self.custom_titlebar:\n                    # check dragging+resize or just dragging\n                    if Config.getboolean('graphics', 'resizable'):\n                        import win32con\n                        import ctypes\n                        self._win.set_border_state(False)\n                        # make windows dispatch,\n                        # WM_NCCALCSIZE explicitly\n                        ctypes.windll.user32.SetWindowPos(\n                            self._win.get_window_info().window,\n                            win32con.HWND_TOP,\n                            *self._win.get_window_pos(),\n                            *self.system_size,\n                            win32con.SWP_FRAMECHANGED\n                        )\n                    else:\n                        self._win.set_border_state(True)\n                else:\n                    self._win.set_border_state(self.borderless)\n            else:\n                self._win.set_border_state(self.borderless\n                                           or self.custom_titlebar)\n            self._win.set_fullscreen_mode(self.fullscreen)\n\n        super(WindowSDL, self).create_window()\n        # set mouse visibility\n        self._set_cursor_state(self.show_cursor)\n\n        if self.initialized:\n            return\n\n        # auto add input provider\n        Logger.info('Window: auto add sdl2 input provider')\n        from kivy.base import EventLoop\n        SDL2MotionEventProvider.win = self\n        EventLoop.add_input_provider(SDL2MotionEventProvider('sdl', ''))\n\n        # set window icon before calling set_mode\n        try:\n            filename_icon = self.icon or Config.get('kivy', 'window_icon')\n            if filename_icon == '':\n                logo_size = 32\n                if platform == 'macosx':\n                    logo_size = 512\n                elif platform == 'win':\n                    logo_size = 64\n                filename_icon = 'kivy-icon-{}.png'.format(logo_size)\n                filename_icon = resource_find(\n                        join(kivy_data_dir, 'logo', filename_icon))\n            self.set_icon(filename_icon)\n        except:\n            Logger.exception('Window: cannot set icon')\n\n        if platform == 'win' and self._win_dpi_watch is None:\n            self._win_dpi_watch = _WindowsSysDPIWatch(window=self)\n            self._win_dpi_watch.start()",
  "def _update_density_and_dpi(self):\n        if platform == 'win':\n            from ctypes import windll\n            self._density = 1.\n            try:\n                hwnd = windll.user32.GetActiveWindow()\n                self.dpi = float(windll.user32.GetDpiForWindow(hwnd))\n            except AttributeError:\n                pass\n        else:\n            self._density = self._win._get_gl_size()[0] / self._size[0]\n            if self._is_desktop:\n                self.dpi = self._density * 96.",
  "def close(self):\n        self._win.teardown_window()\n        super(WindowSDL, self).close()\n        if self._win_dpi_watch is not None:\n            self._win_dpi_watch.stop()\n            self._win_dpi_watch = None\n\n        self.initialized = False",
  "def maximize(self):\n        if self._is_desktop:\n            self._win.maximize_window()\n        else:\n            Logger.warning('Window: maximize() is used only on desktop OSes.')",
  "def minimize(self):\n        if self._is_desktop:\n            self._win.minimize_window()\n        else:\n            Logger.warning('Window: minimize() is used only on desktop OSes.')",
  "def restore(self):\n        if self._is_desktop:\n            self._win.restore_window()\n        else:\n            Logger.warning('Window: restore() is used only on desktop OSes.')",
  "def hide(self):\n        if self._is_desktop:\n            self._win.hide_window()\n        else:\n            Logger.warning('Window: hide() is used only on desktop OSes.')",
  "def show(self):\n        if self._is_desktop:\n            self._win.show_window()\n        else:\n            Logger.warning('Window: show() is used only on desktop OSes.')",
  "def raise_window(self):\n        if self._is_desktop:\n            self._win.raise_window()\n        else:\n            Logger.warning('Window: show() is used only on desktop OSes.')",
  "def set_title(self, title):\n        self._win.set_window_title(title)",
  "def set_icon(self, filename):\n        self._win.set_window_icon(str(filename))",
  "def screenshot(self, *largs, **kwargs):\n        filename = super(WindowSDL, self).screenshot(*largs, **kwargs)\n        if filename is None:\n            return\n\n        from kivy.graphics.opengl import glReadPixels, GL_RGB, GL_UNSIGNED_BYTE\n        width, height = self.size\n        data = glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE)\n        self._win.save_bytes_in_png(filename, data, width, height)\n        Logger.debug('Window: Screenshot saved at <%s>' % filename)\n        return filename",
  "def flip(self):\n        self._win.flip()\n        super(WindowSDL, self).flip()",
  "def set_system_cursor(self, cursor_name):\n        result = self._win.set_system_cursor(cursor_name)\n        return result",
  "def _get_window_pos(self):\n        return self._win.get_window_pos()",
  "def _set_window_pos(self, x, y):\n        self._win.set_window_pos(x, y)",
  "def _is_shaped(self):\n        return self._win.is_window_shaped()",
  "def _set_shape(self, shape_image, mode='default',\n                   cutoff=False, color_key=None):\n        modes = ('default', 'binalpha', 'reversebinalpha', 'colorkey')\n        color_key = color_key or (0, 0, 0, 1)\n        if mode not in modes:\n            Logger.warning(\n                'Window: shape mode can be only '\n                '{}'.format(', '.join(modes))\n            )\n            return\n        if not isinstance(color_key, (tuple, list)):\n            return\n        if len(color_key) not in (3, 4):\n            return\n        if len(color_key) == 3:\n            color_key = (color_key[0], color_key[1], color_key[2], 1)\n            Logger.warning(\n                'Window: Shape color_key must be only tuple or list'\n            )\n            return\n        color_key = (\n            color_key[0] * 255,\n            color_key[1] * 255,\n            color_key[2] * 255,\n            color_key[3] * 255\n        )\n\n        assert cutoff in (1, 0)\n        shape_image = shape_image or Config.get('kivy', 'window_shape')\n        shape_image = resource_find(shape_image) or shape_image\n        self._win.set_shape(shape_image, mode, cutoff, color_key)",
  "def _get_shaped_mode(self):\n        return self._win.get_shaped_mode()",
  "def _set_shaped_mode(self, value):\n        self._set_shape(\n            shape_image=self.shape_image,\n            mode=value, cutoff=self.shape_cutoff,\n            color_key=self.shape_color_key\n        )\n        return self._win.get_shaped_mode()",
  "def _set_cursor_state(self, value):\n        self._win._set_cursor_state(value)",
  "def _fix_mouse_pos(self, x, y):\n        self.mouse_pos = (\n            x * self._density,\n            (self.system_size[1] - 1 - y) * self._density\n        )\n        return x, y",
  "def mainloop(self):\n        # for android/iOS, we don't want to have any event nor executing our\n        # main loop while the pause is going on. This loop wait any event (not\n        # handled by the event filter), and remove them from the queue.\n        # Nothing happen during the pause on iOS, except gyroscope value sent\n        # over joystick. So it's safe.\n        while self._pause_loop:\n            self._win.wait_event()\n            if not self._pause_loop:\n                break\n            event = self._win.poll()\n            if event is None:\n                continue\n            # A drop is send while the app is still in pause.loop\n            # we need to dispatch it\n            action, args = event[0], event[1:]\n            if action.startswith('drop'):\n                self._dispatch_drop_event(action, args)\n            # app_terminating event might be received while the app is paused\n            # in this case EventLoop.quit will be set at _event_filter\n            elif EventLoop.quit:\n                return\n\n        while True:\n            event = self._win.poll()\n            if event is False:\n                break\n            if event is None:\n                continue\n\n            action, args = event[0], event[1:]\n            if action == 'quit':\n                if self.dispatch('on_request_close'):\n                    continue\n                EventLoop.quit = True\n                break\n\n            elif action in ('fingermotion', 'fingerdown', 'fingerup'):\n                # for finger, pass the raw event to SDL motion event provider\n                # XXX this is problematic. On OSX, it generates touches with 0,\n                # 0 coordinates, at the same times as mouse. But it works.\n                # We have a conflict of using either the mouse or the finger.\n                # Right now, we have no mechanism that we could use to know\n                # which is the preferred one for the application.\n                if platform in ('ios', 'android'):\n                    SDL2MotionEventProvider.q.appendleft(event)\n                pass\n\n            elif action == 'mousemotion':\n                x, y = args\n                x, y = self._fix_mouse_pos(x, y)\n                self._mouse_x = x\n                self._mouse_y = y\n                if not self._cursor_entered:\n                    self._cursor_entered = True\n                    self.dispatch('on_cursor_enter')\n                # don't dispatch motion if no button are pressed\n                if len(self._mouse_buttons_down) == 0:\n                    continue\n                self._mouse_meta = self.modifiers\n                self.dispatch('on_mouse_move', x, y, self.modifiers)\n\n            elif action in ('mousebuttondown', 'mousebuttonup'):\n                x, y, button = args\n                x, y = self._fix_mouse_pos(x, y)\n                self._mouse_x = x\n                self._mouse_y = y\n                if not self._cursor_entered:\n                    self._cursor_entered = True\n                    self.dispatch('on_cursor_enter')\n                btn = 'left'\n                if button == 3:\n                    btn = 'right'\n                elif button == 2:\n                    btn = 'middle'\n                elif button == 4:\n                    btn = \"mouse4\"\n                elif button == 5:\n                    btn = \"mouse5\"\n                eventname = 'on_mouse_down'\n                self._mouse_buttons_down.add(button)\n                if action == 'mousebuttonup':\n                    eventname = 'on_mouse_up'\n                    self._mouse_buttons_down.remove(button)\n                self.dispatch(eventname, x, y, btn, self.modifiers)\n            elif action.startswith('mousewheel'):\n                x, y = self._win.get_relative_mouse_pos()\n                if not self._collide_and_dispatch_cursor_enter(x, y):\n                    # Ignore if the cursor position is on the window title bar\n                    # or on its edges\n                    continue\n                self._update_modifiers()\n                x, y, button = args\n                btn = 'scrolldown'\n                if action.endswith('up'):\n                    btn = 'scrollup'\n                elif action.endswith('right'):\n                    btn = 'scrollright'\n                elif action.endswith('left'):\n                    btn = 'scrollleft'\n\n                self._mouse_meta = self.modifiers\n                self._mouse_btn = btn\n                # times = x if y == 0 else y\n                # times = min(abs(times), 100)\n                # for k in range(times):\n                self._mouse_down = True\n                self.dispatch('on_mouse_down',\n                    self._mouse_x, self._mouse_y, btn, self.modifiers)\n                self._mouse_down = False\n                self.dispatch('on_mouse_up',\n                    self._mouse_x, self._mouse_y, btn, self.modifiers)\n\n            elif action.startswith('drop'):\n                self._dispatch_drop_event(action, args)\n            # video resize\n            elif action == 'windowresized':\n                self._size = self._win.window_size\n                # don't use trigger here, we want to delay the resize event\n                ev = self._do_resize_ev\n                if ev is None:\n                    ev = Clock.schedule_once(self._do_resize, .1)\n                    self._do_resize_ev = ev\n                else:\n                    ev()\n            elif action == 'windowdisplaychanged':\n                Logger.info(f\"WindowSDL: Window is now on display {args[0]}\")\n\n                # The display has changed, so the density and dpi\n                # may have changed too.\n                self._update_density_and_dpi()\n\n            elif action == 'windowmoved':\n                self.dispatch('on_move')\n\n            elif action == 'windowrestored':\n                self.dispatch('on_restore')\n                self.canvas.ask_update()\n\n            elif action == 'windowexposed':\n                self.canvas.ask_update()\n\n            elif action == 'windowminimized':\n                self.dispatch('on_minimize')\n                if Config.getboolean('kivy', 'pause_on_minimize'):\n                    self.do_pause()\n\n            elif action == 'windowmaximized':\n                self.dispatch('on_maximize')\n\n            elif action == 'windowhidden':\n                self.dispatch('on_hide')\n\n            elif action == 'windowshown':\n                self.dispatch('on_show')\n\n            elif action == 'windowfocusgained':\n                self._focus = True\n\n            elif action == 'windowfocuslost':\n                self._focus = False\n\n            elif action == 'windowenter':\n                x, y = self._win.get_relative_mouse_pos()\n                self._collide_and_dispatch_cursor_enter(x, y)\n\n            elif action == 'windowleave':\n                self._cursor_entered = False\n                self.dispatch('on_cursor_leave')\n\n            elif action == 'joyaxismotion':\n                stickid, axisid, value = args\n                self.dispatch('on_joy_axis', stickid, axisid, value)\n            elif action == 'joyhatmotion':\n                stickid, hatid, value = args\n                self.dispatch('on_joy_hat', stickid, hatid, value)\n            elif action == 'joyballmotion':\n                stickid, ballid, xrel, yrel = args\n                self.dispatch('on_joy_ball', stickid, ballid, xrel, yrel)\n            elif action == 'joybuttondown':\n                stickid, buttonid = args\n                self.dispatch('on_joy_button_down', stickid, buttonid)\n            elif action == 'joybuttonup':\n                stickid, buttonid = args\n                self.dispatch('on_joy_button_up', stickid, buttonid)\n\n            elif action in ('keydown', 'keyup'):\n                mod, key, scancode, kstr = args\n\n                try:\n                    key = self.key_map[key]\n                except KeyError:\n                    pass\n\n                if action == 'keydown':\n                    self._update_modifiers(mod, key)\n                else:\n                    # ignore the key, it has been released\n                    self._update_modifiers(mod)\n\n                # if mod in self._meta_keys:\n                if (key not in self._modifiers and\n                        key not in self.command_keys.keys()):\n                    try:\n                        kstr_chr = unichr(key)\n                        try:\n                            # On android, there is no 'encoding' attribute.\n                            # On other platforms, if stdout is redirected,\n                            # 'encoding' may be None\n                            encoding = getattr(sys.stdout, 'encoding',\n                                               'utf8') or 'utf8'\n                            kstr_chr.encode(encoding)\n                            kstr = kstr_chr\n                        except UnicodeError:\n                            pass\n                    except ValueError:\n                        pass\n                # if 'shift' in self._modifiers and key\\\n                #        not in self.command_keys.keys():\n                #    return\n\n                if action == 'keyup':\n                    self.dispatch('on_key_up', key, scancode)\n                    continue\n\n                # don't dispatch more key if down event is accepted\n                if self.dispatch('on_key_down', key,\n                                 scancode, kstr,\n                                 self.modifiers):\n                    continue\n                self.dispatch('on_keyboard', key,\n                              scancode, kstr,\n                              self.modifiers)\n\n            elif action == 'textinput':\n                text = args[0]\n                self.dispatch('on_textinput', text)\n\n            elif action == 'textedit':\n                text = args[0]\n                self.dispatch('on_textedit', text)\n\n            # unhandled event !\n            else:\n                Logger.trace('WindowSDL: Unhandled event %s' % str(event))",
  "def _dispatch_drop_event(self, action, args):\n        x, y = (0, 0) if self._drop_pos is None else self._drop_pos\n        if action == 'dropfile':\n            self.dispatch('on_drop_file', args[0], x, y)\n        elif action == 'droptext':\n            self.dispatch('on_drop_text', args[0], x, y)\n        elif action == 'dropbegin':\n            self._drop_pos = x, y = self._win.get_relative_mouse_pos()\n            self._collide_and_dispatch_cursor_enter(x, y)\n            self.dispatch('on_drop_begin', x, y)\n        elif action == 'dropend':\n            self._drop_pos = None\n            self.dispatch('on_drop_end', x, y)",
  "def _collide_and_dispatch_cursor_enter(self, x, y):\n        # x, y are relative to window left/top position\n        w, h = self._win.window_size\n        if 0 <= x < w and 0 <= y < h:\n            self._mouse_x, self._mouse_y = self._fix_mouse_pos(x, y)\n            if not self._cursor_entered:\n                self._cursor_entered = True\n                self.dispatch('on_cursor_enter')\n            return True",
  "def _do_resize(self, dt):\n        Logger.debug('Window: Resize window to %s' % str(self.size))\n        self._win.resize_window(*self._size)\n        self.dispatch('on_pre_resize', *self.size)",
  "def do_pause(self):\n        # should go to app pause mode (desktop style)\n        from kivy.app import App\n        from kivy.base import stopTouchApp\n        app = App.get_running_app()\n        if not app:\n            Logger.info('WindowSDL: No running App found, pause.')\n        elif not app.dispatch('on_pause'):\n            Logger.info('WindowSDL: App doesn\\'t support pause mode, stop.')\n            stopTouchApp()\n            return\n\n        # XXX FIXME wait for sdl resume\n        while True:\n            event = self._win.poll()\n            if event is False:\n                continue\n            if event is None:\n                continue\n\n            action, args = event[0], event[1:]\n            if action == 'quit':\n                EventLoop.quit = True\n                break\n            elif action == 'app_willenterforeground':\n                break\n            elif action == 'windowrestored':\n                break\n\n        if app:\n            app.dispatch('on_resume')",
  "def _update_modifiers(self, mods=None, key=None):\n        if mods is None and key is None:\n            return\n        modifiers = set()\n\n        if mods is not None:\n            if mods & (KMOD_RSHIFT | KMOD_LSHIFT):\n                modifiers.add('shift')\n            if mods & (KMOD_RALT | KMOD_LALT | KMOD_MODE):\n                modifiers.add('alt')\n            if mods & (KMOD_RCTRL | KMOD_LCTRL):\n                modifiers.add('ctrl')\n            if mods & (KMOD_RGUI | KMOD_LGUI):\n                modifiers.add('meta')\n            if mods & KMOD_NUM:\n                modifiers.add('numlock')\n            if mods & KMOD_CAPS:\n                modifiers.add('capslock')\n\n        if key is not None:\n            if key in (KMOD_RSHIFT, KMOD_LSHIFT):\n                modifiers.add('shift')\n            if key in (KMOD_RALT, KMOD_LALT, KMOD_MODE):\n                modifiers.add('alt')\n            if key in (KMOD_RCTRL, KMOD_LCTRL):\n                modifiers.add('ctrl')\n            if key in (KMOD_RGUI, KMOD_LGUI):\n                modifiers.add('meta')\n            if key == KMOD_NUM:\n                modifiers.add('numlock')\n            if key == KMOD_CAPS:\n                modifiers.add('capslock')\n\n        self._modifiers = list(modifiers)\n        return",
  "def request_keyboard(\n            self, callback, target, input_type='text', keyboard_suggestions=True\n    ):\n        self._sdl_keyboard = super(WindowSDL, self).\\\n            request_keyboard(\n            callback, target, input_type, keyboard_suggestions\n        )\n        self._win.show_keyboard(\n            self._system_keyboard,\n            self.softinput_mode,\n            input_type,\n            keyboard_suggestions,\n        )\n        Clock.schedule_interval(self._check_keyboard_shown, 1 / 5.)\n        return self._sdl_keyboard",
  "def release_keyboard(self, *largs):\n        super(WindowSDL, self).release_keyboard(*largs)\n        self._win.hide_keyboard()\n        self._sdl_keyboard = None\n        return True",
  "def _check_keyboard_shown(self, dt):\n        if self._sdl_keyboard is None:\n            return False\n        if not self._win.is_keyboard_shown():\n            self._sdl_keyboard.release()",
  "def map_key(self, original_key, new_key):\n        self.key_map[original_key] = new_key",
  "def unmap_key(self, key):\n        if key in self.key_map:\n            del self.key_map[key]",
  "def grab_mouse(self):\n        self._win.grab_mouse(True)",
  "def ungrab_mouse(self):\n        self._win.grab_mouse(False)",
  "def set_custom_titlebar(self, titlebar_widget):\n        if not self.custom_titlebar:\n            Logger.warning(\"Window: Window.custom_titlebar not set to True\u2026 \"\n                           \"can't set custom titlebar\")\n            return\n        self.titlebar_widget = titlebar_widget\n        return self._win.set_custom_titlebar(self.titlebar_widget) == 0",
  "def __init__(self, window: WindowBase):\n        self.window = window",
  "def start(self):\n        from kivy.input.providers.wm_common import WNDPROC, \\\n            SetWindowLong_WndProc_wrapper\n        from ctypes import windll\n\n        self.hwnd = windll.user32.GetActiveWindow()\n\n        # inject our own handler to handle messages before window manager\n        self.new_windProc = WNDPROC(self._wnd_proc)\n        self.old_windProc = SetWindowLong_WndProc_wrapper(\n            self.hwnd, self.new_windProc)",
  "def stop(self):\n        from kivy.input.providers.wm_common import \\\n            SetWindowLong_WndProc_wrapper\n\n        if self.hwnd is None:\n            return\n\n        self.new_windProc = SetWindowLong_WndProc_wrapper(\n            self.hwnd, self.old_windProc)\n        self.hwnd = self.new_windProc = self.old_windProc = None",
  "def _wnd_proc(self, hwnd, msg, wParam, lParam):\n        from kivy.input.providers.wm_common import WM_DPICHANGED, WM_NCCALCSIZE\n        from ctypes import windll\n\n        if msg == WM_DPICHANGED:\n\n            def clock_callback(*args):\n                if x_dpi != y_dpi:\n                    raise ValueError(\n                        'Can only handle DPI that are same for x and y')\n\n                self.window.dpi = x_dpi\n\n            x_dpi = wParam & 0xFFFF\n            y_dpi = wParam >> 16\n            Clock.schedule_once(clock_callback, -1)\n        elif Config.getboolean('graphics', 'resizable') \\\n                and msg == WM_NCCALCSIZE and self.window.custom_titlebar:\n            return 0\n        return windll.user32.CallWindowProcW(\n            self.old_windProc, hwnd, msg, wParam, lParam)",
  "def clock_callback(*args):\n                if x_dpi != y_dpi:\n                    raise ValueError(\n                        'Can only handle DPI that are same for x and y')\n\n                self.window.dpi = x_dpi",
  "class Keyboard(EventDispatcher):\n    '''Keyboard interface that is returned by\n    :meth:`WindowBase.request_keyboard`. When you request a keyboard,\n    you'll get an instance of this class. Whatever the keyboard input is\n    (system or virtual keyboard), you'll receive events through this\n    instance.\n\n    :Events:\n        `on_key_down`: keycode, text, modifiers\n            Fired when a new key is pressed down\n        `on_key_up`: keycode\n            Fired when a key is released (up)\n\n    Here is an example of how to request a Keyboard in accordance with the\n    current configuration:\n\n    .. include:: ../../examples/widgets/keyboardlistener.py\n        :literal:\n\n    '''\n\n    # Keycodes mapping, between str <-> int. These keycodes are\n    # currently taken from pygame.key. But when a new provider will be\n    # used, it must do the translation to these keycodes too.\n    keycodes = {\n        # specials keys\n        'backspace': 8, 'tab': 9, 'enter': 13, 'rshift': 303, 'shift': 304,\n        'alt': 308, 'rctrl': 306, 'lctrl': 305,\n        'super': 309, 'alt-gr': 307, 'compose': 311, 'pipe': 310,\n        'capslock': 301, 'escape': 27, 'spacebar': 32, 'pageup': 280,\n        'pagedown': 281, 'end': 279, 'home': 278, 'left': 276, 'up':\n        273, 'right': 275, 'down': 274, 'insert': 277, 'delete': 127,\n        'numlock': 300, 'print': 144, 'screenlock': 145, 'pause': 19,\n\n        # a-z keys\n        'a': 97, 'b': 98, 'c': 99, 'd': 100, 'e': 101, 'f': 102, 'g': 103,\n        'h': 104, 'i': 105, 'j': 106, 'k': 107, 'l': 108, 'm': 109, 'n': 110,\n        'o': 111, 'p': 112, 'q': 113, 'r': 114, 's': 115, 't': 116, 'u': 117,\n        'v': 118, 'w': 119, 'x': 120, 'y': 121, 'z': 122,\n\n        # 0-9 keys\n        '0': 48, '1': 49, '2': 50, '3': 51, '4': 52,\n        '5': 53, '6': 54, '7': 55, '8': 56, '9': 57,\n\n        # numpad\n        'numpad0': 256, 'numpad1': 257, 'numpad2': 258, 'numpad3': 259,\n        'numpad4': 260, 'numpad5': 261, 'numpad6': 262, 'numpad7': 263,\n        'numpad8': 264, 'numpad9': 265, 'numpaddecimal': 266,\n        'numpaddivide': 267, 'numpadmul': 268, 'numpadsubstract': 269,\n        'numpadadd': 270, 'numpadenter': 271,\n\n        # F1-15\n        'f1': 282, 'f2': 283, 'f3': 284, 'f4': 285, 'f5': 286, 'f6': 287,\n        'f7': 288, 'f8': 289, 'f9': 290, 'f10': 291, 'f11': 292, 'f12': 293,\n        'f13': 294, 'f14': 295, 'f15': 296,\n\n        # other keys\n        '(': 40, ')': 41,\n        '[': 91, ']': 93,\n        '{': 123, '}': 125,\n        ':': 58, ';': 59,\n        '=': 61, '+': 43,\n        '-': 45, '_': 95,\n        '/': 47, '*': 42,\n        '?': 47,\n        '`': 96, '~': 126,\n        '\u00b4': 180, '\u00a6': 166,\n        '\\\\': 92, '|': 124,\n        '\"': 34, \"'\": 39,\n        ',': 44, '.': 46,\n        '<': 60, '>': 62,\n        '@': 64, '!': 33,\n        '#': 35, '$': 36,\n        '%': 37, '^': 94,\n        '&': 38, '\u00ac': 172,\n        '\u00a8': 168, '\u2026': 8230,\n        '\u00f9': 249, '\u00e0': 224,\n        '\u00e9': 233, '\u00e8': 232,\n    }\n\n    __events__ = ('on_key_down', 'on_key_up', 'on_textinput')\n\n    def __init__(self, **kwargs):\n        super(Keyboard, self).__init__()\n\n        #: Window which the keyboard is attached too\n        self.window = kwargs.get('window', None)\n\n        #: Callback that will be called when the keyboard is released\n        self.callback = kwargs.get('callback', None)\n\n        #: Target that have requested the keyboard\n        self.target = kwargs.get('target', None)\n\n        #: VKeyboard widget, if allowed by the configuration\n        self.widget = kwargs.get('widget', None)\n\n    def on_key_down(self, keycode, text, modifiers):\n        pass\n\n    def on_key_up(self, keycode):\n        pass\n\n    def on_textinput(self, text):\n        pass\n\n    def release(self):\n        '''Call this method to release the current keyboard.\n        This will ensure that the keyboard is no longer attached to your\n        callback.'''\n        if self.window:\n            self.window.release_keyboard(self.target)\n            self.target = None\n\n    def _on_window_textinput(self, instance, text):\n        return self.dispatch('on_textinput', text)\n\n    def _on_window_key_down(self, instance, keycode, scancode, text,\n                            modifiers):\n        keycode = (keycode, self.keycode_to_string(keycode))\n        if text == '\\x04':\n            Window.trigger_keyboard_height()\n            return\n        return self.dispatch('on_key_down', keycode, text, modifiers)\n\n    def _on_window_key_up(self, instance, keycode, *largs):\n        keycode = (keycode, self.keycode_to_string(keycode))\n        return self.dispatch('on_key_up', keycode)\n\n    def _on_vkeyboard_key_down(self, instance, keycode, text, modifiers):\n        if keycode is None:\n            keycode = text.lower()\n        keycode = (self.string_to_keycode(keycode), keycode)\n        return self.dispatch('on_key_down', keycode, text, modifiers)\n\n    def _on_vkeyboard_key_up(self, instance, keycode, text, modifiers):\n        if keycode is None:\n            keycode = text\n        keycode = (self.string_to_keycode(keycode), keycode)\n        return self.dispatch('on_key_up', keycode)\n\n    def _on_vkeyboard_textinput(self, instance, text):\n        return self.dispatch('on_textinput', text)\n\n    def string_to_keycode(self, value):\n        '''Convert a string to a keycode number according to the\n        :attr:`Keyboard.keycodes`. If the value is not found in the\n        keycodes, it will return -1.\n        '''\n        return Keyboard.keycodes.get(value, -1)\n\n    def keycode_to_string(self, value):\n        '''Convert a keycode number to a string according to the\n        :attr:`Keyboard.keycodes`. If the value is not found in the\n        keycodes, it will return ''.\n        '''\n        keycodes = list(Keyboard.keycodes.values())\n        if value in keycodes:\n            return list(Keyboard.keycodes.keys())[keycodes.index(value)]\n        return ''",
  "class WindowBase(EventDispatcher):\n    '''WindowBase is an abstract window widget for any window implementation.\n\n    :Parameters:\n        `borderless`: str, one of ('0', '1')\n            Set the window border state. Check the\n            :mod:`~kivy.config` documentation for a\n            more detailed explanation on the values.\n        `custom_titlebar`: str, one of ('0', '1')\n            Set to `'1'` to uses a custom titlebar\n        `fullscreen`: str, one of ('0', '1', 'auto', 'fake')\n            Make the window fullscreen. Check the\n            :mod:`~kivy.config` documentation for a\n            more detailed explanation on the values.\n        `width`: int\n            Width of the window.\n        `height`: int\n            Height of the window.\n        `minimum_width`: int\n            Minimum width of the window (only works for sdl2 window provider).\n        `minimum_height`: int\n            Minimum height of the window (only works for sdl2 window provider).\n        `always_on_top`: bool\n            When enabled, the window will be brought to the front and will keep\n            the window above the rest. If disabled, it will restore the default\n            behavior. Only works for the sdl2 window provider.\n        `allow_screensaver`: bool\n            Allow the device to show a screen saver, or to go to sleep\n            on mobile devices. Defaults to True. Only works for sdl2 window\n            provider.\n\n    :Events:\n        `on_motion`: etype, motionevent\n            Fired when a new :class:`~kivy.input.motionevent.MotionEvent` is\n            dispatched\n        `on_touch_down`:\n            Fired when a new touch event is initiated.\n        `on_touch_move`:\n            Fired when an existing touch event changes location.\n        `on_touch_up`:\n            Fired when an existing touch event is terminated.\n        `on_draw`:\n            Fired when the :class:`Window` is being drawn.\n        `on_flip`:\n            Fired when the :class:`Window` GL surface is being flipped.\n        `on_rotate`: rotation\n            Fired when the :class:`Window` is being rotated.\n        `on_close`:\n            Fired when the :class:`Window` is closed.\n        `on_request_close`:\n            Fired when the event loop wants to close the window, or if the\n            escape key is pressed and `exit_on_escape` is `True`. If a function\n            bound to this event returns `True`, the window will not be closed.\n            If the event is triggered because of the keyboard escape key,\n            the keyword argument `source` is dispatched along with a value of\n            `keyboard` to the bound functions.\n\n            .. versionadded:: 1.9.0\n\n        `on_cursor_enter`:\n            Fired when the cursor enters the window.\n\n            .. versionadded:: 1.9.1\n\n        `on_cursor_leave`:\n            Fired when the cursor leaves the window.\n\n            .. versionadded:: 1.9.1\n\n        `on_minimize`:\n            Fired when the window is minimized.\n\n            .. versionadded:: 1.10.0\n\n        `on_maximize`:\n            Fired when the window is maximized.\n\n            .. versionadded:: 1.10.0\n\n        `on_restore`:\n            Fired when the window is restored.\n\n            .. versionadded:: 1.10.0\n\n        `on_hide`:\n            Fired when the window is hidden.\n\n            .. versionadded:: 1.10.0\n\n        `on_show`:\n            Fired when the window is shown.\n\n            .. versionadded:: 1.10.0\n\n        `on_keyboard`: key, scancode, codepoint, modifier\n            Fired when the keyboard is used for input.\n\n            .. versionchanged:: 1.3.0\n                The *unicode* parameter has been deprecated in favor of\n                codepoint, and will be removed completely in future versions.\n\n        `on_key_down`: key, scancode, codepoint, modifier\n            Fired when a key pressed.\n\n            .. versionchanged:: 1.3.0\n                The *unicode* parameter has been deprecated in favor of\n                codepoint, and will be removed completely in future versions.\n\n        `on_key_up`: key, scancode, codepoint\n            Fired when a key is released.\n\n            .. versionchanged:: 1.3.0\n                The *unicode* parameter has be deprecated in favor of\n                codepoint, and will be removed completely in future versions.\n\n        `on_drop_begin`: x, y, *args\n            Fired when text(s) or file(s) drop on the application is about to\n            begin.\n\n            .. versionadded:: 2.1.0\n\n        `on_drop_file`: filename (bytes), x, y, *args\n            Fired when a file is dropped on the application.\n\n            .. versionadded:: 1.2.0\n\n            .. versionchanged:: 2.1.0\n                Renamed from `on_dropfile` to `on_drop_file`.\n\n        `on_drop_text`: text (bytes), x, y, *args\n            Fired when a text is dropped on the application.\n\n            .. versionadded:: 2.1.0\n\n        `on_drop_end`: x, y, *args\n            Fired when text(s) or file(s) drop on the application has ended.\n\n            .. versionadded:: 2.1.0\n\n        `on_memorywarning`:\n            Fired when the platform have memory issue (iOS / Android mostly)\n            You can listen to this one, and clean whatever you can.\n\n            .. versionadded:: 1.9.0\n\n        `on_textedit(self, text)`:\n            Fired when inputting with IME.\n            The string inputting with IME is set as the parameter of\n            this event.\n\n            .. versionadded:: 1.10.1\n    '''\n\n    __instance = None\n    __initialized = False\n    _fake_fullscreen = False\n\n    # private properties\n    _density = NumericProperty(1.)\n    _size = ListProperty([0, 0])\n    _modifiers = ListProperty([])\n    _rotation = NumericProperty(0)\n    _focus = BooleanProperty(True)\n\n    gl_backends_allowed = []\n    \"\"\"\n    A list of Kivy gl backend names, which if not empty, will be the\n    exclusive list of gl backends that can be used with this window.\n    \"\"\"\n\n    gl_backends_ignored = []\n    \"\"\"\n    A list of Kivy gl backend names that may not be used with this window.\n    \"\"\"\n\n    managed_textinput = False\n    \"\"\"\n    True if this Window class uses `on_textinput` to insert text, internal.\n    \"\"\"\n\n    children = ListProperty([])\n    '''List of the children of this window.\n\n    :attr:`children` is a :class:`~kivy.properties.ListProperty` instance and\n    defaults to an empty list.\n\n    Use :meth:`add_widget` and :meth:`remove_widget` to manipulate the list of\n    children. Don't manipulate the list directly unless you know what you are\n    doing.\n    '''\n\n    parent = ObjectProperty(None, allownone=True)\n    '''Parent of this window.\n\n    :attr:`parent` is a :class:`~kivy.properties.ObjectProperty` instance and\n    defaults to None. When created, the parent is set to the window itself.\n    You must take care of it if you are doing a recursive check.\n    '''\n\n    icon = StringProperty()\n    '''A path to the window icon.\n\n    .. versionadded:: 1.1.2\n\n    :attr:`icon` is a :class:`~kivy.properties.StringProperty`.\n    '''\n\n    def _get_modifiers(self):\n        return self._modifiers\n\n    modifiers = AliasProperty(_get_modifiers, None, bind=('_modifiers',))\n    '''List of keyboard modifiers currently active.\n\n    .. versionadded:: 1.0.9\n\n    :attr:`modifiers` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def _get_size(self):\n        r = self._rotation\n        w, h = self._size\n        if platform == 'win' or self._density != 1:\n            w, h = self._win._get_gl_size()\n        if self.softinput_mode == 'resize':\n            h -= self.keyboard_height\n        if r in (0, 180):\n            return w, h\n        return h, w\n\n    def _set_size(self, size):\n        if self._size != size:\n            r = self._rotation\n            if r in (0, 180):\n                self._size = size\n            else:\n                self._size = size[1], size[0]\n            self.dispatch('on_pre_resize', *size)\n\n    minimum_width = NumericProperty(0)\n    '''The minimum width to restrict the window to.\n\n    .. versionadded:: 1.9.1\n\n    :attr:`minimum_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    minimum_height = NumericProperty(0)\n    '''The minimum height to restrict the window to.\n\n    .. versionadded:: 1.9.1\n\n    :attr:`minimum_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    always_on_top = BooleanProperty(False)\n    '''When enabled, the window will be brought to the front and will keep\n    the window above the rest. If disabled, it will restore the default\n    behavior.\n\n    This option can be toggled freely during the window's lifecycle.\n\n    Only works for the sdl2 window provider. Check the :mod:`~kivy.config`\n    documentation for a more detailed explanation on the values.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`always_on_top` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    allow_screensaver = BooleanProperty(True)\n    '''Whether the screen saver is enabled, or on mobile devices whether the\n    device is allowed to go to sleep while the app is open.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`allow_screensaver` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True.\n    '''\n\n    size = AliasProperty(_get_size, _set_size, bind=('_size', '_rotation'))\n    '''Get the rotated size of the window. If :attr:`rotation` is set, then the\n    size will change to reflect the rotation.\n\n    .. versionadded:: 1.0.9\n\n    :attr:`size` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    clearcolor = ColorProperty((0, 0, 0, 1))\n    '''Color used to clear the window.\n\n    ::\n\n        from kivy.core.window import Window\n\n        # red background color\n        Window.clearcolor = (1, 0, 0, 1)\n\n        # don't clear background at all\n        Window.clearcolor = None\n\n    .. versionchanged:: 1.7.2\n        The clearcolor default value is now: (0, 0, 0, 1).\n\n    .. versionadded:: 1.0.9\n\n    :attr:`clearcolor` is an :class:`~kivy.properties.ColorProperty` and\n    defaults to (0, 0, 0, 1).\n\n    .. versionchanged:: 2.1.0\n        Changed from :class:`~kivy.properties.AliasProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    # make some property read-only\n    def _get_width(self):\n        _size = self._size\n        if platform == 'win' or self._density != 1:\n            _size = self._win._get_gl_size()\n        r = self._rotation\n        if r == 0 or r == 180:\n            return _size[0]\n        return _size[1]\n\n    width = AliasProperty(_get_width, bind=('_rotation', '_size', '_density'))\n    '''Rotated window width.\n\n    :attr:`width` is a read-only :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def _get_height(self):\n        '''Rotated window height'''\n        r = self._rotation\n        _size = self._size\n        if platform == 'win' or self._density != 1:\n            _size = self._win._get_gl_size()\n        kb = self.keyboard_height if self.softinput_mode == 'resize' else 0\n        if r == 0 or r == 180:\n            return _size[1] - kb\n        return _size[0] - kb\n\n    height = AliasProperty(_get_height,\n                           bind=('_rotation', '_size', '_density'))\n    '''Rotated window height.\n\n    :attr:`height` is a read-only :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def _get_center(self):\n        return self.width / 2., self.height / 2.\n\n    center = AliasProperty(_get_center, bind=('width', 'height'))\n    '''Center of the rotated window.\n\n    .. versionadded:: 1.0.9\n\n    :attr:`center` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def _get_rotation(self):\n        return self._rotation\n\n    def _set_rotation(self, x):\n        x = int(x % 360)\n        if x == self._rotation:\n            return\n        if x not in (0, 90, 180, 270):\n            raise ValueError('can rotate only 0, 90, 180, 270 degrees')\n        self._rotation = x\n        if not self.initialized:\n            return\n        self.dispatch('on_pre_resize', *self.size)\n        self.dispatch('on_rotate', x)\n\n    rotation = AliasProperty(_get_rotation, _set_rotation,\n                             bind=('_rotation', ))\n    '''Get/set the window content rotation. Can be one of 0, 90, 180, 270\n    degrees.\n\n    .. versionadded:: 1.0.9\n\n    :attr:`rotation` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    softinput_mode = OptionProperty(\n        '', options=('', 'below_target', 'pan', 'scale', 'resize')\n    )\n    '''This specifies the behavior of window contents on display of the soft\n    keyboard on mobile platforms. It can be one of '', 'pan', 'scale',\n    'resize' or 'below_target'. Their effects are listed below.\n\n    +----------------+-------------------------------------------------------+\n    | Value          | Effect                                                |\n    +================+=======================================================+\n    | ''             | The main window is left as is, allowing you to use    |\n    |                | the :attr:`keyboard_height` to manage the window      |\n    |                | contents manually.                                    |\n    +----------------+-------------------------------------------------------+\n    | 'pan'          | The main window pans, moving the bottom part of the   |\n    |                | window to be always on top of the keyboard.           |\n    +----------------+-------------------------------------------------------+\n    | 'resize'       | The window is resized and the contents scaled to fit  |\n    |                | the remaining space.                                  |\n    +----------------+-------------------------------------------------------+\n    | 'below_target' | The window pans so that the current target TextInput  |\n    |                | widget requesting the keyboard is presented just above|\n    |                | the soft keyboard.                                    |\n    +----------------+-------------------------------------------------------+\n\n    :attr:`softinput_mode` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to ''.\n\n    .. note:: The `resize` option does not currently work with SDL2 on Android.\n\n    .. versionadded:: 1.9.0\n\n    .. versionchanged:: 1.9.1\n        The 'below_target' option was added.\n    '''\n\n    _keyboard_changed = BooleanProperty(False)\n    _kheight = NumericProperty(0)\n    _kanimation = None\n\n    def _free_kanimation(self, *largs):\n        WindowBase._kanimation = None\n\n    def _animate_content(self):\n        '''Animate content to IME height.\n        '''\n        kargs = self.keyboard_anim_args\n        global Animation\n        if not Animation:\n            from kivy.animation import Animation\n        if WindowBase._kanimation:\n            WindowBase._kanimation.cancel(self)\n        WindowBase._kanimation = kanim = Animation(\n            _kheight=self.keyboard_height + self.keyboard_padding,\n            d=kargs['d'], t=kargs['t'])\n        kanim.bind(on_complete=self._free_kanimation)\n        kanim.start(self)\n\n    def _upd_kbd_height(self, *kargs):\n        self._keyboard_changed = not self._keyboard_changed\n        self._animate_content()\n\n    def _get_ios_kheight(self):\n        import ios\n        return ios.get_kheight()\n\n    def _get_android_kheight(self):\n        if USE_SDL2:  # Placeholder until the SDL2 bootstrap supports this\n            return 0\n        global android\n        if not android:\n            import android\n        return android.get_keyboard_height()\n\n    def _get_kivy_vkheight(self):\n        mode = Config.get('kivy', 'keyboard_mode')\n        if (\n            mode in ['dock', 'systemanddock']\n            and self._vkeyboard_cls is not None\n        ):\n            for w in self.children:\n                if isinstance(w, self._vkeyboard_cls):\n                    vkeyboard_height = w.height * w.scale\n                    if self.softinput_mode == 'pan':\n                        return vkeyboard_height\n                    elif (\n                        self.softinput_mode == 'below_target'\n                        and w.target.y < vkeyboard_height\n                    ):\n                        return vkeyboard_height - w.target.y\n        return 0\n\n    def _get_kheight(self):\n        if platform == 'android':\n            return self._get_android_kheight()\n        elif platform == 'ios':\n            return self._get_ios_kheight()\n        return self._get_kivy_vkheight()\n\n    keyboard_height = AliasProperty(_get_kheight, bind=('_keyboard_changed',))\n    '''Returns the height of the softkeyboard/IME on mobile platforms.\n    Will return 0 if not on mobile platform or if IME is not active.\n\n    .. note:: This property returns 0 with SDL2 on Android, but setting\n              Window.softinput_mode does work.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`keyboard_height` is a read-only\n    :class:`~kivy.properties.AliasProperty` and defaults to 0.\n    '''\n\n    keyboard_anim_args = {'t': 'in_out_quart', 'd': .5}\n    '''The attributes for animating softkeyboard/IME.\n    `t` = `transition`, `d` = `duration`. This value will have no effect on\n    desktops.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`keyboard_anim_args` is a dict and defaults to\n    {'t': 'in_out_quart', 'd': `.5`}.\n    '''\n\n    keyboard_padding = NumericProperty(0)\n    '''The padding to have between the softkeyboard/IME & target\n    or bottom of window. Will have no effect on desktops.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`keyboard_padding` is a\n    :class:`~kivy.properties.NumericProperty` and defaults to 0.\n    '''\n\n    def _set_system_size(self, size):\n        self._size = size\n\n    def _get_system_size(self):\n        if self.softinput_mode == 'resize':\n            return self._size[0], self._size[1] - self.keyboard_height\n        return self._size\n\n    system_size = AliasProperty(_get_system_size, _set_system_size,\n                                bind=('_size',))\n    '''Real size of the window ignoring rotation. If the density is\n    not 1, the :attr:`system_size` is the :attr:`size` divided by\n    density.\n\n    .. versionadded:: 1.0.9\n\n    :attr:`system_size` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def _get_effective_size(self):\n        '''On density=1 and non-ios / non-Windows displays,\n        return :attr:`system_size`, else return scaled / rotated :attr:`size`.\n\n        Used by MouseMotionEvent.update_graphics() and WindowBase.on_motion().\n        '''\n        w, h = self.system_size\n        if platform in ('ios', 'win') or self._density != 1:\n            w, h = self.size\n\n        return w, h\n\n    borderless = BooleanProperty(False)\n    '''When set to True, this property removes the window border/decoration.\n    Check the :mod:`~kivy.config` documentation for a more detailed\n    explanation on the values.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`borderless` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    custom_titlebar = BooleanProperty(False)\n    '''When set to True, allows the user to set a widget as a titlebar.\n    Check the :mod:`~kivy.config` documentation for a more detailed\n    explanation on the values.\n\n    .. versionadded:: 2.1.0\n\n    see :meth:`~kivy.core.window.WindowBase.set_custom_titlebar`\n    for detailed usage\n    :attr:`custom_titlebar` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    fullscreen = OptionProperty(False, options=(True, False, 'auto', 'fake'))\n    '''This property sets the fullscreen mode of the window. Available options\n    are: True, False, 'auto' and 'fake'. Check the :mod:`~kivy.config`\n    documentation for more detailed explanations on these values.\n\n    fullscreen is an :class:`~kivy.properties.OptionProperty` and defaults to\n    `False`.\n\n    .. versionadded:: 1.2.0\n\n    .. note::\n        The 'fake' option has been deprecated, use the :attr:`borderless`\n        property instead.\n\n    .. warning::\n        On iOS, setting :attr:`fullscreen` to `False` will not automatically\n        hide the status bar.\n\n        To achieve this, you must set :attr:`fullscreen` to `False`, and\n        then also set :attr:`borderless` to `False`.\n    '''\n\n    mouse_pos = ObjectProperty((0, 0))\n    '''2d position of the mouse cursor within the window.\n\n    Position is relative to the left/bottom point of the window.\n\n    .. note::\n        Cursor position will be scaled by the pixel density if the high density\n        mode is supported by the window provider.\n\n    .. versionadded:: 1.2.0\n\n    :attr:`mouse_pos` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to (0, 0).\n    '''\n\n    show_cursor = BooleanProperty(True)\n    '''Set whether or not the cursor is shown on the window.\n\n    .. versionadded:: 1.9.1\n\n    :attr:`show_cursor` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    def _get_focus(self):\n        return self._focus\n\n    focus = AliasProperty(_get_focus, None, bind=('_focus',))\n    '''Check whether or not the window currently has focus.\n\n    .. versionadded:: 1.9.1\n\n    :attr:`focus` is a read-only :class:`~kivy.properties.AliasProperty` and\n    defaults to True.\n    '''\n\n    def _set_cursor_state(self, value):\n        pass\n\n    def set_system_cursor(self, cursor_name):\n        '''Set type of a mouse cursor in the Window.\n\n        It can be one of 'arrow', 'ibeam', 'wait', 'crosshair', 'wait_arrow',\n        'size_nwse', 'size_nesw', 'size_we', 'size_ns', 'size_all', 'no', or\n        'hand'.\n\n        On some platforms there might not be a specific cursor supported and\n        such an option falls back to one of the substitutable alternatives:\n\n        +------------+-----------+------------+-----------+---------------+\n        |            | Windows   | MacOS      | Linux X11 | Linux Wayland |\n        +============+===========+============+===========+===============+\n        | arrow      | arrow     | arrow      | arrow     | arrow         |\n        +------------+-----------+------------+-----------+---------------+\n        | ibeam      | ibeam     | ibeam      | ibeam     | ibeam         |\n        +------------+-----------+------------+-----------+---------------+\n        | wait       | wait      | arrow      | wait      | wait          |\n        +------------+-----------+------------+-----------+---------------+\n        | crosshair  | crosshair | crosshair  | crosshair | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | wait_arrow | arrow     | arrow      | wait      | wait          |\n        +------------+-----------+------------+-----------+---------------+\n        | size_nwse  | size_nwse | size_all   | size_all  | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | size_nesw  | size_nesw | size_all   | size_all  | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | size_we    | size_we   | size_we    | size_we   | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | size_ns    | size_ns   | size_ns    | size_ns   | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | size_all   | size_all  | size_all   | size_all  | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | no         | no        | no         | no        | ibeam         |\n        +------------+-----------+------------+-----------+---------------+\n        | hand       | hand      | hand       | hand      | hand          |\n        +------------+-----------+------------+-----------+---------------+\n\n        .. versionadded:: 1.10.1\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        pass\n\n    def _get_window_pos(self):\n        pass\n\n    def _set_window_pos(self, x, y):\n        pass\n\n    def _get_left(self):\n        if not self.initialized:\n            return self._left\n        return self._get_window_pos()[0]\n\n    def _set_left(self, value):\n        pos = self._get_window_pos()\n        self._set_window_pos(value, pos[1])\n\n    def _get_top(self):\n        if not self.initialized:\n            return self._top\n        return self._get_window_pos()[1]\n\n    def _set_top(self, value):\n        pos = self._get_window_pos()\n        self._set_window_pos(pos[0], value)\n\n    top = AliasProperty(_get_top, _set_top)\n    '''Top position of the window.\n\n    .. note:: It's an SDL2 property with `[0, 0]` in the top-left corner.\n\n    .. versionchanged:: 1.10.0\n        :attr:`top` is now an :class:`~kivy.properties.AliasProperty`\n\n    .. versionadded:: 1.9.1\n\n    :attr:`top` is an :class:`~kivy.properties.AliasProperty` and defaults to\n    the position set in :class:`~kivy.config.Config`.\n    '''\n\n    left = AliasProperty(_get_left, _set_left)\n    '''Left position of the window.\n\n    .. note:: It's an SDL2 property with `[0, 0]` in the top-left corner.\n\n    .. versionchanged:: 1.10.0\n        :attr:`left` is now an :class:`~kivy.properties.AliasProperty`\n\n    .. versionadded:: 1.9.1\n\n    :attr:`left` is an :class:`~kivy.properties.AliasProperty` and defaults to\n    the position set in :class:`~kivy.config.Config`.\n    '''\n\n    @property\n    def __self__(self):\n        return self\n\n    position = OptionProperty('auto', options=['auto', 'custom'])\n    render_context = ObjectProperty(None)\n    canvas = ObjectProperty(None)\n    title = StringProperty('Kivy')\n\n    event_managers = None\n    '''Holds a `list` of registered event managers.\n\n    Don't change the property directly but use\n    :meth:`register_event_manager` and :meth:`unregister_event_manager` to\n    register and unregister an event manager.\n\n    Event manager is an instance of\n    :class:`~kivy.eventmanager.EventManagerBase`.\n\n    .. versionadded:: 2.1.0\n\n    .. warning::\n        This is an experimental property and it remains so while this warning\n        is present.\n    '''\n\n    event_managers_dict = None\n    '''Holds a `dict` of `type_id` to `list` of event managers.\n\n    Don't change the property directly but use\n    :meth:`register_event_manager` and :meth:`unregister_event_manager` to\n    register and unregister an event manager.\n\n    Event manager is an instance of\n    :class:`~kivy.eventmanager.EventManagerBase`.\n\n    .. versionadded:: 2.1.0\n\n    .. warning::\n        This is an experimental property and it remains so while this warning\n        is present.\n    '''\n\n    trigger_create_window = None\n\n    __events__ = (\n        'on_draw', 'on_flip', 'on_rotate', 'on_resize', 'on_move',\n        'on_close', 'on_minimize', 'on_maximize', 'on_restore',\n        'on_hide', 'on_show', 'on_motion', 'on_touch_down',\n        'on_touch_move', 'on_touch_up', 'on_mouse_down',\n        'on_mouse_move', 'on_mouse_up', 'on_keyboard', 'on_key_down',\n        'on_key_up', 'on_textinput', 'on_drop_begin', 'on_drop_file',\n        'on_dropfile', 'on_drop_text', 'on_drop_end', 'on_request_close',\n        'on_cursor_enter', 'on_cursor_leave', 'on_joy_axis',\n        'on_joy_hat', 'on_joy_ball', 'on_joy_button_down',\n        'on_joy_button_up', 'on_memorywarning', 'on_textedit',\n        # internal\n        'on_pre_resize')\n\n    def __new__(cls, **kwargs):\n        if cls.__instance is None:\n            cls.__instance = EventDispatcher.__new__(cls)\n        return cls.__instance\n\n    def __init__(self, **kwargs):\n        force = kwargs.pop('force', False)\n\n        # don't init window 2 times,\n        # except if force is specified\n        if WindowBase.__instance is not None and not force:\n            return\n\n        self.initialized = False\n        self.event_managers = []\n        self.event_managers_dict = defaultdict(list)\n        self._is_desktop = Config.getboolean('kivy', 'desktop')\n\n        # create a trigger for update/create the window when one of window\n        # property changes\n        self.trigger_create_window = Clock.create_trigger(\n            self.create_window, -1)\n\n        # Create a trigger for updating the keyboard height\n        self.trigger_keyboard_height = Clock.create_trigger(\n            self._upd_kbd_height, .5)\n        self.bind(_kheight=lambda *args: self.update_viewport())\n\n        # set the default window parameter according to the configuration\n        if 'borderless' not in kwargs:\n            kwargs['borderless'] = Config.getboolean('graphics', 'borderless')\n        if 'custom_titlebar' not in kwargs:\n            kwargs['custom_titlebar'] = Config.getboolean('graphics',\n                                                          'custom_titlebar')\n        if 'fullscreen' not in kwargs:\n            fullscreen = Config.get('graphics', 'fullscreen')\n            if fullscreen not in ('auto', 'fake'):\n                fullscreen = fullscreen.lower() in ('true', '1', 'yes')\n            kwargs['fullscreen'] = fullscreen\n        if 'width' not in kwargs:\n            kwargs['width'] = Config.getint('graphics', 'width')\n        if 'height' not in kwargs:\n            kwargs['height'] = Config.getint('graphics', 'height')\n        if 'minimum_width' not in kwargs:\n            kwargs['minimum_width'] = Config.getint('graphics',\n                                                    'minimum_width')\n        if 'minimum_height' not in kwargs:\n            kwargs['minimum_height'] = Config.getint('graphics',\n                                                     'minimum_height')\n        if 'always_on_top' not in kwargs:\n            kwargs['always_on_top'] = Config.getboolean(\n                'graphics', 'always_on_top'\n            )\n        if 'allow_screensaver' not in kwargs:\n            kwargs['allow_screensaver'] = Config.getboolean(\n                'graphics', 'allow_screensaver')\n        if 'rotation' not in kwargs:\n            kwargs['rotation'] = Config.getint('graphics', 'rotation')\n        if 'position' not in kwargs:\n            kwargs['position'] = Config.getdefault('graphics', 'position',\n                                                   'auto')\n        if 'top' in kwargs:\n            kwargs['position'] = 'custom'\n            self._top = kwargs['top']\n        else:\n            self._top = Config.getint('graphics', 'top')\n        if 'left' in kwargs:\n            kwargs['position'] = 'custom'\n            self._left = kwargs['left']\n        else:\n            self._left = Config.getint('graphics', 'left')\n        kwargs['_size'] = (kwargs.pop('width'), kwargs.pop('height'))\n        if 'show_cursor' not in kwargs:\n            kwargs['show_cursor'] = Config.getboolean(\n                'graphics', 'show_cursor'\n            )\n        if 'shape_image' not in kwargs:\n            kwargs['shape_image'] = Config.get('kivy', 'window_shape')\n\n        self.fbind(\n            'on_drop_file',\n            lambda win, filename, *args: win.dispatch('on_dropfile', filename)\n        )\n        super(WindowBase, self).__init__(**kwargs)\n\n        # bind all the properties that need to recreate the window\n        self._bind_create_window()\n        self.bind(size=self.trigger_keyboard_height,\n                  rotation=self.trigger_keyboard_height)\n\n        self.bind(softinput_mode=lambda *dt: self.update_viewport(),\n                  keyboard_height=lambda *dt: self.update_viewport())\n\n        self.bind(show_cursor=lambda *dt: self._set_cursor_state(dt[1]))\n\n        # init privates\n        self._system_keyboard = Keyboard(window=self)\n        self._keyboards = {'system': self._system_keyboard}\n        self._vkeyboard_cls = None\n\n        self.children = []\n        self.parent = self\n\n        # before creating the window\n        import kivy.core.gl  # NOQA\n\n        # configure the window\n        self.create_window()\n        self.register()\n\n        # manage keyboard(s)\n        self.configure_keyboards()\n\n        # assign the default context of the widget creation\n        if not hasattr(self, '_context'):\n            self._context = get_current_context()\n\n        # because Window is created as soon as imported, if we bound earlier,\n        # metrics would be imported when dp is set during window creation.\n        # Instead, don't process dpi changes until everything is set\n        self.fbind('dpi', self._reset_metrics_dpi)\n\n        # mark as initialized\n        self.initialized = True\n\n    def _reset_metrics_dpi(self, *args):\n        from kivy.metrics import Metrics\n        Metrics.reset_dpi()\n\n    def _bind_create_window(self):\n        for prop in (\n                'fullscreen', 'borderless', 'position', 'top',\n                'left', '_size', 'system_size'):\n            self.bind(**{prop: self.trigger_create_window})\n\n    def _unbind_create_window(self):\n        for prop in (\n                'fullscreen', 'borderless', 'position', 'top',\n                'left', '_size', 'system_size'):\n            self.unbind(**{prop: self.trigger_create_window})\n\n    def register(self):\n        if self.initialized:\n            return\n        # attach modules + listener event\n        EventLoop.set_window(self)\n        Modules.register_window(self)\n        EventLoop.add_event_listener(self)\n\n    def register_event_manager(self, manager):\n        '''Register and start an event manager to handle events declared in\n        :attr:`~kivy.eventmanager.EventManagerBase.type_ids` attribute.\n\n        .. versionadded:: 2.1.0\n\n        .. warning::\n            This is an experimental method and it remains so until this warning\n            is present as it can be changed or removed in the next versions of\n            Kivy.\n        '''\n        self.event_managers.insert(0, manager)\n        for type_id in manager.type_ids:\n            self.event_managers_dict[type_id].insert(0, manager)\n        manager.window = self\n        manager.start()\n\n    def unregister_event_manager(self, manager):\n        '''Unregister and stop an event manager previously registered with\n        :meth:`register_event_manager`.\n\n        .. versionadded:: 2.1.0\n\n        .. warning::\n            This is an experimental method and it remains so until this warning\n            is present as it can be changed or removed in the next versions of\n            Kivy.\n        '''\n        self.event_managers.remove(manager)\n        for type_id in manager.type_ids:\n            self.event_managers_dict[type_id].remove(manager)\n        manager.stop()\n        manager.window = None\n\n    def mainloop(self):\n        '''Called by the EventLoop every frame after it idles.\n        '''\n        pass\n\n    def maximize(self):\n        '''Maximizes the window. This method should be used on desktop\n        platforms only.\n\n        .. versionadded:: 1.9.0\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: maximize() is not implemented in the current '\n                        'window provider.')\n\n    def minimize(self):\n        '''Minimizes the window. This method should be used on desktop\n        platforms only.\n\n        .. versionadded:: 1.9.0\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: minimize() is not implemented in the current '\n                        'window provider.')\n\n    def restore(self):\n        '''Restores the size and position of a maximized or minimized window.\n        This method should be used on desktop platforms only.\n\n        .. versionadded:: 1.9.0\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: restore() is not implemented in the current '\n                        'window provider.')\n\n    def hide(self):\n        '''Hides the window. This method should be used on desktop\n        platforms only.\n\n        .. versionadded:: 1.9.0\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: hide() is not implemented in the current '\n                        'window provider.')\n\n    def show(self):\n        '''Shows the window. This method should be used on desktop\n        platforms only.\n\n        .. versionadded:: 1.9.0\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: show() is not implemented in the current '\n                        'window provider.')\n\n    def raise_window(self):\n        '''Raise the window. This method should be used on desktop\n        platforms only.\n\n        .. versionadded:: 1.9.1\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: raise_window is not implemented in the current'\n                       ' window provider.')\n\n    def close(self):\n        '''Close the window'''\n        self.dispatch('on_close')\n\n        # Prevent any leftover that can crash the app later\n        # like if there is still some GL referenced values\n        # they may be collected later, but because it was already\n        # gone in the system, it may collect invalid GL resources\n        # Just clear everything to force reloading later on.\n        from kivy.cache import Cache\n        from kivy.graphics.context import get_context\n        Cache.remove('kv.loader')\n        Cache.remove('kv.image')\n        Cache.remove('kv.shader')\n        Cache.remove('kv.texture')\n        get_context().flush()\n\n    shape_image = StringProperty('')\n    '''An image for the window shape (only works for sdl2 window provider).\n\n    .. warning:: The image size has to be the same like the window's size!\n\n    .. versionadded:: 1.10.1\n\n    :attr:`shape_image` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'data/images/defaultshape.png'. This value is taken from\n    :class:`~kivy.config.Config`.\n    '''\n    def set_custom_titlebar(self, widget):\n        \"\"\"\n        Sets a Widget as a titlebar\n\n            :widget: The widget you want to set as the titlebar\n\n        .. versionadded:: 2.1.0\n\n        This function returns `True` on successfully setting the custom titlebar,\n        else false\n\n        How to use this feature\n\n        ::\n\n            1. first set Window.custom_titlebar to True\n            2. then call Window.set_custom_titlebar with the widget/layout you want to set as titlebar as the argument # noqa: E501\n\n        If you want a child of the widget to receive touch events, in\n        that child define a property `draggable` and set it to False\n\n        If you set the property `draggable` on a layout,\n        all the child in the layout will receive touch events\n\n        If you want to override default behavior, add function `in_drag_area(x,y)`\n        to the widget\n\n        The function is call with two args x,y which are mouse.x, and mouse.y\n        the function should return\n\n        | `True` if that point should be used to drag the window\n        | `False` if you want to receive the touch event at the point\n\n        .. note::\n            If you use :meth:`in_drag_area` property `draggable`\n            will not be checked\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n\n        .. warning::\n            :mod:`~kivy.core.window.WindowBase.custom_titlebar` must be set to True\n            for the widget to be successfully set as a titlebar\n\n        \"\"\"\n\n        Logger.warning('Window: set_custom_titlebar '\n                       'is not implemented in the current'\n                       ' window provider.')\n\n    def on_shape_image(self, instance, value):\n        if self.initialized:\n            self._set_shape(\n                shape_image=value, mode=self.shape_mode,\n                cutoff=self.shape_cutoff, color_key=self.shape_color_key\n            )\n\n    shape_cutoff = BooleanProperty(True)\n    '''The window :attr:`shape_image` cutoff property (only works for sdl2\n    window provider).\n\n    .. versionadded:: 1.10.1\n\n    :attr:`shape_cutoff` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    def on_shape_cutoff(self, instance, value):\n        self._set_shape(\n            shape_image=self.shape_image, mode=self.shape_mode,\n            cutoff=value, color_key=self.shape_color_key\n        )\n\n    def _get_shaped(self):\n        return self._is_shaped()\n\n    shaped = AliasProperty(_get_shaped, None)\n    '''Read only property to check if the window is shapable or not (only works\n    for sdl2 window provider).\n\n    .. versionadded:: 1.10.1\n\n    :attr:`shaped` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def _get_shape_mode(self):\n        if not self.shaped:\n            return ''\n\n        i = self._get_shaped_mode()['mode']\n        modes = ('default', 'binalpha', 'reversebinalpha', 'colorkey')\n        return modes[i]\n\n    def _set_shape_mode(self, value):\n        self._set_shaped_mode(value)\n\n    shape_mode = AliasProperty(_get_shape_mode, _set_shape_mode)\n    '''Window mode for shaping (only works for sdl2 window provider).\n\n    - can be RGB only\n       - `default` - does nothing special\n       - `colorkey` - hides a color of the :attr:`shape_color_key`\n    - has to contain alpha channel\n       - `binalpha` - hides an alpha channel of the :attr:`shape_image`\n       - `reversebinalpha` - shows only the alpha of the :attr:`shape_image`\n\n    .. note::\n        Before actually setting the mode make sure the Window has the same\n        size like the :attr:`shape_image`, preferably via Config before\n        the Window is actually created.\n\n        If the :attr:`shape_image` isn't set, the default one will be used\n        and the mode might not take the desired visual effect.\n\n    .. versionadded:: 1.10.1\n\n    :attr:`shape_mode` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    shape_color_key = ColorProperty([1, 1, 1, 1])\n    '''Color key of the shaped window - sets which color will be hidden from\n    the window :attr:`shape_image` (only works for sdl2 window provider).\n\n    .. versionadded:: 1.10.1\n\n    :attr:`shape_color_key` is a :class:`~kivy.properties.ColorProperty`\n    instance and defaults to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n    def on_shape_color_key(self, instance, value):\n        self._set_shape(\n            shape_image=self.shape_image, mode=self.shape_mode,\n            cutoff=self.shape_cutoff, color_key=value\n        )\n\n    def get_gl_backend_name(self):\n        \"\"\"\n        Returns the gl backend that will or is used with this window.\n        \"\"\"\n        return cgl_get_backend_name(\n            allowed=self.gl_backends_allowed,\n            ignored=self.gl_backends_ignored)\n\n    def initialize_gl(self):\n        from kivy.core.gl import init_gl\n        init_gl(allowed=self.gl_backends_allowed,\n                ignored=self.gl_backends_ignored)\n\n    def create_window(self, *largs):\n        '''Will create the main window and configure it.\n\n        .. warning::\n            This method is called automatically at runtime. If you call it, it\n            will recreate a RenderContext and Canvas. This means you'll have a\n            new graphics tree, and the old one will be unusable.\n\n            This method exist to permit the creation of a new OpenGL context\n            AFTER closing the first one. (Like using runTouchApp() and\n            stopTouchApp()).\n\n            This method has only been tested in a unittest environment and\n            is not suitable for Applications.\n\n            Again, don't use this method unless you know exactly what you are\n            doing!\n        '''\n        # just to be sure, if the trigger is set, and if this method is\n        # manually called, unset the trigger\n        self.trigger_create_window.cancel()\n\n        # ensure the window creation will not be called twice\n        if platform in ('android'):\n            self._unbind_create_window()\n\n        if not self.initialized:\n            self.initialize_gl()\n\n            # create the render context and canvas, only the first time.\n            from kivy.graphics import RenderContext, Canvas\n            self.render_context = RenderContext()\n            self.canvas = Canvas()\n            self.render_context.add(self.canvas)\n\n        else:\n            # if we get initialized more than once, then reload opengl state\n            # after the second time.\n            # XXX check how it's working on embed platform.\n            if platform == 'linux' or Window.__class__.__name__ == 'WindowSDL':\n                # on linux, it's safe for just sending a resize.\n                self.dispatch('on_pre_resize', *self.size)\n\n            else:\n                # on other platform, window are recreated, we need to reload.\n                from kivy.graphics.context import get_context\n                get_context().reload()\n                Clock.schedule_once(lambda x: self.canvas.ask_update(), 0)\n                self.dispatch('on_pre_resize', *self.size)\n\n        # ensure the gl viewport is correct\n        self.update_viewport()\n\n    def on_flip(self):\n        '''Flip between buffers (event)'''\n        self.flip()\n\n    def flip(self):\n        '''Flip between buffers'''\n        pass\n\n    def _update_childsize(self, instance, value):\n        self.update_childsize([instance])\n\n    def add_widget(self, widget, canvas=None):\n        '''Add a widget to a window'''\n        if widget.parent:\n            from kivy.uix.widget import WidgetException\n            raise WidgetException(\n                'Cannot add %r to window, it already has a parent %r' %\n                (widget, widget.parent)\n            )\n\n        widget.parent = self\n        self.children.insert(0, widget)\n        canvas = self.canvas.before if canvas == 'before' else \\\n            self.canvas.after if canvas == 'after' else self.canvas\n        canvas.add(widget.canvas)\n        self.update_childsize([widget])\n        widget.bind(\n            pos_hint=self._update_childsize,\n            size_hint=self._update_childsize,\n            size_hint_max=self._update_childsize,\n            size_hint_min=self._update_childsize,\n            size=self._update_childsize,\n            pos=self._update_childsize)\n\n    def remove_widget(self, widget):\n        '''Remove a widget from a window\n        '''\n        if widget not in self.children:\n            return\n        self.children.remove(widget)\n        if widget.canvas in self.canvas.children:\n            self.canvas.remove(widget.canvas)\n        elif widget.canvas in self.canvas.after.children:\n            self.canvas.after.remove(widget.canvas)\n        elif widget.canvas in self.canvas.before.children:\n            self.canvas.before.remove(widget.canvas)\n        widget.parent = None\n        widget.unbind(\n            pos_hint=self._update_childsize,\n            size_hint=self._update_childsize,\n            size_hint_max=self._update_childsize,\n            size_hint_min=self._update_childsize,\n            size=self._update_childsize,\n            pos=self._update_childsize)\n\n    def clear(self):\n        '''Clear the window with the background color'''\n        # XXX FIXME use late binding\n        from kivy.graphics import opengl as gl\n        gl.glClearColor(*self.clearcolor)\n        gl.glClear(\n            gl.GL_COLOR_BUFFER_BIT\n            | gl.GL_DEPTH_BUFFER_BIT\n            | gl.GL_STENCIL_BUFFER_BIT\n        )\n\n    def set_title(self, title):\n        '''Set the window title.\n\n        .. versionadded:: 1.0.5\n        '''\n        self.title = title\n\n    def set_icon(self, filename):\n        '''Set the icon of the window.\n\n        .. versionadded:: 1.0.5\n        '''\n        self.icon = filename\n\n    def to_widget(self, x, y, initial=True, relative=False):\n        return (x, y)\n\n    def to_window(self, x, y, initial=True, relative=False):\n        return (x, y)\n\n    def to_normalized_pos(self, x, y):\n        '''Transforms absolute coordinates to normalized (0-1) coordinates\n        using :attr:`system_size`.\n\n        .. versionadded:: 2.1.0\n        '''\n        x_max = self.system_size[0] - 1.0\n        y_max = self.system_size[1] - 1.0\n        return (\n            x / x_max if x_max > 0 else 0.0,\n            y / y_max if y_max > 0 else 0.0\n        )\n\n    def transform_motion_event_2d(self, me, widget=None):\n        '''Transforms the motion event `me` to this window size and then if\n        `widget` is passed transforms `me` to `widget`'s local coordinates.\n\n        :raises:\n            `AttributeError`: If widget's ancestor is ``None``.\n\n        .. note::\n            Unless it's a specific case, call\n            :meth:`~kivy.input.motionevent.MotionEvent.push` before and\n            :meth:`~kivy.input.motionevent.MotionEvent.pop` after this method's\n            call to preserve previous values of `me`'s attributes.\n\n        .. versionadded:: 2.1.0\n        '''\n        width, height = self._get_effective_size()\n        me.scale_for_screen(\n            width, height,\n            rotation=self.rotation,\n            smode=self.softinput_mode,\n            kheight=self.keyboard_height\n        )\n        if widget is not None:\n            parent = widget.parent\n            try:\n                if parent:\n                    me.apply_transform_2d(parent.to_widget)\n                else:\n                    me.apply_transform_2d(widget.to_widget)\n                    me.apply_transform_2d(widget.to_parent)\n            except AttributeError:\n                # when using inner window, an app have grab the touch\n                # but app is removed. The touch can't access\n                # to one of the parent. (i.e, self.parent will be None)\n                # and BAM the bug happen.\n                raise\n\n    def _apply_transform(self, m):\n        return m\n\n    def get_window_matrix(self, x=0, y=0):\n        m = Matrix()\n        m.translate(x, y, 0)\n        return m\n\n    def get_root_window(self):\n        return self\n\n    def get_parent_window(self):\n        return self\n\n    def get_parent_layout(self):\n        return None\n\n    def on_draw(self):\n        self.clear()\n        self.render_context.draw()\n\n    def on_motion(self, etype, me):\n        '''Event called when a motion event is received.\n\n        :Parameters:\n            `etype`: str\n                One of \"begin\", \"update\" or \"end\".\n            `me`: :class:`~kivy.input.motionevent.MotionEvent`\n                The motion event currently dispatched.\n\n        .. versionchanged:: 2.1.0\n            Event managers get to handle the touch event first and if none of\n            them accepts the event (by returning `True`) then window will\n            dispatch `me` through \"on_touch_down\", \"on_touch_move\",\n            \"on_touch_up\" events depending on the `etype`. All non-touch events\n            will go only through managers.\n        '''\n        accepted = False\n        for manager in self.event_managers_dict[me.type_id][:]:\n            accepted = manager.dispatch(etype, me) or accepted\n        if accepted:\n            if me.is_touch and etype == 'end':\n                FocusBehavior._handle_post_on_touch_up(me)\n            return accepted\n        if me.is_touch:\n            # TODO: Use me.push/me.pop methods because `me` is transformed\n            # Clock execution of partial ScrollView._on_touch_up method and\n            # other similar cases should be changed so that me.push/me.pop can\n            # be used restore previous values of event's attributes\n            # me.push()\n            self.transform_motion_event_2d(me)\n            if etype == 'begin':\n                self.dispatch('on_touch_down', me)\n            elif etype == 'update':\n                self.dispatch('on_touch_move', me)\n            elif etype == 'end':\n                self.dispatch('on_touch_up', me)\n                FocusBehavior._handle_post_on_touch_up(me)\n            # me.pop()\n\n    def on_touch_down(self, touch):\n        '''Event called when a touch down event is initiated.\n\n        .. versionchanged:: 1.9.0\n            The touch `pos` is now transformed to window coordinates before\n            this method is called. Before, the touch `pos` coordinate would be\n            `(0, 0)` when this method was called.\n        '''\n        for w in self.children[:]:\n            if w.dispatch('on_touch_down', touch):\n                return True\n\n    def on_touch_move(self, touch):\n        '''Event called when a touch event moves (changes location).\n\n        .. versionchanged:: 1.9.0\n            The touch `pos` is now transformed to window coordinates before\n            this method is called. Before, the touch `pos` coordinate would be\n            `(0, 0)` when this method was called.\n        '''\n        for w in self.children[:]:\n            if w.dispatch('on_touch_move', touch):\n                return True\n\n    def on_touch_up(self, touch):\n        '''Event called when a touch event is released (terminated).\n\n        .. versionchanged:: 1.9.0\n            The touch `pos` is now transformed to window coordinates before\n            this method is called. Before, the touch `pos` coordinate would be\n            `(0, 0)` when this method was called.\n        '''\n        for w in self.children[:]:\n            if w.dispatch('on_touch_up', touch):\n                return True\n\n    def on_pre_resize(self, width, height):\n        key = (width, height)\n        if hasattr(self, '_last_resize') and self._last_resize == key:\n            return\n        self._last_resize = key\n        self.dispatch('on_resize', width, height)\n\n    def on_resize(self, width, height):\n        '''Event called when the window is resized.'''\n        self.update_viewport()\n\n    def on_move(self):\n        self.property('top').dispatch(self)\n        self.property('left').dispatch(self)\n\n    def update_viewport(self):\n        from kivy.graphics.opengl import glViewport\n        from kivy.graphics.transformation import Matrix\n        from math import radians\n\n        w, h = self._get_effective_size()\n\n        smode = self.softinput_mode\n        target = self._system_keyboard.target\n        targettop = max(0, target.to_window(0, target.y)[1]) if target else 0\n        kheight = self._kheight\n\n        w2, h2 = w / 2., h / 2.\n        r = radians(self.rotation)\n\n        y = 0\n        _h = h\n        if smode == 'pan':\n            y = kheight\n        elif smode == 'below_target':\n            y = 0 if kheight < targettop else (kheight - targettop)\n        if smode == 'scale':\n            _h -= kheight\n\n        # prepare the viewport\n        glViewport(0, 0, w, _h)\n\n        # do projection matrix\n        projection_mat = Matrix()\n        projection_mat.view_clip(0.0, w, 0.0, h, -1.0, 1.0, 0)\n        self.render_context['projection_mat'] = projection_mat\n\n        # do modelview matrix\n        modelview_mat = Matrix().translate(w2, h2, 0)\n        modelview_mat = modelview_mat.multiply(Matrix().rotate(r, 0, 0, 1))\n\n        w, h = self.size\n        w2, h2 = w / 2., h / 2. - y\n        modelview_mat = modelview_mat.multiply(Matrix().translate(-w2, -h2, 0))\n        self.render_context['modelview_mat'] = modelview_mat\n        frag_modelview_mat = Matrix()\n        frag_modelview_mat.set(flat=modelview_mat.get())\n        self.render_context['frag_modelview_mat'] = frag_modelview_mat\n\n        # redraw canvas\n        self.canvas.ask_update()\n\n        # and update childs\n        self.update_childsize()\n\n    def update_childsize(self, childs=None):\n        width, height = self.size\n        if childs is None:\n            childs = self.children\n        for w in childs:\n            shw, shh = w.size_hint\n            shw_min, shh_min = w.size_hint_min\n            shw_max, shh_max = w.size_hint_max\n\n            if shw is not None and shh is not None:\n                c_w = shw * width\n                c_h = shh * height\n\n                if shw_min is not None and c_w < shw_min:\n                    c_w = shw_min\n                elif shw_max is not None and c_w > shw_max:\n                    c_w = shw_max\n\n                if shh_min is not None and c_h < shh_min:\n                    c_h = shh_min\n                elif shh_max is not None and c_h > shh_max:\n                    c_h = shh_max\n                w.size = c_w, c_h\n            elif shw is not None:\n                c_w = shw * width\n\n                if shw_min is not None and c_w < shw_min:\n                    c_w = shw_min\n                elif shw_max is not None and c_w > shw_max:\n                    c_w = shw_max\n                w.width = c_w\n            elif shh is not None:\n                c_h = shh * height\n\n                if shh_min is not None and c_h < shh_min:\n                    c_h = shh_min\n                elif shh_max is not None and c_h > shh_max:\n                    c_h = shh_max\n                w.height = c_h\n\n            for key, value in w.pos_hint.items():\n                if key == 'x':\n                    w.x = value * width\n                elif key == 'right':\n                    w.right = value * width\n                elif key == 'y':\n                    w.y = value * height\n                elif key == 'top':\n                    w.top = value * height\n                elif key == 'center_x':\n                    w.center_x = value * width\n                elif key == 'center_y':\n                    w.center_y = value * height\n\n    def screenshot(self, name='screenshot{:04d}.png'):\n        '''Save the actual displayed image to a file.\n        '''\n        i = 0\n        path = None\n        if name != 'screenshot{:04d}.png':\n            _ext = name.split('.')[-1]\n            name = ''.join((name[:-(len(_ext) + 1)], '{:04d}.', _ext))\n        while True:\n            i += 1\n            path = join(getcwd(), name.format(i))\n            if not exists(path):\n                break\n        return path\n\n    def on_rotate(self, rotation):\n        '''Event called when the screen has been rotated.\n        '''\n        pass\n\n    def on_close(self, *largs):\n        '''Event called when the window is closed.'''\n        Modules.unregister_window(self)\n        EventLoop.remove_event_listener(self)\n\n    def on_minimize(self, *largs):\n        '''Event called when the window is minimized.\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass\n\n    def on_maximize(self, *largs):\n        '''Event called when the window is maximized.\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass\n\n    def on_restore(self, *largs):\n        '''Event called when the window is restored.\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass\n\n    def on_hide(self, *largs):\n        '''Event called when the window is hidden.\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass\n\n    def on_show(self, *largs):\n        '''Event called when the window is shown.\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass\n\n    def on_request_close(self, *largs, **kwargs):\n        '''Event called before we close the window. If a bound function returns\n        `True`, the window will not be closed. If the event is triggered\n        because of the keyboard escape key, the keyword argument `source` is\n        dispatched along with a value of `keyboard` to the bound functions.\n\n        .. warning::\n            When the bound function returns True the window will not be closed,\n            so use with care because the user would not be able to close the\n            program, even if the red X is clicked.\n        '''\n        pass\n\n    def on_cursor_enter(self, *largs):\n        '''Event called when the cursor enters the window.\n\n        .. versionadded:: 1.9.1\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass\n\n    def on_cursor_leave(self, *largs):\n        '''Event called when the cursor leaves the window.\n\n        .. versionadded:: 1.9.1\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass\n\n    def on_mouse_down(self, x, y, button, modifiers):\n        '''Event called when the mouse is used (pressed/released).'''\n        pass\n\n    def on_mouse_move(self, x, y, modifiers):\n        '''Event called when the mouse is moved with buttons pressed.'''\n        pass\n\n    def on_mouse_up(self, x, y, button, modifiers):\n        '''Event called when the mouse is moved with buttons pressed.'''\n        pass\n\n    def on_joy_axis(self, stickid, axisid, value):\n        '''Event called when a joystick has a stick or other axis moved.\n\n        .. versionadded:: 1.9.0'''\n        pass\n\n    def on_joy_hat(self, stickid, hatid, value):\n        '''Event called when a joystick has a hat/dpad moved.\n\n        .. versionadded:: 1.9.0'''\n        pass\n\n    def on_joy_ball(self, stickid, ballid, xvalue, yvalue):\n        '''Event called when a joystick has a ball moved.\n\n        .. versionadded:: 1.9.0'''\n        pass\n\n    def on_joy_button_down(self, stickid, buttonid):\n        '''Event called when a joystick has a button pressed.\n\n        .. versionadded:: 1.9.0'''\n        pass\n\n    def on_joy_button_up(self, stickid, buttonid):\n        '''Event called when a joystick has a button released.\n\n        .. versionadded:: 1.9.0'''\n        pass\n\n    def on_keyboard(self, key, scancode=None, codepoint=None,\n                    modifier=None, **kwargs):\n        '''Event called when keyboard is used.\n\n        .. warning::\n            Some providers may omit `scancode`, `codepoint` and/or `modifier`.\n        '''\n        if 'unicode' in kwargs:\n            Logger.warning(\"The use of the unicode parameter is deprecated, \"\n                           \"and will be removed in future versions. Use \"\n                           \"codepoint instead, which has identical \"\n                           \"semantics.\")\n\n        # Quit if user presses ESC or the typical OSX shortcuts CMD+q or CMD+w\n        # On Android a back key/gesture is mapped to 27 and initiates a pause.\n        # Consume the event and tell Android to pause.\n        # TODO If just CMD+w is pressed, only the window should be closed.\n        is_osx = platform == 'darwin'\n        if key == 27 and platform == 'android':\n            from android import mActivity\n            mActivity.moveTaskToBack(True)\n            return True\n        elif WindowBase.on_keyboard.exit_on_escape:\n            if key == 27 or all([is_osx, key in [113, 119], modifier == 1024]):\n                if not self.dispatch('on_request_close', source='keyboard'):\n                    stopTouchApp()\n                    self.close()\n                    return True\n\n    if Config:\n        on_keyboard.exit_on_escape = Config.getboolean(\n                                        'kivy', 'exit_on_escape')\n\n        def __exit(section, name, value):\n            WindowBase.__dict__['on_keyboard'].exit_on_escape = \\\n                Config.getboolean('kivy', 'exit_on_escape')\n\n        Config.add_callback(__exit, 'kivy', 'exit_on_escape')\n\n    def on_key_down(self, key, scancode=None, codepoint=None,\n                    modifier=None, **kwargs):\n        '''Event called when a key is down (same arguments as on_keyboard)'''\n        if 'unicode' in kwargs:\n            Logger.warning(\"The use of the unicode parameter is deprecated, \"\n                           \"and will be removed in future versions. Use \"\n                           \"codepoint instead, which has identical \"\n                           \"semantics.\")\n\n    def on_key_up(self, key, scancode=None, codepoint=None,\n                  modifier=None, **kwargs):\n        '''Event called when a key is released (same arguments as on_keyboard).\n        '''\n        if 'unicode' in kwargs:\n            Logger.warning(\"The use of the unicode parameter is deprecated, \"\n                           \"and will be removed in future versions. Use \"\n                           \"codepoint instead, which has identical \"\n                           \"semantics.\")\n\n    def on_textinput(self, text):\n        '''Event called when text: i.e. alpha numeric non control keys or set\n        of keys is entered. As it is not guaranteed whether we get one\n        character or multiple ones, this event supports handling multiple\n        characters.\n\n        .. versionadded:: 1.9.0\n        '''\n        pass\n\n    def on_drop_begin(self, x, y, *args):\n        '''Event called when a text or a file drop on the application is about\n        to begin. It will be followed-up by a single or a multiple\n        `on_drop_text` or `on_drop_file` events ending with an `on_drop_end`\n        event.\n\n        Arguments `x` and `y` are the mouse cursor position at the time of the\n        drop and you should only rely on them if the drop originated from the\n        mouse.\n\n        :Parameters:\n            `x`: `int`\n                Cursor x position, relative to the window :attr:`left`, at the\n                time of the drop.\n            `y`: `int`\n                Cursor y position, relative to the window :attr:`top`, at the\n                time of the drop.\n            `*args`: `tuple`\n                Additional arguments.\n\n        .. note::\n            This event works with sdl2 window provider.\n\n        .. versionadded:: 2.1.0\n        '''\n        pass\n\n    def on_drop_file(self, filename, x, y, *args):\n        '''Event called when a file is dropped on the application.\n\n        Arguments `x` and `y` are the mouse cursor position at the time of the\n        drop and you should only rely on them if the drop originated from the\n        mouse.\n\n        :Parameters:\n            `filename`: `bytes`\n                Absolute path to a dropped file.\n            `x`: `int`\n                Cursor x position, relative to the window :attr:`left`, at the\n                time of the drop.\n            `y`: `int`\n                Cursor y position, relative to the window :attr:`top`, at the\n                time of the drop.\n            `*args`: `tuple`\n                Additional arguments.\n\n        .. warning::\n            This event currently works with sdl2 window provider, on pygame\n            window provider and OS X with a patched version of pygame.\n            This event is left in place for further evolution\n            (ios, android etc.)\n\n        .. note::\n            On Windows it is possible to drop a file on the window title bar\n            or on its edges and for that case :attr:`mouse_pos` won't be\n            updated as the mouse cursor is not within the window.\n\n        .. note::\n            This event doesn't work for apps with elevated permissions,\n            because the OS API calls are filtered. Check issue\n            `#4999 <https://github.com/kivy/kivy/issues/4999>`_ for\n            pointers to workarounds.\n\n        .. versionadded:: 1.2.0\n\n        .. versionchanged:: 2.1.0\n            Renamed from `on_dropfile` to `on_drop_file`.\n        '''\n        pass\n\n    @deprecated(msg='Deprecated in 2.1.0, use on_drop_file event instead. '\n                    'Event on_dropfile will be removed in the next two '\n                    'releases.')\n    def on_dropfile(self, filename):\n        pass\n\n    def on_drop_text(self, text, x, y, *args):\n        '''Event called when a text is dropped on the application.\n\n        Arguments `x` and `y` are the mouse cursor position at the time of the\n        drop and you should only rely on them if the drop originated from the\n        mouse.\n\n        :Parameters:\n            `text`: `bytes`\n                Text which is dropped.\n            `x`: `int`\n                Cursor x position, relative to the window :attr:`left`, at the\n                time of the drop.\n            `y`: `int`\n                Cursor y position, relative to the window :attr:`top`, at the\n                time of the drop.\n            `*args`: `tuple`\n                Additional arguments.\n\n        .. note::\n            This event works with sdl2 window provider on x11 window.\n\n        .. note::\n            On Windows it is possible to drop a text on the window title bar\n            or on its edges and for that case :attr:`mouse_pos` won't be\n            updated as the mouse cursor is not within the window.\n\n        .. versionadded:: 2.1.0\n        '''\n        pass\n\n    def on_drop_end(self, x, y, *args):\n        '''Event called when a text or a file drop on the application has\n        ended.\n\n        Arguments `x` and `y` are the mouse cursor position at the time of the\n        drop and you should only rely on them if the drop originated from the\n        mouse.\n\n        :Parameters:\n            `x`: `int`\n                Cursor x position, relative to the window :attr:`left`, at the\n                time of the drop.\n            `y`: `int`\n                Cursor y position, relative to the window :attr:`top`, at the\n                time of the drop.\n            `*args`: `tuple`\n                Additional arguments.\n\n        .. note::\n            This event works with sdl2 window provider.\n\n        .. versionadded:: 2.1.0\n        '''\n        pass\n\n    def on_memorywarning(self):\n        '''Event called when the platform have memory issue.\n        Your goal is to clear the cache in your app as much as you can,\n        release unused widgets, do garbage collection etc.\n\n        Currently, this event is fired only from the SDL2 provider, for\n        iOS and Android.\n\n        .. versionadded:: 1.9.0\n        '''\n        pass\n\n    def on_textedit(self, text):\n        '''Event called when inputting with IME.\n        The string inputting with IME is set as the parameter of\n        this event.\n\n        .. versionadded:: 1.10.1\n        '''\n        pass\n\n    dpi = NumericProperty(96.)\n    '''Return the DPI of the screen as computed by the window. If the\n    implementation doesn't support DPI lookup, it's 96.\n\n    .. warning::\n\n        This value is not cross-platform. Use\n        :attr:`kivy.metrics.Metrics.dpi` instead.\n    '''\n\n    def configure_keyboards(self):\n        # Configure how to provide keyboards (virtual or not)\n\n        # register system keyboard to listening keys from window\n        sk = self._system_keyboard\n        self.bind(\n            on_key_down=sk._on_window_key_down,\n            on_key_up=sk._on_window_key_up,\n            on_textinput=sk._on_window_textinput)\n\n        # use the device's real keyboard\n        self.use_syskeyboard = True\n\n        # use the device's real keyboard\n        self.allow_vkeyboard = False\n\n        # one single vkeyboard shared between all widgets\n        self.single_vkeyboard = True\n\n        # the single vkeyboard is always sitting at the same position\n        self.docked_vkeyboard = False\n\n        # now read the configuration\n        mode = Config.get('kivy', 'keyboard_mode')\n        if mode not in ('', 'system', 'dock', 'multi', 'systemanddock',\n                        'systemandmulti'):\n            Logger.critical('Window: unknown keyboard mode %r' % mode)\n\n        # adapt mode according to the configuration\n        if mode == 'system':\n            self.use_syskeyboard = True\n            self.allow_vkeyboard = False\n            self.single_vkeyboard = True\n            self.docked_vkeyboard = False\n        elif mode == 'dock':\n            self.use_syskeyboard = False\n            self.allow_vkeyboard = True\n            self.single_vkeyboard = True\n            self.docked_vkeyboard = True\n        elif mode == 'multi':\n            self.use_syskeyboard = False\n            self.allow_vkeyboard = True\n            self.single_vkeyboard = False\n            self.docked_vkeyboard = False\n        elif mode == 'systemanddock':\n            self.use_syskeyboard = True\n            self.allow_vkeyboard = True\n            self.single_vkeyboard = True\n            self.docked_vkeyboard = True\n        elif mode == 'systemandmulti':\n            self.use_syskeyboard = True\n            self.allow_vkeyboard = True\n            self.single_vkeyboard = False\n            self.docked_vkeyboard = False\n\n        Logger.info(\n            'Window: virtual keyboard %sallowed, %s, %s' % (\n                '' if self.allow_vkeyboard else 'not ',\n                'single mode' if self.single_vkeyboard else 'multiuser mode',\n                'docked' if self.docked_vkeyboard else 'not docked'))\n\n    def set_vkeyboard_class(self, cls):\n        '''.. versionadded:: 1.0.8\n\n        Set the VKeyboard class to use. If set to `None`, it will use the\n        :class:`kivy.uix.vkeyboard.VKeyboard`.\n        '''\n        self._vkeyboard_cls = cls\n\n    def release_all_keyboards(self):\n        '''.. versionadded:: 1.0.8\n\n        This will ensure that no virtual keyboard / system keyboard is\n        requested. All instances will be closed.\n        '''\n        for key in list(self._keyboards.keys())[:]:\n            keyboard = self._keyboards[key]\n            if keyboard:\n                keyboard.release()\n\n    def request_keyboard(\n            self, callback, target, input_type='text', keyboard_suggestions=True\n    ):\n        '''.. versionadded:: 1.0.4\n\n        Internal widget method to request the keyboard. This method is rarely\n        required by the end-user as it is handled automatically by the\n        :class:`~kivy.uix.textinput.TextInput`. We expose it in case you want\n        to handle the keyboard manually for unique input scenarios.\n\n        A widget can request the keyboard, indicating a callback to call\n        when the keyboard is released (or taken by another widget).\n\n        :Parameters:\n            `callback`: func\n                Callback that will be called when the keyboard is\n                closed. This can be because somebody else requested the\n                keyboard or the user closed it.\n            `target`: Widget\n                Attach the keyboard to the specified `target`. This should be\n                the widget that requested the keyboard. Ensure you have a\n                different target attached to each keyboard if you're working in\n                a multi user mode.\n\n                .. versionadded:: 1.0.8\n\n            `input_type`: string\n                Choose the type of soft keyboard to request. Can be one of\n                'null', 'text', 'number', 'url', 'mail', 'datetime', 'tel',\n                'address'.\n\n                .. note::\n\n                    `input_type` is currently only honored on Android.\n\n                .. versionadded:: 1.8.0\n\n                .. versionchanged:: 2.1.0\n                    Added `null` to soft keyboard types.\n\n            `keyboard_suggestions`: bool\n                If True provides auto suggestions on top of keyboard.\n                This will only work if input_type is set to `text`, `url`,\n                `mail` or `address`.\n\n                .. versionadded:: 2.1.0\n\n        :Return:\n            An instance of :class:`Keyboard` containing the callback, target,\n            and if the configuration allows it, a\n            :class:`~kivy.uix.vkeyboard.VKeyboard` instance attached as a\n            *.widget* property.\n\n        .. note::\n\n            The behavior of this function is heavily influenced by the current\n            `keyboard_mode`. Please see the Config's\n            :ref:`configuration tokens <configuration-tokens>` section for\n            more information.\n\n        '''\n\n        # release any previous keyboard attached.\n        self.release_keyboard(target)\n\n        # if we can use virtual vkeyboard, activate it.\n        if self.allow_vkeyboard:\n            keyboard = None\n\n            # late import\n            global VKeyboard\n            if VKeyboard is None and self._vkeyboard_cls is None:\n                from kivy.uix.vkeyboard import VKeyboard\n                self._vkeyboard_cls = VKeyboard\n\n            # if the keyboard doesn't exist, create it.\n            key = 'single' if self.single_vkeyboard else target\n            if key not in self._keyboards:\n                vkeyboard = self._vkeyboard_cls()\n                keyboard = Keyboard(widget=vkeyboard, window=self)\n                vkeyboard.bind(\n                    on_key_down=keyboard._on_vkeyboard_key_down,\n                    on_key_up=keyboard._on_vkeyboard_key_up,\n                    on_textinput=keyboard._on_vkeyboard_textinput)\n                self._keyboards[key] = keyboard\n            else:\n                keyboard = self._keyboards[key]\n\n            # configure vkeyboard\n            keyboard.target = keyboard.widget.target = target\n            keyboard.callback = keyboard.widget.callback = callback\n\n            # add to the window\n            self.add_widget(keyboard.widget)\n\n            # only after add, do dock mode\n            keyboard.widget.docked = self.docked_vkeyboard\n            keyboard.widget.setup_mode()\n\n            # sets vkeyboard position according to Window.softinput_mode\n            if self.softinput_mode == 'pan':\n                keyboard.widget.top = 0\n            elif self.softinput_mode == 'below_target':\n                keyboard.widget.top = keyboard.target.y\n\n        else:\n            # system keyboard, just register the callback.\n            keyboard = self._system_keyboard\n            keyboard.callback = callback\n            keyboard.target = target\n\n        # use system (hardware) keyboard according to flag\n        if self.allow_vkeyboard and self.use_syskeyboard:\n            self.unbind(\n                on_key_down=keyboard._on_window_key_down,\n                on_key_up=keyboard._on_window_key_up,\n                on_textinput=keyboard._on_window_textinput)\n            self.bind(\n                on_key_down=keyboard._on_window_key_down,\n                on_key_up=keyboard._on_window_key_up,\n                on_textinput=keyboard._on_window_textinput)\n\n        return keyboard\n\n    def release_keyboard(self, target=None):\n        '''.. versionadded:: 1.0.4\n\n        Internal method for the widget to release the real-keyboard. Check\n        :meth:`request_keyboard` to understand how it works.\n        '''\n        if self.allow_vkeyboard:\n            key = 'single' if self.single_vkeyboard else target\n            if key not in self._keyboards:\n                return\n            keyboard = self._keyboards[key]\n            callback = keyboard.callback\n            if callback:\n                keyboard.callback = None\n                callback()\n            keyboard.target = None\n            self.remove_widget(keyboard.widget)\n            if key != 'single' and key in self._keyboards:\n                del self._keyboards[key]\n        elif self._system_keyboard.callback:\n            # this way will prevent possible recursion.\n            callback = self._system_keyboard.callback\n            self._system_keyboard.callback = None\n            callback()\n            return True\n\n    def grab_mouse(self):\n        '''Grab mouse - so won't leave window\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass\n\n    def ungrab_mouse(self):\n        '''Ungrab mouse\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass",
  "def __init__(self, **kwargs):\n        super(Keyboard, self).__init__()\n\n        #: Window which the keyboard is attached too\n        self.window = kwargs.get('window', None)\n\n        #: Callback that will be called when the keyboard is released\n        self.callback = kwargs.get('callback', None)\n\n        #: Target that have requested the keyboard\n        self.target = kwargs.get('target', None)\n\n        #: VKeyboard widget, if allowed by the configuration\n        self.widget = kwargs.get('widget', None)",
  "def on_key_down(self, keycode, text, modifiers):\n        pass",
  "def on_key_up(self, keycode):\n        pass",
  "def on_textinput(self, text):\n        pass",
  "def release(self):\n        '''Call this method to release the current keyboard.\n        This will ensure that the keyboard is no longer attached to your\n        callback.'''\n        if self.window:\n            self.window.release_keyboard(self.target)\n            self.target = None",
  "def _on_window_textinput(self, instance, text):\n        return self.dispatch('on_textinput', text)",
  "def _on_window_key_down(self, instance, keycode, scancode, text,\n                            modifiers):\n        keycode = (keycode, self.keycode_to_string(keycode))\n        if text == '\\x04':\n            Window.trigger_keyboard_height()\n            return\n        return self.dispatch('on_key_down', keycode, text, modifiers)",
  "def _on_window_key_up(self, instance, keycode, *largs):\n        keycode = (keycode, self.keycode_to_string(keycode))\n        return self.dispatch('on_key_up', keycode)",
  "def _on_vkeyboard_key_down(self, instance, keycode, text, modifiers):\n        if keycode is None:\n            keycode = text.lower()\n        keycode = (self.string_to_keycode(keycode), keycode)\n        return self.dispatch('on_key_down', keycode, text, modifiers)",
  "def _on_vkeyboard_key_up(self, instance, keycode, text, modifiers):\n        if keycode is None:\n            keycode = text\n        keycode = (self.string_to_keycode(keycode), keycode)\n        return self.dispatch('on_key_up', keycode)",
  "def _on_vkeyboard_textinput(self, instance, text):\n        return self.dispatch('on_textinput', text)",
  "def string_to_keycode(self, value):\n        '''Convert a string to a keycode number according to the\n        :attr:`Keyboard.keycodes`. If the value is not found in the\n        keycodes, it will return -1.\n        '''\n        return Keyboard.keycodes.get(value, -1)",
  "def keycode_to_string(self, value):\n        '''Convert a keycode number to a string according to the\n        :attr:`Keyboard.keycodes`. If the value is not found in the\n        keycodes, it will return ''.\n        '''\n        keycodes = list(Keyboard.keycodes.values())\n        if value in keycodes:\n            return list(Keyboard.keycodes.keys())[keycodes.index(value)]\n        return ''",
  "def _get_modifiers(self):\n        return self._modifiers",
  "def _get_size(self):\n        r = self._rotation\n        w, h = self._size\n        if platform == 'win' or self._density != 1:\n            w, h = self._win._get_gl_size()\n        if self.softinput_mode == 'resize':\n            h -= self.keyboard_height\n        if r in (0, 180):\n            return w, h\n        return h, w",
  "def _set_size(self, size):\n        if self._size != size:\n            r = self._rotation\n            if r in (0, 180):\n                self._size = size\n            else:\n                self._size = size[1], size[0]\n            self.dispatch('on_pre_resize', *size)",
  "def _get_width(self):\n        _size = self._size\n        if platform == 'win' or self._density != 1:\n            _size = self._win._get_gl_size()\n        r = self._rotation\n        if r == 0 or r == 180:\n            return _size[0]\n        return _size[1]",
  "def _get_height(self):\n        '''Rotated window height'''\n        r = self._rotation\n        _size = self._size\n        if platform == 'win' or self._density != 1:\n            _size = self._win._get_gl_size()\n        kb = self.keyboard_height if self.softinput_mode == 'resize' else 0\n        if r == 0 or r == 180:\n            return _size[1] - kb\n        return _size[0] - kb",
  "def _get_center(self):\n        return self.width / 2., self.height / 2.",
  "def _get_rotation(self):\n        return self._rotation",
  "def _set_rotation(self, x):\n        x = int(x % 360)\n        if x == self._rotation:\n            return\n        if x not in (0, 90, 180, 270):\n            raise ValueError('can rotate only 0, 90, 180, 270 degrees')\n        self._rotation = x\n        if not self.initialized:\n            return\n        self.dispatch('on_pre_resize', *self.size)\n        self.dispatch('on_rotate', x)",
  "def _free_kanimation(self, *largs):\n        WindowBase._kanimation = None",
  "def _animate_content(self):\n        '''Animate content to IME height.\n        '''\n        kargs = self.keyboard_anim_args\n        global Animation\n        if not Animation:\n            from kivy.animation import Animation\n        if WindowBase._kanimation:\n            WindowBase._kanimation.cancel(self)\n        WindowBase._kanimation = kanim = Animation(\n            _kheight=self.keyboard_height + self.keyboard_padding,\n            d=kargs['d'], t=kargs['t'])\n        kanim.bind(on_complete=self._free_kanimation)\n        kanim.start(self)",
  "def _upd_kbd_height(self, *kargs):\n        self._keyboard_changed = not self._keyboard_changed\n        self._animate_content()",
  "def _get_ios_kheight(self):\n        import ios\n        return ios.get_kheight()",
  "def _get_android_kheight(self):\n        if USE_SDL2:  # Placeholder until the SDL2 bootstrap supports this\n            return 0\n        global android\n        if not android:\n            import android\n        return android.get_keyboard_height()",
  "def _get_kivy_vkheight(self):\n        mode = Config.get('kivy', 'keyboard_mode')\n        if (\n            mode in ['dock', 'systemanddock']\n            and self._vkeyboard_cls is not None\n        ):\n            for w in self.children:\n                if isinstance(w, self._vkeyboard_cls):\n                    vkeyboard_height = w.height * w.scale\n                    if self.softinput_mode == 'pan':\n                        return vkeyboard_height\n                    elif (\n                        self.softinput_mode == 'below_target'\n                        and w.target.y < vkeyboard_height\n                    ):\n                        return vkeyboard_height - w.target.y\n        return 0",
  "def _get_kheight(self):\n        if platform == 'android':\n            return self._get_android_kheight()\n        elif platform == 'ios':\n            return self._get_ios_kheight()\n        return self._get_kivy_vkheight()",
  "def _set_system_size(self, size):\n        self._size = size",
  "def _get_system_size(self):\n        if self.softinput_mode == 'resize':\n            return self._size[0], self._size[1] - self.keyboard_height\n        return self._size",
  "def _get_effective_size(self):\n        '''On density=1 and non-ios / non-Windows displays,\n        return :attr:`system_size`, else return scaled / rotated :attr:`size`.\n\n        Used by MouseMotionEvent.update_graphics() and WindowBase.on_motion().\n        '''\n        w, h = self.system_size\n        if platform in ('ios', 'win') or self._density != 1:\n            w, h = self.size\n\n        return w, h",
  "def _get_focus(self):\n        return self._focus",
  "def _set_cursor_state(self, value):\n        pass",
  "def set_system_cursor(self, cursor_name):\n        '''Set type of a mouse cursor in the Window.\n\n        It can be one of 'arrow', 'ibeam', 'wait', 'crosshair', 'wait_arrow',\n        'size_nwse', 'size_nesw', 'size_we', 'size_ns', 'size_all', 'no', or\n        'hand'.\n\n        On some platforms there might not be a specific cursor supported and\n        such an option falls back to one of the substitutable alternatives:\n\n        +------------+-----------+------------+-----------+---------------+\n        |            | Windows   | MacOS      | Linux X11 | Linux Wayland |\n        +============+===========+============+===========+===============+\n        | arrow      | arrow     | arrow      | arrow     | arrow         |\n        +------------+-----------+------------+-----------+---------------+\n        | ibeam      | ibeam     | ibeam      | ibeam     | ibeam         |\n        +------------+-----------+------------+-----------+---------------+\n        | wait       | wait      | arrow      | wait      | wait          |\n        +------------+-----------+------------+-----------+---------------+\n        | crosshair  | crosshair | crosshair  | crosshair | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | wait_arrow | arrow     | arrow      | wait      | wait          |\n        +------------+-----------+------------+-----------+---------------+\n        | size_nwse  | size_nwse | size_all   | size_all  | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | size_nesw  | size_nesw | size_all   | size_all  | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | size_we    | size_we   | size_we    | size_we   | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | size_ns    | size_ns   | size_ns    | size_ns   | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | size_all   | size_all  | size_all   | size_all  | hand          |\n        +------------+-----------+------------+-----------+---------------+\n        | no         | no        | no         | no        | ibeam         |\n        +------------+-----------+------------+-----------+---------------+\n        | hand       | hand      | hand       | hand      | hand          |\n        +------------+-----------+------------+-----------+---------------+\n\n        .. versionadded:: 1.10.1\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        pass",
  "def _get_window_pos(self):\n        pass",
  "def _set_window_pos(self, x, y):\n        pass",
  "def _get_left(self):\n        if not self.initialized:\n            return self._left\n        return self._get_window_pos()[0]",
  "def _set_left(self, value):\n        pos = self._get_window_pos()\n        self._set_window_pos(value, pos[1])",
  "def _get_top(self):\n        if not self.initialized:\n            return self._top\n        return self._get_window_pos()[1]",
  "def _set_top(self, value):\n        pos = self._get_window_pos()\n        self._set_window_pos(pos[0], value)",
  "def __self__(self):\n        return self",
  "def __new__(cls, **kwargs):\n        if cls.__instance is None:\n            cls.__instance = EventDispatcher.__new__(cls)\n        return cls.__instance",
  "def __init__(self, **kwargs):\n        force = kwargs.pop('force', False)\n\n        # don't init window 2 times,\n        # except if force is specified\n        if WindowBase.__instance is not None and not force:\n            return\n\n        self.initialized = False\n        self.event_managers = []\n        self.event_managers_dict = defaultdict(list)\n        self._is_desktop = Config.getboolean('kivy', 'desktop')\n\n        # create a trigger for update/create the window when one of window\n        # property changes\n        self.trigger_create_window = Clock.create_trigger(\n            self.create_window, -1)\n\n        # Create a trigger for updating the keyboard height\n        self.trigger_keyboard_height = Clock.create_trigger(\n            self._upd_kbd_height, .5)\n        self.bind(_kheight=lambda *args: self.update_viewport())\n\n        # set the default window parameter according to the configuration\n        if 'borderless' not in kwargs:\n            kwargs['borderless'] = Config.getboolean('graphics', 'borderless')\n        if 'custom_titlebar' not in kwargs:\n            kwargs['custom_titlebar'] = Config.getboolean('graphics',\n                                                          'custom_titlebar')\n        if 'fullscreen' not in kwargs:\n            fullscreen = Config.get('graphics', 'fullscreen')\n            if fullscreen not in ('auto', 'fake'):\n                fullscreen = fullscreen.lower() in ('true', '1', 'yes')\n            kwargs['fullscreen'] = fullscreen\n        if 'width' not in kwargs:\n            kwargs['width'] = Config.getint('graphics', 'width')\n        if 'height' not in kwargs:\n            kwargs['height'] = Config.getint('graphics', 'height')\n        if 'minimum_width' not in kwargs:\n            kwargs['minimum_width'] = Config.getint('graphics',\n                                                    'minimum_width')\n        if 'minimum_height' not in kwargs:\n            kwargs['minimum_height'] = Config.getint('graphics',\n                                                     'minimum_height')\n        if 'always_on_top' not in kwargs:\n            kwargs['always_on_top'] = Config.getboolean(\n                'graphics', 'always_on_top'\n            )\n        if 'allow_screensaver' not in kwargs:\n            kwargs['allow_screensaver'] = Config.getboolean(\n                'graphics', 'allow_screensaver')\n        if 'rotation' not in kwargs:\n            kwargs['rotation'] = Config.getint('graphics', 'rotation')\n        if 'position' not in kwargs:\n            kwargs['position'] = Config.getdefault('graphics', 'position',\n                                                   'auto')\n        if 'top' in kwargs:\n            kwargs['position'] = 'custom'\n            self._top = kwargs['top']\n        else:\n            self._top = Config.getint('graphics', 'top')\n        if 'left' in kwargs:\n            kwargs['position'] = 'custom'\n            self._left = kwargs['left']\n        else:\n            self._left = Config.getint('graphics', 'left')\n        kwargs['_size'] = (kwargs.pop('width'), kwargs.pop('height'))\n        if 'show_cursor' not in kwargs:\n            kwargs['show_cursor'] = Config.getboolean(\n                'graphics', 'show_cursor'\n            )\n        if 'shape_image' not in kwargs:\n            kwargs['shape_image'] = Config.get('kivy', 'window_shape')\n\n        self.fbind(\n            'on_drop_file',\n            lambda win, filename, *args: win.dispatch('on_dropfile', filename)\n        )\n        super(WindowBase, self).__init__(**kwargs)\n\n        # bind all the properties that need to recreate the window\n        self._bind_create_window()\n        self.bind(size=self.trigger_keyboard_height,\n                  rotation=self.trigger_keyboard_height)\n\n        self.bind(softinput_mode=lambda *dt: self.update_viewport(),\n                  keyboard_height=lambda *dt: self.update_viewport())\n\n        self.bind(show_cursor=lambda *dt: self._set_cursor_state(dt[1]))\n\n        # init privates\n        self._system_keyboard = Keyboard(window=self)\n        self._keyboards = {'system': self._system_keyboard}\n        self._vkeyboard_cls = None\n\n        self.children = []\n        self.parent = self\n\n        # before creating the window\n        import kivy.core.gl  # NOQA\n\n        # configure the window\n        self.create_window()\n        self.register()\n\n        # manage keyboard(s)\n        self.configure_keyboards()\n\n        # assign the default context of the widget creation\n        if not hasattr(self, '_context'):\n            self._context = get_current_context()\n\n        # because Window is created as soon as imported, if we bound earlier,\n        # metrics would be imported when dp is set during window creation.\n        # Instead, don't process dpi changes until everything is set\n        self.fbind('dpi', self._reset_metrics_dpi)\n\n        # mark as initialized\n        self.initialized = True",
  "def _reset_metrics_dpi(self, *args):\n        from kivy.metrics import Metrics\n        Metrics.reset_dpi()",
  "def _bind_create_window(self):\n        for prop in (\n                'fullscreen', 'borderless', 'position', 'top',\n                'left', '_size', 'system_size'):\n            self.bind(**{prop: self.trigger_create_window})",
  "def _unbind_create_window(self):\n        for prop in (\n                'fullscreen', 'borderless', 'position', 'top',\n                'left', '_size', 'system_size'):\n            self.unbind(**{prop: self.trigger_create_window})",
  "def register(self):\n        if self.initialized:\n            return\n        # attach modules + listener event\n        EventLoop.set_window(self)\n        Modules.register_window(self)\n        EventLoop.add_event_listener(self)",
  "def register_event_manager(self, manager):\n        '''Register and start an event manager to handle events declared in\n        :attr:`~kivy.eventmanager.EventManagerBase.type_ids` attribute.\n\n        .. versionadded:: 2.1.0\n\n        .. warning::\n            This is an experimental method and it remains so until this warning\n            is present as it can be changed or removed in the next versions of\n            Kivy.\n        '''\n        self.event_managers.insert(0, manager)\n        for type_id in manager.type_ids:\n            self.event_managers_dict[type_id].insert(0, manager)\n        manager.window = self\n        manager.start()",
  "def unregister_event_manager(self, manager):\n        '''Unregister and stop an event manager previously registered with\n        :meth:`register_event_manager`.\n\n        .. versionadded:: 2.1.0\n\n        .. warning::\n            This is an experimental method and it remains so until this warning\n            is present as it can be changed or removed in the next versions of\n            Kivy.\n        '''\n        self.event_managers.remove(manager)\n        for type_id in manager.type_ids:\n            self.event_managers_dict[type_id].remove(manager)\n        manager.stop()\n        manager.window = None",
  "def mainloop(self):\n        '''Called by the EventLoop every frame after it idles.\n        '''\n        pass",
  "def maximize(self):\n        '''Maximizes the window. This method should be used on desktop\n        platforms only.\n\n        .. versionadded:: 1.9.0\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: maximize() is not implemented in the current '\n                        'window provider.')",
  "def minimize(self):\n        '''Minimizes the window. This method should be used on desktop\n        platforms only.\n\n        .. versionadded:: 1.9.0\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: minimize() is not implemented in the current '\n                        'window provider.')",
  "def restore(self):\n        '''Restores the size and position of a maximized or minimized window.\n        This method should be used on desktop platforms only.\n\n        .. versionadded:: 1.9.0\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: restore() is not implemented in the current '\n                        'window provider.')",
  "def hide(self):\n        '''Hides the window. This method should be used on desktop\n        platforms only.\n\n        .. versionadded:: 1.9.0\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: hide() is not implemented in the current '\n                        'window provider.')",
  "def show(self):\n        '''Shows the window. This method should be used on desktop\n        platforms only.\n\n        .. versionadded:: 1.9.0\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: show() is not implemented in the current '\n                        'window provider.')",
  "def raise_window(self):\n        '''Raise the window. This method should be used on desktop\n        platforms only.\n\n        .. versionadded:: 1.9.1\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n        '''\n        Logger.warning('Window: raise_window is not implemented in the current'\n                       ' window provider.')",
  "def close(self):\n        '''Close the window'''\n        self.dispatch('on_close')\n\n        # Prevent any leftover that can crash the app later\n        # like if there is still some GL referenced values\n        # they may be collected later, but because it was already\n        # gone in the system, it may collect invalid GL resources\n        # Just clear everything to force reloading later on.\n        from kivy.cache import Cache\n        from kivy.graphics.context import get_context\n        Cache.remove('kv.loader')\n        Cache.remove('kv.image')\n        Cache.remove('kv.shader')\n        Cache.remove('kv.texture')\n        get_context().flush()",
  "def set_custom_titlebar(self, widget):\n        \"\"\"\n        Sets a Widget as a titlebar\n\n            :widget: The widget you want to set as the titlebar\n\n        .. versionadded:: 2.1.0\n\n        This function returns `True` on successfully setting the custom titlebar,\n        else false\n\n        How to use this feature\n\n        ::\n\n            1. first set Window.custom_titlebar to True\n            2. then call Window.set_custom_titlebar with the widget/layout you want to set as titlebar as the argument # noqa: E501\n\n        If you want a child of the widget to receive touch events, in\n        that child define a property `draggable` and set it to False\n\n        If you set the property `draggable` on a layout,\n        all the child in the layout will receive touch events\n\n        If you want to override default behavior, add function `in_drag_area(x,y)`\n        to the widget\n\n        The function is call with two args x,y which are mouse.x, and mouse.y\n        the function should return\n\n        | `True` if that point should be used to drag the window\n        | `False` if you want to receive the touch event at the point\n\n        .. note::\n            If you use :meth:`in_drag_area` property `draggable`\n            will not be checked\n\n        .. note::\n            This feature requires the SDL2 window provider and is currently\n            only supported on desktop platforms.\n\n        .. warning::\n            :mod:`~kivy.core.window.WindowBase.custom_titlebar` must be set to True\n            for the widget to be successfully set as a titlebar\n\n        \"\"\"\n\n        Logger.warning('Window: set_custom_titlebar '\n                       'is not implemented in the current'\n                       ' window provider.')",
  "def on_shape_image(self, instance, value):\n        if self.initialized:\n            self._set_shape(\n                shape_image=value, mode=self.shape_mode,\n                cutoff=self.shape_cutoff, color_key=self.shape_color_key\n            )",
  "def on_shape_cutoff(self, instance, value):\n        self._set_shape(\n            shape_image=self.shape_image, mode=self.shape_mode,\n            cutoff=value, color_key=self.shape_color_key\n        )",
  "def _get_shaped(self):\n        return self._is_shaped()",
  "def _get_shape_mode(self):\n        if not self.shaped:\n            return ''\n\n        i = self._get_shaped_mode()['mode']\n        modes = ('default', 'binalpha', 'reversebinalpha', 'colorkey')\n        return modes[i]",
  "def _set_shape_mode(self, value):\n        self._set_shaped_mode(value)",
  "def on_shape_color_key(self, instance, value):\n        self._set_shape(\n            shape_image=self.shape_image, mode=self.shape_mode,\n            cutoff=self.shape_cutoff, color_key=value\n        )",
  "def get_gl_backend_name(self):\n        \"\"\"\n        Returns the gl backend that will or is used with this window.\n        \"\"\"\n        return cgl_get_backend_name(\n            allowed=self.gl_backends_allowed,\n            ignored=self.gl_backends_ignored)",
  "def initialize_gl(self):\n        from kivy.core.gl import init_gl\n        init_gl(allowed=self.gl_backends_allowed,\n                ignored=self.gl_backends_ignored)",
  "def create_window(self, *largs):\n        '''Will create the main window and configure it.\n\n        .. warning::\n            This method is called automatically at runtime. If you call it, it\n            will recreate a RenderContext and Canvas. This means you'll have a\n            new graphics tree, and the old one will be unusable.\n\n            This method exist to permit the creation of a new OpenGL context\n            AFTER closing the first one. (Like using runTouchApp() and\n            stopTouchApp()).\n\n            This method has only been tested in a unittest environment and\n            is not suitable for Applications.\n\n            Again, don't use this method unless you know exactly what you are\n            doing!\n        '''\n        # just to be sure, if the trigger is set, and if this method is\n        # manually called, unset the trigger\n        self.trigger_create_window.cancel()\n\n        # ensure the window creation will not be called twice\n        if platform in ('android'):\n            self._unbind_create_window()\n\n        if not self.initialized:\n            self.initialize_gl()\n\n            # create the render context and canvas, only the first time.\n            from kivy.graphics import RenderContext, Canvas\n            self.render_context = RenderContext()\n            self.canvas = Canvas()\n            self.render_context.add(self.canvas)\n\n        else:\n            # if we get initialized more than once, then reload opengl state\n            # after the second time.\n            # XXX check how it's working on embed platform.\n            if platform == 'linux' or Window.__class__.__name__ == 'WindowSDL':\n                # on linux, it's safe for just sending a resize.\n                self.dispatch('on_pre_resize', *self.size)\n\n            else:\n                # on other platform, window are recreated, we need to reload.\n                from kivy.graphics.context import get_context\n                get_context().reload()\n                Clock.schedule_once(lambda x: self.canvas.ask_update(), 0)\n                self.dispatch('on_pre_resize', *self.size)\n\n        # ensure the gl viewport is correct\n        self.update_viewport()",
  "def on_flip(self):\n        '''Flip between buffers (event)'''\n        self.flip()",
  "def flip(self):\n        '''Flip between buffers'''\n        pass",
  "def _update_childsize(self, instance, value):\n        self.update_childsize([instance])",
  "def add_widget(self, widget, canvas=None):\n        '''Add a widget to a window'''\n        if widget.parent:\n            from kivy.uix.widget import WidgetException\n            raise WidgetException(\n                'Cannot add %r to window, it already has a parent %r' %\n                (widget, widget.parent)\n            )\n\n        widget.parent = self\n        self.children.insert(0, widget)\n        canvas = self.canvas.before if canvas == 'before' else \\\n            self.canvas.after if canvas == 'after' else self.canvas\n        canvas.add(widget.canvas)\n        self.update_childsize([widget])\n        widget.bind(\n            pos_hint=self._update_childsize,\n            size_hint=self._update_childsize,\n            size_hint_max=self._update_childsize,\n            size_hint_min=self._update_childsize,\n            size=self._update_childsize,\n            pos=self._update_childsize)",
  "def remove_widget(self, widget):\n        '''Remove a widget from a window\n        '''\n        if widget not in self.children:\n            return\n        self.children.remove(widget)\n        if widget.canvas in self.canvas.children:\n            self.canvas.remove(widget.canvas)\n        elif widget.canvas in self.canvas.after.children:\n            self.canvas.after.remove(widget.canvas)\n        elif widget.canvas in self.canvas.before.children:\n            self.canvas.before.remove(widget.canvas)\n        widget.parent = None\n        widget.unbind(\n            pos_hint=self._update_childsize,\n            size_hint=self._update_childsize,\n            size_hint_max=self._update_childsize,\n            size_hint_min=self._update_childsize,\n            size=self._update_childsize,\n            pos=self._update_childsize)",
  "def clear(self):\n        '''Clear the window with the background color'''\n        # XXX FIXME use late binding\n        from kivy.graphics import opengl as gl\n        gl.glClearColor(*self.clearcolor)\n        gl.glClear(\n            gl.GL_COLOR_BUFFER_BIT\n            | gl.GL_DEPTH_BUFFER_BIT\n            | gl.GL_STENCIL_BUFFER_BIT\n        )",
  "def set_title(self, title):\n        '''Set the window title.\n\n        .. versionadded:: 1.0.5\n        '''\n        self.title = title",
  "def set_icon(self, filename):\n        '''Set the icon of the window.\n\n        .. versionadded:: 1.0.5\n        '''\n        self.icon = filename",
  "def to_widget(self, x, y, initial=True, relative=False):\n        return (x, y)",
  "def to_window(self, x, y, initial=True, relative=False):\n        return (x, y)",
  "def to_normalized_pos(self, x, y):\n        '''Transforms absolute coordinates to normalized (0-1) coordinates\n        using :attr:`system_size`.\n\n        .. versionadded:: 2.1.0\n        '''\n        x_max = self.system_size[0] - 1.0\n        y_max = self.system_size[1] - 1.0\n        return (\n            x / x_max if x_max > 0 else 0.0,\n            y / y_max if y_max > 0 else 0.0\n        )",
  "def transform_motion_event_2d(self, me, widget=None):\n        '''Transforms the motion event `me` to this window size and then if\n        `widget` is passed transforms `me` to `widget`'s local coordinates.\n\n        :raises:\n            `AttributeError`: If widget's ancestor is ``None``.\n\n        .. note::\n            Unless it's a specific case, call\n            :meth:`~kivy.input.motionevent.MotionEvent.push` before and\n            :meth:`~kivy.input.motionevent.MotionEvent.pop` after this method's\n            call to preserve previous values of `me`'s attributes.\n\n        .. versionadded:: 2.1.0\n        '''\n        width, height = self._get_effective_size()\n        me.scale_for_screen(\n            width, height,\n            rotation=self.rotation,\n            smode=self.softinput_mode,\n            kheight=self.keyboard_height\n        )\n        if widget is not None:\n            parent = widget.parent\n            try:\n                if parent:\n                    me.apply_transform_2d(parent.to_widget)\n                else:\n                    me.apply_transform_2d(widget.to_widget)\n                    me.apply_transform_2d(widget.to_parent)\n            except AttributeError:\n                # when using inner window, an app have grab the touch\n                # but app is removed. The touch can't access\n                # to one of the parent. (i.e, self.parent will be None)\n                # and BAM the bug happen.\n                raise",
  "def _apply_transform(self, m):\n        return m",
  "def get_window_matrix(self, x=0, y=0):\n        m = Matrix()\n        m.translate(x, y, 0)\n        return m",
  "def get_root_window(self):\n        return self",
  "def get_parent_window(self):\n        return self",
  "def get_parent_layout(self):\n        return None",
  "def on_draw(self):\n        self.clear()\n        self.render_context.draw()",
  "def on_motion(self, etype, me):\n        '''Event called when a motion event is received.\n\n        :Parameters:\n            `etype`: str\n                One of \"begin\", \"update\" or \"end\".\n            `me`: :class:`~kivy.input.motionevent.MotionEvent`\n                The motion event currently dispatched.\n\n        .. versionchanged:: 2.1.0\n            Event managers get to handle the touch event first and if none of\n            them accepts the event (by returning `True`) then window will\n            dispatch `me` through \"on_touch_down\", \"on_touch_move\",\n            \"on_touch_up\" events depending on the `etype`. All non-touch events\n            will go only through managers.\n        '''\n        accepted = False\n        for manager in self.event_managers_dict[me.type_id][:]:\n            accepted = manager.dispatch(etype, me) or accepted\n        if accepted:\n            if me.is_touch and etype == 'end':\n                FocusBehavior._handle_post_on_touch_up(me)\n            return accepted\n        if me.is_touch:\n            # TODO: Use me.push/me.pop methods because `me` is transformed\n            # Clock execution of partial ScrollView._on_touch_up method and\n            # other similar cases should be changed so that me.push/me.pop can\n            # be used restore previous values of event's attributes\n            # me.push()\n            self.transform_motion_event_2d(me)\n            if etype == 'begin':\n                self.dispatch('on_touch_down', me)\n            elif etype == 'update':\n                self.dispatch('on_touch_move', me)\n            elif etype == 'end':\n                self.dispatch('on_touch_up', me)\n                FocusBehavior._handle_post_on_touch_up(me)",
  "def on_touch_down(self, touch):\n        '''Event called when a touch down event is initiated.\n\n        .. versionchanged:: 1.9.0\n            The touch `pos` is now transformed to window coordinates before\n            this method is called. Before, the touch `pos` coordinate would be\n            `(0, 0)` when this method was called.\n        '''\n        for w in self.children[:]:\n            if w.dispatch('on_touch_down', touch):\n                return True",
  "def on_touch_move(self, touch):\n        '''Event called when a touch event moves (changes location).\n\n        .. versionchanged:: 1.9.0\n            The touch `pos` is now transformed to window coordinates before\n            this method is called. Before, the touch `pos` coordinate would be\n            `(0, 0)` when this method was called.\n        '''\n        for w in self.children[:]:\n            if w.dispatch('on_touch_move', touch):\n                return True",
  "def on_touch_up(self, touch):\n        '''Event called when a touch event is released (terminated).\n\n        .. versionchanged:: 1.9.0\n            The touch `pos` is now transformed to window coordinates before\n            this method is called. Before, the touch `pos` coordinate would be\n            `(0, 0)` when this method was called.\n        '''\n        for w in self.children[:]:\n            if w.dispatch('on_touch_up', touch):\n                return True",
  "def on_pre_resize(self, width, height):\n        key = (width, height)\n        if hasattr(self, '_last_resize') and self._last_resize == key:\n            return\n        self._last_resize = key\n        self.dispatch('on_resize', width, height)",
  "def on_resize(self, width, height):\n        '''Event called when the window is resized.'''\n        self.update_viewport()",
  "def on_move(self):\n        self.property('top').dispatch(self)\n        self.property('left').dispatch(self)",
  "def update_viewport(self):\n        from kivy.graphics.opengl import glViewport\n        from kivy.graphics.transformation import Matrix\n        from math import radians\n\n        w, h = self._get_effective_size()\n\n        smode = self.softinput_mode\n        target = self._system_keyboard.target\n        targettop = max(0, target.to_window(0, target.y)[1]) if target else 0\n        kheight = self._kheight\n\n        w2, h2 = w / 2., h / 2.\n        r = radians(self.rotation)\n\n        y = 0\n        _h = h\n        if smode == 'pan':\n            y = kheight\n        elif smode == 'below_target':\n            y = 0 if kheight < targettop else (kheight - targettop)\n        if smode == 'scale':\n            _h -= kheight\n\n        # prepare the viewport\n        glViewport(0, 0, w, _h)\n\n        # do projection matrix\n        projection_mat = Matrix()\n        projection_mat.view_clip(0.0, w, 0.0, h, -1.0, 1.0, 0)\n        self.render_context['projection_mat'] = projection_mat\n\n        # do modelview matrix\n        modelview_mat = Matrix().translate(w2, h2, 0)\n        modelview_mat = modelview_mat.multiply(Matrix().rotate(r, 0, 0, 1))\n\n        w, h = self.size\n        w2, h2 = w / 2., h / 2. - y\n        modelview_mat = modelview_mat.multiply(Matrix().translate(-w2, -h2, 0))\n        self.render_context['modelview_mat'] = modelview_mat\n        frag_modelview_mat = Matrix()\n        frag_modelview_mat.set(flat=modelview_mat.get())\n        self.render_context['frag_modelview_mat'] = frag_modelview_mat\n\n        # redraw canvas\n        self.canvas.ask_update()\n\n        # and update childs\n        self.update_childsize()",
  "def update_childsize(self, childs=None):\n        width, height = self.size\n        if childs is None:\n            childs = self.children\n        for w in childs:\n            shw, shh = w.size_hint\n            shw_min, shh_min = w.size_hint_min\n            shw_max, shh_max = w.size_hint_max\n\n            if shw is not None and shh is not None:\n                c_w = shw * width\n                c_h = shh * height\n\n                if shw_min is not None and c_w < shw_min:\n                    c_w = shw_min\n                elif shw_max is not None and c_w > shw_max:\n                    c_w = shw_max\n\n                if shh_min is not None and c_h < shh_min:\n                    c_h = shh_min\n                elif shh_max is not None and c_h > shh_max:\n                    c_h = shh_max\n                w.size = c_w, c_h\n            elif shw is not None:\n                c_w = shw * width\n\n                if shw_min is not None and c_w < shw_min:\n                    c_w = shw_min\n                elif shw_max is not None and c_w > shw_max:\n                    c_w = shw_max\n                w.width = c_w\n            elif shh is not None:\n                c_h = shh * height\n\n                if shh_min is not None and c_h < shh_min:\n                    c_h = shh_min\n                elif shh_max is not None and c_h > shh_max:\n                    c_h = shh_max\n                w.height = c_h\n\n            for key, value in w.pos_hint.items():\n                if key == 'x':\n                    w.x = value * width\n                elif key == 'right':\n                    w.right = value * width\n                elif key == 'y':\n                    w.y = value * height\n                elif key == 'top':\n                    w.top = value * height\n                elif key == 'center_x':\n                    w.center_x = value * width\n                elif key == 'center_y':\n                    w.center_y = value * height",
  "def screenshot(self, name='screenshot{:04d}.png'):\n        '''Save the actual displayed image to a file.\n        '''\n        i = 0\n        path = None\n        if name != 'screenshot{:04d}.png':\n            _ext = name.split('.')[-1]\n            name = ''.join((name[:-(len(_ext) + 1)], '{:04d}.', _ext))\n        while True:\n            i += 1\n            path = join(getcwd(), name.format(i))\n            if not exists(path):\n                break\n        return path",
  "def on_rotate(self, rotation):\n        '''Event called when the screen has been rotated.\n        '''\n        pass",
  "def on_close(self, *largs):\n        '''Event called when the window is closed.'''\n        Modules.unregister_window(self)\n        EventLoop.remove_event_listener(self)",
  "def on_minimize(self, *largs):\n        '''Event called when the window is minimized.\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass",
  "def on_maximize(self, *largs):\n        '''Event called when the window is maximized.\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass",
  "def on_restore(self, *largs):\n        '''Event called when the window is restored.\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass",
  "def on_hide(self, *largs):\n        '''Event called when the window is hidden.\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass",
  "def on_show(self, *largs):\n        '''Event called when the window is shown.\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass",
  "def on_request_close(self, *largs, **kwargs):\n        '''Event called before we close the window. If a bound function returns\n        `True`, the window will not be closed. If the event is triggered\n        because of the keyboard escape key, the keyword argument `source` is\n        dispatched along with a value of `keyboard` to the bound functions.\n\n        .. warning::\n            When the bound function returns True the window will not be closed,\n            so use with care because the user would not be able to close the\n            program, even if the red X is clicked.\n        '''\n        pass",
  "def on_cursor_enter(self, *largs):\n        '''Event called when the cursor enters the window.\n\n        .. versionadded:: 1.9.1\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass",
  "def on_cursor_leave(self, *largs):\n        '''Event called when the cursor leaves the window.\n\n        .. versionadded:: 1.9.1\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass",
  "def on_mouse_down(self, x, y, button, modifiers):\n        '''Event called when the mouse is used (pressed/released).'''\n        pass",
  "def on_mouse_move(self, x, y, modifiers):\n        '''Event called when the mouse is moved with buttons pressed.'''\n        pass",
  "def on_mouse_up(self, x, y, button, modifiers):\n        '''Event called when the mouse is moved with buttons pressed.'''\n        pass",
  "def on_joy_axis(self, stickid, axisid, value):\n        '''Event called when a joystick has a stick or other axis moved.\n\n        .. versionadded:: 1.9.0'''\n        pass",
  "def on_joy_hat(self, stickid, hatid, value):\n        '''Event called when a joystick has a hat/dpad moved.\n\n        .. versionadded:: 1.9.0'''\n        pass",
  "def on_joy_ball(self, stickid, ballid, xvalue, yvalue):\n        '''Event called when a joystick has a ball moved.\n\n        .. versionadded:: 1.9.0'''\n        pass",
  "def on_joy_button_down(self, stickid, buttonid):\n        '''Event called when a joystick has a button pressed.\n\n        .. versionadded:: 1.9.0'''\n        pass",
  "def on_joy_button_up(self, stickid, buttonid):\n        '''Event called when a joystick has a button released.\n\n        .. versionadded:: 1.9.0'''\n        pass",
  "def on_keyboard(self, key, scancode=None, codepoint=None,\n                    modifier=None, **kwargs):\n        '''Event called when keyboard is used.\n\n        .. warning::\n            Some providers may omit `scancode`, `codepoint` and/or `modifier`.\n        '''\n        if 'unicode' in kwargs:\n            Logger.warning(\"The use of the unicode parameter is deprecated, \"\n                           \"and will be removed in future versions. Use \"\n                           \"codepoint instead, which has identical \"\n                           \"semantics.\")\n\n        # Quit if user presses ESC or the typical OSX shortcuts CMD+q or CMD+w\n        # On Android a back key/gesture is mapped to 27 and initiates a pause.\n        # Consume the event and tell Android to pause.\n        # TODO If just CMD+w is pressed, only the window should be closed.\n        is_osx = platform == 'darwin'\n        if key == 27 and platform == 'android':\n            from android import mActivity\n            mActivity.moveTaskToBack(True)\n            return True\n        elif WindowBase.on_keyboard.exit_on_escape:\n            if key == 27 or all([is_osx, key in [113, 119], modifier == 1024]):\n                if not self.dispatch('on_request_close', source='keyboard'):\n                    stopTouchApp()\n                    self.close()\n                    return True",
  "def on_key_down(self, key, scancode=None, codepoint=None,\n                    modifier=None, **kwargs):\n        '''Event called when a key is down (same arguments as on_keyboard)'''\n        if 'unicode' in kwargs:\n            Logger.warning(\"The use of the unicode parameter is deprecated, \"\n                           \"and will be removed in future versions. Use \"\n                           \"codepoint instead, which has identical \"\n                           \"semantics.\")",
  "def on_key_up(self, key, scancode=None, codepoint=None,\n                  modifier=None, **kwargs):\n        '''Event called when a key is released (same arguments as on_keyboard).\n        '''\n        if 'unicode' in kwargs:\n            Logger.warning(\"The use of the unicode parameter is deprecated, \"\n                           \"and will be removed in future versions. Use \"\n                           \"codepoint instead, which has identical \"\n                           \"semantics.\")",
  "def on_textinput(self, text):\n        '''Event called when text: i.e. alpha numeric non control keys or set\n        of keys is entered. As it is not guaranteed whether we get one\n        character or multiple ones, this event supports handling multiple\n        characters.\n\n        .. versionadded:: 1.9.0\n        '''\n        pass",
  "def on_drop_begin(self, x, y, *args):\n        '''Event called when a text or a file drop on the application is about\n        to begin. It will be followed-up by a single or a multiple\n        `on_drop_text` or `on_drop_file` events ending with an `on_drop_end`\n        event.\n\n        Arguments `x` and `y` are the mouse cursor position at the time of the\n        drop and you should only rely on them if the drop originated from the\n        mouse.\n\n        :Parameters:\n            `x`: `int`\n                Cursor x position, relative to the window :attr:`left`, at the\n                time of the drop.\n            `y`: `int`\n                Cursor y position, relative to the window :attr:`top`, at the\n                time of the drop.\n            `*args`: `tuple`\n                Additional arguments.\n\n        .. note::\n            This event works with sdl2 window provider.\n\n        .. versionadded:: 2.1.0\n        '''\n        pass",
  "def on_drop_file(self, filename, x, y, *args):\n        '''Event called when a file is dropped on the application.\n\n        Arguments `x` and `y` are the mouse cursor position at the time of the\n        drop and you should only rely on them if the drop originated from the\n        mouse.\n\n        :Parameters:\n            `filename`: `bytes`\n                Absolute path to a dropped file.\n            `x`: `int`\n                Cursor x position, relative to the window :attr:`left`, at the\n                time of the drop.\n            `y`: `int`\n                Cursor y position, relative to the window :attr:`top`, at the\n                time of the drop.\n            `*args`: `tuple`\n                Additional arguments.\n\n        .. warning::\n            This event currently works with sdl2 window provider, on pygame\n            window provider and OS X with a patched version of pygame.\n            This event is left in place for further evolution\n            (ios, android etc.)\n\n        .. note::\n            On Windows it is possible to drop a file on the window title bar\n            or on its edges and for that case :attr:`mouse_pos` won't be\n            updated as the mouse cursor is not within the window.\n\n        .. note::\n            This event doesn't work for apps with elevated permissions,\n            because the OS API calls are filtered. Check issue\n            `#4999 <https://github.com/kivy/kivy/issues/4999>`_ for\n            pointers to workarounds.\n\n        .. versionadded:: 1.2.0\n\n        .. versionchanged:: 2.1.0\n            Renamed from `on_dropfile` to `on_drop_file`.\n        '''\n        pass",
  "def on_dropfile(self, filename):\n        pass",
  "def on_drop_text(self, text, x, y, *args):\n        '''Event called when a text is dropped on the application.\n\n        Arguments `x` and `y` are the mouse cursor position at the time of the\n        drop and you should only rely on them if the drop originated from the\n        mouse.\n\n        :Parameters:\n            `text`: `bytes`\n                Text which is dropped.\n            `x`: `int`\n                Cursor x position, relative to the window :attr:`left`, at the\n                time of the drop.\n            `y`: `int`\n                Cursor y position, relative to the window :attr:`top`, at the\n                time of the drop.\n            `*args`: `tuple`\n                Additional arguments.\n\n        .. note::\n            This event works with sdl2 window provider on x11 window.\n\n        .. note::\n            On Windows it is possible to drop a text on the window title bar\n            or on its edges and for that case :attr:`mouse_pos` won't be\n            updated as the mouse cursor is not within the window.\n\n        .. versionadded:: 2.1.0\n        '''\n        pass",
  "def on_drop_end(self, x, y, *args):\n        '''Event called when a text or a file drop on the application has\n        ended.\n\n        Arguments `x` and `y` are the mouse cursor position at the time of the\n        drop and you should only rely on them if the drop originated from the\n        mouse.\n\n        :Parameters:\n            `x`: `int`\n                Cursor x position, relative to the window :attr:`left`, at the\n                time of the drop.\n            `y`: `int`\n                Cursor y position, relative to the window :attr:`top`, at the\n                time of the drop.\n            `*args`: `tuple`\n                Additional arguments.\n\n        .. note::\n            This event works with sdl2 window provider.\n\n        .. versionadded:: 2.1.0\n        '''\n        pass",
  "def on_memorywarning(self):\n        '''Event called when the platform have memory issue.\n        Your goal is to clear the cache in your app as much as you can,\n        release unused widgets, do garbage collection etc.\n\n        Currently, this event is fired only from the SDL2 provider, for\n        iOS and Android.\n\n        .. versionadded:: 1.9.0\n        '''\n        pass",
  "def on_textedit(self, text):\n        '''Event called when inputting with IME.\n        The string inputting with IME is set as the parameter of\n        this event.\n\n        .. versionadded:: 1.10.1\n        '''\n        pass",
  "def configure_keyboards(self):\n        # Configure how to provide keyboards (virtual or not)\n\n        # register system keyboard to listening keys from window\n        sk = self._system_keyboard\n        self.bind(\n            on_key_down=sk._on_window_key_down,\n            on_key_up=sk._on_window_key_up,\n            on_textinput=sk._on_window_textinput)\n\n        # use the device's real keyboard\n        self.use_syskeyboard = True\n\n        # use the device's real keyboard\n        self.allow_vkeyboard = False\n\n        # one single vkeyboard shared between all widgets\n        self.single_vkeyboard = True\n\n        # the single vkeyboard is always sitting at the same position\n        self.docked_vkeyboard = False\n\n        # now read the configuration\n        mode = Config.get('kivy', 'keyboard_mode')\n        if mode not in ('', 'system', 'dock', 'multi', 'systemanddock',\n                        'systemandmulti'):\n            Logger.critical('Window: unknown keyboard mode %r' % mode)\n\n        # adapt mode according to the configuration\n        if mode == 'system':\n            self.use_syskeyboard = True\n            self.allow_vkeyboard = False\n            self.single_vkeyboard = True\n            self.docked_vkeyboard = False\n        elif mode == 'dock':\n            self.use_syskeyboard = False\n            self.allow_vkeyboard = True\n            self.single_vkeyboard = True\n            self.docked_vkeyboard = True\n        elif mode == 'multi':\n            self.use_syskeyboard = False\n            self.allow_vkeyboard = True\n            self.single_vkeyboard = False\n            self.docked_vkeyboard = False\n        elif mode == 'systemanddock':\n            self.use_syskeyboard = True\n            self.allow_vkeyboard = True\n            self.single_vkeyboard = True\n            self.docked_vkeyboard = True\n        elif mode == 'systemandmulti':\n            self.use_syskeyboard = True\n            self.allow_vkeyboard = True\n            self.single_vkeyboard = False\n            self.docked_vkeyboard = False\n\n        Logger.info(\n            'Window: virtual keyboard %sallowed, %s, %s' % (\n                '' if self.allow_vkeyboard else 'not ',\n                'single mode' if self.single_vkeyboard else 'multiuser mode',\n                'docked' if self.docked_vkeyboard else 'not docked'))",
  "def set_vkeyboard_class(self, cls):\n        '''.. versionadded:: 1.0.8\n\n        Set the VKeyboard class to use. If set to `None`, it will use the\n        :class:`kivy.uix.vkeyboard.VKeyboard`.\n        '''\n        self._vkeyboard_cls = cls",
  "def release_all_keyboards(self):\n        '''.. versionadded:: 1.0.8\n\n        This will ensure that no virtual keyboard / system keyboard is\n        requested. All instances will be closed.\n        '''\n        for key in list(self._keyboards.keys())[:]:\n            keyboard = self._keyboards[key]\n            if keyboard:\n                keyboard.release()",
  "def request_keyboard(\n            self, callback, target, input_type='text', keyboard_suggestions=True\n    ):\n        '''.. versionadded:: 1.0.4\n\n        Internal widget method to request the keyboard. This method is rarely\n        required by the end-user as it is handled automatically by the\n        :class:`~kivy.uix.textinput.TextInput`. We expose it in case you want\n        to handle the keyboard manually for unique input scenarios.\n\n        A widget can request the keyboard, indicating a callback to call\n        when the keyboard is released (or taken by another widget).\n\n        :Parameters:\n            `callback`: func\n                Callback that will be called when the keyboard is\n                closed. This can be because somebody else requested the\n                keyboard or the user closed it.\n            `target`: Widget\n                Attach the keyboard to the specified `target`. This should be\n                the widget that requested the keyboard. Ensure you have a\n                different target attached to each keyboard if you're working in\n                a multi user mode.\n\n                .. versionadded:: 1.0.8\n\n            `input_type`: string\n                Choose the type of soft keyboard to request. Can be one of\n                'null', 'text', 'number', 'url', 'mail', 'datetime', 'tel',\n                'address'.\n\n                .. note::\n\n                    `input_type` is currently only honored on Android.\n\n                .. versionadded:: 1.8.0\n\n                .. versionchanged:: 2.1.0\n                    Added `null` to soft keyboard types.\n\n            `keyboard_suggestions`: bool\n                If True provides auto suggestions on top of keyboard.\n                This will only work if input_type is set to `text`, `url`,\n                `mail` or `address`.\n\n                .. versionadded:: 2.1.0\n\n        :Return:\n            An instance of :class:`Keyboard` containing the callback, target,\n            and if the configuration allows it, a\n            :class:`~kivy.uix.vkeyboard.VKeyboard` instance attached as a\n            *.widget* property.\n\n        .. note::\n\n            The behavior of this function is heavily influenced by the current\n            `keyboard_mode`. Please see the Config's\n            :ref:`configuration tokens <configuration-tokens>` section for\n            more information.\n\n        '''\n\n        # release any previous keyboard attached.\n        self.release_keyboard(target)\n\n        # if we can use virtual vkeyboard, activate it.\n        if self.allow_vkeyboard:\n            keyboard = None\n\n            # late import\n            global VKeyboard\n            if VKeyboard is None and self._vkeyboard_cls is None:\n                from kivy.uix.vkeyboard import VKeyboard\n                self._vkeyboard_cls = VKeyboard\n\n            # if the keyboard doesn't exist, create it.\n            key = 'single' if self.single_vkeyboard else target\n            if key not in self._keyboards:\n                vkeyboard = self._vkeyboard_cls()\n                keyboard = Keyboard(widget=vkeyboard, window=self)\n                vkeyboard.bind(\n                    on_key_down=keyboard._on_vkeyboard_key_down,\n                    on_key_up=keyboard._on_vkeyboard_key_up,\n                    on_textinput=keyboard._on_vkeyboard_textinput)\n                self._keyboards[key] = keyboard\n            else:\n                keyboard = self._keyboards[key]\n\n            # configure vkeyboard\n            keyboard.target = keyboard.widget.target = target\n            keyboard.callback = keyboard.widget.callback = callback\n\n            # add to the window\n            self.add_widget(keyboard.widget)\n\n            # only after add, do dock mode\n            keyboard.widget.docked = self.docked_vkeyboard\n            keyboard.widget.setup_mode()\n\n            # sets vkeyboard position according to Window.softinput_mode\n            if self.softinput_mode == 'pan':\n                keyboard.widget.top = 0\n            elif self.softinput_mode == 'below_target':\n                keyboard.widget.top = keyboard.target.y\n\n        else:\n            # system keyboard, just register the callback.\n            keyboard = self._system_keyboard\n            keyboard.callback = callback\n            keyboard.target = target\n\n        # use system (hardware) keyboard according to flag\n        if self.allow_vkeyboard and self.use_syskeyboard:\n            self.unbind(\n                on_key_down=keyboard._on_window_key_down,\n                on_key_up=keyboard._on_window_key_up,\n                on_textinput=keyboard._on_window_textinput)\n            self.bind(\n                on_key_down=keyboard._on_window_key_down,\n                on_key_up=keyboard._on_window_key_up,\n                on_textinput=keyboard._on_window_textinput)\n\n        return keyboard",
  "def release_keyboard(self, target=None):\n        '''.. versionadded:: 1.0.4\n\n        Internal method for the widget to release the real-keyboard. Check\n        :meth:`request_keyboard` to understand how it works.\n        '''\n        if self.allow_vkeyboard:\n            key = 'single' if self.single_vkeyboard else target\n            if key not in self._keyboards:\n                return\n            keyboard = self._keyboards[key]\n            callback = keyboard.callback\n            if callback:\n                keyboard.callback = None\n                callback()\n            keyboard.target = None\n            self.remove_widget(keyboard.widget)\n            if key != 'single' and key in self._keyboards:\n                del self._keyboards[key]\n        elif self._system_keyboard.callback:\n            # this way will prevent possible recursion.\n            callback = self._system_keyboard.callback\n            self._system_keyboard.callback = None\n            callback()\n            return True",
  "def grab_mouse(self):\n        '''Grab mouse - so won't leave window\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass",
  "def ungrab_mouse(self):\n        '''Ungrab mouse\n\n        .. versionadded:: 1.10.0\n\n        .. note::\n            This feature requires the SDL2 window provider.\n        '''\n        pass",
  "def __exit(section, name, value):\n            WindowBase.__dict__['on_keyboard'].exit_on_escape = \\\n                Config.getboolean('kivy', 'exit_on_escape')",
  "class LabelPango(LabelBase):\n\n    _font_family_support = True\n\n    def __init__(self, *largs, **kwargs):\n        self.get_extents = MethodType(kpango_get_extents, self)\n        self.get_ascent = MethodType(kpango_get_ascent, self)\n        self.get_descent = MethodType(kpango_get_descent, self)\n        super(LabelPango, self).__init__(*largs, **kwargs)\n\n    find_base_direction = staticmethod(kpango_find_base_dir)\n\n    def _render_begin(self):\n        self._rdr = KivyPangoRenderer(*self._size)\n\n    def _render_text(self, text, x, y):\n        self._rdr.render(self, text, x, y)\n\n    def _render_end(self):\n        imgdata = self._rdr.get_ImageData()\n        del self._rdr\n        return imgdata",
  "class PangoFontContextManager(FontContextManagerBase):\n    create = staticmethod(kpango_font_context_create)\n    exists = staticmethod(kpango_font_context_exists)\n    destroy = staticmethod(kpango_font_context_destroy)\n    list = staticmethod(kpango_font_context_list)\n    list_families = staticmethod(kpango_font_context_list_families)\n    list_custom = staticmethod(kpango_font_context_list_custom)\n\n    @staticmethod\n    def add_font(font_context, filename, autocreate=True, family=None):\n        if not autocreate and not PangoFontContextManager.exists(font_context):\n            raise Exception(\"FontContextManager: Attempt to add font file \"\n                            \"'{}' to non-existing context '{}' without \"\n                            \"autocreate.\".format(filename, font_context))\n        if not filename:\n            raise Exception(\"FontContextManager: Cannot add empty font file\")\n        if not isfile(filename):\n            filename = resource_find(filename)\n        if not isfile(filename):\n            if not filename.endswith('.ttf'):\n                filename = resource_find('{}.ttf'.format(filename))\n        if filename and isfile(filename):\n            return kpango_font_context_add_font(font_context, filename)\n        raise Exception(\"FontContextManager: Attempt to add non-existent \"\n                        \"font file: '{}' to context '{}'\"\n                        .format(filename, font_context))",
  "def __init__(self, *largs, **kwargs):\n        self.get_extents = MethodType(kpango_get_extents, self)\n        self.get_ascent = MethodType(kpango_get_ascent, self)\n        self.get_descent = MethodType(kpango_get_descent, self)\n        super(LabelPango, self).__init__(*largs, **kwargs)",
  "def _render_begin(self):\n        self._rdr = KivyPangoRenderer(*self._size)",
  "def _render_text(self, text, x, y):\n        self._rdr.render(self, text, x, y)",
  "def _render_end(self):\n        imgdata = self._rdr.get_ImageData()\n        del self._rdr\n        return imgdata",
  "def add_font(font_context, filename, autocreate=True, family=None):\n        if not autocreate and not PangoFontContextManager.exists(font_context):\n            raise Exception(\"FontContextManager: Attempt to add font file \"\n                            \"'{}' to non-existing context '{}' without \"\n                            \"autocreate.\".format(filename, font_context))\n        if not filename:\n            raise Exception(\"FontContextManager: Cannot add empty font file\")\n        if not isfile(filename):\n            filename = resource_find(filename)\n        if not isfile(filename):\n            if not filename.endswith('.ttf'):\n                filename = resource_find('{}.ttf'.format(filename))\n        if filename and isfile(filename):\n            return kpango_font_context_add_font(font_context, filename)\n        raise Exception(\"FontContextManager: Attempt to add non-existent \"\n                        \"font file: '{}' to context '{}'\"\n                        .format(filename, font_context))",
  "class LabelSDL2(LabelBase):\n\n    def _get_font_id(self):\n        return '|'.join([str(self.options[x]) for x\n            in ('font_size', 'font_name_r', 'bold',\n                'italic', 'underline', 'strikethrough')])\n\n    def get_extents(self, text):\n        try:\n            if PY2:\n                text = text.encode('UTF-8')\n        except:\n            pass\n        return _get_extents(self, text)\n\n    def get_descent(self):\n        return _get_fontdescent(self)\n\n    def get_ascent(self):\n        return _get_fontascent(self)\n\n    def _render_begin(self):\n        self._surface = _SurfaceContainer(self._size[0], self._size[1])\n\n    def _render_text(self, text, x, y):\n        self._surface.render(self, text, x, y)\n\n    def _render_end(self):\n        return self._surface.get_data()",
  "def _get_font_id(self):\n        return '|'.join([str(self.options[x]) for x\n            in ('font_size', 'font_name_r', 'bold',\n                'italic', 'underline', 'strikethrough')])",
  "def get_extents(self, text):\n        try:\n            if PY2:\n                text = text.encode('UTF-8')\n        except:\n            pass\n        return _get_extents(self, text)",
  "def get_descent(self):\n        return _get_fontdescent(self)",
  "def get_ascent(self):\n        return _get_fontascent(self)",
  "def _render_begin(self):\n        self._surface = _SurfaceContainer(self._size[0], self._size[1])",
  "def _render_text(self, text, x, y):\n        self._surface.render(self, text, x, y)",
  "def _render_end(self):\n        return self._surface.get_data()",
  "class LabelPygame(LabelBase):\n\n    @deprecated(\n        msg='Pygame has been deprecated and will be removed after 1.11.0')\n    def __init__(self, *largs, **kwargs):\n        super(LabelPygame, self).__init__(*largs, **kwargs)\n\n    def _get_font_id(self):\n        return '|'.join([str(self.options[x]) for x in\n                         ('font_size', 'font_name_r', 'bold', 'italic')])\n\n    def _get_font(self):\n        fontid = self._get_font_id()\n        if fontid not in pygame_cache:\n            # try first the file if it's a filename\n            font_handle = fontobject = None\n            fontname = self.options['font_name_r']\n            ext = fontname.rsplit('.', 1)\n            if len(ext) == 2:\n                # try to open the font if it has an extension\n                font_handle = open(fontname, 'rb')\n                fontobject = pygame.font.Font(font_handle,\n                                              int(self.options['font_size']))\n\n            # fallback to search a system font\n            if fontobject is None:\n                # try to search the font\n                font = pygame.font.match_font(\n                    self.options['font_name_r'].replace(' ', ''),\n                    bold=self.options['bold'],\n                    italic=self.options['italic'])\n\n                # fontobject\n                fontobject = pygame.font.Font(font,\n                                              int(self.options['font_size']))\n            pygame_cache[fontid] = fontobject\n            pygame_font_handles[fontid] = font_handle\n            pygame_cache_order.append(fontid)\n\n        # to prevent too much file open, limit the number of opened fonts to 64\n        while len(pygame_cache_order) > 64:\n            popid = pygame_cache_order.pop(0)\n            del pygame_cache[popid]\n            font_handle = pygame_font_handles.pop(popid)\n            if font_handle is not None:\n                font_handle.close()\n\n        return pygame_cache[fontid]\n\n    def get_ascent(self):\n        return self._get_font().get_ascent()\n\n    def get_descent(self):\n        return self._get_font().get_descent()\n\n    def get_extents(self, text):\n        return self._get_font().size(text)\n\n    def get_cached_extents(self):\n        return self._get_font().size\n\n    def _render_begin(self):\n        self._pygame_surface = pygame.Surface(self._size, pygame.SRCALPHA, 32)\n        self._pygame_surface.fill((0, 0, 0, 0))\n\n    def _render_text(self, text, x, y):\n        font = self._get_font()\n        color = [c * 255 for c in self.options['color']]\n        color[0], color[2] = color[2], color[0]\n        try:\n            text = font.render(text, True, color)\n            text.set_colorkey(color)\n            self._pygame_surface.blit(text, (x, y), None,\n                                      pygame.BLEND_RGBA_ADD)\n        except pygame.error:\n            pass\n\n    def _render_end(self):\n        w, h = self._size\n        data = ImageData(w, h,\n                         'rgba', self._pygame_surface.get_buffer().raw)\n\n        del self._pygame_surface\n\n        return data",
  "def __init__(self, *largs, **kwargs):\n        super(LabelPygame, self).__init__(*largs, **kwargs)",
  "def _get_font_id(self):\n        return '|'.join([str(self.options[x]) for x in\n                         ('font_size', 'font_name_r', 'bold', 'italic')])",
  "def _get_font(self):\n        fontid = self._get_font_id()\n        if fontid not in pygame_cache:\n            # try first the file if it's a filename\n            font_handle = fontobject = None\n            fontname = self.options['font_name_r']\n            ext = fontname.rsplit('.', 1)\n            if len(ext) == 2:\n                # try to open the font if it has an extension\n                font_handle = open(fontname, 'rb')\n                fontobject = pygame.font.Font(font_handle,\n                                              int(self.options['font_size']))\n\n            # fallback to search a system font\n            if fontobject is None:\n                # try to search the font\n                font = pygame.font.match_font(\n                    self.options['font_name_r'].replace(' ', ''),\n                    bold=self.options['bold'],\n                    italic=self.options['italic'])\n\n                # fontobject\n                fontobject = pygame.font.Font(font,\n                                              int(self.options['font_size']))\n            pygame_cache[fontid] = fontobject\n            pygame_font_handles[fontid] = font_handle\n            pygame_cache_order.append(fontid)\n\n        # to prevent too much file open, limit the number of opened fonts to 64\n        while len(pygame_cache_order) > 64:\n            popid = pygame_cache_order.pop(0)\n            del pygame_cache[popid]\n            font_handle = pygame_font_handles.pop(popid)\n            if font_handle is not None:\n                font_handle.close()\n\n        return pygame_cache[fontid]",
  "def get_ascent(self):\n        return self._get_font().get_ascent()",
  "def get_descent(self):\n        return self._get_font().get_descent()",
  "def get_extents(self, text):\n        return self._get_font().size(text)",
  "def get_cached_extents(self):\n        return self._get_font().size",
  "def _render_begin(self):\n        self._pygame_surface = pygame.Surface(self._size, pygame.SRCALPHA, 32)\n        self._pygame_surface.fill((0, 0, 0, 0))",
  "def _render_text(self, text, x, y):\n        font = self._get_font()\n        color = [c * 255 for c in self.options['color']]\n        color[0], color[2] = color[2], color[0]\n        try:\n            text = font.render(text, True, color)\n            text.set_colorkey(color)\n            self._pygame_surface.blit(text, (x, y), None,\n                                      pygame.BLEND_RGBA_ADD)\n        except pygame.error:\n            pass",
  "def _render_end(self):\n        w, h = self._size\n        data = ImageData(w, h,\n                         'rgba', self._pygame_surface.get_buffer().raw)\n\n        del self._pygame_surface\n\n        return data",
  "class MarkupLabel(MarkupLabelBase):\n    '''Markup text label.\n\n    See module documentation for more information.\n    '''\n\n    def __init__(self, *largs, **kwargs):\n        self._style_stack = {}\n        self._refs = {}\n        self._anchors = {}\n        super(MarkupLabel, self).__init__(*largs, **kwargs)\n        self._internal_size = 0, 0\n        self._cached_lines = []\n\n    @property\n    def refs(self):\n        '''Get the bounding box of all the ``[ref=...]``::\n\n            { 'refA': ((x1, y1, x2, y2), (x1, y1, x2, y2)), ... }\n        '''\n        return self._refs\n\n    @property\n    def anchors(self):\n        '''Get the position of all the ``[anchor=...]``::\n\n            { 'anchorA': (x, y), 'anchorB': (x, y), ... }\n        '''\n        return self._anchors\n\n    @property\n    def markup(self):\n        '''Return the text with all the markup split::\n\n            >>> MarkupLabel('[b]Hello world[/b]').markup\n            >>> ('[b]', 'Hello world', '[/b]')\n\n        '''\n        s = re.split(r'(\\[.*?\\])', self.label)\n        s = [x for x in s if x != '']\n        return s\n\n    def _push_style(self, k):\n        if k not in self._style_stack:\n            self._style_stack[k] = []\n        self._style_stack[k].append(self.options[k])\n\n    def _pop_style(self, k):\n        if k not in self._style_stack or len(self._style_stack[k]) == 0:\n            Logger.warning('Label: pop style stack without push')\n            return\n        v = self._style_stack[k].pop()\n        self.options[k] = v\n\n    def render(self, real=False):\n        options = copy(self.options)\n        if not real:\n            ret = self._pre_render()\n        else:\n            ret = self._render_real()\n        self.options = options\n        return ret\n\n    def _pre_render(self):\n        # split markup, words, and lines\n        # result: list of word with position and width/height\n        # during the first pass, we don't care about h/valign\n        self._cached_lines = lines = []\n        self._refs = {}\n        self._anchors = {}\n        clipped = False\n        w = h = 0\n        uw, uh = self.text_size\n        spush = self._push_style\n        spop = self._pop_style\n        options = self.options\n        options['_ref'] = None\n        options['_anchor'] = None\n        options['script'] = 'normal'\n        shorten = options['shorten']\n        # if shorten, then don't split lines to fit uw, because it will be\n        # flattened later when shortening and broken up lines if broken\n        # mid-word will have space mid-word when lines are joined\n        uw_temp = None if shorten else uw\n        xpad = options['padding'][0] + options['padding'][2]\n        uhh = (None if uh is not None and options['valign'] != 'top' or\n               options['shorten'] else uh)\n        options['strip'] = options['strip'] or options['halign'] == 'justify'\n        find_base_dir = Label.find_base_direction\n        base_dir = options['base_direction']\n        self._resolved_base_dir = None\n        for item in self.markup:\n            if item == '[b]':\n                spush('bold')\n                options['bold'] = True\n                self.resolve_font_name()\n            elif item == '[/b]':\n                spop('bold')\n                self.resolve_font_name()\n            elif item == '[i]':\n                spush('italic')\n                options['italic'] = True\n                self.resolve_font_name()\n            elif item == '[/i]':\n                spop('italic')\n                self.resolve_font_name()\n            elif item == '[u]':\n                spush('underline')\n                options['underline'] = True\n                self.resolve_font_name()\n            elif item == '[/u]':\n                spop('underline')\n                self.resolve_font_name()\n            elif item == '[s]':\n                spush('strikethrough')\n                options['strikethrough'] = True\n                self.resolve_font_name()\n            elif item == '[/s]':\n                spop('strikethrough')\n                self.resolve_font_name()\n            elif item[:6] == '[size=':\n                item = item[6:-1]\n                try:\n                    if item[-2:] in ('px', 'pt', 'in', 'cm', 'mm', 'dp', 'sp'):\n                        size = dpi2px(item[:-2], item[-2:])\n                    else:\n                        size = int(item)\n                except ValueError:\n                    raise\n                    size = options['font_size']\n                spush('font_size')\n                options['font_size'] = size\n            elif item == '[/size]':\n                spop('font_size')\n            elif item[:7] == '[color=':\n                color = parse_color(item[7:-1])\n                spush('color')\n                options['color'] = color\n            elif item == '[/color]':\n                spop('color')\n            elif item[:6] == '[font=':\n                fontname = item[6:-1]\n                spush('font_name')\n                options['font_name'] = fontname\n                self.resolve_font_name()\n            elif item == '[/font]':\n                spop('font_name')\n                self.resolve_font_name()\n            elif item[:13] == '[font_family=':\n                spush('font_family')\n                options['font_family'] = item[13:-1]\n            elif item == '[/font_family]':\n                spop('font_family')\n            elif item[:14] == '[font_context=':\n                fctx = item[14:-1]\n                if not fctx or fctx.lower() == 'none':\n                    fctx = None\n                spush('font_context')\n                options['font_context'] = fctx\n            elif item == '[/font_context]':\n                spop('font_context')\n            elif item[:15] == '[font_features=':\n                spush('font_features')\n                options['font_features'] = item[15:-1]\n            elif item == '[/font_features]':\n                spop('font_features')\n            elif item[:15] == '[text_language=':\n                lang = item[15:-1]\n                if not lang or lang.lower() == 'none':\n                    lang = None\n                spush('text_language')\n                options['text_language'] = lang\n            elif item == '[/text_language]':\n                spop('text_language')\n            elif item[:5] == '[sub]':\n                spush('font_size')\n                spush('script')\n                options['font_size'] = options['font_size'] * .5\n                options['script'] = 'subscript'\n            elif item == '[/sub]':\n                spop('font_size')\n                spop('script')\n            elif item[:5] == '[sup]':\n                spush('font_size')\n                spush('script')\n                options['font_size'] = options['font_size'] * .5\n                options['script'] = 'superscript'\n            elif item == '[/sup]':\n                spop('font_size')\n                spop('script')\n            elif item[:5] == '[ref=':\n                ref = item[5:-1]\n                spush('_ref')\n                options['_ref'] = ref\n            elif item == '[/ref]':\n                spop('_ref')\n            elif not clipped and item[:8] == '[anchor=':\n                options['_anchor'] = item[8:-1]\n            elif not clipped:\n                item = item.replace('&bl;', '[').replace(\n                    '&br;', ']').replace('&amp;', '&')\n                if not base_dir:\n                    base_dir = self._resolved_base_dir = find_base_dir(item)\n                opts = copy(options)\n                extents = self.get_cached_extents()\n                opts['space_width'] = extents(' ')[0]\n                w, h, clipped = layout_text(\n                    item, lines, (w, h), (uw_temp, uhh),\n                    opts, extents,\n                    append_down=True,\n                    complete=False\n                )\n\n        if len(lines):  # remove any trailing spaces from the last line\n            old_opts = self.options\n            self.options = copy(opts)\n            w, h, clipped = layout_text(\n                '', lines, (w, h), (uw_temp, uhh),\n                self.options, self.get_cached_extents(),\n                append_down=True,\n                complete=True\n            )\n            self.options = old_opts\n\n        self.is_shortened = False\n        if shorten:\n            options['_ref'] = None  # no refs for you!\n            options['_anchor'] = None\n            w, h, lines = self.shorten_post(lines, w, h)\n            self._cached_lines = lines\n        # when valign is not top, for markup we layout everything (text_size[1]\n        # is temporarily set to None) and after layout cut to size if too tall\n        elif uh != uhh and h > uh and len(lines) > 1:\n            if options['valign'] == 'bottom':\n                i = 0\n                while i < len(lines) - 1 and h > uh:\n                    h -= lines[i].h\n                    i += 1\n                del lines[:i]\n            else:  # middle\n                i = 0\n                top = int(h / 2. + uh / 2.)  # remove extra top portion\n                while i < len(lines) - 1 and h > top:\n                    h -= lines[i].h\n                    i += 1\n                del lines[:i]\n                i = len(lines) - 1  # remove remaining bottom portion\n                while i and h > uh:\n                    h -= lines[i].h\n                    i -= 1\n                del lines[i + 1:]\n\n        # now justify the text\n        if options['halign'] == 'justify' and uw is not None:\n            # XXX: update refs to justified pos\n            # when justify, each line should've been stripped already\n            split = partial(re.split, re.compile('( +)'))\n            uww = uw - xpad\n            chr = type(self.text)\n            space = chr(' ')\n            empty = chr('')\n\n            for i in range(len(lines)):\n                line = lines[i]\n                words = line.words\n                # if there's nothing to justify, we're done\n                if (not line.w or int(uww - line.w) <= 0 or not len(words) or\n                        line.is_last_line):\n                    continue\n\n                done = False\n                parts = [None, ] * len(words)  # contains words split by space\n                idxs = [None, ] * len(words)  # indices of the space in parts\n                # break each word into spaces and add spaces until it's full\n                # do first round of split in case we don't need to split all\n                for w in range(len(words)):\n                    word = words[w]\n                    sw = word.options['space_width']\n                    p = parts[w] = split(word.text)\n                    idxs[w] = [v for v in range(len(p)) if\n                               p[v].startswith(' ')]\n                    # now we have the indices of the spaces in split list\n                    for k in idxs[w]:\n                        # try to add single space at each space\n                        if line.w + sw > uww:\n                            done = True\n                            break\n                        line.w += sw\n                        word.lw += sw\n                        p[k] += space\n                    if done:\n                        break\n\n                # there's not a single space in the line?\n                if not any(idxs):\n                    continue\n\n                # now keep adding spaces to already split words until done\n                while not done:\n                    for w in range(len(words)):\n                        if not idxs[w]:\n                            continue\n                        word = words[w]\n                        sw = word.options['space_width']\n                        p = parts[w]\n                        for k in idxs[w]:\n                            # try to add single space at each space\n                            if line.w + sw > uww:\n                                done = True\n                                break\n                            line.w += sw\n                            word.lw += sw\n                            p[k] += space\n                        if done:\n                            break\n\n                # if not completely full, push last words to right edge\n                diff = int(uww - line.w)\n                if diff > 0:\n                    # find the last word that had a space\n                    for w in range(len(words) - 1, -1, -1):\n                        if not idxs[w]:\n                            continue\n                        break\n                    old_opts = self.options\n                    self.options = word.options\n                    word = words[w]\n                    # split that word into left/right and push right till uww\n                    l_text = empty.join(parts[w][:idxs[w][-1]])\n                    r_text = empty.join(parts[w][idxs[w][-1]:])\n                    left = LayoutWord(\n                        word.options,\n                        self.get_extents(l_text)[0],\n                        word.lh,\n                        l_text\n                    )\n                    right = LayoutWord(\n                        word.options,\n                        self.get_extents(r_text)[0],\n                        word.lh,\n                        r_text\n                    )\n                    left.lw = max(left.lw, word.lw + diff - right.lw)\n                    self.options = old_opts\n\n                    # now put words back together with right/left inserted\n                    for k in range(len(words)):\n                        if idxs[k]:\n                            words[k].text = empty.join(parts[k])\n                    words[w] = right\n                    words.insert(w, left)\n                else:\n                    for k in range(len(words)):\n                        if idxs[k]:\n                            words[k].text = empty.join(parts[k])\n                line.w = uww\n                w = max(w, uww)\n\n        self._internal_size = w, h\n        if uw:\n            w = uw\n        if uh:\n            h = uh\n        if h > 1 and w < 2:\n            w = 2\n        if w < 1:\n            w = 1\n        if h < 1:\n            h = 1\n        return int(w), int(h)\n\n    def render_lines(self, lines, options, render_text, y, size):\n        padding_left = options['padding'][0]\n        padding_right = options['padding'][2]\n        w = size[0]\n        halign = options['halign']\n        refs = self._refs\n        anchors = self._anchors\n        base_dir = options['base_direction'] or self._resolved_base_dir\n        auto_halign_r = halign == 'auto' and base_dir and 'rtl' in base_dir\n\n        for layout_line in lines:  # for plain label each line has only one str\n            lw, lh = layout_line.w, layout_line.h\n            x = padding_left\n            if halign == 'center':\n                x = min(\n                    int(w - lw),\n                    max(\n                        int(padding_left),\n                        int((w - lw + padding_left - padding_right) / 2.0)\n                    )\n                )\n            elif halign == 'right' or auto_halign_r:\n                x = max(0, int(w - lw - padding_right))\n            layout_line.x = x\n            layout_line.y = y\n            psp = pph = 0\n            for word in layout_line.words:\n                options = self.options = word.options\n                # the word height is not scaled by line_height, only lh was\n                wh = options['line_height'] * word.lh\n                # calculate sub/super script pos\n                if options['script'] == 'superscript':\n                    script_pos = max(0, psp if psp else self.get_descent())\n                    psp = script_pos\n                    pph = wh\n                elif options['script'] == 'subscript':\n                    script_pos = min(lh - wh, ((psp + pph) - wh)\n                                     if pph else (lh - wh))\n                    pph = wh\n                    psp = script_pos\n                else:\n                    script_pos = (lh - wh) / 1.25\n                    psp = pph = 0\n                if len(word.text):\n                    render_text(word.text, x, y + script_pos)\n\n                # should we record refs ?\n                ref = options['_ref']\n                if ref is not None:\n                    if ref not in refs:\n                        refs[ref] = []\n                    refs[ref].append((x, y, x + word.lw, y + wh))\n\n                # Should we record anchors?\n                anchor = options['_anchor']\n                if anchor is not None:\n                    if anchor not in anchors:\n                        anchors[anchor] = (x, y)\n                x += word.lw\n            y += lh\n        return y\n\n    def shorten_post(self, lines, w, h, margin=2):\n        ''' Shortens the text to a single line according to the label options.\n\n        This function operates on a text that has already been laid out because\n        for markup, parts of text can have different size and options.\n\n        If :attr:`text_size` [0] is None, the lines are returned unchanged.\n        Otherwise, the lines are converted to a single line fitting within the\n        constrained width, :attr:`text_size` [0].\n\n        :params:\n\n            `lines`: list of `LayoutLine` instances describing the text.\n            `w`: int, the width of the text in lines, including padding.\n            `h`: int, the height of the text in lines, including padding.\n            `margin` int, the additional space left on the sides. This is in\n            addition to :attr:`padding_x`.\n\n        :returns:\n            3-tuple of (xw, h, lines), where w, and h is similar to the input\n            and contains the resulting width / height of the text, including\n            padding. lines, is a list containing a single `LayoutLine`, which\n            contains the words for the line.\n        '''\n\n        def n(line, c):\n            ''' A function similar to text.find, except it's an iterator that\n            returns successive occurrences of string c in list line. line is\n            not a string, but a list of LayoutWord instances that we walk\n            from left to right returning the indices of c in the words as we\n            encounter them. Note that the options can be different among the\n            words.\n\n            :returns:\n                3-tuple: the index of the word in line, the index of the\n                occurrence in word, and the extents (width) of the combined\n                words until this occurrence, not including the occurrence char.\n                If no more are found it returns (-1, -1, total_w) where total_w\n                is the full width of all the words.\n            '''\n            total_w = 0\n            for w in range(len(line)):\n                word = line[w]\n                if not word.lw:\n                    continue\n                f = partial(word.text.find, c)\n                i = f()\n                while i != -1:\n                    self.options = word.options\n                    yield w, i, total_w + self.get_extents(word.text[:i])[0]\n                    i = f(i + 1)\n                self.options = word.options\n                total_w += self.get_extents(word.text)[0]\n            yield -1, -1, total_w  # this should never be reached, really\n\n        def p(line, c):\n            ''' Similar to the `n` function, except it returns occurrences of c\n            from right to left in the list, line, similar to rfind.\n            '''\n            total_w = 0\n            offset = 0 if len(c) else 1\n            for w in range(len(line) - 1, -1, -1):\n                word = line[w]\n                if not word.lw:\n                    continue\n                f = partial(word.text.rfind, c)\n                i = f()\n                while i != -1:\n                    self.options = word.options\n                    yield (w, i, total_w +\n                           self.get_extents(word.text[i + 1:])[0])\n                    if i:\n                        i = f(0, i - offset)\n                    else:\n                        if not c:\n                            self.options = word.options\n                            yield (w, -1, total_w +\n                                   self.get_extents(word.text)[0])\n                        break\n                self.options = word.options\n                total_w += self.get_extents(word.text)[0]\n            yield -1, -1, total_w  # this should never be reached, really\n\n        def n_restricted(line, uw, c):\n            ''' Similar to the function `n`, except it only returns the first\n            occurrence and it's not an iterator. Furthermore, if the first\n            occurrence doesn't fit within width uw, it returns the index of\n            whatever amount of text will still fit in uw.\n\n            :returns:\n                similar to the function `n`, except it's a 4-tuple, with the\n                last element a boolean, indicating if we had to clip the text\n                to fit in uw (True) or if the whole text until the first\n                occurrence fitted in uw (False).\n            '''\n            total_w = 0\n            if not len(line):\n                return 0, 0, 0\n            for w in range(len(line)):\n                word = line[w]\n                f = partial(word.text.find, c)\n                self.options = word.options\n                extents = self.get_cached_extents()\n                i = f()\n                if i != -1:\n                    ww = extents(word.text[:i])[0]\n\n                if i != -1 and total_w + ww <= uw:  # found and it fits\n                    return w, i, total_w + ww, False\n                elif i == -1:\n                    ww = extents(word.text)[0]\n                    if total_w + ww <= uw:  # wasn't found and all fits\n                        total_w += ww\n                        continue\n                    i = len(word.text)\n\n                # now just find whatever amount of the word does fit\n                e = 0\n                while e != i and total_w + extents(word.text[:e])[0] <= uw:\n                    e += 1\n                e = max(0, e - 1)\n                return w, e, total_w + extents(word.text[:e])[0], True\n\n            return -1, -1, total_w, False\n\n        def p_restricted(line, uw, c):\n            ''' Similar to `n_restricted`, except it returns the first\n            occurrence starting from the right, like `p`.\n            '''\n            total_w = 0\n            if not len(line):\n                return 0, 0, 0\n            for w in range(len(line) - 1, -1, -1):\n                word = line[w]\n                f = partial(word.text.rfind, c)\n                self.options = word.options\n                extents = self.get_cached_extents()\n                i = f()\n                if i != -1:\n                    ww = extents(word.text[i + 1:])[0]\n\n                if i != -1 and total_w + ww <= uw:  # found and it fits\n                    return w, i, total_w + ww, False\n                elif i == -1:\n                    ww = extents(word.text)[0]\n                    if total_w + ww <= uw:  # wasn't found and all fits\n                        total_w += ww\n                        continue\n\n                # now just find whatever amount of the word does fit\n                s = len(word.text) - 1\n                while s >= 0 and total_w + extents(word.text[s:])[0] <= uw:\n                    s -= 1\n                return w, s, total_w + extents(word.text[s + 1:])[0], True\n\n            return -1, -1, total_w, False\n\n        textwidth = self.get_cached_extents()\n        uw = self.text_size[0]\n        if uw is None:\n            return w, h, lines\n        old_opts = copy(self.options)\n        uw = max(\n            0,\n            int(uw - old_opts[\"padding\"][0] - old_opts[\"padding\"][2] - margin),\n        )\n        chr = type(self.text)\n        ssize = textwidth(' ')\n        c = old_opts['split_str']\n        line_height = old_opts['line_height']\n        xpad, ypad = (\n            old_opts[\"padding\"][0] + old_opts[\"padding\"][2],\n            old_opts[\"padding\"][1] + old_opts[\"padding\"][3],\n        )\n        dir = old_opts['shorten_from'][0]\n\n        # flatten lines into single line\n        line = []\n        last_w = 0\n        for l in range(len(lines)):\n            # concatenate (non-empty) inside lines with a space\n            this_line = lines[l]\n            if last_w and this_line.w and not this_line.line_wrap:\n                line.append(LayoutWord(old_opts, ssize[0], ssize[1], chr(' ')))\n            last_w = this_line.w or last_w\n            for word in this_line.words:\n                if word.lw:\n                    line.append(word)\n\n        # if that fits, just return the flattened line\n        lw = sum([word.lw for word in line])\n        if lw <= uw:\n            lh = max([word.lh for word in line] + [0]) * line_height\n            self.is_shortened = False\n            return (\n                lw + xpad,\n                lh + ypad,\n                [LayoutLine(0, 0, lw, lh, 1, 0, line)]\n            )\n\n        elps_opts = copy(old_opts)\n        if 'ellipsis_options' in old_opts:\n            elps_opts.update(old_opts['ellipsis_options'])\n\n        # Set new opts for ellipsis\n        self.options = elps_opts\n        # find the size of ellipsis that'll fit\n        elps_s = textwidth('...')\n        if elps_s[0] > uw:  # even ellipsis didn't fit...\n            self.is_shortened = True\n            s = textwidth('..')\n            if s[0] <= uw:\n                return (\n                    s[0] + xpad,\n                    s[1] * line_height + ypad,\n                    [LayoutLine(\n                        0, 0, s[0], s[1], 1, 0,\n                        [LayoutWord(old_opts, s[0], s[1], '..')])]\n                )\n\n            else:\n                s = textwidth('.')\n                return (\n                    s[0] + xpad,\n                    s[1] * line_height + ypad,\n                    [LayoutLine(\n                        0, 0, s[0], s[1], 1, 0,\n                        [LayoutWord(old_opts, s[0], s[1], '.')])]\n                )\n\n        elps = LayoutWord(elps_opts, elps_s[0], elps_s[1], '...')\n        uw -= elps_s[0]\n        # Restore old opts\n        self.options = old_opts\n\n        # now find the first left and right words that fit\n        w1, e1, l1, clipped1 = n_restricted(line, uw, c)\n        w2, s2, l2, clipped2 = p_restricted(line, uw, c)\n\n        if dir != 'l':  # center or right\n            line1 = None\n            if clipped1 or clipped2 or l1 + l2 > uw:\n                # if either was clipped or both don't fit, just take first\n                if len(c):\n                    self.options = old_opts\n                    old_opts['split_str'] = ''\n                    res = self.shorten_post(lines, w, h, margin)\n                    self.options['split_str'] = c\n                    self.is_shortened = True\n                    return res\n                line1 = line[:w1]\n                last_word = line[w1]\n                last_text = last_word.text[:e1]\n                self.options = last_word.options\n                s = self.get_extents(last_text)\n                line1.append(LayoutWord(last_word.options, s[0], s[1],\n                                        last_text))\n            elif (w1, e1) == (-1, -1):  # this shouldn't occur\n                line1 = line\n            if line1:\n                line1.append(elps)\n                lw = sum([word.lw for word in line1])\n                lh = max([word.lh for word in line1]) * line_height\n                self.options = old_opts\n                self.is_shortened = True\n                return (\n                    lw + xpad,\n                    lh + ypad,\n                    [LayoutLine(0, 0, lw, lh, 1, 0, line1)]\n                )\n\n            # now we know that both the first and last word fit, and that\n            # there's at least one instances of the split_str in the line\n            if (w1, e1) != (w2, s2):  # more than one split_str\n                if dir == 'r':\n                    f = n(line, c)  # iterator\n                    assert next(f)[:-1] == (w1, e1)  # first word should match\n                    ww1, ee1, l1 = next(f)\n                    while l2 + l1 <= uw:\n                        w1, e1 = ww1, ee1\n                        ww1, ee1, l1 = next(f)\n                        if (w1, e1) == (w2, s2):\n                            break\n                else:   # center\n                    f = n(line, c)  # iterator\n                    f_inv = p(line, c)  # iterator\n                    assert next(f)[:-1] == (w1, e1)\n                    assert next(f_inv)[:-1] == (w2, s2)\n                    while True:\n                        if l1 <= l2:\n                            ww1, ee1, l1 = next(f)  # hypothesize that next fit\n                            if l2 + l1 > uw:\n                                break\n                            w1, e1 = ww1, ee1\n                            if (w1, e1) == (w2, s2):\n                                break\n                        else:\n                            ww2, ss2, l2 = next(f_inv)\n                            if l2 + l1 > uw:\n                                break\n                            w2, s2 = ww2, ss2\n                            if (w1, e1) == (w2, s2):\n                                break\n        else:  # left\n            line1 = [elps]\n            if clipped1 or clipped2 or l1 + l2 > uw:\n                # if either was clipped or both don't fit, just take last\n                if len(c):\n                    self.options = old_opts\n                    old_opts['split_str'] = ''\n                    res = self.shorten_post(lines, w, h, margin)\n                    self.options['split_str'] = c\n                    self.is_shortened = True\n                    return res\n                first_word = line[w2]\n                first_text = first_word.text[s2 + 1:]\n                self.options = first_word.options\n                s = self.get_extents(first_text)\n                line1.append(LayoutWord(first_word.options, s[0], s[1],\n                                        first_text))\n                line1.extend(line[w2 + 1:])\n            elif (w1, e1) == (-1, -1):  # this shouldn't occur\n                line1 = line\n            if len(line1) != 1:\n                lw = sum([word.lw for word in line1])\n                lh = max([word.lh for word in line1]) * line_height\n                self.options = old_opts\n                self.is_shortened = True\n                return (\n                    lw + xpad,\n                    lh + ypad,\n                    [LayoutLine(0, 0, lw, lh, 1, 0, line1)]\n                )\n\n            # now we know that both the first and last word fit, and that\n            # there's at least one instances of the split_str in the line\n            if (w1, e1) != (w2, s2):  # more than one split_str\n                f_inv = p(line, c)  # iterator\n                assert next(f_inv)[:-1] == (w2, s2)  # last word should match\n                ww2, ss2, l2 = next(f_inv)\n                while l2 + l1 <= uw:\n                    w2, s2 = ww2, ss2\n                    ww2, ss2, l2 = next(f_inv)\n                    if (w1, e1) == (w2, s2):\n                        break\n\n        # now add back the left half\n        line1 = line[:w1]\n        last_word = line[w1]\n        last_text = last_word.text[:e1]\n        self.options = last_word.options\n        s = self.get_extents(last_text)\n        if len(last_text):\n            line1.append(LayoutWord(last_word.options, s[0], s[1], last_text))\n        line1.append(elps)\n\n        # now add back the right half\n        first_word = line[w2]\n        first_text = first_word.text[s2 + 1:]\n        self.options = first_word.options\n        s = self.get_extents(first_text)\n        if len(first_text):\n            line1.append(LayoutWord(first_word.options, s[0], s[1],\n                                    first_text))\n        line1.extend(line[w2 + 1:])\n\n        lw = sum([word.lw for word in line1])\n        lh = max([word.lh for word in line1]) * line_height\n        self.options = old_opts\n        if uw < lw:\n            self.is_shortened = True\n        return (\n            lw + xpad,\n            lh + ypad,\n            [LayoutLine(0, 0, lw, lh, 1, 0, line1)]\n        )",
  "def __init__(self, *largs, **kwargs):\n        self._style_stack = {}\n        self._refs = {}\n        self._anchors = {}\n        super(MarkupLabel, self).__init__(*largs, **kwargs)\n        self._internal_size = 0, 0\n        self._cached_lines = []",
  "def refs(self):\n        '''Get the bounding box of all the ``[ref=...]``::\n\n            { 'refA': ((x1, y1, x2, y2), (x1, y1, x2, y2)), ... }\n        '''\n        return self._refs",
  "def anchors(self):\n        '''Get the position of all the ``[anchor=...]``::\n\n            { 'anchorA': (x, y), 'anchorB': (x, y), ... }\n        '''\n        return self._anchors",
  "def markup(self):\n        '''Return the text with all the markup split::\n\n            >>> MarkupLabel('[b]Hello world[/b]').markup\n            >>> ('[b]', 'Hello world', '[/b]')\n\n        '''\n        s = re.split(r'(\\[.*?\\])', self.label)\n        s = [x for x in s if x != '']\n        return s",
  "def _push_style(self, k):\n        if k not in self._style_stack:\n            self._style_stack[k] = []\n        self._style_stack[k].append(self.options[k])",
  "def _pop_style(self, k):\n        if k not in self._style_stack or len(self._style_stack[k]) == 0:\n            Logger.warning('Label: pop style stack without push')\n            return\n        v = self._style_stack[k].pop()\n        self.options[k] = v",
  "def render(self, real=False):\n        options = copy(self.options)\n        if not real:\n            ret = self._pre_render()\n        else:\n            ret = self._render_real()\n        self.options = options\n        return ret",
  "def _pre_render(self):\n        # split markup, words, and lines\n        # result: list of word with position and width/height\n        # during the first pass, we don't care about h/valign\n        self._cached_lines = lines = []\n        self._refs = {}\n        self._anchors = {}\n        clipped = False\n        w = h = 0\n        uw, uh = self.text_size\n        spush = self._push_style\n        spop = self._pop_style\n        options = self.options\n        options['_ref'] = None\n        options['_anchor'] = None\n        options['script'] = 'normal'\n        shorten = options['shorten']\n        # if shorten, then don't split lines to fit uw, because it will be\n        # flattened later when shortening and broken up lines if broken\n        # mid-word will have space mid-word when lines are joined\n        uw_temp = None if shorten else uw\n        xpad = options['padding'][0] + options['padding'][2]\n        uhh = (None if uh is not None and options['valign'] != 'top' or\n               options['shorten'] else uh)\n        options['strip'] = options['strip'] or options['halign'] == 'justify'\n        find_base_dir = Label.find_base_direction\n        base_dir = options['base_direction']\n        self._resolved_base_dir = None\n        for item in self.markup:\n            if item == '[b]':\n                spush('bold')\n                options['bold'] = True\n                self.resolve_font_name()\n            elif item == '[/b]':\n                spop('bold')\n                self.resolve_font_name()\n            elif item == '[i]':\n                spush('italic')\n                options['italic'] = True\n                self.resolve_font_name()\n            elif item == '[/i]':\n                spop('italic')\n                self.resolve_font_name()\n            elif item == '[u]':\n                spush('underline')\n                options['underline'] = True\n                self.resolve_font_name()\n            elif item == '[/u]':\n                spop('underline')\n                self.resolve_font_name()\n            elif item == '[s]':\n                spush('strikethrough')\n                options['strikethrough'] = True\n                self.resolve_font_name()\n            elif item == '[/s]':\n                spop('strikethrough')\n                self.resolve_font_name()\n            elif item[:6] == '[size=':\n                item = item[6:-1]\n                try:\n                    if item[-2:] in ('px', 'pt', 'in', 'cm', 'mm', 'dp', 'sp'):\n                        size = dpi2px(item[:-2], item[-2:])\n                    else:\n                        size = int(item)\n                except ValueError:\n                    raise\n                    size = options['font_size']\n                spush('font_size')\n                options['font_size'] = size\n            elif item == '[/size]':\n                spop('font_size')\n            elif item[:7] == '[color=':\n                color = parse_color(item[7:-1])\n                spush('color')\n                options['color'] = color\n            elif item == '[/color]':\n                spop('color')\n            elif item[:6] == '[font=':\n                fontname = item[6:-1]\n                spush('font_name')\n                options['font_name'] = fontname\n                self.resolve_font_name()\n            elif item == '[/font]':\n                spop('font_name')\n                self.resolve_font_name()\n            elif item[:13] == '[font_family=':\n                spush('font_family')\n                options['font_family'] = item[13:-1]\n            elif item == '[/font_family]':\n                spop('font_family')\n            elif item[:14] == '[font_context=':\n                fctx = item[14:-1]\n                if not fctx or fctx.lower() == 'none':\n                    fctx = None\n                spush('font_context')\n                options['font_context'] = fctx\n            elif item == '[/font_context]':\n                spop('font_context')\n            elif item[:15] == '[font_features=':\n                spush('font_features')\n                options['font_features'] = item[15:-1]\n            elif item == '[/font_features]':\n                spop('font_features')\n            elif item[:15] == '[text_language=':\n                lang = item[15:-1]\n                if not lang or lang.lower() == 'none':\n                    lang = None\n                spush('text_language')\n                options['text_language'] = lang\n            elif item == '[/text_language]':\n                spop('text_language')\n            elif item[:5] == '[sub]':\n                spush('font_size')\n                spush('script')\n                options['font_size'] = options['font_size'] * .5\n                options['script'] = 'subscript'\n            elif item == '[/sub]':\n                spop('font_size')\n                spop('script')\n            elif item[:5] == '[sup]':\n                spush('font_size')\n                spush('script')\n                options['font_size'] = options['font_size'] * .5\n                options['script'] = 'superscript'\n            elif item == '[/sup]':\n                spop('font_size')\n                spop('script')\n            elif item[:5] == '[ref=':\n                ref = item[5:-1]\n                spush('_ref')\n                options['_ref'] = ref\n            elif item == '[/ref]':\n                spop('_ref')\n            elif not clipped and item[:8] == '[anchor=':\n                options['_anchor'] = item[8:-1]\n            elif not clipped:\n                item = item.replace('&bl;', '[').replace(\n                    '&br;', ']').replace('&amp;', '&')\n                if not base_dir:\n                    base_dir = self._resolved_base_dir = find_base_dir(item)\n                opts = copy(options)\n                extents = self.get_cached_extents()\n                opts['space_width'] = extents(' ')[0]\n                w, h, clipped = layout_text(\n                    item, lines, (w, h), (uw_temp, uhh),\n                    opts, extents,\n                    append_down=True,\n                    complete=False\n                )\n\n        if len(lines):  # remove any trailing spaces from the last line\n            old_opts = self.options\n            self.options = copy(opts)\n            w, h, clipped = layout_text(\n                '', lines, (w, h), (uw_temp, uhh),\n                self.options, self.get_cached_extents(),\n                append_down=True,\n                complete=True\n            )\n            self.options = old_opts\n\n        self.is_shortened = False\n        if shorten:\n            options['_ref'] = None  # no refs for you!\n            options['_anchor'] = None\n            w, h, lines = self.shorten_post(lines, w, h)\n            self._cached_lines = lines\n        # when valign is not top, for markup we layout everything (text_size[1]\n        # is temporarily set to None) and after layout cut to size if too tall\n        elif uh != uhh and h > uh and len(lines) > 1:\n            if options['valign'] == 'bottom':\n                i = 0\n                while i < len(lines) - 1 and h > uh:\n                    h -= lines[i].h\n                    i += 1\n                del lines[:i]\n            else:  # middle\n                i = 0\n                top = int(h / 2. + uh / 2.)  # remove extra top portion\n                while i < len(lines) - 1 and h > top:\n                    h -= lines[i].h\n                    i += 1\n                del lines[:i]\n                i = len(lines) - 1  # remove remaining bottom portion\n                while i and h > uh:\n                    h -= lines[i].h\n                    i -= 1\n                del lines[i + 1:]\n\n        # now justify the text\n        if options['halign'] == 'justify' and uw is not None:\n            # XXX: update refs to justified pos\n            # when justify, each line should've been stripped already\n            split = partial(re.split, re.compile('( +)'))\n            uww = uw - xpad\n            chr = type(self.text)\n            space = chr(' ')\n            empty = chr('')\n\n            for i in range(len(lines)):\n                line = lines[i]\n                words = line.words\n                # if there's nothing to justify, we're done\n                if (not line.w or int(uww - line.w) <= 0 or not len(words) or\n                        line.is_last_line):\n                    continue\n\n                done = False\n                parts = [None, ] * len(words)  # contains words split by space\n                idxs = [None, ] * len(words)  # indices of the space in parts\n                # break each word into spaces and add spaces until it's full\n                # do first round of split in case we don't need to split all\n                for w in range(len(words)):\n                    word = words[w]\n                    sw = word.options['space_width']\n                    p = parts[w] = split(word.text)\n                    idxs[w] = [v for v in range(len(p)) if\n                               p[v].startswith(' ')]\n                    # now we have the indices of the spaces in split list\n                    for k in idxs[w]:\n                        # try to add single space at each space\n                        if line.w + sw > uww:\n                            done = True\n                            break\n                        line.w += sw\n                        word.lw += sw\n                        p[k] += space\n                    if done:\n                        break\n\n                # there's not a single space in the line?\n                if not any(idxs):\n                    continue\n\n                # now keep adding spaces to already split words until done\n                while not done:\n                    for w in range(len(words)):\n                        if not idxs[w]:\n                            continue\n                        word = words[w]\n                        sw = word.options['space_width']\n                        p = parts[w]\n                        for k in idxs[w]:\n                            # try to add single space at each space\n                            if line.w + sw > uww:\n                                done = True\n                                break\n                            line.w += sw\n                            word.lw += sw\n                            p[k] += space\n                        if done:\n                            break\n\n                # if not completely full, push last words to right edge\n                diff = int(uww - line.w)\n                if diff > 0:\n                    # find the last word that had a space\n                    for w in range(len(words) - 1, -1, -1):\n                        if not idxs[w]:\n                            continue\n                        break\n                    old_opts = self.options\n                    self.options = word.options\n                    word = words[w]\n                    # split that word into left/right and push right till uww\n                    l_text = empty.join(parts[w][:idxs[w][-1]])\n                    r_text = empty.join(parts[w][idxs[w][-1]:])\n                    left = LayoutWord(\n                        word.options,\n                        self.get_extents(l_text)[0],\n                        word.lh,\n                        l_text\n                    )\n                    right = LayoutWord(\n                        word.options,\n                        self.get_extents(r_text)[0],\n                        word.lh,\n                        r_text\n                    )\n                    left.lw = max(left.lw, word.lw + diff - right.lw)\n                    self.options = old_opts\n\n                    # now put words back together with right/left inserted\n                    for k in range(len(words)):\n                        if idxs[k]:\n                            words[k].text = empty.join(parts[k])\n                    words[w] = right\n                    words.insert(w, left)\n                else:\n                    for k in range(len(words)):\n                        if idxs[k]:\n                            words[k].text = empty.join(parts[k])\n                line.w = uww\n                w = max(w, uww)\n\n        self._internal_size = w, h\n        if uw:\n            w = uw\n        if uh:\n            h = uh\n        if h > 1 and w < 2:\n            w = 2\n        if w < 1:\n            w = 1\n        if h < 1:\n            h = 1\n        return int(w), int(h)",
  "def render_lines(self, lines, options, render_text, y, size):\n        padding_left = options['padding'][0]\n        padding_right = options['padding'][2]\n        w = size[0]\n        halign = options['halign']\n        refs = self._refs\n        anchors = self._anchors\n        base_dir = options['base_direction'] or self._resolved_base_dir\n        auto_halign_r = halign == 'auto' and base_dir and 'rtl' in base_dir\n\n        for layout_line in lines:  # for plain label each line has only one str\n            lw, lh = layout_line.w, layout_line.h\n            x = padding_left\n            if halign == 'center':\n                x = min(\n                    int(w - lw),\n                    max(\n                        int(padding_left),\n                        int((w - lw + padding_left - padding_right) / 2.0)\n                    )\n                )\n            elif halign == 'right' or auto_halign_r:\n                x = max(0, int(w - lw - padding_right))\n            layout_line.x = x\n            layout_line.y = y\n            psp = pph = 0\n            for word in layout_line.words:\n                options = self.options = word.options\n                # the word height is not scaled by line_height, only lh was\n                wh = options['line_height'] * word.lh\n                # calculate sub/super script pos\n                if options['script'] == 'superscript':\n                    script_pos = max(0, psp if psp else self.get_descent())\n                    psp = script_pos\n                    pph = wh\n                elif options['script'] == 'subscript':\n                    script_pos = min(lh - wh, ((psp + pph) - wh)\n                                     if pph else (lh - wh))\n                    pph = wh\n                    psp = script_pos\n                else:\n                    script_pos = (lh - wh) / 1.25\n                    psp = pph = 0\n                if len(word.text):\n                    render_text(word.text, x, y + script_pos)\n\n                # should we record refs ?\n                ref = options['_ref']\n                if ref is not None:\n                    if ref not in refs:\n                        refs[ref] = []\n                    refs[ref].append((x, y, x + word.lw, y + wh))\n\n                # Should we record anchors?\n                anchor = options['_anchor']\n                if anchor is not None:\n                    if anchor not in anchors:\n                        anchors[anchor] = (x, y)\n                x += word.lw\n            y += lh\n        return y",
  "def shorten_post(self, lines, w, h, margin=2):\n        ''' Shortens the text to a single line according to the label options.\n\n        This function operates on a text that has already been laid out because\n        for markup, parts of text can have different size and options.\n\n        If :attr:`text_size` [0] is None, the lines are returned unchanged.\n        Otherwise, the lines are converted to a single line fitting within the\n        constrained width, :attr:`text_size` [0].\n\n        :params:\n\n            `lines`: list of `LayoutLine` instances describing the text.\n            `w`: int, the width of the text in lines, including padding.\n            `h`: int, the height of the text in lines, including padding.\n            `margin` int, the additional space left on the sides. This is in\n            addition to :attr:`padding_x`.\n\n        :returns:\n            3-tuple of (xw, h, lines), where w, and h is similar to the input\n            and contains the resulting width / height of the text, including\n            padding. lines, is a list containing a single `LayoutLine`, which\n            contains the words for the line.\n        '''\n\n        def n(line, c):\n            ''' A function similar to text.find, except it's an iterator that\n            returns successive occurrences of string c in list line. line is\n            not a string, but a list of LayoutWord instances that we walk\n            from left to right returning the indices of c in the words as we\n            encounter them. Note that the options can be different among the\n            words.\n\n            :returns:\n                3-tuple: the index of the word in line, the index of the\n                occurrence in word, and the extents (width) of the combined\n                words until this occurrence, not including the occurrence char.\n                If no more are found it returns (-1, -1, total_w) where total_w\n                is the full width of all the words.\n            '''\n            total_w = 0\n            for w in range(len(line)):\n                word = line[w]\n                if not word.lw:\n                    continue\n                f = partial(word.text.find, c)\n                i = f()\n                while i != -1:\n                    self.options = word.options\n                    yield w, i, total_w + self.get_extents(word.text[:i])[0]\n                    i = f(i + 1)\n                self.options = word.options\n                total_w += self.get_extents(word.text)[0]\n            yield -1, -1, total_w  # this should never be reached, really\n\n        def p(line, c):\n            ''' Similar to the `n` function, except it returns occurrences of c\n            from right to left in the list, line, similar to rfind.\n            '''\n            total_w = 0\n            offset = 0 if len(c) else 1\n            for w in range(len(line) - 1, -1, -1):\n                word = line[w]\n                if not word.lw:\n                    continue\n                f = partial(word.text.rfind, c)\n                i = f()\n                while i != -1:\n                    self.options = word.options\n                    yield (w, i, total_w +\n                           self.get_extents(word.text[i + 1:])[0])\n                    if i:\n                        i = f(0, i - offset)\n                    else:\n                        if not c:\n                            self.options = word.options\n                            yield (w, -1, total_w +\n                                   self.get_extents(word.text)[0])\n                        break\n                self.options = word.options\n                total_w += self.get_extents(word.text)[0]\n            yield -1, -1, total_w  # this should never be reached, really\n\n        def n_restricted(line, uw, c):\n            ''' Similar to the function `n`, except it only returns the first\n            occurrence and it's not an iterator. Furthermore, if the first\n            occurrence doesn't fit within width uw, it returns the index of\n            whatever amount of text will still fit in uw.\n\n            :returns:\n                similar to the function `n`, except it's a 4-tuple, with the\n                last element a boolean, indicating if we had to clip the text\n                to fit in uw (True) or if the whole text until the first\n                occurrence fitted in uw (False).\n            '''\n            total_w = 0\n            if not len(line):\n                return 0, 0, 0\n            for w in range(len(line)):\n                word = line[w]\n                f = partial(word.text.find, c)\n                self.options = word.options\n                extents = self.get_cached_extents()\n                i = f()\n                if i != -1:\n                    ww = extents(word.text[:i])[0]\n\n                if i != -1 and total_w + ww <= uw:  # found and it fits\n                    return w, i, total_w + ww, False\n                elif i == -1:\n                    ww = extents(word.text)[0]\n                    if total_w + ww <= uw:  # wasn't found and all fits\n                        total_w += ww\n                        continue\n                    i = len(word.text)\n\n                # now just find whatever amount of the word does fit\n                e = 0\n                while e != i and total_w + extents(word.text[:e])[0] <= uw:\n                    e += 1\n                e = max(0, e - 1)\n                return w, e, total_w + extents(word.text[:e])[0], True\n\n            return -1, -1, total_w, False\n\n        def p_restricted(line, uw, c):\n            ''' Similar to `n_restricted`, except it returns the first\n            occurrence starting from the right, like `p`.\n            '''\n            total_w = 0\n            if not len(line):\n                return 0, 0, 0\n            for w in range(len(line) - 1, -1, -1):\n                word = line[w]\n                f = partial(word.text.rfind, c)\n                self.options = word.options\n                extents = self.get_cached_extents()\n                i = f()\n                if i != -1:\n                    ww = extents(word.text[i + 1:])[0]\n\n                if i != -1 and total_w + ww <= uw:  # found and it fits\n                    return w, i, total_w + ww, False\n                elif i == -1:\n                    ww = extents(word.text)[0]\n                    if total_w + ww <= uw:  # wasn't found and all fits\n                        total_w += ww\n                        continue\n\n                # now just find whatever amount of the word does fit\n                s = len(word.text) - 1\n                while s >= 0 and total_w + extents(word.text[s:])[0] <= uw:\n                    s -= 1\n                return w, s, total_w + extents(word.text[s + 1:])[0], True\n\n            return -1, -1, total_w, False\n\n        textwidth = self.get_cached_extents()\n        uw = self.text_size[0]\n        if uw is None:\n            return w, h, lines\n        old_opts = copy(self.options)\n        uw = max(\n            0,\n            int(uw - old_opts[\"padding\"][0] - old_opts[\"padding\"][2] - margin),\n        )\n        chr = type(self.text)\n        ssize = textwidth(' ')\n        c = old_opts['split_str']\n        line_height = old_opts['line_height']\n        xpad, ypad = (\n            old_opts[\"padding\"][0] + old_opts[\"padding\"][2],\n            old_opts[\"padding\"][1] + old_opts[\"padding\"][3],\n        )\n        dir = old_opts['shorten_from'][0]\n\n        # flatten lines into single line\n        line = []\n        last_w = 0\n        for l in range(len(lines)):\n            # concatenate (non-empty) inside lines with a space\n            this_line = lines[l]\n            if last_w and this_line.w and not this_line.line_wrap:\n                line.append(LayoutWord(old_opts, ssize[0], ssize[1], chr(' ')))\n            last_w = this_line.w or last_w\n            for word in this_line.words:\n                if word.lw:\n                    line.append(word)\n\n        # if that fits, just return the flattened line\n        lw = sum([word.lw for word in line])\n        if lw <= uw:\n            lh = max([word.lh for word in line] + [0]) * line_height\n            self.is_shortened = False\n            return (\n                lw + xpad,\n                lh + ypad,\n                [LayoutLine(0, 0, lw, lh, 1, 0, line)]\n            )\n\n        elps_opts = copy(old_opts)\n        if 'ellipsis_options' in old_opts:\n            elps_opts.update(old_opts['ellipsis_options'])\n\n        # Set new opts for ellipsis\n        self.options = elps_opts\n        # find the size of ellipsis that'll fit\n        elps_s = textwidth('...')\n        if elps_s[0] > uw:  # even ellipsis didn't fit...\n            self.is_shortened = True\n            s = textwidth('..')\n            if s[0] <= uw:\n                return (\n                    s[0] + xpad,\n                    s[1] * line_height + ypad,\n                    [LayoutLine(\n                        0, 0, s[0], s[1], 1, 0,\n                        [LayoutWord(old_opts, s[0], s[1], '..')])]\n                )\n\n            else:\n                s = textwidth('.')\n                return (\n                    s[0] + xpad,\n                    s[1] * line_height + ypad,\n                    [LayoutLine(\n                        0, 0, s[0], s[1], 1, 0,\n                        [LayoutWord(old_opts, s[0], s[1], '.')])]\n                )\n\n        elps = LayoutWord(elps_opts, elps_s[0], elps_s[1], '...')\n        uw -= elps_s[0]\n        # Restore old opts\n        self.options = old_opts\n\n        # now find the first left and right words that fit\n        w1, e1, l1, clipped1 = n_restricted(line, uw, c)\n        w2, s2, l2, clipped2 = p_restricted(line, uw, c)\n\n        if dir != 'l':  # center or right\n            line1 = None\n            if clipped1 or clipped2 or l1 + l2 > uw:\n                # if either was clipped or both don't fit, just take first\n                if len(c):\n                    self.options = old_opts\n                    old_opts['split_str'] = ''\n                    res = self.shorten_post(lines, w, h, margin)\n                    self.options['split_str'] = c\n                    self.is_shortened = True\n                    return res\n                line1 = line[:w1]\n                last_word = line[w1]\n                last_text = last_word.text[:e1]\n                self.options = last_word.options\n                s = self.get_extents(last_text)\n                line1.append(LayoutWord(last_word.options, s[0], s[1],\n                                        last_text))\n            elif (w1, e1) == (-1, -1):  # this shouldn't occur\n                line1 = line\n            if line1:\n                line1.append(elps)\n                lw = sum([word.lw for word in line1])\n                lh = max([word.lh for word in line1]) * line_height\n                self.options = old_opts\n                self.is_shortened = True\n                return (\n                    lw + xpad,\n                    lh + ypad,\n                    [LayoutLine(0, 0, lw, lh, 1, 0, line1)]\n                )\n\n            # now we know that both the first and last word fit, and that\n            # there's at least one instances of the split_str in the line\n            if (w1, e1) != (w2, s2):  # more than one split_str\n                if dir == 'r':\n                    f = n(line, c)  # iterator\n                    assert next(f)[:-1] == (w1, e1)  # first word should match\n                    ww1, ee1, l1 = next(f)\n                    while l2 + l1 <= uw:\n                        w1, e1 = ww1, ee1\n                        ww1, ee1, l1 = next(f)\n                        if (w1, e1) == (w2, s2):\n                            break\n                else:   # center\n                    f = n(line, c)  # iterator\n                    f_inv = p(line, c)  # iterator\n                    assert next(f)[:-1] == (w1, e1)\n                    assert next(f_inv)[:-1] == (w2, s2)\n                    while True:\n                        if l1 <= l2:\n                            ww1, ee1, l1 = next(f)  # hypothesize that next fit\n                            if l2 + l1 > uw:\n                                break\n                            w1, e1 = ww1, ee1\n                            if (w1, e1) == (w2, s2):\n                                break\n                        else:\n                            ww2, ss2, l2 = next(f_inv)\n                            if l2 + l1 > uw:\n                                break\n                            w2, s2 = ww2, ss2\n                            if (w1, e1) == (w2, s2):\n                                break\n        else:  # left\n            line1 = [elps]\n            if clipped1 or clipped2 or l1 + l2 > uw:\n                # if either was clipped or both don't fit, just take last\n                if len(c):\n                    self.options = old_opts\n                    old_opts['split_str'] = ''\n                    res = self.shorten_post(lines, w, h, margin)\n                    self.options['split_str'] = c\n                    self.is_shortened = True\n                    return res\n                first_word = line[w2]\n                first_text = first_word.text[s2 + 1:]\n                self.options = first_word.options\n                s = self.get_extents(first_text)\n                line1.append(LayoutWord(first_word.options, s[0], s[1],\n                                        first_text))\n                line1.extend(line[w2 + 1:])\n            elif (w1, e1) == (-1, -1):  # this shouldn't occur\n                line1 = line\n            if len(line1) != 1:\n                lw = sum([word.lw for word in line1])\n                lh = max([word.lh for word in line1]) * line_height\n                self.options = old_opts\n                self.is_shortened = True\n                return (\n                    lw + xpad,\n                    lh + ypad,\n                    [LayoutLine(0, 0, lw, lh, 1, 0, line1)]\n                )\n\n            # now we know that both the first and last word fit, and that\n            # there's at least one instances of the split_str in the line\n            if (w1, e1) != (w2, s2):  # more than one split_str\n                f_inv = p(line, c)  # iterator\n                assert next(f_inv)[:-1] == (w2, s2)  # last word should match\n                ww2, ss2, l2 = next(f_inv)\n                while l2 + l1 <= uw:\n                    w2, s2 = ww2, ss2\n                    ww2, ss2, l2 = next(f_inv)\n                    if (w1, e1) == (w2, s2):\n                        break\n\n        # now add back the left half\n        line1 = line[:w1]\n        last_word = line[w1]\n        last_text = last_word.text[:e1]\n        self.options = last_word.options\n        s = self.get_extents(last_text)\n        if len(last_text):\n            line1.append(LayoutWord(last_word.options, s[0], s[1], last_text))\n        line1.append(elps)\n\n        # now add back the right half\n        first_word = line[w2]\n        first_text = first_word.text[s2 + 1:]\n        self.options = first_word.options\n        s = self.get_extents(first_text)\n        if len(first_text):\n            line1.append(LayoutWord(first_word.options, s[0], s[1],\n                                    first_text))\n        line1.extend(line[w2 + 1:])\n\n        lw = sum([word.lw for word in line1])\n        lh = max([word.lh for word in line1]) * line_height\n        self.options = old_opts\n        if uw < lw:\n            self.is_shortened = True\n        return (\n            lw + xpad,\n            lh + ypad,\n            [LayoutLine(0, 0, lw, lh, 1, 0, line1)]\n        )",
  "def n(line, c):\n            ''' A function similar to text.find, except it's an iterator that\n            returns successive occurrences of string c in list line. line is\n            not a string, but a list of LayoutWord instances that we walk\n            from left to right returning the indices of c in the words as we\n            encounter them. Note that the options can be different among the\n            words.\n\n            :returns:\n                3-tuple: the index of the word in line, the index of the\n                occurrence in word, and the extents (width) of the combined\n                words until this occurrence, not including the occurrence char.\n                If no more are found it returns (-1, -1, total_w) where total_w\n                is the full width of all the words.\n            '''\n            total_w = 0\n            for w in range(len(line)):\n                word = line[w]\n                if not word.lw:\n                    continue\n                f = partial(word.text.find, c)\n                i = f()\n                while i != -1:\n                    self.options = word.options\n                    yield w, i, total_w + self.get_extents(word.text[:i])[0]\n                    i = f(i + 1)\n                self.options = word.options\n                total_w += self.get_extents(word.text)[0]\n            yield -1, -1, total_w",
  "def p(line, c):\n            ''' Similar to the `n` function, except it returns occurrences of c\n            from right to left in the list, line, similar to rfind.\n            '''\n            total_w = 0\n            offset = 0 if len(c) else 1\n            for w in range(len(line) - 1, -1, -1):\n                word = line[w]\n                if not word.lw:\n                    continue\n                f = partial(word.text.rfind, c)\n                i = f()\n                while i != -1:\n                    self.options = word.options\n                    yield (w, i, total_w +\n                           self.get_extents(word.text[i + 1:])[0])\n                    if i:\n                        i = f(0, i - offset)\n                    else:\n                        if not c:\n                            self.options = word.options\n                            yield (w, -1, total_w +\n                                   self.get_extents(word.text)[0])\n                        break\n                self.options = word.options\n                total_w += self.get_extents(word.text)[0]\n            yield -1, -1, total_w",
  "def n_restricted(line, uw, c):\n            ''' Similar to the function `n`, except it only returns the first\n            occurrence and it's not an iterator. Furthermore, if the first\n            occurrence doesn't fit within width uw, it returns the index of\n            whatever amount of text will still fit in uw.\n\n            :returns:\n                similar to the function `n`, except it's a 4-tuple, with the\n                last element a boolean, indicating if we had to clip the text\n                to fit in uw (True) or if the whole text until the first\n                occurrence fitted in uw (False).\n            '''\n            total_w = 0\n            if not len(line):\n                return 0, 0, 0\n            for w in range(len(line)):\n                word = line[w]\n                f = partial(word.text.find, c)\n                self.options = word.options\n                extents = self.get_cached_extents()\n                i = f()\n                if i != -1:\n                    ww = extents(word.text[:i])[0]\n\n                if i != -1 and total_w + ww <= uw:  # found and it fits\n                    return w, i, total_w + ww, False\n                elif i == -1:\n                    ww = extents(word.text)[0]\n                    if total_w + ww <= uw:  # wasn't found and all fits\n                        total_w += ww\n                        continue\n                    i = len(word.text)\n\n                # now just find whatever amount of the word does fit\n                e = 0\n                while e != i and total_w + extents(word.text[:e])[0] <= uw:\n                    e += 1\n                e = max(0, e - 1)\n                return w, e, total_w + extents(word.text[:e])[0], True\n\n            return -1, -1, total_w, False",
  "def p_restricted(line, uw, c):\n            ''' Similar to `n_restricted`, except it returns the first\n            occurrence starting from the right, like `p`.\n            '''\n            total_w = 0\n            if not len(line):\n                return 0, 0, 0\n            for w in range(len(line) - 1, -1, -1):\n                word = line[w]\n                f = partial(word.text.rfind, c)\n                self.options = word.options\n                extents = self.get_cached_extents()\n                i = f()\n                if i != -1:\n                    ww = extents(word.text[i + 1:])[0]\n\n                if i != -1 and total_w + ww <= uw:  # found and it fits\n                    return w, i, total_w + ww, False\n                elif i == -1:\n                    ww = extents(word.text)[0]\n                    if total_w + ww <= uw:  # wasn't found and all fits\n                        total_w += ww\n                        continue\n\n                # now just find whatever amount of the word does fit\n                s = len(word.text) - 1\n                while s >= 0 and total_w + extents(word.text[s:])[0] <= uw:\n                    s -= 1\n                return w, s, total_w + extents(word.text[s + 1:])[0], True\n\n            return -1, -1, total_w, False",
  "class LabelBase(object):\n    '''Core text label.\n    This is the abstract class used by different backends to render text.\n\n    .. warning::\n        The core text label can't be changed at runtime. You must recreate one.\n\n    :Parameters:\n        `font_size`: int, defaults to 12\n            Font size of the text\n        `font_context`: str, defaults to None\n            Context for the specified font (see :class:`kivy.uix.label.Label`\n            for details). `None` will autocreate an isolated context named\n            after the resolved font file.\n        `font_name`: str, defaults to DEFAULT_FONT\n            Font name of the text\n        `font_family`: str, defaults to None\n            Font family name to request for drawing, this can only be used\n            with `font_context`.\n        `bold`: bool, defaults to False\n            Activate \"bold\" text style\n        `italic`: bool, defaults to False\n            Activate \"italic\" text style\n        `text_size`: tuple, defaults to (None, None)\n            Add constraint to render the text (inside a bounding box).\n            If no size is given, the label size will be set to the text size.\n        `padding`: int|float or list|tuple, defaults to [0, 0, 0, 0].\n            Padding of the text in the format [padding_left, padding_top,\n            padding_right, padding_bottom].\n            ``padding`` should be int|float or a list|tuple with 1, 2 or 4\n            elements.\n        `padding_x`: float, defaults to 0.0\n            Left/right padding\n        `padding_y`: float, defaults to 0.0\n            Top/bottom padding\n        `halign`: str, defaults to \"left\"\n            Horizontal text alignment inside the bounding box\n        `valign`: str, defaults to \"bottom\"\n            Vertical text alignment inside the bounding box\n        `shorten`: bool, defaults to False\n            Indicate whether the label should attempt to shorten its textual\n            contents as much as possible if a `size` is given.\n            Setting this to True without an appropriately set size will lead to\n            unexpected results.\n        `shorten_from`: str, defaults to `center`\n            The side from which we should shorten the text from, can be left,\n            right, or center. E.g. if left, the ellipsis will appear towards\n            the left side and it will display as much text starting from the\n            right as possible.\n        `split_str`: string, defaults to `' '` (space)\n            The string to use to split the words by when shortening. If empty,\n            we can split after every character filling up the line as much as\n            possible.\n        `max_lines`: int, defaults to 0 (unlimited)\n            If set, this indicate how maximum line are allowed to render the\n            text. Works only if a limitation on text_size is set.\n        `mipmap`: bool, defaults to False\n            Create a mipmap for the texture\n        `strip`: bool, defaults to False\n            Whether each row of text has its leading and trailing spaces\n            stripped. If `halign` is `justify` it is implicitly True.\n        `strip_reflow`: bool, defaults to True\n            Whether text that has been reflowed into a second line should\n            be stripped, even if `strip` is False. This is only in effect when\n            `size_hint_x` is not None, because otherwise lines are never\n            split.\n        `unicode_errors`: str, defaults to `'replace'`\n            How to handle unicode decode errors. Can be `'strict'`, `'replace'`\n            or `'ignore'`.\n        `outline_width`: int, defaults to None\n            Width in pixels for the outline.\n        `outline_color`: tuple, defaults to (0, 0, 0)\n            Color of the outline.\n        `font_features`: str, defaults to None\n            OpenType font features in CSS format (Pango only)\n        `base_direction`: str, defaults to None (auto)\n            Text direction, one of `None`, `'ltr'`, `'rtl'`, `'weak_ltr'`,\n            or `'weak_rtl'` (Pango only)\n        `text_language`: str, defaults to None (user locale)\n            RFC-3066 format language tag as a string (Pango only)\n\n    .. deprecated:: 2.2.0\n        `padding_x` and `padding_y` have been deprecated. Please use `padding`\n        instead.\n\n    .. versionchanged:: 2.2.0\n        `padding` is now a list and defaults to [0, 0, 0, 0]. `padding` accepts\n        int|float or a list|tuple with 1, 2 or 4 elements.\n\n    .. versionchanged:: 1.10.1\n        `font_context`, `font_family`, `font_features`, `base_direction`\n        and `text_language` were added.\n\n    .. versionchanged:: 1.10.0\n        `outline_width` and `outline_color` were added.\n\n    .. versionchanged:: 1.9.0\n        `strip`, `strip_reflow`, `shorten_from`, `split_str`, and\n        `unicode_errors` were added.\n\n    .. versionchanged:: 1.9.0\n        `padding_x` and `padding_y` has been fixed to work as expected.\n        In the past, the text was padded by the negative of their values.\n\n    .. versionchanged:: 1.8.0\n        `max_lines` parameters has been added.\n\n    .. versionchanged:: 1.0.8\n        `size` have been deprecated and replaced with `text_size`.\n\n    .. versionchanged:: 1.0.7\n        The `valign` is now respected. This wasn't the case previously\n        so you might have an issue in your application if you have not\n        considered this.\n\n    '''\n\n    __slots__ = ('options', 'texture', '_label', '_text_size')\n\n    _cached_lines = []\n\n    _fonts = {}\n\n    _fonts_cache = {}\n\n    _fonts_dirs = []\n\n    _font_dirs_files = []\n\n    _texture_1px = None\n\n    _font_family_support = False\n\n    def __init__(\n        self, text='', font_size=12, font_name=DEFAULT_FONT, bold=False,\n        italic=False, underline=False, strikethrough=False, font_family=None,\n        halign='left', valign='bottom', shorten=False,\n        text_size=None, mipmap=False, color=None, line_height=1.0, strip=False,\n        strip_reflow=True, shorten_from='center', split_str=' ',\n        unicode_errors='replace',\n        font_hinting='normal', font_kerning=True, font_blended=True,\n        outline_width=None, outline_color=None, font_context=None,\n        font_features=None, base_direction=None, font_direction='ltr',\n        font_script_name='Latin', text_language=None,\n        **kwargs):\n\n        # Include system fonts_dir in resource paths.\n        # This allows us to specify a font from those dirs.\n        LabelBase.get_system_fonts_dir()\n\n        options = {'text': text, 'font_size': font_size,\n                   'font_name': font_name, 'bold': bold, 'italic': italic,\n                   'underline': underline, 'strikethrough': strikethrough,\n                   'font_family': font_family,\n                   'halign': halign, 'valign': valign, 'shorten': shorten,\n                   'mipmap': mipmap, 'line_height': line_height,\n                   'strip': strip, 'strip_reflow': strip_reflow,\n                   'shorten_from': shorten_from, 'split_str': split_str,\n                   'unicode_errors': unicode_errors,\n                   'font_hinting': font_hinting,\n                   'font_kerning': font_kerning,\n                   'font_blended': font_blended,\n                   'outline_width': outline_width,\n                   'font_context': font_context,\n                   'font_features': font_features,\n                   'base_direction': base_direction,\n                   'font_direction': font_direction,\n                   'font_script_name': font_script_name,\n                   'text_language': text_language}\n\n        kwargs_get = kwargs.get\n        options['color'] = color or (1, 1, 1, 1)\n        options['outline_color'] = outline_color or (0, 0, 0, 1)\n\n        options['padding'] = kwargs_get('padding', [0, 0, 0, 0])\n        if isinstance(options['padding'], (int, float)):\n            options['padding'] = [options['padding']] * 4\n        elif (\n            isinstance(options['padding'], (list, tuple))\n            and len(options['padding']) != 4\n        ):\n            if len(options['padding']) == 1:\n                options['padding'] = options['padding'] * 4\n            elif len(options['padding']) == 2:\n                options['padding'] = options['padding'] * 2\n            else:\n                raise ValueError(\n                    \"padding should be int|float or a list|tuple with 1, 2 or \"\n                    f\"4 elements, got {type(options['padding'])} with \"\n                    f\"{len(options['padding'])} elements.\"\n                )\n\n        options['padding_x'] = kwargs_get('padding_x')\n        options['padding_y'] = kwargs_get('padding_y')\n        for padding_option in ('padding_x', 'padding_y'):\n            if kwargs_get(padding_option):\n                Logger.warning(\n                    f\"LabelBase: The use of the {padding_option} parameter is \"\n                    \"deprecated, and will be removed in future versions. Use \"\n                    \"padding instead.\"\n                )\n\n        if 'size' in kwargs:\n            options['text_size'] = kwargs['size']\n        else:\n            if text_size is None:\n                options['text_size'] = (None, None)\n            else:\n                options['text_size'] = text_size\n\n        self._text_size = options['text_size']\n        self._text = options['text']\n        self._internal_size = 0, 0  # the real computed text size (inclds pad)\n        self._cached_lines = []\n\n        self.options = options\n        self.texture = None\n        self.is_shortened = False\n        self.resolve_font_name()\n        self._migrate_deprecated_padding_xy()\n\n    def _migrate_deprecated_padding_xy(self):\n        options = self.options\n        self.options['padding'] = list(self.options['padding'])\n        if options['padding_x']:\n            self.options['padding'][::2] = [options['padding_x']] * 2\n        if options['padding_y']:\n            self.options['padding'][1::2] = [options['padding_y']] * 2\n\n    @staticmethod\n    def register(name, fn_regular, fn_italic=None, fn_bold=None,\n                 fn_bolditalic=None):\n        '''Register an alias for a Font.\n\n        .. versionadded:: 1.1.0\n\n        If you're using a ttf directly, you might not be able to use the\n        bold/italic properties of\n        the ttf version. If the font is delivered in multiple files\n        (one regular, one italic and one bold), then you need to register these\n        files and use the alias instead.\n\n        All the fn_regular/fn_italic/fn_bold parameters are resolved with\n        :func:`kivy.resources.resource_find`. If fn_italic/fn_bold are None,\n        fn_regular will be used instead.\n        '''\n\n        if fn_regular is None:\n            raise ValueError(\"font_regular cannot be None\")\n\n        fonts = []\n\n        for font_type in fn_regular, fn_italic, fn_bold, fn_bolditalic:\n            if font_type is not None:\n                font = resource_find(font_type)\n\n                if font is None:\n                    raise IOError('File {0} not found'.format(font_type))\n                else:\n                    fonts.append(font)\n            else:\n                fonts.append(fonts[0])  # add regular font to list again\n\n        LabelBase._fonts[name] = tuple(fonts)\n\n    def resolve_font_name(self):\n        options = self.options\n        fontname = options['font_name']\n        fonts = self._fonts\n        fontscache = self._fonts_cache\n\n        if self._font_family_support and options['font_family']:\n            options['font_name_r'] = None\n            return\n\n        # is the font registered?\n        if fontname in fonts:\n            # return the preferred font for the current bold/italic combination\n            italic = int(options['italic'])\n            if options['bold']:\n                bold = FONT_BOLD\n            else:\n                bold = FONT_REGULAR\n\n            options['font_name_r'] = fonts[fontname][italic | bold]\n\n        elif fontname in fontscache:\n            options['font_name_r'] = fontscache[fontname]\n        else:\n            filename = resource_find(fontname)\n            if not filename and not fontname.endswith('.ttf'):\n                fontname = '{}.ttf'.format(fontname)\n                filename = resource_find(fontname)\n\n            if filename is None:\n                # XXX for compatibility, check directly in the data dir\n                filename = pep8_fn = os.path.join(kivy_data_dir, fontname)\n                if not os.path.exists(pep8_fn) or not os.path.isfile(pep8_fn):\n                    raise IOError('Label: File %r not found' % fontname)\n            fontscache[fontname] = filename\n            options['font_name_r'] = filename\n\n    @staticmethod\n    def get_system_fonts_dir():\n        '''Return the directories used by the system for fonts.\n        '''\n        if LabelBase._fonts_dirs:\n            return LabelBase._fonts_dirs\n\n        fdirs = []\n        if platform == 'linux':\n            fdirs = [\n                '/usr/share/fonts', '/usr/local/share/fonts',\n                os.path.expanduser('~/.fonts'),\n                os.path.expanduser('~/.local/share/fonts')]\n        elif platform == 'macosx':\n            fdirs = ['/Library/Fonts', '/System/Library/Fonts',\n                     os.path.expanduser('~/Library/Fonts')]\n        elif platform == 'win':\n            fdirs = [os.path.join(os.environ['SYSTEMROOT'], 'Fonts')]\n        elif platform == 'ios':\n            fdirs = ['/System/Library/Fonts']\n        elif platform == 'android':\n            fdirs = ['/system/fonts']\n        else:\n            raise Exception(\"Unknown platform: {}\".format(platform))\n\n        fdirs.append(os.path.join(kivy_data_dir, 'fonts'))\n        # register the font dirs\n        rdirs = []\n        _font_dir_files = []\n        for fdir in fdirs:\n            for _dir, dirs, files in os.walk(fdir):\n                _font_dir_files.extend(files)\n                resource_add_path(_dir)\n                rdirs.append(_dir)\n        LabelBase._fonts_dirs = rdirs\n        LabelBase._font_dirs_files = _font_dir_files\n\n        return rdirs\n\n    def get_extents(self, text):\n        '''Return a tuple (width, height) indicating the size of the specified\n        text'''\n        return (0, 0)\n\n    def get_cached_extents(self):\n        '''Returns a cached version of the :meth:`get_extents` function.\n\n        ::\n\n            >>> func = self._get_cached_extents()\n            >>> func\n            <built-in method size of pygame.font.Font object at 0x01E45650>\n            >>> func('a line')\n            (36, 18)\n\n        .. warning::\n\n            This method returns a size measuring function that is valid\n            for the font settings used at the time :meth:`get_cached_extents`\n            was called. Any change in the font settings will render the\n            returned function incorrect. You should only use this if you know\n            what you're doing.\n\n        .. versionadded:: 1.9.0\n        '''\n        return self.get_extents\n\n    def _render_begin(self):\n        pass\n\n    def _render_text(self, text, x, y):\n        pass\n\n    def _render_end(self):\n        pass\n\n    def shorten(self, text, margin=2):\n        ''' Shortens the text to fit into a single line by the width specified\n        by :attr:`text_size` [0]. If :attr:`text_size` [0] is None, it returns\n        text unchanged.\n\n        :attr:`split_str` and :attr:`shorten_from` determines how the text is\n        shortened.\n\n        :params:\n\n            `text` str, the text to be shortened.\n            `margin` int, the amount of space to leave between the margins\n            and the text. This is in addition to :attr:`padding_x`.\n\n        :returns:\n            the text shortened to fit into a single line.\n        '''\n        textwidth = self.get_cached_extents()\n        uw = self.text_size[0]\n        if uw is None or not text:\n            return text\n\n        opts = self.options\n        uw = max(0, int(uw - opts['padding'][0] - opts['padding'][2] - margin))\n        # if larger, it won't fit so don't even try extents\n        chr = type(text)\n        text = text.replace(chr('\\n'), chr(' '))\n        if len(text) <= uw and textwidth(text)[0] <= uw:\n            return text\n        c = opts['split_str']\n        offset = 0 if len(c) else 1\n        dir = opts['shorten_from'][0]\n        elps = textwidth('...')[0]\n        if elps > uw:\n            self.is_shortened = True\n            if textwidth('..')[0] <= uw:\n                return '..'\n            else:\n                return '.'\n        uw -= elps\n\n        f = partial(text.find, c)\n        f_rev = partial(text.rfind, c)\n        # now find the first and last word\n        e1, s2 = f(), f_rev()\n\n        if dir != 'l':  # center or right\n            # no split, or the first word doesn't even fit\n            if e1 != -1:\n                l1 = textwidth(text[:e1])[0]\n                l2 = textwidth(text[s2 + 1:])[0]\n            if e1 == -1 or l1 + l2 > uw:\n                self.is_shortened = True\n                if len(c):\n                    opts['split_str'] = ''\n                    res = self.shorten(text, margin)\n                    opts['split_str'] = c\n                    return res\n                # at this point we do char by char so e1 must be zero\n                if l1 <= uw:\n                    return chr('{0}...').format(text[:e1])\n                return chr('...')\n\n            # both word fits, and there's at least on split_str\n            if s2 == e1:  # there's only on split_str\n                self.is_shortened = True\n                return chr('{0}...{1}').format(text[:e1], text[s2 + 1:])\n\n            # both the first and last word fits, and they start/end at diff pos\n            if dir == 'r':\n                ee1 = f(e1 + 1)\n                while l2 + textwidth(text[:ee1])[0] <= uw:\n                    e1 = ee1\n                    if e1 == s2:\n                        break\n                    ee1 = f(e1 + 1)\n            else:\n                while True:\n                    if l1 <= l2:\n                        ee1 = f(e1 + 1)\n                        l1 = textwidth(text[:ee1])[0]\n                        if l2 + l1 > uw:\n                            break\n                        e1 = ee1\n                        if e1 == s2:\n                            break\n                    else:\n                        ss2 = f_rev(0, s2 - offset)\n                        l2 = textwidth(text[ss2 + 1:])[0]\n                        if l2 + l1 > uw:\n                            break\n                        s2 = ss2\n                        if e1 == s2:\n                            break\n        else:  # left\n            # no split, or the last word doesn't even fit\n            if s2 != -1:\n                l2 = textwidth(text[s2 + (1 if len(c) else -1):])[0]\n                l1 = textwidth(text[:max(0, e1)])[0]\n            # if split_str\n            if s2 == -1 or l2 + l1 > uw:\n                self.is_shortened = True\n                if len(c):\n                    opts['split_str'] = ''\n                    res = self.shorten(text, margin)\n                    opts['split_str'] = c\n                    return res\n\n                return chr('...')\n\n            # both word fits, and there's at least on split_str\n            if s2 == e1:  # there's only on split_str\n                self.is_shortened = True\n                return chr('{0}...{1}').format(text[:e1], text[s2 + 1:])\n\n            # both the first and last word fits, and they start/end at diff pos\n            ss2 = f_rev(0, s2 - offset)\n            while l1 + textwidth(text[ss2 + 1:])[0] <= uw:\n                s2 = ss2\n                if s2 == e1:\n                    break\n                ss2 = f_rev(0, s2 - offset)\n\n        self.is_shortened = True\n        return chr('{0}...{1}').format(text[:e1], text[s2 + 1:])\n\n    def _default_line_options(self, lines):\n        for line in lines:\n            if len(line.words):  # get opts from first line, first word\n                return line.words[0].options\n        return None\n\n    def clear_texture(self):\n        self._render_begin()\n        data = self._render_end()\n        assert data\n        if data is not None and data.width > 1:\n            self.texture.blit_data(data)\n        return\n\n    # FIXME: This should possibly use a Config value, and possibly we should\n    #        expose pango_unichar_direction() / pango_bidi_type_for_unichar()\n    @staticmethod\n    def find_base_direction(text):\n        '''Searches a string the first character that has a strong direction,\n        according to the Unicode bidirectional algorithm. Returns `None` if\n        the base direction cannot be determined, or one of `'ltr'` or `'rtl'`.\n\n        .. versionadded: 1.10.1\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        return 'ltr'\n\n    def render_lines(self, lines, options, render_text, y, size):\n        get_extents = self.get_cached_extents()\n        uw, uh = options['text_size']\n        padding_left = options['padding'][0]\n        padding_right = options['padding'][2]\n        if uw is not None:\n            uww = uw - padding_left - padding_right  # real width of just text\n        w = size[0]\n        sw = options['space_width']\n        halign = options['halign']\n        split = re.split\n        find_base_dir = self.find_base_direction\n        cur_base_dir = options['base_direction']\n\n        for layout_line in lines:  # for plain label each line has only one str\n            lw, lh = layout_line.w, layout_line.h\n            line = ''\n            assert len(layout_line.words) < 2\n            if len(layout_line.words):\n                last_word = layout_line.words[0]\n                line = last_word.text\n                if not cur_base_dir:\n                    cur_base_dir = find_base_dir(line)\n            x = padding_left\n            if halign == 'auto':\n                if cur_base_dir and 'rtl' in cur_base_dir:\n                    # right-align RTL text\n                    x = max(0, int(w - lw - padding_right))\n            elif halign == 'center':\n                x = min(\n                    int(w - lw),\n                    max(\n                        int(padding_left),\n                        int((w - lw + padding_left - padding_right) / 2.0)\n                    )\n                )\n\n            elif halign == 'right':\n                x = max(0, int(w - lw - padding_right))\n\n            # right left justify\n            # divide left over space between `spaces`\n            # TODO implement a better method of stretching glyphs?\n            if (uw is not None and halign == 'justify' and line and not\n                    layout_line.is_last_line):\n                # number spaces needed to fill, and remainder\n                n, rem = divmod(max(uww - lw, 0), sw)\n                n = int(n)\n                words = None\n                if n or rem:\n                    # there's no trailing space when justify is selected\n                    words = split(whitespace_pat, line)\n                if words is not None and len(words) > 1:\n                    space = type(line)(' ')\n                    # words: every even index is spaces, just add ltr n spaces\n                    for i in range(n):\n                        idx = (2 * i + 1) % (len(words) - 1)\n                        words[idx] = words[idx] + space\n                    if rem:\n                        # render the last word at the edge, also add it to line\n                        ext = get_extents(words[-1])\n                        word = LayoutWord(last_word.options, ext[0], ext[1],\n                                          words[-1])\n                        layout_line.words.append(word)\n                        last_word.lw = uww - ext[0]  # word was stretched\n                        render_text(words[-1], x + last_word.lw, y)\n                        last_word.text = line = ''.join(words[:-2])\n                    else:\n                        last_word.lw = uww  # word was stretched\n                        last_word.text = line = ''.join(words)\n                    layout_line.w = uww  # the line occupies full width\n\n            if len(line):\n                layout_line.x = x\n                layout_line.y = y\n                render_text(line, x, y)\n            y += lh\n        return y\n\n    def _render_real(self):\n        lines = self._cached_lines\n        options = self._default_line_options(lines)\n        if options is None:  # there was no text to render\n            return self.clear_texture()\n\n        old_opts = self.options\n        ih = self._internal_size[1]  # the real size of text, not texture\n        size = self.size\n        valign = options['valign']\n\n        padding_top = options['padding'][1]\n        if valign == 'bottom':\n            y = int(size[1] - ih + padding_top)\n        elif valign == 'top':\n            y = int(padding_top)\n        elif valign in ('middle', 'center'):\n            y = int((size[1] - ih + 2 * padding_top) / 2)\n\n        self._render_begin()\n        self.render_lines(lines, options, self._render_text, y, size)\n\n        # get data from provider\n        data = self._render_end()\n        assert data\n        self.options = old_opts\n\n        # If the text is 1px width, usually, the data is black.\n        # Don't blit that kind of data, otherwise, you have a little black bar.\n        if data is not None and data.width > 1:\n            self.texture.blit_data(data)\n\n    def render(self, real=False):\n        '''Return a tuple (width, height) to create the image\n        with the user constraints. (width, height) includes the padding.\n        '''\n        if real:\n            return self._render_real()\n\n        options = copy(self.options)\n        options['space_width'] = self.get_extents(' ')[0]\n        options['strip'] = strip = (options['strip'] or\n                                    options['halign'] == 'justify')\n        uw, uh = options['text_size'] = self._text_size\n        text = self.text\n        if strip:\n            text = text.strip()\n\n        self.is_shortened = False\n        if uw is not None and options['shorten']:\n            text = self.shorten(text)\n\n        self._cached_lines = lines = []\n        if not text:\n            return 0, 0\n\n        if uh is not None and (options['valign'] == 'middle' or\n                               options['valign'] == 'center'):\n            center = -1  # pos of newline\n            if len(text) > 1:\n                middle = int(len(text) // 2)\n                l, r = text.rfind('\\n', 0, middle), text.find('\\n', middle)\n                if l != -1 and r != -1:\n                    center = l if center - l <= r - center else r\n                elif l != -1:\n                    center = l\n                elif r != -1:\n                    center = r\n            # if a newline split text, render from center down and up til uh\n            if center != -1:\n                # layout from center down until half uh\n                w, h, clipped = layout_text(text[center + 1:], lines, (0, 0),\n                (uw, uh / 2), options, self.get_cached_extents(), True, True)\n                # now layout from center upwards until uh is reached\n                w, h, clipped = layout_text(text[:center + 1], lines, (w, h),\n                (uw, uh), options, self.get_cached_extents(), False, True)\n            else:  # if there's no new line, layout everything\n                w, h, clipped = layout_text(text, lines, (0, 0), (uw, None),\n                options, self.get_cached_extents(), True, True)\n        else:  # top or bottom\n            w, h, clipped = layout_text(text, lines, (0, 0), (uw, uh), options,\n                self.get_cached_extents(), options['valign'] == 'top', True)\n        self._internal_size = w, h\n        if uw:\n            w = uw\n        if uh:\n            h = uh\n        if h > 1 and w < 2:\n            w = 2\n        return int(w), int(h)\n\n    def _texture_refresh(self, *l):\n        self.refresh()\n\n    def _texture_fill(self, texture):\n        # second pass, render for real\n        self.render(real=True)\n\n    def refresh(self):\n        '''Force re-rendering of the text\n        '''\n        self.resolve_font_name()\n\n        # first pass, calculating width/height\n        sz = self.render()\n        self._size_texture = sz\n        self._size = (sz[0], sz[1])\n\n        # if no text are rendered, return nothing.\n        width, height = self._size\n        if width <= 1 or height <= 1:\n            self.texture = self.texture_1px\n            return\n\n        # create a delayed texture\n        texture = self.texture\n        if texture is None or \\\n                width != texture.width or \\\n                height != texture.height:\n            texture = Texture.create(size=(width, height),\n                                     mipmap=self.options['mipmap'],\n                                     callback=self._texture_fill)\n            texture.flip_vertical()\n            texture.add_reload_observer(self._texture_refresh)\n            self.texture = texture\n        else:\n            texture.ask_update(self._texture_fill)\n\n    def _get_text(self):\n        return self._text\n\n    def _set_text(self, text):\n        if text != self._text:\n            self._text = text\n\n    text = property(_get_text, _set_text, doc='Get/Set the text')\n    label = property(_get_text, _set_text, doc='Get/Set the text')\n\n    @property\n    def texture_1px(self):\n        if LabelBase._texture_1px is None:\n            tex = Texture.create(size=(1, 1), colorfmt='rgba')\n            tex.blit_buffer(b'\\x00\\x00\\x00\\x00', colorfmt='rgba')\n            LabelBase._texture_1px = tex\n        return LabelBase._texture_1px\n\n    @property\n    def size(self):\n        return self._size\n\n    @property\n    def width(self):\n        return self._size[0]\n\n    @property\n    def height(self):\n        return self._size[1]\n\n    @property\n    def content_width(self):\n        '''Return the content width; i.e. the width of the text without\n        any padding.'''\n        if self.texture is None:\n            return 0\n        return self.texture.width - (\n            self.options['padding'][0] + self.options['padding'][2]\n        )\n\n    @property\n    def content_height(self):\n        '''Return the content height; i.e. the height of the text without\n        any padding.'''\n        if self.texture is None:\n            return 0\n        return self.texture.height - (\n            self.options['padding'][1] + self.options['padding'][3]\n        )\n\n    @property\n    def content_size(self):\n        '''Return the content size (width, height)'''\n        if self.texture is None:\n            return (0, 0)\n        return (self.content_width, self.content_height)\n\n    @property\n    def fontid(self):\n        '''Return a unique id for all font parameters'''\n        return str([self.options[x] for x in (\n            'font_size', 'font_name_r', 'bold',\n            'italic', 'underline', 'strikethrough')])\n\n    def _get_text_size(self):\n        return self._text_size\n\n    def _set_text_size(self, x):\n        self._text_size = x\n\n    text_size = property(_get_text_size, _set_text_size,\n                         doc='''Get/set the (width, height) of the '\n                         'contrained rendering box''')\n\n    usersize = property(_get_text_size, _set_text_size,\n                        doc='''(deprecated) Use text_size instead.''')",
  "class FontContextManagerBase(object):\n    @staticmethod\n    def create(font_context):\n        '''Create a font context, you must specify a unique name (string).\n        Returns `True` on success and `False` on failure.\n\n        If `font_context` starts with one of the reserved words `'system://'`,\n        `'directory://'`, `'fontconfig://'` or `'systemconfig://'`, the context\n        is setup accordingly (exact results of this depends on your platform,\n        environment and configuration).\n\n        * `'system://'` loads the default system's FontConfig configuration\n          and all fonts (usually including user fonts).\n        * `directory://` contexts preload a directory of font files (specified\n          in the context name), `systemconfig://` loads the system's FontConfig\n          configuration (but no fonts), and `fontconfig://` loads FontConfig\n          configuration file (specified in the context name!). These are for\n          advanced users only, check the source code and FontConfig\n          documentation for details.\n        * Fonts automatically loaded to an isolated context (ie when no\n          font context was specified) start with `'isolated://'`. This has\n          no special effect, and only serves to help you identify them in\n          the results returned from :meth:`list`.\n        * Any other string is a context that will only draw with the font\n          file(s) you explicitly add to it.\n\n        .. versionadded:: 1.11.0\n\n        .. note::\n            Font contexts are created automatically by specifying a name in the\n            `font_context` property of :class:`kivy.uix.label.Label` or\n            :class:`kivy.uix.textinput.TextInput`. They are also auto-created\n            by :meth:`add_font` by default, so you normally don't need to\n            call this directly.\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")\n\n    @staticmethod\n    def exists(font_context):\n        '''Returns True if a font context with the given name exists.\n\n        .. versionadded:: 1.11.0\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")\n\n    @staticmethod\n    def destroy(font_context):\n        '''Destroy a named font context (if it exists)\n\n        .. versionadded:: 1.11.0\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")\n\n    @staticmethod\n    def list():\n        '''Returns a list of `bytes` objects, each representing a cached font\n        context name. Note that entries that start with `isolated://` were\n        autocreated by loading a font file with no font_context specified.\n\n        .. versionadded:: 1.11.0\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")\n\n    @staticmethod\n    def list_families(font_context):\n        '''Returns a list of `bytes` objects, each representing a font family\n        name that is available in the given `font_context`.\n\n        .. versionadded:: 1.11.0\n\n        .. note::\n            Pango adds static \"Serif\", \"Sans\" and \"Monospace\" to the list in\n            current versions, even if only a single custom font file is added\n            to the context.\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")\n\n    @staticmethod\n    def list_custom(font_context):\n        '''Returns a dictionary representing all the custom-loaded fonts in\n        the context. The key is a `bytes` object representing the full path\n        to the font file, the value is a `bytes` object representing the font\n        family name used to request drawing with the font.\n\n        .. versionadded:: 1.11.0\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")\n\n    @staticmethod\n    def add_font(font_context, filename, autocreate=True, family=None):\n        '''Add a font file to a named font context. If `autocreate` is true,\n        the context will be created if it does not exist (this is the\n        default). You can specify the `family` argument (string) to skip\n        auto-detecting the font family name.\n\n        .. warning::\n\n            The `family` argument is slated for removal if the underlying\n            implementation can be fixed, It is offered as a way to optimize\n            startup time for deployed applications (it avoids opening the\n            file with FreeType2 to determine its family name). To use this,\n            first load the font file without specifying `family`, and\n            hardcode the returned (autodetected) `family` value in your font\n            context initialization.\n\n        .. versionadded:: 1.11.0\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")",
  "def __init__(\n        self, text='', font_size=12, font_name=DEFAULT_FONT, bold=False,\n        italic=False, underline=False, strikethrough=False, font_family=None,\n        halign='left', valign='bottom', shorten=False,\n        text_size=None, mipmap=False, color=None, line_height=1.0, strip=False,\n        strip_reflow=True, shorten_from='center', split_str=' ',\n        unicode_errors='replace',\n        font_hinting='normal', font_kerning=True, font_blended=True,\n        outline_width=None, outline_color=None, font_context=None,\n        font_features=None, base_direction=None, font_direction='ltr',\n        font_script_name='Latin', text_language=None,\n        **kwargs):\n\n        # Include system fonts_dir in resource paths.\n        # This allows us to specify a font from those dirs.\n        LabelBase.get_system_fonts_dir()\n\n        options = {'text': text, 'font_size': font_size,\n                   'font_name': font_name, 'bold': bold, 'italic': italic,\n                   'underline': underline, 'strikethrough': strikethrough,\n                   'font_family': font_family,\n                   'halign': halign, 'valign': valign, 'shorten': shorten,\n                   'mipmap': mipmap, 'line_height': line_height,\n                   'strip': strip, 'strip_reflow': strip_reflow,\n                   'shorten_from': shorten_from, 'split_str': split_str,\n                   'unicode_errors': unicode_errors,\n                   'font_hinting': font_hinting,\n                   'font_kerning': font_kerning,\n                   'font_blended': font_blended,\n                   'outline_width': outline_width,\n                   'font_context': font_context,\n                   'font_features': font_features,\n                   'base_direction': base_direction,\n                   'font_direction': font_direction,\n                   'font_script_name': font_script_name,\n                   'text_language': text_language}\n\n        kwargs_get = kwargs.get\n        options['color'] = color or (1, 1, 1, 1)\n        options['outline_color'] = outline_color or (0, 0, 0, 1)\n\n        options['padding'] = kwargs_get('padding', [0, 0, 0, 0])\n        if isinstance(options['padding'], (int, float)):\n            options['padding'] = [options['padding']] * 4\n        elif (\n            isinstance(options['padding'], (list, tuple))\n            and len(options['padding']) != 4\n        ):\n            if len(options['padding']) == 1:\n                options['padding'] = options['padding'] * 4\n            elif len(options['padding']) == 2:\n                options['padding'] = options['padding'] * 2\n            else:\n                raise ValueError(\n                    \"padding should be int|float or a list|tuple with 1, 2 or \"\n                    f\"4 elements, got {type(options['padding'])} with \"\n                    f\"{len(options['padding'])} elements.\"\n                )\n\n        options['padding_x'] = kwargs_get('padding_x')\n        options['padding_y'] = kwargs_get('padding_y')\n        for padding_option in ('padding_x', 'padding_y'):\n            if kwargs_get(padding_option):\n                Logger.warning(\n                    f\"LabelBase: The use of the {padding_option} parameter is \"\n                    \"deprecated, and will be removed in future versions. Use \"\n                    \"padding instead.\"\n                )\n\n        if 'size' in kwargs:\n            options['text_size'] = kwargs['size']\n        else:\n            if text_size is None:\n                options['text_size'] = (None, None)\n            else:\n                options['text_size'] = text_size\n\n        self._text_size = options['text_size']\n        self._text = options['text']\n        self._internal_size = 0, 0  # the real computed text size (inclds pad)\n        self._cached_lines = []\n\n        self.options = options\n        self.texture = None\n        self.is_shortened = False\n        self.resolve_font_name()\n        self._migrate_deprecated_padding_xy()",
  "def _migrate_deprecated_padding_xy(self):\n        options = self.options\n        self.options['padding'] = list(self.options['padding'])\n        if options['padding_x']:\n            self.options['padding'][::2] = [options['padding_x']] * 2\n        if options['padding_y']:\n            self.options['padding'][1::2] = [options['padding_y']] * 2",
  "def register(name, fn_regular, fn_italic=None, fn_bold=None,\n                 fn_bolditalic=None):\n        '''Register an alias for a Font.\n\n        .. versionadded:: 1.1.0\n\n        If you're using a ttf directly, you might not be able to use the\n        bold/italic properties of\n        the ttf version. If the font is delivered in multiple files\n        (one regular, one italic and one bold), then you need to register these\n        files and use the alias instead.\n\n        All the fn_regular/fn_italic/fn_bold parameters are resolved with\n        :func:`kivy.resources.resource_find`. If fn_italic/fn_bold are None,\n        fn_regular will be used instead.\n        '''\n\n        if fn_regular is None:\n            raise ValueError(\"font_regular cannot be None\")\n\n        fonts = []\n\n        for font_type in fn_regular, fn_italic, fn_bold, fn_bolditalic:\n            if font_type is not None:\n                font = resource_find(font_type)\n\n                if font is None:\n                    raise IOError('File {0} not found'.format(font_type))\n                else:\n                    fonts.append(font)\n            else:\n                fonts.append(fonts[0])  # add regular font to list again\n\n        LabelBase._fonts[name] = tuple(fonts)",
  "def resolve_font_name(self):\n        options = self.options\n        fontname = options['font_name']\n        fonts = self._fonts\n        fontscache = self._fonts_cache\n\n        if self._font_family_support and options['font_family']:\n            options['font_name_r'] = None\n            return\n\n        # is the font registered?\n        if fontname in fonts:\n            # return the preferred font for the current bold/italic combination\n            italic = int(options['italic'])\n            if options['bold']:\n                bold = FONT_BOLD\n            else:\n                bold = FONT_REGULAR\n\n            options['font_name_r'] = fonts[fontname][italic | bold]\n\n        elif fontname in fontscache:\n            options['font_name_r'] = fontscache[fontname]\n        else:\n            filename = resource_find(fontname)\n            if not filename and not fontname.endswith('.ttf'):\n                fontname = '{}.ttf'.format(fontname)\n                filename = resource_find(fontname)\n\n            if filename is None:\n                # XXX for compatibility, check directly in the data dir\n                filename = pep8_fn = os.path.join(kivy_data_dir, fontname)\n                if not os.path.exists(pep8_fn) or not os.path.isfile(pep8_fn):\n                    raise IOError('Label: File %r not found' % fontname)\n            fontscache[fontname] = filename\n            options['font_name_r'] = filename",
  "def get_system_fonts_dir():\n        '''Return the directories used by the system for fonts.\n        '''\n        if LabelBase._fonts_dirs:\n            return LabelBase._fonts_dirs\n\n        fdirs = []\n        if platform == 'linux':\n            fdirs = [\n                '/usr/share/fonts', '/usr/local/share/fonts',\n                os.path.expanduser('~/.fonts'),\n                os.path.expanduser('~/.local/share/fonts')]\n        elif platform == 'macosx':\n            fdirs = ['/Library/Fonts', '/System/Library/Fonts',\n                     os.path.expanduser('~/Library/Fonts')]\n        elif platform == 'win':\n            fdirs = [os.path.join(os.environ['SYSTEMROOT'], 'Fonts')]\n        elif platform == 'ios':\n            fdirs = ['/System/Library/Fonts']\n        elif platform == 'android':\n            fdirs = ['/system/fonts']\n        else:\n            raise Exception(\"Unknown platform: {}\".format(platform))\n\n        fdirs.append(os.path.join(kivy_data_dir, 'fonts'))\n        # register the font dirs\n        rdirs = []\n        _font_dir_files = []\n        for fdir in fdirs:\n            for _dir, dirs, files in os.walk(fdir):\n                _font_dir_files.extend(files)\n                resource_add_path(_dir)\n                rdirs.append(_dir)\n        LabelBase._fonts_dirs = rdirs\n        LabelBase._font_dirs_files = _font_dir_files\n\n        return rdirs",
  "def get_extents(self, text):\n        '''Return a tuple (width, height) indicating the size of the specified\n        text'''\n        return (0, 0)",
  "def get_cached_extents(self):\n        '''Returns a cached version of the :meth:`get_extents` function.\n\n        ::\n\n            >>> func = self._get_cached_extents()\n            >>> func\n            <built-in method size of pygame.font.Font object at 0x01E45650>\n            >>> func('a line')\n            (36, 18)\n\n        .. warning::\n\n            This method returns a size measuring function that is valid\n            for the font settings used at the time :meth:`get_cached_extents`\n            was called. Any change in the font settings will render the\n            returned function incorrect. You should only use this if you know\n            what you're doing.\n\n        .. versionadded:: 1.9.0\n        '''\n        return self.get_extents",
  "def _render_begin(self):\n        pass",
  "def _render_text(self, text, x, y):\n        pass",
  "def _render_end(self):\n        pass",
  "def shorten(self, text, margin=2):\n        ''' Shortens the text to fit into a single line by the width specified\n        by :attr:`text_size` [0]. If :attr:`text_size` [0] is None, it returns\n        text unchanged.\n\n        :attr:`split_str` and :attr:`shorten_from` determines how the text is\n        shortened.\n\n        :params:\n\n            `text` str, the text to be shortened.\n            `margin` int, the amount of space to leave between the margins\n            and the text. This is in addition to :attr:`padding_x`.\n\n        :returns:\n            the text shortened to fit into a single line.\n        '''\n        textwidth = self.get_cached_extents()\n        uw = self.text_size[0]\n        if uw is None or not text:\n            return text\n\n        opts = self.options\n        uw = max(0, int(uw - opts['padding'][0] - opts['padding'][2] - margin))\n        # if larger, it won't fit so don't even try extents\n        chr = type(text)\n        text = text.replace(chr('\\n'), chr(' '))\n        if len(text) <= uw and textwidth(text)[0] <= uw:\n            return text\n        c = opts['split_str']\n        offset = 0 if len(c) else 1\n        dir = opts['shorten_from'][0]\n        elps = textwidth('...')[0]\n        if elps > uw:\n            self.is_shortened = True\n            if textwidth('..')[0] <= uw:\n                return '..'\n            else:\n                return '.'\n        uw -= elps\n\n        f = partial(text.find, c)\n        f_rev = partial(text.rfind, c)\n        # now find the first and last word\n        e1, s2 = f(), f_rev()\n\n        if dir != 'l':  # center or right\n            # no split, or the first word doesn't even fit\n            if e1 != -1:\n                l1 = textwidth(text[:e1])[0]\n                l2 = textwidth(text[s2 + 1:])[0]\n            if e1 == -1 or l1 + l2 > uw:\n                self.is_shortened = True\n                if len(c):\n                    opts['split_str'] = ''\n                    res = self.shorten(text, margin)\n                    opts['split_str'] = c\n                    return res\n                # at this point we do char by char so e1 must be zero\n                if l1 <= uw:\n                    return chr('{0}...').format(text[:e1])\n                return chr('...')\n\n            # both word fits, and there's at least on split_str\n            if s2 == e1:  # there's only on split_str\n                self.is_shortened = True\n                return chr('{0}...{1}').format(text[:e1], text[s2 + 1:])\n\n            # both the first and last word fits, and they start/end at diff pos\n            if dir == 'r':\n                ee1 = f(e1 + 1)\n                while l2 + textwidth(text[:ee1])[0] <= uw:\n                    e1 = ee1\n                    if e1 == s2:\n                        break\n                    ee1 = f(e1 + 1)\n            else:\n                while True:\n                    if l1 <= l2:\n                        ee1 = f(e1 + 1)\n                        l1 = textwidth(text[:ee1])[0]\n                        if l2 + l1 > uw:\n                            break\n                        e1 = ee1\n                        if e1 == s2:\n                            break\n                    else:\n                        ss2 = f_rev(0, s2 - offset)\n                        l2 = textwidth(text[ss2 + 1:])[0]\n                        if l2 + l1 > uw:\n                            break\n                        s2 = ss2\n                        if e1 == s2:\n                            break\n        else:  # left\n            # no split, or the last word doesn't even fit\n            if s2 != -1:\n                l2 = textwidth(text[s2 + (1 if len(c) else -1):])[0]\n                l1 = textwidth(text[:max(0, e1)])[0]\n            # if split_str\n            if s2 == -1 or l2 + l1 > uw:\n                self.is_shortened = True\n                if len(c):\n                    opts['split_str'] = ''\n                    res = self.shorten(text, margin)\n                    opts['split_str'] = c\n                    return res\n\n                return chr('...')\n\n            # both word fits, and there's at least on split_str\n            if s2 == e1:  # there's only on split_str\n                self.is_shortened = True\n                return chr('{0}...{1}').format(text[:e1], text[s2 + 1:])\n\n            # both the first and last word fits, and they start/end at diff pos\n            ss2 = f_rev(0, s2 - offset)\n            while l1 + textwidth(text[ss2 + 1:])[0] <= uw:\n                s2 = ss2\n                if s2 == e1:\n                    break\n                ss2 = f_rev(0, s2 - offset)\n\n        self.is_shortened = True\n        return chr('{0}...{1}').format(text[:e1], text[s2 + 1:])",
  "def _default_line_options(self, lines):\n        for line in lines:\n            if len(line.words):  # get opts from first line, first word\n                return line.words[0].options\n        return None",
  "def clear_texture(self):\n        self._render_begin()\n        data = self._render_end()\n        assert data\n        if data is not None and data.width > 1:\n            self.texture.blit_data(data)\n        return",
  "def find_base_direction(text):\n        '''Searches a string the first character that has a strong direction,\n        according to the Unicode bidirectional algorithm. Returns `None` if\n        the base direction cannot be determined, or one of `'ltr'` or `'rtl'`.\n\n        .. versionadded: 1.10.1\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        return 'ltr'",
  "def render_lines(self, lines, options, render_text, y, size):\n        get_extents = self.get_cached_extents()\n        uw, uh = options['text_size']\n        padding_left = options['padding'][0]\n        padding_right = options['padding'][2]\n        if uw is not None:\n            uww = uw - padding_left - padding_right  # real width of just text\n        w = size[0]\n        sw = options['space_width']\n        halign = options['halign']\n        split = re.split\n        find_base_dir = self.find_base_direction\n        cur_base_dir = options['base_direction']\n\n        for layout_line in lines:  # for plain label each line has only one str\n            lw, lh = layout_line.w, layout_line.h\n            line = ''\n            assert len(layout_line.words) < 2\n            if len(layout_line.words):\n                last_word = layout_line.words[0]\n                line = last_word.text\n                if not cur_base_dir:\n                    cur_base_dir = find_base_dir(line)\n            x = padding_left\n            if halign == 'auto':\n                if cur_base_dir and 'rtl' in cur_base_dir:\n                    # right-align RTL text\n                    x = max(0, int(w - lw - padding_right))\n            elif halign == 'center':\n                x = min(\n                    int(w - lw),\n                    max(\n                        int(padding_left),\n                        int((w - lw + padding_left - padding_right) / 2.0)\n                    )\n                )\n\n            elif halign == 'right':\n                x = max(0, int(w - lw - padding_right))\n\n            # right left justify\n            # divide left over space between `spaces`\n            # TODO implement a better method of stretching glyphs?\n            if (uw is not None and halign == 'justify' and line and not\n                    layout_line.is_last_line):\n                # number spaces needed to fill, and remainder\n                n, rem = divmod(max(uww - lw, 0), sw)\n                n = int(n)\n                words = None\n                if n or rem:\n                    # there's no trailing space when justify is selected\n                    words = split(whitespace_pat, line)\n                if words is not None and len(words) > 1:\n                    space = type(line)(' ')\n                    # words: every even index is spaces, just add ltr n spaces\n                    for i in range(n):\n                        idx = (2 * i + 1) % (len(words) - 1)\n                        words[idx] = words[idx] + space\n                    if rem:\n                        # render the last word at the edge, also add it to line\n                        ext = get_extents(words[-1])\n                        word = LayoutWord(last_word.options, ext[0], ext[1],\n                                          words[-1])\n                        layout_line.words.append(word)\n                        last_word.lw = uww - ext[0]  # word was stretched\n                        render_text(words[-1], x + last_word.lw, y)\n                        last_word.text = line = ''.join(words[:-2])\n                    else:\n                        last_word.lw = uww  # word was stretched\n                        last_word.text = line = ''.join(words)\n                    layout_line.w = uww  # the line occupies full width\n\n            if len(line):\n                layout_line.x = x\n                layout_line.y = y\n                render_text(line, x, y)\n            y += lh\n        return y",
  "def _render_real(self):\n        lines = self._cached_lines\n        options = self._default_line_options(lines)\n        if options is None:  # there was no text to render\n            return self.clear_texture()\n\n        old_opts = self.options\n        ih = self._internal_size[1]  # the real size of text, not texture\n        size = self.size\n        valign = options['valign']\n\n        padding_top = options['padding'][1]\n        if valign == 'bottom':\n            y = int(size[1] - ih + padding_top)\n        elif valign == 'top':\n            y = int(padding_top)\n        elif valign in ('middle', 'center'):\n            y = int((size[1] - ih + 2 * padding_top) / 2)\n\n        self._render_begin()\n        self.render_lines(lines, options, self._render_text, y, size)\n\n        # get data from provider\n        data = self._render_end()\n        assert data\n        self.options = old_opts\n\n        # If the text is 1px width, usually, the data is black.\n        # Don't blit that kind of data, otherwise, you have a little black bar.\n        if data is not None and data.width > 1:\n            self.texture.blit_data(data)",
  "def render(self, real=False):\n        '''Return a tuple (width, height) to create the image\n        with the user constraints. (width, height) includes the padding.\n        '''\n        if real:\n            return self._render_real()\n\n        options = copy(self.options)\n        options['space_width'] = self.get_extents(' ')[0]\n        options['strip'] = strip = (options['strip'] or\n                                    options['halign'] == 'justify')\n        uw, uh = options['text_size'] = self._text_size\n        text = self.text\n        if strip:\n            text = text.strip()\n\n        self.is_shortened = False\n        if uw is not None and options['shorten']:\n            text = self.shorten(text)\n\n        self._cached_lines = lines = []\n        if not text:\n            return 0, 0\n\n        if uh is not None and (options['valign'] == 'middle' or\n                               options['valign'] == 'center'):\n            center = -1  # pos of newline\n            if len(text) > 1:\n                middle = int(len(text) // 2)\n                l, r = text.rfind('\\n', 0, middle), text.find('\\n', middle)\n                if l != -1 and r != -1:\n                    center = l if center - l <= r - center else r\n                elif l != -1:\n                    center = l\n                elif r != -1:\n                    center = r\n            # if a newline split text, render from center down and up til uh\n            if center != -1:\n                # layout from center down until half uh\n                w, h, clipped = layout_text(text[center + 1:], lines, (0, 0),\n                (uw, uh / 2), options, self.get_cached_extents(), True, True)\n                # now layout from center upwards until uh is reached\n                w, h, clipped = layout_text(text[:center + 1], lines, (w, h),\n                (uw, uh), options, self.get_cached_extents(), False, True)\n            else:  # if there's no new line, layout everything\n                w, h, clipped = layout_text(text, lines, (0, 0), (uw, None),\n                options, self.get_cached_extents(), True, True)\n        else:  # top or bottom\n            w, h, clipped = layout_text(text, lines, (0, 0), (uw, uh), options,\n                self.get_cached_extents(), options['valign'] == 'top', True)\n        self._internal_size = w, h\n        if uw:\n            w = uw\n        if uh:\n            h = uh\n        if h > 1 and w < 2:\n            w = 2\n        return int(w), int(h)",
  "def _texture_refresh(self, *l):\n        self.refresh()",
  "def _texture_fill(self, texture):\n        # second pass, render for real\n        self.render(real=True)",
  "def refresh(self):\n        '''Force re-rendering of the text\n        '''\n        self.resolve_font_name()\n\n        # first pass, calculating width/height\n        sz = self.render()\n        self._size_texture = sz\n        self._size = (sz[0], sz[1])\n\n        # if no text are rendered, return nothing.\n        width, height = self._size\n        if width <= 1 or height <= 1:\n            self.texture = self.texture_1px\n            return\n\n        # create a delayed texture\n        texture = self.texture\n        if texture is None or \\\n                width != texture.width or \\\n                height != texture.height:\n            texture = Texture.create(size=(width, height),\n                                     mipmap=self.options['mipmap'],\n                                     callback=self._texture_fill)\n            texture.flip_vertical()\n            texture.add_reload_observer(self._texture_refresh)\n            self.texture = texture\n        else:\n            texture.ask_update(self._texture_fill)",
  "def _get_text(self):\n        return self._text",
  "def _set_text(self, text):\n        if text != self._text:\n            self._text = text",
  "def texture_1px(self):\n        if LabelBase._texture_1px is None:\n            tex = Texture.create(size=(1, 1), colorfmt='rgba')\n            tex.blit_buffer(b'\\x00\\x00\\x00\\x00', colorfmt='rgba')\n            LabelBase._texture_1px = tex\n        return LabelBase._texture_1px",
  "def size(self):\n        return self._size",
  "def width(self):\n        return self._size[0]",
  "def height(self):\n        return self._size[1]",
  "def content_width(self):\n        '''Return the content width; i.e. the width of the text without\n        any padding.'''\n        if self.texture is None:\n            return 0\n        return self.texture.width - (\n            self.options['padding'][0] + self.options['padding'][2]\n        )",
  "def content_height(self):\n        '''Return the content height; i.e. the height of the text without\n        any padding.'''\n        if self.texture is None:\n            return 0\n        return self.texture.height - (\n            self.options['padding'][1] + self.options['padding'][3]\n        )",
  "def content_size(self):\n        '''Return the content size (width, height)'''\n        if self.texture is None:\n            return (0, 0)\n        return (self.content_width, self.content_height)",
  "def fontid(self):\n        '''Return a unique id for all font parameters'''\n        return str([self.options[x] for x in (\n            'font_size', 'font_name_r', 'bold',\n            'italic', 'underline', 'strikethrough')])",
  "def _get_text_size(self):\n        return self._text_size",
  "def _set_text_size(self, x):\n        self._text_size = x",
  "def create(font_context):\n        '''Create a font context, you must specify a unique name (string).\n        Returns `True` on success and `False` on failure.\n\n        If `font_context` starts with one of the reserved words `'system://'`,\n        `'directory://'`, `'fontconfig://'` or `'systemconfig://'`, the context\n        is setup accordingly (exact results of this depends on your platform,\n        environment and configuration).\n\n        * `'system://'` loads the default system's FontConfig configuration\n          and all fonts (usually including user fonts).\n        * `directory://` contexts preload a directory of font files (specified\n          in the context name), `systemconfig://` loads the system's FontConfig\n          configuration (but no fonts), and `fontconfig://` loads FontConfig\n          configuration file (specified in the context name!). These are for\n          advanced users only, check the source code and FontConfig\n          documentation for details.\n        * Fonts automatically loaded to an isolated context (ie when no\n          font context was specified) start with `'isolated://'`. This has\n          no special effect, and only serves to help you identify them in\n          the results returned from :meth:`list`.\n        * Any other string is a context that will only draw with the font\n          file(s) you explicitly add to it.\n\n        .. versionadded:: 1.11.0\n\n        .. note::\n            Font contexts are created automatically by specifying a name in the\n            `font_context` property of :class:`kivy.uix.label.Label` or\n            :class:`kivy.uix.textinput.TextInput`. They are also auto-created\n            by :meth:`add_font` by default, so you normally don't need to\n            call this directly.\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")",
  "def exists(font_context):\n        '''Returns True if a font context with the given name exists.\n\n        .. versionadded:: 1.11.0\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")",
  "def destroy(font_context):\n        '''Destroy a named font context (if it exists)\n\n        .. versionadded:: 1.11.0\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")",
  "def list():\n        '''Returns a list of `bytes` objects, each representing a cached font\n        context name. Note that entries that start with `isolated://` were\n        autocreated by loading a font file with no font_context specified.\n\n        .. versionadded:: 1.11.0\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")",
  "def list_families(font_context):\n        '''Returns a list of `bytes` objects, each representing a font family\n        name that is available in the given `font_context`.\n\n        .. versionadded:: 1.11.0\n\n        .. note::\n            Pango adds static \"Serif\", \"Sans\" and \"Monospace\" to the list in\n            current versions, even if only a single custom font file is added\n            to the context.\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")",
  "def list_custom(font_context):\n        '''Returns a dictionary representing all the custom-loaded fonts in\n        the context. The key is a `bytes` object representing the full path\n        to the font file, the value is a `bytes` object representing the font\n        family name used to request drawing with the font.\n\n        .. versionadded:: 1.11.0\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")",
  "def add_font(font_context, filename, autocreate=True, family=None):\n        '''Add a font file to a named font context. If `autocreate` is true,\n        the context will be created if it does not exist (this is the\n        default). You can specify the `family` argument (string) to skip\n        auto-detecting the font family name.\n\n        .. warning::\n\n            The `family` argument is slated for removal if the underlying\n            implementation can be fixed, It is offered as a way to optimize\n            startup time for deployed applications (it avoids opening the\n            file with FreeType2 to determine its family name). To use this,\n            first load the font file without specifying `family`, and\n            hardcode the returned (autodetected) `family` value in your font\n            context initialization.\n\n        .. versionadded:: 1.11.0\n\n        .. note:: This feature requires the Pango text provider.\n        '''\n        raise NotImplementedError(\"No font_context support in text provider\")",
  "class LabelPIL(LabelBase):\n    _cache = {}\n\n    def _select_font(self):\n        fontsize = int(self.options['font_size'])\n        fontname = self.options['font_name_r']\n        try:\n            id = '%s.%s' % (text_type(fontname), text_type(fontsize))\n        except UnicodeDecodeError:\n            id = '%s.%s' % (fontname, fontsize)\n\n        if id not in self._cache:\n            font = ImageFont.truetype(fontname, fontsize)\n            self._cache[id] = font\n\n        return self._cache[id]\n\n    def get_extents(self, text):\n        font = self._select_font()\n        w, h = font.getsize(text)\n        return w, h\n\n    def get_cached_extents(self):\n        return self._select_font().getsize\n\n    def _render_begin(self):\n        # create a surface, context, font...\n        self._pil_im = Image.new('RGBA', self._size, color=(255, 255, 255, 0))\n        self._pil_draw = ImageDraw.Draw(self._pil_im)\n\n    def _render_text(self, text, x, y):\n        color = tuple([int(c * 255) for c in self.options['color']])\n        self._pil_draw.text((int(x), int(y)),\n                            text, font=self._select_font(), fill=color)\n\n    def _render_end(self):\n        data = ImageData(self._size[0], self._size[1],\n                         self._pil_im.mode.lower(), self._pil_im.tobytes())\n\n        del self._pil_im\n        del self._pil_draw\n\n        return data",
  "def _select_font(self):\n        fontsize = int(self.options['font_size'])\n        fontname = self.options['font_name_r']\n        try:\n            id = '%s.%s' % (text_type(fontname), text_type(fontsize))\n        except UnicodeDecodeError:\n            id = '%s.%s' % (fontname, fontsize)\n\n        if id not in self._cache:\n            font = ImageFont.truetype(fontname, fontsize)\n            self._cache[id] = font\n\n        return self._cache[id]",
  "def get_extents(self, text):\n        font = self._select_font()\n        w, h = font.getsize(text)\n        return w, h",
  "def get_cached_extents(self):\n        return self._select_font().getsize",
  "def _render_begin(self):\n        # create a surface, context, font...\n        self._pil_im = Image.new('RGBA', self._size, color=(255, 255, 255, 0))\n        self._pil_draw = ImageDraw.Draw(self._pil_im)",
  "def _render_text(self, text, x, y):\n        color = tuple([int(c * 255) for c in self.options['color']])\n        self._pil_draw.text((int(x), int(y)),\n                            text, font=self._select_font(), fill=color)",
  "def _render_end(self):\n        data = ImageData(self._size[0], self._size[1],\n                         self._pil_im.mode.lower(), self._pil_im.tobytes())\n\n        del self._pil_im\n        del self._pil_draw\n\n        return data",
  "def _log_callback(message, level):\n    message = message.strip()\n    if message:\n        logger_func[level]('ffpyplayer: {}'.format(message))",
  "class ImageLoaderFFPy(ImageLoaderBase):\n    '''Image loader based on the ffpyplayer library.\n\n    .. versionadded:: 1.9.0\n\n    .. note:\n        This provider may support more formats than what is listed in\n        :meth:`extensions`.\n    '''\n\n    @staticmethod\n    def extensions():\n        '''Return accepted extensions for this loader'''\n        # See https://www.ffmpeg.org/general.html#Image-Formats\n        return ('bmp', 'dpx', 'exr', 'gif', 'ico', 'jpeg', 'jpg2000', 'jpg',\n                'jls', 'pam', 'pbm', 'pcx', 'pgm', 'pgmyuv', 'pic', 'png',\n                'ppm', 'ptx', 'sgi', 'ras', 'tga', 'tiff', 'webp', 'xbm',\n                'xface', 'xwd')\n\n    def load(self, filename):\n        try:\n            loader = ffImageLoader(filename)\n        except:\n            Logger.warning('Image: Unable to load image <%s>' % filename)\n            raise\n\n        # update internals\n        self.filename = filename\n        images = []\n\n        while True:\n            frame, t = loader.next_frame()\n            if frame is None:\n                break\n            images.append(frame)\n        if not len(images):\n            raise Exception('No image found in {}'.format(filename))\n\n        w, h = images[0].get_size()\n        ifmt = images[0].get_pixel_format()\n        if ifmt != 'rgba' and ifmt != 'rgb24':\n            fmt = 'rgba'\n            sws = SWScale(w, h, ifmt, ofmt=fmt)\n            for i, image in enumerate(images):\n                images[i] = sws.scale(image)\n        else:\n            fmt = ifmt if ifmt == 'rgba' else 'rgb'\n\n        return [ImageData(w, h, fmt, img.to_memoryview()[0], source_image=img)\n                for img in images]",
  "def extensions():\n        '''Return accepted extensions for this loader'''\n        # See https://www.ffmpeg.org/general.html#Image-Formats\n        return ('bmp', 'dpx', 'exr', 'gif', 'ico', 'jpeg', 'jpg2000', 'jpg',\n                'jls', 'pam', 'pbm', 'pcx', 'pgm', 'pgmyuv', 'pic', 'png',\n                'ppm', 'ptx', 'sgi', 'ras', 'tga', 'tiff', 'webp', 'xbm',\n                'xface', 'xwd')",
  "def load(self, filename):\n        try:\n            loader = ffImageLoader(filename)\n        except:\n            Logger.warning('Image: Unable to load image <%s>' % filename)\n            raise\n\n        # update internals\n        self.filename = filename\n        images = []\n\n        while True:\n            frame, t = loader.next_frame()\n            if frame is None:\n                break\n            images.append(frame)\n        if not len(images):\n            raise Exception('No image found in {}'.format(filename))\n\n        w, h = images[0].get_size()\n        ifmt = images[0].get_pixel_format()\n        if ifmt != 'rgba' and ifmt != 'rgb24':\n            fmt = 'rgba'\n            sws = SWScale(w, h, ifmt, ofmt=fmt)\n            for i, image in enumerate(images):\n                images[i] = sws.scale(image)\n        else:\n            fmt = ifmt if ifmt == 'rgba' else 'rgb'\n\n        return [ImageData(w, h, fmt, img.to_memoryview()[0], source_image=img)\n                for img in images]",
  "class ImageLoaderDDS(ImageLoaderBase):\n\n    @staticmethod\n    def extensions():\n        return ('dds', )\n\n    def load(self, filename):\n        try:\n            dds = DDSFile(filename=filename)\n        except:\n            Logger.warning('Image: Unable to load image <%s>' % filename)\n            raise\n\n        self.filename = filename\n        width, height = dds.size\n        im = ImageData(width, height, dds.dxt, dds.images[0], source=filename,\n                       flip_vertical=False)\n        if len(dds.images) > 1:\n            images = dds.images\n            images_size = dds.images_size\n            for index in range(1, len(dds.images)):\n                w, h = images_size[index]\n                data = images[index]\n                im.add_mipmap(index, w, h, data)\n        return [im]",
  "def extensions():\n        return ('dds', )",
  "def load(self, filename):\n        try:\n            dds = DDSFile(filename=filename)\n        except:\n            Logger.warning('Image: Unable to load image <%s>' % filename)\n            raise\n\n        self.filename = filename\n        width, height = dds.size\n        im = ImageData(width, height, dds.dxt, dds.images[0], source=filename,\n                       flip_vertical=False)\n        if len(dds.images) > 1:\n            images = dds.images\n            images_size = dds.images_size\n            for index in range(1, len(dds.images)):\n                w, h = images_size[index]\n                data = images[index]\n                im.add_mipmap(index, w, h, data)\n        return [im]",
  "class ImageLoaderSDL2(ImageLoaderBase):\n    '''Image loader based on SDL2_image'''\n\n    def _ensure_ext(self):\n        _img_sdl2.init()\n\n    @staticmethod\n    def extensions():\n        '''Return accepted extensions for this loader'''\n        return ('bmp', 'jpg', 'jpeg', 'jpe', 'lbm', 'pcx', 'png', 'pnm',\n                'tga', 'tiff', 'webp', 'xcf', 'xpm', 'xv')\n\n    @staticmethod\n    def can_save(fmt, is_bytesio):\n        return fmt in ('jpg', 'png')\n\n    @staticmethod\n    def can_load_memory():\n        return True\n\n    def load(self, filename):\n        if self._inline:\n            data = filename.read()\n            info = _img_sdl2.load_from_memory(data)\n        else:\n            info = _img_sdl2.load_from_filename(filename)\n        if not info:\n            Logger.warning('Image: Unable to load image <%s>' % filename)\n            raise Exception('SDL2: Unable to load image')\n\n        w, h, fmt, pixels, rowlength = info\n\n        # update internals\n        if not self._inline:\n            self.filename = filename\n        return [ImageData(\n            w, h, fmt, pixels, source=filename,\n            rowlength=rowlength)]\n\n    @staticmethod\n    def save(filename, width, height, pixelfmt, pixels, flipped, imagefmt):\n        _img_sdl2.save(filename, width, height, pixelfmt, pixels, flipped,\n                       imagefmt)\n        return True",
  "def _ensure_ext(self):\n        _img_sdl2.init()",
  "def extensions():\n        '''Return accepted extensions for this loader'''\n        return ('bmp', 'jpg', 'jpeg', 'jpe', 'lbm', 'pcx', 'png', 'pnm',\n                'tga', 'tiff', 'webp', 'xcf', 'xpm', 'xv')",
  "def can_save(fmt, is_bytesio):\n        return fmt in ('jpg', 'png')",
  "def can_load_memory():\n        return True",
  "def load(self, filename):\n        if self._inline:\n            data = filename.read()\n            info = _img_sdl2.load_from_memory(data)\n        else:\n            info = _img_sdl2.load_from_filename(filename)\n        if not info:\n            Logger.warning('Image: Unable to load image <%s>' % filename)\n            raise Exception('SDL2: Unable to load image')\n\n        w, h, fmt, pixels, rowlength = info\n\n        # update internals\n        if not self._inline:\n            self.filename = filename\n        return [ImageData(\n            w, h, fmt, pixels, source=filename,\n            rowlength=rowlength)]",
  "def save(filename, width, height, pixelfmt, pixels, flipped, imagefmt):\n        _img_sdl2.save(filename, width, height, pixelfmt, pixels, flipped,\n                       imagefmt)\n        return True",
  "class ImageLoaderPIL(ImageLoaderBase):\n    '''Image loader based on the PIL library.\n\n    .. versionadded:: 1.0.8\n\n    Support for GIF animation added.\n\n    Gif animation has a lot of issues(transparency/color depths... etc).\n    In order to keep it simple, what is implemented here is what is\n    natively supported by the PIL library.\n\n    As a general rule, try to use gifs that have no transparency.\n    Gif's with transparency will work but be prepared for some\n    artifacts until transparency support is improved.\n\n    '''\n\n    @staticmethod\n    def can_save(fmt, is_bytesio):\n        if is_bytesio:\n            return False\n        return fmt in ImageLoaderPIL.extensions()\n\n    @staticmethod\n    def can_load_memory():\n        return True\n\n    @staticmethod\n    def extensions():\n        '''Return accepted extensions for this loader'''\n        PILImage.init()\n        return tuple((ext_with_dot[1:] for ext_with_dot in PILImage.EXTENSION))\n\n    def _img_correct(self, _img_tmp):\n        '''Convert image to the correct format and orientation.\n        '''\n        # image loader work only with rgb/rgba image\n        if _img_tmp.mode.lower() not in ('rgb', 'rgba'):\n            try:\n                imc = _img_tmp.convert('RGBA')\n            except:\n                Logger.warning(\n                    'Image: Unable to convert image to rgba (was %s)' %\n                    (_img_tmp.mode.lower()))\n                raise\n            _img_tmp = imc\n\n        return _img_tmp\n\n    def _img_read(self, im):\n        '''Read images from an animated file.\n        '''\n        im.seek(0)\n\n        # Read all images inside\n        try:\n            img_ol = None\n            while True:\n                img_tmp = im\n                img_tmp = self._img_correct(img_tmp)\n                if img_ol and (hasattr(im, 'dispose') and not im.dispose):\n                    # paste new frame over old so as to handle\n                    # transparency properly\n                    img_ol.paste(img_tmp, (0, 0), img_tmp)\n                    img_tmp = img_ol\n                img_ol = img_tmp\n                yield ImageData(img_tmp.size[0], img_tmp.size[1],\n                                img_tmp.mode.lower(), img_tmp.tobytes())\n                im.seek(im.tell() + 1)\n        except EOFError:\n            pass\n\n    def load(self, filename):\n        try:\n            im = PILImage.open(filename)\n        except:\n            Logger.warning('Image: Unable to load image <%s>' % filename)\n            raise\n        # update internals\n        if not self._inline:\n            self.filename = filename\n        # returns an array of type ImageData len 1 if not a sequence image\n        return list(self._img_read(im))\n\n    @staticmethod\n    def save(filename, width, height, pixelfmt, pixels, flipped=False,\n             imagefmt=None):\n        image = PILImage.frombytes(pixelfmt.upper(), (width, height), pixels)\n        if flipped:\n            image = image.transpose(PILImage.FLIP_TOP_BOTTOM)\n        image.save(filename)\n        return True",
  "def can_save(fmt, is_bytesio):\n        if is_bytesio:\n            return False\n        return fmt in ImageLoaderPIL.extensions()",
  "def can_load_memory():\n        return True",
  "def extensions():\n        '''Return accepted extensions for this loader'''\n        PILImage.init()\n        return tuple((ext_with_dot[1:] for ext_with_dot in PILImage.EXTENSION))",
  "def _img_correct(self, _img_tmp):\n        '''Convert image to the correct format and orientation.\n        '''\n        # image loader work only with rgb/rgba image\n        if _img_tmp.mode.lower() not in ('rgb', 'rgba'):\n            try:\n                imc = _img_tmp.convert('RGBA')\n            except:\n                Logger.warning(\n                    'Image: Unable to convert image to rgba (was %s)' %\n                    (_img_tmp.mode.lower()))\n                raise\n            _img_tmp = imc\n\n        return _img_tmp",
  "def _img_read(self, im):\n        '''Read images from an animated file.\n        '''\n        im.seek(0)\n\n        # Read all images inside\n        try:\n            img_ol = None\n            while True:\n                img_tmp = im\n                img_tmp = self._img_correct(img_tmp)\n                if img_ol and (hasattr(im, 'dispose') and not im.dispose):\n                    # paste new frame over old so as to handle\n                    # transparency properly\n                    img_ol.paste(img_tmp, (0, 0), img_tmp)\n                    img_tmp = img_ol\n                img_ol = img_tmp\n                yield ImageData(img_tmp.size[0], img_tmp.size[1],\n                                img_tmp.mode.lower(), img_tmp.tobytes())\n                im.seek(im.tell() + 1)\n        except EOFError:\n            pass",
  "def load(self, filename):\n        try:\n            im = PILImage.open(filename)\n        except:\n            Logger.warning('Image: Unable to load image <%s>' % filename)\n            raise\n        # update internals\n        if not self._inline:\n            self.filename = filename\n        # returns an array of type ImageData len 1 if not a sequence image\n        return list(self._img_read(im))",
  "def save(filename, width, height, pixelfmt, pixels, flipped=False,\n             imagefmt=None):\n        image = PILImage.frombytes(pixelfmt.upper(), (width, height), pixels)\n        if flipped:\n            image = image.transpose(PILImage.FLIP_TOP_BOTTOM)\n        image.save(filename)\n        return True",
  "class ImageLoaderTex(ImageLoaderBase):\n\n    @staticmethod\n    def extensions():\n        return ('tex', )\n\n    def load(self, filename):\n        try:\n            fd = open(filename, 'rb')\n            if fd.read(4) != 'KTEX':\n                raise Exception('Invalid tex identifier')\n\n            headersize = unpack('I', fd.read(4))[0]\n            header = fd.read(headersize)\n            if len(header) != headersize:\n                raise Exception('Truncated tex header')\n\n            info = json.loads(header)\n            data = fd.read()\n            if len(data) != info['datalen']:\n                raise Exception('Truncated tex data')\n\n        except:\n            Logger.warning('Image: Image <%s> is corrupted' % filename)\n            raise\n\n        width, height = info['image_size']\n        tw, th = info['texture_size']\n\n        images = [data]\n        im = ImageData(width, height, str(info['format']), images[0],\n                       source=filename)\n        '''\n        if len(dds.images) > 1:\n            images = dds.images\n            images_size = dds.images_size\n            for index in range(1, len(dds.images)):\n                w, h = images_size[index]\n                data = images[index]\n                im.add_mipmap(index, w, h, data)\n        '''\n        return [im]",
  "def extensions():\n        return ('tex', )",
  "def load(self, filename):\n        try:\n            fd = open(filename, 'rb')\n            if fd.read(4) != 'KTEX':\n                raise Exception('Invalid tex identifier')\n\n            headersize = unpack('I', fd.read(4))[0]\n            header = fd.read(headersize)\n            if len(header) != headersize:\n                raise Exception('Truncated tex header')\n\n            info = json.loads(header)\n            data = fd.read()\n            if len(data) != info['datalen']:\n                raise Exception('Truncated tex data')\n\n        except:\n            Logger.warning('Image: Image <%s> is corrupted' % filename)\n            raise\n\n        width, height = info['image_size']\n        tw, th = info['texture_size']\n\n        images = [data]\n        im = ImageData(width, height, str(info['format']), images[0],\n                       source=filename)\n        '''\n        if len(dds.images) > 1:\n            images = dds.images\n            images_size = dds.images_size\n            for index in range(1, len(dds.images)):\n                w, h = images_size[index]\n                data = images[index]\n                im.add_mipmap(index, w, h, data)\n        '''\n        return [im]",
  "class ImageLoaderPygame(ImageLoaderBase):\n    '''Image loader based on the PIL library'''\n\n    @deprecated(\n        msg='Pygame has been deprecated and will be removed after 1.11.0')\n    def __init__(self, *largs, **kwargs):\n        super(ImageLoaderPygame, self).__init__(*largs, **kwargs)\n\n    @staticmethod\n    def extensions():\n        '''Return accepted extensions for this loader'''\n        # under OS X, i got with \"pygame.error: File is not a Windows BMP\n        # file\". documentation said: The image module is a required dependency\n        # of Pygame, but it only optionally supports any extended file formats.\n        # By default it can only load uncompressed BMP image\n        if pygame.image.get_extended() == 0:\n            return ('bmp', )\n        return ('jpg', 'jpeg', 'jpe', 'png', 'bmp', 'pcx', 'tga', 'tiff',\n                'tif', 'lbm', 'pbm', 'ppm', 'xpm')\n\n    @staticmethod\n    def can_save(fmt, is_bytesio):\n        if is_bytesio:\n            return False\n        return fmt in ('png', 'jpg')\n\n    @staticmethod\n    def can_load_memory():\n        return True\n\n    def load(self, filename):\n        if not filename:\n            import traceback\n            traceback.print_stack()\n            return\n        try:\n            im = None\n            if self._inline:\n                im = pygame.image.load(filename, 'x.{}'.format(self._ext))\n            elif isfile(filename):\n                with open(filename, 'rb') as fd:\n                    im = pygame.image.load(fd)\n            elif isinstance(filename, bytes):\n                try:\n                    fname = filename.decode()\n                    if isfile(fname):\n                        with open(fname, 'rb') as fd:\n                            im = pygame.image.load(fd)\n                except UnicodeDecodeError:\n                    pass\n            if im is None:\n                im = pygame.image.load(filename)\n        except:\n            # Logger.warning(type(filename)('Image: Unable to load image <%s>')\n            #               % filename)\n            raise\n\n        fmt = ''\n        if im.get_bytesize() == 3 and not im.get_colorkey():\n            fmt = 'rgb'\n        elif im.get_bytesize() == 4:\n            fmt = 'rgba'\n\n        # image loader work only with rgb/rgba image\n        if fmt not in ('rgb', 'rgba'):\n            try:\n                imc = im.convert(32)\n                fmt = 'rgba'\n            except:\n                try:\n                    imc = im.convert_alpha()\n                    fmt = 'rgba'\n                except:\n                    Logger.warning(\n                        'Image: Unable to convert image %r to rgba (was %r)' %\n                        (filename, im.fmt))\n                    raise\n            im = imc\n\n        # update internals\n        if not self._inline:\n            self.filename = filename\n        data = pygame.image.tostring(im, fmt.upper())\n        return [ImageData(im.get_width(), im.get_height(),\n                fmt, data, source=filename)]\n\n    @staticmethod\n    def save(filename, width, height, pixelfmt, pixels, flipped,\n             imagefmt=None):\n        surface = pygame.image.fromstring(\n            pixels, (width, height), pixelfmt.upper(), flipped)\n        pygame.image.save(surface, filename)\n        return True",
  "def __init__(self, *largs, **kwargs):\n        super(ImageLoaderPygame, self).__init__(*largs, **kwargs)",
  "def extensions():\n        '''Return accepted extensions for this loader'''\n        # under OS X, i got with \"pygame.error: File is not a Windows BMP\n        # file\". documentation said: The image module is a required dependency\n        # of Pygame, but it only optionally supports any extended file formats.\n        # By default it can only load uncompressed BMP image\n        if pygame.image.get_extended() == 0:\n            return ('bmp', )\n        return ('jpg', 'jpeg', 'jpe', 'png', 'bmp', 'pcx', 'tga', 'tiff',\n                'tif', 'lbm', 'pbm', 'ppm', 'xpm')",
  "def can_save(fmt, is_bytesio):\n        if is_bytesio:\n            return False\n        return fmt in ('png', 'jpg')",
  "def can_load_memory():\n        return True",
  "def load(self, filename):\n        if not filename:\n            import traceback\n            traceback.print_stack()\n            return\n        try:\n            im = None\n            if self._inline:\n                im = pygame.image.load(filename, 'x.{}'.format(self._ext))\n            elif isfile(filename):\n                with open(filename, 'rb') as fd:\n                    im = pygame.image.load(fd)\n            elif isinstance(filename, bytes):\n                try:\n                    fname = filename.decode()\n                    if isfile(fname):\n                        with open(fname, 'rb') as fd:\n                            im = pygame.image.load(fd)\n                except UnicodeDecodeError:\n                    pass\n            if im is None:\n                im = pygame.image.load(filename)\n        except:\n            # Logger.warning(type(filename)('Image: Unable to load image <%s>')\n            #               % filename)\n            raise\n\n        fmt = ''\n        if im.get_bytesize() == 3 and not im.get_colorkey():\n            fmt = 'rgb'\n        elif im.get_bytesize() == 4:\n            fmt = 'rgba'\n\n        # image loader work only with rgb/rgba image\n        if fmt not in ('rgb', 'rgba'):\n            try:\n                imc = im.convert(32)\n                fmt = 'rgba'\n            except:\n                try:\n                    imc = im.convert_alpha()\n                    fmt = 'rgba'\n                except:\n                    Logger.warning(\n                        'Image: Unable to convert image %r to rgba (was %r)' %\n                        (filename, im.fmt))\n                    raise\n            im = imc\n\n        # update internals\n        if not self._inline:\n            self.filename = filename\n        data = pygame.image.tostring(im, fmt.upper())\n        return [ImageData(im.get_width(), im.get_height(),\n                fmt, data, source=filename)]",
  "def save(filename, width, height, pixelfmt, pixels, flipped,\n             imagefmt=None):\n        surface = pygame.image.fromstring(\n            pixels, (width, height), pixelfmt.upper(), flipped)\n        pygame.image.save(surface, filename)\n        return True",
  "class ImageData(object):\n    '''Container for images and mipmap images.\n    The container will always have at least the mipmap level 0.\n    '''\n\n    __slots__ = ('fmt', 'mipmaps', 'source', 'flip_vertical', 'source_image')\n    _supported_fmts = ('rgb', 'bgr', 'rgba', 'bgra', 'argb', 'abgr',\n                       's3tc_dxt1', 's3tc_dxt3', 's3tc_dxt5', 'pvrtc_rgb2',\n                       'pvrtc_rgb4', 'pvrtc_rgba2', 'pvrtc_rgba4', 'etc1_rgb8')\n\n    def __init__(self, width, height, fmt, data, source=None,\n                 flip_vertical=True, source_image=None,\n                 rowlength=0):\n        assert fmt in ImageData._supported_fmts\n\n        #: Decoded image format, one of a available texture format\n        self.fmt = fmt\n\n        #: Data for each mipmap.\n        self.mipmaps = {}\n        self.add_mipmap(0, width, height, data, rowlength)\n\n        #: Image source, if available\n        self.source = source\n\n        #: Indicate if the texture will need to be vertically flipped\n        self.flip_vertical = flip_vertical\n\n        # the original image, which we might need to save if it is a memoryview\n        self.source_image = source_image\n\n    def release_data(self):\n        mm = self.mipmaps\n        for item in mm.values():\n            item[2] = None\n            self.source_image = None\n\n    @property\n    def width(self):\n        '''Image width in pixels.\n        (If the image is mipmapped, it will use the level 0)\n        '''\n        return self.mipmaps[0][0]\n\n    @property\n    def height(self):\n        '''Image height in pixels.\n        (If the image is mipmapped, it will use the level 0)\n        '''\n        return self.mipmaps[0][1]\n\n    @property\n    def data(self):\n        '''Image data.\n        (If the image is mipmapped, it will use the level 0)\n        '''\n        return self.mipmaps[0][2]\n\n    @property\n    def rowlength(self):\n        '''Image rowlength.\n        (If the image is mipmapped, it will use the level 0)\n\n        .. versionadded:: 1.9.0\n        '''\n        return self.mipmaps[0][3]\n\n    @property\n    def size(self):\n        '''Image (width, height) in pixels.\n        (If the image is mipmapped, it will use the level 0)\n        '''\n        mm = self.mipmaps[0]\n        return mm[0], mm[1]\n\n    @property\n    def have_mipmap(self):\n        return len(self.mipmaps) > 1\n\n    def __repr__(self):\n        return ('<ImageData width=%d height=%d fmt=%s '\n                'source=%r with %d images>' % (\n                    self.width, self.height, self.fmt,\n                    self.source, len(self.mipmaps)))\n\n    def add_mipmap(self, level, width, height, data, rowlength):\n        '''Add a image for a specific mipmap level.\n\n        .. versionadded:: 1.0.7\n        '''\n        self.mipmaps[level] = [int(width), int(height), data, rowlength]\n\n    def get_mipmap(self, level):\n        '''Get the mipmap image at a specific level if it exists\n\n        .. versionadded:: 1.0.7\n        '''\n        if level == 0:\n            return (self.width, self.height, self.data, self.rowlength)\n        assert level < len(self.mipmaps)\n        return self.mipmaps[level]\n\n    def iterate_mipmaps(self):\n        '''Iterate over all mipmap images available.\n\n        .. versionadded:: 1.0.7\n        '''\n        mm = self.mipmaps\n        for x in range(len(mm)):\n            item = mm.get(x, None)\n            if item is None:\n                raise Exception('Invalid mipmap level, found empty one')\n            yield x, item[0], item[1], item[2], item[3]",
  "class ImageLoaderBase(object):\n    '''Base to implement an image loader.'''\n\n    __slots__ = ('_texture', '_data', 'filename', 'keep_data',\n                 '_mipmap', '_nocache', '_ext', '_inline')\n\n    def __init__(self, filename, **kwargs):\n        self._mipmap = kwargs.get('mipmap', False)\n        self.keep_data = kwargs.get('keep_data', False)\n        self._nocache = kwargs.get('nocache', False)\n        self._ext = kwargs.get('ext')\n        self._inline = kwargs.get('inline')\n        self.filename = filename\n        if self._inline:\n            self._data = self.load(kwargs.get('rawdata'))\n        else:\n            self._data = self.load(filename)\n        self._textures = None\n\n    def load(self, filename):\n        '''Load an image'''\n        return None\n\n    @staticmethod\n    def can_save(fmt, is_bytesio=False):\n        '''Indicate if the loader can save the Image object\n\n        .. versionchanged:: 1.11.0\n            Parameter `fmt` and `is_bytesio` added\n        '''\n        return False\n\n    @staticmethod\n    def can_load_memory():\n        '''Indicate if the loader can load an image by passing data\n        '''\n        return False\n\n    @staticmethod\n    def save(*largs, **kwargs):\n        raise NotImplementedError()\n\n    def populate(self):\n        self._textures = []\n        fname = self.filename\n        if __debug__:\n            Logger.trace('Image: %r, populate to textures (%d)' %\n                         (fname, len(self._data)))\n\n        for count in range(len(self._data)):\n\n            # first, check if a texture with the same name already exist in the\n            # cache\n            chr = type(fname)\n            uid = chr(u'%s|%d|%d') % (fname, self._mipmap, count)\n            texture = Cache.get('kv.texture', uid)\n\n            # if not create it and append to the cache\n            if texture is None:\n                imagedata = self._data[count]\n                source = '{}{}|'.format(\n                    'zip|' if fname.endswith('.zip') else '',\n                    self._nocache)\n                imagedata.source = chr(source) + uid\n                texture = Texture.create_from_data(\n                    imagedata, mipmap=self._mipmap)\n                if not self._nocache:\n                    Cache.append('kv.texture', uid, texture)\n                if imagedata.flip_vertical:\n                    texture.flip_vertical()\n\n            # set as our current texture\n            self._textures.append(texture)\n\n            # release data if ask\n            if not self.keep_data:\n                self._data[count].release_data()\n\n    @property\n    def width(self):\n        '''Image width\n        '''\n        return self._data[0].width\n\n    @property\n    def height(self):\n        '''Image height\n        '''\n        return self._data[0].height\n\n    @property\n    def size(self):\n        '''Image size (width, height)\n        '''\n        return (self._data[0].width, self._data[0].height)\n\n    @property\n    def texture(self):\n        '''Get the image texture (created on the first call)\n        '''\n        if self._textures is None:\n            self.populate()\n        if self._textures is None:\n            return None\n        return self._textures[0]\n\n    @property\n    def textures(self):\n        '''Get the textures list (for mipmapped image or animated image)\n\n        .. versionadded:: 1.0.8\n        '''\n        if self._textures is None:\n            self.populate()\n        return self._textures\n\n    @property\n    def nocache(self):\n        '''Indicate if the texture will not be stored in the cache\n\n        .. versionadded:: 1.6.0\n        '''\n        return self._nocache",
  "class ImageLoader(object):\n\n    loaders = []\n\n    @staticmethod\n    def zip_loader(filename, **kwargs):\n        '''Read images from an zip file.\n\n        .. versionadded:: 1.0.8\n\n        Returns an Image with a list of type ImageData stored in Image._data\n        '''\n        # read zip in memory for faster access\n        _file = BytesIO(open(filename, 'rb').read())\n        # read all images inside the zip\n        z = zipfile.ZipFile(_file)\n        image_data = []\n        # sort filename list\n        znamelist = z.namelist()\n        znamelist.sort()\n        image = None\n        for zfilename in znamelist:\n            try:\n                # read file and store it in mem with fileIO struct around it\n                tmpfile = BytesIO(z.read(zfilename))\n                ext = zfilename.split('.')[-1].lower()\n                im = None\n                for loader in ImageLoader.loaders:\n                    if (ext not in loader.extensions() or\n                            not loader.can_load_memory()):\n                        continue\n                    Logger.debug('Image%s: Load <%s> from <%s>' %\n                                 (loader.__name__[11:], zfilename, filename))\n                    try:\n                        im = loader(zfilename, ext=ext, rawdata=tmpfile,\n                                    inline=True, **kwargs)\n                    except:\n                        # Loader failed, continue trying.\n                        continue\n                    break\n                if im is not None:\n                    # append ImageData to local variable before its\n                    # overwritten\n                    image_data.append(im._data[0])\n                    image = im\n                # else: if not image file skip to next\n            except:\n                Logger.warning('Image: Unable to load image'\n                               '<%s> in zip <%s> trying to continue...'\n                               % (zfilename, filename))\n        z.close()\n        if len(image_data) == 0:\n            raise Exception('no images in zip <%s>' % filename)\n        # replace Image.Data with the array of all the images in the zip\n        image._data = image_data\n        image.filename = filename\n        return image\n\n    @staticmethod\n    def register(defcls):\n        ImageLoader.loaders.append(defcls)\n\n    @staticmethod\n    def load(filename, **kwargs):\n\n        # atlas ?\n        if filename[:8] == 'atlas://':\n            # remove the url\n            rfn = filename[8:]\n            # last field is the ID\n            try:\n                rfn, uid = rfn.rsplit('/', 1)\n            except ValueError:\n                raise ValueError(\n                    'Image: Invalid %s name for atlas' % filename)\n\n            # search if we already got the atlas loaded\n            atlas = Cache.get('kv.atlas', rfn)\n\n            # atlas already loaded, so reupload the missing texture in cache,\n            # because when it's not in use, the texture can be removed from the\n            # kv.texture cache.\n            if atlas:\n                texture = atlas[uid]\n                fn = 'atlas://%s/%s' % (rfn, uid)\n                cid = '{}|{:d}|{:d}'.format(fn, False, 0)\n                Cache.append('kv.texture', cid, texture)\n                return Image(texture)\n\n            # search with resource\n            afn = rfn\n            if not afn.endswith('.atlas'):\n                afn += '.atlas'\n            afn = resource_find(afn)\n            if not afn:\n                raise Exception('Unable to find %r atlas' % afn)\n            atlas = Atlas(afn)\n            Cache.append('kv.atlas', rfn, atlas)\n            # first time, fill our texture cache.\n            for nid, texture in atlas.textures.items():\n                fn = 'atlas://%s/%s' % (rfn, nid)\n                cid = '{}|{:d}|{:d}'.format(fn, False, 0)\n                Cache.append('kv.texture', cid, texture)\n            return Image(atlas[uid])\n\n        # extract extensions\n        ext = filename.split('.')[-1].lower()\n\n        # prevent url querystrings\n        if filename.startswith((('http://', 'https://'))):\n            ext = ext.split('?')[0]\n\n        filename = resource_find(filename)\n\n        # special case. When we are trying to load a \"zip\" file with image, we\n        # will use the special zip_loader in ImageLoader. This might return a\n        # sequence of images contained in the zip.\n        if ext == 'zip':\n            return ImageLoader.zip_loader(filename)\n        else:\n            im = None\n            # Get actual image format instead of extension if possible\n            ext = imghdr.what(filename) or ext\n            for loader in ImageLoader.loaders:\n                if ext not in loader.extensions():\n                    continue\n                Logger.debug('Image%s: Load <%s>' %\n                             (loader.__name__[11:], filename))\n                im = loader(filename, **kwargs)\n                break\n            if im is None:\n                raise Exception('Unknown <%s> type, no loader found.' % ext)\n            return im",
  "class Image(EventDispatcher):\n    '''Load an image and store the size and texture.\n\n    .. versionchanged:: 1.0.7\n\n        `mipmap` attribute has been added. The `texture_mipmap` and\n        `texture_rectangle` have been deleted.\n\n    .. versionchanged:: 1.0.8\n\n        An Image widget can change its texture. A new event 'on_texture' has\n        been introduced. New methods for handling sequenced animation have been\n        added.\n\n    :Parameters:\n        `arg`: can be a string (str), Texture, BytesIO or Image object\n            A string path to the image file or data URI to be loaded; or a\n            Texture object, which will be wrapped in an Image object; or a\n            BytesIO object containing raw image data; or an already existing\n            image object, in which case, a real copy of the given image object\n            will be returned.\n        `keep_data`: bool, defaults to False\n            Keep the image data when the texture is created.\n        `mipmap`: bool, defaults to False\n            Create mipmap for the texture.\n        `anim_delay`: float, defaults to .25\n            Delay in seconds between each animation frame. Lower values means\n            faster animation.\n        `ext`: str, only with BytesIO `arg`\n            File extension to use in determining how to load raw image data.\n        `filename`: str, only with BytesIO `arg`\n            Filename to use in the image cache for raw image data.\n    '''\n\n    copy_attributes = ('_size', '_filename', '_texture', '_image',\n                       '_mipmap', '_nocache')\n\n    data_uri_re = re.compile(r'^data:image/([^;,]*)(;[^,]*)?,(.*)$')\n\n    _anim_ev = None\n\n    def __init__(self, arg, **kwargs):\n        # this event should be fired on animation of sequenced img's\n        self.register_event_type('on_texture')\n\n        super(Image, self).__init__()\n\n        self._mipmap = kwargs.get('mipmap', False)\n        self._keep_data = kwargs.get('keep_data', False)\n        self._nocache = kwargs.get('nocache', False)\n        self._size = [0, 0]\n        self._image = None\n        self._filename = None\n        self._texture = None\n        self._anim_available = False\n        self._anim_index = 0\n        self._anim_delay = 0\n        self.anim_delay = kwargs.get('anim_delay', .25)\n        # indicator of images having been loded in cache\n        self._iteration_done = False\n\n        if isinstance(arg, Image):\n            for attr in Image.copy_attributes:\n                self.__setattr__(attr, arg.__getattribute__(attr))\n        elif type(arg) in (Texture, TextureRegion):\n            if not hasattr(self, 'textures'):\n                self.textures = []\n                self.textures.append(arg)\n            self._texture = arg\n            self._size = self.texture.size\n        elif isinstance(arg, ImageLoaderBase):\n            self.image = arg\n        elif isinstance(arg, BytesIO):\n            ext = kwargs.get('ext', None)\n            if not ext:\n                raise Exception('Inline loading require \"ext\" parameter')\n            filename = kwargs.get('filename')\n            if not filename:\n                self._nocache = True\n                filename = '__inline__'\n            self.load_memory(arg, ext, filename)\n        elif isinstance(arg, string_types):\n            groups = self.data_uri_re.findall(arg)\n            if groups:\n                self._nocache = True\n                imtype, optstr, data = groups[0]\n                options = [o for o in optstr.split(';') if o]\n                ext = imtype\n                isb64 = 'base64' in options\n                if data:\n                    if isb64:\n                        data = b64decode(data)\n                    self.load_memory(BytesIO(data), ext)\n            else:\n                self.filename = arg\n        else:\n            raise Exception('Unable to load image type {0!r}'.format(arg))\n\n    def remove_from_cache(self):\n        '''Remove the Image from cache. This facilitates re-loading of\n        images from disk in case the image content has changed.\n\n        .. versionadded:: 1.3.0\n\n        Usage::\n\n            im = CoreImage('1.jpg')\n            # -- do something --\n            im.remove_from_cache()\n            im = CoreImage('1.jpg')\n            # this time image will be re-loaded from disk\n\n        '''\n        count = 0\n        f = self.filename\n        pat = type(f)(u'%s|%d|%d')\n        uid = pat % (f, self._mipmap, count)\n        Cache.remove(\"kv.image\", uid)\n        while Cache.get(\"kv.texture\", uid):\n            Cache.remove(\"kv.texture\", uid)\n            count += 1\n            uid = pat % (f, self._mipmap, count)\n\n    def _anim(self, *largs):\n        if not self._image:\n            return\n        textures = self.image.textures\n        if self._anim_index >= len(textures):\n            self._anim_index = 0\n        self._texture = self.image.textures[self._anim_index]\n        self.dispatch('on_texture')\n        self._anim_index += 1\n        self._anim_index %= len(self._image.textures)\n\n    def anim_reset(self, allow_anim):\n        '''Reset an animation if available.\n\n        .. versionadded:: 1.0.8\n\n        :Parameters:\n            `allow_anim`: bool\n                Indicate whether the animation should restart playing or not.\n\n        Usage::\n\n            # start/reset animation\n            image.anim_reset(True)\n\n            # or stop the animation\n            image.anim_reset(False)\n\n        You can change the animation speed whilst it is playing::\n\n            # Set to 20 FPS\n            image.anim_delay = 1 / 20.\n\n        '''\n        # stop animation\n        if self._anim_ev is not None:\n            self._anim_ev.cancel()\n            self._anim_ev = None\n\n        if allow_anim and self._anim_available and self._anim_delay >= 0:\n            self._anim_ev = Clock.schedule_interval(self._anim,\n                                                    self.anim_delay)\n            self._anim()\n\n    def _get_anim_delay(self):\n        return self._anim_delay\n\n    def _set_anim_delay(self, x):\n        if self._anim_delay == x:\n            return\n        self._anim_delay = x\n        if self._anim_available:\n            if self._anim_ev is not None:\n                self._anim_ev.cancel()\n                self._anim_ev = None\n\n            if self._anim_delay >= 0:\n                self._anim_ev = Clock.schedule_interval(self._anim,\n                                                        self._anim_delay)\n\n    anim_delay = property(_get_anim_delay, _set_anim_delay)\n    '''Delay between each animation frame. A lower value means faster\n    animation.\n\n    .. versionadded:: 1.0.8\n    '''\n\n    @property\n    def anim_available(self):\n        '''Return True if this Image instance has animation available.\n\n        .. versionadded:: 1.0.8\n        '''\n        return self._anim_available\n\n    @property\n    def anim_index(self):\n        '''Return the index number of the image currently in the texture.\n\n        .. versionadded:: 1.0.8\n        '''\n        return self._anim_index\n\n    def _img_iterate(self, *largs):\n        if not self.image or self._iteration_done:\n            return\n        self._iteration_done = True\n        imgcount = len(self.image.textures)\n        if imgcount > 1:\n            self._anim_available = True\n            self.anim_reset(True)\n        self._texture = self.image.textures[0]\n\n    def on_texture(self, *largs):\n        '''This event is fired when the texture reference or content has\n           changed. It is normally used for sequenced images.\n\n        .. versionadded:: 1.0.8\n        '''\n        pass\n\n    @staticmethod\n    def load(filename, **kwargs):\n        '''Load an image\n\n        :Parameters:\n            `filename`: str\n                Filename of the image.\n            `keep_data`: bool, defaults to False\n                Keep the image data when the texture is created.\n        '''\n        kwargs.setdefault('keep_data', False)\n        return Image(filename, **kwargs)\n\n    def _get_image(self):\n        return self._image\n\n    def _set_image(self, image):\n        self._image = image\n        if hasattr(image, 'filename'):\n            self._filename = image.filename\n        if image:\n            self._size = (self.image.width, self.image.height)\n\n    image = property(_get_image, _set_image,\n                     doc='Get/set the data image object')\n\n    def _get_filename(self):\n        return self._filename\n\n    def _set_filename(self, value):\n        if value is None or value == self._filename:\n            return\n        self._filename = value\n\n        # construct uid as a key for Cache\n        f = self.filename\n        uid = type(f)(u'%s|%d|%d') % (f, self._mipmap, 0)\n\n        # in case of Image have been asked with keep_data\n        # check the kv.image cache instead of texture.\n        image = Cache.get('kv.image', uid)\n        if image:\n            # we found an image, yeah ! but reset the texture now.\n            self.image = image\n            # if image.__class__ is core image then it's a texture\n            # from atlas or other sources and has no data so skip\n            if (image.__class__ != self.__class__ and\n                    not image.keep_data and self._keep_data):\n                self.remove_from_cache()\n                self._filename = ''\n                self._set_filename(value)\n            else:\n                self._texture = None\n            return\n        else:\n            # if we already got a texture, it will be automatically reloaded.\n            _texture = Cache.get('kv.texture', uid)\n            if _texture:\n                self._texture = _texture\n                return\n\n        # if image not already in cache then load\n        tmpfilename = self._filename\n        image = ImageLoader.load(\n            self._filename, keep_data=self._keep_data,\n            mipmap=self._mipmap, nocache=self._nocache)\n        self._filename = tmpfilename\n        # put the image into the cache if needed\n        if isinstance(image, Texture):\n            self._texture = image\n            self._size = image.size\n        else:\n            self.image = image\n            if not self._nocache:\n                Cache.append('kv.image', uid, self.image)\n\n    filename = property(_get_filename, _set_filename,\n                        doc='Get/set the filename of image')\n\n    def load_memory(self, data, ext, filename='__inline__'):\n        '''(internal) Method to load an image from raw data.\n        '''\n        self._filename = filename\n\n        # see if there is a available loader for it\n        loaders = [loader for loader in ImageLoader.loaders if\n                   loader.can_load_memory() and\n                   ext in loader.extensions()]\n        if not loaders:\n            raise Exception('No inline loader found to load {}'.format(ext))\n        image = loaders[0](filename, ext=ext, rawdata=data, inline=True,\n                nocache=self._nocache, mipmap=self._mipmap,\n                keep_data=self._keep_data)\n        if isinstance(image, Texture):\n            self._texture = image\n            self._size = image.size\n        else:\n            self.image = image\n\n    @property\n    def size(self):\n        '''Image size (width, height)\n        '''\n        return self._size\n\n    @property\n    def width(self):\n        '''Image width\n        '''\n        return self._size[0]\n\n    @property\n    def height(self):\n        '''Image height\n        '''\n        return self._size[1]\n\n    @property\n    def texture(self):\n        '''Texture of the image'''\n        if self.image:\n            if not self._iteration_done:\n                self._img_iterate()\n        return self._texture\n\n    @property\n    def nocache(self):\n        '''Indicate whether the texture will not be stored in the cache or not.\n\n        .. versionadded:: 1.6.0\n        '''\n        return self._nocache\n\n    def save(self, filename, flipped=False, fmt=None):\n        '''Save image texture to file.\n\n        The filename should have the '.png' extension because the texture data\n        read from the GPU is in the RGBA format. '.jpg' might work but has not\n        been heavily tested so some providers might break when using it.\n        Any other extensions are not officially supported.\n\n        The flipped parameter flips the saved image vertically, and\n        defaults to False.\n\n        Example::\n\n            # Save an core image object\n            from kivy.core.image import Image\n            img = Image('hello.png')\n            img.save('hello2.png')\n\n            # Save a texture\n            texture = Texture.create(...)\n            img = Image(texture)\n            img.save('hello3.png')\n\n        .. versionadded:: 1.7.0\n\n        .. versionchanged:: 1.8.0\n            Parameter `flipped` added to flip the image before saving, default\n            to False.\n\n        .. versionchanged:: 1.11.0\n            Parameter `fmt` added to force the output format of the file\n            Filename can now be a BytesIO object.\n\n        '''\n        is_bytesio = False\n        if isinstance(filename, BytesIO):\n            is_bytesio = True\n            if not fmt:\n                raise Exception(\n                    \"You must specify a format to save into a BytesIO object\")\n        elif fmt is None:\n            fmt = self._find_format_from_filename(filename)\n\n        pixels = None\n        size = None\n        loaders = [\n            x for x in ImageLoader.loaders\n            if x.can_save(fmt, is_bytesio=is_bytesio)\n        ]\n        if not loaders:\n            return False\n        loader = loaders[0]\n\n        if self.image:\n            # we might have a ImageData object to use\n            data = self.image._data[0]\n            if data.data is not None:\n                if data.fmt in ('rgba', 'rgb'):\n                    # fast path, use the \"raw\" data when keep_data is used\n                    size = data.width, data.height\n                    pixels = data.data\n\n                else:\n                    # the format is not rgba, we need to convert it.\n                    # use texture for that.\n                    self.populate()\n\n        if pixels is None and self._texture:\n            # use the texture pixels\n            size = self._texture.size\n            pixels = self._texture.pixels\n\n        if pixels is None:\n            return False\n\n        l_pixels = len(pixels)\n        if l_pixels == size[0] * size[1] * 3:\n            pixelfmt = 'rgb'\n        elif l_pixels == size[0] * size[1] * 4:\n            pixelfmt = 'rgba'\n        else:\n            raise Exception('Unable to determine the format of the pixels')\n        return loader.save(\n            filename, size[0], size[1], pixelfmt, pixels, flipped, fmt)\n\n    def _find_format_from_filename(self, filename):\n        ext = filename.rsplit(\".\", 1)[-1].lower()\n        if ext in {\n                'bmp', 'jpe', 'lbm', 'pcx', 'png', 'pnm',\n                'tga', 'tiff', 'webp', 'xcf', 'xpm', 'xv'}:\n            return ext\n        elif ext in ('jpg', 'jpeg'):\n            return 'jpg'\n        elif ext in ('b64', 'base64'):\n            return 'base64'\n        return None\n\n    def read_pixel(self, x, y):\n        '''For a given local x/y position, return the pixel color at that\n        position.\n\n        .. warning::\n            This function can only be used with images loaded with the\n            keep_data=True keyword. For example::\n\n                m = Image.load('image.png', keep_data=True)\n                color = m.read_pixel(150, 150)\n\n        :Parameters:\n            `x`: int\n                Local x coordinate of the pixel in question.\n            `y`: int\n                Local y coordinate of the pixel in question.\n        '''\n        data = self.image._data[0]\n\n        # can't use this function without ImageData\n        if data.data is None:\n            raise EOFError('Image data is missing, make sure that image is'\n                           'loaded with keep_data=True keyword.')\n\n        # check bounds\n        x, y = int(x), int(y)\n        if not (0 <= x < data.width and 0 <= y < data.height):\n            raise IndexError('Position (%d, %d) is out of range.' % (x, y))\n\n        assert data.fmt in ImageData._supported_fmts\n        size = 3 if data.fmt in ('rgb', 'bgr') else 4\n        index = y * data.width * size + x * size\n        raw = bytearray(data.data[index:index + size])\n        color = [c / 255.0 for c in raw]\n\n        bgr_flag = False\n        if data.fmt == 'argb':\n            color.reverse()  # bgra\n            bgr_flag = True\n        elif data.fmt == 'abgr':\n            color.reverse()  # rgba\n\n        # conversion for BGR->RGB, BGRA->RGBA format\n        if bgr_flag or data.fmt in ('bgr', 'bgra'):\n            color[0], color[2] = color[2], color[0]\n\n        return color",
  "def load(filename):\n    '''Load an image'''\n    return Image.load(filename)",
  "def __init__(self, width, height, fmt, data, source=None,\n                 flip_vertical=True, source_image=None,\n                 rowlength=0):\n        assert fmt in ImageData._supported_fmts\n\n        #: Decoded image format, one of a available texture format\n        self.fmt = fmt\n\n        #: Data for each mipmap.\n        self.mipmaps = {}\n        self.add_mipmap(0, width, height, data, rowlength)\n\n        #: Image source, if available\n        self.source = source\n\n        #: Indicate if the texture will need to be vertically flipped\n        self.flip_vertical = flip_vertical\n\n        # the original image, which we might need to save if it is a memoryview\n        self.source_image = source_image",
  "def release_data(self):\n        mm = self.mipmaps\n        for item in mm.values():\n            item[2] = None\n            self.source_image = None",
  "def width(self):\n        '''Image width in pixels.\n        (If the image is mipmapped, it will use the level 0)\n        '''\n        return self.mipmaps[0][0]",
  "def height(self):\n        '''Image height in pixels.\n        (If the image is mipmapped, it will use the level 0)\n        '''\n        return self.mipmaps[0][1]",
  "def data(self):\n        '''Image data.\n        (If the image is mipmapped, it will use the level 0)\n        '''\n        return self.mipmaps[0][2]",
  "def rowlength(self):\n        '''Image rowlength.\n        (If the image is mipmapped, it will use the level 0)\n\n        .. versionadded:: 1.9.0\n        '''\n        return self.mipmaps[0][3]",
  "def size(self):\n        '''Image (width, height) in pixels.\n        (If the image is mipmapped, it will use the level 0)\n        '''\n        mm = self.mipmaps[0]\n        return mm[0], mm[1]",
  "def have_mipmap(self):\n        return len(self.mipmaps) > 1",
  "def __repr__(self):\n        return ('<ImageData width=%d height=%d fmt=%s '\n                'source=%r with %d images>' % (\n                    self.width, self.height, self.fmt,\n                    self.source, len(self.mipmaps)))",
  "def add_mipmap(self, level, width, height, data, rowlength):\n        '''Add a image for a specific mipmap level.\n\n        .. versionadded:: 1.0.7\n        '''\n        self.mipmaps[level] = [int(width), int(height), data, rowlength]",
  "def get_mipmap(self, level):\n        '''Get the mipmap image at a specific level if it exists\n\n        .. versionadded:: 1.0.7\n        '''\n        if level == 0:\n            return (self.width, self.height, self.data, self.rowlength)\n        assert level < len(self.mipmaps)\n        return self.mipmaps[level]",
  "def iterate_mipmaps(self):\n        '''Iterate over all mipmap images available.\n\n        .. versionadded:: 1.0.7\n        '''\n        mm = self.mipmaps\n        for x in range(len(mm)):\n            item = mm.get(x, None)\n            if item is None:\n                raise Exception('Invalid mipmap level, found empty one')\n            yield x, item[0], item[1], item[2], item[3]",
  "def __init__(self, filename, **kwargs):\n        self._mipmap = kwargs.get('mipmap', False)\n        self.keep_data = kwargs.get('keep_data', False)\n        self._nocache = kwargs.get('nocache', False)\n        self._ext = kwargs.get('ext')\n        self._inline = kwargs.get('inline')\n        self.filename = filename\n        if self._inline:\n            self._data = self.load(kwargs.get('rawdata'))\n        else:\n            self._data = self.load(filename)\n        self._textures = None",
  "def load(self, filename):\n        '''Load an image'''\n        return None",
  "def can_save(fmt, is_bytesio=False):\n        '''Indicate if the loader can save the Image object\n\n        .. versionchanged:: 1.11.0\n            Parameter `fmt` and `is_bytesio` added\n        '''\n        return False",
  "def can_load_memory():\n        '''Indicate if the loader can load an image by passing data\n        '''\n        return False",
  "def save(*largs, **kwargs):\n        raise NotImplementedError()",
  "def populate(self):\n        self._textures = []\n        fname = self.filename\n        if __debug__:\n            Logger.trace('Image: %r, populate to textures (%d)' %\n                         (fname, len(self._data)))\n\n        for count in range(len(self._data)):\n\n            # first, check if a texture with the same name already exist in the\n            # cache\n            chr = type(fname)\n            uid = chr(u'%s|%d|%d') % (fname, self._mipmap, count)\n            texture = Cache.get('kv.texture', uid)\n\n            # if not create it and append to the cache\n            if texture is None:\n                imagedata = self._data[count]\n                source = '{}{}|'.format(\n                    'zip|' if fname.endswith('.zip') else '',\n                    self._nocache)\n                imagedata.source = chr(source) + uid\n                texture = Texture.create_from_data(\n                    imagedata, mipmap=self._mipmap)\n                if not self._nocache:\n                    Cache.append('kv.texture', uid, texture)\n                if imagedata.flip_vertical:\n                    texture.flip_vertical()\n\n            # set as our current texture\n            self._textures.append(texture)\n\n            # release data if ask\n            if not self.keep_data:\n                self._data[count].release_data()",
  "def width(self):\n        '''Image width\n        '''\n        return self._data[0].width",
  "def height(self):\n        '''Image height\n        '''\n        return self._data[0].height",
  "def size(self):\n        '''Image size (width, height)\n        '''\n        return (self._data[0].width, self._data[0].height)",
  "def texture(self):\n        '''Get the image texture (created on the first call)\n        '''\n        if self._textures is None:\n            self.populate()\n        if self._textures is None:\n            return None\n        return self._textures[0]",
  "def textures(self):\n        '''Get the textures list (for mipmapped image or animated image)\n\n        .. versionadded:: 1.0.8\n        '''\n        if self._textures is None:\n            self.populate()\n        return self._textures",
  "def nocache(self):\n        '''Indicate if the texture will not be stored in the cache\n\n        .. versionadded:: 1.6.0\n        '''\n        return self._nocache",
  "def zip_loader(filename, **kwargs):\n        '''Read images from an zip file.\n\n        .. versionadded:: 1.0.8\n\n        Returns an Image with a list of type ImageData stored in Image._data\n        '''\n        # read zip in memory for faster access\n        _file = BytesIO(open(filename, 'rb').read())\n        # read all images inside the zip\n        z = zipfile.ZipFile(_file)\n        image_data = []\n        # sort filename list\n        znamelist = z.namelist()\n        znamelist.sort()\n        image = None\n        for zfilename in znamelist:\n            try:\n                # read file and store it in mem with fileIO struct around it\n                tmpfile = BytesIO(z.read(zfilename))\n                ext = zfilename.split('.')[-1].lower()\n                im = None\n                for loader in ImageLoader.loaders:\n                    if (ext not in loader.extensions() or\n                            not loader.can_load_memory()):\n                        continue\n                    Logger.debug('Image%s: Load <%s> from <%s>' %\n                                 (loader.__name__[11:], zfilename, filename))\n                    try:\n                        im = loader(zfilename, ext=ext, rawdata=tmpfile,\n                                    inline=True, **kwargs)\n                    except:\n                        # Loader failed, continue trying.\n                        continue\n                    break\n                if im is not None:\n                    # append ImageData to local variable before its\n                    # overwritten\n                    image_data.append(im._data[0])\n                    image = im\n                # else: if not image file skip to next\n            except:\n                Logger.warning('Image: Unable to load image'\n                               '<%s> in zip <%s> trying to continue...'\n                               % (zfilename, filename))\n        z.close()\n        if len(image_data) == 0:\n            raise Exception('no images in zip <%s>' % filename)\n        # replace Image.Data with the array of all the images in the zip\n        image._data = image_data\n        image.filename = filename\n        return image",
  "def register(defcls):\n        ImageLoader.loaders.append(defcls)",
  "def load(filename, **kwargs):\n\n        # atlas ?\n        if filename[:8] == 'atlas://':\n            # remove the url\n            rfn = filename[8:]\n            # last field is the ID\n            try:\n                rfn, uid = rfn.rsplit('/', 1)\n            except ValueError:\n                raise ValueError(\n                    'Image: Invalid %s name for atlas' % filename)\n\n            # search if we already got the atlas loaded\n            atlas = Cache.get('kv.atlas', rfn)\n\n            # atlas already loaded, so reupload the missing texture in cache,\n            # because when it's not in use, the texture can be removed from the\n            # kv.texture cache.\n            if atlas:\n                texture = atlas[uid]\n                fn = 'atlas://%s/%s' % (rfn, uid)\n                cid = '{}|{:d}|{:d}'.format(fn, False, 0)\n                Cache.append('kv.texture', cid, texture)\n                return Image(texture)\n\n            # search with resource\n            afn = rfn\n            if not afn.endswith('.atlas'):\n                afn += '.atlas'\n            afn = resource_find(afn)\n            if not afn:\n                raise Exception('Unable to find %r atlas' % afn)\n            atlas = Atlas(afn)\n            Cache.append('kv.atlas', rfn, atlas)\n            # first time, fill our texture cache.\n            for nid, texture in atlas.textures.items():\n                fn = 'atlas://%s/%s' % (rfn, nid)\n                cid = '{}|{:d}|{:d}'.format(fn, False, 0)\n                Cache.append('kv.texture', cid, texture)\n            return Image(atlas[uid])\n\n        # extract extensions\n        ext = filename.split('.')[-1].lower()\n\n        # prevent url querystrings\n        if filename.startswith((('http://', 'https://'))):\n            ext = ext.split('?')[0]\n\n        filename = resource_find(filename)\n\n        # special case. When we are trying to load a \"zip\" file with image, we\n        # will use the special zip_loader in ImageLoader. This might return a\n        # sequence of images contained in the zip.\n        if ext == 'zip':\n            return ImageLoader.zip_loader(filename)\n        else:\n            im = None\n            # Get actual image format instead of extension if possible\n            ext = imghdr.what(filename) or ext\n            for loader in ImageLoader.loaders:\n                if ext not in loader.extensions():\n                    continue\n                Logger.debug('Image%s: Load <%s>' %\n                             (loader.__name__[11:], filename))\n                im = loader(filename, **kwargs)\n                break\n            if im is None:\n                raise Exception('Unknown <%s> type, no loader found.' % ext)\n            return im",
  "def __init__(self, arg, **kwargs):\n        # this event should be fired on animation of sequenced img's\n        self.register_event_type('on_texture')\n\n        super(Image, self).__init__()\n\n        self._mipmap = kwargs.get('mipmap', False)\n        self._keep_data = kwargs.get('keep_data', False)\n        self._nocache = kwargs.get('nocache', False)\n        self._size = [0, 0]\n        self._image = None\n        self._filename = None\n        self._texture = None\n        self._anim_available = False\n        self._anim_index = 0\n        self._anim_delay = 0\n        self.anim_delay = kwargs.get('anim_delay', .25)\n        # indicator of images having been loded in cache\n        self._iteration_done = False\n\n        if isinstance(arg, Image):\n            for attr in Image.copy_attributes:\n                self.__setattr__(attr, arg.__getattribute__(attr))\n        elif type(arg) in (Texture, TextureRegion):\n            if not hasattr(self, 'textures'):\n                self.textures = []\n                self.textures.append(arg)\n            self._texture = arg\n            self._size = self.texture.size\n        elif isinstance(arg, ImageLoaderBase):\n            self.image = arg\n        elif isinstance(arg, BytesIO):\n            ext = kwargs.get('ext', None)\n            if not ext:\n                raise Exception('Inline loading require \"ext\" parameter')\n            filename = kwargs.get('filename')\n            if not filename:\n                self._nocache = True\n                filename = '__inline__'\n            self.load_memory(arg, ext, filename)\n        elif isinstance(arg, string_types):\n            groups = self.data_uri_re.findall(arg)\n            if groups:\n                self._nocache = True\n                imtype, optstr, data = groups[0]\n                options = [o for o in optstr.split(';') if o]\n                ext = imtype\n                isb64 = 'base64' in options\n                if data:\n                    if isb64:\n                        data = b64decode(data)\n                    self.load_memory(BytesIO(data), ext)\n            else:\n                self.filename = arg\n        else:\n            raise Exception('Unable to load image type {0!r}'.format(arg))",
  "def remove_from_cache(self):\n        '''Remove the Image from cache. This facilitates re-loading of\n        images from disk in case the image content has changed.\n\n        .. versionadded:: 1.3.0\n\n        Usage::\n\n            im = CoreImage('1.jpg')\n            # -- do something --\n            im.remove_from_cache()\n            im = CoreImage('1.jpg')\n            # this time image will be re-loaded from disk\n\n        '''\n        count = 0\n        f = self.filename\n        pat = type(f)(u'%s|%d|%d')\n        uid = pat % (f, self._mipmap, count)\n        Cache.remove(\"kv.image\", uid)\n        while Cache.get(\"kv.texture\", uid):\n            Cache.remove(\"kv.texture\", uid)\n            count += 1\n            uid = pat % (f, self._mipmap, count)",
  "def _anim(self, *largs):\n        if not self._image:\n            return\n        textures = self.image.textures\n        if self._anim_index >= len(textures):\n            self._anim_index = 0\n        self._texture = self.image.textures[self._anim_index]\n        self.dispatch('on_texture')\n        self._anim_index += 1\n        self._anim_index %= len(self._image.textures)",
  "def anim_reset(self, allow_anim):\n        '''Reset an animation if available.\n\n        .. versionadded:: 1.0.8\n\n        :Parameters:\n            `allow_anim`: bool\n                Indicate whether the animation should restart playing or not.\n\n        Usage::\n\n            # start/reset animation\n            image.anim_reset(True)\n\n            # or stop the animation\n            image.anim_reset(False)\n\n        You can change the animation speed whilst it is playing::\n\n            # Set to 20 FPS\n            image.anim_delay = 1 / 20.\n\n        '''\n        # stop animation\n        if self._anim_ev is not None:\n            self._anim_ev.cancel()\n            self._anim_ev = None\n\n        if allow_anim and self._anim_available and self._anim_delay >= 0:\n            self._anim_ev = Clock.schedule_interval(self._anim,\n                                                    self.anim_delay)\n            self._anim()",
  "def _get_anim_delay(self):\n        return self._anim_delay",
  "def _set_anim_delay(self, x):\n        if self._anim_delay == x:\n            return\n        self._anim_delay = x\n        if self._anim_available:\n            if self._anim_ev is not None:\n                self._anim_ev.cancel()\n                self._anim_ev = None\n\n            if self._anim_delay >= 0:\n                self._anim_ev = Clock.schedule_interval(self._anim,\n                                                        self._anim_delay)",
  "def anim_available(self):\n        '''Return True if this Image instance has animation available.\n\n        .. versionadded:: 1.0.8\n        '''\n        return self._anim_available",
  "def anim_index(self):\n        '''Return the index number of the image currently in the texture.\n\n        .. versionadded:: 1.0.8\n        '''\n        return self._anim_index",
  "def _img_iterate(self, *largs):\n        if not self.image or self._iteration_done:\n            return\n        self._iteration_done = True\n        imgcount = len(self.image.textures)\n        if imgcount > 1:\n            self._anim_available = True\n            self.anim_reset(True)\n        self._texture = self.image.textures[0]",
  "def on_texture(self, *largs):\n        '''This event is fired when the texture reference or content has\n           changed. It is normally used for sequenced images.\n\n        .. versionadded:: 1.0.8\n        '''\n        pass",
  "def load(filename, **kwargs):\n        '''Load an image\n\n        :Parameters:\n            `filename`: str\n                Filename of the image.\n            `keep_data`: bool, defaults to False\n                Keep the image data when the texture is created.\n        '''\n        kwargs.setdefault('keep_data', False)\n        return Image(filename, **kwargs)",
  "def _get_image(self):\n        return self._image",
  "def _set_image(self, image):\n        self._image = image\n        if hasattr(image, 'filename'):\n            self._filename = image.filename\n        if image:\n            self._size = (self.image.width, self.image.height)",
  "def _get_filename(self):\n        return self._filename",
  "def _set_filename(self, value):\n        if value is None or value == self._filename:\n            return\n        self._filename = value\n\n        # construct uid as a key for Cache\n        f = self.filename\n        uid = type(f)(u'%s|%d|%d') % (f, self._mipmap, 0)\n\n        # in case of Image have been asked with keep_data\n        # check the kv.image cache instead of texture.\n        image = Cache.get('kv.image', uid)\n        if image:\n            # we found an image, yeah ! but reset the texture now.\n            self.image = image\n            # if image.__class__ is core image then it's a texture\n            # from atlas or other sources and has no data so skip\n            if (image.__class__ != self.__class__ and\n                    not image.keep_data and self._keep_data):\n                self.remove_from_cache()\n                self._filename = ''\n                self._set_filename(value)\n            else:\n                self._texture = None\n            return\n        else:\n            # if we already got a texture, it will be automatically reloaded.\n            _texture = Cache.get('kv.texture', uid)\n            if _texture:\n                self._texture = _texture\n                return\n\n        # if image not already in cache then load\n        tmpfilename = self._filename\n        image = ImageLoader.load(\n            self._filename, keep_data=self._keep_data,\n            mipmap=self._mipmap, nocache=self._nocache)\n        self._filename = tmpfilename\n        # put the image into the cache if needed\n        if isinstance(image, Texture):\n            self._texture = image\n            self._size = image.size\n        else:\n            self.image = image\n            if not self._nocache:\n                Cache.append('kv.image', uid, self.image)",
  "def load_memory(self, data, ext, filename='__inline__'):\n        '''(internal) Method to load an image from raw data.\n        '''\n        self._filename = filename\n\n        # see if there is a available loader for it\n        loaders = [loader for loader in ImageLoader.loaders if\n                   loader.can_load_memory() and\n                   ext in loader.extensions()]\n        if not loaders:\n            raise Exception('No inline loader found to load {}'.format(ext))\n        image = loaders[0](filename, ext=ext, rawdata=data, inline=True,\n                nocache=self._nocache, mipmap=self._mipmap,\n                keep_data=self._keep_data)\n        if isinstance(image, Texture):\n            self._texture = image\n            self._size = image.size\n        else:\n            self.image = image",
  "def size(self):\n        '''Image size (width, height)\n        '''\n        return self._size",
  "def width(self):\n        '''Image width\n        '''\n        return self._size[0]",
  "def height(self):\n        '''Image height\n        '''\n        return self._size[1]",
  "def texture(self):\n        '''Texture of the image'''\n        if self.image:\n            if not self._iteration_done:\n                self._img_iterate()\n        return self._texture",
  "def nocache(self):\n        '''Indicate whether the texture will not be stored in the cache or not.\n\n        .. versionadded:: 1.6.0\n        '''\n        return self._nocache",
  "def save(self, filename, flipped=False, fmt=None):\n        '''Save image texture to file.\n\n        The filename should have the '.png' extension because the texture data\n        read from the GPU is in the RGBA format. '.jpg' might work but has not\n        been heavily tested so some providers might break when using it.\n        Any other extensions are not officially supported.\n\n        The flipped parameter flips the saved image vertically, and\n        defaults to False.\n\n        Example::\n\n            # Save an core image object\n            from kivy.core.image import Image\n            img = Image('hello.png')\n            img.save('hello2.png')\n\n            # Save a texture\n            texture = Texture.create(...)\n            img = Image(texture)\n            img.save('hello3.png')\n\n        .. versionadded:: 1.7.0\n\n        .. versionchanged:: 1.8.0\n            Parameter `flipped` added to flip the image before saving, default\n            to False.\n\n        .. versionchanged:: 1.11.0\n            Parameter `fmt` added to force the output format of the file\n            Filename can now be a BytesIO object.\n\n        '''\n        is_bytesio = False\n        if isinstance(filename, BytesIO):\n            is_bytesio = True\n            if not fmt:\n                raise Exception(\n                    \"You must specify a format to save into a BytesIO object\")\n        elif fmt is None:\n            fmt = self._find_format_from_filename(filename)\n\n        pixels = None\n        size = None\n        loaders = [\n            x for x in ImageLoader.loaders\n            if x.can_save(fmt, is_bytesio=is_bytesio)\n        ]\n        if not loaders:\n            return False\n        loader = loaders[0]\n\n        if self.image:\n            # we might have a ImageData object to use\n            data = self.image._data[0]\n            if data.data is not None:\n                if data.fmt in ('rgba', 'rgb'):\n                    # fast path, use the \"raw\" data when keep_data is used\n                    size = data.width, data.height\n                    pixels = data.data\n\n                else:\n                    # the format is not rgba, we need to convert it.\n                    # use texture for that.\n                    self.populate()\n\n        if pixels is None and self._texture:\n            # use the texture pixels\n            size = self._texture.size\n            pixels = self._texture.pixels\n\n        if pixels is None:\n            return False\n\n        l_pixels = len(pixels)\n        if l_pixels == size[0] * size[1] * 3:\n            pixelfmt = 'rgb'\n        elif l_pixels == size[0] * size[1] * 4:\n            pixelfmt = 'rgba'\n        else:\n            raise Exception('Unable to determine the format of the pixels')\n        return loader.save(\n            filename, size[0], size[1], pixelfmt, pixels, flipped, fmt)",
  "def _find_format_from_filename(self, filename):\n        ext = filename.rsplit(\".\", 1)[-1].lower()\n        if ext in {\n                'bmp', 'jpe', 'lbm', 'pcx', 'png', 'pnm',\n                'tga', 'tiff', 'webp', 'xcf', 'xpm', 'xv'}:\n            return ext\n        elif ext in ('jpg', 'jpeg'):\n            return 'jpg'\n        elif ext in ('b64', 'base64'):\n            return 'base64'\n        return None",
  "def read_pixel(self, x, y):\n        '''For a given local x/y position, return the pixel color at that\n        position.\n\n        .. warning::\n            This function can only be used with images loaded with the\n            keep_data=True keyword. For example::\n\n                m = Image.load('image.png', keep_data=True)\n                color = m.read_pixel(150, 150)\n\n        :Parameters:\n            `x`: int\n                Local x coordinate of the pixel in question.\n            `y`: int\n                Local y coordinate of the pixel in question.\n        '''\n        data = self.image._data[0]\n\n        # can't use this function without ImageData\n        if data.data is None:\n            raise EOFError('Image data is missing, make sure that image is'\n                           'loaded with keep_data=True keyword.')\n\n        # check bounds\n        x, y = int(x), int(y)\n        if not (0 <= x < data.width and 0 <= y < data.height):\n            raise IndexError('Position (%d, %d) is out of range.' % (x, y))\n\n        assert data.fmt in ImageData._supported_fmts\n        size = 3 if data.fmt in ('rgb', 'bgr') else 4\n        index = y * data.width * size + x * size\n        raw = bytearray(data.data[index:index + size])\n        color = [c / 255.0 for c in raw]\n\n        bgr_flag = False\n        if data.fmt == 'argb':\n            color.reverse()  # bgra\n            bgr_flag = True\n        elif data.fmt == 'abgr':\n            color.reverse()  # rgba\n\n        # conversion for BGR->RGB, BGRA->RGBA format\n        if bgr_flag or data.fmt in ('bgr', 'bgra'):\n            color[0], color[2] = color[2], color[0]\n\n        return color",
  "class OnCompletionListener(PythonJavaClass):\n    __javainterfaces__ = [\"android/media/MediaPlayer$OnCompletionListener\"]\n    __javacontext__ = \"app\"\n\n    def __init__(self, callback, **kwargs):\n        super(OnCompletionListener, self).__init__(**kwargs)\n        self.callback = callback\n\n    @java_method(\"(Landroid/media/MediaPlayer;)V\")\n    def onCompletion(self, mp):\n        self.callback()",
  "class SoundAndroidPlayer(Sound):\n    @staticmethod\n    def extensions():\n        return (\"mp3\", \"mp4\", \"aac\", \"3gp\", \"flac\", \"mkv\", \"wav\", \"ogg\", \"m4a\",\n                \"gsm\", \"mid\", \"xmf\", \"mxmf\", \"rtttl\", \"rtx\", \"ota\", \"imy\")\n\n    def __init__(self, **kwargs):\n        self._mediaplayer = None\n        self._completion_listener = None\n        super(SoundAndroidPlayer, self).__init__(**kwargs)\n\n    def load(self):\n        self.unload()\n        self._mediaplayer = MediaPlayer()\n        if api_version >= 21:\n            self._mediaplayer.setAudioAttributes(\n                AudioAttributesBuilder()\n                .setLegacyStreamType(AudioManager.STREAM_MUSIC)\n                .build())\n        else:\n            self._mediaplayer.setAudioStreamType(AudioManager.STREAM_MUSIC)\n        self._mediaplayer.setDataSource(self.source)\n        self._completion_listener = OnCompletionListener(\n            self._completion_callback\n        )\n        self._mediaplayer.setOnCompletionListener(self._completion_listener)\n        self._mediaplayer.prepare()\n\n    def unload(self):\n        if self._mediaplayer:\n            self._mediaplayer.release()\n            self._mediaplayer = None\n\n    def play(self):\n        if not self._mediaplayer:\n            return\n        self._mediaplayer.start()\n        super(SoundAndroidPlayer, self).play()\n\n    def stop(self):\n        if not self._mediaplayer:\n            return\n        self._mediaplayer.stop()\n        self._mediaplayer.prepare()\n\n    def seek(self, position):\n        if not self._mediaplayer:\n            return\n        self._mediaplayer.seekTo(float(position) * 1000)\n\n    def get_pos(self):\n        if self._mediaplayer:\n            return self._mediaplayer.getCurrentPosition() / 1000.\n        return super(SoundAndroidPlayer, self).get_pos()\n\n    def on_volume(self, instance, volume):\n        if self._mediaplayer:\n            volume = float(volume)\n            self._mediaplayer.setVolume(volume, volume)\n\n    def _completion_callback(self):\n        super(SoundAndroidPlayer, self).stop()\n\n    def _get_length(self):\n        if self._mediaplayer:\n            return self._mediaplayer.getDuration() / 1000.\n        return super(SoundAndroidPlayer, self)._get_length()\n\n    def on_loop(self, instance, loop):\n        if self._mediaplayer:\n            self._mediaplayer.setLooping(loop)",
  "def __init__(self, callback, **kwargs):\n        super(OnCompletionListener, self).__init__(**kwargs)\n        self.callback = callback",
  "def onCompletion(self, mp):\n        self.callback()",
  "def extensions():\n        return (\"mp3\", \"mp4\", \"aac\", \"3gp\", \"flac\", \"mkv\", \"wav\", \"ogg\", \"m4a\",\n                \"gsm\", \"mid\", \"xmf\", \"mxmf\", \"rtttl\", \"rtx\", \"ota\", \"imy\")",
  "def __init__(self, **kwargs):\n        self._mediaplayer = None\n        self._completion_listener = None\n        super(SoundAndroidPlayer, self).__init__(**kwargs)",
  "def load(self):\n        self.unload()\n        self._mediaplayer = MediaPlayer()\n        if api_version >= 21:\n            self._mediaplayer.setAudioAttributes(\n                AudioAttributesBuilder()\n                .setLegacyStreamType(AudioManager.STREAM_MUSIC)\n                .build())\n        else:\n            self._mediaplayer.setAudioStreamType(AudioManager.STREAM_MUSIC)\n        self._mediaplayer.setDataSource(self.source)\n        self._completion_listener = OnCompletionListener(\n            self._completion_callback\n        )\n        self._mediaplayer.setOnCompletionListener(self._completion_listener)\n        self._mediaplayer.prepare()",
  "def unload(self):\n        if self._mediaplayer:\n            self._mediaplayer.release()\n            self._mediaplayer = None",
  "def play(self):\n        if not self._mediaplayer:\n            return\n        self._mediaplayer.start()\n        super(SoundAndroidPlayer, self).play()",
  "def stop(self):\n        if not self._mediaplayer:\n            return\n        self._mediaplayer.stop()\n        self._mediaplayer.prepare()",
  "def seek(self, position):\n        if not self._mediaplayer:\n            return\n        self._mediaplayer.seekTo(float(position) * 1000)",
  "def get_pos(self):\n        if self._mediaplayer:\n            return self._mediaplayer.getCurrentPosition() / 1000.\n        return super(SoundAndroidPlayer, self).get_pos()",
  "def on_volume(self, instance, volume):\n        if self._mediaplayer:\n            volume = float(volume)\n            self._mediaplayer.setVolume(volume, volume)",
  "def _completion_callback(self):\n        super(SoundAndroidPlayer, self).stop()",
  "def _get_length(self):\n        if self._mediaplayer:\n            return self._mediaplayer.getDuration() / 1000.\n        return super(SoundAndroidPlayer, self)._get_length()",
  "def on_loop(self, instance, loop):\n        if self._mediaplayer:\n            self._mediaplayer.setLooping(loop)",
  "def _log_callback(message, level):\n    message = message.strip()\n    if message:\n        logger_func[level]('ffpyplayer: {}'.format(message))",
  "class SoundFFPy(Sound):\n\n    @staticmethod\n    def extensions():\n        return formats_in\n\n    def __init__(self, **kwargs):\n        self._ffplayer = None\n        self.quitted = False\n        self._log_callback_set = False\n        self._state = ''\n        self.state = 'stop'\n\n        if not get_log_callback():\n            set_log_callback(_log_callback)\n            self._log_callback_set = True\n\n        super(SoundFFPy, self).__init__(**kwargs)\n\n    def __del__(self):\n        self.unload()\n        if self._log_callback_set:\n            set_log_callback(None)\n\n    def _player_callback(self, selector, value):\n        if self._ffplayer is None:\n            return\n        if selector == 'quit':\n            def close(*args):\n                self.quitted = True\n                self.unload()\n            Clock.schedule_once(close, 0)\n        elif selector == 'eof':\n            Clock.schedule_once(self._do_eos, 0)\n\n    def load(self):\n        self.unload()\n        ff_opts = {'vn': True, 'sn': True}  # only audio\n        self._ffplayer = MediaPlayer(self.source,\n                                     callback=self._player_callback,\n                                     loglevel='info', ff_opts=ff_opts)\n        player = self._ffplayer\n        player.set_volume(self.volume)\n        player.toggle_pause()\n        self._state = 'paused'\n        # wait until loaded or failed, shouldn't take long, but just to make\n        # sure metadata is available.\n        s = time.perf_counter()\n        while (player.get_metadata()['duration'] is None and\n               not self.quitted and time.perf_counter() - s < 10.):\n            time.sleep(0.005)\n\n    def unload(self):\n        if self._ffplayer:\n            self._ffplayer = None\n        self._state = ''\n        self.state = 'stop'\n        self.quitted = False\n\n    def play(self):\n        if self._state == 'playing':\n            super(SoundFFPy, self).play()\n            return\n        if not self._ffplayer:\n            self.load()\n        self._ffplayer.toggle_pause()\n        self._state = 'playing'\n        self.state = 'play'\n        super(SoundFFPy, self).play()\n        self.seek(0)\n\n    def stop(self):\n        if self._ffplayer and self._state == 'playing':\n            self._ffplayer.toggle_pause()\n            self._state = 'paused'\n            self.state = 'stop'\n        super(SoundFFPy, self).stop()\n\n    def seek(self, position):\n        if self._ffplayer is None:\n            return\n        self._ffplayer.seek(position, relative=False)\n\n    def get_pos(self):\n        if self._ffplayer is not None:\n            return self._ffplayer.get_pts()\n        return 0\n\n    def on_volume(self, instance, volume):\n        if self._ffplayer is not None:\n            self._ffplayer.set_volume(volume)\n\n    def _get_length(self):\n        if self._ffplayer is None:\n            return super(SoundFFPy, self)._get_length()\n        return self._ffplayer.get_metadata()['duration']\n\n    def _do_eos(self, *args):\n        if not self.loop:\n            self.stop()\n        else:\n            self.seek(0.)",
  "def extensions():\n        return formats_in",
  "def __init__(self, **kwargs):\n        self._ffplayer = None\n        self.quitted = False\n        self._log_callback_set = False\n        self._state = ''\n        self.state = 'stop'\n\n        if not get_log_callback():\n            set_log_callback(_log_callback)\n            self._log_callback_set = True\n\n        super(SoundFFPy, self).__init__(**kwargs)",
  "def __del__(self):\n        self.unload()\n        if self._log_callback_set:\n            set_log_callback(None)",
  "def _player_callback(self, selector, value):\n        if self._ffplayer is None:\n            return\n        if selector == 'quit':\n            def close(*args):\n                self.quitted = True\n                self.unload()\n            Clock.schedule_once(close, 0)\n        elif selector == 'eof':\n            Clock.schedule_once(self._do_eos, 0)",
  "def load(self):\n        self.unload()\n        ff_opts = {'vn': True, 'sn': True}  # only audio\n        self._ffplayer = MediaPlayer(self.source,\n                                     callback=self._player_callback,\n                                     loglevel='info', ff_opts=ff_opts)\n        player = self._ffplayer\n        player.set_volume(self.volume)\n        player.toggle_pause()\n        self._state = 'paused'\n        # wait until loaded or failed, shouldn't take long, but just to make\n        # sure metadata is available.\n        s = time.perf_counter()\n        while (player.get_metadata()['duration'] is None and\n               not self.quitted and time.perf_counter() - s < 10.):\n            time.sleep(0.005)",
  "def unload(self):\n        if self._ffplayer:\n            self._ffplayer = None\n        self._state = ''\n        self.state = 'stop'\n        self.quitted = False",
  "def play(self):\n        if self._state == 'playing':\n            super(SoundFFPy, self).play()\n            return\n        if not self._ffplayer:\n            self.load()\n        self._ffplayer.toggle_pause()\n        self._state = 'playing'\n        self.state = 'play'\n        super(SoundFFPy, self).play()\n        self.seek(0)",
  "def stop(self):\n        if self._ffplayer and self._state == 'playing':\n            self._ffplayer.toggle_pause()\n            self._state = 'paused'\n            self.state = 'stop'\n        super(SoundFFPy, self).stop()",
  "def seek(self, position):\n        if self._ffplayer is None:\n            return\n        self._ffplayer.seek(position, relative=False)",
  "def get_pos(self):\n        if self._ffplayer is not None:\n            return self._ffplayer.get_pts()\n        return 0",
  "def on_volume(self, instance, volume):\n        if self._ffplayer is not None:\n            self._ffplayer.set_volume(volume)",
  "def _get_length(self):\n        if self._ffplayer is None:\n            return super(SoundFFPy, self)._get_length()\n        return self._ffplayer.get_metadata()['duration']",
  "def _do_eos(self, *args):\n        if not self.loop:\n            self.stop()\n        else:\n            self.seek(0.)",
  "def close(*args):\n                self.quitted = True\n                self.unload()",
  "class SoundLoader:\n    '''Load a sound, using the best loader for the given file type.\n    '''\n\n    _classes = []\n\n    @staticmethod\n    def register(classobj):\n        '''Register a new class to load the sound.'''\n        Logger.debug('Audio: register %s' % classobj.__name__)\n        SoundLoader._classes.append(classobj)\n\n    @staticmethod\n    def load(filename):\n        '''Load a sound, and return a Sound() instance.'''\n        rfn = resource_find(filename)\n        if rfn is not None:\n            filename = rfn\n        ext = filename.split('.')[-1].lower()\n        if '?' in ext:\n            ext = ext.split('?')[0]\n        for classobj in SoundLoader._classes:\n            if ext in classobj.extensions():\n                return classobj(source=filename)\n        Logger.warning('Audio: Unable to find a loader for <%s>' %\n                       filename)\n        return None",
  "class Sound(EventDispatcher):\n    '''Represents a sound to play. This class is abstract, and cannot be used\n    directly.\n\n    Use SoundLoader to load a sound.\n\n    :Events:\n        `on_play`: None\n            Fired when the sound is played.\n        `on_stop`: None\n            Fired when the sound is stopped.\n    '''\n\n    source = StringProperty(None)\n    '''Filename / source of your audio file.\n\n    .. versionadded:: 1.3.0\n\n    :attr:`source` is a :class:`~kivy.properties.StringProperty` that defaults\n    to None and is read-only. Use the :meth:`SoundLoader.load` for loading\n    audio.\n    '''\n\n    volume = NumericProperty(1.)\n    '''Volume, in the range 0-1. 1 means full volume, 0 means mute.\n\n    .. versionadded:: 1.3.0\n\n    :attr:`volume` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 1.\n    '''\n\n    pitch = BoundedNumericProperty(1., min=float_info.epsilon)\n    '''Pitch of a sound. 2 is an octave higher, .5 one below. This is only\n    implemented for SDL2 audio provider yet.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`pitch` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 1.\n    '''\n\n    state = OptionProperty('stop', options=('stop', 'play'))\n    '''State of the sound, one of 'stop' or 'play'.\n\n    .. versionadded:: 1.3.0\n\n    :attr:`state` is a read-only :class:`~kivy.properties.OptionProperty`.'''\n\n    loop = BooleanProperty(False)\n    '''Set to True if the sound should automatically loop when it finishes.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`loop` is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.'''\n\n    __events__ = ('on_play', 'on_stop')\n\n    def on_source(self, instance, filename):\n        self.unload()\n        if filename is None:\n            return\n        self.load()\n\n    def get_pos(self):\n        '''\n        Returns the current position of the audio file.\n        Returns 0 if not playing.\n\n        .. versionadded:: 1.4.1\n        '''\n        return 0\n\n    def _get_length(self):\n        return 0\n\n    length = property(lambda self: self._get_length(),\n                      doc='Get length of the sound (in seconds).')\n\n    def load(self):\n        '''Load the file into memory.'''\n        pass\n\n    def unload(self):\n        '''Unload the file from memory.'''\n        pass\n\n    def play(self):\n        '''Play the file.'''\n        self.state = 'play'\n        self.dispatch('on_play')\n\n    def stop(self):\n        '''Stop playback.'''\n        self.state = 'stop'\n        self.dispatch('on_stop')\n\n    def seek(self, position):\n        '''Go to the <position> (in seconds).\n\n        .. note::\n            Most sound providers cannot seek when the audio is stopped.\n            Play then seek.\n        '''\n        pass\n\n    def on_play(self):\n        pass\n\n    def on_stop(self):\n        pass",
  "def register(classobj):\n        '''Register a new class to load the sound.'''\n        Logger.debug('Audio: register %s' % classobj.__name__)\n        SoundLoader._classes.append(classobj)",
  "def load(filename):\n        '''Load a sound, and return a Sound() instance.'''\n        rfn = resource_find(filename)\n        if rfn is not None:\n            filename = rfn\n        ext = filename.split('.')[-1].lower()\n        if '?' in ext:\n            ext = ext.split('?')[0]\n        for classobj in SoundLoader._classes:\n            if ext in classobj.extensions():\n                return classobj(source=filename)\n        Logger.warning('Audio: Unable to find a loader for <%s>' %\n                       filename)\n        return None",
  "def on_source(self, instance, filename):\n        self.unload()\n        if filename is None:\n            return\n        self.load()",
  "def get_pos(self):\n        '''\n        Returns the current position of the audio file.\n        Returns 0 if not playing.\n\n        .. versionadded:: 1.4.1\n        '''\n        return 0",
  "def _get_length(self):\n        return 0",
  "def load(self):\n        '''Load the file into memory.'''\n        pass",
  "def unload(self):\n        '''Unload the file from memory.'''\n        pass",
  "def play(self):\n        '''Play the file.'''\n        self.state = 'play'\n        self.dispatch('on_play')",
  "def stop(self):\n        '''Stop playback.'''\n        self.state = 'stop'\n        self.dispatch('on_stop')",
  "def seek(self, position):\n        '''Go to the <position> (in seconds).\n\n        .. note::\n            Most sound providers cannot seek when the audio is stopped.\n            Play then seek.\n        '''\n        pass",
  "def on_play(self):\n        pass",
  "def on_stop(self):\n        pass",
  "def _on_gstplayer_message(mtype, message):\n    if mtype == 'error':\n        Logger.error('AudioGstplayer: {}'.format(message))\n    elif mtype == 'warning':\n        Logger.warning('AudioGstplayer: {}'.format(message))\n    elif mtype == 'info':\n        Logger.info('AudioGstplayer: {}'.format(message))",
  "class SoundGstplayer(Sound):\n\n    @staticmethod\n    def extensions():\n        return ('wav', 'ogg', 'mp3', 'm4a', 'flac', 'mp4')\n\n    def __init__(self, **kwargs):\n        self.player = None\n        super(SoundGstplayer, self).__init__(**kwargs)\n\n    def _on_gst_eos_sync(self):\n        Clock.schedule_once(self._on_gst_eos, 0)\n\n    def _on_gst_eos(self, *dt):\n        if self.loop:\n            self.player.stop()\n            self.player.play()\n        else:\n            self.stop()\n\n    def load(self):\n        self.unload()\n        uri = self._get_uri()\n        self.player = GstPlayer(uri, None, self._on_gst_eos_sync,\n                                _on_gstplayer_message)\n        self.player.load()\n\n    def play(self):\n        # we need to set the volume everytime, it seems that stopping + playing\n        # the sound reset the volume.\n        self.player.set_volume(self.volume)\n        self.player.play()\n        super(SoundGstplayer, self).play()\n\n    def stop(self):\n        self.player.stop()\n        super(SoundGstplayer, self).stop()\n\n    def unload(self):\n        if self.player:\n            self.player.unload()\n            self.player = None\n\n    def seek(self, position):\n        self.player.seek(position / self.length)\n\n    def get_pos(self):\n        return self.player.get_position()\n\n    def _get_length(self):\n        return self.player.get_duration()\n\n    def on_volume(self, instance, volume):\n        self.player.set_volume(volume)\n\n    def _get_uri(self):\n        uri = self.source\n        if not uri:\n            return\n        if '://' not in uri:\n            uri = 'file:' + pathname2url(realpath(uri))\n        return uri",
  "def extensions():\n        return ('wav', 'ogg', 'mp3', 'm4a', 'flac', 'mp4')",
  "def __init__(self, **kwargs):\n        self.player = None\n        super(SoundGstplayer, self).__init__(**kwargs)",
  "def _on_gst_eos_sync(self):\n        Clock.schedule_once(self._on_gst_eos, 0)",
  "def _on_gst_eos(self, *dt):\n        if self.loop:\n            self.player.stop()\n            self.player.play()\n        else:\n            self.stop()",
  "def load(self):\n        self.unload()\n        uri = self._get_uri()\n        self.player = GstPlayer(uri, None, self._on_gst_eos_sync,\n                                _on_gstplayer_message)\n        self.player.load()",
  "def play(self):\n        # we need to set the volume everytime, it seems that stopping + playing\n        # the sound reset the volume.\n        self.player.set_volume(self.volume)\n        self.player.play()\n        super(SoundGstplayer, self).play()",
  "def stop(self):\n        self.player.stop()\n        super(SoundGstplayer, self).stop()",
  "def unload(self):\n        if self.player:\n            self.player.unload()\n            self.player = None",
  "def seek(self, position):\n        self.player.seek(position / self.length)",
  "def get_pos(self):\n        return self.player.get_position()",
  "def _get_length(self):\n        return self.player.get_duration()",
  "def on_volume(self, instance, volume):\n        self.player.set_volume(volume)",
  "def _get_uri(self):\n        uri = self.source\n        if not uri:\n            return\n        if '://' not in uri:\n            uri = 'file:' + pathname2url(realpath(uri))\n        return uri",
  "class SoundPygame(Sound):\n\n    # XXX we don't set __slots__ here, to automatically add\n    # a dictionary. We need that to be able to use weakref for\n    # SoundPygame object. Otherwise, it failed with:\n    # TypeError: cannot create weak reference to 'SoundPygame' object\n    # We use our clock in play() method.\n    # __slots__ = ('_data', '_channel')\n    _check_play_ev = None\n\n    @staticmethod\n    def extensions():\n        if _platform == 'android':\n            return ('wav', 'ogg', 'mp3', 'm4a')\n        return ('wav', 'ogg')\n\n    @deprecated(\n        msg='Pygame has been deprecated and will be removed after 1.11.0')\n    def __init__(self, **kwargs):\n        self._data = None\n        self._channel = None\n        super(SoundPygame, self).__init__(**kwargs)\n\n    def _check_play(self, dt):\n        if self._channel is None:\n            return False\n        if self._channel.get_busy():\n            return\n        if self.loop:\n            def do_loop(dt):\n                self.play()\n            Clock.schedule_once(do_loop)\n        else:\n            self.stop()\n        return False\n\n    def play(self):\n        if not self._data:\n            return\n        self._data.set_volume(self.volume)\n        self._channel = self._data.play()\n        self.start_time = Clock.time()\n        # schedule event to check if the sound is still playing or not\n        self._check_play_ev = Clock.schedule_interval(self._check_play, 0.1)\n        super(SoundPygame, self).play()\n\n    def stop(self):\n        if not self._data:\n            return\n        self._data.stop()\n        # ensure we don't have anymore the callback\n        if self._check_play_ev is not None:\n            self._check_play_ev.cancel()\n            self._check_play_ev = None\n        self._channel = None\n        super(SoundPygame, self).stop()\n\n    def load(self):\n        self.unload()\n        if self.source is None:\n            return\n        self._data = mixer.Sound(self.source)\n\n    def unload(self):\n        self.stop()\n        self._data = None\n\n    def seek(self, position):\n        if not self._data:\n            return\n        if _platform == 'android' and self._channel:\n            self._channel.seek(position)\n\n    def get_pos(self):\n        if self._data is not None and self._channel:\n            if _platform == 'android':\n                return self._channel.get_pos()\n            return Clock.time() - self.start_time\n        return 0\n\n    def on_volume(self, instance, volume):\n        if self._data is not None:\n            self._data.set_volume(volume)\n\n    def _get_length(self):\n        if _platform == 'android' and self._channel:\n            return self._channel.get_length()\n        if self._data is not None:\n            return self._data.get_length()\n        return super(SoundPygame, self)._get_length()",
  "def extensions():\n        if _platform == 'android':\n            return ('wav', 'ogg', 'mp3', 'm4a')\n        return ('wav', 'ogg')",
  "def __init__(self, **kwargs):\n        self._data = None\n        self._channel = None\n        super(SoundPygame, self).__init__(**kwargs)",
  "def _check_play(self, dt):\n        if self._channel is None:\n            return False\n        if self._channel.get_busy():\n            return\n        if self.loop:\n            def do_loop(dt):\n                self.play()\n            Clock.schedule_once(do_loop)\n        else:\n            self.stop()\n        return False",
  "def play(self):\n        if not self._data:\n            return\n        self._data.set_volume(self.volume)\n        self._channel = self._data.play()\n        self.start_time = Clock.time()\n        # schedule event to check if the sound is still playing or not\n        self._check_play_ev = Clock.schedule_interval(self._check_play, 0.1)\n        super(SoundPygame, self).play()",
  "def stop(self):\n        if not self._data:\n            return\n        self._data.stop()\n        # ensure we don't have anymore the callback\n        if self._check_play_ev is not None:\n            self._check_play_ev.cancel()\n            self._check_play_ev = None\n        self._channel = None\n        super(SoundPygame, self).stop()",
  "def load(self):\n        self.unload()\n        if self.source is None:\n            return\n        self._data = mixer.Sound(self.source)",
  "def unload(self):\n        self.stop()\n        self._data = None",
  "def seek(self, position):\n        if not self._data:\n            return\n        if _platform == 'android' and self._channel:\n            self._channel.seek(position)",
  "def get_pos(self):\n        if self._data is not None and self._channel:\n            if _platform == 'android':\n                return self._channel.get_pos()\n            return Clock.time() - self.start_time\n        return 0",
  "def on_volume(self, instance, volume):\n        if self._data is not None:\n            self._data.set_volume(volume)",
  "def _get_length(self):\n        if _platform == 'android' and self._channel:\n            return self._channel.get_length()\n        if self._data is not None:\n            return self._data.get_length()\n        return super(SoundPygame, self)._get_length()",
  "def do_loop(dt):\n                self.play()",
  "class SoundAvplayer(Sound):\n    @staticmethod\n    def extensions():\n        # taken from https://goo.gl/015kvU\n        return (\"aac\", \"adts\", \"aif\", \"aiff\", \"aifc\", \"caf\", \"mp3\", \"mp4\",\n                \"m4a\", \"snd\", \"au\", \"sd2\", \"wav\")\n\n    def __init__(self, **kwargs):\n        self._avplayer = None\n        super(SoundAvplayer, self).__init__(**kwargs)\n\n    def load(self):\n        self.unload()\n        fn = NSString.alloc().initWithUTF8String_(self.source)\n        url = NSURL.alloc().initFileURLWithPath_(fn)\n        self._avplayer = AVAudioPlayer.alloc().initWithContentsOfURL_error_(\n            url, None)\n\n    def unload(self):\n        self.stop()\n        self._avplayer = None\n\n    def play(self):\n        if not self._avplayer:\n            return\n        self._avplayer.play()\n        super(SoundAvplayer, self).play()\n\n    def stop(self):\n        if not self._avplayer:\n            return\n        self._avplayer.stop()\n        super(SoundAvplayer, self).stop()\n\n    def seek(self, position):\n        if not self._avplayer:\n            return\n        self._avplayer.playAtTime_(float(position))\n\n    def get_pos(self):\n        if self._avplayer:\n            return self._avplayer.currentTime\n        return super(SoundAvplayer, self).get_pos()\n\n    def on_volume(self, instance, volume):\n        if self._avplayer:\n            self._avplayer.volume = float(volume)\n\n    def _get_length(self):\n        if self._avplayer:\n            return self._avplayer.duration\n        return super(SoundAvplayer, self)._get_length()",
  "def extensions():\n        # taken from https://goo.gl/015kvU\n        return (\"aac\", \"adts\", \"aif\", \"aiff\", \"aifc\", \"caf\", \"mp3\", \"mp4\",\n                \"m4a\", \"snd\", \"au\", \"sd2\", \"wav\")",
  "def __init__(self, **kwargs):\n        self._avplayer = None\n        super(SoundAvplayer, self).__init__(**kwargs)",
  "def load(self):\n        self.unload()\n        fn = NSString.alloc().initWithUTF8String_(self.source)\n        url = NSURL.alloc().initFileURLWithPath_(fn)\n        self._avplayer = AVAudioPlayer.alloc().initWithContentsOfURL_error_(\n            url, None)",
  "def unload(self):\n        self.stop()\n        self._avplayer = None",
  "def play(self):\n        if not self._avplayer:\n            return\n        self._avplayer.play()\n        super(SoundAvplayer, self).play()",
  "def stop(self):\n        if not self._avplayer:\n            return\n        self._avplayer.stop()\n        super(SoundAvplayer, self).stop()",
  "def seek(self, position):\n        if not self._avplayer:\n            return\n        self._avplayer.playAtTime_(float(position))",
  "def get_pos(self):\n        if self._avplayer:\n            return self._avplayer.currentTime\n        return super(SoundAvplayer, self).get_pos()",
  "def on_volume(self, instance, volume):\n        if self._avplayer:\n            self._avplayer.volume = float(volume)",
  "def _get_length(self):\n        if self._avplayer:\n            return self._avplayer.duration\n        return super(SoundAvplayer, self)._get_length()",
  "def msgbox(message):\n    if sys.platform == 'win32':\n        import ctypes\n        from ctypes.wintypes import LPCWSTR\n        ctypes.windll.user32.MessageBoxW(None, LPCWSTR(message),\n                                         u\"Kivy Fatal Error\", 0)\n        sys.exit(1)",
  "def init_gl(allowed=[], ignored=[]):\n        gl_init_symbols(allowed, ignored)\n        print_gl_version()\n        gl_init_resources()",
  "def print_gl_version():\n        backend = cgl_get_initialized_backend_name()\n        Logger.info('GL: Backend used <{}>'.format(backend))\n        version = glGetString(GL_VERSION)\n        vendor = glGetString(GL_VENDOR)\n        renderer = glGetString(GL_RENDERER)\n        Logger.info('GL: OpenGL version <{0}>'.format(version))\n        Logger.info('GL: OpenGL vendor <{0}>'.format(vendor))\n        Logger.info('GL: OpenGL renderer <{0}>'.format(renderer))\n\n        # Let the user know if his graphics hardware/drivers are too old\n        major, minor = gl_get_version()\n        Logger.info('GL: OpenGL parsed version: %d, %d' % (major, minor))\n        if ((major, minor) < MIN_REQUIRED_GL_VERSION and backend != \"mock\"):\n            if hasattr(sys, \"_kivy_opengl_required_func\"):\n                sys._kivy_opengl_required_func(major, minor, version, vendor,\n                                               renderer)\n            else:\n                msg = (\n                    'GL: Minimum required OpenGL version (2.0) NOT found!\\n\\n'\n                    'OpenGL version detected: {0}.{1}\\n\\n'\n                    'Version: {2}\\nVendor: {3}\\nRenderer: {4}\\n\\n'\n                    'Try upgrading your graphics drivers and/or your '\n                    'graphics hardware in case of problems.\\n\\n'\n                    'The application will leave now.').format(\n                        major, minor, version, vendor, renderer)\n                Logger.critical(msg)\n                msgbox(msg)\n\n        if platform != 'android':\n            # XXX in the android emulator (latest version at 22 march 2013),\n            # this call was segfaulting the gl stack.\n            Logger.info('GL: Shading version <{0}>'.format(glGetString(\n                GL_SHADING_LANGUAGE_VERSION)))\n        Logger.info('GL: Texture max size <{0}>'.format(glGetIntegerv(\n            GL_MAX_TEXTURE_SIZE)[0]))\n        Logger.info('GL: Texture max units <{0}>'.format(glGetIntegerv(\n            GL_MAX_TEXTURE_IMAGE_UNITS)[0]))",
  "class ClipboardSDL2(ClipboardBase):\n\n    def get(self, mimetype):\n        return _get_text() if _has_text() else ''\n\n    def _ensure_clipboard(self):\n        super(ClipboardSDL2, self)._ensure_clipboard()\n        self._encoding = 'utf8'\n\n    def put(self, data=b'', mimetype='text/plain'):\n        _set_text(data)\n\n    def get_types(self):\n        return ['text/plain']",
  "def get(self, mimetype):\n        return _get_text() if _has_text() else ''",
  "def _ensure_clipboard(self):\n        super(ClipboardSDL2, self)._ensure_clipboard()\n        self._encoding = 'utf8'",
  "def put(self, data=b'', mimetype='text/plain'):\n        _set_text(data)",
  "def get_types(self):\n        return ['text/plain']",
  "class ClipboardXsel(ClipboardExternalBase):\n    @staticmethod\n    def _clip(inout, selection):\n        pipe = {'std' + inout: subprocess.PIPE}\n        sel = 'b' if selection == 'clipboard' else selection[0]\n        io = inout[0]\n        return subprocess.Popen(\n            ['xsel', '-' + sel + io], **pipe)",
  "def _clip(inout, selection):\n        pipe = {'std' + inout: subprocess.PIPE}\n        sel = 'b' if selection == 'clipboard' else selection[0]\n        io = inout[0]\n        return subprocess.Popen(\n            ['xsel', '-' + sel + io], **pipe)",
  "class ClipboardNSPaste(ClipboardBase):\n\n    def __init__(self):\n        super(ClipboardNSPaste, self).__init__()\n        self._clipboard = NSPasteboard.generalPasteboard()\n\n    def get(self, mimetype='text/plain'):\n        pb = self._clipboard\n        data = pb.stringForType_('public.utf8-plain-text')\n        if not data:\n            return \"\"\n        return data.UTF8String()\n\n    def put(self, data, mimetype='text/plain'):\n        pb = self._clipboard\n        pb.clearContents()\n        utf8 = NSString.alloc().initWithUTF8String_(data)\n        pb.setString_forType_(utf8, 'public.utf8-plain-text')\n\n    def get_types(self):\n        return list('text/plain',)",
  "def __init__(self):\n        super(ClipboardNSPaste, self).__init__()\n        self._clipboard = NSPasteboard.generalPasteboard()",
  "def get(self, mimetype='text/plain'):\n        pb = self._clipboard\n        data = pb.stringForType_('public.utf8-plain-text')\n        if not data:\n            return \"\"\n        return data.UTF8String()",
  "def put(self, data, mimetype='text/plain'):\n        pb = self._clipboard\n        pb.clearContents()\n        utf8 = NSString.alloc().initWithUTF8String_(data)\n        pb.setString_forType_(utf8, 'public.utf8-plain-text')",
  "def get_types(self):\n        return list('text/plain',)",
  "class ClipboardWindows(ClipboardBase):\n\n    def get(self, mimetype='text/plain'):\n        GetClipboardData = user32.GetClipboardData\n        GetClipboardData.argtypes = [wintypes.UINT]\n        GetClipboardData.restype = wintypes.HANDLE\n\n        user32.OpenClipboard(user32.GetActiveWindow())\n        # Standard Clipboard Format \"1\" is \"CF_TEXT\"\n        pcontents = GetClipboardData(13)\n\n        # if someone pastes a FILE, the content is None for SCF 13\n        # and the clipboard is locked if not closed properly\n        if not pcontents:\n            user32.CloseClipboard()\n            return ''\n        data = c_wchar_p(pcontents).value.encode(self._encoding)\n        user32.CloseClipboard()\n        return data\n\n    def put(self, text, mimetype='text/plain'):\n        text = text.decode(self._encoding)  # auto converted later\n        text += u'\\x00'\n\n        SetClipboardData = user32.SetClipboardData\n        SetClipboardData.argtypes = [wintypes.UINT, wintypes.HANDLE]\n        SetClipboardData.restype = wintypes.HANDLE\n\n        GlobalAlloc = kernel32.GlobalAlloc\n        GlobalAlloc.argtypes = [wintypes.UINT, ctypes.c_size_t]\n        GlobalAlloc.restype = wintypes.HGLOBAL\n\n        CF_UNICODETEXT = 13\n\n        user32.OpenClipboard(user32.GetActiveWindow())\n        user32.EmptyClipboard()\n        hCd = GlobalAlloc(0, len(text) * ctypes.sizeof(ctypes.c_wchar))\n\n        # ignore null character for strSource pointer\n        msvcrt.wcscpy_s(c_wchar_p(hCd), len(text), c_wchar_p(text[:-1]))\n        SetClipboardData(CF_UNICODETEXT, hCd)\n        user32.CloseClipboard()\n\n    def get_types(self):\n        return ['text/plain']",
  "def get(self, mimetype='text/plain'):\n        GetClipboardData = user32.GetClipboardData\n        GetClipboardData.argtypes = [wintypes.UINT]\n        GetClipboardData.restype = wintypes.HANDLE\n\n        user32.OpenClipboard(user32.GetActiveWindow())\n        # Standard Clipboard Format \"1\" is \"CF_TEXT\"\n        pcontents = GetClipboardData(13)\n\n        # if someone pastes a FILE, the content is None for SCF 13\n        # and the clipboard is locked if not closed properly\n        if not pcontents:\n            user32.CloseClipboard()\n            return ''\n        data = c_wchar_p(pcontents).value.encode(self._encoding)\n        user32.CloseClipboard()\n        return data",
  "def put(self, text, mimetype='text/plain'):\n        text = text.decode(self._encoding)  # auto converted later\n        text += u'\\x00'\n\n        SetClipboardData = user32.SetClipboardData\n        SetClipboardData.argtypes = [wintypes.UINT, wintypes.HANDLE]\n        SetClipboardData.restype = wintypes.HANDLE\n\n        GlobalAlloc = kernel32.GlobalAlloc\n        GlobalAlloc.argtypes = [wintypes.UINT, ctypes.c_size_t]\n        GlobalAlloc.restype = wintypes.HGLOBAL\n\n        CF_UNICODETEXT = 13\n\n        user32.OpenClipboard(user32.GetActiveWindow())\n        user32.EmptyClipboard()\n        hCd = GlobalAlloc(0, len(text) * ctypes.sizeof(ctypes.c_wchar))\n\n        # ignore null character for strSource pointer\n        msvcrt.wcscpy_s(c_wchar_p(hCd), len(text), c_wchar_p(text[:-1]))\n        SetClipboardData(CF_UNICODETEXT, hCd)\n        user32.CloseClipboard()",
  "def get_types(self):\n        return ['text/plain']",
  "class ClipboardExternalBase(ClipboardBase):\n    @staticmethod\n    def _clip(inout, selection):\n        raise NotImplementedError('clip method not implemented')\n\n    def get(self, mimetype='text/plain'):\n        p = self._clip('out', 'clipboard')\n        data, _ = p.communicate()\n        return data\n\n    def put(self, data, mimetype='text/plain'):\n        p = self._clip('in', 'clipboard')\n        p.communicate(data)\n\n    def get_cutbuffer(self):\n        p = self._clip('out', 'primary')\n        data, _ = p.communicate()\n        return data.decode('utf8')\n\n    def set_cutbuffer(self, data):\n        if not isinstance(data, bytes):\n            data = data.encode('utf8')\n        p = self._clip('in', 'primary')\n        p.communicate(data)\n\n    def get_types(self):\n        return [u'text/plain']",
  "def _clip(inout, selection):\n        raise NotImplementedError('clip method not implemented')",
  "def get(self, mimetype='text/plain'):\n        p = self._clip('out', 'clipboard')\n        data, _ = p.communicate()\n        return data",
  "def put(self, data, mimetype='text/plain'):\n        p = self._clip('in', 'clipboard')\n        p.communicate(data)",
  "def get_cutbuffer(self):\n        p = self._clip('out', 'primary')\n        data, _ = p.communicate()\n        return data.decode('utf8')",
  "def set_cutbuffer(self, data):\n        if not isinstance(data, bytes):\n            data = data.encode('utf8')\n        p = self._clip('in', 'primary')\n        p.communicate(data)",
  "def get_types(self):\n        return [u'text/plain']",
  "class ClipboardAndroid(ClipboardBase):\n\n    def __init__(self):\n        super(ClipboardAndroid, self).__init__()\n        self._clipboard = None\n        self._data = dict()\n        self._data['text/plain'] = None\n        self._data['application/data'] = None\n        PythonActivity._clipboard = None\n\n    def get(self, mimetype='text/plain'):\n        return self._get(mimetype).encode('utf-8')\n\n    def put(self, data, mimetype='text/plain'):\n        self._set(data, mimetype)\n\n    def get_types(self):\n        return list(self._data.keys())\n\n    @run_on_ui_thread\n    def _initialize_clipboard(self):\n        PythonActivity._clipboard = cast(\n            'android.app.Activity',\n            PythonActivity.mActivity).getSystemService(\n                                        Context.CLIPBOARD_SERVICE)\n\n    def _get_clipboard(f):\n        def called(*args, **kargs):\n            self = args[0]\n            if not PythonActivity._clipboard:\n                self._initialize_clipboard()\n                import time\n                while not PythonActivity._clipboard:\n                    time.sleep(.01)\n            return f(*args, **kargs)\n        return called\n\n    @_get_clipboard\n    def _get(self, mimetype='text/plain'):\n        clippy = PythonActivity._clipboard\n        data = ''\n        if sdk < 11:\n            data = clippy.getText()\n        else:\n            ClipDescription = autoclass('android.content.ClipDescription')\n            primary_clip = clippy.getPrimaryClip()\n            if primary_clip:\n                try:\n                    data = primary_clip.getItemAt(0)\n                    if data:\n                        data = data.coerceToText(\n                            PythonActivity.mActivity.getApplicationContext())\n                except Exception:\n                    Logger.exception('Clipboard: failed to paste')\n        return data\n\n    @_get_clipboard\n    def _set(self, data, mimetype):\n        clippy = PythonActivity._clipboard\n\n        if sdk < 11:\n            # versions previous to honeycomb\n            clippy.setText(AndroidString(data))\n        else:\n            ClipData = autoclass('android.content.ClipData')\n            new_clip = ClipData.newPlainText(AndroidString(\"\"),\n                                         AndroidString(data))\n            # put text data onto clipboard\n            clippy.setPrimaryClip(new_clip)",
  "def __init__(self):\n        super(ClipboardAndroid, self).__init__()\n        self._clipboard = None\n        self._data = dict()\n        self._data['text/plain'] = None\n        self._data['application/data'] = None\n        PythonActivity._clipboard = None",
  "def get(self, mimetype='text/plain'):\n        return self._get(mimetype).encode('utf-8')",
  "def put(self, data, mimetype='text/plain'):\n        self._set(data, mimetype)",
  "def get_types(self):\n        return list(self._data.keys())",
  "def _initialize_clipboard(self):\n        PythonActivity._clipboard = cast(\n            'android.app.Activity',\n            PythonActivity.mActivity).getSystemService(\n                                        Context.CLIPBOARD_SERVICE)",
  "def _get_clipboard(f):\n        def called(*args, **kargs):\n            self = args[0]\n            if not PythonActivity._clipboard:\n                self._initialize_clipboard()\n                import time\n                while not PythonActivity._clipboard:\n                    time.sleep(.01)\n            return f(*args, **kargs)\n        return called",
  "def _get(self, mimetype='text/plain'):\n        clippy = PythonActivity._clipboard\n        data = ''\n        if sdk < 11:\n            data = clippy.getText()\n        else:\n            ClipDescription = autoclass('android.content.ClipDescription')\n            primary_clip = clippy.getPrimaryClip()\n            if primary_clip:\n                try:\n                    data = primary_clip.getItemAt(0)\n                    if data:\n                        data = data.coerceToText(\n                            PythonActivity.mActivity.getApplicationContext())\n                except Exception:\n                    Logger.exception('Clipboard: failed to paste')\n        return data",
  "def _set(self, data, mimetype):\n        clippy = PythonActivity._clipboard\n\n        if sdk < 11:\n            # versions previous to honeycomb\n            clippy.setText(AndroidString(data))\n        else:\n            ClipData = autoclass('android.content.ClipData')\n            new_clip = ClipData.newPlainText(AndroidString(\"\"),\n                                         AndroidString(data))\n            # put text data onto clipboard\n            clippy.setPrimaryClip(new_clip)",
  "def called(*args, **kargs):\n            self = args[0]\n            if not PythonActivity._clipboard:\n                self._initialize_clipboard()\n                import time\n                while not PythonActivity._clipboard:\n                    time.sleep(.01)\n            return f(*args, **kargs)",
  "class ClipboardDbusKlipper(ClipboardBase):\n\n    _is_init = False\n\n    def init(self):\n        if ClipboardDbusKlipper._is_init:\n            return\n        self.iface = dbus.Interface(proxy, \"org.kde.klipper.klipper\")\n        ClipboardDbusKlipper._is_init = True\n\n    def get(self, mimetype='text/plain'):\n        self.init()\n        return str(self.iface.getClipboardContents())\n\n    def put(self, data, mimetype='text/plain'):\n        self.init()\n        self.iface.setClipboardContents(data.replace('\\x00', ''))\n\n    def get_types(self):\n        self.init()\n        return [u'text/plain']",
  "def init(self):\n        if ClipboardDbusKlipper._is_init:\n            return\n        self.iface = dbus.Interface(proxy, \"org.kde.klipper.klipper\")\n        ClipboardDbusKlipper._is_init = True",
  "def get(self, mimetype='text/plain'):\n        self.init()\n        return str(self.iface.getClipboardContents())",
  "def put(self, data, mimetype='text/plain'):\n        self.init()\n        self.iface.setClipboardContents(data.replace('\\x00', ''))",
  "def get_types(self):\n        self.init()\n        return [u'text/plain']",
  "class ClipboardGtk3(ClipboardBase):\n\n    _is_init = False\n\n    def init(self):\n        if self._is_init:\n            return\n        install_gobject_iteration()\n        self._is_init = True\n\n    def get(self, mimetype='text/plain;charset=utf-8'):\n        self.init()\n        if mimetype == 'text/plain;charset=utf-8':\n            contents = clipboard.wait_for_text()\n            if contents:\n                return contents\n        return ''\n\n    def put(self, data, mimetype='text/plain;charset=utf-8'):\n        self.init()\n        if mimetype == 'text/plain;charset=utf-8':\n            text = data.decode(self._encoding)\n            clipboard.set_text(text, -1)\n            clipboard.store()\n\n    def get_types(self):\n        self.init()\n        return ['text/plain;charset=utf-8']",
  "def init(self):\n        if self._is_init:\n            return\n        install_gobject_iteration()\n        self._is_init = True",
  "def get(self, mimetype='text/plain;charset=utf-8'):\n        self.init()\n        if mimetype == 'text/plain;charset=utf-8':\n            contents = clipboard.wait_for_text()\n            if contents:\n                return contents\n        return ''",
  "def put(self, data, mimetype='text/plain;charset=utf-8'):\n        self.init()\n        if mimetype == 'text/plain;charset=utf-8':\n            text = data.decode(self._encoding)\n            clipboard.set_text(text, -1)\n            clipboard.store()",
  "def get_types(self):\n        self.init()\n        return ['text/plain;charset=utf-8']",
  "class ClipboardDummy(ClipboardBase):\n\n    def __init__(self):\n        super(ClipboardDummy, self).__init__()\n        self._data = dict()\n        self._data['text/plain'] = None\n        self._data['application/data'] = None\n\n    def get(self, mimetype='text/plain'):\n        return self._data.get(mimetype, None)\n\n    def put(self, data, mimetype='text/plain'):\n        self._data[mimetype] = data\n\n    def get_types(self):\n        return list(self._data.keys())",
  "def __init__(self):\n        super(ClipboardDummy, self).__init__()\n        self._data = dict()\n        self._data['text/plain'] = None\n        self._data['application/data'] = None",
  "def get(self, mimetype='text/plain'):\n        return self._data.get(mimetype, None)",
  "def put(self, data, mimetype='text/plain'):\n        self._data[mimetype] = data",
  "def get_types(self):\n        return list(self._data.keys())",
  "class ClipboardPygame(ClipboardBase):\n\n    _is_init = False\n    _types = None\n\n    _aliases = {\n        'text/plain;charset=utf-8': 'UTF8_STRING'\n    }\n\n    @deprecated(\n        msg='Pygame has been deprecated and will be removed after 1.11.0')\n    def __init__(self, *largs, **kwargs):\n        super(ClipboardPygame, self).__init__(*largs, **kwargs)\n\n    def init(self):\n        if ClipboardPygame._is_init:\n            return\n        pygame.scrap.init()\n        ClipboardPygame._is_init = True\n\n    def get(self, mimetype='text/plain'):\n        self.init()\n        mimetype = self._aliases.get(mimetype, mimetype)\n        text = pygame.scrap.get(mimetype)\n        return text\n\n    def put(self, data, mimetype='text/plain'):\n        self.init()\n        mimetype = self._aliases.get(mimetype, mimetype)\n        pygame.scrap.put(mimetype, data)\n\n    def get_types(self):\n        if not self._types:\n            self.init()\n            types = pygame.scrap.get_types()\n            for mime, pygtype in list(self._aliases.items())[:]:\n                if mime in types:\n                    del self._aliases[mime]\n                if pygtype in types:\n                    types.append(mime)\n            self._types = types\n        return self._types",
  "def __init__(self, *largs, **kwargs):\n        super(ClipboardPygame, self).__init__(*largs, **kwargs)",
  "def init(self):\n        if ClipboardPygame._is_init:\n            return\n        pygame.scrap.init()\n        ClipboardPygame._is_init = True",
  "def get(self, mimetype='text/plain'):\n        self.init()\n        mimetype = self._aliases.get(mimetype, mimetype)\n        text = pygame.scrap.get(mimetype)\n        return text",
  "def put(self, data, mimetype='text/plain'):\n        self.init()\n        mimetype = self._aliases.get(mimetype, mimetype)\n        pygame.scrap.put(mimetype, data)",
  "def get_types(self):\n        if not self._types:\n            self.init()\n            types = pygame.scrap.get_types()\n            for mime, pygtype in list(self._aliases.items())[:]:\n                if mime in types:\n                    del self._aliases[mime]\n                if pygtype in types:\n                    types.append(mime)\n            self._types = types\n        return self._types",
  "class ClipboardBase(object):\n\n    def get(self, mimetype):\n        '''Get the current data in clipboard, using the mimetype if possible.\n        You not use this method directly. Use :meth:`paste` instead.\n        '''\n        pass\n\n    def put(self, data, mimetype):\n        '''Put data on the clipboard, and attach a mimetype.\n        You should not use this method directly. Use :meth:`copy` instead.\n        '''\n        pass\n\n    def get_types(self):\n        '''Return a list of supported mimetypes\n        '''\n        return []\n\n    def _ensure_clipboard(self):\n        ''' Ensure that the clipboard has been properly initialized.\n        '''\n\n        if hasattr(self, '_clip_mime_type'):\n            return\n\n        if platform == 'win':\n            self._clip_mime_type = 'text/plain;charset=utf-8'\n            # windows clipboard uses a utf-16 little endian encoding\n            self._encoding = 'utf-16-le'\n        elif platform == 'linux':\n            self._clip_mime_type = 'text/plain;charset=utf-8'\n            self._encoding = 'utf-8'\n        else:\n            self._clip_mime_type = 'text/plain'\n            self._encoding = 'utf-8'\n\n    def copy(self, data=''):\n        ''' Copy the value provided in argument `data` into current clipboard.\n        If data is not of type string it will be converted to string.\n\n        .. versionadded:: 1.9.0\n\n        '''\n        if data:\n            self._copy(data)\n\n    def paste(self):\n        ''' Get text from the system clipboard and return it a usable string.\n\n        .. versionadded:: 1.9.0\n\n        '''\n        return self._paste()\n\n    def _copy(self, data):\n        self._ensure_clipboard()\n        if not isinstance(data, bytes):\n            data = data.encode(self._encoding)\n        self.put(data, self._clip_mime_type)\n\n    def _paste(self):\n        self._ensure_clipboard()\n        _clip_types = Clipboard.get_types()\n\n        mime_type = self._clip_mime_type\n        if mime_type not in _clip_types:\n            mime_type = 'text/plain'\n\n        data = self.get(mime_type)\n        if data is not None:\n            # decode only if we don't have unicode\n            # we would still need to decode from utf-16 (windows)\n            # data is of type bytes in PY3\n            if isinstance(data, bytes):\n                data = data.decode(self._encoding, 'ignore')\n            # remove null strings mostly a windows issue\n            data = data.replace(u'\\x00', u'')\n            return data\n        return u''",
  "def get(self, mimetype):\n        '''Get the current data in clipboard, using the mimetype if possible.\n        You not use this method directly. Use :meth:`paste` instead.\n        '''\n        pass",
  "def put(self, data, mimetype):\n        '''Put data on the clipboard, and attach a mimetype.\n        You should not use this method directly. Use :meth:`copy` instead.\n        '''\n        pass",
  "def get_types(self):\n        '''Return a list of supported mimetypes\n        '''\n        return []",
  "def _ensure_clipboard(self):\n        ''' Ensure that the clipboard has been properly initialized.\n        '''\n\n        if hasattr(self, '_clip_mime_type'):\n            return\n\n        if platform == 'win':\n            self._clip_mime_type = 'text/plain;charset=utf-8'\n            # windows clipboard uses a utf-16 little endian encoding\n            self._encoding = 'utf-16-le'\n        elif platform == 'linux':\n            self._clip_mime_type = 'text/plain;charset=utf-8'\n            self._encoding = 'utf-8'\n        else:\n            self._clip_mime_type = 'text/plain'\n            self._encoding = 'utf-8'",
  "def copy(self, data=''):\n        ''' Copy the value provided in argument `data` into current clipboard.\n        If data is not of type string it will be converted to string.\n\n        .. versionadded:: 1.9.0\n\n        '''\n        if data:\n            self._copy(data)",
  "def paste(self):\n        ''' Get text from the system clipboard and return it a usable string.\n\n        .. versionadded:: 1.9.0\n\n        '''\n        return self._paste()",
  "def _copy(self, data):\n        self._ensure_clipboard()\n        if not isinstance(data, bytes):\n            data = data.encode(self._encoding)\n        self.put(data, self._clip_mime_type)",
  "def _paste(self):\n        self._ensure_clipboard()\n        _clip_types = Clipboard.get_types()\n\n        mime_type = self._clip_mime_type\n        if mime_type not in _clip_types:\n            mime_type = 'text/plain'\n\n        data = self.get(mime_type)\n        if data is not None:\n            # decode only if we don't have unicode\n            # we would still need to decode from utf-16 (windows)\n            # data is of type bytes in PY3\n            if isinstance(data, bytes):\n                data = data.decode(self._encoding, 'ignore')\n            # remove null strings mostly a windows issue\n            data = data.replace(u'\\x00', u'')\n            return data\n        return u''",
  "class ClipboardXclip(ClipboardExternalBase):\n    @staticmethod\n    def _clip(inout, selection):\n        pipe = {'std' + inout: subprocess.PIPE}\n        return subprocess.Popen(\n            ['xclip', '-' + inout, '-selection', selection], **pipe)",
  "def _clip(inout, selection):\n        pipe = {'std' + inout: subprocess.PIPE}\n        return subprocess.Popen(\n            ['xclip', '-' + inout, '-selection', selection], **pipe)",
  "def _on_gstplayer_buffer(video, width, height, data):\n    video = video()\n    # if we still receive the video but no more player, remove it.\n    if not video:\n        return\n    with video._buffer_lock:\n        video._buffer = (width, height, data)",
  "def _on_gstplayer_message(mtype, message):\n    if mtype == 'error':\n        Logger.error('VideoGstplayer: {}'.format(message))\n    elif mtype == 'warning':\n        Logger.warning('VideoGstplayer: {}'.format(message))\n    elif mtype == 'info':\n        Logger.info('VideoGstplayer: {}'.format(message))",
  "class VideoGstplayer(VideoBase):\n\n    def __init__(self, **kwargs):\n        self.player = None\n        self._buffer = None\n        self._buffer_lock = Lock()\n        super(VideoGstplayer, self).__init__(**kwargs)\n\n    def _on_gst_eos_sync(self):\n        Clock.schedule_once(self._do_eos, 0)\n\n    def load(self):\n        Logger.debug('VideoGstplayer: Load <{}>'.format(self._filename))\n        uri = self._get_uri()\n        wk_self = ref(self)\n        self.player_callback = partial(_on_gstplayer_buffer, wk_self)\n        self.player = GstPlayer(uri, self.player_callback,\n                                self._on_gst_eos_sync, _on_gstplayer_message)\n        self.player.load()\n\n    def unload(self):\n        if self.player:\n            self.player.unload()\n            self.player = None\n        with self._buffer_lock:\n            self._buffer = None\n        self._texture = None\n\n    def stop(self):\n        super(VideoGstplayer, self).stop()\n        self.player.stop()\n\n    def pause(self):\n        super(VideoGstplayer, self).pause()\n        self.player.pause()\n\n    def play(self):\n        super(VideoGstplayer, self).play()\n        self.player.set_volume(self.volume)\n        self.player.play()\n\n    def seek(self, percent, precise=True):\n        self.player.seek(percent)\n\n    def _get_position(self):\n        return self.player.get_position()\n\n    def _get_duration(self):\n        return self.player.get_duration()\n\n    def _set_volume(self, value):\n        self._volume = value\n        if self.player:\n            self.player.set_volume(self._volume)\n\n    def _update(self, dt):\n        buf = None\n        with self._buffer_lock:\n            buf = self._buffer\n            self._buffer = None\n        if buf is not None:\n            self._update_texture(buf)\n            self.dispatch('on_frame')\n\n    def _update_texture(self, buf):\n        width, height, data = buf\n\n        # texture is not allocated yet, create it first\n        if not self._texture:\n            self._texture = Texture.create(size=(width, height),\n                                           colorfmt='rgb')\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n\n        if self._texture:\n            self._texture.blit_buffer(\n                data, size=(width, height), colorfmt='rgb')\n\n    def _get_uri(self):\n        uri = self.filename\n        if not uri:\n            return\n        if '://' not in uri:\n            uri = 'file:' + pathname2url(realpath(uri))\n        return uri",
  "def __init__(self, **kwargs):\n        self.player = None\n        self._buffer = None\n        self._buffer_lock = Lock()\n        super(VideoGstplayer, self).__init__(**kwargs)",
  "def _on_gst_eos_sync(self):\n        Clock.schedule_once(self._do_eos, 0)",
  "def load(self):\n        Logger.debug('VideoGstplayer: Load <{}>'.format(self._filename))\n        uri = self._get_uri()\n        wk_self = ref(self)\n        self.player_callback = partial(_on_gstplayer_buffer, wk_self)\n        self.player = GstPlayer(uri, self.player_callback,\n                                self._on_gst_eos_sync, _on_gstplayer_message)\n        self.player.load()",
  "def unload(self):\n        if self.player:\n            self.player.unload()\n            self.player = None\n        with self._buffer_lock:\n            self._buffer = None\n        self._texture = None",
  "def stop(self):\n        super(VideoGstplayer, self).stop()\n        self.player.stop()",
  "def pause(self):\n        super(VideoGstplayer, self).pause()\n        self.player.pause()",
  "def play(self):\n        super(VideoGstplayer, self).play()\n        self.player.set_volume(self.volume)\n        self.player.play()",
  "def seek(self, percent, precise=True):\n        self.player.seek(percent)",
  "def _get_position(self):\n        return self.player.get_position()",
  "def _get_duration(self):\n        return self.player.get_duration()",
  "def _set_volume(self, value):\n        self._volume = value\n        if self.player:\n            self.player.set_volume(self._volume)",
  "def _update(self, dt):\n        buf = None\n        with self._buffer_lock:\n            buf = self._buffer\n            self._buffer = None\n        if buf is not None:\n            self._update_texture(buf)\n            self.dispatch('on_frame')",
  "def _update_texture(self, buf):\n        width, height, data = buf\n\n        # texture is not allocated yet, create it first\n        if not self._texture:\n            self._texture = Texture.create(size=(width, height),\n                                           colorfmt='rgb')\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n\n        if self._texture:\n            self._texture.blit_buffer(\n                data, size=(width, height), colorfmt='rgb')",
  "def _get_uri(self):\n        uri = self.filename\n        if not uri:\n            return\n        if '://' not in uri:\n            uri = 'file:' + pathname2url(realpath(uri))\n        return uri",
  "class VideoFFMpeg(VideoBase):\n\n    def __init__(self, **kwargs):\n        self._do_load = False\n        self._player = None\n        super(VideoFFMpeg, self).__init__(**kwargs)\n\n    def unload(self):\n        if self._player:\n            self._player.stop()\n            self._player = None\n        self._state = ''\n        self._do_load = False\n\n    def load(self):\n        self.unload()\n\n    def play(self):\n        if self._player:\n            self.unload()\n        self._player = ffmpeg.FFVideo(self._filename)\n        self._player.set_volume(self._volume)\n        self._do_load = True\n\n    def stop(self):\n        self.unload()\n\n    def seek(self, percent, precise=True):\n        if self._player is None:\n            return\n        self._player.seek(percent)\n\n    def _do_eos(self):\n        self.unload()\n        self.dispatch('on_eos')\n        super(VideoFFMpeg, self)._do_eos()\n\n    def _update(self, dt):\n        if self._do_load:\n            self._player.open()\n            self._do_load = False\n            return\n\n        player = self._player\n        if player is None:\n            return\n        if not player.is_open:\n            self._do_eos()\n            return\n\n        frame = player.get_next_frame()\n        if frame is None:\n            return\n\n        # first time we got a frame, we know that video is read now.\n        if self._texture is None:\n            self._texture = Texture.create(size=(\n                player.get_width(), player.get_height()),\n                colorfmt='rgb')\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n\n        if self._texture:\n            self._texture.blit_buffer(frame)\n            self.dispatch('on_frame')\n\n    def _get_duration(self):\n        if self._player is None:\n            return 0\n        return self._player.get_duration()\n\n    def _get_position(self):\n        if self._player is None:\n            return 0\n        return self._player.get_position()\n\n    def _set_volume(self, value):\n        self._volume = value\n        if self._player:\n            self._player.set_volume(self._volume)",
  "def __init__(self, **kwargs):\n        self._do_load = False\n        self._player = None\n        super(VideoFFMpeg, self).__init__(**kwargs)",
  "def unload(self):\n        if self._player:\n            self._player.stop()\n            self._player = None\n        self._state = ''\n        self._do_load = False",
  "def load(self):\n        self.unload()",
  "def play(self):\n        if self._player:\n            self.unload()\n        self._player = ffmpeg.FFVideo(self._filename)\n        self._player.set_volume(self._volume)\n        self._do_load = True",
  "def stop(self):\n        self.unload()",
  "def seek(self, percent, precise=True):\n        if self._player is None:\n            return\n        self._player.seek(percent)",
  "def _do_eos(self):\n        self.unload()\n        self.dispatch('on_eos')\n        super(VideoFFMpeg, self)._do_eos()",
  "def _update(self, dt):\n        if self._do_load:\n            self._player.open()\n            self._do_load = False\n            return\n\n        player = self._player\n        if player is None:\n            return\n        if not player.is_open:\n            self._do_eos()\n            return\n\n        frame = player.get_next_frame()\n        if frame is None:\n            return\n\n        # first time we got a frame, we know that video is read now.\n        if self._texture is None:\n            self._texture = Texture.create(size=(\n                player.get_width(), player.get_height()),\n                colorfmt='rgb')\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n\n        if self._texture:\n            self._texture.blit_buffer(frame)\n            self.dispatch('on_frame')",
  "def _get_duration(self):\n        if self._player is None:\n            return 0\n        return self._player.get_duration()",
  "def _get_position(self):\n        if self._player is None:\n            return 0\n        return self._player.get_position()",
  "def _set_volume(self, value):\n        self._volume = value\n        if self._player:\n            self._player.set_volume(self._volume)",
  "def _log_callback(message, level):\n    message = message.strip()\n    if message:\n        logger_func[level]('ffpyplayer: {}'.format(message))",
  "class VideoFFPy(VideoBase):\n\n    YUV_RGB_FS = \"\"\"\n    $HEADER$\n    uniform sampler2D tex_y;\n    uniform sampler2D tex_u;\n    uniform sampler2D tex_v;\n\n    void main(void) {\n        float y = texture2D(tex_y, tex_coord0).r;\n        float u = texture2D(tex_u, tex_coord0).r - 0.5;\n        float v = texture2D(tex_v, tex_coord0).r - 0.5;\n        float r = y +             1.402 * v;\n        float g = y - 0.344 * u - 0.714 * v;\n        float b = y + 1.772 * u;\n        gl_FragColor = vec4(r, g, b, 1.0);\n    }\n    \"\"\"\n\n    _trigger = None\n\n    def __init__(self, **kwargs):\n        self._ffplayer = None\n        self._thread = None\n        self._next_frame = None\n        self._seek_queue = []\n        self._ffplayer_need_quit = False\n        self._wakeup_queue = Queue(maxsize=1)\n        self._trigger = Clock.create_trigger(self._redraw)\n\n        super(VideoFFPy, self).__init__(**kwargs)\n\n    @property\n    def _is_stream(self):\n        # This is only used when building ff_opts, to prevent starting\n        # player paused and can probably be removed as soon as the 'eof'\n        # receiving issue is solved.\n        # See https://github.com/matham/ffpyplayer/issues/142\n        return self.filename.startswith('rtsp://')\n\n    def __del__(self):\n        self.unload()\n\n    def _wakeup_thread(self):\n        try:\n            self._wakeup_queue.put(None, False)\n        except Full:\n            pass\n\n    def _wait_for_wakeup(self, timeout):\n        try:\n            self._wakeup_queue.get(True, timeout)\n        except Empty:\n            pass\n\n    def _player_callback(self, selector, value):\n        if self._ffplayer is None:\n            return\n        if selector == 'quit':\n            def close(*args):\n                self.unload()\n            Clock.schedule_once(close, 0)\n\n    def _get_position(self):\n        if self._ffplayer is not None:\n            return self._ffplayer.get_pts()\n        return 0\n\n    def _set_position(self, pos):\n        self.seek(pos)\n\n    def _set_volume(self, volume):\n        self._volume = volume\n        if self._ffplayer is not None:\n            self._ffplayer.set_volume(self._volume)\n\n    def _get_duration(self):\n        if self._ffplayer is None:\n            return 0\n        return self._ffplayer.get_metadata()['duration']\n\n    @mainthread\n    def _do_eos(self):\n        if self.eos == 'pause':\n            self.pause()\n        elif self.eos == 'stop':\n            self.stop()\n        elif self.eos == 'loop':\n            # this causes a seek to zero\n            self.position = 0\n\n        self.dispatch('on_eos')\n\n    @mainthread\n    def _finish_setup(self):\n        # once setup is done, we make sure player state matches what user\n        # could have requested while player was being setup and it was in limbo\n        # also, thread starts player in internal paused mode, so this unpauses\n        # it if user didn't request pause meanwhile\n        if self._ffplayer is not None:\n            self._ffplayer.set_volume(self._volume)\n            self._ffplayer.set_pause(self._state == 'paused')\n            self._wakeup_thread()\n\n    def _redraw(self, *args):\n        if not self._ffplayer:\n            return\n        next_frame = self._next_frame\n        if not next_frame:\n            return\n\n        img, pts = next_frame\n        if img.get_size() != self._size or self._texture is None:\n            self._size = w, h = img.get_size()\n\n            if self._out_fmt == 'yuv420p':\n                w2 = int(w / 2)\n                h2 = int(h / 2)\n                self._tex_y = Texture.create(\n                    size=(w, h), colorfmt='luminance')\n                self._tex_u = Texture.create(\n                    size=(w2, h2), colorfmt='luminance')\n                self._tex_v = Texture.create(\n                    size=(w2, h2), colorfmt='luminance')\n                self._fbo = fbo = Fbo(size=self._size)\n                with fbo:\n                    BindTexture(texture=self._tex_u, index=1)\n                    BindTexture(texture=self._tex_v, index=2)\n                    Rectangle(size=fbo.size, texture=self._tex_y)\n                fbo.shader.fs = VideoFFPy.YUV_RGB_FS\n                fbo['tex_y'] = 0\n                fbo['tex_u'] = 1\n                fbo['tex_v'] = 2\n                self._texture = fbo.texture\n            else:\n                self._texture = Texture.create(size=self._size,\n                                               colorfmt='rgba')\n\n            # XXX FIXME\n            # self.texture.add_reload_observer(self.reload_buffer)\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n\n        if self._texture:\n            if self._out_fmt == 'yuv420p':\n                dy, du, dv, _ = img.to_memoryview()\n                if dy and du and dv:\n                    self._tex_y.blit_buffer(dy, colorfmt='luminance')\n                    self._tex_u.blit_buffer(du, colorfmt='luminance')\n                    self._tex_v.blit_buffer(dv, colorfmt='luminance')\n                    self._fbo.ask_update()\n                    self._fbo.draw()\n            else:\n                self._texture.blit_buffer(\n                    img.to_memoryview()[0], colorfmt='rgba')\n\n            self.dispatch('on_frame')\n\n    def _next_frame_run(self, ffplayer):\n        sleep = time.sleep\n        trigger = self._trigger\n        did_dispatch_eof = False\n        wait_for_wakeup = self._wait_for_wakeup\n        seek_queue = self._seek_queue\n        # video starts in internal paused state\n\n        # fast path, if the source video is yuv420p, we'll use a glsl shader\n        # for buffer conversion to rgba\n        # wait until we get frame metadata\n        while not self._ffplayer_need_quit:\n            src_pix_fmt = ffplayer.get_metadata().get('src_pix_fmt')\n            if not src_pix_fmt:\n                wait_for_wakeup(0.005)\n                continue\n\n            # ffpyplayer reports src_pix_fmt as bytes. this may or may not\n            # change in future, so we check for both bytes and str\n            if src_pix_fmt in (b'yuv420p', 'yuv420p'):\n                self._out_fmt = 'yuv420p'\n                ffplayer.set_output_pix_fmt(self._out_fmt)\n            break\n\n        if self._ffplayer_need_quit:\n            ffplayer.close_player()\n            return\n\n        self._ffplayer = ffplayer\n        self._finish_setup()\n        # now, we'll be in internal paused state and loop will wait until\n        # mainthread unpauses us when finishing setup\n\n        while not self._ffplayer_need_quit:\n            seek_happened = False\n            if seek_queue:\n                vals = seek_queue[:]\n                del seek_queue[:len(vals)]\n                percent, precise = vals[-1]\n                ffplayer.seek(\n                    percent * ffplayer.get_metadata()['duration'],\n                    relative=False,\n                    accurate=precise\n                )\n                seek_happened = True\n                did_dispatch_eof = False\n                self._next_frame = None\n\n            # Get next frame if paused:\n            if seek_happened and ffplayer.get_pause():\n                ffplayer.set_volume(0.0)  # Try to do it silently.\n                ffplayer.set_pause(False)\n                try:\n                    # We don't know concrete number of frames to skip,\n                    # this number worked fine on couple of tested videos:\n                    to_skip = 6\n                    while True:\n                        frame, val = ffplayer.get_frame(show=False)\n                        # Exit loop on invalid val:\n                        if val in ('paused', 'eof'):\n                            break\n                        # Exit loop on seek_queue updated:\n                        if seek_queue:\n                            break\n                        # Wait for next frame:\n                        if frame is None:\n                            sleep(0.005)\n                            continue\n                        # Wait until we skipped enough frames:\n                        to_skip -= 1\n                        if to_skip == 0:\n                            break\n                    # Assuming last frame is actual, just get it:\n                    frame, val = ffplayer.get_frame(force_refresh=True)\n                finally:\n                    ffplayer.set_pause(bool(self._state == 'paused'))\n                    # todo: this is not safe because user could have updated\n                    # volume between us reading it and setting it\n                    ffplayer.set_volume(self._volume)\n            # Get next frame regular:\n            else:\n                frame, val = ffplayer.get_frame()\n\n            if val == 'eof':\n                if not did_dispatch_eof:\n                    self._do_eos()\n                    did_dispatch_eof = True\n                wait_for_wakeup(None)\n            elif val == 'paused':\n                did_dispatch_eof = False\n                wait_for_wakeup(None)\n            else:\n                did_dispatch_eof = False\n                if frame:\n                    self._next_frame = frame\n                    trigger()\n                else:\n                    val = val if val else (1 / 30.)\n                wait_for_wakeup(val)\n\n        ffplayer.close_player()\n\n    def seek(self, percent, precise=True):\n        # still save seek while thread is setting up\n        self._seek_queue.append((percent, precise,))\n        self._wakeup_thread()\n\n    def stop(self):\n        self.unload()\n\n    def pause(self):\n        # if state hasn't been set (empty), there's no player. If it's\n        # paused, nothing to do so just handle playing\n        if self._state == 'playing':\n            # we could be in limbo while player is setting up so check. Player\n            # will pause when finishing setting up\n            if self._ffplayer is not None:\n                self._ffplayer.set_pause(True)\n            # even in limbo, indicate to start in paused state\n            self._state = 'paused'\n            self._wakeup_thread()\n\n    def play(self):\n        # _state starts empty and is empty again after unloading\n        if self._ffplayer:\n            # player is already setup, just handle unpausing\n            assert self._state in ('paused', 'playing')\n            if self._state == 'paused':\n                self._ffplayer.set_pause(False)\n                self._state = 'playing'\n                self._wakeup_thread()\n            return\n\n        # we're now either in limbo state waiting for thread to setup,\n        # or no thread has been started\n        if self._state == 'playing':\n            # in limbo, just wait for thread to setup player\n            return\n        elif self._state == 'paused':\n            # in limbo, still unpause for when player becomes ready\n            self._state = 'playing'\n            self._wakeup_thread()\n            return\n\n        # load first unloads\n        self.load()\n        self._out_fmt = 'rgba'\n        # if no stream, it starts internally paused, but unpauses itself\n        # if stream and we start paused, we sometimes receive eof after a\n        # few frames, depending on the stream producer.\n        # XXX: This probably needs to be figured out in ffpyplayer, using\n        #      ffplay directly works.\n        ff_opts = {\n            'paused': not self._is_stream,\n            'out_fmt': self._out_fmt,\n            'sn': True,\n            'volume': self._volume,\n        }\n        ffplayer = MediaPlayer(\n            self._filename, callback=self._player_callback,\n            thread_lib='SDL',\n            loglevel='info', ff_opts=ff_opts\n        )\n\n        # Disabled as an attempt to fix kivy issue #6210\n        # self._ffplayer.set_volume(self._volume)\n\n        self._thread = Thread(\n            target=self._next_frame_run,\n            name='Next frame',\n            args=(ffplayer, )\n        )\n        # todo: remove\n        self._thread.daemon = True\n\n        # start in playing mode, but _ffplayer isn't set until ready. We're\n        # now in a limbo state\n        self._state = 'playing'\n        self._thread.start()\n\n    def load(self):\n        self.unload()\n\n    def unload(self):\n        # no need to call self._trigger.cancel() because _ffplayer is set\n        # to None below, and it's not safe to call clock stuff from __del__\n\n        # if thread is still alive, set it to exit and wake it\n        self._wakeup_thread()\n        self._ffplayer_need_quit = True\n        # wait until it exits\n        if self._thread:\n            # TODO: use callback, don't block here\n            self._thread.join()\n            self._thread = None\n\n        if self._ffplayer:\n            self._ffplayer = None\n        self._next_frame = None\n        self._size = (0, 0)\n        self._state = ''\n        self._seek_queue = []\n\n        # reset for next load since thread is dead for sure\n        self._ffplayer_need_quit = False\n        self._wakeup_queue = Queue(maxsize=1)",
  "def __init__(self, **kwargs):\n        self._ffplayer = None\n        self._thread = None\n        self._next_frame = None\n        self._seek_queue = []\n        self._ffplayer_need_quit = False\n        self._wakeup_queue = Queue(maxsize=1)\n        self._trigger = Clock.create_trigger(self._redraw)\n\n        super(VideoFFPy, self).__init__(**kwargs)",
  "def _is_stream(self):\n        # This is only used when building ff_opts, to prevent starting\n        # player paused and can probably be removed as soon as the 'eof'\n        # receiving issue is solved.\n        # See https://github.com/matham/ffpyplayer/issues/142\n        return self.filename.startswith('rtsp://')",
  "def __del__(self):\n        self.unload()",
  "def _wakeup_thread(self):\n        try:\n            self._wakeup_queue.put(None, False)\n        except Full:\n            pass",
  "def _wait_for_wakeup(self, timeout):\n        try:\n            self._wakeup_queue.get(True, timeout)\n        except Empty:\n            pass",
  "def _player_callback(self, selector, value):\n        if self._ffplayer is None:\n            return\n        if selector == 'quit':\n            def close(*args):\n                self.unload()\n            Clock.schedule_once(close, 0)",
  "def _get_position(self):\n        if self._ffplayer is not None:\n            return self._ffplayer.get_pts()\n        return 0",
  "def _set_position(self, pos):\n        self.seek(pos)",
  "def _set_volume(self, volume):\n        self._volume = volume\n        if self._ffplayer is not None:\n            self._ffplayer.set_volume(self._volume)",
  "def _get_duration(self):\n        if self._ffplayer is None:\n            return 0\n        return self._ffplayer.get_metadata()['duration']",
  "def _do_eos(self):\n        if self.eos == 'pause':\n            self.pause()\n        elif self.eos == 'stop':\n            self.stop()\n        elif self.eos == 'loop':\n            # this causes a seek to zero\n            self.position = 0\n\n        self.dispatch('on_eos')",
  "def _finish_setup(self):\n        # once setup is done, we make sure player state matches what user\n        # could have requested while player was being setup and it was in limbo\n        # also, thread starts player in internal paused mode, so this unpauses\n        # it if user didn't request pause meanwhile\n        if self._ffplayer is not None:\n            self._ffplayer.set_volume(self._volume)\n            self._ffplayer.set_pause(self._state == 'paused')\n            self._wakeup_thread()",
  "def _redraw(self, *args):\n        if not self._ffplayer:\n            return\n        next_frame = self._next_frame\n        if not next_frame:\n            return\n\n        img, pts = next_frame\n        if img.get_size() != self._size or self._texture is None:\n            self._size = w, h = img.get_size()\n\n            if self._out_fmt == 'yuv420p':\n                w2 = int(w / 2)\n                h2 = int(h / 2)\n                self._tex_y = Texture.create(\n                    size=(w, h), colorfmt='luminance')\n                self._tex_u = Texture.create(\n                    size=(w2, h2), colorfmt='luminance')\n                self._tex_v = Texture.create(\n                    size=(w2, h2), colorfmt='luminance')\n                self._fbo = fbo = Fbo(size=self._size)\n                with fbo:\n                    BindTexture(texture=self._tex_u, index=1)\n                    BindTexture(texture=self._tex_v, index=2)\n                    Rectangle(size=fbo.size, texture=self._tex_y)\n                fbo.shader.fs = VideoFFPy.YUV_RGB_FS\n                fbo['tex_y'] = 0\n                fbo['tex_u'] = 1\n                fbo['tex_v'] = 2\n                self._texture = fbo.texture\n            else:\n                self._texture = Texture.create(size=self._size,\n                                               colorfmt='rgba')\n\n            # XXX FIXME\n            # self.texture.add_reload_observer(self.reload_buffer)\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n\n        if self._texture:\n            if self._out_fmt == 'yuv420p':\n                dy, du, dv, _ = img.to_memoryview()\n                if dy and du and dv:\n                    self._tex_y.blit_buffer(dy, colorfmt='luminance')\n                    self._tex_u.blit_buffer(du, colorfmt='luminance')\n                    self._tex_v.blit_buffer(dv, colorfmt='luminance')\n                    self._fbo.ask_update()\n                    self._fbo.draw()\n            else:\n                self._texture.blit_buffer(\n                    img.to_memoryview()[0], colorfmt='rgba')\n\n            self.dispatch('on_frame')",
  "def _next_frame_run(self, ffplayer):\n        sleep = time.sleep\n        trigger = self._trigger\n        did_dispatch_eof = False\n        wait_for_wakeup = self._wait_for_wakeup\n        seek_queue = self._seek_queue\n        # video starts in internal paused state\n\n        # fast path, if the source video is yuv420p, we'll use a glsl shader\n        # for buffer conversion to rgba\n        # wait until we get frame metadata\n        while not self._ffplayer_need_quit:\n            src_pix_fmt = ffplayer.get_metadata().get('src_pix_fmt')\n            if not src_pix_fmt:\n                wait_for_wakeup(0.005)\n                continue\n\n            # ffpyplayer reports src_pix_fmt as bytes. this may or may not\n            # change in future, so we check for both bytes and str\n            if src_pix_fmt in (b'yuv420p', 'yuv420p'):\n                self._out_fmt = 'yuv420p'\n                ffplayer.set_output_pix_fmt(self._out_fmt)\n            break\n\n        if self._ffplayer_need_quit:\n            ffplayer.close_player()\n            return\n\n        self._ffplayer = ffplayer\n        self._finish_setup()\n        # now, we'll be in internal paused state and loop will wait until\n        # mainthread unpauses us when finishing setup\n\n        while not self._ffplayer_need_quit:\n            seek_happened = False\n            if seek_queue:\n                vals = seek_queue[:]\n                del seek_queue[:len(vals)]\n                percent, precise = vals[-1]\n                ffplayer.seek(\n                    percent * ffplayer.get_metadata()['duration'],\n                    relative=False,\n                    accurate=precise\n                )\n                seek_happened = True\n                did_dispatch_eof = False\n                self._next_frame = None\n\n            # Get next frame if paused:\n            if seek_happened and ffplayer.get_pause():\n                ffplayer.set_volume(0.0)  # Try to do it silently.\n                ffplayer.set_pause(False)\n                try:\n                    # We don't know concrete number of frames to skip,\n                    # this number worked fine on couple of tested videos:\n                    to_skip = 6\n                    while True:\n                        frame, val = ffplayer.get_frame(show=False)\n                        # Exit loop on invalid val:\n                        if val in ('paused', 'eof'):\n                            break\n                        # Exit loop on seek_queue updated:\n                        if seek_queue:\n                            break\n                        # Wait for next frame:\n                        if frame is None:\n                            sleep(0.005)\n                            continue\n                        # Wait until we skipped enough frames:\n                        to_skip -= 1\n                        if to_skip == 0:\n                            break\n                    # Assuming last frame is actual, just get it:\n                    frame, val = ffplayer.get_frame(force_refresh=True)\n                finally:\n                    ffplayer.set_pause(bool(self._state == 'paused'))\n                    # todo: this is not safe because user could have updated\n                    # volume between us reading it and setting it\n                    ffplayer.set_volume(self._volume)\n            # Get next frame regular:\n            else:\n                frame, val = ffplayer.get_frame()\n\n            if val == 'eof':\n                if not did_dispatch_eof:\n                    self._do_eos()\n                    did_dispatch_eof = True\n                wait_for_wakeup(None)\n            elif val == 'paused':\n                did_dispatch_eof = False\n                wait_for_wakeup(None)\n            else:\n                did_dispatch_eof = False\n                if frame:\n                    self._next_frame = frame\n                    trigger()\n                else:\n                    val = val if val else (1 / 30.)\n                wait_for_wakeup(val)\n\n        ffplayer.close_player()",
  "def seek(self, percent, precise=True):\n        # still save seek while thread is setting up\n        self._seek_queue.append((percent, precise,))\n        self._wakeup_thread()",
  "def stop(self):\n        self.unload()",
  "def pause(self):\n        # if state hasn't been set (empty), there's no player. If it's\n        # paused, nothing to do so just handle playing\n        if self._state == 'playing':\n            # we could be in limbo while player is setting up so check. Player\n            # will pause when finishing setting up\n            if self._ffplayer is not None:\n                self._ffplayer.set_pause(True)\n            # even in limbo, indicate to start in paused state\n            self._state = 'paused'\n            self._wakeup_thread()",
  "def play(self):\n        # _state starts empty and is empty again after unloading\n        if self._ffplayer:\n            # player is already setup, just handle unpausing\n            assert self._state in ('paused', 'playing')\n            if self._state == 'paused':\n                self._ffplayer.set_pause(False)\n                self._state = 'playing'\n                self._wakeup_thread()\n            return\n\n        # we're now either in limbo state waiting for thread to setup,\n        # or no thread has been started\n        if self._state == 'playing':\n            # in limbo, just wait for thread to setup player\n            return\n        elif self._state == 'paused':\n            # in limbo, still unpause for when player becomes ready\n            self._state = 'playing'\n            self._wakeup_thread()\n            return\n\n        # load first unloads\n        self.load()\n        self._out_fmt = 'rgba'\n        # if no stream, it starts internally paused, but unpauses itself\n        # if stream and we start paused, we sometimes receive eof after a\n        # few frames, depending on the stream producer.\n        # XXX: This probably needs to be figured out in ffpyplayer, using\n        #      ffplay directly works.\n        ff_opts = {\n            'paused': not self._is_stream,\n            'out_fmt': self._out_fmt,\n            'sn': True,\n            'volume': self._volume,\n        }\n        ffplayer = MediaPlayer(\n            self._filename, callback=self._player_callback,\n            thread_lib='SDL',\n            loglevel='info', ff_opts=ff_opts\n        )\n\n        # Disabled as an attempt to fix kivy issue #6210\n        # self._ffplayer.set_volume(self._volume)\n\n        self._thread = Thread(\n            target=self._next_frame_run,\n            name='Next frame',\n            args=(ffplayer, )\n        )\n        # todo: remove\n        self._thread.daemon = True\n\n        # start in playing mode, but _ffplayer isn't set until ready. We're\n        # now in a limbo state\n        self._state = 'playing'\n        self._thread.start()",
  "def load(self):\n        self.unload()",
  "def unload(self):\n        # no need to call self._trigger.cancel() because _ffplayer is set\n        # to None below, and it's not safe to call clock stuff from __del__\n\n        # if thread is still alive, set it to exit and wake it\n        self._wakeup_thread()\n        self._ffplayer_need_quit = True\n        # wait until it exits\n        if self._thread:\n            # TODO: use callback, don't block here\n            self._thread.join()\n            self._thread = None\n\n        if self._ffplayer:\n            self._ffplayer = None\n        self._next_frame = None\n        self._size = (0, 0)\n        self._state = ''\n        self._seek_queue = []\n\n        # reset for next load since thread is dead for sure\n        self._ffplayer_need_quit = False\n        self._wakeup_queue = Queue(maxsize=1)",
  "def close(*args):\n                self.unload()",
  "class VideoBase(EventDispatcher):\n    '''VideoBase, a class used to implement a video reader.\n\n    :Parameters:\n        `filename`: str\n            Filename of the video. Can be a file or an URI.\n        `eos`: str, defaults to 'pause'\n            Action to take when EOS is hit. Can be one of 'pause', 'stop' or\n            'loop'.\n\n            .. versionchanged:: 1.4.0\n                added 'pause'\n\n        `async`: bool, defaults to True\n            Load the video asynchronously (may be not supported by all\n            providers).\n        `autoplay`: bool, defaults to False\n            Auto play the video on init.\n\n    :Events:\n        `on_eos`\n            Fired when EOS is hit.\n        `on_load`\n            Fired when the video is loaded and the texture is available.\n        `on_frame`\n            Fired when a new frame is written to the texture.\n    '''\n\n    __slots__ = ('_wantplay', '_buffer', '_filename', '_texture',\n                 '_volume', 'eos', '_state', '_async', '_autoplay')\n\n    __events__ = ('on_eos', 'on_load', 'on_frame')\n\n    def __init__(self, **kwargs):\n        kwargs.setdefault('filename', None)\n        kwargs.setdefault('eos', 'stop')\n        kwargs.setdefault('async', True)\n        kwargs.setdefault('autoplay', False)\n\n        super(VideoBase, self).__init__()\n\n        self._wantplay = False\n        self._buffer = None\n        self._filename = None\n        self._texture = None\n        self._volume = 1.\n        self._state = ''\n\n        self._autoplay = kwargs.get('autoplay')\n        self._async = kwargs.get('async')\n        self.eos = kwargs.get('eos')\n        if self.eos == 'pause':\n            Logger.warning(\"'pause' is deprecated. Use 'stop' instead.\")\n            self.eos = 'stop'\n        self.filename = kwargs.get('filename')\n\n        Clock.schedule_interval(self._update, 1 / 30.)\n\n        if self._autoplay:\n            self.play()\n\n    def __del__(self):\n        self.unload()\n\n    def on_eos(self):\n        pass\n\n    def on_load(self):\n        pass\n\n    def on_frame(self):\n        pass\n\n    def _get_filename(self):\n        return self._filename\n\n    def _set_filename(self, filename):\n        if filename == self._filename:\n            return\n        self.unload()\n        self._filename = filename\n        if self._filename is None:\n            return\n        self.load()\n\n    filename = property(lambda self: self._get_filename(),\n                        lambda self, x: self._set_filename(x),\n                        doc='Get/set the filename/uri of the current video')\n\n    def _get_position(self):\n        return 0\n\n    def _set_position(self, pos):\n        self.seek(pos)\n\n    position = property(lambda self: self._get_position(),\n                        lambda self, x: self._set_position(x),\n                        doc='Get/set the position in the video (in seconds)')\n\n    def _get_volume(self):\n        return self._volume\n\n    def _set_volume(self, volume):\n        self._volume = volume\n\n    volume = property(lambda self: self._get_volume(),\n                      lambda self, x: self._set_volume(x),\n                      doc='Get/set the volume in the video (1.0 = 100%)')\n\n    def _get_duration(self):\n        return 0\n\n    duration = property(lambda self: self._get_duration(),\n                        doc='Get the video duration (in seconds)')\n\n    def _get_texture(self):\n        return self._texture\n\n    texture = property(lambda self: self._get_texture(),\n                       doc='Get the video texture')\n\n    def _get_state(self):\n        return self._state\n\n    state = property(lambda self: self._get_state(),\n                     doc='Get the video playing status')\n\n    def _do_eos(self, *args):\n        '''\n        .. versionchanged:: 1.4.0\n            Now dispatches the `on_eos` event.\n        '''\n        if self.eos == 'pause':\n            self.pause()\n        elif self.eos == 'stop':\n            self.stop()\n        elif self.eos == 'loop':\n            self.position = 0\n            self.play()\n\n        self.dispatch('on_eos')\n\n    def _update(self, dt):\n        '''Update the video content to texture.\n        '''\n        pass\n\n    def seek(self, percent, precise=True):\n        '''Move to position as percentage (strictly, a proportion from\n            0 - 1) of the duration'''\n        pass\n\n    def stop(self):\n        '''Stop the video playing'''\n        self._state = ''\n\n    def pause(self):\n        '''Pause the video\n\n        .. versionadded:: 1.4.0\n        '''\n        self._state = 'paused'\n\n    def play(self):\n        '''Play the video'''\n        self._state = 'playing'\n\n    def load(self):\n        '''Load the video from the current filename'''\n        pass\n\n    def unload(self):\n        '''Unload the actual video'''\n        self._state = ''",
  "def __init__(self, **kwargs):\n        kwargs.setdefault('filename', None)\n        kwargs.setdefault('eos', 'stop')\n        kwargs.setdefault('async', True)\n        kwargs.setdefault('autoplay', False)\n\n        super(VideoBase, self).__init__()\n\n        self._wantplay = False\n        self._buffer = None\n        self._filename = None\n        self._texture = None\n        self._volume = 1.\n        self._state = ''\n\n        self._autoplay = kwargs.get('autoplay')\n        self._async = kwargs.get('async')\n        self.eos = kwargs.get('eos')\n        if self.eos == 'pause':\n            Logger.warning(\"'pause' is deprecated. Use 'stop' instead.\")\n            self.eos = 'stop'\n        self.filename = kwargs.get('filename')\n\n        Clock.schedule_interval(self._update, 1 / 30.)\n\n        if self._autoplay:\n            self.play()",
  "def __del__(self):\n        self.unload()",
  "def on_eos(self):\n        pass",
  "def on_load(self):\n        pass",
  "def on_frame(self):\n        pass",
  "def _get_filename(self):\n        return self._filename",
  "def _set_filename(self, filename):\n        if filename == self._filename:\n            return\n        self.unload()\n        self._filename = filename\n        if self._filename is None:\n            return\n        self.load()",
  "def _get_position(self):\n        return 0",
  "def _set_position(self, pos):\n        self.seek(pos)",
  "def _get_volume(self):\n        return self._volume",
  "def _set_volume(self, volume):\n        self._volume = volume",
  "def _get_duration(self):\n        return 0",
  "def _get_texture(self):\n        return self._texture",
  "def _get_state(self):\n        return self._state",
  "def _do_eos(self, *args):\n        '''\n        .. versionchanged:: 1.4.0\n            Now dispatches the `on_eos` event.\n        '''\n        if self.eos == 'pause':\n            self.pause()\n        elif self.eos == 'stop':\n            self.stop()\n        elif self.eos == 'loop':\n            self.position = 0\n            self.play()\n\n        self.dispatch('on_eos')",
  "def _update(self, dt):\n        '''Update the video content to texture.\n        '''\n        pass",
  "def seek(self, percent, precise=True):\n        '''Move to position as percentage (strictly, a proportion from\n            0 - 1) of the duration'''\n        pass",
  "def stop(self):\n        '''Stop the video playing'''\n        self._state = ''",
  "def pause(self):\n        '''Pause the video\n\n        .. versionadded:: 1.4.0\n        '''\n        self._state = 'paused'",
  "def play(self):\n        '''Play the video'''\n        self._state = 'playing'",
  "def load(self):\n        '''Load the video from the current filename'''\n        pass",
  "def unload(self):\n        '''Unload the actual video'''\n        self._state = ''",
  "class VideoNull(VideoBase):\n    '''VideoBase implementation when there is no provider.\n    '''\n    pass",
  "class _MapInfo(Structure):\n    _fields_ = [\n        ('memory', c_void_p),\n        ('flags', c_int),\n        ('data', c_void_p)]",
  "def _on_cameragi_unref(obj):\n    if obj in CameraGi._instances:\n        CameraGi._instances.remove(obj)",
  "class CameraGi(CameraBase):\n    '''Implementation of CameraBase using GStreamer\n\n    :Parameters:\n        `video_src`: str, default is 'v4l2src'\n            Other tested options are: 'dc1394src' for firewire\n            dc camera (e.g. firefly MV). Any gstreamer video source\n            should potentially work.\n            Theoretically a longer string using \"!\" can be used\n            describing the first part of a gstreamer pipeline.\n    '''\n\n    _instances = []\n\n    def __init__(self, **kwargs):\n        self._pipeline = None\n        self._camerasink = None\n        self._decodebin = None\n        self._texturesize = None\n        self._video_src = kwargs.get('video_src', 'v4l2src')\n        wk = ref(self, _on_cameragi_unref)\n        CameraGi._instances.append(wk)\n        super(CameraGi, self).__init__(**kwargs)\n\n    def init_camera(self):\n        # TODO: This doesn't work when camera resolution is resized at runtime.\n        # There must be some other way to release the camera?\n        if self._pipeline:\n            self._pipeline = None\n\n        video_src = self._video_src\n        if video_src == 'v4l2src':\n            video_src += ' device=/dev/video%d' % self._index\n        elif video_src == 'dc1394src':\n            video_src += ' camera-number=%d' % self._index\n\n        if Gst.version() < (1, 0, 0, 0):\n            caps = ('video/x-raw-rgb,red_mask=(int)0xff0000,'\n                    'green_mask=(int)0x00ff00,blue_mask=(int)0x0000ff')\n            pl = ('{} ! decodebin name=decoder ! ffmpegcolorspace ! '\n                  'appsink name=camerasink emit-signals=True caps={}')\n        else:\n            caps = 'video/x-raw,format=RGB'\n            pl = '{} ! decodebin name=decoder ! videoconvert ! appsink ' + \\\n                 'name=camerasink emit-signals=True caps={}'\n\n        self._pipeline = Gst.parse_launch(pl.format(video_src, caps))\n        self._camerasink = self._pipeline.get_by_name('camerasink')\n        self._camerasink.connect('new-sample', self._gst_new_sample)\n        self._decodebin = self._pipeline.get_by_name('decoder')\n\n        if self._camerasink and not self.stopped:\n            self.start()\n\n    def _gst_new_sample(self, *largs):\n        sample = self._camerasink.emit('pull-sample')\n        if sample is None:\n            return False\n\n        self._sample = sample\n\n        if self._texturesize is None:\n            # try to get the camera image size\n            for pad in self._decodebin.srcpads:\n                s = pad.get_current_caps().get_structure(0)\n                self._texturesize = (\n                    s.get_value('width'),\n                    s.get_value('height'))\n                Clock.schedule_once(self._update)\n                return False\n\n        Clock.schedule_once(self._update)\n        return False\n\n    def start(self):\n        super(CameraGi, self).start()\n        self._pipeline.set_state(Gst.State.PLAYING)\n\n    def stop(self):\n        super(CameraGi, self).stop()\n        self._pipeline.set_state(Gst.State.PAUSED)\n\n    def unload(self):\n        self._pipeline.set_state(Gst.State.NULL)\n\n    def _update(self, dt):\n        sample, self._sample = self._sample, None\n        if sample is None:\n            return\n\n        if self._texture is None and self._texturesize is not None:\n            self._texture = Texture.create(\n                size=self._texturesize, colorfmt='rgb')\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n\n        # decode sample\n        # read the data from the buffer memory\n        try:\n            buf = sample.get_buffer()\n            result, mapinfo = buf.map(Gst.MapFlags.READ)\n\n            # We cannot get the data out of mapinfo, using Gst 1.0.6 + Gi 3.8.0\n            # related bug report:\n            # https://bugzilla.gnome.org/show_bug.cgi?id=6t8663\n            # ie: mapinfo.data is normally a char*, but here, we have an int\n            # So right now, we use ctypes instead to read the mapinfo ourself.\n            addr = mapinfo.__hash__()\n            c_mapinfo = _MapInfo.from_address(addr)\n\n            # now get the memory\n            self._buffer = string_at(c_mapinfo.data, mapinfo.size)\n            self._copy_to_gpu()\n        finally:\n            if mapinfo is not None:\n                buf.unmap(mapinfo)",
  "def camera_gi_clean():\n    # if we leave the python process with some video running, we can hit a\n    # segfault. This is forcing the stop/unload of all remaining videos before\n    # exiting the python process.\n    for weakcamera in CameraGi._instances:\n        camera = weakcamera()\n        if isinstance(camera, CameraGi):\n            camera.stop()\n            camera.unload()",
  "def __init__(self, **kwargs):\n        self._pipeline = None\n        self._camerasink = None\n        self._decodebin = None\n        self._texturesize = None\n        self._video_src = kwargs.get('video_src', 'v4l2src')\n        wk = ref(self, _on_cameragi_unref)\n        CameraGi._instances.append(wk)\n        super(CameraGi, self).__init__(**kwargs)",
  "def init_camera(self):\n        # TODO: This doesn't work when camera resolution is resized at runtime.\n        # There must be some other way to release the camera?\n        if self._pipeline:\n            self._pipeline = None\n\n        video_src = self._video_src\n        if video_src == 'v4l2src':\n            video_src += ' device=/dev/video%d' % self._index\n        elif video_src == 'dc1394src':\n            video_src += ' camera-number=%d' % self._index\n\n        if Gst.version() < (1, 0, 0, 0):\n            caps = ('video/x-raw-rgb,red_mask=(int)0xff0000,'\n                    'green_mask=(int)0x00ff00,blue_mask=(int)0x0000ff')\n            pl = ('{} ! decodebin name=decoder ! ffmpegcolorspace ! '\n                  'appsink name=camerasink emit-signals=True caps={}')\n        else:\n            caps = 'video/x-raw,format=RGB'\n            pl = '{} ! decodebin name=decoder ! videoconvert ! appsink ' + \\\n                 'name=camerasink emit-signals=True caps={}'\n\n        self._pipeline = Gst.parse_launch(pl.format(video_src, caps))\n        self._camerasink = self._pipeline.get_by_name('camerasink')\n        self._camerasink.connect('new-sample', self._gst_new_sample)\n        self._decodebin = self._pipeline.get_by_name('decoder')\n\n        if self._camerasink and not self.stopped:\n            self.start()",
  "def _gst_new_sample(self, *largs):\n        sample = self._camerasink.emit('pull-sample')\n        if sample is None:\n            return False\n\n        self._sample = sample\n\n        if self._texturesize is None:\n            # try to get the camera image size\n            for pad in self._decodebin.srcpads:\n                s = pad.get_current_caps().get_structure(0)\n                self._texturesize = (\n                    s.get_value('width'),\n                    s.get_value('height'))\n                Clock.schedule_once(self._update)\n                return False\n\n        Clock.schedule_once(self._update)\n        return False",
  "def start(self):\n        super(CameraGi, self).start()\n        self._pipeline.set_state(Gst.State.PLAYING)",
  "def stop(self):\n        super(CameraGi, self).stop()\n        self._pipeline.set_state(Gst.State.PAUSED)",
  "def unload(self):\n        self._pipeline.set_state(Gst.State.NULL)",
  "def _update(self, dt):\n        sample, self._sample = self._sample, None\n        if sample is None:\n            return\n\n        if self._texture is None and self._texturesize is not None:\n            self._texture = Texture.create(\n                size=self._texturesize, colorfmt='rgb')\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n\n        # decode sample\n        # read the data from the buffer memory\n        try:\n            buf = sample.get_buffer()\n            result, mapinfo = buf.map(Gst.MapFlags.READ)\n\n            # We cannot get the data out of mapinfo, using Gst 1.0.6 + Gi 3.8.0\n            # related bug report:\n            # https://bugzilla.gnome.org/show_bug.cgi?id=6t8663\n            # ie: mapinfo.data is normally a char*, but here, we have an int\n            # So right now, we use ctypes instead to read the mapinfo ourself.\n            addr = mapinfo.__hash__()\n            c_mapinfo = _MapInfo.from_address(addr)\n\n            # now get the memory\n            self._buffer = string_at(c_mapinfo.data, mapinfo.size)\n            self._copy_to_gpu()\n        finally:\n            if mapinfo is not None:\n                buf.unmap(mapinfo)",
  "class PreviewCallback(PythonJavaClass):\n    \"\"\"\n    Interface used to get back the preview frame of the Android Camera\n    \"\"\"\n    __javainterfaces__ = ('android.hardware.Camera$PreviewCallback', )\n\n    def __init__(self, callback):\n        super(PreviewCallback, self).__init__()\n        self._callback = callback\n\n    @java_method('([BLandroid/hardware/Camera;)V')\n    def onPreviewFrame(self, data, camera):\n        self._callback(data, camera)",
  "class CameraAndroid(CameraBase):\n    \"\"\"\n    Implementation of CameraBase using Android API\n    \"\"\"\n\n    _update_ev = None\n\n    def __init__(self, **kwargs):\n        self._android_camera = None\n        self._preview_cb = PreviewCallback(self._on_preview_frame)\n        self._buflock = threading.Lock()\n        super(CameraAndroid, self).__init__(**kwargs)\n\n    def __del__(self):\n        self._release_camera()\n\n    def init_camera(self):\n        self._release_camera()\n        self._android_camera = Camera.open(self._index)\n        params = self._android_camera.getParameters()\n        width, height = self._resolution\n        params.setPreviewSize(width, height)\n        supported_focus_modes = self._android_camera.getParameters() \\\n            .getSupportedFocusModes()\n        if supported_focus_modes.contains('continuous-picture'):\n            params.setFocusMode('continuous-picture')\n        self._android_camera.setParameters(params)\n        # self._android_camera.setDisplayOrientation()\n        self.fps = 30.\n\n        pf = params.getPreviewFormat()\n        assert pf == ImageFormat.NV21  # default format is NV21\n        self._bufsize = int(ImageFormat.getBitsPerPixel(pf) / 8. *\n                            width * height)\n\n        self._camera_texture = Texture(width=width, height=height,\n                                       target=GL_TEXTURE_EXTERNAL_OES,\n                                       colorfmt='rgba')\n        self._surface_texture = SurfaceTexture(int(self._camera_texture.id))\n        self._android_camera.setPreviewTexture(self._surface_texture)\n\n        self._fbo = Fbo(size=self._resolution)\n        self._fbo['resolution'] = (float(width), float(height))\n        self._fbo.shader.fs = '''\n            #extension GL_OES_EGL_image_external : require\n            #ifdef GL_ES\n                precision highp float;\n            #endif\n\n            /* Outputs from the vertex shader */\n            varying vec4 frag_color;\n            varying vec2 tex_coord0;\n\n            /* uniform texture samplers */\n            uniform sampler2D texture0;\n            uniform samplerExternalOES texture1;\n            uniform vec2 resolution;\n\n            void main()\n            {\n                vec2 coord = vec2(tex_coord0.y * (\n                    resolution.y / resolution.x), 1. -tex_coord0.x);\n                gl_FragColor = texture2D(texture1, tex_coord0);\n            }\n        '''\n        with self._fbo:\n            self._texture_cb = Callback(lambda instr:\n                                        self._camera_texture.bind)\n            Rectangle(size=self._resolution)\n\n    def _release_camera(self):\n        if self._android_camera is None:\n            return\n\n        self.stop()\n        self._android_camera.release()\n        self._android_camera = None\n\n        # clear texture and it'll be reset in `_update` pointing to new FBO\n        self._texture = None\n        del self._fbo, self._surface_texture, self._camera_texture\n\n    def _on_preview_frame(self, data, camera):\n        with self._buflock:\n            if self._buffer is not None:\n                # add buffer back for reuse\n                self._android_camera.addCallbackBuffer(self._buffer)\n            self._buffer = data\n        # check if frame grabbing works\n        # print self._buffer, len(self.frame_data)\n\n    def _refresh_fbo(self):\n        self._texture_cb.ask_update()\n        self._fbo.draw()\n\n    def start(self):\n        super(CameraAndroid, self).start()\n\n        with self._buflock:\n            self._buffer = None\n        for k in range(2):  # double buffer\n            buf = b'\\x00' * self._bufsize\n            self._android_camera.addCallbackBuffer(buf)\n        self._android_camera.setPreviewCallbackWithBuffer(self._preview_cb)\n\n        self._android_camera.startPreview()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n        self._update_ev = Clock.schedule_interval(self._update, 1 / self.fps)\n\n    def stop(self):\n        super(CameraAndroid, self).stop()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n            self._update_ev = None\n        self._android_camera.stopPreview()\n\n        self._android_camera.setPreviewCallbackWithBuffer(None)\n        # buffer queue cleared as well, to be recreated on next start\n        with self._buflock:\n            self._buffer = None\n\n    def _update(self, dt):\n        self._surface_texture.updateTexImage()\n        self._refresh_fbo()\n        if self._texture is None:\n            self._texture = self._fbo.texture\n            self.dispatch('on_load')\n        self._copy_to_gpu()\n\n    def _copy_to_gpu(self):\n        \"\"\"\n        A dummy placeholder (the image is already in GPU) to be consistent\n        with other providers.\n        \"\"\"\n        self.dispatch('on_texture')\n\n    def grab_frame(self):\n        \"\"\"\n        Grab current frame (thread-safe, minimal overhead)\n        \"\"\"\n        with self._buflock:\n            if self._buffer is None:\n                return None\n            buf = self._buffer.tostring()\n            return buf\n\n    def decode_frame(self, buf):\n        \"\"\"\n        Decode image data from grabbed frame.\n\n        This method depends on OpenCV and NumPy - however it is only used for\n        fetching the current frame as a NumPy array, and not required when\n        this :class:`CameraAndroid` provider is simply used by a\n        :class:`~kivy.uix.camera.Camera` widget.\n        \"\"\"\n        import numpy as np\n        from cv2 import cvtColor\n\n        w, h = self._resolution\n        arr = np.fromstring(buf, 'uint8').reshape((h + h / 2, w))\n        arr = cvtColor(arr, 93)  # NV21 -> BGR\n        return arr\n\n    def read_frame(self):\n        \"\"\"\n        Grab and decode frame in one call\n        \"\"\"\n        return self.decode_frame(self.grab_frame())\n\n    @staticmethod\n    def get_camera_count():\n        \"\"\"\n        Get the number of available cameras.\n        \"\"\"\n        return Camera.getNumberOfCameras()",
  "def __init__(self, callback):\n        super(PreviewCallback, self).__init__()\n        self._callback = callback",
  "def onPreviewFrame(self, data, camera):\n        self._callback(data, camera)",
  "def __init__(self, **kwargs):\n        self._android_camera = None\n        self._preview_cb = PreviewCallback(self._on_preview_frame)\n        self._buflock = threading.Lock()\n        super(CameraAndroid, self).__init__(**kwargs)",
  "def __del__(self):\n        self._release_camera()",
  "def init_camera(self):\n        self._release_camera()\n        self._android_camera = Camera.open(self._index)\n        params = self._android_camera.getParameters()\n        width, height = self._resolution\n        params.setPreviewSize(width, height)\n        supported_focus_modes = self._android_camera.getParameters() \\\n            .getSupportedFocusModes()\n        if supported_focus_modes.contains('continuous-picture'):\n            params.setFocusMode('continuous-picture')\n        self._android_camera.setParameters(params)\n        # self._android_camera.setDisplayOrientation()\n        self.fps = 30.\n\n        pf = params.getPreviewFormat()\n        assert pf == ImageFormat.NV21  # default format is NV21\n        self._bufsize = int(ImageFormat.getBitsPerPixel(pf) / 8. *\n                            width * height)\n\n        self._camera_texture = Texture(width=width, height=height,\n                                       target=GL_TEXTURE_EXTERNAL_OES,\n                                       colorfmt='rgba')\n        self._surface_texture = SurfaceTexture(int(self._camera_texture.id))\n        self._android_camera.setPreviewTexture(self._surface_texture)\n\n        self._fbo = Fbo(size=self._resolution)\n        self._fbo['resolution'] = (float(width), float(height))\n        self._fbo.shader.fs = '''\n            #extension GL_OES_EGL_image_external : require\n            #ifdef GL_ES\n                precision highp float;\n            #endif\n\n            /* Outputs from the vertex shader */\n            varying vec4 frag_color;\n            varying vec2 tex_coord0;\n\n            /* uniform texture samplers */\n            uniform sampler2D texture0;\n            uniform samplerExternalOES texture1;\n            uniform vec2 resolution;\n\n            void main()\n            {\n                vec2 coord = vec2(tex_coord0.y * (\n                    resolution.y / resolution.x), 1. -tex_coord0.x);\n                gl_FragColor = texture2D(texture1, tex_coord0);\n            }\n        '''\n        with self._fbo:\n            self._texture_cb = Callback(lambda instr:\n                                        self._camera_texture.bind)\n            Rectangle(size=self._resolution)",
  "def _release_camera(self):\n        if self._android_camera is None:\n            return\n\n        self.stop()\n        self._android_camera.release()\n        self._android_camera = None\n\n        # clear texture and it'll be reset in `_update` pointing to new FBO\n        self._texture = None\n        del self._fbo, self._surface_texture, self._camera_texture",
  "def _on_preview_frame(self, data, camera):\n        with self._buflock:\n            if self._buffer is not None:\n                # add buffer back for reuse\n                self._android_camera.addCallbackBuffer(self._buffer)\n            self._buffer = data",
  "def _refresh_fbo(self):\n        self._texture_cb.ask_update()\n        self._fbo.draw()",
  "def start(self):\n        super(CameraAndroid, self).start()\n\n        with self._buflock:\n            self._buffer = None\n        for k in range(2):  # double buffer\n            buf = b'\\x00' * self._bufsize\n            self._android_camera.addCallbackBuffer(buf)\n        self._android_camera.setPreviewCallbackWithBuffer(self._preview_cb)\n\n        self._android_camera.startPreview()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n        self._update_ev = Clock.schedule_interval(self._update, 1 / self.fps)",
  "def stop(self):\n        super(CameraAndroid, self).stop()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n            self._update_ev = None\n        self._android_camera.stopPreview()\n\n        self._android_camera.setPreviewCallbackWithBuffer(None)\n        # buffer queue cleared as well, to be recreated on next start\n        with self._buflock:\n            self._buffer = None",
  "def _update(self, dt):\n        self._surface_texture.updateTexImage()\n        self._refresh_fbo()\n        if self._texture is None:\n            self._texture = self._fbo.texture\n            self.dispatch('on_load')\n        self._copy_to_gpu()",
  "def _copy_to_gpu(self):\n        \"\"\"\n        A dummy placeholder (the image is already in GPU) to be consistent\n        with other providers.\n        \"\"\"\n        self.dispatch('on_texture')",
  "def grab_frame(self):\n        \"\"\"\n        Grab current frame (thread-safe, minimal overhead)\n        \"\"\"\n        with self._buflock:\n            if self._buffer is None:\n                return None\n            buf = self._buffer.tostring()\n            return buf",
  "def decode_frame(self, buf):\n        \"\"\"\n        Decode image data from grabbed frame.\n\n        This method depends on OpenCV and NumPy - however it is only used for\n        fetching the current frame as a NumPy array, and not required when\n        this :class:`CameraAndroid` provider is simply used by a\n        :class:`~kivy.uix.camera.Camera` widget.\n        \"\"\"\n        import numpy as np\n        from cv2 import cvtColor\n\n        w, h = self._resolution\n        arr = np.fromstring(buf, 'uint8').reshape((h + h / 2, w))\n        arr = cvtColor(arr, 93)  # NV21 -> BGR\n        return arr",
  "def read_frame(self):\n        \"\"\"\n        Grab and decode frame in one call\n        \"\"\"\n        return self.decode_frame(self.grab_frame())",
  "def get_camera_count():\n        \"\"\"\n        Get the number of available cameras.\n        \"\"\"\n        return Camera.getNumberOfCameras()",
  "class CameraBase(EventDispatcher):\n    '''Abstract Camera Widget class.\n\n    Concrete camera classes must implement initialization and\n    frame capturing to a buffer that can be uploaded to the gpu.\n\n    :Parameters:\n        `index`: int\n            Source index of the camera.\n        `size`: tuple (int, int)\n            Size at which the image is drawn. If no size is specified,\n            it defaults to the resolution of the camera image.\n        `resolution`: tuple (int, int)\n            Resolution to try to request from the camera.\n            Used in the gstreamer pipeline by forcing the appsink caps\n            to this resolution. If the camera doesn't support the resolution,\n            a negotiation error might be thrown.\n\n    :Events:\n        `on_load`\n            Fired when the camera is loaded and the texture has become\n            available.\n        `on_texture`\n            Fired each time the camera texture is updated.\n    '''\n\n    __events__ = ('on_load', 'on_texture')\n\n    def __init__(self, **kwargs):\n        kwargs.setdefault('stopped', False)\n        kwargs.setdefault('resolution', (640, 480))\n        kwargs.setdefault('index', 0)\n\n        self.stopped = kwargs.get('stopped')\n        self._resolution = kwargs.get('resolution')\n        self._index = kwargs.get('index')\n        self._buffer = None\n        self._format = 'rgb'\n        self._texture = None\n        self.capture_device = None\n        kwargs.setdefault('size', self._resolution)\n\n        super(CameraBase, self).__init__()\n\n        self.init_camera()\n\n        if not self.stopped:\n            self.start()\n\n    def _set_resolution(self, res):\n        self._resolution = res\n        self.init_camera()\n\n    def _get_resolution(self):\n        return self._resolution\n\n    resolution = property(lambda self: self._get_resolution(),\n                          lambda self, x: self._set_resolution(x),\n                          doc='Resolution of camera capture (width, height)')\n\n    def _set_index(self, x):\n        if x == self._index:\n            return\n        self._index = x\n        self.init_camera()\n\n    def _get_index(self):\n        return self._x\n\n    index = property(lambda self: self._get_index(),\n                     lambda self, x: self._set_index(x),\n                     doc='Source index of the camera')\n\n    def _get_texture(self):\n        return self._texture\n    texture = property(lambda self: self._get_texture(),\n                       doc='Return the camera texture with the latest capture')\n\n    def init_camera(self):\n        '''Initialize the camera (internal)'''\n        pass\n\n    def start(self):\n        '''Start the camera acquire'''\n        self.stopped = False\n\n    def stop(self):\n        '''Release the camera'''\n        self.stopped = True\n\n    def _update(self, dt):\n        '''Update the camera (internal)'''\n        pass\n\n    def _copy_to_gpu(self):\n        '''Copy the buffer into the texture.'''\n        if self._texture is None:\n            Logger.debug('Camera: copy_to_gpu() failed, _texture is None !')\n            return\n        self._texture.blit_buffer(self._buffer, colorfmt=self._format)\n        self._buffer = None\n        self.dispatch('on_texture')\n\n    def on_texture(self):\n        pass\n\n    def on_load(self):\n        pass",
  "def __init__(self, **kwargs):\n        kwargs.setdefault('stopped', False)\n        kwargs.setdefault('resolution', (640, 480))\n        kwargs.setdefault('index', 0)\n\n        self.stopped = kwargs.get('stopped')\n        self._resolution = kwargs.get('resolution')\n        self._index = kwargs.get('index')\n        self._buffer = None\n        self._format = 'rgb'\n        self._texture = None\n        self.capture_device = None\n        kwargs.setdefault('size', self._resolution)\n\n        super(CameraBase, self).__init__()\n\n        self.init_camera()\n\n        if not self.stopped:\n            self.start()",
  "def _set_resolution(self, res):\n        self._resolution = res\n        self.init_camera()",
  "def _get_resolution(self):\n        return self._resolution",
  "def _set_index(self, x):\n        if x == self._index:\n            return\n        self._index = x\n        self.init_camera()",
  "def _get_index(self):\n        return self._x",
  "def _get_texture(self):\n        return self._texture",
  "def init_camera(self):\n        '''Initialize the camera (internal)'''\n        pass",
  "def start(self):\n        '''Start the camera acquire'''\n        self.stopped = False",
  "def stop(self):\n        '''Release the camera'''\n        self.stopped = True",
  "def _update(self, dt):\n        '''Update the camera (internal)'''\n        pass",
  "def _copy_to_gpu(self):\n        '''Copy the buffer into the texture.'''\n        if self._texture is None:\n            Logger.debug('Camera: copy_to_gpu() failed, _texture is None !')\n            return\n        self._texture.blit_buffer(self._buffer, colorfmt=self._format)\n        self._buffer = None\n        self.dispatch('on_texture')",
  "def on_texture(self):\n        pass",
  "def on_load(self):\n        pass",
  "class CameraOpenCV(CameraBase):\n    '''\n    Implementation of CameraBase using OpenCV\n    '''\n    _update_ev = None\n\n    def __init__(self, **kwargs):\n        # we will need it, because constants have\n        # different access paths between ver. 2 and 3\n        try:\n            self.opencvMajorVersion = int(cv.__version__[0])\n        except NameError:\n            self.opencvMajorVersion = int(cv2.__version__[0])\n\n        self._device = None\n        super(CameraOpenCV, self).__init__(**kwargs)\n\n    def init_camera(self):\n        # consts have changed locations between versions 2 and 3\n        if self.opencvMajorVersion in (3, 4):\n            PROPERTY_WIDTH = cv2.CAP_PROP_FRAME_WIDTH\n            PROPERTY_HEIGHT = cv2.CAP_PROP_FRAME_HEIGHT\n            PROPERTY_FPS = cv2.CAP_PROP_FPS\n        elif self.opencvMajorVersion == 2:\n            PROPERTY_WIDTH = cv2.cv.CV_CAP_PROP_FRAME_WIDTH\n            PROPERTY_HEIGHT = cv2.cv.CV_CAP_PROP_FRAME_HEIGHT\n            PROPERTY_FPS = cv2.cv.CV_CAP_PROP_FPS\n        elif self.opencvMajorVersion == 1:\n            PROPERTY_WIDTH = cv.CV_CAP_PROP_FRAME_WIDTH\n            PROPERTY_HEIGHT = cv.CV_CAP_PROP_FRAME_HEIGHT\n            PROPERTY_FPS = cv.CV_CAP_PROP_FPS\n\n        Logger.debug('Using opencv ver.' + str(self.opencvMajorVersion))\n\n        if self.opencvMajorVersion == 1:\n            # create the device\n            self._device = hg.cvCreateCameraCapture(self._index)\n            # Set preferred resolution\n            cv.SetCaptureProperty(self._device, cv.CV_CAP_PROP_FRAME_WIDTH,\n                                  self.resolution[0])\n            cv.SetCaptureProperty(self._device, cv.CV_CAP_PROP_FRAME_HEIGHT,\n                                  self.resolution[1])\n            # and get frame to check if it's ok\n            frame = hg.cvQueryFrame(self._device)\n            # Just set the resolution to the frame we just got, but don't use\n            # self.resolution for that as that would cause an infinite\n            # recursion with self.init_camera (but slowly as we'd have to\n            # always get a frame).\n            self._resolution = (int(frame.width), int(frame.height))\n            # get fps\n            self.fps = cv.GetCaptureProperty(self._device, cv.CV_CAP_PROP_FPS)\n\n        elif self.opencvMajorVersion in (2, 3, 4):\n            # create the device\n            self._device = cv2.VideoCapture(self._index)\n            # Set preferred resolution\n            self._device.set(PROPERTY_WIDTH,\n                             self.resolution[0])\n            self._device.set(PROPERTY_HEIGHT,\n                             self.resolution[1])\n            # and get frame to check if it's ok\n            ret, frame = self._device.read()\n\n            # source:\n            # http://stackoverflow.com/questions/32468371/video-capture-propid-parameters-in-opencv # noqa\n            self._resolution = (int(frame.shape[1]), int(frame.shape[0]))\n            # get fps\n            self.fps = self._device.get(PROPERTY_FPS)\n\n        if self.fps == 0 or self.fps == 1:\n            self.fps = 1.0 / 30\n        elif self.fps > 1:\n            self.fps = 1.0 / self.fps\n\n        if not self.stopped:\n            self.start()\n\n    def _update(self, dt):\n        if self.stopped:\n            return\n        if self._texture is None:\n            # Create the texture\n            self._texture = Texture.create(self._resolution)\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n        try:\n            ret, frame = self._device.read()\n            self._format = 'bgr'\n            try:\n                self._buffer = frame.imageData\n            except AttributeError:\n                # frame is already of type ndarray\n                # which can be reshaped to 1-d.\n                self._buffer = frame.reshape(-1)\n            self._copy_to_gpu()\n        except:\n            Logger.exception('OpenCV: Couldn\\'t get image from Camera')\n\n    def start(self):\n        super(CameraOpenCV, self).start()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n        self._update_ev = Clock.schedule_interval(self._update, self.fps)\n\n    def stop(self):\n        super(CameraOpenCV, self).stop()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n            self._update_ev = None",
  "def __init__(self, **kwargs):\n        # we will need it, because constants have\n        # different access paths between ver. 2 and 3\n        try:\n            self.opencvMajorVersion = int(cv.__version__[0])\n        except NameError:\n            self.opencvMajorVersion = int(cv2.__version__[0])\n\n        self._device = None\n        super(CameraOpenCV, self).__init__(**kwargs)",
  "def init_camera(self):\n        # consts have changed locations between versions 2 and 3\n        if self.opencvMajorVersion in (3, 4):\n            PROPERTY_WIDTH = cv2.CAP_PROP_FRAME_WIDTH\n            PROPERTY_HEIGHT = cv2.CAP_PROP_FRAME_HEIGHT\n            PROPERTY_FPS = cv2.CAP_PROP_FPS\n        elif self.opencvMajorVersion == 2:\n            PROPERTY_WIDTH = cv2.cv.CV_CAP_PROP_FRAME_WIDTH\n            PROPERTY_HEIGHT = cv2.cv.CV_CAP_PROP_FRAME_HEIGHT\n            PROPERTY_FPS = cv2.cv.CV_CAP_PROP_FPS\n        elif self.opencvMajorVersion == 1:\n            PROPERTY_WIDTH = cv.CV_CAP_PROP_FRAME_WIDTH\n            PROPERTY_HEIGHT = cv.CV_CAP_PROP_FRAME_HEIGHT\n            PROPERTY_FPS = cv.CV_CAP_PROP_FPS\n\n        Logger.debug('Using opencv ver.' + str(self.opencvMajorVersion))\n\n        if self.opencvMajorVersion == 1:\n            # create the device\n            self._device = hg.cvCreateCameraCapture(self._index)\n            # Set preferred resolution\n            cv.SetCaptureProperty(self._device, cv.CV_CAP_PROP_FRAME_WIDTH,\n                                  self.resolution[0])\n            cv.SetCaptureProperty(self._device, cv.CV_CAP_PROP_FRAME_HEIGHT,\n                                  self.resolution[1])\n            # and get frame to check if it's ok\n            frame = hg.cvQueryFrame(self._device)\n            # Just set the resolution to the frame we just got, but don't use\n            # self.resolution for that as that would cause an infinite\n            # recursion with self.init_camera (but slowly as we'd have to\n            # always get a frame).\n            self._resolution = (int(frame.width), int(frame.height))\n            # get fps\n            self.fps = cv.GetCaptureProperty(self._device, cv.CV_CAP_PROP_FPS)\n\n        elif self.opencvMajorVersion in (2, 3, 4):\n            # create the device\n            self._device = cv2.VideoCapture(self._index)\n            # Set preferred resolution\n            self._device.set(PROPERTY_WIDTH,\n                             self.resolution[0])\n            self._device.set(PROPERTY_HEIGHT,\n                             self.resolution[1])\n            # and get frame to check if it's ok\n            ret, frame = self._device.read()\n\n            # source:\n            # http://stackoverflow.com/questions/32468371/video-capture-propid-parameters-in-opencv # noqa\n            self._resolution = (int(frame.shape[1]), int(frame.shape[0]))\n            # get fps\n            self.fps = self._device.get(PROPERTY_FPS)\n\n        if self.fps == 0 or self.fps == 1:\n            self.fps = 1.0 / 30\n        elif self.fps > 1:\n            self.fps = 1.0 / self.fps\n\n        if not self.stopped:\n            self.start()",
  "def _update(self, dt):\n        if self.stopped:\n            return\n        if self._texture is None:\n            # Create the texture\n            self._texture = Texture.create(self._resolution)\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n        try:\n            ret, frame = self._device.read()\n            self._format = 'bgr'\n            try:\n                self._buffer = frame.imageData\n            except AttributeError:\n                # frame is already of type ndarray\n                # which can be reshaped to 1-d.\n                self._buffer = frame.reshape(-1)\n            self._copy_to_gpu()\n        except:\n            Logger.exception('OpenCV: Couldn\\'t get image from Camera')",
  "def start(self):\n        super(CameraOpenCV, self).start()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n        self._update_ev = Clock.schedule_interval(self._update, self.fps)",
  "def stop(self):\n        super(CameraOpenCV, self).stop()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n            self._update_ev = None",
  "class Hg(object):\n            '''\n            On OSX, not only are the import names different,\n            but the API also differs.\n            There is no module called 'highgui' but the names are\n            directly available in the 'cv' module.\n            Some of them even have a different names.\n\n            Therefore we use this proxy object.\n            '''\n\n            def __getattr__(self, attr):\n                if attr.startswith('cv'):\n                    attr = attr[2:]\n                got = getattr(cv, attr)\n                return got",
  "def __getattr__(self, attr):\n                if attr.startswith('cv'):\n                    attr = attr[2:]\n                got = getattr(cv, attr)\n                return got",
  "class CameraPiCamera(CameraBase):\n    '''Implementation of CameraBase using PiCamera\n    '''\n    _update_ev = None\n\n    def __init__(self, **kwargs):\n        self._camera = None\n        self._format = 'bgr'\n        self._framerate = kwargs.get('framerate', 30)\n        super(CameraPiCamera, self).__init__(**kwargs)\n\n    def init_camera(self):\n        if self._camera is not None:\n            self._camera.close()\n\n        self._camera = PiCamera()\n        self._camera.resolution = self.resolution\n        self._camera.framerate = self._framerate\n        self._camera.iso = 800\n\n        self.fps = 1. / self._framerate\n\n        if not self.stopped:\n            self.start()\n\n    def raw_buffer_size(self):\n        '''Round buffer size up to 32x16 blocks.\n\n        See https://picamera.readthedocs.io/en/release-1.13/recipes2.html#capturing-to-a-numpy-array\n        '''  # noqa\n        return (\n            ceil(self.resolution[0] / 32.) * 32,\n            ceil(self.resolution[1] / 16.) * 16\n        )\n\n    def _update(self, dt):\n        if self.stopped:\n            return\n\n        if self._texture is None:\n            # Create the texture\n            self._texture = Texture.create(self._resolution)\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n\n        try:\n            bufsize = self.raw_buffer_size()\n            output = numpy.empty(\n                (bufsize[0] * bufsize[1] * 3,), dtype=numpy.uint8)\n            self._camera.capture(output, self._format, use_video_port=True)\n\n            # Trim the buffer to fit the actual requested resolution.\n            # TODO: Is there a simpler way to do all this reshuffling?\n            output = output.reshape((bufsize[0], bufsize[1], 3))\n            output = output[:self.resolution[0], :self.resolution[1], :]\n            self._buffer = output.reshape(\n                (self.resolution[0] * self.resolution[1] * 3,))\n\n            self._copy_to_gpu()\n        except KeyboardInterrupt:\n            raise\n        except Exception:\n            Logger.exception('PiCamera: Couldn\\'t get image from Camera')\n\n    def start(self):\n        super(CameraPiCamera, self).start()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n        self._update_ev = Clock.schedule_interval(self._update, self.fps)\n\n    def stop(self):\n        super(CameraPiCamera, self).stop()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n            self._update_ev = None",
  "def __init__(self, **kwargs):\n        self._camera = None\n        self._format = 'bgr'\n        self._framerate = kwargs.get('framerate', 30)\n        super(CameraPiCamera, self).__init__(**kwargs)",
  "def init_camera(self):\n        if self._camera is not None:\n            self._camera.close()\n\n        self._camera = PiCamera()\n        self._camera.resolution = self.resolution\n        self._camera.framerate = self._framerate\n        self._camera.iso = 800\n\n        self.fps = 1. / self._framerate\n\n        if not self.stopped:\n            self.start()",
  "def raw_buffer_size(self):\n        '''Round buffer size up to 32x16 blocks.\n\n        See https://picamera.readthedocs.io/en/release-1.13/recipes2.html#capturing-to-a-numpy-array\n        '''  # noqa\n        return (\n            ceil(self.resolution[0] / 32.) * 32,\n            ceil(self.resolution[1] / 16.) * 16\n        )",
  "def _update(self, dt):\n        if self.stopped:\n            return\n\n        if self._texture is None:\n            # Create the texture\n            self._texture = Texture.create(self._resolution)\n            self._texture.flip_vertical()\n            self.dispatch('on_load')\n\n        try:\n            bufsize = self.raw_buffer_size()\n            output = numpy.empty(\n                (bufsize[0] * bufsize[1] * 3,), dtype=numpy.uint8)\n            self._camera.capture(output, self._format, use_video_port=True)\n\n            # Trim the buffer to fit the actual requested resolution.\n            # TODO: Is there a simpler way to do all this reshuffling?\n            output = output.reshape((bufsize[0], bufsize[1], 3))\n            output = output[:self.resolution[0], :self.resolution[1], :]\n            self._buffer = output.reshape(\n                (self.resolution[0] * self.resolution[1] * 3,))\n\n            self._copy_to_gpu()\n        except KeyboardInterrupt:\n            raise\n        except Exception:\n            Logger.exception('PiCamera: Couldn\\'t get image from Camera')",
  "def start(self):\n        super(CameraPiCamera, self).start()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n        self._update_ev = Clock.schedule_interval(self._update, self.fps)",
  "def stop(self):\n        super(CameraPiCamera, self).stop()\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n            self._update_ev = None",
  "class SpellingEnchant(SpellingBase):\n    '''\n    Spelling backend based on the enchant library.\n    '''\n\n    def __init__(self, language=None):\n        self._language = None\n        super(SpellingEnchant, self).__init__(language)\n\n    def select_language(self, language):\n        try:\n            self._language = enchant.Dict(language)\n        except enchant.DictNotFoundError:\n            err = 'Enchant Backend: No language for \"%s\"' % (language, )\n            raise NoSuchLangError(err)\n\n    def list_languages(self):\n        # Note: We do NOT return enchant.list_dicts because that also returns\n        #       the enchant dict objects and not only the language identifiers.\n        return enchant.list_languages()\n\n    def check(self, word):\n        if not word:\n            return None\n        return self._language.check(word)\n\n    def suggest(self, fragment):\n        suggestions = self._language.suggest(fragment)\n        # Don't show suggestions that are invalid\n        suggestions = [s for s in suggestions if self.check(s)]\n        if PY2:\n            suggestions = [s.decode('utf-8') for s in suggestions]\n        return suggestions",
  "def __init__(self, language=None):\n        self._language = None\n        super(SpellingEnchant, self).__init__(language)",
  "def select_language(self, language):\n        try:\n            self._language = enchant.Dict(language)\n        except enchant.DictNotFoundError:\n            err = 'Enchant Backend: No language for \"%s\"' % (language, )\n            raise NoSuchLangError(err)",
  "def list_languages(self):\n        # Note: We do NOT return enchant.list_dicts because that also returns\n        #       the enchant dict objects and not only the language identifiers.\n        return enchant.list_languages()",
  "def check(self, word):\n        if not word:\n            return None\n        return self._language.check(word)",
  "def suggest(self, fragment):\n        suggestions = self._language.suggest(fragment)\n        # Don't show suggestions that are invalid\n        suggestions = [s for s in suggestions if self.check(s)]\n        if PY2:\n            suggestions = [s.decode('utf-8') for s in suggestions]\n        return suggestions",
  "class SpellingOSXAppKit(SpellingBase):\n    '''\n    Spelling backend based on OSX's spelling features provided by AppKit.\n    '''\n\n    def __init__(self, language=None):\n        self._language = NSSpellChecker.alloc().init()\n        super(SpellingOSXAppKit, self).__init__(language)\n\n    def select_language(self, language):\n        success = self._language.setLanguage_(language)\n        if not success:\n            err = 'AppKit Backend: No language \"%s\" ' % (language, )\n            raise NoSuchLangError(err)\n\n    def list_languages(self):\n        return list(self._language.availableLanguages())\n\n    def check(self, word):\n        # TODO Implement this!\n        #      NSSpellChecker provides several functions that look like what we\n        #      need, but they're a) slooow and b) return a strange result.\n        #      Might be a snow leopard bug. Have to test further.\n        #      See: http://paste.pocoo.org/show/217968/\n        if not word:\n            return None\n        err = 'check() not currently supported by the OSX AppKit backend'\n        raise NotImplementedError(err)\n\n    def suggest(self, fragment):\n        l = self._language\n        # XXX Both ways below work on OSX 10.6. It has not been tested on any\n        #     other version, but it should work.\n        try:\n            # This is deprecated as of OSX 10.6, hence the try-except\n            return list(l.guessesForWord_(fragment))\n        except AttributeError:\n            # From 10.6 onwards you're supposed to do it like this:\n            checkrange = NSMakeRange(0, len(fragment))\n            g = l.\\\n                guessesForWordRange_inString_language_inSpellDocumentWithTag_(\n                    checkrange, fragment, l.language(), 0)\n            # Right, this was much easier, Apple! :-)\n            return list(g)",
  "def __init__(self, language=None):\n        self._language = NSSpellChecker.alloc().init()\n        super(SpellingOSXAppKit, self).__init__(language)",
  "def select_language(self, language):\n        success = self._language.setLanguage_(language)\n        if not success:\n            err = 'AppKit Backend: No language \"%s\" ' % (language, )\n            raise NoSuchLangError(err)",
  "def list_languages(self):\n        return list(self._language.availableLanguages())",
  "def check(self, word):\n        # TODO Implement this!\n        #      NSSpellChecker provides several functions that look like what we\n        #      need, but they're a) slooow and b) return a strange result.\n        #      Might be a snow leopard bug. Have to test further.\n        #      See: http://paste.pocoo.org/show/217968/\n        if not word:\n            return None\n        err = 'check() not currently supported by the OSX AppKit backend'\n        raise NotImplementedError(err)",
  "def suggest(self, fragment):\n        l = self._language\n        # XXX Both ways below work on OSX 10.6. It has not been tested on any\n        #     other version, but it should work.\n        try:\n            # This is deprecated as of OSX 10.6, hence the try-except\n            return list(l.guessesForWord_(fragment))\n        except AttributeError:\n            # From 10.6 onwards you're supposed to do it like this:\n            checkrange = NSMakeRange(0, len(fragment))\n            g = l.\\\n                guessesForWordRange_inString_language_inSpellDocumentWithTag_(\n                    checkrange, fragment, l.language(), 0)\n            # Right, this was much easier, Apple! :-)\n            return list(g)",
  "class NoSuchLangError(Exception):\n    '''\n    Exception to be raised when a specific language could not be found.\n    '''\n    pass",
  "class NoLanguageSelectedError(Exception):\n    '''\n    Exception to be raised when a language-using method is called but no\n    language was selected prior to the call.\n    '''\n    pass",
  "class SpellingBase(object):\n    '''\n    Base class for all spelling providers.\n    Supports some abstract methods for checking words and getting suggestions.\n    '''\n\n    def __init__(self, language=None):\n        '''\n        If a `language` identifier (such as 'en_US') is provided and a matching\n        language exists, it is selected. If an identifier is provided and no\n        matching language exists, a NoSuchLangError exception is raised by\n        self.select_language().\n        If no `language` identifier is provided, we just fall back to the first\n        one that is available.\n\n        :Parameters:\n            `language`: str, defaults to None\n                If provided, indicates the language to be used. This needs\n                to be a language identifier understood by select_language(),\n                i.e. one of the options returned by list_languages().\n                If nothing is provided, the first available language is used.\n                If no language is available, NoLanguageSelectedError is raised.\n        '''\n        langs = self.list_languages()\n        try:\n            # If no language was specified, we just use the first one\n            # that is available.\n            fallback_lang = langs[0]\n        except IndexError:\n            raise NoLanguageSelectedError(\"No languages available!\")\n        self.select_language(language or fallback_lang)\n\n    def select_language(self, language):\n        '''\n        From the set of registered languages, select the first language\n        for `language`.\n\n        :Parameters:\n            `language`: str\n                Language identifier. Needs to be one of the options returned by\n                list_languages(). Sets the language used for spell checking and\n                word suggestions.\n        '''\n        raise NotImplementedError('select_language() method not implemented '\n                                  'by abstract spelling base class!')\n\n    def list_languages(self):\n        '''\n        Return a list of all supported languages.\n        E.g. ['en', 'en_GB', 'en_US', 'de', ...]\n        '''\n        raise NotImplementedError('list_languages() is not implemented '\n                                  'by abstract spelling base class!')\n\n    def check(self, word):\n        '''\n        If `word` is a valid word in `self._language` (the currently active\n        language), returns True. If the word shouldn't be checked, returns\n        None (e.g. for ''). If it is not a valid word in `self._language`,\n        return False.\n\n        :Parameters:\n            `word`: str\n                The word to check.\n        '''\n        raise NotImplementedError('check() not implemented by abstract ' +\n                                  'spelling base class!')\n\n    def suggest(self, fragment):\n        '''\n        For a given `fragment` (i.e. part of a word or a word by itself),\n        provide corrections (`fragment` may be misspelled) or completions\n        as a list of strings.\n\n        :Parameters:\n            `fragment`: str\n                The word fragment to get suggestions/corrections for.\n                E.g. 'foo' might become 'of', 'food' or 'foot'.\n\n        '''\n        raise NotImplementedError('suggest() not implemented by abstract ' +\n                                  'spelling base class!')",
  "def __init__(self, language=None):\n        '''\n        If a `language` identifier (such as 'en_US') is provided and a matching\n        language exists, it is selected. If an identifier is provided and no\n        matching language exists, a NoSuchLangError exception is raised by\n        self.select_language().\n        If no `language` identifier is provided, we just fall back to the first\n        one that is available.\n\n        :Parameters:\n            `language`: str, defaults to None\n                If provided, indicates the language to be used. This needs\n                to be a language identifier understood by select_language(),\n                i.e. one of the options returned by list_languages().\n                If nothing is provided, the first available language is used.\n                If no language is available, NoLanguageSelectedError is raised.\n        '''\n        langs = self.list_languages()\n        try:\n            # If no language was specified, we just use the first one\n            # that is available.\n            fallback_lang = langs[0]\n        except IndexError:\n            raise NoLanguageSelectedError(\"No languages available!\")\n        self.select_language(language or fallback_lang)",
  "def select_language(self, language):\n        '''\n        From the set of registered languages, select the first language\n        for `language`.\n\n        :Parameters:\n            `language`: str\n                Language identifier. Needs to be one of the options returned by\n                list_languages(). Sets the language used for spell checking and\n                word suggestions.\n        '''\n        raise NotImplementedError('select_language() method not implemented '\n                                  'by abstract spelling base class!')",
  "def list_languages(self):\n        '''\n        Return a list of all supported languages.\n        E.g. ['en', 'en_GB', 'en_US', 'de', ...]\n        '''\n        raise NotImplementedError('list_languages() is not implemented '\n                                  'by abstract spelling base class!')",
  "def check(self, word):\n        '''\n        If `word` is a valid word in `self._language` (the currently active\n        language), returns True. If the word shouldn't be checked, returns\n        None (e.g. for ''). If it is not a valid word in `self._language`,\n        return False.\n\n        :Parameters:\n            `word`: str\n                The word to check.\n        '''\n        raise NotImplementedError('check() not implemented by abstract ' +\n                                  'spelling base class!')",
  "def suggest(self, fragment):\n        '''\n        For a given `fragment` (i.e. part of a word or a word by itself),\n        provide corrections (`fragment` may be misspelled) or completions\n        as a list of strings.\n\n        :Parameters:\n            `fragment`: str\n                The word fragment to get suggestions/corrections for.\n                E.g. 'foo' might become 'of', 'food' or 'foot'.\n\n        '''\n        raise NotImplementedError('suggest() not implemented by abstract ' +\n                                  'spelling base class!')",
  "class DictStore(AbstractStore):\n    '''Store implementation using a pickled `dict`.\n    See the :mod:`kivy.storage` module documentation for more information.\n    '''\n    def __init__(self, filename, data=None, **kwargs):\n        if isinstance(filename, dict):\n            # backward compatibility, first argument was a dict.\n            self.filename = None\n            self._data = filename\n        else:\n            self.filename = filename\n            self._data = data or {}\n        self._is_changed = True\n        super(DictStore, self).__init__(**kwargs)\n\n    def store_load(self):\n        if self.filename is None:\n            return\n        if not exists(self.filename):\n            folder = abspath(dirname(self.filename))\n            if not exists(folder):\n                not_found = IOError(\n                    \"The folder '{}' doesn't exist!\"\n                    \"\".format(folder)\n                )\n                not_found.errno = errno.ENOENT\n                raise not_found\n            return\n        with open(self.filename, 'rb') as fd:\n            data = fd.read()\n            if data:\n                self._data = pickle.loads(data)\n\n    def store_sync(self):\n        if self.filename is None:\n            return\n        if not self._is_changed:\n            return\n\n        with open(self.filename, 'wb') as fd:\n            pickle.dump(self._data, fd)\n\n        self._is_changed = False\n\n    def store_exists(self, key):\n        return key in self._data\n\n    def store_get(self, key):\n        return self._data[key]\n\n    def store_put(self, key, value):\n        self._data[key] = value\n        self._is_changed = True\n        return True\n\n    def store_delete(self, key):\n        del self._data[key]\n        self._is_changed = True\n        return True\n\n    def store_find(self, filters):\n        for key, values in iteritems(self._data):\n            found = True\n            for fkey, fvalue in iteritems(filters):\n                if fkey not in values:\n                    found = False\n                    break\n                if values[fkey] != fvalue:\n                    found = False\n                    break\n            if found:\n                yield key, values\n\n    def store_count(self):\n        return len(self._data)\n\n    def store_keys(self):\n        return list(self._data.keys())",
  "def __init__(self, filename, data=None, **kwargs):\n        if isinstance(filename, dict):\n            # backward compatibility, first argument was a dict.\n            self.filename = None\n            self._data = filename\n        else:\n            self.filename = filename\n            self._data = data or {}\n        self._is_changed = True\n        super(DictStore, self).__init__(**kwargs)",
  "def store_load(self):\n        if self.filename is None:\n            return\n        if not exists(self.filename):\n            folder = abspath(dirname(self.filename))\n            if not exists(folder):\n                not_found = IOError(\n                    \"The folder '{}' doesn't exist!\"\n                    \"\".format(folder)\n                )\n                not_found.errno = errno.ENOENT\n                raise not_found\n            return\n        with open(self.filename, 'rb') as fd:\n            data = fd.read()\n            if data:\n                self._data = pickle.loads(data)",
  "def store_sync(self):\n        if self.filename is None:\n            return\n        if not self._is_changed:\n            return\n\n        with open(self.filename, 'wb') as fd:\n            pickle.dump(self._data, fd)\n\n        self._is_changed = False",
  "def store_exists(self, key):\n        return key in self._data",
  "def store_get(self, key):\n        return self._data[key]",
  "def store_put(self, key, value):\n        self._data[key] = value\n        self._is_changed = True\n        return True",
  "def store_delete(self, key):\n        del self._data[key]\n        self._is_changed = True\n        return True",
  "def store_find(self, filters):\n        for key, values in iteritems(self._data):\n            found = True\n            for fkey, fvalue in iteritems(filters):\n                if fkey not in values:\n                    found = False\n                    break\n                if values[fkey] != fvalue:\n                    found = False\n                    break\n            if found:\n                yield key, values",
  "def store_count(self):\n        return len(self._data)",
  "def store_keys(self):\n        return list(self._data.keys())",
  "class JsonStore(AbstractStore):\n    '''Store implementation using a json file for storing the key-value pairs.\n    See the :mod:`kivy.storage` module documentation for more information.\n    '''\n    def __init__(self, filename, indent=None, sort_keys=False, **kwargs):\n        self.filename = filename\n        self.indent = indent\n        self.sort_keys = sort_keys\n        self._data = {}\n        self._is_changed = True\n        super(JsonStore, self).__init__(**kwargs)\n\n    def store_load(self):\n        if not exists(self.filename):\n            folder = abspath(dirname(self.filename))\n            if not exists(folder):\n                not_found = IOError(\n                    \"The folder '{}' doesn't exist!\"\n                    \"\".format(folder)\n                )\n                not_found.errno = errno.ENOENT\n                raise not_found\n            return\n        with open(self.filename) as fd:\n            data = fd.read()\n            if len(data) == 0:\n                return\n            self._data = loads(data)\n\n    def store_sync(self):\n        if not self._is_changed:\n            return\n        with open(self.filename, 'w') as fd:\n            dump(\n                self._data, fd,\n                indent=self.indent,\n                sort_keys=self.sort_keys\n            )\n        self._is_changed = False\n\n    def store_exists(self, key):\n        return key in self._data\n\n    def store_get(self, key):\n        return self._data[key]\n\n    def store_put(self, key, value):\n        self._data[key] = value\n        self._is_changed = True\n        return True\n\n    def store_delete(self, key):\n        del self._data[key]\n        self._is_changed = True\n        return True\n\n    def store_find(self, filters):\n        for key, values in iteritems(self._data):\n            found = True\n            for fkey, fvalue in iteritems(filters):\n                if fkey not in values:\n                    found = False\n                    break\n                if values[fkey] != fvalue:\n                    found = False\n                    break\n            if found:\n                yield key, values\n\n    def store_count(self):\n        return len(self._data)\n\n    def store_keys(self):\n        return list(self._data.keys())",
  "def __init__(self, filename, indent=None, sort_keys=False, **kwargs):\n        self.filename = filename\n        self.indent = indent\n        self.sort_keys = sort_keys\n        self._data = {}\n        self._is_changed = True\n        super(JsonStore, self).__init__(**kwargs)",
  "def store_load(self):\n        if not exists(self.filename):\n            folder = abspath(dirname(self.filename))\n            if not exists(folder):\n                not_found = IOError(\n                    \"The folder '{}' doesn't exist!\"\n                    \"\".format(folder)\n                )\n                not_found.errno = errno.ENOENT\n                raise not_found\n            return\n        with open(self.filename) as fd:\n            data = fd.read()\n            if len(data) == 0:\n                return\n            self._data = loads(data)",
  "def store_sync(self):\n        if not self._is_changed:\n            return\n        with open(self.filename, 'w') as fd:\n            dump(\n                self._data, fd,\n                indent=self.indent,\n                sort_keys=self.sort_keys\n            )\n        self._is_changed = False",
  "def store_exists(self, key):\n        return key in self._data",
  "def store_get(self, key):\n        return self._data[key]",
  "def store_put(self, key, value):\n        self._data[key] = value\n        self._is_changed = True\n        return True",
  "def store_delete(self, key):\n        del self._data[key]\n        self._is_changed = True\n        return True",
  "def store_find(self, filters):\n        for key, values in iteritems(self._data):\n            found = True\n            for fkey, fvalue in iteritems(filters):\n                if fkey not in values:\n                    found = False\n                    break\n                if values[fkey] != fvalue:\n                    found = False\n                    break\n            if found:\n                yield key, values",
  "def store_count(self):\n        return len(self._data)",
  "def store_keys(self):\n        return list(self._data.keys())",
  "class AbstractStore(EventDispatcher):\n    '''Abstract class used to implement a Store\n    '''\n\n    def __init__(self, **kwargs):\n        super(AbstractStore, self).__init__(**kwargs)\n        self.store_load()\n\n    def exists(self, key):\n        '''Check if a key exists in the store.\n        '''\n        return self.store_exists(key)\n\n    def async_exists(self, callback, key):\n        '''Asynchronous version of :meth:`exists`.\n\n        :Callback arguments:\n            `store`: :class:`AbstractStore` instance\n                Store instance\n            `key`: string\n                Name of the key to search for\n            `result`: boo\n                Result of the query, None if any error\n        '''\n        self._schedule(self.store_exists_async,\n                       key=key, callback=callback)\n\n    def get(self, key):\n        '''Get the key-value pairs stored at `key`. If the key is not found, a\n        `KeyError` exception will be thrown.\n        '''\n        return self.store_get(key)\n\n    def async_get(self, callback, key):\n        '''Asynchronous version of :meth:`get`.\n\n        :Callback arguments:\n            `store`: :class:`AbstractStore` instance\n                Store instance\n            `key`: string\n                Name of the key to search for\n            `result`: dict\n                Result of the query, None if any error\n        '''\n        self._schedule(self.store_get_async, key=key, callback=callback)\n\n    def put(self, key, **values):\n        '''Put new key-value pairs (given in *values*) into the storage. Any\n        existing key-value pairs will be removed.\n        '''\n        need_sync = self.store_put(key, values)\n        if need_sync:\n            self.store_sync()\n        return need_sync\n\n    def async_put(self, callback, key, **values):\n        '''Asynchronous version of :meth:`put`.\n\n        :Callback arguments:\n            `store`: :class:`AbstractStore` instance\n                Store instance\n            `key`: string\n                Name of the key to search for\n            `result`: bool\n                Indicate True if the storage has been updated, or False if\n                nothing has been done (no changes). None if any error.\n        '''\n        self._schedule(self.store_put_async,\n                       key=key, value=values, callback=callback)\n\n    def delete(self, key):\n        '''Delete a key from the storage. If the key is not found, a `KeyError`\n        exception will be thrown.'''\n        need_sync = self.store_delete(key)\n        if need_sync:\n            self.store_sync()\n        return need_sync\n\n    def async_delete(self, callback, key):\n        '''Asynchronous version of :meth:`delete`.\n\n        :Callback arguments:\n            `store`: :class:`AbstractStore` instance\n                Store instance\n            `key`: string\n                Name of the key to search for\n            `result`: bool\n                Indicate True if the storage has been updated, or False if\n                nothing has been done (no changes). None if any error.\n        '''\n        self._schedule(self.store_delete_async, key=key,\n                       callback=callback)\n\n    def find(self, **filters):\n        '''Return all the entries matching the filters. The entries are\n        returned through a generator as a list of (key, entry) pairs\n        where *entry* is a dict of key-value pairs ::\n\n            for key, entry in store.find(name='Mathieu'):\n                print('key:', key, ', entry:', entry)\n\n        Because it's a generator, you cannot directly use it as a list. You can\n        do::\n\n            # get all the (key, entry) availables\n            entries = list(store.find(name='Mathieu'))\n            # get only the entry from (key, entry)\n            entries = list((x[1] for x in store.find(name='Mathieu')))\n        '''\n        return self.store_find(filters)\n\n    def async_find(self, callback, **filters):\n        '''Asynchronous version of :meth:`find`.\n\n        The callback will be called for each entry in the result.\n\n        :Callback arguments:\n            `store`: :class:`AbstractStore` instance\n                Store instance\n            `key`: string\n                Name of the key to search for, or None if we reach the end of\n                the results\n            `result`: bool\n                Indicate True if the storage has been updated, or False if\n                nothing has been done (no changes). None if any error.\n        '''\n        self._schedule(self.store_find_async,\n                       callback=callback, filters=filters)\n\n    def keys(self):\n        '''Return a list of all the keys in the storage.\n        '''\n        return self.store_keys()\n\n    def async_keys(self, callback):\n        '''Asynchronously return all the keys in the storage.\n        '''\n        self._schedule(self.store_keys_async, callback=callback)\n\n    def count(self):\n        '''Return the number of entries in the storage.\n        '''\n        return self.store_count()\n\n    def async_count(self, callback):\n        '''Asynchronously return the number of entries in the storage.\n        '''\n        self._schedule(self.store_count_async, callback=callback)\n\n    def clear(self):\n        '''Wipe the whole storage.\n        '''\n        return self.store_clear()\n\n    def async_clear(self, callback):\n        '''Asynchronous version of :meth:`clear`.\n        '''\n        self._schedule(self.store_clear_async, callback=callback)\n\n    #\n    # Operators\n    #\n\n    def __setitem__(self, key, values):\n        if not isinstance(values, dict):\n            raise Exception('Only dict are accepted for the store[key] = dict')\n        self.put(key, **values)\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __delitem__(self, key):\n        return self.keys()\n\n    def __contains__(self, key):\n        return self.exists(key)\n\n    def __len__(self):\n        return self.count()\n\n    def __iter__(self):\n        for key in self.keys():\n            yield key\n\n    #\n    # Used for implementation\n    #\n\n    def store_load(self):\n        pass\n\n    def store_sync(self):\n        pass\n\n    def store_get(self, key):\n        raise NotImplementedError\n\n    def store_put(self, key, value):\n        raise NotImplementedError\n\n    def store_exists(self, key):\n        raise NotImplementedError\n\n    def store_delete(self, key):\n        raise NotImplementedError\n\n    def store_find(self, filters):\n        return []\n\n    def store_keys(self):\n        return []\n\n    def store_count(self):\n        return len(self.store_keys())\n\n    def store_clear(self):\n        for key in self.store_keys():\n            self.store_delete(key)\n        self.store_sync()\n\n    def store_get_async(self, key, callback):\n        try:\n            value = self.store_get(key)\n            callback(self, key, value)\n        except KeyError:\n            callback(self, key, None)\n\n    def store_put_async(self, key, value, callback):\n        try:\n            value = self.put(key, **value)\n            callback(self, key, value)\n        except:\n            callback(self, key, None)\n\n    def store_exists_async(self, key, callback):\n        try:\n            value = self.store_exists(key)\n            callback(self, key, value)\n        except:\n            callback(self, key, None)\n\n    def store_delete_async(self, key, callback):\n        try:\n            value = self.delete(key)\n            callback(self, key, value)\n        except:\n            callback(self, key, None)\n\n    def store_find_async(self, filters, callback):\n        for key, entry in self.store_find(filters):\n            callback(self, filters, key, entry)\n        callback(self, filters, None, None)\n\n    def store_count_async(self, callback):\n        try:\n            value = self.store_count()\n            callback(self, value)\n        except:\n            callback(self, 0)\n\n    def store_keys_async(self, callback):\n        try:\n            keys = self.store_keys()\n            callback(self, keys)\n        except:\n            callback(self, [])\n\n    def store_clear_async(self, callback):\n        self.store_clear()\n        callback(self)\n\n    #\n    # Privates\n    #\n\n    def _schedule(self, cb, **kwargs):\n        # XXX not entirely sure about the best value (0 or -1).\n        Clock.schedule_once(lambda dt: cb(**kwargs), 0)",
  "def __init__(self, **kwargs):\n        super(AbstractStore, self).__init__(**kwargs)\n        self.store_load()",
  "def exists(self, key):\n        '''Check if a key exists in the store.\n        '''\n        return self.store_exists(key)",
  "def async_exists(self, callback, key):\n        '''Asynchronous version of :meth:`exists`.\n\n        :Callback arguments:\n            `store`: :class:`AbstractStore` instance\n                Store instance\n            `key`: string\n                Name of the key to search for\n            `result`: boo\n                Result of the query, None if any error\n        '''\n        self._schedule(self.store_exists_async,\n                       key=key, callback=callback)",
  "def get(self, key):\n        '''Get the key-value pairs stored at `key`. If the key is not found, a\n        `KeyError` exception will be thrown.\n        '''\n        return self.store_get(key)",
  "def async_get(self, callback, key):\n        '''Asynchronous version of :meth:`get`.\n\n        :Callback arguments:\n            `store`: :class:`AbstractStore` instance\n                Store instance\n            `key`: string\n                Name of the key to search for\n            `result`: dict\n                Result of the query, None if any error\n        '''\n        self._schedule(self.store_get_async, key=key, callback=callback)",
  "def put(self, key, **values):\n        '''Put new key-value pairs (given in *values*) into the storage. Any\n        existing key-value pairs will be removed.\n        '''\n        need_sync = self.store_put(key, values)\n        if need_sync:\n            self.store_sync()\n        return need_sync",
  "def async_put(self, callback, key, **values):\n        '''Asynchronous version of :meth:`put`.\n\n        :Callback arguments:\n            `store`: :class:`AbstractStore` instance\n                Store instance\n            `key`: string\n                Name of the key to search for\n            `result`: bool\n                Indicate True if the storage has been updated, or False if\n                nothing has been done (no changes). None if any error.\n        '''\n        self._schedule(self.store_put_async,\n                       key=key, value=values, callback=callback)",
  "def delete(self, key):\n        '''Delete a key from the storage. If the key is not found, a `KeyError`\n        exception will be thrown.'''\n        need_sync = self.store_delete(key)\n        if need_sync:\n            self.store_sync()\n        return need_sync",
  "def async_delete(self, callback, key):\n        '''Asynchronous version of :meth:`delete`.\n\n        :Callback arguments:\n            `store`: :class:`AbstractStore` instance\n                Store instance\n            `key`: string\n                Name of the key to search for\n            `result`: bool\n                Indicate True if the storage has been updated, or False if\n                nothing has been done (no changes). None if any error.\n        '''\n        self._schedule(self.store_delete_async, key=key,\n                       callback=callback)",
  "def find(self, **filters):\n        '''Return all the entries matching the filters. The entries are\n        returned through a generator as a list of (key, entry) pairs\n        where *entry* is a dict of key-value pairs ::\n\n            for key, entry in store.find(name='Mathieu'):\n                print('key:', key, ', entry:', entry)\n\n        Because it's a generator, you cannot directly use it as a list. You can\n        do::\n\n            # get all the (key, entry) availables\n            entries = list(store.find(name='Mathieu'))\n            # get only the entry from (key, entry)\n            entries = list((x[1] for x in store.find(name='Mathieu')))\n        '''\n        return self.store_find(filters)",
  "def async_find(self, callback, **filters):\n        '''Asynchronous version of :meth:`find`.\n\n        The callback will be called for each entry in the result.\n\n        :Callback arguments:\n            `store`: :class:`AbstractStore` instance\n                Store instance\n            `key`: string\n                Name of the key to search for, or None if we reach the end of\n                the results\n            `result`: bool\n                Indicate True if the storage has been updated, or False if\n                nothing has been done (no changes). None if any error.\n        '''\n        self._schedule(self.store_find_async,\n                       callback=callback, filters=filters)",
  "def keys(self):\n        '''Return a list of all the keys in the storage.\n        '''\n        return self.store_keys()",
  "def async_keys(self, callback):\n        '''Asynchronously return all the keys in the storage.\n        '''\n        self._schedule(self.store_keys_async, callback=callback)",
  "def count(self):\n        '''Return the number of entries in the storage.\n        '''\n        return self.store_count()",
  "def async_count(self, callback):\n        '''Asynchronously return the number of entries in the storage.\n        '''\n        self._schedule(self.store_count_async, callback=callback)",
  "def clear(self):\n        '''Wipe the whole storage.\n        '''\n        return self.store_clear()",
  "def async_clear(self, callback):\n        '''Asynchronous version of :meth:`clear`.\n        '''\n        self._schedule(self.store_clear_async, callback=callback)",
  "def __setitem__(self, key, values):\n        if not isinstance(values, dict):\n            raise Exception('Only dict are accepted for the store[key] = dict')\n        self.put(key, **values)",
  "def __getitem__(self, key):\n        return self.get(key)",
  "def __delitem__(self, key):\n        return self.keys()",
  "def __contains__(self, key):\n        return self.exists(key)",
  "def __len__(self):\n        return self.count()",
  "def __iter__(self):\n        for key in self.keys():\n            yield key",
  "def store_load(self):\n        pass",
  "def store_sync(self):\n        pass",
  "def store_get(self, key):\n        raise NotImplementedError",
  "def store_put(self, key, value):\n        raise NotImplementedError",
  "def store_exists(self, key):\n        raise NotImplementedError",
  "def store_delete(self, key):\n        raise NotImplementedError",
  "def store_find(self, filters):\n        return []",
  "def store_keys(self):\n        return []",
  "def store_count(self):\n        return len(self.store_keys())",
  "def store_clear(self):\n        for key in self.store_keys():\n            self.store_delete(key)\n        self.store_sync()",
  "def store_get_async(self, key, callback):\n        try:\n            value = self.store_get(key)\n            callback(self, key, value)\n        except KeyError:\n            callback(self, key, None)",
  "def store_put_async(self, key, value, callback):\n        try:\n            value = self.put(key, **value)\n            callback(self, key, value)\n        except:\n            callback(self, key, None)",
  "def store_exists_async(self, key, callback):\n        try:\n            value = self.store_exists(key)\n            callback(self, key, value)\n        except:\n            callback(self, key, None)",
  "def store_delete_async(self, key, callback):\n        try:\n            value = self.delete(key)\n            callback(self, key, value)\n        except:\n            callback(self, key, None)",
  "def store_find_async(self, filters, callback):\n        for key, entry in self.store_find(filters):\n            callback(self, filters, key, entry)\n        callback(self, filters, None, None)",
  "def store_count_async(self, callback):\n        try:\n            value = self.store_count()\n            callback(self, value)\n        except:\n            callback(self, 0)",
  "def store_keys_async(self, callback):\n        try:\n            keys = self.store_keys()\n            callback(self, keys)\n        except:\n            callback(self, [])",
  "def store_clear_async(self, callback):\n        self.store_clear()\n        callback(self)",
  "def _schedule(self, cb, **kwargs):\n        # XXX not entirely sure about the best value (0 or -1).\n        Clock.schedule_once(lambda dt: cb(**kwargs), 0)",
  "class RedisStore(AbstractStore):\n    '''Store implementation using a Redis database.\n    See the :mod:`kivy.storage` module documentation for more information.\n    '''\n\n    prefix = StringProperty('store')\n\n    def __init__(self, redis_params, **kwargs):\n        self.redis_params = redis_params\n        self.r = None\n        super(RedisStore, self).__init__(**kwargs)\n\n    def store_load(self):\n        self.r = redis.StrictRedis(**self.redis_params)\n\n    def store_sync(self):\n        pass\n\n    def store_exists(self, key):\n        key = self.prefix + '.d.' + key\n        value = self.r.exists(key)\n        return value\n\n    def store_get(self, key):\n        key = self.prefix + '.d.' + key\n        if not self.r.exists(key):\n            raise KeyError(key)\n        result = self.r.hgetall(key)\n        for k in result.keys():\n            result[k] = loads(result[k])\n        return result\n\n    def store_put(self, key, values):\n        key = self.prefix + '.d.' + key\n        pipe = self.r.pipeline()\n        pipe.delete(key)\n        for k, v in iteritems(values):\n            pipe.hset(key, k, dumps(v))\n        pipe.execute()\n        return True\n\n    def store_delete(self, key):\n        key = self.prefix + '.d.' + key\n        if not self.r.exists(key):\n            raise KeyError(key)\n        return self.r.delete(key)\n\n    def store_keys(self):\n        z = len(self.prefix + '.d.')\n        return [x[z:] for x in self.r.keys(self.prefix + '.d.*')]\n\n    def store_find(self, filters):\n        fkeys = filters.keys()\n        fvalues = filters.values()\n        for key in self.store_keys():\n            skey = self.prefix + '.d.' + key\n            svalues = self.r.hmget(skey, fkeys)\n            if None in svalues:\n                continue\n            svalues = [loads(x) for x in svalues]\n            if fvalues != svalues:\n                continue\n            yield key, self.r.hgetall(skey)",
  "def __init__(self, redis_params, **kwargs):\n        self.redis_params = redis_params\n        self.r = None\n        super(RedisStore, self).__init__(**kwargs)",
  "def store_load(self):\n        self.r = redis.StrictRedis(**self.redis_params)",
  "def store_sync(self):\n        pass",
  "def store_exists(self, key):\n        key = self.prefix + '.d.' + key\n        value = self.r.exists(key)\n        return value",
  "def store_get(self, key):\n        key = self.prefix + '.d.' + key\n        if not self.r.exists(key):\n            raise KeyError(key)\n        result = self.r.hgetall(key)\n        for k in result.keys():\n            result[k] = loads(result[k])\n        return result",
  "def store_put(self, key, values):\n        key = self.prefix + '.d.' + key\n        pipe = self.r.pipeline()\n        pipe.delete(key)\n        for k, v in iteritems(values):\n            pipe.hset(key, k, dumps(v))\n        pipe.execute()\n        return True",
  "def store_delete(self, key):\n        key = self.prefix + '.d.' + key\n        if not self.r.exists(key):\n            raise KeyError(key)\n        return self.r.delete(key)",
  "def store_keys(self):\n        z = len(self.prefix + '.d.')\n        return [x[z:] for x in self.r.keys(self.prefix + '.d.*')]",
  "def store_find(self, filters):\n        fkeys = filters.keys()\n        fvalues = filters.values()\n        for key in self.store_keys():\n            skey = self.prefix + '.d.' + key\n            svalues = self.r.hmget(skey, fkeys)\n            if None in svalues:\n                continue\n            svalues = [loads(x) for x in svalues]\n            if fvalues != svalues:\n                continue\n            yield key, self.r.hgetall(skey)",
  "class RecorderMotionEvent(MotionEvent):\n\n    def depack(self, args):\n        for key, value in list(args.items()):\n            setattr(self, key, value)\n        super(RecorderMotionEvent, self).depack(args)",
  "class Recorder(EventDispatcher):\n    '''Recorder class. Please check module documentation for more information.\n\n    :Events:\n        `on_stop`:\n            Fired when the playing stops.\n\n    .. versionchanged:: 1.10.0\n        Event `on_stop` added.\n    '''\n\n    window = ObjectProperty(None)\n    '''Window instance to attach the recorder. If None, it will use the\n    default instance.\n\n    :attr:`window` is a :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    counter = NumericProperty(0)\n    '''Number of events recorded in the last session.\n\n    :attr:`counter` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 0, read-only.\n    '''\n\n    play = BooleanProperty(False)\n    '''Boolean to start/stop the replay of the current file (if it exists).\n\n    :attr:`play` is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.\n    '''\n\n    record = BooleanProperty(False)\n    '''Boolean to start/stop the recording of input events.\n\n    :attr:`record` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    filename = StringProperty('recorder.kvi')\n    '''Filename to save the output of the recorder.\n\n    :attr:`filename` is a :class:`~kivy.properties.StringProperty` and defaults\n    to 'recorder.kvi'.\n    '''\n\n    record_attrs = ListProperty(['is_touch', 'sx', 'sy'])\n    '''Attributes to record from the motion event.\n\n    :attr:`record_attrs` is a :class:`~kivy.properties.ListProperty` and\n    defaults to ['is_touch', 'sx', 'sy'].\n    '''\n\n    record_profile_mask = ListProperty(['pos'])\n    '''Profile to save in the fake motion event when replayed.\n\n    :attr:`record_profile_mask` is a :class:`~kivy.properties.ListProperty` and\n    defaults to ['pos'].\n    '''\n\n    # internals\n    record_fd = ObjectProperty(None)\n    record_time = NumericProperty(0.)\n\n    __events__ = ('on_stop',)\n\n    def __init__(self, **kwargs):\n        super(Recorder, self).__init__(**kwargs)\n        if self.window is None:\n            # manually set the current window\n            from kivy.core.window import Window\n            self.window = Window\n        self.window.bind(\n            on_motion=self.on_motion,\n            on_key_up=partial(self.on_keyboard, 'keyup'),\n            on_key_down=partial(self.on_keyboard, 'keydown'),\n            on_keyboard=partial(self.on_keyboard, 'keyboard'))\n\n    def on_motion(self, window, etype, motionevent):\n        if not self.record:\n            return\n\n        args = dict((arg, getattr(motionevent, arg))\n                    for arg in self.record_attrs if hasattr(motionevent, arg))\n\n        args['profile'] = [x for x in motionevent.profile if x in\n                           self.record_profile_mask]\n        self.record_fd.write('%r\\n' % (\n            (time() - self.record_time, etype, motionevent.uid, args), ))\n        self.counter += 1\n\n    def on_keyboard(self, etype, window, key, *args, **kwargs):\n        if not self.record:\n            return\n        self.record_fd.write('%r\\n' % (\n            (time() - self.record_time, etype, 0, {\n                'key': key,\n                'scancode': kwargs.get('scancode'),\n                'codepoint': kwargs.get('codepoint', kwargs.get('unicode')),\n                'modifier': kwargs.get('modifier'),\n                'is_touch': False}), ))\n        self.counter += 1\n\n    def release(self):\n        self.window.unbind(\n            on_motion=self.on_motion,\n            on_key_up=self.on_keyboard,\n            on_key_down=self.on_keyboard)\n\n    def on_record(self, instance, value):\n        if value:\n            # generate a record filename\n            self.counter = 0\n            self.record_time = time()\n            self.record_fd = open(self.filename, 'w')\n            self.record_fd.write('#RECORDER1.0\\n')\n            Logger.info('Recorder: Recording inputs to %r' % self.filename)\n        else:\n            self.record_fd.close()\n            Logger.info('Recorder: Recorded %d events in %r' % (self.counter,\n                                                                self.filename))\n\n    # needed for acting as an input provider\n    def stop(self):\n        pass\n\n    def start(self):\n        pass\n\n    def on_play(self, instance, value):\n        if not value:\n            Logger.info('Recorder: Stop playing %r' % self.filename)\n            EventLoop.remove_input_provider(self)\n            return\n        if not exists(self.filename):\n            Logger.error('Recorder: Unable to find %r file, play aborted.' % (\n                self.filename))\n            return\n\n        with open(self.filename, 'r') as fd:\n            data = fd.read().splitlines()\n\n        if len(data) < 2:\n            Logger.error('Recorder: Unable to play %r, file truncated.' % (\n                self.filename))\n            return\n\n        if data[0] != '#RECORDER1.0':\n            Logger.error('Recorder: Unable to play %r, invalid header.' % (\n                self.filename))\n            return\n\n        # decompile data\n        self.play_data = [literal_eval(x) for x in data[1:]]\n        self.play_time = time()\n        self.play_me = {}\n        Logger.info('Recorder: Start playing %d events from %r' %\n                    (len(self.play_data), self.filename))\n        EventLoop.add_input_provider(self)\n\n    def on_stop(self):\n        pass\n\n    def update(self, dispatch_fn):\n        if not self.play_data:\n            Logger.info('Recorder: Playing finished.')\n            self.play = False\n            self.dispatch('on_stop')\n\n        dt = time() - self.play_time\n        while self.play_data:\n            event = self.play_data[0]\n            assert len(event) == 4\n            if event[0] > dt:\n                return\n\n            me = None\n            etype, uid, args = event[1:]\n            if etype == 'begin':\n                me = RecorderMotionEvent('recorder', uid, args)\n                self.play_me[uid] = me\n            elif etype == 'update':\n                me = self.play_me[uid]\n                me.depack(args)\n            elif etype == 'end':\n                me = self.play_me.pop(uid)\n                me.depack(args)\n            elif etype == 'keydown':\n                self.window.dispatch(\n                    'on_key_down',\n                    args['key'],\n                    args['scancode'],\n                    args['codepoint'],\n                    args['modifier'])\n            elif etype == 'keyup':\n                self.window.dispatch(\n                    'on_key_up',\n                    args['key'],\n                    args['scancode'],\n                    args['codepoint'],\n                    args['modifier'])\n            elif etype == 'keyboard':\n                self.window.dispatch(\n                    'on_keyboard',\n                    args['key'],\n                    args['scancode'],\n                    args['codepoint'],\n                    args['modifier'])\n\n            if me:\n                dispatch_fn(etype, me)\n\n            self.play_data.pop(0)",
  "def start(win, ctx):\n    ctx.recorder = Recorder(window=win)",
  "def stop(win, ctx):\n    if hasattr(ctx, 'recorder'):\n        ctx.recorder.release()",
  "def depack(self, args):\n        for key, value in list(args.items()):\n            setattr(self, key, value)\n        super(RecorderMotionEvent, self).depack(args)",
  "def __init__(self, **kwargs):\n        super(Recorder, self).__init__(**kwargs)\n        if self.window is None:\n            # manually set the current window\n            from kivy.core.window import Window\n            self.window = Window\n        self.window.bind(\n            on_motion=self.on_motion,\n            on_key_up=partial(self.on_keyboard, 'keyup'),\n            on_key_down=partial(self.on_keyboard, 'keydown'),\n            on_keyboard=partial(self.on_keyboard, 'keyboard'))",
  "def on_motion(self, window, etype, motionevent):\n        if not self.record:\n            return\n\n        args = dict((arg, getattr(motionevent, arg))\n                    for arg in self.record_attrs if hasattr(motionevent, arg))\n\n        args['profile'] = [x for x in motionevent.profile if x in\n                           self.record_profile_mask]\n        self.record_fd.write('%r\\n' % (\n            (time() - self.record_time, etype, motionevent.uid, args), ))\n        self.counter += 1",
  "def on_keyboard(self, etype, window, key, *args, **kwargs):\n        if not self.record:\n            return\n        self.record_fd.write('%r\\n' % (\n            (time() - self.record_time, etype, 0, {\n                'key': key,\n                'scancode': kwargs.get('scancode'),\n                'codepoint': kwargs.get('codepoint', kwargs.get('unicode')),\n                'modifier': kwargs.get('modifier'),\n                'is_touch': False}), ))\n        self.counter += 1",
  "def release(self):\n        self.window.unbind(\n            on_motion=self.on_motion,\n            on_key_up=self.on_keyboard,\n            on_key_down=self.on_keyboard)",
  "def on_record(self, instance, value):\n        if value:\n            # generate a record filename\n            self.counter = 0\n            self.record_time = time()\n            self.record_fd = open(self.filename, 'w')\n            self.record_fd.write('#RECORDER1.0\\n')\n            Logger.info('Recorder: Recording inputs to %r' % self.filename)\n        else:\n            self.record_fd.close()\n            Logger.info('Recorder: Recorded %d events in %r' % (self.counter,\n                                                                self.filename))",
  "def stop(self):\n        pass",
  "def start(self):\n        pass",
  "def on_play(self, instance, value):\n        if not value:\n            Logger.info('Recorder: Stop playing %r' % self.filename)\n            EventLoop.remove_input_provider(self)\n            return\n        if not exists(self.filename):\n            Logger.error('Recorder: Unable to find %r file, play aborted.' % (\n                self.filename))\n            return\n\n        with open(self.filename, 'r') as fd:\n            data = fd.read().splitlines()\n\n        if len(data) < 2:\n            Logger.error('Recorder: Unable to play %r, file truncated.' % (\n                self.filename))\n            return\n\n        if data[0] != '#RECORDER1.0':\n            Logger.error('Recorder: Unable to play %r, invalid header.' % (\n                self.filename))\n            return\n\n        # decompile data\n        self.play_data = [literal_eval(x) for x in data[1:]]\n        self.play_time = time()\n        self.play_me = {}\n        Logger.info('Recorder: Start playing %d events from %r' %\n                    (len(self.play_data), self.filename))\n        EventLoop.add_input_provider(self)",
  "def on_stop(self):\n        pass",
  "def update(self, dispatch_fn):\n        if not self.play_data:\n            Logger.info('Recorder: Playing finished.')\n            self.play = False\n            self.dispatch('on_stop')\n\n        dt = time() - self.play_time\n        while self.play_data:\n            event = self.play_data[0]\n            assert len(event) == 4\n            if event[0] > dt:\n                return\n\n            me = None\n            etype, uid, args = event[1:]\n            if etype == 'begin':\n                me = RecorderMotionEvent('recorder', uid, args)\n                self.play_me[uid] = me\n            elif etype == 'update':\n                me = self.play_me[uid]\n                me.depack(args)\n            elif etype == 'end':\n                me = self.play_me.pop(uid)\n                me.depack(args)\n            elif etype == 'keydown':\n                self.window.dispatch(\n                    'on_key_down',\n                    args['key'],\n                    args['scancode'],\n                    args['codepoint'],\n                    args['modifier'])\n            elif etype == 'keyup':\n                self.window.dispatch(\n                    'on_key_up',\n                    args['key'],\n                    args['scancode'],\n                    args['codepoint'],\n                    args['modifier'])\n            elif etype == 'keyboard':\n                self.window.dispatch(\n                    'on_keyboard',\n                    args['key'],\n                    args['scancode'],\n                    args['codepoint'],\n                    args['modifier'])\n\n            if me:\n                dispatch_fn(etype, me)\n\n            self.play_data.pop(0)",
  "class MotionEventFactory:\n    '''MotionEvent factory is a class that registers all availables input\n    factories. If you create a new input factory, you need to register\n    it here::\n\n        MotionEventFactory.register('myproviderid', MyInputProvider)\n\n    '''\n    __providers__ = {}\n\n    @staticmethod\n    def register(name, classname):\n        '''Register a input provider in the database'''\n        MotionEventFactory.__providers__[name] = classname\n\n    @staticmethod\n    def list():\n        '''Get a list of all available providers'''\n        return MotionEventFactory.__providers__\n\n    @staticmethod\n    def get(name):\n        '''Get a provider class from the provider id'''\n        if name in MotionEventFactory.__providers__:\n            return MotionEventFactory.__providers__[name]",
  "def register(name, classname):\n        '''Register a input provider in the database'''\n        MotionEventFactory.__providers__[name] = classname",
  "def list():\n        '''Get a list of all available providers'''\n        return MotionEventFactory.__providers__",
  "def get(name):\n        '''Get a provider class from the provider id'''\n        if name in MotionEventFactory.__providers__:\n            return MotionEventFactory.__providers__[name]",
  "class MotionEventProvider(object):\n    '''Base class for a provider.\n    '''\n\n    def __init__(self, device, args):\n        self.device = device\n        if self.__class__ == MotionEventProvider:\n            raise NotImplementedError('class MotionEventProvider is abstract')\n\n    def start(self):\n        '''Start the provider. This method is automatically called when the\n        application is started and if the configuration uses the current\n        provider.\n        '''\n        pass\n\n    def stop(self):\n        '''Stop the provider.\n        '''\n        pass\n\n    def update(self, dispatch_fn):\n        '''Update the provider and dispatch all the new touch events though the\n        `dispatch_fn` argument.\n        '''\n        pass",
  "def __init__(self, device, args):\n        self.device = device\n        if self.__class__ == MotionEventProvider:\n            raise NotImplementedError('class MotionEventProvider is abstract')",
  "def start(self):\n        '''Start the provider. This method is automatically called when the\n        application is started and if the configuration uses the current\n        provider.\n        '''\n        pass",
  "def stop(self):\n        '''Stop the provider.\n        '''\n        pass",
  "def update(self, dispatch_fn):\n        '''Update the provider and dispatch all the new touch events though the\n        `dispatch_fn` argument.\n        '''\n        pass",
  "class EnhancedDictionary(dict):\n\n    def __getattr__(self, attr):\n        try:\n            return self.__getitem__(attr)\n        except KeyError:\n            return super(EnhancedDictionary, self).__getattr__(attr)\n\n    def __setattr__(self, attr, value):\n        self.__setitem__(attr, value)",
  "class MotionEventMetaclass(type):\n\n    def __new__(mcs, name, bases, attrs):\n        __attrs__ = []\n        for base in bases:\n            if hasattr(base, '__attrs__'):\n                __attrs__.extend(base.__attrs__)\n        if '__attrs__' in attrs:\n            __attrs__.extend(attrs['__attrs__'])\n        attrs['__attrs__'] = tuple(__attrs__)\n        return super(MotionEventMetaclass, mcs).__new__(mcs, name,\n                                                        bases, attrs)",
  "class MotionEvent(MotionEventBase):\n    '''Abstract class that represents an input event.\n\n    :Parameters:\n        `id`: str\n            unique ID of the MotionEvent\n        `args`: list\n            list of parameters, passed to the depack() function\n    '''\n\n    __uniq_id = 0\n    __attrs__ = \\\n        ('device', 'push_attrs', 'push_attrs_stack',\n         'is_touch', 'type_id', 'id', 'dispatch_mode', 'shape', 'profile',\n         # current position, in 0-1 range\n         'sx', 'sy', 'sz',\n         # first position set, in 0-1 range\n         'osx', 'osy', 'osz',\n         # last position set, in 0-1 range\n         'psx', 'psy', 'psz',\n         # delta from the last position and current one, in 0-1 range\n         'dsx', 'dsy', 'dsz',\n         # current position, in screen range\n         'x', 'y', 'z',\n         # first position set, in screen range\n         'ox', 'oy', 'oz',\n         # last position set, in 0-1 range\n         'px', 'py', 'pz',\n         # delta from the last position and current one, in screen range\n         'dx', 'dy', 'dz',\n         'time_start',\n         'is_double_tap', 'double_tap_time',\n         'is_triple_tap', 'triple_tap_time',\n         'ud')\n\n    def __init__(self, device, id, args, is_touch=False, type_id=None):\n        if self.__class__ == MotionEvent:\n            raise NotImplementedError('class MotionEvent is abstract')\n        MotionEvent.__uniq_id += 1\n\n        #: True if the MotionEvent is a touch.\n        self.is_touch = is_touch\n\n        #: (Experimental) String to identify event type.\n        #:\n        #: .. versionadded:: 2.1.0\n        self.type_id = type_id\n\n        #: (Experimental) Used by a event manager or a widget to assign\n        #: the dispatching mode. Defaults to\n        #: :const:`~kivy.eventmanager.MODE_DEFAULT_DISPATCH`. See\n        #: :mod:`~kivy.eventmanager` for available modes.\n        #:\n        #: .. versionadded:: 2.1.0\n        self.dispatch_mode = MODE_DEFAULT_DISPATCH\n\n        #: Attributes to push by default, when we use :meth:`push` : x, y, z,\n        #: dx, dy, dz, ox, oy, oz, px, py, pz.\n        self.push_attrs_stack = []\n        self.push_attrs = ('x', 'y', 'z', 'dx', 'dy', 'dz', 'ox', 'oy', 'oz',\n                           'px', 'py', 'pz', 'pos', 'type_id', 'dispatch_mode')\n\n        #: Uniq ID of the event. You can safely use this property, it will be\n        #: never the same across all existing events.\n        self.uid = MotionEvent.__uniq_id\n\n        #: Device used for creating this event.\n        self.device = device\n\n        # For grab\n        self.grab_list = []\n        self.grab_exclusive_class = None\n        self.grab_state = False\n\n        #: Used to determine which widget the event is being dispatched to.\n        #: Check the :meth:`grab` function for more information.\n        self.grab_current = None\n\n        #: Currently pressed button.\n        self.button = None\n\n        #: Profiles currently used in the event.\n        self.profile = []\n\n        #: Id of the event, not unique. This is generally the Id set by the\n        #: input provider, like ID in TUIO. If you have multiple TUIO sources,\n        #: then same id can be used. Prefer to use :attr:`uid` attribute\n        #: instead.\n        self.id = id\n\n        #: Shape of the touch event, subclass of\n        #: :class:`~kivy.input.shape.Shape`.\n        #: By default, the property is set to None.\n        self.shape = None\n\n        #: X position, in 0-1 range.\n        self.sx = 0.0\n        #: Y position, in 0-1 range.\n        self.sy = 0.0\n        #: Z position, in 0-1 range.\n        self.sz = 0.0\n        #: Origin X position, in 0-1 range.\n        self.osx = None\n        #: Origin Y position, in 0-1 range.\n        self.osy = None\n        #: Origin Z position, in 0-1 range.\n        self.osz = None\n        #: Previous X position, in 0-1 range.\n        self.psx = None\n        #: Previous Y position, in 0-1 range.\n        self.psy = None\n        #: Previous Z position, in 0-1 range.\n        self.psz = None\n        #: Delta between self.sx and self.psx, in 0-1 range.\n        self.dsx = None\n        #: Delta between self.sy and self.psy, in 0-1 range.\n        self.dsy = None\n        #: Delta between self.sz and self.psz, in 0-1 range.\n        self.dsz = None\n        #: X position, in window range.\n        self.x = 0.0\n        #: Y position, in window range.\n        self.y = 0.0\n        #: Z position, in window range.\n        self.z = 0.0\n        #: Origin X position, in window range.\n        self.ox = None\n        #: Origin Y position, in window range.\n        self.oy = None\n        #: Origin Z position, in window range.\n        self.oz = None\n        #: Previous X position, in window range.\n        self.px = None\n        #: Previous Y position, in window range.\n        self.py = None\n        #: Previous Z position, in window range.\n        self.pz = None\n        #: Delta between self.x and self.px, in window range.\n        self.dx = None\n        #: Delta between self.y and self.py, in window range.\n        self.dy = None\n        #: Delta between self.z and self.pz, in window range.\n        self.dz = None\n        #: Position (X, Y), in window range.\n        self.pos = (0.0, 0.0)\n\n        #: Initial time of the event creation.\n        self.time_start = time()\n\n        #: Time of the last update.\n        self.time_update = self.time_start\n\n        #: Time of the end event (last event usage).\n        self.time_end = -1\n\n        #: Indicate if the touch event is a double tap or not.\n        self.is_double_tap = False\n\n        #: Indicate if the touch event is a triple tap or not.\n        #:\n        #: .. versionadded:: 1.7.0\n        self.is_triple_tap = False\n\n        #: If the touch is a :attr:`is_double_tap`, this is the time\n        #: between the previous tap and the current touch.\n        self.double_tap_time = 0\n\n        #: If the touch is a :attr:`is_triple_tap`, this is the time\n        #: between the first tap and the current touch.\n        #:\n        #: .. versionadded:: 1.7.0\n        self.triple_tap_time = 0\n\n        #: User data dictionary. Use this dictionary to save your own data on\n        #: the event.\n        self.ud = EnhancedDictionary()\n\n        #: If set to `True` (default) keeps first previous position\n        #: (X, Y, Z in 0-1 range) and ignore all other until\n        #: :meth:`MotionEvent.dispatch_done` is called from the `EventLoop`.\n        #:\n        #: This attribute is needed because event provider can make many calls\n        #: to :meth:`MotionEvent.move`, but for all those calls event is\n        #: dispatched to the listeners only once. Assigning `False` will keep\n        #: latest previous position. See :meth:`MotionEvent.move`.\n        #:\n        #: .. versionadded:: 2.1.0\n        self.sync_with_dispatch = True\n\n        #: Keep first previous position if :attr:`sync_with_dispatch` is\n        #: `True`.\n        self._keep_prev_pos = True\n\n        #: Flag that first dispatch of this event is done.\n        self._first_dispatch_done = False\n\n        self.depack(args)\n\n    def depack(self, args):\n        '''Depack `args` into attributes of the class'''\n        if self.osx is None \\\n                or self.sync_with_dispatch and not self._first_dispatch_done:\n            # Sync origin/previous/current positions until the first\n            # dispatch (etype == 'begin') is done.\n            self.osx = self.psx = self.sx\n            self.osy = self.psy = self.sy\n            self.osz = self.psz = self.sz\n        # update the delta\n        self.dsx = self.sx - self.psx\n        self.dsy = self.sy - self.psy\n        self.dsz = self.sz - self.psz\n\n    def grab(self, class_instance, exclusive=False):\n        '''Grab this motion event.\n\n        If this event is a touch you can grab it if you want to receive\n        subsequent :meth:`~kivy.uix.widget.Widget.on_touch_move` and\n        :meth:`~kivy.uix.widget.Widget.on_touch_up` events, even if the touch\n        is not dispatched by the parent:\n\n        .. code-block:: python\n\n            def on_touch_down(self, touch):\n                touch.grab(self)\n\n            def on_touch_move(self, touch):\n                if touch.grab_current is self:\n                    # I received my grabbed touch\n                else:\n                    # it's a normal touch\n\n            def on_touch_up(self, touch):\n                if touch.grab_current is self:\n                    # I receive my grabbed touch, I must ungrab it!\n                    touch.ungrab(self)\n                else:\n                    # it's a normal touch\n                    pass\n\n        .. versionchanged:: 2.1.0\n            Allowed grab for non-touch events.\n        '''\n        if self.grab_exclusive_class is not None:\n            raise Exception('Event is exclusive and cannot be grabbed')\n        class_instance = weakref.ref(class_instance.__self__)\n        if exclusive:\n            self.grab_exclusive_class = class_instance\n        self.grab_list.append(class_instance)\n\n    def ungrab(self, class_instance):\n        '''Ungrab a previously grabbed motion event.\n        '''\n        class_instance = weakref.ref(class_instance.__self__)\n        if self.grab_exclusive_class == class_instance:\n            self.grab_exclusive_class = None\n        if class_instance in self.grab_list:\n            self.grab_list.remove(class_instance)\n\n    def dispatch_done(self):\n        '''Notify that dispatch to the listeners is done.\n\n        Called by the :meth:`EventLoopBase.post_dispatch_input`.\n\n        .. versionadded:: 2.1.0\n        '''\n        self._keep_prev_pos = True\n        self._first_dispatch_done = True\n\n    def move(self, args):\n        '''Move to another position.\n        '''\n        if self.sync_with_dispatch:\n            if self._keep_prev_pos:\n                self.psx, self.psy, self.psz = self.sx, self.sy, self.sz\n                self._keep_prev_pos = False\n        else:\n            self.psx, self.psy, self.psz = self.sx, self.sy, self.sz\n        self.time_update = time()\n        self.depack(args)\n\n    def scale_for_screen(self, w, h, p=None, rotation=0,\n                         smode='None', kheight=0):\n        '''Scale position for the screen.\n\n        .. versionchanged:: 2.1.0\n            Max value for `x`, `y` and `z` is changed respectively to `w` - 1,\n            `h` - 1 and `p` - 1.\n        '''\n        x_max, y_max = max(0, w - 1), max(0, h - 1)\n        absolute = self.to_absolute_pos\n        self.x, self.y = absolute(self.sx, self.sy, x_max, y_max, rotation)\n        self.ox, self.oy = absolute(self.osx, self.osy, x_max, y_max, rotation)\n        self.px, self.py = absolute(self.psx, self.psy, x_max, y_max, rotation)\n        z_max = 0 if p is None else max(0, p - 1)\n        self.z = self.sz * z_max\n        self.oz = self.osz * z_max\n        self.pz = self.psz * z_max\n        if smode:\n            # Adjust y for keyboard height\n            if smode == 'pan' or smode == 'below_target':\n                self.y -= kheight\n                self.oy -= kheight\n                self.py -= kheight\n            elif smode == 'scale':\n                offset = kheight * (self.y - h) / (h - kheight)\n                self.y += offset\n                self.oy += offset\n                self.py += offset\n        # Update delta values\n        self.dx = self.x - self.px\n        self.dy = self.y - self.py\n        self.dz = self.z - self.pz\n        # Cache position\n        self.pos = self.x, self.y\n\n    def to_absolute_pos(self, nx, ny, x_max, y_max, rotation):\n        '''Transforms normalized (0-1) coordinates `nx` and `ny` to absolute\n        coordinates using `x_max`, `y_max` and `rotation`.\n\n        :raises:\n            `ValueError`: If `rotation` is not one of: 0, 90, 180 or 270\n\n        .. versionadded:: 2.1.0\n        '''\n        if rotation == 0:\n            return nx * x_max, ny * y_max\n        elif rotation == 90:\n            return ny * y_max, (1 - nx) * x_max\n        elif rotation == 180:\n            return (1 - nx) * x_max, (1 - ny) * y_max\n        elif rotation == 270:\n            return (1 - ny) * y_max, nx * x_max\n        raise ValueError('Invalid rotation %s, '\n                         'valid values are 0, 90, 180 or 270' % rotation)\n\n    def push(self, attrs=None):\n        '''Push attribute values in `attrs` onto the stack.\n        '''\n        if attrs is None:\n            attrs = self.push_attrs\n        values = [getattr(self, x) for x in attrs]\n        self.push_attrs_stack.append((attrs, values))\n\n    def pop(self):\n        '''Pop attributes values from the stack.\n        '''\n        attrs, values = self.push_attrs_stack.pop()\n        for i in range(len(attrs)):\n            setattr(self, attrs[i], values[i])\n\n    def apply_transform_2d(self, transform):\n        '''Apply a transformation on x, y, z, px, py, pz,\n        ox, oy, oz, dx, dy, dz.\n        '''\n        self.x, self.y = self.pos = transform(self.x, self.y)\n        self.px, self.py = transform(self.px, self.py)\n        self.ox, self.oy = transform(self.ox, self.oy)\n        self.dx = self.x - self.px\n        self.dy = self.y - self.py\n\n    def copy_to(self, to):\n        '''Copy some attribute to another motion event object.'''\n        for attr in self.__attrs__:\n            to.__setattr__(attr, copy(self.__getattribute__(attr)))\n\n    def distance(self, other_touch):\n        '''Return the distance between the two events.\n        '''\n        return Vector(self.pos).distance(other_touch.pos)\n\n    def update_time_end(self):\n        self.time_end = time()\n\n    # facilities\n    @property\n    def dpos(self):\n        '''Return delta between last position and current position, in the\n        screen coordinate system (self.dx, self.dy).'''\n        return self.dx, self.dy\n\n    @property\n    def opos(self):\n        '''Return the initial position of the motion event in the screen\n        coordinate system (self.ox, self.oy).'''\n        return self.ox, self.oy\n\n    @property\n    def ppos(self):\n        '''Return the previous position of the motion event in the screen\n        coordinate system (self.px, self.py).'''\n        return self.px, self.py\n\n    @property\n    def spos(self):\n        '''Return the position in the 0-1 coordinate system (self.sx, self.sy).\n        '''\n        return self.sx, self.sy\n\n    def __str__(self):\n        basename = str(self.__class__)\n        classname = basename.split('.')[-1].replace('>', '').replace('\\'', '')\n        return '<%s spos=%s pos=%s>' % (classname, self.spos, self.pos)\n\n    def __repr__(self):\n        out = []\n        for x in dir(self):\n            v = getattr(self, x)\n            if x[0] == '_':\n                continue\n            if isroutine(v):\n                continue\n            out.append('%s=\"%s\"' % (x, v))\n        return '<%s %s>' % (\n            self.__class__.__name__,\n            ' '.join(out))\n\n    @property\n    def is_mouse_scrolling(self, *args):\n        '''Returns True if the touch event is a mousewheel scrolling\n\n        .. versionadded:: 1.6.0\n        '''\n        return 'button' in self.profile and 'scroll' in self.button",
  "def __getattr__(self, attr):\n        try:\n            return self.__getitem__(attr)\n        except KeyError:\n            return super(EnhancedDictionary, self).__getattr__(attr)",
  "def __setattr__(self, attr, value):\n        self.__setitem__(attr, value)",
  "def __new__(mcs, name, bases, attrs):\n        __attrs__ = []\n        for base in bases:\n            if hasattr(base, '__attrs__'):\n                __attrs__.extend(base.__attrs__)\n        if '__attrs__' in attrs:\n            __attrs__.extend(attrs['__attrs__'])\n        attrs['__attrs__'] = tuple(__attrs__)\n        return super(MotionEventMetaclass, mcs).__new__(mcs, name,\n                                                        bases, attrs)",
  "def __init__(self, device, id, args, is_touch=False, type_id=None):\n        if self.__class__ == MotionEvent:\n            raise NotImplementedError('class MotionEvent is abstract')\n        MotionEvent.__uniq_id += 1\n\n        #: True if the MotionEvent is a touch.\n        self.is_touch = is_touch\n\n        #: (Experimental) String to identify event type.\n        #:\n        #: .. versionadded:: 2.1.0\n        self.type_id = type_id\n\n        #: (Experimental) Used by a event manager or a widget to assign\n        #: the dispatching mode. Defaults to\n        #: :const:`~kivy.eventmanager.MODE_DEFAULT_DISPATCH`. See\n        #: :mod:`~kivy.eventmanager` for available modes.\n        #:\n        #: .. versionadded:: 2.1.0\n        self.dispatch_mode = MODE_DEFAULT_DISPATCH\n\n        #: Attributes to push by default, when we use :meth:`push` : x, y, z,\n        #: dx, dy, dz, ox, oy, oz, px, py, pz.\n        self.push_attrs_stack = []\n        self.push_attrs = ('x', 'y', 'z', 'dx', 'dy', 'dz', 'ox', 'oy', 'oz',\n                           'px', 'py', 'pz', 'pos', 'type_id', 'dispatch_mode')\n\n        #: Uniq ID of the event. You can safely use this property, it will be\n        #: never the same across all existing events.\n        self.uid = MotionEvent.__uniq_id\n\n        #: Device used for creating this event.\n        self.device = device\n\n        # For grab\n        self.grab_list = []\n        self.grab_exclusive_class = None\n        self.grab_state = False\n\n        #: Used to determine which widget the event is being dispatched to.\n        #: Check the :meth:`grab` function for more information.\n        self.grab_current = None\n\n        #: Currently pressed button.\n        self.button = None\n\n        #: Profiles currently used in the event.\n        self.profile = []\n\n        #: Id of the event, not unique. This is generally the Id set by the\n        #: input provider, like ID in TUIO. If you have multiple TUIO sources,\n        #: then same id can be used. Prefer to use :attr:`uid` attribute\n        #: instead.\n        self.id = id\n\n        #: Shape of the touch event, subclass of\n        #: :class:`~kivy.input.shape.Shape`.\n        #: By default, the property is set to None.\n        self.shape = None\n\n        #: X position, in 0-1 range.\n        self.sx = 0.0\n        #: Y position, in 0-1 range.\n        self.sy = 0.0\n        #: Z position, in 0-1 range.\n        self.sz = 0.0\n        #: Origin X position, in 0-1 range.\n        self.osx = None\n        #: Origin Y position, in 0-1 range.\n        self.osy = None\n        #: Origin Z position, in 0-1 range.\n        self.osz = None\n        #: Previous X position, in 0-1 range.\n        self.psx = None\n        #: Previous Y position, in 0-1 range.\n        self.psy = None\n        #: Previous Z position, in 0-1 range.\n        self.psz = None\n        #: Delta between self.sx and self.psx, in 0-1 range.\n        self.dsx = None\n        #: Delta between self.sy and self.psy, in 0-1 range.\n        self.dsy = None\n        #: Delta between self.sz and self.psz, in 0-1 range.\n        self.dsz = None\n        #: X position, in window range.\n        self.x = 0.0\n        #: Y position, in window range.\n        self.y = 0.0\n        #: Z position, in window range.\n        self.z = 0.0\n        #: Origin X position, in window range.\n        self.ox = None\n        #: Origin Y position, in window range.\n        self.oy = None\n        #: Origin Z position, in window range.\n        self.oz = None\n        #: Previous X position, in window range.\n        self.px = None\n        #: Previous Y position, in window range.\n        self.py = None\n        #: Previous Z position, in window range.\n        self.pz = None\n        #: Delta between self.x and self.px, in window range.\n        self.dx = None\n        #: Delta between self.y and self.py, in window range.\n        self.dy = None\n        #: Delta between self.z and self.pz, in window range.\n        self.dz = None\n        #: Position (X, Y), in window range.\n        self.pos = (0.0, 0.0)\n\n        #: Initial time of the event creation.\n        self.time_start = time()\n\n        #: Time of the last update.\n        self.time_update = self.time_start\n\n        #: Time of the end event (last event usage).\n        self.time_end = -1\n\n        #: Indicate if the touch event is a double tap or not.\n        self.is_double_tap = False\n\n        #: Indicate if the touch event is a triple tap or not.\n        #:\n        #: .. versionadded:: 1.7.0\n        self.is_triple_tap = False\n\n        #: If the touch is a :attr:`is_double_tap`, this is the time\n        #: between the previous tap and the current touch.\n        self.double_tap_time = 0\n\n        #: If the touch is a :attr:`is_triple_tap`, this is the time\n        #: between the first tap and the current touch.\n        #:\n        #: .. versionadded:: 1.7.0\n        self.triple_tap_time = 0\n\n        #: User data dictionary. Use this dictionary to save your own data on\n        #: the event.\n        self.ud = EnhancedDictionary()\n\n        #: If set to `True` (default) keeps first previous position\n        #: (X, Y, Z in 0-1 range) and ignore all other until\n        #: :meth:`MotionEvent.dispatch_done` is called from the `EventLoop`.\n        #:\n        #: This attribute is needed because event provider can make many calls\n        #: to :meth:`MotionEvent.move`, but for all those calls event is\n        #: dispatched to the listeners only once. Assigning `False` will keep\n        #: latest previous position. See :meth:`MotionEvent.move`.\n        #:\n        #: .. versionadded:: 2.1.0\n        self.sync_with_dispatch = True\n\n        #: Keep first previous position if :attr:`sync_with_dispatch` is\n        #: `True`.\n        self._keep_prev_pos = True\n\n        #: Flag that first dispatch of this event is done.\n        self._first_dispatch_done = False\n\n        self.depack(args)",
  "def depack(self, args):\n        '''Depack `args` into attributes of the class'''\n        if self.osx is None \\\n                or self.sync_with_dispatch and not self._first_dispatch_done:\n            # Sync origin/previous/current positions until the first\n            # dispatch (etype == 'begin') is done.\n            self.osx = self.psx = self.sx\n            self.osy = self.psy = self.sy\n            self.osz = self.psz = self.sz\n        # update the delta\n        self.dsx = self.sx - self.psx\n        self.dsy = self.sy - self.psy\n        self.dsz = self.sz - self.psz",
  "def grab(self, class_instance, exclusive=False):\n        '''Grab this motion event.\n\n        If this event is a touch you can grab it if you want to receive\n        subsequent :meth:`~kivy.uix.widget.Widget.on_touch_move` and\n        :meth:`~kivy.uix.widget.Widget.on_touch_up` events, even if the touch\n        is not dispatched by the parent:\n\n        .. code-block:: python\n\n            def on_touch_down(self, touch):\n                touch.grab(self)\n\n            def on_touch_move(self, touch):\n                if touch.grab_current is self:\n                    # I received my grabbed touch\n                else:\n                    # it's a normal touch\n\n            def on_touch_up(self, touch):\n                if touch.grab_current is self:\n                    # I receive my grabbed touch, I must ungrab it!\n                    touch.ungrab(self)\n                else:\n                    # it's a normal touch\n                    pass\n\n        .. versionchanged:: 2.1.0\n            Allowed grab for non-touch events.\n        '''\n        if self.grab_exclusive_class is not None:\n            raise Exception('Event is exclusive and cannot be grabbed')\n        class_instance = weakref.ref(class_instance.__self__)\n        if exclusive:\n            self.grab_exclusive_class = class_instance\n        self.grab_list.append(class_instance)",
  "def ungrab(self, class_instance):\n        '''Ungrab a previously grabbed motion event.\n        '''\n        class_instance = weakref.ref(class_instance.__self__)\n        if self.grab_exclusive_class == class_instance:\n            self.grab_exclusive_class = None\n        if class_instance in self.grab_list:\n            self.grab_list.remove(class_instance)",
  "def dispatch_done(self):\n        '''Notify that dispatch to the listeners is done.\n\n        Called by the :meth:`EventLoopBase.post_dispatch_input`.\n\n        .. versionadded:: 2.1.0\n        '''\n        self._keep_prev_pos = True\n        self._first_dispatch_done = True",
  "def move(self, args):\n        '''Move to another position.\n        '''\n        if self.sync_with_dispatch:\n            if self._keep_prev_pos:\n                self.psx, self.psy, self.psz = self.sx, self.sy, self.sz\n                self._keep_prev_pos = False\n        else:\n            self.psx, self.psy, self.psz = self.sx, self.sy, self.sz\n        self.time_update = time()\n        self.depack(args)",
  "def scale_for_screen(self, w, h, p=None, rotation=0,\n                         smode='None', kheight=0):\n        '''Scale position for the screen.\n\n        .. versionchanged:: 2.1.0\n            Max value for `x`, `y` and `z` is changed respectively to `w` - 1,\n            `h` - 1 and `p` - 1.\n        '''\n        x_max, y_max = max(0, w - 1), max(0, h - 1)\n        absolute = self.to_absolute_pos\n        self.x, self.y = absolute(self.sx, self.sy, x_max, y_max, rotation)\n        self.ox, self.oy = absolute(self.osx, self.osy, x_max, y_max, rotation)\n        self.px, self.py = absolute(self.psx, self.psy, x_max, y_max, rotation)\n        z_max = 0 if p is None else max(0, p - 1)\n        self.z = self.sz * z_max\n        self.oz = self.osz * z_max\n        self.pz = self.psz * z_max\n        if smode:\n            # Adjust y for keyboard height\n            if smode == 'pan' or smode == 'below_target':\n                self.y -= kheight\n                self.oy -= kheight\n                self.py -= kheight\n            elif smode == 'scale':\n                offset = kheight * (self.y - h) / (h - kheight)\n                self.y += offset\n                self.oy += offset\n                self.py += offset\n        # Update delta values\n        self.dx = self.x - self.px\n        self.dy = self.y - self.py\n        self.dz = self.z - self.pz\n        # Cache position\n        self.pos = self.x, self.y",
  "def to_absolute_pos(self, nx, ny, x_max, y_max, rotation):\n        '''Transforms normalized (0-1) coordinates `nx` and `ny` to absolute\n        coordinates using `x_max`, `y_max` and `rotation`.\n\n        :raises:\n            `ValueError`: If `rotation` is not one of: 0, 90, 180 or 270\n\n        .. versionadded:: 2.1.0\n        '''\n        if rotation == 0:\n            return nx * x_max, ny * y_max\n        elif rotation == 90:\n            return ny * y_max, (1 - nx) * x_max\n        elif rotation == 180:\n            return (1 - nx) * x_max, (1 - ny) * y_max\n        elif rotation == 270:\n            return (1 - ny) * y_max, nx * x_max\n        raise ValueError('Invalid rotation %s, '\n                         'valid values are 0, 90, 180 or 270' % rotation)",
  "def push(self, attrs=None):\n        '''Push attribute values in `attrs` onto the stack.\n        '''\n        if attrs is None:\n            attrs = self.push_attrs\n        values = [getattr(self, x) for x in attrs]\n        self.push_attrs_stack.append((attrs, values))",
  "def pop(self):\n        '''Pop attributes values from the stack.\n        '''\n        attrs, values = self.push_attrs_stack.pop()\n        for i in range(len(attrs)):\n            setattr(self, attrs[i], values[i])",
  "def apply_transform_2d(self, transform):\n        '''Apply a transformation on x, y, z, px, py, pz,\n        ox, oy, oz, dx, dy, dz.\n        '''\n        self.x, self.y = self.pos = transform(self.x, self.y)\n        self.px, self.py = transform(self.px, self.py)\n        self.ox, self.oy = transform(self.ox, self.oy)\n        self.dx = self.x - self.px\n        self.dy = self.y - self.py",
  "def copy_to(self, to):\n        '''Copy some attribute to another motion event object.'''\n        for attr in self.__attrs__:\n            to.__setattr__(attr, copy(self.__getattribute__(attr)))",
  "def distance(self, other_touch):\n        '''Return the distance between the two events.\n        '''\n        return Vector(self.pos).distance(other_touch.pos)",
  "def update_time_end(self):\n        self.time_end = time()",
  "def dpos(self):\n        '''Return delta between last position and current position, in the\n        screen coordinate system (self.dx, self.dy).'''\n        return self.dx, self.dy",
  "def opos(self):\n        '''Return the initial position of the motion event in the screen\n        coordinate system (self.ox, self.oy).'''\n        return self.ox, self.oy",
  "def ppos(self):\n        '''Return the previous position of the motion event in the screen\n        coordinate system (self.px, self.py).'''\n        return self.px, self.py",
  "def spos(self):\n        '''Return the position in the 0-1 coordinate system (self.sx, self.sy).\n        '''\n        return self.sx, self.sy",
  "def __str__(self):\n        basename = str(self.__class__)\n        classname = basename.split('.')[-1].replace('>', '').replace('\\'', '')\n        return '<%s spos=%s pos=%s>' % (classname, self.spos, self.pos)",
  "def __repr__(self):\n        out = []\n        for x in dir(self):\n            v = getattr(self, x)\n            if x[0] == '_':\n                continue\n            if isroutine(v):\n                continue\n            out.append('%s=\"%s\"' % (x, v))\n        return '<%s %s>' % (\n            self.__class__.__name__,\n            ' '.join(out))",
  "def is_mouse_scrolling(self, *args):\n        '''Returns True if the touch event is a mousewheel scrolling\n\n        .. versionadded:: 1.6.0\n        '''\n        return 'button' in self.profile and 'scroll' in self.button",
  "class Shape(object):\n    '''Abstract class for all implementations of a shape'''\n    pass",
  "class ShapeRect(Shape):\n    '''Class for the representation of a rectangle.'''\n    __slots__ = ('width', 'height')\n\n    def __init__(self):\n        super(ShapeRect, self).__init__()\n\n        #: Width of the rect\n        self.width = 0\n\n        #: Height of the rect\n        self.height = 0",
  "def __init__(self):\n        super(ShapeRect, self).__init__()\n\n        #: Width of the rect\n        self.width = 0\n\n        #: Height of the rect\n        self.height = 0",
  "class MouseMotionEvent(MotionEvent):\n\n    def __init__(self, *args, **kwargs):\n        self.multitouch_sim = False\n        super().__init__(*args, **kwargs)\n\n    def depack(self, args):\n        self.sx, self.sy = args[:2]\n        profile = self.profile\n        if self.is_touch:\n            # don't overwrite previous profile\n            if not profile:\n                profile.extend(('pos', 'button'))\n            if len(args) >= 3:\n                self.button = args[2]\n            if len(args) == 4:\n                self.multitouch_sim = args[3]\n                profile.append('multitouch_sim')\n        else:\n            if not profile:\n                profile.append('pos')\n        super().depack(args)\n\n    #\n    # Create automatically touch on the surface.\n    #\n\n    def update_graphics(self, win, create=False):\n        global Color, Ellipse\n        de = self.ud.get('_drawelement', None)\n        if de is None and create:\n            if Color is None:\n                from kivy.graphics import Color, Ellipse\n            with win.canvas.after:\n                de = (\n                    Color(.8, .2, .2, .7),\n                    Ellipse(size=(20, 20), segments=15))\n            self.ud._drawelement = de\n        if de is not None:\n            self.push()\n\n            # use same logic as WindowBase.on_motion() so we get correct\n            # coordinates when _density != 1\n            w, h = win._get_effective_size()\n\n            self.scale_for_screen(w, h, rotation=win.rotation)\n\n            de[1].pos = self.x - 10, self.y - 10\n            self.pop()\n\n    def clear_graphics(self, win):\n        de = self.ud.pop('_drawelement', None)\n        if de is not None:\n            win.canvas.after.remove(de[0])\n            win.canvas.after.remove(de[1])",
  "class MouseMotionEventProvider(MotionEventProvider):\n    __handlers__ = {}\n\n    def __init__(self, device, args):\n        super(MouseMotionEventProvider, self).__init__(device, args)\n        self.waiting_event = deque()\n        self.touches = {}\n        self.counter = 0\n        self.current_drag = None\n        self.alt_touch = None\n        self.disable_on_activity = False\n        self.disable_multitouch = False\n        self.multitouch_on_demand = False\n        self.hover_event = None\n        self._disable_hover = False\n        self._running = False\n        # split arguments\n        args = args.split(',')\n        for arg in args:\n            arg = arg.strip()\n            if arg == '':\n                continue\n            elif arg == 'disable_on_activity':\n                self.disable_on_activity = True\n            elif arg == 'disable_multitouch':\n                self.disable_multitouch = True\n            elif arg == 'disable_hover':\n                self.disable_hover = True\n            elif arg == 'multitouch_on_demand':\n                self.multitouch_on_demand = True\n            else:\n                Logger.error('Mouse: unknown parameter <%s>' % arg)\n\n    def _get_disable_hover(self):\n        return self._disable_hover\n\n    def _set_disable_hover(self, value):\n        if self._disable_hover != value:\n            if self._running:\n                if value:\n                    self._stop_hover_events()\n                else:\n                    self._start_hover_events()\n            self._disable_hover = value\n\n    disable_hover = property(_get_disable_hover, _set_disable_hover)\n    '''Disables dispatching of hover events if set to ``True``.\n\n    Hover events are enabled by default (`disable_hover` is ``False``). See\n    module documentation if you want to enable/disable hover events through\n    config file.\n\n    .. versionadded:: 2.1.0\n    '''\n\n    def start(self):\n        '''Start the mouse provider'''\n        if not EventLoop.window:\n            return\n        fbind = EventLoop.window.fbind\n        fbind('on_mouse_down', self.on_mouse_press)\n        fbind('on_mouse_move', self.on_mouse_motion)\n        fbind('on_mouse_up', self.on_mouse_release)\n        fbind('on_rotate', self.update_touch_graphics)\n        fbind('system_size', self.update_touch_graphics)\n        if not self.disable_hover:\n            self._start_hover_events()\n        self._running = True\n\n    def _start_hover_events(self):\n        fbind = EventLoop.window.fbind\n        fbind('mouse_pos', self.begin_or_update_hover_event)\n        fbind('system_size', self.update_hover_event)\n        fbind('on_cursor_enter', self.begin_hover_event)\n        fbind('on_cursor_leave', self.end_hover_event)\n        fbind('on_close', self.end_hover_event)\n        fbind('on_rotate', self.update_hover_event)\n\n    def stop(self):\n        '''Stop the mouse provider'''\n        if not EventLoop.window:\n            return\n        funbind = EventLoop.window.funbind\n        funbind('on_mouse_down', self.on_mouse_press)\n        funbind('on_mouse_move', self.on_mouse_motion)\n        funbind('on_mouse_up', self.on_mouse_release)\n        funbind('on_rotate', self.update_touch_graphics)\n        funbind('system_size', self.update_touch_graphics)\n        if not self.disable_hover:\n            self._stop_hover_events()\n        self._running = False\n\n    def _stop_hover_events(self):\n        funbind = EventLoop.window.funbind\n        funbind('mouse_pos', self.begin_or_update_hover_event)\n        funbind('system_size', self.update_hover_event)\n        funbind('on_cursor_enter', self.begin_hover_event)\n        funbind('on_cursor_leave', self.end_hover_event)\n        funbind('on_close', self.end_hover_event)\n        funbind('on_rotate', self.update_hover_event)\n\n    def test_activity(self):\n        if not self.disable_on_activity:\n            return False\n        # trying to get if we currently have other touch than us\n        # discard touches generated from kinetic\n        for touch in EventLoop.touches:\n            # discard all kinetic touch\n            if touch.__class__.__name__ == 'KineticMotionEvent':\n                continue\n            # not our instance, stop mouse\n            if touch.__class__ != MouseMotionEvent:\n                return True\n        return False\n\n    def find_touch(self, win, x, y):\n        factor = 10. / win.system_size[0]\n        for touch in self.touches.values():\n            if abs(x - touch.sx) < factor and abs(y - touch.sy) < factor:\n                return touch\n        return None\n\n    def create_event_id(self):\n        self.counter += 1\n        return self.device + str(self.counter)\n\n    def create_touch(self, win, nx, ny, is_double_tap, do_graphics, button):\n        event_id = self.create_event_id()\n        args = [nx, ny, button]\n        if do_graphics:\n            args += [not self.multitouch_on_demand]\n        self.current_drag = touch = MouseMotionEvent(\n            self.device, event_id, args,\n            is_touch=True,\n            type_id='touch'\n        )\n        touch.is_double_tap = is_double_tap\n        self.touches[event_id] = touch\n        if do_graphics:\n            # only draw red circle if multitouch is not disabled, and\n            # if the multitouch_on_demand feature is not enable\n            # (because in that case, we wait to see if multitouch_sim\n            # is True or not before doing the multitouch)\n            create_flag = (\n                not self.disable_multitouch\n                and not self.multitouch_on_demand\n            )\n            touch.update_graphics(win, create_flag)\n        self.waiting_event.append(('begin', touch))\n        return touch\n\n    def remove_touch(self, win, touch):\n        if touch.id in self.touches:\n            del self.touches[touch.id]\n            touch.update_time_end()\n            self.waiting_event.append(('end', touch))\n            touch.clear_graphics(win)\n\n    def create_hover(self, win, etype):\n        nx, ny = win.to_normalized_pos(*win.mouse_pos)\n        # Divide by density because it's used by mouse_pos\n        nx /= win._density\n        ny /= win._density\n        args = (nx, ny)\n        hover = self.hover_event\n        if hover:\n            hover.move(args)\n        else:\n            self.hover_event = hover = MouseMotionEvent(\n                self.device,\n                self.create_event_id(),\n                args,\n                type_id='hover'\n            )\n        if etype == 'end':\n            hover.update_time_end()\n            self.hover_event = None\n        self.waiting_event.append((etype, hover))\n\n    def on_mouse_motion(self, win, x, y, modifiers):\n        nx, ny = win.to_normalized_pos(x, y)\n        ny = 1.0 - ny\n        if self.current_drag:\n            touch = self.current_drag\n            touch.move([nx, ny])\n            touch.update_graphics(win)\n            self.waiting_event.append(('update', touch))\n        elif self.alt_touch is not None and 'alt' not in modifiers:\n            # alt just released ?\n            is_double_tap = 'shift' in modifiers\n            self.create_touch(win, nx, ny, is_double_tap, True, [])\n\n    def on_mouse_press(self, win, x, y, button, modifiers):\n        if self.test_activity():\n            return\n        nx, ny = win.to_normalized_pos(x, y)\n        ny = 1.0 - ny\n        found_touch = self.find_touch(win, nx, ny)\n        if found_touch:\n            self.current_drag = found_touch\n        else:\n            is_double_tap = 'shift' in modifiers\n            do_graphics = (\n                not self.disable_multitouch\n                and (button != 'left' or 'ctrl' in modifiers)\n            )\n            touch = self.create_touch(\n                win, nx, ny, is_double_tap, do_graphics, button\n            )\n            if 'alt' in modifiers:\n                self.alt_touch = touch\n                self.current_drag = None\n\n    def on_mouse_release(self, win, x, y, button, modifiers):\n        if button == 'all':\n            # Special case, if button is all,\n            # then remove all the current touches.\n            for touch in list(self.touches.values()):\n                self.remove_touch(win, touch)\n            self.current_drag = None\n        touch = self.current_drag\n        if touch:\n            not_right = button in (\n                'left',\n                'scrollup', 'scrolldown',\n                'scrollleft', 'scrollright'\n            )\n            not_ctrl = 'ctrl' not in modifiers\n            not_multi = (\n                self.disable_multitouch\n                or 'multitouch_sim' not in touch.profile\n                or not touch.multitouch_sim\n            )\n            if not_right and not_ctrl or not_multi:\n                self.remove_touch(win, touch)\n                self.current_drag = None\n            else:\n                touch.update_graphics(win, True)\n        if self.alt_touch:\n            self.remove_touch(win, self.alt_touch)\n            self.alt_touch = None\n\n    def update_touch_graphics(self, win, *args):\n        for touch in self.touches.values():\n            touch.update_graphics(win)\n\n    def begin_or_update_hover_event(self, win, *args):\n        etype = 'update' if self.hover_event else 'begin'\n        self.create_hover(win, etype)\n\n    def begin_hover_event(self, win, *args):\n        if not self.hover_event:\n            self.create_hover(win, 'begin')\n\n    def update_hover_event(self, win, *args):\n        if self.hover_event:\n            self.create_hover(win, 'update')\n\n    def end_hover_event(self, win, *args):\n        if self.hover_event:\n            self.create_hover(win, 'end')\n\n    def update(self, dispatch_fn):\n        '''Update the mouse provider (pop event from the queue)'''\n        try:\n            while True:\n                event = self.waiting_event.popleft()\n                dispatch_fn(*event)\n        except IndexError:\n            pass",
  "def __init__(self, *args, **kwargs):\n        self.multitouch_sim = False\n        super().__init__(*args, **kwargs)",
  "def depack(self, args):\n        self.sx, self.sy = args[:2]\n        profile = self.profile\n        if self.is_touch:\n            # don't overwrite previous profile\n            if not profile:\n                profile.extend(('pos', 'button'))\n            if len(args) >= 3:\n                self.button = args[2]\n            if len(args) == 4:\n                self.multitouch_sim = args[3]\n                profile.append('multitouch_sim')\n        else:\n            if not profile:\n                profile.append('pos')\n        super().depack(args)",
  "def update_graphics(self, win, create=False):\n        global Color, Ellipse\n        de = self.ud.get('_drawelement', None)\n        if de is None and create:\n            if Color is None:\n                from kivy.graphics import Color, Ellipse\n            with win.canvas.after:\n                de = (\n                    Color(.8, .2, .2, .7),\n                    Ellipse(size=(20, 20), segments=15))\n            self.ud._drawelement = de\n        if de is not None:\n            self.push()\n\n            # use same logic as WindowBase.on_motion() so we get correct\n            # coordinates when _density != 1\n            w, h = win._get_effective_size()\n\n            self.scale_for_screen(w, h, rotation=win.rotation)\n\n            de[1].pos = self.x - 10, self.y - 10\n            self.pop()",
  "def clear_graphics(self, win):\n        de = self.ud.pop('_drawelement', None)\n        if de is not None:\n            win.canvas.after.remove(de[0])\n            win.canvas.after.remove(de[1])",
  "def __init__(self, device, args):\n        super(MouseMotionEventProvider, self).__init__(device, args)\n        self.waiting_event = deque()\n        self.touches = {}\n        self.counter = 0\n        self.current_drag = None\n        self.alt_touch = None\n        self.disable_on_activity = False\n        self.disable_multitouch = False\n        self.multitouch_on_demand = False\n        self.hover_event = None\n        self._disable_hover = False\n        self._running = False\n        # split arguments\n        args = args.split(',')\n        for arg in args:\n            arg = arg.strip()\n            if arg == '':\n                continue\n            elif arg == 'disable_on_activity':\n                self.disable_on_activity = True\n            elif arg == 'disable_multitouch':\n                self.disable_multitouch = True\n            elif arg == 'disable_hover':\n                self.disable_hover = True\n            elif arg == 'multitouch_on_demand':\n                self.multitouch_on_demand = True\n            else:\n                Logger.error('Mouse: unknown parameter <%s>' % arg)",
  "def _get_disable_hover(self):\n        return self._disable_hover",
  "def _set_disable_hover(self, value):\n        if self._disable_hover != value:\n            if self._running:\n                if value:\n                    self._stop_hover_events()\n                else:\n                    self._start_hover_events()\n            self._disable_hover = value",
  "def start(self):\n        '''Start the mouse provider'''\n        if not EventLoop.window:\n            return\n        fbind = EventLoop.window.fbind\n        fbind('on_mouse_down', self.on_mouse_press)\n        fbind('on_mouse_move', self.on_mouse_motion)\n        fbind('on_mouse_up', self.on_mouse_release)\n        fbind('on_rotate', self.update_touch_graphics)\n        fbind('system_size', self.update_touch_graphics)\n        if not self.disable_hover:\n            self._start_hover_events()\n        self._running = True",
  "def _start_hover_events(self):\n        fbind = EventLoop.window.fbind\n        fbind('mouse_pos', self.begin_or_update_hover_event)\n        fbind('system_size', self.update_hover_event)\n        fbind('on_cursor_enter', self.begin_hover_event)\n        fbind('on_cursor_leave', self.end_hover_event)\n        fbind('on_close', self.end_hover_event)\n        fbind('on_rotate', self.update_hover_event)",
  "def stop(self):\n        '''Stop the mouse provider'''\n        if not EventLoop.window:\n            return\n        funbind = EventLoop.window.funbind\n        funbind('on_mouse_down', self.on_mouse_press)\n        funbind('on_mouse_move', self.on_mouse_motion)\n        funbind('on_mouse_up', self.on_mouse_release)\n        funbind('on_rotate', self.update_touch_graphics)\n        funbind('system_size', self.update_touch_graphics)\n        if not self.disable_hover:\n            self._stop_hover_events()\n        self._running = False",
  "def _stop_hover_events(self):\n        funbind = EventLoop.window.funbind\n        funbind('mouse_pos', self.begin_or_update_hover_event)\n        funbind('system_size', self.update_hover_event)\n        funbind('on_cursor_enter', self.begin_hover_event)\n        funbind('on_cursor_leave', self.end_hover_event)\n        funbind('on_close', self.end_hover_event)\n        funbind('on_rotate', self.update_hover_event)",
  "def test_activity(self):\n        if not self.disable_on_activity:\n            return False\n        # trying to get if we currently have other touch than us\n        # discard touches generated from kinetic\n        for touch in EventLoop.touches:\n            # discard all kinetic touch\n            if touch.__class__.__name__ == 'KineticMotionEvent':\n                continue\n            # not our instance, stop mouse\n            if touch.__class__ != MouseMotionEvent:\n                return True\n        return False",
  "def find_touch(self, win, x, y):\n        factor = 10. / win.system_size[0]\n        for touch in self.touches.values():\n            if abs(x - touch.sx) < factor and abs(y - touch.sy) < factor:\n                return touch\n        return None",
  "def create_event_id(self):\n        self.counter += 1\n        return self.device + str(self.counter)",
  "def create_touch(self, win, nx, ny, is_double_tap, do_graphics, button):\n        event_id = self.create_event_id()\n        args = [nx, ny, button]\n        if do_graphics:\n            args += [not self.multitouch_on_demand]\n        self.current_drag = touch = MouseMotionEvent(\n            self.device, event_id, args,\n            is_touch=True,\n            type_id='touch'\n        )\n        touch.is_double_tap = is_double_tap\n        self.touches[event_id] = touch\n        if do_graphics:\n            # only draw red circle if multitouch is not disabled, and\n            # if the multitouch_on_demand feature is not enable\n            # (because in that case, we wait to see if multitouch_sim\n            # is True or not before doing the multitouch)\n            create_flag = (\n                not self.disable_multitouch\n                and not self.multitouch_on_demand\n            )\n            touch.update_graphics(win, create_flag)\n        self.waiting_event.append(('begin', touch))\n        return touch",
  "def remove_touch(self, win, touch):\n        if touch.id in self.touches:\n            del self.touches[touch.id]\n            touch.update_time_end()\n            self.waiting_event.append(('end', touch))\n            touch.clear_graphics(win)",
  "def create_hover(self, win, etype):\n        nx, ny = win.to_normalized_pos(*win.mouse_pos)\n        # Divide by density because it's used by mouse_pos\n        nx /= win._density\n        ny /= win._density\n        args = (nx, ny)\n        hover = self.hover_event\n        if hover:\n            hover.move(args)\n        else:\n            self.hover_event = hover = MouseMotionEvent(\n                self.device,\n                self.create_event_id(),\n                args,\n                type_id='hover'\n            )\n        if etype == 'end':\n            hover.update_time_end()\n            self.hover_event = None\n        self.waiting_event.append((etype, hover))",
  "def on_mouse_motion(self, win, x, y, modifiers):\n        nx, ny = win.to_normalized_pos(x, y)\n        ny = 1.0 - ny\n        if self.current_drag:\n            touch = self.current_drag\n            touch.move([nx, ny])\n            touch.update_graphics(win)\n            self.waiting_event.append(('update', touch))\n        elif self.alt_touch is not None and 'alt' not in modifiers:\n            # alt just released ?\n            is_double_tap = 'shift' in modifiers\n            self.create_touch(win, nx, ny, is_double_tap, True, [])",
  "def on_mouse_press(self, win, x, y, button, modifiers):\n        if self.test_activity():\n            return\n        nx, ny = win.to_normalized_pos(x, y)\n        ny = 1.0 - ny\n        found_touch = self.find_touch(win, nx, ny)\n        if found_touch:\n            self.current_drag = found_touch\n        else:\n            is_double_tap = 'shift' in modifiers\n            do_graphics = (\n                not self.disable_multitouch\n                and (button != 'left' or 'ctrl' in modifiers)\n            )\n            touch = self.create_touch(\n                win, nx, ny, is_double_tap, do_graphics, button\n            )\n            if 'alt' in modifiers:\n                self.alt_touch = touch\n                self.current_drag = None",
  "def on_mouse_release(self, win, x, y, button, modifiers):\n        if button == 'all':\n            # Special case, if button is all,\n            # then remove all the current touches.\n            for touch in list(self.touches.values()):\n                self.remove_touch(win, touch)\n            self.current_drag = None\n        touch = self.current_drag\n        if touch:\n            not_right = button in (\n                'left',\n                'scrollup', 'scrolldown',\n                'scrollleft', 'scrollright'\n            )\n            not_ctrl = 'ctrl' not in modifiers\n            not_multi = (\n                self.disable_multitouch\n                or 'multitouch_sim' not in touch.profile\n                or not touch.multitouch_sim\n            )\n            if not_right and not_ctrl or not_multi:\n                self.remove_touch(win, touch)\n                self.current_drag = None\n            else:\n                touch.update_graphics(win, True)\n        if self.alt_touch:\n            self.remove_touch(win, self.alt_touch)\n            self.alt_touch = None",
  "def update_touch_graphics(self, win, *args):\n        for touch in self.touches.values():\n            touch.update_graphics(win)",
  "def begin_or_update_hover_event(self, win, *args):\n        etype = 'update' if self.hover_event else 'begin'\n        self.create_hover(win, etype)",
  "def begin_hover_event(self, win, *args):\n        if not self.hover_event:\n            self.create_hover(win, 'begin')",
  "def update_hover_event(self, win, *args):\n        if self.hover_event:\n            self.create_hover(win, 'update')",
  "def end_hover_event(self, win, *args):\n        if self.hover_event:\n            self.create_hover(win, 'end')",
  "def update(self, dispatch_fn):\n        '''Update the mouse provider (pop event from the queue)'''\n        try:\n            while True:\n                event = self.waiting_event.popleft()\n                dispatch_fn(*event)\n        except IndexError:\n            pass",
  "class TuioMotionEventProvider(MotionEventProvider):\n    '''The TUIO provider listens to a socket and handles some of the incoming\n    OSC messages:\n\n        * /tuio/2Dcur\n        * /tuio/2Dobj\n\n    You can easily extend the provider to handle new TUIO paths like so::\n\n        # Create a class to handle the new TUIO type/path\n        # Replace NEWPATH with the pathname you want to handle\n        class TuioNEWPATHMotionEvent(MotionEvent):\n\n            def depack(self, args):\n                # In this method, implement 'unpacking' for the received\n                # arguments. you basically translate from TUIO args to Kivy\n                # MotionEvent variables. If all you receive are x and y\n                # values, you can do it like this:\n                if len(args) == 2:\n                    self.sx, self.sy = args\n                    self.profile = ('pos', )\n                self.sy = 1 - self.sy\n                super().depack(args)\n\n        # Register it with the TUIO MotionEvent provider.\n        # You obviously need to replace the PATH placeholders appropriately.\n        TuioMotionEventProvider.register('/tuio/PATH', TuioNEWPATHMotionEvent)\n\n    .. note::\n\n        The class name is of no technical importance. Your class will be\n        associated with the path that you pass to the ``register()``\n        function. To keep things simple, you should name your class after the\n        path that it handles, though.\n    '''\n\n    __handlers__ = {}\n\n    def __init__(self, device, args):\n        super().__init__(device, args)\n        args = args.split(',')\n        if len(args) == 0:\n            Logger.error('Tuio: Invalid configuration for TUIO provider')\n            Logger.error('Tuio: Format must be ip:port (eg. 127.0.0.1:3333)')\n            err = 'Tuio: Current configuration is <%s>' % (str(','.join(args)))\n            Logger.error(err)\n            return\n        ipport = args[0].split(':')\n        if len(ipport) != 2:\n            Logger.error('Tuio: Invalid configuration for TUIO provider')\n            Logger.error('Tuio: Format must be ip:port (eg. 127.0.0.1:3333)')\n            err = 'Tuio: Current configuration is <%s>' % (str(','.join(args)))\n            Logger.error(err)\n            return\n        self.ip, self.port = args[0].split(':')\n        self.port = int(self.port)\n        self.handlers = {}\n        self.oscid = None\n        self.tuio_event_q = deque()\n        self.touches = {}\n\n    @staticmethod\n    def register(oscpath, classname):\n        '''Register a new path to handle in TUIO provider'''\n        TuioMotionEventProvider.__handlers__[oscpath] = classname\n\n    @staticmethod\n    def unregister(oscpath, classname):\n        '''Unregister a path to stop handling it in the TUIO provider'''\n        if oscpath in TuioMotionEventProvider.__handlers__:\n            del TuioMotionEventProvider.__handlers__[oscpath]\n\n    @staticmethod\n    def create(oscpath, **kwargs):\n        '''Create a touch event from a TUIO path'''\n        if oscpath not in TuioMotionEventProvider.__handlers__:\n            raise Exception('Unknown %s touch path' % oscpath)\n        return TuioMotionEventProvider.__handlers__[oscpath](**kwargs)\n\n    def start(self):\n        '''Start the TUIO provider'''\n        try:\n            from oscpy.server import OSCThreadServer\n        except ImportError:\n            Logger.info(\n                'Please install the oscpy python module to use the TUIO '\n                'provider.'\n            )\n            raise\n        self.oscid = osc = OSCThreadServer()\n        osc.listen(self.ip, self.port, default=True)\n        for oscpath in TuioMotionEventProvider.__handlers__:\n            self.touches[oscpath] = {}\n            osc.bind(oscpath, partial(self._osc_tuio_cb, oscpath))\n\n    def stop(self):\n        '''Stop the TUIO provider'''\n        self.oscid.stop_all()\n\n    def update(self, dispatch_fn):\n        '''Update the TUIO provider (pop events from the queue)'''\n\n        # read the Queue with event\n        while True:\n            try:\n                value = self.tuio_event_q.pop()\n            except IndexError:\n                # queue is empty, we're done for now\n                return\n            self._update(dispatch_fn, value)\n\n    def _osc_tuio_cb(self, oscpath, address, *args):\n        self.tuio_event_q.appendleft([oscpath, address, args])\n\n    def _update(self, dispatch_fn, value):\n        oscpath, command, args = value\n\n        # verify commands\n        if command not in [b'alive', b'set']:\n            return\n\n        # move or create a new touch\n        if command == b'set':\n            id = args[0]\n            if id not in self.touches[oscpath]:\n                # new touch\n                touch = TuioMotionEventProvider.__handlers__[oscpath](\n                    self.device, id, args[1:])\n                self.touches[oscpath][id] = touch\n                dispatch_fn('begin', touch)\n            else:\n                # update a current touch\n                touch = self.touches[oscpath][id]\n                touch.move(args[1:])\n                dispatch_fn('update', touch)\n\n        # alive event, check for deleted touch\n        if command == b'alive':\n            alives = args\n            to_delete = []\n            for id in self.touches[oscpath]:\n                if id not in alives:\n                    # touch up\n                    touch = self.touches[oscpath][id]\n                    if touch not in to_delete:\n                        to_delete.append(touch)\n\n            for touch in to_delete:\n                dispatch_fn('end', touch)\n                del self.touches[oscpath][touch.id]",
  "class TuioMotionEvent(MotionEvent):\n    '''Abstraction for TUIO touches/fiducials.\n\n    Depending on the tracking software you use (e.g. Movid, CCV, etc.) and its\n    TUIO implementation, the TuioMotionEvent object can support multiple\n    profiles such as:\n\n        * Fiducial ID: profile name 'markerid', attribute ``.fid``\n        * Position: profile name 'pos', attributes ``.x``, ``.y``\n        * Angle: profile name 'angle', attribute ``.a``\n        * Velocity vector: profile name 'mov', attributes ``.X``, ``.Y``\n        * Rotation velocity: profile name 'rot', attribute ``.A``\n        * Motion acceleration: profile name 'motacc', attribute ``.m``\n        * Rotation acceleration: profile name 'rotacc', attribute ``.r``\n    '''\n    __attrs__ = ('a', 'b', 'c', 'X', 'Y', 'Z', 'A', 'B', 'C', 'm', 'r')\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        # Default argument for TUIO touches\n        self.a = 0.0\n        self.b = 0.0\n        self.c = 0.0\n        self.X = 0.0\n        self.Y = 0.0\n        self.Z = 0.0\n        self.A = 0.0\n        self.B = 0.0\n        self.C = 0.0\n        self.m = 0.0\n        self.r = 0.0\n\n    angle = property(lambda self: self.a)\n    mot_accel = property(lambda self: self.m)\n    rot_accel = property(lambda self: self.r)\n    xmot = property(lambda self: self.X)\n    ymot = property(lambda self: self.Y)\n    zmot = property(lambda self: self.Z)",
  "class Tuio2dCurMotionEvent(TuioMotionEvent):\n    '''A 2dCur TUIO touch.'''\n\n    def depack(self, args):\n        if len(args) < 5:\n            self.sx, self.sy = list(map(float, args[0:2]))\n            self.profile = ('pos', )\n        elif len(args) == 5:\n            self.sx, self.sy, self.X, self.Y, self.m = list(map(float,\n                                                                args[0:5]))\n            self.Y = -self.Y\n            self.profile = ('pos', 'mov', 'motacc')\n        else:\n            self.sx, self.sy, self.X, self.Y = list(map(float, args[0:4]))\n            self.m, width, height = list(map(float, args[4:7]))\n            self.Y = -self.Y\n            self.profile = ('pos', 'mov', 'motacc', 'shape')\n            if self.shape is None:\n                self.shape = ShapeRect()\n            self.shape.width = width\n            self.shape.height = height\n        self.sy = 1 - self.sy\n        super().depack(args)",
  "class Tuio2dObjMotionEvent(TuioMotionEvent):\n    '''A 2dObj TUIO object.\n    '''\n\n    def depack(self, args):\n        if len(args) < 5:\n            self.sx, self.sy = args[0:2]\n            self.profile = ('pos', )\n        elif len(args) == 9:\n            self.fid, self.sx, self.sy, self.a, self.X, self.Y = args[:6]\n            self.A, self.m, self.r = args[6:9]\n            self.Y = -self.Y\n            self.profile = ('markerid', 'pos', 'angle', 'mov', 'rot',\n                            'motacc', 'rotacc')\n        else:\n            self.fid, self.sx, self.sy, self.a, self.X, self.Y = args[:6]\n            self.A, self.m, self.r, width, height = args[6:11]\n            self.Y = -self.Y\n            self.profile = ('markerid', 'pos', 'angle', 'mov', 'rot', 'rotacc',\n                            'acc', 'shape')\n            if self.shape is None:\n                self.shape = ShapeRect()\n                self.shape.width = width\n                self.shape.height = height\n        self.sy = 1 - self.sy\n        super().depack(args)",
  "class Tuio2dBlbMotionEvent(TuioMotionEvent):\n    '''A 2dBlb TUIO object.\n    # FIXME 3d shape are not supported\n    /tuio/2Dobj set s i x y a       X Y A m r\n    /tuio/2Dblb set s   x y a w h f X Y A m r\n    '''\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.profile = ('pos', 'angle', 'mov', 'rot', 'rotacc', 'acc', 'shape')\n\n    def depack(self, args):\n        self.sx, self.sy, self.a, self.X, self.Y, sw, sh, sd, \\\n            self.A, self.m, self.r = args\n        self.Y = -self.Y\n        if self.shape is None:\n            self.shape = ShapeRect()\n            self.shape.width = sw\n            self.shape.height = sh\n        self.sy = 1 - self.sy\n        super().depack(args)",
  "def __init__(self, device, args):\n        super().__init__(device, args)\n        args = args.split(',')\n        if len(args) == 0:\n            Logger.error('Tuio: Invalid configuration for TUIO provider')\n            Logger.error('Tuio: Format must be ip:port (eg. 127.0.0.1:3333)')\n            err = 'Tuio: Current configuration is <%s>' % (str(','.join(args)))\n            Logger.error(err)\n            return\n        ipport = args[0].split(':')\n        if len(ipport) != 2:\n            Logger.error('Tuio: Invalid configuration for TUIO provider')\n            Logger.error('Tuio: Format must be ip:port (eg. 127.0.0.1:3333)')\n            err = 'Tuio: Current configuration is <%s>' % (str(','.join(args)))\n            Logger.error(err)\n            return\n        self.ip, self.port = args[0].split(':')\n        self.port = int(self.port)\n        self.handlers = {}\n        self.oscid = None\n        self.tuio_event_q = deque()\n        self.touches = {}",
  "def register(oscpath, classname):\n        '''Register a new path to handle in TUIO provider'''\n        TuioMotionEventProvider.__handlers__[oscpath] = classname",
  "def unregister(oscpath, classname):\n        '''Unregister a path to stop handling it in the TUIO provider'''\n        if oscpath in TuioMotionEventProvider.__handlers__:\n            del TuioMotionEventProvider.__handlers__[oscpath]",
  "def create(oscpath, **kwargs):\n        '''Create a touch event from a TUIO path'''\n        if oscpath not in TuioMotionEventProvider.__handlers__:\n            raise Exception('Unknown %s touch path' % oscpath)\n        return TuioMotionEventProvider.__handlers__[oscpath](**kwargs)",
  "def start(self):\n        '''Start the TUIO provider'''\n        try:\n            from oscpy.server import OSCThreadServer\n        except ImportError:\n            Logger.info(\n                'Please install the oscpy python module to use the TUIO '\n                'provider.'\n            )\n            raise\n        self.oscid = osc = OSCThreadServer()\n        osc.listen(self.ip, self.port, default=True)\n        for oscpath in TuioMotionEventProvider.__handlers__:\n            self.touches[oscpath] = {}\n            osc.bind(oscpath, partial(self._osc_tuio_cb, oscpath))",
  "def stop(self):\n        '''Stop the TUIO provider'''\n        self.oscid.stop_all()",
  "def update(self, dispatch_fn):\n        '''Update the TUIO provider (pop events from the queue)'''\n\n        # read the Queue with event\n        while True:\n            try:\n                value = self.tuio_event_q.pop()\n            except IndexError:\n                # queue is empty, we're done for now\n                return\n            self._update(dispatch_fn, value)",
  "def _osc_tuio_cb(self, oscpath, address, *args):\n        self.tuio_event_q.appendleft([oscpath, address, args])",
  "def _update(self, dispatch_fn, value):\n        oscpath, command, args = value\n\n        # verify commands\n        if command not in [b'alive', b'set']:\n            return\n\n        # move or create a new touch\n        if command == b'set':\n            id = args[0]\n            if id not in self.touches[oscpath]:\n                # new touch\n                touch = TuioMotionEventProvider.__handlers__[oscpath](\n                    self.device, id, args[1:])\n                self.touches[oscpath][id] = touch\n                dispatch_fn('begin', touch)\n            else:\n                # update a current touch\n                touch = self.touches[oscpath][id]\n                touch.move(args[1:])\n                dispatch_fn('update', touch)\n\n        # alive event, check for deleted touch\n        if command == b'alive':\n            alives = args\n            to_delete = []\n            for id in self.touches[oscpath]:\n                if id not in alives:\n                    # touch up\n                    touch = self.touches[oscpath][id]\n                    if touch not in to_delete:\n                        to_delete.append(touch)\n\n            for touch in to_delete:\n                dispatch_fn('end', touch)\n                del self.touches[oscpath][touch.id]",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        # Default argument for TUIO touches\n        self.a = 0.0\n        self.b = 0.0\n        self.c = 0.0\n        self.X = 0.0\n        self.Y = 0.0\n        self.Z = 0.0\n        self.A = 0.0\n        self.B = 0.0\n        self.C = 0.0\n        self.m = 0.0\n        self.r = 0.0",
  "def depack(self, args):\n        if len(args) < 5:\n            self.sx, self.sy = list(map(float, args[0:2]))\n            self.profile = ('pos', )\n        elif len(args) == 5:\n            self.sx, self.sy, self.X, self.Y, self.m = list(map(float,\n                                                                args[0:5]))\n            self.Y = -self.Y\n            self.profile = ('pos', 'mov', 'motacc')\n        else:\n            self.sx, self.sy, self.X, self.Y = list(map(float, args[0:4]))\n            self.m, width, height = list(map(float, args[4:7]))\n            self.Y = -self.Y\n            self.profile = ('pos', 'mov', 'motacc', 'shape')\n            if self.shape is None:\n                self.shape = ShapeRect()\n            self.shape.width = width\n            self.shape.height = height\n        self.sy = 1 - self.sy\n        super().depack(args)",
  "def depack(self, args):\n        if len(args) < 5:\n            self.sx, self.sy = args[0:2]\n            self.profile = ('pos', )\n        elif len(args) == 9:\n            self.fid, self.sx, self.sy, self.a, self.X, self.Y = args[:6]\n            self.A, self.m, self.r = args[6:9]\n            self.Y = -self.Y\n            self.profile = ('markerid', 'pos', 'angle', 'mov', 'rot',\n                            'motacc', 'rotacc')\n        else:\n            self.fid, self.sx, self.sy, self.a, self.X, self.Y = args[:6]\n            self.A, self.m, self.r, width, height = args[6:11]\n            self.Y = -self.Y\n            self.profile = ('markerid', 'pos', 'angle', 'mov', 'rot', 'rotacc',\n                            'acc', 'shape')\n            if self.shape is None:\n                self.shape = ShapeRect()\n                self.shape.width = width\n                self.shape.height = height\n        self.sy = 1 - self.sy\n        super().depack(args)",
  "def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.profile = ('pos', 'angle', 'mov', 'rot', 'rotacc', 'acc', 'shape')",
  "def depack(self, args):\n        self.sx, self.sy, self.a, self.X, self.Y, sw, sh, sd, \\\n            self.A, self.m, self.r = args\n        self.Y = -self.Y\n        if self.shape is None:\n            self.shape = ShapeRect()\n            self.shape.width = sw\n            self.shape.height = sh\n        self.sy = 1 - self.sy\n        super().depack(args)",
  "class Input(object):\n\n        def __init__(self, path):\n            query_xinput()\n            self.path = path\n\n        @property\n        def device(self):\n            base = os.path.basename(self.path)\n            return os.path.join(\"/dev\", \"input\", base)\n\n        @property\n        def name(self):\n            path = os.path.join(self.path, \"device\", \"name\")\n            return read_line(path)\n\n        def get_capabilities(self):\n            path = os.path.join(self.path, \"device\", \"capabilities\", \"abs\")\n            line = \"0\"\n            try:\n                line = read_line(path)\n            except (IOError, OSError):\n                return []\n\n            capabilities = []\n            long_bit = ctypes.sizeof(ctypes.c_long) * 8\n            for i, word in enumerate(line.split(\" \")):\n                word = int(word, 16)\n                subcapabilities = [bool(word & 1 << i)\n                                   for i in range(long_bit)]\n                capabilities[:0] = subcapabilities\n\n            return capabilities\n\n        def has_capability(self, capability):\n            capabilities = self.get_capabilities()\n            return len(capabilities) > capability and capabilities[capability]\n\n        @property\n        def is_mouse(self):\n            return self.device in _cache_xinput",
  "def getout(*args):\n        try:\n            return Popen(args, stdout=PIPE).communicate()[0]\n        except OSError:\n            return ''",
  "def query_xinput():\n        global _cache_xinput\n        if _cache_xinput is None:\n            _cache_xinput = []\n            devids = getout('xinput', '--list', '--id-only')\n            for did in devids.splitlines():\n                devprops = getout('xinput', '--list-props', did)\n                evpath = None\n                for prop in devprops.splitlines():\n                    prop = prop.strip()\n                    if (prop.startswith(b'Device Enabled') and\n                            prop.endswith(b'0')):\n                        evpath = None\n                        break\n                    if prop.startswith(b'Device Node'):\n                        try:\n                            evpath = prop.split('\"')[1]\n                        except Exception:\n                            evpath = None\n                if evpath:\n                    _cache_xinput.append(evpath)",
  "def get_inputs(path):\n        global _cache_input\n        if _cache_input is None:\n            event_glob = os.path.join(path, \"event*\")\n            _cache_input = [Input(x) for x in glob(event_glob)]\n        return _cache_input",
  "def read_line(path):\n        f = open(path)\n        try:\n            return f.readline().strip()\n        finally:\n            f.close()",
  "class ProbeSysfsHardwareProbe(MotionEventProvider):\n\n        def __new__(self, device, args):\n            # hack to not return an instance of this provider.\n            # :)\n            instance = super(ProbeSysfsHardwareProbe, self).__new__(self)\n            instance.__init__(device, args)\n\n        def __init__(self, device, args):\n            super(ProbeSysfsHardwareProbe, self).__init__(device, args)\n            self.provider = 'mtdev'\n            self.match = None\n            self.input_path = '/sys/class/input'\n            self.select_all = True if _is_rpi else False\n            self.use_mouse = False\n            self.use_regex = False\n            self.args = []\n\n            args = args.split(',')\n            for arg in args:\n                if arg == '':\n                    continue\n                arg = arg.split('=', 1)\n                # ensure it's a key = value\n                if len(arg) != 2:\n                    Logger.error('ProbeSysfs: invalid parameters %s, not'\n                                 ' key=value format' % arg)\n                    continue\n\n                key, value = arg\n                if key == 'match':\n                    self.match = value\n                elif key == 'provider':\n                    self.provider = value\n                elif key == 'use_regex':\n                    self.use_regex = bool(int(value))\n                elif key == 'select_all':\n                    self.select_all = bool(int(value))\n                elif key == 'use_mouse':\n                    self.use_mouse = bool(int(value))\n                elif key == 'param':\n                    self.args.append(value)\n                else:\n                    Logger.error('ProbeSysfs: unknown %s option' % key)\n                    continue\n\n            self.probe()\n\n        def should_use_mouse(self):\n            return (self.use_mouse or\n                    not any(p for p in EventLoop.input_providers\n                            if isinstance(p, MouseMotionEventProvider)))\n\n        def probe(self):\n            global EventLoop\n            from kivy.base import EventLoop\n\n            inputs = get_inputs(self.input_path)\n            Logger.debug('ProbeSysfs: using probesysfs!')\n\n            use_mouse = self.should_use_mouse()\n\n            if not self.select_all:\n                inputs = [x for x in inputs if\n                          x.has_capability(ABS_MT_POSITION_X) and\n                          (use_mouse or not x.is_mouse)]\n            for device in inputs:\n                Logger.debug('ProbeSysfs: found device: %s at %s' % (\n                    device.name, device.device))\n\n                # must ignore ?\n                if self.match:\n                    if self.use_regex:\n                        if not match(self.match, device.name, IGNORECASE):\n                            Logger.debug('ProbeSysfs: device not match the'\n                                         ' rule in config, ignoring.')\n                            continue\n                    else:\n                        if self.match not in device.name:\n                            continue\n\n                Logger.info('ProbeSysfs: device match: %s' % device.device)\n\n                d = device.device\n                devicename = self.device % dict(name=d.split(sep)[-1])\n\n                provider = MotionEventFactory.get(self.provider)\n                if provider is None:\n                    Logger.info('ProbeSysfs: Unable to find provider %s' %\n                                self.provider)\n                    Logger.info('ProbeSysfs: fallback on hidinput')\n                    provider = MotionEventFactory.get('hidinput')\n                if provider is None:\n                    Logger.critical('ProbeSysfs: no input provider found'\n                                    ' to handle this device !')\n                    continue\n\n                instance = provider(devicename, '%s,%s' % (\n                    device.device, ','.join(self.args)))\n                if instance:\n                    EventLoop.add_input_provider(instance)",
  "def __init__(self, path):\n            query_xinput()\n            self.path = path",
  "def device(self):\n            base = os.path.basename(self.path)\n            return os.path.join(\"/dev\", \"input\", base)",
  "def name(self):\n            path = os.path.join(self.path, \"device\", \"name\")\n            return read_line(path)",
  "def get_capabilities(self):\n            path = os.path.join(self.path, \"device\", \"capabilities\", \"abs\")\n            line = \"0\"\n            try:\n                line = read_line(path)\n            except (IOError, OSError):\n                return []\n\n            capabilities = []\n            long_bit = ctypes.sizeof(ctypes.c_long) * 8\n            for i, word in enumerate(line.split(\" \")):\n                word = int(word, 16)\n                subcapabilities = [bool(word & 1 << i)\n                                   for i in range(long_bit)]\n                capabilities[:0] = subcapabilities\n\n            return capabilities",
  "def has_capability(self, capability):\n            capabilities = self.get_capabilities()\n            return len(capabilities) > capability and capabilities[capability]",
  "def is_mouse(self):\n            return self.device in _cache_xinput",
  "def __new__(self, device, args):\n            # hack to not return an instance of this provider.\n            # :)\n            instance = super(ProbeSysfsHardwareProbe, self).__new__(self)\n            instance.__init__(device, args)",
  "def __init__(self, device, args):\n            super(ProbeSysfsHardwareProbe, self).__init__(device, args)\n            self.provider = 'mtdev'\n            self.match = None\n            self.input_path = '/sys/class/input'\n            self.select_all = True if _is_rpi else False\n            self.use_mouse = False\n            self.use_regex = False\n            self.args = []\n\n            args = args.split(',')\n            for arg in args:\n                if arg == '':\n                    continue\n                arg = arg.split('=', 1)\n                # ensure it's a key = value\n                if len(arg) != 2:\n                    Logger.error('ProbeSysfs: invalid parameters %s, not'\n                                 ' key=value format' % arg)\n                    continue\n\n                key, value = arg\n                if key == 'match':\n                    self.match = value\n                elif key == 'provider':\n                    self.provider = value\n                elif key == 'use_regex':\n                    self.use_regex = bool(int(value))\n                elif key == 'select_all':\n                    self.select_all = bool(int(value))\n                elif key == 'use_mouse':\n                    self.use_mouse = bool(int(value))\n                elif key == 'param':\n                    self.args.append(value)\n                else:\n                    Logger.error('ProbeSysfs: unknown %s option' % key)\n                    continue\n\n            self.probe()",
  "def should_use_mouse(self):\n            return (self.use_mouse or\n                    not any(p for p in EventLoop.input_providers\n                            if isinstance(p, MouseMotionEventProvider)))",
  "def probe(self):\n            global EventLoop\n            from kivy.base import EventLoop\n\n            inputs = get_inputs(self.input_path)\n            Logger.debug('ProbeSysfs: using probesysfs!')\n\n            use_mouse = self.should_use_mouse()\n\n            if not self.select_all:\n                inputs = [x for x in inputs if\n                          x.has_capability(ABS_MT_POSITION_X) and\n                          (use_mouse or not x.is_mouse)]\n            for device in inputs:\n                Logger.debug('ProbeSysfs: found device: %s at %s' % (\n                    device.name, device.device))\n\n                # must ignore ?\n                if self.match:\n                    if self.use_regex:\n                        if not match(self.match, device.name, IGNORECASE):\n                            Logger.debug('ProbeSysfs: device not match the'\n                                         ' rule in config, ignoring.')\n                            continue\n                    else:\n                        if self.match not in device.name:\n                            continue\n\n                Logger.info('ProbeSysfs: device match: %s' % device.device)\n\n                d = device.device\n                devicename = self.device % dict(name=d.split(sep)[-1])\n\n                provider = MotionEventFactory.get(self.provider)\n                if provider is None:\n                    Logger.info('ProbeSysfs: Unable to find provider %s' %\n                                self.provider)\n                    Logger.info('ProbeSysfs: fallback on hidinput')\n                    provider = MotionEventFactory.get('hidinput')\n                if provider is None:\n                    Logger.critical('ProbeSysfs: no input provider found'\n                                    ' to handle this device !')\n                    continue\n\n                instance = provider(devicename, '%s,%s' % (\n                    device.device, ','.join(self.args)))\n                if instance:\n                    EventLoop.add_input_provider(instance)",
  "class LinuxWacomMotionEvent(MotionEvent):\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n\n    def depack(self, args):\n        self.sx = args['x']\n        self.sy = args['y']\n        self.profile = ['pos']\n        if 'size_w' in args and 'size_h' in args:\n            self.shape = ShapeRect()\n            self.shape.width = args['size_w']\n            self.shape.height = args['size_h']\n            self.profile.append('shape')\n        if 'pressure' in args:\n            self.pressure = args['pressure']\n            self.profile.append('pressure')\n        super().depack(args)\n\n    def __str__(self):\n        return '<LinuxWacomMotionEvent id=%d pos=(%f, %f) device=%s>' \\\n            % (self.id, self.sx, self.sy, self.device)",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)",
  "def depack(self, args):\n        self.sx = args['x']\n        self.sy = args['y']\n        self.profile = ['pos']\n        if 'size_w' in args and 'size_h' in args:\n            self.shape = ShapeRect()\n            self.shape.width = args['size_w']\n            self.shape.height = args['size_h']\n            self.profile.append('shape')\n        if 'pressure' in args:\n            self.pressure = args['pressure']\n            self.profile.append('pressure')\n        super().depack(args)",
  "def __str__(self):\n        return '<LinuxWacomMotionEvent id=%d pos=(%f, %f) device=%s>' \\\n            % (self.id, self.sx, self.sy, self.device)",
  "class LinuxWacomMotionEventProvider(MotionEventProvider):\n\n        options = ('min_position_x', 'max_position_x',\n                   'min_position_y', 'max_position_y',\n                   'min_pressure', 'max_pressure',\n                   'invert_x', 'invert_y')\n\n        def __init__(self, device, args):\n            super(LinuxWacomMotionEventProvider, self).__init__(device, args)\n            self.input_fn = None\n            self.default_ranges = dict()\n            self.mode = 'touch'\n\n            # split arguments\n            args = args.split(',')\n            if not args:\n                Logger.error('LinuxWacom: No filename given in config')\n                Logger.error('LinuxWacom: Use /dev/input/event0 for example')\n                return\n\n            # read filename\n            self.input_fn = args[0]\n            Logger.info('LinuxWacom: Read event from <%s>' % self.input_fn)\n\n            # read parameters\n            for arg in args[1:]:\n                if arg == '':\n                    continue\n                arg = arg.split('=')\n\n                # ensure it's a key = value\n                if len(arg) != 2:\n                    err = 'LinuxWacom: Bad parameter' \\\n                        '%s: Not in key=value format.' % arg\n                    Logger.error(err)\n                    continue\n\n                # ensure the key exist\n                key, value = arg\n                if key == 'mode':\n                    self.mode = value\n                    continue\n\n                if key not in LinuxWacomMotionEventProvider.options:\n                    Logger.error('LinuxWacom: unknown %s option' % key)\n                    continue\n\n                # ensure the value\n                try:\n                    self.default_ranges[key] = int(value)\n                except ValueError:\n                    err = 'LinuxWacom: value %s invalid for %s' % (key, value)\n                    Logger.error(err)\n                    continue\n\n                # all good!\n                msg = 'LinuxWacom: Set custom %s to %d' % (key, int(value))\n                Logger.info(msg)\n            Logger.info('LinuxWacom: mode is <%s>' % self.mode)\n\n        def start(self):\n            if self.input_fn is None:\n                return\n            self.uid = 0\n            self.queue = collections.deque()\n            self.thread = threading.Thread(\n                target=self._thread_run,\n                kwargs=dict(\n                    queue=self.queue,\n                    input_fn=self.input_fn,\n                    device=self.device,\n                    default_ranges=self.default_ranges))\n            self.thread.daemon = True\n            self.thread.start()\n\n        def _thread_run(self, **kwargs):\n            input_fn = kwargs.get('input_fn')\n            queue = kwargs.get('queue')\n            device = kwargs.get('device')\n            drs = kwargs.get('default_ranges').get\n            touches = {}\n            touches_sent = []\n            l_points = {}\n\n            # prepare some vars to get limit of some component\n            range_min_position_x = 0\n            range_max_position_x = 2048\n            range_min_position_y = 0\n            range_max_position_y = 2048\n            range_min_pressure = 0\n            range_max_pressure = 255\n            invert_x = int(bool(drs('invert_x', 0)))\n            invert_y = int(bool(drs('invert_y', 0)))\n            reset_touch = False\n\n            def process(points):\n                actives = list(points.keys())\n                for args in points.values():\n                    tid = args['id']\n                    try:\n                        touch = touches[tid]\n                    except KeyError:\n                        touch = LinuxWacomMotionEvent(device, tid, args)\n                        touches[touch.id] = touch\n                    if touch.sx == args['x'] \\\n                            and touch.sy == args['y'] \\\n                            and tid in touches_sent:\n                        continue\n                    touch.move(args)\n                    if tid not in touches_sent:\n                        queue.append(('begin', touch))\n                        touches_sent.append(tid)\n                    queue.append(('update', touch))\n\n                for tid in list(touches.keys())[:]:\n                    if tid not in actives:\n                        touch = touches[tid]\n                        if tid in touches_sent:\n                            touch.update_time_end()\n                            queue.append(('end', touch))\n                            touches_sent.remove(tid)\n                        del touches[tid]\n\n            def normalize(value, vmin, vmax):\n                return (value - vmin) / float(vmax - vmin)\n\n            # open the input\n            try:\n                fd = open(input_fn, 'rb')\n            except IOError:\n                Logger.exception('Unable to open %s' % input_fn)\n                return\n\n            # get the controller name (EVIOCGNAME)\n            device_name = fcntl.ioctl(fd, EVIOCGNAME + (256 << 16),\n                                      \" \" * 256).split('\\x00')[0]\n            Logger.info('LinuxWacom: using <%s>' % device_name)\n\n            # get abs infos\n            bit = fcntl.ioctl(fd, EVIOCGBIT + (EV_MAX << 16), ' ' * sz_l)\n            bit, = struct.unpack('Q', bit)\n            for x in range(EV_MAX):\n                # preserve this, we may want other things than EV_ABS\n                if x != EV_ABS:\n                    continue\n                # EV_ABS available for this device ?\n                if (bit & (1 << x)) == 0:\n                    continue\n                # ask abs info keys to the devices\n                sbit = fcntl.ioctl(fd, EVIOCGBIT + x + (KEY_MAX << 16),\n                                   ' ' * sz_l)\n                sbit, = struct.unpack('Q', sbit)\n                for y in range(KEY_MAX):\n                    if (sbit & (1 << y)) == 0:\n                        continue\n                    absinfo = fcntl.ioctl(fd, EVIOCGABS + y +\n                                          (struct_input_absinfo_sz << 16),\n                                          ' ' * struct_input_absinfo_sz)\n                    abs_value, abs_min, abs_max, abs_fuzz, \\\n                        abs_flat, abs_res = struct.unpack('iiiiii', absinfo)\n                    if y == ABS_X:\n                        range_min_position_x = drs('min_position_x', abs_min)\n                        range_max_position_x = drs('max_position_x', abs_max)\n                        Logger.info('LinuxWacom: ' +\n                                    '<%s> range position X is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_Y:\n                        range_min_position_y = drs('min_position_y', abs_min)\n                        range_max_position_y = drs('max_position_y', abs_max)\n                        Logger.info('LinuxWacom: ' +\n                                    '<%s> range position Y is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_PRESSURE:\n                        range_min_pressure = drs('min_pressure', abs_min)\n                        range_max_pressure = drs('max_pressure', abs_max)\n                        Logger.info('LinuxWacom: ' +\n                                    '<%s> range pressure is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n\n            # read until the end\n            changed = False\n            touch_id = 0\n            touch_x = 0\n            touch_y = 0\n            touch_pressure = 0\n            while fd:\n\n                data = fd.read(struct_input_event_sz)\n                if len(data) < struct_input_event_sz:\n                    break\n\n                # extract each event\n                for i in range(len(data) / struct_input_event_sz):\n                    ev = data[i * struct_input_event_sz:]\n\n                    # extract timeval + event infos\n                    tv_sec, tv_usec, ev_type, ev_code, ev_value = \\\n                        struct.unpack('LLHHi', ev[:struct_input_event_sz])\n\n                    if ev_type == EV_SYN and ev_code == SYN_REPORT:\n                        if touch_id in l_points:\n                            p = l_points[touch_id]\n                        else:\n                            p = dict()\n                            l_points[touch_id] = p\n                        p['id'] = touch_id\n                        if not reset_touch:\n                            p['x'] = touch_x\n                            p['y'] = touch_y\n                            p['pressure'] = touch_pressure\n                        if self.mode == 'pen' \\\n                                and touch_pressure == 0 \\\n                                and not reset_touch:\n                            del l_points[touch_id]\n                        if changed:\n                            if 'x' not in p:\n                                reset_touch = False\n                                continue\n                            process(l_points)\n                            changed = False\n                        if reset_touch:\n                            l_points.clear()\n                            reset_touch = False\n                            process(l_points)\n                    elif ev_type == EV_MSC and ev_code == MSC_SERIAL:\n                        touch_id = ev_value\n                    elif ev_type == EV_ABS and ev_code == ABS_X:\n                        val = normalize(ev_value,\n                                        range_min_position_x,\n                                        range_max_position_x)\n                        if invert_x:\n                            val = 1. - val\n                        touch_x = val\n                        changed = True\n                    elif ev_type == EV_ABS and ev_code == ABS_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_position_y,\n                                             range_max_position_y)\n                        if invert_y:\n                            val = 1. - val\n                        touch_y = val\n                        changed = True\n                    elif ev_type == EV_ABS and ev_code == ABS_PRESSURE:\n                        touch_pressure = normalize(ev_value,\n                                                   range_min_pressure,\n                                                   range_max_pressure)\n                        changed = True\n                    elif ev_type == EV_ABS and ev_code == ABS_MISC:\n                        if ev_value == 0:\n                            reset_touch = True\n\n        def update(self, dispatch_fn):\n            # dispatch all event from threads\n            try:\n                while True:\n                    event_type, touch = self.queue.popleft()\n                    dispatch_fn(event_type, touch)\n            except:\n                pass",
  "def __init__(self, device, args):\n            super(LinuxWacomMotionEventProvider, self).__init__(device, args)\n            self.input_fn = None\n            self.default_ranges = dict()\n            self.mode = 'touch'\n\n            # split arguments\n            args = args.split(',')\n            if not args:\n                Logger.error('LinuxWacom: No filename given in config')\n                Logger.error('LinuxWacom: Use /dev/input/event0 for example')\n                return\n\n            # read filename\n            self.input_fn = args[0]\n            Logger.info('LinuxWacom: Read event from <%s>' % self.input_fn)\n\n            # read parameters\n            for arg in args[1:]:\n                if arg == '':\n                    continue\n                arg = arg.split('=')\n\n                # ensure it's a key = value\n                if len(arg) != 2:\n                    err = 'LinuxWacom: Bad parameter' \\\n                        '%s: Not in key=value format.' % arg\n                    Logger.error(err)\n                    continue\n\n                # ensure the key exist\n                key, value = arg\n                if key == 'mode':\n                    self.mode = value\n                    continue\n\n                if key not in LinuxWacomMotionEventProvider.options:\n                    Logger.error('LinuxWacom: unknown %s option' % key)\n                    continue\n\n                # ensure the value\n                try:\n                    self.default_ranges[key] = int(value)\n                except ValueError:\n                    err = 'LinuxWacom: value %s invalid for %s' % (key, value)\n                    Logger.error(err)\n                    continue\n\n                # all good!\n                msg = 'LinuxWacom: Set custom %s to %d' % (key, int(value))\n                Logger.info(msg)\n            Logger.info('LinuxWacom: mode is <%s>' % self.mode)",
  "def start(self):\n            if self.input_fn is None:\n                return\n            self.uid = 0\n            self.queue = collections.deque()\n            self.thread = threading.Thread(\n                target=self._thread_run,\n                kwargs=dict(\n                    queue=self.queue,\n                    input_fn=self.input_fn,\n                    device=self.device,\n                    default_ranges=self.default_ranges))\n            self.thread.daemon = True\n            self.thread.start()",
  "def _thread_run(self, **kwargs):\n            input_fn = kwargs.get('input_fn')\n            queue = kwargs.get('queue')\n            device = kwargs.get('device')\n            drs = kwargs.get('default_ranges').get\n            touches = {}\n            touches_sent = []\n            l_points = {}\n\n            # prepare some vars to get limit of some component\n            range_min_position_x = 0\n            range_max_position_x = 2048\n            range_min_position_y = 0\n            range_max_position_y = 2048\n            range_min_pressure = 0\n            range_max_pressure = 255\n            invert_x = int(bool(drs('invert_x', 0)))\n            invert_y = int(bool(drs('invert_y', 0)))\n            reset_touch = False\n\n            def process(points):\n                actives = list(points.keys())\n                for args in points.values():\n                    tid = args['id']\n                    try:\n                        touch = touches[tid]\n                    except KeyError:\n                        touch = LinuxWacomMotionEvent(device, tid, args)\n                        touches[touch.id] = touch\n                    if touch.sx == args['x'] \\\n                            and touch.sy == args['y'] \\\n                            and tid in touches_sent:\n                        continue\n                    touch.move(args)\n                    if tid not in touches_sent:\n                        queue.append(('begin', touch))\n                        touches_sent.append(tid)\n                    queue.append(('update', touch))\n\n                for tid in list(touches.keys())[:]:\n                    if tid not in actives:\n                        touch = touches[tid]\n                        if tid in touches_sent:\n                            touch.update_time_end()\n                            queue.append(('end', touch))\n                            touches_sent.remove(tid)\n                        del touches[tid]\n\n            def normalize(value, vmin, vmax):\n                return (value - vmin) / float(vmax - vmin)\n\n            # open the input\n            try:\n                fd = open(input_fn, 'rb')\n            except IOError:\n                Logger.exception('Unable to open %s' % input_fn)\n                return\n\n            # get the controller name (EVIOCGNAME)\n            device_name = fcntl.ioctl(fd, EVIOCGNAME + (256 << 16),\n                                      \" \" * 256).split('\\x00')[0]\n            Logger.info('LinuxWacom: using <%s>' % device_name)\n\n            # get abs infos\n            bit = fcntl.ioctl(fd, EVIOCGBIT + (EV_MAX << 16), ' ' * sz_l)\n            bit, = struct.unpack('Q', bit)\n            for x in range(EV_MAX):\n                # preserve this, we may want other things than EV_ABS\n                if x != EV_ABS:\n                    continue\n                # EV_ABS available for this device ?\n                if (bit & (1 << x)) == 0:\n                    continue\n                # ask abs info keys to the devices\n                sbit = fcntl.ioctl(fd, EVIOCGBIT + x + (KEY_MAX << 16),\n                                   ' ' * sz_l)\n                sbit, = struct.unpack('Q', sbit)\n                for y in range(KEY_MAX):\n                    if (sbit & (1 << y)) == 0:\n                        continue\n                    absinfo = fcntl.ioctl(fd, EVIOCGABS + y +\n                                          (struct_input_absinfo_sz << 16),\n                                          ' ' * struct_input_absinfo_sz)\n                    abs_value, abs_min, abs_max, abs_fuzz, \\\n                        abs_flat, abs_res = struct.unpack('iiiiii', absinfo)\n                    if y == ABS_X:\n                        range_min_position_x = drs('min_position_x', abs_min)\n                        range_max_position_x = drs('max_position_x', abs_max)\n                        Logger.info('LinuxWacom: ' +\n                                    '<%s> range position X is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_Y:\n                        range_min_position_y = drs('min_position_y', abs_min)\n                        range_max_position_y = drs('max_position_y', abs_max)\n                        Logger.info('LinuxWacom: ' +\n                                    '<%s> range position Y is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_PRESSURE:\n                        range_min_pressure = drs('min_pressure', abs_min)\n                        range_max_pressure = drs('max_pressure', abs_max)\n                        Logger.info('LinuxWacom: ' +\n                                    '<%s> range pressure is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n\n            # read until the end\n            changed = False\n            touch_id = 0\n            touch_x = 0\n            touch_y = 0\n            touch_pressure = 0\n            while fd:\n\n                data = fd.read(struct_input_event_sz)\n                if len(data) < struct_input_event_sz:\n                    break\n\n                # extract each event\n                for i in range(len(data) / struct_input_event_sz):\n                    ev = data[i * struct_input_event_sz:]\n\n                    # extract timeval + event infos\n                    tv_sec, tv_usec, ev_type, ev_code, ev_value = \\\n                        struct.unpack('LLHHi', ev[:struct_input_event_sz])\n\n                    if ev_type == EV_SYN and ev_code == SYN_REPORT:\n                        if touch_id in l_points:\n                            p = l_points[touch_id]\n                        else:\n                            p = dict()\n                            l_points[touch_id] = p\n                        p['id'] = touch_id\n                        if not reset_touch:\n                            p['x'] = touch_x\n                            p['y'] = touch_y\n                            p['pressure'] = touch_pressure\n                        if self.mode == 'pen' \\\n                                and touch_pressure == 0 \\\n                                and not reset_touch:\n                            del l_points[touch_id]\n                        if changed:\n                            if 'x' not in p:\n                                reset_touch = False\n                                continue\n                            process(l_points)\n                            changed = False\n                        if reset_touch:\n                            l_points.clear()\n                            reset_touch = False\n                            process(l_points)\n                    elif ev_type == EV_MSC and ev_code == MSC_SERIAL:\n                        touch_id = ev_value\n                    elif ev_type == EV_ABS and ev_code == ABS_X:\n                        val = normalize(ev_value,\n                                        range_min_position_x,\n                                        range_max_position_x)\n                        if invert_x:\n                            val = 1. - val\n                        touch_x = val\n                        changed = True\n                    elif ev_type == EV_ABS and ev_code == ABS_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_position_y,\n                                             range_max_position_y)\n                        if invert_y:\n                            val = 1. - val\n                        touch_y = val\n                        changed = True\n                    elif ev_type == EV_ABS and ev_code == ABS_PRESSURE:\n                        touch_pressure = normalize(ev_value,\n                                                   range_min_pressure,\n                                                   range_max_pressure)\n                        changed = True\n                    elif ev_type == EV_ABS and ev_code == ABS_MISC:\n                        if ev_value == 0:\n                            reset_touch = True",
  "def update(self, dispatch_fn):\n            # dispatch all event from threads\n            try:\n                while True:\n                    event_type, touch = self.queue.popleft()\n                    dispatch_fn(event_type, touch)\n            except:\n                pass",
  "def process(points):\n                actives = list(points.keys())\n                for args in points.values():\n                    tid = args['id']\n                    try:\n                        touch = touches[tid]\n                    except KeyError:\n                        touch = LinuxWacomMotionEvent(device, tid, args)\n                        touches[touch.id] = touch\n                    if touch.sx == args['x'] \\\n                            and touch.sy == args['y'] \\\n                            and tid in touches_sent:\n                        continue\n                    touch.move(args)\n                    if tid not in touches_sent:\n                        queue.append(('begin', touch))\n                        touches_sent.append(tid)\n                    queue.append(('update', touch))\n\n                for tid in list(touches.keys())[:]:\n                    if tid not in actives:\n                        touch = touches[tid]\n                        if tid in touches_sent:\n                            touch.update_time_end()\n                            queue.append(('end', touch))\n                            touches_sent.remove(tid)\n                        del touches[tid]",
  "def normalize(value, vmin, vmax):\n                return (value - vmin) / float(vmax - vmin)",
  "class AndroidMotionEvent(MotionEvent):\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ['pos', 'pressure', 'shape']\n\n    def depack(self, args):\n        self.sx, self.sy, self.pressure, radius = args\n        self.shape = ShapeRect()\n        self.shape.width = radius\n        self.shape.height = radius\n        super().depack(args)",
  "class AndroidMotionEventProvider(MotionEventProvider):\n\n    def __init__(self, device, args):\n        super(AndroidMotionEventProvider, self).__init__(device, args)\n        self.joysticks = []\n        self.touches = {}\n        self.uid = 0\n        self.window = None\n\n    def create_joystick(self, index):\n        Logger.info('Android: create joystick <%d>' % index)\n        js = pygame.joystick.Joystick(index)\n        js.init()\n        if js.get_numbuttons() == 0:\n            Logger.info('Android: discard joystick <%d> cause no button' %\n                        index)\n            return\n        self.joysticks.append(js)\n\n    def start(self):\n        pygame.joystick.init()\n        Logger.info('Android: found %d joystick' % pygame.joystick.get_count())\n        for i in range(pygame.joystick.get_count()):\n            self.create_joystick(i)\n\n    def stop(self):\n        self.joysticks = []\n\n    def update(self, dispatch_fn):\n        if not self.window:\n            from kivy.core.window import Window\n            self.window = Window\n        w, h = self.window.system_size\n        touches = self.touches\n        for joy in self.joysticks:\n            jid = joy.get_id()\n            pressed = joy.get_button(0)\n            if pressed or jid in touches:\n                x = joy.get_axis(0) * 32768. / w\n                y = 1. - (joy.get_axis(1) * 32768. / h)\n\n                # python for android do * 1000.\n                pressure = joy.get_axis(2) / 1000.\n                radius = joy.get_axis(3) / 1000.\n\n                # new touch ?\n                if pressed and jid not in touches:\n                    self.uid += 1\n                    touch = AndroidMotionEvent(self.device, self.uid,\n                                            [x, y, pressure, radius])\n                    touches[jid] = touch\n                    dispatch_fn('begin', touch)\n                # update touch\n                elif pressed:\n                    touch = touches[jid]\n                    # avoid same touch position\n                    if (touch.sx == x and touch.sy == y and\n                            touch.pressure == pressure):\n                        continue\n                    touch.move([x, y, pressure, radius])\n                    dispatch_fn('update', touch)\n                # disappear\n                elif not pressed and jid in touches:\n                    touch = touches[jid]\n                    touch.move([x, y, pressure, radius])\n                    touch.update_time_end()\n                    dispatch_fn('end', touch)\n                    touches.pop(jid)",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ['pos', 'pressure', 'shape']",
  "def depack(self, args):\n        self.sx, self.sy, self.pressure, radius = args\n        self.shape = ShapeRect()\n        self.shape.width = radius\n        self.shape.height = radius\n        super().depack(args)",
  "def __init__(self, device, args):\n        super(AndroidMotionEventProvider, self).__init__(device, args)\n        self.joysticks = []\n        self.touches = {}\n        self.uid = 0\n        self.window = None",
  "def create_joystick(self, index):\n        Logger.info('Android: create joystick <%d>' % index)\n        js = pygame.joystick.Joystick(index)\n        js.init()\n        if js.get_numbuttons() == 0:\n            Logger.info('Android: discard joystick <%d> cause no button' %\n                        index)\n            return\n        self.joysticks.append(js)",
  "def start(self):\n        pygame.joystick.init()\n        Logger.info('Android: found %d joystick' % pygame.joystick.get_count())\n        for i in range(pygame.joystick.get_count()):\n            self.create_joystick(i)",
  "def stop(self):\n        self.joysticks = []",
  "def update(self, dispatch_fn):\n        if not self.window:\n            from kivy.core.window import Window\n            self.window = Window\n        w, h = self.window.system_size\n        touches = self.touches\n        for joy in self.joysticks:\n            jid = joy.get_id()\n            pressed = joy.get_button(0)\n            if pressed or jid in touches:\n                x = joy.get_axis(0) * 32768. / w\n                y = 1. - (joy.get_axis(1) * 32768. / h)\n\n                # python for android do * 1000.\n                pressure = joy.get_axis(2) / 1000.\n                radius = joy.get_axis(3) / 1000.\n\n                # new touch ?\n                if pressed and jid not in touches:\n                    self.uid += 1\n                    touch = AndroidMotionEvent(self.device, self.uid,\n                                            [x, y, pressure, radius])\n                    touches[jid] = touch\n                    dispatch_fn('begin', touch)\n                # update touch\n                elif pressed:\n                    touch = touches[jid]\n                    # avoid same touch position\n                    if (touch.sx == x and touch.sy == y and\n                            touch.pressure == pressure):\n                        continue\n                    touch.move([x, y, pressure, radius])\n                    dispatch_fn('update', touch)\n                # disappear\n                elif not pressed and jid in touches:\n                    touch = touches[jid]\n                    touch.move([x, y, pressure, radius])\n                    touch.update_time_end()\n                    dispatch_fn('end', touch)\n                    touches.pop(jid)",
  "class MacMotionEvent(MotionEvent):\n    '''MotionEvent representing a contact point on the touchpad. Supports pos\n    and shape profiles.\n    '''\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ('pos', 'shape')\n\n    def depack(self, args):\n        self.shape = ShapeRect()\n        self.sx, self.sy = args[0], args[1]\n        self.shape.width = args[2]\n        self.shape.height = args[2]\n        super().depack(args)\n\n    def __str__(self):\n        return '<MacMotionEvent id=%d pos=(%f, %f) device=%s>' \\\n            % (self.id, self.sx, self.sy, self.device)",
  "class MacMotionEventProvider(MotionEventProvider):\n\n    def __init__(self, *largs, **kwargs):\n        global _instance\n        if _instance is not None:\n            raise Exception('Only one MacMotionEvent provider is allowed.')\n        _instance = self\n        super(MacMotionEventProvider, self).__init__(*largs, **kwargs)\n\n    def start(self):\n        # global uid\n        self.uid = 0\n        # touches will be per devices\n        self.touches = {}\n        # lock needed to access on uid\n        self.lock = threading.Lock()\n        # event queue to dispatch in main thread\n        self.queue = collections.deque()\n\n        # ok, listing devices, and attach !\n        devices = MultitouchSupport.MTDeviceCreateList()\n        num_devices = CFArrayGetCount(devices)\n        for i in range(num_devices):\n            device = CFArrayGetValueAtIndex(devices, i)\n            # create touch dict for this device\n            data_id = str(device)\n            self.touches[data_id] = {}\n            # start !\n            MTRegisterContactFrameCallback(device, self._mts_callback)\n            MTDeviceStart(device, 0)\n\n    def update(self, dispatch_fn):\n        # dispatch all event from threads\n        try:\n            while True:\n                event_type, touch = self.queue.popleft()\n                dispatch_fn(event_type, touch)\n        except:\n            pass\n\n    def stop(self):\n        # i don't known how to stop it...\n        pass\n\n    @MTContactCallbackFunction\n    def _mts_callback(device, data_ptr, n_fingers, timestamp, frame):\n        global _instance\n        devid = str(device)\n\n        # XXX create live touch, we get one case that\n        # the device announced by macosx don't match the device\n        # in _mts_callback....\n        if devid not in _instance.touches:\n            _instance.touches[devid] = {}\n\n        touches = _instance.touches[devid]\n        actives = []\n\n        for i in range(n_fingers):\n            # get pointer on data\n            data = data_ptr[i]\n\n            # add this touch as an active touch\n            actives.append(data.identifier)\n\n            # extract identifier\n            data_id = data.identifier\n\n            # prepare argument position\n            norm_pos = data.normalized.position\n            args = (norm_pos.x, norm_pos.y, data.size)\n\n            if data_id not in touches:\n                # increment uid\n                _instance.lock.acquire()\n                _instance.uid += 1\n                # create a touch\n                touch = MacMotionEvent(_instance.device, _instance.uid, args)\n                _instance.lock.release()\n                # create event\n                _instance.queue.append(('begin', touch))\n                # store touch\n                touches[data_id] = touch\n            else:\n                touch = touches[data_id]\n                # check if he really moved\n                if data.normalized.position.x == touch.sx and \\\n                   data.normalized.position.y == touch.sy:\n                    continue\n                touch.move(args)\n                _instance.queue.append(('update', touch))\n\n        # delete old touchs\n        for tid in list(touches.keys())[:]:\n            if tid not in actives:\n                touch = touches[tid]\n                touch.update_time_end()\n                _instance.queue.append(('end', touch))\n                del touches[tid]\n\n        return 0",
  "class MTPoint(ctypes.Structure):\n        _fields_ = [('x', ctypes.c_float),\n                    ('y', ctypes.c_float)]",
  "class MTVector(ctypes.Structure):\n        _fields_ = [('position', MTPoint),\n                    ('velocity', MTPoint)]",
  "class MTData(ctypes.Structure):\n        _fields_ = [\n            ('frame', ctypes.c_int),\n            ('timestamp', ctypes.c_double),\n            ('identifier', ctypes.c_int),\n            # Current state (of unknown meaning).\n            ('state', ctypes.c_int),\n            ('unknown1', ctypes.c_int),\n            ('unknown2', ctypes.c_int),\n            # Normalized position and vector of the touch (0 to 1)\n            ('normalized', MTVector),\n            # The area of the touch.\n            ('size', ctypes.c_float),\n            ('unknown3', ctypes.c_int),\n            # The following three define the ellipsoid of a finger.\n            ('angle', ctypes.c_float),\n            ('major_axis', ctypes.c_float),\n            ('minor_axis', ctypes.c_float),\n            ('unknown4', MTVector),\n            ('unknown5_1', ctypes.c_int),\n            ('unknown5_2', ctypes.c_int),\n            ('unknown6', ctypes.c_float), ]",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ('pos', 'shape')",
  "def depack(self, args):\n        self.shape = ShapeRect()\n        self.sx, self.sy = args[0], args[1]\n        self.shape.width = args[2]\n        self.shape.height = args[2]\n        super().depack(args)",
  "def __str__(self):\n        return '<MacMotionEvent id=%d pos=(%f, %f) device=%s>' \\\n            % (self.id, self.sx, self.sy, self.device)",
  "def __init__(self, *largs, **kwargs):\n        global _instance\n        if _instance is not None:\n            raise Exception('Only one MacMotionEvent provider is allowed.')\n        _instance = self\n        super(MacMotionEventProvider, self).__init__(*largs, **kwargs)",
  "def start(self):\n        # global uid\n        self.uid = 0\n        # touches will be per devices\n        self.touches = {}\n        # lock needed to access on uid\n        self.lock = threading.Lock()\n        # event queue to dispatch in main thread\n        self.queue = collections.deque()\n\n        # ok, listing devices, and attach !\n        devices = MultitouchSupport.MTDeviceCreateList()\n        num_devices = CFArrayGetCount(devices)\n        for i in range(num_devices):\n            device = CFArrayGetValueAtIndex(devices, i)\n            # create touch dict for this device\n            data_id = str(device)\n            self.touches[data_id] = {}\n            # start !\n            MTRegisterContactFrameCallback(device, self._mts_callback)\n            MTDeviceStart(device, 0)",
  "def update(self, dispatch_fn):\n        # dispatch all event from threads\n        try:\n            while True:\n                event_type, touch = self.queue.popleft()\n                dispatch_fn(event_type, touch)\n        except:\n            pass",
  "def stop(self):\n        # i don't known how to stop it...\n        pass",
  "def _mts_callback(device, data_ptr, n_fingers, timestamp, frame):\n        global _instance\n        devid = str(device)\n\n        # XXX create live touch, we get one case that\n        # the device announced by macosx don't match the device\n        # in _mts_callback....\n        if devid not in _instance.touches:\n            _instance.touches[devid] = {}\n\n        touches = _instance.touches[devid]\n        actives = []\n\n        for i in range(n_fingers):\n            # get pointer on data\n            data = data_ptr[i]\n\n            # add this touch as an active touch\n            actives.append(data.identifier)\n\n            # extract identifier\n            data_id = data.identifier\n\n            # prepare argument position\n            norm_pos = data.normalized.position\n            args = (norm_pos.x, norm_pos.y, data.size)\n\n            if data_id not in touches:\n                # increment uid\n                _instance.lock.acquire()\n                _instance.uid += 1\n                # create a touch\n                touch = MacMotionEvent(_instance.device, _instance.uid, args)\n                _instance.lock.release()\n                # create event\n                _instance.queue.append(('begin', touch))\n                # store touch\n                touches[data_id] = touch\n            else:\n                touch = touches[data_id]\n                # check if he really moved\n                if data.normalized.position.x == touch.sx and \\\n                   data.normalized.position.y == touch.sy:\n                    continue\n                touch.move(args)\n                _instance.queue.append(('update', touch))\n\n        # delete old touchs\n        for tid in list(touches.keys())[:]:\n            if tid not in actives:\n                touch = touches[tid]\n                touch.update_time_end()\n                _instance.queue.append(('end', touch))\n                del touches[tid]\n\n        return 0",
  "class WM_MotionEvent(MotionEvent):\n    '''MotionEvent representing the WM_MotionEvent event.\n       Supports pos, shape and size profiles.\n    '''\n    __attrs__ = ('size', )\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ('pos', 'shape', 'size')\n\n    def depack(self, args):\n        self.shape = ShapeRect()\n        self.sx, self.sy = args[0], args[1]\n        self.shape.width = args[2][0]\n        self.shape.height = args[2][1]\n        self.size = self.shape.width * self.shape.height\n        super().depack(args)\n\n    def __str__(self):\n        args = (self.id, self.uid, str(self.spos), self.device)\n        return '<WMMotionEvent id:%d uid:%d pos:%s device:%s>' % args",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ('pos', 'shape', 'size')",
  "def depack(self, args):\n        self.shape = ShapeRect()\n        self.sx, self.sy = args[0], args[1]\n        self.shape.width = args[2][0]\n        self.shape.height = args[2][1]\n        self.size = self.shape.width * self.shape.height\n        super().depack(args)",
  "def __str__(self):\n        args = (self.id, self.uid, str(self.spos), self.device)\n        return '<WMMotionEvent id:%d uid:%d pos:%s device:%s>' % args",
  "class WM_MotionEventProvider(MotionEventProvider):\n\n        def start(self):\n            global Window\n            if not Window:\n                from kivy.core.window import Window\n\n            self.touch_events = deque()\n            self.touches = {}\n            self.uid = 0\n\n            # get window handle, and register to receive WM_TOUCH messages\n            self.hwnd = windll.user32.GetActiveWindow()\n            windll.user32.RegisterTouchWindow(self.hwnd, 1)\n\n            # inject our own wndProc to handle messages\n            # before window manager does\n            self.new_windProc = WNDPROC(self._touch_wndProc)\n            self.old_windProc = SetWindowLong_WndProc_wrapper(\n                self.hwnd, self.new_windProc)\n\n        def update(self, dispatch_fn):\n            c_rect = RECT()\n            windll.user32.GetClientRect(self.hwnd, byref(c_rect))\n            pt = POINT(x=0, y=0)\n            windll.user32.ClientToScreen(self.hwnd, byref(pt))\n            x_offset, y_offset = pt.x, pt.y\n            usable_w, usable_h = float(c_rect.w), float(c_rect.h)\n\n            while True:\n                try:\n                    t = self.touch_events.pop()\n                except:\n                    break\n\n                # adjust x,y to window coordinates (0.0 to 1.0)\n                x = (t.screen_x() - x_offset) / usable_w\n                y = 1.0 - (t.screen_y() - y_offset) / usable_h\n\n                # actually dispatch input\n                if t.event_type == 'begin':\n                    self.uid += 1\n                    self.touches[t.id] = WM_MotionEvent(\n                        self.device, self.uid, [x, y, t.size()])\n                    dispatch_fn('begin', self.touches[t.id])\n\n                if t.event_type == 'update' and t.id in self.touches:\n                    self.touches[t.id].move([x, y, t.size()])\n                    dispatch_fn('update', self.touches[t.id])\n\n                if t.event_type == 'end' and t.id in self.touches:\n                    touch = self.touches[t.id]\n                    touch.move([x, y, t.size()])\n                    touch.update_time_end()\n                    dispatch_fn('end', touch)\n                    del self.touches[t.id]\n\n        def stop(self):\n            windll.user32.UnregisterTouchWindow(self.hwnd)\n            self.new_windProc = SetWindowLong_WndProc_wrapper(\n                self.hwnd, self.old_windProc)\n\n        # we inject this wndProc into our main window, to process\n        # WM_TOUCH and mouse messages before the window manager does\n        def _touch_wndProc(self, hwnd, msg, wParam, lParam):\n            done = False\n            if msg == WM_TABLET_QUERYSYSTEMGESTURE:\n                return QUERYSYSTEMGESTURE_WNDPROC\n\n            if msg == WM_TOUCH:\n                done = self._touch_handler(msg, wParam, lParam)\n\n            if msg >= WM_MOUSEMOVE and msg <= WM_MOUSELAST:\n                done = self._mouse_handler(msg, wParam, lParam)\n\n            if not done:\n                return windll.user32.CallWindowProcW(self.old_windProc,\n                                                     hwnd, msg, wParam,\n                                                     lParam)\n            return 1\n\n        # this on pushes WM_TOUCH messages onto our event stack\n        def _touch_handler(self, msg, wParam, lParam):\n            touches = (TOUCHINPUT * wParam)()\n            windll.user32.GetTouchInputInfo(HANDLE(lParam),\n                                            wParam,\n                                            touches,\n                                            sizeof(TOUCHINPUT))\n            for i in range(wParam):\n                self.touch_events.appendleft(touches[i])\n            windll.user32.CloseTouchInputHandle(HANDLE(lParam))\n            return True\n\n        # filter fake mouse events, because touch and stylus\n        # also make mouse events\n        def _mouse_handler(self, msg, wparam, lParam):\n            info = windll.user32.GetMessageExtraInfo()\n            # its a touch or a pen\n            if (info & PEN_OR_TOUCH_MASK) == PEN_OR_TOUCH_SIGNATURE:\n                if info & PEN_EVENT_TOUCH_MASK:\n                    return True",
  "def start(self):\n            global Window\n            if not Window:\n                from kivy.core.window import Window\n\n            self.touch_events = deque()\n            self.touches = {}\n            self.uid = 0\n\n            # get window handle, and register to receive WM_TOUCH messages\n            self.hwnd = windll.user32.GetActiveWindow()\n            windll.user32.RegisterTouchWindow(self.hwnd, 1)\n\n            # inject our own wndProc to handle messages\n            # before window manager does\n            self.new_windProc = WNDPROC(self._touch_wndProc)\n            self.old_windProc = SetWindowLong_WndProc_wrapper(\n                self.hwnd, self.new_windProc)",
  "def update(self, dispatch_fn):\n            c_rect = RECT()\n            windll.user32.GetClientRect(self.hwnd, byref(c_rect))\n            pt = POINT(x=0, y=0)\n            windll.user32.ClientToScreen(self.hwnd, byref(pt))\n            x_offset, y_offset = pt.x, pt.y\n            usable_w, usable_h = float(c_rect.w), float(c_rect.h)\n\n            while True:\n                try:\n                    t = self.touch_events.pop()\n                except:\n                    break\n\n                # adjust x,y to window coordinates (0.0 to 1.0)\n                x = (t.screen_x() - x_offset) / usable_w\n                y = 1.0 - (t.screen_y() - y_offset) / usable_h\n\n                # actually dispatch input\n                if t.event_type == 'begin':\n                    self.uid += 1\n                    self.touches[t.id] = WM_MotionEvent(\n                        self.device, self.uid, [x, y, t.size()])\n                    dispatch_fn('begin', self.touches[t.id])\n\n                if t.event_type == 'update' and t.id in self.touches:\n                    self.touches[t.id].move([x, y, t.size()])\n                    dispatch_fn('update', self.touches[t.id])\n\n                if t.event_type == 'end' and t.id in self.touches:\n                    touch = self.touches[t.id]\n                    touch.move([x, y, t.size()])\n                    touch.update_time_end()\n                    dispatch_fn('end', touch)\n                    del self.touches[t.id]",
  "def stop(self):\n            windll.user32.UnregisterTouchWindow(self.hwnd)\n            self.new_windProc = SetWindowLong_WndProc_wrapper(\n                self.hwnd, self.old_windProc)",
  "def _touch_wndProc(self, hwnd, msg, wParam, lParam):\n            done = False\n            if msg == WM_TABLET_QUERYSYSTEMGESTURE:\n                return QUERYSYSTEMGESTURE_WNDPROC\n\n            if msg == WM_TOUCH:\n                done = self._touch_handler(msg, wParam, lParam)\n\n            if msg >= WM_MOUSEMOVE and msg <= WM_MOUSELAST:\n                done = self._mouse_handler(msg, wParam, lParam)\n\n            if not done:\n                return windll.user32.CallWindowProcW(self.old_windProc,\n                                                     hwnd, msg, wParam,\n                                                     lParam)\n            return 1",
  "def _touch_handler(self, msg, wParam, lParam):\n            touches = (TOUCHINPUT * wParam)()\n            windll.user32.GetTouchInputInfo(HANDLE(lParam),\n                                            wParam,\n                                            touches,\n                                            sizeof(TOUCHINPUT))\n            for i in range(wParam):\n                self.touch_events.appendleft(touches[i])\n            windll.user32.CloseTouchInputHandle(HANDLE(lParam))\n            return True",
  "def _mouse_handler(self, msg, wparam, lParam):\n            info = windll.user32.GetMessageExtraInfo()\n            # its a touch or a pen\n            if (info & PEN_OR_TOUCH_MASK) == PEN_OR_TOUCH_SIGNATURE:\n                if info & PEN_EVENT_TOUCH_MASK:\n                    return True",
  "class WM_Pen(MotionEvent):\n    '''MotionEvent representing the WM_Pen event. Supports the pos profile.'''\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ['pos']\n\n    def depack(self, args):\n        self.sx, self.sy = args[0], args[1]\n        super().depack(args)\n\n    def __str__(self):\n        i, u, s, d = (self.id, self.uid, str(self.spos), self.device)\n        return '<WMPen id:%d uid:%d pos:%s device:%s>' % (i, u, s, d)",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ['pos']",
  "def depack(self, args):\n        self.sx, self.sy = args[0], args[1]\n        super().depack(args)",
  "def __str__(self):\n        i, u, s, d = (self.id, self.uid, str(self.spos), self.device)\n        return '<WMPen id:%d uid:%d pos:%s device:%s>' % (i, u, s, d)",
  "class WM_PenProvider(MotionEventProvider):\n\n        def _is_pen_message(self, msg):\n            info = windll.user32.GetMessageExtraInfo()\n            # It's a touch or a pen\n            if (info & PEN_OR_TOUCH_MASK) == PEN_OR_TOUCH_SIGNATURE:\n                if not info & PEN_EVENT_TOUCH_MASK:\n                    return True\n\n        def _pen_handler(self, msg, wParam, lParam):\n            if msg not in (WM_LBUTTONDOWN, WM_MOUSEMOVE, WM_LBUTTONUP):\n                return\n\n            windll.user32.GetClientRect(self.hwnd, byref(win_rect))\n            x = c_int16(lParam & 0xffff).value / float(win_rect.w)\n            y = c_int16(lParam >> 16).value / float(win_rect.h)\n            y = abs(1.0 - y)\n\n            if msg == WM_LBUTTONDOWN:\n                self.pen_events.appendleft(('begin', x, y))\n                self.pen_status = True\n\n            if msg == WM_MOUSEMOVE and self.pen_status:\n                self.pen_events.appendleft(('update', x, y))\n\n            if msg == WM_LBUTTONUP:\n                self.pen_events.appendleft(('end', x, y))\n                self.pen_status = False\n\n        def _pen_wndProc(self, hwnd, msg, wParam, lParam):\n            if msg == WM_TABLET_QUERYSYSTEMGESTURE:\n                return QUERYSYSTEMGESTURE_WNDPROC\n            if self._is_pen_message(msg):\n                self._pen_handler(msg, wParam, lParam)\n                return 1\n            else:\n                return windll.user32.CallWindowProcW(self.old_windProc,\n                                                     hwnd, msg, wParam, lParam)\n\n        def start(self):\n            self.uid = 0\n            self.pen = None\n            self.pen_status = None\n            self.pen_events = deque()\n\n            self.hwnd = windll.user32.GetActiveWindow()\n\n            # inject our own wndProc to handle messages\n            # before window manager does\n            self.new_windProc = WNDPROC(self._pen_wndProc)\n            self.old_windProc = SetWindowLong_WndProc_wrapper(\n                self.hwnd, self.new_windProc)\n\n        def update(self, dispatch_fn):\n            while True:\n\n                try:\n                    etype, x, y = self.pen_events.pop()\n                except:\n                    break\n\n                if etype == 'begin':\n                    self.uid += 1\n                    self.pen = WM_Pen(self.device, self.uid, [x, y])\n                elif etype == 'update':\n                    self.pen.move([x, y])\n                elif etype == 'end':\n                    self.pen.update_time_end()\n\n                dispatch_fn(etype, self.pen)\n\n        def stop(self):\n            self.pen = None\n            SetWindowLong_WndProc_wrapper(self.hwnd, self.old_windProc)",
  "def _is_pen_message(self, msg):\n            info = windll.user32.GetMessageExtraInfo()\n            # It's a touch or a pen\n            if (info & PEN_OR_TOUCH_MASK) == PEN_OR_TOUCH_SIGNATURE:\n                if not info & PEN_EVENT_TOUCH_MASK:\n                    return True",
  "def _pen_handler(self, msg, wParam, lParam):\n            if msg not in (WM_LBUTTONDOWN, WM_MOUSEMOVE, WM_LBUTTONUP):\n                return\n\n            windll.user32.GetClientRect(self.hwnd, byref(win_rect))\n            x = c_int16(lParam & 0xffff).value / float(win_rect.w)\n            y = c_int16(lParam >> 16).value / float(win_rect.h)\n            y = abs(1.0 - y)\n\n            if msg == WM_LBUTTONDOWN:\n                self.pen_events.appendleft(('begin', x, y))\n                self.pen_status = True\n\n            if msg == WM_MOUSEMOVE and self.pen_status:\n                self.pen_events.appendleft(('update', x, y))\n\n            if msg == WM_LBUTTONUP:\n                self.pen_events.appendleft(('end', x, y))\n                self.pen_status = False",
  "def _pen_wndProc(self, hwnd, msg, wParam, lParam):\n            if msg == WM_TABLET_QUERYSYSTEMGESTURE:\n                return QUERYSYSTEMGESTURE_WNDPROC\n            if self._is_pen_message(msg):\n                self._pen_handler(msg, wParam, lParam)\n                return 1\n            else:\n                return windll.user32.CallWindowProcW(self.old_windProc,\n                                                     hwnd, msg, wParam, lParam)",
  "def start(self):\n            self.uid = 0\n            self.pen = None\n            self.pen_status = None\n            self.pen_events = deque()\n\n            self.hwnd = windll.user32.GetActiveWindow()\n\n            # inject our own wndProc to handle messages\n            # before window manager does\n            self.new_windProc = WNDPROC(self._pen_wndProc)\n            self.old_windProc = SetWindowLong_WndProc_wrapper(\n                self.hwnd, self.new_windProc)",
  "def update(self, dispatch_fn):\n            while True:\n\n                try:\n                    etype, x, y = self.pen_events.pop()\n                except:\n                    break\n\n                if etype == 'begin':\n                    self.uid += 1\n                    self.pen = WM_Pen(self.device, self.uid, [x, y])\n                elif etype == 'update':\n                    self.pen.move([x, y])\n                elif etype == 'end':\n                    self.pen.update_time_end()\n\n                dispatch_fn(etype, self.pen)",
  "def stop(self):\n            self.pen = None\n            SetWindowLong_WndProc_wrapper(self.hwnd, self.old_windProc)",
  "def normalize(value, a, b):\n    return (value - a) / float(b - a)",
  "class LeapFingerEvent(MotionEvent):\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ('pos', 'pos3d',)\n\n    def depack(self, args):\n        super().depack(args)\n        if args[0] is None:\n            return\n        x, y, z = args\n        self.sx = normalize(x, -150, 150)\n        self.sy = normalize(y, 40, 460)\n        self.sz = normalize(z, -350, 350)\n        self.z = z",
  "class LeapFingerEventProvider(MotionEventProvider):\n\n    __handlers__ = {}\n\n    def start(self):\n        # don't do the import at start, or the error will be always displayed\n        # for user who don't have Leap\n        global Leap, InteractionBox\n        import Leap\n        from Leap import InteractionBox\n\n        class LeapMotionListener(Leap.Listener):\n\n            def on_init(self, controller):\n                Logger.info('leapmotion: Initialized')\n\n            def on_connect(self, controller):\n                Logger.info('leapmotion: Connected')\n\n            def on_disconnect(self, controller):\n                Logger.info('leapmotion: Disconnected')\n\n            def on_frame(self, controller):\n                frame = controller.frame()\n                _LEAP_QUEUE.append(frame)\n\n            def on_exit(self, controller):\n                pass\n\n        self.uid = 0\n        self.touches = {}\n        self.listener = LeapMotionListener()\n        self.controller = Leap.Controller(self.listener)\n\n    def update(self, dispatch_fn):\n        try:\n            while True:\n                frame = _LEAP_QUEUE.popleft()\n                events = self.process_frame(frame)\n                for ev in events:\n                    dispatch_fn(*ev)\n        except IndexError:\n            pass\n\n    def process_frame(self, frame):\n        events = []\n        touches = self.touches\n        available_uid = []\n        for hand in frame.hands:\n            for finger in hand.fingers:\n                # print(hand.id(), finger.id(), finger.tip())\n                uid = '{0}:{1}'.format(hand.id, finger.id)\n                available_uid.append(uid)\n                position = finger.tip_position\n                args = (position.x, position.y, position.z)\n                if uid not in touches:\n                    touch = LeapFingerEvent(self.device, uid, args)\n                    events.append(('begin', touch))\n                    touches[uid] = touch\n                else:\n                    touch = touches[uid]\n                    touch.move(args)\n                    events.append(('update', touch))\n        for key in list(touches.keys())[:]:\n            if key not in available_uid:\n                events.append(('end', touches[key]))\n                del touches[key]\n        return events",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n        self.profile = ('pos', 'pos3d',)",
  "def depack(self, args):\n        super().depack(args)\n        if args[0] is None:\n            return\n        x, y, z = args\n        self.sx = normalize(x, -150, 150)\n        self.sy = normalize(y, 40, 460)\n        self.sz = normalize(z, -350, 350)\n        self.z = z",
  "def start(self):\n        # don't do the import at start, or the error will be always displayed\n        # for user who don't have Leap\n        global Leap, InteractionBox\n        import Leap\n        from Leap import InteractionBox\n\n        class LeapMotionListener(Leap.Listener):\n\n            def on_init(self, controller):\n                Logger.info('leapmotion: Initialized')\n\n            def on_connect(self, controller):\n                Logger.info('leapmotion: Connected')\n\n            def on_disconnect(self, controller):\n                Logger.info('leapmotion: Disconnected')\n\n            def on_frame(self, controller):\n                frame = controller.frame()\n                _LEAP_QUEUE.append(frame)\n\n            def on_exit(self, controller):\n                pass\n\n        self.uid = 0\n        self.touches = {}\n        self.listener = LeapMotionListener()\n        self.controller = Leap.Controller(self.listener)",
  "def update(self, dispatch_fn):\n        try:\n            while True:\n                frame = _LEAP_QUEUE.popleft()\n                events = self.process_frame(frame)\n                for ev in events:\n                    dispatch_fn(*ev)\n        except IndexError:\n            pass",
  "def process_frame(self, frame):\n        events = []\n        touches = self.touches\n        available_uid = []\n        for hand in frame.hands:\n            for finger in hand.fingers:\n                # print(hand.id(), finger.id(), finger.tip())\n                uid = '{0}:{1}'.format(hand.id, finger.id)\n                available_uid.append(uid)\n                position = finger.tip_position\n                args = (position.x, position.y, position.z)\n                if uid not in touches:\n                    touch = LeapFingerEvent(self.device, uid, args)\n                    events.append(('begin', touch))\n                    touches[uid] = touch\n                else:\n                    touch = touches[uid]\n                    touch.move(args)\n                    events.append(('update', touch))\n        for key in list(touches.keys())[:]:\n            if key not in available_uid:\n                events.append(('end', touches[key]))\n                del touches[key]\n        return events",
  "class LeapMotionListener(Leap.Listener):\n\n            def on_init(self, controller):\n                Logger.info('leapmotion: Initialized')\n\n            def on_connect(self, controller):\n                Logger.info('leapmotion: Connected')\n\n            def on_disconnect(self, controller):\n                Logger.info('leapmotion: Disconnected')\n\n            def on_frame(self, controller):\n                frame = controller.frame()\n                _LEAP_QUEUE.append(frame)\n\n            def on_exit(self, controller):\n                pass",
  "def on_init(self, controller):\n                Logger.info('leapmotion: Initialized')",
  "def on_connect(self, controller):\n                Logger.info('leapmotion: Connected')",
  "def on_disconnect(self, controller):\n                Logger.info('leapmotion: Disconnected')",
  "def on_frame(self, controller):\n                frame = controller.frame()\n                _LEAP_QUEUE.append(frame)",
  "def on_exit(self, controller):\n                pass",
  "class RECT(RECT_BASE):\n        x = property(lambda self: self.left)\n        y = property(lambda self: self.top)\n        w = property(lambda self: self.right - self.left)\n        h = property(lambda self: self.bottom - self.top)",
  "class TOUCHINPUT(Structure):\n        _fields_ = [\n            ('x', LONG),\n            ('y', LONG),\n            ('pSource', HANDLE),\n            ('id', DWORD),\n            ('flags', DWORD),\n            ('mask', DWORD),\n            ('time', DWORD),\n            ('extraInfo', POINTER(ULONG)),\n            ('size_x', DWORD),\n            ('size_y', DWORD)]\n\n        def size(self):\n            return (self.size_x, self.size_y)\n\n        def screen_x(self):\n            return self.x / 100.0\n\n        def screen_y(self):\n            return self.y / 100.0\n\n        def _event_type(self):\n            if self.flags & TOUCHEVENTF_MOVE:\n                return 'update'\n            if self.flags & TOUCHEVENTF_DOWN:\n                return 'begin'\n            if self.flags & TOUCHEVENTF_UP:\n                return 'end'\n        event_type = property(_event_type)",
  "def SetWindowLong_WndProc_wrapper_generator(func):\n        def _closure(hWnd, wndProc):\n            oldAddr = func(hWnd, GWL_WNDPROC, cast(wndProc, c_void_p).value)\n            return cast(c_void_p(oldAddr), WNDPROC)\n\n        return _closure",
  "def size(self):\n            return (self.size_x, self.size_y)",
  "def screen_x(self):\n            return self.x / 100.0",
  "def screen_y(self):\n            return self.y / 100.0",
  "def _event_type(self):\n            if self.flags & TOUCHEVENTF_MOVE:\n                return 'update'\n            if self.flags & TOUCHEVENTF_DOWN:\n                return 'begin'\n            if self.flags & TOUCHEVENTF_UP:\n                return 'end'",
  "def _closure(hWnd, wndProc):\n            oldAddr = func(hWnd, GWL_WNDPROC, cast(wndProc, c_void_p).value)\n            return cast(c_void_p(oldAddr), WNDPROC)",
  "class HIDMotionEvent(MotionEvent):\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n\n    def depack(self, args):\n        self.sx = args['x']\n        self.sy = args['y']\n        self.profile = ['pos']\n        if 'size_w' in args and 'size_h' in args:\n            self.shape = ShapeRect()\n            self.shape.width = args['size_w']\n            self.shape.height = args['size_h']\n            self.profile.append('shape')\n        if 'pressure' in args:\n            self.pressure = args['pressure']\n            self.profile.append('pressure')\n        if 'button' in args:\n            self.button = args['button']\n            self.profile.append('button')\n        super().depack(args)\n\n    def __str__(self):\n        return '<HIDMotionEvent id=%d pos=(%f, %f) device=%s>' \\\n            % (self.id, self.sx, self.sy, self.device)",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)",
  "def depack(self, args):\n        self.sx = args['x']\n        self.sy = args['y']\n        self.profile = ['pos']\n        if 'size_w' in args and 'size_h' in args:\n            self.shape = ShapeRect()\n            self.shape.width = args['size_w']\n            self.shape.height = args['size_h']\n            self.profile.append('shape')\n        if 'pressure' in args:\n            self.pressure = args['pressure']\n            self.profile.append('pressure')\n        if 'button' in args:\n            self.button = args['button']\n            self.profile.append('button')\n        super().depack(args)",
  "def __str__(self):\n        return '<HIDMotionEvent id=%d pos=(%f, %f) device=%s>' \\\n            % (self.id, self.sx, self.sy, self.device)",
  "class HIDInputMotionEventProvider(MotionEventProvider):\n\n        options = ('min_position_x', 'max_position_x',\n                   'min_position_y', 'max_position_y',\n                   'min_pressure', 'max_pressure',\n                   'min_abs_x', 'max_abs_x',\n                   'min_abs_y', 'max_abs_y',\n                   'invert_x', 'invert_y', 'rotation')\n\n        def __init__(self, device, args):\n            super(HIDInputMotionEventProvider, self).__init__(device, args)\n            global Window, Keyboard\n\n            if Window is None:\n                from kivy.core.window import Window\n            if Keyboard is None:\n                from kivy.core.window import Keyboard\n\n            self.input_fn = None\n            self.default_ranges = dict()\n\n            # split arguments\n            args = args.split(',')\n            if not args:\n                Logger.error('HIDInput: Filename missing in configuration')\n                Logger.error('HIDInput: Use /dev/input/event0 for example')\n                return None\n\n            # read filename\n            self.input_fn = args[0]\n            Logger.info('HIDInput: Read event from <%s>' % self.input_fn)\n\n            # read parameters\n            for arg in args[1:]:\n                if arg == '':\n                    continue\n                arg = arg.split('=')\n\n                # ensure it's a key = value\n                if len(arg) != 2:\n                    Logger.error('HIDInput: invalid parameter '\n                                 '%s, not in key=value format.' % arg)\n                    continue\n\n                # ensure the key exist\n                key, value = arg\n                if key not in HIDInputMotionEventProvider.options:\n                    Logger.error('HIDInput: unknown %s option' % key)\n                    continue\n\n                # ensure the value\n                try:\n                    self.default_ranges[key] = int(value)\n                except ValueError:\n                    err = 'HIDInput: invalid value \"%s\" for \"%s\"' % (\n                        key, value)\n                    Logger.error(err)\n                    continue\n\n                # all good!\n                Logger.info('HIDInput: Set custom %s to %d' % (\n                    key, int(value)))\n\n            if 'rotation' not in self.default_ranges:\n                self.default_ranges['rotation'] = 0\n            elif self.default_ranges['rotation'] not in (0, 90, 180, 270):\n                Logger.error('HIDInput: invalid rotation value ({})'.format(\n                    self.default_ranges['rotation']))\n                self.default_ranges['rotation'] = 0\n\n        def start(self):\n            if self.input_fn is None:\n                return\n            self.uid = 0\n            self.queue = collections.deque()\n            self.dispatch_queue = []\n            self.thread = threading.Thread(\n                name=self.__class__.__name__,\n                target=self._thread_run,\n                kwargs=dict(\n                    queue=self.queue,\n                    input_fn=self.input_fn,\n                    device=self.device,\n                    default_ranges=self.default_ranges))\n            self.thread.daemon = True\n            self.thread.start()\n\n        def _thread_run(self, **kwargs):\n            input_fn = kwargs.get('input_fn')\n            queue = self.queue\n            dispatch_queue = self.dispatch_queue\n            device = kwargs.get('device')\n            drs = kwargs.get('default_ranges').get\n            touches = {}\n            touches_sent = []\n            point = {}\n            l_points = []\n\n            # prepare some vars to get limit of some component\n            range_min_position_x = 0\n            range_max_position_x = 2048\n            range_min_position_y = 0\n            range_max_position_y = 2048\n            range_min_pressure = 0\n            range_max_pressure = 255\n            range_min_abs_x = 0\n            range_max_abs_x = 255\n            range_min_abs_y = 0\n            range_max_abs_y = 255\n            range_min_abs_pressure = 0\n            range_max_abs_pressure = 255\n            invert_x = int(bool(drs('invert_x', 0)))\n            invert_y = int(bool(drs('invert_y', 1)))\n            rotation = drs('rotation', 0)\n\n            def assign_coord(point, value, invert, coords):\n                cx, cy = coords\n                if invert:\n                    value = 1. - value\n                if rotation == 0:\n                    point[cx] = value\n                elif rotation == 90:\n                    point[cy] = value\n                elif rotation == 180:\n                    point[cx] = 1. - value\n                elif rotation == 270:\n                    point[cy] = 1. - value\n\n            def assign_rel_coord(point, value, invert, coords):\n                cx, cy = coords\n                if invert:\n                    value = -1 * value\n                if rotation == 0:\n                    point[cx] += value\n                elif rotation == 90:\n                    point[cy] += value\n                elif rotation == 180:\n                    point[cx] += -value\n                elif rotation == 270:\n                    point[cy] += -value\n\n                # limit it to the screen area 0-1\n                point['x'] = min(1., max(0., point['x']))\n                point['y'] = min(1., max(0., point['y']))\n\n            def process_as_multitouch(tv_sec, tv_usec, ev_type,\n                                      ev_code, ev_value):\n                # sync event\n                if ev_type == EV_SYN:\n                    if ev_code == SYN_MT_REPORT:\n                        if 'id' not in point:\n                            return\n                        l_points.append(point.copy())\n                    elif ev_code == SYN_REPORT:\n                        process(l_points)\n                        del l_points[:]\n\n                elif ev_type == EV_MSC and ev_code in (MSC_RAW, MSC_SCAN):\n                    pass\n\n                else:\n                    # compute multitouch track\n                    if ev_code == ABS_MT_TRACKING_ID:\n                        point.clear()\n                        point['id'] = ev_value\n                    elif ev_code == ABS_MT_POSITION_X:\n                        val = normalize(ev_value,\n                                        range_min_position_x,\n                                        range_max_position_x)\n                        assign_coord(point, val, invert_x, 'xy')\n                    elif ev_code == ABS_MT_POSITION_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_position_y,\n                                             range_max_position_y)\n                        assign_coord(point, val, invert_y, 'yx')\n                    elif ev_code == ABS_MT_ORIENTATION:\n                        point['orientation'] = ev_value\n                    elif ev_code == ABS_MT_BLOB_ID:\n                        point['blobid'] = ev_value\n                    elif ev_code == ABS_MT_PRESSURE:\n                        point['pressure'] = normalize(ev_value,\n                                                      range_min_pressure,\n                                                      range_max_pressure)\n                    elif ev_code == ABS_MT_TOUCH_MAJOR:\n                        point['size_w'] = ev_value\n                    elif ev_code == ABS_MT_TOUCH_MINOR:\n                        point['size_h'] = ev_value\n\n            def process_as_mouse_or_keyboard(\n                    tv_sec, tv_usec, ev_type, ev_code, ev_value):\n                if ev_type == EV_SYN:\n                    if ev_code == SYN_REPORT:\n                        process([point])\n                        if ('button' in point and\n                                point['button'].startswith('scroll')):\n                            # for scrolls we need to remove it as there is\n                            # no up key\n                            del point['button']\n                            point['id'] += 1\n                            point['_avoid'] = True\n                            process([point])\n\n                elif ev_type == EV_REL:\n                    if ev_code == 0:\n                        assign_rel_coord(point,\n                                         min(1., max(-1., ev_value / 1000.)),\n                                         invert_x, 'xy')\n                    elif ev_code == 1:\n                        assign_rel_coord(point,\n                                         min(1., max(-1., ev_value / 1000.)),\n                                         invert_y, 'yx')\n                    elif ev_code == 8:  # Wheel\n                        # translates the wheel move to a button\n                        b = \"scrollup\" if ev_value < 0 else \"scrolldown\"\n                        if 'button' not in point:\n                            point['button'] = b\n                            point['id'] += 1\n                            if '_avoid' in point:\n                                del point['_avoid']\n\n                elif ev_type != EV_KEY:\n                    if ev_code == ABS_X:\n                        val = normalize(ev_value,\n                                        range_min_abs_x,\n                                        range_max_abs_x)\n                        assign_coord(point, val, invert_x, 'xy')\n                    elif ev_code == ABS_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_abs_y,\n                                             range_max_abs_y)\n                        assign_coord(point, val, invert_y, 'yx')\n                    elif ev_code == ABS_PRESSURE:\n                        point['pressure'] = normalize(ev_value,\n                                                      range_min_abs_pressure,\n                                                      range_max_abs_pressure)\n                else:\n                    buttons = {\n                        272: 'left',\n                        273: 'right',\n                        274: 'middle',\n                        275: 'side',\n                        276: 'extra',\n                        277: 'forward',\n                        278: 'back',\n                        279: 'task',\n                        330: 'touch',\n                        320: 'pen'}\n\n                    if ev_code in buttons.keys():\n                        if ev_value:\n                            if 'button' not in point:\n                                point['button'] = buttons[ev_code]\n                                point['id'] += 1\n                                if '_avoid' in point:\n                                    del point['_avoid']\n                        elif 'button' in point:\n                            if point['button'] == buttons[ev_code]:\n                                del point['button']\n                                point['id'] += 1\n                                point['_avoid'] = True\n                    else:\n                        if not 0 <= ev_value <= 1:\n                            return\n\n                        if ev_code not in keyboard_keys:\n                            Logger.warn('HIDInput: unhandled HID code: {}'.\n                                        format(ev_code))\n                            return\n\n                        z = keyboard_keys[ev_code][-1 if 'shift' in\n                                                   Window._modifiers else 0]\n                        if z.lower() not in Keyboard.keycodes:\n                            # or if it is not in this LUT\n                            Logger.warn('HIDInput: unhandled character: {}'.\n                                        format(z))\n                            return\n\n                        keycode = Keyboard.keycodes[z.lower()]\n\n                        if ev_value == 1:\n                            if z == 'shift' or z == 'alt':\n                                Window._modifiers.append(z)\n                            elif z.endswith('ctrl'):\n                                Window._modifiers.append('ctrl')\n\n                            dispatch_queue.append(('key_down', (\n                                keycode, ev_code,\n                                keys_str.get(z, z), Window._modifiers)))\n                        elif ev_value == 0:\n                            dispatch_queue.append(('key_up', (\n                                keycode, ev_code,\n                                keys_str.get(z, z), Window._modifiers)))\n                            if ((z == 'shift' or z == 'alt') and\n                                    (z in Window._modifiers)):\n                                Window._modifiers.remove(z)\n                            elif (z.endswith('ctrl') and\n                                  'ctrl' in Window._modifiers):\n                                Window._modifiers.remove('ctrl')\n\n            def process(points):\n                if not is_multitouch:\n                    dispatch_queue.append(('mouse_pos', (\n                        points[0]['x'] * Window.width,\n                        points[0]['y'] * Window.height)))\n\n                actives = [args['id']\n                           for args in points\n                           if 'id' in args and '_avoid' not in args]\n                for args in points:\n                    tid = args['id']\n                    try:\n                        touch = touches[tid]\n                        if touch.sx == args['x'] and touch.sy == args['y']:\n                            continue\n                        touch.move(args)\n                        if tid not in touches_sent:\n                            queue.append(('begin', touch))\n                            touches_sent.append(tid)\n                        queue.append(('update', touch))\n                    except KeyError:\n                        if '_avoid' not in args:\n                            touch = HIDMotionEvent(device, tid, args)\n                            touches[touch.id] = touch\n                            if tid not in touches_sent:\n                                queue.append(('begin', touch))\n                                touches_sent.append(tid)\n\n                for tid in list(touches.keys())[:]:\n                    if tid not in actives:\n                        touch = touches[tid]\n                        if tid in touches_sent:\n                            touch.update_time_end()\n                            queue.append(('end', touch))\n                            touches_sent.remove(tid)\n                        del touches[tid]\n\n            def normalize(value, vmin, vmax):\n                return (value - vmin) / float(vmax - vmin)\n\n            # open the input\n            fd = open(input_fn, 'rb')\n\n            # get the controller name (EVIOCGNAME)\n            device_name = fcntl.ioctl(fd, EVIOCGNAME + (256 << 16),\n                                      \" \" * 256).decode().strip()\n            Logger.info('HIDMotionEvent: using <%s>' % device_name)\n\n            # get abs infos\n            bit = fcntl.ioctl(fd, EVIOCGBIT + (EV_MAX << 16), ' ' * sz_l)\n            bit, = struct.unpack('Q', bit)\n            is_multitouch = False\n            for x in range(EV_MAX):\n                # preserve this, we may want other things than EV_ABS\n                if x != EV_ABS:\n                    continue\n                # EV_ABS available for this device ?\n                if (bit & (1 << x)) == 0:\n                    continue\n                # ask abs info keys to the devices\n                sbit = fcntl.ioctl(fd, EVIOCGBIT + x + (KEY_MAX << 16),\n                                   ' ' * sz_l)\n                sbit, = struct.unpack('Q', sbit)\n                for y in range(KEY_MAX):\n                    if (sbit & (1 << y)) == 0:\n                        continue\n                    absinfo = fcntl.ioctl(fd, EVIOCGABS + y +\n                                          (struct_input_absinfo_sz << 16),\n                                          ' ' * struct_input_absinfo_sz)\n                    abs_value, abs_min, abs_max, abs_fuzz, \\\n                        abs_flat, abs_res = struct.unpack('iiiiii', absinfo)\n                    if y == ABS_MT_POSITION_X:\n                        is_multitouch = True\n                        range_min_position_x = drs('min_position_x', abs_min)\n                        range_max_position_x = drs('max_position_x', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range position X is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_MT_POSITION_Y:\n                        is_multitouch = True\n                        range_min_position_y = drs('min_position_y', abs_min)\n                        range_max_position_y = drs('max_position_y', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range position Y is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_MT_PRESSURE:\n                        range_min_pressure = drs('min_pressure', abs_min)\n                        range_max_pressure = drs('max_pressure', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range pressure is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_X:\n                        range_min_abs_x = drs('min_abs_x', abs_min)\n                        range_max_abs_x = drs('max_abs_x', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range ABS X position is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_Y:\n                        range_min_abs_y = drs('min_abs_y', abs_min)\n                        range_max_abs_y = drs('max_abs_y', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range ABS Y position is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_PRESSURE:\n                        range_min_abs_pressure = drs(\n                            'min_abs_pressure', abs_min)\n                        range_max_abs_pressure = drs(\n                            'max_abs_pressure', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range ABS pressure is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n\n            # init the point\n            if not is_multitouch:\n                point = {'x': .5, 'y': .5, 'id': 0, '_avoid': True}\n\n            # read until the end\n            while fd:\n\n                data = fd.read(struct_input_event_sz)\n                if len(data) < struct_input_event_sz:\n                    break\n\n                # extract each event\n                for i in range(int(len(data) / struct_input_event_sz)):\n                    ev = data[i * struct_input_event_sz:]\n\n                    # extract timeval + event infos\n                    infos = struct.unpack('LLHHi', ev[:struct_input_event_sz])\n\n                    if is_multitouch:\n                        process_as_multitouch(*infos)\n                    else:\n                        process_as_mouse_or_keyboard(*infos)\n\n        def update(self, dispatch_fn):\n            # dispatch all events from threads\n            dispatch_queue = self.dispatch_queue\n            n = len(dispatch_queue)\n            for name, args in dispatch_queue[:n]:\n                if name == 'mouse_pos':\n                    Window.mouse_pos = args\n                elif name == 'key_down':\n                    if not Window.dispatch('on_key_down', *args):\n                        Window.dispatch('on_keyboard', *args)\n                elif name == 'key_up':\n                    Window.dispatch('on_key_up', *args)\n            del dispatch_queue[:n]\n\n            try:\n                while True:\n                    event_type, touch = self.queue.popleft()\n                    dispatch_fn(event_type, touch)\n            except:\n                pass",
  "def __init__(self, device, args):\n            super(HIDInputMotionEventProvider, self).__init__(device, args)\n            global Window, Keyboard\n\n            if Window is None:\n                from kivy.core.window import Window\n            if Keyboard is None:\n                from kivy.core.window import Keyboard\n\n            self.input_fn = None\n            self.default_ranges = dict()\n\n            # split arguments\n            args = args.split(',')\n            if not args:\n                Logger.error('HIDInput: Filename missing in configuration')\n                Logger.error('HIDInput: Use /dev/input/event0 for example')\n                return None\n\n            # read filename\n            self.input_fn = args[0]\n            Logger.info('HIDInput: Read event from <%s>' % self.input_fn)\n\n            # read parameters\n            for arg in args[1:]:\n                if arg == '':\n                    continue\n                arg = arg.split('=')\n\n                # ensure it's a key = value\n                if len(arg) != 2:\n                    Logger.error('HIDInput: invalid parameter '\n                                 '%s, not in key=value format.' % arg)\n                    continue\n\n                # ensure the key exist\n                key, value = arg\n                if key not in HIDInputMotionEventProvider.options:\n                    Logger.error('HIDInput: unknown %s option' % key)\n                    continue\n\n                # ensure the value\n                try:\n                    self.default_ranges[key] = int(value)\n                except ValueError:\n                    err = 'HIDInput: invalid value \"%s\" for \"%s\"' % (\n                        key, value)\n                    Logger.error(err)\n                    continue\n\n                # all good!\n                Logger.info('HIDInput: Set custom %s to %d' % (\n                    key, int(value)))\n\n            if 'rotation' not in self.default_ranges:\n                self.default_ranges['rotation'] = 0\n            elif self.default_ranges['rotation'] not in (0, 90, 180, 270):\n                Logger.error('HIDInput: invalid rotation value ({})'.format(\n                    self.default_ranges['rotation']))\n                self.default_ranges['rotation'] = 0",
  "def start(self):\n            if self.input_fn is None:\n                return\n            self.uid = 0\n            self.queue = collections.deque()\n            self.dispatch_queue = []\n            self.thread = threading.Thread(\n                name=self.__class__.__name__,\n                target=self._thread_run,\n                kwargs=dict(\n                    queue=self.queue,\n                    input_fn=self.input_fn,\n                    device=self.device,\n                    default_ranges=self.default_ranges))\n            self.thread.daemon = True\n            self.thread.start()",
  "def _thread_run(self, **kwargs):\n            input_fn = kwargs.get('input_fn')\n            queue = self.queue\n            dispatch_queue = self.dispatch_queue\n            device = kwargs.get('device')\n            drs = kwargs.get('default_ranges').get\n            touches = {}\n            touches_sent = []\n            point = {}\n            l_points = []\n\n            # prepare some vars to get limit of some component\n            range_min_position_x = 0\n            range_max_position_x = 2048\n            range_min_position_y = 0\n            range_max_position_y = 2048\n            range_min_pressure = 0\n            range_max_pressure = 255\n            range_min_abs_x = 0\n            range_max_abs_x = 255\n            range_min_abs_y = 0\n            range_max_abs_y = 255\n            range_min_abs_pressure = 0\n            range_max_abs_pressure = 255\n            invert_x = int(bool(drs('invert_x', 0)))\n            invert_y = int(bool(drs('invert_y', 1)))\n            rotation = drs('rotation', 0)\n\n            def assign_coord(point, value, invert, coords):\n                cx, cy = coords\n                if invert:\n                    value = 1. - value\n                if rotation == 0:\n                    point[cx] = value\n                elif rotation == 90:\n                    point[cy] = value\n                elif rotation == 180:\n                    point[cx] = 1. - value\n                elif rotation == 270:\n                    point[cy] = 1. - value\n\n            def assign_rel_coord(point, value, invert, coords):\n                cx, cy = coords\n                if invert:\n                    value = -1 * value\n                if rotation == 0:\n                    point[cx] += value\n                elif rotation == 90:\n                    point[cy] += value\n                elif rotation == 180:\n                    point[cx] += -value\n                elif rotation == 270:\n                    point[cy] += -value\n\n                # limit it to the screen area 0-1\n                point['x'] = min(1., max(0., point['x']))\n                point['y'] = min(1., max(0., point['y']))\n\n            def process_as_multitouch(tv_sec, tv_usec, ev_type,\n                                      ev_code, ev_value):\n                # sync event\n                if ev_type == EV_SYN:\n                    if ev_code == SYN_MT_REPORT:\n                        if 'id' not in point:\n                            return\n                        l_points.append(point.copy())\n                    elif ev_code == SYN_REPORT:\n                        process(l_points)\n                        del l_points[:]\n\n                elif ev_type == EV_MSC and ev_code in (MSC_RAW, MSC_SCAN):\n                    pass\n\n                else:\n                    # compute multitouch track\n                    if ev_code == ABS_MT_TRACKING_ID:\n                        point.clear()\n                        point['id'] = ev_value\n                    elif ev_code == ABS_MT_POSITION_X:\n                        val = normalize(ev_value,\n                                        range_min_position_x,\n                                        range_max_position_x)\n                        assign_coord(point, val, invert_x, 'xy')\n                    elif ev_code == ABS_MT_POSITION_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_position_y,\n                                             range_max_position_y)\n                        assign_coord(point, val, invert_y, 'yx')\n                    elif ev_code == ABS_MT_ORIENTATION:\n                        point['orientation'] = ev_value\n                    elif ev_code == ABS_MT_BLOB_ID:\n                        point['blobid'] = ev_value\n                    elif ev_code == ABS_MT_PRESSURE:\n                        point['pressure'] = normalize(ev_value,\n                                                      range_min_pressure,\n                                                      range_max_pressure)\n                    elif ev_code == ABS_MT_TOUCH_MAJOR:\n                        point['size_w'] = ev_value\n                    elif ev_code == ABS_MT_TOUCH_MINOR:\n                        point['size_h'] = ev_value\n\n            def process_as_mouse_or_keyboard(\n                    tv_sec, tv_usec, ev_type, ev_code, ev_value):\n                if ev_type == EV_SYN:\n                    if ev_code == SYN_REPORT:\n                        process([point])\n                        if ('button' in point and\n                                point['button'].startswith('scroll')):\n                            # for scrolls we need to remove it as there is\n                            # no up key\n                            del point['button']\n                            point['id'] += 1\n                            point['_avoid'] = True\n                            process([point])\n\n                elif ev_type == EV_REL:\n                    if ev_code == 0:\n                        assign_rel_coord(point,\n                                         min(1., max(-1., ev_value / 1000.)),\n                                         invert_x, 'xy')\n                    elif ev_code == 1:\n                        assign_rel_coord(point,\n                                         min(1., max(-1., ev_value / 1000.)),\n                                         invert_y, 'yx')\n                    elif ev_code == 8:  # Wheel\n                        # translates the wheel move to a button\n                        b = \"scrollup\" if ev_value < 0 else \"scrolldown\"\n                        if 'button' not in point:\n                            point['button'] = b\n                            point['id'] += 1\n                            if '_avoid' in point:\n                                del point['_avoid']\n\n                elif ev_type != EV_KEY:\n                    if ev_code == ABS_X:\n                        val = normalize(ev_value,\n                                        range_min_abs_x,\n                                        range_max_abs_x)\n                        assign_coord(point, val, invert_x, 'xy')\n                    elif ev_code == ABS_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_abs_y,\n                                             range_max_abs_y)\n                        assign_coord(point, val, invert_y, 'yx')\n                    elif ev_code == ABS_PRESSURE:\n                        point['pressure'] = normalize(ev_value,\n                                                      range_min_abs_pressure,\n                                                      range_max_abs_pressure)\n                else:\n                    buttons = {\n                        272: 'left',\n                        273: 'right',\n                        274: 'middle',\n                        275: 'side',\n                        276: 'extra',\n                        277: 'forward',\n                        278: 'back',\n                        279: 'task',\n                        330: 'touch',\n                        320: 'pen'}\n\n                    if ev_code in buttons.keys():\n                        if ev_value:\n                            if 'button' not in point:\n                                point['button'] = buttons[ev_code]\n                                point['id'] += 1\n                                if '_avoid' in point:\n                                    del point['_avoid']\n                        elif 'button' in point:\n                            if point['button'] == buttons[ev_code]:\n                                del point['button']\n                                point['id'] += 1\n                                point['_avoid'] = True\n                    else:\n                        if not 0 <= ev_value <= 1:\n                            return\n\n                        if ev_code not in keyboard_keys:\n                            Logger.warn('HIDInput: unhandled HID code: {}'.\n                                        format(ev_code))\n                            return\n\n                        z = keyboard_keys[ev_code][-1 if 'shift' in\n                                                   Window._modifiers else 0]\n                        if z.lower() not in Keyboard.keycodes:\n                            # or if it is not in this LUT\n                            Logger.warn('HIDInput: unhandled character: {}'.\n                                        format(z))\n                            return\n\n                        keycode = Keyboard.keycodes[z.lower()]\n\n                        if ev_value == 1:\n                            if z == 'shift' or z == 'alt':\n                                Window._modifiers.append(z)\n                            elif z.endswith('ctrl'):\n                                Window._modifiers.append('ctrl')\n\n                            dispatch_queue.append(('key_down', (\n                                keycode, ev_code,\n                                keys_str.get(z, z), Window._modifiers)))\n                        elif ev_value == 0:\n                            dispatch_queue.append(('key_up', (\n                                keycode, ev_code,\n                                keys_str.get(z, z), Window._modifiers)))\n                            if ((z == 'shift' or z == 'alt') and\n                                    (z in Window._modifiers)):\n                                Window._modifiers.remove(z)\n                            elif (z.endswith('ctrl') and\n                                  'ctrl' in Window._modifiers):\n                                Window._modifiers.remove('ctrl')\n\n            def process(points):\n                if not is_multitouch:\n                    dispatch_queue.append(('mouse_pos', (\n                        points[0]['x'] * Window.width,\n                        points[0]['y'] * Window.height)))\n\n                actives = [args['id']\n                           for args in points\n                           if 'id' in args and '_avoid' not in args]\n                for args in points:\n                    tid = args['id']\n                    try:\n                        touch = touches[tid]\n                        if touch.sx == args['x'] and touch.sy == args['y']:\n                            continue\n                        touch.move(args)\n                        if tid not in touches_sent:\n                            queue.append(('begin', touch))\n                            touches_sent.append(tid)\n                        queue.append(('update', touch))\n                    except KeyError:\n                        if '_avoid' not in args:\n                            touch = HIDMotionEvent(device, tid, args)\n                            touches[touch.id] = touch\n                            if tid not in touches_sent:\n                                queue.append(('begin', touch))\n                                touches_sent.append(tid)\n\n                for tid in list(touches.keys())[:]:\n                    if tid not in actives:\n                        touch = touches[tid]\n                        if tid in touches_sent:\n                            touch.update_time_end()\n                            queue.append(('end', touch))\n                            touches_sent.remove(tid)\n                        del touches[tid]\n\n            def normalize(value, vmin, vmax):\n                return (value - vmin) / float(vmax - vmin)\n\n            # open the input\n            fd = open(input_fn, 'rb')\n\n            # get the controller name (EVIOCGNAME)\n            device_name = fcntl.ioctl(fd, EVIOCGNAME + (256 << 16),\n                                      \" \" * 256).decode().strip()\n            Logger.info('HIDMotionEvent: using <%s>' % device_name)\n\n            # get abs infos\n            bit = fcntl.ioctl(fd, EVIOCGBIT + (EV_MAX << 16), ' ' * sz_l)\n            bit, = struct.unpack('Q', bit)\n            is_multitouch = False\n            for x in range(EV_MAX):\n                # preserve this, we may want other things than EV_ABS\n                if x != EV_ABS:\n                    continue\n                # EV_ABS available for this device ?\n                if (bit & (1 << x)) == 0:\n                    continue\n                # ask abs info keys to the devices\n                sbit = fcntl.ioctl(fd, EVIOCGBIT + x + (KEY_MAX << 16),\n                                   ' ' * sz_l)\n                sbit, = struct.unpack('Q', sbit)\n                for y in range(KEY_MAX):\n                    if (sbit & (1 << y)) == 0:\n                        continue\n                    absinfo = fcntl.ioctl(fd, EVIOCGABS + y +\n                                          (struct_input_absinfo_sz << 16),\n                                          ' ' * struct_input_absinfo_sz)\n                    abs_value, abs_min, abs_max, abs_fuzz, \\\n                        abs_flat, abs_res = struct.unpack('iiiiii', absinfo)\n                    if y == ABS_MT_POSITION_X:\n                        is_multitouch = True\n                        range_min_position_x = drs('min_position_x', abs_min)\n                        range_max_position_x = drs('max_position_x', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range position X is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_MT_POSITION_Y:\n                        is_multitouch = True\n                        range_min_position_y = drs('min_position_y', abs_min)\n                        range_max_position_y = drs('max_position_y', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range position Y is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_MT_PRESSURE:\n                        range_min_pressure = drs('min_pressure', abs_min)\n                        range_max_pressure = drs('max_pressure', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range pressure is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_X:\n                        range_min_abs_x = drs('min_abs_x', abs_min)\n                        range_max_abs_x = drs('max_abs_x', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range ABS X position is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_Y:\n                        range_min_abs_y = drs('min_abs_y', abs_min)\n                        range_max_abs_y = drs('max_abs_y', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range ABS Y position is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_PRESSURE:\n                        range_min_abs_pressure = drs(\n                            'min_abs_pressure', abs_min)\n                        range_max_abs_pressure = drs(\n                            'max_abs_pressure', abs_max)\n                        Logger.info('HIDMotionEvent: ' +\n                                    '<%s> range ABS pressure is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n\n            # init the point\n            if not is_multitouch:\n                point = {'x': .5, 'y': .5, 'id': 0, '_avoid': True}\n\n            # read until the end\n            while fd:\n\n                data = fd.read(struct_input_event_sz)\n                if len(data) < struct_input_event_sz:\n                    break\n\n                # extract each event\n                for i in range(int(len(data) / struct_input_event_sz)):\n                    ev = data[i * struct_input_event_sz:]\n\n                    # extract timeval + event infos\n                    infos = struct.unpack('LLHHi', ev[:struct_input_event_sz])\n\n                    if is_multitouch:\n                        process_as_multitouch(*infos)\n                    else:\n                        process_as_mouse_or_keyboard(*infos)",
  "def update(self, dispatch_fn):\n            # dispatch all events from threads\n            dispatch_queue = self.dispatch_queue\n            n = len(dispatch_queue)\n            for name, args in dispatch_queue[:n]:\n                if name == 'mouse_pos':\n                    Window.mouse_pos = args\n                elif name == 'key_down':\n                    if not Window.dispatch('on_key_down', *args):\n                        Window.dispatch('on_keyboard', *args)\n                elif name == 'key_up':\n                    Window.dispatch('on_key_up', *args)\n            del dispatch_queue[:n]\n\n            try:\n                while True:\n                    event_type, touch = self.queue.popleft()\n                    dispatch_fn(event_type, touch)\n            except:\n                pass",
  "def assign_coord(point, value, invert, coords):\n                cx, cy = coords\n                if invert:\n                    value = 1. - value\n                if rotation == 0:\n                    point[cx] = value\n                elif rotation == 90:\n                    point[cy] = value\n                elif rotation == 180:\n                    point[cx] = 1. - value\n                elif rotation == 270:\n                    point[cy] = 1. - value",
  "def assign_rel_coord(point, value, invert, coords):\n                cx, cy = coords\n                if invert:\n                    value = -1 * value\n                if rotation == 0:\n                    point[cx] += value\n                elif rotation == 90:\n                    point[cy] += value\n                elif rotation == 180:\n                    point[cx] += -value\n                elif rotation == 270:\n                    point[cy] += -value\n\n                # limit it to the screen area 0-1\n                point['x'] = min(1., max(0., point['x']))\n                point['y'] = min(1., max(0., point['y']))",
  "def process_as_multitouch(tv_sec, tv_usec, ev_type,\n                                      ev_code, ev_value):\n                # sync event\n                if ev_type == EV_SYN:\n                    if ev_code == SYN_MT_REPORT:\n                        if 'id' not in point:\n                            return\n                        l_points.append(point.copy())\n                    elif ev_code == SYN_REPORT:\n                        process(l_points)\n                        del l_points[:]\n\n                elif ev_type == EV_MSC and ev_code in (MSC_RAW, MSC_SCAN):\n                    pass\n\n                else:\n                    # compute multitouch track\n                    if ev_code == ABS_MT_TRACKING_ID:\n                        point.clear()\n                        point['id'] = ev_value\n                    elif ev_code == ABS_MT_POSITION_X:\n                        val = normalize(ev_value,\n                                        range_min_position_x,\n                                        range_max_position_x)\n                        assign_coord(point, val, invert_x, 'xy')\n                    elif ev_code == ABS_MT_POSITION_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_position_y,\n                                             range_max_position_y)\n                        assign_coord(point, val, invert_y, 'yx')\n                    elif ev_code == ABS_MT_ORIENTATION:\n                        point['orientation'] = ev_value\n                    elif ev_code == ABS_MT_BLOB_ID:\n                        point['blobid'] = ev_value\n                    elif ev_code == ABS_MT_PRESSURE:\n                        point['pressure'] = normalize(ev_value,\n                                                      range_min_pressure,\n                                                      range_max_pressure)\n                    elif ev_code == ABS_MT_TOUCH_MAJOR:\n                        point['size_w'] = ev_value\n                    elif ev_code == ABS_MT_TOUCH_MINOR:\n                        point['size_h'] = ev_value",
  "def process_as_mouse_or_keyboard(\n                    tv_sec, tv_usec, ev_type, ev_code, ev_value):\n                if ev_type == EV_SYN:\n                    if ev_code == SYN_REPORT:\n                        process([point])\n                        if ('button' in point and\n                                point['button'].startswith('scroll')):\n                            # for scrolls we need to remove it as there is\n                            # no up key\n                            del point['button']\n                            point['id'] += 1\n                            point['_avoid'] = True\n                            process([point])\n\n                elif ev_type == EV_REL:\n                    if ev_code == 0:\n                        assign_rel_coord(point,\n                                         min(1., max(-1., ev_value / 1000.)),\n                                         invert_x, 'xy')\n                    elif ev_code == 1:\n                        assign_rel_coord(point,\n                                         min(1., max(-1., ev_value / 1000.)),\n                                         invert_y, 'yx')\n                    elif ev_code == 8:  # Wheel\n                        # translates the wheel move to a button\n                        b = \"scrollup\" if ev_value < 0 else \"scrolldown\"\n                        if 'button' not in point:\n                            point['button'] = b\n                            point['id'] += 1\n                            if '_avoid' in point:\n                                del point['_avoid']\n\n                elif ev_type != EV_KEY:\n                    if ev_code == ABS_X:\n                        val = normalize(ev_value,\n                                        range_min_abs_x,\n                                        range_max_abs_x)\n                        assign_coord(point, val, invert_x, 'xy')\n                    elif ev_code == ABS_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_abs_y,\n                                             range_max_abs_y)\n                        assign_coord(point, val, invert_y, 'yx')\n                    elif ev_code == ABS_PRESSURE:\n                        point['pressure'] = normalize(ev_value,\n                                                      range_min_abs_pressure,\n                                                      range_max_abs_pressure)\n                else:\n                    buttons = {\n                        272: 'left',\n                        273: 'right',\n                        274: 'middle',\n                        275: 'side',\n                        276: 'extra',\n                        277: 'forward',\n                        278: 'back',\n                        279: 'task',\n                        330: 'touch',\n                        320: 'pen'}\n\n                    if ev_code in buttons.keys():\n                        if ev_value:\n                            if 'button' not in point:\n                                point['button'] = buttons[ev_code]\n                                point['id'] += 1\n                                if '_avoid' in point:\n                                    del point['_avoid']\n                        elif 'button' in point:\n                            if point['button'] == buttons[ev_code]:\n                                del point['button']\n                                point['id'] += 1\n                                point['_avoid'] = True\n                    else:\n                        if not 0 <= ev_value <= 1:\n                            return\n\n                        if ev_code not in keyboard_keys:\n                            Logger.warn('HIDInput: unhandled HID code: {}'.\n                                        format(ev_code))\n                            return\n\n                        z = keyboard_keys[ev_code][-1 if 'shift' in\n                                                   Window._modifiers else 0]\n                        if z.lower() not in Keyboard.keycodes:\n                            # or if it is not in this LUT\n                            Logger.warn('HIDInput: unhandled character: {}'.\n                                        format(z))\n                            return\n\n                        keycode = Keyboard.keycodes[z.lower()]\n\n                        if ev_value == 1:\n                            if z == 'shift' or z == 'alt':\n                                Window._modifiers.append(z)\n                            elif z.endswith('ctrl'):\n                                Window._modifiers.append('ctrl')\n\n                            dispatch_queue.append(('key_down', (\n                                keycode, ev_code,\n                                keys_str.get(z, z), Window._modifiers)))\n                        elif ev_value == 0:\n                            dispatch_queue.append(('key_up', (\n                                keycode, ev_code,\n                                keys_str.get(z, z), Window._modifiers)))\n                            if ((z == 'shift' or z == 'alt') and\n                                    (z in Window._modifiers)):\n                                Window._modifiers.remove(z)\n                            elif (z.endswith('ctrl') and\n                                  'ctrl' in Window._modifiers):\n                                Window._modifiers.remove('ctrl')",
  "def process(points):\n                if not is_multitouch:\n                    dispatch_queue.append(('mouse_pos', (\n                        points[0]['x'] * Window.width,\n                        points[0]['y'] * Window.height)))\n\n                actives = [args['id']\n                           for args in points\n                           if 'id' in args and '_avoid' not in args]\n                for args in points:\n                    tid = args['id']\n                    try:\n                        touch = touches[tid]\n                        if touch.sx == args['x'] and touch.sy == args['y']:\n                            continue\n                        touch.move(args)\n                        if tid not in touches_sent:\n                            queue.append(('begin', touch))\n                            touches_sent.append(tid)\n                        queue.append(('update', touch))\n                    except KeyError:\n                        if '_avoid' not in args:\n                            touch = HIDMotionEvent(device, tid, args)\n                            touches[touch.id] = touch\n                            if tid not in touches_sent:\n                                queue.append(('begin', touch))\n                                touches_sent.append(tid)\n\n                for tid in list(touches.keys())[:]:\n                    if tid not in actives:\n                        touch = touches[tid]\n                        if tid in touches_sent:\n                            touch.update_time_end()\n                            queue.append(('end', touch))\n                            touches_sent.remove(tid)\n                        del touches[tid]",
  "def normalize(value, vmin, vmax):\n                return (value - vmin) / float(vmax - vmin)",
  "class MTDMotionEvent(MotionEvent):\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)\n\n    def depack(self, args):\n        if 'x' in args:\n            self.sx = args['x']\n        else:\n            self.sx = -1\n        if 'y' in args:\n            self.sy = args['y']\n        else:\n            self.sy = -1\n        self.profile = ['pos']\n        if 'size_w' in args and 'size_h' in args:\n            self.shape = ShapeRect()\n            self.shape.width = args['size_w']\n            self.shape.height = args['size_h']\n            self.profile.append('shape')\n        if 'pressure' in args:\n            self.pressure = args['pressure']\n            self.profile.append('pressure')\n        super().depack(args)\n\n    def __str__(self):\n        i, sx, sy, d = (self.id, self.sx, self.sy, self.device)\n        return '<MTDMotionEvent id=%d pos=(%f, %f) device=%s>' % (i, sx, sy, d)",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault('is_touch', True)\n        kwargs.setdefault('type_id', 'touch')\n        super().__init__(*args, **kwargs)",
  "def depack(self, args):\n        if 'x' in args:\n            self.sx = args['x']\n        else:\n            self.sx = -1\n        if 'y' in args:\n            self.sy = args['y']\n        else:\n            self.sy = -1\n        self.profile = ['pos']\n        if 'size_w' in args and 'size_h' in args:\n            self.shape = ShapeRect()\n            self.shape.width = args['size_w']\n            self.shape.height = args['size_h']\n            self.profile.append('shape')\n        if 'pressure' in args:\n            self.pressure = args['pressure']\n            self.profile.append('pressure')\n        super().depack(args)",
  "def __str__(self):\n        i, sx, sy, d = (self.id, self.sx, self.sy, self.device)\n        return '<MTDMotionEvent id=%d pos=(%f, %f) device=%s>' % (i, sx, sy, d)",
  "class MTDMotionEventProvider(MotionEventProvider):\n\n        options = ('min_position_x', 'max_position_x',\n                   'min_position_y', 'max_position_y',\n                   'min_pressure', 'max_pressure',\n                   'min_touch_major', 'max_touch_major',\n                   'min_touch_minor', 'max_touch_minor',\n                   'invert_x', 'invert_y',\n                   'rotation')\n\n        def __init__(self, device, args):\n            super(MTDMotionEventProvider, self).__init__(device, args)\n            self._device = None\n            self.input_fn = None\n            self.default_ranges = dict()\n\n            # split arguments\n            args = args.split(',')\n            if not args:\n                Logger.error('MTD: No filename pass to MTD configuration')\n                Logger.error('MTD: Use /dev/input/event0 for example')\n                return\n\n            # read filename\n            self.input_fn = args[0]\n            Logger.info('MTD: Read event from <%s>' % self.input_fn)\n\n            # read parameters\n            for arg in args[1:]:\n                if arg == '':\n                    continue\n                arg = arg.split('=')\n\n                # ensure it's a key = value\n                if len(arg) != 2:\n                    err = 'MTD: Bad parameter %s: Not in key=value format' %\\\n                        arg\n                    Logger.error(err)\n                    continue\n\n                # ensure the key exist\n                key, value = arg\n                if key not in MTDMotionEventProvider.options:\n                    Logger.error('MTD: unknown %s option' % key)\n                    continue\n\n                # ensure the value\n                try:\n                    self.default_ranges[key] = int(value)\n                except ValueError:\n                    err = 'MTD: invalid value %s for option %s' % (key, value)\n                    Logger.error(err)\n                    continue\n\n                # all good!\n                Logger.info('MTD: Set custom %s to %d' % (key, int(value)))\n\n            if 'rotation' not in self.default_ranges:\n                self.default_ranges['rotation'] = 0\n            elif self.default_ranges['rotation'] not in (0, 90, 180, 270):\n                Logger.error('HIDInput: invalid rotation value ({})'.format(\n                    self.default_ranges['rotation']))\n                self.default_ranges['rotation'] = 0\n\n        def start(self):\n            if self.input_fn is None:\n                return\n            self.uid = 0\n            self.queue = collections.deque()\n            self.thread = threading.Thread(\n                name=self.__class__.__name__,\n                target=self._thread_run,\n                kwargs=dict(\n                    queue=self.queue,\n                    input_fn=self.input_fn,\n                    device=self.device,\n                    default_ranges=self.default_ranges))\n            self.thread.daemon = True\n            self.thread.start()\n\n        def _thread_run(self, **kwargs):\n            input_fn = kwargs.get('input_fn')\n            queue = kwargs.get('queue')\n            device = kwargs.get('device')\n            drs = kwargs.get('default_ranges').get\n            touches = {}\n            touches_sent = []\n            point = {}\n            l_points = {}\n\n            def assign_coord(point, value, invert, coords):\n                cx, cy = coords\n                if invert:\n                    value = 1. - value\n                if rotation == 0:\n                    point[cx] = value\n                elif rotation == 90:\n                    point[cy] = value\n                elif rotation == 180:\n                    point[cx] = 1. - value\n                elif rotation == 270:\n                    point[cy] = 1. - value\n\n            def process(points):\n                for args in points:\n                    # this can happen if we have a touch going on already at\n                    # the start of the app\n                    if 'id' not in args:\n                        continue\n                    tid = args['id']\n                    try:\n                        touch = touches[tid]\n                    except KeyError:\n                        touch = MTDMotionEvent(device, tid, args)\n                        touches[touch.id] = touch\n                    touch.move(args)\n                    action = 'update'\n                    if tid not in touches_sent:\n                        action = 'begin'\n                        touches_sent.append(tid)\n                    if 'delete' in args:\n                        action = 'end'\n                        del args['delete']\n                        del touches[touch.id]\n                        touches_sent.remove(tid)\n                        touch.update_time_end()\n                    queue.append((action, touch))\n\n            def normalize(value, vmin, vmax):\n                try:\n                    return (value - vmin) / float(vmax - vmin)\n                except ZeroDivisionError:  # it's both in py2 and py3\n                    return (value - vmin)\n\n            # open mtdev device\n            _fn = input_fn\n            _slot = 0\n            try:\n                _device = Device(_fn)\n            except OSError as e:\n                if e.errno == 13:  # Permission denied\n                    Logger.warn(\n                        'MTD: Unable to open device \"{0}\". Please ensure you'\n                        ' have the appropriate permissions.'.format(_fn))\n                    return\n                else:\n                    raise\n            _changes = set()\n\n            # prepare some vars to get limit of some component\n            ab = _device.get_abs(MTDEV_ABS_POSITION_X)\n            range_min_position_x = drs('min_position_x', ab.minimum)\n            range_max_position_x = drs('max_position_x', ab.maximum)\n            Logger.info('MTD: <%s> range position X is %d - %d' %\n                        (_fn, range_min_position_x, range_max_position_x))\n\n            ab = _device.get_abs(MTDEV_ABS_POSITION_Y)\n            range_min_position_y = drs('min_position_y', ab.minimum)\n            range_max_position_y = drs('max_position_y', ab.maximum)\n            Logger.info('MTD: <%s> range position Y is %d - %d' %\n                        (_fn, range_min_position_y, range_max_position_y))\n\n            ab = _device.get_abs(MTDEV_ABS_TOUCH_MAJOR)\n            range_min_major = drs('min_touch_major', ab.minimum)\n            range_max_major = drs('max_touch_major', ab.maximum)\n            Logger.info('MTD: <%s> range touch major is %d - %d' %\n                        (_fn, range_min_major, range_max_major))\n\n            ab = _device.get_abs(MTDEV_ABS_TOUCH_MINOR)\n            range_min_minor = drs('min_touch_minor', ab.minimum)\n            range_max_minor = drs('max_touch_minor', ab.maximum)\n            Logger.info('MTD: <%s> range touch minor is %d - %d' %\n                        (_fn, range_min_minor, range_max_minor))\n\n            range_min_pressure = drs('min_pressure', 0)\n            range_max_pressure = drs('max_pressure', 255)\n            Logger.info('MTD: <%s> range pressure is %d - %d' %\n                        (_fn, range_min_pressure, range_max_pressure))\n\n            invert_x = int(bool(drs('invert_x', 0)))\n            invert_y = int(bool(drs('invert_y', 0)))\n            Logger.info('MTD: <%s> axes inversion: X is %d, Y is %d' %\n                        (_fn, invert_x, invert_y))\n\n            rotation = drs('rotation', 0)\n            Logger.info('MTD: <%s> rotation set to %d' %\n                        (_fn, rotation))\n            failures = 0\n            while _device:\n                # if device have disconnected lets try to connect\n                if failures > 1000:\n                    Logger.info('MTD: <%s> input device disconnected' % _fn)\n                    while not os.path.exists(_fn):\n                        time.sleep(0.05)\n                    # input device is back online let's recreate device\n                    _device.close()\n                    _device = Device(_fn)\n                    Logger.info('MTD: <%s> input device reconnected' % _fn)\n                    failures = 0\n                    continue\n\n                # idle as much as we can.\n                while _device.idle(1000):\n                    continue\n\n                # got data, read all without redoing idle\n                while True:\n                    data = _device.get()\n                    if data is None:\n                        failures += 1\n                        break\n\n                    failures = 0\n\n                    # set the working slot\n                    if data.type == MTDEV_TYPE_EV_ABS and \\\n                       data.code == MTDEV_CODE_SLOT:\n                        _slot = data.value\n                        continue\n\n                    # fill the slot\n                    if not (_slot in l_points):\n                        l_points[_slot] = dict()\n                    point = l_points[_slot]\n                    ev_value = data.value\n                    ev_code = data.code\n                    if ev_code == MTDEV_CODE_POSITION_X:\n                        val = normalize(ev_value,\n                                        range_min_position_x,\n                                        range_max_position_x)\n                        assign_coord(point, val, invert_x, 'xy')\n                    elif ev_code == MTDEV_CODE_POSITION_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_position_y,\n                                             range_max_position_y)\n                        assign_coord(point, val, invert_y, 'yx')\n                    elif ev_code == MTDEV_CODE_PRESSURE:\n                        point['pressure'] = normalize(ev_value,\n                                                      range_min_pressure,\n                                                      range_max_pressure)\n                    elif ev_code == MTDEV_CODE_TOUCH_MAJOR:\n                        point['size_w'] = normalize(ev_value,\n                                                    range_min_major,\n                                                    range_max_major)\n                    elif ev_code == MTDEV_CODE_TOUCH_MINOR:\n                        point['size_h'] = normalize(ev_value,\n                                                    range_min_minor,\n                                                    range_max_minor)\n                    elif ev_code == MTDEV_CODE_TRACKING_ID:\n                        if ev_value == -1:\n                            point['delete'] = True\n                            # force process of changes here, as the slot can be\n                            # reused.\n                            _changes.add(_slot)\n                            process([l_points[x] for x in _changes])\n                            _changes.clear()\n                            continue\n                        else:\n                            point['id'] = ev_value\n                    else:\n                        # unrecognized command, ignore.\n                        continue\n                    _changes.add(_slot)\n\n                # push all changes\n                if _changes:\n                    process([l_points[x] for x in _changes])\n                    _changes.clear()\n\n        def update(self, dispatch_fn):\n            # dispatch all event from threads\n            try:\n                while True:\n                    event_type, touch = self.queue.popleft()\n                    dispatch_fn(event_type, touch)\n            except:\n                pass",
  "def __init__(self, device, args):\n            super(MTDMotionEventProvider, self).__init__(device, args)\n            self._device = None\n            self.input_fn = None\n            self.default_ranges = dict()\n\n            # split arguments\n            args = args.split(',')\n            if not args:\n                Logger.error('MTD: No filename pass to MTD configuration')\n                Logger.error('MTD: Use /dev/input/event0 for example')\n                return\n\n            # read filename\n            self.input_fn = args[0]\n            Logger.info('MTD: Read event from <%s>' % self.input_fn)\n\n            # read parameters\n            for arg in args[1:]:\n                if arg == '':\n                    continue\n                arg = arg.split('=')\n\n                # ensure it's a key = value\n                if len(arg) != 2:\n                    err = 'MTD: Bad parameter %s: Not in key=value format' %\\\n                        arg\n                    Logger.error(err)\n                    continue\n\n                # ensure the key exist\n                key, value = arg\n                if key not in MTDMotionEventProvider.options:\n                    Logger.error('MTD: unknown %s option' % key)\n                    continue\n\n                # ensure the value\n                try:\n                    self.default_ranges[key] = int(value)\n                except ValueError:\n                    err = 'MTD: invalid value %s for option %s' % (key, value)\n                    Logger.error(err)\n                    continue\n\n                # all good!\n                Logger.info('MTD: Set custom %s to %d' % (key, int(value)))\n\n            if 'rotation' not in self.default_ranges:\n                self.default_ranges['rotation'] = 0\n            elif self.default_ranges['rotation'] not in (0, 90, 180, 270):\n                Logger.error('HIDInput: invalid rotation value ({})'.format(\n                    self.default_ranges['rotation']))\n                self.default_ranges['rotation'] = 0",
  "def start(self):\n            if self.input_fn is None:\n                return\n            self.uid = 0\n            self.queue = collections.deque()\n            self.thread = threading.Thread(\n                name=self.__class__.__name__,\n                target=self._thread_run,\n                kwargs=dict(\n                    queue=self.queue,\n                    input_fn=self.input_fn,\n                    device=self.device,\n                    default_ranges=self.default_ranges))\n            self.thread.daemon = True\n            self.thread.start()",
  "def _thread_run(self, **kwargs):\n            input_fn = kwargs.get('input_fn')\n            queue = kwargs.get('queue')\n            device = kwargs.get('device')\n            drs = kwargs.get('default_ranges').get\n            touches = {}\n            touches_sent = []\n            point = {}\n            l_points = {}\n\n            def assign_coord(point, value, invert, coords):\n                cx, cy = coords\n                if invert:\n                    value = 1. - value\n                if rotation == 0:\n                    point[cx] = value\n                elif rotation == 90:\n                    point[cy] = value\n                elif rotation == 180:\n                    point[cx] = 1. - value\n                elif rotation == 270:\n                    point[cy] = 1. - value\n\n            def process(points):\n                for args in points:\n                    # this can happen if we have a touch going on already at\n                    # the start of the app\n                    if 'id' not in args:\n                        continue\n                    tid = args['id']\n                    try:\n                        touch = touches[tid]\n                    except KeyError:\n                        touch = MTDMotionEvent(device, tid, args)\n                        touches[touch.id] = touch\n                    touch.move(args)\n                    action = 'update'\n                    if tid not in touches_sent:\n                        action = 'begin'\n                        touches_sent.append(tid)\n                    if 'delete' in args:\n                        action = 'end'\n                        del args['delete']\n                        del touches[touch.id]\n                        touches_sent.remove(tid)\n                        touch.update_time_end()\n                    queue.append((action, touch))\n\n            def normalize(value, vmin, vmax):\n                try:\n                    return (value - vmin) / float(vmax - vmin)\n                except ZeroDivisionError:  # it's both in py2 and py3\n                    return (value - vmin)\n\n            # open mtdev device\n            _fn = input_fn\n            _slot = 0\n            try:\n                _device = Device(_fn)\n            except OSError as e:\n                if e.errno == 13:  # Permission denied\n                    Logger.warn(\n                        'MTD: Unable to open device \"{0}\". Please ensure you'\n                        ' have the appropriate permissions.'.format(_fn))\n                    return\n                else:\n                    raise\n            _changes = set()\n\n            # prepare some vars to get limit of some component\n            ab = _device.get_abs(MTDEV_ABS_POSITION_X)\n            range_min_position_x = drs('min_position_x', ab.minimum)\n            range_max_position_x = drs('max_position_x', ab.maximum)\n            Logger.info('MTD: <%s> range position X is %d - %d' %\n                        (_fn, range_min_position_x, range_max_position_x))\n\n            ab = _device.get_abs(MTDEV_ABS_POSITION_Y)\n            range_min_position_y = drs('min_position_y', ab.minimum)\n            range_max_position_y = drs('max_position_y', ab.maximum)\n            Logger.info('MTD: <%s> range position Y is %d - %d' %\n                        (_fn, range_min_position_y, range_max_position_y))\n\n            ab = _device.get_abs(MTDEV_ABS_TOUCH_MAJOR)\n            range_min_major = drs('min_touch_major', ab.minimum)\n            range_max_major = drs('max_touch_major', ab.maximum)\n            Logger.info('MTD: <%s> range touch major is %d - %d' %\n                        (_fn, range_min_major, range_max_major))\n\n            ab = _device.get_abs(MTDEV_ABS_TOUCH_MINOR)\n            range_min_minor = drs('min_touch_minor', ab.minimum)\n            range_max_minor = drs('max_touch_minor', ab.maximum)\n            Logger.info('MTD: <%s> range touch minor is %d - %d' %\n                        (_fn, range_min_minor, range_max_minor))\n\n            range_min_pressure = drs('min_pressure', 0)\n            range_max_pressure = drs('max_pressure', 255)\n            Logger.info('MTD: <%s> range pressure is %d - %d' %\n                        (_fn, range_min_pressure, range_max_pressure))\n\n            invert_x = int(bool(drs('invert_x', 0)))\n            invert_y = int(bool(drs('invert_y', 0)))\n            Logger.info('MTD: <%s> axes inversion: X is %d, Y is %d' %\n                        (_fn, invert_x, invert_y))\n\n            rotation = drs('rotation', 0)\n            Logger.info('MTD: <%s> rotation set to %d' %\n                        (_fn, rotation))\n            failures = 0\n            while _device:\n                # if device have disconnected lets try to connect\n                if failures > 1000:\n                    Logger.info('MTD: <%s> input device disconnected' % _fn)\n                    while not os.path.exists(_fn):\n                        time.sleep(0.05)\n                    # input device is back online let's recreate device\n                    _device.close()\n                    _device = Device(_fn)\n                    Logger.info('MTD: <%s> input device reconnected' % _fn)\n                    failures = 0\n                    continue\n\n                # idle as much as we can.\n                while _device.idle(1000):\n                    continue\n\n                # got data, read all without redoing idle\n                while True:\n                    data = _device.get()\n                    if data is None:\n                        failures += 1\n                        break\n\n                    failures = 0\n\n                    # set the working slot\n                    if data.type == MTDEV_TYPE_EV_ABS and \\\n                       data.code == MTDEV_CODE_SLOT:\n                        _slot = data.value\n                        continue\n\n                    # fill the slot\n                    if not (_slot in l_points):\n                        l_points[_slot] = dict()\n                    point = l_points[_slot]\n                    ev_value = data.value\n                    ev_code = data.code\n                    if ev_code == MTDEV_CODE_POSITION_X:\n                        val = normalize(ev_value,\n                                        range_min_position_x,\n                                        range_max_position_x)\n                        assign_coord(point, val, invert_x, 'xy')\n                    elif ev_code == MTDEV_CODE_POSITION_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_position_y,\n                                             range_max_position_y)\n                        assign_coord(point, val, invert_y, 'yx')\n                    elif ev_code == MTDEV_CODE_PRESSURE:\n                        point['pressure'] = normalize(ev_value,\n                                                      range_min_pressure,\n                                                      range_max_pressure)\n                    elif ev_code == MTDEV_CODE_TOUCH_MAJOR:\n                        point['size_w'] = normalize(ev_value,\n                                                    range_min_major,\n                                                    range_max_major)\n                    elif ev_code == MTDEV_CODE_TOUCH_MINOR:\n                        point['size_h'] = normalize(ev_value,\n                                                    range_min_minor,\n                                                    range_max_minor)\n                    elif ev_code == MTDEV_CODE_TRACKING_ID:\n                        if ev_value == -1:\n                            point['delete'] = True\n                            # force process of changes here, as the slot can be\n                            # reused.\n                            _changes.add(_slot)\n                            process([l_points[x] for x in _changes])\n                            _changes.clear()\n                            continue\n                        else:\n                            point['id'] = ev_value\n                    else:\n                        # unrecognized command, ignore.\n                        continue\n                    _changes.add(_slot)\n\n                # push all changes\n                if _changes:\n                    process([l_points[x] for x in _changes])\n                    _changes.clear()",
  "def update(self, dispatch_fn):\n            # dispatch all event from threads\n            try:\n                while True:\n                    event_type, touch = self.queue.popleft()\n                    dispatch_fn(event_type, touch)\n            except:\n                pass",
  "def assign_coord(point, value, invert, coords):\n                cx, cy = coords\n                if invert:\n                    value = 1. - value\n                if rotation == 0:\n                    point[cx] = value\n                elif rotation == 90:\n                    point[cy] = value\n                elif rotation == 180:\n                    point[cx] = 1. - value\n                elif rotation == 270:\n                    point[cy] = 1. - value",
  "def process(points):\n                for args in points:\n                    # this can happen if we have a touch going on already at\n                    # the start of the app\n                    if 'id' not in args:\n                        continue\n                    tid = args['id']\n                    try:\n                        touch = touches[tid]\n                    except KeyError:\n                        touch = MTDMotionEvent(device, tid, args)\n                        touches[touch.id] = touch\n                    touch.move(args)\n                    action = 'update'\n                    if tid not in touches_sent:\n                        action = 'begin'\n                        touches_sent.append(tid)\n                    if 'delete' in args:\n                        action = 'end'\n                        del args['delete']\n                        del touches[touch.id]\n                        touches_sent.remove(tid)\n                        touch.update_time_end()\n                    queue.append((action, touch))",
  "def normalize(value, vmin, vmax):\n                try:\n                    return (value - vmin) / float(vmax - vmin)\n                except ZeroDivisionError:  # it's both in py2 and py3\n                    return (value - vmin)",
  "class InputPostprocCalibration(object):\n    '''Recalibrate the inputs.\n\n    The configuration must go within a section named `postproc:calibration`.\n    Within the section, you must have a line like::\n\n        devicename = param=value,param=value\n\n    If you wish to match by provider, you must have a line like::\n\n        (provider) = param=value,param=value\n\n    :Parameters:\n        `xratio`: float\n            Value to multiply X\n        `yratio`: float\n            Value to multiply Y\n        `xoffset`: float\n            Value to add to X\n        `yoffset`: float\n            Value to add to Y\n        `auto`: str\n            If set, then the touch is transformed from screen-relative\n            to window-relative The value is used as an indication of\n            screen size, e.g for fullHD:\n\n                auto=1920x1080\n\n            If present, this setting overrides all the others.\n            This assumes the input device exactly covers the display\n            area, if they are different, the computations will be wrong.\n\n    .. versionchanged:: 1.11.0\n        Added `auto` parameter\n    '''\n\n    def __init__(self):\n        super(InputPostprocCalibration, self).__init__()\n        self.devices = {}\n        self.frame = 0\n        self.provider_map = self._get_provider_map()\n        if not Config.has_section('postproc:calibration'):\n            return\n        default_params = {'xoffset': 0, 'yoffset': 0, 'xratio': 1, 'yratio': 1}\n        for device_key, params_str in Config.items('postproc:calibration'):\n            params = default_params.copy()\n            for param in params_str.split(','):\n                param = param.strip()\n                if not param:\n                    continue\n                key, value = param.split('=', 1)\n                if key == 'auto':\n                    width, height = [float(x) for x in value.split('x')]\n                    params['auto'] = width, height\n                    break\n                if key not in ('xoffset', 'yoffset', 'xratio', 'yratio'):\n                    Logger.error(\n                        'Calibration: invalid key provided: {}'.format(key))\n                params[key] = float(value)\n            self.devices[device_key] = params\n\n    def _get_provider_map(self):\n        \"\"\"Iterates through all registered input provider names and finds the\n        respective MotionEvent subclass for each. Returns a dict of MotionEvent\n        subclasses mapped to their provider name.\n        \"\"\"\n        provider_map = {}\n        for input_provider in MotionEventFactory.list():\n            if not hasattr(providers, input_provider):\n                continue\n\n            p = getattr(providers, input_provider)\n            for m in p.__all__:\n                event = getattr(p, m)\n                if issubclass(event, MotionEvent):\n                    provider_map[event] = input_provider\n\n        return provider_map\n\n    def _get_provider_key(self, event):\n        \"\"\"Returns the provider key for the event if the provider is configured\n        for calibration.\n        \"\"\"\n        input_type = self.provider_map.get(event.__class__)\n        key = '({})'.format(input_type)\n        if input_type and key in self.devices:\n            return key\n\n    def process(self, events):\n        # avoid doing any processing if there is no device to calibrate at all.\n        if not self.devices:\n            return events\n\n        self.frame += 1\n        frame = self.frame\n        to_remove = []\n        for etype, event in events:\n            # frame-based logic below doesn't account for\n            # end events having been already processed\n            if etype == 'end':\n                continue\n\n            if event.device in self.devices:\n                dev = event.device\n            else:\n                dev = self._get_provider_key(event)\n            if not dev:\n                continue\n\n            # some providers use the same event to update and end\n            if 'calibration:frame' not in event.ud:\n                event.ud['calibration:frame'] = frame\n            elif event.ud['calibration:frame'] == frame:\n                continue\n            event.ud['calibration:frame'] = frame\n\n            params = self.devices[dev]\n            if 'auto' in params:\n                event.sx, event.sy = self.auto_calibrate(\n                    event.sx, event.sy, params['auto'])\n                if not (0 <= event.sx <= 1 and 0 <= event.sy <= 1):\n                    to_remove.append((etype, event))\n            else:\n                event.sx = event.sx * params['xratio'] + params['xoffset']\n                event.sy = event.sy * params['yratio'] + params['yoffset']\n\n        for event in to_remove:\n            events.remove(event)\n\n        return events\n\n    def auto_calibrate(self, sx, sy, size):\n        from kivy.core.window import Window as W\n        WIDTH, HEIGHT = size\n\n        xratio = WIDTH / W.width\n        yratio = HEIGHT / W.height\n\n        xoffset = - W.left / W.width\n        yoffset = - (HEIGHT - W.top - W.height) / W.height\n\n        sx = sx * xratio + xoffset\n        sy = sy * yratio + yoffset\n\n        return sx, sy",
  "def __init__(self):\n        super(InputPostprocCalibration, self).__init__()\n        self.devices = {}\n        self.frame = 0\n        self.provider_map = self._get_provider_map()\n        if not Config.has_section('postproc:calibration'):\n            return\n        default_params = {'xoffset': 0, 'yoffset': 0, 'xratio': 1, 'yratio': 1}\n        for device_key, params_str in Config.items('postproc:calibration'):\n            params = default_params.copy()\n            for param in params_str.split(','):\n                param = param.strip()\n                if not param:\n                    continue\n                key, value = param.split('=', 1)\n                if key == 'auto':\n                    width, height = [float(x) for x in value.split('x')]\n                    params['auto'] = width, height\n                    break\n                if key not in ('xoffset', 'yoffset', 'xratio', 'yratio'):\n                    Logger.error(\n                        'Calibration: invalid key provided: {}'.format(key))\n                params[key] = float(value)\n            self.devices[device_key] = params",
  "def _get_provider_map(self):\n        \"\"\"Iterates through all registered input provider names and finds the\n        respective MotionEvent subclass for each. Returns a dict of MotionEvent\n        subclasses mapped to their provider name.\n        \"\"\"\n        provider_map = {}\n        for input_provider in MotionEventFactory.list():\n            if not hasattr(providers, input_provider):\n                continue\n\n            p = getattr(providers, input_provider)\n            for m in p.__all__:\n                event = getattr(p, m)\n                if issubclass(event, MotionEvent):\n                    provider_map[event] = input_provider\n\n        return provider_map",
  "def _get_provider_key(self, event):\n        \"\"\"Returns the provider key for the event if the provider is configured\n        for calibration.\n        \"\"\"\n        input_type = self.provider_map.get(event.__class__)\n        key = '({})'.format(input_type)\n        if input_type and key in self.devices:\n            return key",
  "def process(self, events):\n        # avoid doing any processing if there is no device to calibrate at all.\n        if not self.devices:\n            return events\n\n        self.frame += 1\n        frame = self.frame\n        to_remove = []\n        for etype, event in events:\n            # frame-based logic below doesn't account for\n            # end events having been already processed\n            if etype == 'end':\n                continue\n\n            if event.device in self.devices:\n                dev = event.device\n            else:\n                dev = self._get_provider_key(event)\n            if not dev:\n                continue\n\n            # some providers use the same event to update and end\n            if 'calibration:frame' not in event.ud:\n                event.ud['calibration:frame'] = frame\n            elif event.ud['calibration:frame'] == frame:\n                continue\n            event.ud['calibration:frame'] = frame\n\n            params = self.devices[dev]\n            if 'auto' in params:\n                event.sx, event.sy = self.auto_calibrate(\n                    event.sx, event.sy, params['auto'])\n                if not (0 <= event.sx <= 1 and 0 <= event.sy <= 1):\n                    to_remove.append((etype, event))\n            else:\n                event.sx = event.sx * params['xratio'] + params['xoffset']\n                event.sy = event.sy * params['yratio'] + params['yoffset']\n\n        for event in to_remove:\n            events.remove(event)\n\n        return events",
  "def auto_calibrate(self, sx, sy, size):\n        from kivy.core.window import Window as W\n        WIDTH, HEIGHT = size\n\n        xratio = WIDTH / W.width\n        yratio = HEIGHT / W.height\n\n        xoffset = - W.left / W.width\n        yoffset = - (HEIGHT - W.top - W.height) / W.height\n\n        sx = sx * xratio + xoffset\n        sy = sy * yratio + yoffset\n\n        return sx, sy",
  "class InputPostprocDoubleTap(object):\n    '''\n    InputPostProcDoubleTap is a post-processor to check if\n    a touch is a double tap or not.\n    Double tap can be configured in the Kivy config file::\n\n        [postproc]\n        double_tap_time = 250\n        double_tap_distance = 20\n\n    Distance parameter is in the range 0-1000 and time is in milliseconds.\n    '''\n\n    def __init__(self):\n        dist = Config.getint('postproc', 'double_tap_distance')\n        self.double_tap_distance = dist / 1000.0\n        tap_time = Config.getint('postproc', 'double_tap_time')\n        self.double_tap_time = tap_time / 1000.0\n        self.touches = {}\n\n    def find_double_tap(self, ref):\n        '''Find a double tap touch within self.touches.\n        The touch must be not a previous double tap and the distance must be\n        within the specified threshold. Additionally, the touch profiles\n        must be the same kind of touch.\n        '''\n        ref_button = None\n        if 'button' in ref.profile:\n            ref_button = ref.button\n\n        for touchid in self.touches:\n            if ref.uid == touchid:\n                continue\n            etype, touch = self.touches[touchid]\n            if etype != 'end':\n                continue\n            if touch.is_double_tap:\n                continue\n            distance = Vector.distance(\n                Vector(ref.sx, ref.sy),\n                Vector(touch.osx, touch.osy))\n            if distance > self.double_tap_distance:\n                continue\n            if touch.is_mouse_scrolling or ref.is_mouse_scrolling:\n                continue\n            touch_button = None\n            if 'button' in touch.profile:\n                touch_button = touch.button\n            if touch_button != ref_button:\n                continue\n            touch.double_tap_distance = distance\n            return touch\n\n    def process(self, events):\n        if self.double_tap_distance == 0 or self.double_tap_time == 0:\n            return events\n        # first, check if a touch down have a double tap\n        for etype, touch in events:\n            if not touch.is_touch:\n                continue\n            if etype == 'begin':\n                double_tap = self.find_double_tap(touch)\n                if double_tap:\n                    touch.is_double_tap = True\n                    tap_time = touch.time_start - double_tap.time_start\n                    touch.double_tap_time = tap_time\n                    distance = double_tap.double_tap_distance\n                    touch.double_tap_distance = distance\n\n            # add the touch internally\n            self.touches[touch.uid] = (etype, touch)\n\n        # second, check if up-touch is timeout for double tap\n        time_current = time()\n        to_delete = []\n        for touchid in self.touches.keys():\n            etype, touch = self.touches[touchid]\n            if etype != 'end':\n                continue\n            if time_current - touch.time_start < self.double_tap_time:\n                continue\n            to_delete.append(touchid)\n\n        for touchid in to_delete:\n            del self.touches[touchid]\n\n        return events",
  "def __init__(self):\n        dist = Config.getint('postproc', 'double_tap_distance')\n        self.double_tap_distance = dist / 1000.0\n        tap_time = Config.getint('postproc', 'double_tap_time')\n        self.double_tap_time = tap_time / 1000.0\n        self.touches = {}",
  "def find_double_tap(self, ref):\n        '''Find a double tap touch within self.touches.\n        The touch must be not a previous double tap and the distance must be\n        within the specified threshold. Additionally, the touch profiles\n        must be the same kind of touch.\n        '''\n        ref_button = None\n        if 'button' in ref.profile:\n            ref_button = ref.button\n\n        for touchid in self.touches:\n            if ref.uid == touchid:\n                continue\n            etype, touch = self.touches[touchid]\n            if etype != 'end':\n                continue\n            if touch.is_double_tap:\n                continue\n            distance = Vector.distance(\n                Vector(ref.sx, ref.sy),\n                Vector(touch.osx, touch.osy))\n            if distance > self.double_tap_distance:\n                continue\n            if touch.is_mouse_scrolling or ref.is_mouse_scrolling:\n                continue\n            touch_button = None\n            if 'button' in touch.profile:\n                touch_button = touch.button\n            if touch_button != ref_button:\n                continue\n            touch.double_tap_distance = distance\n            return touch",
  "def process(self, events):\n        if self.double_tap_distance == 0 or self.double_tap_time == 0:\n            return events\n        # first, check if a touch down have a double tap\n        for etype, touch in events:\n            if not touch.is_touch:\n                continue\n            if etype == 'begin':\n                double_tap = self.find_double_tap(touch)\n                if double_tap:\n                    touch.is_double_tap = True\n                    tap_time = touch.time_start - double_tap.time_start\n                    touch.double_tap_time = tap_time\n                    distance = double_tap.double_tap_distance\n                    touch.double_tap_distance = distance\n\n            # add the touch internally\n            self.touches[touch.uid] = (etype, touch)\n\n        # second, check if up-touch is timeout for double tap\n        time_current = time()\n        to_delete = []\n        for touchid in self.touches.keys():\n            etype, touch = self.touches[touchid]\n            if etype != 'end':\n                continue\n            if time_current - touch.time_start < self.double_tap_time:\n                continue\n            to_delete.append(touchid)\n\n        for touchid in to_delete:\n            del self.touches[touchid]\n\n        return events",
  "class InputPostprocTripleTap(object):\n    '''\n    InputPostProcTripleTap is a post-processor to check if\n    a touch is a triple tap or not.\n    Triple tap can be configured in the Kivy config file::\n\n        [postproc]\n        triple_tap_time = 250\n        triple_tap_distance = 20\n\n    The distance parameter is in the range 0-1000 and time is in milliseconds.\n    '''\n\n    def __init__(self):\n        dist = Config.getint('postproc', 'triple_tap_distance')\n        self.triple_tap_distance = dist / 1000.0\n        time = Config.getint('postproc', 'triple_tap_time')\n        self.triple_tap_time = time / 1000.0\n        self.touches = {}\n\n    def find_triple_tap(self, ref):\n        '''Find a triple tap touch within *self.touches*.\n        The touch must be not be a previous triple tap and the distance\n        must be within the bounds specified. Additionally, the touch profile\n        must be the same kind of touch.\n        '''\n        ref_button = None\n        if 'button' in ref.profile:\n            ref_button = ref.button\n\n        for touchid in self.touches:\n            if ref.uid == touchid:\n                continue\n            etype, touch = self.touches[touchid]\n            if not touch.is_double_tap:\n                continue\n            if etype != 'end':\n                continue\n            if touch.is_triple_tap:\n                continue\n            distance = Vector.distance(\n                Vector(ref.sx, ref.sy),\n                Vector(touch.osx, touch.osy))\n            if distance > self.triple_tap_distance:\n                continue\n            if touch.is_mouse_scrolling or ref.is_mouse_scrolling:\n                continue\n            touch_button = None\n            if 'button' in touch.profile:\n                touch_button = touch.button\n            if touch_button != ref_button:\n                continue\n            touch.triple_tap_distance = distance\n            return touch\n\n    def process(self, events):\n        if self.triple_tap_distance == 0 or self.triple_tap_time == 0:\n            return events\n        # first, check if a touch down have a triple tap\n        for etype, touch in events:\n            if not touch.is_touch:\n                continue\n            if etype == 'begin':\n                triple_tap = self.find_triple_tap(touch)\n                if triple_tap:\n                    touch.is_double_tap = False\n                    touch.is_triple_tap = True\n                    tap_time = touch.time_start - triple_tap.time_start\n                    touch.triple_tap_time = tap_time\n                    distance = triple_tap.triple_tap_distance\n                    touch.triple_tap_distance = distance\n\n            # add the touch internally\n            self.touches[touch.uid] = (etype, touch)\n\n        # second, check if up-touch is timeout for triple tap\n        time_current = time()\n        to_delete = []\n        for touchid in self.touches.keys():\n            etype, touch = self.touches[touchid]\n            if etype != 'end':\n                continue\n            if time_current - touch.time_start < self.triple_tap_time:\n                continue\n            to_delete.append(touchid)\n\n        for touchid in to_delete:\n            del self.touches[touchid]\n\n        return events",
  "def __init__(self):\n        dist = Config.getint('postproc', 'triple_tap_distance')\n        self.triple_tap_distance = dist / 1000.0\n        time = Config.getint('postproc', 'triple_tap_time')\n        self.triple_tap_time = time / 1000.0\n        self.touches = {}",
  "def find_triple_tap(self, ref):\n        '''Find a triple tap touch within *self.touches*.\n        The touch must be not be a previous triple tap and the distance\n        must be within the bounds specified. Additionally, the touch profile\n        must be the same kind of touch.\n        '''\n        ref_button = None\n        if 'button' in ref.profile:\n            ref_button = ref.button\n\n        for touchid in self.touches:\n            if ref.uid == touchid:\n                continue\n            etype, touch = self.touches[touchid]\n            if not touch.is_double_tap:\n                continue\n            if etype != 'end':\n                continue\n            if touch.is_triple_tap:\n                continue\n            distance = Vector.distance(\n                Vector(ref.sx, ref.sy),\n                Vector(touch.osx, touch.osy))\n            if distance > self.triple_tap_distance:\n                continue\n            if touch.is_mouse_scrolling or ref.is_mouse_scrolling:\n                continue\n            touch_button = None\n            if 'button' in touch.profile:\n                touch_button = touch.button\n            if touch_button != ref_button:\n                continue\n            touch.triple_tap_distance = distance\n            return touch",
  "def process(self, events):\n        if self.triple_tap_distance == 0 or self.triple_tap_time == 0:\n            return events\n        # first, check if a touch down have a triple tap\n        for etype, touch in events:\n            if not touch.is_touch:\n                continue\n            if etype == 'begin':\n                triple_tap = self.find_triple_tap(touch)\n                if triple_tap:\n                    touch.is_double_tap = False\n                    touch.is_triple_tap = True\n                    tap_time = touch.time_start - triple_tap.time_start\n                    touch.triple_tap_time = tap_time\n                    distance = triple_tap.triple_tap_distance\n                    touch.triple_tap_distance = distance\n\n            # add the touch internally\n            self.touches[touch.uid] = (etype, touch)\n\n        # second, check if up-touch is timeout for triple tap\n        time_current = time()\n        to_delete = []\n        for touchid in self.touches.keys():\n            etype, touch = self.touches[touchid]\n            if etype != 'end':\n                continue\n            if time_current - touch.time_start < self.triple_tap_time:\n                continue\n            to_delete.append(touchid)\n\n        for touchid in to_delete:\n            del self.touches[touchid]\n\n        return events",
  "class InputPostprocDejitter(object):\n    '''\n    Get rid of jitterish BLOBs.\n    Example::\n\n        [postproc]\n        jitter_distance = 0.004\n        jitter_ignore_devices = mouse,mactouch\n\n    :Configuration:\n        `jitter_distance`: float\n            A float in range 0-1.\n        `jitter_ignore_devices`: string\n            A comma-separated list of device identifiers that\n            should not be processed by dejitter (because they're\n            very precise already).\n    '''\n\n    def __init__(self):\n        self.jitterdist = Config.getfloat('postproc', 'jitter_distance')\n        ignore_devices = Config.get('postproc', 'jitter_ignore_devices')\n        self.ignore_devices = ignore_devices.split(',')\n        self.last_touches = {}\n\n    def taxicab_distance(self, p, q):\n        # Get the taxicab/manhattan/citiblock distance for efficiency reasons\n        return abs(p[0] - q[0]) + abs(p[1] - q[1])\n\n    def process(self, events):\n        if not self.jitterdist:\n            return events\n        processed = []\n        for etype, touch in events:\n            if not touch.is_touch:\n                continue\n            if touch.device in self.ignore_devices:\n                processed.append((etype, touch))\n                continue\n            if etype == 'begin':\n                self.last_touches[touch.id] = touch.spos\n            if etype == 'end':\n                if touch.id in self.last_touches:\n                    del self.last_touches[touch.id]\n            if etype != 'update':\n                processed.append((etype, touch))\n                continue\n            # Check whether the touch moved more than the jitter distance\n            last_spos = self.last_touches[touch.id]\n            dist = self.taxicab_distance(last_spos, touch.spos)\n            if dist > self.jitterdist:\n                # Only if the touch has moved more than the jitter dist we take\n                # it into account and dispatch it. Otherwise suppress it.\n                self.last_touches[touch.id] = touch.spos\n                processed.append((etype, touch))\n        return processed",
  "def __init__(self):\n        self.jitterdist = Config.getfloat('postproc', 'jitter_distance')\n        ignore_devices = Config.get('postproc', 'jitter_ignore_devices')\n        self.ignore_devices = ignore_devices.split(',')\n        self.last_touches = {}",
  "def taxicab_distance(self, p, q):\n        # Get the taxicab/manhattan/citiblock distance for efficiency reasons\n        return abs(p[0] - q[0]) + abs(p[1] - q[1])",
  "def process(self, events):\n        if not self.jitterdist:\n            return events\n        processed = []\n        for etype, touch in events:\n            if not touch.is_touch:\n                continue\n            if touch.device in self.ignore_devices:\n                processed.append((etype, touch))\n                continue\n            if etype == 'begin':\n                self.last_touches[touch.id] = touch.spos\n            if etype == 'end':\n                if touch.id in self.last_touches:\n                    del self.last_touches[touch.id]\n            if etype != 'update':\n                processed.append((etype, touch))\n                continue\n            # Check whether the touch moved more than the jitter distance\n            last_spos = self.last_touches[touch.id]\n            dist = self.taxicab_distance(last_spos, touch.spos)\n            if dist > self.jitterdist:\n                # Only if the touch has moved more than the jitter dist we take\n                # it into account and dispatch it. Otherwise suppress it.\n                self.last_touches[touch.id] = touch.spos\n                processed.append((etype, touch))\n        return processed",
  "class InputPostprocIgnoreList(object):\n    '''\n    InputPostprocIgnoreList is a post-processor which removes touches in the\n    Ignore list. The Ignore list can be configured in the Kivy config file::\n\n        [postproc]\n        # Format: [(xmin, ymin, xmax, ymax), ...]\n        ignore = [(0.1, 0.1, 0.15, 0.15)]\n\n    The Ignore list coordinates are in the range 0-1, not in screen pixels.\n    '''\n\n    def __init__(self):\n        self.ignore_list = strtotuple(Config.get('postproc', 'ignore'))\n\n    def collide_ignore(self, touch):\n        x, y = touch.sx, touch.sy\n        for l in self.ignore_list:\n            xmin, ymin, xmax, ymax = l\n            if x > xmin and x < xmax and y > ymin and y < ymax:\n                return True\n\n    def process(self, events):\n        if not len(self.ignore_list):\n            return events\n        for etype, touch in events:\n            if not touch.is_touch:\n                continue\n            if etype != 'begin':\n                continue\n            if self.collide_ignore(touch):\n                touch.ud.__pp_ignore__ = True\n        return [(etype, touch) for etype, touch in events\n                if '__pp_ignore__' not in touch.ud]",
  "def __init__(self):\n        self.ignore_list = strtotuple(Config.get('postproc', 'ignore'))",
  "def collide_ignore(self, touch):\n        x, y = touch.sx, touch.sy\n        for l in self.ignore_list:\n            xmin, ymin, xmax, ymax = l\n            if x > xmin and x < xmax and y > ymin and y < ymax:\n                return True",
  "def process(self, events):\n        if not len(self.ignore_list):\n            return events\n        for etype, touch in events:\n            if not touch.is_touch:\n                continue\n            if etype != 'begin':\n                continue\n            if self.collide_ignore(touch):\n                touch.ud.__pp_ignore__ = True\n        return [(etype, touch) for etype, touch in events\n                if '__pp_ignore__' not in touch.ud]",
  "class InputPostprocRetainTouch(object):\n    '''\n    InputPostprocRetainTouch is a post-processor to delay the 'up' event of a\n    touch, to reuse it under certains conditions. This module is designed to\n    prevent lost finger touches on some hardware/setups.\n\n    Retain touch can be configured in the Kivy config file::\n\n        [postproc]\n            retain_time = 100\n            retain_distance = 50\n\n    The distance parameter is in the range 0-1000 and time is in milliseconds.\n    '''\n\n    def __init__(self):\n        self.timeout = Config.getint('postproc', 'retain_time') / 1000.0\n        self.distance = Config.getint('postproc', 'retain_distance') / 1000.0\n        self._available = []\n        self._links = {}\n\n    def process(self, events):\n        # check if module is disabled\n        if self.timeout == 0:\n            return events\n\n        d = time.time()\n        for etype, touch in events[:]:\n            if not touch.is_touch:\n                continue\n            if etype == 'end':\n                events.remove((etype, touch))\n                if touch.uid in self._links:\n                    selection = self._links[touch.uid]\n                    selection.ud.__pp_retain_time__ = d\n                    self._available.append(selection)\n                    del self._links[touch.uid]\n                else:\n                    touch.ud.__pp_retain_time__ = d\n                    self._available.append(touch)\n            elif etype == 'update':\n                if touch.uid in self._links:\n                    selection = self._links[touch.uid]\n                    selection.x = touch.x\n                    selection.y = touch.y\n                    selection.sx = touch.sx\n                    selection.sy = touch.sy\n                    events.remove((etype, touch))\n                    events.append((etype, selection))\n                else:\n                    pass\n            elif etype == 'begin':\n                # new touch, found the nearest one\n                selection = None\n                selection_distance = 99999\n                for touch2 in self._available:\n                    touch_distance = Vector(touch2.spos).distance(touch.spos)\n                    if touch_distance > self.distance:\n                        continue\n                    if touch2.__class__ != touch.__class__:\n                        continue\n                    if touch_distance < selection_distance:\n                        # eligible for continuation\n                        selection_distance = touch_distance\n                        selection = touch2\n                if selection is None:\n                    continue\n\n                self._links[touch.uid] = selection\n                self._available.remove(selection)\n                events.remove((etype, touch))\n\n        for touch in self._available[:]:\n            t = touch.ud.__pp_retain_time__\n            if d - t > self.timeout:\n                self._available.remove(touch)\n                events.append(('end', touch))\n\n        return events",
  "def __init__(self):\n        self.timeout = Config.getint('postproc', 'retain_time') / 1000.0\n        self.distance = Config.getint('postproc', 'retain_distance') / 1000.0\n        self._available = []\n        self._links = {}",
  "def process(self, events):\n        # check if module is disabled\n        if self.timeout == 0:\n            return events\n\n        d = time.time()\n        for etype, touch in events[:]:\n            if not touch.is_touch:\n                continue\n            if etype == 'end':\n                events.remove((etype, touch))\n                if touch.uid in self._links:\n                    selection = self._links[touch.uid]\n                    selection.ud.__pp_retain_time__ = d\n                    self._available.append(selection)\n                    del self._links[touch.uid]\n                else:\n                    touch.ud.__pp_retain_time__ = d\n                    self._available.append(touch)\n            elif etype == 'update':\n                if touch.uid in self._links:\n                    selection = self._links[touch.uid]\n                    selection.x = touch.x\n                    selection.y = touch.y\n                    selection.sx = touch.sx\n                    selection.sy = touch.sy\n                    events.remove((etype, touch))\n                    events.append((etype, selection))\n                else:\n                    pass\n            elif etype == 'begin':\n                # new touch, found the nearest one\n                selection = None\n                selection_distance = 99999\n                for touch2 in self._available:\n                    touch_distance = Vector(touch2.spos).distance(touch.spos)\n                    if touch_distance > self.distance:\n                        continue\n                    if touch2.__class__ != touch.__class__:\n                        continue\n                    if touch_distance < selection_distance:\n                        # eligible for continuation\n                        selection_distance = touch_distance\n                        selection = touch2\n                if selection is None:\n                    continue\n\n                self._links[touch.uid] = selection\n                self._available.remove(selection)\n                events.remove((etype, touch))\n\n        for touch in self._available[:]:\n            t = touch.ud.__pp_retain_time__\n            if d - t > self.timeout:\n                self._available.remove(touch)\n                events.append(('end', touch))\n\n        return events",
  "def dxt_to_str(dxt):\n    if dxt == DDS_DXT1:\n        return 's3tc_dxt1'\n    elif dxt == DDS_DXT2:\n        return 's3tc_dxt2'\n    elif dxt == DDS_DXT3:\n        return 's3tc_dxt3'\n    elif dxt == DDS_DXT4:\n        return 's3tc_dxt4'\n    elif dxt == DDS_DXT5:\n        return 's3tc_dxt5'\n    elif dxt == 0:\n        return 'rgba'\n    elif dxt == 1:\n        return 'alpha'\n    elif dxt == 2:\n        return 'luminance'\n    elif dxt == 3:\n        return 'luminance_alpha'",
  "def str_to_dxt(dxt):\n    if dxt == 's3tc_dxt1':\n        return DDS_DXT1\n    if dxt == 's3tc_dxt2':\n        return DDS_DXT2\n    if dxt == 's3tc_dxt3':\n        return DDS_DXT3\n    if dxt == 's3tc_dxt4':\n        return DDS_DXT4\n    if dxt == 's3tc_dxt5':\n        return DDS_DXT5\n    if dxt == 'rgba':\n        return 0\n    if dxt == 'alpha':\n        return 1\n    if dxt == 'luminance':\n        return 2\n    if dxt == 'luminance_alpha':\n        return 3",
  "def align_value(val, b):\n    return val + (-val % b)",
  "def check_flags(val, fl):\n    return (val & fl) == fl",
  "def dxt_size(w, h, dxt):\n    w = max(1, w // 4)\n    h = max(1, h // 4)\n    if dxt == DDS_DXT1:\n        return w * h * 8\n    elif dxt in (DDS_DXT2, DDS_DXT3, DDS_DXT4, DDS_DXT5):\n        return w * h * 16\n    return -1",
  "class QueryDict(dict):\n    def __getattr__(self, attr):\n        try:\n            return self.__getitem__(attr)\n        except KeyError:\n            try:\n                return super(QueryDict, self).__getattr__(attr)\n            except AttributeError:\n                raise KeyError(attr)\n\n    def __setattr__(self, attr, value):\n        self.__setitem__(attr, value)",
  "class DDSException(Exception):\n    pass",
  "class DDSFile(object):\n    fields = (\n        ('size', 0), ('flags', 1), ('height', 2),\n        ('width', 3), ('pitchOrLinearSize', 4), ('depth', 5),\n        ('mipmapCount', 6), ('pf_size', 18), ('pf_flags', 19),\n        ('pf_fourcc', 20), ('pf_rgbBitCount', 21), ('pf_rBitMask', 22),\n        ('pf_gBitMask', 23), ('pf_bBitMask', 24), ('pf_aBitMask', 25),\n        ('caps1', 26), ('caps2', 27))\n\n    def __init__(self, filename=None):\n        super(DDSFile, self).__init__()\n        self._dxt = 0\n        self._fmt = None\n        self.meta = meta = QueryDict()\n        self.count = 0\n        self.images = []\n        self.images_size = []\n        for field, index in DDSFile.fields:\n            meta[field] = 0\n        if filename:\n            self.load(filename)\n\n    def load(self, filename):\n        self.filename = filename\n        with open(filename, 'rb') as fd:\n            data = fd.read()\n\n        if data[:4] != b'DDS ':\n            raise DDSException('Invalid magic header {}'.format(data[:4]))\n\n        # read header\n        fmt = 'I' * 31\n        fmt_size = calcsize(fmt)\n        pf_size = calcsize('I' * 8)\n        header, data = data[4:4+fmt_size], data[4+fmt_size:]\n        if len(header) != fmt_size:\n            raise DDSException('Truncated header in')\n\n        # depack\n        header = unpack(fmt, header)\n        meta = self.meta\n        for name, index in DDSFile.fields:\n            meta[name] = header[index]\n\n        # check header validity\n        if meta.size != fmt_size:\n            raise DDSException('Invalid header size (%d instead of %d)' %\n                    (meta.size, fmt_size))\n        if meta.pf_size != pf_size:\n            raise DDSException('Invalid pixelformat size (%d instead of %d)' %\n                    (meta.pf_size, pf_size))\n        if not check_flags(meta.flags,\n                DDSD_CAPS | DDSD_PIXELFORMAT | DDSD_WIDTH | DDSD_HEIGHT):\n            raise DDSException('Not enough flags')\n        if not check_flags(meta.caps1, DDSCAPS_TEXTURE):\n            raise DDSException('Not a DDS texture')\n\n        self.count = 1\n        if check_flags(meta.flags, DDSD_MIPMAPCOUNT):\n            if not check_flags(meta.caps1, DDSCAPS_COMPLEX | DDSCAPS_MIPMAP):\n                raise DDSException('Invalid mipmap without flags')\n            self.count = meta.mipmapCount\n\n        hasrgb = check_flags(meta.pf_flags, DDPF_RGB)\n        hasalpha = check_flags(meta.pf_flags, DDPF_ALPHAPIXELS)\n        hasluminance = check_flags(meta.pf_flags, DDPF_LUMINANCE)\n        bpp = None\n        dxt = block = pitch = 0\n        if hasrgb or hasalpha or hasluminance:\n            bpp = meta.pf_rgbBitCount\n\n        if hasrgb and hasluminance:\n            raise DDSException('File have RGB and Luminance')\n\n        if hasrgb:\n            dxt = 0\n        elif hasalpha and not hasluminance:\n            dxt = 1\n        elif hasluminance and not hasalpha:\n            dxt = 2\n        elif hasalpha and hasluminance:\n            dxt = 3\n        elif check_flags(meta.pf_flags, DDPF_FOURCC):\n            dxt = meta.pf_fourcc\n            if dxt not in (DDS_DXT1, DDS_DXT2, DDS_DXT3, DDS_DXT4, DDS_DXT5):\n                raise DDSException('Unsupported FOURCC')\n        else:\n            raise DDSException('Unsupported format specified')\n\n        if bpp:\n            block = align_value(bpp, 8) // 8\n            pitch = align_value(block * meta.width, 4)\n\n        if check_flags(meta.flags, DDSD_LINEARSIZE):\n            if dxt in (0, 1, 2, 3):\n                size = pitch * meta.height\n            else:\n                size = dxt_size(meta.width, meta.height, dxt)\n\n        w = meta.width\n        h = meta.height\n        images = self.images\n        images_size = self.images_size\n        for i in range(self.count):\n            if dxt in (0, 1, 2, 3):\n                size = align_value(block * w, 4) * h\n            else:\n                size = dxt_size(w, h, dxt)\n            image, data = data[:size], data[size:]\n            if len(image) < size:\n                raise DDSException('Truncated image for mipmap %d' % i)\n            images_size.append((w, h))\n            images.append(image)\n            if w == 1 and h == 1:\n                break\n            w = max(1, w // 2)\n            h = max(1, h // 2)\n\n        if len(images) == 0:\n            raise DDSException('No images available')\n        if len(images) < self.count:\n            raise DDSException('Not enough images')\n\n        self._dxt = dxt\n\n    def save(self, filename):\n        if len(self.images) == 0:\n            raise DDSException('No images to save')\n\n        fields = dict(DDSFile.fields)\n        fields_keys = list(fields.keys())\n        fields_index = list(fields.values())\n        mget = self.meta.get\n        header = []\n        for idx in range(31):\n            if idx in fields_index:\n                value = mget(fields_keys[fields_index.index(idx)], 0)\n            else:\n                value = 0\n            header.append(value)\n\n        with open(filename, 'wb') as fd:\n            fd.write('DDS ')\n            fd.write(pack('I' * 31, *header))\n            for image in self.images:\n                fd.write(image)\n\n    def add_image(self, level, bpp, fmt, width, height, data):\n        assert bpp == 32\n        assert fmt in ('rgb', 'rgba', 'dxt1', 'dxt2', 'dxt3', 'dxt4', 'dxt5')\n        assert width > 0\n        assert height > 0\n        assert level >= 0\n\n        meta = self.meta\n        images = self.images\n        if len(images) == 0:\n            assert level == 0\n\n            # first image, set defaults !\n            for k in meta.keys():\n                meta[k] = 0\n\n            self._fmt = fmt\n            meta.size = calcsize('I' * 31)\n            meta.pf_size = calcsize('I' * 8)\n            meta.pf_flags = 0\n            meta.flags = DDSD_CAPS | DDSD_PIXELFORMAT | DDSD_WIDTH | DDSD_HEIGHT\n            meta.width = width\n            meta.height = height\n            meta.caps1 = DDSCAPS_TEXTURE\n\n            meta.flags |= DDSD_LINEARSIZE\n            meta.pitchOrLinearSize = len(data)\n\n            meta.pf_rgbBitCount = 32\n            meta.pf_rBitMask = 0x00ff0000\n            meta.pf_gBitMask = 0x0000ff00\n            meta.pf_bBitMask = 0x000000ff\n            meta.pf_aBitMask = 0xff000000\n\n            if fmt in ('rgb', 'rgba'):\n                assert True\n                assert bpp == 32\n                meta.pf_flags |= DDPF_RGB\n                meta.pf_rgbBitCount = 32\n                meta.pf_rBitMask = 0x00ff0000\n                meta.pf_gBitMask = 0x0000ff00\n                meta.pf_bBitMask = 0x000000ff\n                meta.pf_aBitMask = 0x00000000\n                if fmt == 'rgba':\n                    meta.pf_flags |= DDPF_ALPHAPIXELS\n                    meta.pf_aBitMask = 0xff000000\n            else:\n                meta.pf_flags |= DDPF_FOURCC\n                if fmt == 'dxt1':\n                    meta.pf_fourcc = DDS_DXT1\n                elif fmt == 'dxt2':\n                    meta.pf_fourcc = DDS_DXT2\n                elif fmt == 'dxt3':\n                    meta.pf_fourcc = DDS_DXT3\n                elif fmt == 'dxt4':\n                    meta.pf_fourcc = DDS_DXT4\n                elif fmt == 'dxt5':\n                    meta.pf_fourcc = DDS_DXT5\n\n            images.append(data)\n        else:\n            assert level == len(images)\n            assert fmt == self._fmt\n\n            images.append(data)\n\n            meta.flags |= DDSD_MIPMAPCOUNT\n            meta.caps1 |= DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\n            meta.mipmapCount = len(images)\n\n    def __repr__(self):\n        return '<DDSFile filename=%r size=%r dxt=%r len(images)=%r>' % (\n                self.filename, self.size, self.dxt, len(self.images))\n\n    def _get_size(self):\n        meta = self.meta\n        return meta.width, meta.height\n    def _set_size(self, size):\n        self.meta.update({'width': size[0], 'height': size[1]})\n    size = property(_get_size, _set_size)\n\n    def _get_dxt(self):\n        return dxt_to_str(self._dxt)\n    def _set_dxt(self, dxt):\n        self._dxt = str_to_dxt(dxt)\n    dxt = property(_get_dxt, _set_dxt)",
  "def __getattr__(self, attr):\n        try:\n            return self.__getitem__(attr)\n        except KeyError:\n            try:\n                return super(QueryDict, self).__getattr__(attr)\n            except AttributeError:\n                raise KeyError(attr)",
  "def __setattr__(self, attr, value):\n        self.__setitem__(attr, value)",
  "def __init__(self, filename=None):\n        super(DDSFile, self).__init__()\n        self._dxt = 0\n        self._fmt = None\n        self.meta = meta = QueryDict()\n        self.count = 0\n        self.images = []\n        self.images_size = []\n        for field, index in DDSFile.fields:\n            meta[field] = 0\n        if filename:\n            self.load(filename)",
  "def load(self, filename):\n        self.filename = filename\n        with open(filename, 'rb') as fd:\n            data = fd.read()\n\n        if data[:4] != b'DDS ':\n            raise DDSException('Invalid magic header {}'.format(data[:4]))\n\n        # read header\n        fmt = 'I' * 31\n        fmt_size = calcsize(fmt)\n        pf_size = calcsize('I' * 8)\n        header, data = data[4:4+fmt_size], data[4+fmt_size:]\n        if len(header) != fmt_size:\n            raise DDSException('Truncated header in')\n\n        # depack\n        header = unpack(fmt, header)\n        meta = self.meta\n        for name, index in DDSFile.fields:\n            meta[name] = header[index]\n\n        # check header validity\n        if meta.size != fmt_size:\n            raise DDSException('Invalid header size (%d instead of %d)' %\n                    (meta.size, fmt_size))\n        if meta.pf_size != pf_size:\n            raise DDSException('Invalid pixelformat size (%d instead of %d)' %\n                    (meta.pf_size, pf_size))\n        if not check_flags(meta.flags,\n                DDSD_CAPS | DDSD_PIXELFORMAT | DDSD_WIDTH | DDSD_HEIGHT):\n            raise DDSException('Not enough flags')\n        if not check_flags(meta.caps1, DDSCAPS_TEXTURE):\n            raise DDSException('Not a DDS texture')\n\n        self.count = 1\n        if check_flags(meta.flags, DDSD_MIPMAPCOUNT):\n            if not check_flags(meta.caps1, DDSCAPS_COMPLEX | DDSCAPS_MIPMAP):\n                raise DDSException('Invalid mipmap without flags')\n            self.count = meta.mipmapCount\n\n        hasrgb = check_flags(meta.pf_flags, DDPF_RGB)\n        hasalpha = check_flags(meta.pf_flags, DDPF_ALPHAPIXELS)\n        hasluminance = check_flags(meta.pf_flags, DDPF_LUMINANCE)\n        bpp = None\n        dxt = block = pitch = 0\n        if hasrgb or hasalpha or hasluminance:\n            bpp = meta.pf_rgbBitCount\n\n        if hasrgb and hasluminance:\n            raise DDSException('File have RGB and Luminance')\n\n        if hasrgb:\n            dxt = 0\n        elif hasalpha and not hasluminance:\n            dxt = 1\n        elif hasluminance and not hasalpha:\n            dxt = 2\n        elif hasalpha and hasluminance:\n            dxt = 3\n        elif check_flags(meta.pf_flags, DDPF_FOURCC):\n            dxt = meta.pf_fourcc\n            if dxt not in (DDS_DXT1, DDS_DXT2, DDS_DXT3, DDS_DXT4, DDS_DXT5):\n                raise DDSException('Unsupported FOURCC')\n        else:\n            raise DDSException('Unsupported format specified')\n\n        if bpp:\n            block = align_value(bpp, 8) // 8\n            pitch = align_value(block * meta.width, 4)\n\n        if check_flags(meta.flags, DDSD_LINEARSIZE):\n            if dxt in (0, 1, 2, 3):\n                size = pitch * meta.height\n            else:\n                size = dxt_size(meta.width, meta.height, dxt)\n\n        w = meta.width\n        h = meta.height\n        images = self.images\n        images_size = self.images_size\n        for i in range(self.count):\n            if dxt in (0, 1, 2, 3):\n                size = align_value(block * w, 4) * h\n            else:\n                size = dxt_size(w, h, dxt)\n            image, data = data[:size], data[size:]\n            if len(image) < size:\n                raise DDSException('Truncated image for mipmap %d' % i)\n            images_size.append((w, h))\n            images.append(image)\n            if w == 1 and h == 1:\n                break\n            w = max(1, w // 2)\n            h = max(1, h // 2)\n\n        if len(images) == 0:\n            raise DDSException('No images available')\n        if len(images) < self.count:\n            raise DDSException('Not enough images')\n\n        self._dxt = dxt",
  "def save(self, filename):\n        if len(self.images) == 0:\n            raise DDSException('No images to save')\n\n        fields = dict(DDSFile.fields)\n        fields_keys = list(fields.keys())\n        fields_index = list(fields.values())\n        mget = self.meta.get\n        header = []\n        for idx in range(31):\n            if idx in fields_index:\n                value = mget(fields_keys[fields_index.index(idx)], 0)\n            else:\n                value = 0\n            header.append(value)\n\n        with open(filename, 'wb') as fd:\n            fd.write('DDS ')\n            fd.write(pack('I' * 31, *header))\n            for image in self.images:\n                fd.write(image)",
  "def add_image(self, level, bpp, fmt, width, height, data):\n        assert bpp == 32\n        assert fmt in ('rgb', 'rgba', 'dxt1', 'dxt2', 'dxt3', 'dxt4', 'dxt5')\n        assert width > 0\n        assert height > 0\n        assert level >= 0\n\n        meta = self.meta\n        images = self.images\n        if len(images) == 0:\n            assert level == 0\n\n            # first image, set defaults !\n            for k in meta.keys():\n                meta[k] = 0\n\n            self._fmt = fmt\n            meta.size = calcsize('I' * 31)\n            meta.pf_size = calcsize('I' * 8)\n            meta.pf_flags = 0\n            meta.flags = DDSD_CAPS | DDSD_PIXELFORMAT | DDSD_WIDTH | DDSD_HEIGHT\n            meta.width = width\n            meta.height = height\n            meta.caps1 = DDSCAPS_TEXTURE\n\n            meta.flags |= DDSD_LINEARSIZE\n            meta.pitchOrLinearSize = len(data)\n\n            meta.pf_rgbBitCount = 32\n            meta.pf_rBitMask = 0x00ff0000\n            meta.pf_gBitMask = 0x0000ff00\n            meta.pf_bBitMask = 0x000000ff\n            meta.pf_aBitMask = 0xff000000\n\n            if fmt in ('rgb', 'rgba'):\n                assert True\n                assert bpp == 32\n                meta.pf_flags |= DDPF_RGB\n                meta.pf_rgbBitCount = 32\n                meta.pf_rBitMask = 0x00ff0000\n                meta.pf_gBitMask = 0x0000ff00\n                meta.pf_bBitMask = 0x000000ff\n                meta.pf_aBitMask = 0x00000000\n                if fmt == 'rgba':\n                    meta.pf_flags |= DDPF_ALPHAPIXELS\n                    meta.pf_aBitMask = 0xff000000\n            else:\n                meta.pf_flags |= DDPF_FOURCC\n                if fmt == 'dxt1':\n                    meta.pf_fourcc = DDS_DXT1\n                elif fmt == 'dxt2':\n                    meta.pf_fourcc = DDS_DXT2\n                elif fmt == 'dxt3':\n                    meta.pf_fourcc = DDS_DXT3\n                elif fmt == 'dxt4':\n                    meta.pf_fourcc = DDS_DXT4\n                elif fmt == 'dxt5':\n                    meta.pf_fourcc = DDS_DXT5\n\n            images.append(data)\n        else:\n            assert level == len(images)\n            assert fmt == self._fmt\n\n            images.append(data)\n\n            meta.flags |= DDSD_MIPMAPCOUNT\n            meta.caps1 |= DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\n            meta.mipmapCount = len(images)",
  "def __repr__(self):\n        return '<DDSFile filename=%r size=%r dxt=%r len(images)=%r>' % (\n                self.filename, self.size, self.dxt, len(self.images))",
  "def _get_size(self):\n        meta = self.meta\n        return meta.width, meta.height",
  "def _set_size(self, size):\n        self.meta.update({'width': size[0], 'height': size[1]})",
  "def _get_dxt(self):\n        return dxt_to_str(self._dxt)",
  "def _set_dxt(self, dxt):\n        self._dxt = str_to_dxt(dxt)",
  "class timeval(Structure):\n    _fields_ = [\n        ('tv_sec', c_ulong),\n        ('tv_usec', c_ulong)\n    ]",
  "class input_event(Structure):\n    _fields_ = [\n        ('time', timeval),\n        ('type', c_ushort),\n        ('code', c_ushort),\n        ('value', c_int)\n    ]",
  "class input_absinfo(Structure):\n    _fields_ = [\n        ('value', c_int),\n        ('minimum', c_int),\n        ('maximum', c_int),\n        ('fuzz', c_int),\n        ('flat', c_int),\n        ('resolution', c_int)\n    ]",
  "class mtdev_caps(Structure):\n    _fields_ = [\n        ('has_mtdata', c_int),\n        ('has_slot', c_int),\n        ('has_abs', c_int * MTDEV_ABS_SIZE),\n        ('slot', input_absinfo),\n        ('abs', input_absinfo * MTDEV_ABS_SIZE)\n    ]",
  "class mtdev(Structure):\n    _fields_ = [\n        ('caps', mtdev_caps),\n        ('state', c_void_p)\n    ]",
  "class Device:\n    def __init__(self, filename):\n        self._filename = filename\n        self._fd = -1\n        self._device = mtdev()\n\n        # Linux kernel creates input devices then hands permission changes\n        # off to udev. This results in a period of time when the device is\n        # readable only by root. Device reconnects can be processed by\n        # MTDMotionEventProvider faster than udev can get a chance to run,\n        # so we spin for a period of time to allow udev to fix permissions.\n        # We limit the loop time in case the system is misconfigured and\n        # the user really does not (and will not) have permission to access\n        # the device.\n        # Note: udev takes about 0.6 s on a Raspberry Pi 4\n        permission_wait_until = time.time() + 3.0\n        while self._fd == -1:\n            try:\n                self._fd = os.open(filename, os.O_NONBLOCK | os.O_RDONLY)\n            except PermissionError:\n                if time.time() > permission_wait_until:\n                    raise\n        ret = mtdev_open(pointer(self._device), self._fd)\n        if ret != 0:\n            os.close(self._fd)\n            self._fd = -1\n            raise Exception('Unable to open device')\n\n    def close(self):\n        '''Close the mtdev converter\n        '''\n        if self._fd == -1:\n            return\n        mtdev_close(pointer(self._device))\n        os.close(self._fd)\n        self._fd = -1\n\n    def idle(self, ms):\n        '''Check state of kernel device\n\n        :Parameters:\n            `ms`: int\n                Number of milliseconds to wait for activity\n\n        :Return:\n            Return True if the device is idle, i.e, there are no fetched events\n            in the pipe and there is nothing to fetch from the device.\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        return bool(mtdev_idle(pointer(self._device), self._fd, ms))\n\n\n    def get(self):\n        if self._fd == -1:\n            raise Exception('Device closed')\n        ev = input_event()\n        if mtdev_get(pointer(self._device), self._fd, byref(ev), 1) <= 0:\n            return None\n        return ev\n\n    def has_mtdata(self):\n        '''Return True if the device has multitouch data.\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        return bool(self._device.caps.has_mtdata)\n\n    def has_slot(self):\n        '''Return True if the device has slot information.\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        return bool(self._device.caps.has_slot)\n\n    def has_abs(self, index):\n        '''Return True if the device has abs data.\n\n        :Parameters:\n            `index`: int\n                One of const starting with a name ABS_MT_\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        if index < 0 or index >= MTDEV_ABS_SIZE:\n            raise IndexError('Invalid index')\n        return bool(self._device.caps.has_abs[index])\n\n    def get_max_abs(self):\n        '''Return the maximum number of abs information available.\n        '''\n        return MTDEV_ABS_SIZE\n\n    def get_slot(self):\n        '''Return the slot data.\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        if self._device.caps.has_slot == 0:\n            return\n        return self._device.caps.slot\n\n    def get_abs(self, index):\n        '''Return the abs data.\n\n        :Parameters:\n            `index`: int\n                One of const starting with a name ABS_MT_\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        if index < 0 or index >= MTDEV_ABS_SIZE:\n            raise IndexError('Invalid index')\n        return self._device.caps.abs[index]",
  "def __init__(self, filename):\n        self._filename = filename\n        self._fd = -1\n        self._device = mtdev()\n\n        # Linux kernel creates input devices then hands permission changes\n        # off to udev. This results in a period of time when the device is\n        # readable only by root. Device reconnects can be processed by\n        # MTDMotionEventProvider faster than udev can get a chance to run,\n        # so we spin for a period of time to allow udev to fix permissions.\n        # We limit the loop time in case the system is misconfigured and\n        # the user really does not (and will not) have permission to access\n        # the device.\n        # Note: udev takes about 0.6 s on a Raspberry Pi 4\n        permission_wait_until = time.time() + 3.0\n        while self._fd == -1:\n            try:\n                self._fd = os.open(filename, os.O_NONBLOCK | os.O_RDONLY)\n            except PermissionError:\n                if time.time() > permission_wait_until:\n                    raise\n        ret = mtdev_open(pointer(self._device), self._fd)\n        if ret != 0:\n            os.close(self._fd)\n            self._fd = -1\n            raise Exception('Unable to open device')",
  "def close(self):\n        '''Close the mtdev converter\n        '''\n        if self._fd == -1:\n            return\n        mtdev_close(pointer(self._device))\n        os.close(self._fd)\n        self._fd = -1",
  "def idle(self, ms):\n        '''Check state of kernel device\n\n        :Parameters:\n            `ms`: int\n                Number of milliseconds to wait for activity\n\n        :Return:\n            Return True if the device is idle, i.e, there are no fetched events\n            in the pipe and there is nothing to fetch from the device.\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        return bool(mtdev_idle(pointer(self._device), self._fd, ms))",
  "def get(self):\n        if self._fd == -1:\n            raise Exception('Device closed')\n        ev = input_event()\n        if mtdev_get(pointer(self._device), self._fd, byref(ev), 1) <= 0:\n            return None\n        return ev",
  "def has_mtdata(self):\n        '''Return True if the device has multitouch data.\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        return bool(self._device.caps.has_mtdata)",
  "def has_slot(self):\n        '''Return True if the device has slot information.\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        return bool(self._device.caps.has_slot)",
  "def has_abs(self, index):\n        '''Return True if the device has abs data.\n\n        :Parameters:\n            `index`: int\n                One of const starting with a name ABS_MT_\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        if index < 0 or index >= MTDEV_ABS_SIZE:\n            raise IndexError('Invalid index')\n        return bool(self._device.caps.has_abs[index])",
  "def get_max_abs(self):\n        '''Return the maximum number of abs information available.\n        '''\n        return MTDEV_ABS_SIZE",
  "def get_slot(self):\n        '''Return the slot data.\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        if self._device.caps.has_slot == 0:\n            return\n        return self._device.caps.slot",
  "def get_abs(self, index):\n        '''Return the abs data.\n\n        :Parameters:\n            `index`: int\n                One of const starting with a name ABS_MT_\n        '''\n        if self._fd == -1:\n            raise Exception('Device closed')\n        if index < 0 or index >= MTDEV_ABS_SIZE:\n            raise IndexError('Invalid index')\n        return self._device.caps.abs[index]",
  "class EventManagerBase(object):\n    '''Abstract class with methods :meth:`start`, :meth:`stop` and\n    :meth:`dispatch` for specific class to implement.\n\n    Example of the manager receiving touch and hover events::\n\n        class TouchHoverManager(EventManagerBase):\n\n            type_ids = ('touch', 'hover')\n\n            def start(self):\n                # Create additional resources, bind callbacks to self.window\n\n            def dispatch(self, etype, me):\n                if me.type_id == 'touch':\n                    # Handle touch event\n                elif me.type_id == 'hover'\n                    # Handle hover event\n\n            def stop(self):\n                # Release resources\n\n    '''\n\n    type_ids = None\n    '''Override this attribute to declare the type ids of the events which\n    manager wants to receive. This attribute will be used by\n    :class:`~kivy.core.window.WindowBase` to know which events to pass to the\n    :meth:`dispatch` method.\n\n    .. versionadded:: 2.1.0\n    '''\n\n    window = None\n    '''Holds the instance of the :class:`~kivy.core.window.WindowBase`.\n\n    .. versionadded:: 2.1.0\n    '''\n\n    def start(self):\n        '''Start the manager, bind callbacks to the objects and create\n        additional resources. Attribute :attr:`window` is assigned when this\n        method is called.\n\n        .. versionadded:: 2.1.0\n        '''\n\n    def dispatch(self, etype, me):\n        '''Dispatch event `me` to the widgets in the :attr:`window`.\n\n        :Parameters:\n            `etype`: `str`\n                One of \"begin\", \"update\" or \"end\"\n            `me`: :class:`~kivy.input.motionevent.MotionEvent`\n                The Motion Event currently dispatched.\n        :Returns: `bool`\n            `True` to stop event dispatching\n\n        .. versionadded:: 2.1.0\n        '''\n\n    def stop(self):\n        '''Stop the manager, unbind from any objects and release any allocated\n        resources.\n\n        .. versionadded:: 2.1.0\n        '''",
  "def start(self):\n        '''Start the manager, bind callbacks to the objects and create\n        additional resources. Attribute :attr:`window` is assigned when this\n        method is called.\n\n        .. versionadded:: 2.1.0\n        '''",
  "def dispatch(self, etype, me):\n        '''Dispatch event `me` to the widgets in the :attr:`window`.\n\n        :Parameters:\n            `etype`: `str`\n                One of \"begin\", \"update\" or \"end\"\n            `me`: :class:`~kivy.input.motionevent.MotionEvent`\n                The Motion Event currently dispatched.\n        :Returns: `bool`\n            `True` to stop event dispatching\n\n        .. versionadded:: 2.1.0\n        '''",
  "def stop(self):\n        '''Stop the manager, unbind from any objects and release any allocated\n        resources.\n\n        .. versionadded:: 2.1.0\n        '''",
  "class OpacityScrollEffect(DampedScrollEffect):\n    '''OpacityScrollEffect class. Uses the overscroll\n    information to reduce the opacity of the scrollview widget. When the user\n    stops the drag, the opacity is set back to 1.\n    '''\n\n    def on_overscroll(self, *args):\n        if self.target_widget and self.target_widget.height != 0:\n            alpha = (1.0 -\n                     abs(self.overscroll / float(self.target_widget.height)))\n            self.target_widget.opacity = min(1, alpha)\n        self.trigger_velocity_update()",
  "def on_overscroll(self, *args):\n        if self.target_widget and self.target_widget.height != 0:\n            alpha = (1.0 -\n                     abs(self.overscroll / float(self.target_widget.height)))\n            self.target_widget.opacity = min(1, alpha)\n        self.trigger_velocity_update()",
  "class KineticEffect(EventDispatcher):\n    '''Kinetic effect class. See module documentation for more information.\n    '''\n\n    velocity = NumericProperty(0)\n    '''Velocity of the movement.\n\n    :attr:`velocity` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    friction = NumericProperty(0.05)\n    '''Friction to apply on the velocity\n\n    :attr:`friction` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.05.\n    '''\n\n    value = NumericProperty(0)\n    '''Value (during the movement and computed) of the effect.\n\n    :attr:`value` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    is_manual = BooleanProperty(False)\n    '''Indicate if a movement is in progress (True) or not (False).\n\n    :attr:`is_manual` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    max_history = NumericProperty(5)\n    '''Save up to `max_history` movement value into the history. This is used\n    for correctly calculating the velocity according to the movement.\n\n    :attr:`max_history` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 5.\n    '''\n\n    min_distance = NumericProperty(.1)\n    '''The minimal distance for a movement to have nonzero velocity.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`min_distance` is :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.1.\n    '''\n\n    min_velocity = NumericProperty(.5)\n    '''Velocity below this quantity is normalized to 0. In other words,\n    any motion whose velocity falls below this number is stopped.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`min_velocity` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.5.\n    '''\n\n    std_dt = NumericProperty(0.017)\n    ''' std_dt\n        correction update_velocity if dt is not constant\n\n    .. versionadded:: 2.0.0\n\n    :attr:`std_dt` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.017.\n    '''\n\n    def __init__(self, **kwargs):\n        self.history = []\n        self.trigger_velocity_update = Clock.create_trigger(\n            self.update_velocity, 0)\n        super(KineticEffect, self).__init__(**kwargs)\n\n    def apply_distance(self, distance):\n        if abs(distance) < self.min_distance:\n            self.velocity = 0\n        self.value += distance\n\n    def start(self, val, t=None):\n        '''Start the movement.\n\n        :Parameters:\n            `val`: float or int\n                Value of the movement\n            `t`: float, defaults to None\n                Time when the movement happen. If no time is set, it will use\n                time.time()\n        '''\n        self.is_manual = True\n        t = t or time()\n        self.velocity = 0\n        self.history = [(t, val)]\n\n    def update(self, val, t=None):\n        '''Update the movement.\n\n        See :meth:`start` for the arguments.\n        '''\n        t = t or time()\n        distance = val - self.history[-1][1]\n        self.apply_distance(distance)\n        self.history.append((t, val))\n        if len(self.history) > self.max_history:\n            self.history.pop(0)\n\n    def stop(self, val, t=None):\n        '''Stop the movement.\n\n        See :meth:`start` for the arguments.\n        '''\n        self.is_manual = False\n        t = t or time()\n        distance = val - self.history[-1][1]\n        self.apply_distance(distance)\n        newest_sample = (t, val)\n        old_sample = self.history[0]\n        for sample in self.history:\n            if (newest_sample[0] - sample[0]) < 10. / 60.:\n                break\n            old_sample = sample\n        distance = newest_sample[1] - old_sample[1]\n        duration = abs(newest_sample[0] - old_sample[0])\n        self.velocity = (distance / max(duration, 0.0001))\n        self.trigger_velocity_update()\n\n    def cancel(self):\n        '''Cancel a movement. This can be used in case :meth:`stop` cannot be\n        called. It will reset :attr:`is_manual` to False, and compute the\n        movement if the velocity is > 0.\n        '''\n        self.is_manual = False\n        self.trigger_velocity_update()\n\n    def update_velocity(self, dt):\n        '''(internal) Update the velocity according to the frametime and\n        friction.\n        '''\n        if abs(self.velocity) <= self.min_velocity:\n            self.velocity = 0\n            return\n\n        self.velocity -= self.velocity * self.friction * dt / self.std_dt\n        self.apply_distance(self.velocity * dt)\n        self.trigger_velocity_update()",
  "def __init__(self, **kwargs):\n        self.history = []\n        self.trigger_velocity_update = Clock.create_trigger(\n            self.update_velocity, 0)\n        super(KineticEffect, self).__init__(**kwargs)",
  "def apply_distance(self, distance):\n        if abs(distance) < self.min_distance:\n            self.velocity = 0\n        self.value += distance",
  "def start(self, val, t=None):\n        '''Start the movement.\n\n        :Parameters:\n            `val`: float or int\n                Value of the movement\n            `t`: float, defaults to None\n                Time when the movement happen. If no time is set, it will use\n                time.time()\n        '''\n        self.is_manual = True\n        t = t or time()\n        self.velocity = 0\n        self.history = [(t, val)]",
  "def update(self, val, t=None):\n        '''Update the movement.\n\n        See :meth:`start` for the arguments.\n        '''\n        t = t or time()\n        distance = val - self.history[-1][1]\n        self.apply_distance(distance)\n        self.history.append((t, val))\n        if len(self.history) > self.max_history:\n            self.history.pop(0)",
  "def stop(self, val, t=None):\n        '''Stop the movement.\n\n        See :meth:`start` for the arguments.\n        '''\n        self.is_manual = False\n        t = t or time()\n        distance = val - self.history[-1][1]\n        self.apply_distance(distance)\n        newest_sample = (t, val)\n        old_sample = self.history[0]\n        for sample in self.history:\n            if (newest_sample[0] - sample[0]) < 10. / 60.:\n                break\n            old_sample = sample\n        distance = newest_sample[1] - old_sample[1]\n        duration = abs(newest_sample[0] - old_sample[0])\n        self.velocity = (distance / max(duration, 0.0001))\n        self.trigger_velocity_update()",
  "def cancel(self):\n        '''Cancel a movement. This can be used in case :meth:`stop` cannot be\n        called. It will reset :attr:`is_manual` to False, and compute the\n        movement if the velocity is > 0.\n        '''\n        self.is_manual = False\n        self.trigger_velocity_update()",
  "def update_velocity(self, dt):\n        '''(internal) Update the velocity according to the frametime and\n        friction.\n        '''\n        if abs(self.velocity) <= self.min_velocity:\n            self.velocity = 0\n            return\n\n        self.velocity -= self.velocity * self.friction * dt / self.std_dt\n        self.apply_distance(self.velocity * dt)\n        self.trigger_velocity_update()",
  "class DampedScrollEffect(ScrollEffect):\n    '''DampedScrollEffect class. See the module documentation for more\n    information.\n    '''\n\n    edge_damping = NumericProperty(0.25)\n    '''Edge damping.\n\n    :attr:`edge_damping` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.25\n    '''\n\n    spring_constant = NumericProperty(2.0)\n    '''Spring constant.\n\n    :attr:`spring_constant` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 2.0\n    '''\n\n    min_overscroll = NumericProperty(.5)\n    '''An overscroll less than this amount will be normalized to 0.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`min_overscroll` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to .5.\n    '''\n\n    round_value = BooleanProperty(True)\n    '''If True, when the motion stops, :attr:`value` is rounded to the nearest\n    integer.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`round_value` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    def update_velocity(self, dt):\n        if abs(self.velocity) <= self.min_velocity and self.overscroll == 0:\n            self.velocity = 0\n            # why does this need to be rounded? For now refactored it.\n            if self.round_value:\n                self.value = round(self.value)\n            return\n\n        total_force = self.velocity * self.friction * dt / self.std_dt\n        if abs(self.overscroll) > self.min_overscroll:\n            total_force += self.velocity * self.edge_damping\n            total_force += self.overscroll * self.spring_constant\n        else:\n            self.overscroll = 0\n\n        stop_overscroll = ''\n        if not self.is_manual:\n            if self.overscroll > 0 and self.velocity < 0:\n                stop_overscroll = 'max'\n            elif self.overscroll < 0 and self.velocity > 0:\n                stop_overscroll = 'min'\n\n        self.velocity = self.velocity - total_force\n        if not self.is_manual:\n            self.apply_distance(self.velocity * dt)\n            if stop_overscroll == 'min' and self.value > self.min:\n                self.value = self.min\n                self.velocity = 0\n                return\n            if stop_overscroll == 'max' and self.value < self.max:\n                self.value = self.max\n                self.velocity = 0\n                return\n        self.trigger_velocity_update()\n\n    def on_value(self, *args):\n        scroll_min = self.min\n        scroll_max = self.max\n        if scroll_min > scroll_max:\n            scroll_min, scroll_max = scroll_max, scroll_min\n        if self.value < scroll_min:\n            self.overscroll = self.value - scroll_min\n        elif self.value > scroll_max:\n            self.overscroll = self.value - scroll_max\n        else:\n            self.overscroll = 0\n        self.scroll = self.value\n\n    def on_overscroll(self, *args):\n        self.trigger_velocity_update()\n\n    def apply_distance(self, distance):\n        os = abs(self.overscroll)\n        if os:\n            distance /= 1. + os / sp(200.)\n        super(DampedScrollEffect, self).apply_distance(distance)",
  "def update_velocity(self, dt):\n        if abs(self.velocity) <= self.min_velocity and self.overscroll == 0:\n            self.velocity = 0\n            # why does this need to be rounded? For now refactored it.\n            if self.round_value:\n                self.value = round(self.value)\n            return\n\n        total_force = self.velocity * self.friction * dt / self.std_dt\n        if abs(self.overscroll) > self.min_overscroll:\n            total_force += self.velocity * self.edge_damping\n            total_force += self.overscroll * self.spring_constant\n        else:\n            self.overscroll = 0\n\n        stop_overscroll = ''\n        if not self.is_manual:\n            if self.overscroll > 0 and self.velocity < 0:\n                stop_overscroll = 'max'\n            elif self.overscroll < 0 and self.velocity > 0:\n                stop_overscroll = 'min'\n\n        self.velocity = self.velocity - total_force\n        if not self.is_manual:\n            self.apply_distance(self.velocity * dt)\n            if stop_overscroll == 'min' and self.value > self.min:\n                self.value = self.min\n                self.velocity = 0\n                return\n            if stop_overscroll == 'max' and self.value < self.max:\n                self.value = self.max\n                self.velocity = 0\n                return\n        self.trigger_velocity_update()",
  "def on_value(self, *args):\n        scroll_min = self.min\n        scroll_max = self.max\n        if scroll_min > scroll_max:\n            scroll_min, scroll_max = scroll_max, scroll_min\n        if self.value < scroll_min:\n            self.overscroll = self.value - scroll_min\n        elif self.value > scroll_max:\n            self.overscroll = self.value - scroll_max\n        else:\n            self.overscroll = 0\n        self.scroll = self.value",
  "def on_overscroll(self, *args):\n        self.trigger_velocity_update()",
  "def apply_distance(self, distance):\n        os = abs(self.overscroll)\n        if os:\n            distance /= 1. + os / sp(200.)\n        super(DampedScrollEffect, self).apply_distance(distance)",
  "class ScrollEffect(KineticEffect):\n    '''ScrollEffect class. See the module documentation for more information.\n    '''\n\n    drag_threshold = NumericProperty('20sp')\n    '''Minimum distance to travel before the movement is considered as a drag.\n\n    :attr:`drag_threshold` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 20sp.\n    '''\n\n    min = NumericProperty(0)\n    '''Minimum boundary to use for scrolling.\n\n    :attr:`min` is a :class:`~kivy.properties.NumericProperty` and defaults to\n    0.\n    '''\n\n    max = NumericProperty(0)\n    '''Maximum boundary to use for scrolling.\n\n    :attr:`max` is a :class:`~kivy.properties.NumericProperty` and defaults to\n    0.\n    '''\n\n    scroll = NumericProperty(0)\n    '''Computed value for scrolling. This value is different from\n    :py:attr:`kivy.effects.kinetic.KineticEffect.value`\n    in that it will return to one of the min/max bounds.\n\n    :attr:`scroll` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 0.\n    '''\n\n    overscroll = NumericProperty(0)\n    '''Computed value when the user over-scrolls i.e. goes out of the bounds.\n\n    :attr:`overscroll` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    target_widget = ObjectProperty(None, allownone=True, baseclass=Widget)\n    '''Widget to attach to this effect. Even if this class doesn't make changes\n    to the `target_widget` by default, subclasses can use it to change the\n    graphics or apply custom transformations.\n\n    :attr:`target_widget` is a :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    displacement = NumericProperty(0)\n    '''Cumulative distance of the movement during the interaction. This is used\n    to determine if the movement is a drag (more than :attr:`drag_threshold`)\n    or not.\n\n    :attr:`displacement` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    def reset(self, pos):\n        '''(internal) Reset the value and the velocity to the `pos`.\n        Mostly used when the bounds are checked.\n        '''\n        self.value = pos\n        self.velocity = 0\n        if self.history:\n            val = self.history[-1][1]\n            self.history = [(time(), val)]\n\n    def on_value(self, *args):\n        scroll_min = self.min\n        scroll_max = self.max\n        if scroll_min > scroll_max:\n            scroll_min, scroll_max = scroll_max, scroll_min\n        if self.value < scroll_min:\n            self.overscroll = self.value - scroll_min\n            self.reset(scroll_min)\n        elif self.value > scroll_max:\n            self.overscroll = self.value - scroll_max\n            self.reset(scroll_max)\n        else:\n            self.scroll = self.value\n\n    def start(self, val, t=None):\n        self.is_manual = True\n        self.displacement = 0\n        return super(ScrollEffect, self).start(val, t)\n\n    def update(self, val, t=None):\n        self.displacement += abs(val - self.history[-1][1])\n        return super(ScrollEffect, self).update(val, t)\n\n    def stop(self, val, t=None):\n        self.is_manual = False\n        self.displacement += abs(val - self.history[-1][1])\n        if self.displacement <= self.drag_threshold:\n            self.velocity = 0\n            return\n        return super(ScrollEffect, self).stop(val, t)",
  "def reset(self, pos):\n        '''(internal) Reset the value and the velocity to the `pos`.\n        Mostly used when the bounds are checked.\n        '''\n        self.value = pos\n        self.velocity = 0\n        if self.history:\n            val = self.history[-1][1]\n            self.history = [(time(), val)]",
  "def on_value(self, *args):\n        scroll_min = self.min\n        scroll_max = self.max\n        if scroll_min > scroll_max:\n            scroll_min, scroll_max = scroll_max, scroll_min\n        if self.value < scroll_min:\n            self.overscroll = self.value - scroll_min\n            self.reset(scroll_min)\n        elif self.value > scroll_max:\n            self.overscroll = self.value - scroll_max\n            self.reset(scroll_max)\n        else:\n            self.scroll = self.value",
  "def start(self, val, t=None):\n        self.is_manual = True\n        self.displacement = 0\n        return super(ScrollEffect, self).start(val, t)",
  "def update(self, val, t=None):\n        self.displacement += abs(val - self.history[-1][1])\n        return super(ScrollEffect, self).update(val, t)",
  "def stop(self, val, t=None):\n        self.is_manual = False\n        self.displacement += abs(val - self.history[-1][1])\n        if self.displacement <= self.drag_threshold:\n            self.velocity = 0\n            return\n        return super(ScrollEffect, self).stop(val, t)",
  "class GardenImporter(object):\n\n    def find_module(self, fullname, path):\n        if path == 'kivy.garden':\n            return self\n\n    def load_module(self, fullname):\n        assert fullname.startswith('kivy.garden')\n\n        moddir = join(garden_kivy_dir, fullname.split('.', 2)[-1])\n        if exists(moddir):\n            return self._load_module(fullname, moddir)\n\n        modname = fullname.split('.', 1)[-1]\n        for directory in (garden_app_dir, garden_system_dir):\n            moddir = join(directory, modname)\n            if exists(moddir):\n                return self._load_module(fullname, moddir)\n\n    def _load_module(self, fullname, moddir):\n        mod = imp.load_module(fullname, None, moddir,\n                              ('', '', imp.PKG_DIRECTORY))\n        return mod",
  "def find_module(self, fullname, path):\n        if path == 'kivy.garden':\n            return self",
  "def load_module(self, fullname):\n        assert fullname.startswith('kivy.garden')\n\n        moddir = join(garden_kivy_dir, fullname.split('.', 2)[-1])\n        if exists(moddir):\n            return self._load_module(fullname, moddir)\n\n        modname = fullname.split('.', 1)[-1]\n        for directory in (garden_app_dir, garden_system_dir):\n            moddir = join(directory, modname)\n            if exists(moddir):\n                return self._load_module(fullname, moddir)",
  "def _load_module(self, fullname, moddir):\n        mod = imp.load_module(fullname, None, moddir,\n                              ('', '', imp.PKG_DIRECTORY))\n        return mod",
  "def replay(recorder, *args):\n    if recorder.play:\n        return\n    else:\n        recorder.play = True",
  "def on_recorder_key(recorder, window, key, *largs):\n    if key == 289:  # F8\n        if recorder.play:\n            Logger.error('Recorder: Cannot start recording while playing.')\n            return\n        recorder.record = not recorder.record\n    elif key == 288:  # F7\n        if recorder.record:\n            Logger.error('Recorder: Cannot start playing while recording.')\n            return\n        recorder.play = not recorder.play\n    elif key == 287:  # F6\n        if recorder.play:\n            recorder.unbind(play=replay)\n        else:\n            recorder.bind(play=replay)\n            recorder.play = True",
  "def start(win, ctx):\n    keys = {}\n\n    # attributes\n    value = ctx.config.get('attrs', None)\n    if value is not None:\n        keys['record_attrs'] = value.split(':')\n\n    # profile mask\n    value = ctx.config.get('profile_mask', None)\n    if value is not None:\n        keys['record_profile_mask'] = value.split(':')\n\n    # filename\n    value = ctx.config.get('filename', None)\n    if value is not None:\n        keys['filename'] = value\n\n    from kivy.input.recorder import Recorder\n    ctx.recorder = Recorder(window=win, **keys)\n    win.bind(on_key_down=partial(on_recorder_key, ctx.recorder))",
  "def stop(win, ctx):\n    if hasattr(ctx, 'recorder'):\n        ctx.recorder.release()",
  "def start(win, ctx):\n    pass",
  "def stop(win, ctx):\n    pass",
  "def apply_device(device, scale, orientation):\n    name, width, height, dpi, density = devices[device]\n    if orientation == 'portrait':\n        width, height = height, width\n    Logger.info('Screen: Apply screen settings for {0}'.format(name))\n    Logger.info('Screen: size={0}x{1} dpi={2} density={3} '\n                'orientation={4}'.format(width, height, dpi, density,\n                                         orientation))\n    try:\n        scale = float(scale)\n    except:\n        scale = 1\n    environ['KIVY_METRICS_DENSITY'] = str(density * scale)\n    environ['KIVY_DPI'] = str(dpi * scale)\n    Config.set('graphics', 'width', str(int(width * scale)))\n    # simulate with the android bar\n    # FIXME should be configurable\n    Config.set('graphics', 'height', str(int(height * scale - 25 * density)))\n    Config.set('graphics', 'fullscreen', '0')\n    Config.set('graphics', 'show_mousecursor', '1')",
  "def usage(device=None):\n    if device:\n        Logger.error('Screen: The specified device ({0}) is unknown.',\n                     device)\n    print('\\nModule usage: python main.py -m screen:deviceid[,orientation]\\n')\n    print('Available devices:\\n')\n    print('{0:12} {1:<22} {2:<8} {3:<8} {4:<5} {5:<8}'.format(\n        'Device ID', 'Name', 'Width', 'Height', 'DPI', 'Density'))\n    for device, info in devices.items():\n        print('{0:12} {1:<22} {2:<8} {3:<8} {4:<5} {5:<8}'.format(\n            device, *info))\n    print('\\n')\n    print('Simulate a medium-density screen such as Motorola Droid 2:\\n')\n    print('    python main.py -m screen:droid2\\n')\n    print('Simulate a high-density screen such as HTC One X, in portrait:\\n')\n    print('    python main.py -m screen:onex,portrait\\n')\n    print('Simulate the iPad 2 screen\\n')\n    print('    python main.py -m screen:ipad\\n')\n    print('If the generated window is too large, you can specify a scale:\\n')\n    print('    python main.py -m screen:note2,portrait,scale=.75\\n')\n    sys.exit(1)",
  "def configure(ctx):\n    scale = ctx.pop('scale', None)\n    orientation = 'landscape'\n    ctx.pop('landscape', None)\n    if ctx.pop('portrait', None):\n        orientation = 'portrait'\n    if not ctx:\n        return usage(None)\n    device = list(ctx.keys())[0]\n    if device not in devices:\n        return usage('')\n    apply_device(device, scale, orientation)",
  "def start(win, ctx):\n    Builder.load_string(KV_CODE, filename=__file__)",
  "def stop(win, ctx):\n    Builder.unload_file(__file__)",
  "def _on_keyboard_handler(instance, key, scancode, codepoint, modifiers):\n    if key == 293 and modifiers == []:  # F12\n        instance.screenshot()\n    elif key == 292 and modifiers == []:  # F11\n        instance.rotation += 90\n    elif key == 292 and modifiers == ['shift']:  # Shift + F11\n        if platform in ('win', 'linux', 'macosx'):\n            instance.rotation = 0\n            w, h = instance.size\n            w, h = h, w\n            instance.size = (w, h)",
  "def start(win, ctx):\n    win.bind(on_keyboard=_on_keyboard_handler)",
  "def stop(win, ctx):\n    win.unbind(on_keyboard=_on_keyboard_handler)",
  "def _mouse_move(texture, size, offset, win, pos, *args):\n    if hasattr(win, '_cursor'):\n        c = win._cursor\n    else:\n        with win.canvas.after:\n            Color(1, 1, 1, 1, mode='rgba')\n            win._cursor = c = Rectangle(texture=texture, size=size)\n\n    c.pos = pos[0] + offset[0], pos[1] - size[1] + offset[1]",
  "def start(win, ctx):\n    cursor_texture = Image(\n        ctx.config.get('texture', join(kivy_data_dir, 'images', 'cursor.png'))\n    ).texture\n    cursor_size = ctx.config.get('size')\n    if isinstance(cursor_size, string_types):\n        cursor_size = [int(x) for x in cursor_size.split('x')]\n    elif not cursor_size:\n        cursor_size = cursor_texture.size\n\n    cursor_offset = ctx.config.get('offset', (0, 0))\n    if isinstance(cursor_offset, string_types):\n        cursor_offset = [int(x) for x in cursor_offset.split('x')]\n\n    win.bind(\n        mouse_pos=partial(\n            _mouse_move, cursor_texture, cursor_size, cursor_offset))",
  "def stop(win, ctx):\n    win.unbind(mouse_pos=_mouse_move)",
  "class JoyCursor(Widget):\n    win = ObjectProperty()\n    activated = BooleanProperty(False)\n    cursor_width = NumericProperty(1.1)\n    cursor_hold = BooleanProperty(False)\n    intensity = NumericProperty(4)\n    dead_zone = NumericProperty(10000)\n    offset_x = NumericProperty(0)\n    offset_y = NumericProperty(0)\n\n    def __init__(self, **kwargs):\n        super(JoyCursor, self).__init__(**kwargs)\n        self.avoid_bring_to_top = False\n        self.size_hint = (None, None)\n        self.size = (21, 21)\n        self.set_cursor()\n\n        # draw cursor\n        with self.canvas:\n            Color(rgba=(0.19, 0.64, 0.81, 0.5))\n            self.cursor_ox = Line(\n                points=self.cursor_pts[:4],\n                width=self.cursor_width + 0.1\n            )\n            self.cursor_oy = Line(\n                points=self.cursor_pts[4:],\n                width=self.cursor_width + 0.1\n            )\n            Color(rgba=(1, 1, 1, 0.5))\n            self.cursor_x = Line(\n                points=self.cursor_pts[:4],\n                width=self.cursor_width\n            )\n            self.cursor_y = Line(\n                points=self.cursor_pts[4:],\n                width=self.cursor_width\n            )\n        self.pos = [-i for i in self.size]\n\n    def on_window_children(self, win, *args):\n        # pull JoyCursor to the front when added\n        # as a child directly to the window.\n        if self.avoid_bring_to_top or not self.activated:\n            return\n        self.avoid_bring_to_top = True\n        win.remove_widget(self)\n        win.add_widget(self)\n        self.avoid_bring_to_top = False\n\n    def on_activated(self, instance, activated):\n        # bind/unbind when JoyCursor's state is changed\n        if activated:\n            self.win.add_widget(self)\n            self.move = Clock.schedule_interval(self.move_cursor, 0)\n            self.win.fbind('on_joy_axis', self.check_cursor)\n            self.win.fbind('on_joy_button_down', self.set_intensity)\n            self.win.fbind('on_joy_button_down', self.check_dispatch)\n            self.win.fbind('mouse_pos', self.stop_cursor)\n            mouse_pos = self.win.mouse_pos\n            self.pos = (\n                mouse_pos[0] - self.size[0] / 2.0,\n                mouse_pos[1] - self.size[1] / 2.0\n            )\n            Logger.info('JoyCursor: joycursor activated')\n        else:\n            self.pos = [-i for i in self.size]\n            Clock.unschedule(self.move)\n            self.win.funbind('on_joy_axis', self.check_cursor)\n            self.win.funbind('on_joy_button_down', self.set_intensity)\n            self.win.funbind('on_joy_button_down', self.check_dispatch)\n            self.win.funbind('mouse_pos', self.stop_cursor)\n            self.win.remove_widget(self)\n            Logger.info('JoyCursor: joycursor deactivated')\n\n    def set_cursor(self, *args):\n        # create cursor points\n        px, py = self.pos\n        sx, sy = self.size\n        self.cursor_pts = [\n            px, py + round(sy / 2.0), px + sx, py + round(sy / 2.0),\n            px + round(sx / 2.0), py, px + round(sx / 2.0), py + sy\n        ]\n\n    def check_cursor(self, win, stickid, axisid, value):\n        # check axes and set offset if a movement is registered\n        intensity = self.intensity\n        dead = self.dead_zone\n\n        if axisid == 3:\n            if value < -dead:\n                self.offset_x = -intensity\n            elif value > dead:\n                self.offset_x = intensity\n            else:\n                self.offset_x = 0\n        elif axisid == 4:\n            # invert Y axis to behave like mouse\n            if value < -dead:\n                self.offset_y = intensity\n            elif value > dead:\n                self.offset_y = -intensity\n            else:\n                self.offset_y = 0\n        else:\n            self.offset_x = 0\n            self.offset_y = 0\n\n    def set_intensity(self, win, stickid, buttonid):\n        # set intensity of joycursor with joystick buttons\n        intensity = self.intensity\n        if buttonid == 0 and intensity > 2:\n            intensity -= 1\n        elif buttonid == 1:\n            intensity += 1\n        self.intensity = intensity\n\n    def check_dispatch(self, win, stickid, buttonid):\n        if buttonid == 6:\n            self.cursor_hold = not self.cursor_hold\n        if buttonid not in (2, 3, 4, 5, 6):\n            return\n\n        x, y = self.center\n        # window event, correction necessary\n        y = self.win.system_size[1] - y\n        modifiers = []\n        actions = {\n            2: 'left',\n            3: 'right',\n            4: 'scrollup',\n            5: 'scrolldown',\n            6: 'left'\n        }\n        button = actions[buttonid]\n\n        self.win.dispatch('on_mouse_down', x, y, button, modifiers)\n        if not self.cursor_hold:\n            self.win.dispatch('on_mouse_up', x, y, button, modifiers)\n\n    def move_cursor(self, *args):\n        # move joycursor as a mouse\n        self.pos[0] += self.offset_x\n        self.pos[1] += self.offset_y\n        modifiers = []\n        if self.cursor_hold:\n            self.win.dispatch(\n                'on_mouse_move',\n                self.center[0],\n                self.win.system_size[1] - self.center[1],\n                modifiers\n            )\n\n    def stop_cursor(self, instance, mouse_pos):\n        # pin the cursor to the mouse pos\n        self.offset_x = 0\n        self.offset_y = 0\n        self.pos = (\n            mouse_pos[0] - self.size[0] / 2.0,\n            mouse_pos[1] - self.size[1] / 2.0\n        )\n\n    def on_pos(self, instance, new_pos):\n        self.set_cursor()\n        self.cursor_x.points = self.cursor_pts[:4]\n        self.cursor_y.points = self.cursor_pts[4:]\n        self.cursor_ox.points = self.cursor_pts[:4]\n        self.cursor_oy.points = self.cursor_pts[4:]\n\n    def keyboard_shortcuts(self, win, scancode, *args):\n        modifiers = args[-1]\n        if scancode == 101 and modifiers == ['ctrl']:\n            self.activated = not self.activated\n            return True\n        elif scancode == 27:\n            if self.activated:\n                self.activated = False\n                return True\n\n    def joystick_shortcuts(self, win, stickid, buttonid):\n        if buttonid == 7:\n            self.activated = not self.activated\n            if self.activated:\n                self.pos = [round(i / 2.0) for i in win.size]",
  "def create_joycursor(win, ctx, *args):\n    '''Create a JoyCursor instance attached to the *ctx* and bound to the\n    Window's :meth:`~kivy.core.window.WindowBase.on_keyboard` event for\n    capturing the keyboard shortcuts.\n\n        :Parameters:\n            `win`: A :class:`Window <kivy.core.window.WindowBase>`\n                The application Window to bind to.\n            `ctx`: A :class:`~kivy.uix.widget.Widget` or subclass\n                The Widget for JoyCursor to attach to.\n\n    '''\n    ctx.joycursor = JoyCursor(win=win)\n    win.bind(children=ctx.joycursor.on_window_children,\n             on_keyboard=ctx.joycursor.keyboard_shortcuts)\n    # always listen for joystick input to open the module\n    # (like a keyboard listener)\n    win.fbind('on_joy_button_down', ctx.joycursor.joystick_shortcuts)",
  "def start(win, ctx):\n    Clock.schedule_once(lambda *t: create_joycursor(win, ctx))",
  "def stop(win, ctx):\n    '''Stop and unload any active JoyCursors for the given *ctx*.\n    '''\n    if hasattr(ctx, 'joycursor'):\n        ctx.joycursor.activated = False\n        win.unbind(children=ctx.joycursor.on_window_children,\n                   on_keyboard=ctx.joycursor.keyboard_shortcuts)\n        win.funbind('on_joy_button_down', ctx.joycursor.joystick_shortcuts)\n        win.remove_widget(ctx.joycursor)\n        del ctx.joycursor",
  "def __init__(self, **kwargs):\n        super(JoyCursor, self).__init__(**kwargs)\n        self.avoid_bring_to_top = False\n        self.size_hint = (None, None)\n        self.size = (21, 21)\n        self.set_cursor()\n\n        # draw cursor\n        with self.canvas:\n            Color(rgba=(0.19, 0.64, 0.81, 0.5))\n            self.cursor_ox = Line(\n                points=self.cursor_pts[:4],\n                width=self.cursor_width + 0.1\n            )\n            self.cursor_oy = Line(\n                points=self.cursor_pts[4:],\n                width=self.cursor_width + 0.1\n            )\n            Color(rgba=(1, 1, 1, 0.5))\n            self.cursor_x = Line(\n                points=self.cursor_pts[:4],\n                width=self.cursor_width\n            )\n            self.cursor_y = Line(\n                points=self.cursor_pts[4:],\n                width=self.cursor_width\n            )\n        self.pos = [-i for i in self.size]",
  "def on_window_children(self, win, *args):\n        # pull JoyCursor to the front when added\n        # as a child directly to the window.\n        if self.avoid_bring_to_top or not self.activated:\n            return\n        self.avoid_bring_to_top = True\n        win.remove_widget(self)\n        win.add_widget(self)\n        self.avoid_bring_to_top = False",
  "def on_activated(self, instance, activated):\n        # bind/unbind when JoyCursor's state is changed\n        if activated:\n            self.win.add_widget(self)\n            self.move = Clock.schedule_interval(self.move_cursor, 0)\n            self.win.fbind('on_joy_axis', self.check_cursor)\n            self.win.fbind('on_joy_button_down', self.set_intensity)\n            self.win.fbind('on_joy_button_down', self.check_dispatch)\n            self.win.fbind('mouse_pos', self.stop_cursor)\n            mouse_pos = self.win.mouse_pos\n            self.pos = (\n                mouse_pos[0] - self.size[0] / 2.0,\n                mouse_pos[1] - self.size[1] / 2.0\n            )\n            Logger.info('JoyCursor: joycursor activated')\n        else:\n            self.pos = [-i for i in self.size]\n            Clock.unschedule(self.move)\n            self.win.funbind('on_joy_axis', self.check_cursor)\n            self.win.funbind('on_joy_button_down', self.set_intensity)\n            self.win.funbind('on_joy_button_down', self.check_dispatch)\n            self.win.funbind('mouse_pos', self.stop_cursor)\n            self.win.remove_widget(self)\n            Logger.info('JoyCursor: joycursor deactivated')",
  "def set_cursor(self, *args):\n        # create cursor points\n        px, py = self.pos\n        sx, sy = self.size\n        self.cursor_pts = [\n            px, py + round(sy / 2.0), px + sx, py + round(sy / 2.0),\n            px + round(sx / 2.0), py, px + round(sx / 2.0), py + sy\n        ]",
  "def check_cursor(self, win, stickid, axisid, value):\n        # check axes and set offset if a movement is registered\n        intensity = self.intensity\n        dead = self.dead_zone\n\n        if axisid == 3:\n            if value < -dead:\n                self.offset_x = -intensity\n            elif value > dead:\n                self.offset_x = intensity\n            else:\n                self.offset_x = 0\n        elif axisid == 4:\n            # invert Y axis to behave like mouse\n            if value < -dead:\n                self.offset_y = intensity\n            elif value > dead:\n                self.offset_y = -intensity\n            else:\n                self.offset_y = 0\n        else:\n            self.offset_x = 0\n            self.offset_y = 0",
  "def set_intensity(self, win, stickid, buttonid):\n        # set intensity of joycursor with joystick buttons\n        intensity = self.intensity\n        if buttonid == 0 and intensity > 2:\n            intensity -= 1\n        elif buttonid == 1:\n            intensity += 1\n        self.intensity = intensity",
  "def check_dispatch(self, win, stickid, buttonid):\n        if buttonid == 6:\n            self.cursor_hold = not self.cursor_hold\n        if buttonid not in (2, 3, 4, 5, 6):\n            return\n\n        x, y = self.center\n        # window event, correction necessary\n        y = self.win.system_size[1] - y\n        modifiers = []\n        actions = {\n            2: 'left',\n            3: 'right',\n            4: 'scrollup',\n            5: 'scrolldown',\n            6: 'left'\n        }\n        button = actions[buttonid]\n\n        self.win.dispatch('on_mouse_down', x, y, button, modifiers)\n        if not self.cursor_hold:\n            self.win.dispatch('on_mouse_up', x, y, button, modifiers)",
  "def move_cursor(self, *args):\n        # move joycursor as a mouse\n        self.pos[0] += self.offset_x\n        self.pos[1] += self.offset_y\n        modifiers = []\n        if self.cursor_hold:\n            self.win.dispatch(\n                'on_mouse_move',\n                self.center[0],\n                self.win.system_size[1] - self.center[1],\n                modifiers\n            )",
  "def stop_cursor(self, instance, mouse_pos):\n        # pin the cursor to the mouse pos\n        self.offset_x = 0\n        self.offset_y = 0\n        self.pos = (\n            mouse_pos[0] - self.size[0] / 2.0,\n            mouse_pos[1] - self.size[1] / 2.0\n        )",
  "def on_pos(self, instance, new_pos):\n        self.set_cursor()\n        self.cursor_x.points = self.cursor_pts[:4]\n        self.cursor_y.points = self.cursor_pts[4:]\n        self.cursor_ox.points = self.cursor_pts[:4]\n        self.cursor_oy.points = self.cursor_pts[4:]",
  "def keyboard_shortcuts(self, win, scancode, *args):\n        modifiers = args[-1]\n        if scancode == 101 and modifiers == ['ctrl']:\n            self.activated = not self.activated\n            return True\n        elif scancode == 27:\n            if self.activated:\n                self.activated = False\n                return True",
  "def joystick_shortcuts(self, win, stickid, buttonid):\n        if buttonid == 7:\n            self.activated = not self.activated\n            if self.activated:\n                self.pos = [round(i / 2.0) for i in win.size]",
  "class MissingOrderedDict(OrderedDict):\n\n    def __missing__(self, key):\n        self[key] = [0] * history_max\n        return self[key]",
  "def index():\n    return render_template_string(html_index)",
  "def metrics_json():\n    resp = make_response(json.dumps(metrics), 200)\n    resp.headers['Content-Type'] = 'text/json'\n    return resp",
  "def getfile(name):\n    name = name.replace('.', '_')\n    text = globals()[name]\n    resp = make_response(text, 200)\n    if name.endswith('_js'):\n        resp.headers['Content-Type'] = 'text/javascript'\n    elif name.endswith('_jpg'):\n        resp.headers['Content-Type'] = 'image/jpeg'\n    return resp",
  "class FlaskThread(threading.Thread):\n\n    def run(self):\n        Clock.schedule_interval(self.dump_metrics, .1)\n        app.run(debug=True, use_debugger=True, use_reloader=False)\n\n    def dump_metrics(self, dt):\n        m = metrics\n        m['Python objects'].append(len(get_objects()))\n        m['Python garbage'].append(len(garbage))\n        m['FPS (internal)'].append(Clock.get_fps())\n        m['FPS (real)'].append(Clock.get_rfps())\n        m['Events'].append(len(Clock.get_events()))\n        for category in Cache._categories:\n            m['Cache ' + category].append(\n                len(Cache._objects.get(category, [])))\n        for values in m.values():\n            values.pop(0)\n            values[0] = 0",
  "def start(win, ctx):\n    ctx.thread = FlaskThread()\n    ctx.thread.daemon = True\n    ctx.thread.start()",
  "def stop(win, ctx):\n    pass",
  "def __missing__(self, key):\n        self[key] = [0] * history_max\n        return self[key]",
  "def run(self):\n        Clock.schedule_interval(self.dump_metrics, .1)\n        app.run(debug=True, use_debugger=True, use_reloader=False)",
  "def dump_metrics(self, dt):\n        m = metrics\n        m['Python objects'].append(len(get_objects()))\n        m['Python garbage'].append(len(garbage))\n        m['FPS (internal)'].append(Clock.get_fps())\n        m['FPS (real)'].append(Clock.get_rfps())\n        m['Events'].append(len(Clock.get_events()))\n        for category in Cache._categories:\n            m['Cache ' + category].append(\n                len(Cache._objects.get(category, [])))\n        for values in m.values():\n            values.pop(0)\n            values[0] = 0",
  "def ignore_exception(f):\n    def f2(*args, **kwargs):\n        try:\n            return f(*args, **kwargs)\n        except:\n            pass\n\n    return f2",
  "class TreeViewProperty(BoxLayout, TreeViewNode):\n    key = ObjectProperty(None, allownone=True)\n    refresh = BooleanProperty(False)\n    widget_ref = ObjectProperty(None, allownone=True)\n\n    def _get_widget(self):\n        wr = self.widget_ref\n        if wr is None:\n            return None\n        wr = wr()\n        if wr is None:\n            self.widget_ref = None\n            return None\n        return wr\n\n    widget = AliasProperty(_get_widget, None, bind=('widget_ref', ))",
  "class ConsoleButton(Button):\n    \"\"\"Button specialized for the Console\"\"\"\n    pass",
  "class ConsoleToggleButton(ToggleButton):\n    \"\"\"ToggleButton specialized for the Console\"\"\"\n    pass",
  "class ConsoleLabel(Label):\n    \"\"\"LabelButton specialized for the Console\"\"\"\n    pass",
  "class ConsoleAddonSeparator(Widget):\n    pass",
  "class ConsoleAddon(object):\n    \"\"\"Base class for implementing addons\"\"\"\n\n    #: Console instance\n    console = None\n\n    def __init__(self, console):\n        super(ConsoleAddon, self).__init__()\n        self.console = console\n        self.init()\n\n    def init(self):\n        \"\"\"Method called when the addon is instantiated by the Console\n        \"\"\"\n        pass\n\n    def activate(self):\n        \"\"\"Method called when the addon is activated by the console\n        (when the console is displayed)\"\"\"\n        pass\n\n    def deactivate(self):\n        \"\"\"Method called when the addon is deactivated by the console\n        (when the console is hidden)\n        \"\"\"\n        pass",
  "class ConsoleAddonMode(ConsoleAddon):\n    def init(self):\n        btn = ConsoleToggleButton(text=u\"Docked\")\n        self.console.add_toolbar_widget(btn)",
  "class ConsoleAddonSelect(ConsoleAddon):\n    def init(self):\n        self.btn = ConsoleToggleButton(text=u\"Select\")\n        self.btn.bind(state=self.on_button_state)\n        self.console.add_toolbar_widget(self.btn)\n        self.console.bind(inspect_enabled=self.on_inspect_enabled)\n\n    def on_inspect_enabled(self, instance, value):\n        self.btn.state = \"down\" if value else \"normal\"\n\n    def on_button_state(self, instance, value):\n        self.console.inspect_enabled = (value == \"down\")",
  "class ConsoleAddonFps(ConsoleAddon):\n\n    _update_ev = None\n\n    def init(self):\n        self.lbl = ConsoleLabel(text=\"0 Fps\")\n        self.console.add_toolbar_widget(self.lbl, right=True)\n\n    def activate(self):\n        ev = self._update_ev\n        if ev is None:\n            self._update_ev = Clock.schedule_interval(self.update_fps, 1 / 2.)\n        else:\n            ev()\n\n    def deactivated(self):\n        if self._update_ev is not None:\n            self._update_ev.cancel()\n\n    def update_fps(self, *args):\n        fps = Clock.get_fps()\n        self.lbl.text = \"{} Fps\".format(int(fps))",
  "class ConsoleAddonBreadcrumbView(RelativeLayout):\n    widget = ObjectProperty(None, allownone=True)\n    parents = []\n\n    def on_widget(self, instance, value):\n        stack = self.ids.stack\n\n        # determine if we can just highlight the current one\n        # or if we need to rebuild the breadcrumb\n        prefs = [btn.widget_ref() for btn in self.parents]\n        if value in prefs:\n            # ok, so just toggle this one instead.\n            index = prefs.index(value)\n            for btn in self.parents:\n                btn.state = \"normal\"\n            self.parents[index].state = \"down\"\n            return\n\n        # we need to rebuild the breadcrumb.\n        stack.clear_widgets()\n        if not value:\n            return\n        widget = value\n        parents = []\n        while True:\n            btn = ConsoleButton(text=widget.__class__.__name__)\n            btn.widget_ref = weakref.ref(widget)\n            btn.bind(on_release=self.highlight_widget)\n            parents.append(btn)\n            if widget == widget.parent:\n                break\n            widget = widget.parent\n        for btn in reversed(parents):\n            stack.add_widget(btn)\n        self.ids.sv.scroll_x = 1\n        self.parents = parents\n        btn.state = \"down\"\n\n    def highlight_widget(self, instance):\n        self.console.widget = instance.widget_ref()",
  "class ConsoleAddonBreadcrumb(ConsoleAddon):\n    def init(self):\n        self.view = ConsoleAddonBreadcrumbView()\n        self.view.console = self.console\n        self.console.ids.layout.add_widget(self.view)\n\n    def activate(self):\n        self.console.bind(widget=self.update_content)\n        self.update_content()\n\n    def deactivate(self):\n        self.console.unbind(widget=self.update_content)\n\n    def update_content(self, *args):\n        self.view.widget = self.console.widget",
  "class ConsoleAddonWidgetPanel(ConsoleAddon):\n    def init(self):\n        self.console.add_panel(\"Properties\", self.panel_activate,\n                               self.deactivate)\n\n    def panel_activate(self):\n        self.console.bind(widget=self.update_content)\n        self.update_content()\n\n    def deactivate(self):\n        self.console.unbind(widget=self.update_content)\n\n    def update_content(self, *args):\n        widget = self.console.widget\n        if not widget:\n            return\n\n        from kivy.uix.scrollview import ScrollView\n        self.root = root = BoxLayout()\n        self.sv = sv = ScrollView(scroll_type=[\"bars\", \"content\"],\n                                  bar_width='10dp')\n        treeview = TreeView(hide_root=True, size_hint_y=None)\n        treeview.bind(minimum_height=treeview.setter(\"height\"))\n        keys = list(widget.properties().keys())\n        keys.sort()\n        node = None\n        wk_widget = weakref.ref(widget)\n        for key in keys:\n            node = TreeViewProperty(key=key, widget_ref=wk_widget)\n            node.bind(is_selected=self.show_property)\n            try:\n                widget.bind(**{\n                    key: partial(self.update_node_content, weakref.ref(node))\n                })\n            except:\n                pass\n            treeview.add_node(node)\n\n        root.add_widget(sv)\n        sv.add_widget(treeview)\n        self.console.set_content(root)\n\n    def show_property(self, instance, value, key=None, index=-1, *l):\n        # normal call: (tree node, focus, )\n        # nested call: (widget, prop value, prop key, index in dict/list)\n        if value is False:\n            return\n\n        console = self.console\n        content = None\n        if key is None:\n            # normal call\n            nested = False\n            widget = instance.widget\n            key = instance.key\n            prop = widget.property(key)\n            value = getattr(widget, key)\n        else:\n            # nested call, we might edit subvalue\n            nested = True\n            widget = instance\n            prop = None\n\n        dtype = None\n\n        if isinstance(prop, AliasProperty) or nested:\n            # trying to resolve type dynamically\n            if type(value) in (str, str):\n                dtype = 'string'\n            elif type(value) in (int, float):\n                dtype = 'numeric'\n            elif type(value) in (tuple, list):\n                dtype = 'list'\n\n        if isinstance(prop, NumericProperty) or dtype == 'numeric':\n            content = TextInput(text=str(value) or '', multiline=False)\n            content.bind(\n                text=partial(self.save_property_numeric, widget, key, index))\n\n        elif isinstance(prop, StringProperty) or dtype == 'string':\n            content = TextInput(text=value or '', multiline=True)\n            content.bind(\n                text=partial(self.save_property_text, widget, key, index))\n\n        elif (isinstance(prop, ListProperty) or\n              isinstance(prop, ReferenceListProperty) or\n              isinstance(prop, VariableListProperty) or dtype == 'list'):\n            content = GridLayout(cols=1, size_hint_y=None)\n            content.bind(minimum_height=content.setter('height'))\n            for i, item in enumerate(value):\n                button = Button(text=repr(item), size_hint_y=None, height=44)\n                if isinstance(item, Widget):\n                    button.bind(on_release=partial(console.highlight_widget,\n                                                   item, False))\n                else:\n                    button.bind(on_release=partial(self.show_property, widget,\n                                                   item, key, i))\n                content.add_widget(button)\n\n        elif isinstance(prop, OptionProperty):\n            content = GridLayout(cols=1, size_hint_y=None)\n            content.bind(minimum_height=content.setter('height'))\n            for option in prop.options:\n                button = ToggleButton(\n                    text=option,\n                    state='down' if option == value else 'normal',\n                    group=repr(content.uid),\n                    size_hint_y=None,\n                    height=44)\n                button.bind(\n                    on_press=partial(self.save_property_option, widget, key))\n                content.add_widget(button)\n\n        elif isinstance(prop, ObjectProperty):\n            if isinstance(value, Widget):\n                content = Button(text=repr(value))\n                content.bind(\n                    on_release=partial(console.highlight_widget, value))\n            elif isinstance(value, Texture):\n                content = Image(texture=value)\n            else:\n                content = Label(text=repr(value))\n\n        elif isinstance(prop, BooleanProperty):\n            state = 'down' if value else 'normal'\n            content = ToggleButton(text=key, state=state)\n            content.bind(on_release=partial(self.save_property_boolean, widget,\n                                            key, index))\n\n        self.root.clear_widgets()\n        self.root.add_widget(self.sv)\n        if content:\n            self.root.add_widget(content)\n\n    @ignore_exception\n    def save_property_numeric(self, widget, key, index, instance, value):\n        if index >= 0:\n            getattr(widget, key)[index] = float(instance.text)\n        else:\n            setattr(widget, key, float(instance.text))\n\n    @ignore_exception\n    def save_property_text(self, widget, key, index, instance, value):\n        if index >= 0:\n            getattr(widget, key)[index] = instance.text\n        else:\n            setattr(widget, key, instance.text)\n\n    @ignore_exception\n    def save_property_boolean(self, widget, key, index, instance, ):\n        value = instance.state == 'down'\n        if index >= 0:\n            getattr(widget, key)[index] = value\n        else:\n            setattr(widget, key, value)\n\n    @ignore_exception\n    def save_property_option(self, widget, key, instance, *l):\n        setattr(widget, key, instance.text)",
  "class TreeViewWidget(Label, TreeViewNode):\n    widget = ObjectProperty(None)",
  "class ConsoleAddonWidgetTreeImpl(TreeView):\n    selected_widget = ObjectProperty(None, allownone=True)\n\n    __events__ = ('on_select_widget', )\n\n    def __init__(self, **kwargs):\n        super(ConsoleAddonWidgetTreeImpl, self).__init__(**kwargs)\n        self.update_scroll = Clock.create_trigger(self._update_scroll)\n\n    def find_node_by_widget(self, widget):\n        for node in self.iterate_all_nodes():\n            if not node.parent_node:\n                continue\n            try:\n                if node.widget == widget:\n                    return node\n            except ReferenceError:\n                pass\n        return None\n\n    def update_selected_widget(self, widget):\n        if widget:\n            node = self.find_node_by_widget(widget)\n            if node:\n                self.select_node(node, False)\n                while node and isinstance(node, TreeViewWidget):\n                    if not node.is_open:\n                        self.toggle_node(node)\n                    node = node.parent_node\n\n    def on_selected_widget(self, inst, widget):\n        if widget:\n            self.update_selected_widget(widget)\n            self.update_scroll()\n\n    def select_node(self, node, select_widget=True):\n        super(ConsoleAddonWidgetTreeImpl, self).select_node(node)\n        if select_widget:\n            try:\n                self.dispatch(\"on_select_widget\", node.widget.__self__)\n            except ReferenceError:\n                pass\n\n    def on_select_widget(self, widget):\n        pass\n\n    def _update_scroll(self, *args):\n        node = self._selected_node\n        if not node:\n            return\n\n        self.parent.scroll_to(node)",
  "class ConsoleAddonWidgetTreeView(RelativeLayout):\n    widget = ObjectProperty(None, allownone=True)\n    _window_node = None\n\n    def _update_widget_tree_node(self, node, widget, is_open=False):\n        tree = self.ids.widgettree\n        update_nodes = []\n        nodes = {}\n        for cnode in node.nodes[:]:\n            try:\n                nodes[cnode.widget] = cnode\n            except ReferenceError:\n                # widget no longer exists, just remove it\n                pass\n            tree.remove_node(cnode)\n        for child in widget.children:\n            if isinstance(child, Console):\n                continue\n            if child in nodes:\n                cnode = tree.add_node(nodes[child], node)\n            else:\n                cnode = tree.add_node(\n                    TreeViewWidget(text=child.__class__.__name__,\n                                   widget=child.proxy_ref,\n                                   is_open=is_open), node)\n            update_nodes.append((cnode, child))\n        return update_nodes\n\n    def update_widget_tree(self, *args):\n        win = self.console.win\n        if not self._window_node:\n            self._window_node = self.ids.widgettree.add_node(\n                TreeViewWidget(text=\"Window\",\n                               widget=win,\n                               is_open=True))\n\n        nodes = self._update_widget_tree_node(self._window_node, win,\n                                              is_open=True)\n        while nodes:\n            ntmp = nodes[:]\n            nodes = []\n            for node in ntmp:\n                nodes += self._update_widget_tree_node(*node)\n\n        self.ids.widgettree.update_selected_widget(self.widget)",
  "class ConsoleAddonWidgetTree(ConsoleAddon):\n    def init(self):\n        self.content = None\n        self.console.add_panel(\"Tree\", self.panel_activate, self.deactivate,\n                               self.panel_refresh)\n\n    def panel_activate(self):\n        self.console.bind(widget=self.update_content)\n        self.update_content()\n\n    def deactivate(self):\n        if self.content:\n            self.content.widget = None\n            self.content.console = None\n        self.console.unbind(widget=self.update_content)\n\n    def update_content(self, *args):\n        widget = self.console.widget\n        if not self.content:\n            self.content = ConsoleAddonWidgetTreeView()\n        self.content.console = self.console\n        self.content.widget = widget\n        self.content.update_widget_tree()\n        self.console.set_content(self.content)\n\n    def panel_refresh(self):\n        if self.content:\n            self.content.update_widget_tree()",
  "class Console(RelativeLayout):\n    \"\"\"Console interface\n\n    This widget is created by create_console(), when the module is loaded.\n    During that time, you can add addons on the console to extend the\n    functionalities, or add your own application stats / debugging module.\n    \"\"\"\n\n    #: Array of addons that will be created at Console creation\n    addons = [  # ConsoleAddonMode,\n        ConsoleAddonSelect, ConsoleAddonFps, ConsoleAddonWidgetPanel,\n        ConsoleAddonWidgetTree, ConsoleAddonBreadcrumb]\n\n    #: Display mode of the Console, either docked at the bottom, or as a\n    #: floating window.\n    mode = OptionProperty(\"docked\", options=[\"docked\", \"floated\"])\n\n    #: Current widget being selected\n    widget = ObjectProperty(None, allownone=True)\n\n    #: Indicate if the inspector inspection is enabled. If yes, the next\n    #: touch down will select a the widget under the touch\n    inspect_enabled = BooleanProperty(False)\n\n    #: True if the Console is activated (showed)\n    activated = BooleanProperty(False)\n\n    def __init__(self, **kwargs):\n        self.win = kwargs.pop('win', None)\n        super(Console, self).__init__(**kwargs)\n        self.avoid_bring_to_top = False\n        with self.canvas.before:\n            self.gcolor = Color(1, 0, 0, .25)\n            PushMatrix()\n            self.gtransform = Transform(Matrix())\n            self.grect = Rectangle(size=(0, 0))\n            PopMatrix()\n        Clock.schedule_interval(self.update_widget_graphics, 0)\n\n        # instantiate all addons\n        self._toolbar = {\"left\": [], \"panels\": [], \"right\": []}\n        self._addons = []\n        self._panel = None\n        for addon in self.addons:\n            instance = addon(self)\n            self._addons.append(instance)\n        self._init_toolbar()\n        # select the first panel\n        self._panel = self._toolbar[\"panels\"][0]\n        self._panel.state = \"down\"\n        self._panel.cb_activate()\n\n    def _init_toolbar(self):\n        toolbar = self.ids.toolbar\n        for key in (\"left\", \"panels\", \"right\"):\n            if key == \"right\":\n                toolbar.add_widget(Widget())\n            for el in self._toolbar[key]:\n                toolbar.add_widget(el)\n            if key != \"right\":\n                toolbar.add_widget(ConsoleAddonSeparator())\n\n    @classmethod\n    def register_addon(cls, addon):\n        cls.addons.append(addon)\n\n    def add_toolbar_widget(self, widget, right=False):\n        \"\"\"Add a widget in the top left toolbar of the Console.\n        Use `right=True` if you wanna add the widget at the right instead.\n        \"\"\"\n        key = \"right\" if right else \"left\"\n        self._toolbar[key].append(widget)\n\n    def remove_toolbar_widget(self, widget):\n        \"\"\"Remove a widget from the toolbar\n        \"\"\"\n        self.ids.toolbar.remove_widget(widget)\n\n    def add_panel(self, name, cb_activate, cb_deactivate, cb_refresh=None):\n        \"\"\"Add a new panel in the Console.\n\n        - `cb_activate` is a callable that will be called when the panel is\n          activated by the user.\n\n        - `cb_deactivate` is a callable that will be called when the panel is\n          deactivated or when the console will hide.\n\n        - `cb_refresh` is an optional callable that is called if the user\n          click again on the button for display the panel\n\n        When activated, it's up to the panel to display a content in the\n        Console by using :meth:`set_content`.\n        \"\"\"\n        btn = ConsoleToggleButton(text=name)\n        btn.cb_activate = cb_activate\n        btn.cb_deactivate = cb_deactivate\n        btn.cb_refresh = cb_refresh\n        btn.bind(on_press=self._activate_panel)\n        self._toolbar[\"panels\"].append(btn)\n\n    def _activate_panel(self, instance):\n        if self._panel != instance:\n            self._panel.cb_deactivate()\n            self._panel.state = \"normal\"\n            self.ids.content.clear_widgets()\n            self._panel = instance\n            self._panel.cb_activate()\n            self._panel.state = \"down\"\n        else:\n            self._panel.state = \"down\"\n            if self._panel.cb_refresh:\n                self._panel.cb_refresh()\n\n    def set_content(self, content):\n        \"\"\"Replace the Console content with a new one.\n        \"\"\"\n        self.ids.content.clear_widgets()\n        self.ids.content.add_widget(content)\n\n    def on_touch_down(self, touch):\n        ret = super(Console, self).on_touch_down(touch)\n        if (('button' not in touch.profile or touch.button == 'left') and\n                not ret and self.inspect_enabled):\n            self.highlight_at(*touch.pos)\n            if touch.is_double_tap:\n                self.inspect_enabled = False\n            ret = True\n        else:\n            ret = self.collide_point(*touch.pos)\n        return ret\n\n    def on_touch_move(self, touch):\n        ret = super(Console, self).on_touch_move(touch)\n        if not ret and self.inspect_enabled:\n            self.highlight_at(*touch.pos)\n            ret = True\n        return ret\n\n    def on_touch_up(self, touch):\n        ret = super(Console, self).on_touch_up(touch)\n        if not ret and self.inspect_enabled:\n            ret = True\n        return ret\n\n    def on_window_children(self, win, children):\n        if self.avoid_bring_to_top or not self.activated:\n            return\n        self.avoid_bring_to_top = True\n        win.remove_widget(self)\n        win.add_widget(self)\n        self.avoid_bring_to_top = False\n\n    def highlight_at(self, x, y):\n        \"\"\"Select a widget from a x/y window coordinate.\n        This is mostly used internally when Select mode is activated\n        \"\"\"\n        widget = None\n        # reverse the loop - look at children on top first and\n        # modalviews before others\n        win_children = self.win.children\n        children = chain((c for c in reversed(win_children)\n                          if isinstance(c, ModalView)),\n                         (c for c in reversed(win_children)\n                          if not isinstance(c, ModalView)))\n        for child in children:\n            if child is self:\n                continue\n            widget = self.pick(child, x, y)\n            if widget:\n                break\n        self.highlight_widget(widget)\n\n    def highlight_widget(self, widget, *largs):\n        # no widget to highlight, reduce rectangle to 0, 0\n        self.widget = widget\n        if not widget:\n            self.grect.size = 0, 0\n\n    def update_widget_graphics(self, *l):\n        if not self.activated:\n            return\n        if self.widget is None:\n            self.grect.size = 0, 0\n            return\n        self.grect.size = self.widget.size\n        matrix = self.widget.get_window_matrix()\n        if self.gtransform.matrix.get() != matrix.get():\n            self.gtransform.matrix = matrix\n\n    def pick(self, widget, x, y):\n        \"\"\"Pick a widget at x/y, given a root `widget`\n        \"\"\"\n        ret = None\n        # try to filter widgets that are not visible (invalid inspect target)\n        if (hasattr(widget, 'visible') and not widget.visible):\n            return ret\n        if widget.collide_point(x, y):\n            ret = widget\n            x2, y2 = widget.to_local(x, y)\n            # reverse the loop - look at children on top first\n            for child in reversed(widget.children):\n                ret = self.pick(child, x2, y2) or ret\n        return ret\n\n    def on_activated(self, instance, activated):\n        if activated:\n            self._activate_console()\n        else:\n            self._deactivate_console()\n\n    def _activate_console(self):\n        if self not in self.win.children:\n            self.win.add_widget(self)\n        self.y = 0\n        for addon in self._addons:\n            addon.activate()\n        Logger.info('Console: console activated')\n\n    def _deactivate_console(self):\n        for addon in self._addons:\n            addon.deactivate()\n        self.grect.size = 0, 0\n        self.y = -self.height\n        self.widget = None\n        self.inspect_enabled = False\n        # self.win.remove_widget(self)\n        self._window_node = None\n        Logger.info('Console: console deactivated')\n\n    def keyboard_shortcut(self, win, scancode, *largs):\n        modifiers = largs[-1]\n        if scancode == 101 and modifiers == ['ctrl']:\n            self.activated = not self.activated\n            if self.activated:\n                self.inspect_enabled = True\n            return True\n\n        elif scancode == 27:\n            if self.inspect_enabled:\n                self.inspect_enabled = False\n                return True\n            if self.activated:\n                self.activated = False\n                return True\n\n        if not self.activated or not self.widget:\n            return\n\n        if scancode == 273:  # top\n            self.widget = self.widget.parent\n\n        elif scancode == 274:  # down\n            filtered_children = [c for c in self.widget.children\n                                 if not isinstance(c, Console)]\n            if filtered_children:\n                self.widget = filtered_children[0]\n\n        elif scancode == 276:  # left\n            parent = self.widget.parent\n            filtered_children = [c for c in parent.children\n                                 if not isinstance(c, Console)]\n            index = filtered_children.index(self.widget)\n            index = max(0, index - 1)\n            self.widget = filtered_children[index]\n\n        elif scancode == 275:  # right\n            parent = self.widget.parent\n            filtered_children = [c for c in parent.children\n                                 if not isinstance(c, Console)]\n            index = filtered_children.index(self.widget)\n            index = min(len(filtered_children) - 1, index + 1)\n            self.widget = filtered_children[index]",
  "def create_console(win, ctx, *l):\n    ctx.console = Console(win=win)\n    win.bind(children=ctx.console.on_window_children,\n             on_keyboard=ctx.console.keyboard_shortcut)",
  "def start(win, ctx):\n    \"\"\"Create an Console instance attached to the *ctx* and bound to the\n    Window's :meth:`~kivy.core.window.WindowBase.on_keyboard` event for\n    capturing the keyboard shortcut.\n\n        :Parameters:\n            `win`: A :class:`Window <kivy.core.window.WindowBase>`\n                The application Window to bind to.\n            `ctx`: A :class:`~kivy.uix.widget.Widget` or subclass\n                The Widget to be inspected.\n\n    \"\"\"\n    Clock.schedule_once(partial(create_console, win, ctx))",
  "def stop(win, ctx):\n    \"\"\"Stop and unload any active Inspectors for the given *ctx*.\"\"\"\n    if hasattr(ctx, \"console\"):\n        win.unbind(children=ctx.console.on_window_children,\n                   on_keyboard=ctx.console.keyboard_shortcut)\n        win.remove_widget(ctx.console)\n        del ctx.console",
  "def f2(*args, **kwargs):\n        try:\n            return f(*args, **kwargs)\n        except:\n            pass",
  "def _get_widget(self):\n        wr = self.widget_ref\n        if wr is None:\n            return None\n        wr = wr()\n        if wr is None:\n            self.widget_ref = None\n            return None\n        return wr",
  "def __init__(self, console):\n        super(ConsoleAddon, self).__init__()\n        self.console = console\n        self.init()",
  "def init(self):\n        \"\"\"Method called when the addon is instantiated by the Console\n        \"\"\"\n        pass",
  "def activate(self):\n        \"\"\"Method called when the addon is activated by the console\n        (when the console is displayed)\"\"\"\n        pass",
  "def deactivate(self):\n        \"\"\"Method called when the addon is deactivated by the console\n        (when the console is hidden)\n        \"\"\"\n        pass",
  "def init(self):\n        btn = ConsoleToggleButton(text=u\"Docked\")\n        self.console.add_toolbar_widget(btn)",
  "def init(self):\n        self.btn = ConsoleToggleButton(text=u\"Select\")\n        self.btn.bind(state=self.on_button_state)\n        self.console.add_toolbar_widget(self.btn)\n        self.console.bind(inspect_enabled=self.on_inspect_enabled)",
  "def on_inspect_enabled(self, instance, value):\n        self.btn.state = \"down\" if value else \"normal\"",
  "def on_button_state(self, instance, value):\n        self.console.inspect_enabled = (value == \"down\")",
  "def init(self):\n        self.lbl = ConsoleLabel(text=\"0 Fps\")\n        self.console.add_toolbar_widget(self.lbl, right=True)",
  "def activate(self):\n        ev = self._update_ev\n        if ev is None:\n            self._update_ev = Clock.schedule_interval(self.update_fps, 1 / 2.)\n        else:\n            ev()",
  "def deactivated(self):\n        if self._update_ev is not None:\n            self._update_ev.cancel()",
  "def update_fps(self, *args):\n        fps = Clock.get_fps()\n        self.lbl.text = \"{} Fps\".format(int(fps))",
  "def on_widget(self, instance, value):\n        stack = self.ids.stack\n\n        # determine if we can just highlight the current one\n        # or if we need to rebuild the breadcrumb\n        prefs = [btn.widget_ref() for btn in self.parents]\n        if value in prefs:\n            # ok, so just toggle this one instead.\n            index = prefs.index(value)\n            for btn in self.parents:\n                btn.state = \"normal\"\n            self.parents[index].state = \"down\"\n            return\n\n        # we need to rebuild the breadcrumb.\n        stack.clear_widgets()\n        if not value:\n            return\n        widget = value\n        parents = []\n        while True:\n            btn = ConsoleButton(text=widget.__class__.__name__)\n            btn.widget_ref = weakref.ref(widget)\n            btn.bind(on_release=self.highlight_widget)\n            parents.append(btn)\n            if widget == widget.parent:\n                break\n            widget = widget.parent\n        for btn in reversed(parents):\n            stack.add_widget(btn)\n        self.ids.sv.scroll_x = 1\n        self.parents = parents\n        btn.state = \"down\"",
  "def highlight_widget(self, instance):\n        self.console.widget = instance.widget_ref()",
  "def init(self):\n        self.view = ConsoleAddonBreadcrumbView()\n        self.view.console = self.console\n        self.console.ids.layout.add_widget(self.view)",
  "def activate(self):\n        self.console.bind(widget=self.update_content)\n        self.update_content()",
  "def deactivate(self):\n        self.console.unbind(widget=self.update_content)",
  "def update_content(self, *args):\n        self.view.widget = self.console.widget",
  "def init(self):\n        self.console.add_panel(\"Properties\", self.panel_activate,\n                               self.deactivate)",
  "def panel_activate(self):\n        self.console.bind(widget=self.update_content)\n        self.update_content()",
  "def deactivate(self):\n        self.console.unbind(widget=self.update_content)",
  "def update_content(self, *args):\n        widget = self.console.widget\n        if not widget:\n            return\n\n        from kivy.uix.scrollview import ScrollView\n        self.root = root = BoxLayout()\n        self.sv = sv = ScrollView(scroll_type=[\"bars\", \"content\"],\n                                  bar_width='10dp')\n        treeview = TreeView(hide_root=True, size_hint_y=None)\n        treeview.bind(minimum_height=treeview.setter(\"height\"))\n        keys = list(widget.properties().keys())\n        keys.sort()\n        node = None\n        wk_widget = weakref.ref(widget)\n        for key in keys:\n            node = TreeViewProperty(key=key, widget_ref=wk_widget)\n            node.bind(is_selected=self.show_property)\n            try:\n                widget.bind(**{\n                    key: partial(self.update_node_content, weakref.ref(node))\n                })\n            except:\n                pass\n            treeview.add_node(node)\n\n        root.add_widget(sv)\n        sv.add_widget(treeview)\n        self.console.set_content(root)",
  "def show_property(self, instance, value, key=None, index=-1, *l):\n        # normal call: (tree node, focus, )\n        # nested call: (widget, prop value, prop key, index in dict/list)\n        if value is False:\n            return\n\n        console = self.console\n        content = None\n        if key is None:\n            # normal call\n            nested = False\n            widget = instance.widget\n            key = instance.key\n            prop = widget.property(key)\n            value = getattr(widget, key)\n        else:\n            # nested call, we might edit subvalue\n            nested = True\n            widget = instance\n            prop = None\n\n        dtype = None\n\n        if isinstance(prop, AliasProperty) or nested:\n            # trying to resolve type dynamically\n            if type(value) in (str, str):\n                dtype = 'string'\n            elif type(value) in (int, float):\n                dtype = 'numeric'\n            elif type(value) in (tuple, list):\n                dtype = 'list'\n\n        if isinstance(prop, NumericProperty) or dtype == 'numeric':\n            content = TextInput(text=str(value) or '', multiline=False)\n            content.bind(\n                text=partial(self.save_property_numeric, widget, key, index))\n\n        elif isinstance(prop, StringProperty) or dtype == 'string':\n            content = TextInput(text=value or '', multiline=True)\n            content.bind(\n                text=partial(self.save_property_text, widget, key, index))\n\n        elif (isinstance(prop, ListProperty) or\n              isinstance(prop, ReferenceListProperty) or\n              isinstance(prop, VariableListProperty) or dtype == 'list'):\n            content = GridLayout(cols=1, size_hint_y=None)\n            content.bind(minimum_height=content.setter('height'))\n            for i, item in enumerate(value):\n                button = Button(text=repr(item), size_hint_y=None, height=44)\n                if isinstance(item, Widget):\n                    button.bind(on_release=partial(console.highlight_widget,\n                                                   item, False))\n                else:\n                    button.bind(on_release=partial(self.show_property, widget,\n                                                   item, key, i))\n                content.add_widget(button)\n\n        elif isinstance(prop, OptionProperty):\n            content = GridLayout(cols=1, size_hint_y=None)\n            content.bind(minimum_height=content.setter('height'))\n            for option in prop.options:\n                button = ToggleButton(\n                    text=option,\n                    state='down' if option == value else 'normal',\n                    group=repr(content.uid),\n                    size_hint_y=None,\n                    height=44)\n                button.bind(\n                    on_press=partial(self.save_property_option, widget, key))\n                content.add_widget(button)\n\n        elif isinstance(prop, ObjectProperty):\n            if isinstance(value, Widget):\n                content = Button(text=repr(value))\n                content.bind(\n                    on_release=partial(console.highlight_widget, value))\n            elif isinstance(value, Texture):\n                content = Image(texture=value)\n            else:\n                content = Label(text=repr(value))\n\n        elif isinstance(prop, BooleanProperty):\n            state = 'down' if value else 'normal'\n            content = ToggleButton(text=key, state=state)\n            content.bind(on_release=partial(self.save_property_boolean, widget,\n                                            key, index))\n\n        self.root.clear_widgets()\n        self.root.add_widget(self.sv)\n        if content:\n            self.root.add_widget(content)",
  "def save_property_numeric(self, widget, key, index, instance, value):\n        if index >= 0:\n            getattr(widget, key)[index] = float(instance.text)\n        else:\n            setattr(widget, key, float(instance.text))",
  "def save_property_text(self, widget, key, index, instance, value):\n        if index >= 0:\n            getattr(widget, key)[index] = instance.text\n        else:\n            setattr(widget, key, instance.text)",
  "def save_property_boolean(self, widget, key, index, instance, ):\n        value = instance.state == 'down'\n        if index >= 0:\n            getattr(widget, key)[index] = value\n        else:\n            setattr(widget, key, value)",
  "def save_property_option(self, widget, key, instance, *l):\n        setattr(widget, key, instance.text)",
  "def __init__(self, **kwargs):\n        super(ConsoleAddonWidgetTreeImpl, self).__init__(**kwargs)\n        self.update_scroll = Clock.create_trigger(self._update_scroll)",
  "def find_node_by_widget(self, widget):\n        for node in self.iterate_all_nodes():\n            if not node.parent_node:\n                continue\n            try:\n                if node.widget == widget:\n                    return node\n            except ReferenceError:\n                pass\n        return None",
  "def update_selected_widget(self, widget):\n        if widget:\n            node = self.find_node_by_widget(widget)\n            if node:\n                self.select_node(node, False)\n                while node and isinstance(node, TreeViewWidget):\n                    if not node.is_open:\n                        self.toggle_node(node)\n                    node = node.parent_node",
  "def on_selected_widget(self, inst, widget):\n        if widget:\n            self.update_selected_widget(widget)\n            self.update_scroll()",
  "def select_node(self, node, select_widget=True):\n        super(ConsoleAddonWidgetTreeImpl, self).select_node(node)\n        if select_widget:\n            try:\n                self.dispatch(\"on_select_widget\", node.widget.__self__)\n            except ReferenceError:\n                pass",
  "def on_select_widget(self, widget):\n        pass",
  "def _update_scroll(self, *args):\n        node = self._selected_node\n        if not node:\n            return\n\n        self.parent.scroll_to(node)",
  "def _update_widget_tree_node(self, node, widget, is_open=False):\n        tree = self.ids.widgettree\n        update_nodes = []\n        nodes = {}\n        for cnode in node.nodes[:]:\n            try:\n                nodes[cnode.widget] = cnode\n            except ReferenceError:\n                # widget no longer exists, just remove it\n                pass\n            tree.remove_node(cnode)\n        for child in widget.children:\n            if isinstance(child, Console):\n                continue\n            if child in nodes:\n                cnode = tree.add_node(nodes[child], node)\n            else:\n                cnode = tree.add_node(\n                    TreeViewWidget(text=child.__class__.__name__,\n                                   widget=child.proxy_ref,\n                                   is_open=is_open), node)\n            update_nodes.append((cnode, child))\n        return update_nodes",
  "def update_widget_tree(self, *args):\n        win = self.console.win\n        if not self._window_node:\n            self._window_node = self.ids.widgettree.add_node(\n                TreeViewWidget(text=\"Window\",\n                               widget=win,\n                               is_open=True))\n\n        nodes = self._update_widget_tree_node(self._window_node, win,\n                                              is_open=True)\n        while nodes:\n            ntmp = nodes[:]\n            nodes = []\n            for node in ntmp:\n                nodes += self._update_widget_tree_node(*node)\n\n        self.ids.widgettree.update_selected_widget(self.widget)",
  "def init(self):\n        self.content = None\n        self.console.add_panel(\"Tree\", self.panel_activate, self.deactivate,\n                               self.panel_refresh)",
  "def panel_activate(self):\n        self.console.bind(widget=self.update_content)\n        self.update_content()",
  "def deactivate(self):\n        if self.content:\n            self.content.widget = None\n            self.content.console = None\n        self.console.unbind(widget=self.update_content)",
  "def update_content(self, *args):\n        widget = self.console.widget\n        if not self.content:\n            self.content = ConsoleAddonWidgetTreeView()\n        self.content.console = self.console\n        self.content.widget = widget\n        self.content.update_widget_tree()\n        self.console.set_content(self.content)",
  "def panel_refresh(self):\n        if self.content:\n            self.content.update_widget_tree()",
  "def __init__(self, **kwargs):\n        self.win = kwargs.pop('win', None)\n        super(Console, self).__init__(**kwargs)\n        self.avoid_bring_to_top = False\n        with self.canvas.before:\n            self.gcolor = Color(1, 0, 0, .25)\n            PushMatrix()\n            self.gtransform = Transform(Matrix())\n            self.grect = Rectangle(size=(0, 0))\n            PopMatrix()\n        Clock.schedule_interval(self.update_widget_graphics, 0)\n\n        # instantiate all addons\n        self._toolbar = {\"left\": [], \"panels\": [], \"right\": []}\n        self._addons = []\n        self._panel = None\n        for addon in self.addons:\n            instance = addon(self)\n            self._addons.append(instance)\n        self._init_toolbar()\n        # select the first panel\n        self._panel = self._toolbar[\"panels\"][0]\n        self._panel.state = \"down\"\n        self._panel.cb_activate()",
  "def _init_toolbar(self):\n        toolbar = self.ids.toolbar\n        for key in (\"left\", \"panels\", \"right\"):\n            if key == \"right\":\n                toolbar.add_widget(Widget())\n            for el in self._toolbar[key]:\n                toolbar.add_widget(el)\n            if key != \"right\":\n                toolbar.add_widget(ConsoleAddonSeparator())",
  "def register_addon(cls, addon):\n        cls.addons.append(addon)",
  "def add_toolbar_widget(self, widget, right=False):\n        \"\"\"Add a widget in the top left toolbar of the Console.\n        Use `right=True` if you wanna add the widget at the right instead.\n        \"\"\"\n        key = \"right\" if right else \"left\"\n        self._toolbar[key].append(widget)",
  "def remove_toolbar_widget(self, widget):\n        \"\"\"Remove a widget from the toolbar\n        \"\"\"\n        self.ids.toolbar.remove_widget(widget)",
  "def add_panel(self, name, cb_activate, cb_deactivate, cb_refresh=None):\n        \"\"\"Add a new panel in the Console.\n\n        - `cb_activate` is a callable that will be called when the panel is\n          activated by the user.\n\n        - `cb_deactivate` is a callable that will be called when the panel is\n          deactivated or when the console will hide.\n\n        - `cb_refresh` is an optional callable that is called if the user\n          click again on the button for display the panel\n\n        When activated, it's up to the panel to display a content in the\n        Console by using :meth:`set_content`.\n        \"\"\"\n        btn = ConsoleToggleButton(text=name)\n        btn.cb_activate = cb_activate\n        btn.cb_deactivate = cb_deactivate\n        btn.cb_refresh = cb_refresh\n        btn.bind(on_press=self._activate_panel)\n        self._toolbar[\"panels\"].append(btn)",
  "def _activate_panel(self, instance):\n        if self._panel != instance:\n            self._panel.cb_deactivate()\n            self._panel.state = \"normal\"\n            self.ids.content.clear_widgets()\n            self._panel = instance\n            self._panel.cb_activate()\n            self._panel.state = \"down\"\n        else:\n            self._panel.state = \"down\"\n            if self._panel.cb_refresh:\n                self._panel.cb_refresh()",
  "def set_content(self, content):\n        \"\"\"Replace the Console content with a new one.\n        \"\"\"\n        self.ids.content.clear_widgets()\n        self.ids.content.add_widget(content)",
  "def on_touch_down(self, touch):\n        ret = super(Console, self).on_touch_down(touch)\n        if (('button' not in touch.profile or touch.button == 'left') and\n                not ret and self.inspect_enabled):\n            self.highlight_at(*touch.pos)\n            if touch.is_double_tap:\n                self.inspect_enabled = False\n            ret = True\n        else:\n            ret = self.collide_point(*touch.pos)\n        return ret",
  "def on_touch_move(self, touch):\n        ret = super(Console, self).on_touch_move(touch)\n        if not ret and self.inspect_enabled:\n            self.highlight_at(*touch.pos)\n            ret = True\n        return ret",
  "def on_touch_up(self, touch):\n        ret = super(Console, self).on_touch_up(touch)\n        if not ret and self.inspect_enabled:\n            ret = True\n        return ret",
  "def on_window_children(self, win, children):\n        if self.avoid_bring_to_top or not self.activated:\n            return\n        self.avoid_bring_to_top = True\n        win.remove_widget(self)\n        win.add_widget(self)\n        self.avoid_bring_to_top = False",
  "def highlight_at(self, x, y):\n        \"\"\"Select a widget from a x/y window coordinate.\n        This is mostly used internally when Select mode is activated\n        \"\"\"\n        widget = None\n        # reverse the loop - look at children on top first and\n        # modalviews before others\n        win_children = self.win.children\n        children = chain((c for c in reversed(win_children)\n                          if isinstance(c, ModalView)),\n                         (c for c in reversed(win_children)\n                          if not isinstance(c, ModalView)))\n        for child in children:\n            if child is self:\n                continue\n            widget = self.pick(child, x, y)\n            if widget:\n                break\n        self.highlight_widget(widget)",
  "def highlight_widget(self, widget, *largs):\n        # no widget to highlight, reduce rectangle to 0, 0\n        self.widget = widget\n        if not widget:\n            self.grect.size = 0, 0",
  "def update_widget_graphics(self, *l):\n        if not self.activated:\n            return\n        if self.widget is None:\n            self.grect.size = 0, 0\n            return\n        self.grect.size = self.widget.size\n        matrix = self.widget.get_window_matrix()\n        if self.gtransform.matrix.get() != matrix.get():\n            self.gtransform.matrix = matrix",
  "def pick(self, widget, x, y):\n        \"\"\"Pick a widget at x/y, given a root `widget`\n        \"\"\"\n        ret = None\n        # try to filter widgets that are not visible (invalid inspect target)\n        if (hasattr(widget, 'visible') and not widget.visible):\n            return ret\n        if widget.collide_point(x, y):\n            ret = widget\n            x2, y2 = widget.to_local(x, y)\n            # reverse the loop - look at children on top first\n            for child in reversed(widget.children):\n                ret = self.pick(child, x2, y2) or ret\n        return ret",
  "def on_activated(self, instance, activated):\n        if activated:\n            self._activate_console()\n        else:\n            self._deactivate_console()",
  "def _activate_console(self):\n        if self not in self.win.children:\n            self.win.add_widget(self)\n        self.y = 0\n        for addon in self._addons:\n            addon.activate()\n        Logger.info('Console: console activated')",
  "def _deactivate_console(self):\n        for addon in self._addons:\n            addon.deactivate()\n        self.grect.size = 0, 0\n        self.y = -self.height\n        self.widget = None\n        self.inspect_enabled = False\n        # self.win.remove_widget(self)\n        self._window_node = None\n        Logger.info('Console: console deactivated')",
  "def keyboard_shortcut(self, win, scancode, *largs):\n        modifiers = largs[-1]\n        if scancode == 101 and modifiers == ['ctrl']:\n            self.activated = not self.activated\n            if self.activated:\n                self.inspect_enabled = True\n            return True\n\n        elif scancode == 27:\n            if self.inspect_enabled:\n                self.inspect_enabled = False\n                return True\n            if self.activated:\n                self.activated = False\n                return True\n\n        if not self.activated or not self.widget:\n            return\n\n        if scancode == 273:  # top\n            self.widget = self.widget.parent\n\n        elif scancode == 274:  # down\n            filtered_children = [c for c in self.widget.children\n                                 if not isinstance(c, Console)]\n            if filtered_children:\n                self.widget = filtered_children[0]\n\n        elif scancode == 276:  # left\n            parent = self.widget.parent\n            filtered_children = [c for c in parent.children\n                                 if not isinstance(c, Console)]\n            index = filtered_children.index(self.widget)\n            index = max(0, index - 1)\n            self.widget = filtered_children[index]\n\n        elif scancode == 275:  # right\n            parent = self.widget.parent\n            filtered_children = [c for c in parent.children\n                                 if not isinstance(c, Console)]\n            index = filtered_children.index(self.widget)\n            index = min(len(filtered_children) - 1, index + 1)\n            self.widget = filtered_children[index]",
  "def _touch_down(win, touch):\n    ud = touch.ud\n    with win.canvas.after:\n        ud['tr.color'] = Color(1, 1, 1, pointer_alpha)\n        iw, ih = pointer_image.size\n        ud['tr.rect'] = Rectangle(\n            pos=(\n                touch.x - (pointer_image.width / 2. * pointer_scale),\n                touch.y - (pointer_image.height / 2. * pointer_scale)),\n            size=(iw * pointer_scale, ih * pointer_scale),\n            texture=pointer_image.texture)\n\n    if not ud.get('tr.grab', False):\n        ud['tr.grab'] = True\n        touch.grab(win)",
  "def _touch_move(win, touch):\n    ud = touch.ud\n    if not ud.get('tr.rect', False):\n        _touch_down(win, touch)\n    ud['tr.rect'].pos = (\n        touch.x - (pointer_image.width / 2. * pointer_scale),\n        touch.y - (pointer_image.height / 2. * pointer_scale))",
  "def _touch_up(win, touch):\n    if touch.grab_current is win:\n        ud = touch.ud\n        win.canvas.after.remove(ud['tr.color'])\n        win.canvas.after.remove(ud['tr.rect'])\n\n        if ud.get('tr.grab') is True:\n            touch.ungrab(win)\n            ud['tr.grab'] = False",
  "def start(win, ctx):\n    # XXX use ctx !\n    global pointer_image, pointer_scale, pointer_alpha\n\n    pointer_fn = ctx.config.get('image',\n                                'atlas://data/images/defaulttheme/ring')\n    pointer_scale = float(ctx.config.get('scale', 1.0))\n    pointer_alpha = float(ctx.config.get('alpha', 1.0))\n    pointer_image = Image(pointer_fn)\n\n    win.bind(on_touch_down=_touch_down,\n             on_touch_move=_touch_move,\n             on_touch_up=_touch_up)",
  "def stop(win, ctx):\n    win.unbind(on_touch_down=_touch_down,\n               on_touch_move=_touch_move,\n               on_touch_up=_touch_up)",
  "def update_fps(ctx, *largs):\n    ctx.label.text = 'FPS: %f' % Clock.get_fps()\n    ctx.rectangle.texture = ctx.label.texture\n    ctx.rectangle.size = ctx.label.texture_size",
  "def update_stats(win, ctx, *largs):\n    global _statsinput\n    ctx.stats = ctx.stats[1:] + [_statsinput]\n    _statsinput = 0\n    m = max(1., _maxinput)\n    for i, x in enumerate(ctx.stats):\n        ctx.statsr[i].size = (4, ctx.stats[i] / m * 20)\n        ctx.statsr[i].pos = (win.width - 64 * 4 + i * 4, win.height - 25)",
  "def _update_monitor_canvas(win, ctx, *largs):\n    with win.canvas.after:\n        ctx.overlay.pos = (0, win.height - 25)\n        ctx.overlay.size = (win.width, 25)\n        ctx.rectangle.pos = (5, win.height - 20)",
  "class StatsInput(object):\n    def process(self, events):\n        global _statsinput, _maxinput\n        _statsinput += len(events)\n        if _statsinput > _maxinput:\n            _maxinput = float(_statsinput)\n        return events",
  "def start(win, ctx):\n    # late import to avoid breaking module loading\n    from kivy.input.postproc import kivy_postproc_modules\n    kivy_postproc_modules['fps'] = StatsInput()\n    global _ctx\n    ctx.label = Label(text='FPS: 0.0')\n    ctx.inputstats = 0\n    ctx.stats = []\n    ctx.statsr = []\n    with win.canvas.after:\n        ctx.color = Color(1, 0, 0, .5)\n        ctx.overlay = Rectangle(pos=(0, win.height - 25),\n                                size=(win.width, 25))\n        ctx.color = Color(1, 1, 1)\n        ctx.rectangle = Rectangle(pos=(5, win.height - 20))\n        ctx.color = Color(1, 1, 1, .5)\n        for i in range(64):\n            ctx.stats.append(0)\n            ctx.statsr.append(\n                Rectangle(pos=(win.width - 64 * 4 + i * 4, win.height - 25),\n                          size=(4, 0)))\n    win.bind(size=partial(_update_monitor_canvas, win, ctx))\n    Clock.schedule_interval(partial(update_fps, ctx), .5)\n    Clock.schedule_interval(partial(update_stats, win, ctx), 1 / 60.)",
  "def stop(win, ctx):\n    win.canvas.remove(ctx.label)",
  "def process(self, events):\n        global _statsinput, _maxinput\n        _statsinput += len(events)\n        if _statsinput > _maxinput:\n            _maxinput = float(_statsinput)\n        return events",
  "class ModuleContext:\n    '''Context of a module\n\n    You can access to the config with self.config.\n    '''\n\n    def __init__(self):\n        self.config = {}\n\n    def __repr__(self):\n        return repr(self.config)",
  "class ModuleBase:\n    '''Handle Kivy modules. It will automatically load and instantiate the\n    module for the general window.'''\n\n    def __init__(self, **kwargs):\n        self.mods = {}\n        self.wins = []\n\n    def add_path(self, path):\n        '''Add a path to search for modules in'''\n        if not os.path.exists(path):\n            return\n        if path not in sys.path:\n            sys.path.append(path)\n        dirs = os.listdir(path)\n        for module in dirs:\n            name, ext = os.path.splitext(module)\n            # accept only python extensions\n            if ext not in ('.py', '.pyo', '.pyc') or name == '__init__':\n                continue\n            self.mods[name] = {\n                'name': name,\n                'activated': False,\n                'context': ModuleContext()}\n\n    def list(self):\n        '''Return the list of available modules'''\n        return self.mods\n\n    def import_module(self, name):\n        try:\n            modname = 'kivy.modules.{0}'.format(name)\n            module = importlib.__import__(name=modname)\n            module = sys.modules[modname]\n        except ImportError:\n            try:\n                module = importlib.__import__(name=name)\n                module = sys.modules[name]\n            except ImportError:\n                Logger.exception('Modules: unable to import <%s>' % name)\n                # protect against missing module dependency crash\n                self.mods[name]['module'] = None\n                return\n        # basic check on module\n        if not hasattr(module, 'start'):\n            Logger.warning('Modules: Module <%s> missing start() function' %\n                           name)\n            return\n        if not hasattr(module, 'stop'):\n            err = 'Modules: Module <%s> missing stop() function' % name\n            Logger.warning(err)\n            return\n        self.mods[name]['module'] = module\n\n    def activate_module(self, name, win):\n        '''Activate a module on a window'''\n        if name not in self.mods:\n            Logger.warning('Modules: Module <%s> not found' % name)\n            return\n\n        mod = self.mods[name]\n\n        # ensure the module has been configured\n        if 'module' not in mod:\n            self._configure_module(name)\n\n        pymod = mod['module']\n        if not mod['activated']:\n            context = mod['context']\n            msg = 'Modules: Start <{0}> with config {1}'.format(\n                  name, context)\n            Logger.debug(msg)\n            pymod.start(win, context)\n            mod['activated'] = True\n\n    def deactivate_module(self, name, win):\n        '''Deactivate a module from a window'''\n        if name not in self.mods:\n            Logger.warning('Modules: Module <%s> not found' % name)\n            return\n        if 'module' not in self.mods[name]:\n            return\n\n        module = self.mods[name]['module']\n        if self.mods[name]['activated']:\n            module.stop(win, self.mods[name]['context'])\n            self.mods[name]['activated'] = False\n\n    def register_window(self, win):\n        '''Add the window to the window list'''\n        if win not in self.wins:\n            self.wins.append(win)\n        self.update()\n\n    def unregister_window(self, win):\n        '''Remove the window from the window list'''\n        if win in self.wins:\n            self.wins.remove(win)\n        self.update()\n\n    def update(self):\n        '''Update the status of the module for each window'''\n        modules_to_activate = [x[0] for x in Config.items('modules')]\n        for win in self.wins:\n            for name in self.mods:\n                if name not in modules_to_activate:\n                    self.deactivate_module(name, win)\n            for name in modules_to_activate:\n                try:\n                    self.activate_module(name, win)\n                except:\n                    import traceback\n                    traceback.print_exc()\n                    raise\n\n    def configure(self):\n        '''(internal) Configure all the modules before using them.\n        '''\n        modules_to_configure = [x[0] for x in Config.items('modules')]\n        for name in modules_to_configure:\n            if name not in self.mods:\n                Logger.warning('Modules: Module <%s> not found' % name)\n                continue\n            self._configure_module(name)\n\n    def _configure_module(self, name):\n        if 'module' not in self.mods[name]:\n            try:\n                self.import_module(name)\n            except ImportError:\n                return\n\n        # convert configuration like:\n        # -m mjpegserver:port=8080,fps=8\n        # and pass it in context.config token\n        config = dict()\n\n        args = Config.get('modules', name)\n        if args != '':\n            values = Config.get('modules', name).split(',')\n            for value in values:\n                x = value.split('=', 1)\n                if len(x) == 1:\n                    config[x[0]] = True\n                else:\n                    config[x[0]] = x[1]\n\n        self.mods[name]['context'].config = config\n\n        # call configure if module have one\n        if hasattr(self.mods[name]['module'], 'configure'):\n            self.mods[name]['module'].configure(config)\n\n    def usage_list(self):\n        print('Available modules')\n        print('=================')\n        for module in sorted(self.list()):\n            if 'module' not in self.mods[module]:\n                self.import_module(module)\n\n            # ignore modules without docstring\n            if not self.mods[module]['module'].__doc__:\n                continue\n\n            text = self.mods[module]['module'].__doc__.strip(\"\\n \")\n            text = text.split('\\n')\n            # make sure we don't get IndexError along the way\n            # then pretty format the header\n            if len(text) > 2:\n                if text[1].startswith('='):\n                    # '\\n%-12s: %s' -> 12 spaces + \": \"\n                    text[1] = '=' * (14 + len(text[1]))\n            text = '\\n'.join(text)\n            print('\\n%-12s: %s' % (module, text))",
  "def __init__(self):\n        self.config = {}",
  "def __repr__(self):\n        return repr(self.config)",
  "def __init__(self, **kwargs):\n        self.mods = {}\n        self.wins = []",
  "def add_path(self, path):\n        '''Add a path to search for modules in'''\n        if not os.path.exists(path):\n            return\n        if path not in sys.path:\n            sys.path.append(path)\n        dirs = os.listdir(path)\n        for module in dirs:\n            name, ext = os.path.splitext(module)\n            # accept only python extensions\n            if ext not in ('.py', '.pyo', '.pyc') or name == '__init__':\n                continue\n            self.mods[name] = {\n                'name': name,\n                'activated': False,\n                'context': ModuleContext()}",
  "def list(self):\n        '''Return the list of available modules'''\n        return self.mods",
  "def import_module(self, name):\n        try:\n            modname = 'kivy.modules.{0}'.format(name)\n            module = importlib.__import__(name=modname)\n            module = sys.modules[modname]\n        except ImportError:\n            try:\n                module = importlib.__import__(name=name)\n                module = sys.modules[name]\n            except ImportError:\n                Logger.exception('Modules: unable to import <%s>' % name)\n                # protect against missing module dependency crash\n                self.mods[name]['module'] = None\n                return\n        # basic check on module\n        if not hasattr(module, 'start'):\n            Logger.warning('Modules: Module <%s> missing start() function' %\n                           name)\n            return\n        if not hasattr(module, 'stop'):\n            err = 'Modules: Module <%s> missing stop() function' % name\n            Logger.warning(err)\n            return\n        self.mods[name]['module'] = module",
  "def activate_module(self, name, win):\n        '''Activate a module on a window'''\n        if name not in self.mods:\n            Logger.warning('Modules: Module <%s> not found' % name)\n            return\n\n        mod = self.mods[name]\n\n        # ensure the module has been configured\n        if 'module' not in mod:\n            self._configure_module(name)\n\n        pymod = mod['module']\n        if not mod['activated']:\n            context = mod['context']\n            msg = 'Modules: Start <{0}> with config {1}'.format(\n                  name, context)\n            Logger.debug(msg)\n            pymod.start(win, context)\n            mod['activated'] = True",
  "def deactivate_module(self, name, win):\n        '''Deactivate a module from a window'''\n        if name not in self.mods:\n            Logger.warning('Modules: Module <%s> not found' % name)\n            return\n        if 'module' not in self.mods[name]:\n            return\n\n        module = self.mods[name]['module']\n        if self.mods[name]['activated']:\n            module.stop(win, self.mods[name]['context'])\n            self.mods[name]['activated'] = False",
  "def register_window(self, win):\n        '''Add the window to the window list'''\n        if win not in self.wins:\n            self.wins.append(win)\n        self.update()",
  "def unregister_window(self, win):\n        '''Remove the window from the window list'''\n        if win in self.wins:\n            self.wins.remove(win)\n        self.update()",
  "def update(self):\n        '''Update the status of the module for each window'''\n        modules_to_activate = [x[0] for x in Config.items('modules')]\n        for win in self.wins:\n            for name in self.mods:\n                if name not in modules_to_activate:\n                    self.deactivate_module(name, win)\n            for name in modules_to_activate:\n                try:\n                    self.activate_module(name, win)\n                except:\n                    import traceback\n                    traceback.print_exc()\n                    raise",
  "def configure(self):\n        '''(internal) Configure all the modules before using them.\n        '''\n        modules_to_configure = [x[0] for x in Config.items('modules')]\n        for name in modules_to_configure:\n            if name not in self.mods:\n                Logger.warning('Modules: Module <%s> not found' % name)\n                continue\n            self._configure_module(name)",
  "def _configure_module(self, name):\n        if 'module' not in self.mods[name]:\n            try:\n                self.import_module(name)\n            except ImportError:\n                return\n\n        # convert configuration like:\n        # -m mjpegserver:port=8080,fps=8\n        # and pass it in context.config token\n        config = dict()\n\n        args = Config.get('modules', name)\n        if args != '':\n            values = Config.get('modules', name).split(',')\n            for value in values:\n                x = value.split('=', 1)\n                if len(x) == 1:\n                    config[x[0]] = True\n                else:\n                    config[x[0]] = x[1]\n\n        self.mods[name]['context'].config = config\n\n        # call configure if module have one\n        if hasattr(self.mods[name]['module'], 'configure'):\n            self.mods[name]['module'].configure(config)",
  "def usage_list(self):\n        print('Available modules')\n        print('=================')\n        for module in sorted(self.list()):\n            if 'module' not in self.mods[module]:\n                self.import_module(module)\n\n            # ignore modules without docstring\n            if not self.mods[module]['module'].__doc__:\n                continue\n\n            text = self.mods[module]['module'].__doc__.strip(\"\\n \")\n            text = text.split('\\n')\n            # make sure we don't get IndexError along the way\n            # then pretty format the header\n            if len(text) > 2:\n                if text[1].startswith('='):\n                    # '\\n%-12s: %s' -> 12 spaces + \": \"\n                    text[1] = '=' * (14 + len(text[1]))\n            text = '\\n'.join(text)\n            print('\\n%-12s: %s' % (module, text))",
  "class TreeViewProperty(Factory.BoxLayout, Factory.TreeViewNode):\n\n    widget_ref = ObjectProperty(None, allownone=True)\n\n    def _get_widget(self):\n        wr = self.widget_ref\n        if wr is None:\n            return\n        wr = wr()\n        if wr is None:\n            self.widget_ref = None\n            return\n        return wr\n    widget = AliasProperty(_get_widget, None, bind=('widget_ref', ))\n\n    key = ObjectProperty(None, allownone=True)\n\n    inspector = ObjectProperty(None)\n\n    refresh = BooleanProperty(False)",
  "class TreeViewWidget(Factory.Label, Factory.TreeViewNode):\n    widget = ObjectProperty(None)",
  "class WidgetTree(Factory.TreeView):\n    selected_widget = ObjectProperty(None, allownone=True)\n\n    __events__ = ('on_select_widget',)\n\n    def __init__(self, **kwargs):\n        super(WidgetTree, self).__init__(**kwargs)\n        self.update_scroll = Clock.create_trigger(self._update_scroll)\n\n    def find_node_by_widget(self, widget):\n        for node in self.iterate_all_nodes():\n            if not node.parent_node:\n                continue\n            try:\n                if node.widget == widget:\n                    return node\n            except ReferenceError:\n                pass\n        return\n\n    def update_selected_widget(self, widget):\n        if widget:\n            node = self.find_node_by_widget(widget)\n            if node:\n                self.select_node(node, False)\n                while node and isinstance(node, TreeViewWidget):\n                    if not node.is_open:\n                        self.toggle_node(node)\n                    node = node.parent_node\n\n    def on_selected_widget(self, inst, widget):\n        if widget:\n            self.update_selected_widget(widget)\n            self.update_scroll()\n\n    def select_node(self, node, select_widget=True):\n        super(WidgetTree, self).select_node(node)\n        if select_widget:\n            try:\n                self.dispatch('on_select_widget', node.widget.__self__)\n            except ReferenceError:\n                pass\n\n    def on_select_widget(self, widget):\n        pass\n\n    def _update_scroll(self, *args):\n        node = self._selected_node\n        if not node:\n            return\n\n        self.parent.scroll_to(node)",
  "class Inspector(Factory.FloatLayout):\n\n    widget = ObjectProperty(None, allownone=True)\n\n    layout = ObjectProperty(None)\n\n    widgettree = ObjectProperty(None)\n\n    treeview = ObjectProperty(None)\n\n    inspect_enabled = BooleanProperty(False)\n\n    activated = BooleanProperty(False)\n\n    widget_info = BooleanProperty(False)\n\n    content = ObjectProperty(None)\n\n    at_bottom = BooleanProperty(True)\n\n    _update_widget_tree_ev = None\n\n    def __init__(self, **kwargs):\n        self.win = kwargs.pop('win', None)\n        super(Inspector, self).__init__(**kwargs)\n        self.avoid_bring_to_top = False\n        with self.canvas.before:\n            self.gcolor = Factory.Color(1, 0, 0, .25)\n            Factory.PushMatrix()\n            self.gtransform = Factory.Transform(Matrix())\n            self.grect = Factory.Rectangle(size=(0, 0))\n            Factory.PopMatrix()\n        Clock.schedule_interval(self.update_widget_graphics, 0)\n\n    def on_touch_down(self, touch):\n        ret = super(Inspector, self).on_touch_down(touch)\n        if (('button' not in touch.profile or touch.button == 'left') and\n                not ret and self.inspect_enabled):\n            self.highlight_at(*touch.pos)\n            if touch.is_double_tap:\n                self.inspect_enabled = False\n                self.show_widget_info()\n            ret = True\n        return ret\n\n    def on_touch_move(self, touch):\n        ret = super(Inspector, self).on_touch_move(touch)\n        if not ret and self.inspect_enabled:\n            self.highlight_at(*touch.pos)\n            ret = True\n        return ret\n\n    def on_touch_up(self, touch):\n        ret = super(Inspector, self).on_touch_up(touch)\n        if not ret and self.inspect_enabled:\n            ret = True\n        return ret\n\n    def on_window_children(self, win, children):\n        if self.avoid_bring_to_top or not self.activated:\n            return\n        self.avoid_bring_to_top = True\n        win.remove_widget(self)\n        win.add_widget(self)\n        self.avoid_bring_to_top = False\n\n    def highlight_at(self, x, y):\n        widget = None\n        # reverse the loop - look at children on top first and\n        # modalviews before others\n        win_children = self.win.children\n        children = chain(\n            (c for c in win_children if isinstance(c, Factory.ModalView)),\n            (\n                c for c in reversed(win_children)\n                if not isinstance(c, Factory.ModalView)\n            )\n        )\n        for child in children:\n            if child is self:\n                continue\n            widget = self.pick(child, x, y)\n            if widget:\n                break\n        self.highlight_widget(widget)\n\n    def highlight_widget(self, widget, info=True, *largs):\n        # no widget to highlight, reduce rectangle to 0, 0\n        self.widget = widget\n        if not widget:\n            self.grect.size = 0, 0\n        if self.widget_info and info:\n            self.show_widget_info()\n\n    def update_widget_graphics(self, *largs):\n        if not self.activated:\n            return\n        if self.widget is None:\n            self.grect.size = 0, 0\n            return\n        self.grect.size = self.widget.size\n        matrix = self.widget.get_window_matrix()\n        if self.gtransform.matrix.get() != matrix.get():\n            self.gtransform.matrix = matrix\n\n    def toggle_position(self, button):\n        to_bottom = button.text == 'Move to Bottom'\n\n        if to_bottom:\n            button.text = 'Move to Top'\n            if self.widget_info:\n                Animation(top=250, t='out_quad', d=.3).start(self.layout)\n            else:\n                Animation(top=60, t='out_quad', d=.3).start(self.layout)\n\n            bottom_bar = self.layout.children[1]\n            self.layout.remove_widget(bottom_bar)\n            self.layout.add_widget(bottom_bar)\n        else:\n            button.text = 'Move to Bottom'\n            if self.widget_info:\n                Animation(top=self.height, t='out_quad', d=.3).start(\n                    self.layout)\n            else:\n                Animation(y=self.height - 60, t='out_quad', d=.3).start(\n                    self.layout)\n\n            bottom_bar = self.layout.children[1]\n            self.layout.remove_widget(bottom_bar)\n            self.layout.add_widget(bottom_bar)\n        self.at_bottom = to_bottom\n\n    def pick(self, widget, x, y):\n        ret = None\n        # try to filter widgets that are not visible (invalid inspect target)\n        if (hasattr(widget, 'visible') and not widget.visible):\n            return ret\n        if widget.collide_point(x, y):\n            ret = widget\n            x2, y2 = widget.to_local(x, y)\n            # reverse the loop - look at children on top first\n            for child in reversed(widget.children):\n                ret = self.pick(child, x2, y2) or ret\n        return ret\n\n    def on_activated(self, instance, activated):\n        if not activated:\n            self.grect.size = 0, 0\n            if self.at_bottom:\n                anim = Animation(top=0, t='out_quad', d=.3)\n            else:\n                anim = Animation(y=self.height, t='out_quad', d=.3)\n            anim.bind(on_complete=self.animation_close)\n            anim.start(self.layout)\n            self.widget = None\n            self.widget_info = False\n        else:\n            self.win.add_widget(self)\n            Logger.info('Inspector: inspector activated')\n            if self.at_bottom:\n                Animation(top=60, t='out_quad', d=.3).start(self.layout)\n            else:\n                Animation(y=self.height - 60, t='out_quad', d=.3).start(\n                    self.layout)\n            ev = self._update_widget_tree_ev\n            if ev is None:\n                ev = self._update_widget_tree_ev = Clock.schedule_interval(\n                    self.update_widget_tree, 1)\n            else:\n                ev()\n            self.update_widget_tree()\n\n    def animation_close(self, instance, value):\n        if not self.activated:\n            self.inspect_enabled = False\n            self.win.remove_widget(self)\n            self.content.clear_widgets()\n            treeview = self.treeview\n            for node in list(treeview.iterate_all_nodes()):\n                node.widget_ref = None\n                treeview.remove_node(node)\n\n            self._window_node = None\n            if self._update_widget_tree_ev is not None:\n                self._update_widget_tree_ev.cancel()\n\n            widgettree = self.widgettree\n            for node in list(widgettree.iterate_all_nodes()):\n                widgettree.remove_node(node)\n            Logger.info('Inspector: inspector deactivated')\n\n    def show_widget_info(self):\n        self.content.clear_widgets()\n        widget = self.widget\n        treeview = self.treeview\n        for node in list(treeview.iterate_all_nodes())[:]:\n            node.widget_ref = None\n            treeview.remove_node(node)\n        if not widget:\n            if self.at_bottom:\n                Animation(top=60, t='out_quad', d=.3).start(self.layout)\n            else:\n                Animation(y=self.height - 60, t='out_quad', d=.3).start(\n                    self.layout)\n            self.widget_info = False\n            return\n        self.widget_info = True\n        if self.at_bottom:\n            Animation(top=250, t='out_quad', d=.3).start(self.layout)\n        else:\n            Animation(top=self.height, t='out_quad', d=.3).start(self.layout)\n        for node in list(treeview.iterate_all_nodes())[:]:\n            treeview.remove_node(node)\n\n        keys = list(widget.properties().keys())\n        keys.sort()\n        node = None\n        if type(widget) is WeakProxy:\n            wk_widget = widget.__ref__\n        else:\n            wk_widget = weakref.ref(widget)\n        for key in keys:\n            node = TreeViewProperty(key=key, widget_ref=wk_widget)\n            node.bind(is_selected=self.show_property)\n            try:\n                widget.bind(**{key: partial(\n                    self.update_node_content, weakref.ref(node))})\n            except:\n                pass\n            treeview.add_node(node)\n\n    def update_node_content(self, node, *largs):\n        node = node()\n        if node is None:\n            return\n        node.refresh = True\n        node.refresh = False\n\n    def keyboard_shortcut(self, win, scancode, *largs):\n        modifiers = largs[-1]\n        if scancode == 101 and set(modifiers) & {'ctrl'} and not set(\n                modifiers) & {'shift', 'alt', 'meta'}:\n            self.activated = not self.activated\n            if self.activated:\n                self.inspect_enabled = True\n            return True\n        elif scancode == 27:\n            if self.inspect_enabled:\n                self.inspect_enabled = False\n                return True\n            if self.activated:\n                self.activated = False\n                return True\n\n    def show_property(self, instance, value, key=None, index=-1, *largs):\n        # normal call: (tree node, focus, )\n        # nested call: (widget, prop value, prop key, index in dict/list)\n        if value is False:\n            return\n\n        content = None\n        if key is None:\n            # normal call\n            nested = False\n            widget = instance.widget\n            key = instance.key\n            prop = widget.property(key)\n            value = getattr(widget, key)\n        else:\n            # nested call, we might edit subvalue\n            nested = True\n            widget = instance\n            prop = None\n\n        dtype = None\n\n        if isinstance(prop, AliasProperty) or nested:\n            # trying to resolve type dynamically\n            if type(value) in (str, str):\n                dtype = 'string'\n            elif type(value) in (int, float):\n                dtype = 'numeric'\n            elif type(value) in (tuple, list):\n                dtype = 'list'\n\n        if isinstance(prop, NumericProperty) or dtype == 'numeric':\n            content = Factory.TextInput(text=str(value) or '', multiline=False)\n            content.bind(text=partial(\n                self.save_property_numeric, widget, key, index))\n        elif isinstance(prop, StringProperty) or dtype == 'string':\n            content = Factory.TextInput(text=value or '', multiline=True)\n            content.bind(text=partial(\n                self.save_property_text, widget, key, index))\n        elif (isinstance(prop, ListProperty) or\n              isinstance(prop, ReferenceListProperty) or\n              isinstance(prop, VariableListProperty) or\n              dtype == 'list'):\n            content = Factory.GridLayout(cols=1, size_hint_y=None)\n            content.bind(minimum_height=content.setter('height'))\n            for i, item in enumerate(value):\n                button = Factory.Button(\n                    text=repr(item),\n                    size_hint_y=None,\n                    height=44\n                )\n                if isinstance(item, Factory.Widget):\n                    button.bind(on_release=partial(self.highlight_widget, item,\n                                                   False))\n                else:\n                    button.bind(on_release=partial(self.show_property, widget,\n                                                   item, key, i))\n                content.add_widget(button)\n        elif isinstance(prop, OptionProperty):\n            content = Factory.GridLayout(cols=1, size_hint_y=None)\n            content.bind(minimum_height=content.setter('height'))\n            for option in prop.options:\n                button = Factory.ToggleButton(\n                    text=option,\n                    state='down' if option == value else 'normal',\n                    group=repr(content.uid), size_hint_y=None,\n                    height=44)\n                button.bind(on_press=partial(\n                    self.save_property_option, widget, key))\n                content.add_widget(button)\n        elif isinstance(prop, ObjectProperty):\n            if isinstance(value, Factory.Widget):\n                content = Factory.Button(text=repr(value))\n                content.bind(on_release=partial(self.highlight_widget, value))\n            elif isinstance(value, Factory.Texture):\n                content = Factory.Image(texture=value)\n            else:\n                content = Factory.Label(text=repr(value))\n\n        elif isinstance(prop, BooleanProperty):\n            state = 'down' if value else 'normal'\n            content = Factory.ToggleButton(text=key, state=state)\n            content.bind(on_release=partial(self.save_property_boolean, widget,\n                                            key, index))\n\n        self.content.clear_widgets()\n        if content:\n            self.content.add_widget(content)\n\n    def save_property_numeric(self, widget, key, index, instance, value):\n        try:\n            if index >= 0:\n                getattr(widget, key)[index] = float(instance.text)\n            else:\n                setattr(widget, key, float(instance.text))\n        except:\n            pass\n\n    def save_property_text(self, widget, key, index, instance, value):\n        try:\n            if index >= 0:\n                getattr(widget, key)[index] = instance.text\n            else:\n                setattr(widget, key, instance.text)\n        except:\n            pass\n\n    def save_property_boolean(self, widget, key, index, instance, ):\n        try:\n            value = instance.state == 'down'\n            if index >= 0:\n                getattr(widget, key)[index] = value\n            else:\n                setattr(widget, key, value)\n        except:\n            pass\n\n    def save_property_option(self, widget, key, instance, *largs):\n        try:\n            setattr(widget, key, instance.text)\n        except:\n            pass\n\n    def _update_widget_tree_node(self, node, widget, is_open=False):\n        tree = self.widgettree\n        update_nodes = []\n        nodes = {}\n        for cnode in node.nodes[:]:\n            try:\n                nodes[cnode.widget] = cnode\n            except ReferenceError:\n                # widget no longer exists, just remove it\n                pass\n            tree.remove_node(cnode)\n        for child in widget.children:\n            if child is self:\n                continue\n            if child in nodes:\n                cnode = tree.add_node(nodes[child], node)\n            else:\n                cnode = tree.add_node(TreeViewWidget(\n                    text=child.__class__.__name__, widget=child.proxy_ref,\n                    is_open=is_open), node)\n            update_nodes.append((cnode, child))\n        return update_nodes\n\n    def update_widget_tree(self, *args):\n        if not hasattr(self, '_window_node') or not self._window_node:\n            self._window_node = self.widgettree.add_node(\n                TreeViewWidget(text='Window', widget=self.win, is_open=True))\n\n        nodes = self._update_widget_tree_node(self._window_node, self.win,\n                                              is_open=True)\n        while nodes:\n            ntmp = nodes[:]\n            nodes = []\n            for node in ntmp:\n                nodes += self._update_widget_tree_node(*node)\n\n        self.widgettree.update_selected_widget(self.widget)",
  "def create_inspector(win, ctx, *largs):\n    '''Create an Inspector instance attached to the *ctx* and bound to the\n    Window's :meth:`~kivy.core.window.WindowBase.on_keyboard` event for\n    capturing the keyboard shortcut.\n\n        :Parameters:\n            `win`: A :class:`Window <kivy.core.window.WindowBase>`\n                The application Window to bind to.\n            `ctx`: A :class:`~kivy.uix.widget.Widget` or subclass\n                The Widget to be inspected.\n\n    '''\n    # Dunno why, but if we are creating inspector within the start(), no lang\n    # rules are applied.\n    ctx.inspector = Inspector(win=win)\n    win.bind(children=ctx.inspector.on_window_children,\n             on_keyboard=ctx.inspector.keyboard_shortcut)",
  "def start(win, ctx):\n    ctx.ev_late_create = Clock.schedule_once(\n        partial(create_inspector, win, ctx))",
  "def stop(win, ctx):\n    '''Stop and unload any active Inspectors for the given *ctx*.'''\n    if hasattr(ctx, 'ev_late_create'):\n        ctx.ev_late_create.cancel()\n        del ctx.ev_late_create\n    if hasattr(ctx, 'inspector'):\n        win.unbind(children=ctx.inspector.on_window_children,\n                   on_keyboard=ctx.inspector.keyboard_shortcut)\n        win.remove_widget(ctx.inspector)\n        del ctx.inspector",
  "def _get_widget(self):\n        wr = self.widget_ref\n        if wr is None:\n            return\n        wr = wr()\n        if wr is None:\n            self.widget_ref = None\n            return\n        return wr",
  "def __init__(self, **kwargs):\n        super(WidgetTree, self).__init__(**kwargs)\n        self.update_scroll = Clock.create_trigger(self._update_scroll)",
  "def find_node_by_widget(self, widget):\n        for node in self.iterate_all_nodes():\n            if not node.parent_node:\n                continue\n            try:\n                if node.widget == widget:\n                    return node\n            except ReferenceError:\n                pass\n        return",
  "def update_selected_widget(self, widget):\n        if widget:\n            node = self.find_node_by_widget(widget)\n            if node:\n                self.select_node(node, False)\n                while node and isinstance(node, TreeViewWidget):\n                    if not node.is_open:\n                        self.toggle_node(node)\n                    node = node.parent_node",
  "def on_selected_widget(self, inst, widget):\n        if widget:\n            self.update_selected_widget(widget)\n            self.update_scroll()",
  "def select_node(self, node, select_widget=True):\n        super(WidgetTree, self).select_node(node)\n        if select_widget:\n            try:\n                self.dispatch('on_select_widget', node.widget.__self__)\n            except ReferenceError:\n                pass",
  "def on_select_widget(self, widget):\n        pass",
  "def _update_scroll(self, *args):\n        node = self._selected_node\n        if not node:\n            return\n\n        self.parent.scroll_to(node)",
  "def __init__(self, **kwargs):\n        self.win = kwargs.pop('win', None)\n        super(Inspector, self).__init__(**kwargs)\n        self.avoid_bring_to_top = False\n        with self.canvas.before:\n            self.gcolor = Factory.Color(1, 0, 0, .25)\n            Factory.PushMatrix()\n            self.gtransform = Factory.Transform(Matrix())\n            self.grect = Factory.Rectangle(size=(0, 0))\n            Factory.PopMatrix()\n        Clock.schedule_interval(self.update_widget_graphics, 0)",
  "def on_touch_down(self, touch):\n        ret = super(Inspector, self).on_touch_down(touch)\n        if (('button' not in touch.profile or touch.button == 'left') and\n                not ret and self.inspect_enabled):\n            self.highlight_at(*touch.pos)\n            if touch.is_double_tap:\n                self.inspect_enabled = False\n                self.show_widget_info()\n            ret = True\n        return ret",
  "def on_touch_move(self, touch):\n        ret = super(Inspector, self).on_touch_move(touch)\n        if not ret and self.inspect_enabled:\n            self.highlight_at(*touch.pos)\n            ret = True\n        return ret",
  "def on_touch_up(self, touch):\n        ret = super(Inspector, self).on_touch_up(touch)\n        if not ret and self.inspect_enabled:\n            ret = True\n        return ret",
  "def on_window_children(self, win, children):\n        if self.avoid_bring_to_top or not self.activated:\n            return\n        self.avoid_bring_to_top = True\n        win.remove_widget(self)\n        win.add_widget(self)\n        self.avoid_bring_to_top = False",
  "def highlight_at(self, x, y):\n        widget = None\n        # reverse the loop - look at children on top first and\n        # modalviews before others\n        win_children = self.win.children\n        children = chain(\n            (c for c in win_children if isinstance(c, Factory.ModalView)),\n            (\n                c for c in reversed(win_children)\n                if not isinstance(c, Factory.ModalView)\n            )\n        )\n        for child in children:\n            if child is self:\n                continue\n            widget = self.pick(child, x, y)\n            if widget:\n                break\n        self.highlight_widget(widget)",
  "def highlight_widget(self, widget, info=True, *largs):\n        # no widget to highlight, reduce rectangle to 0, 0\n        self.widget = widget\n        if not widget:\n            self.grect.size = 0, 0\n        if self.widget_info and info:\n            self.show_widget_info()",
  "def update_widget_graphics(self, *largs):\n        if not self.activated:\n            return\n        if self.widget is None:\n            self.grect.size = 0, 0\n            return\n        self.grect.size = self.widget.size\n        matrix = self.widget.get_window_matrix()\n        if self.gtransform.matrix.get() != matrix.get():\n            self.gtransform.matrix = matrix",
  "def toggle_position(self, button):\n        to_bottom = button.text == 'Move to Bottom'\n\n        if to_bottom:\n            button.text = 'Move to Top'\n            if self.widget_info:\n                Animation(top=250, t='out_quad', d=.3).start(self.layout)\n            else:\n                Animation(top=60, t='out_quad', d=.3).start(self.layout)\n\n            bottom_bar = self.layout.children[1]\n            self.layout.remove_widget(bottom_bar)\n            self.layout.add_widget(bottom_bar)\n        else:\n            button.text = 'Move to Bottom'\n            if self.widget_info:\n                Animation(top=self.height, t='out_quad', d=.3).start(\n                    self.layout)\n            else:\n                Animation(y=self.height - 60, t='out_quad', d=.3).start(\n                    self.layout)\n\n            bottom_bar = self.layout.children[1]\n            self.layout.remove_widget(bottom_bar)\n            self.layout.add_widget(bottom_bar)\n        self.at_bottom = to_bottom",
  "def pick(self, widget, x, y):\n        ret = None\n        # try to filter widgets that are not visible (invalid inspect target)\n        if (hasattr(widget, 'visible') and not widget.visible):\n            return ret\n        if widget.collide_point(x, y):\n            ret = widget\n            x2, y2 = widget.to_local(x, y)\n            # reverse the loop - look at children on top first\n            for child in reversed(widget.children):\n                ret = self.pick(child, x2, y2) or ret\n        return ret",
  "def on_activated(self, instance, activated):\n        if not activated:\n            self.grect.size = 0, 0\n            if self.at_bottom:\n                anim = Animation(top=0, t='out_quad', d=.3)\n            else:\n                anim = Animation(y=self.height, t='out_quad', d=.3)\n            anim.bind(on_complete=self.animation_close)\n            anim.start(self.layout)\n            self.widget = None\n            self.widget_info = False\n        else:\n            self.win.add_widget(self)\n            Logger.info('Inspector: inspector activated')\n            if self.at_bottom:\n                Animation(top=60, t='out_quad', d=.3).start(self.layout)\n            else:\n                Animation(y=self.height - 60, t='out_quad', d=.3).start(\n                    self.layout)\n            ev = self._update_widget_tree_ev\n            if ev is None:\n                ev = self._update_widget_tree_ev = Clock.schedule_interval(\n                    self.update_widget_tree, 1)\n            else:\n                ev()\n            self.update_widget_tree()",
  "def animation_close(self, instance, value):\n        if not self.activated:\n            self.inspect_enabled = False\n            self.win.remove_widget(self)\n            self.content.clear_widgets()\n            treeview = self.treeview\n            for node in list(treeview.iterate_all_nodes()):\n                node.widget_ref = None\n                treeview.remove_node(node)\n\n            self._window_node = None\n            if self._update_widget_tree_ev is not None:\n                self._update_widget_tree_ev.cancel()\n\n            widgettree = self.widgettree\n            for node in list(widgettree.iterate_all_nodes()):\n                widgettree.remove_node(node)\n            Logger.info('Inspector: inspector deactivated')",
  "def show_widget_info(self):\n        self.content.clear_widgets()\n        widget = self.widget\n        treeview = self.treeview\n        for node in list(treeview.iterate_all_nodes())[:]:\n            node.widget_ref = None\n            treeview.remove_node(node)\n        if not widget:\n            if self.at_bottom:\n                Animation(top=60, t='out_quad', d=.3).start(self.layout)\n            else:\n                Animation(y=self.height - 60, t='out_quad', d=.3).start(\n                    self.layout)\n            self.widget_info = False\n            return\n        self.widget_info = True\n        if self.at_bottom:\n            Animation(top=250, t='out_quad', d=.3).start(self.layout)\n        else:\n            Animation(top=self.height, t='out_quad', d=.3).start(self.layout)\n        for node in list(treeview.iterate_all_nodes())[:]:\n            treeview.remove_node(node)\n\n        keys = list(widget.properties().keys())\n        keys.sort()\n        node = None\n        if type(widget) is WeakProxy:\n            wk_widget = widget.__ref__\n        else:\n            wk_widget = weakref.ref(widget)\n        for key in keys:\n            node = TreeViewProperty(key=key, widget_ref=wk_widget)\n            node.bind(is_selected=self.show_property)\n            try:\n                widget.bind(**{key: partial(\n                    self.update_node_content, weakref.ref(node))})\n            except:\n                pass\n            treeview.add_node(node)",
  "def update_node_content(self, node, *largs):\n        node = node()\n        if node is None:\n            return\n        node.refresh = True\n        node.refresh = False",
  "def keyboard_shortcut(self, win, scancode, *largs):\n        modifiers = largs[-1]\n        if scancode == 101 and set(modifiers) & {'ctrl'} and not set(\n                modifiers) & {'shift', 'alt', 'meta'}:\n            self.activated = not self.activated\n            if self.activated:\n                self.inspect_enabled = True\n            return True\n        elif scancode == 27:\n            if self.inspect_enabled:\n                self.inspect_enabled = False\n                return True\n            if self.activated:\n                self.activated = False\n                return True",
  "def show_property(self, instance, value, key=None, index=-1, *largs):\n        # normal call: (tree node, focus, )\n        # nested call: (widget, prop value, prop key, index in dict/list)\n        if value is False:\n            return\n\n        content = None\n        if key is None:\n            # normal call\n            nested = False\n            widget = instance.widget\n            key = instance.key\n            prop = widget.property(key)\n            value = getattr(widget, key)\n        else:\n            # nested call, we might edit subvalue\n            nested = True\n            widget = instance\n            prop = None\n\n        dtype = None\n\n        if isinstance(prop, AliasProperty) or nested:\n            # trying to resolve type dynamically\n            if type(value) in (str, str):\n                dtype = 'string'\n            elif type(value) in (int, float):\n                dtype = 'numeric'\n            elif type(value) in (tuple, list):\n                dtype = 'list'\n\n        if isinstance(prop, NumericProperty) or dtype == 'numeric':\n            content = Factory.TextInput(text=str(value) or '', multiline=False)\n            content.bind(text=partial(\n                self.save_property_numeric, widget, key, index))\n        elif isinstance(prop, StringProperty) or dtype == 'string':\n            content = Factory.TextInput(text=value or '', multiline=True)\n            content.bind(text=partial(\n                self.save_property_text, widget, key, index))\n        elif (isinstance(prop, ListProperty) or\n              isinstance(prop, ReferenceListProperty) or\n              isinstance(prop, VariableListProperty) or\n              dtype == 'list'):\n            content = Factory.GridLayout(cols=1, size_hint_y=None)\n            content.bind(minimum_height=content.setter('height'))\n            for i, item in enumerate(value):\n                button = Factory.Button(\n                    text=repr(item),\n                    size_hint_y=None,\n                    height=44\n                )\n                if isinstance(item, Factory.Widget):\n                    button.bind(on_release=partial(self.highlight_widget, item,\n                                                   False))\n                else:\n                    button.bind(on_release=partial(self.show_property, widget,\n                                                   item, key, i))\n                content.add_widget(button)\n        elif isinstance(prop, OptionProperty):\n            content = Factory.GridLayout(cols=1, size_hint_y=None)\n            content.bind(minimum_height=content.setter('height'))\n            for option in prop.options:\n                button = Factory.ToggleButton(\n                    text=option,\n                    state='down' if option == value else 'normal',\n                    group=repr(content.uid), size_hint_y=None,\n                    height=44)\n                button.bind(on_press=partial(\n                    self.save_property_option, widget, key))\n                content.add_widget(button)\n        elif isinstance(prop, ObjectProperty):\n            if isinstance(value, Factory.Widget):\n                content = Factory.Button(text=repr(value))\n                content.bind(on_release=partial(self.highlight_widget, value))\n            elif isinstance(value, Factory.Texture):\n                content = Factory.Image(texture=value)\n            else:\n                content = Factory.Label(text=repr(value))\n\n        elif isinstance(prop, BooleanProperty):\n            state = 'down' if value else 'normal'\n            content = Factory.ToggleButton(text=key, state=state)\n            content.bind(on_release=partial(self.save_property_boolean, widget,\n                                            key, index))\n\n        self.content.clear_widgets()\n        if content:\n            self.content.add_widget(content)",
  "def save_property_numeric(self, widget, key, index, instance, value):\n        try:\n            if index >= 0:\n                getattr(widget, key)[index] = float(instance.text)\n            else:\n                setattr(widget, key, float(instance.text))\n        except:\n            pass",
  "def save_property_text(self, widget, key, index, instance, value):\n        try:\n            if index >= 0:\n                getattr(widget, key)[index] = instance.text\n            else:\n                setattr(widget, key, instance.text)\n        except:\n            pass",
  "def save_property_boolean(self, widget, key, index, instance, ):\n        try:\n            value = instance.state == 'down'\n            if index >= 0:\n                getattr(widget, key)[index] = value\n            else:\n                setattr(widget, key, value)\n        except:\n            pass",
  "def save_property_option(self, widget, key, instance, *largs):\n        try:\n            setattr(widget, key, instance.text)\n        except:\n            pass",
  "def _update_widget_tree_node(self, node, widget, is_open=False):\n        tree = self.widgettree\n        update_nodes = []\n        nodes = {}\n        for cnode in node.nodes[:]:\n            try:\n                nodes[cnode.widget] = cnode\n            except ReferenceError:\n                # widget no longer exists, just remove it\n                pass\n            tree.remove_node(cnode)\n        for child in widget.children:\n            if child is self:\n                continue\n            if child in nodes:\n                cnode = tree.add_node(nodes[child], node)\n            else:\n                cnode = tree.add_node(TreeViewWidget(\n                    text=child.__class__.__name__, widget=child.proxy_ref,\n                    is_open=is_open), node)\n            update_nodes.append((cnode, child))\n        return update_nodes",
  "def update_widget_tree(self, *args):\n        if not hasattr(self, '_window_node') or not self._window_node:\n            self._window_node = self.widgettree.add_node(\n                TreeViewWidget(text='Window', widget=self.win, is_open=True))\n\n        nodes = self._update_widget_tree_node(self._window_node, self.win,\n                                              is_open=True)\n        while nodes:\n            ntmp = nodes[:]\n            nodes = []\n            for node in ntmp:\n                nodes += self._update_widget_tree_node(*node)\n\n        self.widgettree.update_selected_widget(self.widget)",
  "class TreeViewException(Exception):\n    '''Exception for errors in the :class:`TreeView`.\n    '''\n    pass",
  "class TreeViewNode(object):\n    '''TreeViewNode class, used to build a node class for a TreeView object.\n    '''\n\n    def __init__(self, **kwargs):\n        if self.__class__ is TreeViewNode:\n            raise TreeViewException('You cannot use directly TreeViewNode.')\n        super(TreeViewNode, self).__init__(**kwargs)\n\n    is_leaf = BooleanProperty(True)\n    '''Boolean to indicate whether this node is a leaf or not. Used to adjust\n    the graphical representation.\n\n    :attr:`is_leaf` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to True. It is automatically set to False when child is added.\n    '''\n\n    is_open = BooleanProperty(False)\n    '''Boolean to indicate whether this node is opened or not, in case there\n    are child nodes. This is used to adjust the graphical representation.\n\n    .. warning::\n\n        This property is automatically set by the :class:`TreeView`. You can\n        read but not write it.\n\n    :attr:`is_open` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    is_loaded = BooleanProperty(False)\n    '''Boolean to indicate whether this node is already loaded or not. This\n    property is used only if the :class:`TreeView` uses asynchronous loading.\n\n    :attr:`is_loaded` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    is_selected = BooleanProperty(False)\n    '''Boolean to indicate whether this node is selected or not. This is used\n    adjust the graphical representation.\n\n    .. warning::\n\n        This property is automatically set by the :class:`TreeView`. You can\n        read but not write it.\n\n    :attr:`is_selected` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    no_selection = BooleanProperty(False)\n    '''Boolean used to indicate whether selection of the node is allowed or\n     not.\n\n    :attr:`no_selection` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    nodes = ListProperty([])\n    '''List of nodes. The nodes list is different than the children list. A\n    node in the nodes list represents a node on the tree. An item in the\n    children list represents the widget associated with the node.\n\n    .. warning::\n\n        This property is automatically set by the :class:`TreeView`. You can\n        read but not write it.\n\n    :attr:`nodes` is a :class:`~kivy.properties.ListProperty` and defaults to\n    [].\n    '''\n\n    parent_node = ObjectProperty(None, allownone=True)\n    '''Parent node. This attribute is needed because the :attr:`parent` can be\n    None when the node is not displayed.\n\n    .. versionadded:: 1.0.7\n\n    :attr:`parent_node` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    level = NumericProperty(-1)\n    '''Level of the node.\n\n    :attr:`level` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to -1.\n    '''\n\n    color_selected = ColorProperty([.3, .3, .3, 1.])\n    '''Background color of the node when the node is selected.\n\n    :attr:`color_selected` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [.1, .1, .1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    odd = BooleanProperty(False)\n    '''\n    This property is set by the TreeView widget automatically and is read-only.\n\n    :attr:`odd` is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.\n    '''\n\n    odd_color = ColorProperty([1., 1., 1., .0])\n    '''Background color of odd nodes when the node is not selected.\n\n    :attr:`odd_color` is a :class:`~kivy.properties.ColorProperty` and defaults\n    to [1., 1., 1., 0.].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    even_color = ColorProperty([0.5, 0.5, 0.5, 0.1])\n    '''Background color of even nodes when the node is not selected.\n\n    :attr:`bg_color` is a :class:`~kivy.properties.ColorProperty` and defaults\n    to [.5, .5, .5, .1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''",
  "class TreeViewLabel(Label, TreeViewNode):\n    '''Combines a :class:`~kivy.uix.label.Label` and a :class:`TreeViewNode` to\n    create a :class:`TreeViewLabel` that can be used as a text node in the\n    tree.\n\n    See module documentation for more information.\n    '''",
  "class TreeView(Widget):\n    '''TreeView class. See module documentation for more information.\n\n    :Events:\n        `on_node_expand`: (node, )\n            Fired when a node is being expanded\n        `on_node_collapse`: (node, )\n            Fired when a node is being collapsed\n    '''\n\n    __events__ = ('on_node_expand', 'on_node_collapse')\n\n    def __init__(self, **kwargs):\n        self._trigger_layout = Clock.create_trigger(self._do_layout, -1)\n        super(TreeView, self).__init__(**kwargs)\n        tvlabel = TreeViewLabel(text='Root', is_open=True, level=0)\n        for key, value in self.root_options.items():\n            setattr(tvlabel, key, value)\n        self._root = self.add_node(tvlabel, None)\n\n        trigger = self._trigger_layout\n        fbind = self.fbind\n        fbind('pos', trigger)\n        fbind('size', trigger)\n        fbind('indent_level', trigger)\n        fbind('indent_start', trigger)\n        trigger()\n\n    def add_node(self, node, parent=None):\n        '''Add a new node to the tree.\n\n        :Parameters:\n            `node`: instance of a :class:`TreeViewNode`\n                Node to add into the tree\n            `parent`: instance of a :class:`TreeViewNode`, defaults to None\n                Parent node to attach the new node. If `None`, it is added to\n                the :attr:`root` node.\n\n        :returns:\n            the node `node`.\n        '''\n        # check if the widget is \"ok\" for a node\n        if not isinstance(node, TreeViewNode):\n            raise TreeViewException(\n                'The node must be a subclass of TreeViewNode')\n        # create node\n        if parent is None and self._root:\n            parent = self._root\n        if parent:\n            parent.is_leaf = False\n            parent.nodes.append(node)\n            node.parent_node = parent\n            node.level = parent.level + 1\n        node.fbind('size', self._trigger_layout)\n        self._trigger_layout()\n        return node\n\n    def remove_node(self, node):\n        '''Removes a node from the tree.\n\n        .. versionadded:: 1.0.7\n\n        :Parameters:\n            `node`: instance of a :class:`TreeViewNode`\n                Node to remove from the tree. If `node` is :attr:`root`, it is\n                not removed.\n        '''\n        # check if the widget is \"ok\" for a node\n        if not isinstance(node, TreeViewNode):\n            raise TreeViewException(\n                'The node must be a subclass of TreeViewNode')\n        parent = node.parent_node\n        if parent is not None:\n            if node == self._selected_node:\n                node.is_selected = False\n                self._selected_node = None\n            nodes = parent.nodes\n            if node in nodes:\n                nodes.remove(node)\n            parent.is_leaf = not bool(len(nodes))\n            node.parent_node = None\n            node.funbind('size', self._trigger_layout)\n            self._trigger_layout()\n\n    def on_node_expand(self, node):\n        pass\n\n    def on_node_collapse(self, node):\n        pass\n\n    def select_node(self, node):\n        '''Select a node in the tree.\n        '''\n        if node.no_selection:\n            return\n        if self._selected_node:\n            self._selected_node.is_selected = False\n        node.is_selected = True\n        self._selected_node = node\n\n    def deselect_node(self, *args):\n        '''Deselect any selected node.\n\n        .. versionadded:: 1.10.0\n        '''\n        if self._selected_node:\n            self._selected_node.is_selected = False\n            self._selected_node = None\n\n    def toggle_node(self, node):\n        '''Toggle the state of the node (open/collapsed).\n        '''\n        node.is_open = not node.is_open\n        if node.is_open:\n            if self.load_func and not node.is_loaded:\n                self._do_node_load(node)\n            self.dispatch('on_node_expand', node)\n        else:\n            self.dispatch('on_node_collapse', node)\n        self._trigger_layout()\n\n    def get_node_at_pos(self, pos):\n        '''Get the node at the position (x, y).\n        '''\n        x, y = pos\n        for node in self.iterate_open_nodes(self.root):\n            if self.x <= x <= self.right and \\\n               node.y <= y <= node.top:\n                return node\n\n    def iterate_open_nodes(self, node=None):\n        '''Generator to iterate over all the expended nodes starting from\n        `node` and down. If `node` is `None`, the generator start with\n        :attr:`root`.\n\n        To get all the open nodes::\n\n            treeview = TreeView()\n            # ... add nodes ...\n            for node in treeview.iterate_open_nodes():\n                print(node)\n\n        '''\n        if not node:\n            node = self.root\n        if self.hide_root and node is self.root:\n            pass\n        else:\n            yield node\n        if not node.is_open:\n            return\n        f = self.iterate_open_nodes\n        for cnode in node.nodes:\n            for ynode in f(cnode):\n                yield ynode\n\n    def iterate_all_nodes(self, node=None):\n        '''Generator to iterate over all nodes from `node` and down whether\n        expanded or not. If `node` is `None`, the generator start with\n        :attr:`root`.\n        '''\n        if not node:\n            node = self.root\n        yield node\n        f = self.iterate_all_nodes\n        for cnode in node.nodes:\n            for ynode in f(cnode):\n                yield ynode\n\n    #\n    # Private\n    #\n    def on_load_func(self, instance, value):\n        if value:\n            Clock.schedule_once(self._do_initial_load)\n\n    def _do_initial_load(self, *largs):\n        if not self.load_func:\n            return\n        self._do_node_load(None)\n\n    def _do_node_load(self, node):\n        gen = self.load_func(self, node)\n        if node:\n            node.is_loaded = True\n        if not gen:\n            return\n        for cnode in gen:\n            self.add_node(cnode, node)\n\n    def on_root_options(self, instance, value):\n        if not self.root:\n            return\n        for key, value in value.items():\n            setattr(self.root, key, value)\n\n    def _do_layout(self, *largs):\n        self.clear_widgets()\n        # display only the one who are is_open\n        self._do_open_node(self.root)\n        # now do layout\n        self._do_layout_node(self.root, 0, self.top)\n        # now iterate for calculating minimum size\n        min_width = min_height = 0\n        for count, node in enumerate(self.iterate_open_nodes(self.root)):\n            node.odd = False if count % 2 else True\n            min_width = max(min_width, node.right - self.x)\n            min_height += node.height\n        self.minimum_size = (min_width, min_height)\n\n    def _do_open_node(self, node):\n        if self.hide_root and node is self.root:\n            height = 0\n        else:\n            self.add_widget(node)\n            height = node.height\n            if not node.is_open:\n                return height\n        for cnode in node.nodes:\n            height += self._do_open_node(cnode)\n        return height\n\n    def _do_layout_node(self, node, level, y):\n        if self.hide_root and node is self.root:\n            level -= 1\n        else:\n            node.x = self.x + self.indent_start + level * self.indent_level\n            node.top = y\n            if node.size_hint_x:\n                node.width = (self.width - (node.x - self.x)) \\\n                    * node.size_hint_x\n            y -= node.height\n            if not node.is_open:\n                return y\n        for cnode in node.nodes:\n            y = self._do_layout_node(cnode, level + 1, y)\n        return y\n\n    def on_touch_down(self, touch):\n        node = self.get_node_at_pos(touch.pos)\n        if not node:\n            return\n        if node.disabled:\n            return\n        # toggle node or selection ?\n        if node.x - self.indent_start <= touch.x < node.x:\n            self.toggle_node(node)\n        elif node.x <= touch.x:\n            self.select_node(node)\n            node.dispatch('on_touch_down', touch)\n        return True\n\n    #\n    # Private properties\n    #\n    _root = ObjectProperty(None)\n\n    _selected_node = ObjectProperty(None, allownone=True)\n\n    #\n    # Properties\n    #\n\n    minimum_width = NumericProperty(0)\n    '''Minimum width needed to contain all children.\n\n    .. versionadded:: 1.0.9\n\n    :attr:`minimum_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    minimum_height = NumericProperty(0)\n    '''Minimum height needed to contain all children.\n\n    .. versionadded:: 1.0.9\n\n    :attr:`minimum_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    minimum_size = ReferenceListProperty(minimum_width, minimum_height)\n    '''Minimum size needed to contain all children.\n\n    .. versionadded:: 1.0.9\n\n    :attr:`minimum_size` is a :class:`~kivy.properties.ReferenceListProperty`\n    of (:attr:`minimum_width`, :attr:`minimum_height`) properties.\n    '''\n\n    indent_level = NumericProperty('16dp')\n    '''Width used for the indentation of each level except the first level.\n\n    Computation of indent for each level of the tree is::\n\n        indent = indent_start + level * indent_level\n\n    :attr:`indent_level` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 16.\n    '''\n\n    indent_start = NumericProperty('24dp')\n    '''Indentation width of the level 0 / root node. This is mostly the initial\n    size to accommodate a tree icon (collapsed / expanded). See\n    :attr:`indent_level` for more information about the computation of level\n    indentation.\n\n    :attr:`indent_start` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 24.\n    '''\n\n    hide_root = BooleanProperty(False)\n    '''Use this property to show/hide the initial root node. If True, the root\n    node will be appear as a closed node.\n\n    :attr:`hide_root` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    def get_selected_node(self):\n        return self._selected_node\n\n    selected_node = AliasProperty(get_selected_node, None,\n                                  bind=('_selected_node', ))\n    '''Node selected by :meth:`TreeView.select_node` or by touch.\n\n    :attr:`selected_node` is a :class:`~kivy.properties.AliasProperty` and\n    defaults to None. It is read-only.\n    '''\n\n    def get_root(self):\n        return self._root\n\n    root = AliasProperty(get_root, None, bind=('_root', ))\n    '''Root node.\n\n    By default, the root node widget is a :class:`TreeViewLabel` with text\n    'Root'. If you want to change the default options passed to the widget\n    creation, use the :attr:`root_options` property::\n\n        treeview = TreeView(root_options={\n            'text': 'Root directory',\n            'font_size': 15})\n\n    :attr:`root_options` will change the properties of the\n    :class:`TreeViewLabel` instance. However, you cannot change the class used\n    for root node yet.\n\n    :attr:`root` is an :class:`~kivy.properties.AliasProperty` and defaults to\n    None. It is read-only. However, the content of the widget can be changed.\n    '''\n\n    root_options = ObjectProperty({})\n    '''Default root options to pass for root widget. See :attr:`root` property\n    for more information about the usage of root_options.\n\n    :attr:`root_options` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to {}.\n    '''\n\n    load_func = ObjectProperty(None)\n    '''Callback to use for asynchronous loading. If set, asynchronous loading\n    will be automatically done. The callback must act as a Python generator\n    function, using yield to send data back to the treeview.\n\n    The callback should be in the format::\n\n        def callback(treeview, node):\n            for name in ('Item 1', 'Item 2'):\n                yield TreeViewLabel(text=name)\n\n    :attr:`load_func` is a :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''",
  "def __init__(self, **kwargs):\n        if self.__class__ is TreeViewNode:\n            raise TreeViewException('You cannot use directly TreeViewNode.')\n        super(TreeViewNode, self).__init__(**kwargs)",
  "def __init__(self, **kwargs):\n        self._trigger_layout = Clock.create_trigger(self._do_layout, -1)\n        super(TreeView, self).__init__(**kwargs)\n        tvlabel = TreeViewLabel(text='Root', is_open=True, level=0)\n        for key, value in self.root_options.items():\n            setattr(tvlabel, key, value)\n        self._root = self.add_node(tvlabel, None)\n\n        trigger = self._trigger_layout\n        fbind = self.fbind\n        fbind('pos', trigger)\n        fbind('size', trigger)\n        fbind('indent_level', trigger)\n        fbind('indent_start', trigger)\n        trigger()",
  "def add_node(self, node, parent=None):\n        '''Add a new node to the tree.\n\n        :Parameters:\n            `node`: instance of a :class:`TreeViewNode`\n                Node to add into the tree\n            `parent`: instance of a :class:`TreeViewNode`, defaults to None\n                Parent node to attach the new node. If `None`, it is added to\n                the :attr:`root` node.\n\n        :returns:\n            the node `node`.\n        '''\n        # check if the widget is \"ok\" for a node\n        if not isinstance(node, TreeViewNode):\n            raise TreeViewException(\n                'The node must be a subclass of TreeViewNode')\n        # create node\n        if parent is None and self._root:\n            parent = self._root\n        if parent:\n            parent.is_leaf = False\n            parent.nodes.append(node)\n            node.parent_node = parent\n            node.level = parent.level + 1\n        node.fbind('size', self._trigger_layout)\n        self._trigger_layout()\n        return node",
  "def remove_node(self, node):\n        '''Removes a node from the tree.\n\n        .. versionadded:: 1.0.7\n\n        :Parameters:\n            `node`: instance of a :class:`TreeViewNode`\n                Node to remove from the tree. If `node` is :attr:`root`, it is\n                not removed.\n        '''\n        # check if the widget is \"ok\" for a node\n        if not isinstance(node, TreeViewNode):\n            raise TreeViewException(\n                'The node must be a subclass of TreeViewNode')\n        parent = node.parent_node\n        if parent is not None:\n            if node == self._selected_node:\n                node.is_selected = False\n                self._selected_node = None\n            nodes = parent.nodes\n            if node in nodes:\n                nodes.remove(node)\n            parent.is_leaf = not bool(len(nodes))\n            node.parent_node = None\n            node.funbind('size', self._trigger_layout)\n            self._trigger_layout()",
  "def on_node_expand(self, node):\n        pass",
  "def on_node_collapse(self, node):\n        pass",
  "def select_node(self, node):\n        '''Select a node in the tree.\n        '''\n        if node.no_selection:\n            return\n        if self._selected_node:\n            self._selected_node.is_selected = False\n        node.is_selected = True\n        self._selected_node = node",
  "def deselect_node(self, *args):\n        '''Deselect any selected node.\n\n        .. versionadded:: 1.10.0\n        '''\n        if self._selected_node:\n            self._selected_node.is_selected = False\n            self._selected_node = None",
  "def toggle_node(self, node):\n        '''Toggle the state of the node (open/collapsed).\n        '''\n        node.is_open = not node.is_open\n        if node.is_open:\n            if self.load_func and not node.is_loaded:\n                self._do_node_load(node)\n            self.dispatch('on_node_expand', node)\n        else:\n            self.dispatch('on_node_collapse', node)\n        self._trigger_layout()",
  "def get_node_at_pos(self, pos):\n        '''Get the node at the position (x, y).\n        '''\n        x, y = pos\n        for node in self.iterate_open_nodes(self.root):\n            if self.x <= x <= self.right and \\\n               node.y <= y <= node.top:\n                return node",
  "def iterate_open_nodes(self, node=None):\n        '''Generator to iterate over all the expended nodes starting from\n        `node` and down. If `node` is `None`, the generator start with\n        :attr:`root`.\n\n        To get all the open nodes::\n\n            treeview = TreeView()\n            # ... add nodes ...\n            for node in treeview.iterate_open_nodes():\n                print(node)\n\n        '''\n        if not node:\n            node = self.root\n        if self.hide_root and node is self.root:\n            pass\n        else:\n            yield node\n        if not node.is_open:\n            return\n        f = self.iterate_open_nodes\n        for cnode in node.nodes:\n            for ynode in f(cnode):\n                yield ynode",
  "def iterate_all_nodes(self, node=None):\n        '''Generator to iterate over all nodes from `node` and down whether\n        expanded or not. If `node` is `None`, the generator start with\n        :attr:`root`.\n        '''\n        if not node:\n            node = self.root\n        yield node\n        f = self.iterate_all_nodes\n        for cnode in node.nodes:\n            for ynode in f(cnode):\n                yield ynode",
  "def on_load_func(self, instance, value):\n        if value:\n            Clock.schedule_once(self._do_initial_load)",
  "def _do_initial_load(self, *largs):\n        if not self.load_func:\n            return\n        self._do_node_load(None)",
  "def _do_node_load(self, node):\n        gen = self.load_func(self, node)\n        if node:\n            node.is_loaded = True\n        if not gen:\n            return\n        for cnode in gen:\n            self.add_node(cnode, node)",
  "def on_root_options(self, instance, value):\n        if not self.root:\n            return\n        for key, value in value.items():\n            setattr(self.root, key, value)",
  "def _do_layout(self, *largs):\n        self.clear_widgets()\n        # display only the one who are is_open\n        self._do_open_node(self.root)\n        # now do layout\n        self._do_layout_node(self.root, 0, self.top)\n        # now iterate for calculating minimum size\n        min_width = min_height = 0\n        for count, node in enumerate(self.iterate_open_nodes(self.root)):\n            node.odd = False if count % 2 else True\n            min_width = max(min_width, node.right - self.x)\n            min_height += node.height\n        self.minimum_size = (min_width, min_height)",
  "def _do_open_node(self, node):\n        if self.hide_root and node is self.root:\n            height = 0\n        else:\n            self.add_widget(node)\n            height = node.height\n            if not node.is_open:\n                return height\n        for cnode in node.nodes:\n            height += self._do_open_node(cnode)\n        return height",
  "def _do_layout_node(self, node, level, y):\n        if self.hide_root and node is self.root:\n            level -= 1\n        else:\n            node.x = self.x + self.indent_start + level * self.indent_level\n            node.top = y\n            if node.size_hint_x:\n                node.width = (self.width - (node.x - self.x)) \\\n                    * node.size_hint_x\n            y -= node.height\n            if not node.is_open:\n                return y\n        for cnode in node.nodes:\n            y = self._do_layout_node(cnode, level + 1, y)\n        return y",
  "def on_touch_down(self, touch):\n        node = self.get_node_at_pos(touch.pos)\n        if not node:\n            return\n        if node.disabled:\n            return\n        # toggle node or selection ?\n        if node.x - self.indent_start <= touch.x < node.x:\n            self.toggle_node(node)\n        elif node.x <= touch.x:\n            self.select_node(node)\n            node.dispatch('on_touch_down', touch)\n        return True",
  "def get_selected_node(self):\n        return self._selected_node",
  "def get_root(self):\n        return self._root",
  "class TestApp(App):\n\n        def build(self):\n            tv = TreeView(hide_root=True)\n            add = tv.add_node\n            root = add(TreeViewLabel(text='Level 1, entry 1', is_open=True))\n            for x in range(5):\n                add(TreeViewLabel(text='Element %d' % x), root)\n            root2 = add(TreeViewLabel(text='Level 1, entry 2', is_open=False))\n            for x in range(24):\n                add(TreeViewLabel(text='Element %d' % x), root2)\n            for x in range(5):\n                add(TreeViewLabel(text='Element %d' % x), root)\n            root2 = add(TreeViewLabel(text='Element childs 2', is_open=False),\n                        root)\n            for x in range(24):\n                add(TreeViewLabel(text='Element %d' % x), root2)\n            return tv",
  "def build(self):\n            tv = TreeView(hide_root=True)\n            add = tv.add_node\n            root = add(TreeViewLabel(text='Level 1, entry 1', is_open=True))\n            for x in range(5):\n                add(TreeViewLabel(text='Element %d' % x), root)\n            root2 = add(TreeViewLabel(text='Level 1, entry 2', is_open=False))\n            for x in range(24):\n                add(TreeViewLabel(text='Element %d' % x), root2)\n            for x in range(5):\n                add(TreeViewLabel(text='Element %d' % x), root)\n            root2 = add(TreeViewLabel(text='Element childs 2', is_open=False),\n                        root)\n            for x in range(24):\n                add(TreeViewLabel(text='Element %d' % x), root2)\n            return tv",
  "class CheckBox(ToggleButtonBehavior, Widget):\n    '''CheckBox class, see module documentation for more information.\n    '''\n\n    def _get_active(self):\n        return self.state == 'down'\n\n    def _set_active(self, value):\n        self.state = 'down' if value else 'normal'\n\n    active = AliasProperty(\n        _get_active, _set_active, bind=('state', ), cache=True)\n    '''Indicates if the switch is active or inactive.\n\n    :attr:`active` is a boolean and reflects and sets whether the underlying\n    :attr:`~kivy.uix.button.Button.state` is 'down' (True) or 'normal' (False).\n    It is a :class:`~kivy.properties.AliasProperty`, which accepts boolean\n    values and defaults to False.\n\n    .. versionchanged:: 1.11.0\n\n        It changed from a BooleanProperty to a AliasProperty.\n    '''\n\n    background_checkbox_normal = StringProperty(\n        'atlas://data/images/defaulttheme/checkbox_off')\n    '''Background image of the checkbox used for the default graphical\n    representation when the checkbox is not active.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`background_checkbox_normal` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/checkbox_off'.\n    '''\n\n    background_checkbox_down = StringProperty(\n        'atlas://data/images/defaulttheme/checkbox_on')\n    '''Background image of the checkbox used for the default graphical\n    representation when the checkbox is active.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`background_checkbox_down` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/checkbox_on'.\n    '''\n\n    background_checkbox_disabled_normal = StringProperty(\n        'atlas://data/images/defaulttheme/checkbox_disabled_off')\n    '''Background image of the checkbox used for the default graphical\n    representation when the checkbox is disabled and not active.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`background_checkbox_disabled_normal` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/checkbox_disabled_off'.\n    '''\n\n    background_checkbox_disabled_down = StringProperty(\n        'atlas://data/images/defaulttheme/checkbox_disabled_on')\n    '''Background image of the checkbox used for the default graphical\n    representation when the checkbox is disabled and active.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`background_checkbox_disabled_down` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/checkbox_disabled_on'.\n    '''\n\n    background_radio_normal = StringProperty(\n        'atlas://data/images/defaulttheme/checkbox_radio_off')\n    '''Background image of the radio button used for the default graphical\n    representation when the radio button is not active.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`background_radio_normal` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/checkbox_radio_off'.\n    '''\n\n    background_radio_down = StringProperty(\n        'atlas://data/images/defaulttheme/checkbox_radio_on')\n    '''Background image of the radio button used for the default graphical\n    representation when the radio button is active.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`background_radio_down` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/checkbox_radio_on'.\n    '''\n\n    background_radio_disabled_normal = StringProperty(\n        'atlas://data/images/defaulttheme/checkbox_radio_disabled_off')\n    '''Background image of the radio button used for the default graphical\n    representation when the radio button is disabled and not active.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`background_radio_disabled_normal` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/checkbox_radio_disabled_off'.\n    '''\n\n    background_radio_disabled_down = StringProperty(\n        'atlas://data/images/defaulttheme/checkbox_radio_disabled_on')\n    '''Background image of the radio button used for the default graphical\n    representation when the radio button is disabled and active.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`background_radio_disabled_down` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/checkbox_radio_disabled_on'.\n    '''\n\n    color = ColorProperty([1, 1, 1, 1])\n    '''Color is used for tinting the default graphical representation\n    of checkbox and radio button (images).\n\n    Color is in the format (r, g, b, a).\n\n    .. versionadded:: 1.10.0\n\n    :attr:`color` is a\n    :class:`~kivy.properties.ColorProperty` and defaults to\n    '[1, 1, 1, 1]'.\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    def __init__(self, **kwargs):\n        self.fbind('state', self._on_state)\n        super(CheckBox, self).__init__(**kwargs)\n\n    def _on_state(self, instance, value):\n        if self.group and self.state == 'down':\n            self._release_group(self)\n\n    def on_group(self, *largs):\n        super(CheckBox, self).on_group(*largs)\n        if self.active:\n            self._release_group(self)",
  "def _get_active(self):\n        return self.state == 'down'",
  "def _set_active(self, value):\n        self.state = 'down' if value else 'normal'",
  "def __init__(self, **kwargs):\n        self.fbind('state', self._on_state)\n        super(CheckBox, self).__init__(**kwargs)",
  "def _on_state(self, instance, value):\n        if self.group and self.state == 'down':\n            self._release_group(self)",
  "def on_group(self, *largs):\n        super(CheckBox, self).on_group(*largs)\n        if self.active:\n            self._release_group(self)",
  "class Image(Widget):\n    '''Image class, see module documentation for more information.'''\n\n    source = StringProperty(None)\n    '''Filename / source of your image.\n\n    :attr:`source` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    texture = ObjectProperty(None, allownone=True)\n    '''Texture object of the image. The texture represents the original, loaded\n    image texture. It is stretched and positioned during rendering according to\n    the :attr:`fit_mode` property.\n\n    Depending of the texture creation, the value will be a\n    :class:`~kivy.graphics.texture.Texture` or a\n    :class:`~kivy.graphics.texture.TextureRegion` object.\n\n    :attr:`texture` is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    texture_size = ListProperty([0, 0])\n    '''Texture size of the image. This represents the original, loaded image\n    texture size.\n\n    .. warning::\n\n        The texture size is set after the texture property. So if you listen to\n        the change on :attr:`texture`, the property texture_size will not be\n        up-to-date. Use self.texture.size instead.\n    '''\n\n    def get_image_ratio(self):\n        if self.texture:\n            return self.texture.width / float(self.texture.height)\n        return 1.0\n\n    mipmap = BooleanProperty(False)\n    '''Indicate if you want OpenGL mipmapping to be applied to the texture.\n    Read :ref:`mipmap` for more information.\n\n    .. versionadded:: 1.0.7\n\n    :attr:`mipmap` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    image_ratio = AliasProperty(get_image_ratio, bind=('texture',), cache=True)\n    '''Ratio of the image (width / float(height).\n\n    :attr:`image_ratio` is an :class:`~kivy.properties.AliasProperty` and is\n    read-only.\n    '''\n\n    color = ColorProperty([1, 1, 1, 1])\n    '''Image color, in the format (r, g, b, a). This attribute can be used to\n    'tint' an image. Be careful: if the source image is not gray/white, the\n    color will not really work as expected.\n\n    .. versionadded:: 1.0.6\n\n    :attr:`color` is a :class:`~kivy.properties.ColorProperty` and defaults to\n    [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    allow_stretch = BooleanProperty(False, deprecated=True)\n    '''If True, the normalized image size will be maximized to fit in the image\n    box. Otherwise, if the box is too tall, the image will not be\n    stretched more than 1:1 pixels.\n\n    .. versionadded:: 1.0.7\n\n    .. deprecated:: 2.2.0\n        :attr:`allow_stretch` have been deprecated. Please use `fit_mode`\n        instead.\n\n    :attr:`allow_stretch` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    keep_ratio = BooleanProperty(True, deprecated=True)\n    '''If False along with allow_stretch being True, the normalized image\n    size will be maximized to fit in the image box and ignores the aspect\n    ratio of the image.\n    Otherwise, if the box is too tall, the image will not be stretched more\n    than 1:1 pixels.\n\n    .. versionadded:: 1.0.8\n\n    .. deprecated:: 2.2.0\n        :attr:`keep_ratio` have been deprecated. Please use `fit_mode`\n        instead.\n\n    :attr:`keep_ratio` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    fit_mode = OptionProperty(\n        \"scale-down\", options=[\"scale-down\", \"fill\", \"contain\", \"cover\"]\n    )\n    '''If the size of the image is different than the size of the widget,\n    determine how the image should be resized to fit inside the widget box.\n\n    Available options:\n\n    - ``\"scale-down\"``: the image will be scaled down to fit inside the widget\n    box, **maintaining its aspect ratio and without stretching**. If the size\n    of the image is smaller than the widget, it will be displayed at its\n    original size. If the image has a different aspect ratio than the widget,\n    there will be blank areas on the widget box.\n\n    - ``\"fill\"``: the image is stretched to fill the widget, **regardless of\n    its aspect ratio or dimensions**. If the image has a different aspect ratio\n    than the widget, this option can lead to distortion of the image.\n\n    - ``\"contain\"``: the image is resized to fit inside the widget box,\n    **maintaining its aspect ratio**. If the image size is larger than the\n    widget size, the behavior will be similar to ``\"scale-down\"``. However, if\n    the size of the image is smaller than the widget size, unlike\n    ``\"scale-down``, the image will be resized to fit inside the widget.\n    If the image has a different aspect ratio than the widget, there will be\n    blank areas on the widget box.\n\n    - ``\"cover\"``: the image will be stretched horizontally or vertically to\n    fill the widget box, **maintaining its aspect ratio**. If the image has a\n    different aspect ratio than the widget, then the image will be clipped to\n    fit.\n\n    :attr:`fit_mode` is a :class:`~kivy.properties.OptionProperty` and\n    defaults to ``\"scale-down\"``.\n    '''\n\n    keep_data = BooleanProperty(False)\n    '''If True, the underlying _coreimage will store the raw image data.\n    This is useful when performing pixel based collision detection.\n\n    .. versionadded:: 1.3.0\n\n    :attr:`keep_data` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    anim_delay = NumericProperty(0.25)\n    '''Delay the animation if the image is sequenced (like an animated gif).\n    If anim_delay is set to -1, the animation will be stopped.\n\n    .. versionadded:: 1.0.8\n\n    :attr:`anim_delay` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.25 (4 FPS).\n    '''\n\n    anim_loop = NumericProperty(0)\n    '''Number of loops to play then stop animating. 0 means keep animating.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`anim_loop` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    nocache = BooleanProperty(False)\n    '''If this property is set True, the image will not be added to the\n    internal cache. The cache will simply ignore any calls trying to\n    append the core image.\n\n    .. versionadded:: 1.6.0\n\n    :attr:`nocache` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    def get_norm_image_size(self):\n        if not self.texture:\n            return list(self.size)\n\n        ratio = self.image_ratio\n        w, h = self.size\n        tw, th = self.texture.size\n\n        if self.fit_mode == \"cover\":\n            widget_ratio = w / max(1, h)\n            if widget_ratio > ratio:\n                return [w, (w * th) / tw]\n            else:\n                return [(h * tw) / th, h]\n        elif self.fit_mode == \"fill\":\n            return [w, h]\n        elif self.fit_mode == \"contain\":\n            iw = w\n        else:\n            iw = min(w, tw)\n\n        # calculate the appropriate height\n        ih = iw / ratio\n        # if the height is too higher, take the height of the container\n        # and calculate appropriate width. no need to test further. :)\n        if ih > h:\n            if self.fit_mode == \"contain\":\n                ih = h\n            else:\n                ih = min(h, th)\n            iw = ih * ratio\n        return [iw, ih]\n\n    norm_image_size = AliasProperty(\n        get_norm_image_size,\n        bind=(\n            'texture',\n            'size',\n            'image_ratio',\n            'fit_mode',\n        ),\n        cache=True,\n    )\n    '''Normalized image size within the widget box.\n\n    This size will always fit the widget size and will preserve the image\n    ratio.\n\n    :attr:`norm_image_size` is an :class:`~kivy.properties.AliasProperty` and\n    is read-only.\n    '''\n\n    def __init__(self, **kwargs):\n        self._coreimage = None\n        self._loops = 0\n        update = self.texture_update\n        fbind = self.fbind\n        fbind('source', update)\n        fbind('mipmap', update)\n\n        # NOTE: Compatibility code due to deprecated properties.\n        fbind('keep_ratio', self._update_fit_mode)\n        fbind('allow_stretch', self._update_fit_mode)\n        super().__init__(**kwargs)\n\n    def _update_fit_mode(self, *args):\n        keep_ratio = self.keep_ratio\n        allow_stretch = self.allow_stretch\n        if (\n            not keep_ratio and not allow_stretch\n            or keep_ratio and not allow_stretch\n        ):\n            self.fit_mode = \"scale-down\"\n        elif not keep_ratio and allow_stretch:\n            self.fit_mode = \"fill\"\n        elif keep_ratio and allow_stretch:\n            self.fit_mode = \"contain\"\n\n    def texture_update(self, *largs):\n        self.set_texture_from_resource(self.source)\n\n    def set_texture_from_resource(self, resource):\n        if not resource:\n            self._clear_core_image()\n            return\n        source = resource_find(resource)\n        if not source:\n            Logger.error('Image: Not found <%s>' % resource)\n            self._clear_core_image()\n            return\n        if self._coreimage:\n            self._coreimage.unbind(on_texture=self._on_tex_change)\n        try:\n            self._coreimage = image = CoreImage(\n                source,\n                mipmap=self.mipmap,\n                anim_delay=self.anim_delay,\n                keep_data=self.keep_data,\n                nocache=self.nocache\n            )\n        except Exception:\n            Logger.error('Image: Error loading <%s>' % resource)\n            self._clear_core_image()\n            image = self._coreimage\n        if image:\n            image.bind(on_texture=self._on_tex_change)\n            self.texture = image.texture\n\n    def on_anim_delay(self, instance, value):\n        if self._coreimage is None:\n            return\n        self._coreimage.anim_delay = value\n        if value < 0:\n            self._coreimage.anim_reset(False)\n\n    def on_texture(self, instance, value):\n        self.texture_size = value.size if value else [0, 0]\n\n    def _clear_core_image(self):\n        if self._coreimage:\n            self._coreimage.unbind(on_texture=self._on_tex_change)\n        self.texture = None\n        self._coreimage = None\n        self._loops = 0\n\n    def _on_tex_change(self, *largs):\n        # update texture from core image\n        self.texture = self._coreimage.texture\n        ci = self._coreimage\n        if self.anim_loop and ci._anim_index == len(ci._image.textures) - 1:\n            self._loops += 1\n            if self.anim_loop == self._loops:\n                ci.anim_reset(False)\n                self._loops = 0\n\n    def reload(self):\n        '''Reload image from disk. This facilitates re-loading of\n        images from disk in case the image content changes.\n\n        .. versionadded:: 1.3.0\n\n        Usage::\n\n            im = Image(source = '1.jpg')\n            # -- do something --\n            im.reload()\n            # image will be re-loaded from disk\n\n        '''\n        self.remove_from_cache()\n        old_source = self.source\n        self.source = ''\n        self.source = old_source\n\n    def remove_from_cache(self):\n        '''Remove image from cache.\n\n        .. versionadded:: 2.0.0\n        '''\n        if self._coreimage:\n            self._coreimage.remove_from_cache()\n\n    def on_nocache(self, *args):\n        if self.nocache:\n            self.remove_from_cache()\n            if self._coreimage:\n                self._coreimage._nocache = True",
  "class AsyncImage(Image):\n    '''Asynchronous Image class. See the module documentation for more\n    information.\n\n    .. note::\n\n        The AsyncImage is a specialized form of the Image class. You may\n        want to refer to the :mod:`~kivy.loader` documentation and in\n        particular, the :class:`~kivy.loader.ProxyImage` for more detail\n        on how to handle events around asynchronous image loading.\n\n    .. note::\n\n        AsyncImage currently does not support properties\n        :attr:`anim_loop` and :attr:`mipmap` and setting those properties will\n        have no effect.\n    '''\n\n    __events__ = ('on_error', 'on_load')\n\n    def __init__(self, **kwargs):\n        self._found_source = None\n        self._coreimage = None\n        global Loader\n        if not Loader:\n            from kivy.loader import Loader\n        self.fbind('source', self._load_source)\n        super().__init__(**kwargs)\n\n    def _load_source(self, *args):\n        source = self.source\n        if not source:\n            self._clear_core_image()\n            return\n        if not self.is_uri(source):\n            source = resource_find(source)\n            if not source:\n                Logger.error('AsyncImage: Not found <%s>' % self.source)\n                self._clear_core_image()\n                return\n        self._found_source = source\n        self._coreimage = image = Loader.image(\n            source,\n            nocache=self.nocache,\n            mipmap=self.mipmap,\n            anim_delay=self.anim_delay\n        )\n        image.bind(\n            on_load=self._on_source_load,\n            on_error=self._on_source_error,\n            on_texture=self._on_tex_change\n        )\n        self.texture = image.texture\n\n    def _on_source_load(self, value):\n        image = self._coreimage.image\n        if not image:\n            return\n        self.texture = image.texture\n        self.dispatch('on_load')\n\n    def _on_source_error(self, instance, error=None):\n        self.dispatch('on_error', error)\n\n    def on_error(self, error):\n        pass\n\n    def on_load(self, *args):\n        pass\n\n    def is_uri(self, filename):\n        proto = filename.split('://', 1)[0]\n        return proto in ('http', 'https', 'ftp', 'smb')\n\n    def _clear_core_image(self):\n        if self._coreimage:\n            self._coreimage.unbind(on_load=self._on_source_load)\n        super()._clear_core_image()\n        self._found_source = None\n\n    def _on_tex_change(self, *largs):\n        if self._coreimage:\n            self.texture = self._coreimage.texture\n\n    def texture_update(self, *largs):\n        pass\n\n    def remove_from_cache(self):\n        if self._found_source:\n            Loader.remove_from_cache(self._found_source)\n        super().remove_from_cache()",
  "def get_image_ratio(self):\n        if self.texture:\n            return self.texture.width / float(self.texture.height)\n        return 1.0",
  "def get_norm_image_size(self):\n        if not self.texture:\n            return list(self.size)\n\n        ratio = self.image_ratio\n        w, h = self.size\n        tw, th = self.texture.size\n\n        if self.fit_mode == \"cover\":\n            widget_ratio = w / max(1, h)\n            if widget_ratio > ratio:\n                return [w, (w * th) / tw]\n            else:\n                return [(h * tw) / th, h]\n        elif self.fit_mode == \"fill\":\n            return [w, h]\n        elif self.fit_mode == \"contain\":\n            iw = w\n        else:\n            iw = min(w, tw)\n\n        # calculate the appropriate height\n        ih = iw / ratio\n        # if the height is too higher, take the height of the container\n        # and calculate appropriate width. no need to test further. :)\n        if ih > h:\n            if self.fit_mode == \"contain\":\n                ih = h\n            else:\n                ih = min(h, th)\n            iw = ih * ratio\n        return [iw, ih]",
  "def __init__(self, **kwargs):\n        self._coreimage = None\n        self._loops = 0\n        update = self.texture_update\n        fbind = self.fbind\n        fbind('source', update)\n        fbind('mipmap', update)\n\n        # NOTE: Compatibility code due to deprecated properties.\n        fbind('keep_ratio', self._update_fit_mode)\n        fbind('allow_stretch', self._update_fit_mode)\n        super().__init__(**kwargs)",
  "def _update_fit_mode(self, *args):\n        keep_ratio = self.keep_ratio\n        allow_stretch = self.allow_stretch\n        if (\n            not keep_ratio and not allow_stretch\n            or keep_ratio and not allow_stretch\n        ):\n            self.fit_mode = \"scale-down\"\n        elif not keep_ratio and allow_stretch:\n            self.fit_mode = \"fill\"\n        elif keep_ratio and allow_stretch:\n            self.fit_mode = \"contain\"",
  "def texture_update(self, *largs):\n        self.set_texture_from_resource(self.source)",
  "def set_texture_from_resource(self, resource):\n        if not resource:\n            self._clear_core_image()\n            return\n        source = resource_find(resource)\n        if not source:\n            Logger.error('Image: Not found <%s>' % resource)\n            self._clear_core_image()\n            return\n        if self._coreimage:\n            self._coreimage.unbind(on_texture=self._on_tex_change)\n        try:\n            self._coreimage = image = CoreImage(\n                source,\n                mipmap=self.mipmap,\n                anim_delay=self.anim_delay,\n                keep_data=self.keep_data,\n                nocache=self.nocache\n            )\n        except Exception:\n            Logger.error('Image: Error loading <%s>' % resource)\n            self._clear_core_image()\n            image = self._coreimage\n        if image:\n            image.bind(on_texture=self._on_tex_change)\n            self.texture = image.texture",
  "def on_anim_delay(self, instance, value):\n        if self._coreimage is None:\n            return\n        self._coreimage.anim_delay = value\n        if value < 0:\n            self._coreimage.anim_reset(False)",
  "def on_texture(self, instance, value):\n        self.texture_size = value.size if value else [0, 0]",
  "def _clear_core_image(self):\n        if self._coreimage:\n            self._coreimage.unbind(on_texture=self._on_tex_change)\n        self.texture = None\n        self._coreimage = None\n        self._loops = 0",
  "def _on_tex_change(self, *largs):\n        # update texture from core image\n        self.texture = self._coreimage.texture\n        ci = self._coreimage\n        if self.anim_loop and ci._anim_index == len(ci._image.textures) - 1:\n            self._loops += 1\n            if self.anim_loop == self._loops:\n                ci.anim_reset(False)\n                self._loops = 0",
  "def reload(self):\n        '''Reload image from disk. This facilitates re-loading of\n        images from disk in case the image content changes.\n\n        .. versionadded:: 1.3.0\n\n        Usage::\n\n            im = Image(source = '1.jpg')\n            # -- do something --\n            im.reload()\n            # image will be re-loaded from disk\n\n        '''\n        self.remove_from_cache()\n        old_source = self.source\n        self.source = ''\n        self.source = old_source",
  "def remove_from_cache(self):\n        '''Remove image from cache.\n\n        .. versionadded:: 2.0.0\n        '''\n        if self._coreimage:\n            self._coreimage.remove_from_cache()",
  "def on_nocache(self, *args):\n        if self.nocache:\n            self.remove_from_cache()\n            if self._coreimage:\n                self._coreimage._nocache = True",
  "def __init__(self, **kwargs):\n        self._found_source = None\n        self._coreimage = None\n        global Loader\n        if not Loader:\n            from kivy.loader import Loader\n        self.fbind('source', self._load_source)\n        super().__init__(**kwargs)",
  "def _load_source(self, *args):\n        source = self.source\n        if not source:\n            self._clear_core_image()\n            return\n        if not self.is_uri(source):\n            source = resource_find(source)\n            if not source:\n                Logger.error('AsyncImage: Not found <%s>' % self.source)\n                self._clear_core_image()\n                return\n        self._found_source = source\n        self._coreimage = image = Loader.image(\n            source,\n            nocache=self.nocache,\n            mipmap=self.mipmap,\n            anim_delay=self.anim_delay\n        )\n        image.bind(\n            on_load=self._on_source_load,\n            on_error=self._on_source_error,\n            on_texture=self._on_tex_change\n        )\n        self.texture = image.texture",
  "def _on_source_load(self, value):\n        image = self._coreimage.image\n        if not image:\n            return\n        self.texture = image.texture\n        self.dispatch('on_load')",
  "def _on_source_error(self, instance, error=None):\n        self.dispatch('on_error', error)",
  "def on_error(self, error):\n        pass",
  "def on_load(self, *args):\n        pass",
  "def is_uri(self, filename):\n        proto = filename.split('://', 1)[0]\n        return proto in ('http', 'https', 'ftp', 'smb')",
  "def _clear_core_image(self):\n        if self._coreimage:\n            self._coreimage.unbind(on_load=self._on_source_load)\n        super()._clear_core_image()\n        self._found_source = None",
  "def _on_tex_change(self, *largs):\n        if self._coreimage:\n            self.texture = self._coreimage.texture",
  "def texture_update(self, *largs):\n        pass",
  "def remove_from_cache(self):\n        if self._found_source:\n            Loader.remove_from_cache(self._found_source)\n        super().remove_from_cache()",
  "class PageLayout(Layout):\n    '''PageLayout class. See module documentation for more information.\n    '''\n\n    page = NumericProperty(0)\n    '''The currently displayed page.\n\n    :data:`page` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 0.\n    '''\n\n    border = NumericProperty('50dp')\n    '''The width of the border around the current page used to display\n    the previous/next page swipe areas when needed.\n\n    :data:`border` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 50dp.\n    '''\n\n    swipe_threshold = NumericProperty(.5)\n    '''The threshold used to trigger swipes as ratio of the widget\n    size.\n\n    :data:`swipe_threshold` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to .5.\n    '''\n\n    anim_kwargs = DictProperty({'d': .5, 't': 'in_quad'})\n    '''The animation kwargs used to construct the animation\n\n    :data:`anim_kwargs` is a :class:`~kivy.properties.DictProperty`\n    and defaults to {'d': .5, 't': 'in_quad'}.\n\n    .. versionadded:: 1.11.0\n    '''\n\n    def __init__(self, **kwargs):\n        super(PageLayout, self).__init__(**kwargs)\n\n        trigger = self._trigger_layout\n        fbind = self.fbind\n        fbind('border', trigger)\n        fbind('page', trigger)\n        fbind('parent', trigger)\n        fbind('children', trigger)\n        fbind('size', trigger)\n        fbind('pos', trigger)\n\n    def do_layout(self, *largs):\n        l_children = len(self.children) - 1\n        h = self.height\n        x_parent, y_parent = self.pos\n        p = self.page\n        border = self.border\n        half_border = border / 2.\n        right = self.right\n        width = self.width - border\n        for i, c in enumerate(reversed(self.children)):\n\n            if i < p:\n                x = x_parent\n            elif i == p:\n                if not p:  # it's first page\n                    x = x_parent\n                elif p != l_children:  # not first, but there are post pages\n                    x = x_parent + half_border\n                else:  # not first and there are no post pages\n                    x = x_parent + border\n            elif i == p + 1:\n                if not p:  # second page - no left margin\n                    x = right - border\n                else:  # there's already a left margin\n                    x = right - half_border\n            else:\n                x = right\n\n            c.height = h\n            c.width = width\n\n            Animation(\n                x=x,\n                y=y_parent,\n                **self.anim_kwargs).start(c)\n\n    def on_touch_down(self, touch):\n        if (\n            self.disabled or\n            not self.collide_point(*touch.pos) or\n            not self.children\n        ):\n            return\n\n        page = self.children[-self.page - 1]\n        if self.x <= touch.x < page.x:\n            touch.ud['page'] = 'previous'\n            touch.grab(self)\n            return True\n        elif page.right <= touch.x < self.right:\n            touch.ud['page'] = 'next'\n            touch.grab(self)\n            return True\n        return page.on_touch_down(touch)\n\n    def on_touch_move(self, touch):\n        if touch.grab_current != self:\n            return\n\n        p = self.page\n        border = self.border\n        half_border = border / 2.\n        page = self.children[-p - 1]\n        if touch.ud['page'] == 'previous':\n            # move next page up to right edge\n            if p < len(self.children) - 1:\n                self.children[-p - 2].x = min(\n                    self.right - self.border * (1 - (touch.sx - touch.osx)),\n                    self.right)\n\n            # move current page until edge hits the right border\n            if p >= 1:\n                b_right = half_border if p > 1 else border\n                b_left = half_border if p < len(self.children) - 1 else border\n                self.children[-p - 1].x = max(min(\n                    self.x + b_left + (touch.x - touch.ox),\n                    self.right - b_right),\n                    self.x + b_left)\n\n            # move previous page left edge up to left border\n            if p > 1:\n                self.children[-p].x = min(\n                    self.x + half_border * (touch.sx - touch.osx),\n                    self.x + half_border)\n\n        elif touch.ud['page'] == 'next':\n            # move current page up to left edge\n            if p >= 1:\n                self.children[-p - 1].x = max(\n                    self.x + half_border * (1 - (touch.osx - touch.sx)),\n                    self.x)\n\n            # move next page until its edge hit the left border\n            if p < len(self.children) - 1:\n                b_right = half_border if p >= 1 else border\n                b_left = half_border if p < len(self.children) - 2 else border\n                self.children[-p - 2].x = min(max(\n                    self.right - b_right + (touch.x - touch.ox),\n                    self.x + b_left),\n                    self.right - b_right)\n\n            # move second next page up to right border\n            if p < len(self.children) - 2:\n                self.children[-p - 3].x = max(\n                    self.right + half_border * (touch.sx - touch.osx),\n                    self.right - half_border)\n\n        return page.on_touch_move(touch)\n\n    def on_touch_up(self, touch):\n        if touch.grab_current == self:\n            if (\n                touch.ud['page'] == 'previous' and\n                abs(touch.x - touch.ox) / self.width > self.swipe_threshold\n            ):\n                self.page -= 1\n            elif (\n                touch.ud['page'] == 'next' and\n                abs(touch.x - touch.ox) / self.width > self.swipe_threshold\n            ):\n                self.page += 1\n            else:\n                self._trigger_layout()\n\n            touch.ungrab(self)\n\n        if len(self.children) > 1:\n            return self.children[-self.page + 1].on_touch_up(touch)",
  "def __init__(self, **kwargs):\n        super(PageLayout, self).__init__(**kwargs)\n\n        trigger = self._trigger_layout\n        fbind = self.fbind\n        fbind('border', trigger)\n        fbind('page', trigger)\n        fbind('parent', trigger)\n        fbind('children', trigger)\n        fbind('size', trigger)\n        fbind('pos', trigger)",
  "def do_layout(self, *largs):\n        l_children = len(self.children) - 1\n        h = self.height\n        x_parent, y_parent = self.pos\n        p = self.page\n        border = self.border\n        half_border = border / 2.\n        right = self.right\n        width = self.width - border\n        for i, c in enumerate(reversed(self.children)):\n\n            if i < p:\n                x = x_parent\n            elif i == p:\n                if not p:  # it's first page\n                    x = x_parent\n                elif p != l_children:  # not first, but there are post pages\n                    x = x_parent + half_border\n                else:  # not first and there are no post pages\n                    x = x_parent + border\n            elif i == p + 1:\n                if not p:  # second page - no left margin\n                    x = right - border\n                else:  # there's already a left margin\n                    x = right - half_border\n            else:\n                x = right\n\n            c.height = h\n            c.width = width\n\n            Animation(\n                x=x,\n                y=y_parent,\n                **self.anim_kwargs).start(c)",
  "def on_touch_down(self, touch):\n        if (\n            self.disabled or\n            not self.collide_point(*touch.pos) or\n            not self.children\n        ):\n            return\n\n        page = self.children[-self.page - 1]\n        if self.x <= touch.x < page.x:\n            touch.ud['page'] = 'previous'\n            touch.grab(self)\n            return True\n        elif page.right <= touch.x < self.right:\n            touch.ud['page'] = 'next'\n            touch.grab(self)\n            return True\n        return page.on_touch_down(touch)",
  "def on_touch_move(self, touch):\n        if touch.grab_current != self:\n            return\n\n        p = self.page\n        border = self.border\n        half_border = border / 2.\n        page = self.children[-p - 1]\n        if touch.ud['page'] == 'previous':\n            # move next page up to right edge\n            if p < len(self.children) - 1:\n                self.children[-p - 2].x = min(\n                    self.right - self.border * (1 - (touch.sx - touch.osx)),\n                    self.right)\n\n            # move current page until edge hits the right border\n            if p >= 1:\n                b_right = half_border if p > 1 else border\n                b_left = half_border if p < len(self.children) - 1 else border\n                self.children[-p - 1].x = max(min(\n                    self.x + b_left + (touch.x - touch.ox),\n                    self.right - b_right),\n                    self.x + b_left)\n\n            # move previous page left edge up to left border\n            if p > 1:\n                self.children[-p].x = min(\n                    self.x + half_border * (touch.sx - touch.osx),\n                    self.x + half_border)\n\n        elif touch.ud['page'] == 'next':\n            # move current page up to left edge\n            if p >= 1:\n                self.children[-p - 1].x = max(\n                    self.x + half_border * (1 - (touch.osx - touch.sx)),\n                    self.x)\n\n            # move next page until its edge hit the left border\n            if p < len(self.children) - 1:\n                b_right = half_border if p >= 1 else border\n                b_left = half_border if p < len(self.children) - 2 else border\n                self.children[-p - 2].x = min(max(\n                    self.right - b_right + (touch.x - touch.ox),\n                    self.x + b_left),\n                    self.right - b_right)\n\n            # move second next page up to right border\n            if p < len(self.children) - 2:\n                self.children[-p - 3].x = max(\n                    self.right + half_border * (touch.sx - touch.osx),\n                    self.right - half_border)\n\n        return page.on_touch_move(touch)",
  "def on_touch_up(self, touch):\n        if touch.grab_current == self:\n            if (\n                touch.ud['page'] == 'previous' and\n                abs(touch.x - touch.ox) / self.width > self.swipe_threshold\n            ):\n                self.page -= 1\n            elif (\n                touch.ud['page'] == 'next' and\n                abs(touch.x - touch.ox) / self.width > self.swipe_threshold\n            ):\n                self.page += 1\n            else:\n                self._trigger_layout()\n\n            touch.ungrab(self)\n\n        if len(self.children) > 1:\n            return self.children[-self.page + 1].on_touch_up(touch)",
  "class Label(Widget):\n    '''Label class, see module documentation for more information.\n\n    :Events:\n        `on_ref_press`\n            Fired when the user clicks on a word referenced with a\n            ``[ref]`` tag in a text markup.\n    '''\n\n    __events__ = ['on_ref_press']\n\n    _font_properties = ('text', 'font_size', 'font_name', 'font_script_name',\n                        'font_direction', 'bold', 'italic',\n                        'underline', 'strikethrough', 'font_family', 'color',\n                        'disabled_color', 'halign', 'valign', 'padding',\n                        'outline_width', 'disabled_outline_color',\n                        'outline_color', 'text_size', 'shorten', 'mipmap',\n                        'line_height', 'max_lines', 'strip', 'shorten_from',\n                        'split_str', 'ellipsis_options', 'unicode_errors',\n                        'markup', 'font_hinting', 'font_kerning',\n                        'font_blended', 'font_context', 'font_features',\n                        'base_direction', 'text_language')\n\n    def __init__(self, **kwargs):\n        self._trigger_texture = Clock.create_trigger(self.texture_update, -1)\n        super(Label, self).__init__(**kwargs)\n\n        # bind all the property for recreating the texture\n        d = Label._font_properties\n        fbind = self.fbind\n        update = self._trigger_texture_update\n\n        # NOTE: Compatibility code due to deprecated properties.\n        fbind('padding_x', update, 'padding_x')\n        fbind('padding_y', update, 'padding_y')\n\n        fbind('disabled', update, 'disabled')\n        for x in d:\n            fbind(x, update, x)\n\n        self._label = None\n        self._create_label()\n\n        # force the texture creation\n        self._trigger_texture()\n\n    def _create_label(self):\n        # create the core label class according to markup value\n        if self._label is not None:\n            cls = self._label.__class__\n        else:\n            cls = None\n        markup = self.markup\n        if (markup and cls is not CoreMarkupLabel) or \\\n           (not markup and cls is not CoreLabel):\n            # markup have change, we need to change our rendering method.\n            dkw = {x: getattr(self, x) for x in self._font_properties}\n            dkw['usersize'] = self.text_size\n            if self.disabled:\n                dkw['color'] = self.disabled_color\n                dkw['outline_color'] = self.disabled_outline_color\n\n            if markup:\n                self._label = CoreMarkupLabel(**dkw)\n            else:\n                self._label = CoreLabel(**dkw)\n\n    def _trigger_texture_update(self, name=None, source=None, value=None):\n        # check if the label core class need to be switch to a new one\n        if name == 'markup':\n            self._create_label()\n        if source:\n            if name == 'text':\n                self._label.text = value\n            elif name == 'text_size':\n                self._label.usersize = value\n            elif name == 'font_size':\n                self._label.options[name] = value\n            elif name == 'disabled_color' and self.disabled:\n                self._label.options['color'] = value\n            elif name == 'disabled_outline_color' and self.disabled:\n                self._label.options['outline_color'] = value\n            elif name == 'disabled':\n                self._label.options['color'] = self.disabled_color if value \\\n                    else self.color\n                self._label.options['outline_color'] = (\n                    self.disabled_outline_color if value else\n                    self.outline_color)\n\n            # NOTE: Compatibility code due to deprecated properties\n            # Must be removed along with padding_x and padding_y\n            elif name == 'padding_x':\n                self._label.options['padding'][::2] = [value] * 2\n            elif name == 'padding_y':\n                self._label.options['padding'][1::2] = [value] * 2\n\n            else:\n                self._label.options[name] = value\n\n        self._trigger_texture()\n\n    def texture_update(self, *largs):\n        '''Force texture recreation with the current Label properties.\n\n        After this function call, the :attr:`texture` and :attr:`texture_size`\n        will be updated in this order.\n        '''\n        mrkup = self._label.__class__ is CoreMarkupLabel\n        self.texture = None\n\n        if (not self._label.text or\n                (self.halign == 'justify' or self.strip) and\n                not self._label.text.strip()):\n            self.texture_size = (0, 0)\n            self.is_shortened = False\n            if mrkup:\n                self.refs, self._label._refs = {}, {}\n                self.anchors, self._label._anchors = {}, {}\n        else:\n            if mrkup:\n                text = self.text\n                # we must strip here, otherwise, if the last line is empty,\n                # markup will retain the last empty line since it only strips\n                # line by line within markup\n                if self.halign == 'justify' or self.strip:\n                    text = text.strip()\n                self._label.text = ''.join(('[color=',\n                                            get_hex_from_color(\n                                                self.disabled_color if\n                                                self.disabled else self.color),\n                                            ']', text, '[/color]'))\n                self._label.refresh()\n                # force the rendering to get the references\n                if self._label.texture:\n                    self._label.texture.bind()\n                self.refs = self._label.refs\n                self.anchors = self._label.anchors\n            else:\n                self._label.refresh()\n            texture = self._label.texture\n            if texture is not None:\n                self.texture = self._label.texture\n                self.texture_size = list(self.texture.size)\n            self.is_shortened = self._label.is_shortened\n\n    def on_touch_down(self, touch):\n        if super(Label, self).on_touch_down(touch):\n            return True\n        if not len(self.refs):\n            return False\n        tx, ty = touch.pos\n        tx -= self.center_x - self.texture_size[0] / 2.\n        ty -= self.center_y - self.texture_size[1] / 2.\n        ty = self.texture_size[1] - ty\n        for uid, zones in self.refs.items():\n            for zone in zones:\n                x, y, w, h = zone\n                if x <= tx <= w and y <= ty <= h:\n                    self.dispatch('on_ref_press', uid)\n                    return True\n        return False\n\n    def on_ref_press(self, ref):\n        pass\n\n    #\n    # Properties\n    #\n\n    disabled_color = ColorProperty([1, 1, 1, .3])\n    '''The color of the text when the widget is disabled, in the (r, g, b, a)\n    format.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`disabled_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [1, 1, 1, .3].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    text = StringProperty('')\n    '''Text of the label.\n\n    Creation of a simple hello world::\n\n        widget = Label(text='Hello world')\n\n    :attr:`text` is a :class:`~kivy.properties.StringProperty` and defaults to\n    ''.\n    '''\n\n    text_size = ListProperty([None, None])\n    '''By default, the label is not constrained to any bounding box.\n    You can set the size constraint of the label with this property.\n    The text will autoflow into the constraints. So although the font size\n    will not be reduced, the text will be arranged to fit into the box as best\n    as possible, with any text still outside the box clipped.\n\n    This sets and clips :attr:`texture_size` to text_size if not None.\n\n    .. versionadded:: 1.0.4\n\n    For example, whatever your current widget size is, if you want the label to\n    be created in a box with width=200 and unlimited height::\n\n        Label(text='Very big big line', text_size=(200, None))\n\n    .. note::\n\n        This text_size property is the same as the\n        :attr:`~kivy.core.text.Label.usersize` property in the\n        :class:`~kivy.core.text.Label` class. (It is named size= in the\n        constructor.)\n\n    :attr:`text_size` is a :class:`~kivy.properties.ListProperty` and\n    defaults to (None, None), meaning no size restriction by default.\n    '''\n\n    base_direction = OptionProperty(None,\n                     options=['ltr', 'rtl', 'weak_rtl', 'weak_ltr', None],\n                     allownone=True)\n    '''Base direction of text, this impacts horizontal alignment when\n    :attr:`halign` is `auto` (the default). Available options are: None,\n    \"ltr\" (left to right), \"rtl\" (right to left) plus \"weak_ltr\" and\n    \"weak_rtl\".\n\n    .. note::\n        This feature requires the Pango text provider.\n\n    .. note::\n        Weak modes are currently not implemented in Kivy text layout, and\n        have the same effect as setting strong mode.\n\n    .. versionadded:: 1.11.0\n\n    :attr:`base_direction` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to None (autodetect RTL if possible, otherwise LTR).\n    '''\n\n    text_language = StringProperty(None, allownone=True)\n    '''Language of the text, if None Pango will determine it from locale.\n    This is an RFC-3066 format language tag (as a string), for example\n    \"en_US\", \"zh_CN\", \"fr\" or \"ja\". This can impact font selection, metrics\n    and rendering. For example, the same bytes of text can look different\n    for `ur` and `ar` languages, though both use Arabic script.\n\n    .. note::\n        This feature requires the Pango text provider.\n\n    .. versionadded:: 1.11.0\n\n    :attr:`text_language` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    font_context = StringProperty(None, allownone=True)\n    '''Font context. `None` means the font is used in isolation, so you are\n    guaranteed to be drawing with the TTF file resolved by :attr:`font_name`.\n    Specifying a value here will load the font file into a named context,\n    enabling fallback between all fonts in the same context. If a font\n    context is set, you are not guaranteed that rendering will actually use\n    the specified TTF file for all glyphs (Pango will pick the one it\n    thinks is best).\n\n    If Kivy is linked against a system-wide installation of FontConfig,\n    you can load the system fonts by specifying a font context starting\n    with the special string `system://`. This will load the system\n    fontconfig configuration, and add your application-specific fonts on\n    top of it (this imposes a significant risk of family name collision,\n    Pango may not use your custom font file, but pick one from the system)\n\n    .. note::\n        This feature requires the Pango text provider.\n\n    .. versionadded:: 1.11.0\n\n    :attr:`font_context` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    font_family = StringProperty(None, allownone=True)\n    '''Font family, this is only applicable when using :attr:`font_context`\n    option. The specified font family will be requested, but note that it may\n    not be available, or there could be multiple fonts registered with the\n    same family. The value can be a family name (string) available in the\n    font context (for example a system font in a `system://` context, or a\n    custom font file added using :class:`kivy.core.text.FontContextManager`).\n    If set to `None`, font selection is controlled by the :attr:`font_name`\n    setting.\n\n    .. note::\n        If using :attr:`font_name` to reference a custom font file, you\n        should leave this as `None`. The family name is managed automatically\n        in this case.\n\n    .. note::\n        This feature requires the Pango text provider.\n\n    .. versionadded:: 1.11.0\n\n    :attr:`font_family` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    font_name = StringProperty(DEFAULT_FONT)\n    '''Filename of the font to use. The path can be absolute or relative.\n    Relative paths are resolved by the :func:`~kivy.resources.resource_find`\n    function.\n\n    .. warning::\n\n        Depending of your text provider, the font file can be ignored. However,\n        you can mostly use this without problems.\n\n        If the font used lacks the glyphs for the particular language/symbols\n        you are using, you will see '[]' blank box characters instead of the\n        actual glyphs. The solution is to use a font that has the glyphs you\n        need to display. For example, to display |unicodechar|, use a font such\n        as freesans.ttf that has the glyph.\n\n        .. |unicodechar| image:: images/unicode-char.png\n\n    :attr:`font_name` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'Roboto'. This value is taken\n    from :class:`~kivy.config.Config`.\n    '''\n\n    font_script_name = OptionProperty('Latn', options=['Zyyy', 'Latn', 'Hani',\n                'Cyrl', 'Hira', 'Kana', 'Thai', 'Arab', 'Hang', 'Deva', 'Grek',\n                'Hebr', 'Taml', 'Knda', 'Geor', 'Mlym', 'Telu', 'Mymr', 'Gujr',\n                'Beng', 'Guru', 'Laoo', 'Zinh', 'Khmr', 'Tibt', 'Sinh', 'Ethi',\n                'Thaa', 'Orya', 'Zzzz', 'Cans', 'Syrc', 'Bopo', 'Nkoo', 'Cher',\n                'Yiii', 'Samr', 'Copt', 'Mong', 'Glag', 'Vaii', 'Bali', 'Tfng',\n                'Bamu', 'Batk', 'Cham', 'Java', 'Kali', 'Lepc', 'Limb', 'Lisu',\n                'Mand', 'Mtei', 'Talu', 'Olck', 'Saur', 'Sund', 'Sylo', 'Tale',\n                'Lana', 'Avst', 'Brah', 'Bugi', 'Buhd', 'Cari', 'Xsux', 'Cprt',\n                'Dsrt', 'Egyp', 'Goth', 'Hano', 'Armi', 'Phli', 'Prti', 'Kthi',\n                'Khar', 'Linb', 'Lyci', 'Lydi', 'Ogam', 'Ital', 'Xpeo', 'Sarb',\n                'Orkh', 'Osma', 'Phag', 'Phnx', 'Rjng', 'Runr', 'Shaw', 'Tglg',\n                'Tagb', 'Ugar', 'Cakm', 'Merc', 'Mero', 'Plrd', 'Shrd', 'Sora',\n                'Takr', 'Brai', 'Aghb', 'Bass', 'Dupl', 'Elba', 'Gran', 'Khoj',\n                'Lina', 'Mahj', 'Mani', 'Modi', 'Mroo', 'Narb', 'Nbat', 'Palm',\n                'Pauc', 'Perm', 'Phlp', 'Sidd', 'Sind', 'Tirh', 'Wara', 'Ahom',\n                'Hluw', 'Hatr', 'Mult', 'Hung', 'Sgnw', 'Adlm', 'Bhks', 'Marc',\n                'Osge', 'Tang', 'Newa', 'Gonm', 'Nshu', 'Soyo', 'Zanb', 'Dogr',\n                'Gong', 'Rohg', 'Maka', 'Medf', 'Sogo', 'Sogd', 'Elym', 'Hmnp',\n                'Nand', 'Wcho', 'Chrs', 'Diak', 'Kits', 'Yezi', 'Cpmn', 'Ougr',\n                'Tnsa', 'Toto', 'Vith', 'Kawi', 'Nagm'])\n    '''`script_code` from https://bit.ly/TypeScriptCodes .\n\n    .. versionadded:: 2.2.0\n\n    .. warning::\n\n        font_script_name is only currently supported in SDL2 ttf providers.\n\n\n    :attr:`font_script_name` is a :class:`~kivy.properties.OptionProperty` and\n    defaults to 'Latn'.\n    '''\n\n    font_direction = OptionProperty('ltr', options=['rtl', 'ltr', 'ttb', 'btt'])\n    '''Direction for the specific font, can be one of `ltr`, `rtl`, `ttb`,`btt`.\n\n    font_direction currently only works with SDL2 ttf providers.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`font_direction` is a :class:`~kivy.properties.OptionProperty` and\n    defults to 'ltr'. '''\n\n    font_size = NumericProperty('15sp')\n    '''Font size of the text, in pixels.\n\n    :attr:`font_size` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 15sp.\n    '''\n\n    font_features = StringProperty()\n    '''OpenType font features, in CSS format, this is passed straight\n    through to Pango. The effects of requesting a feature depends on loaded\n    fonts, library versions, etc. For a complete list of features, see:\n\n    https://en.wikipedia.org/wiki/List_of_typographic_features\n\n    .. note::\n        This feature requires the Pango text provider, and Pango library\n        v1.38 or later.\n\n    .. versionadded:: 1.11.0\n\n    :attr:`font_features` is a :class:`~kivy.properties.StringProperty` and\n    defaults to an empty string.\n    '''\n\n    line_height = NumericProperty(1.0)\n    '''Line Height for the text. e.g. line_height = 2 will cause the spacing\n    between lines to be twice the size.\n\n    :attr:`line_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 1.0.\n\n    .. versionadded:: 1.5.0\n    '''\n\n    bold = BooleanProperty(False)\n    '''Indicates use of the bold version of your font.\n\n    .. note::\n\n        Depending of your font, the bold attribute may have no impact on your\n        text rendering.\n\n    :attr:`bold` is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.\n    '''\n\n    italic = BooleanProperty(False)\n    '''Indicates use of the italic version of your font.\n\n    .. note::\n\n        Depending of your font, the italic attribute may have no impact on your\n        text rendering.\n\n    :attr:`italic` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    underline = BooleanProperty(False)\n    '''Adds an underline to the text.\n\n    .. note::\n        This feature requires the SDL2 text provider.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`underline` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    strikethrough = BooleanProperty(False)\n    '''Adds a strikethrough line to the text.\n\n    .. note::\n        This feature requires the SDL2 text provider.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`strikethrough` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    padding_x = NumericProperty(0, deprecated=True)\n    '''Horizontal padding of the text inside the widget box.\n\n    :attr:`padding_x` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n\n    .. versionchanged:: 1.9.0\n        `padding_x` has been fixed to work as expected.\n        In the past, the text was padded by the negative of its values.\n\n    .. deprecated:: 2.2.0\n        Please use :attr:`padding` instead.\n    '''\n\n    padding_y = NumericProperty(0, deprecated=True)\n    '''Vertical padding of the text inside the widget box.\n\n    :attr:`padding_y` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n\n    .. versionchanged:: 1.9.0\n        `padding_y` has been fixed to work as expected.\n        In the past, the text was padded by the negative of its values.\n\n    .. deprecated:: 2.2.0\n        Please use :attr:`padding` instead.\n    '''\n\n    padding = VariableListProperty([0, 0, 0, 0], lenght=4)\n    '''Padding of the text in the format [padding_left, padding_top,\n    padding_right, padding_bottom]\n\n    ``padding`` also accepts a two argument form [padding_horizontal,\n    padding_vertical] and a one argument form [padding].\n\n    .. versionchanged:: 2.2.0\n        Replaced ReferenceListProperty with VariableListProperty.\n\n    :attr:`padding` is a :class:`~kivy.properties.VariableListProperty` and\n    defaults to [0, 0, 0, 0].\n    '''\n\n    halign = OptionProperty('auto', options=['left', 'center', 'right',\n                            'justify', 'auto'])\n    '''Horizontal alignment of the text.\n\n    :attr:`halign` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'auto'. Available options are : auto, left, center, right and\n    justify. Auto will attempt to autodetect horizontal alignment for RTL text\n    (Pango only), otherwise it behaves like `left`.\n\n    .. warning::\n\n        This doesn't change the position of the text texture of the Label\n        (centered), only the position of the text in this texture. You probably\n        want to bind the size of the Label to the :attr:`texture_size` or set a\n        :attr:`text_size`.\n\n    .. versionchanged:: 1.10.1\n        Added `auto` option\n\n    .. versionchanged:: 1.6.0\n        A new option was added to :attr:`halign`, namely `justify`.\n    '''\n\n    valign = OptionProperty('bottom',\n                            options=['bottom', 'middle', 'center', 'top'])\n    '''Vertical alignment of the text.\n\n    :attr:`valign` is an :class:`~kivy.properties.OptionProperty` and defaults\n    to 'bottom'. Available options are : `'bottom'`,\n    `'middle'` (or `'center'`) and `'top'`.\n\n    .. versionchanged:: 1.10.0\n        The `'center'` option has been added as an alias of `'middle'`.\n\n    .. warning::\n\n        This doesn't change the position of the text texture of the Label\n        (centered), only the position of the text within this texture. You\n        probably want to bind the size of the Label to the :attr:`texture_size`\n        or set a :attr:`text_size` to change this behavior.\n    '''\n\n    color = ColorProperty([1, 1, 1, 1])\n    '''Text color, in the format (r, g, b, a).\n\n    :attr:`color` is a :class:`~kivy.properties.ColorProperty` and defaults to\n    [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    outline_width = NumericProperty(None, allownone=True)\n    '''Width in pixels for the outline around the text. No outline will be\n    rendered if the value is None.\n\n    .. note::\n        This feature requires the SDL2 text provider.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`outline_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to None.\n    '''\n\n    outline_color = ColorProperty([0, 0, 0, 1])\n    '''The color of the text outline, in the (r, g, b) format.\n\n    .. note::\n        This feature requires the SDL2 text provider.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`outline_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [0, 0, 0, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`. Alpha component is ignored\n        and assigning value to it has no effect.\n    '''\n\n    disabled_outline_color = ColorProperty([0, 0, 0, 1])\n    '''The color of the text outline when the widget is disabled, in the\n    (r, g, b) format.\n\n    .. note::\n        This feature requires the SDL2 text provider.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`disabled_outline_color` is a :class:`~kivy.properties.ColorProperty`\n    and defaults to [0, 0, 0].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`. Alpha component is ignored\n        and assigning value to it has no effect.\n    '''\n\n    texture = ObjectProperty(None, allownone=True)\n    '''Texture object of the text.\n    The text is rendered automatically when a property changes. The OpenGL\n    texture created in this operation is stored in this property. You can use\n    this :attr:`texture` for any graphics elements.\n\n    Depending on the texture creation, the value will be a\n    :class:`~kivy.graphics.texture.Texture` or\n    :class:`~kivy.graphics.texture.TextureRegion` object.\n\n    .. warning::\n\n        The :attr:`texture` update is scheduled for the next frame. If you need\n        the texture immediately after changing a property, you have to call\n        the :meth:`texture_update` method before accessing :attr:`texture`::\n\n            l = Label(text='Hello world')\n            # l.texture is good\n            l.font_size = '50sp'\n            # l.texture is not updated yet\n            l.texture_update()\n            # l.texture is good now.\n\n    :attr:`texture` is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    texture_size = ListProperty([0, 0])\n    '''Texture size of the text. The size is determined by the font size and\n    text. If :attr:`text_size` is [None, None], the texture will be the size\n    required to fit the text, otherwise it's clipped to fit :attr:`text_size`.\n\n    When :attr:`text_size` is [None, None], one can bind to texture_size\n    and rescale it proportionally to fit the size of the label in order to\n    make the text fit maximally in the label.\n\n    .. warning::\n\n        The :attr:`texture_size` is set after the :attr:`texture`\n        property. If you listen for changes to :attr:`texture`,\n        :attr:`texture_size` will not be up-to-date in your callback.\n        Bind to :attr:`texture_size` instead.\n    '''\n\n    mipmap = BooleanProperty(False)\n    '''Indicates whether OpenGL mipmapping is applied to the texture or not.\n    Read :ref:`mipmap` for more information.\n\n    .. versionadded:: 1.0.7\n\n    :attr:`mipmap` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    shorten = BooleanProperty(False)\n    '''\n    Indicates whether the label should attempt to shorten its textual contents\n    as much as possible if a :attr:`text_size` is given. Setting this to True\n    without an appropriately set :attr:`text_size` will lead to unexpected\n    results.\n\n    :attr:`shorten_from` and :attr:`split_str` control the direction from\n    which the :attr:`text` is split, as well as where in the :attr:`text` we\n    are allowed to split.\n\n    :attr:`shorten` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    shorten_from = OptionProperty('center', options=['left', 'center',\n                                                     'right'])\n    '''The side from which we should shorten the text from, can be left,\n    right, or center.\n\n    For example, if left, the ellipsis will appear towards the left side and we\n    will display as much text starting from the right as possible. Similar to\n    :attr:`shorten`, this option only applies when :attr:`text_size` [0] is\n    not None, In this case, the string is shortened to fit within the specified\n    width.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`shorten_from` is a :class:`~kivy.properties.OptionProperty` and\n    defaults to `center`.\n    '''\n\n    is_shortened = BooleanProperty(False)\n    '''This property indicates if :attr:`text` was rendered with or without\n    shortening when :attr:`shorten` is True.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`is_shortened` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    split_str = StringProperty('')\n    '''The string used to split the :attr:`text` while shortening the string\n    when :attr:`shorten` is True.\n\n    For example, if it's a space, the string will be broken into words and as\n    many whole words that can fit into a single line will be displayed. If\n    :attr:`split_str` is the empty string, `''`, we split on every character\n    fitting as much text as possible into the line.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`split_str` is a :class:`~kivy.properties.StringProperty` and\n    defaults to `''` (the empty string).\n    '''\n\n    ellipsis_options = DictProperty({})\n    '''Font options for the ellipsis string('...') used to split the text.\n\n    Accepts a dict as option name with the value. Only applied when\n    :attr:`markup` is true and text is shortened. All font options which work\n    for :class:`Label` will work for :attr:`ellipsis_options`. Defaults for\n    the options not specified are taken from the surronding text.\n\n    .. code-block:: kv\n\n        Label:\n            text: 'Some very long line which will be cut'\n            markup: True\n            shorten: True\n            ellipsis_options: {'color':(1,0.5,0.5,1),'underline':True}\n\n    .. versionadded:: 2.0.0\n\n    :attr:`ellipsis_options` is a :class:`~kivy.properties.DictProperty` and\n    defaults to `{}` (the empty dict).\n    '''\n\n    unicode_errors = OptionProperty(\n        'replace', options=('strict', 'replace', 'ignore'))\n    '''How to handle unicode decode errors. Can be `'strict'`, `'replace'` or\n    `'ignore'`.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`unicode_errors` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to `'replace'`.\n    '''\n\n    markup = BooleanProperty(False)\n    '''\n    .. versionadded:: 1.1.0\n\n    If True, the text will be rendered using the\n    :class:`~kivy.core.text.markup.MarkupLabel`: you can change the\n    style of the text using tags. Check the\n    :doc:`api-kivy.core.text.markup` documentation for more information.\n\n    :attr:`markup` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    refs = DictProperty({})\n    '''\n    .. versionadded:: 1.1.0\n\n    List of ``[ref=xxx]`` markup items in the text with the bounding box of\n    all the words contained in a ref, available only after rendering.\n\n    For example, if you wrote::\n\n        Check out my [ref=hello]link[/ref]\n\n    The refs will be set with::\n\n        {'hello': ((64, 0, 78, 16), )}\n\n    The references marked \"hello\" have a bounding box at (x1, y1, x2, y2).\n    These coordinates are relative to the top left corner of the text, with\n    the y value increasing downwards. You can define multiple refs with the\n    same name: each occurrence will be added as another (x1, y1, x2, y2) tuple\n    to this list.\n\n    The current Label implementation uses these references if they exist in\n    your markup text, automatically doing the collision with the touch and\n    dispatching an `on_ref_press` event.\n\n    You can bind a ref event like this::\n\n        def print_it(instance, value):\n            print('User click on', value)\n        widget = Label(text='Hello [ref=world]World[/ref]', markup=True)\n        widget.bind(on_ref_press=print_it)\n\n    .. note::\n\n        This works only with markup text. You need :attr:`markup` set to\n        True.\n    '''\n\n    anchors = DictProperty({})\n    '''\n    .. versionadded:: 1.1.0\n\n    Position of all the ``[anchor=xxx]`` markup in the text.\n    These coordinates are relative to the top left corner of the text, with\n    the y value increasing downwards. Anchors names should be unique and only\n    the first occurrence of any duplicate anchors will be recorded.\n\n\n    You can place anchors in your markup text as follows::\n\n        text = \"\"\"\n            [anchor=title1][size=24]This is my Big title.[/size]\n            [anchor=content]Hello world\n        \"\"\"\n\n    Then, all the ``[anchor=]`` references will be removed and you'll get all\n    the anchor positions in this property (only after rendering)::\n\n        >>> widget = Label(text=text, markup=True)\n        >>> widget.texture_update()\n        >>> widget.anchors\n        {\"content\": (20, 32), \"title1\": (20, 16)}\n\n    .. note::\n\n        This works only with markup text. You need :attr:`markup` set to\n        True.\n\n    '''\n\n    max_lines = NumericProperty(0)\n    '''Maximum number of lines to use, defaults to 0, which means unlimited.\n    Please note that :attr:`shorten` take over this property. (with\n    shorten, the text is always one line.)\n\n    .. versionadded:: 1.8.0\n\n    :attr:`max_lines` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    strip = BooleanProperty(False)\n    '''Whether leading and trailing spaces and newlines should be stripped from\n    each displayed line. If True, every line will start at the right or left\n    edge, depending on :attr:`halign`. If :attr:`halign` is `justify` it is\n    implicitly True.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`strip` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    font_hinting = OptionProperty(\n        'normal', options=[None, 'normal', 'light', 'mono'], allownone=True)\n    '''What hinting option to use for font rendering.\n    Can be one of `'normal'`, `'light'`, `'mono'` or None.\n\n    .. note::\n        This feature requires SDL2 or Pango text provider.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`font_hinting` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to `'normal'`.\n    '''\n\n    font_kerning = BooleanProperty(True)\n    '''Whether kerning is enabled for font rendering. You should normally\n    only disable this if rendering is broken with a particular font file.\n\n    .. note::\n        This feature requires the SDL2 text provider.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`font_kerning` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    font_blended = BooleanProperty(True)\n    '''Whether blended or solid font rendering should be used.\n\n    .. note::\n        This feature requires the SDL2 text provider.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`font_blended` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''",
  "def __init__(self, **kwargs):\n        self._trigger_texture = Clock.create_trigger(self.texture_update, -1)\n        super(Label, self).__init__(**kwargs)\n\n        # bind all the property for recreating the texture\n        d = Label._font_properties\n        fbind = self.fbind\n        update = self._trigger_texture_update\n\n        # NOTE: Compatibility code due to deprecated properties.\n        fbind('padding_x', update, 'padding_x')\n        fbind('padding_y', update, 'padding_y')\n\n        fbind('disabled', update, 'disabled')\n        for x in d:\n            fbind(x, update, x)\n\n        self._label = None\n        self._create_label()\n\n        # force the texture creation\n        self._trigger_texture()",
  "def _create_label(self):\n        # create the core label class according to markup value\n        if self._label is not None:\n            cls = self._label.__class__\n        else:\n            cls = None\n        markup = self.markup\n        if (markup and cls is not CoreMarkupLabel) or \\\n           (not markup and cls is not CoreLabel):\n            # markup have change, we need to change our rendering method.\n            dkw = {x: getattr(self, x) for x in self._font_properties}\n            dkw['usersize'] = self.text_size\n            if self.disabled:\n                dkw['color'] = self.disabled_color\n                dkw['outline_color'] = self.disabled_outline_color\n\n            if markup:\n                self._label = CoreMarkupLabel(**dkw)\n            else:\n                self._label = CoreLabel(**dkw)",
  "def _trigger_texture_update(self, name=None, source=None, value=None):\n        # check if the label core class need to be switch to a new one\n        if name == 'markup':\n            self._create_label()\n        if source:\n            if name == 'text':\n                self._label.text = value\n            elif name == 'text_size':\n                self._label.usersize = value\n            elif name == 'font_size':\n                self._label.options[name] = value\n            elif name == 'disabled_color' and self.disabled:\n                self._label.options['color'] = value\n            elif name == 'disabled_outline_color' and self.disabled:\n                self._label.options['outline_color'] = value\n            elif name == 'disabled':\n                self._label.options['color'] = self.disabled_color if value \\\n                    else self.color\n                self._label.options['outline_color'] = (\n                    self.disabled_outline_color if value else\n                    self.outline_color)\n\n            # NOTE: Compatibility code due to deprecated properties\n            # Must be removed along with padding_x and padding_y\n            elif name == 'padding_x':\n                self._label.options['padding'][::2] = [value] * 2\n            elif name == 'padding_y':\n                self._label.options['padding'][1::2] = [value] * 2\n\n            else:\n                self._label.options[name] = value\n\n        self._trigger_texture()",
  "def texture_update(self, *largs):\n        '''Force texture recreation with the current Label properties.\n\n        After this function call, the :attr:`texture` and :attr:`texture_size`\n        will be updated in this order.\n        '''\n        mrkup = self._label.__class__ is CoreMarkupLabel\n        self.texture = None\n\n        if (not self._label.text or\n                (self.halign == 'justify' or self.strip) and\n                not self._label.text.strip()):\n            self.texture_size = (0, 0)\n            self.is_shortened = False\n            if mrkup:\n                self.refs, self._label._refs = {}, {}\n                self.anchors, self._label._anchors = {}, {}\n        else:\n            if mrkup:\n                text = self.text\n                # we must strip here, otherwise, if the last line is empty,\n                # markup will retain the last empty line since it only strips\n                # line by line within markup\n                if self.halign == 'justify' or self.strip:\n                    text = text.strip()\n                self._label.text = ''.join(('[color=',\n                                            get_hex_from_color(\n                                                self.disabled_color if\n                                                self.disabled else self.color),\n                                            ']', text, '[/color]'))\n                self._label.refresh()\n                # force the rendering to get the references\n                if self._label.texture:\n                    self._label.texture.bind()\n                self.refs = self._label.refs\n                self.anchors = self._label.anchors\n            else:\n                self._label.refresh()\n            texture = self._label.texture\n            if texture is not None:\n                self.texture = self._label.texture\n                self.texture_size = list(self.texture.size)\n            self.is_shortened = self._label.is_shortened",
  "def on_touch_down(self, touch):\n        if super(Label, self).on_touch_down(touch):\n            return True\n        if not len(self.refs):\n            return False\n        tx, ty = touch.pos\n        tx -= self.center_x - self.texture_size[0] / 2.\n        ty -= self.center_y - self.texture_size[1] / 2.\n        ty = self.texture_size[1] - ty\n        for uid, zones in self.refs.items():\n            for zone in zones:\n                x, y, w, h = zone\n                if x <= tx <= w and y <= ty <= h:\n                    self.dispatch('on_ref_press', uid)\n                    return True\n        return False",
  "def on_ref_press(self, ref):\n        pass",
  "class BubbleException(Exception):\n    pass",
  "class BubbleButton(Button):\n    '''A button intended for use in a BubbleContent widget.\n    You can use a \"normal\" button class, but it will not look good unless the\n    background is changed.\n\n    Rather use this BubbleButton widget that is already defined and provides a\n    suitable background for you.\n    '''\n    pass",
  "class BubbleContent(BoxLayout):\n    '''A styled BoxLayout that can be used as the content widget of a Bubble.\n\n    .. versionchanged:: 2.2.0\n    The graphical appearance of :class:`BubbleContent` is now based on it's\n    own properties :attr:`background_image`, :attr:`background_color`,\n    :attr:`border` and :attr:`border_auto_scale`. The parent widget properties\n    are no longer considered. This makes the BubbleContent a standalone themed\n    BoxLayout.\n    '''\n\n    background_color = ColorProperty([1, 1, 1, 1])\n    '''Background color, in the format (r, g, b, a). To use it you have to set\n    :attr:`background_image` first.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`background_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [1, 1, 1, 1].\n    '''\n\n    background_image = StringProperty('atlas://data/images/defaulttheme/bubble')\n    '''Background image of the bubble.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`background_image` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/bubble'.\n    '''\n\n    border = ListProperty([16, 16, 16, 16])\n    '''Border used for :class:`~kivy.graphics.vertex_instructions.BorderImage`\n    graphics instruction. Used with the :attr:`background_image`.\n    It should be used when using custom backgrounds.\n\n    It must be a list of 4 values: (bottom, right, top, left). Read the\n    BorderImage instructions for more information about how to use it.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`border` is a :class:`~kivy.properties.ListProperty` and defaults to\n    (16, 16, 16, 16)\n    '''\n\n    border_auto_scale = OptionProperty(\n        'both_lower',\n        options=[\n            'off', 'both', 'x_only', 'y_only', 'y_full_x_lower',\n            'x_full_y_lower', 'both_lower'\n        ]\n    )\n    '''Specifies the :attr:`kivy.graphics.BorderImage.auto_scale`\n    value on the background BorderImage.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`border_auto_scale` is a\n    :class:`~kivy.properties.OptionProperty` and defaults to\n    'both_lower'.\n    '''",
  "class Bubble(BoxLayout):\n    '''Bubble class. See module documentation for more information.\n    '''\n\n    content = ObjectProperty(allownone=True)\n    '''This is the object where the main content of the bubble is held.\n\n    The content of the Bubble set by 'add_widget' and removed with\n    'remove_widget' similarly to the :class:`ActionView` which is placed into\n    a class:`ActionBar`\n\n    :attr:`content` is a :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    arrow_image = StringProperty(\n        'atlas://data/images/defaulttheme/bubble_arrow'\n    )\n    ''' Image of the arrow pointing to the bubble.\n\n    :attr:`arrow_image` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/bubble_arrow'.\n    '''\n\n    arrow_color = ColorProperty([1, 1, 1, 1])\n    '''Arrow color, in the format (r, g, b, a). To use it you have to set\n    :attr:`arrow_image` first.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`arrow_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [1, 1, 1, 1].\n    '''\n\n    show_arrow = BooleanProperty(True)\n    ''' Indicates whether to show arrow.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`show_arrow` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to `True`.\n    '''\n\n    arrow_pos = OptionProperty(\n        'bottom_mid',\n        options=(\n            'left_top', 'left_mid', 'left_bottom',\n            'top_left', 'top_mid', 'top_right',\n            'right_top', 'right_mid', 'right_bottom',\n            'bottom_left', 'bottom_mid', 'bottom_right',\n        )\n    )\n    '''Specifies the position of the arrow as predefined relative position to\n    the bubble.\n    Can be one of: left_top, left_mid, left_bottom top_left, top_mid, top_right\n    right_top, right_mid, right_bottom bottom_left, bottom_mid, bottom_right.\n\n    :attr:`arrow_pos` is a :class:`~kivy.properties.OptionProperty` and\n    defaults to 'bottom_mid'.\n    '''\n\n    flex_arrow_pos = ListProperty(None)\n    '''Specifies the position of the arrow as flex coordinate around the\n    border of the :class:`Bubble` Widget.\n    If this property is set to a proper position (relative pixel coordinates\n    within the :class:`Bubble` widget, it overwrites the setting\n    :attr:`arrow_pos`.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`flex_arrow_pos` is a :class:`~kivy.properties.ListProperty` and\n    defaults to None.\n    '''\n\n    limit_to = ObjectProperty(None, allownone=True)\n    '''Specifies the widget to which the bubbles position is restricted.\n\n    .. versionadded:: 1.6.0\n\n    :attr:`limit_to` is a :class:`~kivy.properties.ObjectProperty` and defaults\n    to 'None'.\n    '''\n\n    arrow_margin_x = NumericProperty(0)\n    '''Automatically computed margin in x direction that the arrow widget\n    occupies in pixel.\n\n    In combination with the :attr:`content_width`, this property can be used\n    to determine the correct width of the Bubble to exactly enclose the\n    arrow + content by adding :attr:`content_width` and :attr:`arrow_margin_x`\n\n    .. versionadded:: 2.2.0\n\n    :attr:`arrow_margin_x` is a :class:`~kivy.properties.NumericProperty` and\n    represents the added margin in x direction due to the arrow widget.\n    It defaults to 0 and is read only.\n    '''\n\n    arrow_margin_y = NumericProperty(0)\n    '''Automatically computed margin in y direction that the arrow widget\n    occupies in pixel.\n\n    In combination with the :attr:`content_height`, this property can be used\n    to determine the correct height of the Bubble to exactly enclose the\n    arrow + content by adding :attr:`content_height` and :attr:`arrow_margin_y`\n\n    .. versionadded:: 2.2.0\n\n    :attr:`arrow_margin_y` is a :class:`~kivy.properties.NumericProperty` and\n    represents the added margin in y direction due to the arrow widget.\n    It defaults to 0 and is read only.\n    '''\n\n    arrow_margin = ReferenceListProperty(arrow_margin_x, arrow_margin_y)\n    '''Automatically computed margin that the arrow widget occupies in\n    x and y direction in pixel.\n\n    Check the description of :attr:`arrow_margin_x` and :attr:`arrow_margin_y`.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`arrow_margin` is a :class:`~kivy.properties.ReferenceListProperty`\n    of (:attr:`arrow_margin_x`, :attr:`arrow_margin_y`) properties.\n    It is read only.\n    '''\n\n    content_width = NumericProperty(0)\n    '''The width of the content Widget.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`content_width` is a :class:`~kivy.properties.NumericProperty` and\n    is the same as self.content.width if content is not None, else it defaults\n    to 0. It is read only.\n    '''\n\n    content_height = NumericProperty(0)\n    '''The height of the content Widget.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`content_height` is a :class:`~kivy.properties.NumericProperty` and\n    is the same as self.content.height if content is not None, else it defaults\n    to 0. It is read only.\n    '''\n\n    content_size = ReferenceListProperty(content_width, content_height)\n    ''' The size of the content Widget.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`content_size` is a :class:`~kivy.properties.ReferenceListProperty`\n    of (:attr:`content_width`, :attr:`content_height`) properties.\n    It is read only.\n    '''\n\n    # Internal map that specifies the different parameters for fixed arrow\n    # position layouts. The flex_arrow_pos uses these parameter sets\n    # as a template.\n    # 0: orientation of the children of Bubble ([content, arrow])\n    # 1: order of widgets to add to the BoxLayout (default: [content, arrow])\n    # 2: size_hint of _arrow_image_layout\n    # 3: rotation of the _arrow_image\n    # 4: pos_hint of the _arrow_image_layout\n    ARROW_LAYOUTS = {\n        \"bottom_left\":  (   \"vertical\",  1, (   1, None),   0, {   \"top\": 1.0,        \"x\": 0.05}),  # noqa: E201,E241,E501\n        \"bottom_mid\":   (   \"vertical\",  1, (   1, None),   0, {   \"top\": 1.0, \"center_x\": 0.50}),  # noqa: E201,E241,E501\n        \"bottom_right\": (   \"vertical\",  1, (   1, None),   0, {   \"top\": 1.0,    \"right\": 0.95}),  # noqa: E201,E241,E501\n        \"right_bottom\": ( \"horizontal\",  1, (None,    1),  90, {  \"left\": 0.0,        \"y\": 0.05}),  # noqa: E201,E241,E501\n        \"right_mid\":    ( \"horizontal\",  1, (None,    1),  90, {  \"left\": 0.0, \"center_y\": 0.50}),  # noqa: E201,E241,E501\n        \"right_top\":    ( \"horizontal\",  1, (None,    1),  90, {  \"left\": 0.0,      \"top\": 0.95}),  # noqa: E201,E241,E501\n        \"top_left\":     (   \"vertical\", -1, (   1, None), 180, {\"bottom\": 0.0,        \"x\": 0.05}),  # noqa: E201,E241,E501\n        \"top_mid\":      (   \"vertical\", -1, (   1, None), 180, {\"bottom\": 0.0, \"center_x\": 0.50}),  # noqa: E201,E241,E501\n        \"top_right\":    (   \"vertical\", -1, (   1, None), 180, {\"bottom\": 0.0,    \"right\": 0.95}),  # noqa: E201,E241,E501\n        \"left_bottom\":  ( \"horizontal\", -1, (None,    1), -90, {\"right\":  1.0,        \"y\": 0.05}),  # noqa: E201,E241,E501\n        \"left_mid\":     ( \"horizontal\", -1, (None,    1), -90, {\"right\":  1.0, \"center_y\": 0.50}),  # noqa: E201,E241,E501\n        \"left_top\":     ( \"horizontal\", -1, (None,    1), -90, {\"right\":  1.0,      \"top\": 0.95}),  # noqa: E201,E241,E501\n    }\n\n    def __init__(self, **kwargs):\n        self.content = None\n\n        self._flex_arrow_layout_params = None\n        self._temporarily_ignore_limits = False\n\n        self._arrow_image = Image(\n            source=self.arrow_image,\n            fit_mode=\"scale-down\",\n            color=self.arrow_color\n        )\n        self._arrow_image.width = self._arrow_image.texture_size[0]\n        self._arrow_image.height = dp(self._arrow_image.texture_size[1])\n        self._arrow_image_scatter = Scatter(\n            size_hint=(None, None),\n            do_scale=False,\n            do_rotation=False,\n            do_translation=False,\n        )\n        self._arrow_image_scatter.add_widget(self._arrow_image)\n        self._arrow_image_scatter.size = self._arrow_image.texture_size\n        self._arrow_image_scatter_wrapper = BoxLayout(\n            size_hint=(None, None),\n        )\n        self._arrow_image_scatter_wrapper.add_widget(self._arrow_image_scatter)\n        self._arrow_image_layout = RelativeLayout()\n        self._arrow_image_layout.add_widget(self._arrow_image_scatter_wrapper)\n\n        self._arrow_layout = None\n\n        super().__init__(**kwargs)\n        self.reposition_inner_widgets()\n\n    def add_widget(self, widget, *args, **kwargs):\n        if self.content is None:\n            self.content = widget\n            self.content_size = widget.size\n            self.content.bind(size=self.update_content_size)\n            self.reposition_inner_widgets()\n        else:\n            raise BubbleException(\n                \"Bubble can only contain a single Widget or Layout\"\n            )\n\n    def remove_widget(self, widget, *args, **kwargs):\n        if widget == self.content:\n            self.content.unbind(size=self.update_content_size)\n            self.content = None\n            self.content_size = [0, 0]\n            self.reposition_inner_widgets()\n            return\n        super().remove_widget(widget, *args, **kwargs)\n\n    def on_content_size(self, instance, value):\n        self.adjust_position()\n\n    def on_limit_to(self, instance, value):\n        self.adjust_position()\n\n    def on_pos(self, instance, value):\n        self.adjust_position()\n\n    def on_size(self, instance, value):\n        self.reposition_inner_widgets()\n\n    def on_arrow_image(self, instance, value):\n        self._arrow_image.source = self.arrow_image\n        self._arrow_image.width = self._arrow_image.texture_size[0]\n        self._arrow_image.height = dp(self._arrow_image.texture_size[1])\n        self._arrow_image_scatter.size = self._arrow_image.texture_size\n        self.reposition_inner_widgets()\n\n    def on_arrow_color(self, instance, value):\n        self._arrow_image.color = self.arrow_color\n\n    def on_arrow_pos(self, instance, value):\n        self.reposition_inner_widgets()\n\n    def on_flex_arrow_pos(self, instance, value):\n        self._flex_arrow_layout_params = self.get_flex_arrow_layout_params()\n        self.reposition_inner_widgets()\n\n    def get_flex_arrow_layout_params(self):\n        pos = self.flex_arrow_pos\n\n        if pos is None:\n            return None\n\n        x, y = pos\n        if not (0 <= x <= self.width and 0 <= y <= self.height):\n            return None\n\n        # the order of the following list defines the side that the arrow\n        # will be attached to in case of ambiguity (same distances)\n        base_layouts_map = [\n            (\"bottom_mid\", y),\n            (\"top_mid\", self.height - y),\n            (\"left_mid\", x),\n            (\"right_mid\", self.width - x),\n        ]\n        base_layout_key = min(base_layouts_map, key=lambda val: val[1])[0]\n        arrow_layout = list(Bubble.ARROW_LAYOUTS[base_layout_key])\n\n        arrow_width = self._arrow_image.width\n\n        # This function calculates the proper value for pos_hint, i.e., the\n        # arrow texture does not 'overflow' and stays entirely connected to\n        # the side of the content.\n        def calc_x0(x, length):\n            return x * (length - arrow_width) / (length * length)\n\n        if base_layout_key == \"bottom_mid\":\n            arrow_layout[-1] = {\"top\": 1.0, \"x\": calc_x0(x, self.width)}\n        elif base_layout_key == \"top_mid\":\n            arrow_layout[-1] = {\"bottom\": 0.0, \"x\": calc_x0(x, self.width)}\n        elif base_layout_key == \"left_mid\":\n            arrow_layout[-1] = {\"right\": 1.0, \"y\": calc_x0(y, self.height)}\n        elif base_layout_key == \"right_mid\":\n            arrow_layout[-1] = {\"left\": 0.0, \"y\": calc_x0(y, self.height)}\n        return arrow_layout\n\n    def update_content_size(self, instance, value):\n        self.content_size = self.content.size\n\n    def adjust_position(self):\n        if self.limit_to is not None and not self._temporarily_ignore_limits:\n            if self.limit_to is EventLoop.window:\n                lim_x, lim_y = 0, 0\n                lim_top, lim_right = self.limit_to.size\n            else:\n                lim_x = self.limit_to.x\n                lim_y = self.limit_to.y\n                lim_top = self.limit_to.top\n                lim_right = self.limit_to.right\n\n            self._temporarily_ignore_limits = True\n\n            if not (lim_x > self.x and lim_right < self.right):\n                self.x = max(lim_x, min(lim_right - self.width, self.x))\n\n            if not (lim_y > self.y and lim_right < self.right):\n                self.y = min(lim_top - self.height, max(lim_y, self.y))\n\n            self._temporarily_ignore_limits = False\n\n    def reposition_inner_widgets(self):\n        arrow_image_layout = self._arrow_image_layout\n        arrow_image_scatter = self._arrow_image_scatter\n        arrow_image_scatter_wrapper = self._arrow_image_scatter_wrapper\n        content = self.content\n\n        # Remove the children of the Bubble (BoxLayout) as a first step\n        for child in list(self.children):\n            super().remove_widget(child)\n\n        if self.canvas is None or content is None:\n            return\n\n        # find the layout parameters that define a specific bubble setup\n        if self._flex_arrow_layout_params is not None:\n            layout_params = self._flex_arrow_layout_params\n        else:\n            layout_params = Bubble.ARROW_LAYOUTS[self.arrow_pos]\n        (bubble_orientation,\n         widget_order,\n         arrow_size_hint,\n         arrow_rotation,\n         arrow_pos_hint) = layout_params\n\n        # rotate the arrow, place it at the right pos and setup the size\n        # of the widget, so the BoxLayout can do the rest.\n        arrow_image_scatter.rotation = arrow_rotation\n        arrow_image_scatter_wrapper.size = arrow_image_scatter.bbox[1]\n        arrow_image_scatter_wrapper.pos_hint = arrow_pos_hint\n        arrow_image_layout.size_hint = arrow_size_hint\n        arrow_image_layout.size = arrow_image_scatter.bbox[1]\n\n        # set the orientation of the Bubble (BoxLayout)\n        self.orientation = bubble_orientation\n\n        # Add the updated children of the Bubble (BoxLayout) and update\n        # properties\n        widgets_to_add = [content, arrow_image_layout]\n\n        # Set the arrow_margin, so we can use this property for proper sizing\n        # of the Bubble Widget.\n        # Determine whether to add the arrow_image_layout to the\n        # Bubble (BoxLayout) or not.\n        arrow_margin_x, arrow_margin_y = (0, 0)\n        if self.show_arrow:\n            if bubble_orientation[0] == \"h\":\n                arrow_margin_x = arrow_image_layout.width\n            elif bubble_orientation[0] == \"v\":\n                arrow_margin_y = arrow_image_layout.height\n        else:\n            widgets_to_add.pop(1)\n\n        for widget in widgets_to_add[::widget_order]:\n            super().add_widget(widget)\n\n        self.arrow_margin = (arrow_margin_x, arrow_margin_y)",
  "def __init__(self, **kwargs):\n        self.content = None\n\n        self._flex_arrow_layout_params = None\n        self._temporarily_ignore_limits = False\n\n        self._arrow_image = Image(\n            source=self.arrow_image,\n            fit_mode=\"scale-down\",\n            color=self.arrow_color\n        )\n        self._arrow_image.width = self._arrow_image.texture_size[0]\n        self._arrow_image.height = dp(self._arrow_image.texture_size[1])\n        self._arrow_image_scatter = Scatter(\n            size_hint=(None, None),\n            do_scale=False,\n            do_rotation=False,\n            do_translation=False,\n        )\n        self._arrow_image_scatter.add_widget(self._arrow_image)\n        self._arrow_image_scatter.size = self._arrow_image.texture_size\n        self._arrow_image_scatter_wrapper = BoxLayout(\n            size_hint=(None, None),\n        )\n        self._arrow_image_scatter_wrapper.add_widget(self._arrow_image_scatter)\n        self._arrow_image_layout = RelativeLayout()\n        self._arrow_image_layout.add_widget(self._arrow_image_scatter_wrapper)\n\n        self._arrow_layout = None\n\n        super().__init__(**kwargs)\n        self.reposition_inner_widgets()",
  "def add_widget(self, widget, *args, **kwargs):\n        if self.content is None:\n            self.content = widget\n            self.content_size = widget.size\n            self.content.bind(size=self.update_content_size)\n            self.reposition_inner_widgets()\n        else:\n            raise BubbleException(\n                \"Bubble can only contain a single Widget or Layout\"\n            )",
  "def remove_widget(self, widget, *args, **kwargs):\n        if widget == self.content:\n            self.content.unbind(size=self.update_content_size)\n            self.content = None\n            self.content_size = [0, 0]\n            self.reposition_inner_widgets()\n            return\n        super().remove_widget(widget, *args, **kwargs)",
  "def on_content_size(self, instance, value):\n        self.adjust_position()",
  "def on_limit_to(self, instance, value):\n        self.adjust_position()",
  "def on_pos(self, instance, value):\n        self.adjust_position()",
  "def on_size(self, instance, value):\n        self.reposition_inner_widgets()",
  "def on_arrow_image(self, instance, value):\n        self._arrow_image.source = self.arrow_image\n        self._arrow_image.width = self._arrow_image.texture_size[0]\n        self._arrow_image.height = dp(self._arrow_image.texture_size[1])\n        self._arrow_image_scatter.size = self._arrow_image.texture_size\n        self.reposition_inner_widgets()",
  "def on_arrow_color(self, instance, value):\n        self._arrow_image.color = self.arrow_color",
  "def on_arrow_pos(self, instance, value):\n        self.reposition_inner_widgets()",
  "def on_flex_arrow_pos(self, instance, value):\n        self._flex_arrow_layout_params = self.get_flex_arrow_layout_params()\n        self.reposition_inner_widgets()",
  "def get_flex_arrow_layout_params(self):\n        pos = self.flex_arrow_pos\n\n        if pos is None:\n            return None\n\n        x, y = pos\n        if not (0 <= x <= self.width and 0 <= y <= self.height):\n            return None\n\n        # the order of the following list defines the side that the arrow\n        # will be attached to in case of ambiguity (same distances)\n        base_layouts_map = [\n            (\"bottom_mid\", y),\n            (\"top_mid\", self.height - y),\n            (\"left_mid\", x),\n            (\"right_mid\", self.width - x),\n        ]\n        base_layout_key = min(base_layouts_map, key=lambda val: val[1])[0]\n        arrow_layout = list(Bubble.ARROW_LAYOUTS[base_layout_key])\n\n        arrow_width = self._arrow_image.width\n\n        # This function calculates the proper value for pos_hint, i.e., the\n        # arrow texture does not 'overflow' and stays entirely connected to\n        # the side of the content.\n        def calc_x0(x, length):\n            return x * (length - arrow_width) / (length * length)\n\n        if base_layout_key == \"bottom_mid\":\n            arrow_layout[-1] = {\"top\": 1.0, \"x\": calc_x0(x, self.width)}\n        elif base_layout_key == \"top_mid\":\n            arrow_layout[-1] = {\"bottom\": 0.0, \"x\": calc_x0(x, self.width)}\n        elif base_layout_key == \"left_mid\":\n            arrow_layout[-1] = {\"right\": 1.0, \"y\": calc_x0(y, self.height)}\n        elif base_layout_key == \"right_mid\":\n            arrow_layout[-1] = {\"left\": 0.0, \"y\": calc_x0(y, self.height)}\n        return arrow_layout",
  "def update_content_size(self, instance, value):\n        self.content_size = self.content.size",
  "def adjust_position(self):\n        if self.limit_to is not None and not self._temporarily_ignore_limits:\n            if self.limit_to is EventLoop.window:\n                lim_x, lim_y = 0, 0\n                lim_top, lim_right = self.limit_to.size\n            else:\n                lim_x = self.limit_to.x\n                lim_y = self.limit_to.y\n                lim_top = self.limit_to.top\n                lim_right = self.limit_to.right\n\n            self._temporarily_ignore_limits = True\n\n            if not (lim_x > self.x and lim_right < self.right):\n                self.x = max(lim_x, min(lim_right - self.width, self.x))\n\n            if not (lim_y > self.y and lim_right < self.right):\n                self.y = min(lim_top - self.height, max(lim_y, self.y))\n\n            self._temporarily_ignore_limits = False",
  "def reposition_inner_widgets(self):\n        arrow_image_layout = self._arrow_image_layout\n        arrow_image_scatter = self._arrow_image_scatter\n        arrow_image_scatter_wrapper = self._arrow_image_scatter_wrapper\n        content = self.content\n\n        # Remove the children of the Bubble (BoxLayout) as a first step\n        for child in list(self.children):\n            super().remove_widget(child)\n\n        if self.canvas is None or content is None:\n            return\n\n        # find the layout parameters that define a specific bubble setup\n        if self._flex_arrow_layout_params is not None:\n            layout_params = self._flex_arrow_layout_params\n        else:\n            layout_params = Bubble.ARROW_LAYOUTS[self.arrow_pos]\n        (bubble_orientation,\n         widget_order,\n         arrow_size_hint,\n         arrow_rotation,\n         arrow_pos_hint) = layout_params\n\n        # rotate the arrow, place it at the right pos and setup the size\n        # of the widget, so the BoxLayout can do the rest.\n        arrow_image_scatter.rotation = arrow_rotation\n        arrow_image_scatter_wrapper.size = arrow_image_scatter.bbox[1]\n        arrow_image_scatter_wrapper.pos_hint = arrow_pos_hint\n        arrow_image_layout.size_hint = arrow_size_hint\n        arrow_image_layout.size = arrow_image_scatter.bbox[1]\n\n        # set the orientation of the Bubble (BoxLayout)\n        self.orientation = bubble_orientation\n\n        # Add the updated children of the Bubble (BoxLayout) and update\n        # properties\n        widgets_to_add = [content, arrow_image_layout]\n\n        # Set the arrow_margin, so we can use this property for proper sizing\n        # of the Bubble Widget.\n        # Determine whether to add the arrow_image_layout to the\n        # Bubble (BoxLayout) or not.\n        arrow_margin_x, arrow_margin_y = (0, 0)\n        if self.show_arrow:\n            if bubble_orientation[0] == \"h\":\n                arrow_margin_x = arrow_image_layout.width\n            elif bubble_orientation[0] == \"v\":\n                arrow_margin_y = arrow_image_layout.height\n        else:\n            widgets_to_add.pop(1)\n\n        for widget in widgets_to_add[::widget_order]:\n            super().add_widget(widget)\n\n        self.arrow_margin = (arrow_margin_x, arrow_margin_y)",
  "def calc_x0(x, length):\n            return x * (length - arrow_width) / (length * length)",
  "def sandbox(f):\n    @wraps(f)\n    def _f2(self, *args, **kwargs):\n        ret = None\n        with self:\n            ret = f(self, *args, **kwargs)\n        return ret\n    return _f2",
  "class SandboxExceptionManager(ExceptionManagerBase):\n\n    def __init__(self, sandbox):\n        ExceptionManagerBase.__init__(self)\n        self.sandbox = sandbox\n\n    def handle_exception(self, e):\n        if not self.sandbox.on_exception(e):\n            return ExceptionManagerBase.RAISE\n        return ExceptionManagerBase.PASS",
  "class SandboxContent(RelativeLayout):\n    pass",
  "class Sandbox(FloatLayout):\n    '''Sandbox widget, used to trap all the exceptions raised by child\n    widgets.\n    '''\n\n    def __init__(self, **kwargs):\n        self._context = Context(init=True)\n        self._context['ExceptionManager'] = SandboxExceptionManager(self)\n        self._context.sandbox = self\n        self._context.push()\n        self.on_context_created()\n        self._container = None\n        super(Sandbox, self).__init__(**kwargs)\n        self._container = SandboxContent(size=self.size, pos=self.pos)\n        super(Sandbox, self).add_widget(self._container)\n        self._context.pop()\n\n        # force SandboxClock's scheduling\n        Clock.schedule_interval(self._clock_sandbox, 0)\n        Clock.schedule_once(self._clock_sandbox_draw, -1)\n        self.main_clock = object.__getattribute__(Clock, '_obj')\n\n    def __enter__(self):\n        self._context.push()\n\n    def __exit__(self, _type, value, traceback):\n        self._context.pop()\n        if _type is not None:\n            return self.on_exception(value, _traceback=traceback)\n\n    def on_context_created(self):\n        '''Override this method in order to load your kv file or do anything\n        else with the newly created context.\n        '''\n        pass\n\n    def on_exception(self, exception, _traceback=None):\n        '''Override this method in order to catch all the exceptions from\n        children.\n\n        If you return True, it will not reraise the exception.\n        If you return False, the exception will be raised to the parent.\n        '''\n        import traceback\n        traceback.print_tb(_traceback)\n        return True\n\n    on_motion = sandbox(Widget.on_motion)\n    on_touch_down = sandbox(Widget.on_touch_down)\n    on_touch_move = sandbox(Widget.on_touch_move)\n    on_touch_up = sandbox(Widget.on_touch_up)\n\n    @sandbox\n    def add_widget(self, *args, **kwargs):\n        self._container.add_widget(*args, **kwargs)\n\n    @sandbox\n    def remove_widget(self, *args, **kwargs):\n        self._container.remove_widget(*args, **kwargs)\n\n    @sandbox\n    def clear_widgets(self, *args, **kwargs):\n        self._container.clear_widgets(*args, **kwargs)\n\n    @sandbox\n    def on_size(self, *args):\n        if self._container:\n            self._container.size = self.size\n\n    @sandbox\n    def on_pos(self, *args):\n        if self._container:\n            self._container.pos = self.pos\n\n    @sandbox\n    def _clock_sandbox(self, dt):\n        # import pdb; pdb.set_trace()\n        Clock.tick()\n        Builder.sync()\n\n    @sandbox\n    def _clock_sandbox_draw(self, dt):\n        Clock.tick_draw()\n        Builder.sync()\n        self.main_clock.schedule_once(self._call_draw, 0)\n\n    def _call_draw(self, dt):\n        self.main_clock.schedule_once(self._clock_sandbox_draw, -1)",
  "def _f2(self, *args, **kwargs):\n        ret = None\n        with self:\n            ret = f(self, *args, **kwargs)\n        return ret",
  "def __init__(self, sandbox):\n        ExceptionManagerBase.__init__(self)\n        self.sandbox = sandbox",
  "def handle_exception(self, e):\n        if not self.sandbox.on_exception(e):\n            return ExceptionManagerBase.RAISE\n        return ExceptionManagerBase.PASS",
  "def __init__(self, **kwargs):\n        self._context = Context(init=True)\n        self._context['ExceptionManager'] = SandboxExceptionManager(self)\n        self._context.sandbox = self\n        self._context.push()\n        self.on_context_created()\n        self._container = None\n        super(Sandbox, self).__init__(**kwargs)\n        self._container = SandboxContent(size=self.size, pos=self.pos)\n        super(Sandbox, self).add_widget(self._container)\n        self._context.pop()\n\n        # force SandboxClock's scheduling\n        Clock.schedule_interval(self._clock_sandbox, 0)\n        Clock.schedule_once(self._clock_sandbox_draw, -1)\n        self.main_clock = object.__getattribute__(Clock, '_obj')",
  "def __enter__(self):\n        self._context.push()",
  "def __exit__(self, _type, value, traceback):\n        self._context.pop()\n        if _type is not None:\n            return self.on_exception(value, _traceback=traceback)",
  "def on_context_created(self):\n        '''Override this method in order to load your kv file or do anything\n        else with the newly created context.\n        '''\n        pass",
  "def on_exception(self, exception, _traceback=None):\n        '''Override this method in order to catch all the exceptions from\n        children.\n\n        If you return True, it will not reraise the exception.\n        If you return False, the exception will be raised to the parent.\n        '''\n        import traceback\n        traceback.print_tb(_traceback)\n        return True",
  "def add_widget(self, *args, **kwargs):\n        self._container.add_widget(*args, **kwargs)",
  "def remove_widget(self, *args, **kwargs):\n        self._container.remove_widget(*args, **kwargs)",
  "def clear_widgets(self, *args, **kwargs):\n        self._container.clear_widgets(*args, **kwargs)",
  "def on_size(self, *args):\n        if self._container:\n            self._container.size = self.size",
  "def on_pos(self, *args):\n        if self._container:\n            self._container.pos = self.pos",
  "def _clock_sandbox(self, dt):\n        # import pdb; pdb.set_trace()\n        Clock.tick()\n        Builder.sync()",
  "def _clock_sandbox_draw(self, dt):\n        Clock.tick_draw()\n        Builder.sync()\n        self.main_clock.schedule_once(self._call_draw, 0)",
  "def _call_draw(self, dt):\n        self.main_clock.schedule_once(self._clock_sandbox_draw, -1)",
  "class TestButton(Button):\n\n        def on_touch_up(self, touch):\n            # raise Exception('fdfdfdfdfdfdfd')\n            return super(TestButton, self).on_touch_up(touch)\n\n        def on_touch_down(self, touch):\n            # raise Exception('')\n            return super(TestButton, self).on_touch_down(touch)",
  "def on_touch_up(self, touch):\n            # raise Exception('fdfdfdfdfdfdfd')\n            return super(TestButton, self).on_touch_up(touch)",
  "def on_touch_down(self, touch):\n            # raise Exception('')\n            return super(TestButton, self).on_touch_down(touch)",
  "def _compute_size(c, available_size, idx):\n    sh_min = c.size_hint_min[idx]\n    sh_max = c.size_hint_max[idx]\n    val = c.size_hint[idx] * available_size\n\n    if sh_min is not None:\n        if sh_max is not None:\n            return max(min(sh_max, val), sh_min)\n        return max(val, sh_min)\n    if sh_max is not None:\n        return min(sh_max, val)\n    return val",
  "class StackLayout(Layout):\n    '''Stack layout class. See module documentation for more information.\n    '''\n\n    spacing = VariableListProperty([0, 0], length=2)\n    '''Spacing between children: [spacing_horizontal, spacing_vertical].\n\n    spacing also accepts a single argument form [spacing].\n\n    :attr:`spacing` is a\n    :class:`~kivy.properties.VariableListProperty` and defaults to [0, 0].\n\n    '''\n\n    padding = VariableListProperty([0, 0, 0, 0])\n    '''Padding between the layout box and it's children: [padding_left,\n    padding_top, padding_right, padding_bottom].\n\n    padding also accepts a two argument form [padding_horizontal,\n    padding_vertical] and a single argument form [padding].\n\n    .. versionchanged:: 1.7.0\n        Replaced the NumericProperty with a VariableListProperty.\n\n    :attr:`padding` is a\n    :class:`~kivy.properties.VariableListProperty` and defaults to\n    [0, 0, 0, 0].\n\n    '''\n\n    orientation = OptionProperty('lr-tb', options=(\n        'lr-tb', 'tb-lr', 'rl-tb', 'tb-rl', 'lr-bt', 'bt-lr', 'rl-bt',\n        'bt-rl'))\n    '''Orientation of the layout.\n\n    :attr:`orientation` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'lr-tb'.\n\n    Valid orientations are 'lr-tb', 'tb-lr', 'rl-tb', 'tb-rl', 'lr-bt',\n    'bt-lr', 'rl-bt' and 'bt-rl'.\n\n    .. versionchanged:: 1.5.0\n        :attr:`orientation` now correctly handles all valid combinations of\n        'lr','rl','tb','bt'. Before this version only 'lr-tb' and\n        'tb-lr' were supported, and 'tb-lr' was misnamed and placed\n        widgets from bottom to top and from right to left (reversed compared\n        to what was expected).\n\n    .. note::\n\n        'lr' means Left to Right.\n        'rl' means Right to Left.\n        'tb' means Top to Bottom.\n        'bt' means Bottom to Top.\n    '''\n\n    minimum_width = NumericProperty(0)\n    '''Minimum width needed to contain all children. It is automatically set\n    by the layout.\n\n    .. versionadded:: 1.0.8\n\n    :attr:`minimum_width` is a :class:`kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    minimum_height = NumericProperty(0)\n    '''Minimum height needed to contain all children. It is automatically set\n    by the layout.\n\n    .. versionadded:: 1.0.8\n\n    :attr:`minimum_height` is a :class:`kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    minimum_size = ReferenceListProperty(minimum_width, minimum_height)\n    '''Minimum size needed to contain all children. It is automatically set\n    by the layout.\n\n    .. versionadded:: 1.0.8\n\n    :attr:`minimum_size` is a\n    :class:`~kivy.properties.ReferenceListProperty` of\n    (:attr:`minimum_width`, :attr:`minimum_height`) properties.\n    '''\n\n    def __init__(self, **kwargs):\n        super(StackLayout, self).__init__(**kwargs)\n        trigger = self._trigger_layout\n        fbind = self.fbind\n        fbind('padding', trigger)\n        fbind('spacing', trigger)\n        fbind('children', trigger)\n        fbind('orientation', trigger)\n        fbind('size', trigger)\n        fbind('pos', trigger)\n\n    def do_layout(self, *largs):\n        if not self.children:\n            self.minimum_size = (0., 0.)\n            return\n\n        # optimize layout by preventing looking at the same attribute in a loop\n        selfpos = self.pos\n        selfsize = self.size\n        orientation = self.orientation.split('-')\n        padding_left = self.padding[0]\n        padding_top = self.padding[1]\n        padding_right = self.padding[2]\n        padding_bottom = self.padding[3]\n\n        padding_x = padding_left + padding_right\n        padding_y = padding_top + padding_bottom\n        spacing_x, spacing_y = self.spacing\n\n        # Determine which direction and in what order to place the widgets\n        posattr = [0] * 2\n        posdelta = [0] * 2\n        posstart = [0] * 2\n        for i in (0, 1):\n            posattr[i] = 1 * (orientation[i] in ('tb', 'bt'))\n            k = posattr[i]\n            if orientation[i] == 'lr':\n                # left to right\n                posdelta[i] = 1\n                posstart[i] = selfpos[k] + padding_left\n            elif orientation[i] == 'bt':\n                # bottom to top\n                posdelta[i] = 1\n                posstart[i] = selfpos[k] + padding_bottom\n            elif orientation[i] == 'rl':\n                # right to left\n                posdelta[i] = -1\n                posstart[i] = selfpos[k] + selfsize[k] - padding_right\n            else:\n                # top to bottom\n                posdelta[i] = -1\n                posstart[i] = selfpos[k] + selfsize[k] - padding_top\n\n        innerattr, outerattr = posattr\n        ustart, vstart = posstart\n        deltau, deltav = posdelta\n        del posattr, posdelta, posstart\n\n        u = ustart  # inner loop position variable\n        v = vstart  # outer loop position variable\n\n        # space calculation, used for determining when a row or column is full\n\n        if orientation[0] in ('lr', 'rl'):\n            sv = padding_y  # size in v-direction, for minimum_size property\n            su = padding_x  # size in h-direction\n            spacing_u = spacing_x\n            spacing_v = spacing_y\n            padding_u = padding_x\n            padding_v = padding_y\n        else:\n            sv = padding_x  # size in v-direction, for minimum_size property\n            su = padding_y  # size in h-direction\n            spacing_u = spacing_y\n            spacing_v = spacing_x\n            padding_u = padding_y\n            padding_v = padding_x\n\n        # space calculation, row height or column width, for arranging widgets\n        lv = 0\n\n        urev = (deltau < 0)\n        vrev = (deltav < 0)\n        firstchild = self.children[0]\n        sizes = []\n        lc = []\n        for c in reversed(self.children):\n            if c.size_hint[outerattr] is not None:\n                c.size[outerattr] = max(\n                    1, _compute_size(c, selfsize[outerattr] - padding_v,\n                                     outerattr))\n\n            # does the widget fit in the row/column?\n            ccount = len(lc)\n            totalsize = availsize = max(\n                0, selfsize[innerattr] - padding_u - spacing_u * ccount)\n            if not lc:\n                if c.size_hint[innerattr] is not None:\n                    childsize = max(1, _compute_size(c, totalsize, innerattr))\n                else:\n                    childsize = max(0, c.size[innerattr])\n                availsize = selfsize[innerattr] - padding_u - childsize\n                testsizes = [childsize]\n            else:\n                testsizes = [0] * (ccount + 1)\n                for i, child in enumerate(lc):\n                    if availsize <= 0:\n                        # no space left but we're trying to add another widget.\n                        availsize = -1\n                        break\n                    if child.size_hint[innerattr] is not None:\n                        testsizes[i] = childsize = max(\n                            1, _compute_size(child, totalsize, innerattr))\n                    else:\n                        childsize = max(0, child.size[innerattr])\n                        testsizes[i] = childsize\n                    availsize -= childsize\n                if c.size_hint[innerattr] is not None:\n                    testsizes[-1] = max(\n                        1, _compute_size(c, totalsize, innerattr))\n                else:\n                    testsizes[-1] = max(0, c.size[innerattr])\n                availsize -= testsizes[-1]\n\n            # Tiny value added in order to avoid issues with float precision\n            # causing unexpected children reordering when parent resizes.\n            # e.g. if size is 101 and children size_hint_x is 1./5\n            # 5 children would not fit in one line because 101*(1./5) > 101/5\n            if (availsize + 1e-10) >= 0 or not lc:\n                # even if there's no space, we always add one widget to a row\n                lc.append(c)\n                sizes = testsizes\n                lv = max(lv, c.size[outerattr])\n                continue\n\n            # apply the sizes\n            for i, child in enumerate(lc):\n                if child.size_hint[innerattr] is not None:\n                    child.size[innerattr] = sizes[i]\n\n            # push the line\n            sv += lv + spacing_v\n            for c2 in lc:\n                if urev:\n                    u -= c2.size[innerattr]\n                c2.pos[innerattr] = u\n                pos_outer = v\n                if vrev:\n                    # v position is actually the top/right side of the widget\n                    # when going from high to low coordinate values,\n                    # we need to subtract the height/width from the position.\n                    pos_outer -= c2.size[outerattr]\n                c2.pos[outerattr] = pos_outer\n                if urev:\n                    u -= spacing_u\n                else:\n                    u += c2.size[innerattr] + spacing_u\n\n            v += deltav * lv\n            v += deltav * spacing_v\n            lc = [c]\n            lv = c.size[outerattr]\n            if c.size_hint[innerattr] is not None:\n                sizes = [\n                    max(1, _compute_size(c, selfsize[innerattr] - padding_u,\n                                         innerattr))]\n            else:\n                sizes = [max(0, c.size[innerattr])]\n            u = ustart\n\n        if lc:\n            # apply the sizes\n            for i, child in enumerate(lc):\n                if child.size_hint[innerattr] is not None:\n                    child.size[innerattr] = sizes[i]\n\n            # push the last (incomplete) line\n            sv += lv + spacing_v\n            for c2 in lc:\n                if urev:\n                    u -= c2.size[innerattr]\n                c2.pos[innerattr] = u\n                pos_outer = v\n                if vrev:\n                    pos_outer -= c2.size[outerattr]\n                c2.pos[outerattr] = pos_outer\n                if urev:\n                    u -= spacing_u\n                else:\n                    u += c2.size[innerattr] + spacing_u\n\n        self.minimum_size[outerattr] = sv",
  "def __init__(self, **kwargs):\n        super(StackLayout, self).__init__(**kwargs)\n        trigger = self._trigger_layout\n        fbind = self.fbind\n        fbind('padding', trigger)\n        fbind('spacing', trigger)\n        fbind('children', trigger)\n        fbind('orientation', trigger)\n        fbind('size', trigger)\n        fbind('pos', trigger)",
  "def do_layout(self, *largs):\n        if not self.children:\n            self.minimum_size = (0., 0.)\n            return\n\n        # optimize layout by preventing looking at the same attribute in a loop\n        selfpos = self.pos\n        selfsize = self.size\n        orientation = self.orientation.split('-')\n        padding_left = self.padding[0]\n        padding_top = self.padding[1]\n        padding_right = self.padding[2]\n        padding_bottom = self.padding[3]\n\n        padding_x = padding_left + padding_right\n        padding_y = padding_top + padding_bottom\n        spacing_x, spacing_y = self.spacing\n\n        # Determine which direction and in what order to place the widgets\n        posattr = [0] * 2\n        posdelta = [0] * 2\n        posstart = [0] * 2\n        for i in (0, 1):\n            posattr[i] = 1 * (orientation[i] in ('tb', 'bt'))\n            k = posattr[i]\n            if orientation[i] == 'lr':\n                # left to right\n                posdelta[i] = 1\n                posstart[i] = selfpos[k] + padding_left\n            elif orientation[i] == 'bt':\n                # bottom to top\n                posdelta[i] = 1\n                posstart[i] = selfpos[k] + padding_bottom\n            elif orientation[i] == 'rl':\n                # right to left\n                posdelta[i] = -1\n                posstart[i] = selfpos[k] + selfsize[k] - padding_right\n            else:\n                # top to bottom\n                posdelta[i] = -1\n                posstart[i] = selfpos[k] + selfsize[k] - padding_top\n\n        innerattr, outerattr = posattr\n        ustart, vstart = posstart\n        deltau, deltav = posdelta\n        del posattr, posdelta, posstart\n\n        u = ustart  # inner loop position variable\n        v = vstart  # outer loop position variable\n\n        # space calculation, used for determining when a row or column is full\n\n        if orientation[0] in ('lr', 'rl'):\n            sv = padding_y  # size in v-direction, for minimum_size property\n            su = padding_x  # size in h-direction\n            spacing_u = spacing_x\n            spacing_v = spacing_y\n            padding_u = padding_x\n            padding_v = padding_y\n        else:\n            sv = padding_x  # size in v-direction, for minimum_size property\n            su = padding_y  # size in h-direction\n            spacing_u = spacing_y\n            spacing_v = spacing_x\n            padding_u = padding_y\n            padding_v = padding_x\n\n        # space calculation, row height or column width, for arranging widgets\n        lv = 0\n\n        urev = (deltau < 0)\n        vrev = (deltav < 0)\n        firstchild = self.children[0]\n        sizes = []\n        lc = []\n        for c in reversed(self.children):\n            if c.size_hint[outerattr] is not None:\n                c.size[outerattr] = max(\n                    1, _compute_size(c, selfsize[outerattr] - padding_v,\n                                     outerattr))\n\n            # does the widget fit in the row/column?\n            ccount = len(lc)\n            totalsize = availsize = max(\n                0, selfsize[innerattr] - padding_u - spacing_u * ccount)\n            if not lc:\n                if c.size_hint[innerattr] is not None:\n                    childsize = max(1, _compute_size(c, totalsize, innerattr))\n                else:\n                    childsize = max(0, c.size[innerattr])\n                availsize = selfsize[innerattr] - padding_u - childsize\n                testsizes = [childsize]\n            else:\n                testsizes = [0] * (ccount + 1)\n                for i, child in enumerate(lc):\n                    if availsize <= 0:\n                        # no space left but we're trying to add another widget.\n                        availsize = -1\n                        break\n                    if child.size_hint[innerattr] is not None:\n                        testsizes[i] = childsize = max(\n                            1, _compute_size(child, totalsize, innerattr))\n                    else:\n                        childsize = max(0, child.size[innerattr])\n                        testsizes[i] = childsize\n                    availsize -= childsize\n                if c.size_hint[innerattr] is not None:\n                    testsizes[-1] = max(\n                        1, _compute_size(c, totalsize, innerattr))\n                else:\n                    testsizes[-1] = max(0, c.size[innerattr])\n                availsize -= testsizes[-1]\n\n            # Tiny value added in order to avoid issues with float precision\n            # causing unexpected children reordering when parent resizes.\n            # e.g. if size is 101 and children size_hint_x is 1./5\n            # 5 children would not fit in one line because 101*(1./5) > 101/5\n            if (availsize + 1e-10) >= 0 or not lc:\n                # even if there's no space, we always add one widget to a row\n                lc.append(c)\n                sizes = testsizes\n                lv = max(lv, c.size[outerattr])\n                continue\n\n            # apply the sizes\n            for i, child in enumerate(lc):\n                if child.size_hint[innerattr] is not None:\n                    child.size[innerattr] = sizes[i]\n\n            # push the line\n            sv += lv + spacing_v\n            for c2 in lc:\n                if urev:\n                    u -= c2.size[innerattr]\n                c2.pos[innerattr] = u\n                pos_outer = v\n                if vrev:\n                    # v position is actually the top/right side of the widget\n                    # when going from high to low coordinate values,\n                    # we need to subtract the height/width from the position.\n                    pos_outer -= c2.size[outerattr]\n                c2.pos[outerattr] = pos_outer\n                if urev:\n                    u -= spacing_u\n                else:\n                    u += c2.size[innerattr] + spacing_u\n\n            v += deltav * lv\n            v += deltav * spacing_v\n            lc = [c]\n            lv = c.size[outerattr]\n            if c.size_hint[innerattr] is not None:\n                sizes = [\n                    max(1, _compute_size(c, selfsize[innerattr] - padding_u,\n                                         innerattr))]\n            else:\n                sizes = [max(0, c.size[innerattr])]\n            u = ustart\n\n        if lc:\n            # apply the sizes\n            for i, child in enumerate(lc):\n                if child.size_hint[innerattr] is not None:\n                    child.size[innerattr] = sizes[i]\n\n            # push the last (incomplete) line\n            sv += lv + spacing_v\n            for c2 in lc:\n                if urev:\n                    u -= c2.size[innerattr]\n                c2.pos[innerattr] = u\n                pos_outer = v\n                if vrev:\n                    pos_outer -= c2.size[outerattr]\n                c2.pos[outerattr] = pos_outer\n                if urev:\n                    u -= spacing_u\n                else:\n                    u += c2.size[innerattr] + spacing_u\n\n        self.minimum_size[outerattr] = sv",
  "class Scatter(Widget):\n    '''Scatter class. See module documentation for more information.\n\n    :Events:\n        `on_transform_with_touch`:\n            Fired when the scatter has been transformed by user touch\n            or multitouch, such as panning or zooming.\n        `on_bring_to_front`:\n            Fired when the scatter is brought to the front.\n\n    .. versionchanged:: 1.9.0\n        Event `on_bring_to_front` added.\n\n    .. versionchanged:: 1.8.0\n        Event `on_transform_with_touch` added.\n    '''\n\n    __events__ = ('on_transform_with_touch', 'on_bring_to_front')\n\n    auto_bring_to_front = BooleanProperty(True)\n    '''If True, the widget will be automatically pushed on the top of parent\n    widget list for drawing.\n\n    :attr:`auto_bring_to_front` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True.\n    '''\n\n    do_translation_x = BooleanProperty(True)\n    '''Allow translation on the X axis.\n\n    :attr:`do_translation_x` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    do_translation_y = BooleanProperty(True)\n    '''Allow translation on Y axis.\n\n    :attr:`do_translation_y` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    def _get_do_translation(self):\n        return (self.do_translation_x, self.do_translation_y)\n\n    def _set_do_translation(self, value):\n        if type(value) in (list, tuple):\n            self.do_translation_x, self.do_translation_y = value\n        else:\n            self.do_translation_x = self.do_translation_y = bool(value)\n\n    do_translation = AliasProperty(_get_do_translation, _set_do_translation,\n                                   bind=('do_translation_x',\n                                         'do_translation_y'),\n                                   cache=True)\n    '''Allow translation on the X or Y axis.\n\n    :attr:`do_translation` is an :class:`~kivy.properties.AliasProperty` of\n    (:attr:`do_translation_x` + :attr:`do_translation_y`)\n    '''\n\n    translation_touches = BoundedNumericProperty(1, min=1)\n    '''Determine whether translation was triggered by a single or multiple\n    touches. This only has effect when :attr:`do_translation` = True.\n\n    :attr:`translation_touches` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 1.\n\n    .. versionadded:: 1.7.0\n    '''\n\n    do_rotation = BooleanProperty(True)\n    '''Allow rotation.\n\n    :attr:`do_rotation` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    do_scale = BooleanProperty(True)\n    '''Allow scaling.\n\n    :attr:`do_scale` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    do_collide_after_children = BooleanProperty(False)\n    '''If True, the collision detection for limiting the touch inside the\n    scatter will be done after dispaching the touch to the children.\n    You can put children outside the bounding box of the scatter and still be\n    able to touch them.\n\n    :attr:`do_collide_after_children` is a\n    :class:`~kivy.properties.BooleanProperty` and defaults to False.\n\n    .. versionadded:: 1.3.0\n    '''\n\n    scale_min = NumericProperty(0.01)\n    '''Minimum scaling factor allowed.\n\n    :attr:`scale_min` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.01.\n    '''\n\n    scale_max = NumericProperty(1e20)\n    '''Maximum scaling factor allowed.\n\n    :attr:`scale_max` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 1e20.\n    '''\n\n    transform = ObjectProperty(Matrix())\n    '''Transformation matrix.\n\n    :attr:`transform` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to the identity matrix.\n\n    .. note::\n\n        This matrix reflects the current state of the transformation matrix\n        but setting it directly will erase previously applied\n        transformations. To apply a transformation considering context,\n        please use the :attr:`~Scatter.apply_transform` method.\n\n    '''\n\n    transform_inv = ObjectProperty(Matrix())\n    '''Inverse of the transformation matrix.\n\n    :attr:`transform_inv` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to the identity matrix.\n    '''\n\n    def _get_bbox(self):\n        xmin, ymin = xmax, ymax = self.to_parent(0, 0)\n        for point in [(self.width, 0), (0, self.height), self.size]:\n            x, y = self.to_parent(*point)\n            if x < xmin:\n                xmin = x\n            if y < ymin:\n                ymin = y\n            if x > xmax:\n                xmax = x\n            if y > ymax:\n                ymax = y\n        return (xmin, ymin), (xmax - xmin, ymax - ymin)\n\n    bbox = AliasProperty(_get_bbox, bind=('transform', 'width', 'height'))\n    '''Bounding box of the widget in parent space::\n\n        ((x, y), (w, h))\n        # x, y = lower left corner\n\n    :attr:`bbox` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def _get_rotation(self):\n        v1 = Vector(0, 10)\n        tp = self.to_parent\n        v2 = Vector(*tp(*self.pos)) - tp(self.x, self.y + 10)\n        return -1.0 * (v1.angle(v2) + 180) % 360\n\n    def _set_rotation(self, rotation):\n        angle_change = self.rotation - rotation\n        r = Matrix().rotate(-radians(angle_change), 0, 0, 1)\n        self.apply_transform(r, post_multiply=True,\n                             anchor=self.to_local(*self.center))\n\n    rotation = AliasProperty(_get_rotation, _set_rotation,\n                             bind=('x', 'y', 'transform'))\n    '''Rotation value of the scatter in degrees moving in a counterclockwise\n    direction.\n\n    :attr:`rotation` is an :class:`~kivy.properties.AliasProperty` and defaults\n    to 0.0.\n    '''\n\n    def _get_scale(self):\n        p1 = Vector(*self.to_parent(0, 0))\n        p2 = Vector(*self.to_parent(1, 0))\n        scale = p1.distance(p2)\n\n        # XXX float calculation are not accurate, and then, scale can be\n        # thrown again even with only the position change. So to\n        # prevent anything wrong with scale, just avoid to dispatch it\n        # if the scale \"visually\" didn't change. #947\n        # Remove this ugly hack when we'll be Python 3 only.\n        if hasattr(self, '_scale_p'):\n            if str(scale) == str(self._scale_p):\n                return self._scale_p\n\n        self._scale_p = scale\n        return scale\n\n    def _set_scale(self, scale):\n        rescale = scale * 1.0 / self.scale\n        self.apply_transform(Matrix().scale(rescale, rescale, rescale),\n                             post_multiply=True,\n                             anchor=self.to_local(*self.center))\n\n    scale = AliasProperty(_get_scale, _set_scale, bind=('x', 'y', 'transform'))\n    '''Scale value of the scatter.\n\n    :attr:`scale` is an :class:`~kivy.properties.AliasProperty` and defaults to\n    1.0.\n    '''\n\n    def _get_center(self):\n        return (self.bbox[0][0] + self.bbox[1][0] / 2.0,\n                self.bbox[0][1] + self.bbox[1][1] / 2.0)\n\n    def _set_center(self, center):\n        if center == self.center:\n            return False\n        t = Vector(*center) - self.center\n        trans = Matrix().translate(t.x, t.y, 0)\n        self.apply_transform(trans)\n\n    center = AliasProperty(_get_center, _set_center, bind=('bbox',))\n\n    def _get_pos(self):\n        return self.bbox[0]\n\n    def _set_pos(self, pos):\n        _pos = self.bbox[0]\n        if pos == _pos:\n            return\n        t = Vector(*pos) - _pos\n        trans = Matrix().translate(t.x, t.y, 0)\n        self.apply_transform(trans)\n\n    pos = AliasProperty(_get_pos, _set_pos, bind=('bbox',))\n\n    def _get_x(self):\n        return self.bbox[0][0]\n\n    def _set_x(self, x):\n        if x == self.bbox[0][0]:\n            return False\n        self.pos = (x, self.y)\n        return True\n\n    x = AliasProperty(_get_x, _set_x, bind=('bbox',))\n\n    def _get_y(self):\n        return self.bbox[0][1]\n\n    def _set_y(self, y):\n        if y == self.bbox[0][1]:\n            return False\n        self.pos = (self.x, y)\n        return True\n\n    y = AliasProperty(_get_y, _set_y, bind=('bbox',))\n\n    def get_right(self):\n        return self.x + self.bbox[1][0]\n\n    def set_right(self, value):\n        self.x = value - self.bbox[1][0]\n\n    right = AliasProperty(get_right, set_right, bind=('x', 'bbox'))\n\n    def get_top(self):\n        return self.y + self.bbox[1][1]\n\n    def set_top(self, value):\n        self.y = value - self.bbox[1][1]\n\n    top = AliasProperty(get_top, set_top, bind=('y', 'bbox'))\n\n    def get_center_x(self):\n        return self.x + self.bbox[1][0] / 2.\n\n    def set_center_x(self, value):\n        self.x = value - self.bbox[1][0] / 2.\n\n    center_x = AliasProperty(get_center_x, set_center_x, bind=('x', 'bbox'))\n\n    def get_center_y(self):\n        return self.y + self.bbox[1][1] / 2.\n\n    def set_center_y(self, value):\n        self.y = value - self.bbox[1][1] / 2.\n\n    center_y = AliasProperty(get_center_y, set_center_y, bind=('y', 'bbox'))\n\n    def __init__(self, **kwargs):\n        self._touches = []\n        self._last_touch_pos = {}\n        super(Scatter, self).__init__(**kwargs)\n\n    def on_transform(self, instance, value):\n        self.transform_inv = value.inverse()\n\n    def collide_point(self, x, y):\n        x, y = self.to_local(x, y)\n        return 0 <= x <= self.width and 0 <= y <= self.height\n\n    def to_parent(self, x, y, **k):\n        p = self.transform.transform_point(x, y, 0)\n        return (p[0], p[1])\n\n    def to_local(self, x, y, **k):\n        p = self.transform_inv.transform_point(x, y, 0)\n        return (p[0], p[1])\n\n    def _apply_transform(self, m, pos=None):\n        m = self.transform.multiply(m)\n        return super(Scatter, self)._apply_transform(m, (0, 0))\n\n    def apply_transform(self, trans, post_multiply=False, anchor=(0, 0)):\n        '''\n        Transforms the scatter by applying the \"trans\" transformation\n        matrix (on top of its current transformation state). The resultant\n        matrix can be found in the :attr:`~Scatter.transform` property.\n\n        :Parameters:\n            `trans`: :class:`~kivy.graphics.transformation.Matrix`.\n                Transformation matrix to be applied to the scatter widget.\n            `anchor`: tuple, defaults to (0, 0).\n                The point to use as the origin of the transformation\n                (uses local widget space).\n            `post_multiply`: bool, defaults to False.\n                If True, the transform matrix is post multiplied\n                (as if applied before the current transform).\n\n        Usage example::\n\n            from kivy.graphics.transformation import Matrix\n            mat = Matrix().scale(3, 3, 3)\n            scatter_instance.apply_transform(mat)\n\n        '''\n        t = Matrix().translate(anchor[0], anchor[1], 0)\n        t = t.multiply(trans)\n        t = t.multiply(Matrix().translate(-anchor[0], -anchor[1], 0))\n\n        if post_multiply:\n            self.transform = self.transform.multiply(t)\n        else:\n            self.transform = t.multiply(self.transform)\n\n    def transform_with_touch(self, touch):\n        # just do a simple one finger drag\n        changed = False\n        if len(self._touches) == self.translation_touches:\n            # _last_touch_pos has last pos in correct parent space,\n            # just like incoming touch\n            dx = (touch.x - self._last_touch_pos[touch][0]) \\\n                * self.do_translation_x\n            dy = (touch.y - self._last_touch_pos[touch][1]) \\\n                * self.do_translation_y\n            dx = dx / self.translation_touches\n            dy = dy / self.translation_touches\n            self.apply_transform(Matrix().translate(dx, dy, 0))\n            changed = True\n\n        if len(self._touches) == 1:\n            return changed\n\n        # we have more than one touch... list of last known pos\n        points = [Vector(self._last_touch_pos[t]) for t in self._touches\n                  if t is not touch]\n        # add current touch last\n        points.append(Vector(touch.pos))\n\n        # we only want to transform if the touch is part of the two touches\n        # farthest apart! So first we find anchor, the point to transform\n        # around as another touch farthest away from current touch's pos\n        anchor = max(points[:-1], key=lambda p: p.distance(touch.pos))\n\n        # now we find the touch farthest away from anchor, if its not the\n        # same as touch. Touch is not one of the two touches used to transform\n        farthest = max(points, key=anchor.distance)\n        if farthest is not points[-1]:\n            return changed\n\n        # ok, so we have touch, and anchor, so we can actually compute the\n        # transformation\n        old_line = Vector(*touch.ppos) - anchor\n        new_line = Vector(*touch.pos) - anchor\n        if not old_line.length():   # div by zero\n            return changed\n\n        angle = radians(new_line.angle(old_line)) * self.do_rotation\n        if angle:\n            changed = True\n        self.apply_transform(Matrix().rotate(angle, 0, 0, 1), anchor=anchor)\n\n        if self.do_scale:\n            scale = new_line.length() / old_line.length()\n            new_scale = scale * self.scale\n            if new_scale < self.scale_min:\n                scale = self.scale_min / self.scale\n            elif new_scale > self.scale_max:\n                scale = self.scale_max / self.scale\n            self.apply_transform(Matrix().scale(scale, scale, scale),\n                                 anchor=anchor)\n            changed = True\n        return changed\n\n    def _bring_to_front(self, touch):\n        # auto bring to front\n        if self.auto_bring_to_front and self.parent:\n            parent = self.parent\n            if parent.children[0] is self:\n                return\n            parent.remove_widget(self)\n            parent.add_widget(self)\n            self.dispatch('on_bring_to_front', touch)\n\n    def on_motion(self, etype, me):\n        if me.type_id in self.motion_filter and 'pos' in me.profile:\n            me.push()\n            me.apply_transform_2d(self.to_local)\n            ret = super().on_motion(etype, me)\n            me.pop()\n            return ret\n        return super().on_motion(etype, me)\n\n    def on_touch_down(self, touch):\n        x, y = touch.x, touch.y\n\n        # if the touch isn't on the widget we do nothing\n        if not self.do_collide_after_children:\n            if not self.collide_point(x, y):\n                return False\n\n        # let the child widgets handle the event if they want\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        if super(Scatter, self).on_touch_down(touch):\n            touch.pop()\n            self._bring_to_front(touch)\n            return True\n        touch.pop()\n\n        # if our child didn't do anything, and if we don't have any active\n        # interaction control, then don't accept the touch.\n        if not self.do_translation_x and \\\n                not self.do_translation_y and \\\n                not self.do_rotation and \\\n                not self.do_scale:\n            return False\n\n        if self.do_collide_after_children:\n            if not self.collide_point(x, y):\n                return False\n\n        if 'multitouch_sim' in touch.profile:\n            touch.multitouch_sim = True\n        # grab the touch so we get all it later move events for sure\n        self._bring_to_front(touch)\n        touch.grab(self)\n        self._touches.append(touch)\n        self._last_touch_pos[touch] = touch.pos\n\n        return True\n\n    def on_touch_move(self, touch):\n        x, y = touch.x, touch.y\n        # let the child widgets handle the event if they want\n        if self.collide_point(x, y) and not touch.grab_current == self:\n            touch.push()\n            touch.apply_transform_2d(self.to_local)\n            if super(Scatter, self).on_touch_move(touch):\n                touch.pop()\n                return True\n            touch.pop()\n\n        # rotate/scale/translate\n        if touch in self._touches and touch.grab_current == self:\n            if self.transform_with_touch(touch):\n                self.dispatch('on_transform_with_touch', touch)\n            self._last_touch_pos[touch] = touch.pos\n\n        # stop propagating if its within our bounds\n        if self.collide_point(x, y):\n            return True\n\n    def on_transform_with_touch(self, touch):\n        '''\n        Called when a touch event has transformed the scatter widget.\n        By default this does nothing, but can be overridden by derived\n        classes that need to react to transformations caused by user\n        input.\n\n        :Parameters:\n            `touch`:\n                The touch object which triggered the transformation.\n\n        .. versionadded:: 1.8.0\n        '''\n        pass\n\n    def on_bring_to_front(self, touch):\n        '''\n        Called when a touch event causes the scatter to be brought to the\n        front of the parent (only if :attr:`auto_bring_to_front` is True)\n\n        :Parameters:\n            `touch`:\n                The touch object which brought the scatter to front.\n\n        .. versionadded:: 1.9.0\n        '''\n        pass\n\n    def on_touch_up(self, touch):\n        x, y = touch.x, touch.y\n        # if the touch isn't on the widget we do nothing, just try children\n        if not touch.grab_current == self:\n            touch.push()\n            touch.apply_transform_2d(self.to_local)\n            if super(Scatter, self).on_touch_up(touch):\n                touch.pop()\n                return True\n            touch.pop()\n\n        # remove it from our saved touches\n        if touch in self._touches and touch.grab_state:\n            touch.ungrab(self)\n            del self._last_touch_pos[touch]\n            self._touches.remove(touch)\n\n        # stop propagating if its within our bounds\n        if self.collide_point(x, y):\n            return True",
  "class ScatterPlane(Scatter):\n    '''This is essentially an unbounded Scatter widget. It's a convenience\n       class to make it easier to handle infinite planes.\n    '''\n\n    def __init__(self, **kwargs):\n        if 'auto_bring_to_front' not in kwargs:\n            self.auto_bring_to_front = False\n        super(ScatterPlane, self).__init__(**kwargs)\n\n    def collide_point(self, x, y):\n        return True",
  "def _get_do_translation(self):\n        return (self.do_translation_x, self.do_translation_y)",
  "def _set_do_translation(self, value):\n        if type(value) in (list, tuple):\n            self.do_translation_x, self.do_translation_y = value\n        else:\n            self.do_translation_x = self.do_translation_y = bool(value)",
  "def _get_bbox(self):\n        xmin, ymin = xmax, ymax = self.to_parent(0, 0)\n        for point in [(self.width, 0), (0, self.height), self.size]:\n            x, y = self.to_parent(*point)\n            if x < xmin:\n                xmin = x\n            if y < ymin:\n                ymin = y\n            if x > xmax:\n                xmax = x\n            if y > ymax:\n                ymax = y\n        return (xmin, ymin), (xmax - xmin, ymax - ymin)",
  "def _get_rotation(self):\n        v1 = Vector(0, 10)\n        tp = self.to_parent\n        v2 = Vector(*tp(*self.pos)) - tp(self.x, self.y + 10)\n        return -1.0 * (v1.angle(v2) + 180) % 360",
  "def _set_rotation(self, rotation):\n        angle_change = self.rotation - rotation\n        r = Matrix().rotate(-radians(angle_change), 0, 0, 1)\n        self.apply_transform(r, post_multiply=True,\n                             anchor=self.to_local(*self.center))",
  "def _get_scale(self):\n        p1 = Vector(*self.to_parent(0, 0))\n        p2 = Vector(*self.to_parent(1, 0))\n        scale = p1.distance(p2)\n\n        # XXX float calculation are not accurate, and then, scale can be\n        # thrown again even with only the position change. So to\n        # prevent anything wrong with scale, just avoid to dispatch it\n        # if the scale \"visually\" didn't change. #947\n        # Remove this ugly hack when we'll be Python 3 only.\n        if hasattr(self, '_scale_p'):\n            if str(scale) == str(self._scale_p):\n                return self._scale_p\n\n        self._scale_p = scale\n        return scale",
  "def _set_scale(self, scale):\n        rescale = scale * 1.0 / self.scale\n        self.apply_transform(Matrix().scale(rescale, rescale, rescale),\n                             post_multiply=True,\n                             anchor=self.to_local(*self.center))",
  "def _get_center(self):\n        return (self.bbox[0][0] + self.bbox[1][0] / 2.0,\n                self.bbox[0][1] + self.bbox[1][1] / 2.0)",
  "def _set_center(self, center):\n        if center == self.center:\n            return False\n        t = Vector(*center) - self.center\n        trans = Matrix().translate(t.x, t.y, 0)\n        self.apply_transform(trans)",
  "def _get_pos(self):\n        return self.bbox[0]",
  "def _set_pos(self, pos):\n        _pos = self.bbox[0]\n        if pos == _pos:\n            return\n        t = Vector(*pos) - _pos\n        trans = Matrix().translate(t.x, t.y, 0)\n        self.apply_transform(trans)",
  "def _get_x(self):\n        return self.bbox[0][0]",
  "def _set_x(self, x):\n        if x == self.bbox[0][0]:\n            return False\n        self.pos = (x, self.y)\n        return True",
  "def _get_y(self):\n        return self.bbox[0][1]",
  "def _set_y(self, y):\n        if y == self.bbox[0][1]:\n            return False\n        self.pos = (self.x, y)\n        return True",
  "def get_right(self):\n        return self.x + self.bbox[1][0]",
  "def set_right(self, value):\n        self.x = value - self.bbox[1][0]",
  "def get_top(self):\n        return self.y + self.bbox[1][1]",
  "def set_top(self, value):\n        self.y = value - self.bbox[1][1]",
  "def get_center_x(self):\n        return self.x + self.bbox[1][0] / 2.",
  "def set_center_x(self, value):\n        self.x = value - self.bbox[1][0] / 2.",
  "def get_center_y(self):\n        return self.y + self.bbox[1][1] / 2.",
  "def set_center_y(self, value):\n        self.y = value - self.bbox[1][1] / 2.",
  "def __init__(self, **kwargs):\n        self._touches = []\n        self._last_touch_pos = {}\n        super(Scatter, self).__init__(**kwargs)",
  "def on_transform(self, instance, value):\n        self.transform_inv = value.inverse()",
  "def collide_point(self, x, y):\n        x, y = self.to_local(x, y)\n        return 0 <= x <= self.width and 0 <= y <= self.height",
  "def to_parent(self, x, y, **k):\n        p = self.transform.transform_point(x, y, 0)\n        return (p[0], p[1])",
  "def to_local(self, x, y, **k):\n        p = self.transform_inv.transform_point(x, y, 0)\n        return (p[0], p[1])",
  "def _apply_transform(self, m, pos=None):\n        m = self.transform.multiply(m)\n        return super(Scatter, self)._apply_transform(m, (0, 0))",
  "def apply_transform(self, trans, post_multiply=False, anchor=(0, 0)):\n        '''\n        Transforms the scatter by applying the \"trans\" transformation\n        matrix (on top of its current transformation state). The resultant\n        matrix can be found in the :attr:`~Scatter.transform` property.\n\n        :Parameters:\n            `trans`: :class:`~kivy.graphics.transformation.Matrix`.\n                Transformation matrix to be applied to the scatter widget.\n            `anchor`: tuple, defaults to (0, 0).\n                The point to use as the origin of the transformation\n                (uses local widget space).\n            `post_multiply`: bool, defaults to False.\n                If True, the transform matrix is post multiplied\n                (as if applied before the current transform).\n\n        Usage example::\n\n            from kivy.graphics.transformation import Matrix\n            mat = Matrix().scale(3, 3, 3)\n            scatter_instance.apply_transform(mat)\n\n        '''\n        t = Matrix().translate(anchor[0], anchor[1], 0)\n        t = t.multiply(trans)\n        t = t.multiply(Matrix().translate(-anchor[0], -anchor[1], 0))\n\n        if post_multiply:\n            self.transform = self.transform.multiply(t)\n        else:\n            self.transform = t.multiply(self.transform)",
  "def transform_with_touch(self, touch):\n        # just do a simple one finger drag\n        changed = False\n        if len(self._touches) == self.translation_touches:\n            # _last_touch_pos has last pos in correct parent space,\n            # just like incoming touch\n            dx = (touch.x - self._last_touch_pos[touch][0]) \\\n                * self.do_translation_x\n            dy = (touch.y - self._last_touch_pos[touch][1]) \\\n                * self.do_translation_y\n            dx = dx / self.translation_touches\n            dy = dy / self.translation_touches\n            self.apply_transform(Matrix().translate(dx, dy, 0))\n            changed = True\n\n        if len(self._touches) == 1:\n            return changed\n\n        # we have more than one touch... list of last known pos\n        points = [Vector(self._last_touch_pos[t]) for t in self._touches\n                  if t is not touch]\n        # add current touch last\n        points.append(Vector(touch.pos))\n\n        # we only want to transform if the touch is part of the two touches\n        # farthest apart! So first we find anchor, the point to transform\n        # around as another touch farthest away from current touch's pos\n        anchor = max(points[:-1], key=lambda p: p.distance(touch.pos))\n\n        # now we find the touch farthest away from anchor, if its not the\n        # same as touch. Touch is not one of the two touches used to transform\n        farthest = max(points, key=anchor.distance)\n        if farthest is not points[-1]:\n            return changed\n\n        # ok, so we have touch, and anchor, so we can actually compute the\n        # transformation\n        old_line = Vector(*touch.ppos) - anchor\n        new_line = Vector(*touch.pos) - anchor\n        if not old_line.length():   # div by zero\n            return changed\n\n        angle = radians(new_line.angle(old_line)) * self.do_rotation\n        if angle:\n            changed = True\n        self.apply_transform(Matrix().rotate(angle, 0, 0, 1), anchor=anchor)\n\n        if self.do_scale:\n            scale = new_line.length() / old_line.length()\n            new_scale = scale * self.scale\n            if new_scale < self.scale_min:\n                scale = self.scale_min / self.scale\n            elif new_scale > self.scale_max:\n                scale = self.scale_max / self.scale\n            self.apply_transform(Matrix().scale(scale, scale, scale),\n                                 anchor=anchor)\n            changed = True\n        return changed",
  "def _bring_to_front(self, touch):\n        # auto bring to front\n        if self.auto_bring_to_front and self.parent:\n            parent = self.parent\n            if parent.children[0] is self:\n                return\n            parent.remove_widget(self)\n            parent.add_widget(self)\n            self.dispatch('on_bring_to_front', touch)",
  "def on_motion(self, etype, me):\n        if me.type_id in self.motion_filter and 'pos' in me.profile:\n            me.push()\n            me.apply_transform_2d(self.to_local)\n            ret = super().on_motion(etype, me)\n            me.pop()\n            return ret\n        return super().on_motion(etype, me)",
  "def on_touch_down(self, touch):\n        x, y = touch.x, touch.y\n\n        # if the touch isn't on the widget we do nothing\n        if not self.do_collide_after_children:\n            if not self.collide_point(x, y):\n                return False\n\n        # let the child widgets handle the event if they want\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        if super(Scatter, self).on_touch_down(touch):\n            touch.pop()\n            self._bring_to_front(touch)\n            return True\n        touch.pop()\n\n        # if our child didn't do anything, and if we don't have any active\n        # interaction control, then don't accept the touch.\n        if not self.do_translation_x and \\\n                not self.do_translation_y and \\\n                not self.do_rotation and \\\n                not self.do_scale:\n            return False\n\n        if self.do_collide_after_children:\n            if not self.collide_point(x, y):\n                return False\n\n        if 'multitouch_sim' in touch.profile:\n            touch.multitouch_sim = True\n        # grab the touch so we get all it later move events for sure\n        self._bring_to_front(touch)\n        touch.grab(self)\n        self._touches.append(touch)\n        self._last_touch_pos[touch] = touch.pos\n\n        return True",
  "def on_touch_move(self, touch):\n        x, y = touch.x, touch.y\n        # let the child widgets handle the event if they want\n        if self.collide_point(x, y) and not touch.grab_current == self:\n            touch.push()\n            touch.apply_transform_2d(self.to_local)\n            if super(Scatter, self).on_touch_move(touch):\n                touch.pop()\n                return True\n            touch.pop()\n\n        # rotate/scale/translate\n        if touch in self._touches and touch.grab_current == self:\n            if self.transform_with_touch(touch):\n                self.dispatch('on_transform_with_touch', touch)\n            self._last_touch_pos[touch] = touch.pos\n\n        # stop propagating if its within our bounds\n        if self.collide_point(x, y):\n            return True",
  "def on_transform_with_touch(self, touch):\n        '''\n        Called when a touch event has transformed the scatter widget.\n        By default this does nothing, but can be overridden by derived\n        classes that need to react to transformations caused by user\n        input.\n\n        :Parameters:\n            `touch`:\n                The touch object which triggered the transformation.\n\n        .. versionadded:: 1.8.0\n        '''\n        pass",
  "def on_bring_to_front(self, touch):\n        '''\n        Called when a touch event causes the scatter to be brought to the\n        front of the parent (only if :attr:`auto_bring_to_front` is True)\n\n        :Parameters:\n            `touch`:\n                The touch object which brought the scatter to front.\n\n        .. versionadded:: 1.9.0\n        '''\n        pass",
  "def on_touch_up(self, touch):\n        x, y = touch.x, touch.y\n        # if the touch isn't on the widget we do nothing, just try children\n        if not touch.grab_current == self:\n            touch.push()\n            touch.apply_transform_2d(self.to_local)\n            if super(Scatter, self).on_touch_up(touch):\n                touch.pop()\n                return True\n            touch.pop()\n\n        # remove it from our saved touches\n        if touch in self._touches and touch.grab_state:\n            touch.ungrab(self)\n            del self._last_touch_pos[touch]\n            self._touches.remove(touch)\n\n        # stop propagating if its within our bounds\n        if self.collide_point(x, y):\n            return True",
  "def __init__(self, **kwargs):\n        if 'auto_bring_to_front' not in kwargs:\n            self.auto_bring_to_front = False\n        super(ScatterPlane, self).__init__(**kwargs)",
  "def collide_point(self, x, y):\n        return True",
  "class TabbedPanelException(Exception):\n    '''The TabbedPanelException class.\n    '''\n    pass",
  "class TabbedPanelHeader(ToggleButton):\n    '''A Base for implementing a Tabbed Panel Head. A button intended to be\n    used as a Heading/Tab for a TabbedPanel widget.\n\n    You can use this TabbedPanelHeader widget to add a new tab to a\n    TabbedPanel.\n    '''\n\n    content = ObjectProperty(None, allownone=True)\n    '''Content to be loaded when this tab header is selected.\n\n    :attr:`content` is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    # only allow selecting the tab if not already selected\n    def on_touch_down(self, touch):\n        if self.state == 'down':\n            # dispatch to children, not to self\n            for child in self.children:\n                child.dispatch('on_touch_down', touch)\n            return\n        else:\n            super(TabbedPanelHeader, self).on_touch_down(touch)\n\n    def on_release(self, *largs):\n        # Tabbed panel header is a child of tab_strib which has a\n        # `tabbed_panel` property\n        if self.parent:\n            self.parent.tabbed_panel.switch_to(self)\n        else:\n            # tab removed before we could switch to it. Switch back to\n            # previous tab\n            self.panel.switch_to(self.panel.current_tab)",
  "class TabbedPanelItem(TabbedPanelHeader):\n    '''This is a convenience class that provides a header of type\n    TabbedPanelHeader and links it with the content automatically. Thus\n    facilitating you to simply do the following in kv language:\n\n    .. code-block:: kv\n\n        <TabbedPanel>:\n            # ...other settings\n            TabbedPanelItem:\n                BoxLayout:\n                    Label:\n                        text: 'Second tab content area'\n                    Button:\n                        text: 'Button that does nothing'\n\n    .. versionadded:: 1.5.0\n    '''\n\n    def add_widget(self, widget, *args, **kwargs):\n        self.content = widget\n        if not self.parent:\n            return\n        panel = self.parent.tabbed_panel\n        if panel.current_tab == self:\n            panel.switch_to(self)\n\n    def remove_widget(self, *args, **kwargs):\n        self.content = None\n        if not self.parent:\n            return\n        panel = self.parent.tabbed_panel\n        if panel.current_tab == self:\n            panel.remove_widget(*args, **kwargs)",
  "class TabbedPanelStrip(GridLayout):\n    '''A strip intended to be used as background for Heading/Tab.\n    This does not cover the blank areas in case the tabs don't cover\n    the entire width/height of the TabbedPanel(use :class:`StripLayout`\n    for that).\n    '''\n    tabbed_panel = ObjectProperty(None)\n    '''Link to the panel that the tab strip is a part of.\n\n    :attr:`tabbed_panel` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None .\n    '''",
  "class StripLayout(GridLayout):\n    ''' The main layout that is used to house the entire tabbedpanel strip\n    including the blank areas in case the tabs don't cover the entire\n    width/height.\n\n    .. versionadded:: 1.8.0\n\n    '''\n\n    border = ListProperty([4, 4, 4, 4])\n    '''Border property for the :attr:`background_image`.\n\n    :attr:`border` is a :class:`~kivy.properties.ListProperty` and defaults\n    to [4, 4, 4, 4]\n    '''\n\n    background_image = StringProperty(\n        'atlas://data/images/defaulttheme/action_view')\n    '''Background image to be used for the Strip layout of the TabbedPanel.\n\n    :attr:`background_image` is a :class:`~kivy.properties.StringProperty` and\n    defaults to a transparent image.\n    '''",
  "class TabbedPanelContent(FloatLayout):\n    '''The TabbedPanelContent class.\n    '''\n    pass",
  "class TabbedPanel(GridLayout):\n    '''The TabbedPanel class. See module documentation for more information.\n    '''\n\n    background_color = ColorProperty([1, 1, 1, 1])\n    '''Background color, in the format (r, g, b, a).\n\n    :attr:`background_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    border = ListProperty([16, 16, 16, 16])\n    '''Border used for :class:`~kivy.graphics.vertex_instructions.BorderImage`\n    graphics instruction, used itself for :attr:`background_image`.\n    Can be changed for a custom background.\n\n    It must be a list of four values: (bottom, right, top, left). Read the\n    BorderImage instructions for more information.\n\n    :attr:`border` is a :class:`~kivy.properties.ListProperty` and\n    defaults to (16, 16, 16, 16)\n    '''\n\n    background_image = StringProperty('atlas://data/images/defaulttheme/tab')\n    '''Background image of the main shared content object.\n\n    :attr:`background_image` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/tab'.\n    '''\n\n    background_disabled_image = StringProperty(\n        'atlas://data/images/defaulttheme/tab_disabled')\n    '''Background image of the main shared content object when disabled.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`background_disabled_image` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/tab'.\n    '''\n\n    strip_image = StringProperty(\n        'atlas://data/images/defaulttheme/action_view')\n    '''Background image of the tabbed strip.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`strip_image` is a :class:`~kivy.properties.StringProperty`\n    and defaults to a empty image.\n    '''\n\n    strip_border = ListProperty([4, 4, 4, 4])\n    '''Border to be used on :attr:`strip_image`.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`strip_border` is a :class:`~kivy.properties.ListProperty` and\n    defaults to [4, 4, 4, 4].\n    '''\n\n    _current_tab = ObjectProperty(None)\n\n    def get_current_tab(self):\n        return self._current_tab\n\n    current_tab = AliasProperty(get_current_tab, None, bind=('_current_tab', ))\n    '''Links to the currently selected or active tab.\n\n    .. versionadded:: 1.4.0\n\n    :attr:`current_tab` is an :class:`~kivy.AliasProperty`, read-only.\n    '''\n\n    tab_pos = OptionProperty(\n        'top_left',\n        options=('left_top', 'left_mid', 'left_bottom', 'top_left',\n                 'top_mid', 'top_right', 'right_top', 'right_mid',\n                 'right_bottom', 'bottom_left', 'bottom_mid', 'bottom_right'))\n    '''Specifies the position of the tabs relative to the content.\n    Can be one of: `left_top`, `left_mid`, `left_bottom`, `top_left`,\n    `top_mid`, `top_right`, `right_top`, `right_mid`, `right_bottom`,\n    `bottom_left`, `bottom_mid`, `bottom_right`.\n\n    :attr:`tab_pos` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'top_left'.\n    '''\n\n    tab_height = NumericProperty('40dp')\n    '''Specifies the height of the tab header.\n\n    :attr:`tab_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 40.\n    '''\n\n    tab_width = NumericProperty('100dp', allownone=True)\n    '''Specifies the width of the tab header.\n\n    :attr:`tab_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 100.\n    '''\n\n    bar_width = NumericProperty('2dp')\n    '''Width of the horizontal scroll bar. The width is interpreted\n    as a height for the horizontal bar.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`bar_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 2.\n    '''\n\n    scroll_type = OptionProperty(['content'], options=(['content'], ['bars'],\n                                 ['bars', 'content'], ['content', 'bars']))\n\n    '''Sets the type of scrolling to use for the content of the scrollview.\n    Available options are: ['content'], ['bars'], ['bars', 'content'].\n\n    .. versionadded:: 2.2.0\n\n    :attr:`scroll_type` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to ['content'].\n    '''\n\n    do_default_tab = BooleanProperty(True)\n    '''Specifies whether a default_tab head is provided.\n\n    .. versionadded:: 1.5.0\n\n    :attr:`do_default_tab` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to 'True'.\n    '''\n\n    default_tab_text = StringProperty('Default tab')\n    '''Specifies the text displayed on the default tab header.\n\n    :attr:`default_tab_text` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'default tab'.\n    '''\n\n    default_tab_cls = ObjectProperty(TabbedPanelHeader)\n    '''Specifies the class to use for the styling of the default tab.\n\n    .. versionadded:: 1.4.0\n\n    .. warning::\n        `default_tab_cls` should be subclassed from `TabbedPanelHeader`\n\n    :attr:`default_tab_cls` is an :class:`~kivy.properties.ObjectProperty`\n    and defaults to `TabbedPanelHeader`. If you set a string, the\n    :class:`~kivy.factory.Factory` will be used to resolve the class.\n\n    .. versionchanged:: 1.8.0\n        The :class:`~kivy.factory.Factory` will resolve the class if a string\n        is set.\n    '''\n\n    def get_tab_list(self):\n        if self._tab_strip:\n            return self._tab_strip.children\n        return 1.\n\n    tab_list = AliasProperty(get_tab_list, None)\n    '''List of all the tab headers.\n\n    :attr:`tab_list` is an :class:`~kivy.properties.AliasProperty` and is\n    read-only.\n    '''\n\n    content = ObjectProperty(None)\n    '''This is the object holding (current_tab's content is added to this)\n    the content of the current tab. To Listen to the changes in the content\n    of the current tab, you should bind to current_tabs `content` property.\n\n    :attr:`content` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to 'None'.\n    '''\n\n    _default_tab = ObjectProperty(None, allow_none=True)\n\n    def get_def_tab(self):\n        return self._default_tab\n\n    def set_def_tab(self, new_tab):\n        if not issubclass(new_tab.__class__, TabbedPanelHeader):\n            raise TabbedPanelException('`default_tab_class` should be\\\n                subclassed from `TabbedPanelHeader`')\n        if self._default_tab == new_tab:\n            return\n        oltab = self._default_tab\n        self._default_tab = new_tab\n        self.remove_widget(oltab)\n        self._original_tab = None\n        self.switch_to(new_tab)\n        new_tab.state = 'down'\n\n    default_tab = AliasProperty(get_def_tab, set_def_tab,\n                                bind=('_default_tab', ))\n    '''Holds the default tab.\n\n    .. Note:: For convenience, the automatically provided default tab is\n              deleted when you change default_tab to something else.\n              As of 1.5.0, this behavior has been extended to every\n              `default_tab` for consistency and not just the automatically\n              provided one.\n\n    :attr:`default_tab` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def get_def_tab_content(self):\n        return self.default_tab.content\n\n    def set_def_tab_content(self, *l):\n        self.default_tab.content = l[0]\n\n    default_tab_content = AliasProperty(get_def_tab_content,\n                                        set_def_tab_content)\n    '''Holds the default tab content.\n\n    :attr:`default_tab_content` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    _update_top_ev = _update_tab_ev = _update_tabs_ev = None\n\n    def __init__(self, **kwargs):\n        # these variables need to be initialized before the kv lang is\n        # processed setup the base layout for the tabbed panel\n        self._childrens = []\n        self._tab_layout = StripLayout(rows=1)\n        self.rows = 1\n        self._tab_strip = TabbedPanelStrip(\n            tabbed_panel=self,\n            rows=1, size_hint=(None, None),\n            height=self.tab_height, width=self.tab_width)\n\n        self._partial_update_scrollview = None\n        self.content = TabbedPanelContent()\n        self._current_tab = self._original_tab \\\n            = self._default_tab = TabbedPanelHeader()\n\n        super(TabbedPanel, self).__init__(**kwargs)\n\n        self.fbind('size', self._reposition_tabs)\n        if not self.do_default_tab:\n            Clock.schedule_once(self._switch_to_first_tab)\n            return\n        self._setup_default_tab()\n        self.switch_to(self.default_tab)\n\n    def switch_to(self, header, do_scroll=False):\n        '''Switch to a specific panel header.\n\n        .. versionchanged:: 1.10.0\n\n        If used with `do_scroll=True`, it scrolls\n        to the header's tab too.\n\n        :meth:`switch_to` cannot be called from within the\n        :class:`TabbedPanel` or its subclass' ``__init__`` method.\n        If that is required, use the ``Clock`` to schedule it. See `discussion\n        <https://github.com/kivy/kivy/issues/3493#issuecomment-121567969>`_\n        for full example.\n        '''\n        header_content = header.content\n        self._current_tab.state = 'normal'\n        header.state = 'down'\n        self._current_tab = header\n        self.clear_widgets()\n        if header_content is None:\n            return\n        # if content has a previous parent remove it from that parent\n        parent = header_content.parent\n        if parent:\n            parent.remove_widget(header_content)\n        self.add_widget(header_content)\n\n        if do_scroll:\n            tabs = self._tab_strip\n            tabs.parent.scroll_to(header)\n\n    def clear_tabs(self, *l):\n        self_tabs = self._tab_strip\n        self_tabs.clear_widgets()\n        if self.do_default_tab:\n            self_default_tab = self._default_tab\n            self_tabs.add_widget(self_default_tab)\n            self_tabs.width = self_default_tab.width\n        self._reposition_tabs()\n\n    def add_widget(self, widget, *args, **kwargs):\n        content = self.content\n        if content is None:\n            return\n        parent = widget.parent\n        if parent:\n            parent.remove_widget(widget)\n        if widget in (content, self._tab_layout):\n            super(TabbedPanel, self).add_widget(widget, *args, **kwargs)\n        elif isinstance(widget, TabbedPanelHeader):\n            self_tabs = self._tab_strip\n            self_tabs.add_widget(widget, *args, **kwargs)\n            widget.group = '__tab%r__' % self_tabs.uid\n            self.on_tab_width()\n        else:\n            widget.pos_hint = {'x': 0, 'top': 1}\n            self._childrens.append(widget)\n            content.disabled = self.current_tab.disabled\n            content.add_widget(widget, *args, **kwargs)\n\n    def remove_widget(self, widget, *args, **kwargs):\n        content = self.content\n        if content is None:\n            return\n        if widget in (content, self._tab_layout):\n            super(TabbedPanel, self).remove_widget(widget, *args, **kwargs)\n        elif isinstance(widget, TabbedPanelHeader):\n            if not (self.do_default_tab and widget is self._default_tab):\n                self_tabs = self._tab_strip\n                self_tabs.width -= widget.width\n                self_tabs.remove_widget(widget)\n                if widget.state == 'down' and self.do_default_tab:\n                    self._default_tab.on_release()\n                self._reposition_tabs()\n            else:\n                Logger.info('TabbedPanel: default tab! can\\'t be removed.\\n' +\n                            'Change `default_tab` to a different tab.')\n        else:\n            if widget in self._childrens:\n                self._childrens.remove(widget)\n            if widget in content.children:\n                content.remove_widget(widget, *args, **kwargs)\n\n    def clear_widgets(self, *args, **kwargs):\n        if self.content:\n            self.content.clear_widgets(*args, **kwargs)\n\n    def on_strip_image(self, instance, value):\n        if not self._tab_layout:\n            return\n        self._tab_layout.background_image = value\n\n    def on_strip_border(self, instance, value):\n        if not self._tab_layout:\n            return\n        self._tab_layout.border = value\n\n    def on_do_default_tab(self, instance, value):\n        if not value:\n            dft = self.default_tab\n            if dft in self.tab_list:\n                self.remove_widget(dft)\n                self._switch_to_first_tab()\n                self._default_tab = self._current_tab\n        else:\n            self._current_tab.state = 'normal'\n            self._setup_default_tab()\n\n    def on_default_tab_text(self, *args):\n        self._default_tab.text = self.default_tab_text\n\n    def on_tab_width(self, *l):\n        ev = self._update_tab_ev\n        if ev is None:\n            ev = self._update_tab_ev = Clock.create_trigger(\n                self._update_tab_width, 0)\n        ev()\n\n    def on_tab_height(self, *l):\n        self._tab_layout.height = self._tab_strip.height = self.tab_height\n        self._reposition_tabs()\n\n    def on_tab_pos(self, *l):\n        # ensure canvas\n        self._reposition_tabs()\n\n    def _setup_default_tab(self):\n        if self._default_tab in self.tab_list:\n            return\n        content = self._default_tab.content\n        _tabs = self._tab_strip\n        cls = self.default_tab_cls\n\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n\n        if not issubclass(cls, TabbedPanelHeader):\n            raise TabbedPanelException('`default_tab_class` should be\\\n                subclassed from `TabbedPanelHeader`')\n\n        # no need to instantiate if class is TabbedPanelHeader\n        if cls != TabbedPanelHeader:\n            self._current_tab = self._original_tab = self._default_tab = cls()\n\n        default_tab = self.default_tab\n        if self._original_tab == self.default_tab:\n            default_tab.text = self.default_tab_text\n\n        default_tab.height = self.tab_height\n        default_tab.group = '__tab%r__' % _tabs.uid\n        default_tab.state = 'down'\n        default_tab.width = self.tab_width if self.tab_width else 100\n        default_tab.content = content\n\n        tl = self.tab_list\n        if default_tab not in tl:\n            _tabs.add_widget(default_tab, len(tl))\n\n        if default_tab.content:\n            self.clear_widgets()\n            self.add_widget(self.default_tab.content)\n        else:\n            Clock.schedule_once(self._load_default_tab_content)\n        self._current_tab = default_tab\n\n    def _switch_to_first_tab(self, *l):\n        ltl = len(self.tab_list) - 1\n        if ltl > -1:\n            self._current_tab = dt = self._original_tab \\\n                = self.tab_list[ltl]\n            self.switch_to(dt)\n\n    def _load_default_tab_content(self, dt):\n        if self.default_tab:\n            self.switch_to(self.default_tab)\n\n    def _reposition_tabs(self, *l):\n        ev = self._update_tabs_ev\n        if ev is None:\n            ev = self._update_tabs_ev = Clock.create_trigger(\n                self._update_tabs, 0)\n        ev()\n\n    def _update_tabs(self, *l):\n        self_content = self.content\n        if not self_content:\n            return\n        # cache variables for faster access\n        tab_pos = self.tab_pos\n        tab_layout = self._tab_layout\n        tab_layout.clear_widgets()\n        scrl_v = ScrollView(size_hint=(None, 1), always_overscroll=False,\n                            bar_width=self.bar_width,\n                            scroll_type=self.scroll_type)\n        tabs = self._tab_strip\n        parent = tabs.parent\n        if parent:\n            parent.remove_widget(tabs)\n        scrl_v.add_widget(tabs)\n        scrl_v.pos = (0, 0)\n        self_update_scrollview = self._update_scrollview\n\n        # update scrlv width when tab width changes depends on tab_pos\n        if self._partial_update_scrollview is not None:\n            tabs.unbind(width=self._partial_update_scrollview)\n        self._partial_update_scrollview = partial(\n            self_update_scrollview, scrl_v)\n        tabs.bind(width=self._partial_update_scrollview)\n\n        # remove all widgets from the tab_strip\n        super(TabbedPanel, self).clear_widgets()\n        tab_height = self.tab_height\n\n        widget_list = []\n        tab_list = []\n        pos_letter = tab_pos[0]\n        if pos_letter == 'b' or pos_letter == 't':\n            # bottom or top positions\n            # one col containing the tab_strip and the content\n            self.cols = 1\n            self.rows = 2\n            # tab_layout contains the scrollview containing tabs and two blank\n            # dummy widgets for spacing\n            tab_layout.rows = 1\n            tab_layout.cols = 3\n            tab_layout.size_hint = (1, None)\n            tab_layout.height = (tab_height + tab_layout.padding[1] +\n                                 tab_layout.padding[3] + dp(2))\n            self_update_scrollview(scrl_v)\n\n            if pos_letter == 'b':\n                # bottom\n                if tab_pos == 'bottom_mid':\n                    tab_list = (Widget(), scrl_v, Widget())\n                    widget_list = (self_content, tab_layout)\n                else:\n                    if tab_pos == 'bottom_left':\n                        tab_list = (scrl_v, Widget(), Widget())\n                    elif tab_pos == 'bottom_right':\n                        # add two dummy widgets\n                        tab_list = (Widget(), Widget(), scrl_v)\n                    widget_list = (self_content, tab_layout)\n            else:\n                # top\n                if tab_pos == 'top_mid':\n                    tab_list = (Widget(), scrl_v, Widget())\n                elif tab_pos == 'top_left':\n                    tab_list = (scrl_v, Widget(), Widget())\n                elif tab_pos == 'top_right':\n                    tab_list = (Widget(), Widget(), scrl_v)\n                widget_list = (tab_layout, self_content)\n        elif pos_letter == 'l' or pos_letter == 'r':\n            # left or right positions\n            # one row containing the tab_strip and the content\n            self.cols = 2\n            self.rows = 1\n            # tab_layout contains two blank dummy widgets for spacing\n            # \"vertically\" and the scatter containing scrollview\n            # containing tabs\n            tab_layout.rows = 3\n            tab_layout.cols = 1\n            tab_layout.size_hint = (None, 1)\n            tab_layout.width = tab_height\n            scrl_v.height = tab_height\n            self_update_scrollview(scrl_v)\n\n            # rotate the scatter for vertical positions\n            rotation = 90 if tab_pos[0] == 'l' else -90\n            sctr = Scatter(do_translation=False,\n                           rotation=rotation,\n                           do_rotation=False,\n                           do_scale=False,\n                           size_hint=(None, None),\n                           auto_bring_to_front=False,\n                           size=scrl_v.size)\n            sctr.add_widget(scrl_v)\n\n            lentab_pos = len(tab_pos)\n\n            # Update scatter's top when its pos changes.\n            # Needed for repositioning scatter to the correct place after its\n            # added to the parent. Use clock_schedule_once to ensure top is\n            # calculated after the parent's pos on canvas has been calculated.\n            # This is needed for when tab_pos changes to correctly position\n            # scatter. Without clock.schedule_once the positions would look\n            # fine but touch won't translate to the correct position\n\n            if tab_pos[lentab_pos - 4:] == '_top':\n                # on positions 'left_top' and 'right_top'\n                sctr.bind(pos=partial(self._update_top, sctr, 'top', None))\n                tab_list = (sctr, )\n            elif tab_pos[lentab_pos - 4:] == '_mid':\n                # calculate top of scatter\n                sctr.bind(pos=partial(self._update_top, sctr, 'mid',\n                                      scrl_v.width))\n                tab_list = (Widget(), sctr, Widget())\n            elif tab_pos[lentab_pos - 7:] == '_bottom':\n                tab_list = (Widget(), Widget(), sctr)\n\n            if pos_letter == 'l':\n                widget_list = (tab_layout, self_content)\n            else:\n                widget_list = (self_content, tab_layout)\n\n        # add widgets to tab_layout\n        add = tab_layout.add_widget\n        for widg in tab_list:\n            add(widg)\n\n        # add widgets to self\n        add = self.add_widget\n        for widg in widget_list:\n            add(widg)\n\n    def _update_tab_width(self, *l):\n        if self.tab_width:\n            for tab in self.tab_list:\n                tab.size_hint_x = 1\n            tsw = self.tab_width * len(self._tab_strip.children)\n        else:\n            # tab_width = None\n            tsw = 0\n            for tab in self.tab_list:\n                if tab.size_hint_x:\n                    # size_hint_x: x/.xyz\n                    tab.size_hint_x = 1\n                    # drop to default tab_width\n                    tsw += 100\n                else:\n                    # size_hint_x: None\n                    tsw += tab.width\n        self._tab_strip.width = tsw\n        self._reposition_tabs()\n\n    def _update_top(self, *args):\n        sctr, top, scrl_v_width, x, y = args\n        ev = self._update_top_ev\n        if ev is not None:\n            ev.cancel()\n\n        ev = self._update_top_ev = Clock.schedule_once(\n            partial(self._updt_top, sctr, top, scrl_v_width), 0)\n\n    def _updt_top(self, sctr, top, scrl_v_width, *args):\n        if top[0] == 't':\n            sctr.top = self.top\n        else:\n            sctr.top = self.top - (self.height - scrl_v_width) / 2\n\n    def _update_scrollview(self, scrl_v, *l):\n        self_tab_pos = self.tab_pos\n        self_tabs = self._tab_strip\n        if self_tab_pos[0] == 'b' or self_tab_pos[0] == 't':\n            # bottom or top\n            scrl_v.width = min(self.width, self_tabs.width)\n            # required for situations when scrl_v's pos is calculated\n            # when it has no parent\n            scrl_v.top += 1\n            scrl_v.top -= 1\n        else:\n            # left or right\n            scrl_v.width = min(self.height, self_tabs.width)\n            self_tabs.pos = (0, 0)",
  "def on_touch_down(self, touch):\n        if self.state == 'down':\n            # dispatch to children, not to self\n            for child in self.children:\n                child.dispatch('on_touch_down', touch)\n            return\n        else:\n            super(TabbedPanelHeader, self).on_touch_down(touch)",
  "def on_release(self, *largs):\n        # Tabbed panel header is a child of tab_strib which has a\n        # `tabbed_panel` property\n        if self.parent:\n            self.parent.tabbed_panel.switch_to(self)\n        else:\n            # tab removed before we could switch to it. Switch back to\n            # previous tab\n            self.panel.switch_to(self.panel.current_tab)",
  "def add_widget(self, widget, *args, **kwargs):\n        self.content = widget\n        if not self.parent:\n            return\n        panel = self.parent.tabbed_panel\n        if panel.current_tab == self:\n            panel.switch_to(self)",
  "def remove_widget(self, *args, **kwargs):\n        self.content = None\n        if not self.parent:\n            return\n        panel = self.parent.tabbed_panel\n        if panel.current_tab == self:\n            panel.remove_widget(*args, **kwargs)",
  "def get_current_tab(self):\n        return self._current_tab",
  "def get_tab_list(self):\n        if self._tab_strip:\n            return self._tab_strip.children\n        return 1.",
  "def get_def_tab(self):\n        return self._default_tab",
  "def set_def_tab(self, new_tab):\n        if not issubclass(new_tab.__class__, TabbedPanelHeader):\n            raise TabbedPanelException('`default_tab_class` should be\\\n                subclassed from `TabbedPanelHeader`')\n        if self._default_tab == new_tab:\n            return\n        oltab = self._default_tab\n        self._default_tab = new_tab\n        self.remove_widget(oltab)\n        self._original_tab = None\n        self.switch_to(new_tab)\n        new_tab.state = 'down'",
  "def get_def_tab_content(self):\n        return self.default_tab.content",
  "def set_def_tab_content(self, *l):\n        self.default_tab.content = l[0]",
  "def __init__(self, **kwargs):\n        # these variables need to be initialized before the kv lang is\n        # processed setup the base layout for the tabbed panel\n        self._childrens = []\n        self._tab_layout = StripLayout(rows=1)\n        self.rows = 1\n        self._tab_strip = TabbedPanelStrip(\n            tabbed_panel=self,\n            rows=1, size_hint=(None, None),\n            height=self.tab_height, width=self.tab_width)\n\n        self._partial_update_scrollview = None\n        self.content = TabbedPanelContent()\n        self._current_tab = self._original_tab \\\n            = self._default_tab = TabbedPanelHeader()\n\n        super(TabbedPanel, self).__init__(**kwargs)\n\n        self.fbind('size', self._reposition_tabs)\n        if not self.do_default_tab:\n            Clock.schedule_once(self._switch_to_first_tab)\n            return\n        self._setup_default_tab()\n        self.switch_to(self.default_tab)",
  "def switch_to(self, header, do_scroll=False):\n        '''Switch to a specific panel header.\n\n        .. versionchanged:: 1.10.0\n\n        If used with `do_scroll=True`, it scrolls\n        to the header's tab too.\n\n        :meth:`switch_to` cannot be called from within the\n        :class:`TabbedPanel` or its subclass' ``__init__`` method.\n        If that is required, use the ``Clock`` to schedule it. See `discussion\n        <https://github.com/kivy/kivy/issues/3493#issuecomment-121567969>`_\n        for full example.\n        '''\n        header_content = header.content\n        self._current_tab.state = 'normal'\n        header.state = 'down'\n        self._current_tab = header\n        self.clear_widgets()\n        if header_content is None:\n            return\n        # if content has a previous parent remove it from that parent\n        parent = header_content.parent\n        if parent:\n            parent.remove_widget(header_content)\n        self.add_widget(header_content)\n\n        if do_scroll:\n            tabs = self._tab_strip\n            tabs.parent.scroll_to(header)",
  "def clear_tabs(self, *l):\n        self_tabs = self._tab_strip\n        self_tabs.clear_widgets()\n        if self.do_default_tab:\n            self_default_tab = self._default_tab\n            self_tabs.add_widget(self_default_tab)\n            self_tabs.width = self_default_tab.width\n        self._reposition_tabs()",
  "def add_widget(self, widget, *args, **kwargs):\n        content = self.content\n        if content is None:\n            return\n        parent = widget.parent\n        if parent:\n            parent.remove_widget(widget)\n        if widget in (content, self._tab_layout):\n            super(TabbedPanel, self).add_widget(widget, *args, **kwargs)\n        elif isinstance(widget, TabbedPanelHeader):\n            self_tabs = self._tab_strip\n            self_tabs.add_widget(widget, *args, **kwargs)\n            widget.group = '__tab%r__' % self_tabs.uid\n            self.on_tab_width()\n        else:\n            widget.pos_hint = {'x': 0, 'top': 1}\n            self._childrens.append(widget)\n            content.disabled = self.current_tab.disabled\n            content.add_widget(widget, *args, **kwargs)",
  "def remove_widget(self, widget, *args, **kwargs):\n        content = self.content\n        if content is None:\n            return\n        if widget in (content, self._tab_layout):\n            super(TabbedPanel, self).remove_widget(widget, *args, **kwargs)\n        elif isinstance(widget, TabbedPanelHeader):\n            if not (self.do_default_tab and widget is self._default_tab):\n                self_tabs = self._tab_strip\n                self_tabs.width -= widget.width\n                self_tabs.remove_widget(widget)\n                if widget.state == 'down' and self.do_default_tab:\n                    self._default_tab.on_release()\n                self._reposition_tabs()\n            else:\n                Logger.info('TabbedPanel: default tab! can\\'t be removed.\\n' +\n                            'Change `default_tab` to a different tab.')\n        else:\n            if widget in self._childrens:\n                self._childrens.remove(widget)\n            if widget in content.children:\n                content.remove_widget(widget, *args, **kwargs)",
  "def clear_widgets(self, *args, **kwargs):\n        if self.content:\n            self.content.clear_widgets(*args, **kwargs)",
  "def on_strip_image(self, instance, value):\n        if not self._tab_layout:\n            return\n        self._tab_layout.background_image = value",
  "def on_strip_border(self, instance, value):\n        if not self._tab_layout:\n            return\n        self._tab_layout.border = value",
  "def on_do_default_tab(self, instance, value):\n        if not value:\n            dft = self.default_tab\n            if dft in self.tab_list:\n                self.remove_widget(dft)\n                self._switch_to_first_tab()\n                self._default_tab = self._current_tab\n        else:\n            self._current_tab.state = 'normal'\n            self._setup_default_tab()",
  "def on_default_tab_text(self, *args):\n        self._default_tab.text = self.default_tab_text",
  "def on_tab_width(self, *l):\n        ev = self._update_tab_ev\n        if ev is None:\n            ev = self._update_tab_ev = Clock.create_trigger(\n                self._update_tab_width, 0)\n        ev()",
  "def on_tab_height(self, *l):\n        self._tab_layout.height = self._tab_strip.height = self.tab_height\n        self._reposition_tabs()",
  "def on_tab_pos(self, *l):\n        # ensure canvas\n        self._reposition_tabs()",
  "def _setup_default_tab(self):\n        if self._default_tab in self.tab_list:\n            return\n        content = self._default_tab.content\n        _tabs = self._tab_strip\n        cls = self.default_tab_cls\n\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n\n        if not issubclass(cls, TabbedPanelHeader):\n            raise TabbedPanelException('`default_tab_class` should be\\\n                subclassed from `TabbedPanelHeader`')\n\n        # no need to instantiate if class is TabbedPanelHeader\n        if cls != TabbedPanelHeader:\n            self._current_tab = self._original_tab = self._default_tab = cls()\n\n        default_tab = self.default_tab\n        if self._original_tab == self.default_tab:\n            default_tab.text = self.default_tab_text\n\n        default_tab.height = self.tab_height\n        default_tab.group = '__tab%r__' % _tabs.uid\n        default_tab.state = 'down'\n        default_tab.width = self.tab_width if self.tab_width else 100\n        default_tab.content = content\n\n        tl = self.tab_list\n        if default_tab not in tl:\n            _tabs.add_widget(default_tab, len(tl))\n\n        if default_tab.content:\n            self.clear_widgets()\n            self.add_widget(self.default_tab.content)\n        else:\n            Clock.schedule_once(self._load_default_tab_content)\n        self._current_tab = default_tab",
  "def _switch_to_first_tab(self, *l):\n        ltl = len(self.tab_list) - 1\n        if ltl > -1:\n            self._current_tab = dt = self._original_tab \\\n                = self.tab_list[ltl]\n            self.switch_to(dt)",
  "def _load_default_tab_content(self, dt):\n        if self.default_tab:\n            self.switch_to(self.default_tab)",
  "def _reposition_tabs(self, *l):\n        ev = self._update_tabs_ev\n        if ev is None:\n            ev = self._update_tabs_ev = Clock.create_trigger(\n                self._update_tabs, 0)\n        ev()",
  "def _update_tabs(self, *l):\n        self_content = self.content\n        if not self_content:\n            return\n        # cache variables for faster access\n        tab_pos = self.tab_pos\n        tab_layout = self._tab_layout\n        tab_layout.clear_widgets()\n        scrl_v = ScrollView(size_hint=(None, 1), always_overscroll=False,\n                            bar_width=self.bar_width,\n                            scroll_type=self.scroll_type)\n        tabs = self._tab_strip\n        parent = tabs.parent\n        if parent:\n            parent.remove_widget(tabs)\n        scrl_v.add_widget(tabs)\n        scrl_v.pos = (0, 0)\n        self_update_scrollview = self._update_scrollview\n\n        # update scrlv width when tab width changes depends on tab_pos\n        if self._partial_update_scrollview is not None:\n            tabs.unbind(width=self._partial_update_scrollview)\n        self._partial_update_scrollview = partial(\n            self_update_scrollview, scrl_v)\n        tabs.bind(width=self._partial_update_scrollview)\n\n        # remove all widgets from the tab_strip\n        super(TabbedPanel, self).clear_widgets()\n        tab_height = self.tab_height\n\n        widget_list = []\n        tab_list = []\n        pos_letter = tab_pos[0]\n        if pos_letter == 'b' or pos_letter == 't':\n            # bottom or top positions\n            # one col containing the tab_strip and the content\n            self.cols = 1\n            self.rows = 2\n            # tab_layout contains the scrollview containing tabs and two blank\n            # dummy widgets for spacing\n            tab_layout.rows = 1\n            tab_layout.cols = 3\n            tab_layout.size_hint = (1, None)\n            tab_layout.height = (tab_height + tab_layout.padding[1] +\n                                 tab_layout.padding[3] + dp(2))\n            self_update_scrollview(scrl_v)\n\n            if pos_letter == 'b':\n                # bottom\n                if tab_pos == 'bottom_mid':\n                    tab_list = (Widget(), scrl_v, Widget())\n                    widget_list = (self_content, tab_layout)\n                else:\n                    if tab_pos == 'bottom_left':\n                        tab_list = (scrl_v, Widget(), Widget())\n                    elif tab_pos == 'bottom_right':\n                        # add two dummy widgets\n                        tab_list = (Widget(), Widget(), scrl_v)\n                    widget_list = (self_content, tab_layout)\n            else:\n                # top\n                if tab_pos == 'top_mid':\n                    tab_list = (Widget(), scrl_v, Widget())\n                elif tab_pos == 'top_left':\n                    tab_list = (scrl_v, Widget(), Widget())\n                elif tab_pos == 'top_right':\n                    tab_list = (Widget(), Widget(), scrl_v)\n                widget_list = (tab_layout, self_content)\n        elif pos_letter == 'l' or pos_letter == 'r':\n            # left or right positions\n            # one row containing the tab_strip and the content\n            self.cols = 2\n            self.rows = 1\n            # tab_layout contains two blank dummy widgets for spacing\n            # \"vertically\" and the scatter containing scrollview\n            # containing tabs\n            tab_layout.rows = 3\n            tab_layout.cols = 1\n            tab_layout.size_hint = (None, 1)\n            tab_layout.width = tab_height\n            scrl_v.height = tab_height\n            self_update_scrollview(scrl_v)\n\n            # rotate the scatter for vertical positions\n            rotation = 90 if tab_pos[0] == 'l' else -90\n            sctr = Scatter(do_translation=False,\n                           rotation=rotation,\n                           do_rotation=False,\n                           do_scale=False,\n                           size_hint=(None, None),\n                           auto_bring_to_front=False,\n                           size=scrl_v.size)\n            sctr.add_widget(scrl_v)\n\n            lentab_pos = len(tab_pos)\n\n            # Update scatter's top when its pos changes.\n            # Needed for repositioning scatter to the correct place after its\n            # added to the parent. Use clock_schedule_once to ensure top is\n            # calculated after the parent's pos on canvas has been calculated.\n            # This is needed for when tab_pos changes to correctly position\n            # scatter. Without clock.schedule_once the positions would look\n            # fine but touch won't translate to the correct position\n\n            if tab_pos[lentab_pos - 4:] == '_top':\n                # on positions 'left_top' and 'right_top'\n                sctr.bind(pos=partial(self._update_top, sctr, 'top', None))\n                tab_list = (sctr, )\n            elif tab_pos[lentab_pos - 4:] == '_mid':\n                # calculate top of scatter\n                sctr.bind(pos=partial(self._update_top, sctr, 'mid',\n                                      scrl_v.width))\n                tab_list = (Widget(), sctr, Widget())\n            elif tab_pos[lentab_pos - 7:] == '_bottom':\n                tab_list = (Widget(), Widget(), sctr)\n\n            if pos_letter == 'l':\n                widget_list = (tab_layout, self_content)\n            else:\n                widget_list = (self_content, tab_layout)\n\n        # add widgets to tab_layout\n        add = tab_layout.add_widget\n        for widg in tab_list:\n            add(widg)\n\n        # add widgets to self\n        add = self.add_widget\n        for widg in widget_list:\n            add(widg)",
  "def _update_tab_width(self, *l):\n        if self.tab_width:\n            for tab in self.tab_list:\n                tab.size_hint_x = 1\n            tsw = self.tab_width * len(self._tab_strip.children)\n        else:\n            # tab_width = None\n            tsw = 0\n            for tab in self.tab_list:\n                if tab.size_hint_x:\n                    # size_hint_x: x/.xyz\n                    tab.size_hint_x = 1\n                    # drop to default tab_width\n                    tsw += 100\n                else:\n                    # size_hint_x: None\n                    tsw += tab.width\n        self._tab_strip.width = tsw\n        self._reposition_tabs()",
  "def _update_top(self, *args):\n        sctr, top, scrl_v_width, x, y = args\n        ev = self._update_top_ev\n        if ev is not None:\n            ev.cancel()\n\n        ev = self._update_top_ev = Clock.schedule_once(\n            partial(self._updt_top, sctr, top, scrl_v_width), 0)",
  "def _updt_top(self, sctr, top, scrl_v_width, *args):\n        if top[0] == 't':\n            sctr.top = self.top\n        else:\n            sctr.top = self.top - (self.height - scrl_v_width) / 2",
  "def _update_scrollview(self, scrl_v, *l):\n        self_tab_pos = self.tab_pos\n        self_tabs = self._tab_strip\n        if self_tab_pos[0] == 'b' or self_tab_pos[0] == 't':\n            # bottom or top\n            scrl_v.width = min(self.width, self_tabs.width)\n            # required for situations when scrl_v's pos is calculated\n            # when it has no parent\n            scrl_v.top += 1\n            scrl_v.top -= 1\n        else:\n            # left or right\n            scrl_v.width = min(self.height, self_tabs.width)\n            self_tabs.pos = (0, 0)",
  "class Switch(Widget):\n    '''Switch class. See module documentation for more information.\n    '''\n    active = BooleanProperty(False)\n    '''Indicate whether the switch is active or inactive.\n\n    :attr:`active` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    touch_control = ObjectProperty(None, allownone=True)\n    '''(internal) Contains the touch that currently interacts with the switch.\n\n    :attr:`touch_control` is an :class:`~kivy.properties.ObjectProperty`\n    and defaults to None.\n    '''\n\n    touch_distance = NumericProperty(0)\n    '''(internal) Contains the distance between the initial position of the\n    touch and the current position to determine if the swipe is from the left\n    or right.\n\n    :attr:`touch_distance` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 0.\n    '''\n\n    active_norm_pos = NumericProperty(0)\n    '''(internal) Contains the normalized position of the movable element\n    inside the switch, in the 0-1 range.\n\n    :attr:`active_norm_pos` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 0.\n    '''\n\n    def on_touch_down(self, touch):\n        if self.disabled or self.touch_control is not None:\n            return\n        if not self.collide_point(*touch.pos):\n            return\n        touch.grab(self)\n        self.touch_distance = 0\n        self.touch_control = touch\n        return True\n\n    def on_touch_move(self, touch):\n        if touch.grab_current is not self:\n            return\n        self.touch_distance = touch.x - touch.ox\n        return True\n\n    def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n        # depending of the distance, activate by norm pos or invert\n        if abs(touch.ox - touch.x) < 5:\n            self.active = not self.active\n        else:\n            self.active = self.active_norm_pos > 0.5\n        Animation(active_norm_pos=int(self.active), t='out_quad',\n                  d=.2).start(self)\n        self.touch_control = None\n        return True",
  "def on_touch_down(self, touch):\n        if self.disabled or self.touch_control is not None:\n            return\n        if not self.collide_point(*touch.pos):\n            return\n        touch.grab(self)\n        self.touch_distance = 0\n        self.touch_control = touch\n        return True",
  "def on_touch_move(self, touch):\n        if touch.grab_current is not self:\n            return\n        self.touch_distance = touch.x - touch.ox\n        return True",
  "def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n        # depending of the distance, activate by norm pos or invert\n        if abs(touch.ox - touch.x) < 5:\n            self.active = not self.active\n        else:\n            self.active = self.active_norm_pos > 0.5\n        Animation(active_norm_pos=int(self.active), t='out_quad',\n                  d=.2).start(self)\n        self.touch_control = None\n        return True",
  "class Slider(Widget):\n    \"\"\"Class for creating a Slider widget.\n\n    Check module documentation for more details.\n    \"\"\"\n\n    value = NumericProperty(0.)\n    '''Current value used for the slider.\n\n    :attr:`value` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 0.'''\n\n    min = NumericProperty(0.)\n    '''Minimum value allowed for :attr:`value`.\n\n    :attr:`min` is a :class:`~kivy.properties.NumericProperty` and defaults to\n    0.'''\n\n    max = NumericProperty(100.)\n    '''Maximum value allowed for :attr:`value`.\n\n    :attr:`max` is a :class:`~kivy.properties.NumericProperty` and defaults to\n    100.'''\n\n    padding = NumericProperty('16sp')\n    '''Padding of the slider. The padding is used for graphical representation\n    and interaction. It prevents the cursor from going out of the bounds of the\n    slider bounding box.\n\n    By default, padding is 16sp. The range of the slider is reduced from\n    padding \\\\*2 on the screen. It allows drawing the default cursor of 32sp\n    width without having the cursor go out of the widget.\n\n    :attr:`padding` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 16sp.'''\n\n    orientation = OptionProperty('horizontal', options=(\n        'vertical', 'horizontal'))\n    '''Orientation of the slider.\n\n    :attr:`orientation` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'horizontal'. Can take a value of 'vertical' or 'horizontal'.\n    '''\n\n    range = ReferenceListProperty(min, max)\n    '''Range of the slider in the format (minimum value, maximum value)::\n\n        >>> slider = Slider(min=10, max=80)\n        >>> slider.range\n        [10, 80]\n        >>> slider.range = (20, 100)\n        >>> slider.min\n        20\n        >>> slider.max\n        100\n\n    :attr:`range` is a :class:`~kivy.properties.ReferenceListProperty` of\n    (:attr:`min`, :attr:`max`) properties.\n    '''\n\n    step = BoundedNumericProperty(0, min=0)\n    '''Step size of the slider.\n\n    .. versionadded:: 1.4.0\n\n    Determines the size of each interval or step the slider takes between\n    :attr:`min` and :attr:`max`. If the value range can't be evenly\n    divisible by step the last step will be capped by slider.max.\n    A zero value will result in the smallest possible intervals/steps,\n    calculated from the (pixel) position of the slider.\n\n    :attr:`step` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 0.'''\n\n    background_horizontal = StringProperty(\n        'atlas://data/images/defaulttheme/sliderh_background')\n    \"\"\"Background of the slider used in the horizontal orientation.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`background_horizontal` is a :class:`~kivy.properties.StringProperty`\n    and defaults to `atlas://data/images/defaulttheme/sliderh_background`.\n    \"\"\"\n\n    background_disabled_horizontal = StringProperty(\n        'atlas://data/images/defaulttheme/sliderh_background_disabled')\n    \"\"\"Background of the disabled slider used in the horizontal orientation.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`background_disabled_horizontal` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    `atlas://data/images/defaulttheme/sliderh_background_disabled`.\n    \"\"\"\n\n    background_vertical = StringProperty(\n        'atlas://data/images/defaulttheme/sliderv_background')\n    \"\"\"Background of the slider used in the vertical orientation.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`background_vertical` is a :class:`~kivy.properties.StringProperty`\n    and defaults to `atlas://data/images/defaulttheme/sliderv_background`.\n    \"\"\"\n\n    background_disabled_vertical = StringProperty(\n        'atlas://data/images/defaulttheme/sliderv_background_disabled')\n    \"\"\"Background of the disabled slider used in the vertical orientation.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`background_disabled_vertical` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    `atlas://data/images/defaulttheme/sliderv_background_disabled`.\n    \"\"\"\n\n    background_width = NumericProperty('36sp')\n    \"\"\"Slider's background's width (thickness), used in both horizontal\n    and vertical orientations.\n\n    .. versionadded 1.10.0\n\n    :attr:`background_width` is a\n    :class:`~kivy.properties.NumericProperty` and defaults to 36sp.\n    \"\"\"\n\n    cursor_image = StringProperty(\n        'atlas://data/images/defaulttheme/slider_cursor')\n    \"\"\"Path of the image used to draw the slider cursor.\n\n    .. versionadded 1.10.0\n\n    :attr:`cursor_image` is a :class:`~kivy.properties.StringProperty`\n    and defaults to `atlas://data/images/defaulttheme/slider_cursor`.\n    \"\"\"\n\n    cursor_disabled_image = StringProperty(\n        'atlas://data/images/defaulttheme/slider_cursor_disabled')\n    \"\"\"Path of the image used to draw the disabled slider cursor.\n\n    .. versionadded 1.10.0\n\n    :attr:`cursor_image` is a :class:`~kivy.properties.StringProperty`\n    and defaults to `atlas://data/images/defaulttheme/slider_cursor_disabled`.\n    \"\"\"\n\n    cursor_width = NumericProperty('32sp')\n    \"\"\"Width of the cursor image.\n\n    .. versionadded 1.10.0\n\n    :attr:`cursor_width` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 32sp.\n    \"\"\"\n\n    cursor_height = NumericProperty('32sp')\n    \"\"\"Height of the cursor image.\n\n    .. versionadded 1.10.0\n\n    :attr:`cursor_height` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 32sp.\n    \"\"\"\n\n    cursor_size = ReferenceListProperty(cursor_width, cursor_height)\n    \"\"\"Size of the cursor image.\n\n    .. versionadded 1.10.0\n\n    :attr:`cursor_size` is a :class:`~kivy.properties.ReferenceListProperty`\n    of (:attr:`cursor_width`, :attr:`cursor_height`) properties.\n    \"\"\"\n\n    border_horizontal = ListProperty([0, 18, 0, 18])\n    \"\"\"Border used to draw the slider background in horizontal orientation.\n\n    .. versionadded 1.10.0\n\n    :attr:`border_horizontal` is a :class:`~kivy.properties.ListProperty`\n    and defaults to [0, 18, 0, 18].\n    \"\"\"\n\n    border_vertical = ListProperty([18, 0, 18, 0])\n    \"\"\"Border used to draw the slider background in vertical orientation.\n\n    .. versionadded 1.10.0\n\n    :attr:`border_horizontal` is a :class:`~kivy.properties.ListProperty`\n    and defaults to [18, 0, 18, 0].\n    \"\"\"\n\n    value_track = BooleanProperty(False)\n    \"\"\"Decides if slider should draw the line indicating the\n    space between :attr:`min` and :attr:`value` properties values.\n\n    .. versionadded 1.10.0\n\n    :attr:`value_track` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to False.\n    \"\"\"\n\n    value_track_color = ColorProperty([1, 1, 1, 1])\n    \"\"\"Color of the :attr:`value_line` in rgba format.\n\n    .. versionadded 1.10.0\n\n    :attr:`value_track_color` is a :class:`~kivy.properties.ColorProperty`\n    and defaults to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    \"\"\"\n\n    value_track_width = NumericProperty('3dp')\n    \"\"\"Width of the track line.\n\n    .. versionadded 1.10.0\n\n    :attr:`value_track_width` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 3dp.\n    \"\"\"\n\n    sensitivity = OptionProperty('all', options=('all', 'handle'))\n    \"\"\"Whether the touch collides with the whole body of the widget\n    or with the slider handle part only.\n\n    .. versionadded:: 1.10.1\n\n    :attr:`sensitivity` is a :class:`~kivy.properties.OptionProperty`\n    and defaults to 'all'. Can take a value of 'all' or 'handle'.\n    \"\"\"\n\n    # The following two methods constrain the slider's value\n    # to range(min,max). Otherwise it may happen that self.value < self.min\n    # at init.\n\n    def on_min(self, *largs):\n        self.value = min(self.max, max(self.min, self.value))\n\n    def on_max(self, *largs):\n        self.value = min(self.max, max(self.min, self.value))\n\n    def get_norm_value(self):\n        vmin = self.min\n        d = self.max - vmin\n        if d == 0:\n            return 0\n        return (self.value - vmin) / float(d)\n\n    def set_norm_value(self, value):\n        vmin = self.min\n        vmax = self.max\n        step = self.step\n        val = min(value * (vmax - vmin) + vmin, vmax)\n        if step == 0:\n            self.value = val\n        else:\n            self.value = min(round((val - vmin) / step) * step + vmin,\n                             vmax)\n\n    value_normalized = AliasProperty(get_norm_value, set_norm_value,\n                                     bind=('value', 'min', 'max'),\n                                     cache=True)\n    '''Normalized value inside the :attr:`range` (min/max) to 0-1 range::\n\n        >>> slider = Slider(value=50, min=0, max=100)\n        >>> slider.value\n        50\n        >>> slider.value_normalized\n        0.5\n        >>> slider.value = 0\n        >>> slider.value_normalized\n        0\n        >>> slider.value = 100\n        >>> slider.value_normalized\n        1\n\n    You can also use it for setting the real value without knowing the minimum\n    and maximum::\n\n        >>> slider = Slider(min=0, max=200)\n        >>> slider.value_normalized = .5\n        >>> slider.value\n        100\n        >>> slider.value_normalized = 1.\n        >>> slider.value\n        200\n\n    :attr:`value_normalized` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def get_value_pos(self):\n        padding = self.padding\n        x = self.x\n        y = self.y\n        nval = self.value_normalized\n        if self.orientation == 'horizontal':\n            return (x + padding + nval * (self.width - 2 * padding), y)\n        else:\n            return (x, y + padding + nval * (self.height - 2 * padding))\n\n    def set_value_pos(self, pos):\n        padding = self.padding\n        x = min(self.right - padding, max(pos[0], self.x + padding))\n        y = min(self.top - padding, max(pos[1], self.y + padding))\n        if self.orientation == 'horizontal':\n            if self.width == 0:\n                self.value_normalized = 0\n            else:\n                self.value_normalized = (x - self.x - padding\n                                         ) / float(self.width - 2 * padding)\n        else:\n            if self.height == 0:\n                self.value_normalized = 0\n            else:\n                self.value_normalized = (y - self.y - padding\n                                         ) / float(self.height - 2 * padding)\n\n    value_pos = AliasProperty(get_value_pos, set_value_pos,\n                              bind=('pos', 'size', 'min', 'max', 'padding',\n                                    'value_normalized', 'orientation'),\n                              cache=True)\n    '''Position of the internal cursor, based on the normalized value.\n\n    :attr:`value_pos` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def on_touch_down(self, touch):\n        if self.disabled or not self.collide_point(*touch.pos):\n            return\n        if touch.is_mouse_scrolling:\n            if 'down' in touch.button or 'left' in touch.button:\n                if self.step:\n                    self.value = min(self.max, self.value + self.step)\n                else:\n                    self.value = min(\n                        self.max,\n                        self.value + (self.max - self.min) / 20)\n            if 'up' in touch.button or 'right' in touch.button:\n                if self.step:\n                    self.value = max(self.min, self.value - self.step)\n                else:\n                    self.value = max(\n                        self.min,\n                        self.value - (self.max - self.min) / 20)\n        elif self.sensitivity == 'handle':\n            if self.children[0].collide_point(*touch.pos):\n                touch.grab(self)\n        else:\n            touch.grab(self)\n            self.value_pos = touch.pos\n        return True\n\n    def on_touch_move(self, touch):\n        if touch.grab_current == self:\n            self.value_pos = touch.pos\n            return True\n\n    def on_touch_up(self, touch):\n        if touch.grab_current == self:\n            self.value_pos = touch.pos\n            return True",
  "def on_min(self, *largs):\n        self.value = min(self.max, max(self.min, self.value))",
  "def on_max(self, *largs):\n        self.value = min(self.max, max(self.min, self.value))",
  "def get_norm_value(self):\n        vmin = self.min\n        d = self.max - vmin\n        if d == 0:\n            return 0\n        return (self.value - vmin) / float(d)",
  "def set_norm_value(self, value):\n        vmin = self.min\n        vmax = self.max\n        step = self.step\n        val = min(value * (vmax - vmin) + vmin, vmax)\n        if step == 0:\n            self.value = val\n        else:\n            self.value = min(round((val - vmin) / step) * step + vmin,\n                             vmax)",
  "def get_value_pos(self):\n        padding = self.padding\n        x = self.x\n        y = self.y\n        nval = self.value_normalized\n        if self.orientation == 'horizontal':\n            return (x + padding + nval * (self.width - 2 * padding), y)\n        else:\n            return (x, y + padding + nval * (self.height - 2 * padding))",
  "def set_value_pos(self, pos):\n        padding = self.padding\n        x = min(self.right - padding, max(pos[0], self.x + padding))\n        y = min(self.top - padding, max(pos[1], self.y + padding))\n        if self.orientation == 'horizontal':\n            if self.width == 0:\n                self.value_normalized = 0\n            else:\n                self.value_normalized = (x - self.x - padding\n                                         ) / float(self.width - 2 * padding)\n        else:\n            if self.height == 0:\n                self.value_normalized = 0\n            else:\n                self.value_normalized = (y - self.y - padding\n                                         ) / float(self.height - 2 * padding)",
  "def on_touch_down(self, touch):\n        if self.disabled or not self.collide_point(*touch.pos):\n            return\n        if touch.is_mouse_scrolling:\n            if 'down' in touch.button or 'left' in touch.button:\n                if self.step:\n                    self.value = min(self.max, self.value + self.step)\n                else:\n                    self.value = min(\n                        self.max,\n                        self.value + (self.max - self.min) / 20)\n            if 'up' in touch.button or 'right' in touch.button:\n                if self.step:\n                    self.value = max(self.min, self.value - self.step)\n                else:\n                    self.value = max(\n                        self.min,\n                        self.value - (self.max - self.min) / 20)\n        elif self.sensitivity == 'handle':\n            if self.children[0].collide_point(*touch.pos):\n                touch.grab(self)\n        else:\n            touch.grab(self)\n            self.value_pos = touch.pos\n        return True",
  "def on_touch_move(self, touch):\n        if touch.grab_current == self:\n            self.value_pos = touch.pos\n            return True",
  "def on_touch_up(self, touch):\n        if touch.grab_current == self:\n            self.value_pos = touch.pos\n            return True",
  "class SliderApp(App):\n        def build(self):\n            return Slider(padding=25)",
  "def build(self):\n            return Slider(padding=25)",
  "class StencilView(Widget):\n    '''StencilView class. See module documentation for more information.\n    '''\n    pass",
  "class Layout(Widget):\n    '''Layout interface class, used to implement every layout. See module\n    documentation for more information.\n    '''\n\n    _trigger_layout = None\n\n    def __init__(self, **kwargs):\n        if self.__class__ == Layout:\n            raise Exception('The Layout class is abstract and \\\n                cannot be used directly.')\n        if self._trigger_layout is None:\n            self._trigger_layout = Clock.create_trigger(self.do_layout, -1)\n        super(Layout, self).__init__(**kwargs)\n\n    def do_layout(self, *largs):\n        '''This function is called when a layout is called by a trigger.\n        If you are writing a new Layout subclass, don't call this function\n        directly but use :meth:`_trigger_layout` instead.\n\n        The function is by default called *before* the next frame, therefore\n        the layout isn't updated immediately. Anything depending on the\n        positions of e.g. children should be scheduled for the next frame.\n\n        .. versionadded:: 1.0.8\n        '''\n        raise NotImplementedError('Must be implemented in subclasses.')\n\n    def add_widget(self, widget, *args, **kwargs):\n        fbind = widget.fbind\n        fbind('size', self._trigger_layout)\n        fbind('size_hint', self._trigger_layout)\n        fbind('size_hint_max', self._trigger_layout)\n        fbind('size_hint_min', self._trigger_layout)\n        super(Layout, self).add_widget(widget, *args, **kwargs)\n\n    def remove_widget(self, widget, *args, **kwargs):\n        funbind = widget.funbind\n        funbind('size', self._trigger_layout)\n        funbind('size_hint', self._trigger_layout)\n        funbind('size_hint_max', self._trigger_layout)\n        funbind('size_hint_min', self._trigger_layout)\n        super(Layout, self).remove_widget(widget, *args, **kwargs)\n\n    def layout_hint_with_bounds(\n            self, sh_sum, available_space, min_bounded_size, sh_min_vals,\n            sh_max_vals, hint):\n        '''(internal) Computes the appropriate (size) hint for all the\n        widgets given (potential) min or max bounds on the widgets' size.\n        The ``hint`` list is updated with appropriate sizes.\n\n        It walks through the hints and for any widgets whose hint will result\n        in violating min or max constraints, it fixes the hint. Any remaining\n        or missing space after all the widgets are fixed get distributed\n        to the widgets making them smaller or larger according to their\n        size hint.\n\n        This algorithms knows nothing about the widgets other than what is\n        passed through the input params, so it's fairly generic for laying\n        things out according to constraints using size hints.\n\n        :Parameters:\n\n            `sh_sum`: float\n                The sum of the size hints (basically ``sum(size_hint)``).\n            `available_space`: float\n                The amount of pixels available for all the widgets\n                whose size hint is not None. Cannot be zero.\n            `min_bounded_size`: float\n                The minimum amount of space required according to the\n                `size_hint_min` of the widgets (basically\n                ``sum(size_hint_min)``).\n            `sh_min_vals`: list or iterable\n                Items in the iterable are the size_hint_min for each widget.\n                Can be None. The length should be the same as ``hint``\n            `sh_max_vals`: list or iterable\n                Items in the iterable are the size_hint_max for each widget.\n                Can be None. The length should be the same as ``hint``\n            `hint`: list\n                A list whose size is the same as the length of ``sh_min_vals``\n                and ``sh_min_vals`` whose each element is the corresponding\n                size hint value of that element. This list is updated in place\n                with correct size hints that ensure the constraints are not\n                violated.\n\n        :returns:\n            Nothing. ``hint`` is updated in place.\n        '''\n        if not sh_sum:\n            return\n        # TODO: test when children have size_hint, max/min of zero\n\n        # all divs are float denominator ;)\n        stretch_ratio = sh_sum / float(available_space)\n        if available_space <= min_bounded_size or \\\n                isclose(available_space, min_bounded_size):\n            # too small, just set to min\n            for i, (sh, sh_min) in enumerate(zip(hint, sh_min_vals)):\n                if sh is None:\n                    continue\n\n                if sh_min is not None:\n                    hint[i] = sh_min * stretch_ratio  # set to min size\n                else:\n                    hint[i] = 0.  # everything else is zero\n            return\n\n        # these dicts take i (widget child) as key\n        not_mined_contrib = {}  # all who's sh > min_sh or had no min_sh\n        not_maxed_contrib = {}  # all who's sh < max_sh or had no max_sh\n        sh_mins_avail = {}  # the sh amt removable until we hit sh_min\n        sh_maxs_avail = {}  # the sh amt addable until we hit sh_max\n        oversize_amt = undersize_amt = 0\n        hint_orig = hint[:]\n\n        # first, for all the items, set them to be within their max/min\n        # size_hint bound, also find how much their size_hint can be reduced\n        # or increased\n        for i, (sh, sh_min, sh_max) in enumerate(\n                zip(hint, sh_min_vals, sh_max_vals)):\n            if sh is None:\n                continue\n\n            diff = 0\n\n            if sh_min is not None:\n                sh_min *= stretch_ratio\n                diff = sh_min - sh  # how much we are under the min\n\n                if diff > 0:\n                    hint[i] = sh_min\n                    undersize_amt += diff\n                else:\n                    not_mined_contrib[i] = None\n\n                sh_mins_avail[i] = hint[i] - sh_min\n            else:\n                not_mined_contrib[i] = None\n                sh_mins_avail[i] = hint[i]\n\n            if sh_max is not None:\n                sh_max *= stretch_ratio\n                diff = sh - sh_max\n\n                if diff > 0:\n                    hint[i] = sh_max  # how much we are over the max\n                    oversize_amt += diff\n                else:\n                    not_maxed_contrib[i] = None\n\n                sh_maxs_avail[i] = sh_max - hint[i]\n            else:\n                not_maxed_contrib[i] = None\n                sh_maxs_avail[i] = sh_sum - hint[i]\n\n            if i in not_mined_contrib:\n                not_mined_contrib[i] = max(0., diff)  # how much got removed\n            if i in not_maxed_contrib:\n                not_maxed_contrib[i] = max(0., diff)  # how much got added\n\n        # if margin is zero, the amount of the widgets that were made smaller\n        # magically equals the amount of the widgets that were made larger\n        # so we're all good\n        margin = oversize_amt - undersize_amt\n        if isclose(oversize_amt, undersize_amt, abs_tol=1e-15):\n            return\n\n        # we need to redistribute the margin among all widgets\n        # if margin is positive, then we have extra space because the widgets\n        # that were larger and were reduced contributed more, so increase\n        # the size hint for those that are allowed to be larger by the\n        # most allowed, proportionately to their size (or inverse size hint).\n        # similarly for the opposite case\n        if margin > 1e-15:\n            contrib_amt = not_maxed_contrib\n            sh_available = sh_maxs_avail\n            mult = 1.\n            contrib_proportion = hint_orig\n        elif margin < -1e-15:\n            margin *= -1.\n            contrib_amt = not_mined_contrib\n            sh_available = sh_mins_avail\n            mult = -1.\n\n            # when reducing the size of widgets proportionately, those with\n            # larger sh get reduced less, and those with smaller, more.\n            mn = min((h for h in hint_orig if h))\n            mx = max((h for h in hint_orig if h is not None))\n            hint_top = (2. * mn if mn else 1.) if mn == mx else mn + mx\n            contrib_proportion = [None if h is None else hint_top - h for\n                          h in hint_orig]\n\n        # contrib_amt is all the widgets that are not their max/min and\n        # can afford to be made bigger/smaller\n        # We only use the contrib_amt indices from now on\n        contrib_prop_sum = float(\n            sum((contrib_proportion[i] for i in contrib_amt)))\n\n        if contrib_prop_sum < 1e-9:\n            assert mult == 1.  # should only happen when all sh are zero\n            return\n\n        contrib_height = {\n            i: val / (contrib_proportion[i] / contrib_prop_sum) for\n            i, val in contrib_amt.items()}\n        items = sorted(\n            (i for i in contrib_amt),\n            key=lambda x: contrib_height[x])\n\n        j = items[0]\n        sum_i_contributed = contrib_amt[j]\n        last_height = contrib_height[j]\n        sh_available_i = {j: sh_available[j]}\n        contrib_prop_sum_i = contrib_proportion[j]\n\n        n = len(items)  # check when n <= 1\n        i = 1\n        if 1 < n:\n            j = items[1]\n            curr_height = contrib_height[j]\n\n        done = False\n        while not done and i < n:\n            while i < n and last_height == curr_height:\n                j = items[i]\n                sum_i_contributed += contrib_amt[j]\n                contrib_prop_sum_i += contrib_proportion[j]\n                sh_available_i[j] = sh_available[j]\n                curr_height = contrib_height[j]\n                i += 1\n            last_height = curr_height\n\n            while not done:\n                margin_height = ((margin + sum_i_contributed) /\n                                 (contrib_prop_sum_i / contrib_prop_sum))\n                if margin_height - curr_height > 1e-9 and i < n:\n                    break\n\n                done = True\n                for k, available_sh in list(sh_available_i.items()):\n                    if margin_height - available_sh / (\n                            contrib_proportion[k] / contrib_prop_sum) > 1e-9:\n                        del sh_available_i[k]\n                        sum_i_contributed -= contrib_amt[k]\n                        contrib_prop_sum_i -= contrib_proportion[k]\n                        margin -= available_sh\n                        hint[k] += mult * available_sh\n                        done = False\n\n                if not sh_available_i:  # all were under the margin\n                    break\n\n        if sh_available_i:\n            assert contrib_prop_sum_i and margin\n            margin_height = ((margin + sum_i_contributed) /\n                             (contrib_prop_sum_i / contrib_prop_sum))\n            for i in sh_available_i:\n                hint[i] += mult * (\n                    margin_height * contrib_proportion[i] / contrib_prop_sum -\n                    contrib_amt[i])",
  "def __init__(self, **kwargs):\n        if self.__class__ == Layout:\n            raise Exception('The Layout class is abstract and \\\n                cannot be used directly.')\n        if self._trigger_layout is None:\n            self._trigger_layout = Clock.create_trigger(self.do_layout, -1)\n        super(Layout, self).__init__(**kwargs)",
  "def do_layout(self, *largs):\n        '''This function is called when a layout is called by a trigger.\n        If you are writing a new Layout subclass, don't call this function\n        directly but use :meth:`_trigger_layout` instead.\n\n        The function is by default called *before* the next frame, therefore\n        the layout isn't updated immediately. Anything depending on the\n        positions of e.g. children should be scheduled for the next frame.\n\n        .. versionadded:: 1.0.8\n        '''\n        raise NotImplementedError('Must be implemented in subclasses.')",
  "def add_widget(self, widget, *args, **kwargs):\n        fbind = widget.fbind\n        fbind('size', self._trigger_layout)\n        fbind('size_hint', self._trigger_layout)\n        fbind('size_hint_max', self._trigger_layout)\n        fbind('size_hint_min', self._trigger_layout)\n        super(Layout, self).add_widget(widget, *args, **kwargs)",
  "def remove_widget(self, widget, *args, **kwargs):\n        funbind = widget.funbind\n        funbind('size', self._trigger_layout)\n        funbind('size_hint', self._trigger_layout)\n        funbind('size_hint_max', self._trigger_layout)\n        funbind('size_hint_min', self._trigger_layout)\n        super(Layout, self).remove_widget(widget, *args, **kwargs)",
  "def layout_hint_with_bounds(\n            self, sh_sum, available_space, min_bounded_size, sh_min_vals,\n            sh_max_vals, hint):\n        '''(internal) Computes the appropriate (size) hint for all the\n        widgets given (potential) min or max bounds on the widgets' size.\n        The ``hint`` list is updated with appropriate sizes.\n\n        It walks through the hints and for any widgets whose hint will result\n        in violating min or max constraints, it fixes the hint. Any remaining\n        or missing space after all the widgets are fixed get distributed\n        to the widgets making them smaller or larger according to their\n        size hint.\n\n        This algorithms knows nothing about the widgets other than what is\n        passed through the input params, so it's fairly generic for laying\n        things out according to constraints using size hints.\n\n        :Parameters:\n\n            `sh_sum`: float\n                The sum of the size hints (basically ``sum(size_hint)``).\n            `available_space`: float\n                The amount of pixels available for all the widgets\n                whose size hint is not None. Cannot be zero.\n            `min_bounded_size`: float\n                The minimum amount of space required according to the\n                `size_hint_min` of the widgets (basically\n                ``sum(size_hint_min)``).\n            `sh_min_vals`: list or iterable\n                Items in the iterable are the size_hint_min for each widget.\n                Can be None. The length should be the same as ``hint``\n            `sh_max_vals`: list or iterable\n                Items in the iterable are the size_hint_max for each widget.\n                Can be None. The length should be the same as ``hint``\n            `hint`: list\n                A list whose size is the same as the length of ``sh_min_vals``\n                and ``sh_min_vals`` whose each element is the corresponding\n                size hint value of that element. This list is updated in place\n                with correct size hints that ensure the constraints are not\n                violated.\n\n        :returns:\n            Nothing. ``hint`` is updated in place.\n        '''\n        if not sh_sum:\n            return\n        # TODO: test when children have size_hint, max/min of zero\n\n        # all divs are float denominator ;)\n        stretch_ratio = sh_sum / float(available_space)\n        if available_space <= min_bounded_size or \\\n                isclose(available_space, min_bounded_size):\n            # too small, just set to min\n            for i, (sh, sh_min) in enumerate(zip(hint, sh_min_vals)):\n                if sh is None:\n                    continue\n\n                if sh_min is not None:\n                    hint[i] = sh_min * stretch_ratio  # set to min size\n                else:\n                    hint[i] = 0.  # everything else is zero\n            return\n\n        # these dicts take i (widget child) as key\n        not_mined_contrib = {}  # all who's sh > min_sh or had no min_sh\n        not_maxed_contrib = {}  # all who's sh < max_sh or had no max_sh\n        sh_mins_avail = {}  # the sh amt removable until we hit sh_min\n        sh_maxs_avail = {}  # the sh amt addable until we hit sh_max\n        oversize_amt = undersize_amt = 0\n        hint_orig = hint[:]\n\n        # first, for all the items, set them to be within their max/min\n        # size_hint bound, also find how much their size_hint can be reduced\n        # or increased\n        for i, (sh, sh_min, sh_max) in enumerate(\n                zip(hint, sh_min_vals, sh_max_vals)):\n            if sh is None:\n                continue\n\n            diff = 0\n\n            if sh_min is not None:\n                sh_min *= stretch_ratio\n                diff = sh_min - sh  # how much we are under the min\n\n                if diff > 0:\n                    hint[i] = sh_min\n                    undersize_amt += diff\n                else:\n                    not_mined_contrib[i] = None\n\n                sh_mins_avail[i] = hint[i] - sh_min\n            else:\n                not_mined_contrib[i] = None\n                sh_mins_avail[i] = hint[i]\n\n            if sh_max is not None:\n                sh_max *= stretch_ratio\n                diff = sh - sh_max\n\n                if diff > 0:\n                    hint[i] = sh_max  # how much we are over the max\n                    oversize_amt += diff\n                else:\n                    not_maxed_contrib[i] = None\n\n                sh_maxs_avail[i] = sh_max - hint[i]\n            else:\n                not_maxed_contrib[i] = None\n                sh_maxs_avail[i] = sh_sum - hint[i]\n\n            if i in not_mined_contrib:\n                not_mined_contrib[i] = max(0., diff)  # how much got removed\n            if i in not_maxed_contrib:\n                not_maxed_contrib[i] = max(0., diff)  # how much got added\n\n        # if margin is zero, the amount of the widgets that were made smaller\n        # magically equals the amount of the widgets that were made larger\n        # so we're all good\n        margin = oversize_amt - undersize_amt\n        if isclose(oversize_amt, undersize_amt, abs_tol=1e-15):\n            return\n\n        # we need to redistribute the margin among all widgets\n        # if margin is positive, then we have extra space because the widgets\n        # that were larger and were reduced contributed more, so increase\n        # the size hint for those that are allowed to be larger by the\n        # most allowed, proportionately to their size (or inverse size hint).\n        # similarly for the opposite case\n        if margin > 1e-15:\n            contrib_amt = not_maxed_contrib\n            sh_available = sh_maxs_avail\n            mult = 1.\n            contrib_proportion = hint_orig\n        elif margin < -1e-15:\n            margin *= -1.\n            contrib_amt = not_mined_contrib\n            sh_available = sh_mins_avail\n            mult = -1.\n\n            # when reducing the size of widgets proportionately, those with\n            # larger sh get reduced less, and those with smaller, more.\n            mn = min((h for h in hint_orig if h))\n            mx = max((h for h in hint_orig if h is not None))\n            hint_top = (2. * mn if mn else 1.) if mn == mx else mn + mx\n            contrib_proportion = [None if h is None else hint_top - h for\n                          h in hint_orig]\n\n        # contrib_amt is all the widgets that are not their max/min and\n        # can afford to be made bigger/smaller\n        # We only use the contrib_amt indices from now on\n        contrib_prop_sum = float(\n            sum((contrib_proportion[i] for i in contrib_amt)))\n\n        if contrib_prop_sum < 1e-9:\n            assert mult == 1.  # should only happen when all sh are zero\n            return\n\n        contrib_height = {\n            i: val / (contrib_proportion[i] / contrib_prop_sum) for\n            i, val in contrib_amt.items()}\n        items = sorted(\n            (i for i in contrib_amt),\n            key=lambda x: contrib_height[x])\n\n        j = items[0]\n        sum_i_contributed = contrib_amt[j]\n        last_height = contrib_height[j]\n        sh_available_i = {j: sh_available[j]}\n        contrib_prop_sum_i = contrib_proportion[j]\n\n        n = len(items)  # check when n <= 1\n        i = 1\n        if 1 < n:\n            j = items[1]\n            curr_height = contrib_height[j]\n\n        done = False\n        while not done and i < n:\n            while i < n and last_height == curr_height:\n                j = items[i]\n                sum_i_contributed += contrib_amt[j]\n                contrib_prop_sum_i += contrib_proportion[j]\n                sh_available_i[j] = sh_available[j]\n                curr_height = contrib_height[j]\n                i += 1\n            last_height = curr_height\n\n            while not done:\n                margin_height = ((margin + sum_i_contributed) /\n                                 (contrib_prop_sum_i / contrib_prop_sum))\n                if margin_height - curr_height > 1e-9 and i < n:\n                    break\n\n                done = True\n                for k, available_sh in list(sh_available_i.items()):\n                    if margin_height - available_sh / (\n                            contrib_proportion[k] / contrib_prop_sum) > 1e-9:\n                        del sh_available_i[k]\n                        sum_i_contributed -= contrib_amt[k]\n                        contrib_prop_sum_i -= contrib_proportion[k]\n                        margin -= available_sh\n                        hint[k] += mult * available_sh\n                        done = False\n\n                if not sh_available_i:  # all were under the margin\n                    break\n\n        if sh_available_i:\n            assert contrib_prop_sum_i and margin\n            margin_height = ((margin + sum_i_contributed) /\n                             (contrib_prop_sum_i / contrib_prop_sum))\n            for i in sh_available_i:\n                hint[i] += mult * (\n                    margin_height * contrib_proportion[i] / contrib_prop_sum -\n                    contrib_amt[i])",
  "class ModalView(AnchorLayout):\n    \"\"\"ModalView class. See module documentation for more information.\n\n    :Events:\n        `on_pre_open`:\n            Fired before the ModalView is opened. When this event is fired\n            ModalView is not yet added to window.\n        `on_open`:\n            Fired when the ModalView is opened.\n        `on_pre_dismiss`:\n            Fired before the ModalView is closed.\n        `on_dismiss`:\n            Fired when the ModalView is closed. If the callback returns True,\n            the dismiss will be canceled.\n\n    .. versionchanged:: 1.11.0\n        Added events `on_pre_open` and `on_pre_dismiss`.\n\n    .. versionchanged:: 2.0.0\n        Added property 'overlay_color'.\n\n    .. versionchanged:: 2.1.0\n        Marked `attach_to` property as deprecated.\n\n    \"\"\"\n\n    # noinspection PyArgumentEqualDefault\n    auto_dismiss = BooleanProperty(True)\n    '''This property determines if the view is automatically\n    dismissed when the user clicks outside it.\n\n    :attr:`auto_dismiss` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    attach_to = ObjectProperty(None, deprecated=True)\n    '''If a widget is set on attach_to, the view will attach to the nearest\n    parent window of the widget. If none is found, it will attach to the\n    main/global Window.\n\n    :attr:`attach_to` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    background_color = ColorProperty([1, 1, 1, 1])\n    '''Background color, in the format (r, g, b, a).\n\n    This acts as a *multiplier* to the texture color. The default\n    texture is grey, so just setting the background color will give\n    a darker result. To set a plain color, set the\n    :attr:`background_normal` to ``''``.\n\n    The :attr:`background_color` is a\n    :class:`~kivy.properties.ColorProperty` and defaults to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed behavior to affect the background of the widget itself, not\n        the overlay dimming.\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    background = StringProperty(\n        'atlas://data/images/defaulttheme/modalview-background')\n    '''Background image of the view used for the view background.\n\n    :attr:`background` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/modalview-background'.\n    '''\n\n    border = ListProperty([16, 16, 16, 16])\n    '''Border used for :class:`~kivy.graphics.vertex_instructions.BorderImage`\n    graphics instruction. Used for the :attr:`background_normal` and the\n    :attr:`background_down` properties. Can be used when using custom\n    backgrounds.\n\n    It must be a list of four values: (bottom, right, top, left). Read the\n    BorderImage instructions for more information about how to use it.\n\n    :attr:`border` is a :class:`~kivy.properties.ListProperty` and defaults to\n    (16, 16, 16, 16).\n    '''\n\n    overlay_color = ColorProperty([0, 0, 0, .7])\n    '''Overlay color in the format (r, g, b, a).\n    Used for dimming the window behind the modal view.\n\n    :attr:`overlay_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [0, 0, 0, .7].\n\n    .. versionadded:: 2.0.0\n    '''\n\n    # Internals properties used for graphical representation.\n\n    _anim_alpha = NumericProperty(0)\n\n    _anim_duration = NumericProperty(.1)\n\n    _window = ObjectProperty(allownone=True, rebind=True)\n\n    _is_open = BooleanProperty(False)\n\n    _touch_started_inside = None\n\n    __events__ = ('on_pre_open', 'on_open', 'on_pre_dismiss', 'on_dismiss')\n\n    def __init__(self, **kwargs):\n        self._parent = None\n        super(ModalView, self).__init__(**kwargs)\n\n    def open(self, *_args, **kwargs):\n        \"\"\"Display the modal in the Window.\n\n        When the view is opened, it will be faded in with an animation. If you\n        don't want the animation, use::\n\n            view.open(animation=False)\n\n        \"\"\"\n        from kivy.core.window import Window\n        if self._is_open:\n            return\n        self._window = Window\n        self._is_open = True\n        self.dispatch('on_pre_open')\n        Window.add_widget(self)\n        Window.bind(\n            on_resize=self._align_center,\n            on_keyboard=self._handle_keyboard)\n        self.center = Window.center\n        self.fbind('center', self._align_center)\n        self.fbind('size', self._align_center)\n        if kwargs.get('animation', True):\n            ani = Animation(_anim_alpha=1., d=self._anim_duration)\n            ani.bind(on_complete=lambda *_args: self.dispatch('on_open'))\n            ani.start(self)\n        else:\n            self._anim_alpha = 1.\n            self.dispatch('on_open')\n\n    def dismiss(self, *_args, **kwargs):\n        \"\"\" Close the view if it is open.\n\n        If you really want to close the view, whatever the on_dismiss\n        event returns, you can use the *force* keyword argument::\n\n            view = ModalView()\n            view.dismiss(force=True)\n\n        When the view is dismissed, it will be faded out before being\n        removed from the parent. If you don't want this animation, use::\n\n            view.dismiss(animation=False)\n\n        \"\"\"\n        if not self._is_open:\n            return\n        self.dispatch('on_pre_dismiss')\n        if self.dispatch('on_dismiss') is True:\n            if kwargs.get('force', False) is not True:\n                return\n        if kwargs.get('animation', True):\n            Animation(_anim_alpha=0., d=self._anim_duration).start(self)\n        else:\n            self._anim_alpha = 0\n            self._real_remove_widget()\n\n    def _align_center(self, *_args):\n        if self._is_open:\n            self.center = self._window.center\n\n    def on_motion(self, etype, me):\n        super().on_motion(etype, me)\n        return True\n\n    def on_touch_down(self, touch):\n        \"\"\" touch down event handler. \"\"\"\n        self._touch_started_inside = self.collide_point(*touch.pos)\n        if not self.auto_dismiss or self._touch_started_inside:\n            super().on_touch_down(touch)\n        return True\n\n    def on_touch_move(self, touch):\n        \"\"\" touch moved event handler. \"\"\"\n        if not self.auto_dismiss or self._touch_started_inside:\n            super().on_touch_move(touch)\n        return True\n\n    def on_touch_up(self, touch):\n        \"\"\" touch up event handler. \"\"\"\n        # Explicitly test for False as None occurs when shown by on_touch_down\n        if self.auto_dismiss and self._touch_started_inside is False:\n            self.dismiss()\n        else:\n            super().on_touch_up(touch)\n        self._touch_started_inside = None\n        return True\n\n    def on__anim_alpha(self, _instance, value):\n        \"\"\" animation progress callback. \"\"\"\n        if value == 0 and self._is_open:\n            self._real_remove_widget()\n\n    def _real_remove_widget(self):\n        if not self._is_open:\n            return\n        self._window.remove_widget(self)\n        self._window.unbind(\n            on_resize=self._align_center,\n            on_keyboard=self._handle_keyboard)\n        self._is_open = False\n        self._window = None\n\n    def on_pre_open(self):\n        \"\"\" default pre-open event handler. \"\"\"\n\n    def on_open(self):\n        \"\"\" default open event handler. \"\"\"\n\n    def on_pre_dismiss(self):\n        \"\"\" default pre-dismiss event handler. \"\"\"\n\n    def on_dismiss(self):\n        \"\"\" default dismiss event handler. \"\"\"\n\n    def _handle_keyboard(self, _window, key, *_args):\n        if key == 27 and self.auto_dismiss:\n            self.dismiss()\n            return True",
  "def __init__(self, **kwargs):\n        self._parent = None\n        super(ModalView, self).__init__(**kwargs)",
  "def open(self, *_args, **kwargs):\n        \"\"\"Display the modal in the Window.\n\n        When the view is opened, it will be faded in with an animation. If you\n        don't want the animation, use::\n\n            view.open(animation=False)\n\n        \"\"\"\n        from kivy.core.window import Window\n        if self._is_open:\n            return\n        self._window = Window\n        self._is_open = True\n        self.dispatch('on_pre_open')\n        Window.add_widget(self)\n        Window.bind(\n            on_resize=self._align_center,\n            on_keyboard=self._handle_keyboard)\n        self.center = Window.center\n        self.fbind('center', self._align_center)\n        self.fbind('size', self._align_center)\n        if kwargs.get('animation', True):\n            ani = Animation(_anim_alpha=1., d=self._anim_duration)\n            ani.bind(on_complete=lambda *_args: self.dispatch('on_open'))\n            ani.start(self)\n        else:\n            self._anim_alpha = 1.\n            self.dispatch('on_open')",
  "def dismiss(self, *_args, **kwargs):\n        \"\"\" Close the view if it is open.\n\n        If you really want to close the view, whatever the on_dismiss\n        event returns, you can use the *force* keyword argument::\n\n            view = ModalView()\n            view.dismiss(force=True)\n\n        When the view is dismissed, it will be faded out before being\n        removed from the parent. If you don't want this animation, use::\n\n            view.dismiss(animation=False)\n\n        \"\"\"\n        if not self._is_open:\n            return\n        self.dispatch('on_pre_dismiss')\n        if self.dispatch('on_dismiss') is True:\n            if kwargs.get('force', False) is not True:\n                return\n        if kwargs.get('animation', True):\n            Animation(_anim_alpha=0., d=self._anim_duration).start(self)\n        else:\n            self._anim_alpha = 0\n            self._real_remove_widget()",
  "def _align_center(self, *_args):\n        if self._is_open:\n            self.center = self._window.center",
  "def on_motion(self, etype, me):\n        super().on_motion(etype, me)\n        return True",
  "def on_touch_down(self, touch):\n        \"\"\" touch down event handler. \"\"\"\n        self._touch_started_inside = self.collide_point(*touch.pos)\n        if not self.auto_dismiss or self._touch_started_inside:\n            super().on_touch_down(touch)\n        return True",
  "def on_touch_move(self, touch):\n        \"\"\" touch moved event handler. \"\"\"\n        if not self.auto_dismiss or self._touch_started_inside:\n            super().on_touch_move(touch)\n        return True",
  "def on_touch_up(self, touch):\n        \"\"\" touch up event handler. \"\"\"\n        # Explicitly test for False as None occurs when shown by on_touch_down\n        if self.auto_dismiss and self._touch_started_inside is False:\n            self.dismiss()\n        else:\n            super().on_touch_up(touch)\n        self._touch_started_inside = None\n        return True",
  "def on__anim_alpha(self, _instance, value):\n        \"\"\" animation progress callback. \"\"\"\n        if value == 0 and self._is_open:\n            self._real_remove_widget()",
  "def _real_remove_widget(self):\n        if not self._is_open:\n            return\n        self._window.remove_widget(self)\n        self._window.unbind(\n            on_resize=self._align_center,\n            on_keyboard=self._handle_keyboard)\n        self._is_open = False\n        self._window = None",
  "def on_pre_open(self):\n        \"\"\" default pre-open event handler. \"\"\"",
  "def on_open(self):\n        \"\"\" default open event handler. \"\"\"",
  "def on_pre_dismiss(self):\n        \"\"\" default pre-dismiss event handler. \"\"\"",
  "def on_dismiss(self):\n        \"\"\" default dismiss event handler. \"\"\"",
  "def _handle_keyboard(self, _window, key, *_args):\n        if key == 27 and self.auto_dismiss:\n            self.dismiss()\n            return True",
  "class VKeyboard(Scatter):\n    '''\n    VKeyboard is an onscreen keyboard with multitouch support.\n    Its layout is entirely customizable and you can switch between available\n    layouts using a button in the bottom right of the widget.\n\n    :Events:\n        `on_key_down`: keycode, internal, modifiers\n            Fired when the keyboard received a key down event (key press).\n        `on_key_up`: keycode, internal, modifiers\n            Fired when the keyboard received a key up event (key release).\n    '''\n\n    target = ObjectProperty(None, allownone=True)\n    '''Target widget associated with the VKeyboard. If set, it will be used to\n    send keyboard events. If the VKeyboard mode is \"free\", it will also be used\n    to set the initial position.\n\n    :attr:`target` is an :class:`~kivy.properties.ObjectProperty` instance and\n    defaults to None.\n    '''\n\n    callback = ObjectProperty(None, allownone=True)\n    '''Callback can be set to a function that will be called if the\n    VKeyboard is closed by the user.\n\n    :attr:`target` is an :class:`~kivy.properties.ObjectProperty` instance and\n    defaults to None.\n    '''\n\n    layout = StringProperty(None)\n    '''Layout to use for the VKeyboard. By default, it will be the\n    layout set in the configuration, according to the `keyboard_layout`\n    in `[kivy]` section.\n\n    .. versionchanged:: 1.8.0\n        If layout is a .json filename, it will loaded and added to the\n        available_layouts.\n\n    :attr:`layout` is a :class:`~kivy.properties.StringProperty` and defaults\n    to None.\n    '''\n\n    layout_path = StringProperty(default_layout_path)\n    '''Path from which layouts are read.\n\n    :attr:`layout` is a :class:`~kivy.properties.StringProperty` and\n    defaults to :file:`<kivy_data_dir>/keyboards/`\n    '''\n\n    available_layouts = DictProperty({})\n    '''Dictionary of all available layouts. Keys are the layout ID, and the\n    value is the JSON (translated into a Python object).\n\n    :attr:`available_layouts` is a :class:`~kivy.properties.DictProperty` and\n    defaults to {}.\n    '''\n\n    docked = BooleanProperty(False)\n    '''Indicate whether the VKeyboard is docked on the screen or not. If you\n    change it, you must manually call :meth:`setup_mode` otherwise it will have\n    no impact. If the VKeyboard is created by the Window, the docked mode will\n    be automatically set by the configuration, using the `keyboard_mode` token\n    in `[kivy]` section.\n\n    :attr:`docked` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    margin_hint = ListProperty([.05, .06, .05, .06])\n    '''Margin hint, used as spacing between keyboard background and keys\n    content. The margin is composed of four values, between 0 and 1::\n\n        margin_hint = [top, right, bottom, left]\n\n    The margin hints will be multiplied by width and height, according to their\n    position.\n\n    :attr:`margin_hint` is a :class:`~kivy.properties.ListProperty` and\n    defaults to [.05, .06, .05, .06]\n    '''\n\n    key_margin = ListProperty([2, 2, 2, 2])\n    '''Key margin, used to create space between keys. The margin is composed of\n    four values, in pixels::\n\n        key_margin = [top, right, bottom, left]\n\n    :attr:`key_margin` is a :class:`~kivy.properties.ListProperty` and defaults\n    to [2, 2, 2, 2]\n    '''\n\n    font_size = NumericProperty(20.)\n    '''font_size, specifies the size of the text on the virtual keyboard keys.\n    It should be kept within limits to ensure the text does not extend beyond\n    the bounds of the key or become too small to read.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`font_size` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 20.\n    '''\n\n    background_color = ColorProperty([1, 1, 1, 1])\n    '''Background color, in the format (r, g, b, a). If a background is\n    set, the color will be combined with the background texture.\n\n    :attr:`background_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    background = StringProperty(\n        'atlas://data/images/defaulttheme/vkeyboard_background')\n    '''Filename of the background image.\n\n    :attr:`background` is a :class:`~kivy.properties.StringProperty` and\n    defaults to :file:`atlas://data/images/defaulttheme/vkeyboard_background`.\n    '''\n\n    background_disabled = StringProperty(\n        'atlas://data/images/defaulttheme/vkeyboard_disabled_background')\n    '''Filename of the background image when the vkeyboard is disabled.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`background_disabled` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    :file:`atlas://data/images/defaulttheme/vkeyboard__disabled_background`.\n\n    '''\n\n    key_background_color = ColorProperty([1, 1, 1, 1])\n    '''Key background color, in the format (r, g, b, a). If a key background is\n    set, the color will be combined with the key background texture.\n\n    :attr:`key_background_color` is a :class:`~kivy.properties.ColorProperty`\n    and defaults to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    key_background_normal = StringProperty(\n        'atlas://data/images/defaulttheme/vkeyboard_key_normal')\n    '''Filename of the key background image for use when no touches are active\n    on the widget.\n\n    :attr:`key_background_normal` is a :class:`~kivy.properties.StringProperty`\n    and defaults to\n    :file:`atlas://data/images/defaulttheme/vkeyboard_key_normal`.\n    '''\n\n    key_disabled_background_normal = StringProperty(\n        'atlas://data/images/defaulttheme/vkeyboard_key_normal')\n    '''Filename of the key background image for use when no touches are active\n    on the widget and vkeyboard is disabled.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`key_disabled_background_normal` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    :file:`atlas://data/images/defaulttheme/vkeyboard_disabled_key_normal`.\n\n    '''\n\n    key_background_down = StringProperty(\n        'atlas://data/images/defaulttheme/vkeyboard_key_down')\n    '''Filename of the key background image for use when a touch is active\n    on the widget.\n\n    :attr:`key_background_down` is a :class:`~kivy.properties.StringProperty`\n    and defaults to\n    :file:`atlas://data/images/defaulttheme/vkeyboard_key_down`.\n    '''\n\n    background_border = ListProperty([16, 16, 16, 16])\n    '''Background image border. Used for controlling the\n    :attr:`~kivy.graphics.vertex_instructions.BorderImage.border` property of\n    the background.\n\n    :attr:`background_border` is a :class:`~kivy.properties.ListProperty` and\n    defaults to [16, 16, 16, 16]\n    '''\n\n    key_border = ListProperty([8, 8, 8, 8])\n    '''Key image border. Used for controlling the\n    :attr:`~kivy.graphics.vertex_instructions.BorderImage.border` property of\n    the key.\n\n    :attr:`key_border` is a :class:`~kivy.properties.ListProperty` and\n    defaults to [16, 16, 16, 16]\n    '''\n\n    # XXX internal variables\n    layout_mode = OptionProperty('normal',\n        options=('normal', 'shift', 'special'))\n    layout_geometry = DictProperty({})\n    have_capslock = BooleanProperty(False)\n    have_shift = BooleanProperty(False)\n    have_special = BooleanProperty(False)\n    active_keys = DictProperty({})\n    font_name = StringProperty('data/fonts/DejaVuSans.ttf')\n    repeat_touch = ObjectProperty(allownone=True)\n\n    _start_repeat_key_ev = None\n    _repeat_key_ev = None\n\n    __events__ = ('on_key_down', 'on_key_up', 'on_textinput')\n\n    def __init__(self, **kwargs):\n        # XXX move to style.kv\n        if 'size_hint' not in kwargs:\n            if 'size_hint_x' not in kwargs:\n                self.size_hint_x = None\n            if 'size_hint_y' not in kwargs:\n                self.size_hint_y = None\n        if 'size' not in kwargs:\n            if 'width' not in kwargs:\n                self.width = 700\n            if 'height' not in kwargs:\n                self.height = 200\n        if 'scale_min' not in kwargs:\n            self.scale_min = .4\n        if 'scale_max' not in kwargs:\n            self.scale_max = 1.6\n        if 'docked' not in kwargs:\n            self.docked = False\n\n        layout_mode = self._trigger_update_layout_mode = Clock.create_trigger(\n            self._update_layout_mode)\n        layouts = self._trigger_load_layouts = Clock.create_trigger(\n            self._load_layouts)\n        layout = self._trigger_load_layout = Clock.create_trigger(\n            self._load_layout)\n        fbind = self.fbind\n\n        fbind('docked', self.setup_mode)\n        fbind('have_shift', layout_mode)\n        fbind('have_capslock', layout_mode)\n        fbind('have_special', layout_mode)\n        fbind('layout_path', layouts)\n        fbind('layout', layout)\n        super(VKeyboard, self).__init__(**kwargs)\n\n        # load all the layouts found in the layout_path directory\n        self._load_layouts()\n\n        # ensure we have default layouts\n        available_layouts = self.available_layouts\n        if not available_layouts:\n            Logger.critical('VKeyboard: unable to load default layouts')\n\n        # load the default layout from configuration\n        if self.layout is None:\n            self.layout = Config.get('kivy', 'keyboard_layout')\n        else:\n            # ensure the current layout is found on the available layout\n            self._trigger_load_layout()\n\n        # update layout mode (shift or normal)\n        self._trigger_update_layout_mode()\n\n        # create a top layer to draw active keys on\n        with self.canvas:\n            self.background_key_layer = Canvas()\n            self.active_keys_layer = Canvas()\n\n    def on_disabled(self, instance, value):\n        self.refresh_keys()\n\n    def _update_layout_mode(self, *l):\n        # update mode according to capslock and shift key\n        mode = self.have_capslock != self.have_shift\n        mode = 'shift' if mode else 'normal'\n        if self.have_special:\n            mode = \"special\"\n        if mode != self.layout_mode:\n            self.layout_mode = mode\n            self.refresh(False)\n\n    def _load_layout(self, *largs):\n        # ensure new layouts are loaded first\n        if self._trigger_load_layouts.is_triggered:\n            self._load_layouts()\n            self._trigger_load_layouts.cancel()\n\n        value = self.layout\n        available_layouts = self.available_layouts\n\n        # it's a filename, try to load it directly\n        if self.layout[-5:] == '.json':\n            if value not in available_layouts:\n                fn = resource_find(self.layout)\n                self._load_layout_fn(fn, self.layout)\n\n        if not available_layouts:\n            return\n        if value not in available_layouts and value != 'qwerty':\n            Logger.error(\n                'Vkeyboard: <%s> keyboard layout mentioned in '\n                'conf file was not found, fallback on qwerty' %\n                value)\n            self.layout = 'qwerty'\n        self.refresh(True)\n\n    def _load_layouts(self, *largs):\n        # first load available layouts from json files\n        # XXX fix to be able to reload layout when path is changing\n        value = self.layout_path\n        for fn in listdir(value):\n            self._load_layout_fn(join(value, fn),\n                                 basename(splitext(fn)[0]))\n\n    def _load_layout_fn(self, fn, name):\n        available_layouts = self.available_layouts\n        if fn[-5:] != '.json':\n            return\n        with open(fn, 'r', encoding='utf-8') as fd:\n            json_content = fd.read()\n            layout = loads(json_content)\n        available_layouts[name] = layout\n\n    def setup_mode(self, *largs):\n        '''Call this method when you want to readjust the keyboard according to\n        options: :attr:`docked` or not, with attached :attr:`target` or not:\n\n        * If :attr:`docked` is True, it will call :meth:`setup_mode_dock`\n        * If :attr:`docked` is False, it will call :meth:`setup_mode_free`\n\n        Feel free to overload these methods to create new\n        positioning behavior.\n        '''\n        if self.docked:\n            self.setup_mode_dock()\n        else:\n            self.setup_mode_free()\n\n    def setup_mode_dock(self, *largs):\n        '''Setup the keyboard in docked mode.\n\n        Dock mode will reset the rotation, disable translation, rotation and\n        scale. Scale and position will be automatically adjusted to attach the\n        keyboard to the bottom of the screen.\n\n        .. note::\n            Don't call this method directly, use :meth:`setup_mode` instead.\n        '''\n        self.do_translation = False\n        self.do_rotation = False\n        self.do_scale = False\n        self.rotation = 0\n        win = self.get_parent_window()\n        scale = win.width / float(self.width)\n        self.scale = scale\n        self.pos = 0, 0\n        win.bind(on_resize=self._update_dock_mode)\n\n    def _update_dock_mode(self, win, *largs):\n        scale = win.width / float(self.width)\n        self.scale = scale\n        self.pos = 0, 0\n\n    def setup_mode_free(self):\n        '''Setup the keyboard in free mode.\n\n        Free mode is designed to let the user control the position and\n        orientation of the keyboard. The only real usage is for a multiuser\n        environment, but you might found other ways to use it.\n        If a :attr:`target` is set, it will place the vkeyboard under the\n        target.\n\n        .. note::\n            Don't call this method directly, use :meth:`setup_mode` instead.\n        '''\n        self.do_translation = True\n        self.do_rotation = True\n        self.do_scale = True\n        target = self.target\n        if not target:\n            return\n\n        # NOTE all math will be done in window point of view\n        # determine rotation of the target\n        a = Vector(1, 0)\n        b = Vector(target.to_window(0, 0))\n        c = Vector(target.to_window(1, 0)) - b\n        self.rotation = -a.angle(c)\n\n        # determine the position of center/top of the keyboard\n        dpos = Vector(self.to_window(self.width / 2., self.height))\n\n        # determine the position of center/bottom of the target\n        cpos = Vector(target.to_window(target.center_x, target.y))\n\n        # the goal now is to map both point, calculate the diff between them\n        diff = dpos - cpos\n\n        # we still have an issue, self.pos represent the bounding box,\n        # not the 0,0 coordinate of the scatter. we need to apply also\n        # the diff between them (inside and outside coordinate matrix).\n        # It's hard to explain, but do a scheme on a paper, write all\n        # the vector i'm calculating, and you'll understand. :)\n        diff2 = Vector(self.x + self.width / 2., self.y + self.height) - \\\n            Vector(self.to_parent(self.width / 2., self.height))\n        diff -= diff2\n\n        # now we have a good \"diff\", set it as a pos.\n        self.pos = -diff\n\n    def change_layout(self):\n        # XXX implement popup with all available layouts\n        pass\n\n    def refresh(self, force=False):\n        '''(internal) Recreate the entire widget and graphics according to the\n        selected layout.\n        '''\n        self.clear_widgets()\n        if force:\n            self.refresh_keys_hint()\n        self.refresh_keys()\n        self.refresh_active_keys_layer()\n\n    def refresh_active_keys_layer(self):\n        self.active_keys_layer.clear()\n\n        active_keys = self.active_keys\n        layout_geometry = self.layout_geometry\n        background = resource_find(self.key_background_down)\n        texture = Image(background, mipmap=True).texture\n\n        with self.active_keys_layer:\n            Color(*self.key_background_color)\n            for line_nb, index in active_keys.values():\n                pos, size = layout_geometry['LINE_%d' % line_nb][index]\n                BorderImage(texture=texture, pos=pos, size=size,\n                            border=self.key_border)\n\n    def refresh_keys_hint(self):\n        layout = self.available_layouts[self.layout]\n        layout_cols = layout['cols']\n        layout_rows = layout['rows']\n        layout_geometry = self.layout_geometry\n        mtop, mright, mbottom, mleft = self.margin_hint\n\n        # get relative EFFICIENT surface of the layout without external margins\n        el_hint = 1. - mleft - mright\n        eh_hint = 1. - mtop - mbottom\n        ex_hint = 0 + mleft\n        ey_hint = 0 + mbottom\n\n        # get relative unit surface\n        uw_hint = (1. / layout_cols) * el_hint\n        uh_hint = (1. / layout_rows) * eh_hint\n        layout_geometry['U_HINT'] = (uw_hint, uh_hint)\n\n        # calculate individual key RELATIVE surface and pos (without key\n        # margin)\n        current_y_hint = ey_hint + eh_hint\n        for line_nb in range(1, layout_rows + 1):\n            current_y_hint -= uh_hint\n            # get line_name\n            line_name = '%s_%d' % (self.layout_mode, line_nb)\n            line_hint = 'LINE_HINT_%d' % line_nb\n            layout_geometry[line_hint] = []\n            current_x_hint = ex_hint\n            # go through the list of keys (tuples of 4)\n            for key in layout[line_name]:\n                # calculate relative pos, size\n                layout_geometry[line_hint].append([\n                    (current_x_hint, current_y_hint),\n                    (key[3] * uw_hint, uh_hint)])\n                current_x_hint += key[3] * uw_hint\n\n        self.layout_geometry = layout_geometry\n\n    def refresh_keys(self):\n        layout = self.available_layouts[self.layout]\n        layout_rows = layout['rows']\n        layout_geometry = self.layout_geometry\n        w, h = self.size\n        kmtop, kmright, kmbottom, kmleft = self.key_margin\n        uw_hint, uh_hint = layout_geometry['U_HINT']\n\n        for line_nb in range(1, layout_rows + 1):\n            llg = layout_geometry['LINE_%d' % line_nb] = []\n            llg_append = llg.append\n            for key in layout_geometry['LINE_HINT_%d' % line_nb]:\n                x_hint, y_hint = key[0]\n                w_hint, h_hint = key[1]\n                kx = x_hint * w\n                ky = y_hint * h\n                kw = w_hint * w\n                kh = h_hint * h\n\n                # now adjust, considering the key margin\n                kx = int(kx + kmleft)\n                ky = int(ky + kmbottom)\n                kw = int(kw - kmleft - kmright)\n                kh = int(kh - kmbottom - kmtop)\n\n                pos = (kx, ky)\n                size = (kw, kh)\n                llg_append((pos, size))\n\n        self.layout_geometry = layout_geometry\n        self.draw_keys()\n\n    def draw_keys(self):\n        layout = self.available_layouts[self.layout]\n        layout_rows = layout['rows']\n        layout_geometry = self.layout_geometry\n        layout_mode = self.layout_mode\n\n        # draw background\n        background = resource_find(self.background_disabled\n                                   if self.disabled else\n                                   self.background)\n        texture = Image(background, mipmap=True).texture\n        self.background_key_layer.clear()\n        with self.background_key_layer:\n            Color(*self.background_color)\n            BorderImage(texture=texture, size=self.size,\n                        border=self.background_border)\n\n        # XXX separate drawing the keys and the fonts to avoid\n        # XXX reloading the texture each time\n\n        # first draw keys without the font\n        key_normal = resource_find(self.key_background_disabled_normal\n                                   if self.disabled else\n                                   self.key_background_normal)\n        texture = Image(key_normal, mipmap=True).texture\n        with self.background_key_layer:\n            Color(*self.key_background_color)\n            for line_nb in range(1, layout_rows + 1):\n                for pos, size in layout_geometry['LINE_%d' % line_nb]:\n                    BorderImage(texture=texture, pos=pos, size=size,\n                                border=self.key_border)\n\n        # then draw the text\n        for line_nb in range(1, layout_rows + 1):\n            key_nb = 0\n            for pos, size in layout_geometry['LINE_%d' % line_nb]:\n                # retrieve the relative text\n                text = layout[layout_mode + '_' + str(line_nb)][key_nb][0]\n                z = Label(text=text, font_size=self.font_size, pos=pos,\n                           size=size, font_name=self.font_name)\n                self.add_widget(z)\n                key_nb += 1\n\n    def on_key_down(self, *largs):\n        pass\n\n    def on_key_up(self, *largs):\n        pass\n\n    def on_textinput(self, *largs):\n        pass\n\n    def get_key_at_pos(self, x, y):\n        w, h = self.size\n        x_hint = x / w\n        # focus on the surface without margins\n        layout_geometry = self.layout_geometry\n        layout = self.available_layouts[self.layout]\n        layout_rows = layout['rows']\n        mtop, mright, mbottom, mleft = self.margin_hint\n\n        # get the line of the layout\n        e_height = h - (mbottom + mtop) * h  # efficient height in pixels\n        line_height = e_height / layout_rows  # line height in px\n        y = y - mbottom * h\n        line_nb = layout_rows - int(y / line_height)\n\n        if line_nb > layout_rows:\n            line_nb = layout_rows\n        if line_nb < 1:\n            line_nb = 1\n\n        # get the key within the line\n        key_index = ''\n        current_key_index = 0\n        for key in layout_geometry['LINE_HINT_%d' % line_nb]:\n            if x_hint >= key[0][0] and x_hint < key[0][0] + key[1][0]:\n                key_index = current_key_index\n                break\n            else:\n                current_key_index += 1\n        if key_index == '':\n            return None\n\n        # get the full character\n        key = layout['%s_%d' % (self.layout_mode, line_nb)][key_index]\n\n        return [key, (line_nb, key_index)]\n\n    def collide_margin(self, x, y):\n        '''Do a collision test, and return True if the (x, y) is inside the\n        vkeyboard margin.\n        '''\n        mtop, mright, mbottom, mleft = self.margin_hint\n        x_hint = x / self.width\n        y_hint = y / self.height\n        if x_hint > mleft and x_hint < 1. - mright \\\n                and y_hint > mbottom and y_hint < 1. - mtop:\n            return False\n        return True\n\n    def process_key_on(self, touch):\n        if not touch:\n            return\n        x, y = self.to_local(*touch.pos)\n        key = self.get_key_at_pos(x, y)\n        if not key:\n            return\n\n        key_data = key[0]\n        displayed_char, internal, special_char, size = key_data\n        line_nb, key_index = key[1]\n\n        # save pressed key on the touch\n        ud = touch.ud[self.uid] = {}\n        ud['key'] = key\n\n        # for caps lock or shift only:\n        uid = touch.uid\n        if special_char is not None:\n            # Do not repeat special keys\n            if special_char in ('capslock', 'shift', 'layout', 'special'):\n                if self._start_repeat_key_ev is not None:\n                    self._start_repeat_key_ev.cancel()\n                    self._start_repeat_key_ev = None\n                self.repeat_touch = None\n            if special_char == 'capslock':\n                self.have_capslock = not self.have_capslock\n                uid = -1\n            elif special_char == 'shift':\n                self.have_shift = True\n            elif special_char == 'special':\n                self.have_special = True\n            elif special_char == 'layout':\n                self.change_layout()\n\n        # send info to the bus\n        b_keycode = special_char\n        b_modifiers = self._get_modifiers()\n        if self.get_parent_window().__class__.__module__ == \\\n            'kivy.core.window.window_sdl2' and internal:\n            self.dispatch('on_textinput', internal)\n        else:\n            self.dispatch('on_key_down', b_keycode, internal, b_modifiers)\n\n        # save key as an active key for drawing\n        self.active_keys[uid] = key[1]\n        self.refresh_active_keys_layer()\n\n    def process_key_up(self, touch):\n        uid = touch.uid\n        if self.uid not in touch.ud:\n            return\n\n        # save pressed key on the touch\n        key_data, key = touch.ud[self.uid]['key']\n        displayed_char, internal, special_char, size = key_data\n\n        # send info to the bus\n        b_keycode = special_char\n        b_modifiers = self._get_modifiers()\n        self.dispatch('on_key_up', b_keycode, internal, b_modifiers)\n\n        if special_char == 'capslock':\n            uid = -1\n\n        if uid in self.active_keys:\n            self.active_keys.pop(uid, None)\n            if special_char == 'shift':\n                self.have_shift = False\n            elif special_char == 'special':\n                self.have_special = False\n            if special_char == 'capslock' and self.have_capslock:\n                self.active_keys[-1] = key\n            self.refresh_active_keys_layer()\n\n    def _get_modifiers(self):\n        ret = []\n        if self.have_shift:\n            ret.append('shift')\n        if self.have_capslock:\n            ret.append('capslock')\n        return ret\n\n    def _start_repeat_key(self, *kwargs):\n        self._repeat_key_ev = Clock.schedule_interval(self._repeat_key, 0.05)\n\n    def _repeat_key(self, *kwargs):\n        self.process_key_on(self.repeat_touch)\n\n    def on_touch_down(self, touch):\n        x, y = touch.pos\n        if not self.collide_point(x, y):\n            return\n        if self.disabled:\n            return True\n\n        x, y = self.to_local(x, y)\n        if not self.collide_margin(x, y):\n            if self.repeat_touch is None:\n                self._start_repeat_key_ev = Clock.schedule_once(\n                    self._start_repeat_key, 0.5)\n            self.repeat_touch = touch\n\n            self.process_key_on(touch)\n            touch.grab(self, exclusive=True)\n\n        else:\n            super(VKeyboard, self).on_touch_down(touch)\n        return True\n\n    def on_touch_up(self, touch):\n        if touch.grab_current is self:\n            self.process_key_up(touch)\n\n            if self._start_repeat_key_ev is not None:\n                self._start_repeat_key_ev.cancel()\n                self._start_repeat_key_ev = None\n            if touch == self.repeat_touch:\n                if self._repeat_key_ev is not None:\n                    self._repeat_key_ev.cancel()\n                    self._repeat_key_ev = None\n                self.repeat_touch = None\n\n        return super(VKeyboard, self).on_touch_up(touch)",
  "def __init__(self, **kwargs):\n        # XXX move to style.kv\n        if 'size_hint' not in kwargs:\n            if 'size_hint_x' not in kwargs:\n                self.size_hint_x = None\n            if 'size_hint_y' not in kwargs:\n                self.size_hint_y = None\n        if 'size' not in kwargs:\n            if 'width' not in kwargs:\n                self.width = 700\n            if 'height' not in kwargs:\n                self.height = 200\n        if 'scale_min' not in kwargs:\n            self.scale_min = .4\n        if 'scale_max' not in kwargs:\n            self.scale_max = 1.6\n        if 'docked' not in kwargs:\n            self.docked = False\n\n        layout_mode = self._trigger_update_layout_mode = Clock.create_trigger(\n            self._update_layout_mode)\n        layouts = self._trigger_load_layouts = Clock.create_trigger(\n            self._load_layouts)\n        layout = self._trigger_load_layout = Clock.create_trigger(\n            self._load_layout)\n        fbind = self.fbind\n\n        fbind('docked', self.setup_mode)\n        fbind('have_shift', layout_mode)\n        fbind('have_capslock', layout_mode)\n        fbind('have_special', layout_mode)\n        fbind('layout_path', layouts)\n        fbind('layout', layout)\n        super(VKeyboard, self).__init__(**kwargs)\n\n        # load all the layouts found in the layout_path directory\n        self._load_layouts()\n\n        # ensure we have default layouts\n        available_layouts = self.available_layouts\n        if not available_layouts:\n            Logger.critical('VKeyboard: unable to load default layouts')\n\n        # load the default layout from configuration\n        if self.layout is None:\n            self.layout = Config.get('kivy', 'keyboard_layout')\n        else:\n            # ensure the current layout is found on the available layout\n            self._trigger_load_layout()\n\n        # update layout mode (shift or normal)\n        self._trigger_update_layout_mode()\n\n        # create a top layer to draw active keys on\n        with self.canvas:\n            self.background_key_layer = Canvas()\n            self.active_keys_layer = Canvas()",
  "def on_disabled(self, instance, value):\n        self.refresh_keys()",
  "def _update_layout_mode(self, *l):\n        # update mode according to capslock and shift key\n        mode = self.have_capslock != self.have_shift\n        mode = 'shift' if mode else 'normal'\n        if self.have_special:\n            mode = \"special\"\n        if mode != self.layout_mode:\n            self.layout_mode = mode\n            self.refresh(False)",
  "def _load_layout(self, *largs):\n        # ensure new layouts are loaded first\n        if self._trigger_load_layouts.is_triggered:\n            self._load_layouts()\n            self._trigger_load_layouts.cancel()\n\n        value = self.layout\n        available_layouts = self.available_layouts\n\n        # it's a filename, try to load it directly\n        if self.layout[-5:] == '.json':\n            if value not in available_layouts:\n                fn = resource_find(self.layout)\n                self._load_layout_fn(fn, self.layout)\n\n        if not available_layouts:\n            return\n        if value not in available_layouts and value != 'qwerty':\n            Logger.error(\n                'Vkeyboard: <%s> keyboard layout mentioned in '\n                'conf file was not found, fallback on qwerty' %\n                value)\n            self.layout = 'qwerty'\n        self.refresh(True)",
  "def _load_layouts(self, *largs):\n        # first load available layouts from json files\n        # XXX fix to be able to reload layout when path is changing\n        value = self.layout_path\n        for fn in listdir(value):\n            self._load_layout_fn(join(value, fn),\n                                 basename(splitext(fn)[0]))",
  "def _load_layout_fn(self, fn, name):\n        available_layouts = self.available_layouts\n        if fn[-5:] != '.json':\n            return\n        with open(fn, 'r', encoding='utf-8') as fd:\n            json_content = fd.read()\n            layout = loads(json_content)\n        available_layouts[name] = layout",
  "def setup_mode(self, *largs):\n        '''Call this method when you want to readjust the keyboard according to\n        options: :attr:`docked` or not, with attached :attr:`target` or not:\n\n        * If :attr:`docked` is True, it will call :meth:`setup_mode_dock`\n        * If :attr:`docked` is False, it will call :meth:`setup_mode_free`\n\n        Feel free to overload these methods to create new\n        positioning behavior.\n        '''\n        if self.docked:\n            self.setup_mode_dock()\n        else:\n            self.setup_mode_free()",
  "def setup_mode_dock(self, *largs):\n        '''Setup the keyboard in docked mode.\n\n        Dock mode will reset the rotation, disable translation, rotation and\n        scale. Scale and position will be automatically adjusted to attach the\n        keyboard to the bottom of the screen.\n\n        .. note::\n            Don't call this method directly, use :meth:`setup_mode` instead.\n        '''\n        self.do_translation = False\n        self.do_rotation = False\n        self.do_scale = False\n        self.rotation = 0\n        win = self.get_parent_window()\n        scale = win.width / float(self.width)\n        self.scale = scale\n        self.pos = 0, 0\n        win.bind(on_resize=self._update_dock_mode)",
  "def _update_dock_mode(self, win, *largs):\n        scale = win.width / float(self.width)\n        self.scale = scale\n        self.pos = 0, 0",
  "def setup_mode_free(self):\n        '''Setup the keyboard in free mode.\n\n        Free mode is designed to let the user control the position and\n        orientation of the keyboard. The only real usage is for a multiuser\n        environment, but you might found other ways to use it.\n        If a :attr:`target` is set, it will place the vkeyboard under the\n        target.\n\n        .. note::\n            Don't call this method directly, use :meth:`setup_mode` instead.\n        '''\n        self.do_translation = True\n        self.do_rotation = True\n        self.do_scale = True\n        target = self.target\n        if not target:\n            return\n\n        # NOTE all math will be done in window point of view\n        # determine rotation of the target\n        a = Vector(1, 0)\n        b = Vector(target.to_window(0, 0))\n        c = Vector(target.to_window(1, 0)) - b\n        self.rotation = -a.angle(c)\n\n        # determine the position of center/top of the keyboard\n        dpos = Vector(self.to_window(self.width / 2., self.height))\n\n        # determine the position of center/bottom of the target\n        cpos = Vector(target.to_window(target.center_x, target.y))\n\n        # the goal now is to map both point, calculate the diff between them\n        diff = dpos - cpos\n\n        # we still have an issue, self.pos represent the bounding box,\n        # not the 0,0 coordinate of the scatter. we need to apply also\n        # the diff between them (inside and outside coordinate matrix).\n        # It's hard to explain, but do a scheme on a paper, write all\n        # the vector i'm calculating, and you'll understand. :)\n        diff2 = Vector(self.x + self.width / 2., self.y + self.height) - \\\n            Vector(self.to_parent(self.width / 2., self.height))\n        diff -= diff2\n\n        # now we have a good \"diff\", set it as a pos.\n        self.pos = -diff",
  "def change_layout(self):\n        # XXX implement popup with all available layouts\n        pass",
  "def refresh(self, force=False):\n        '''(internal) Recreate the entire widget and graphics according to the\n        selected layout.\n        '''\n        self.clear_widgets()\n        if force:\n            self.refresh_keys_hint()\n        self.refresh_keys()\n        self.refresh_active_keys_layer()",
  "def refresh_active_keys_layer(self):\n        self.active_keys_layer.clear()\n\n        active_keys = self.active_keys\n        layout_geometry = self.layout_geometry\n        background = resource_find(self.key_background_down)\n        texture = Image(background, mipmap=True).texture\n\n        with self.active_keys_layer:\n            Color(*self.key_background_color)\n            for line_nb, index in active_keys.values():\n                pos, size = layout_geometry['LINE_%d' % line_nb][index]\n                BorderImage(texture=texture, pos=pos, size=size,\n                            border=self.key_border)",
  "def refresh_keys_hint(self):\n        layout = self.available_layouts[self.layout]\n        layout_cols = layout['cols']\n        layout_rows = layout['rows']\n        layout_geometry = self.layout_geometry\n        mtop, mright, mbottom, mleft = self.margin_hint\n\n        # get relative EFFICIENT surface of the layout without external margins\n        el_hint = 1. - mleft - mright\n        eh_hint = 1. - mtop - mbottom\n        ex_hint = 0 + mleft\n        ey_hint = 0 + mbottom\n\n        # get relative unit surface\n        uw_hint = (1. / layout_cols) * el_hint\n        uh_hint = (1. / layout_rows) * eh_hint\n        layout_geometry['U_HINT'] = (uw_hint, uh_hint)\n\n        # calculate individual key RELATIVE surface and pos (without key\n        # margin)\n        current_y_hint = ey_hint + eh_hint\n        for line_nb in range(1, layout_rows + 1):\n            current_y_hint -= uh_hint\n            # get line_name\n            line_name = '%s_%d' % (self.layout_mode, line_nb)\n            line_hint = 'LINE_HINT_%d' % line_nb\n            layout_geometry[line_hint] = []\n            current_x_hint = ex_hint\n            # go through the list of keys (tuples of 4)\n            for key in layout[line_name]:\n                # calculate relative pos, size\n                layout_geometry[line_hint].append([\n                    (current_x_hint, current_y_hint),\n                    (key[3] * uw_hint, uh_hint)])\n                current_x_hint += key[3] * uw_hint\n\n        self.layout_geometry = layout_geometry",
  "def refresh_keys(self):\n        layout = self.available_layouts[self.layout]\n        layout_rows = layout['rows']\n        layout_geometry = self.layout_geometry\n        w, h = self.size\n        kmtop, kmright, kmbottom, kmleft = self.key_margin\n        uw_hint, uh_hint = layout_geometry['U_HINT']\n\n        for line_nb in range(1, layout_rows + 1):\n            llg = layout_geometry['LINE_%d' % line_nb] = []\n            llg_append = llg.append\n            for key in layout_geometry['LINE_HINT_%d' % line_nb]:\n                x_hint, y_hint = key[0]\n                w_hint, h_hint = key[1]\n                kx = x_hint * w\n                ky = y_hint * h\n                kw = w_hint * w\n                kh = h_hint * h\n\n                # now adjust, considering the key margin\n                kx = int(kx + kmleft)\n                ky = int(ky + kmbottom)\n                kw = int(kw - kmleft - kmright)\n                kh = int(kh - kmbottom - kmtop)\n\n                pos = (kx, ky)\n                size = (kw, kh)\n                llg_append((pos, size))\n\n        self.layout_geometry = layout_geometry\n        self.draw_keys()",
  "def draw_keys(self):\n        layout = self.available_layouts[self.layout]\n        layout_rows = layout['rows']\n        layout_geometry = self.layout_geometry\n        layout_mode = self.layout_mode\n\n        # draw background\n        background = resource_find(self.background_disabled\n                                   if self.disabled else\n                                   self.background)\n        texture = Image(background, mipmap=True).texture\n        self.background_key_layer.clear()\n        with self.background_key_layer:\n            Color(*self.background_color)\n            BorderImage(texture=texture, size=self.size,\n                        border=self.background_border)\n\n        # XXX separate drawing the keys and the fonts to avoid\n        # XXX reloading the texture each time\n\n        # first draw keys without the font\n        key_normal = resource_find(self.key_background_disabled_normal\n                                   if self.disabled else\n                                   self.key_background_normal)\n        texture = Image(key_normal, mipmap=True).texture\n        with self.background_key_layer:\n            Color(*self.key_background_color)\n            for line_nb in range(1, layout_rows + 1):\n                for pos, size in layout_geometry['LINE_%d' % line_nb]:\n                    BorderImage(texture=texture, pos=pos, size=size,\n                                border=self.key_border)\n\n        # then draw the text\n        for line_nb in range(1, layout_rows + 1):\n            key_nb = 0\n            for pos, size in layout_geometry['LINE_%d' % line_nb]:\n                # retrieve the relative text\n                text = layout[layout_mode + '_' + str(line_nb)][key_nb][0]\n                z = Label(text=text, font_size=self.font_size, pos=pos,\n                           size=size, font_name=self.font_name)\n                self.add_widget(z)\n                key_nb += 1",
  "def on_key_down(self, *largs):\n        pass",
  "def on_key_up(self, *largs):\n        pass",
  "def on_textinput(self, *largs):\n        pass",
  "def get_key_at_pos(self, x, y):\n        w, h = self.size\n        x_hint = x / w\n        # focus on the surface without margins\n        layout_geometry = self.layout_geometry\n        layout = self.available_layouts[self.layout]\n        layout_rows = layout['rows']\n        mtop, mright, mbottom, mleft = self.margin_hint\n\n        # get the line of the layout\n        e_height = h - (mbottom + mtop) * h  # efficient height in pixels\n        line_height = e_height / layout_rows  # line height in px\n        y = y - mbottom * h\n        line_nb = layout_rows - int(y / line_height)\n\n        if line_nb > layout_rows:\n            line_nb = layout_rows\n        if line_nb < 1:\n            line_nb = 1\n\n        # get the key within the line\n        key_index = ''\n        current_key_index = 0\n        for key in layout_geometry['LINE_HINT_%d' % line_nb]:\n            if x_hint >= key[0][0] and x_hint < key[0][0] + key[1][0]:\n                key_index = current_key_index\n                break\n            else:\n                current_key_index += 1\n        if key_index == '':\n            return None\n\n        # get the full character\n        key = layout['%s_%d' % (self.layout_mode, line_nb)][key_index]\n\n        return [key, (line_nb, key_index)]",
  "def collide_margin(self, x, y):\n        '''Do a collision test, and return True if the (x, y) is inside the\n        vkeyboard margin.\n        '''\n        mtop, mright, mbottom, mleft = self.margin_hint\n        x_hint = x / self.width\n        y_hint = y / self.height\n        if x_hint > mleft and x_hint < 1. - mright \\\n                and y_hint > mbottom and y_hint < 1. - mtop:\n            return False\n        return True",
  "def process_key_on(self, touch):\n        if not touch:\n            return\n        x, y = self.to_local(*touch.pos)\n        key = self.get_key_at_pos(x, y)\n        if not key:\n            return\n\n        key_data = key[0]\n        displayed_char, internal, special_char, size = key_data\n        line_nb, key_index = key[1]\n\n        # save pressed key on the touch\n        ud = touch.ud[self.uid] = {}\n        ud['key'] = key\n\n        # for caps lock or shift only:\n        uid = touch.uid\n        if special_char is not None:\n            # Do not repeat special keys\n            if special_char in ('capslock', 'shift', 'layout', 'special'):\n                if self._start_repeat_key_ev is not None:\n                    self._start_repeat_key_ev.cancel()\n                    self._start_repeat_key_ev = None\n                self.repeat_touch = None\n            if special_char == 'capslock':\n                self.have_capslock = not self.have_capslock\n                uid = -1\n            elif special_char == 'shift':\n                self.have_shift = True\n            elif special_char == 'special':\n                self.have_special = True\n            elif special_char == 'layout':\n                self.change_layout()\n\n        # send info to the bus\n        b_keycode = special_char\n        b_modifiers = self._get_modifiers()\n        if self.get_parent_window().__class__.__module__ == \\\n            'kivy.core.window.window_sdl2' and internal:\n            self.dispatch('on_textinput', internal)\n        else:\n            self.dispatch('on_key_down', b_keycode, internal, b_modifiers)\n\n        # save key as an active key for drawing\n        self.active_keys[uid] = key[1]\n        self.refresh_active_keys_layer()",
  "def process_key_up(self, touch):\n        uid = touch.uid\n        if self.uid not in touch.ud:\n            return\n\n        # save pressed key on the touch\n        key_data, key = touch.ud[self.uid]['key']\n        displayed_char, internal, special_char, size = key_data\n\n        # send info to the bus\n        b_keycode = special_char\n        b_modifiers = self._get_modifiers()\n        self.dispatch('on_key_up', b_keycode, internal, b_modifiers)\n\n        if special_char == 'capslock':\n            uid = -1\n\n        if uid in self.active_keys:\n            self.active_keys.pop(uid, None)\n            if special_char == 'shift':\n                self.have_shift = False\n            elif special_char == 'special':\n                self.have_special = False\n            if special_char == 'capslock' and self.have_capslock:\n                self.active_keys[-1] = key\n            self.refresh_active_keys_layer()",
  "def _get_modifiers(self):\n        ret = []\n        if self.have_shift:\n            ret.append('shift')\n        if self.have_capslock:\n            ret.append('capslock')\n        return ret",
  "def _start_repeat_key(self, *kwargs):\n        self._repeat_key_ev = Clock.schedule_interval(self._repeat_key, 0.05)",
  "def _repeat_key(self, *kwargs):\n        self.process_key_on(self.repeat_touch)",
  "def on_touch_down(self, touch):\n        x, y = touch.pos\n        if not self.collide_point(x, y):\n            return\n        if self.disabled:\n            return True\n\n        x, y = self.to_local(x, y)\n        if not self.collide_margin(x, y):\n            if self.repeat_touch is None:\n                self._start_repeat_key_ev = Clock.schedule_once(\n                    self._start_repeat_key, 0.5)\n            self.repeat_touch = touch\n\n            self.process_key_on(touch)\n            touch.grab(self, exclusive=True)\n\n        else:\n            super(VKeyboard, self).on_touch_down(touch)\n        return True",
  "def on_touch_up(self, touch):\n        if touch.grab_current is self:\n            self.process_key_up(touch)\n\n            if self._start_repeat_key_ev is not None:\n                self._start_repeat_key_ev.cancel()\n                self._start_repeat_key_ev = None\n            if touch == self.repeat_touch:\n                if self._repeat_key_ev is not None:\n                    self._repeat_key_ev.cancel()\n                    self._repeat_key_ev = None\n                self.repeat_touch = None\n\n        return super(VKeyboard, self).on_touch_up(touch)",
  "def alphanumeric_folders_first(files, filesystem):\n    return (sorted(f for f in files if filesystem.is_dir(f)) +\n            sorted(f for f in files if not filesystem.is_dir(f)))",
  "class FileSystemAbstract(object):\n    '''Class for implementing a File System view that can be used with the\n    :class:`FileChooser <FileChooser>`.\n\n    .. versionadded:: 1.8.0\n    '''\n\n    def listdir(self, fn):\n        '''Return the list of files in the directory `fn`\n        '''\n        pass\n\n    def getsize(self, fn):\n        '''Return the size in bytes of a file\n        '''\n        pass\n\n    def is_hidden(self, fn):\n        '''Return True if the file is hidden\n        '''\n        pass\n\n    def is_dir(self, fn):\n        '''Return True if the argument passed to this method is a directory\n        '''\n        pass",
  "class FileSystemLocal(FileSystemAbstract):\n    '''Implementation of :class:`FileSystemAbstract` for local files.\n\n    .. versionadded:: 1.8.0\n    '''\n\n    def listdir(self, fn):\n        return listdir(fn)\n\n    def getsize(self, fn):\n        return getsize(fn)\n\n    def is_hidden(self, fn):\n        if platform == 'win':\n            if not _have_win32file:\n                return False\n            try:\n                return GetFileAttributesExW(fn)[0] & FILE_ATTRIBUTE_HIDDEN\n            except error:\n                # This error can occurred when a file is already accessed by\n                # someone else. So don't return to True, because we have lot\n                # of chances to not being able to do anything with it.\n                Logger.exception('unable to access to <%s>' % fn)\n                return True\n\n        return basename(fn).startswith('.')\n\n    def is_dir(self, fn):\n        return isdir(fn)",
  "class FileChooserProgressBase(FloatLayout):\n    '''Base for implementing a progress view. This view is used when too many\n    entries need to be created and are delayed over multiple frames.\n\n    .. versionadded:: 1.2.0\n    '''\n\n    path = StringProperty('')\n    '''Current path of the FileChooser, read-only.\n    '''\n\n    index = NumericProperty(0)\n    '''Current index of :attr:`total` entries to be loaded.\n    '''\n\n    total = NumericProperty(1)\n    '''Total number of entries to load.\n    '''\n\n    def cancel(self, *largs):\n        '''Cancel any action from the FileChooserController.\n        '''\n        if self.parent:\n            self.parent.cancel()\n\n    def on_touch_down(self, touch):\n        if self.collide_point(*touch.pos):\n            super(FileChooserProgressBase, self).on_touch_down(touch)\n            return True\n\n    def on_touch_move(self, touch):\n        if self.collide_point(*touch.pos):\n            super(FileChooserProgressBase, self).on_touch_move(touch)\n            return True\n\n    def on_touch_up(self, touch):\n        if self.collide_point(*touch.pos):\n            super(FileChooserProgressBase, self).on_touch_up(touch)\n            return True",
  "class FileChooserProgress(FileChooserProgressBase):\n    pass",
  "class FileChooserLayout(FloatLayout):\n    '''Base class for file chooser layouts.\n\n    .. versionadded:: 1.9.0\n    '''\n\n    VIEWNAME = 'undefined'\n\n    __events__ = ('on_entry_added', 'on_entries_cleared',\n                  'on_subentry_to_entry', 'on_remove_subentry', 'on_submit')\n\n    controller = ObjectProperty()\n    '''\n    Reference to the controller handling this layout.\n\n    :class:`~kivy.properties.ObjectProperty`\n    '''\n\n    def on_entry_added(self, node, parent=None):\n        pass\n\n    def on_entries_cleared(self):\n        pass\n\n    def on_subentry_to_entry(self, subentry, entry):\n        pass\n\n    def on_remove_subentry(self, subentry, entry):\n        pass\n\n    def on_submit(self, selected, touch=None):\n        pass",
  "class FileChooserListLayout(FileChooserLayout):\n    '''File chooser layout using a list view.\n\n    .. versionadded:: 1.9.0\n    '''\n    VIEWNAME = 'list'\n    _ENTRY_TEMPLATE = 'FileListEntry'\n\n    def __init__(self, **kwargs):\n        super(FileChooserListLayout, self).__init__(**kwargs)\n        self.fbind('on_entries_cleared', self.scroll_to_top)\n\n    def scroll_to_top(self, *args):\n        self.ids.scrollview.scroll_y = 1.0",
  "class FileChooserIconLayout(FileChooserLayout):\n    '''File chooser layout using an icon view.\n\n    .. versionadded:: 1.9.0\n    '''\n\n    VIEWNAME = 'icon'\n    _ENTRY_TEMPLATE = 'FileIconEntry'\n\n    def __init__(self, **kwargs):\n        super(FileChooserIconLayout, self).__init__(**kwargs)\n        self.fbind('on_entries_cleared', self.scroll_to_top)\n\n    def scroll_to_top(self, *args):\n        self.ids.scrollview.scroll_y = 1.0",
  "class FileChooserController(RelativeLayout):\n    '''Base for implementing a FileChooser. Don't use this class directly, but\n    prefer using an implementation such as the :class:`FileChooser`,\n    :class:`FileChooserListView` or :class:`FileChooserIconView`.\n\n    :Events:\n        `on_entry_added`: entry, parent\n            Fired when a root-level entry is added to the file list. If you\n            return True from this event, the entry is not added to FileChooser.\n        `on_entries_cleared`\n            Fired when the the entries list is cleared, usually when the\n            root is refreshed.\n        `on_subentry_to_entry`: entry, parent\n            Fired when a sub-entry is added to an existing entry or\n            when entries are removed from an entry e.g. when\n            a node is closed.\n        `on_submit`: selection, touch\n            Fired when a file has been selected with a double-tap.\n    '''\n    _ENTRY_TEMPLATE = None\n\n    layout = ObjectProperty(baseclass=FileChooserLayout)\n    '''\n    Reference to the layout widget instance.\n\n    layout is an :class:`~kivy.properties.ObjectProperty`.\n\n    .. versionadded:: 1.9.0\n    '''\n\n    path = StringProperty(u'/')\n    '''\n    path is a :class:`~kivy.properties.StringProperty` and defaults to the\n    current working directory as a unicode string. It specifies the path on the\n    filesystem that this controller should refer to.\n\n    .. warning::\n\n        If a unicode path is specified, all the files returned will be in\n        unicode, allowing the display of unicode files and paths. If a bytes\n        path is specified, only files and paths with ascii names will be\n        displayed properly: non-ascii filenames will be displayed and listed\n        with questions marks (?) instead of their unicode characters.\n    '''\n\n    filters = ListProperty([])\n    '''\n    filters specifies the filters to be applied to the files in the directory.\n    filters is a :class:`~kivy.properties.ListProperty` and defaults to [].\n    This is equivalent to '\\\\*' i.e. nothing is filtered.\n\n    The filters are not reset when the path changes. You need to do that\n    yourself if desired.\n\n    There are two kinds of filters: patterns and callbacks.\n\n    #. Patterns\n\n        e.g. ['\\\\*.png'].\n        You can use the following patterns:\n\n            ========== =================================\n            Pattern     Meaning\n            ========== =================================\n            \\\\*         matches everything\n            ?          matches any single character\n            [seq]      matches any character in seq\n            [!seq]     matches any character not in seq\n            ========== =================================\n\n    #. Callbacks\n\n        You can specify a function that will be called for each file. The\n        callback will be passed the folder and file name as the first\n        and second parameters respectively. It should return True to\n        indicate a match and False otherwise.\n\n    .. versionchanged:: 1.4.0\n        Added the option to specify the filter as a callback.\n    '''\n\n    filter_dirs = BooleanProperty(False)\n    '''\n    Indicates whether filters should also apply to directories.\n    filter_dirs is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.\n    '''\n\n    sort_func = ObjectProperty(alphanumeric_folders_first)\n    '''\n    Provides a function to be called with a list of filenames as the first\n    argument and the filesystem implementation as the second argument. It\n    returns a list of filenames sorted for display in the view.\n\n    sort_func is an :class:`~kivy.properties.ObjectProperty` and defaults to a\n    function returning alphanumerically named folders first.\n\n    .. versionchanged:: 1.8.0\n\n        The signature needs now 2 arguments: first the list of files,\n        second the filesystem class to use.\n    '''\n\n    files = ListProperty([])\n    '''\n    The list of files in the directory specified by path after applying the\n    filters.\n\n    files is a read-only :class:`~kivy.properties.ListProperty`.\n    '''\n\n    show_hidden = BooleanProperty(False)\n    '''\n    Determines whether hidden files and folders should be shown.\n\n    show_hidden is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.\n    '''\n\n    selection = ListProperty([])\n    '''\n    Contains the list of files that are currently selected.\n\n    selection is a read-only :class:`~kivy.properties.ListProperty` and\n    defaults to [].\n    '''\n\n    multiselect = BooleanProperty(False)\n    '''\n    Determines whether the user is able to select multiple files or not.\n\n    multiselect is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.\n    '''\n\n    dirselect = BooleanProperty(False)\n    '''\n    Determines whether directories are valid selections or not.\n\n    dirselect is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.\n\n    .. versionadded:: 1.1.0\n    '''\n\n    rootpath = StringProperty(None, allownone=True)\n    '''\n    Root path to use instead of the system root path. If set, it will not show\n    a \"..\" directory to go up to the root path. For example, if you set\n    rootpath to /users/foo, the user will be unable to go to /users or to any\n    other directory not starting with /users/foo.\n\n    rootpath is a :class:`~kivy.properties.StringProperty` and defaults\n    to None.\n\n    .. versionadded:: 1.2.0\n\n    .. note::\n\n        Similarly to :attr:`path`, whether `rootpath` is specified as\n        bytes or a unicode string determines the type of the filenames and\n        paths read.\n    '''\n\n    progress_cls = ObjectProperty(FileChooserProgress)\n    '''Class to use for displaying a progress indicator for filechooser\n    loading.\n\n    progress_cls is an :class:`~kivy.properties.ObjectProperty` and defaults to\n    :class:`FileChooserProgress`.\n\n    .. versionadded:: 1.2.0\n\n    .. versionchanged:: 1.8.0\n\n        If set to a string, the :class:`~kivy.factory.Factory` will be used to\n        resolve the class name.\n\n    '''\n\n    file_encodings = ListProperty(\n        ['utf-8', 'latin1', 'cp1252'], deprecated=True)\n    '''Possible encodings for decoding a filename to unicode. In the case that\n    the user has a non-ascii filename, undecodable without knowing its\n    initial encoding, we have no other choice than to guess it.\n\n    Please note that if you encounter an issue because of a missing encoding\n    here, we'll be glad to add it to this list.\n\n    file_encodings is a :class:`~kivy.properties.ListProperty` and defaults to\n    ['utf-8', 'latin1', 'cp1252'].\n\n    .. versionadded:: 1.3.0\n\n    .. deprecated:: 1.8.0\n       This property is no longer used as the filechooser no longer decodes\n       the file names.\n\n    '''\n\n    file_system = ObjectProperty(FileSystemLocal(),\n                                 baseclass=FileSystemAbstract)\n    '''The file system object used to access the file system. This should be a\n    subclass of :class:`FileSystemAbstract`.\n\n    file_system is an :class:`~kivy.properties.ObjectProperty` and defaults to\n    :class:`FileSystemLocal()`\n\n    .. versionadded:: 1.8.0\n    '''\n\n    font_name = StringProperty(DEFAULT_FONT)\n    '''Filename of the font to use in UI components. The path can be\n    absolute or relative.  Relative paths are resolved by the\n    :func:`~kivy.resources.resource_find` function.\n\n    :attr:`font_name` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'Roboto'. This value is taken\n    from :class:`~kivy.config.Config`.\n    '''\n\n    _update_files_ev = None\n    _create_files_entries_ev = None\n\n    __events__ = ('on_entry_added', 'on_entries_cleared',\n                  'on_subentry_to_entry', 'on_remove_subentry', 'on_submit')\n\n    def __init__(self, **kwargs):\n        self._progress = None\n        super(FileChooserController, self).__init__(**kwargs)\n\n        self._items = []\n        fbind = self.fbind\n        fbind('selection', self._update_item_selection)\n\n        self._previous_path = [self.path]\n        fbind('path', self._save_previous_path)\n        update = self._trigger_update\n        fbind('path', update)\n        fbind('filters', update)\n        fbind('rootpath', update)\n        update()\n\n    def on_touch_down(self, touch):\n        # don't respond to touchs outside self\n        if not self.collide_point(*touch.pos):\n            return\n        if self.disabled:\n            return True\n        return super(FileChooserController, self).on_touch_down(touch)\n\n    def on_touch_up(self, touch):\n        # don't respond to touchs outside self\n        if not self.collide_point(*touch.pos):\n            return\n        if self.disabled:\n            return True\n        return super(FileChooserController, self).on_touch_up(touch)\n\n    def _update_item_selection(self, *args):\n        for item in self._items:\n            item.selected = item.path in self.selection\n\n    def _save_previous_path(self, instance, value):\n        self._previous_path.append(value)\n        self._previous_path = self._previous_path[-2:]\n\n    def _trigger_update(self, *args):\n        ev = self._update_files_ev\n        if ev is None:\n            ev = self._update_files_ev = Clock.create_trigger(\n                self._update_files)\n        ev()\n\n    def on_entry_added(self, node, parent=None):\n        if self.layout:\n            self.layout.dispatch('on_entry_added', node, parent)\n\n    def on_entries_cleared(self):\n        if self.layout:\n            self.layout.dispatch('on_entries_cleared')\n\n    def on_subentry_to_entry(self, subentry, entry):\n        if self.layout:\n            self.layout.dispatch('on_subentry_to_entry', subentry, entry)\n\n    def on_remove_subentry(self, subentry, entry):\n        if self.layout:\n            self.layout.dispatch('on_remove_subentry', subentry, entry)\n\n    def on_submit(self, selected, touch=None):\n        if self.layout:\n            self.layout.dispatch('on_submit', selected, touch)\n\n    def entry_touched(self, entry, touch):\n        '''(internal) This method must be called by the template when an entry\n        is touched by the user.\n        '''\n        if (\n            'button' in touch.profile and touch.button in (\n                'scrollup', 'scrolldown', 'scrollleft', 'scrollright')):\n            return False\n\n        _dir = self.file_system.is_dir(entry.path)\n        dirselect = self.dirselect\n\n        if _dir and dirselect and touch.is_double_tap:\n            self.open_entry(entry)\n            return\n\n        if self.multiselect:\n            if entry.path in self.selection:\n                self.selection.remove(entry.path)\n            else:\n                if _dir and not self.dirselect:\n                    self.open_entry(entry)\n                    return\n                self.selection.append(entry.path)\n        else:\n            if _dir and not self.dirselect:\n                return\n            self.selection = [abspath(join(self.path, entry.path)), ]\n\n    def entry_released(self, entry, touch):\n        '''(internal) This method must be called by the template when an entry\n        is touched by the user.\n\n        .. versionadded:: 1.1.0\n        '''\n        if (\n            'button' in touch.profile and touch.button in (\n                'scrollup', 'scrolldown', 'scrollleft', 'scrollright')):\n            return False\n        if not self.multiselect:\n            if self.file_system.is_dir(entry.path) and not self.dirselect:\n                self.open_entry(entry)\n            elif touch.is_double_tap:\n                if self.dirselect and self.file_system.is_dir(entry.path):\n                    return\n                else:\n                    self.dispatch('on_submit', self.selection, touch)\n\n    def open_entry(self, entry):\n        try:\n            # Just check if we can list the directory. This is also what\n            # _add_file does, so if it fails here, it would also fail later\n            # on. Do the check here to prevent setting path to an invalid\n            # directory that we cannot list.\n            self.file_system.listdir(entry.path)\n        except OSError:\n            entry.locked = True\n        else:\n            # If entry.path is to jump to previous directory, update path with\n            # parent directory\n            self.path = abspath(join(self.path, entry.path))\n            self.selection = [self.path, ] if self.dirselect else []\n\n    def _apply_filters(self, files):\n        if not self.filters:\n            return files\n        filtered = []\n        for filt in self.filters:\n            if isinstance(filt, collections.abc.Callable):\n                filtered.extend([fn for fn in files if filt(self.path, fn)])\n            else:\n                filtered.extend([fn for fn in files if fnmatch(fn, filt)])\n        if not self.filter_dirs:\n            dirs = [fn for fn in files if self.file_system.is_dir(fn)]\n            filtered.extend(dirs)\n        return list(set(filtered))\n\n    def get_nice_size(self, fn):\n        '''Pass the filepath. Returns the size in the best human readable\n        format or '' if it is a directory (Don't recursively calculate size).\n        '''\n        if self.file_system.is_dir(fn):\n            return ''\n        try:\n            size = self.file_system.getsize(fn)\n        except OSError:\n            return '--'\n\n        for unit in filesize_units:\n            if size < 1024.0:\n                return '%1.0f %s' % (size, unit)\n            size /= 1024.0\n\n    def _update_files(self, *args, **kwargs):\n        # trigger to start gathering the files in the new directory\n        # we'll start a timer that will do the job, 10 times per frames\n        # (default)\n        self._gitems = []\n        self._gitems_parent = kwargs.get('parent', None)\n        self._gitems_gen = self._generate_file_entries(\n            path=kwargs.get('path', self.path),\n            parent=self._gitems_parent)\n        self.path = abspath(self.path)\n\n        # cancel any previous clock if exist\n        ev = self._create_files_entries_ev\n        if ev is not None:\n            ev.cancel()\n\n        # show the progression screen\n        self._hide_progress()\n        if self._create_files_entries():\n            # not enough for creating all the entries, all a clock to continue\n            # start a timer for the next 100 ms\n            if ev is None:\n                ev = self._create_files_entries_ev = Clock.schedule_interval(\n                    self._create_files_entries, .1)\n            ev()\n\n    def _get_file_paths(self, items):\n        return [file.path for file in items]\n\n    def _create_files_entries(self, *args):\n        # create maximum entries during 50ms max, or 10 minimum (slow system)\n        # (on a \"fast system\" (core i7 2700K), we can create up to 40 entries\n        # in 50 ms. So 10 is fine for low system.\n        start = time()\n        finished = False\n        index = total = count = 1\n        while time() - start < 0.05 or count < 10:\n            try:\n                index, total, item = next(self._gitems_gen)\n                self._gitems.append(item)\n                count += 1\n            except StopIteration:\n                finished = True\n                break\n            except TypeError:  # in case _gitems_gen is None\n                finished = True\n                break\n\n        # if this wasn't enough for creating all the entries, show a progress\n        # bar, and report the activity to the user.\n        if not finished:\n            self._show_progress()\n            self._progress.total = total\n            self._progress.index = index\n            return True\n\n        # we created all the files, now push them on the view\n        self._items = items = self._gitems\n        parent = self._gitems_parent\n        if parent is None:\n            self.dispatch('on_entries_cleared')\n            for entry in items:\n                self.dispatch('on_entry_added', entry, parent)\n        else:\n            parent.entries[:] = items\n            for entry in items:\n                self.dispatch('on_subentry_to_entry', entry, parent)\n        self.files[:] = self._get_file_paths(items)\n\n        # stop the progression / creation\n        self._hide_progress()\n        self._gitems = None\n        self._gitems_gen = None\n        ev = self._create_files_entries_ev\n        if ev is not None:\n            ev.cancel()\n        return False\n\n    def cancel(self, *largs):\n        '''Cancel any background action started by filechooser, such as loading\n        a new directory.\n\n        .. versionadded:: 1.2.0\n        '''\n        ev = self._create_files_entries_ev\n        if ev is not None:\n            ev.cancel()\n\n        self._hide_progress()\n        if len(self._previous_path) > 1:\n            # if we cancel any action, the path will be set same as the\n            # previous one, so we can safely cancel the update of the previous\n            # path.\n            self.path = self._previous_path[-2]\n\n            ev = self._update_files_ev\n            if ev is not None:\n                ev.cancel()\n\n    def _show_progress(self):\n        if self._progress:\n            return\n        cls = self.progress_cls\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n        self._progress = cls(path=self.path)\n        self._progress.value = 0\n        self.add_widget(self._progress)\n\n    def _hide_progress(self):\n        if self._progress:\n            self.remove_widget(self._progress)\n            self._progress = None\n\n    def _generate_file_entries(self, *args, **kwargs):\n        # Generator that will create all the files entries.\n        # the generator is used via _update_files() and _create_files_entries()\n        # don't use it directly.\n        is_root = False\n        path = kwargs.get('path', self.path)\n        have_parent = kwargs.get('parent', None) is not None\n\n        # Add the components that are always needed\n        if self.rootpath:\n            rootpath = realpath(self.rootpath)\n            path = realpath(path)\n            if not path.startswith(rootpath):\n                self.path = rootpath\n                return\n            elif path == rootpath:\n                is_root = True\n        else:\n            if platform == 'win':\n                is_root = splitdrive(path)[1] in (sep, altsep)\n            elif platform in ('macosx', 'linux', 'android', 'ios'):\n                is_root = normpath(expanduser(path)) == sep\n            else:\n                # Unknown fs, just always add the .. entry but also log\n                Logger.warning('Filechooser: Unsupported OS: %r' % platform)\n        # generate an entries to go back to previous\n        if not is_root and not have_parent:\n            back = '..' + sep\n            if platform == 'win':\n                new_path = path[:path.rfind(sep)]\n                if sep not in new_path:\n                    new_path += sep\n                pardir = self._create_entry_widget(dict(\n                    name=back, size='', path=new_path, controller=ref(self),\n                    isdir=True, parent=None, sep=sep,\n                    get_nice_size=lambda: ''))\n            else:\n                pardir = self._create_entry_widget(dict(\n                    name=back, size='', path=back, controller=ref(self),\n                    isdir=True, parent=None, sep=sep,\n                    get_nice_size=lambda: ''))\n            yield 0, 1, pardir\n\n        # generate all the entries for files\n        try:\n            for index, total, item in self._add_files(path):\n                yield index, total, item\n        except OSError:\n            Logger.exception('Unable to open directory <%s>' % self.path)\n            self.files[:] = []\n\n    def _create_entry_widget(self, ctx):\n        template = self.layout._ENTRY_TEMPLATE\\\n            if self.layout else self._ENTRY_TEMPLATE\n        return Builder.template(template, **ctx)\n\n    def _add_files(self, path, parent=None):\n        path = expanduser(path)\n        if isfile(path):\n            path = dirname(path)\n\n        files = []\n        fappend = files.append\n        for f in self.file_system.listdir(path):\n            try:\n                # In the following, use fully qualified filenames\n                fappend(normpath(join(path, f)))\n            except UnicodeDecodeError:\n                Logger.exception('unable to decode <{}>'.format(f))\n            except UnicodeEncodeError:\n                Logger.exception('unable to encode <{}>'.format(f))\n        # Apply filename filters\n        files = self._apply_filters(files)\n        # Sort the list of files\n        files = self.sort_func(files, self.file_system)\n        is_hidden = self.file_system.is_hidden\n        if not self.show_hidden:\n            files = [x for x in files if not is_hidden(x)]\n        self.files[:] = files\n        total = len(files)\n        wself = ref(self)\n        for index, fn in enumerate(files):\n\n            def get_nice_size():\n                # Use a closure for lazy-loading here\n                return self.get_nice_size(fn)\n\n            ctx = {'name': basename(fn),\n                   'get_nice_size': get_nice_size,\n                   'path': fn,\n                   'controller': wself,\n                   'isdir': self.file_system.is_dir(fn),\n                   'parent': parent,\n                   'sep': sep}\n            entry = self._create_entry_widget(ctx)\n            yield index, total, entry\n\n    def entry_subselect(self, entry):\n        if not self.file_system.is_dir(entry.path):\n            return\n        self._update_files(path=entry.path, parent=entry)\n\n    def close_subselection(self, entry):\n        for subentry in entry.entries:\n            self.dispatch('on_remove_subentry', subentry, entry)",
  "class FileChooserListView(FileChooserController):\n    '''Implementation of a :class:`FileChooserController` using a list view.\n\n    .. versionadded:: 1.9.0\n    '''\n    _ENTRY_TEMPLATE = 'FileListEntry'",
  "class FileChooserIconView(FileChooserController):\n    '''Implementation of a :class:`FileChooserController` using an icon view.\n\n    .. versionadded:: 1.9.0\n    '''\n    _ENTRY_TEMPLATE = 'FileIconEntry'",
  "class FileChooser(FileChooserController):\n    '''Implementation of a :class:`FileChooserController` which supports\n    switching between multiple, synced layout views.\n\n    The FileChooser can be used as follows:\n\n    .. code-block:: kv\n\n        BoxLayout:\n            orientation: 'vertical'\n\n            BoxLayout:\n                size_hint_y: None\n                height: sp(52)\n\n                Button:\n                    text: 'Icon View'\n                    on_press: fc.view_mode = 'icon'\n                Button:\n                    text: 'List View'\n                    on_press: fc.view_mode = 'list'\n\n            FileChooser:\n                id: fc\n                FileChooserIconLayout\n                FileChooserListLayout\n\n    .. versionadded:: 1.9.0\n    '''\n\n    manager = ObjectProperty()\n    '''\n    Reference to the :class:`~kivy.uix.screenmanager.ScreenManager` instance.\n\n    manager is an :class:`~kivy.properties.ObjectProperty`.\n    '''\n\n    _view_list = ListProperty()\n\n    def get_view_list(self):\n        return self._view_list\n\n    view_list = AliasProperty(get_view_list, bind=('_view_list',))\n    '''\n    List of views added to this FileChooser.\n\n    view_list is an :class:`~kivy.properties.AliasProperty` of type\n    :class:`list`.\n    '''\n\n    _view_mode = StringProperty()\n\n    def get_view_mode(self):\n        return self._view_mode\n\n    def set_view_mode(self, mode):\n        if mode not in self._view_list:\n            raise ValueError('unknown view mode %r' % mode)\n        self._view_mode = mode\n\n    view_mode = AliasProperty(\n        get_view_mode, set_view_mode, bind=('_view_mode',))\n    '''\n    Current layout view mode.\n\n    view_mode is an :class:`~kivy.properties.AliasProperty` of type\n    :class:`str`.\n    '''\n\n    @property\n    def _views(self):\n        return [screen.children[0] for screen in self.manager.screens]\n\n    def __init__(self, **kwargs):\n        super(FileChooser, self).__init__(**kwargs)\n\n        self.manager = ScreenManager()\n        super(FileChooser, self).add_widget(self.manager)\n\n        self.trigger_update_view = Clock.create_trigger(self.update_view)\n\n        self.fbind('view_mode', self.trigger_update_view)\n\n    def add_widget(self, widget, *args, **kwargs):\n        if widget is self._progress:\n            super(FileChooser, self).add_widget(widget, *args, **kwargs)\n        elif hasattr(widget, 'VIEWNAME'):\n            name = widget.VIEWNAME + 'view'\n            screen = Screen(name=name)\n            widget.controller = self\n            screen.add_widget(widget)\n            self.manager.add_widget(screen)\n\n            self.trigger_update_view()\n        else:\n            raise ValueError(\n                'widget must be a FileChooserLayout,'\n                ' not %s' % type(widget).__name__)\n\n    def rebuild_views(self):\n        views = [view.VIEWNAME for view in self._views]\n        if views != self._view_list:\n            self._view_list = views\n            if self._view_mode not in self._view_list:\n                self._view_mode = self._view_list[0]\n            self._trigger_update()\n\n    def update_view(self, *args):\n        self.rebuild_views()\n\n        sm = self.manager\n        viewlist = self._view_list\n        view = self.view_mode\n        current = sm.current[:-4]\n\n        viewindex = viewlist.index(view) if view in viewlist else 0\n        currentindex = viewlist.index(current) if current in viewlist else 0\n\n        direction = 'left' if currentindex < viewindex else 'right'\n\n        sm.transition.direction = direction\n        sm.current = view + 'view'\n\n    def _create_entry_widget(self, ctx):\n        return [Builder.template(view._ENTRY_TEMPLATE, **ctx)\n                for view in self._views]\n\n    def _get_file_paths(self, items):\n        if self._views:\n            return [file[0].path for file in items]\n        return []\n\n    def _update_item_selection(self, *args):\n        for viewitem in self._items:\n            selected = viewitem[0].path in self.selection\n            for item in viewitem:\n                item.selected = selected\n\n    def on_entry_added(self, node, parent=None):\n        for index, view in enumerate(self._views):\n            view.dispatch(\n                'on_entry_added',\n                node[index], parent[index] if parent else None)\n\n    def on_entries_cleared(self):\n        for view in self._views:\n            view.dispatch('on_entries_cleared')\n\n    def on_subentry_to_entry(self, subentry, entry):\n        for index, view in enumerate(self._views):\n            view.dispatch('on_subentry_to_entry', subentry[index], entry)\n\n    def on_remove_subentry(self, subentry, entry):\n        for index, view in enumerate(self._views):\n            view.dispatch('on_remove_subentry', subentry[index], entry)\n\n    def on_submit(self, selected, touch=None):\n        view_mode = self.view_mode\n        for view in self._views:\n            if view_mode == view.VIEWNAME:\n                view.dispatch('on_submit', selected, touch)\n                return",
  "def listdir(self, fn):\n        '''Return the list of files in the directory `fn`\n        '''\n        pass",
  "def getsize(self, fn):\n        '''Return the size in bytes of a file\n        '''\n        pass",
  "def is_hidden(self, fn):\n        '''Return True if the file is hidden\n        '''\n        pass",
  "def is_dir(self, fn):\n        '''Return True if the argument passed to this method is a directory\n        '''\n        pass",
  "def listdir(self, fn):\n        return listdir(fn)",
  "def getsize(self, fn):\n        return getsize(fn)",
  "def is_hidden(self, fn):\n        if platform == 'win':\n            if not _have_win32file:\n                return False\n            try:\n                return GetFileAttributesExW(fn)[0] & FILE_ATTRIBUTE_HIDDEN\n            except error:\n                # This error can occurred when a file is already accessed by\n                # someone else. So don't return to True, because we have lot\n                # of chances to not being able to do anything with it.\n                Logger.exception('unable to access to <%s>' % fn)\n                return True\n\n        return basename(fn).startswith('.')",
  "def is_dir(self, fn):\n        return isdir(fn)",
  "def cancel(self, *largs):\n        '''Cancel any action from the FileChooserController.\n        '''\n        if self.parent:\n            self.parent.cancel()",
  "def on_touch_down(self, touch):\n        if self.collide_point(*touch.pos):\n            super(FileChooserProgressBase, self).on_touch_down(touch)\n            return True",
  "def on_touch_move(self, touch):\n        if self.collide_point(*touch.pos):\n            super(FileChooserProgressBase, self).on_touch_move(touch)\n            return True",
  "def on_touch_up(self, touch):\n        if self.collide_point(*touch.pos):\n            super(FileChooserProgressBase, self).on_touch_up(touch)\n            return True",
  "def on_entry_added(self, node, parent=None):\n        pass",
  "def on_entries_cleared(self):\n        pass",
  "def on_subentry_to_entry(self, subentry, entry):\n        pass",
  "def on_remove_subentry(self, subentry, entry):\n        pass",
  "def on_submit(self, selected, touch=None):\n        pass",
  "def __init__(self, **kwargs):\n        super(FileChooserListLayout, self).__init__(**kwargs)\n        self.fbind('on_entries_cleared', self.scroll_to_top)",
  "def scroll_to_top(self, *args):\n        self.ids.scrollview.scroll_y = 1.0",
  "def __init__(self, **kwargs):\n        super(FileChooserIconLayout, self).__init__(**kwargs)\n        self.fbind('on_entries_cleared', self.scroll_to_top)",
  "def scroll_to_top(self, *args):\n        self.ids.scrollview.scroll_y = 1.0",
  "def __init__(self, **kwargs):\n        self._progress = None\n        super(FileChooserController, self).__init__(**kwargs)\n\n        self._items = []\n        fbind = self.fbind\n        fbind('selection', self._update_item_selection)\n\n        self._previous_path = [self.path]\n        fbind('path', self._save_previous_path)\n        update = self._trigger_update\n        fbind('path', update)\n        fbind('filters', update)\n        fbind('rootpath', update)\n        update()",
  "def on_touch_down(self, touch):\n        # don't respond to touchs outside self\n        if not self.collide_point(*touch.pos):\n            return\n        if self.disabled:\n            return True\n        return super(FileChooserController, self).on_touch_down(touch)",
  "def on_touch_up(self, touch):\n        # don't respond to touchs outside self\n        if not self.collide_point(*touch.pos):\n            return\n        if self.disabled:\n            return True\n        return super(FileChooserController, self).on_touch_up(touch)",
  "def _update_item_selection(self, *args):\n        for item in self._items:\n            item.selected = item.path in self.selection",
  "def _save_previous_path(self, instance, value):\n        self._previous_path.append(value)\n        self._previous_path = self._previous_path[-2:]",
  "def _trigger_update(self, *args):\n        ev = self._update_files_ev\n        if ev is None:\n            ev = self._update_files_ev = Clock.create_trigger(\n                self._update_files)\n        ev()",
  "def on_entry_added(self, node, parent=None):\n        if self.layout:\n            self.layout.dispatch('on_entry_added', node, parent)",
  "def on_entries_cleared(self):\n        if self.layout:\n            self.layout.dispatch('on_entries_cleared')",
  "def on_subentry_to_entry(self, subentry, entry):\n        if self.layout:\n            self.layout.dispatch('on_subentry_to_entry', subentry, entry)",
  "def on_remove_subentry(self, subentry, entry):\n        if self.layout:\n            self.layout.dispatch('on_remove_subentry', subentry, entry)",
  "def on_submit(self, selected, touch=None):\n        if self.layout:\n            self.layout.dispatch('on_submit', selected, touch)",
  "def entry_touched(self, entry, touch):\n        '''(internal) This method must be called by the template when an entry\n        is touched by the user.\n        '''\n        if (\n            'button' in touch.profile and touch.button in (\n                'scrollup', 'scrolldown', 'scrollleft', 'scrollright')):\n            return False\n\n        _dir = self.file_system.is_dir(entry.path)\n        dirselect = self.dirselect\n\n        if _dir and dirselect and touch.is_double_tap:\n            self.open_entry(entry)\n            return\n\n        if self.multiselect:\n            if entry.path in self.selection:\n                self.selection.remove(entry.path)\n            else:\n                if _dir and not self.dirselect:\n                    self.open_entry(entry)\n                    return\n                self.selection.append(entry.path)\n        else:\n            if _dir and not self.dirselect:\n                return\n            self.selection = [abspath(join(self.path, entry.path)), ]",
  "def entry_released(self, entry, touch):\n        '''(internal) This method must be called by the template when an entry\n        is touched by the user.\n\n        .. versionadded:: 1.1.0\n        '''\n        if (\n            'button' in touch.profile and touch.button in (\n                'scrollup', 'scrolldown', 'scrollleft', 'scrollright')):\n            return False\n        if not self.multiselect:\n            if self.file_system.is_dir(entry.path) and not self.dirselect:\n                self.open_entry(entry)\n            elif touch.is_double_tap:\n                if self.dirselect and self.file_system.is_dir(entry.path):\n                    return\n                else:\n                    self.dispatch('on_submit', self.selection, touch)",
  "def open_entry(self, entry):\n        try:\n            # Just check if we can list the directory. This is also what\n            # _add_file does, so if it fails here, it would also fail later\n            # on. Do the check here to prevent setting path to an invalid\n            # directory that we cannot list.\n            self.file_system.listdir(entry.path)\n        except OSError:\n            entry.locked = True\n        else:\n            # If entry.path is to jump to previous directory, update path with\n            # parent directory\n            self.path = abspath(join(self.path, entry.path))\n            self.selection = [self.path, ] if self.dirselect else []",
  "def _apply_filters(self, files):\n        if not self.filters:\n            return files\n        filtered = []\n        for filt in self.filters:\n            if isinstance(filt, collections.abc.Callable):\n                filtered.extend([fn for fn in files if filt(self.path, fn)])\n            else:\n                filtered.extend([fn for fn in files if fnmatch(fn, filt)])\n        if not self.filter_dirs:\n            dirs = [fn for fn in files if self.file_system.is_dir(fn)]\n            filtered.extend(dirs)\n        return list(set(filtered))",
  "def get_nice_size(self, fn):\n        '''Pass the filepath. Returns the size in the best human readable\n        format or '' if it is a directory (Don't recursively calculate size).\n        '''\n        if self.file_system.is_dir(fn):\n            return ''\n        try:\n            size = self.file_system.getsize(fn)\n        except OSError:\n            return '--'\n\n        for unit in filesize_units:\n            if size < 1024.0:\n                return '%1.0f %s' % (size, unit)\n            size /= 1024.0",
  "def _update_files(self, *args, **kwargs):\n        # trigger to start gathering the files in the new directory\n        # we'll start a timer that will do the job, 10 times per frames\n        # (default)\n        self._gitems = []\n        self._gitems_parent = kwargs.get('parent', None)\n        self._gitems_gen = self._generate_file_entries(\n            path=kwargs.get('path', self.path),\n            parent=self._gitems_parent)\n        self.path = abspath(self.path)\n\n        # cancel any previous clock if exist\n        ev = self._create_files_entries_ev\n        if ev is not None:\n            ev.cancel()\n\n        # show the progression screen\n        self._hide_progress()\n        if self._create_files_entries():\n            # not enough for creating all the entries, all a clock to continue\n            # start a timer for the next 100 ms\n            if ev is None:\n                ev = self._create_files_entries_ev = Clock.schedule_interval(\n                    self._create_files_entries, .1)\n            ev()",
  "def _get_file_paths(self, items):\n        return [file.path for file in items]",
  "def _create_files_entries(self, *args):\n        # create maximum entries during 50ms max, or 10 minimum (slow system)\n        # (on a \"fast system\" (core i7 2700K), we can create up to 40 entries\n        # in 50 ms. So 10 is fine for low system.\n        start = time()\n        finished = False\n        index = total = count = 1\n        while time() - start < 0.05 or count < 10:\n            try:\n                index, total, item = next(self._gitems_gen)\n                self._gitems.append(item)\n                count += 1\n            except StopIteration:\n                finished = True\n                break\n            except TypeError:  # in case _gitems_gen is None\n                finished = True\n                break\n\n        # if this wasn't enough for creating all the entries, show a progress\n        # bar, and report the activity to the user.\n        if not finished:\n            self._show_progress()\n            self._progress.total = total\n            self._progress.index = index\n            return True\n\n        # we created all the files, now push them on the view\n        self._items = items = self._gitems\n        parent = self._gitems_parent\n        if parent is None:\n            self.dispatch('on_entries_cleared')\n            for entry in items:\n                self.dispatch('on_entry_added', entry, parent)\n        else:\n            parent.entries[:] = items\n            for entry in items:\n                self.dispatch('on_subentry_to_entry', entry, parent)\n        self.files[:] = self._get_file_paths(items)\n\n        # stop the progression / creation\n        self._hide_progress()\n        self._gitems = None\n        self._gitems_gen = None\n        ev = self._create_files_entries_ev\n        if ev is not None:\n            ev.cancel()\n        return False",
  "def cancel(self, *largs):\n        '''Cancel any background action started by filechooser, such as loading\n        a new directory.\n\n        .. versionadded:: 1.2.0\n        '''\n        ev = self._create_files_entries_ev\n        if ev is not None:\n            ev.cancel()\n\n        self._hide_progress()\n        if len(self._previous_path) > 1:\n            # if we cancel any action, the path will be set same as the\n            # previous one, so we can safely cancel the update of the previous\n            # path.\n            self.path = self._previous_path[-2]\n\n            ev = self._update_files_ev\n            if ev is not None:\n                ev.cancel()",
  "def _show_progress(self):\n        if self._progress:\n            return\n        cls = self.progress_cls\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n        self._progress = cls(path=self.path)\n        self._progress.value = 0\n        self.add_widget(self._progress)",
  "def _hide_progress(self):\n        if self._progress:\n            self.remove_widget(self._progress)\n            self._progress = None",
  "def _generate_file_entries(self, *args, **kwargs):\n        # Generator that will create all the files entries.\n        # the generator is used via _update_files() and _create_files_entries()\n        # don't use it directly.\n        is_root = False\n        path = kwargs.get('path', self.path)\n        have_parent = kwargs.get('parent', None) is not None\n\n        # Add the components that are always needed\n        if self.rootpath:\n            rootpath = realpath(self.rootpath)\n            path = realpath(path)\n            if not path.startswith(rootpath):\n                self.path = rootpath\n                return\n            elif path == rootpath:\n                is_root = True\n        else:\n            if platform == 'win':\n                is_root = splitdrive(path)[1] in (sep, altsep)\n            elif platform in ('macosx', 'linux', 'android', 'ios'):\n                is_root = normpath(expanduser(path)) == sep\n            else:\n                # Unknown fs, just always add the .. entry but also log\n                Logger.warning('Filechooser: Unsupported OS: %r' % platform)\n        # generate an entries to go back to previous\n        if not is_root and not have_parent:\n            back = '..' + sep\n            if platform == 'win':\n                new_path = path[:path.rfind(sep)]\n                if sep not in new_path:\n                    new_path += sep\n                pardir = self._create_entry_widget(dict(\n                    name=back, size='', path=new_path, controller=ref(self),\n                    isdir=True, parent=None, sep=sep,\n                    get_nice_size=lambda: ''))\n            else:\n                pardir = self._create_entry_widget(dict(\n                    name=back, size='', path=back, controller=ref(self),\n                    isdir=True, parent=None, sep=sep,\n                    get_nice_size=lambda: ''))\n            yield 0, 1, pardir\n\n        # generate all the entries for files\n        try:\n            for index, total, item in self._add_files(path):\n                yield index, total, item\n        except OSError:\n            Logger.exception('Unable to open directory <%s>' % self.path)\n            self.files[:] = []",
  "def _create_entry_widget(self, ctx):\n        template = self.layout._ENTRY_TEMPLATE\\\n            if self.layout else self._ENTRY_TEMPLATE\n        return Builder.template(template, **ctx)",
  "def _add_files(self, path, parent=None):\n        path = expanduser(path)\n        if isfile(path):\n            path = dirname(path)\n\n        files = []\n        fappend = files.append\n        for f in self.file_system.listdir(path):\n            try:\n                # In the following, use fully qualified filenames\n                fappend(normpath(join(path, f)))\n            except UnicodeDecodeError:\n                Logger.exception('unable to decode <{}>'.format(f))\n            except UnicodeEncodeError:\n                Logger.exception('unable to encode <{}>'.format(f))\n        # Apply filename filters\n        files = self._apply_filters(files)\n        # Sort the list of files\n        files = self.sort_func(files, self.file_system)\n        is_hidden = self.file_system.is_hidden\n        if not self.show_hidden:\n            files = [x for x in files if not is_hidden(x)]\n        self.files[:] = files\n        total = len(files)\n        wself = ref(self)\n        for index, fn in enumerate(files):\n\n            def get_nice_size():\n                # Use a closure for lazy-loading here\n                return self.get_nice_size(fn)\n\n            ctx = {'name': basename(fn),\n                   'get_nice_size': get_nice_size,\n                   'path': fn,\n                   'controller': wself,\n                   'isdir': self.file_system.is_dir(fn),\n                   'parent': parent,\n                   'sep': sep}\n            entry = self._create_entry_widget(ctx)\n            yield index, total, entry",
  "def entry_subselect(self, entry):\n        if not self.file_system.is_dir(entry.path):\n            return\n        self._update_files(path=entry.path, parent=entry)",
  "def close_subselection(self, entry):\n        for subentry in entry.entries:\n            self.dispatch('on_remove_subentry', subentry, entry)",
  "def get_view_list(self):\n        return self._view_list",
  "def get_view_mode(self):\n        return self._view_mode",
  "def set_view_mode(self, mode):\n        if mode not in self._view_list:\n            raise ValueError('unknown view mode %r' % mode)\n        self._view_mode = mode",
  "def _views(self):\n        return [screen.children[0] for screen in self.manager.screens]",
  "def __init__(self, **kwargs):\n        super(FileChooser, self).__init__(**kwargs)\n\n        self.manager = ScreenManager()\n        super(FileChooser, self).add_widget(self.manager)\n\n        self.trigger_update_view = Clock.create_trigger(self.update_view)\n\n        self.fbind('view_mode', self.trigger_update_view)",
  "def add_widget(self, widget, *args, **kwargs):\n        if widget is self._progress:\n            super(FileChooser, self).add_widget(widget, *args, **kwargs)\n        elif hasattr(widget, 'VIEWNAME'):\n            name = widget.VIEWNAME + 'view'\n            screen = Screen(name=name)\n            widget.controller = self\n            screen.add_widget(widget)\n            self.manager.add_widget(screen)\n\n            self.trigger_update_view()\n        else:\n            raise ValueError(\n                'widget must be a FileChooserLayout,'\n                ' not %s' % type(widget).__name__)",
  "def rebuild_views(self):\n        views = [view.VIEWNAME for view in self._views]\n        if views != self._view_list:\n            self._view_list = views\n            if self._view_mode not in self._view_list:\n                self._view_mode = self._view_list[0]\n            self._trigger_update()",
  "def update_view(self, *args):\n        self.rebuild_views()\n\n        sm = self.manager\n        viewlist = self._view_list\n        view = self.view_mode\n        current = sm.current[:-4]\n\n        viewindex = viewlist.index(view) if view in viewlist else 0\n        currentindex = viewlist.index(current) if current in viewlist else 0\n\n        direction = 'left' if currentindex < viewindex else 'right'\n\n        sm.transition.direction = direction\n        sm.current = view + 'view'",
  "def _create_entry_widget(self, ctx):\n        return [Builder.template(view._ENTRY_TEMPLATE, **ctx)\n                for view in self._views]",
  "def _get_file_paths(self, items):\n        if self._views:\n            return [file[0].path for file in items]\n        return []",
  "def _update_item_selection(self, *args):\n        for viewitem in self._items:\n            selected = viewitem[0].path in self.selection\n            for item in viewitem:\n                item.selected = selected",
  "def on_entry_added(self, node, parent=None):\n        for index, view in enumerate(self._views):\n            view.dispatch(\n                'on_entry_added',\n                node[index], parent[index] if parent else None)",
  "def on_entries_cleared(self):\n        for view in self._views:\n            view.dispatch('on_entries_cleared')",
  "def on_subentry_to_entry(self, subentry, entry):\n        for index, view in enumerate(self._views):\n            view.dispatch('on_subentry_to_entry', subentry[index], entry)",
  "def on_remove_subentry(self, subentry, entry):\n        for index, view in enumerate(self._views):\n            view.dispatch('on_remove_subentry', subentry[index], entry)",
  "def on_submit(self, selected, touch=None):\n        view_mode = self.view_mode\n        for view in self._views:\n            if view_mode == view.VIEWNAME:\n                view.dispatch('on_submit', selected, touch)\n                return",
  "class FileChooserApp(App):\n\n        def build(self):\n            v = root.ids.fc\n            if len(sys.argv) > 1:\n                v.path = sys.argv[1]\n\n            v.bind(selection=lambda *x: pprint(\"selection: %s\" % x[1:]))\n            v.bind(path=lambda *x: pprint(\"path: %s\" % x[1:]))\n\n            return root",
  "def build(self):\n            v = root.ids.fc\n            if len(sys.argv) > 1:\n                v.path = sys.argv[1]\n\n            v.bind(selection=lambda *x: pprint(\"selection: %s\" % x[1:]))\n            v.bind(path=lambda *x: pprint(\"path: %s\" % x[1:]))\n\n            return root",
  "def get_nice_size():\n                # Use a closure for lazy-loading here\n                return self.get_nice_size(fn)",
  "class RecycleGridLayout(RecycleLayout, GridLayout):\n\n    _cols_pos = None\n    _rows_pos = None\n\n    def __init__(self, **kwargs):\n        super(RecycleGridLayout, self).__init__(**kwargs)\n        self.funbind('children', self._trigger_layout)\n\n    def on_children(self, instance, value):\n        pass\n\n    def _fill_rows_cols_sizes(self):\n        cols, rows = self._cols, self._rows\n        cols_sh, rows_sh = self._cols_sh, self._rows_sh\n        cols_sh_min, rows_sh_min = self._cols_sh_min, self._rows_sh_min\n        cols_sh_max, rows_sh_max = self._cols_sh_max, self._rows_sh_max\n        self._cols_count = cols_count = [defaultdict(int) for _ in cols]\n        self._rows_count = rows_count = [defaultdict(int) for _ in rows]\n\n        # calculate minimum size for each columns and rows\n        idx_iter = self._create_idx_iter(len(cols), len(rows))\n        has_bound_y = has_bound_x = False\n        for opt, (col, row) in zip(self.view_opts, idx_iter):\n            (shw, shh), (w, h) = opt['size_hint'], opt['size']\n            shw_min, shh_min = opt['size_hint_min']\n            shw_max, shh_max = opt['size_hint_max']\n\n            if shw is None:\n                cols_count[col][w] += 1\n            if shh is None:\n                rows_count[row][h] += 1\n\n            # compute minimum size / maximum stretch needed\n            if shw is None:\n                cols[col] = nmax(cols[col], w)\n            else:\n                cols_sh[col] = nmax(cols_sh[col], shw)\n                if shw_min is not None:\n                    has_bound_x = True\n                    cols_sh_min[col] = nmax(cols_sh_min[col], shw_min)\n                if shw_max is not None:\n                    has_bound_x = True\n                    cols_sh_max[col] = nmin(cols_sh_max[col], shw_max)\n\n            if shh is None:\n                rows[row] = nmax(rows[row], h)\n            else:\n                rows_sh[row] = nmax(rows_sh[row], shh)\n                if shh_min is not None:\n                    has_bound_y = True\n                    rows_sh_min[row] = nmax(rows_sh_min[row], shh_min)\n                if shh_max is not None:\n                    has_bound_y = True\n                    rows_sh_max[row] = nmin(rows_sh_max[row], shh_max)\n        self._has_hint_bound_x = has_bound_x\n        self._has_hint_bound_y = has_bound_y\n\n    def _update_rows_cols_sizes(self, changed):\n        cols_count, rows_count = self._cols_count, self._rows_count\n        cols, rows = self._cols, self._rows\n        remove_view = self.remove_view\n        n_cols = len(cols)\n        n_rows = len(rows)\n        orientation = self.orientation\n\n        # this can be further improved to reduce re-comp, but whatever...\n        for index, widget, (w, h), (wn, hn), sh, shn, sh_min, shn_min, \\\n                sh_max, shn_max, _, _ in changed:\n            if sh != shn or sh_min != shn_min or sh_max != shn_max:\n                return True\n            elif (sh[0] is not None and w != wn and\n                  (h == hn or sh[1] is not None) or\n                  sh[1] is not None and h != hn and\n                  (w == wn or sh[0] is not None)):\n                remove_view(widget, index)\n            else:  # size hint is None, so check if it can be resized inplace\n                col, row = self._calculate_idx_from_a_view_idx(\n                    n_cols, n_rows, index)\n                if w != wn:\n                    col_w = cols[col]\n                    cols_count[col][w] -= 1\n                    cols_count[col][wn] += 1\n                    was_last_w = cols_count[col][w] <= 0\n                    if was_last_w and col_w == w or wn > col_w:\n                        return True\n                    if was_last_w:\n                        del cols_count[col][w]\n\n                if h != hn:\n                    row_h = rows[row]\n                    rows_count[row][h] -= 1\n                    rows_count[row][hn] += 1\n                    was_last_h = rows_count[row][h] <= 0\n                    if was_last_h and row_h == h or hn > row_h:\n                        return True\n                    if was_last_h:\n                        del rows_count[row][h]\n\n        return False\n\n    def compute_layout(self, data, flags):\n        super(RecycleGridLayout, self).compute_layout(data, flags)\n\n        n = len(data)\n        smax = self.get_max_widgets()\n        if smax and n > smax:\n            raise GridLayoutException(\n                'Too many children ({}) in GridLayout. Increase rows/cols!'.\n                format(n))\n\n        changed = self._changed_views\n        if (changed is None or\n                changed and not self._update_rows_cols_sizes(changed)):\n            return\n\n        self.clear_layout()\n        if not self._init_rows_cols_sizes(n):\n            self._cols_pos = None\n            l, t, r, b = self.padding\n            self.minimum_size = l + r, t + b\n            return\n        self._fill_rows_cols_sizes()\n        self._update_minimum_size()\n        self._finalize_rows_cols_sizes()\n\n        view_opts = self.view_opts\n        for widget, x, y, w, h in self._iterate_layout(n):\n            opt = view_opts[n - widget - 1]\n            shw, shh = opt['size_hint']\n            opt['pos'] = x, y\n            wo, ho = opt['size']\n            # layout won't/shouldn't change previous size if size_hint is None\n            # which is what w/h being None means.\n            opt['size'] = [(wo if shw is None else w),\n                           (ho if shh is None else h)]\n\n        spacing_x, spacing_y = self.spacing\n        cols, rows = self._cols, self._rows\n\n        cols_pos = self._cols_pos = [None, ] * len(cols)\n        rows_pos = self._rows_pos = [None, ] * len(rows)\n\n        cols_pos[0] = self.x\n        last = cols_pos[0] + self.padding[0] + cols[0] + spacing_x / 2.\n        for i, val in enumerate(cols[1:], 1):\n            cols_pos[i] = last\n            last += val + spacing_x\n\n        last = rows_pos[-1] = \\\n            self.y + self.height - self.padding[1] - rows[0] - spacing_y / 2.\n        n = len(rows)\n        for i, val in enumerate(rows[1:], 1):\n            last -= spacing_y + val\n            rows_pos[n - 1 - i] = last\n\n    def get_view_index_at(self, pos):\n        if self._cols_pos is None:\n            return 0\n\n        x, y = pos\n        col_pos = self._cols_pos\n        row_pos = self._rows_pos\n        cols, rows = self._cols, self._rows\n        if not col_pos or not row_pos:\n            return 0\n\n        if x >= col_pos[-1]:\n            ix = len(cols) - 1\n        else:\n            ix = 0\n            for val in col_pos[1:]:\n                if x < val:\n                    break\n                ix += 1\n\n        if y >= row_pos[-1]:\n            iy = len(rows) - 1\n        else:\n            iy = 0\n            for val in row_pos[1:]:\n                if y < val:\n                    break\n                iy += 1\n\n        if not self._fills_from_left_to_right:\n            ix = len(cols) - ix - 1\n        if self._fills_from_top_to_bottom:\n            iy = len(rows) - iy - 1\n        return (iy * len(cols) + ix) if self._fills_row_first else \\\n            (ix * len(rows) + iy)\n\n    def compute_visible_views(self, data, viewport):\n        if self._cols_pos is None:\n            return []\n        x, y, w, h = viewport\n        right = x + w\n        top = y + h\n        at_idx = self.get_view_index_at\n        tl, tr, bl, br = sorted((\n            at_idx((x, y)),\n            at_idx((right, y)),\n            at_idx((x, top)),\n            at_idx((right, top)),\n        ))\n\n        n = len(data)\n        if len({tl, tr, bl, br}) < 4:\n            # visible area is one row/column\n            return range(min(n, tl), min(n, br + 1))\n        indices = []\n        stride = len(self._cols) if self._fills_row_first else len(self._rows)\n        if stride:\n            x_slice = br - bl + 1\n            indices = chain_from_iterable(\n                range(min(s, n), min(n, s + x_slice))\n                for s in range(tl, bl + 1, stride))\n        return indices\n\n    def _calculate_idx_from_a_view_idx(self, n_cols, n_rows, view_idx):\n        '''returns a tuple of (column-index, row-index) from a view-index'''\n        if self._fills_row_first:\n            row_idx, col_idx = divmod(view_idx, n_cols)\n        else:\n            col_idx, row_idx = divmod(view_idx, n_rows)\n        if not self._fills_from_left_to_right:\n            col_idx = n_cols - col_idx - 1\n        if not self._fills_from_top_to_bottom:\n            row_idx = n_rows - row_idx - 1\n        return (col_idx, row_idx, )",
  "def __init__(self, **kwargs):\n        super(RecycleGridLayout, self).__init__(**kwargs)\n        self.funbind('children', self._trigger_layout)",
  "def on_children(self, instance, value):\n        pass",
  "def _fill_rows_cols_sizes(self):\n        cols, rows = self._cols, self._rows\n        cols_sh, rows_sh = self._cols_sh, self._rows_sh\n        cols_sh_min, rows_sh_min = self._cols_sh_min, self._rows_sh_min\n        cols_sh_max, rows_sh_max = self._cols_sh_max, self._rows_sh_max\n        self._cols_count = cols_count = [defaultdict(int) for _ in cols]\n        self._rows_count = rows_count = [defaultdict(int) for _ in rows]\n\n        # calculate minimum size for each columns and rows\n        idx_iter = self._create_idx_iter(len(cols), len(rows))\n        has_bound_y = has_bound_x = False\n        for opt, (col, row) in zip(self.view_opts, idx_iter):\n            (shw, shh), (w, h) = opt['size_hint'], opt['size']\n            shw_min, shh_min = opt['size_hint_min']\n            shw_max, shh_max = opt['size_hint_max']\n\n            if shw is None:\n                cols_count[col][w] += 1\n            if shh is None:\n                rows_count[row][h] += 1\n\n            # compute minimum size / maximum stretch needed\n            if shw is None:\n                cols[col] = nmax(cols[col], w)\n            else:\n                cols_sh[col] = nmax(cols_sh[col], shw)\n                if shw_min is not None:\n                    has_bound_x = True\n                    cols_sh_min[col] = nmax(cols_sh_min[col], shw_min)\n                if shw_max is not None:\n                    has_bound_x = True\n                    cols_sh_max[col] = nmin(cols_sh_max[col], shw_max)\n\n            if shh is None:\n                rows[row] = nmax(rows[row], h)\n            else:\n                rows_sh[row] = nmax(rows_sh[row], shh)\n                if shh_min is not None:\n                    has_bound_y = True\n                    rows_sh_min[row] = nmax(rows_sh_min[row], shh_min)\n                if shh_max is not None:\n                    has_bound_y = True\n                    rows_sh_max[row] = nmin(rows_sh_max[row], shh_max)\n        self._has_hint_bound_x = has_bound_x\n        self._has_hint_bound_y = has_bound_y",
  "def _update_rows_cols_sizes(self, changed):\n        cols_count, rows_count = self._cols_count, self._rows_count\n        cols, rows = self._cols, self._rows\n        remove_view = self.remove_view\n        n_cols = len(cols)\n        n_rows = len(rows)\n        orientation = self.orientation\n\n        # this can be further improved to reduce re-comp, but whatever...\n        for index, widget, (w, h), (wn, hn), sh, shn, sh_min, shn_min, \\\n                sh_max, shn_max, _, _ in changed:\n            if sh != shn or sh_min != shn_min or sh_max != shn_max:\n                return True\n            elif (sh[0] is not None and w != wn and\n                  (h == hn or sh[1] is not None) or\n                  sh[1] is not None and h != hn and\n                  (w == wn or sh[0] is not None)):\n                remove_view(widget, index)\n            else:  # size hint is None, so check if it can be resized inplace\n                col, row = self._calculate_idx_from_a_view_idx(\n                    n_cols, n_rows, index)\n                if w != wn:\n                    col_w = cols[col]\n                    cols_count[col][w] -= 1\n                    cols_count[col][wn] += 1\n                    was_last_w = cols_count[col][w] <= 0\n                    if was_last_w and col_w == w or wn > col_w:\n                        return True\n                    if was_last_w:\n                        del cols_count[col][w]\n\n                if h != hn:\n                    row_h = rows[row]\n                    rows_count[row][h] -= 1\n                    rows_count[row][hn] += 1\n                    was_last_h = rows_count[row][h] <= 0\n                    if was_last_h and row_h == h or hn > row_h:\n                        return True\n                    if was_last_h:\n                        del rows_count[row][h]\n\n        return False",
  "def compute_layout(self, data, flags):\n        super(RecycleGridLayout, self).compute_layout(data, flags)\n\n        n = len(data)\n        smax = self.get_max_widgets()\n        if smax and n > smax:\n            raise GridLayoutException(\n                'Too many children ({}) in GridLayout. Increase rows/cols!'.\n                format(n))\n\n        changed = self._changed_views\n        if (changed is None or\n                changed and not self._update_rows_cols_sizes(changed)):\n            return\n\n        self.clear_layout()\n        if not self._init_rows_cols_sizes(n):\n            self._cols_pos = None\n            l, t, r, b = self.padding\n            self.minimum_size = l + r, t + b\n            return\n        self._fill_rows_cols_sizes()\n        self._update_minimum_size()\n        self._finalize_rows_cols_sizes()\n\n        view_opts = self.view_opts\n        for widget, x, y, w, h in self._iterate_layout(n):\n            opt = view_opts[n - widget - 1]\n            shw, shh = opt['size_hint']\n            opt['pos'] = x, y\n            wo, ho = opt['size']\n            # layout won't/shouldn't change previous size if size_hint is None\n            # which is what w/h being None means.\n            opt['size'] = [(wo if shw is None else w),\n                           (ho if shh is None else h)]\n\n        spacing_x, spacing_y = self.spacing\n        cols, rows = self._cols, self._rows\n\n        cols_pos = self._cols_pos = [None, ] * len(cols)\n        rows_pos = self._rows_pos = [None, ] * len(rows)\n\n        cols_pos[0] = self.x\n        last = cols_pos[0] + self.padding[0] + cols[0] + spacing_x / 2.\n        for i, val in enumerate(cols[1:], 1):\n            cols_pos[i] = last\n            last += val + spacing_x\n\n        last = rows_pos[-1] = \\\n            self.y + self.height - self.padding[1] - rows[0] - spacing_y / 2.\n        n = len(rows)\n        for i, val in enumerate(rows[1:], 1):\n            last -= spacing_y + val\n            rows_pos[n - 1 - i] = last",
  "def get_view_index_at(self, pos):\n        if self._cols_pos is None:\n            return 0\n\n        x, y = pos\n        col_pos = self._cols_pos\n        row_pos = self._rows_pos\n        cols, rows = self._cols, self._rows\n        if not col_pos or not row_pos:\n            return 0\n\n        if x >= col_pos[-1]:\n            ix = len(cols) - 1\n        else:\n            ix = 0\n            for val in col_pos[1:]:\n                if x < val:\n                    break\n                ix += 1\n\n        if y >= row_pos[-1]:\n            iy = len(rows) - 1\n        else:\n            iy = 0\n            for val in row_pos[1:]:\n                if y < val:\n                    break\n                iy += 1\n\n        if not self._fills_from_left_to_right:\n            ix = len(cols) - ix - 1\n        if self._fills_from_top_to_bottom:\n            iy = len(rows) - iy - 1\n        return (iy * len(cols) + ix) if self._fills_row_first else \\\n            (ix * len(rows) + iy)",
  "def compute_visible_views(self, data, viewport):\n        if self._cols_pos is None:\n            return []\n        x, y, w, h = viewport\n        right = x + w\n        top = y + h\n        at_idx = self.get_view_index_at\n        tl, tr, bl, br = sorted((\n            at_idx((x, y)),\n            at_idx((right, y)),\n            at_idx((x, top)),\n            at_idx((right, top)),\n        ))\n\n        n = len(data)\n        if len({tl, tr, bl, br}) < 4:\n            # visible area is one row/column\n            return range(min(n, tl), min(n, br + 1))\n        indices = []\n        stride = len(self._cols) if self._fills_row_first else len(self._rows)\n        if stride:\n            x_slice = br - bl + 1\n            indices = chain_from_iterable(\n                range(min(s, n), min(n, s + x_slice))\n                for s in range(tl, bl + 1, stride))\n        return indices",
  "def _calculate_idx_from_a_view_idx(self, n_cols, n_rows, view_idx):\n        '''returns a tuple of (column-index, row-index) from a view-index'''\n        if self._fills_row_first:\n            row_idx, col_idx = divmod(view_idx, n_cols)\n        else:\n            col_idx, row_idx = divmod(view_idx, n_rows)\n        if not self._fills_from_left_to_right:\n            col_idx = n_cols - col_idx - 1\n        if not self._fills_from_top_to_bottom:\n            row_idx = n_rows - row_idx - 1\n        return (col_idx, row_idx, )",
  "class DropDownException(Exception):\n    '''DropDownException class.\n    '''\n    pass",
  "class DropDown(ScrollView):\n    '''DropDown class. See module documentation for more information.\n\n    :Events:\n        `on_select`: data\n            Fired when a selection is done. The data of the selection is passed\n            in as the first argument and is what you pass in the :meth:`select`\n            method as the first argument.\n        `on_dismiss`:\n            .. versionadded:: 1.8.0\n\n            Fired when the DropDown is dismissed, either on selection or on\n            touching outside the widget.\n    '''\n\n    auto_width = BooleanProperty(True)\n    '''By default, the width of the dropdown will be the same as the width of\n    the attached widget. Set to False if you want to provide your own width.\n\n    :attr:`auto_width` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True.\n    '''\n\n    max_height = NumericProperty(None, allownone=True)\n    '''Indicate the maximum height that the dropdown can take. If None, it will\n    take the maximum height available until the top or bottom of the screen\n    is reached.\n\n    :attr:`max_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to None.\n    '''\n\n    dismiss_on_select = BooleanProperty(True)\n    '''By default, the dropdown will be automatically dismissed when a\n    selection has been done. Set to False to prevent the dismiss.\n\n    :attr:`dismiss_on_select` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True.\n    '''\n\n    auto_dismiss = BooleanProperty(True)\n    '''By default, the dropdown will be automatically dismissed when a\n    touch happens outside of it, this option allows to disable this\n    feature\n\n    :attr:`auto_dismiss` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True.\n\n    .. versionadded:: 1.8.0\n    '''\n\n    min_state_time = NumericProperty(0)\n    '''Minimum time before the :class:`~kivy.uix.DropDown` is dismissed.\n    This is used to allow for the widget inside the dropdown to display\n    a down state or for the :class:`~kivy.uix.DropDown` itself to\n    display a animation for closing.\n\n    :attr:`min_state_time` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to the `Config` value `min_state_time`.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    attach_to = ObjectProperty(allownone=True)\n    '''(internal) Property that will be set to the widget to which the\n    drop down list is attached.\n\n    The :meth:`open` method will automatically set this property whilst\n    :meth:`dismiss` will set it back to None.\n    '''\n\n    container = ObjectProperty()\n    '''(internal) Property that will be set to the container of the dropdown\n    list. It is a :class:`~kivy.uix.gridlayout.GridLayout` by default.\n    '''\n\n    _touch_started_inside = None\n\n    __events__ = ('on_select', 'on_dismiss')\n\n    def __init__(self, **kwargs):\n        self._win = None\n        if 'min_state_time' not in kwargs:\n            self.min_state_time = float(\n                Config.get('graphics', 'min_state_time'))\n        if 'container' not in kwargs:\n            c = self.container = Builder.load_string(_grid_kv)\n        else:\n            c = None\n        if 'do_scroll_x' not in kwargs:\n            self.do_scroll_x = False\n        if 'size_hint' not in kwargs:\n            if 'size_hint_x' not in kwargs:\n                self.size_hint_x = None\n            if 'size_hint_y' not in kwargs:\n                self.size_hint_y = None\n        super(DropDown, self).__init__(**kwargs)\n        if c is not None:\n            super(DropDown, self).add_widget(c)\n            self.on_container(self, c)\n        Window.bind(\n            on_key_down=self.on_key_down,\n            size=self._reposition)\n        self.fbind('size', self._reposition)\n\n    def on_key_down(self, instance, key, scancode, codepoint, modifiers):\n        if key == 27 and self.get_parent_window():\n            self.dismiss()\n            return True\n\n    def on_container(self, instance, value):\n        if value is not None:\n            self.container.bind(minimum_size=self._reposition)\n\n    def open(self, widget):\n        '''Open the dropdown list and attach it to a specific widget.\n        Depending on the position of the widget within the window and\n        the height of the dropdown, the dropdown might be above or below\n        that widget.\n        '''\n        # ensure we are not already attached\n        if self.attach_to is not None:\n            self.dismiss()\n\n        # we will attach ourself to the main window, so ensure the\n        # widget we are looking for have a window\n        self._win = widget.get_parent_window()\n        if self._win is None:\n            raise DropDownException(\n                'Cannot open a dropdown list on a hidden widget')\n\n        self.attach_to = widget\n        widget.bind(pos=self._reposition, size=self._reposition)\n        self._reposition()\n\n        # attach ourself to the main window\n        self._win.add_widget(self)\n\n    def dismiss(self, *largs):\n        '''Remove the dropdown widget from the window and detach it from\n        the attached widget.\n        '''\n        Clock.schedule_once(self._real_dismiss, self.min_state_time)\n\n    def _real_dismiss(self, *largs):\n        if self.parent:\n            self.parent.remove_widget(self)\n        if self.attach_to:\n            self.attach_to.unbind(pos=self._reposition, size=self._reposition)\n            self.attach_to = None\n        self.dispatch('on_dismiss')\n\n    def on_dismiss(self):\n        pass\n\n    def select(self, data):\n        '''Call this method to trigger the `on_select` event with the `data`\n        selection. The `data` can be anything you want.\n        '''\n        self.dispatch('on_select', data)\n        if self.dismiss_on_select:\n            self.dismiss()\n\n    def on_select(self, data):\n        pass\n\n    def add_widget(self, *args, **kwargs):\n        if self.container:\n            return self.container.add_widget(*args, **kwargs)\n        return super(DropDown, self).add_widget(*args, **kwargs)\n\n    def remove_widget(self, *args, **kwargs):\n        if self.container:\n            return self.container.remove_widget(*args, **kwargs)\n        return super(DropDown, self).remove_widget(*args, **kwargs)\n\n    def clear_widgets(self, *args, **kwargs):\n        if self.container:\n            return self.container.clear_widgets(*args, **kwargs)\n        return super(DropDown, self).clear_widgets(*args, **kwargs)\n\n    def on_motion(self, etype, me):\n        super().on_motion(etype, me)\n        return True\n\n    def on_touch_down(self, touch):\n        self._touch_started_inside = self.collide_point(*touch.pos)\n        if not self.auto_dismiss or self._touch_started_inside:\n            super(DropDown, self).on_touch_down(touch)\n        return True\n\n    def on_touch_move(self, touch):\n        if not self.auto_dismiss or self._touch_started_inside:\n            super(DropDown, self).on_touch_move(touch)\n        return True\n\n    def on_touch_up(self, touch):\n        # Explicitly test for False as None occurs when shown by on_touch_down\n        if self.auto_dismiss and self._touch_started_inside is False:\n            self.dismiss()\n        else:\n            super(DropDown, self).on_touch_up(touch)\n        self._touch_started_inside = None\n        return True\n\n    def _reposition(self, *largs):\n        # calculate the coordinate of the attached widget in the window\n        # coordinate system\n        win = self._win\n        if not win:\n            return\n        widget = self.attach_to\n        if not widget or not widget.get_parent_window():\n            return\n        wx, wy = widget.to_window(*widget.pos)\n        wright, wtop = widget.to_window(widget.right, widget.top)\n\n        if self.auto_width:\n            self.width = wright - wx\n\n        # ensure the dropdown list doesn't get out on the X axis, with a\n        # preference to 0 in case the list is too wide.\n        x = wx\n        if x + self.width > win.width:\n            x = win.width - self.width\n        if x < 0:\n            x = 0\n        self.x = x\n\n        # determine if we display the dropdown upper or lower to the widget\n        if self.max_height is not None:\n            height = min(self.max_height, self.container.minimum_height)\n        else:\n            height = self.container.minimum_height\n\n        h_bottom = wy - height\n        h_top = win.height - (wtop + height)\n        if h_bottom > 0:\n            self.top = wy\n            self.height = height\n        elif h_top > 0:\n            self.y = wtop\n            self.height = height\n        else:\n            # none of both top/bottom have enough place to display the\n            # widget at the current size. Take the best side, and fit to\n            # it.\n            if h_top < h_bottom:\n                self.top = self.height = wy\n            else:\n                self.y = wtop\n                self.height = win.height - wtop",
  "def __init__(self, **kwargs):\n        self._win = None\n        if 'min_state_time' not in kwargs:\n            self.min_state_time = float(\n                Config.get('graphics', 'min_state_time'))\n        if 'container' not in kwargs:\n            c = self.container = Builder.load_string(_grid_kv)\n        else:\n            c = None\n        if 'do_scroll_x' not in kwargs:\n            self.do_scroll_x = False\n        if 'size_hint' not in kwargs:\n            if 'size_hint_x' not in kwargs:\n                self.size_hint_x = None\n            if 'size_hint_y' not in kwargs:\n                self.size_hint_y = None\n        super(DropDown, self).__init__(**kwargs)\n        if c is not None:\n            super(DropDown, self).add_widget(c)\n            self.on_container(self, c)\n        Window.bind(\n            on_key_down=self.on_key_down,\n            size=self._reposition)\n        self.fbind('size', self._reposition)",
  "def on_key_down(self, instance, key, scancode, codepoint, modifiers):\n        if key == 27 and self.get_parent_window():\n            self.dismiss()\n            return True",
  "def on_container(self, instance, value):\n        if value is not None:\n            self.container.bind(minimum_size=self._reposition)",
  "def open(self, widget):\n        '''Open the dropdown list and attach it to a specific widget.\n        Depending on the position of the widget within the window and\n        the height of the dropdown, the dropdown might be above or below\n        that widget.\n        '''\n        # ensure we are not already attached\n        if self.attach_to is not None:\n            self.dismiss()\n\n        # we will attach ourself to the main window, so ensure the\n        # widget we are looking for have a window\n        self._win = widget.get_parent_window()\n        if self._win is None:\n            raise DropDownException(\n                'Cannot open a dropdown list on a hidden widget')\n\n        self.attach_to = widget\n        widget.bind(pos=self._reposition, size=self._reposition)\n        self._reposition()\n\n        # attach ourself to the main window\n        self._win.add_widget(self)",
  "def dismiss(self, *largs):\n        '''Remove the dropdown widget from the window and detach it from\n        the attached widget.\n        '''\n        Clock.schedule_once(self._real_dismiss, self.min_state_time)",
  "def _real_dismiss(self, *largs):\n        if self.parent:\n            self.parent.remove_widget(self)\n        if self.attach_to:\n            self.attach_to.unbind(pos=self._reposition, size=self._reposition)\n            self.attach_to = None\n        self.dispatch('on_dismiss')",
  "def on_dismiss(self):\n        pass",
  "def select(self, data):\n        '''Call this method to trigger the `on_select` event with the `data`\n        selection. The `data` can be anything you want.\n        '''\n        self.dispatch('on_select', data)\n        if self.dismiss_on_select:\n            self.dismiss()",
  "def on_select(self, data):\n        pass",
  "def add_widget(self, *args, **kwargs):\n        if self.container:\n            return self.container.add_widget(*args, **kwargs)\n        return super(DropDown, self).add_widget(*args, **kwargs)",
  "def remove_widget(self, *args, **kwargs):\n        if self.container:\n            return self.container.remove_widget(*args, **kwargs)\n        return super(DropDown, self).remove_widget(*args, **kwargs)",
  "def clear_widgets(self, *args, **kwargs):\n        if self.container:\n            return self.container.clear_widgets(*args, **kwargs)\n        return super(DropDown, self).clear_widgets(*args, **kwargs)",
  "def on_motion(self, etype, me):\n        super().on_motion(etype, me)\n        return True",
  "def on_touch_down(self, touch):\n        self._touch_started_inside = self.collide_point(*touch.pos)\n        if not self.auto_dismiss or self._touch_started_inside:\n            super(DropDown, self).on_touch_down(touch)\n        return True",
  "def on_touch_move(self, touch):\n        if not self.auto_dismiss or self._touch_started_inside:\n            super(DropDown, self).on_touch_move(touch)\n        return True",
  "def on_touch_up(self, touch):\n        # Explicitly test for False as None occurs when shown by on_touch_down\n        if self.auto_dismiss and self._touch_started_inside is False:\n            self.dismiss()\n        else:\n            super(DropDown, self).on_touch_up(touch)\n        self._touch_started_inside = None\n        return True",
  "def _reposition(self, *largs):\n        # calculate the coordinate of the attached widget in the window\n        # coordinate system\n        win = self._win\n        if not win:\n            return\n        widget = self.attach_to\n        if not widget or not widget.get_parent_window():\n            return\n        wx, wy = widget.to_window(*widget.pos)\n        wright, wtop = widget.to_window(widget.right, widget.top)\n\n        if self.auto_width:\n            self.width = wright - wx\n\n        # ensure the dropdown list doesn't get out on the X axis, with a\n        # preference to 0 in case the list is too wide.\n        x = wx\n        if x + self.width > win.width:\n            x = win.width - self.width\n        if x < 0:\n            x = 0\n        self.x = x\n\n        # determine if we display the dropdown upper or lower to the widget\n        if self.max_height is not None:\n            height = min(self.max_height, self.container.minimum_height)\n        else:\n            height = self.container.minimum_height\n\n        h_bottom = wy - height\n        h_top = win.height - (wtop + height)\n        if h_bottom > 0:\n            self.top = wy\n            self.height = height\n        elif h_top > 0:\n            self.y = wtop\n            self.height = height\n        else:\n            # none of both top/bottom have enough place to display the\n            # widget at the current size. Take the best side, and fit to\n            # it.\n            if h_top < h_bottom:\n                self.top = self.height = wy\n            else:\n                self.y = wtop\n                self.height = win.height - wtop",
  "def show_dropdown(button, *largs):\n        dp = DropDown()\n        dp.bind(on_select=lambda instance, x: setattr(button, 'text', x))\n        for i in range(10):\n            item = Button(text='hello %d' % i, size_hint_y=None, height=44)\n            item.bind(on_release=lambda btn: dp.select(btn.text))\n            dp.add_widget(item)\n        dp.open(button)",
  "def touch_move(instance, touch):\n        instance.center = touch.pos",
  "class ActionBarException(Exception):\n    '''\n    ActionBarException class\n    '''\n    pass",
  "class ActionItem(object):\n    '''\n    ActionItem class, an abstract class for all ActionBar widgets. To create a\n    custom widget for an ActionBar, inherit from this class. See module\n    documentation for more information.\n    '''\n\n    minimum_width = NumericProperty('90sp')\n    '''\n    Minimum Width required by an ActionItem.\n\n    :attr:`minimum_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to '90sp'.\n    '''\n\n    def get_pack_width(self):\n        return max(self.minimum_width, self.width)\n\n    pack_width = AliasProperty(get_pack_width,\n                               bind=('minimum_width', 'width'),\n                               cache=True)\n    '''\n    (read-only) The actual width to use when packing the items. Equal to the\n    greater of minimum_width and width.\n\n    :attr:`pack_width` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    important = BooleanProperty(False)\n    '''\n    Determines if an ActionItem is important or not. If an item is important\n    and space is limited, this item will be displayed in preference to others.\n\n    :attr:`important` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    inside_group = BooleanProperty(False)\n    '''\n    (internal) Determines if an ActionItem is displayed inside an\n    ActionGroup or not.\n\n    :attr:`inside_group` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    background_normal = StringProperty(\n        'atlas://data/images/defaulttheme/action_item')\n    '''\n    Background image of the ActionItem used for the default graphical\n    representation when the ActionItem is not pressed.\n\n    :attr:`background_normal` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/action_item'.\n    '''\n\n    background_down = StringProperty(\n        'atlas://data/images/defaulttheme/action_item_down')\n    '''\n    Background image of the ActionItem used for the default graphical\n    representation when an ActionItem is pressed.\n\n    :attr:`background_down` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/action_item_down'.\n    '''\n\n    mipmap = BooleanProperty(True)\n    '''\n    Defines whether the image/icon dispayed on top of the button uses a\n    mipmap or not.\n\n    :attr:`mipmap` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to `True`.\n    '''",
  "class ActionButton(Button, ActionItem):\n    '''\n    ActionButton class, see module documentation for more information.\n\n    The text color, width and size_hint_x are set manually via the Kv language\n    file. It covers a lot of cases: with/without an icon, with/without a group\n    and takes care of the padding between elements.\n\n    You don't have much control over these properties, so if you want to\n    customize its appearance, we suggest you create you own button\n    representation. You can do this by creating a class that subclasses an\n    existing widget and an :class:`ActionItem`::\n\n        class MyOwnActionButton(Button, ActionItem):\n            pass\n\n    You can then create your own style using the Kv language.\n    '''\n\n    icon = StringProperty(None, allownone=True)\n    '''\n    Source image to use when the Button is part of the ActionBar. If the\n    Button is in a group, the text will be preferred.\n\n    :attr:`icon` is a :class:`~kivy.properties.StringProperty` and defaults\n    to None.\n    '''",
  "class ActionPrevious(BoxLayout, ActionItem):\n    '''\n    ActionPrevious class, see module documentation for more information.\n    '''\n\n    with_previous = BooleanProperty(True)\n    '''\n    Specifies whether the previous_icon will be shown or not. Note that it is\n    up to the user to implement the desired behavior using the *on_press* or\n    similar events.\n\n    :attr:`with_previous` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    app_icon = StringProperty(window_icon)\n    '''\n    Application icon for the ActionView.\n\n    :attr:`app_icon` is a :class:`~kivy.properties.StringProperty`\n    and defaults to the window icon if set, otherwise\n    'data/logo/kivy-icon-32.png'.\n    '''\n\n    app_icon_width = NumericProperty(0)\n    '''\n    Width of app_icon image.\n\n    :attr:`app_icon_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    app_icon_height = NumericProperty(0)\n    '''\n    Height of app_icon image.\n\n    :attr:`app_icon_height` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 0.\n    '''\n\n    color = ColorProperty([1, 1, 1, 1])\n    '''\n    Text color, in the format (r, g, b, a)\n\n    :attr:`color` is a :class:`~kivy.properties.ColorProperty` and defaults\n    to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    previous_image = StringProperty(\n        'atlas://data/images/defaulttheme/previous_normal')\n    '''\n    Image for the 'previous' ActionButtons default graphical representation.\n\n    :attr:`previous_image` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/previous_normal'.\n    '''\n\n    previous_image_width = NumericProperty(0)\n    '''\n    Width of previous_image image.\n\n    :attr:`width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    previous_image_height = NumericProperty(0)\n    '''\n    Height of previous_image image.\n\n    :attr:`app_icon_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    title = StringProperty('')\n    '''\n    Title for ActionView.\n\n    :attr:`title` is a :class:`~kivy.properties.StringProperty` and\n    defaults to ''.\n    '''\n\n    markup = BooleanProperty(False)\n    '''\n    If True, the text will be rendered using the\n    :class:`~kivy.core.text.markup.MarkupLabel`: you can change the style of\n    the text using tags. Check the :doc:`api-kivy.core.text.markup`\n    documentation for more information.\n\n    :attr:`markup` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    def __init__(self, **kwargs):\n        self.register_event_type('on_press')\n        self.register_event_type('on_release')\n        super(ActionPrevious, self).__init__(**kwargs)\n        if not self.app_icon:\n            self.app_icon = 'data/logo/kivy-icon-32.png'\n\n    def on_press(self):\n        pass\n\n    def on_release(self):\n        pass",
  "class ActionToggleButton(ActionItem, ToggleButton):\n    '''\n    ActionToggleButton class, see module documentation for more information.\n    '''\n\n    icon = StringProperty(None, allownone=True)\n    '''\n    Source image to use when the Button is part of the ActionBar. If the\n    Button is in a group, the text will be preferred.\n    '''",
  "class ActionLabel(ActionItem, Label):\n    '''\n    ActionLabel class, see module documentation for more information.\n    '''\n    pass",
  "class ActionCheck(ActionItem, CheckBox):\n    '''\n    ActionCheck class, see module documentation for more information.\n    '''\n    pass",
  "class ActionSeparator(ActionItem, Widget):\n    '''\n    ActionSeparator class, see module documentation for more information.\n    '''\n\n    background_image = StringProperty(\n        'atlas://data/images/defaulttheme/separator')\n    '''\n    Background image for the separators default graphical representation.\n\n    :attr:`background_image` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/separator'.\n    '''",
  "class ActionDropDown(DropDown):\n    '''\n    ActionDropDown class, see module documentation for more information.\n    '''",
  "class ActionGroup(ActionItem, Button):\n    '''\n    ActionGroup class, see module documentation for more information.\n    '''\n\n    use_separator = BooleanProperty(False)\n    '''\n    Specifies whether to use a separator after/before this group or not.\n\n    :attr:`use_separator` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    separator_image = StringProperty(\n        'atlas://data/images/defaulttheme/separator')\n    '''\n    Background Image for an ActionSeparator in an ActionView.\n\n    :attr:`separator_image` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/separator'.\n    '''\n\n    separator_width = NumericProperty(0)\n    '''\n    Width of the ActionSeparator in an ActionView.\n\n    :attr:`separator_width` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 0.\n    '''\n\n    mode = OptionProperty('normal', options=('normal', 'spinner'))\n    '''\n    Sets the current mode of an ActionGroup. If mode is 'normal', the\n    ActionGroups children will be displayed normally if there is enough\n    space, otherwise they will be displayed in a spinner. If mode is\n    'spinner', then the children will always be displayed in a spinner.\n\n    :attr:`mode` is an :class:`~kivy.properties.OptionProperty` and defaults\n    to 'normal'.\n    '''\n\n    dropdown_width = NumericProperty(0)\n    '''\n    If non zero, provides the width for the associated DropDown. This is\n    useful when some items in the ActionGroup's DropDown are wider than usual\n    and you don't want to make the ActionGroup widget itself wider.\n\n    :attr:`dropdown_width` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 0.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    is_open = BooleanProperty(False)\n    '''By default, the DropDown is not open. Set to True to open it.\n\n    :attr:`is_open` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    def __init__(self, **kwargs):\n        self.list_action_item = []\n        self._list_overflow_items = []\n        super(ActionGroup, self).__init__(**kwargs)\n\n        # real is_open independent on public event\n        self._is_open = False\n\n        # create DropDown for the group and save its state to _is_open\n        self._dropdown = ActionDropDown()\n        self._dropdown.bind(attach_to=lambda ins, value: setattr(\n            self, '_is_open', True if value else False\n        ))\n\n        # put open/close responsibility to the event\n        # - trigger dropdown opening when clicked\n        self.bind(on_release=lambda *args: setattr(\n            self, 'is_open', True\n        ))\n\n        # - trigger dropdown closing when an item\n        #   in the dropdown is clicked\n        self._dropdown.bind(on_dismiss=lambda *args: setattr(\n            self, 'is_open', False\n        ))\n\n    def on_is_open(self, instance, value):\n        # opening only if the DropDown is closed\n        if value and not self._is_open:\n            self._toggle_dropdown()\n            self._dropdown.open(self)\n            return\n\n        # closing is_open manually, dismiss manually\n        if not value and self._is_open:\n            self._dropdown.dismiss()\n\n    def _toggle_dropdown(self, *largs):\n        ddn = self._dropdown\n        ddn.size_hint_x = None\n\n        # if container was set incorrectly and/or is missing\n        if not ddn.container:\n            return\n        children = ddn.container.children\n\n        # set DropDown width manually or if not set, then widen\n        # the ActionGroup + DropDown until the widest child fits\n        if children:\n            ddn.width = self.dropdown_width or max(\n                self.width, max(c.pack_width for c in children)\n            )\n        else:\n            ddn.width = self.width\n\n        # set the DropDown children's height\n        for item in children:\n            item.size_hint_y = None\n            item.height = max([self.height, sp(48)])\n\n            # dismiss DropDown manually\n            # auto_dismiss applies to touching outside of the DropDown\n            item.bind(on_release=ddn.dismiss)\n\n    def add_widget(self, widget, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n            Renamed argument `item` to `widget`.\n        '''\n        # if adding ActionSeparator ('normal' mode,\n        # everything visible), add it to the parent\n        if isinstance(widget, ActionSeparator):\n            super(ActionGroup, self).add_widget(widget, *args, **kwargs)\n            return\n\n        if not isinstance(widget, ActionItem):\n            raise ActionBarException('ActionGroup only accepts ActionItem')\n\n        self.list_action_item.append(widget)\n\n    def show_group(self):\n        # 'normal' mode, items can fit to the view\n        self.clear_widgets()\n        for item in self._list_overflow_items + self.list_action_item:\n            item.inside_group = True\n            self._dropdown.add_widget(item)\n\n    def clear_widgets(self, *args, **kwargs):\n        self._dropdown.clear_widgets(*args, **kwargs)",
  "class ActionOverflow(ActionGroup):\n    '''\n    ActionOverflow class, see module documentation for more information.\n    '''\n\n    overflow_image = StringProperty(\n        'atlas://data/images/defaulttheme/overflow')\n    '''\n    Image to be used as an Overflow Image.\n\n    :attr:`overflow_image` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/overflow'.\n    '''\n\n    def add_widget(self, widget, index=0, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n             Renamed argument `action_item` to `widget`.\n        '''\n        if widget is None:\n            return\n\n        if isinstance(widget, ActionSeparator):\n            return\n\n        if not isinstance(widget, ActionItem):\n            raise ActionBarException('ActionView only accepts ActionItem'\n                                     ' (got {!r}'.format(widget))\n\n        else:\n            if index == 0:\n                index = len(self._list_overflow_items)\n            self._list_overflow_items.insert(index, widget)\n\n    def show_default_items(self, parent):\n        # display overflow and its items if widget's directly added to it\n        if self._list_overflow_items == []:\n            return\n        self.show_group()\n        super(ActionView, parent).add_widget(self)",
  "class ActionView(BoxLayout):\n    '''\n    ActionView class, see module documentation for more information.\n    '''\n\n    action_previous = ObjectProperty(None)\n    '''\n    Previous button for an ActionView.\n\n    :attr:`action_previous` is an :class:`~kivy.properties.ObjectProperty`\n    and defaults to None.\n    '''\n\n    background_color = ColorProperty([1, 1, 1, 1])\n    '''\n    Background color in the format (r, g, b, a).\n\n    :attr:`background_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    background_image = StringProperty(\n        'atlas://data/images/defaulttheme/action_view')\n    '''\n    Background image of an ActionViews default graphical representation.\n\n    :attr:`background_image` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/action_view'.\n    '''\n\n    use_separator = BooleanProperty(False)\n    '''\n    Specify whether to use a separator before every ActionGroup or not.\n\n    :attr:`use_separator` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    overflow_group = ObjectProperty(None)\n    '''\n    Widget to be used for the overflow.\n\n    :attr:`overflow_group` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to an instance of :class:`ActionOverflow`.\n    '''\n\n    def __init__(self, **kwargs):\n        self._list_action_items = []\n        self._list_action_group = []\n        super(ActionView, self).__init__(**kwargs)\n        self._state = ''\n        if not self.overflow_group:\n            self.overflow_group = ActionOverflow(\n                use_separator=self.use_separator)\n\n    def on_action_previous(self, instance, value):\n        self._list_action_items.insert(0, value)\n\n    def add_widget(self, widget, index=0, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n            Renamed argument `action_item` to `widget`.\n        '''\n        if widget is None:\n            return\n\n        if not isinstance(widget, ActionItem):\n            raise ActionBarException('ActionView only accepts ActionItem'\n                                     ' (got {!r}'.format(widget))\n\n        elif isinstance(widget, ActionOverflow):\n            self.overflow_group = widget\n            widget.use_separator = self.use_separator\n\n        elif isinstance(widget, ActionGroup):\n            self._list_action_group.append(widget)\n            widget.use_separator = self.use_separator\n\n        elif isinstance(widget, ActionPrevious):\n            self.action_previous = widget\n\n        else:\n            super(ActionView, self).add_widget(widget, index, *args, **kwargs)\n            if index == 0:\n                index = len(self._list_action_items)\n            self._list_action_items.insert(index, widget)\n\n    def on_use_separator(self, instance, value):\n        for group in self._list_action_group:\n            group.use_separator = value\n        if self.overflow_group:\n            self.overflow_group.use_separator = value\n\n    def remove_widget(self, widget, *args, **kwargs):\n        super(ActionView, self).remove_widget(widget, *args, **kwargs)\n        if isinstance(widget, ActionOverflow):\n            for item in widget.list_action_item:\n                if item in self._list_action_items:\n                    self._list_action_items.remove(item)\n\n        if widget in self._list_action_items:\n            self._list_action_items.remove(widget)\n\n    def _clear_all(self):\n        lst = self._list_action_items[:]\n        self.clear_widgets()\n        for group in self._list_action_group:\n            group.clear_widgets()\n\n        self.overflow_group.clear_widgets()\n        self.overflow_group.list_action_item = []\n        self._list_action_items = lst\n\n    def _layout_all(self):\n        # all the items can fit to the view, so expand everything\n        super_add = super(ActionView, self).add_widget\n        self._state = 'all'\n        self._clear_all()\n        if not self.action_previous.parent:\n            super_add(self.action_previous)\n        if len(self._list_action_items) > 1:\n            for child in self._list_action_items[1:]:\n                child.inside_group = False\n                super_add(child)\n\n        for group in self._list_action_group:\n            if group.mode == 'spinner':\n                super_add(group)\n                group.show_group()\n            else:\n                if group.list_action_item != []:\n                    super_add(ActionSeparator())\n                for child in group.list_action_item:\n                    child.inside_group = False\n                    super_add(child)\n\n        self.overflow_group.show_default_items(self)\n\n    def _layout_group(self):\n        # layout all the items in order to pack them per group\n        super_add = super(ActionView, self).add_widget\n        self._state = 'group'\n        self._clear_all()\n        if not self.action_previous.parent:\n            super_add(self.action_previous)\n        if len(self._list_action_items) > 1:\n            for child in self._list_action_items[1:]:\n                super_add(child)\n                child.inside_group = False\n\n        for group in self._list_action_group:\n            super_add(group)\n            group.show_group()\n\n        self.overflow_group.show_default_items(self)\n\n    def _layout_random(self):\n        # layout the items in order to pack all of them grouped, and display\n        # only the action items having 'important'\n        super_add = super(ActionView, self).add_widget\n        self._state = 'random'\n        self._clear_all()\n        hidden_items = []\n        hidden_groups = []\n        total_width = 0\n        if not self.action_previous.parent:\n            super_add(self.action_previous)\n\n        width = (self.width - self.overflow_group.pack_width -\n                 self.action_previous.minimum_width)\n\n        if len(self._list_action_items):\n            for child in self._list_action_items[1:]:\n                if child.important:\n                    if child.pack_width + total_width < width:\n                        super_add(child)\n                        child.inside_group = False\n                        total_width += child.pack_width\n                    else:\n                        hidden_items.append(child)\n                else:\n                    hidden_items.append(child)\n\n        # if space is left then display ActionItem inside their\n        # ActionGroup\n        if total_width < self.width:\n            for group in self._list_action_group:\n                if group.pack_width + total_width +\\\n                        group.separator_width < width:\n                    super_add(group)\n                    group.show_group()\n                    total_width += (group.pack_width +\n                                    group.separator_width)\n\n                else:\n                    hidden_groups.append(group)\n        group_index = len(self.children) - 1\n        # if space is left then display other ActionItems\n        if total_width < self.width:\n            for child in hidden_items[:]:\n                if child.pack_width + total_width < width:\n                    super_add(child, group_index)\n                    total_width += child.pack_width\n                    child.inside_group = False\n                    hidden_items.remove(child)\n\n        # for all the remaining ActionItems and ActionItems with in\n        # ActionGroups, Display them inside overflow_group\n        extend_hidden = hidden_items.extend\n        for group in hidden_groups:\n            extend_hidden(group.list_action_item)\n\n        overflow_group = self.overflow_group\n\n        if hidden_items != []:\n            over_add = super(overflow_group.__class__,\n                             overflow_group).add_widget\n            for child in hidden_items:\n                over_add(child)\n\n            overflow_group.show_group()\n            if not self.overflow_group.parent:\n                super_add(overflow_group)\n\n    def on_width(self, width, *args):\n        # determine the layout to use\n\n        # can we display all of them?\n        total_width = 0\n        for child in self._list_action_items:\n            total_width += child.pack_width\n        for group in self._list_action_group:\n            for child in group.list_action_item:\n                total_width += child.pack_width\n        if total_width <= self.width:\n            if self._state != 'all':\n                self._layout_all()\n            return\n\n        # can we display them per group?\n        total_width = 0\n        for child in self._list_action_items:\n            total_width += child.pack_width\n        for group in self._list_action_group:\n            total_width += group.pack_width\n        if total_width < self.width:\n            # ok, we can display all the items grouped\n            if self._state != 'group':\n                self._layout_group()\n            return\n\n        # none of the solutions worked, display them in pack mode\n        self._layout_random()",
  "class ContextualActionView(ActionView):\n    '''\n    ContextualActionView class, see the module documentation for more\n    information.\n    '''\n    pass",
  "class ActionBar(BoxLayout):\n    '''\n    ActionBar class, which acts as the main container for an\n    :class:`ActionView` instance. The ActionBar determines the overall\n    styling aspects of the bar. :class:`ActionItem`\\\\s are not added to\n    this class directly, but to the contained :class:`ActionView` instance.\n\n    :Events:\n        `on_previous`\n            Fired when action_previous of action_view is pressed.\n\n    Please see the module documentation for more information.\n    '''\n\n    action_view = ObjectProperty(None)\n    '''\n    action_view of the ActionBar.\n\n    :attr:`action_view` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None or the last ActionView instance added to the ActionBar.\n    '''\n\n    background_color = ColorProperty([1, 1, 1, 1])\n    '''\n    Background color, in the format (r, g, b, a).\n\n    :attr:`background_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    background_image = StringProperty(\n        'atlas://data/images/defaulttheme/action_bar')\n\n    '''\n    Background image of the ActionBars default graphical representation.\n\n    :attr:`background_image` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/action_bar'.\n    '''\n\n    border = ListProperty([2, 2, 2, 2])\n    '''\n    The border to be applied to the :attr:`background_image`.\n\n    :attr:`border` is a :class:`~kivy.properties.ListProperty` and defaults to\n    [2, 2, 2, 2]\n    '''\n\n    __events__ = ('on_previous',)\n\n    def __init__(self, **kwargs):\n        super(ActionBar, self).__init__(**kwargs)\n        self._stack_cont_action_view = []\n        self._emit_previous = partial(self.dispatch, 'on_previous')\n\n    def add_widget(self, widget, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n            Renamed argument `view` to `widget`.\n        '''\n        if isinstance(widget, ContextualActionView):\n            self._stack_cont_action_view.append(widget)\n            if widget.action_previous is not None:\n                widget.action_previous.unbind(on_release=self._emit_previous)\n                widget.action_previous.bind(on_release=self._emit_previous)\n            self.clear_widgets()\n            super(ActionBar, self).add_widget(widget, *args, **kwargs)\n\n        elif isinstance(widget, ActionView):\n            self.action_view = widget\n            super(ActionBar, self).add_widget(widget, *args, **kwargs)\n\n        else:\n            raise ActionBarException(\n                'ActionBar can only add ContextualActionView or ActionView')\n\n    def on_previous(self, *args):\n        self._pop_contextual_action_view()\n\n    def _pop_contextual_action_view(self):\n        '''Remove the current ContextualActionView and display either the\n           previous one or the ActionView.\n        '''\n        self._stack_cont_action_view.pop()\n        self.clear_widgets()\n        if self._stack_cont_action_view == []:\n            super(ActionBar, self).add_widget(self.action_view)\n        else:\n            super(ActionBar, self).add_widget(self._stack_cont_action_view[-1])",
  "def get_pack_width(self):\n        return max(self.minimum_width, self.width)",
  "def __init__(self, **kwargs):\n        self.register_event_type('on_press')\n        self.register_event_type('on_release')\n        super(ActionPrevious, self).__init__(**kwargs)\n        if not self.app_icon:\n            self.app_icon = 'data/logo/kivy-icon-32.png'",
  "def on_press(self):\n        pass",
  "def on_release(self):\n        pass",
  "def __init__(self, **kwargs):\n        self.list_action_item = []\n        self._list_overflow_items = []\n        super(ActionGroup, self).__init__(**kwargs)\n\n        # real is_open independent on public event\n        self._is_open = False\n\n        # create DropDown for the group and save its state to _is_open\n        self._dropdown = ActionDropDown()\n        self._dropdown.bind(attach_to=lambda ins, value: setattr(\n            self, '_is_open', True if value else False\n        ))\n\n        # put open/close responsibility to the event\n        # - trigger dropdown opening when clicked\n        self.bind(on_release=lambda *args: setattr(\n            self, 'is_open', True\n        ))\n\n        # - trigger dropdown closing when an item\n        #   in the dropdown is clicked\n        self._dropdown.bind(on_dismiss=lambda *args: setattr(\n            self, 'is_open', False\n        ))",
  "def on_is_open(self, instance, value):\n        # opening only if the DropDown is closed\n        if value and not self._is_open:\n            self._toggle_dropdown()\n            self._dropdown.open(self)\n            return\n\n        # closing is_open manually, dismiss manually\n        if not value and self._is_open:\n            self._dropdown.dismiss()",
  "def _toggle_dropdown(self, *largs):\n        ddn = self._dropdown\n        ddn.size_hint_x = None\n\n        # if container was set incorrectly and/or is missing\n        if not ddn.container:\n            return\n        children = ddn.container.children\n\n        # set DropDown width manually or if not set, then widen\n        # the ActionGroup + DropDown until the widest child fits\n        if children:\n            ddn.width = self.dropdown_width or max(\n                self.width, max(c.pack_width for c in children)\n            )\n        else:\n            ddn.width = self.width\n\n        # set the DropDown children's height\n        for item in children:\n            item.size_hint_y = None\n            item.height = max([self.height, sp(48)])\n\n            # dismiss DropDown manually\n            # auto_dismiss applies to touching outside of the DropDown\n            item.bind(on_release=ddn.dismiss)",
  "def add_widget(self, widget, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n            Renamed argument `item` to `widget`.\n        '''\n        # if adding ActionSeparator ('normal' mode,\n        # everything visible), add it to the parent\n        if isinstance(widget, ActionSeparator):\n            super(ActionGroup, self).add_widget(widget, *args, **kwargs)\n            return\n\n        if not isinstance(widget, ActionItem):\n            raise ActionBarException('ActionGroup only accepts ActionItem')\n\n        self.list_action_item.append(widget)",
  "def show_group(self):\n        # 'normal' mode, items can fit to the view\n        self.clear_widgets()\n        for item in self._list_overflow_items + self.list_action_item:\n            item.inside_group = True\n            self._dropdown.add_widget(item)",
  "def clear_widgets(self, *args, **kwargs):\n        self._dropdown.clear_widgets(*args, **kwargs)",
  "def add_widget(self, widget, index=0, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n             Renamed argument `action_item` to `widget`.\n        '''\n        if widget is None:\n            return\n\n        if isinstance(widget, ActionSeparator):\n            return\n\n        if not isinstance(widget, ActionItem):\n            raise ActionBarException('ActionView only accepts ActionItem'\n                                     ' (got {!r}'.format(widget))\n\n        else:\n            if index == 0:\n                index = len(self._list_overflow_items)\n            self._list_overflow_items.insert(index, widget)",
  "def show_default_items(self, parent):\n        # display overflow and its items if widget's directly added to it\n        if self._list_overflow_items == []:\n            return\n        self.show_group()\n        super(ActionView, parent).add_widget(self)",
  "def __init__(self, **kwargs):\n        self._list_action_items = []\n        self._list_action_group = []\n        super(ActionView, self).__init__(**kwargs)\n        self._state = ''\n        if not self.overflow_group:\n            self.overflow_group = ActionOverflow(\n                use_separator=self.use_separator)",
  "def on_action_previous(self, instance, value):\n        self._list_action_items.insert(0, value)",
  "def add_widget(self, widget, index=0, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n            Renamed argument `action_item` to `widget`.\n        '''\n        if widget is None:\n            return\n\n        if not isinstance(widget, ActionItem):\n            raise ActionBarException('ActionView only accepts ActionItem'\n                                     ' (got {!r}'.format(widget))\n\n        elif isinstance(widget, ActionOverflow):\n            self.overflow_group = widget\n            widget.use_separator = self.use_separator\n\n        elif isinstance(widget, ActionGroup):\n            self._list_action_group.append(widget)\n            widget.use_separator = self.use_separator\n\n        elif isinstance(widget, ActionPrevious):\n            self.action_previous = widget\n\n        else:\n            super(ActionView, self).add_widget(widget, index, *args, **kwargs)\n            if index == 0:\n                index = len(self._list_action_items)\n            self._list_action_items.insert(index, widget)",
  "def on_use_separator(self, instance, value):\n        for group in self._list_action_group:\n            group.use_separator = value\n        if self.overflow_group:\n            self.overflow_group.use_separator = value",
  "def remove_widget(self, widget, *args, **kwargs):\n        super(ActionView, self).remove_widget(widget, *args, **kwargs)\n        if isinstance(widget, ActionOverflow):\n            for item in widget.list_action_item:\n                if item in self._list_action_items:\n                    self._list_action_items.remove(item)\n\n        if widget in self._list_action_items:\n            self._list_action_items.remove(widget)",
  "def _clear_all(self):\n        lst = self._list_action_items[:]\n        self.clear_widgets()\n        for group in self._list_action_group:\n            group.clear_widgets()\n\n        self.overflow_group.clear_widgets()\n        self.overflow_group.list_action_item = []\n        self._list_action_items = lst",
  "def _layout_all(self):\n        # all the items can fit to the view, so expand everything\n        super_add = super(ActionView, self).add_widget\n        self._state = 'all'\n        self._clear_all()\n        if not self.action_previous.parent:\n            super_add(self.action_previous)\n        if len(self._list_action_items) > 1:\n            for child in self._list_action_items[1:]:\n                child.inside_group = False\n                super_add(child)\n\n        for group in self._list_action_group:\n            if group.mode == 'spinner':\n                super_add(group)\n                group.show_group()\n            else:\n                if group.list_action_item != []:\n                    super_add(ActionSeparator())\n                for child in group.list_action_item:\n                    child.inside_group = False\n                    super_add(child)\n\n        self.overflow_group.show_default_items(self)",
  "def _layout_group(self):\n        # layout all the items in order to pack them per group\n        super_add = super(ActionView, self).add_widget\n        self._state = 'group'\n        self._clear_all()\n        if not self.action_previous.parent:\n            super_add(self.action_previous)\n        if len(self._list_action_items) > 1:\n            for child in self._list_action_items[1:]:\n                super_add(child)\n                child.inside_group = False\n\n        for group in self._list_action_group:\n            super_add(group)\n            group.show_group()\n\n        self.overflow_group.show_default_items(self)",
  "def _layout_random(self):\n        # layout the items in order to pack all of them grouped, and display\n        # only the action items having 'important'\n        super_add = super(ActionView, self).add_widget\n        self._state = 'random'\n        self._clear_all()\n        hidden_items = []\n        hidden_groups = []\n        total_width = 0\n        if not self.action_previous.parent:\n            super_add(self.action_previous)\n\n        width = (self.width - self.overflow_group.pack_width -\n                 self.action_previous.minimum_width)\n\n        if len(self._list_action_items):\n            for child in self._list_action_items[1:]:\n                if child.important:\n                    if child.pack_width + total_width < width:\n                        super_add(child)\n                        child.inside_group = False\n                        total_width += child.pack_width\n                    else:\n                        hidden_items.append(child)\n                else:\n                    hidden_items.append(child)\n\n        # if space is left then display ActionItem inside their\n        # ActionGroup\n        if total_width < self.width:\n            for group in self._list_action_group:\n                if group.pack_width + total_width +\\\n                        group.separator_width < width:\n                    super_add(group)\n                    group.show_group()\n                    total_width += (group.pack_width +\n                                    group.separator_width)\n\n                else:\n                    hidden_groups.append(group)\n        group_index = len(self.children) - 1\n        # if space is left then display other ActionItems\n        if total_width < self.width:\n            for child in hidden_items[:]:\n                if child.pack_width + total_width < width:\n                    super_add(child, group_index)\n                    total_width += child.pack_width\n                    child.inside_group = False\n                    hidden_items.remove(child)\n\n        # for all the remaining ActionItems and ActionItems with in\n        # ActionGroups, Display them inside overflow_group\n        extend_hidden = hidden_items.extend\n        for group in hidden_groups:\n            extend_hidden(group.list_action_item)\n\n        overflow_group = self.overflow_group\n\n        if hidden_items != []:\n            over_add = super(overflow_group.__class__,\n                             overflow_group).add_widget\n            for child in hidden_items:\n                over_add(child)\n\n            overflow_group.show_group()\n            if not self.overflow_group.parent:\n                super_add(overflow_group)",
  "def on_width(self, width, *args):\n        # determine the layout to use\n\n        # can we display all of them?\n        total_width = 0\n        for child in self._list_action_items:\n            total_width += child.pack_width\n        for group in self._list_action_group:\n            for child in group.list_action_item:\n                total_width += child.pack_width\n        if total_width <= self.width:\n            if self._state != 'all':\n                self._layout_all()\n            return\n\n        # can we display them per group?\n        total_width = 0\n        for child in self._list_action_items:\n            total_width += child.pack_width\n        for group in self._list_action_group:\n            total_width += group.pack_width\n        if total_width < self.width:\n            # ok, we can display all the items grouped\n            if self._state != 'group':\n                self._layout_group()\n            return\n\n        # none of the solutions worked, display them in pack mode\n        self._layout_random()",
  "def __init__(self, **kwargs):\n        super(ActionBar, self).__init__(**kwargs)\n        self._stack_cont_action_view = []\n        self._emit_previous = partial(self.dispatch, 'on_previous')",
  "def add_widget(self, widget, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n            Renamed argument `view` to `widget`.\n        '''\n        if isinstance(widget, ContextualActionView):\n            self._stack_cont_action_view.append(widget)\n            if widget.action_previous is not None:\n                widget.action_previous.unbind(on_release=self._emit_previous)\n                widget.action_previous.bind(on_release=self._emit_previous)\n            self.clear_widgets()\n            super(ActionBar, self).add_widget(widget, *args, **kwargs)\n\n        elif isinstance(widget, ActionView):\n            self.action_view = widget\n            super(ActionBar, self).add_widget(widget, *args, **kwargs)\n\n        else:\n            raise ActionBarException(\n                'ActionBar can only add ContextualActionView or ActionView')",
  "def on_previous(self, *args):\n        self._pop_contextual_action_view()",
  "def _pop_contextual_action_view(self):\n        '''Remove the current ContextualActionView and display either the\n           previous one or the ActionView.\n        '''\n        self._stack_cont_action_view.pop()\n        self.clear_widgets()\n        if self._stack_cont_action_view == []:\n            super(ActionBar, self).add_widget(self.action_view)\n        else:\n            super(ActionBar, self).add_widget(self._stack_cont_action_view[-1])",
  "class MainWindow(FloatLayout):\n        pass",
  "class ScrollView(StencilView):\n    '''ScrollView class. See module documentation for more information.\n\n    :Events:\n        `on_scroll_start`\n            Generic event fired when scrolling starts from touch.\n        `on_scroll_move`\n            Generic event fired when scrolling move from touch.\n        `on_scroll_stop`\n            Generic event fired when scrolling stops from touch.\n\n    .. versionchanged:: 1.9.0\n        `on_scroll_start`, `on_scroll_move` and `on_scroll_stop` events are\n        now dispatched when scrolling to handle nested ScrollViews.\n\n    .. versionchanged:: 1.7.0\n        `auto_scroll`, `scroll_friction`, `scroll_moves`, `scroll_stoptime' has\n        been deprecated, use :attr:`effect_cls` instead.\n    '''\n\n    scroll_distance = NumericProperty(_scroll_distance)\n    '''Distance to move before scrolling the :class:`ScrollView`, in pixels. As\n    soon as the distance has been traveled, the :class:`ScrollView` will start\n    to scroll, and no touch event will go to children.\n    It is advisable that you base this value on the dpi of your target device's\n    screen.\n\n    :attr:`scroll_distance` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 20 (pixels), according to the default value in user\n    configuration.\n    '''\n\n    scroll_wheel_distance = NumericProperty('20sp')\n    '''Distance to move when scrolling with a mouse wheel.\n    It is advisable that you base this value on the dpi of your target device's\n    screen.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`scroll_wheel_distance` is a\n    :class:`~kivy.properties.NumericProperty` , defaults to 20 pixels.\n    '''\n\n    scroll_timeout = NumericProperty(_scroll_timeout)\n    '''Timeout allowed to trigger the :attr:`scroll_distance`, in milliseconds.\n    If the user has not moved :attr:`scroll_distance` within the timeout,\n    the scrolling will be disabled, and the touch event will go to the\n    children.\n\n    :attr:`scroll_timeout` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 55 (milliseconds) according to the default value in user\n    configuration.\n\n    .. versionchanged:: 1.5.0\n        Default value changed from 250 to 55.\n    '''\n\n    scroll_x = NumericProperty(0.)\n    '''X scrolling value, between 0 and 1. If 0, the content's left side will\n    touch the left side of the ScrollView. If 1, the content's right side will\n    touch the right side.\n\n    This property is controlled by :class:`ScrollView` only if\n    :attr:`do_scroll_x` is True.\n\n    :attr:`scroll_x` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    scroll_y = NumericProperty(1.)\n    '''Y scrolling value, between 0 and 1. If 0, the content's bottom side will\n    touch the bottom side of the ScrollView. If 1, the content's top side will\n    touch the top side.\n\n    This property is controlled by :class:`ScrollView` only if\n    :attr:`do_scroll_y` is True.\n\n    :attr:`scroll_y` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 1.\n    '''\n\n    do_scroll_x = BooleanProperty(True)\n    '''Allow scroll on X axis.\n\n    :attr:`do_scroll_x` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    do_scroll_y = BooleanProperty(True)\n    '''Allow scroll on Y axis.\n\n    :attr:`do_scroll_y` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    def _get_do_scroll(self):\n        return (self.do_scroll_x, self.do_scroll_y)\n\n    def _set_do_scroll(self, value):\n        if isinstance(value, (list, tuple)):\n            self.do_scroll_x, self.do_scroll_y = value\n        else:\n            self.do_scroll_x = self.do_scroll_y = bool(value)\n\n    do_scroll = AliasProperty(_get_do_scroll, _set_do_scroll,\n                              bind=('do_scroll_x', 'do_scroll_y'),\n                              cache=True)\n    '''Allow scroll on X or Y axis.\n\n    :attr:`do_scroll` is a :class:`~kivy.properties.AliasProperty` of\n    (:attr:`do_scroll_x` + :attr:`do_scroll_y`)\n    '''\n\n    always_overscroll = BooleanProperty(True)\n    '''Make sure user can overscroll even if there is not enough content\n    to require scrolling.\n\n    This is useful if you want to trigger some action on overscroll, but\n    there is not always enough content to trigger it.\n\n    :attr:`always_overscroll` is a\n    :class:`~kivy.properties.BooleanProperty` and defaults to `True`.\n\n    .. versionadded:: 2.0.0\n\n    The option was added and enabled by default, set to False to get the\n    previous behavior of only allowing to overscroll when there is\n    enough content to allow scrolling.\n    '''\n\n    def _get_vbar(self):\n        # must return (y, height) in %\n        # calculate the viewport size / scrollview size %\n        if self._viewport is None:\n            return 0, 1.\n        vh = self._viewport.height\n        h = self.height\n        if vh < h or vh == 0:\n            return 0, 1.\n        ph = max(0.01, h / float(vh))\n        sy = min(1.0, max(0.0, self.scroll_y))\n        py = (1. - ph) * sy\n        return (py, ph)\n\n    vbar = AliasProperty(_get_vbar,\n                         bind=('scroll_y', '_viewport', 'viewport_size',\n                               'height'),\n                         cache=True)\n    '''Return a tuple of (position, size) of the vertical scrolling bar.\n\n    .. versionadded:: 1.2.0\n\n    The position and size are normalized between 0-1, and represent a\n    proportion of the current scrollview height. This property is used\n    internally for drawing the little vertical bar when you're scrolling.\n\n    :attr:`vbar` is a :class:`~kivy.properties.AliasProperty`, readonly.\n    '''\n\n    def _get_hbar(self):\n        # must return (x, width) in %\n        # calculate the viewport size / scrollview size %\n        if self._viewport is None:\n            return 0, 1.\n        vw = self._viewport.width\n        w = self.width\n        if vw < w or vw == 0:\n            return 0, 1.\n        pw = max(0.01, w / float(vw))\n        sx = min(1.0, max(0.0, self.scroll_x))\n        px = (1. - pw) * sx\n        return (px, pw)\n\n    hbar = AliasProperty(_get_hbar,\n                         bind=('scroll_x', '_viewport', 'viewport_size',\n                               'width'),\n                         cache=True)\n    '''Return a tuple of (position, size) of the horizontal scrolling bar.\n\n    .. versionadded:: 1.2.0\n\n    The position and size are normalized between 0-1, and represent a\n    proportion of the current scrollview height. This property is used\n    internally for drawing the little horizontal bar when you're scrolling.\n\n    :attr:`hbar` is a :class:`~kivy.properties.AliasProperty`, readonly.\n    '''\n\n    bar_color = ColorProperty([.7, .7, .7, .9])\n    '''Color of horizontal / vertical scroll bar, in RGBA format.\n\n    .. versionadded:: 1.2.0\n\n    :attr:`bar_color` is a :class:`~kivy.properties.ColorProperty` and defaults\n    to [.7, .7, .7, .9].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    bar_inactive_color = ColorProperty([.7, .7, .7, .2])\n    '''Color of horizontal / vertical scroll bar (in RGBA format), when no\n    scroll is happening.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`bar_inactive_color` is a\n    :class:`~kivy.properties.ColorProperty` and defaults to [.7, .7, .7, .2].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    bar_width = NumericProperty('2dp')\n    '''Width of the horizontal / vertical scroll bar. The width is interpreted\n    as a height for the horizontal bar.\n\n    .. versionadded:: 1.2.0\n\n    :attr:`bar_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 2.\n    '''\n\n    bar_pos_x = OptionProperty('bottom', options=('top', 'bottom'))\n    '''Which side of the ScrollView the horizontal scroll bar should go\n    on. Possible values are 'top' and 'bottom'.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`bar_pos_x` is an :class:`~kivy.properties.OptionProperty`,\n    defaults to 'bottom'.\n\n    '''\n\n    bar_pos_y = OptionProperty('right', options=('left', 'right'))\n    '''Which side of the ScrollView the vertical scroll bar should go\n    on. Possible values are 'left' and 'right'.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`bar_pos_y` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'right'.\n\n    '''\n\n    bar_pos = ReferenceListProperty(bar_pos_x, bar_pos_y)\n    '''Which side of the scroll view to place each of the bars on.\n\n    :attr:`bar_pos` is a :class:`~kivy.properties.ReferenceListProperty` of\n    (:attr:`bar_pos_x`, :attr:`bar_pos_y`)\n    '''\n\n    bar_margin = NumericProperty(0)\n    '''Margin between the bottom / right side of the scrollview when drawing\n    the horizontal / vertical scroll bar.\n\n    .. versionadded:: 1.2.0\n\n    :attr:`bar_margin` is a :class:`~kivy.properties.NumericProperty`, default\n    to 0\n    '''\n\n    effect_cls = ObjectProperty(DampedScrollEffect, allownone=True)\n    '''Class effect to instantiate for X and Y axis.\n\n    .. versionadded:: 1.7.0\n\n    :attr:`effect_cls` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to :class:`DampedScrollEffect`.\n\n    .. versionchanged:: 1.8.0\n        If you set a string, the :class:`~kivy.factory.Factory` will be used to\n        resolve the class.\n\n    '''\n\n    effect_x = ObjectProperty(None, allownone=True)\n    '''Effect to apply for the X axis. If None is set, an instance of\n    :attr:`effect_cls` will be created.\n\n    .. versionadded:: 1.7.0\n\n    :attr:`effect_x` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    effect_y = ObjectProperty(None, allownone=True)\n    '''Effect to apply for the Y axis. If None is set, an instance of\n    :attr:`effect_cls` will be created.\n\n    .. versionadded:: 1.7.0\n\n    :attr:`effect_y` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None, read-only.\n    '''\n\n    viewport_size = ListProperty([0, 0])\n    '''(internal) Size of the internal viewport. This is the size of your only\n    child in the scrollview.\n    '''\n\n    scroll_type = OptionProperty(['content'], options=(['content'], ['bars'],\n                                 ['bars', 'content'], ['content', 'bars']))\n    '''Sets the type of scrolling to use for the content of the scrollview.\n    Available options are: ['content'], ['bars'], ['bars', 'content'].\n\n    +---------------------+------------------------------------------------+\n    | ['content']         | Content is scrolled by dragging or swiping the |\n    |                     | content directly.                              |\n    +---------------------+------------------------------------------------+\n    | ['bars']            | Content is scrolled by dragging or swiping the |\n    |                     | scroll bars.                                   |\n    +---------------------+------------------------------------------------+\n    | ['bars', 'content'] | Content is scrolled by either of the above     |\n    |                     | methods.                                       |\n    +---------------------+------------------------------------------------+\n\n    .. versionadded:: 1.8.0\n\n    :attr:`scroll_type` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to ['content'].\n    '''\n\n    smooth_scroll_end = NumericProperty(None, allownone=True)\n    '''Whether smooth scroll end should be used when scrolling with the\n    mouse-wheel and the factor of transforming the scroll distance to\n    velocity. This option also enables velocity addition meaning if you\n    scroll more, you will scroll faster and further. The recommended value\n    is `10`. The velocity is calculated as :attr:`scroll_wheel_distance` *\n    :attr:`smooth_scroll_end`.\n\n    .. versionadded:: 1.11.0\n\n    :attr:`smooth_scroll_end` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to None.\n    '''\n\n    # private, for internal use only\n\n    _viewport = ObjectProperty(None, allownone=True)\n    _bar_color = ListProperty([0, 0, 0, 0])\n    _effect_x_start_width = None\n    _effect_y_start_height = None\n    _update_effect_bounds_ev = None\n    _bind_inactive_bar_color_ev = None\n\n    def _set_viewport_size(self, instance, value):\n        self.viewport_size = value\n\n    def on__viewport(self, instance, value):\n        if value:\n            value.bind(size=self._set_viewport_size)\n            self.viewport_size = value.size\n\n    __events__ = ('on_scroll_start', 'on_scroll_move', 'on_scroll_stop')\n\n    def __init__(self, **kwargs):\n        self._touch = None\n        self._trigger_update_from_scroll = Clock.create_trigger(\n            self.update_from_scroll, -1)\n        # create a specific canvas for the viewport\n        from kivy.graphics import PushMatrix, Translate, PopMatrix, Canvas\n        self.canvas_viewport = Canvas()\n        self.canvas = Canvas()\n        with self.canvas_viewport.before:\n            PushMatrix()\n            self.g_translate = Translate(0, 0)\n        with self.canvas_viewport.after:\n            PopMatrix()\n\n        super(ScrollView, self).__init__(**kwargs)\n\n        self.register_event_type('on_scroll_start')\n        self.register_event_type('on_scroll_move')\n        self.register_event_type('on_scroll_stop')\n\n        # now add the viewport canvas to our canvas\n        self.canvas.add(self.canvas_viewport)\n\n        effect_cls = self.effect_cls\n        if isinstance(effect_cls, string_types):\n            effect_cls = Factory.get(effect_cls)\n        if self.effect_x is None and effect_cls is not None:\n            self.effect_x = effect_cls(target_widget=self._viewport)\n        if self.effect_y is None and effect_cls is not None:\n            self.effect_y = effect_cls(target_widget=self._viewport)\n\n        trigger_update_from_scroll = self._trigger_update_from_scroll\n        update_effect_widget = self._update_effect_widget\n        update_effect_x_bounds = self._update_effect_x_bounds\n        update_effect_y_bounds = self._update_effect_y_bounds\n        fbind = self.fbind\n        fbind('width', update_effect_x_bounds)\n        fbind('height', update_effect_y_bounds)\n        fbind('viewport_size', self._update_effect_bounds)\n        fbind('_viewport', update_effect_widget)\n        fbind('scroll_x', trigger_update_from_scroll)\n        fbind('scroll_y', trigger_update_from_scroll)\n        fbind('pos', trigger_update_from_scroll)\n        fbind('size', trigger_update_from_scroll)\n\n        trigger_update_from_scroll()\n        update_effect_widget()\n        update_effect_x_bounds()\n        update_effect_y_bounds()\n\n    def on_effect_x(self, instance, value):\n        if value:\n            value.bind(scroll=self._update_effect_x)\n            value.target_widget = self._viewport\n\n    def on_effect_y(self, instance, value):\n        if value:\n            value.bind(scroll=self._update_effect_y)\n            value.target_widget = self._viewport\n\n    def on_effect_cls(self, instance, cls):\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n        self.effect_x = cls(target_widget=self._viewport)\n        self.effect_x.bind(scroll=self._update_effect_x)\n        self.effect_y = cls(target_widget=self._viewport)\n        self.effect_y.bind(scroll=self._update_effect_y)\n\n    def _update_effect_widget(self, *args):\n        if self.effect_x:\n            self.effect_x.target_widget = self._viewport\n        if self.effect_y:\n            self.effect_y.target_widget = self._viewport\n\n    def _update_effect_x_bounds(self, *args):\n        if not self._viewport or not self.effect_x:\n            return\n        scrollable_width = self.width - self.viewport_size[0]\n        self.effect_x.min = 0\n        self.effect_x.max = min(0, scrollable_width)\n        self.effect_x.value = scrollable_width * self.scroll_x\n\n    def _update_effect_y_bounds(self, *args):\n        if not self._viewport or not self.effect_y:\n            return\n        scrollable_height = self.height - self.viewport_size[1]\n        self.effect_y.min = 0 if scrollable_height < 0 else scrollable_height\n        self.effect_y.max = scrollable_height\n        self.effect_y.value = self.effect_y.max * self.scroll_y\n\n    def _update_effect_bounds(self, *args):\n        self._update_effect_x_bounds()\n        self._update_effect_y_bounds()\n\n    def _update_effect_x(self, *args):\n        vp = self._viewport\n        if not vp or not self.effect_x:\n            return\n\n        if self.effect_x.is_manual:\n            sw = vp.width - self._effect_x_start_width\n        else:\n            sw = vp.width - self.width\n        if sw < 1 and not (self.always_overscroll and self.do_scroll_x):\n            return\n        if sw != 0:\n            sx = self.effect_x.scroll / sw\n            self.scroll_x = -sx\n        self._trigger_update_from_scroll()\n\n    def _update_effect_y(self, *args):\n        vp = self._viewport\n        if not vp or not self.effect_y:\n            return\n        if self.effect_y.is_manual:\n            sh = vp.height - self._effect_y_start_height\n        else:\n            sh = vp.height - self.height\n\n        if sh < 1 and not (self.always_overscroll and self.do_scroll_y):\n            return\n        if sh != 0:\n            sy = self.effect_y.scroll / sh\n            self.scroll_y = -sy\n        self._trigger_update_from_scroll()\n\n    def to_local(self, x, y, **k):\n        tx, ty = self.g_translate.xy\n        return x - tx, y - ty\n\n    def to_parent(self, x, y, **k):\n        tx, ty = self.g_translate.xy\n        return x + tx, y + ty\n\n    def _apply_transform(self, m, pos=None):\n        tx, ty = self.g_translate.xy\n        m.translate(tx, ty, 0)\n        return super(ScrollView, self)._apply_transform(m, (0, 0))\n\n    def simulate_touch_down(self, touch):\n        # at this point the touch is in parent coords\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        ret = super(ScrollView, self).on_touch_down(touch)\n        touch.pop()\n        return ret\n\n    def on_motion(self, etype, me):\n        if me.type_id in self.motion_filter and 'pos' in me.profile:\n            me.push()\n            me.apply_transform_2d(self.to_local)\n            ret = super().on_motion(etype, me)\n            me.pop()\n            return ret\n        return super().on_motion(etype, me)\n\n    def on_touch_down(self, touch):\n        if self.dispatch('on_scroll_start', touch):\n            self._touch = touch\n            touch.grab(self)\n            return True\n\n    def _touch_in_handle(self, pos, size, touch):\n        x, y = pos\n        width, height = size\n        return x <= touch.x <= x + width and y <= touch.y <= y + height\n\n    def on_scroll_start(self, touch, check_children=True):\n        if check_children:\n            touch.push()\n            touch.apply_transform_2d(self.to_local)\n            if self.dispatch_children('on_scroll_start', touch):\n                touch.pop()\n                return True\n            touch.pop()\n\n        if not self.collide_point(*touch.pos):\n            touch.ud[self._get_uid('svavoid')] = True\n            return\n        if self.disabled:\n            return True\n        if self._touch or (not (self.do_scroll_x or self.do_scroll_y)):\n            return self.simulate_touch_down(touch)\n\n        # handle mouse scrolling, only if the viewport size is bigger than the\n        # scrollview size, and if the user allowed to do it\n        vp = self._viewport\n        if not vp:\n            return True\n        scroll_type = self.scroll_type\n        ud = touch.ud\n        scroll_bar = 'bars' in scroll_type\n\n        # check if touch is in bar_x(horizontal) or bar_y(vertical)\n        # width_enable_overscroll or vp.width > self.width\n        width_scrollable = (\n            (self.always_overscroll and self.do_scroll_x)\n            or vp.width > self.width\n        )\n        height_scrollable = (\n            (self.always_overscroll and self.do_scroll_y)\n            or vp.height > self.height\n        )\n\n        d = {'bottom': touch.y - self.y - self.bar_margin,\n             'top': self.top - touch.y - self.bar_margin,\n             'left': touch.x - self.x - self.bar_margin,\n             'right': self.right - touch.x - self.bar_margin}\n\n        ud['in_bar_x'] = (scroll_bar and width_scrollable and\n                          (0 <= d[self.bar_pos_x] <= self.bar_width))\n        ud['in_bar_y'] = (scroll_bar and height_scrollable and\n                          (0 <= d[self.bar_pos_y] <= self.bar_width))\n\n        if 'button' in touch.profile and touch.button.startswith('scroll'):\n            btn = touch.button\n            m = self.scroll_wheel_distance\n            e = None\n\n            if (\n                (btn == 'scrolldown' and self.scroll_y >= 1)\n                or (btn == 'scrollup' and self.scroll_y <= 0)\n                or (btn == 'scrollleft' and self.scroll_x >= 1)\n                or (btn == 'scrollright' and self.scroll_x <= 0)\n            ):\n                return False\n\n            if (\n                self.effect_x\n                and self.do_scroll_y\n                and height_scrollable\n                and btn in ('scrolldown', 'scrollup')\n            ):\n                e = self.effect_x if ud['in_bar_x'] else self.effect_y\n\n            elif (\n                self.effect_y\n                and self.do_scroll_x\n                and width_scrollable\n                and btn in ('scrollleft', 'scrollright')\n            ):\n                e = self.effect_y if ud['in_bar_y'] else self.effect_x\n\n            if e:\n                # make sure the effect's value is synced to scroll value\n                self._update_effect_bounds()\n                if btn in ('scrolldown', 'scrollleft'):\n                    if self.smooth_scroll_end:\n                        e.velocity -= m * self.smooth_scroll_end\n                    else:\n                        if self.always_overscroll:\n                            e.value = e.value - m\n                        else:\n                            e.value = max(e.value - m, e.max)\n                        e.velocity = 0\n                elif btn in ('scrollup', 'scrollright'):\n                    if self.smooth_scroll_end:\n                        e.velocity += m * self.smooth_scroll_end\n                    else:\n                        if self.always_overscroll:\n                            e.value = e.value + m\n                        else:\n                            e.value = min(e.value + m, e.min)\n                        e.velocity = 0\n                touch.ud[self._get_uid('svavoid')] = True\n                e.trigger_velocity_update()\n            return True\n\n        in_bar = ud['in_bar_x'] or ud['in_bar_y']\n        if scroll_type == ['bars'] and not in_bar:\n            return self.simulate_touch_down(touch)\n\n        if in_bar:\n            if (ud['in_bar_y'] and not\n                    self._touch_in_handle(\n                        self._handle_y_pos, self._handle_y_size, touch)):\n                self.scroll_y = (touch.y - self.y) / self.height\n            elif (ud['in_bar_x'] and not\n                    self._touch_in_handle(\n                        self._handle_x_pos, self._handle_x_size, touch)):\n                self.scroll_x = (touch.x - self.x) / self.width\n\n        # no mouse scrolling, so the user is going to drag the scrollview with\n        # this touch.\n        self._touch = touch\n        uid = self._get_uid()\n\n        ud[uid] = {\n            'mode': 'unknown',\n            'dx': 0,\n            'dy': 0,\n            'user_stopped': in_bar,\n            'frames': Clock.frames,\n            'time': touch.time_start,\n        }\n\n        if (self.do_scroll_x and self.effect_x and not ud['in_bar_x']\n                and not ud['in_bar_y']):\n            # make sure the effect's value is synced to scroll value\n            self._update_effect_bounds()\n\n            self._effect_x_start_width = self.width\n            self.effect_x.start(touch.x)\n            self._scroll_x_mouse = self.scroll_x\n\n        if (self.do_scroll_y and self.effect_y and not ud['in_bar_x']\n                and not ud['in_bar_y']):\n            # make sure the effect's value is synced to scroll value\n            self._update_effect_bounds()\n\n            self._effect_y_start_height = self.height\n            self.effect_y.start(touch.y)\n            self._scroll_y_mouse = self.scroll_y\n\n        if not in_bar:\n            Clock.schedule_once(self._change_touch_mode,\n                                self.scroll_timeout / 1000.)\n        return True\n\n    def on_touch_move(self, touch):\n        if self._touch is not touch:\n            # don't pass on touch to children if outside the sv\n            if self.collide_point(*touch.pos):\n                # touch is in parent\n                touch.push()\n                touch.apply_transform_2d(self.to_local)\n                super(ScrollView, self).on_touch_move(touch)\n                touch.pop()\n            return self._get_uid() in touch.ud\n        if touch.grab_current is not self:\n            return True\n\n        if not any(isinstance(key, str) and key.startswith('sv.')\n                   for key in touch.ud):\n            # don't pass on touch to children if outside the sv\n            if self.collide_point(*touch.pos):\n                # touch is in window coordinates\n                touch.push()\n                touch.apply_transform_2d(self.to_local)\n                res = super(ScrollView, self).on_touch_move(touch)\n                touch.pop()\n                return res\n            return False\n\n        touch.ud['sv.handled'] = {'x': False, 'y': False}\n        if self.dispatch('on_scroll_move', touch):\n            return True\n\n    def on_scroll_move(self, touch):\n        if self._get_uid('svavoid') in touch.ud:\n            return False\n\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        if self.dispatch_children('on_scroll_move', touch):\n            touch.pop()\n            return True\n        touch.pop()\n\n        rv = True\n\n        # By default this touch can be used to defocus currently focused\n        # widget, like any touch outside of ScrollView.\n        touch.ud['sv.can_defocus'] = True\n\n        uid = self._get_uid()\n        if uid not in touch.ud:\n            self._touch = False\n            return self.on_scroll_start(touch, False)\n        ud = touch.ud[uid]\n\n        # check if the minimum distance has been travelled\n        if ud['mode'] == 'unknown':\n            if not (self.do_scroll_x or self.do_scroll_y):\n                # touch is in parent, but _change expects window coords\n                touch.push()\n                touch.apply_transform_2d(self.to_local)\n                touch.apply_transform_2d(self.to_window)\n                self._change_touch_mode()\n                touch.pop()\n                return\n            ud['dx'] += abs(touch.dx)\n            ud['dy'] += abs(touch.dy)\n            if ((ud['dx'] > self.scroll_distance and self.do_scroll_x) or\n                    (ud['dy'] > self.scroll_distance and self.do_scroll_y)):\n                ud['mode'] = 'scroll'\n\n        if ud['mode'] == 'scroll':\n            not_in_bar = not touch.ud.get('in_bar_x', False) and \\\n                not touch.ud.get('in_bar_y', False)\n\n            if not touch.ud['sv.handled']['x'] and self.do_scroll_x \\\n                    and self.effect_x:\n                width = self.width\n                if touch.ud.get('in_bar_x', False):\n                    if self.hbar[1] != 1:\n                        dx = touch.dx / float(width - width * self.hbar[1])\n                        self.scroll_x = min(max(self.scroll_x + dx, 0.), 1.)\n                        self._trigger_update_from_scroll()\n                elif not_in_bar:\n                    self.effect_x.update(touch.x)\n\n                if self.scroll_x < 0 or self.scroll_x > 1:\n                    rv = False\n                else:\n                    touch.ud['sv.handled']['x'] = True\n                # Touch resulted in scroll should not defocus focused widget\n                touch.ud['sv.can_defocus'] = False\n            if not touch.ud['sv.handled']['y'] and self.do_scroll_y \\\n                    and self.effect_y:\n                height = self.height\n                if touch.ud.get('in_bar_y', False) and self.vbar[1] != 1.0:\n                    dy = touch.dy / float(height - height * self.vbar[1])\n                    self.scroll_y = min(max(self.scroll_y + dy, 0.), 1.)\n                    self._trigger_update_from_scroll()\n                elif not_in_bar:\n                    self.effect_y.update(touch.y)\n\n                if self.scroll_y < 0 or self.scroll_y > 1:\n                    rv = False\n                else:\n                    touch.ud['sv.handled']['y'] = True\n                # Touch resulted in scroll should not defocus focused widget\n                touch.ud['sv.can_defocus'] = False\n            ud['dt'] = touch.time_update - ud['time']\n            ud['time'] = touch.time_update\n            ud['user_stopped'] = True\n        return rv\n\n    def on_touch_up(self, touch):\n        uid = self._get_uid('svavoid')\n        if self._touch is not touch and uid not in touch.ud:\n            # don't pass on touch to children if outside the sv\n            if self.collide_point(*touch.pos):\n                # touch is in parents\n                touch.push()\n                touch.apply_transform_2d(self.to_local)\n                if super(ScrollView, self).on_touch_up(touch):\n                    touch.pop()\n                    return True\n                touch.pop()\n            return False\n\n        if self.dispatch('on_scroll_stop', touch):\n            touch.ungrab(self)\n            if not touch.ud.get('sv.can_defocus', True):\n                # Focused widget should stay focused\n                FocusBehavior.ignored_touch.append(touch)\n            return True\n\n    def on_scroll_stop(self, touch, check_children=True):\n        self._touch = None\n\n        if check_children:\n            touch.push()\n            touch.apply_transform_2d(self.to_local)\n            if self.dispatch_children('on_scroll_stop', touch):\n                touch.pop()\n                return True\n            touch.pop()\n\n        if self._get_uid('svavoid') in touch.ud:\n            return\n        if self._get_uid() not in touch.ud:\n            return False\n\n        self._touch = None\n        uid = self._get_uid()\n        ud = touch.ud[uid]\n        not_in_bar = not touch.ud.get('in_bar_x', False) and \\\n            not touch.ud.get('in_bar_y', False)\n        if self.do_scroll_x and self.effect_x and not_in_bar:\n            self.effect_x.stop(touch.x)\n        if self.do_scroll_y and self.effect_y and not_in_bar:\n            self.effect_y.stop(touch.y)\n        if ud['mode'] == 'unknown':\n            # we must do the click at least..\n            # only send the click if it was not a click to stop\n            # autoscrolling\n            if not ud['user_stopped']:\n                self.simulate_touch_down(touch)\n            Clock.schedule_once(partial(self._do_touch_up, touch), .2)\n\n        ev = self._update_effect_bounds_ev\n        if ev is None:\n            ev = self._update_effect_bounds_ev = Clock.create_trigger(\n                self._update_effect_bounds)\n        ev()\n\n        # if we do mouse scrolling, always accept it\n        if 'button' in touch.profile and touch.button.startswith('scroll'):\n            return True\n\n        return self._get_uid() in touch.ud\n\n    def scroll_to(self, widget, padding=10, animate=True):\n        '''Scrolls the viewport to ensure that the given widget is visible,\n        optionally with padding and animation. If animate is True (the\n        default), then the default animation parameters will be used.\n        Otherwise, it should be a dict containing arguments to pass to\n        :class:`~kivy.animation.Animation` constructor.\n\n        .. versionadded:: 1.9.1\n        '''\n        if not self.parent:\n            return\n\n        # if _viewport is layout and has pending operation, reschedule\n        if hasattr(self._viewport, 'do_layout'):\n            if self._viewport._trigger_layout.is_triggered:\n                Clock.schedule_once(\n                     lambda *dt: self.scroll_to(widget, padding, animate))\n                return\n\n        if isinstance(padding, (int, float)):\n            padding = (padding, padding)\n\n        pos = self.parent.to_widget(*widget.to_window(*widget.pos))\n        cor = self.parent.to_widget(*widget.to_window(widget.right,\n                                                      widget.top))\n\n        dx = dy = 0\n\n        if pos[1] < self.y:\n            dy = self.y - pos[1] + dp(padding[1])\n        elif cor[1] > self.top:\n            dy = self.top - cor[1] - dp(padding[1])\n\n        if pos[0] < self.x:\n            dx = self.x - pos[0] + dp(padding[0])\n        elif cor[0] > self.right:\n            dx = self.right - cor[0] - dp(padding[0])\n\n        dsx, dsy = self.convert_distance_to_scroll(dx, dy)\n        sxp = min(1, max(0, self.scroll_x - dsx))\n        syp = min(1, max(0, self.scroll_y - dsy))\n\n        if animate:\n            if animate is True:\n                animate = {'d': 0.2, 't': 'out_quad'}\n            Animation.stop_all(self, 'scroll_x', 'scroll_y')\n            Animation(scroll_x=sxp, scroll_y=syp, **animate).start(self)\n        else:\n            self.scroll_x = sxp\n            self.scroll_y = syp\n\n    def convert_distance_to_scroll(self, dx, dy):\n        '''Convert a distance in pixels to a scroll distance, depending on the\n        content size and the scrollview size.\n\n        The result will be a tuple of scroll distance that can be added to\n        :data:`scroll_x` and :data:`scroll_y`\n        '''\n        if not self._viewport:\n            return 0, 0\n        vp = self._viewport\n        if vp.width > self.width:\n            sw = vp.width - self.width\n            sx = dx / float(sw)\n        else:\n            sx = 0\n        if vp.height > self.height:\n            sh = vp.height - self.height\n            sy = dy / float(sh)\n        else:\n            sy = 1\n        return sx, sy\n\n    def update_from_scroll(self, *largs):\n        '''Force the reposition of the content, according to current value of\n        :attr:`scroll_x` and :attr:`scroll_y`.\n\n        This method is automatically called when one of the :attr:`scroll_x`,\n        :attr:`scroll_y`, :attr:`pos` or :attr:`size` properties change, or\n        if the size of the content changes.\n        '''\n        if not self._viewport:\n            self.g_translate.xy = self.pos\n            return\n        vp = self._viewport\n\n        # update from size_hint\n        if vp.size_hint_x is not None:\n            w = vp.size_hint_x * self.width\n            if vp.size_hint_min_x is not None:\n                w = max(w, vp.size_hint_min_x)\n            if vp.size_hint_max_x is not None:\n                w = min(w, vp.size_hint_max_x)\n            vp.width = w\n\n        if vp.size_hint_y is not None:\n            h = vp.size_hint_y * self.height\n            if vp.size_hint_min_y is not None:\n                h = max(h, vp.size_hint_min_y)\n            if vp.size_hint_max_y is not None:\n                h = min(h, vp.size_hint_max_y)\n            vp.height = h\n\n        if vp.width > self.width or self.always_overscroll:\n            sw = vp.width - self.width\n            x = self.x - self.scroll_x * sw\n        else:\n            x = self.x\n\n        if vp.height > self.height or self.always_overscroll:\n            sh = vp.height - self.height\n            y = self.y - self.scroll_y * sh\n        else:\n            y = self.top - vp.height\n\n        # from 1.8.0, we now use a matrix by default, instead of moving the\n        # widget position behind. We set it here, but it will be a no-op most\n        # of the time.\n        vp.pos = 0, 0\n        self.g_translate.xy = x, y\n\n        # New in 1.2.0, show bar when scrolling happens and (changed in 1.9.0)\n        # fade to bar_inactive_color when no scroll is happening.\n        ev = self._bind_inactive_bar_color_ev\n        if ev is None:\n            ev = self._bind_inactive_bar_color_ev = Clock.create_trigger(\n                self._bind_inactive_bar_color, .5)\n        self.funbind('bar_inactive_color', self._change_bar_color)\n        Animation.stop_all(self, '_bar_color')\n        self.fbind('bar_color', self._change_bar_color)\n        self._bar_color = self.bar_color\n        ev()\n\n    def _bind_inactive_bar_color(self, *l):\n        self.funbind('bar_color', self._change_bar_color)\n        self.fbind('bar_inactive_color', self._change_bar_color)\n        Animation(\n            _bar_color=self.bar_inactive_color,\n            d=.5, t='out_quart').start(self)\n\n    def _change_bar_color(self, inst, value):\n        self._bar_color = value\n\n    def add_widget(self, widget, *args, **kwargs):\n        if self._viewport:\n            raise Exception('ScrollView accept only one widget')\n        canvas = self.canvas\n        self.canvas = self.canvas_viewport\n        super(ScrollView, self).add_widget(widget, *args, **kwargs)\n        self.canvas = canvas\n        self._viewport = widget\n        widget.bind(size=self._trigger_update_from_scroll,\n                    size_hint_min=self._trigger_update_from_scroll)\n        self._trigger_update_from_scroll()\n\n    def remove_widget(self, widget, *args, **kwargs):\n        canvas = self.canvas\n        self.canvas = self.canvas_viewport\n        super(ScrollView, self).remove_widget(widget, *args, **kwargs)\n        self.canvas = canvas\n        if widget is self._viewport:\n            self._viewport = None\n\n    def _get_uid(self, prefix='sv'):\n        return '{0}.{1}'.format(prefix, self.uid)\n\n    def _change_touch_mode(self, *largs):\n        if not self._touch:\n            return\n        uid = self._get_uid()\n        touch = self._touch\n        if uid not in touch.ud:\n            self._touch = False\n            return\n        ud = touch.ud[uid]\n        if ud['mode'] != 'unknown' or ud['user_stopped']:\n            return\n        diff_frames = Clock.frames - ud['frames']\n\n        # in order to be able to scroll on very slow devices, let at least 3\n        # frames displayed to accumulate some velocity. And then, change the\n        # touch mode. Otherwise, we might never be able to compute velocity,\n        # and no way to scroll it. See #1464 and #1499\n        if diff_frames < 3:\n            Clock.schedule_once(self._change_touch_mode, 0)\n            return\n\n        if self.do_scroll_x and self.effect_x:\n            self.effect_x.cancel()\n        if self.do_scroll_y and self.effect_y:\n            self.effect_y.cancel()\n        # XXX the next line was in the condition. But this stop\n        # the possibility to \"drag\" an object out of the scrollview in the\n        # non-used direction: if you have an horizontal scrollview, a\n        # vertical gesture will not \"stop\" the scroll view to look for an\n        # horizontal gesture, until the timeout is done.\n        # and touch.dx + touch.dy == 0:\n        touch.ungrab(self)\n        self._touch = None\n        # touch is in window coords\n        touch.push()\n        touch.apply_transform_2d(self.to_widget)\n        touch.apply_transform_2d(self.to_parent)\n        self.simulate_touch_down(touch)\n        touch.pop()\n        return\n\n    def _do_touch_up(self, touch, *largs):\n        # touch is in window coords\n        touch.push()\n        touch.apply_transform_2d(self.to_widget)\n        super(ScrollView, self).on_touch_up(touch)\n        touch.pop()\n        # don't forget about grab event!\n        for x in touch.grab_list[:]:\n            touch.grab_list.remove(x)\n            x = x()\n            if not x:\n                continue\n            touch.grab_current = x\n            # touch is in window coords\n            touch.push()\n            touch.apply_transform_2d(self.to_widget)\n            super(ScrollView, self).on_touch_up(touch)\n            touch.pop()\n        touch.grab_current = None",
  "def _get_do_scroll(self):\n        return (self.do_scroll_x, self.do_scroll_y)",
  "def _set_do_scroll(self, value):\n        if isinstance(value, (list, tuple)):\n            self.do_scroll_x, self.do_scroll_y = value\n        else:\n            self.do_scroll_x = self.do_scroll_y = bool(value)",
  "def _get_vbar(self):\n        # must return (y, height) in %\n        # calculate the viewport size / scrollview size %\n        if self._viewport is None:\n            return 0, 1.\n        vh = self._viewport.height\n        h = self.height\n        if vh < h or vh == 0:\n            return 0, 1.\n        ph = max(0.01, h / float(vh))\n        sy = min(1.0, max(0.0, self.scroll_y))\n        py = (1. - ph) * sy\n        return (py, ph)",
  "def _get_hbar(self):\n        # must return (x, width) in %\n        # calculate the viewport size / scrollview size %\n        if self._viewport is None:\n            return 0, 1.\n        vw = self._viewport.width\n        w = self.width\n        if vw < w or vw == 0:\n            return 0, 1.\n        pw = max(0.01, w / float(vw))\n        sx = min(1.0, max(0.0, self.scroll_x))\n        px = (1. - pw) * sx\n        return (px, pw)",
  "def _set_viewport_size(self, instance, value):\n        self.viewport_size = value",
  "def on__viewport(self, instance, value):\n        if value:\n            value.bind(size=self._set_viewport_size)\n            self.viewport_size = value.size",
  "def __init__(self, **kwargs):\n        self._touch = None\n        self._trigger_update_from_scroll = Clock.create_trigger(\n            self.update_from_scroll, -1)\n        # create a specific canvas for the viewport\n        from kivy.graphics import PushMatrix, Translate, PopMatrix, Canvas\n        self.canvas_viewport = Canvas()\n        self.canvas = Canvas()\n        with self.canvas_viewport.before:\n            PushMatrix()\n            self.g_translate = Translate(0, 0)\n        with self.canvas_viewport.after:\n            PopMatrix()\n\n        super(ScrollView, self).__init__(**kwargs)\n\n        self.register_event_type('on_scroll_start')\n        self.register_event_type('on_scroll_move')\n        self.register_event_type('on_scroll_stop')\n\n        # now add the viewport canvas to our canvas\n        self.canvas.add(self.canvas_viewport)\n\n        effect_cls = self.effect_cls\n        if isinstance(effect_cls, string_types):\n            effect_cls = Factory.get(effect_cls)\n        if self.effect_x is None and effect_cls is not None:\n            self.effect_x = effect_cls(target_widget=self._viewport)\n        if self.effect_y is None and effect_cls is not None:\n            self.effect_y = effect_cls(target_widget=self._viewport)\n\n        trigger_update_from_scroll = self._trigger_update_from_scroll\n        update_effect_widget = self._update_effect_widget\n        update_effect_x_bounds = self._update_effect_x_bounds\n        update_effect_y_bounds = self._update_effect_y_bounds\n        fbind = self.fbind\n        fbind('width', update_effect_x_bounds)\n        fbind('height', update_effect_y_bounds)\n        fbind('viewport_size', self._update_effect_bounds)\n        fbind('_viewport', update_effect_widget)\n        fbind('scroll_x', trigger_update_from_scroll)\n        fbind('scroll_y', trigger_update_from_scroll)\n        fbind('pos', trigger_update_from_scroll)\n        fbind('size', trigger_update_from_scroll)\n\n        trigger_update_from_scroll()\n        update_effect_widget()\n        update_effect_x_bounds()\n        update_effect_y_bounds()",
  "def on_effect_x(self, instance, value):\n        if value:\n            value.bind(scroll=self._update_effect_x)\n            value.target_widget = self._viewport",
  "def on_effect_y(self, instance, value):\n        if value:\n            value.bind(scroll=self._update_effect_y)\n            value.target_widget = self._viewport",
  "def on_effect_cls(self, instance, cls):\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n        self.effect_x = cls(target_widget=self._viewport)\n        self.effect_x.bind(scroll=self._update_effect_x)\n        self.effect_y = cls(target_widget=self._viewport)\n        self.effect_y.bind(scroll=self._update_effect_y)",
  "def _update_effect_widget(self, *args):\n        if self.effect_x:\n            self.effect_x.target_widget = self._viewport\n        if self.effect_y:\n            self.effect_y.target_widget = self._viewport",
  "def _update_effect_x_bounds(self, *args):\n        if not self._viewport or not self.effect_x:\n            return\n        scrollable_width = self.width - self.viewport_size[0]\n        self.effect_x.min = 0\n        self.effect_x.max = min(0, scrollable_width)\n        self.effect_x.value = scrollable_width * self.scroll_x",
  "def _update_effect_y_bounds(self, *args):\n        if not self._viewport or not self.effect_y:\n            return\n        scrollable_height = self.height - self.viewport_size[1]\n        self.effect_y.min = 0 if scrollable_height < 0 else scrollable_height\n        self.effect_y.max = scrollable_height\n        self.effect_y.value = self.effect_y.max * self.scroll_y",
  "def _update_effect_bounds(self, *args):\n        self._update_effect_x_bounds()\n        self._update_effect_y_bounds()",
  "def _update_effect_x(self, *args):\n        vp = self._viewport\n        if not vp or not self.effect_x:\n            return\n\n        if self.effect_x.is_manual:\n            sw = vp.width - self._effect_x_start_width\n        else:\n            sw = vp.width - self.width\n        if sw < 1 and not (self.always_overscroll and self.do_scroll_x):\n            return\n        if sw != 0:\n            sx = self.effect_x.scroll / sw\n            self.scroll_x = -sx\n        self._trigger_update_from_scroll()",
  "def _update_effect_y(self, *args):\n        vp = self._viewport\n        if not vp or not self.effect_y:\n            return\n        if self.effect_y.is_manual:\n            sh = vp.height - self._effect_y_start_height\n        else:\n            sh = vp.height - self.height\n\n        if sh < 1 and not (self.always_overscroll and self.do_scroll_y):\n            return\n        if sh != 0:\n            sy = self.effect_y.scroll / sh\n            self.scroll_y = -sy\n        self._trigger_update_from_scroll()",
  "def to_local(self, x, y, **k):\n        tx, ty = self.g_translate.xy\n        return x - tx, y - ty",
  "def to_parent(self, x, y, **k):\n        tx, ty = self.g_translate.xy\n        return x + tx, y + ty",
  "def _apply_transform(self, m, pos=None):\n        tx, ty = self.g_translate.xy\n        m.translate(tx, ty, 0)\n        return super(ScrollView, self)._apply_transform(m, (0, 0))",
  "def simulate_touch_down(self, touch):\n        # at this point the touch is in parent coords\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        ret = super(ScrollView, self).on_touch_down(touch)\n        touch.pop()\n        return ret",
  "def on_motion(self, etype, me):\n        if me.type_id in self.motion_filter and 'pos' in me.profile:\n            me.push()\n            me.apply_transform_2d(self.to_local)\n            ret = super().on_motion(etype, me)\n            me.pop()\n            return ret\n        return super().on_motion(etype, me)",
  "def on_touch_down(self, touch):\n        if self.dispatch('on_scroll_start', touch):\n            self._touch = touch\n            touch.grab(self)\n            return True",
  "def _touch_in_handle(self, pos, size, touch):\n        x, y = pos\n        width, height = size\n        return x <= touch.x <= x + width and y <= touch.y <= y + height",
  "def on_scroll_start(self, touch, check_children=True):\n        if check_children:\n            touch.push()\n            touch.apply_transform_2d(self.to_local)\n            if self.dispatch_children('on_scroll_start', touch):\n                touch.pop()\n                return True\n            touch.pop()\n\n        if not self.collide_point(*touch.pos):\n            touch.ud[self._get_uid('svavoid')] = True\n            return\n        if self.disabled:\n            return True\n        if self._touch or (not (self.do_scroll_x or self.do_scroll_y)):\n            return self.simulate_touch_down(touch)\n\n        # handle mouse scrolling, only if the viewport size is bigger than the\n        # scrollview size, and if the user allowed to do it\n        vp = self._viewport\n        if not vp:\n            return True\n        scroll_type = self.scroll_type\n        ud = touch.ud\n        scroll_bar = 'bars' in scroll_type\n\n        # check if touch is in bar_x(horizontal) or bar_y(vertical)\n        # width_enable_overscroll or vp.width > self.width\n        width_scrollable = (\n            (self.always_overscroll and self.do_scroll_x)\n            or vp.width > self.width\n        )\n        height_scrollable = (\n            (self.always_overscroll and self.do_scroll_y)\n            or vp.height > self.height\n        )\n\n        d = {'bottom': touch.y - self.y - self.bar_margin,\n             'top': self.top - touch.y - self.bar_margin,\n             'left': touch.x - self.x - self.bar_margin,\n             'right': self.right - touch.x - self.bar_margin}\n\n        ud['in_bar_x'] = (scroll_bar and width_scrollable and\n                          (0 <= d[self.bar_pos_x] <= self.bar_width))\n        ud['in_bar_y'] = (scroll_bar and height_scrollable and\n                          (0 <= d[self.bar_pos_y] <= self.bar_width))\n\n        if 'button' in touch.profile and touch.button.startswith('scroll'):\n            btn = touch.button\n            m = self.scroll_wheel_distance\n            e = None\n\n            if (\n                (btn == 'scrolldown' and self.scroll_y >= 1)\n                or (btn == 'scrollup' and self.scroll_y <= 0)\n                or (btn == 'scrollleft' and self.scroll_x >= 1)\n                or (btn == 'scrollright' and self.scroll_x <= 0)\n            ):\n                return False\n\n            if (\n                self.effect_x\n                and self.do_scroll_y\n                and height_scrollable\n                and btn in ('scrolldown', 'scrollup')\n            ):\n                e = self.effect_x if ud['in_bar_x'] else self.effect_y\n\n            elif (\n                self.effect_y\n                and self.do_scroll_x\n                and width_scrollable\n                and btn in ('scrollleft', 'scrollright')\n            ):\n                e = self.effect_y if ud['in_bar_y'] else self.effect_x\n\n            if e:\n                # make sure the effect's value is synced to scroll value\n                self._update_effect_bounds()\n                if btn in ('scrolldown', 'scrollleft'):\n                    if self.smooth_scroll_end:\n                        e.velocity -= m * self.smooth_scroll_end\n                    else:\n                        if self.always_overscroll:\n                            e.value = e.value - m\n                        else:\n                            e.value = max(e.value - m, e.max)\n                        e.velocity = 0\n                elif btn in ('scrollup', 'scrollright'):\n                    if self.smooth_scroll_end:\n                        e.velocity += m * self.smooth_scroll_end\n                    else:\n                        if self.always_overscroll:\n                            e.value = e.value + m\n                        else:\n                            e.value = min(e.value + m, e.min)\n                        e.velocity = 0\n                touch.ud[self._get_uid('svavoid')] = True\n                e.trigger_velocity_update()\n            return True\n\n        in_bar = ud['in_bar_x'] or ud['in_bar_y']\n        if scroll_type == ['bars'] and not in_bar:\n            return self.simulate_touch_down(touch)\n\n        if in_bar:\n            if (ud['in_bar_y'] and not\n                    self._touch_in_handle(\n                        self._handle_y_pos, self._handle_y_size, touch)):\n                self.scroll_y = (touch.y - self.y) / self.height\n            elif (ud['in_bar_x'] and not\n                    self._touch_in_handle(\n                        self._handle_x_pos, self._handle_x_size, touch)):\n                self.scroll_x = (touch.x - self.x) / self.width\n\n        # no mouse scrolling, so the user is going to drag the scrollview with\n        # this touch.\n        self._touch = touch\n        uid = self._get_uid()\n\n        ud[uid] = {\n            'mode': 'unknown',\n            'dx': 0,\n            'dy': 0,\n            'user_stopped': in_bar,\n            'frames': Clock.frames,\n            'time': touch.time_start,\n        }\n\n        if (self.do_scroll_x and self.effect_x and not ud['in_bar_x']\n                and not ud['in_bar_y']):\n            # make sure the effect's value is synced to scroll value\n            self._update_effect_bounds()\n\n            self._effect_x_start_width = self.width\n            self.effect_x.start(touch.x)\n            self._scroll_x_mouse = self.scroll_x\n\n        if (self.do_scroll_y and self.effect_y and not ud['in_bar_x']\n                and not ud['in_bar_y']):\n            # make sure the effect's value is synced to scroll value\n            self._update_effect_bounds()\n\n            self._effect_y_start_height = self.height\n            self.effect_y.start(touch.y)\n            self._scroll_y_mouse = self.scroll_y\n\n        if not in_bar:\n            Clock.schedule_once(self._change_touch_mode,\n                                self.scroll_timeout / 1000.)\n        return True",
  "def on_touch_move(self, touch):\n        if self._touch is not touch:\n            # don't pass on touch to children if outside the sv\n            if self.collide_point(*touch.pos):\n                # touch is in parent\n                touch.push()\n                touch.apply_transform_2d(self.to_local)\n                super(ScrollView, self).on_touch_move(touch)\n                touch.pop()\n            return self._get_uid() in touch.ud\n        if touch.grab_current is not self:\n            return True\n\n        if not any(isinstance(key, str) and key.startswith('sv.')\n                   for key in touch.ud):\n            # don't pass on touch to children if outside the sv\n            if self.collide_point(*touch.pos):\n                # touch is in window coordinates\n                touch.push()\n                touch.apply_transform_2d(self.to_local)\n                res = super(ScrollView, self).on_touch_move(touch)\n                touch.pop()\n                return res\n            return False\n\n        touch.ud['sv.handled'] = {'x': False, 'y': False}\n        if self.dispatch('on_scroll_move', touch):\n            return True",
  "def on_scroll_move(self, touch):\n        if self._get_uid('svavoid') in touch.ud:\n            return False\n\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        if self.dispatch_children('on_scroll_move', touch):\n            touch.pop()\n            return True\n        touch.pop()\n\n        rv = True\n\n        # By default this touch can be used to defocus currently focused\n        # widget, like any touch outside of ScrollView.\n        touch.ud['sv.can_defocus'] = True\n\n        uid = self._get_uid()\n        if uid not in touch.ud:\n            self._touch = False\n            return self.on_scroll_start(touch, False)\n        ud = touch.ud[uid]\n\n        # check if the minimum distance has been travelled\n        if ud['mode'] == 'unknown':\n            if not (self.do_scroll_x or self.do_scroll_y):\n                # touch is in parent, but _change expects window coords\n                touch.push()\n                touch.apply_transform_2d(self.to_local)\n                touch.apply_transform_2d(self.to_window)\n                self._change_touch_mode()\n                touch.pop()\n                return\n            ud['dx'] += abs(touch.dx)\n            ud['dy'] += abs(touch.dy)\n            if ((ud['dx'] > self.scroll_distance and self.do_scroll_x) or\n                    (ud['dy'] > self.scroll_distance and self.do_scroll_y)):\n                ud['mode'] = 'scroll'\n\n        if ud['mode'] == 'scroll':\n            not_in_bar = not touch.ud.get('in_bar_x', False) and \\\n                not touch.ud.get('in_bar_y', False)\n\n            if not touch.ud['sv.handled']['x'] and self.do_scroll_x \\\n                    and self.effect_x:\n                width = self.width\n                if touch.ud.get('in_bar_x', False):\n                    if self.hbar[1] != 1:\n                        dx = touch.dx / float(width - width * self.hbar[1])\n                        self.scroll_x = min(max(self.scroll_x + dx, 0.), 1.)\n                        self._trigger_update_from_scroll()\n                elif not_in_bar:\n                    self.effect_x.update(touch.x)\n\n                if self.scroll_x < 0 or self.scroll_x > 1:\n                    rv = False\n                else:\n                    touch.ud['sv.handled']['x'] = True\n                # Touch resulted in scroll should not defocus focused widget\n                touch.ud['sv.can_defocus'] = False\n            if not touch.ud['sv.handled']['y'] and self.do_scroll_y \\\n                    and self.effect_y:\n                height = self.height\n                if touch.ud.get('in_bar_y', False) and self.vbar[1] != 1.0:\n                    dy = touch.dy / float(height - height * self.vbar[1])\n                    self.scroll_y = min(max(self.scroll_y + dy, 0.), 1.)\n                    self._trigger_update_from_scroll()\n                elif not_in_bar:\n                    self.effect_y.update(touch.y)\n\n                if self.scroll_y < 0 or self.scroll_y > 1:\n                    rv = False\n                else:\n                    touch.ud['sv.handled']['y'] = True\n                # Touch resulted in scroll should not defocus focused widget\n                touch.ud['sv.can_defocus'] = False\n            ud['dt'] = touch.time_update - ud['time']\n            ud['time'] = touch.time_update\n            ud['user_stopped'] = True\n        return rv",
  "def on_touch_up(self, touch):\n        uid = self._get_uid('svavoid')\n        if self._touch is not touch and uid not in touch.ud:\n            # don't pass on touch to children if outside the sv\n            if self.collide_point(*touch.pos):\n                # touch is in parents\n                touch.push()\n                touch.apply_transform_2d(self.to_local)\n                if super(ScrollView, self).on_touch_up(touch):\n                    touch.pop()\n                    return True\n                touch.pop()\n            return False\n\n        if self.dispatch('on_scroll_stop', touch):\n            touch.ungrab(self)\n            if not touch.ud.get('sv.can_defocus', True):\n                # Focused widget should stay focused\n                FocusBehavior.ignored_touch.append(touch)\n            return True",
  "def on_scroll_stop(self, touch, check_children=True):\n        self._touch = None\n\n        if check_children:\n            touch.push()\n            touch.apply_transform_2d(self.to_local)\n            if self.dispatch_children('on_scroll_stop', touch):\n                touch.pop()\n                return True\n            touch.pop()\n\n        if self._get_uid('svavoid') in touch.ud:\n            return\n        if self._get_uid() not in touch.ud:\n            return False\n\n        self._touch = None\n        uid = self._get_uid()\n        ud = touch.ud[uid]\n        not_in_bar = not touch.ud.get('in_bar_x', False) and \\\n            not touch.ud.get('in_bar_y', False)\n        if self.do_scroll_x and self.effect_x and not_in_bar:\n            self.effect_x.stop(touch.x)\n        if self.do_scroll_y and self.effect_y and not_in_bar:\n            self.effect_y.stop(touch.y)\n        if ud['mode'] == 'unknown':\n            # we must do the click at least..\n            # only send the click if it was not a click to stop\n            # autoscrolling\n            if not ud['user_stopped']:\n                self.simulate_touch_down(touch)\n            Clock.schedule_once(partial(self._do_touch_up, touch), .2)\n\n        ev = self._update_effect_bounds_ev\n        if ev is None:\n            ev = self._update_effect_bounds_ev = Clock.create_trigger(\n                self._update_effect_bounds)\n        ev()\n\n        # if we do mouse scrolling, always accept it\n        if 'button' in touch.profile and touch.button.startswith('scroll'):\n            return True\n\n        return self._get_uid() in touch.ud",
  "def scroll_to(self, widget, padding=10, animate=True):\n        '''Scrolls the viewport to ensure that the given widget is visible,\n        optionally with padding and animation. If animate is True (the\n        default), then the default animation parameters will be used.\n        Otherwise, it should be a dict containing arguments to pass to\n        :class:`~kivy.animation.Animation` constructor.\n\n        .. versionadded:: 1.9.1\n        '''\n        if not self.parent:\n            return\n\n        # if _viewport is layout and has pending operation, reschedule\n        if hasattr(self._viewport, 'do_layout'):\n            if self._viewport._trigger_layout.is_triggered:\n                Clock.schedule_once(\n                     lambda *dt: self.scroll_to(widget, padding, animate))\n                return\n\n        if isinstance(padding, (int, float)):\n            padding = (padding, padding)\n\n        pos = self.parent.to_widget(*widget.to_window(*widget.pos))\n        cor = self.parent.to_widget(*widget.to_window(widget.right,\n                                                      widget.top))\n\n        dx = dy = 0\n\n        if pos[1] < self.y:\n            dy = self.y - pos[1] + dp(padding[1])\n        elif cor[1] > self.top:\n            dy = self.top - cor[1] - dp(padding[1])\n\n        if pos[0] < self.x:\n            dx = self.x - pos[0] + dp(padding[0])\n        elif cor[0] > self.right:\n            dx = self.right - cor[0] - dp(padding[0])\n\n        dsx, dsy = self.convert_distance_to_scroll(dx, dy)\n        sxp = min(1, max(0, self.scroll_x - dsx))\n        syp = min(1, max(0, self.scroll_y - dsy))\n\n        if animate:\n            if animate is True:\n                animate = {'d': 0.2, 't': 'out_quad'}\n            Animation.stop_all(self, 'scroll_x', 'scroll_y')\n            Animation(scroll_x=sxp, scroll_y=syp, **animate).start(self)\n        else:\n            self.scroll_x = sxp\n            self.scroll_y = syp",
  "def convert_distance_to_scroll(self, dx, dy):\n        '''Convert a distance in pixels to a scroll distance, depending on the\n        content size and the scrollview size.\n\n        The result will be a tuple of scroll distance that can be added to\n        :data:`scroll_x` and :data:`scroll_y`\n        '''\n        if not self._viewport:\n            return 0, 0\n        vp = self._viewport\n        if vp.width > self.width:\n            sw = vp.width - self.width\n            sx = dx / float(sw)\n        else:\n            sx = 0\n        if vp.height > self.height:\n            sh = vp.height - self.height\n            sy = dy / float(sh)\n        else:\n            sy = 1\n        return sx, sy",
  "def update_from_scroll(self, *largs):\n        '''Force the reposition of the content, according to current value of\n        :attr:`scroll_x` and :attr:`scroll_y`.\n\n        This method is automatically called when one of the :attr:`scroll_x`,\n        :attr:`scroll_y`, :attr:`pos` or :attr:`size` properties change, or\n        if the size of the content changes.\n        '''\n        if not self._viewport:\n            self.g_translate.xy = self.pos\n            return\n        vp = self._viewport\n\n        # update from size_hint\n        if vp.size_hint_x is not None:\n            w = vp.size_hint_x * self.width\n            if vp.size_hint_min_x is not None:\n                w = max(w, vp.size_hint_min_x)\n            if vp.size_hint_max_x is not None:\n                w = min(w, vp.size_hint_max_x)\n            vp.width = w\n\n        if vp.size_hint_y is not None:\n            h = vp.size_hint_y * self.height\n            if vp.size_hint_min_y is not None:\n                h = max(h, vp.size_hint_min_y)\n            if vp.size_hint_max_y is not None:\n                h = min(h, vp.size_hint_max_y)\n            vp.height = h\n\n        if vp.width > self.width or self.always_overscroll:\n            sw = vp.width - self.width\n            x = self.x - self.scroll_x * sw\n        else:\n            x = self.x\n\n        if vp.height > self.height or self.always_overscroll:\n            sh = vp.height - self.height\n            y = self.y - self.scroll_y * sh\n        else:\n            y = self.top - vp.height\n\n        # from 1.8.0, we now use a matrix by default, instead of moving the\n        # widget position behind. We set it here, but it will be a no-op most\n        # of the time.\n        vp.pos = 0, 0\n        self.g_translate.xy = x, y\n\n        # New in 1.2.0, show bar when scrolling happens and (changed in 1.9.0)\n        # fade to bar_inactive_color when no scroll is happening.\n        ev = self._bind_inactive_bar_color_ev\n        if ev is None:\n            ev = self._bind_inactive_bar_color_ev = Clock.create_trigger(\n                self._bind_inactive_bar_color, .5)\n        self.funbind('bar_inactive_color', self._change_bar_color)\n        Animation.stop_all(self, '_bar_color')\n        self.fbind('bar_color', self._change_bar_color)\n        self._bar_color = self.bar_color\n        ev()",
  "def _bind_inactive_bar_color(self, *l):\n        self.funbind('bar_color', self._change_bar_color)\n        self.fbind('bar_inactive_color', self._change_bar_color)\n        Animation(\n            _bar_color=self.bar_inactive_color,\n            d=.5, t='out_quart').start(self)",
  "def _change_bar_color(self, inst, value):\n        self._bar_color = value",
  "def add_widget(self, widget, *args, **kwargs):\n        if self._viewport:\n            raise Exception('ScrollView accept only one widget')\n        canvas = self.canvas\n        self.canvas = self.canvas_viewport\n        super(ScrollView, self).add_widget(widget, *args, **kwargs)\n        self.canvas = canvas\n        self._viewport = widget\n        widget.bind(size=self._trigger_update_from_scroll,\n                    size_hint_min=self._trigger_update_from_scroll)\n        self._trigger_update_from_scroll()",
  "def remove_widget(self, widget, *args, **kwargs):\n        canvas = self.canvas\n        self.canvas = self.canvas_viewport\n        super(ScrollView, self).remove_widget(widget, *args, **kwargs)\n        self.canvas = canvas\n        if widget is self._viewport:\n            self._viewport = None",
  "def _get_uid(self, prefix='sv'):\n        return '{0}.{1}'.format(prefix, self.uid)",
  "def _change_touch_mode(self, *largs):\n        if not self._touch:\n            return\n        uid = self._get_uid()\n        touch = self._touch\n        if uid not in touch.ud:\n            self._touch = False\n            return\n        ud = touch.ud[uid]\n        if ud['mode'] != 'unknown' or ud['user_stopped']:\n            return\n        diff_frames = Clock.frames - ud['frames']\n\n        # in order to be able to scroll on very slow devices, let at least 3\n        # frames displayed to accumulate some velocity. And then, change the\n        # touch mode. Otherwise, we might never be able to compute velocity,\n        # and no way to scroll it. See #1464 and #1499\n        if diff_frames < 3:\n            Clock.schedule_once(self._change_touch_mode, 0)\n            return\n\n        if self.do_scroll_x and self.effect_x:\n            self.effect_x.cancel()\n        if self.do_scroll_y and self.effect_y:\n            self.effect_y.cancel()\n        # XXX the next line was in the condition. But this stop\n        # the possibility to \"drag\" an object out of the scrollview in the\n        # non-used direction: if you have an horizontal scrollview, a\n        # vertical gesture will not \"stop\" the scroll view to look for an\n        # horizontal gesture, until the timeout is done.\n        # and touch.dx + touch.dy == 0:\n        touch.ungrab(self)\n        self._touch = None\n        # touch is in window coords\n        touch.push()\n        touch.apply_transform_2d(self.to_widget)\n        touch.apply_transform_2d(self.to_parent)\n        self.simulate_touch_down(touch)\n        touch.pop()\n        return",
  "def _do_touch_up(self, touch, *largs):\n        # touch is in window coords\n        touch.push()\n        touch.apply_transform_2d(self.to_widget)\n        super(ScrollView, self).on_touch_up(touch)\n        touch.pop()\n        # don't forget about grab event!\n        for x in touch.grab_list[:]:\n            touch.grab_list.remove(x)\n            x = x()\n            if not x:\n                continue\n            touch.grab_current = x\n            # touch is in window coords\n            touch.push()\n            touch.apply_transform_2d(self.to_widget)\n            super(ScrollView, self).on_touch_up(touch)\n            touch.pop()\n        touch.grab_current = None",
  "class ScrollViewApp(App):\n\n        def build(self):\n            layout1 = GridLayout(cols=4, spacing=10, size_hint=(None, None))\n            layout1.bind(minimum_height=layout1.setter('height'),\n                         minimum_width=layout1.setter('width'))\n            for i in range(40):\n                btn = Button(text=str(i), size_hint=(None, None),\n                             size=(200, 100))\n                layout1.add_widget(btn)\n            scrollview1 = ScrollView(bar_width='2dp', smooth_scroll_end=10)\n            scrollview1.add_widget(layout1)\n\n            layout2 = GridLayout(cols=4, spacing=10, size_hint=(None, None))\n            layout2.bind(minimum_height=layout2.setter('height'),\n                         minimum_width=layout2.setter('width'))\n            for i in range(40):\n                btn = Button(text=str(i), size_hint=(None, None),\n                             size=(200, 100))\n                layout2.add_widget(btn)\n            scrollview2 = ScrollView(scroll_type=['bars'],\n                                     bar_width='9dp',\n                                     scroll_wheel_distance=100)\n            scrollview2.add_widget(layout2)\n\n            root = GridLayout(cols=2)\n            root.add_widget(scrollview1)\n            root.add_widget(scrollview2)\n            return root",
  "def build(self):\n            layout1 = GridLayout(cols=4, spacing=10, size_hint=(None, None))\n            layout1.bind(minimum_height=layout1.setter('height'),\n                         minimum_width=layout1.setter('width'))\n            for i in range(40):\n                btn = Button(text=str(i), size_hint=(None, None),\n                             size=(200, 100))\n                layout1.add_widget(btn)\n            scrollview1 = ScrollView(bar_width='2dp', smooth_scroll_end=10)\n            scrollview1.add_widget(layout1)\n\n            layout2 = GridLayout(cols=4, spacing=10, size_hint=(None, None))\n            layout2.bind(minimum_height=layout2.setter('height'),\n                         minimum_width=layout2.setter('width'))\n            for i in range(40):\n                btn = Button(text=str(i), size_hint=(None, None),\n                             size=(200, 100))\n                layout2.add_widget(btn)\n            scrollview2 = ScrollView(scroll_type=['bars'],\n                                     bar_width='9dp',\n                                     scroll_wheel_distance=100)\n            scrollview2.add_widget(layout2)\n\n            root = GridLayout(cols=2)\n            root.add_widget(scrollview1)\n            root.add_widget(scrollview2)\n            return root",
  "class ToggleButton(ToggleButtonBehavior, Button):\n    '''Toggle button class, see module documentation for more information.\n    '''\n\n    pass",
  "def distance(pt1, pt2):\n    return sqrt((pt1[0] - pt2[0]) ** 2. + (pt1[1] - pt2[1]) ** 2.)",
  "def polar_to_rect(origin, r, theta):\n    return origin[0] + r * cos(theta), origin[1] + r * sin(theta)",
  "def rect_to_polar(origin, x, y):\n    if x == origin[0]:\n        if y == origin[1]:\n            return (0, 0)\n        elif y > origin[1]:\n            return (y - origin[1], pi / 2.)\n        else:\n            return (origin[1] - y, 3 * pi / 2.)\n    t = atan(float((y - origin[1])) / (x - origin[0]))\n    if x - origin[0] < 0:\n        t += pi\n\n    if t < 0:\n        t += 2 * pi\n\n    return (distance((x, y), origin), t)",
  "class ColorWheel(Widget):\n    '''Chromatic wheel for the ColorPicker.\n\n    .. versionchanged:: 1.7.1\n        `font_size`, `font_name` and `foreground_color` have been removed. The\n        sizing is now the same as others widget, based on 'sp'. Orientation is\n        also automatically determined according to the width/height ratio.\n\n    '''\n\n    r = BoundedNumericProperty(0, min=0, max=1)\n    '''The Red value of the color currently selected.\n\n    :attr:`r` is a :class:`~kivy.properties.BoundedNumericProperty` and\n    can be a value from 0 to 1. It defaults to 0.\n    '''\n\n    g = BoundedNumericProperty(0, min=0, max=1)\n    '''The Green value of the color currently selected.\n\n    :attr:`g` is a :class:`~kivy.properties.BoundedNumericProperty`\n    and can be a value from 0 to 1.\n    '''\n\n    b = BoundedNumericProperty(0, min=0, max=1)\n    '''The Blue value of the color currently selected.\n\n    :attr:`b` is a :class:`~kivy.properties.BoundedNumericProperty` and\n    can be a value from 0 to 1.\n    '''\n\n    a = BoundedNumericProperty(0, min=0, max=1)\n    '''The Alpha value of the color currently selected.\n\n    :attr:`a` is a :class:`~kivy.properties.BoundedNumericProperty` and\n    can be a value from 0 to 1.\n    '''\n\n    color = ReferenceListProperty(r, g, b, a)\n    '''The holds the color currently selected.\n\n    :attr:`color` is a :class:`~kivy.properties.ReferenceListProperty` and\n    contains a list of `r`, `g`, `b`, `a` values.\n    '''\n\n    _origin = ListProperty((100, 100))\n    _radius = NumericProperty(100)\n\n    _piece_divisions = NumericProperty(10)\n    _pieces_of_pie = NumericProperty(16)\n\n    _inertia_slowdown = 1.25\n    _inertia_cutoff = .25\n\n    _num_touches = 0\n    _pinch_flag = False\n\n    _hsv = ListProperty([1, 1, 1, 0])\n\n    def __init__(self, **kwargs):\n        super(ColorWheel, self).__init__(**kwargs)\n\n        pdv = self._piece_divisions\n        self.sv_s = [(float(x) / pdv, 1) for x in range(pdv)] + [\n            (1, float(y) / pdv) for y in reversed(range(pdv))]\n\n    def on__origin(self, instance, value):\n        self.init_wheel(None)\n\n    def on__radius(self, instance, value):\n        self.init_wheel(None)\n\n    def init_wheel(self, dt):\n        # initialize list to hold all meshes\n        self.canvas.clear()\n        self.arcs = []\n        self.sv_idx = 0\n        pdv = self._piece_divisions\n        ppie = self._pieces_of_pie\n\n        for r in range(pdv):\n            for t in range(ppie):\n                self.arcs.append(\n                    _ColorArc(\n                        self._radius * (float(r) / float(pdv)),\n                        self._radius * (float(r + 1) / float(pdv)),\n                        2 * pi * (float(t) / float(ppie)),\n                        2 * pi * (float(t + 1) / float(ppie)),\n                        origin=self._origin,\n                        color=(float(t) / ppie,\n                               self.sv_s[self.sv_idx + r][0],\n                               self.sv_s[self.sv_idx + r][1],\n                               1)))\n\n                self.canvas.add(self.arcs[-1])\n\n    def recolor_wheel(self):\n        ppie = self._pieces_of_pie\n        for idx, segment in enumerate(self.arcs):\n            segment.change_color(\n                sv=self.sv_s[int(self.sv_idx + idx / ppie)])\n\n    def change_alpha(self, val):\n        for idx, segment in enumerate(self.arcs):\n            segment.change_color(a=val)\n\n    def inertial_incr_sv_idx(self, dt):\n        # if its already zoomed all the way out, cancel the inertial zoom\n        if self.sv_idx == len(self.sv_s) - self._piece_divisions:\n            return False\n\n        self.sv_idx += 1\n        self.recolor_wheel()\n        if dt * self._inertia_slowdown > self._inertia_cutoff:\n            return False\n        else:\n            Clock.schedule_once(self.inertial_incr_sv_idx,\n                                dt * self._inertia_slowdown)\n\n    def inertial_decr_sv_idx(self, dt):\n        # if its already zoomed all the way in, cancel the inertial zoom\n        if self.sv_idx == 0:\n            return False\n        self.sv_idx -= 1\n        self.recolor_wheel()\n        if dt * self._inertia_slowdown > self._inertia_cutoff:\n            return False\n        else:\n            Clock.schedule_once(self.inertial_decr_sv_idx,\n                                dt * self._inertia_slowdown)\n\n    def on_touch_down(self, touch):\n        r = self._get_touch_r(touch.pos)\n        if r > self._radius:\n            return False\n\n        # code is still set up to allow pinch to zoom, but this is\n        # disabled for now since it was fiddly with small wheels.\n        # Comment out these lines and  adjust on_touch_move to reenable\n        # this.\n        if self._num_touches != 0:\n            return False\n\n        touch.grab(self)\n        self._num_touches += 1\n        touch.ud['anchor_r'] = r\n        touch.ud['orig_sv_idx'] = self.sv_idx\n        touch.ud['orig_time'] = Clock.get_time()\n\n    def on_touch_move(self, touch):\n        if touch.grab_current is not self:\n            return\n        r = self._get_touch_r(touch.pos)\n        goal_sv_idx = (touch.ud['orig_sv_idx'] -\n                       int((r - touch.ud['anchor_r']) /\n                            (float(self._radius) / self._piece_divisions)))\n\n        if (\n            goal_sv_idx != self.sv_idx and\n            goal_sv_idx >= 0 and\n            goal_sv_idx <= len(self.sv_s) - self._piece_divisions\n        ):\n            # this is a pinch to zoom\n            self._pinch_flag = True\n            self.sv_idx = goal_sv_idx\n            self.recolor_wheel()\n\n    def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n        self._num_touches -= 1\n        if self._pinch_flag:\n            if self._num_touches == 0:\n                # user was pinching, and now both fingers are up. Return\n                # to normal\n                if self.sv_idx > touch.ud['orig_sv_idx']:\n                    Clock.schedule_once(\n                        self.inertial_incr_sv_idx,\n                        (Clock.get_time() - touch.ud['orig_time']) /\n                        (self.sv_idx - touch.ud['orig_sv_idx']))\n\n                if self.sv_idx < touch.ud['orig_sv_idx']:\n                    Clock.schedule_once(\n                        self.inertial_decr_sv_idx,\n                        (Clock.get_time() - touch.ud['orig_time']) /\n                        (self.sv_idx - touch.ud['orig_sv_idx']))\n\n                self._pinch_flag = False\n                return\n            else:\n                # user was pinching, and at least one finger remains. We\n                # don't want to treat the remaining fingers as touches\n                return\n        else:\n            r, theta = rect_to_polar(self._origin, *touch.pos)\n            # if touch up is outside the wheel, ignore\n            if r >= self._radius:\n                return\n            # compute which ColorArc is being touched (they aren't\n            # widgets so we don't get collide_point) and set\n            # _hsv based on the selected ColorArc\n            piece = int((theta / (2 * pi)) * self._pieces_of_pie)\n            division = int((r / self._radius) * self._piece_divisions)\n            hsva = list(\n                self.arcs[self._pieces_of_pie * division + piece].color)\n            self.color = list(hsv_to_rgb(*hsva[:3])) + hsva[-1:]\n\n    def _get_touch_r(self, pos):\n        return distance(pos, self._origin)",
  "class _ColorArc(InstructionGroup):\n    def __init__(self, r_min, r_max, theta_min, theta_max,\n                 color=(0, 0, 1, 1), origin=(0, 0), **kwargs):\n        super(_ColorArc, self).__init__(**kwargs)\n        self.origin = origin\n        self.r_min = r_min\n        self.r_max = r_max\n        self.theta_min = theta_min\n        self.theta_max = theta_max\n        self.color = color\n        self.color_instr = Color(*color, mode='hsv')\n        self.add(self.color_instr)\n        self.mesh = self.get_mesh()\n        self.add(self.mesh)\n\n    def __str__(self):\n        return \"r_min: %s r_max: %s theta_min: %s theta_max: %s color: %s\" % (\n            self.r_min, self.r_max, self.theta_min, self.theta_max, self.color\n        )\n\n    def get_mesh(self):\n        v = []\n        # first calculate the distance between endpoints of the outer\n        # arc, so we know how many steps to use when calculating\n        # vertices\n        theta_step_outer = 0.1\n        theta = self.theta_max - self.theta_min\n        d_outer = int(theta / theta_step_outer)\n        theta_step_outer = theta / d_outer\n\n        if self.r_min == 0:\n            for x in range(0, d_outer, 2):\n                v += (polar_to_rect(self.origin, self.r_max,\n                                    self.theta_min + x * theta_step_outer\n                                    ) * 2)\n                v += polar_to_rect(self.origin, 0, 0) * 2\n                v += (polar_to_rect(self.origin, self.r_max,\n                                    self.theta_min + (x + 1) * theta_step_outer\n                                    ) * 2)\n            if not d_outer & 1:  # add a last point if d_outer is even\n                v += (polar_to_rect(self.origin, self.r_max,\n                                    self.theta_min + d_outer * theta_step_outer\n                                    ) * 2)\n        else:\n            for x in range(d_outer + 1):\n                v += (polar_to_rect(self.origin, self.r_min,\n                                    self.theta_min + x * theta_step_outer\n                                    ) * 2)\n                v += (polar_to_rect(self.origin, self.r_max,\n                                    self.theta_min + x * theta_step_outer\n                                    ) * 2)\n\n        return Mesh(vertices=v, indices=range(int(len(v) / 4)),\n                    mode='triangle_strip')\n\n    def change_color(self, color=None, color_delta=None, sv=None, a=None):\n        self.remove(self.color_instr)\n        if color is not None:\n            self.color = color\n        elif color_delta is not None:\n            self.color = [self.color[i] + color_delta[i] for i in range(4)]\n        elif sv is not None:\n            self.color = (self.color[0], sv[0], sv[1], self.color[3])\n        elif a is not None:\n            self.color = (self.color[0], self.color[1], self.color[2], a)\n        self.color_instr = Color(*self.color, mode='hsv')\n        self.insert(0, self.color_instr)",
  "class ColorPicker(RelativeLayout):\n    '''\n    See module documentation.\n    '''\n\n    font_name = StringProperty('data/fonts/RobotoMono-Regular.ttf')\n    '''Specifies the font used on the ColorPicker.\n\n    :attr:`font_name` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'data/fonts/RobotoMono-Regular.ttf'.\n    '''\n\n    color = ListProperty((1, 1, 1, 1))\n    '''The :attr:`color` holds the color currently selected in rgba format.\n\n    :attr:`color` is a :class:`~kivy.properties.ListProperty` and defaults to\n    (1, 1, 1, 1).\n    '''\n\n    def _get_hsv(self):\n        return rgb_to_hsv(*self.color[:3])\n\n    def _set_hsv(self, value):\n        if self._updating_clr:\n            return\n        self.set_color(value)\n\n    hsv = AliasProperty(_get_hsv, _set_hsv, bind=('color', ))\n    '''The :attr:`hsv` holds the color currently selected in hsv format.\n\n    :attr:`hsv` is a :class:`~kivy.properties.ListProperty` and defaults to\n    (1, 1, 1).\n    '''\n    def _get_hex(self):\n        return get_hex_from_color(self.color)\n\n    def _set_hex(self, value):\n        if self._updating_clr:\n            return\n        self.set_color(get_color_from_hex(value)[:4])\n\n    hex_color = AliasProperty(_get_hex, _set_hex, bind=('color',), cache=True)\n    '''The :attr:`hex_color` holds the currently selected color in hex.\n\n    :attr:`hex_color` is an :class:`~kivy.properties.AliasProperty` and\n    defaults to `#ffffffff`.\n    '''\n\n    wheel = ObjectProperty(None)\n    '''The :attr:`wheel` holds the color wheel.\n\n    :attr:`wheel` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    _update_clr_ev = _update_hex_ev = None\n\n    # now used only internally.\n    foreground_color = ListProperty((1, 1, 1, 1))\n\n    def _trigger_update_clr(self, mode, clr_idx, text):\n        if self._updating_clr:\n            return\n        self._updating_clr = True\n        self._upd_clr_list = mode, clr_idx, text\n        ev = self._update_clr_ev\n        if ev is None:\n            ev = self._update_clr_ev = Clock.create_trigger(self._update_clr)\n        ev()\n\n    def _update_clr(self, dt):\n        # to prevent interaction between hsv/rgba, we work internally using rgba\n        mode, clr_idx, text = self._upd_clr_list\n        try:\n            text = min(255, max(0, float(text)))\n            if mode == 'rgb':\n                self.color[clr_idx] = float(text) / 255.\n            else:\n                hsv = list(self.hsv[:])\n                hsv[clr_idx] = float(text) / 255.\n                self.color[:3] = hsv_to_rgb(*hsv)\n        except ValueError:\n            Logger.warning('ColorPicker: invalid value : {}'.format(text))\n        finally:\n            self._updating_clr = False\n\n    def _update_hex(self, dt):\n        try:\n            if len(self._upd_hex_list) != 9:\n                return\n            self._updating_clr = False\n            self.hex_color = self._upd_hex_list\n        finally:\n            self._updating_clr = False\n\n    def _trigger_update_hex(self, text):\n        if self._updating_clr:\n            return\n        self._updating_clr = True\n        self._upd_hex_list = text\n        ev = self._update_hex_ev\n        if ev is None:\n            ev = self._update_hex_ev = Clock.create_trigger(self._update_hex)\n        ev()\n\n    def set_color(self, color):\n        self._updating_clr = True\n        if len(color) == 3:\n            self.color[:3] = color\n        else:\n            self.color = color\n        self._updating_clr = False\n\n    def __init__(self, **kwargs):\n        self._updating_clr = False\n        super(ColorPicker, self).__init__(**kwargs)",
  "def __init__(self, **kwargs):\n        super(ColorWheel, self).__init__(**kwargs)\n\n        pdv = self._piece_divisions\n        self.sv_s = [(float(x) / pdv, 1) for x in range(pdv)] + [\n            (1, float(y) / pdv) for y in reversed(range(pdv))]",
  "def on__origin(self, instance, value):\n        self.init_wheel(None)",
  "def on__radius(self, instance, value):\n        self.init_wheel(None)",
  "def init_wheel(self, dt):\n        # initialize list to hold all meshes\n        self.canvas.clear()\n        self.arcs = []\n        self.sv_idx = 0\n        pdv = self._piece_divisions\n        ppie = self._pieces_of_pie\n\n        for r in range(pdv):\n            for t in range(ppie):\n                self.arcs.append(\n                    _ColorArc(\n                        self._radius * (float(r) / float(pdv)),\n                        self._radius * (float(r + 1) / float(pdv)),\n                        2 * pi * (float(t) / float(ppie)),\n                        2 * pi * (float(t + 1) / float(ppie)),\n                        origin=self._origin,\n                        color=(float(t) / ppie,\n                               self.sv_s[self.sv_idx + r][0],\n                               self.sv_s[self.sv_idx + r][1],\n                               1)))\n\n                self.canvas.add(self.arcs[-1])",
  "def recolor_wheel(self):\n        ppie = self._pieces_of_pie\n        for idx, segment in enumerate(self.arcs):\n            segment.change_color(\n                sv=self.sv_s[int(self.sv_idx + idx / ppie)])",
  "def change_alpha(self, val):\n        for idx, segment in enumerate(self.arcs):\n            segment.change_color(a=val)",
  "def inertial_incr_sv_idx(self, dt):\n        # if its already zoomed all the way out, cancel the inertial zoom\n        if self.sv_idx == len(self.sv_s) - self._piece_divisions:\n            return False\n\n        self.sv_idx += 1\n        self.recolor_wheel()\n        if dt * self._inertia_slowdown > self._inertia_cutoff:\n            return False\n        else:\n            Clock.schedule_once(self.inertial_incr_sv_idx,\n                                dt * self._inertia_slowdown)",
  "def inertial_decr_sv_idx(self, dt):\n        # if its already zoomed all the way in, cancel the inertial zoom\n        if self.sv_idx == 0:\n            return False\n        self.sv_idx -= 1\n        self.recolor_wheel()\n        if dt * self._inertia_slowdown > self._inertia_cutoff:\n            return False\n        else:\n            Clock.schedule_once(self.inertial_decr_sv_idx,\n                                dt * self._inertia_slowdown)",
  "def on_touch_down(self, touch):\n        r = self._get_touch_r(touch.pos)\n        if r > self._radius:\n            return False\n\n        # code is still set up to allow pinch to zoom, but this is\n        # disabled for now since it was fiddly with small wheels.\n        # Comment out these lines and  adjust on_touch_move to reenable\n        # this.\n        if self._num_touches != 0:\n            return False\n\n        touch.grab(self)\n        self._num_touches += 1\n        touch.ud['anchor_r'] = r\n        touch.ud['orig_sv_idx'] = self.sv_idx\n        touch.ud['orig_time'] = Clock.get_time()",
  "def on_touch_move(self, touch):\n        if touch.grab_current is not self:\n            return\n        r = self._get_touch_r(touch.pos)\n        goal_sv_idx = (touch.ud['orig_sv_idx'] -\n                       int((r - touch.ud['anchor_r']) /\n                            (float(self._radius) / self._piece_divisions)))\n\n        if (\n            goal_sv_idx != self.sv_idx and\n            goal_sv_idx >= 0 and\n            goal_sv_idx <= len(self.sv_s) - self._piece_divisions\n        ):\n            # this is a pinch to zoom\n            self._pinch_flag = True\n            self.sv_idx = goal_sv_idx\n            self.recolor_wheel()",
  "def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n        self._num_touches -= 1\n        if self._pinch_flag:\n            if self._num_touches == 0:\n                # user was pinching, and now both fingers are up. Return\n                # to normal\n                if self.sv_idx > touch.ud['orig_sv_idx']:\n                    Clock.schedule_once(\n                        self.inertial_incr_sv_idx,\n                        (Clock.get_time() - touch.ud['orig_time']) /\n                        (self.sv_idx - touch.ud['orig_sv_idx']))\n\n                if self.sv_idx < touch.ud['orig_sv_idx']:\n                    Clock.schedule_once(\n                        self.inertial_decr_sv_idx,\n                        (Clock.get_time() - touch.ud['orig_time']) /\n                        (self.sv_idx - touch.ud['orig_sv_idx']))\n\n                self._pinch_flag = False\n                return\n            else:\n                # user was pinching, and at least one finger remains. We\n                # don't want to treat the remaining fingers as touches\n                return\n        else:\n            r, theta = rect_to_polar(self._origin, *touch.pos)\n            # if touch up is outside the wheel, ignore\n            if r >= self._radius:\n                return\n            # compute which ColorArc is being touched (they aren't\n            # widgets so we don't get collide_point) and set\n            # _hsv based on the selected ColorArc\n            piece = int((theta / (2 * pi)) * self._pieces_of_pie)\n            division = int((r / self._radius) * self._piece_divisions)\n            hsva = list(\n                self.arcs[self._pieces_of_pie * division + piece].color)\n            self.color = list(hsv_to_rgb(*hsva[:3])) + hsva[-1:]",
  "def _get_touch_r(self, pos):\n        return distance(pos, self._origin)",
  "def __init__(self, r_min, r_max, theta_min, theta_max,\n                 color=(0, 0, 1, 1), origin=(0, 0), **kwargs):\n        super(_ColorArc, self).__init__(**kwargs)\n        self.origin = origin\n        self.r_min = r_min\n        self.r_max = r_max\n        self.theta_min = theta_min\n        self.theta_max = theta_max\n        self.color = color\n        self.color_instr = Color(*color, mode='hsv')\n        self.add(self.color_instr)\n        self.mesh = self.get_mesh()\n        self.add(self.mesh)",
  "def __str__(self):\n        return \"r_min: %s r_max: %s theta_min: %s theta_max: %s color: %s\" % (\n            self.r_min, self.r_max, self.theta_min, self.theta_max, self.color\n        )",
  "def get_mesh(self):\n        v = []\n        # first calculate the distance between endpoints of the outer\n        # arc, so we know how many steps to use when calculating\n        # vertices\n        theta_step_outer = 0.1\n        theta = self.theta_max - self.theta_min\n        d_outer = int(theta / theta_step_outer)\n        theta_step_outer = theta / d_outer\n\n        if self.r_min == 0:\n            for x in range(0, d_outer, 2):\n                v += (polar_to_rect(self.origin, self.r_max,\n                                    self.theta_min + x * theta_step_outer\n                                    ) * 2)\n                v += polar_to_rect(self.origin, 0, 0) * 2\n                v += (polar_to_rect(self.origin, self.r_max,\n                                    self.theta_min + (x + 1) * theta_step_outer\n                                    ) * 2)\n            if not d_outer & 1:  # add a last point if d_outer is even\n                v += (polar_to_rect(self.origin, self.r_max,\n                                    self.theta_min + d_outer * theta_step_outer\n                                    ) * 2)\n        else:\n            for x in range(d_outer + 1):\n                v += (polar_to_rect(self.origin, self.r_min,\n                                    self.theta_min + x * theta_step_outer\n                                    ) * 2)\n                v += (polar_to_rect(self.origin, self.r_max,\n                                    self.theta_min + x * theta_step_outer\n                                    ) * 2)\n\n        return Mesh(vertices=v, indices=range(int(len(v) / 4)),\n                    mode='triangle_strip')",
  "def change_color(self, color=None, color_delta=None, sv=None, a=None):\n        self.remove(self.color_instr)\n        if color is not None:\n            self.color = color\n        elif color_delta is not None:\n            self.color = [self.color[i] + color_delta[i] for i in range(4)]\n        elif sv is not None:\n            self.color = (self.color[0], sv[0], sv[1], self.color[3])\n        elif a is not None:\n            self.color = (self.color[0], self.color[1], self.color[2], a)\n        self.color_instr = Color(*self.color, mode='hsv')\n        self.insert(0, self.color_instr)",
  "def _get_hsv(self):\n        return rgb_to_hsv(*self.color[:3])",
  "def _set_hsv(self, value):\n        if self._updating_clr:\n            return\n        self.set_color(value)",
  "def _get_hex(self):\n        return get_hex_from_color(self.color)",
  "def _set_hex(self, value):\n        if self._updating_clr:\n            return\n        self.set_color(get_color_from_hex(value)[:4])",
  "def _trigger_update_clr(self, mode, clr_idx, text):\n        if self._updating_clr:\n            return\n        self._updating_clr = True\n        self._upd_clr_list = mode, clr_idx, text\n        ev = self._update_clr_ev\n        if ev is None:\n            ev = self._update_clr_ev = Clock.create_trigger(self._update_clr)\n        ev()",
  "def _update_clr(self, dt):\n        # to prevent interaction between hsv/rgba, we work internally using rgba\n        mode, clr_idx, text = self._upd_clr_list\n        try:\n            text = min(255, max(0, float(text)))\n            if mode == 'rgb':\n                self.color[clr_idx] = float(text) / 255.\n            else:\n                hsv = list(self.hsv[:])\n                hsv[clr_idx] = float(text) / 255.\n                self.color[:3] = hsv_to_rgb(*hsv)\n        except ValueError:\n            Logger.warning('ColorPicker: invalid value : {}'.format(text))\n        finally:\n            self._updating_clr = False",
  "def _update_hex(self, dt):\n        try:\n            if len(self._upd_hex_list) != 9:\n                return\n            self._updating_clr = False\n            self.hex_color = self._upd_hex_list\n        finally:\n            self._updating_clr = False",
  "def _trigger_update_hex(self, text):\n        if self._updating_clr:\n            return\n        self._updating_clr = True\n        self._upd_hex_list = text\n        ev = self._update_hex_ev\n        if ev is None:\n            ev = self._update_hex_ev = Clock.create_trigger(self._update_hex)\n        ev()",
  "def set_color(self, color):\n        self._updating_clr = True\n        if len(color) == 3:\n            self.color[:3] = color\n        else:\n            self.color = color\n        self._updating_clr = False",
  "def __init__(self, **kwargs):\n        self._updating_clr = False\n        super(ColorPicker, self).__init__(**kwargs)",
  "class ColorPickerApp(App):\n        def build(self):\n            cp = ColorPicker(pos_hint={'center_x': .5, 'center_y': .5},\n                             size_hint=(1, 1))\n            return cp",
  "def build(self):\n            cp = ColorPicker(pos_hint={'center_x': .5, 'center_y': .5},\n                             size_hint=(1, 1))\n            return cp",
  "class AnchorLayout(Layout):\n    '''Anchor layout class. See the module documentation for more information.\n    '''\n\n    padding = VariableListProperty([0, 0, 0, 0])\n    '''Padding between the widget box and its children, in pixels:\n    [padding_left, padding_top, padding_right, padding_bottom].\n\n    padding also accepts a two argument form [padding_horizontal,\n    padding_vertical] and a one argument form [padding].\n\n    :attr:`padding` is a :class:`~kivy.properties.VariableListProperty` and\n    defaults to [0, 0, 0, 0].\n    '''\n\n    anchor_x = OptionProperty('center', options=(\n        'left', 'center', 'right'))\n    '''Horizontal anchor.\n\n    :attr:`anchor_x` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'center'. It accepts values of 'left', 'center' or\n    'right'.\n    '''\n\n    anchor_y = OptionProperty('center', options=(\n        'top', 'center', 'bottom'))\n    '''Vertical anchor.\n\n    :attr:`anchor_y` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'center'. It accepts values of 'top', 'center' or\n    'bottom'.\n    '''\n\n    def __init__(self, **kwargs):\n        super(AnchorLayout, self).__init__(**kwargs)\n        fbind = self.fbind\n        update = self._trigger_layout\n        fbind('children', update)\n        fbind('parent', update)\n        fbind('padding', update)\n        fbind('anchor_x', update)\n        fbind('anchor_y', update)\n        fbind('size', update)\n        fbind('pos', update)\n\n    def do_layout(self, *largs):\n        _x, _y = self.pos\n        width = self.width\n        height = self.height\n        anchor_x = self.anchor_x\n        anchor_y = self.anchor_y\n        pad_left, pad_top, pad_right, pad_bottom = self.padding\n\n        for c in self.children:\n            x, y = _x, _y\n            cw, ch = c.size\n            shw, shh = c.size_hint\n            shw_min, shh_min = c.size_hint_min\n            shw_max, shh_max = c.size_hint_max\n\n            if shw is not None:\n                cw = shw * (width - pad_left - pad_right)\n                if shw_min is not None and cw < shw_min:\n                    cw = shw_min\n                elif shw_max is not None and cw > shw_max:\n                    cw = shw_max\n\n            if shh is not None:\n                ch = shh * (height - pad_top - pad_bottom)\n                if shh_min is not None and ch < shh_min:\n                    ch = shh_min\n                elif shh_max is not None and ch > shh_max:\n                    ch = shh_max\n\n            if anchor_x == 'left':\n                x = x + pad_left\n            elif anchor_x == 'right':\n                x = x + width - (cw + pad_right)\n            else:\n                x = x + (width - pad_right + pad_left - cw) / 2\n            if anchor_y == 'bottom':\n                y = y + pad_bottom\n            elif anchor_y == 'top':\n                y = y + height - (ch + pad_top)\n            else:\n                y = y + (height - pad_top + pad_bottom - ch) / 2\n\n            c.pos = x, y\n            c.size = cw, ch",
  "def __init__(self, **kwargs):\n        super(AnchorLayout, self).__init__(**kwargs)\n        fbind = self.fbind\n        update = self._trigger_layout\n        fbind('children', update)\n        fbind('parent', update)\n        fbind('padding', update)\n        fbind('anchor_x', update)\n        fbind('anchor_y', update)\n        fbind('size', update)\n        fbind('pos', update)",
  "def do_layout(self, *largs):\n        _x, _y = self.pos\n        width = self.width\n        height = self.height\n        anchor_x = self.anchor_x\n        anchor_y = self.anchor_y\n        pad_left, pad_top, pad_right, pad_bottom = self.padding\n\n        for c in self.children:\n            x, y = _x, _y\n            cw, ch = c.size\n            shw, shh = c.size_hint\n            shw_min, shh_min = c.size_hint_min\n            shw_max, shh_max = c.size_hint_max\n\n            if shw is not None:\n                cw = shw * (width - pad_left - pad_right)\n                if shw_min is not None and cw < shw_min:\n                    cw = shw_min\n                elif shw_max is not None and cw > shw_max:\n                    cw = shw_max\n\n            if shh is not None:\n                ch = shh * (height - pad_top - pad_bottom)\n                if shh_min is not None and ch < shh_min:\n                    ch = shh_min\n                elif shh_max is not None and ch > shh_max:\n                    ch = shh_max\n\n            if anchor_x == 'left':\n                x = x + pad_left\n            elif anchor_x == 'right':\n                x = x + width - (cw + pad_right)\n            else:\n                x = x + (width - pad_right + pad_left - cw) / 2\n            if anchor_y == 'bottom':\n                y = y + pad_bottom\n            elif anchor_y == 'top':\n                y = y + height - (ch + pad_top)\n            else:\n                y = y + (height - pad_top + pad_bottom - ch) / 2\n\n            c.pos = x, y\n            c.size = cw, ch",
  "def _widget_destructor(uid, r):\n    # Internal method called when a widget is deleted from memory. the only\n    # thing we remember about it is its uid. Clear all the associated callbacks\n    # created in kv language.\n    del _widget_destructors[uid]\n    Builder.unbind_widget(uid)",
  "class WidgetException(Exception):\n    '''Fired when the widget gets an exception.\n    '''\n    pass",
  "class WidgetMetaclass(type):\n    '''Metaclass to automatically register new widgets for the\n    :class:`~kivy.factory.Factory`.\n\n    .. warning::\n        This metaclass is used by the Widget. Do not use it directly!\n    '''\n    def __init__(mcs, name, bases, attrs):\n        super(WidgetMetaclass, mcs).__init__(name, bases, attrs)\n        Factory.register(name, cls=mcs)",
  "class Widget(WidgetBase):\n    '''Widget class. See module documentation for more information.\n\n    :Events:\n        `on_touch_down`: `(touch, )`\n            Fired when a new touch event occurs. `touch` is the touch object.\n        `on_touch_move`: `(touch, )`\n            Fired when an existing touch moves. `touch` is the touch object.\n        `on_touch_up`: `(touch, )`\n            Fired when an existing touch disappears. `touch` is the touch\n            object.\n        `on_kv_post`: `(base_widget, )`\n            Fired after all the kv rules associated with the widget\n            and all other widgets that are in any of those rules have had\n            all their kv rules applied. `base_widget` is the base-most widget\n            whose instantiation triggered the kv rules (i.e. the widget\n            instantiated from Python, e.g. ``MyWidget()``).\n\n            .. versionchanged:: 1.11.0\n\n    .. warning::\n        Adding a `__del__` method to a class derived from Widget with Python\n        prior to 3.4 will disable automatic garbage collection for instances\n        of that class. This is because the Widget class creates reference\n        cycles, thereby `preventing garbage collection\n        <https://docs.python.org/2/library/gc.html#gc.garbage>`_.\n\n    .. versionchanged:: 1.0.9\n        Everything related to event properties has been moved to the\n        :class:`~kivy.event.EventDispatcher`. Event properties can now be used\n        when constructing a simple class without subclassing :class:`Widget`.\n\n    .. versionchanged:: 1.5.0\n        The constructor now accepts on_* arguments to automatically bind\n        callbacks to properties or events, as in the Kv language.\n    '''\n\n    __metaclass__ = WidgetMetaclass\n    __events__ = (\n        'on_motion', 'on_touch_down', 'on_touch_move', 'on_touch_up',\n        'on_kv_post'\n    )\n    _proxy_ref = None\n\n    def __init__(self, **kwargs):\n        # Before doing anything, ensure the windows exist.\n        EventLoop.ensure_window()\n\n        # Assign the default context of the widget creation.\n        if not hasattr(self, '_context'):\n            self._context = get_current_context()\n\n        no_builder = '__no_builder' in kwargs\n        self._disabled_value = False\n        if no_builder:\n            del kwargs['__no_builder']\n        on_args = {k: v for k, v in kwargs.items() if k[:3] == 'on_'}\n        for key in on_args:\n            del kwargs[key]\n\n        self._disabled_count = 0\n\n        super(Widget, self).__init__(**kwargs)\n\n        # Create the default canvas if it does not exist.\n        if self.canvas is None:\n            self.canvas = Canvas(opacity=self.opacity)\n\n        # Apply all the styles.\n        if not no_builder:\n            rule_children = []\n            self.apply_class_lang_rules(\n                ignored_consts=self._kwargs_applied_init,\n                rule_children=rule_children)\n\n            for widget in rule_children:\n                widget.dispatch('on_kv_post', self)\n            self.dispatch('on_kv_post', self)\n\n        # Bind all the events.\n        if on_args:\n            self.bind(**on_args)\n\n    @property\n    def proxy_ref(self):\n        '''Return a proxy reference to the widget, i.e. without creating a\n        reference to the widget. See `weakref.proxy\n        <http://docs.python.org/2/library/weakref.html?highlight\\\n        =proxy#weakref.proxy>`_ for more information.\n\n        .. versionadded:: 1.7.2\n        '''\n        _proxy_ref = self._proxy_ref\n        if _proxy_ref is not None:\n            return _proxy_ref\n\n        f = partial(_widget_destructor, self.uid)\n        self._proxy_ref = _proxy_ref = WeakProxy(self, f)\n        # Only f should be enough here, but it appears that is a very\n        # specific case, the proxy destructor is not called if both f and\n        # _proxy_ref are not together in a tuple.\n        _widget_destructors[self.uid] = (f, _proxy_ref)\n        return _proxy_ref\n\n    def __hash__(self):\n        return id(self)\n\n    def apply_class_lang_rules(\n            self, root=None, ignored_consts=set(), rule_children=None):\n        '''\n        Method that is called by kivy to apply the kv rules of this widget's\n        class.\n\n        :Parameters:\n            `root`: :class:`Widget`\n                The root widget that instantiated this widget in kv, if the\n                widget was instantiated in kv, otherwise ``None``.\n            `ignored_consts`: set\n                (internal) See :meth:`~kivy.lang.builder.BuilderBase.apply`.\n            `rule_children`: list\n                (internal) See :meth:`~kivy.lang.builder.BuilderBase.apply`.\n\n        This is useful to be able to execute code before/after the class kv\n        rules are applied to the widget. E.g. if the kv code requires some\n        properties to be initialized before it is used in a binding rule.\n        If overwriting remember to call ``super``, otherwise the kv rules will\n        not be applied.\n\n        In the following example,\n\n        .. code-block:: python\n\n            class MyWidget(Widget):\n                pass\n\n            class OtherWidget(MyWidget):\n                pass\n\n        .. code-block:: kv\n\n        <MyWidget>:\n            my_prop: some_value\n\n        <OtherWidget>:\n            other_prop: some_value\n\n        When ``OtherWidget`` is instantiated with ``OtherWidget()``, the\n        widget's :meth:`apply_class_lang_rules` is called and it applies the\n        kv rules of this class - ``<MyWidget>`` and ``<OtherWidget>``.\n\n        Similarly, when the widget is instantiated from kv, e.g.\n\n        .. code-block:: kv\n\n            <MyBox@BoxLayout>:\n                height: 55\n                OtherWidget:\n                    width: 124\n\n        ``OtherWidget``'s :meth:`apply_class_lang_rules` is called and it\n        applies the kv rules of this class - ``<MyWidget>`` and\n        ``<OtherWidget>``.\n\n        .. note::\n\n            It applies only the class rules not the instance rules. I.e. in the\n            above kv example in the ``MyBox`` rule when ``OtherWidget`` is\n            instantiated, its :meth:`apply_class_lang_rules` applies the\n            ``<MyWidget>`` and ``<OtherWidget>`` rules to it - it does not\n            apply the ``width: 124`` rule. The ``width: 124`` rule is part of\n            the ``MyBox`` rule and is applied by the ``MyBox``'s instance's\n            :meth:`apply_class_lang_rules`.\n\n        .. versionchanged:: 1.11.0\n        '''\n        Builder.apply(\n            self, ignored_consts=ignored_consts,\n            rule_children=rule_children)\n\n    #\n    # Collision\n    #\n    def collide_point(self, x, y):\n        '''\n        Check if a point (x, y) is inside the widget's axis aligned bounding\n        box.\n\n        :Parameters:\n            `x`: numeric\n                x position of the point (in parent coordinates)\n            `y`: numeric\n                y position of the point (in parent coordinates)\n\n        :Returns:\n            A bool. True if the point is inside the bounding box, False\n            otherwise.\n\n        .. code-block:: python\n\n            >>> Widget(pos=(10, 10), size=(50, 50)).collide_point(40, 40)\n            True\n        '''\n        return self.x <= x <= self.right and self.y <= y <= self.top\n\n    def collide_widget(self, wid):\n        '''\n        Check if another widget collides with this widget. This function\n        performs an axis-aligned bounding box intersection test by default.\n\n        :Parameters:\n            `wid`: :class:`Widget` class\n                Widget to test collision with.\n\n        :Returns:\n            bool. True if the other widget collides with this widget, False\n            otherwise.\n\n        .. code-block:: python\n\n            >>> wid = Widget(size=(50, 50))\n            >>> wid2 = Widget(size=(50, 50), pos=(25, 25))\n            >>> wid.collide_widget(wid2)\n            True\n            >>> wid2.pos = (55, 55)\n            >>> wid.collide_widget(wid2)\n            False\n        '''\n        if self.right < wid.x:\n            return False\n        if self.x > wid.right:\n            return False\n        if self.top < wid.y:\n            return False\n        if self.y > wid.top:\n            return False\n        return True\n\n    def on_motion(self, etype, me):\n        '''Called when a motion event is received.\n\n        :Parameters:\n            `etype`: `str`\n                Event type, one of \"begin\", \"update\" or \"end\"\n            `me`: :class:`~kivy.input.motionevent.MotionEvent`\n                Received motion event\n        :Returns: `bool`\n            `True` to stop event dispatching\n\n        .. versionadded:: 2.1.0\n\n        .. warning::\n            This is an experimental method and it remains so while this warning\n            is present.\n        '''\n        if self.disabled or me.dispatch_mode == MODE_DONT_DISPATCH:\n            return\n        if me.type_id not in self.motion_filter:\n            return\n        filtered = self.motion_filter[me.type_id]\n        if filtered[0] is self and len(filtered) == 1:\n            return\n        if me.dispatch_mode == MODE_DEFAULT_DISPATCH:\n            last_filtered = filtered[-1]\n            for widget in self.children[:]:\n                if widget.dispatch('on_motion', etype, me):\n                    return True\n                if widget is last_filtered:\n                    return\n        if me.dispatch_mode == MODE_FILTERED_DISPATCH:\n            widgets = filtered[1:] if filtered[0] is self else filtered[:]\n            for widget in widgets:\n                if widget.dispatch('on_motion', etype, me):\n                    return True\n\n    #\n    # Default event handlers\n    #\n    def on_touch_down(self, touch):\n        '''Receive a touch down event.\n\n        :Parameters:\n            `touch`: :class:`~kivy.input.motionevent.MotionEvent` class\n                Touch received. The touch is in parent coordinates. See\n                :mod:`~kivy.uix.relativelayout` for a discussion on\n                coordinate systems.\n\n        :Returns: bool\n            If True, the dispatching of the touch event will stop.\n            If False, the event will continue to be dispatched to the rest\n            of the widget tree.\n        '''\n        if self.disabled and self.collide_point(*touch.pos):\n            return True\n        for child in self.children[:]:\n            if child.dispatch('on_touch_down', touch):\n                return True\n\n    def on_touch_move(self, touch):\n        '''Receive a touch move event. The touch is in parent coordinates.\n\n        See :meth:`on_touch_down` for more information.\n        '''\n        if self.disabled:\n            return\n        for child in self.children[:]:\n            if child.dispatch('on_touch_move', touch):\n                return True\n\n    def on_touch_up(self, touch):\n        '''Receive a touch up event. The touch is in parent coordinates.\n\n        See :meth:`on_touch_down` for more information.\n        '''\n        if self.disabled:\n            return\n        for child in self.children[:]:\n            if child.dispatch('on_touch_up', touch):\n                return True\n\n    def on_kv_post(self, base_widget):\n        pass\n\n    #\n    # Tree management\n    #\n    def add_widget(self, widget, index=0, canvas=None):\n        '''Add a new widget as a child of this widget.\n\n        :Parameters:\n            `widget`: :class:`Widget`\n                Widget to add to our list of children.\n            `index`: int, defaults to 0\n                Index to insert the widget in the list. Notice that the default\n                of 0 means the widget is inserted at the beginning of the list\n                and will thus be drawn on top of other sibling widgets. For a\n                full discussion of the index and widget hierarchy, please see\n                the :doc:`Widgets Programming Guide <guide/widgets>`.\n\n                .. versionadded:: 1.0.5\n            `canvas`: str, defaults to None\n                Canvas to add widget's canvas to. Can be 'before', 'after' or\n                None for the default canvas.\n\n                .. versionadded:: 1.9.0\n\n    .. code-block:: python\n\n        >>> from kivy.uix.button import Button\n        >>> from kivy.uix.slider import Slider\n        >>> root = Widget()\n        >>> root.add_widget(Button())\n        >>> slider = Slider()\n        >>> root.add_widget(slider)\n\n        '''\n        if not isinstance(widget, Widget):\n            raise WidgetException(\n                'add_widget() can be used only with instances'\n                ' of the Widget class.')\n\n        widget = widget.__self__\n        if widget is self:\n            raise WidgetException(\n                'Widget instances cannot be added to themselves.')\n        parent = widget.parent\n        # Check if the widget is already a child of another widget.\n        if parent:\n            raise WidgetException('Cannot add %r, it already has a parent %r'\n                                  % (widget, parent))\n        widget.parent = parent = self\n        # Child will be disabled if added to a disabled parent.\n        widget.inc_disabled(self._disabled_count)\n\n        canvas = self.canvas.before if canvas == 'before' else \\\n            self.canvas.after if canvas == 'after' else self.canvas\n\n        if index == 0 or len(self.children) == 0:\n            self.children.insert(0, widget)\n            canvas.add(widget.canvas)\n        else:\n            canvas = self.canvas\n            children = self.children\n            if index >= len(children):\n                index = len(children)\n                next_index = canvas.indexof(children[-1].canvas)\n            else:\n                next_child = children[index]\n                next_index = canvas.indexof(next_child.canvas)\n                if next_index == -1:\n                    next_index = canvas.length()\n                else:\n                    next_index += 1\n\n            children.insert(index, widget)\n            # We never want to insert widget _before_ canvas.before.\n            if next_index == 0 and canvas.has_before:\n                next_index = 1\n            canvas.insert(next_index, widget.canvas)\n        for type_id in widget.motion_filter:\n            self.register_for_motion_event(type_id, widget)\n        widget.fbind('motion_filter', self._update_motion_filter)\n\n    def remove_widget(self, widget):\n        '''Remove a widget from the children of this widget.\n\n        :Parameters:\n            `widget`: :class:`Widget`\n                Widget to remove from our children list.\n\n    .. code-block:: python\n\n        >>> from kivy.uix.button import Button\n        >>> root = Widget()\n        >>> button = Button()\n        >>> root.add_widget(button)\n        >>> root.remove_widget(button)\n        '''\n        if widget not in self.children:\n            return\n        self.children.remove(widget)\n        if widget.canvas in self.canvas.children:\n            self.canvas.remove(widget.canvas)\n        elif widget.canvas in self.canvas.after.children:\n            self.canvas.after.remove(widget.canvas)\n        elif widget.canvas in self.canvas.before.children:\n            self.canvas.before.remove(widget.canvas)\n        for type_id in widget.motion_filter:\n            self.unregister_for_motion_event(type_id, widget)\n        widget.funbind('motion_filter', self._update_motion_filter)\n        widget.parent = None\n        widget.dec_disabled(self._disabled_count)\n\n    def clear_widgets(self, children=None):\n        '''\n        Remove all (or the specified) :attr:`~Widget.children` of this widget.\n        If the 'children' argument is specified, it should be a list (or\n        filtered list) of children of the current widget.\n\n        .. versionchanged:: 1.8.0\n            The `children` argument can be used to specify the children you\n            want to remove.\n        .. versionchanged:: 2.1.0\n\n            Specifying an empty ``children`` list leaves the widgets unchanged.\n            Previously it was treated like ``None`` and all children were\n            removed.\n        '''\n        if children is None or children is self.children:\n            children = self.children[:]\n\n        remove_widget = self.remove_widget\n        for child in children:\n            remove_widget(child)\n\n    def _update_motion_filter(self, child_widget, child_motion_filter):\n        old_events = []\n        for type_id, widgets in self.motion_filter.items():\n            if child_widget in widgets:\n                old_events.append(type_id)\n        for type_id in old_events:\n            if type_id not in child_motion_filter:\n                self.unregister_for_motion_event(type_id, child_widget)\n        for type_id in child_motion_filter:\n            if type_id not in old_events:\n                self.register_for_motion_event(type_id, child_widget)\n\n    def _find_index_in_motion_filter(self, type_id, widget):\n        if widget is self:\n            return 0\n        find_index = self.children.index\n        max_index = find_index(widget) + 1\n        motion_widgets = self.motion_filter[type_id]\n        insert_index = 1 if motion_widgets[0] is self else 0\n        for index in range(insert_index, len(motion_widgets)):\n            if find_index(motion_widgets[index]) < max_index:\n                insert_index += 1\n            else:\n                break\n        return insert_index\n\n    def register_for_motion_event(self, type_id, widget=None):\n        '''Register to receive motion events of `type_id`.\n\n        Override :meth:`on_motion` or bind to `on_motion` event to handle\n        the incoming motion events.\n\n        :Parameters:\n            `type_id`: `str`\n                Motion event type id (eg. \"touch\", \"hover\", etc.)\n            `widget`: `Widget`\n                Child widget or `self` if omitted\n\n        .. versionadded:: 2.1.0\n\n        .. note::\n            Method can be called multiple times with the same arguments.\n\n        .. warning::\n            This is an experimental method and it remains so while this warning\n            is present.\n        '''\n        a_widget = widget or self\n        motion_filter = self.motion_filter\n        if type_id not in motion_filter:\n            motion_filter[type_id] = [a_widget]\n        elif widget not in motion_filter[type_id]:\n            index = self._find_index_in_motion_filter(type_id, a_widget)\n            motion_filter[type_id].insert(index, a_widget)\n\n    def unregister_for_motion_event(self, type_id, widget=None):\n        '''Unregister to receive motion events of `type_id`.\n\n        :Parameters:\n            `type_id`: `str`\n                Motion event type id (eg. \"touch\", \"hover\", etc.)\n            `widget`: `Widget`\n                Child widget or `self` if omitted\n\n        .. versionadded:: 2.1.0\n\n        .. note::\n            Method can be called multiple times with the same arguments.\n\n        .. warning::\n            This is an experimental method and it remains so while this warning\n            is present.\n        '''\n        a_widget = widget or self\n        motion_filter = self.motion_filter\n        if type_id in motion_filter:\n            if a_widget in motion_filter[type_id]:\n                motion_filter[type_id].remove(a_widget)\n                if not motion_filter[type_id]:\n                    del motion_filter[type_id]\n\n    def export_to_png(self, filename, *args, **kwargs):\n        '''Saves an image of the widget and its children in png format at the\n        specified filename. Works by removing the widget canvas from its\n        parent, rendering to an :class:`~kivy.graphics.fbo.Fbo`, and calling\n        :meth:`~kivy.graphics.texture.Texture.save`.\n\n        .. note::\n\n            The image includes only this widget and its children. If you want\n            to include widgets elsewhere in the tree, you must call\n            :meth:`~Widget.export_to_png` from their common parent, or use\n            :meth:`~kivy.core.window.WindowBase.screenshot` to capture the\n            whole window.\n\n        .. note::\n\n            The image will be saved in png format, you should include the\n            extension in your filename.\n\n        .. versionadded:: 1.9.0\n\n        :Parameters:\n            `filename`: str\n                The filename with which to save the png.\n            `scale`: float\n                The amount by which to scale the saved image, defaults to 1.\n\n                .. versionadded:: 1.11.0\n        '''\n        self.export_as_image(*args, **kwargs).save(filename, flipped=False)\n\n    def export_as_image(self, *args, **kwargs):\n        '''Return an core :class:`~kivy.core.image.Image` of the actual\n        widget.\n\n        .. versionadded:: 1.11.0\n        '''\n        from kivy.core.image import Image\n        scale = kwargs.get('scale', 1)\n\n        if self.parent is not None:\n            canvas_parent_index = self.parent.canvas.indexof(self.canvas)\n            if canvas_parent_index > -1:\n                self.parent.canvas.remove(self.canvas)\n\n        fbo = Fbo(size=(self.width * scale, self.height * scale),\n                  with_stencilbuffer=True)\n\n        with fbo:\n            ClearColor(0, 0, 0, 0)\n            ClearBuffers()\n            Scale(1, -1, 1)\n            Scale(scale, scale, 1)\n            Translate(-self.x, -self.y - self.height, 0)\n\n        fbo.add(self.canvas)\n        fbo.draw()\n        img = Image(fbo.texture)\n        fbo.remove(self.canvas)\n\n        if self.parent is not None and canvas_parent_index > -1:\n            self.parent.canvas.insert(canvas_parent_index, self.canvas)\n\n        return img\n\n    def get_root_window(self):\n        '''Return the root window.\n\n        :Returns:\n            Instance of the root window. Can be a\n            :class:`~kivy.core.window.WindowBase` or\n            :class:`Widget`.\n        '''\n        if self.parent:\n            return self.parent.get_root_window()\n\n    def get_parent_window(self):\n        '''Return the parent window.\n\n        :Returns:\n            Instance of the parent window. Can be a\n            :class:`~kivy.core.window.WindowBase` or\n            :class:`Widget`.\n        '''\n        if self.parent:\n            return self.parent.get_parent_window()\n\n    def _walk(self, restrict=False, loopback=False, index=None):\n        # We pass index only when we are going on the parent\n        # so don't yield the parent as well.\n        if index is None:\n            index = len(self.children)\n            yield self\n\n        for child in reversed(self.children[:index]):\n            for walk_child in child._walk(restrict=True):\n                yield walk_child\n\n        # If we want to continue with our parent, just do it.\n        if not restrict:\n            parent = self.parent\n            try:\n                if parent is None or not isinstance(parent, Widget):\n                    raise ValueError\n                index = parent.children.index(self)\n            except ValueError:\n                # Self is root, if we want to loopback from the first element:\n                if not loopback:\n                    return\n                # If we started with root (i.e. index==None), then we have to\n                # start from root again, so we return self again. Otherwise, we\n                # never returned it, so return it now starting with it.\n                parent = self\n                index = None\n            for walk_child in parent._walk(loopback=loopback, index=index):\n                yield walk_child\n\n    def walk(self, restrict=False, loopback=False):\n        ''' Iterator that walks the widget tree starting with this widget and\n        goes forward returning widgets in the order in which layouts display\n        them.\n\n        :Parameters:\n            `restrict`: bool, defaults to False\n                If True, it will only iterate through the widget and its\n                children (or children of its children etc.). Defaults to False.\n            `loopback`: bool, defaults to False\n                If True, when the last widget in the tree is reached,\n                it'll loop back to the uppermost root and start walking until\n                we hit this widget again. Naturally, it can only loop back when\n                `restrict` is False. Defaults to False.\n\n        :return:\n            A generator that walks the tree, returning widgets in the\n            forward layout order.\n\n        For example, given a tree with the following structure:\n\n        .. code-block:: kv\n\n            GridLayout:\n                Button\n                BoxLayout:\n                    id: box\n                    Widget\n                    Button\n                Widget\n\n        walking this tree:\n\n        .. code-block:: python\n\n            >>> # Call walk on box with loopback True, and restrict False\n            >>> [type(widget) for widget in box.walk(loopback=True)]\n            [<class 'BoxLayout'>, <class 'Widget'>, <class 'Button'>,\n                <class 'Widget'>, <class 'GridLayout'>, <class 'Button'>]\n            >>> # Now with loopback False, and restrict False\n            >>> [type(widget) for widget in box.walk()]\n            [<class 'BoxLayout'>, <class 'Widget'>, <class 'Button'>,\n                <class 'Widget'>]\n            >>> # Now with restrict True\n            >>> [type(widget) for widget in box.walk(restrict=True)]\n            [<class 'BoxLayout'>, <class 'Widget'>, <class 'Button'>]\n\n        .. versionadded:: 1.9.0\n        '''\n        gen = self._walk(restrict, loopback)\n        yield next(gen)\n        for node in gen:\n            if node is self:\n                return\n            yield node\n\n    def _walk_reverse(self, loopback=False, go_up=False):\n        # process is walk up level, walk down its children tree, then walk up\n        # next level etc.\n        # default just walk down the children tree\n        root = self\n        index = 0\n        # we need to go up a level before walking tree\n        if go_up:\n            root = self.parent\n            try:\n                if root is None or not isinstance(root, Widget):\n                    raise ValueError\n                index = root.children.index(self) + 1\n            except ValueError:\n                if not loopback:\n                    return\n                index = 0\n                go_up = False\n                root = self\n\n        # now walk children tree starting with last-most child\n        for child in islice(root.children, index, None):\n            for walk_child in child._walk_reverse(loopback=loopback):\n                yield walk_child\n        # we need to return ourself last, in all cases\n        yield root\n\n        # if going up, continue walking up the parent tree\n        if go_up:\n            for walk_child in root._walk_reverse(loopback=loopback,\n                                                 go_up=go_up):\n                yield walk_child\n\n    def walk_reverse(self, loopback=False):\n        ''' Iterator that walks the widget tree backwards starting with the\n        widget before this, and going backwards returning widgets in the\n        reverse order in which layouts display them.\n\n        This walks in the opposite direction of :meth:`walk`, so a list of the\n        tree generated with :meth:`walk` will be in reverse order compared\n        to the list generated with this, provided `loopback` is True.\n\n        :Parameters:\n            `loopback`: bool, defaults to False\n                If True, when the uppermost root in the tree is\n                reached, it'll loop back to the last widget and start walking\n                back until after we hit widget again. Defaults to False.\n\n        :return:\n            A generator that walks the tree, returning widgets in the\n            reverse layout order.\n\n        For example, given a tree with the following structure:\n\n        .. code-block:: kv\n\n            GridLayout:\n                Button\n                BoxLayout:\n                    id: box\n                    Widget\n                    Button\n                Widget\n\n        walking this tree:\n\n        .. code-block:: python\n\n            >>> # Call walk on box with loopback True\n            >>> [type(widget) for widget in box.walk_reverse(loopback=True)]\n            [<class 'Button'>, <class 'GridLayout'>, <class 'Widget'>,\n                <class 'Button'>, <class 'Widget'>, <class 'BoxLayout'>]\n            >>> # Now with loopback False\n            >>> [type(widget) for widget in box.walk_reverse()]\n            [<class 'Button'>, <class 'GridLayout'>]\n            >>> forward = [w for w in box.walk(loopback=True)]\n            >>> backward = [w for w in box.walk_reverse(loopback=True)]\n            >>> forward == backward[::-1]\n            True\n\n        .. versionadded:: 1.9.0\n\n        '''\n        for node in self._walk_reverse(loopback=loopback, go_up=True):\n            yield node\n            if node is self:\n                return\n\n    def to_widget(self, x, y, relative=False):\n        '''Convert the coordinate from window to local (current widget)\n        coordinates.\n\n        See :mod:`~kivy.uix.relativelayout` for details on the coordinate\n        systems.\n        '''\n        if self.parent:\n            x, y = self.parent.to_widget(x, y)\n        return self.to_local(x, y, relative=relative)\n\n    def to_window(self, x, y, initial=True, relative=False):\n        \"\"\"If ``initial`` is True, the default, it transforms **parent**\n        coordinates to window coordinates. Otherwise, it transforms **local**\n        (current widget) coordinates to window coordinates.\n\n        See :mod:`~kivy.uix.relativelayout` for details on the coordinate\n        systems.\n        \"\"\"\n        if not initial:\n            x, y = self.to_parent(x, y, relative=relative)\n        if self.parent:\n            return self.parent.to_window(x, y, initial=False,\n                                         relative=relative)\n        return (x, y)\n\n    def to_parent(self, x, y, relative=False):\n        \"\"\"Transform local (current widget) coordinates to parent coordinates.\n\n        See :mod:`~kivy.uix.relativelayout` for details on the coordinate\n        systems.\n\n        :Parameters:\n            `relative`: bool, defaults to False\n                Change to True if you want to translate relative positions from\n                a widget to its parent coordinates.\n        \"\"\"\n        if relative:\n            return (x + self.x, y + self.y)\n        return (x, y)\n\n    def to_local(self, x, y, relative=False):\n        \"\"\"Transform parent coordinates to local (current widget) coordinates.\n\n        See :mod:`~kivy.uix.relativelayout` for details on the coordinate\n        systems.\n\n        :Parameters:\n            `relative`: bool, defaults to False\n                Change to True if you want to translate coordinates to\n                relative widget coordinates.\n        \"\"\"\n        if relative:\n            return (x - self.x, y - self.y)\n        return (x, y)\n\n    def _apply_transform(self, m, pos=None):\n        if self.parent:\n            x, y = self.parent.to_widget(relative=True,\n                                         *self.to_window(*(pos or self.pos)))\n            m.translate(x, y, 0)\n            m = self.parent._apply_transform(m) if self.parent else m\n        return m\n\n    def get_window_matrix(self, x=0, y=0):\n        '''Calculate the transformation matrix to convert between window and\n        widget coordinates.\n\n        :Parameters:\n            `x`: float, defaults to 0\n                Translates the matrix on the x axis.\n            `y`: float, defaults to 0\n                Translates the matrix on the y axis.\n        '''\n        m = Matrix()\n        m.translate(x, y, 0)\n        m = self._apply_transform(m)\n        return m\n\n    x = NumericProperty(0)\n    '''X position of the widget.\n\n    :attr:`x` is a :class:`~kivy.properties.NumericProperty` and defaults to 0.\n    '''\n\n    y = NumericProperty(0)\n    '''Y position of the widget.\n\n    :attr:`y` is a :class:`~kivy.properties.NumericProperty` and defaults to 0.\n    '''\n\n    width = NumericProperty(100)\n    '''Width of the widget.\n\n    :attr:`width` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 100.\n\n    .. warning::\n        Keep in mind that the `width` property is subject to layout logic and\n        that this has not yet happened at the time of the widget's `__init__`\n        method.\n\n    .. warning::\n        A negative width is not supported.\n    '''\n\n    height = NumericProperty(100)\n    '''Height of the widget.\n\n    :attr:`height` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 100.\n\n    .. warning::\n        Keep in mind that the `height` property is subject to layout logic and\n        that this has not yet happened at the time of the widget's `__init__`\n        method.\n\n    .. warning::\n        A negative height is not supported.\n    '''\n\n    pos = ReferenceListProperty(x, y)\n    '''Position of the widget.\n\n    :attr:`pos` is a :class:`~kivy.properties.ReferenceListProperty` of\n    (:attr:`x`, :attr:`y`) properties.\n    '''\n\n    size = ReferenceListProperty(width, height)\n    '''Size of the widget.\n\n    :attr:`size` is a :class:`~kivy.properties.ReferenceListProperty` of\n    (:attr:`width`, :attr:`height`) properties.\n    '''\n\n    def get_right(self):\n        return self.x + self.width\n\n    def set_right(self, value):\n        self.x = value - self.width\n\n    right = AliasProperty(get_right, set_right,\n                          bind=('x', 'width'),\n                          cache=True, watch_before_use=False)\n    '''Right position of the widget.\n\n    :attr:`right` is an :class:`~kivy.properties.AliasProperty` of\n    (:attr:`x` + :attr:`width`).\n    '''\n\n    def get_top(self):\n        return self.y + self.height\n\n    def set_top(self, value):\n        self.y = value - self.height\n\n    top = AliasProperty(get_top, set_top,\n                        bind=('y', 'height'),\n                        cache=True, watch_before_use=False)\n    '''Top position of the widget.\n\n    :attr:`top` is an :class:`~kivy.properties.AliasProperty` of\n    (:attr:`y` + :attr:`height`).\n    '''\n\n    def get_center_x(self):\n        return self.x + self.width / 2.\n\n    def set_center_x(self, value):\n        self.x = value - self.width / 2.\n\n    center_x = AliasProperty(get_center_x, set_center_x,\n                             bind=('x', 'width'),\n                             cache=True, watch_before_use=False)\n    '''X center position of the widget.\n\n    :attr:`center_x` is an :class:`~kivy.properties.AliasProperty` of\n    (:attr:`x` + :attr:`width` / 2.).\n    '''\n\n    def get_center_y(self):\n        return self.y + self.height / 2.\n\n    def set_center_y(self, value):\n        self.y = value - self.height / 2.\n\n    center_y = AliasProperty(get_center_y, set_center_y,\n                             bind=('y', 'height'),\n                             cache=True, watch_before_use=False)\n    '''Y center position of the widget.\n\n    :attr:`center_y` is an :class:`~kivy.properties.AliasProperty` of\n    (:attr:`y` + :attr:`height` / 2.).\n    '''\n\n    center = ReferenceListProperty(center_x, center_y)\n    '''Center position of the widget.\n\n    :attr:`center` is a :class:`~kivy.properties.ReferenceListProperty` of\n    (:attr:`center_x`, :attr:`center_y`) properties.\n    '''\n\n    cls = ListProperty([])\n    '''Class of the widget, used for styling.\n    '''\n\n    children = ListProperty([])\n    '''List of children of this widget.\n\n    :attr:`children` is a :class:`~kivy.properties.ListProperty` and\n    defaults to an empty list.\n\n    Use :meth:`add_widget` and :meth:`remove_widget` for manipulating the\n    children list. Don't manipulate the children list directly unless you know\n    what you are doing.\n    '''\n\n    parent = ObjectProperty(None, allownone=True, rebind=True)\n    '''Parent of this widget. The parent of a widget is set when the widget\n    is added to another widget and unset when the widget is removed from its\n    parent.\n\n    :attr:`parent` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    size_hint_x = NumericProperty(1, allownone=True)\n    '''x size hint. Represents how much space the widget should use in the\n    direction of the x axis relative to its parent's width.\n    Only the :class:`~kivy.uix.layout.Layout` and\n    :class:`~kivy.core.window.Window` classes make use of the hint.\n\n    The size_hint is used by layouts for two purposes:\n\n    - When the layout considers widgets on their own rather than in\n      relation to its other children, the size_hint_x is a direct proportion\n      of the parent width, normally between 0.0 and 1.0. For instance, a\n      widget with ``size_hint_x=0.5`` in\n      a vertical BoxLayout will take up half the BoxLayout's width, or\n      a widget in a FloatLayout with ``size_hint_x=0.2`` will take up 20%\n      of the FloatLayout width. If the size_hint is greater than 1, the\n      widget will be wider than the parent.\n    - When multiple widgets can share a row of a layout, such as in a\n      horizontal BoxLayout, their widths will be their size_hint_x as a\n      fraction of the sum of widget size_hints. For instance, if the\n      size_hint_xs are (0.5, 1.0, 0.5), the first widget will have a\n      width of 25% of the parent width.\n\n    :attr:`size_hint_x` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 1.\n    '''\n\n    size_hint_y = NumericProperty(1, allownone=True)\n    '''y size hint.\n\n    :attr:`size_hint_y` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 1.\n\n    See :attr:`size_hint_x` for more information, but with widths and heights\n    swapped.\n    '''\n\n    size_hint = ReferenceListProperty(size_hint_x, size_hint_y)\n    '''Size hint.\n\n    :attr:`size_hint` is a :class:`~kivy.properties.ReferenceListProperty` of\n    (:attr:`size_hint_x`, :attr:`size_hint_y`) properties.\n\n    See :attr:`size_hint_x` for more information.\n    '''\n\n    pos_hint = ObjectProperty({})\n    '''Position hint. This property allows you to set the position of\n    the widget inside its parent layout (similar to\n    size_hint).\n\n    For example, if you want to set the top of the widget to be at 90%\n    height of its parent layout, you can write::\n\n        widget = Widget(pos_hint={'top': 0.9})\n\n    The keys 'x', 'right' and 'center_x' will use the parent width.\n    The keys 'y', 'top' and 'center_y' will use the parent height.\n\n    See :doc:`api-kivy.uix.floatlayout` for further reference.\n\n    .. note::\n        :attr:`pos_hint` is not used by all layouts. Check the documentation\n        of the layout in question to see if it supports pos_hint.\n\n    :attr:`pos_hint` is an :class:`~kivy.properties.ObjectProperty`\n    containing a dict.\n    '''\n\n    size_hint_min_x = NumericProperty(None, allownone=True)\n    '''When not None, the x-direction minimum size (in pixels,\n    like :attr:`width`) when :attr:`size_hint_x` is also not None.\n\n    When :attr:`size_hint_x` is not None, it is the minimum width that the\n    widget will be set due to the :attr:`size_hint_x`. I.e. when a smaller size\n    would be set, :attr:`size_hint_min_x` is the value used instead for the\n    widget width. When None, or when :attr:`size_hint_x` is None,\n    :attr:`size_hint_min_x` doesn't do anything.\n\n    Only the :class:`~kivy.uix.layout.Layout` and\n    :class:`~kivy.core.window.Window` classes make use of the hint.\n\n    :attr:`size_hint_min_x` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to None.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    size_hint_min_y = NumericProperty(None, allownone=True)\n    '''When not None, the y-direction minimum size (in pixels,\n    like :attr:`height`) when :attr:`size_hint_y` is also not None.\n\n    When :attr:`size_hint_y` is not None, it is the minimum height that the\n    widget will be set due to the :attr:`size_hint_y`. I.e. when a smaller size\n    would be set, :attr:`size_hint_min_y` is the value used instead for the\n    widget height. When None, or when :attr:`size_hint_y` is None,\n    :attr:`size_hint_min_y` doesn't do anything.\n\n    Only the :class:`~kivy.uix.layout.Layout` and\n    :class:`~kivy.core.window.Window` classes make use of the hint.\n\n    :attr:`size_hint_min_y` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to None.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    size_hint_min = ReferenceListProperty(size_hint_min_x, size_hint_min_y)\n    '''Minimum size when using :attr:`size_hint`.\n\n    :attr:`size_hint_min` is a :class:`~kivy.properties.ReferenceListProperty`\n    of (:attr:`size_hint_min_x`, :attr:`size_hint_min_y`) properties.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    size_hint_max_x = NumericProperty(None, allownone=True)\n    '''When not None, the x-direction maximum size (in pixels,\n    like :attr:`width`) when :attr:`size_hint_x` is also not None.\n\n    Similar to :attr:`size_hint_min_x`, except that it sets the maximum width.\n\n    :attr:`size_hint_max_x` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to None.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    size_hint_max_y = NumericProperty(None, allownone=True)\n    '''When not None, the y-direction maximum size (in pixels,\n    like :attr:`height`) when :attr:`size_hint_y` is also not None.\n\n    Similar to :attr:`size_hint_min_y`, except that it sets the maximum height.\n\n    :attr:`size_hint_max_y` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to None.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    size_hint_max = ReferenceListProperty(size_hint_max_x, size_hint_max_y)\n    '''Maximum size when using :attr:`size_hint`.\n\n    :attr:`size_hint_max` is a :class:`~kivy.properties.ReferenceListProperty`\n    of (:attr:`size_hint_max_x`, :attr:`size_hint_max_y`) properties.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    ids = DictProperty({})\n    '''This is a dictionary of ids defined in your kv language. This will only\n    be populated if you use ids in your kv language code.\n\n    .. versionadded:: 1.7.0\n\n    :attr:`ids` is a :class:`~kivy.properties.DictProperty` and defaults to an\n    empty dict {}.\n\n    The :attr:`ids` are populated for each root level widget definition. For\n    example:\n\n    .. code-block:: kv\n\n        # in kv\n        <MyWidget@Widget>:\n            id: my_widget\n            Label:\n                id: label_widget\n                Widget:\n                    id: inner_widget\n                    Label:\n                        id: inner_label\n            TextInput:\n                id: text_input\n            OtherWidget:\n                id: other_widget\n\n\n        <OtherWidget@Widget>\n            id: other_widget\n            Label:\n                id: other_label\n                TextInput:\n                    id: other_textinput\n\n    Then, in python:\n\n    .. code-block:: python\n\n        >>> widget = MyWidget()\n        >>> print(widget.ids)\n        {'other_widget': <weakproxy at 041CFED0 to OtherWidget at 041BEC38>,\n        'inner_widget': <weakproxy at 04137EA0 to Widget at 04138228>,\n        'inner_label': <weakproxy at 04143540 to Label at 04138260>,\n        'label_widget': <weakproxy at 04137B70 to Label at 040F97A0>,\n        'text_input': <weakproxy at 041BB5D0 to TextInput at 041BEC00>}\n        >>> print(widget.ids['other_widget'].ids)\n        {'other_textinput': <weakproxy at 041DBB40 to TextInput at 041BEF48>,\n        'other_label': <weakproxy at 041DB570 to Label at 041BEEA0>}\n        >>> print(widget.ids['label_widget'].ids)\n        {}\n    '''\n\n    opacity = NumericProperty(1.0)\n    '''Opacity of the widget and all its children.\n\n    .. versionadded:: 1.4.1\n\n    The opacity attribute controls the opacity of the widget and its children.\n    Be careful, it's a cumulative attribute: the value is multiplied by the\n    current global opacity and the result is applied to the current context\n    color.\n\n    For example, if the parent has an opacity of 0.5 and a child has an\n    opacity of 0.2, the real opacity of the child will be 0.5 * 0.2 = 0.1.\n\n    Then, the opacity is applied by the shader as:\n\n    .. code-block:: python\n\n        frag_color = color * vec4(1.0, 1.0, 1.0, opacity);\n\n    :attr:`opacity` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 1.0.\n    '''\n\n    def on_opacity(self, instance, value):\n        canvas = self.canvas\n        if canvas is not None:\n            canvas.opacity = value\n\n    canvas = None\n    '''Canvas of the widget.\n\n    The canvas is a graphics object that contains all the drawing instructions\n    for the graphical representation of the widget.\n\n    There are no general properties for the Widget class, such as background\n    color, to keep the design simple and lean. Some derived classes, such as\n    Button, do add such convenience properties but generally the developer is\n    responsible for implementing the graphics representation for a custom\n    widget from the ground up. See the derived widget classes for patterns to\n    follow and extend.\n\n    See :class:`~kivy.graphics.Canvas` for more information about the usage.\n    '''\n\n    def get_disabled(self):\n        return self._disabled_count > 0\n\n    def set_disabled(self, value):\n        # Necessary to ensure a change between value of equal truthiness\n        # doesn't mess up the count\n        value = bool(value)\n        if value != self._disabled_value:\n            self._disabled_value = value\n            if value:\n                self.inc_disabled()\n            else:\n                self.dec_disabled()\n            return True\n\n    def inc_disabled(self, count=1):\n        self._disabled_count += count\n        if self._disabled_count - count < 1 <= self._disabled_count:\n            self.property('disabled').dispatch(self)\n        for c in self.children:\n            c.inc_disabled(count)\n\n    def dec_disabled(self, count=1):\n        self._disabled_count -= count\n        if self._disabled_count <= 0 < self._disabled_count + count:\n            self.property('disabled').dispatch(self)\n        for c in self.children:\n            c.dec_disabled(count)\n\n    disabled = AliasProperty(get_disabled, set_disabled, watch_before_use=False)\n    '''Indicates whether this widget can interact with input or not.\n\n    :attr:`disabled` is an :class:`~kivy.properties.AliasProperty` and\n    defaults to False.\n\n    .. note::\n\n      1. Child Widgets, when added to a disabled widget, will be disabled\n         automatically.\n      2. Disabling/enabling a parent disables/enables all\n         of its children.\n\n    .. versionadded:: 1.8.0\n\n    .. versionchanged:: 1.10.1\n\n        :attr:`disabled` was changed from a\n        :class:`~kivy.properties.BooleanProperty` to an\n        :class:`~kivy.properties.AliasProperty` to allow access to its\n        previous state when a parent's disabled state is changed.\n    '''\n\n    motion_filter = DictProperty()\n    '''Holds a dict of `type_id` to `list` of child widgets registered to\n    receive motion events of `type_id`.\n\n    Don't change the property directly but use\n    :meth:`register_for_motion_event` and :meth:`unregister_for_motion_event`\n    to register and unregister for motion events. If `self` is registered it\n    will always be the first element in the list.\n\n    .. versionadded:: 2.1.0\n\n    .. warning::\n        This is an experimental property and it remains so while this warning\n        is present.\n    '''",
  "def __init__(mcs, name, bases, attrs):\n        super(WidgetMetaclass, mcs).__init__(name, bases, attrs)\n        Factory.register(name, cls=mcs)",
  "def __init__(self, **kwargs):\n        # Before doing anything, ensure the windows exist.\n        EventLoop.ensure_window()\n\n        # Assign the default context of the widget creation.\n        if not hasattr(self, '_context'):\n            self._context = get_current_context()\n\n        no_builder = '__no_builder' in kwargs\n        self._disabled_value = False\n        if no_builder:\n            del kwargs['__no_builder']\n        on_args = {k: v for k, v in kwargs.items() if k[:3] == 'on_'}\n        for key in on_args:\n            del kwargs[key]\n\n        self._disabled_count = 0\n\n        super(Widget, self).__init__(**kwargs)\n\n        # Create the default canvas if it does not exist.\n        if self.canvas is None:\n            self.canvas = Canvas(opacity=self.opacity)\n\n        # Apply all the styles.\n        if not no_builder:\n            rule_children = []\n            self.apply_class_lang_rules(\n                ignored_consts=self._kwargs_applied_init,\n                rule_children=rule_children)\n\n            for widget in rule_children:\n                widget.dispatch('on_kv_post', self)\n            self.dispatch('on_kv_post', self)\n\n        # Bind all the events.\n        if on_args:\n            self.bind(**on_args)",
  "def proxy_ref(self):\n        '''Return a proxy reference to the widget, i.e. without creating a\n        reference to the widget. See `weakref.proxy\n        <http://docs.python.org/2/library/weakref.html?highlight\\\n        =proxy#weakref.proxy>`_ for more information.\n\n        .. versionadded:: 1.7.2\n        '''\n        _proxy_ref = self._proxy_ref\n        if _proxy_ref is not None:\n            return _proxy_ref\n\n        f = partial(_widget_destructor, self.uid)\n        self._proxy_ref = _proxy_ref = WeakProxy(self, f)\n        # Only f should be enough here, but it appears that is a very\n        # specific case, the proxy destructor is not called if both f and\n        # _proxy_ref are not together in a tuple.\n        _widget_destructors[self.uid] = (f, _proxy_ref)\n        return _proxy_ref",
  "def __hash__(self):\n        return id(self)",
  "def apply_class_lang_rules(\n            self, root=None, ignored_consts=set(), rule_children=None):\n        '''\n        Method that is called by kivy to apply the kv rules of this widget's\n        class.\n\n        :Parameters:\n            `root`: :class:`Widget`\n                The root widget that instantiated this widget in kv, if the\n                widget was instantiated in kv, otherwise ``None``.\n            `ignored_consts`: set\n                (internal) See :meth:`~kivy.lang.builder.BuilderBase.apply`.\n            `rule_children`: list\n                (internal) See :meth:`~kivy.lang.builder.BuilderBase.apply`.\n\n        This is useful to be able to execute code before/after the class kv\n        rules are applied to the widget. E.g. if the kv code requires some\n        properties to be initialized before it is used in a binding rule.\n        If overwriting remember to call ``super``, otherwise the kv rules will\n        not be applied.\n\n        In the following example,\n\n        .. code-block:: python\n\n            class MyWidget(Widget):\n                pass\n\n            class OtherWidget(MyWidget):\n                pass\n\n        .. code-block:: kv\n\n        <MyWidget>:\n            my_prop: some_value\n\n        <OtherWidget>:\n            other_prop: some_value\n\n        When ``OtherWidget`` is instantiated with ``OtherWidget()``, the\n        widget's :meth:`apply_class_lang_rules` is called and it applies the\n        kv rules of this class - ``<MyWidget>`` and ``<OtherWidget>``.\n\n        Similarly, when the widget is instantiated from kv, e.g.\n\n        .. code-block:: kv\n\n            <MyBox@BoxLayout>:\n                height: 55\n                OtherWidget:\n                    width: 124\n\n        ``OtherWidget``'s :meth:`apply_class_lang_rules` is called and it\n        applies the kv rules of this class - ``<MyWidget>`` and\n        ``<OtherWidget>``.\n\n        .. note::\n\n            It applies only the class rules not the instance rules. I.e. in the\n            above kv example in the ``MyBox`` rule when ``OtherWidget`` is\n            instantiated, its :meth:`apply_class_lang_rules` applies the\n            ``<MyWidget>`` and ``<OtherWidget>`` rules to it - it does not\n            apply the ``width: 124`` rule. The ``width: 124`` rule is part of\n            the ``MyBox`` rule and is applied by the ``MyBox``'s instance's\n            :meth:`apply_class_lang_rules`.\n\n        .. versionchanged:: 1.11.0\n        '''\n        Builder.apply(\n            self, ignored_consts=ignored_consts,\n            rule_children=rule_children)",
  "def collide_point(self, x, y):\n        '''\n        Check if a point (x, y) is inside the widget's axis aligned bounding\n        box.\n\n        :Parameters:\n            `x`: numeric\n                x position of the point (in parent coordinates)\n            `y`: numeric\n                y position of the point (in parent coordinates)\n\n        :Returns:\n            A bool. True if the point is inside the bounding box, False\n            otherwise.\n\n        .. code-block:: python\n\n            >>> Widget(pos=(10, 10), size=(50, 50)).collide_point(40, 40)\n            True\n        '''\n        return self.x <= x <= self.right and self.y <= y <= self.top",
  "def collide_widget(self, wid):\n        '''\n        Check if another widget collides with this widget. This function\n        performs an axis-aligned bounding box intersection test by default.\n\n        :Parameters:\n            `wid`: :class:`Widget` class\n                Widget to test collision with.\n\n        :Returns:\n            bool. True if the other widget collides with this widget, False\n            otherwise.\n\n        .. code-block:: python\n\n            >>> wid = Widget(size=(50, 50))\n            >>> wid2 = Widget(size=(50, 50), pos=(25, 25))\n            >>> wid.collide_widget(wid2)\n            True\n            >>> wid2.pos = (55, 55)\n            >>> wid.collide_widget(wid2)\n            False\n        '''\n        if self.right < wid.x:\n            return False\n        if self.x > wid.right:\n            return False\n        if self.top < wid.y:\n            return False\n        if self.y > wid.top:\n            return False\n        return True",
  "def on_motion(self, etype, me):\n        '''Called when a motion event is received.\n\n        :Parameters:\n            `etype`: `str`\n                Event type, one of \"begin\", \"update\" or \"end\"\n            `me`: :class:`~kivy.input.motionevent.MotionEvent`\n                Received motion event\n        :Returns: `bool`\n            `True` to stop event dispatching\n\n        .. versionadded:: 2.1.0\n\n        .. warning::\n            This is an experimental method and it remains so while this warning\n            is present.\n        '''\n        if self.disabled or me.dispatch_mode == MODE_DONT_DISPATCH:\n            return\n        if me.type_id not in self.motion_filter:\n            return\n        filtered = self.motion_filter[me.type_id]\n        if filtered[0] is self and len(filtered) == 1:\n            return\n        if me.dispatch_mode == MODE_DEFAULT_DISPATCH:\n            last_filtered = filtered[-1]\n            for widget in self.children[:]:\n                if widget.dispatch('on_motion', etype, me):\n                    return True\n                if widget is last_filtered:\n                    return\n        if me.dispatch_mode == MODE_FILTERED_DISPATCH:\n            widgets = filtered[1:] if filtered[0] is self else filtered[:]\n            for widget in widgets:\n                if widget.dispatch('on_motion', etype, me):\n                    return True",
  "def on_touch_down(self, touch):\n        '''Receive a touch down event.\n\n        :Parameters:\n            `touch`: :class:`~kivy.input.motionevent.MotionEvent` class\n                Touch received. The touch is in parent coordinates. See\n                :mod:`~kivy.uix.relativelayout` for a discussion on\n                coordinate systems.\n\n        :Returns: bool\n            If True, the dispatching of the touch event will stop.\n            If False, the event will continue to be dispatched to the rest\n            of the widget tree.\n        '''\n        if self.disabled and self.collide_point(*touch.pos):\n            return True\n        for child in self.children[:]:\n            if child.dispatch('on_touch_down', touch):\n                return True",
  "def on_touch_move(self, touch):\n        '''Receive a touch move event. The touch is in parent coordinates.\n\n        See :meth:`on_touch_down` for more information.\n        '''\n        if self.disabled:\n            return\n        for child in self.children[:]:\n            if child.dispatch('on_touch_move', touch):\n                return True",
  "def on_touch_up(self, touch):\n        '''Receive a touch up event. The touch is in parent coordinates.\n\n        See :meth:`on_touch_down` for more information.\n        '''\n        if self.disabled:\n            return\n        for child in self.children[:]:\n            if child.dispatch('on_touch_up', touch):\n                return True",
  "def on_kv_post(self, base_widget):\n        pass",
  "def add_widget(self, widget, index=0, canvas=None):\n        '''Add a new widget as a child of this widget.\n\n        :Parameters:\n            `widget`: :class:`Widget`\n                Widget to add to our list of children.\n            `index`: int, defaults to 0\n                Index to insert the widget in the list. Notice that the default\n                of 0 means the widget is inserted at the beginning of the list\n                and will thus be drawn on top of other sibling widgets. For a\n                full discussion of the index and widget hierarchy, please see\n                the :doc:`Widgets Programming Guide <guide/widgets>`.\n\n                .. versionadded:: 1.0.5\n            `canvas`: str, defaults to None\n                Canvas to add widget's canvas to. Can be 'before', 'after' or\n                None for the default canvas.\n\n                .. versionadded:: 1.9.0\n\n    .. code-block:: python\n\n        >>> from kivy.uix.button import Button\n        >>> from kivy.uix.slider import Slider\n        >>> root = Widget()\n        >>> root.add_widget(Button())\n        >>> slider = Slider()\n        >>> root.add_widget(slider)\n\n        '''\n        if not isinstance(widget, Widget):\n            raise WidgetException(\n                'add_widget() can be used only with instances'\n                ' of the Widget class.')\n\n        widget = widget.__self__\n        if widget is self:\n            raise WidgetException(\n                'Widget instances cannot be added to themselves.')\n        parent = widget.parent\n        # Check if the widget is already a child of another widget.\n        if parent:\n            raise WidgetException('Cannot add %r, it already has a parent %r'\n                                  % (widget, parent))\n        widget.parent = parent = self\n        # Child will be disabled if added to a disabled parent.\n        widget.inc_disabled(self._disabled_count)\n\n        canvas = self.canvas.before if canvas == 'before' else \\\n            self.canvas.after if canvas == 'after' else self.canvas\n\n        if index == 0 or len(self.children) == 0:\n            self.children.insert(0, widget)\n            canvas.add(widget.canvas)\n        else:\n            canvas = self.canvas\n            children = self.children\n            if index >= len(children):\n                index = len(children)\n                next_index = canvas.indexof(children[-1].canvas)\n            else:\n                next_child = children[index]\n                next_index = canvas.indexof(next_child.canvas)\n                if next_index == -1:\n                    next_index = canvas.length()\n                else:\n                    next_index += 1\n\n            children.insert(index, widget)\n            # We never want to insert widget _before_ canvas.before.\n            if next_index == 0 and canvas.has_before:\n                next_index = 1\n            canvas.insert(next_index, widget.canvas)\n        for type_id in widget.motion_filter:\n            self.register_for_motion_event(type_id, widget)\n        widget.fbind('motion_filter', self._update_motion_filter)",
  "def remove_widget(self, widget):\n        '''Remove a widget from the children of this widget.\n\n        :Parameters:\n            `widget`: :class:`Widget`\n                Widget to remove from our children list.\n\n    .. code-block:: python\n\n        >>> from kivy.uix.button import Button\n        >>> root = Widget()\n        >>> button = Button()\n        >>> root.add_widget(button)\n        >>> root.remove_widget(button)\n        '''\n        if widget not in self.children:\n            return\n        self.children.remove(widget)\n        if widget.canvas in self.canvas.children:\n            self.canvas.remove(widget.canvas)\n        elif widget.canvas in self.canvas.after.children:\n            self.canvas.after.remove(widget.canvas)\n        elif widget.canvas in self.canvas.before.children:\n            self.canvas.before.remove(widget.canvas)\n        for type_id in widget.motion_filter:\n            self.unregister_for_motion_event(type_id, widget)\n        widget.funbind('motion_filter', self._update_motion_filter)\n        widget.parent = None\n        widget.dec_disabled(self._disabled_count)",
  "def clear_widgets(self, children=None):\n        '''\n        Remove all (or the specified) :attr:`~Widget.children` of this widget.\n        If the 'children' argument is specified, it should be a list (or\n        filtered list) of children of the current widget.\n\n        .. versionchanged:: 1.8.0\n            The `children` argument can be used to specify the children you\n            want to remove.\n        .. versionchanged:: 2.1.0\n\n            Specifying an empty ``children`` list leaves the widgets unchanged.\n            Previously it was treated like ``None`` and all children were\n            removed.\n        '''\n        if children is None or children is self.children:\n            children = self.children[:]\n\n        remove_widget = self.remove_widget\n        for child in children:\n            remove_widget(child)",
  "def _update_motion_filter(self, child_widget, child_motion_filter):\n        old_events = []\n        for type_id, widgets in self.motion_filter.items():\n            if child_widget in widgets:\n                old_events.append(type_id)\n        for type_id in old_events:\n            if type_id not in child_motion_filter:\n                self.unregister_for_motion_event(type_id, child_widget)\n        for type_id in child_motion_filter:\n            if type_id not in old_events:\n                self.register_for_motion_event(type_id, child_widget)",
  "def _find_index_in_motion_filter(self, type_id, widget):\n        if widget is self:\n            return 0\n        find_index = self.children.index\n        max_index = find_index(widget) + 1\n        motion_widgets = self.motion_filter[type_id]\n        insert_index = 1 if motion_widgets[0] is self else 0\n        for index in range(insert_index, len(motion_widgets)):\n            if find_index(motion_widgets[index]) < max_index:\n                insert_index += 1\n            else:\n                break\n        return insert_index",
  "def register_for_motion_event(self, type_id, widget=None):\n        '''Register to receive motion events of `type_id`.\n\n        Override :meth:`on_motion` or bind to `on_motion` event to handle\n        the incoming motion events.\n\n        :Parameters:\n            `type_id`: `str`\n                Motion event type id (eg. \"touch\", \"hover\", etc.)\n            `widget`: `Widget`\n                Child widget or `self` if omitted\n\n        .. versionadded:: 2.1.0\n\n        .. note::\n            Method can be called multiple times with the same arguments.\n\n        .. warning::\n            This is an experimental method and it remains so while this warning\n            is present.\n        '''\n        a_widget = widget or self\n        motion_filter = self.motion_filter\n        if type_id not in motion_filter:\n            motion_filter[type_id] = [a_widget]\n        elif widget not in motion_filter[type_id]:\n            index = self._find_index_in_motion_filter(type_id, a_widget)\n            motion_filter[type_id].insert(index, a_widget)",
  "def unregister_for_motion_event(self, type_id, widget=None):\n        '''Unregister to receive motion events of `type_id`.\n\n        :Parameters:\n            `type_id`: `str`\n                Motion event type id (eg. \"touch\", \"hover\", etc.)\n            `widget`: `Widget`\n                Child widget or `self` if omitted\n\n        .. versionadded:: 2.1.0\n\n        .. note::\n            Method can be called multiple times with the same arguments.\n\n        .. warning::\n            This is an experimental method and it remains so while this warning\n            is present.\n        '''\n        a_widget = widget or self\n        motion_filter = self.motion_filter\n        if type_id in motion_filter:\n            if a_widget in motion_filter[type_id]:\n                motion_filter[type_id].remove(a_widget)\n                if not motion_filter[type_id]:\n                    del motion_filter[type_id]",
  "def export_to_png(self, filename, *args, **kwargs):\n        '''Saves an image of the widget and its children in png format at the\n        specified filename. Works by removing the widget canvas from its\n        parent, rendering to an :class:`~kivy.graphics.fbo.Fbo`, and calling\n        :meth:`~kivy.graphics.texture.Texture.save`.\n\n        .. note::\n\n            The image includes only this widget and its children. If you want\n            to include widgets elsewhere in the tree, you must call\n            :meth:`~Widget.export_to_png` from their common parent, or use\n            :meth:`~kivy.core.window.WindowBase.screenshot` to capture the\n            whole window.\n\n        .. note::\n\n            The image will be saved in png format, you should include the\n            extension in your filename.\n\n        .. versionadded:: 1.9.0\n\n        :Parameters:\n            `filename`: str\n                The filename with which to save the png.\n            `scale`: float\n                The amount by which to scale the saved image, defaults to 1.\n\n                .. versionadded:: 1.11.0\n        '''\n        self.export_as_image(*args, **kwargs).save(filename, flipped=False)",
  "def export_as_image(self, *args, **kwargs):\n        '''Return an core :class:`~kivy.core.image.Image` of the actual\n        widget.\n\n        .. versionadded:: 1.11.0\n        '''\n        from kivy.core.image import Image\n        scale = kwargs.get('scale', 1)\n\n        if self.parent is not None:\n            canvas_parent_index = self.parent.canvas.indexof(self.canvas)\n            if canvas_parent_index > -1:\n                self.parent.canvas.remove(self.canvas)\n\n        fbo = Fbo(size=(self.width * scale, self.height * scale),\n                  with_stencilbuffer=True)\n\n        with fbo:\n            ClearColor(0, 0, 0, 0)\n            ClearBuffers()\n            Scale(1, -1, 1)\n            Scale(scale, scale, 1)\n            Translate(-self.x, -self.y - self.height, 0)\n\n        fbo.add(self.canvas)\n        fbo.draw()\n        img = Image(fbo.texture)\n        fbo.remove(self.canvas)\n\n        if self.parent is not None and canvas_parent_index > -1:\n            self.parent.canvas.insert(canvas_parent_index, self.canvas)\n\n        return img",
  "def get_root_window(self):\n        '''Return the root window.\n\n        :Returns:\n            Instance of the root window. Can be a\n            :class:`~kivy.core.window.WindowBase` or\n            :class:`Widget`.\n        '''\n        if self.parent:\n            return self.parent.get_root_window()",
  "def get_parent_window(self):\n        '''Return the parent window.\n\n        :Returns:\n            Instance of the parent window. Can be a\n            :class:`~kivy.core.window.WindowBase` or\n            :class:`Widget`.\n        '''\n        if self.parent:\n            return self.parent.get_parent_window()",
  "def _walk(self, restrict=False, loopback=False, index=None):\n        # We pass index only when we are going on the parent\n        # so don't yield the parent as well.\n        if index is None:\n            index = len(self.children)\n            yield self\n\n        for child in reversed(self.children[:index]):\n            for walk_child in child._walk(restrict=True):\n                yield walk_child\n\n        # If we want to continue with our parent, just do it.\n        if not restrict:\n            parent = self.parent\n            try:\n                if parent is None or not isinstance(parent, Widget):\n                    raise ValueError\n                index = parent.children.index(self)\n            except ValueError:\n                # Self is root, if we want to loopback from the first element:\n                if not loopback:\n                    return\n                # If we started with root (i.e. index==None), then we have to\n                # start from root again, so we return self again. Otherwise, we\n                # never returned it, so return it now starting with it.\n                parent = self\n                index = None\n            for walk_child in parent._walk(loopback=loopback, index=index):\n                yield walk_child",
  "def walk(self, restrict=False, loopback=False):\n        ''' Iterator that walks the widget tree starting with this widget and\n        goes forward returning widgets in the order in which layouts display\n        them.\n\n        :Parameters:\n            `restrict`: bool, defaults to False\n                If True, it will only iterate through the widget and its\n                children (or children of its children etc.). Defaults to False.\n            `loopback`: bool, defaults to False\n                If True, when the last widget in the tree is reached,\n                it'll loop back to the uppermost root and start walking until\n                we hit this widget again. Naturally, it can only loop back when\n                `restrict` is False. Defaults to False.\n\n        :return:\n            A generator that walks the tree, returning widgets in the\n            forward layout order.\n\n        For example, given a tree with the following structure:\n\n        .. code-block:: kv\n\n            GridLayout:\n                Button\n                BoxLayout:\n                    id: box\n                    Widget\n                    Button\n                Widget\n\n        walking this tree:\n\n        .. code-block:: python\n\n            >>> # Call walk on box with loopback True, and restrict False\n            >>> [type(widget) for widget in box.walk(loopback=True)]\n            [<class 'BoxLayout'>, <class 'Widget'>, <class 'Button'>,\n                <class 'Widget'>, <class 'GridLayout'>, <class 'Button'>]\n            >>> # Now with loopback False, and restrict False\n            >>> [type(widget) for widget in box.walk()]\n            [<class 'BoxLayout'>, <class 'Widget'>, <class 'Button'>,\n                <class 'Widget'>]\n            >>> # Now with restrict True\n            >>> [type(widget) for widget in box.walk(restrict=True)]\n            [<class 'BoxLayout'>, <class 'Widget'>, <class 'Button'>]\n\n        .. versionadded:: 1.9.0\n        '''\n        gen = self._walk(restrict, loopback)\n        yield next(gen)\n        for node in gen:\n            if node is self:\n                return\n            yield node",
  "def _walk_reverse(self, loopback=False, go_up=False):\n        # process is walk up level, walk down its children tree, then walk up\n        # next level etc.\n        # default just walk down the children tree\n        root = self\n        index = 0\n        # we need to go up a level before walking tree\n        if go_up:\n            root = self.parent\n            try:\n                if root is None or not isinstance(root, Widget):\n                    raise ValueError\n                index = root.children.index(self) + 1\n            except ValueError:\n                if not loopback:\n                    return\n                index = 0\n                go_up = False\n                root = self\n\n        # now walk children tree starting with last-most child\n        for child in islice(root.children, index, None):\n            for walk_child in child._walk_reverse(loopback=loopback):\n                yield walk_child\n        # we need to return ourself last, in all cases\n        yield root\n\n        # if going up, continue walking up the parent tree\n        if go_up:\n            for walk_child in root._walk_reverse(loopback=loopback,\n                                                 go_up=go_up):\n                yield walk_child",
  "def walk_reverse(self, loopback=False):\n        ''' Iterator that walks the widget tree backwards starting with the\n        widget before this, and going backwards returning widgets in the\n        reverse order in which layouts display them.\n\n        This walks in the opposite direction of :meth:`walk`, so a list of the\n        tree generated with :meth:`walk` will be in reverse order compared\n        to the list generated with this, provided `loopback` is True.\n\n        :Parameters:\n            `loopback`: bool, defaults to False\n                If True, when the uppermost root in the tree is\n                reached, it'll loop back to the last widget and start walking\n                back until after we hit widget again. Defaults to False.\n\n        :return:\n            A generator that walks the tree, returning widgets in the\n            reverse layout order.\n\n        For example, given a tree with the following structure:\n\n        .. code-block:: kv\n\n            GridLayout:\n                Button\n                BoxLayout:\n                    id: box\n                    Widget\n                    Button\n                Widget\n\n        walking this tree:\n\n        .. code-block:: python\n\n            >>> # Call walk on box with loopback True\n            >>> [type(widget) for widget in box.walk_reverse(loopback=True)]\n            [<class 'Button'>, <class 'GridLayout'>, <class 'Widget'>,\n                <class 'Button'>, <class 'Widget'>, <class 'BoxLayout'>]\n            >>> # Now with loopback False\n            >>> [type(widget) for widget in box.walk_reverse()]\n            [<class 'Button'>, <class 'GridLayout'>]\n            >>> forward = [w for w in box.walk(loopback=True)]\n            >>> backward = [w for w in box.walk_reverse(loopback=True)]\n            >>> forward == backward[::-1]\n            True\n\n        .. versionadded:: 1.9.0\n\n        '''\n        for node in self._walk_reverse(loopback=loopback, go_up=True):\n            yield node\n            if node is self:\n                return",
  "def to_widget(self, x, y, relative=False):\n        '''Convert the coordinate from window to local (current widget)\n        coordinates.\n\n        See :mod:`~kivy.uix.relativelayout` for details on the coordinate\n        systems.\n        '''\n        if self.parent:\n            x, y = self.parent.to_widget(x, y)\n        return self.to_local(x, y, relative=relative)",
  "def to_window(self, x, y, initial=True, relative=False):\n        \"\"\"If ``initial`` is True, the default, it transforms **parent**\n        coordinates to window coordinates. Otherwise, it transforms **local**\n        (current widget) coordinates to window coordinates.\n\n        See :mod:`~kivy.uix.relativelayout` for details on the coordinate\n        systems.\n        \"\"\"\n        if not initial:\n            x, y = self.to_parent(x, y, relative=relative)\n        if self.parent:\n            return self.parent.to_window(x, y, initial=False,\n                                         relative=relative)\n        return (x, y)",
  "def to_parent(self, x, y, relative=False):\n        \"\"\"Transform local (current widget) coordinates to parent coordinates.\n\n        See :mod:`~kivy.uix.relativelayout` for details on the coordinate\n        systems.\n\n        :Parameters:\n            `relative`: bool, defaults to False\n                Change to True if you want to translate relative positions from\n                a widget to its parent coordinates.\n        \"\"\"\n        if relative:\n            return (x + self.x, y + self.y)\n        return (x, y)",
  "def to_local(self, x, y, relative=False):\n        \"\"\"Transform parent coordinates to local (current widget) coordinates.\n\n        See :mod:`~kivy.uix.relativelayout` for details on the coordinate\n        systems.\n\n        :Parameters:\n            `relative`: bool, defaults to False\n                Change to True if you want to translate coordinates to\n                relative widget coordinates.\n        \"\"\"\n        if relative:\n            return (x - self.x, y - self.y)\n        return (x, y)",
  "def _apply_transform(self, m, pos=None):\n        if self.parent:\n            x, y = self.parent.to_widget(relative=True,\n                                         *self.to_window(*(pos or self.pos)))\n            m.translate(x, y, 0)\n            m = self.parent._apply_transform(m) if self.parent else m\n        return m",
  "def get_window_matrix(self, x=0, y=0):\n        '''Calculate the transformation matrix to convert between window and\n        widget coordinates.\n\n        :Parameters:\n            `x`: float, defaults to 0\n                Translates the matrix on the x axis.\n            `y`: float, defaults to 0\n                Translates the matrix on the y axis.\n        '''\n        m = Matrix()\n        m.translate(x, y, 0)\n        m = self._apply_transform(m)\n        return m",
  "def get_right(self):\n        return self.x + self.width",
  "def set_right(self, value):\n        self.x = value - self.width",
  "def get_top(self):\n        return self.y + self.height",
  "def set_top(self, value):\n        self.y = value - self.height",
  "def get_center_x(self):\n        return self.x + self.width / 2.",
  "def set_center_x(self, value):\n        self.x = value - self.width / 2.",
  "def get_center_y(self):\n        return self.y + self.height / 2.",
  "def set_center_y(self, value):\n        self.y = value - self.height / 2.",
  "def on_opacity(self, instance, value):\n        canvas = self.canvas\n        if canvas is not None:\n            canvas.opacity = value",
  "def get_disabled(self):\n        return self._disabled_count > 0",
  "def set_disabled(self, value):\n        # Necessary to ensure a change between value of equal truthiness\n        # doesn't mess up the count\n        value = bool(value)\n        if value != self._disabled_value:\n            self._disabled_value = value\n            if value:\n                self.inc_disabled()\n            else:\n                self.dec_disabled()\n            return True",
  "def inc_disabled(self, count=1):\n        self._disabled_count += count\n        if self._disabled_count - count < 1 <= self._disabled_count:\n            self.property('disabled').dispatch(self)\n        for c in self.children:\n            c.inc_disabled(count)",
  "def dec_disabled(self, count=1):\n        self._disabled_count -= count\n        if self._disabled_count <= 0 < self._disabled_count + count:\n            self.property('disabled').dispatch(self)\n        for c in self.children:\n            c.dec_disabled(count)",
  "class EffectBase(EventDispatcher):\n    '''The base class for GLSL effects. It simply returns its input.\n\n    See the module documentation for more details.\n\n    '''\n\n    glsl = StringProperty(effect_trivial)\n    '''The glsl string defining your effect function. See the\n    module documentation for more details.\n\n    :attr:`glsl` is a :class:`~kivy.properties.StringProperty` and\n    defaults to\n    a trivial effect that returns its input.\n    '''\n\n    source = StringProperty('')\n    '''The (optional) filename from which to load the :attr:`glsl`\n    string.\n\n    :attr:`source` is a :class:`~kivy.properties.StringProperty` and\n    defaults to ''.\n    '''\n\n    fbo = ObjectProperty(None, allownone=True)\n    '''The fbo currently using this effect. The :class:`EffectBase`\n    automatically handles this.\n\n    :attr:`fbo` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    def __init__(self, *args, **kwargs):\n        super(EffectBase, self).__init__(*args, **kwargs)\n        fbind = self.fbind\n        fbo_shader = self.set_fbo_shader\n        fbind('fbo', fbo_shader)\n        fbind('glsl', fbo_shader)\n        fbind('source', self._load_from_source)\n\n    def set_fbo_shader(self, *args):\n        '''Sets the :class:`~kivy.graphics.Fbo`'s shader by splicing\n        the :attr:`glsl` string into a full fragment shader.\n\n        The full shader is made up of :code:`shader_header +\n        shader_uniforms + self.glsl + shader_footer_effect`.\n        '''\n        if self.fbo is None:\n            return\n        self.fbo.set_fs(shader_header + shader_uniforms + self.glsl +\n                        shader_footer_effect)\n\n    def _load_from_source(self, *args):\n        '''(internal) Loads the glsl string from a source file.'''\n        source = self.source\n        if not source:\n            return\n        filename = resource_find(source)\n        if filename is None:\n            return Logger.error('Error reading file {filename}'.\n                                format(filename=source))\n        with open(filename) as fileh:\n            self.glsl = fileh.read()",
  "class AdvancedEffectBase(EffectBase):\n    '''An :class:`EffectBase` with additional behavior to easily\n    set and update uniform variables in your shader.\n\n    This class is provided for convenience when implementing your own\n    effects: it is not used by any of those provided with Kivy.\n\n    In addition to your base glsl string that must be provided as\n    normal, the :class:`AdvancedEffectBase` has an extra property\n    :attr:`uniforms`, a dictionary of name-value pairs. Whenever\n    a value is changed, the new value for the uniform variable is\n    uploaded to the shader.\n\n    You must still manually declare your uniform variables at the top\n    of your glsl string.\n    '''\n\n    uniforms = DictProperty({})\n    '''A dictionary of uniform variable names and their values. These\n    are automatically uploaded to the :attr:`fbo` shader if appropriate.\n\n    uniforms is a :class:`~kivy.properties.DictProperty` and\n    defaults to {}.\n    '''\n\n    def __init__(self, *args, **kwargs):\n        super(AdvancedEffectBase, self).__init__(*args, **kwargs)\n        self.fbind('uniforms', self._update_uniforms)\n\n    def _update_uniforms(self, *args):\n        if self.fbo is None:\n            return\n        for key, value in self.uniforms.items():\n            self.fbo[key] = value\n\n    def set_fbo_shader(self, *args):\n        super(AdvancedEffectBase, self).set_fbo_shader(*args)\n        self._update_uniforms()",
  "class MonochromeEffect(EffectBase):\n    '''Returns its input colors in monochrome.'''\n    def __init__(self, *args, **kwargs):\n        super(MonochromeEffect, self).__init__(*args, **kwargs)\n        self.glsl = effect_monochrome",
  "class InvertEffect(EffectBase):\n    '''Inverts the colors in the input.'''\n    def __init__(self, *args, **kwargs):\n        super(InvertEffect, self).__init__(*args, **kwargs)\n        self.glsl = effect_invert",
  "class ScanlinesEffect(EffectBase):\n    '''Adds scanlines to the input.'''\n    def __init__(self, *args, **kwargs):\n        super(ScanlinesEffect, self).__init__(*args, **kwargs)\n        self.glsl = effect_postprocessing",
  "class ChannelMixEffect(EffectBase):\n    '''Mixes the color channels of the input according to the order\n    property. Channels may be arbitrarily rearranged or repeated.'''\n\n    order = ListProperty([1, 2, 0])\n    '''The new sorted order of the rgb channels.\n\n    order is a :class:`~kivy.properties.ListProperty` and defaults to\n    [1, 2, 0], corresponding to (g, b, r).\n    '''\n\n    def __init__(self, *args, **kwargs):\n        super(ChannelMixEffect, self).__init__(*args, **kwargs)\n        self.do_glsl()\n\n    def on_order(self, *args):\n        self.do_glsl()\n\n    def do_glsl(self):\n        letters = [{0: 'x', 1: 'y', 2: 'z'}[i] for i in self.order]\n        self.glsl = effect_mix.format(*letters)",
  "class PixelateEffect(EffectBase):\n    '''Pixelates the input according to its\n    :attr:`~PixelateEffect.pixel_size`'''\n\n    pixel_size = NumericProperty(10)\n    '''\n    Sets the size of a new 'pixel' in the effect, in terms of number of\n    'real' pixels.\n\n    pixel_size is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 10.\n    '''\n\n    def __init__(self, *args, **kwargs):\n        super(PixelateEffect, self).__init__(*args, **kwargs)\n        self.do_glsl()\n\n    def on_pixel_size(self, *args):\n        self.do_glsl()\n\n    def do_glsl(self):\n        self.glsl = effect_pixelate.format(float(self.pixel_size))",
  "class HorizontalBlurEffect(EffectBase):\n    '''Blurs the input horizontally, with the width given by\n    :attr:`~HorizontalBlurEffect.size`.'''\n\n    size = NumericProperty(4.0)\n    '''The blur width in pixels.\n\n    size is a :class:`~kivy.properties.NumericProperty` and defaults to\n    4.0.\n    '''\n\n    def __init__(self, *args, **kwargs):\n        super(HorizontalBlurEffect, self).__init__(*args, **kwargs)\n        self.do_glsl()\n\n    def on_size(self, *args):\n        self.do_glsl()\n\n    def do_glsl(self):\n        self.glsl = effect_blur_h.format(float(self.size))",
  "class VerticalBlurEffect(EffectBase):\n    '''Blurs the input vertically, with the width given by\n    :attr:`~VerticalBlurEffect.size`.'''\n\n    size = NumericProperty(4.0)\n    '''The blur width in pixels.\n\n    size is a :class:`~kivy.properties.NumericProperty` and defaults to\n    4.0.\n    '''\n\n    def __init__(self, *args, **kwargs):\n        super(VerticalBlurEffect, self).__init__(*args, **kwargs)\n        self.do_glsl()\n\n    def on_size(self, *args):\n        self.do_glsl()\n\n    def do_glsl(self):\n        self.glsl = effect_blur_v.format(float(self.size))",
  "class FXAAEffect(EffectBase):\n    '''Applies very simple anti-aliasing via fxaa.'''\n    def __init__(self, *args, **kwargs):\n        super(FXAAEffect, self).__init__(*args, **kwargs)\n        self.glsl = effect_fxaa",
  "class EffectFbo(Fbo):\n    '''An :class:`~kivy.graphics.Fbo` with extra functionality that allows\n    attempts to set a new shader. See :meth:`set_fs`.\n    '''\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault(\"with_stencilbuffer\", True)\n        super(EffectFbo, self).__init__(*args, **kwargs)\n        self.texture_rectangle = None\n\n    def set_fs(self, value):\n        '''Attempt to set the fragment shader to the given value.\n        If setting the shader fails, the existing one is preserved and an\n        exception is raised.\n        '''\n        shader = self.shader\n        old_value = shader.fs\n        shader.fs = value\n        if not shader.success:\n            shader.fs = old_value\n            raise Exception('Setting new shader failed.')",
  "class EffectWidget(RelativeLayout):\n    '''\n    Widget with the ability to apply a series of graphical effects to\n    its children. See the module documentation for more information on\n    setting effects and creating your own.\n    '''\n\n    background_color = ListProperty((0, 0, 0, 0))\n    '''This defines the background color to be used for the fbo in the\n    EffectWidget.\n\n    :attr:`background_color` is a :class:`ListProperty` defaults to\n    (0, 0, 0, 0)\n    '''\n\n    texture = ObjectProperty(None)\n    '''The output texture of the final :class:`~kivy.graphics.Fbo` after\n    all effects have been applied.\n\n    texture is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    effects = ListProperty([])\n    '''List of all the effects to be applied. These should all be\n    instances or subclasses of :class:`EffectBase`.\n\n    effects is a :class:`ListProperty` and defaults to [].\n    '''\n\n    fbo_list = ListProperty([])\n    '''(internal) List of all the fbos that are being used to apply\n    the effects.\n\n    fbo_list is a :class:`ListProperty` and defaults to [].\n    '''\n\n    _bound_effects = ListProperty([])\n    '''(internal) List of effect classes that have been given an fbo to\n    manage. This is necessary so that the fbo can be removed if the\n    effect is no longer in use.\n\n    _bound_effects is a :class:`ListProperty` and defaults to [].\n    '''\n\n    def __init__(self, **kwargs):\n        # Make sure opengl context exists\n        EventLoop.ensure_window()\n\n        self.canvas = RenderContext(use_parent_projection=True,\n                                    use_parent_modelview=True)\n\n        with self.canvas:\n            self.fbo = Fbo(size=self.size)\n\n        with self.fbo.before:\n            PushMatrix()\n        with self.fbo:\n            ClearColor(0, 0, 0, 0)\n            ClearBuffers()\n            self._background_color = Color(*self.background_color)\n            self.fbo_rectangle = Rectangle(size=self.size)\n        with self.fbo.after:\n            PopMatrix()\n\n        super(EffectWidget, self).__init__(**kwargs)\n\n        Clock.schedule_interval(self._update_glsl, 0)\n\n        fbind = self.fbind\n        fbo_setup = self.refresh_fbo_setup\n        fbind('size', fbo_setup)\n        fbind('effects', fbo_setup)\n        fbind('background_color', self._refresh_background_color)\n\n        self.refresh_fbo_setup()\n        self._refresh_background_color()  # In case this was changed in kwargs\n\n    def _refresh_background_color(self, *args):\n        self._background_color.rgba = self.background_color\n\n    def _update_glsl(self, *largs):\n        '''(internal) Passes new time and resolution uniform\n        variables to the shader.\n        '''\n        time = Clock.get_boottime()\n        resolution = [float(size) for size in self.size]\n        self.canvas['time'] = time\n        self.canvas['resolution'] = resolution\n        for fbo in self.fbo_list:\n            fbo['time'] = time\n            fbo['resolution'] = resolution\n\n    def refresh_fbo_setup(self, *args):\n        '''(internal) Creates and assigns one :class:`~kivy.graphics.Fbo`\n        per effect, and makes sure all sizes etc. are correct and\n        consistent.\n        '''\n        # Add/remove fbos until there is one per effect\n        while len(self.fbo_list) < len(self.effects):\n            with self.canvas:\n                new_fbo = EffectFbo(size=self.size)\n            with new_fbo:\n                ClearColor(0, 0, 0, 0)\n                ClearBuffers()\n                Color(1, 1, 1, 1)\n                new_fbo.texture_rectangle = Rectangle(size=self.size)\n\n                new_fbo.texture_rectangle.size = self.size\n            self.fbo_list.append(new_fbo)\n        while len(self.fbo_list) > len(self.effects):\n            old_fbo = self.fbo_list.pop()\n            self.canvas.remove(old_fbo)\n\n        # Remove fbos from unused effects\n        for effect in self._bound_effects:\n            if effect not in self.effects:\n                effect.fbo = None\n        self._bound_effects = self.effects\n\n        # Do resizing etc.\n        self.fbo.size = self.size\n        self.fbo_rectangle.size = self.size\n        for i in range(len(self.fbo_list)):\n            self.fbo_list[i].size = self.size\n            self.fbo_list[i].texture_rectangle.size = self.size\n\n        # If there are no effects, just draw our main fbo\n        if len(self.fbo_list) == 0:\n            self.texture = self.fbo.texture\n            return\n\n        for i in range(1, len(self.fbo_list)):\n            fbo = self.fbo_list[i]\n            fbo.texture_rectangle.texture = self.fbo_list[i - 1].texture\n\n        # Build effect shaders\n        for effect, fbo in zip(self.effects, self.fbo_list):\n            effect.fbo = fbo\n\n        self.fbo_list[0].texture_rectangle.texture = self.fbo.texture\n        self.texture = self.fbo_list[-1].texture\n\n        for fbo in self.fbo_list:\n            fbo.draw()\n        self.fbo.draw()\n\n    def add_widget(self, *args, **kwargs):\n        # Add the widget to our Fbo instead of the normal canvas\n        c = self.canvas\n        self.canvas = self.fbo\n        super(EffectWidget, self).add_widget(*args, **kwargs)\n        self.canvas = c\n\n    def remove_widget(self, *args, **kwargs):\n        # Remove the widget from our Fbo instead of the normal canvas\n        c = self.canvas\n        self.canvas = self.fbo\n        super(EffectWidget, self).remove_widget(*args, **kwargs)\n        self.canvas = c\n\n    def clear_widgets(self, *args, **kwargs):\n        # Clear widgets from our Fbo instead of the normal canvas\n        c = self.canvas\n        self.canvas = self.fbo\n        super(EffectWidget, self).clear_widgets(*args, **kwargs)\n        self.canvas = c",
  "def __init__(self, *args, **kwargs):\n        super(EffectBase, self).__init__(*args, **kwargs)\n        fbind = self.fbind\n        fbo_shader = self.set_fbo_shader\n        fbind('fbo', fbo_shader)\n        fbind('glsl', fbo_shader)\n        fbind('source', self._load_from_source)",
  "def set_fbo_shader(self, *args):\n        '''Sets the :class:`~kivy.graphics.Fbo`'s shader by splicing\n        the :attr:`glsl` string into a full fragment shader.\n\n        The full shader is made up of :code:`shader_header +\n        shader_uniforms + self.glsl + shader_footer_effect`.\n        '''\n        if self.fbo is None:\n            return\n        self.fbo.set_fs(shader_header + shader_uniforms + self.glsl +\n                        shader_footer_effect)",
  "def _load_from_source(self, *args):\n        '''(internal) Loads the glsl string from a source file.'''\n        source = self.source\n        if not source:\n            return\n        filename = resource_find(source)\n        if filename is None:\n            return Logger.error('Error reading file {filename}'.\n                                format(filename=source))\n        with open(filename) as fileh:\n            self.glsl = fileh.read()",
  "def __init__(self, *args, **kwargs):\n        super(AdvancedEffectBase, self).__init__(*args, **kwargs)\n        self.fbind('uniforms', self._update_uniforms)",
  "def _update_uniforms(self, *args):\n        if self.fbo is None:\n            return\n        for key, value in self.uniforms.items():\n            self.fbo[key] = value",
  "def set_fbo_shader(self, *args):\n        super(AdvancedEffectBase, self).set_fbo_shader(*args)\n        self._update_uniforms()",
  "def __init__(self, *args, **kwargs):\n        super(MonochromeEffect, self).__init__(*args, **kwargs)\n        self.glsl = effect_monochrome",
  "def __init__(self, *args, **kwargs):\n        super(InvertEffect, self).__init__(*args, **kwargs)\n        self.glsl = effect_invert",
  "def __init__(self, *args, **kwargs):\n        super(ScanlinesEffect, self).__init__(*args, **kwargs)\n        self.glsl = effect_postprocessing",
  "def __init__(self, *args, **kwargs):\n        super(ChannelMixEffect, self).__init__(*args, **kwargs)\n        self.do_glsl()",
  "def on_order(self, *args):\n        self.do_glsl()",
  "def do_glsl(self):\n        letters = [{0: 'x', 1: 'y', 2: 'z'}[i] for i in self.order]\n        self.glsl = effect_mix.format(*letters)",
  "def __init__(self, *args, **kwargs):\n        super(PixelateEffect, self).__init__(*args, **kwargs)\n        self.do_glsl()",
  "def on_pixel_size(self, *args):\n        self.do_glsl()",
  "def do_glsl(self):\n        self.glsl = effect_pixelate.format(float(self.pixel_size))",
  "def __init__(self, *args, **kwargs):\n        super(HorizontalBlurEffect, self).__init__(*args, **kwargs)\n        self.do_glsl()",
  "def on_size(self, *args):\n        self.do_glsl()",
  "def do_glsl(self):\n        self.glsl = effect_blur_h.format(float(self.size))",
  "def __init__(self, *args, **kwargs):\n        super(VerticalBlurEffect, self).__init__(*args, **kwargs)\n        self.do_glsl()",
  "def on_size(self, *args):\n        self.do_glsl()",
  "def do_glsl(self):\n        self.glsl = effect_blur_v.format(float(self.size))",
  "def __init__(self, *args, **kwargs):\n        super(FXAAEffect, self).__init__(*args, **kwargs)\n        self.glsl = effect_fxaa",
  "def __init__(self, *args, **kwargs):\n        kwargs.setdefault(\"with_stencilbuffer\", True)\n        super(EffectFbo, self).__init__(*args, **kwargs)\n        self.texture_rectangle = None",
  "def set_fs(self, value):\n        '''Attempt to set the fragment shader to the given value.\n        If setting the shader fails, the existing one is preserved and an\n        exception is raised.\n        '''\n        shader = self.shader\n        old_value = shader.fs\n        shader.fs = value\n        if not shader.success:\n            shader.fs = old_value\n            raise Exception('Setting new shader failed.')",
  "def __init__(self, **kwargs):\n        # Make sure opengl context exists\n        EventLoop.ensure_window()\n\n        self.canvas = RenderContext(use_parent_projection=True,\n                                    use_parent_modelview=True)\n\n        with self.canvas:\n            self.fbo = Fbo(size=self.size)\n\n        with self.fbo.before:\n            PushMatrix()\n        with self.fbo:\n            ClearColor(0, 0, 0, 0)\n            ClearBuffers()\n            self._background_color = Color(*self.background_color)\n            self.fbo_rectangle = Rectangle(size=self.size)\n        with self.fbo.after:\n            PopMatrix()\n\n        super(EffectWidget, self).__init__(**kwargs)\n\n        Clock.schedule_interval(self._update_glsl, 0)\n\n        fbind = self.fbind\n        fbo_setup = self.refresh_fbo_setup\n        fbind('size', fbo_setup)\n        fbind('effects', fbo_setup)\n        fbind('background_color', self._refresh_background_color)\n\n        self.refresh_fbo_setup()\n        self._refresh_background_color()",
  "def _refresh_background_color(self, *args):\n        self._background_color.rgba = self.background_color",
  "def _update_glsl(self, *largs):\n        '''(internal) Passes new time and resolution uniform\n        variables to the shader.\n        '''\n        time = Clock.get_boottime()\n        resolution = [float(size) for size in self.size]\n        self.canvas['time'] = time\n        self.canvas['resolution'] = resolution\n        for fbo in self.fbo_list:\n            fbo['time'] = time\n            fbo['resolution'] = resolution",
  "def refresh_fbo_setup(self, *args):\n        '''(internal) Creates and assigns one :class:`~kivy.graphics.Fbo`\n        per effect, and makes sure all sizes etc. are correct and\n        consistent.\n        '''\n        # Add/remove fbos until there is one per effect\n        while len(self.fbo_list) < len(self.effects):\n            with self.canvas:\n                new_fbo = EffectFbo(size=self.size)\n            with new_fbo:\n                ClearColor(0, 0, 0, 0)\n                ClearBuffers()\n                Color(1, 1, 1, 1)\n                new_fbo.texture_rectangle = Rectangle(size=self.size)\n\n                new_fbo.texture_rectangle.size = self.size\n            self.fbo_list.append(new_fbo)\n        while len(self.fbo_list) > len(self.effects):\n            old_fbo = self.fbo_list.pop()\n            self.canvas.remove(old_fbo)\n\n        # Remove fbos from unused effects\n        for effect in self._bound_effects:\n            if effect not in self.effects:\n                effect.fbo = None\n        self._bound_effects = self.effects\n\n        # Do resizing etc.\n        self.fbo.size = self.size\n        self.fbo_rectangle.size = self.size\n        for i in range(len(self.fbo_list)):\n            self.fbo_list[i].size = self.size\n            self.fbo_list[i].texture_rectangle.size = self.size\n\n        # If there are no effects, just draw our main fbo\n        if len(self.fbo_list) == 0:\n            self.texture = self.fbo.texture\n            return\n\n        for i in range(1, len(self.fbo_list)):\n            fbo = self.fbo_list[i]\n            fbo.texture_rectangle.texture = self.fbo_list[i - 1].texture\n\n        # Build effect shaders\n        for effect, fbo in zip(self.effects, self.fbo_list):\n            effect.fbo = fbo\n\n        self.fbo_list[0].texture_rectangle.texture = self.fbo.texture\n        self.texture = self.fbo_list[-1].texture\n\n        for fbo in self.fbo_list:\n            fbo.draw()\n        self.fbo.draw()",
  "def add_widget(self, *args, **kwargs):\n        # Add the widget to our Fbo instead of the normal canvas\n        c = self.canvas\n        self.canvas = self.fbo\n        super(EffectWidget, self).add_widget(*args, **kwargs)\n        self.canvas = c",
  "def remove_widget(self, *args, **kwargs):\n        # Remove the widget from our Fbo instead of the normal canvas\n        c = self.canvas\n        self.canvas = self.fbo\n        super(EffectWidget, self).remove_widget(*args, **kwargs)\n        self.canvas = c",
  "def clear_widgets(self, *args, **kwargs):\n        # Clear widgets from our Fbo instead of the normal canvas\n        c = self.canvas\n        self.canvas = self.fbo\n        super(EffectWidget, self).clear_widgets(*args, **kwargs)\n        self.canvas = c",
  "class AccordionException(Exception):\n    '''AccordionException class.\n    '''\n    pass",
  "class AccordionItem(FloatLayout):\n    '''AccordionItem class that must be used in conjunction with the\n    :class:`Accordion` class. See the module documentation for more\n    information.\n    '''\n\n    title = StringProperty('')\n    '''Title string of the item. The title might be used in conjunction with the\n    `AccordionItemTitle` template. If you are using a custom template, you can\n    use that property as a text entry, or not. By default, it's used for the\n    title text. See title_template and the example below.\n\n    :attr:`title` is a :class:`~kivy.properties.StringProperty` and defaults\n    to ''.\n    '''\n\n    title_template = StringProperty('AccordionItemTitle')\n    '''Template to use for creating the title part of the accordion item. The\n    default template is a simple Label, not customizable (except the text) that\n    supports vertical and horizontal orientation and different backgrounds for\n    collapse and selected mode.\n\n    It's better to create and use your own template if the default template\n    does not suffice.\n\n    :attr:`title` is a :class:`~kivy.properties.StringProperty` and defaults to\n    'AccordionItemTitle'. The current default template lives in the\n    `kivy/data/style.kv` file.\n\n    Here is the code if you want to build your own template::\n\n        [AccordionItemTitle@Label]:\n            text: ctx.title\n            canvas.before:\n                Color:\n                    rgb: 1, 1, 1\n                BorderImage:\n                    source:\n                        ctx.item.background_normal \\\n                        if ctx.item.collapse \\\n                        else ctx.item.background_selected\n                    pos: self.pos\n                    size: self.size\n                PushMatrix\n                Translate:\n                    xy: self.center_x, self.center_y\n                Rotate:\n                    angle: 90 if ctx.item.orientation == 'horizontal' else 0\n                    axis: 0, 0, 1\n                Translate:\n                    xy: -self.center_x, -self.center_y\n            canvas.after:\n                PopMatrix\n\n\n    '''\n\n    title_args = DictProperty({})\n    '''Default arguments that will be passed to the\n    :meth:`kivy.lang.Builder.template` method.\n\n    :attr:`title_args` is a :class:`~kivy.properties.DictProperty` and defaults\n    to {}.\n    '''\n\n    collapse = BooleanProperty(True)\n    '''Boolean to indicate if the current item is collapsed or not.\n\n    :attr:`collapse` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    collapse_alpha = NumericProperty(1.)\n    '''Value between 0 and 1 to indicate how much the item is collapsed (1) or\n    whether it is selected (0). It's mostly used for animation.\n\n    :attr:`collapse_alpha` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 1.\n    '''\n\n    accordion = ObjectProperty(None)\n    '''Instance of the :class:`Accordion` that the item belongs to.\n\n    :attr:`accordion` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    background_normal = StringProperty(\n        'atlas://data/images/defaulttheme/button')\n    '''Background image of the accordion item used for the default graphical\n    representation when the item is collapsed.\n\n    :attr:`background_normal` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/button'.\n    '''\n\n    background_disabled_normal = StringProperty(\n        'atlas://data/images/defaulttheme/button_disabled')\n    '''Background image of the accordion item used for the default graphical\n    representation when the item is collapsed and disabled.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`background__disabled_normal` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/button_disabled'.\n    '''\n\n    background_selected = StringProperty(\n        'atlas://data/images/defaulttheme/button_pressed')\n    '''Background image of the accordion item used for the default graphical\n    representation when the item is selected (not collapsed).\n\n    :attr:`background_normal` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/button_pressed'.\n    '''\n\n    background_disabled_selected = StringProperty(\n        'atlas://data/images/defaulttheme/button_disabled_pressed')\n    '''Background image of the accordion item used for the default graphical\n    representation when the item is selected (not collapsed) and disabled.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`background_disabled_selected` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/button_disabled_pressed'.\n    '''\n\n    orientation = OptionProperty('vertical', options=(\n        'horizontal', 'vertical'))\n    '''Link to the :attr:`Accordion.orientation` property.\n    '''\n\n    min_space = NumericProperty('44dp')\n    '''Link to the :attr:`Accordion.min_space` property.\n    '''\n\n    content_size = ListProperty([100, 100])\n    '''(internal) Set by the :class:`Accordion` to the size allocated for the\n    content.\n    '''\n\n    container = ObjectProperty(None)\n    '''(internal) Property that will be set to the container of children inside\n    the AccordionItem representation.\n    '''\n\n    container_title = ObjectProperty(None)\n    '''(internal) Property that will be set to the container of title inside\n    the AccordionItem representation.\n    '''\n\n    def __init__(self, **kwargs):\n        self._trigger_title = Clock.create_trigger(self._update_title, -1)\n        self._anim_collapse = None\n        super(AccordionItem, self).__init__(**kwargs)\n        trigger_title = self._trigger_title\n        fbind = self.fbind\n        fbind('title', trigger_title)\n        fbind('title_template', trigger_title)\n        fbind('title_args', trigger_title)\n        trigger_title()\n\n    def add_widget(self, *args, **kwargs):\n        if self.container is None:\n            super(AccordionItem, self).add_widget(*args, **kwargs)\n            return\n        self.container.add_widget(*args, **kwargs)\n\n    def remove_widget(self, *args, **kwargs):\n        if self.container:\n            self.container.remove_widget(*args, **kwargs)\n            return\n        super(AccordionItem, self).remove_widget(*args, **kwargs)\n\n    def on_collapse(self, instance, value):\n        accordion = self.accordion\n        if accordion is None:\n            return\n        if not value:\n            self.accordion.select(self)\n        collapse_alpha = float(value)\n        if self._anim_collapse:\n            self._anim_collapse.stop(self)\n            self._anim_collapse = None\n        if self.collapse_alpha != collapse_alpha:\n            self._anim_collapse = Animation(\n                collapse_alpha=collapse_alpha,\n                t=accordion.anim_func,\n                d=accordion.anim_duration)\n            self._anim_collapse.start(self)\n\n    def on_collapse_alpha(self, instance, value):\n        self.accordion._trigger_layout()\n\n    def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return\n        if self.disabled:\n            return True\n        if self.collapse:\n            self.collapse = False\n            return True\n        else:\n            return super(AccordionItem, self).on_touch_down(touch)\n\n    def _update_title(self, dt):\n        if not self.container_title:\n            self._trigger_title()\n            return\n        c = self.container_title\n        c.clear_widgets()\n        instance = Builder.template(self.title_template,\n                                    title=self.title,\n                                    item=self,\n                                    **self.title_args)\n        c.add_widget(instance)",
  "class Accordion(Widget):\n    '''Accordion class. See module documentation for more information.\n    '''\n\n    orientation = OptionProperty('horizontal', options=(\n        'horizontal', 'vertical'))\n    '''Orientation of the layout.\n\n    :attr:`orientation` is an :class:`~kivy.properties.OptionProperty`\n    and defaults to 'horizontal'. Can take a value of 'vertical' or\n    'horizontal'.\n\n    '''\n\n    anim_duration = NumericProperty(.25)\n    '''Duration of the animation in seconds when a new accordion item is\n    selected.\n\n    :attr:`anim_duration` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to .25 (250ms).\n    '''\n\n    anim_func = ObjectProperty('out_expo')\n    '''Easing function to use for the animation. Check\n    :class:`kivy.animation.AnimationTransition` for more information about\n    available animation functions.\n\n    :attr:`anim_func` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to 'out_expo'. You can set a string or a function to use as an\n    easing function.\n    '''\n\n    min_space = NumericProperty('44dp')\n    '''Minimum space to use for the title of each item. This value is\n    automatically set for each child every time the layout event occurs.\n\n    :attr:`min_space` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 44 (px).\n    '''\n\n    def __init__(self, **kwargs):\n        super(Accordion, self).__init__(**kwargs)\n        update = self._trigger_layout = \\\n            Clock.create_trigger(self._do_layout, -1)\n        fbind = self.fbind\n        fbind('orientation', update)\n        fbind('children', update)\n        fbind('size', update)\n        fbind('pos', update)\n        fbind('min_space', update)\n\n    def add_widget(self, widget, *args, **kwargs):\n        if not isinstance(widget, AccordionItem):\n            raise AccordionException('Accordion accept only AccordionItem')\n        widget.accordion = self\n        super(Accordion, self).add_widget(widget, *args, **kwargs)\n\n    def select(self, instance):\n        if instance not in self.children:\n            raise AccordionException(\n                'Accordion: instance not found in children')\n        for widget in self.children:\n            widget.collapse = widget is not instance\n        self._trigger_layout()\n\n    def _do_layout(self, dt):\n        children = self.children\n        if children:\n            all_collapsed = all(x.collapse for x in children)\n        else:\n            all_collapsed = False\n\n        if all_collapsed:\n            children[0].collapse = False\n\n        orientation = self.orientation\n        min_space = self.min_space\n        min_space_total = len(children) * self.min_space\n        w, h = self.size\n        x, y = self.pos\n        if orientation == 'horizontal':\n            display_space = self.width - min_space_total\n        else:\n            display_space = self.height - min_space_total\n\n        if display_space <= 0:\n            Logger.warning('Accordion: not enough space '\n                           'for displaying all children')\n            Logger.warning('Accordion: need %dpx, got %dpx' % (\n                min_space_total, min_space_total + display_space))\n            Logger.warning('Accordion: layout aborted.')\n            return\n\n        if orientation == 'horizontal':\n            children = reversed(children)\n\n        for child in children:\n            child_space = min_space\n            child_space += display_space * (1 - child.collapse_alpha)\n            child._min_space = min_space\n            child.x = x\n            child.y = y\n            child.orientation = self.orientation\n            if orientation == 'horizontal':\n                child.content_size = display_space, h\n                child.width = child_space\n                child.height = h\n                x += child_space\n            else:\n                child.content_size = w, display_space\n                child.width = w\n                child.height = child_space\n                y += child_space",
  "def __init__(self, **kwargs):\n        self._trigger_title = Clock.create_trigger(self._update_title, -1)\n        self._anim_collapse = None\n        super(AccordionItem, self).__init__(**kwargs)\n        trigger_title = self._trigger_title\n        fbind = self.fbind\n        fbind('title', trigger_title)\n        fbind('title_template', trigger_title)\n        fbind('title_args', trigger_title)\n        trigger_title()",
  "def add_widget(self, *args, **kwargs):\n        if self.container is None:\n            super(AccordionItem, self).add_widget(*args, **kwargs)\n            return\n        self.container.add_widget(*args, **kwargs)",
  "def remove_widget(self, *args, **kwargs):\n        if self.container:\n            self.container.remove_widget(*args, **kwargs)\n            return\n        super(AccordionItem, self).remove_widget(*args, **kwargs)",
  "def on_collapse(self, instance, value):\n        accordion = self.accordion\n        if accordion is None:\n            return\n        if not value:\n            self.accordion.select(self)\n        collapse_alpha = float(value)\n        if self._anim_collapse:\n            self._anim_collapse.stop(self)\n            self._anim_collapse = None\n        if self.collapse_alpha != collapse_alpha:\n            self._anim_collapse = Animation(\n                collapse_alpha=collapse_alpha,\n                t=accordion.anim_func,\n                d=accordion.anim_duration)\n            self._anim_collapse.start(self)",
  "def on_collapse_alpha(self, instance, value):\n        self.accordion._trigger_layout()",
  "def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return\n        if self.disabled:\n            return True\n        if self.collapse:\n            self.collapse = False\n            return True\n        else:\n            return super(AccordionItem, self).on_touch_down(touch)",
  "def _update_title(self, dt):\n        if not self.container_title:\n            self._trigger_title()\n            return\n        c = self.container_title\n        c.clear_widgets()\n        instance = Builder.template(self.title_template,\n                                    title=self.title,\n                                    item=self,\n                                    **self.title_args)\n        c.add_widget(instance)",
  "def __init__(self, **kwargs):\n        super(Accordion, self).__init__(**kwargs)\n        update = self._trigger_layout = \\\n            Clock.create_trigger(self._do_layout, -1)\n        fbind = self.fbind\n        fbind('orientation', update)\n        fbind('children', update)\n        fbind('size', update)\n        fbind('pos', update)\n        fbind('min_space', update)",
  "def add_widget(self, widget, *args, **kwargs):\n        if not isinstance(widget, AccordionItem):\n            raise AccordionException('Accordion accept only AccordionItem')\n        widget.accordion = self\n        super(Accordion, self).add_widget(widget, *args, **kwargs)",
  "def select(self, instance):\n        if instance not in self.children:\n            raise AccordionException(\n                'Accordion: instance not found in children')\n        for widget in self.children:\n            widget.collapse = widget is not instance\n        self._trigger_layout()",
  "def _do_layout(self, dt):\n        children = self.children\n        if children:\n            all_collapsed = all(x.collapse for x in children)\n        else:\n            all_collapsed = False\n\n        if all_collapsed:\n            children[0].collapse = False\n\n        orientation = self.orientation\n        min_space = self.min_space\n        min_space_total = len(children) * self.min_space\n        w, h = self.size\n        x, y = self.pos\n        if orientation == 'horizontal':\n            display_space = self.width - min_space_total\n        else:\n            display_space = self.height - min_space_total\n\n        if display_space <= 0:\n            Logger.warning('Accordion: not enough space '\n                           'for displaying all children')\n            Logger.warning('Accordion: need %dpx, got %dpx' % (\n                min_space_total, min_space_total + display_space))\n            Logger.warning('Accordion: layout aborted.')\n            return\n\n        if orientation == 'horizontal':\n            children = reversed(children)\n\n        for child in children:\n            child_space = min_space\n            child_space += display_space * (1 - child.collapse_alpha)\n            child._min_space = min_space\n            child.x = x\n            child.y = y\n            child.orientation = self.orientation\n            if orientation == 'horizontal':\n                child.content_size = display_space, h\n                child.width = child_space\n                child.height = h\n                x += child_space\n            else:\n                child.content_size = w, display_space\n                child.width = w\n                child.height = child_space\n                y += child_space",
  "def toggle_layout(*l):\n        o = acc.orientation\n        acc.orientation = 'vertical' if o == 'horizontal' else 'horizontal'",
  "def select_2nd_item(*l):\n        acc.select(acc.children[-2])",
  "def update_min_space(instance, value):\n        acc.min_space = value",
  "class ProgressBar(Widget):\n    '''Class for creating a progress bar widget.\n\n    See module documentation for more details.\n    '''\n\n    def __init__(self, **kwargs):\n        self._value = 0.\n        super(ProgressBar, self).__init__(**kwargs)\n\n    def _get_value(self):\n        return self._value\n\n    def _set_value(self, value):\n        value = max(0, min(self.max, value))\n        if value != self._value:\n            self._value = value\n            return True\n\n    value = AliasProperty(_get_value, _set_value)\n    '''Current value used for the slider.\n\n    :attr:`value` is an :class:`~kivy.properties.AliasProperty` that\n    returns the value of the progress bar. If the value is < 0 or >\n    :attr:`max`, it will be normalized to those boundaries.\n\n    .. versionchanged:: 1.6.0\n        The value is now limited to between 0 and :attr:`max`.\n    '''\n\n    def get_norm_value(self):\n        d = self.max\n        if d == 0:\n            return 0\n        return self.value / float(d)\n\n    def set_norm_value(self, value):\n        self.value = value * self.max\n\n    value_normalized = AliasProperty(get_norm_value, set_norm_value,\n                                     bind=('value', 'max'), cache=True)\n    '''Normalized value inside the range 0-1::\n\n        >>> pb = ProgressBar(value=50, max=100)\n        >>> pb.value\n        50\n        >>> pb.value_normalized\n        0.5\n\n    :attr:`value_normalized` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    max = NumericProperty(100.)\n    '''Maximum value allowed for :attr:`value`.\n\n    :attr:`max` is a :class:`~kivy.properties.NumericProperty` and defaults to\n    100.\n    '''",
  "def __init__(self, **kwargs):\n        self._value = 0.\n        super(ProgressBar, self).__init__(**kwargs)",
  "def _get_value(self):\n        return self._value",
  "def _set_value(self, value):\n        value = max(0, min(self.max, value))\n        if value != self._value:\n            self._value = value\n            return True",
  "def get_norm_value(self):\n        d = self.max\n        if d == 0:\n            return 0\n        return self.value / float(d)",
  "def set_norm_value(self, value):\n        self.value = value * self.max",
  "class SplitterStrip(Button):\n    '''Class used for the graphical representation of a\n    :class:`kivy.uix.splitter.SplitterStripe`.\n    '''\n    pass",
  "class Splitter(BoxLayout):\n    '''See module documentation.\n\n    :Events:\n        `on_press`:\n            Fired when the splitter is pressed.\n        `on_release`:\n            Fired when the splitter is released.\n\n    .. versionchanged:: 1.6.0\n        Added `on_press` and `on_release` events.\n\n    '''\n\n    border = ListProperty([4, 4, 4, 4])\n    '''Border used for the\n    :class:`~kivy.graphics.vertex_instructions.BorderImage`\n    graphics instruction.\n\n    This must be a list of four values: (bottom, right, top, left).\n    Read the BorderImage instructions for more information about how\n    to use it.\n\n    :attr:`border` is a :class:`~kivy.properties.ListProperty` and\n    defaults to (4, 4, 4, 4).\n    '''\n\n    strip_cls = ObjectProperty(SplitterStrip)\n    '''Specifies the class of the resize Strip.\n\n    :attr:`strip_cls` is an :class:`kivy.properties.ObjectProperty` and\n    defaults to :class:`~kivy.uix.splitter.SplitterStrip`, which is of type\n    :class:`~kivy.uix.button.Button`.\n\n    .. versionchanged:: 1.8.0\n        If you set a string, the :class:`~kivy.factory.Factory` will be used to\n        resolve the class.\n\n    '''\n\n    sizable_from = OptionProperty('left', options=(\n        'left', 'right', 'top', 'bottom'))\n    '''Specifies whether the widget is resizable. Options are:\n    `left`, `right`, `top` or `bottom`\n\n    :attr:`sizable_from` is an :class:`~kivy.properties.OptionProperty`\n    and defaults to `left`.\n    '''\n\n    strip_size = NumericProperty('10pt')\n    '''Specifies the size of resize strip\n\n    :attr:`strp_size` is a :class:`~kivy.properties.NumericProperty`\n    defaults to `10pt`\n    '''\n\n    min_size = NumericProperty('100pt')\n    '''Specifies the minimum size beyond which the widget is not resizable.\n\n    :attr:`min_size` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to `100pt`.\n    '''\n\n    max_size = NumericProperty('500pt')\n    '''Specifies the maximum size beyond which the widget is not resizable.\n\n    :attr:`max_size` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to `500pt`.\n    '''\n\n    _parent_proportion = NumericProperty(0.)\n    '''(internal) Specifies the distance that the slider has travelled\n    across its parent, used to automatically maintain a sensible\n    position if the parent is resized.\n\n    :attr:`_parent_proportion` is a\n    :class:`~kivy.properties.NumericProperty` and defaults to 0.\n\n    .. versionadded:: 1.9.0\n    '''\n\n    _bound_parent = ObjectProperty(None, allownone=True)\n    '''(internal) References the widget whose size is currently being\n    tracked by :attr:`_parent_proportion`.\n\n    :attr:`_bound_parent` is a\n    :class:`~kivy.properties.ObjectProperty` and defaults to None.\n\n    .. versionadded:: 1.9.0\n    '''\n\n    keep_within_parent = BooleanProperty(False)\n    '''If True, will limit the splitter to stay within its parent widget.\n\n    :attr:`keep_within_parent` is a\n    :class:`~kivy.properties.BooleanProperty` and defaults to False.\n\n    .. versionadded:: 1.9.0\n    '''\n\n    rescale_with_parent = BooleanProperty(False)\n    '''If True, will automatically change size to take up the same\n    proportion of the parent widget when it is resized, while\n    staying within :attr:`min_size` and :attr:`max_size`. As long as\n    these attributes can be satisfied, this stops the\n    :class:`Splitter` from exceeding the parent size during rescaling.\n\n    :attr:`rescale_with_parent` is a\n    :class:`~kivy.properties.BooleanProperty` and defaults to False.\n\n    .. versionadded:: 1.9.0\n    '''\n\n    __events__ = ('on_press', 'on_release')\n\n    def __init__(self, **kwargs):\n        self._container = None\n        self._strip = None\n        super(Splitter, self).__init__(**kwargs)\n\n        do_size = self._do_size\n        fbind = self.fbind\n        fbind('max_size', do_size)\n        fbind('min_size', do_size)\n        fbind('parent', self._rebind_parent)\n\n    def on_sizable_from(self, instance, sizable_from):\n        if not instance._container:\n            return\n\n        sup = super(Splitter, instance)\n        _strp = instance._strip\n        if _strp:\n            # remove any previous binds\n            _strp.unbind(on_touch_down=instance.strip_down)\n            _strp.unbind(on_touch_move=instance.strip_move)\n            _strp.unbind(on_touch_up=instance.strip_up)\n            self.unbind(disabled=_strp.setter('disabled'))\n\n            sup.remove_widget(instance._strip)\n\n        cls = instance.strip_cls\n        if not isinstance(_strp, cls):\n            if isinstance(cls, str):\n                cls = Factory.get(cls)\n            instance._strip = _strp = cls()\n\n        sz_frm = instance.sizable_from[0]\n        if sz_frm in ('l', 'r'):\n            _strp.size_hint = None, 1\n            _strp.width = instance.strip_size\n            instance.orientation = 'horizontal'\n            instance.unbind(strip_size=_strp.setter('width'))\n            instance.bind(strip_size=_strp.setter('width'))\n        else:\n            _strp.size_hint = 1, None\n            _strp.height = instance.strip_size\n            instance.orientation = 'vertical'\n            instance.unbind(strip_size=_strp.setter('height'))\n            instance.bind(strip_size=_strp.setter('height'))\n\n        index = 1\n        if sz_frm in ('r', 'b'):\n            index = 0\n        sup.add_widget(_strp, index)\n\n        _strp.bind(on_touch_down=instance.strip_down)\n        _strp.bind(on_touch_move=instance.strip_move)\n        _strp.bind(on_touch_up=instance.strip_up)\n        _strp.disabled = self.disabled\n        self.bind(disabled=_strp.setter('disabled'))\n\n    def add_widget(self, widget, index=0, *args, **kwargs):\n        if self._container or not widget:\n            return Exception('Splitter accepts only one Child')\n        self._container = widget\n        sz_frm = self.sizable_from[0]\n        if sz_frm in ('l', 'r'):\n            widget.size_hint_x = 1\n        else:\n            widget.size_hint_y = 1\n\n        index = 0\n        if sz_frm in ('r', 'b'):\n            index = 1\n        super(Splitter, self).add_widget(widget, index, *args, **kwargs)\n        self.on_sizable_from(self, self.sizable_from)\n\n    def remove_widget(self, widget, *args, **kwargs):\n        super(Splitter, self).remove_widget(widget, *args, **kwargs)\n        if widget == self._container:\n            self._container = None\n\n    def clear_widgets(self, *args, **kwargs):\n        self.remove_widget(self._container)\n\n    def strip_down(self, instance, touch):\n        if not instance.collide_point(*touch.pos):\n            return False\n        touch.grab(self)\n        self.dispatch('on_press')\n\n    def on_press(self):\n        pass\n\n    def _rebind_parent(self, instance, new_parent):\n        if self._bound_parent is not None:\n            self._bound_parent.unbind(size=self.rescale_parent_proportion)\n        if self.parent is not None:\n            new_parent.bind(size=self.rescale_parent_proportion)\n        self._bound_parent = new_parent\n        self.rescale_parent_proportion()\n\n    def rescale_parent_proportion(self, *args):\n        if not self.parent:\n            return\n        if self.rescale_with_parent:\n            parent_proportion = self._parent_proportion\n            if self.sizable_from in ('top', 'bottom'):\n                new_height = parent_proportion * self.parent.height\n                self.height = max(self.min_size,\n                                 min(new_height, self.max_size))\n            else:\n                new_width = parent_proportion * self.parent.width\n                self.width = max(self.min_size, min(new_width, self.max_size))\n\n    def _do_size(self, instance, value):\n        if self.sizable_from[0] in ('l', 'r'):\n            self.width = max(self.min_size, min(self.width, self.max_size))\n        else:\n            self.height = max(self.min_size, min(self.height, self.max_size))\n\n    @staticmethod\n    def _is_moving(sz_frm, diff, pos, minpos, maxpos):\n        if sz_frm in ('l', 'b'):\n            cmp = minpos\n        else:\n            cmp = maxpos\n        if diff == 0:\n            return False\n        elif diff > 0 and pos <= cmp:\n            return False\n        elif diff < 0 and pos >= cmp:\n            return False\n        return True\n\n    def strip_move(self, instance, touch):\n        if touch.grab_current is not instance:\n            return False\n        max_size = self.max_size\n        min_size = self.min_size\n        sz_frm = self.sizable_from[0]\n\n        if sz_frm in ('t', 'b'):\n            diff_y = (touch.dy)\n            self_y = self.y\n            self_top = self.top\n            if not self._is_moving(sz_frm, diff_y, touch.y, self_y, self_top):\n                return\n            if self.keep_within_parent:\n                if sz_frm == 't' and (self_top + diff_y) > self.parent.top:\n                    diff_y = self.parent.top - self_top\n                elif sz_frm == 'b' and (self_y + diff_y) < self.parent.y:\n                    diff_y = self.parent.y - self_y\n            if sz_frm == 'b':\n                diff_y *= -1\n            if self.size_hint_y:\n                self.size_hint_y = None\n            if self.height > 0:\n                self.height += diff_y\n            else:\n                self.height = 1\n\n            height = self.height\n            self.height = max(min_size, min(height, max_size))\n\n            self._parent_proportion = self.height / self.parent.height\n        else:\n            diff_x = (touch.dx)\n            self_x = self.x\n            self_right = self.right\n            if not self._is_moving(sz_frm, diff_x, touch.x, self_x, self_right):\n                return\n            if self.keep_within_parent:\n                if sz_frm == 'l' and (self_x + diff_x) < self.parent.x:\n                    diff_x = self.parent.x - self_x\n                elif (sz_frm == 'r' and\n                      (self_right + diff_x) > self.parent.right):\n                    diff_x = self.parent.right - self_right\n            if sz_frm == 'l':\n                diff_x *= -1\n            if self.size_hint_x:\n                self.size_hint_x = None\n            if self.width > 0:\n                self.width += diff_x\n            else:\n                self.width = 1\n\n            width = self.width\n            self.width = max(min_size, min(width, max_size))\n\n            self._parent_proportion = self.width / self.parent.width\n\n    def strip_up(self, instance, touch):\n        if touch.grab_current is not instance:\n            return\n\n        if touch.is_double_tap:\n            max_size = self.max_size\n            min_size = self.min_size\n            sz_frm = self.sizable_from[0]\n            s = self.size\n\n            if sz_frm in ('t', 'b'):\n                if self.size_hint_y:\n                    self.size_hint_y = None\n                if s[1] - min_size <= max_size - s[1]:\n                    self.height = max_size\n                else:\n                    self.height = min_size\n            else:\n                if self.size_hint_x:\n                    self.size_hint_x = None\n                if s[0] - min_size <= max_size - s[0]:\n                    self.width = max_size\n                else:\n                    self.width = min_size\n        touch.ungrab(instance)\n        self.dispatch('on_release')\n\n    def on_release(self):\n        pass",
  "def __init__(self, **kwargs):\n        self._container = None\n        self._strip = None\n        super(Splitter, self).__init__(**kwargs)\n\n        do_size = self._do_size\n        fbind = self.fbind\n        fbind('max_size', do_size)\n        fbind('min_size', do_size)\n        fbind('parent', self._rebind_parent)",
  "def on_sizable_from(self, instance, sizable_from):\n        if not instance._container:\n            return\n\n        sup = super(Splitter, instance)\n        _strp = instance._strip\n        if _strp:\n            # remove any previous binds\n            _strp.unbind(on_touch_down=instance.strip_down)\n            _strp.unbind(on_touch_move=instance.strip_move)\n            _strp.unbind(on_touch_up=instance.strip_up)\n            self.unbind(disabled=_strp.setter('disabled'))\n\n            sup.remove_widget(instance._strip)\n\n        cls = instance.strip_cls\n        if not isinstance(_strp, cls):\n            if isinstance(cls, str):\n                cls = Factory.get(cls)\n            instance._strip = _strp = cls()\n\n        sz_frm = instance.sizable_from[0]\n        if sz_frm in ('l', 'r'):\n            _strp.size_hint = None, 1\n            _strp.width = instance.strip_size\n            instance.orientation = 'horizontal'\n            instance.unbind(strip_size=_strp.setter('width'))\n            instance.bind(strip_size=_strp.setter('width'))\n        else:\n            _strp.size_hint = 1, None\n            _strp.height = instance.strip_size\n            instance.orientation = 'vertical'\n            instance.unbind(strip_size=_strp.setter('height'))\n            instance.bind(strip_size=_strp.setter('height'))\n\n        index = 1\n        if sz_frm in ('r', 'b'):\n            index = 0\n        sup.add_widget(_strp, index)\n\n        _strp.bind(on_touch_down=instance.strip_down)\n        _strp.bind(on_touch_move=instance.strip_move)\n        _strp.bind(on_touch_up=instance.strip_up)\n        _strp.disabled = self.disabled\n        self.bind(disabled=_strp.setter('disabled'))",
  "def add_widget(self, widget, index=0, *args, **kwargs):\n        if self._container or not widget:\n            return Exception('Splitter accepts only one Child')\n        self._container = widget\n        sz_frm = self.sizable_from[0]\n        if sz_frm in ('l', 'r'):\n            widget.size_hint_x = 1\n        else:\n            widget.size_hint_y = 1\n\n        index = 0\n        if sz_frm in ('r', 'b'):\n            index = 1\n        super(Splitter, self).add_widget(widget, index, *args, **kwargs)\n        self.on_sizable_from(self, self.sizable_from)",
  "def remove_widget(self, widget, *args, **kwargs):\n        super(Splitter, self).remove_widget(widget, *args, **kwargs)\n        if widget == self._container:\n            self._container = None",
  "def clear_widgets(self, *args, **kwargs):\n        self.remove_widget(self._container)",
  "def strip_down(self, instance, touch):\n        if not instance.collide_point(*touch.pos):\n            return False\n        touch.grab(self)\n        self.dispatch('on_press')",
  "def on_press(self):\n        pass",
  "def _rebind_parent(self, instance, new_parent):\n        if self._bound_parent is not None:\n            self._bound_parent.unbind(size=self.rescale_parent_proportion)\n        if self.parent is not None:\n            new_parent.bind(size=self.rescale_parent_proportion)\n        self._bound_parent = new_parent\n        self.rescale_parent_proportion()",
  "def rescale_parent_proportion(self, *args):\n        if not self.parent:\n            return\n        if self.rescale_with_parent:\n            parent_proportion = self._parent_proportion\n            if self.sizable_from in ('top', 'bottom'):\n                new_height = parent_proportion * self.parent.height\n                self.height = max(self.min_size,\n                                 min(new_height, self.max_size))\n            else:\n                new_width = parent_proportion * self.parent.width\n                self.width = max(self.min_size, min(new_width, self.max_size))",
  "def _do_size(self, instance, value):\n        if self.sizable_from[0] in ('l', 'r'):\n            self.width = max(self.min_size, min(self.width, self.max_size))\n        else:\n            self.height = max(self.min_size, min(self.height, self.max_size))",
  "def _is_moving(sz_frm, diff, pos, minpos, maxpos):\n        if sz_frm in ('l', 'b'):\n            cmp = minpos\n        else:\n            cmp = maxpos\n        if diff == 0:\n            return False\n        elif diff > 0 and pos <= cmp:\n            return False\n        elif diff < 0 and pos >= cmp:\n            return False\n        return True",
  "def strip_move(self, instance, touch):\n        if touch.grab_current is not instance:\n            return False\n        max_size = self.max_size\n        min_size = self.min_size\n        sz_frm = self.sizable_from[0]\n\n        if sz_frm in ('t', 'b'):\n            diff_y = (touch.dy)\n            self_y = self.y\n            self_top = self.top\n            if not self._is_moving(sz_frm, diff_y, touch.y, self_y, self_top):\n                return\n            if self.keep_within_parent:\n                if sz_frm == 't' and (self_top + diff_y) > self.parent.top:\n                    diff_y = self.parent.top - self_top\n                elif sz_frm == 'b' and (self_y + diff_y) < self.parent.y:\n                    diff_y = self.parent.y - self_y\n            if sz_frm == 'b':\n                diff_y *= -1\n            if self.size_hint_y:\n                self.size_hint_y = None\n            if self.height > 0:\n                self.height += diff_y\n            else:\n                self.height = 1\n\n            height = self.height\n            self.height = max(min_size, min(height, max_size))\n\n            self._parent_proportion = self.height / self.parent.height\n        else:\n            diff_x = (touch.dx)\n            self_x = self.x\n            self_right = self.right\n            if not self._is_moving(sz_frm, diff_x, touch.x, self_x, self_right):\n                return\n            if self.keep_within_parent:\n                if sz_frm == 'l' and (self_x + diff_x) < self.parent.x:\n                    diff_x = self.parent.x - self_x\n                elif (sz_frm == 'r' and\n                      (self_right + diff_x) > self.parent.right):\n                    diff_x = self.parent.right - self_right\n            if sz_frm == 'l':\n                diff_x *= -1\n            if self.size_hint_x:\n                self.size_hint_x = None\n            if self.width > 0:\n                self.width += diff_x\n            else:\n                self.width = 1\n\n            width = self.width\n            self.width = max(min_size, min(width, max_size))\n\n            self._parent_proportion = self.width / self.parent.width",
  "def strip_up(self, instance, touch):\n        if touch.grab_current is not instance:\n            return\n\n        if touch.is_double_tap:\n            max_size = self.max_size\n            min_size = self.min_size\n            sz_frm = self.sizable_from[0]\n            s = self.size\n\n            if sz_frm in ('t', 'b'):\n                if self.size_hint_y:\n                    self.size_hint_y = None\n                if s[1] - min_size <= max_size - s[1]:\n                    self.height = max_size\n                else:\n                    self.height = min_size\n            else:\n                if self.size_hint_x:\n                    self.size_hint_x = None\n                if s[0] - min_size <= max_size - s[0]:\n                    self.width = max_size\n                else:\n                    self.width = min_size\n        touch.ungrab(instance)\n        self.dispatch('on_release')",
  "def on_release(self):\n        pass",
  "class SplitterApp(App):\n\n        def build(self):\n            root = FloatLayout()\n            bx = BoxLayout()\n            bx.add_widget(Button())\n            bx.add_widget(Button())\n            bx2 = BoxLayout()\n            bx2.add_widget(Button())\n            bx2.add_widget(Button())\n            bx2.add_widget(Button())\n            spl = Splitter(\n                size_hint=(1, .25),\n                pos_hint={'top': 1},\n                sizable_from='bottom')\n            spl1 = Splitter(\n                sizable_from='left',\n                size_hint=(None, 1), width=90)\n            spl1.add_widget(Button())\n            bx.add_widget(spl1)\n            spl.add_widget(bx)\n\n            spl2 = Splitter(size_hint=(.25, 1))\n            spl2.add_widget(bx2)\n            spl2.sizable_from = 'right'\n            root.add_widget(spl)\n            root.add_widget(spl2)\n            return root",
  "def build(self):\n            root = FloatLayout()\n            bx = BoxLayout()\n            bx.add_widget(Button())\n            bx.add_widget(Button())\n            bx2 = BoxLayout()\n            bx2.add_widget(Button())\n            bx2.add_widget(Button())\n            bx2.add_widget(Button())\n            spl = Splitter(\n                size_hint=(1, .25),\n                pos_hint={'top': 1},\n                sizable_from='bottom')\n            spl1 = Splitter(\n                sizable_from='left',\n                size_hint=(None, 1), width=90)\n            spl1.add_widget(Button())\n            bx.add_widget(spl1)\n            spl.add_widget(bx)\n\n            spl2 = Splitter(size_hint=(.25, 1))\n            spl2.add_widget(bx2)\n            spl2.sizable_from = 'right'\n            root.add_widget(spl)\n            root.add_widget(spl2)\n            return root",
  "class PopupException(Exception):\n    '''Popup exception, fired when multiple content widgets are added to the\n    popup.\n\n    .. versionadded:: 1.4.0\n    '''",
  "class Popup(ModalView):\n    '''Popup class. See module documentation for more information.\n\n    :Events:\n        `on_open`:\n            Fired when the Popup is opened.\n        `on_dismiss`:\n            Fired when the Popup is closed. If the callback returns True, the\n            dismiss will be canceled.\n    '''\n\n    title = StringProperty('No title')\n    '''String that represents the title of the popup.\n\n    :attr:`title` is a :class:`~kivy.properties.StringProperty` and defaults to\n    'No title'.\n    '''\n\n    title_size = NumericProperty('14sp')\n    '''Represents the font size of the popup title.\n\n    .. versionadded:: 1.6.0\n\n    :attr:`title_size` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to '14sp'.\n    '''\n\n    title_align = OptionProperty(\n        'left', options=['left', 'center', 'right', 'justify'])\n    '''Horizontal alignment of the title.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`title_align` is a :class:`~kivy.properties.OptionProperty` and\n    defaults to 'left'. Available options are left, center, right and justify.\n    '''\n\n    title_font = StringProperty(DEFAULT_FONT)\n    '''Font used to render the title text.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`title_font` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'Roboto'. This value is taken\n    from :class:`~kivy.config.Config`.\n    '''\n\n    content = ObjectProperty(None)\n    '''Content of the popup that is displayed just under the title.\n\n    :attr:`content` is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    title_color = ColorProperty([1, 1, 1, 1])\n    '''Color used by the Title.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`title_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    separator_color = ColorProperty([47 / 255., 167 / 255., 212 / 255., 1.])\n    '''Color used by the separator between title and content.\n\n    .. versionadded:: 1.1.0\n\n    :attr:`separator_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [47 / 255., 167 / 255., 212 / 255., 1.].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    separator_height = NumericProperty('2dp')\n    '''Height of the separator.\n\n    .. versionadded:: 1.1.0\n\n    :attr:`separator_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 2dp.\n    '''\n\n    # Internal properties used for graphical representation.\n\n    _container = ObjectProperty(None)\n\n    def add_widget(self, widget, *args, **kwargs):\n        if self._container:\n            if self.content:\n                raise PopupException(\n                    'Popup can have only one widget as content')\n            self.content = widget\n        else:\n            super(Popup, self).add_widget(widget, *args, **kwargs)\n\n    def on_content(self, instance, value):\n        if self._container:\n            self._container.clear_widgets()\n            self._container.add_widget(value)\n\n    def on__container(self, instance, value):\n        if value is None or self.content is None:\n            return\n        self._container.clear_widgets()\n        self._container.add_widget(self.content)\n\n    def on_touch_down(self, touch):\n        if self.disabled and self.collide_point(*touch.pos):\n            return True\n        return super(Popup, self).on_touch_down(touch)",
  "def add_widget(self, widget, *args, **kwargs):\n        if self._container:\n            if self.content:\n                raise PopupException(\n                    'Popup can have only one widget as content')\n            self.content = widget\n        else:\n            super(Popup, self).add_widget(widget, *args, **kwargs)",
  "def on_content(self, instance, value):\n        if self._container:\n            self._container.clear_widgets()\n            self._container.add_widget(value)",
  "def on__container(self, instance, value):\n        if value is None or self.content is None:\n            return\n        self._container.clear_widgets()\n        self._container.add_widget(self.content)",
  "def on_touch_down(self, touch):\n        if self.disabled and self.collide_point(*touch.pos):\n            return True\n        return super(Popup, self).on_touch_down(touch)",
  "class Button(ButtonBehavior, Label):\n    '''Button class, see module documentation for more information.\n\n    .. versionchanged:: 1.8.0\n        The behavior / logic of the button has been moved to\n        :class:`~kivy.uix.behaviors.ButtonBehaviors`.\n\n    '''\n\n    background_color = ColorProperty([1, 1, 1, 1])\n    '''Background color, in the format (r, g, b, a).\n\n    This acts as a *multiplier* to the texture color. The default\n    texture is grey, so just setting the background color will give\n    a darker result. To set a plain color, set the\n    :attr:`background_normal` to ``''``.\n\n    .. versionadded:: 1.0.8\n\n    The :attr:`background_color` is a\n    :class:`~kivy.properties.ColorProperty` and defaults to [1, 1, 1, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    background_normal = StringProperty(\n        'atlas://data/images/defaulttheme/button')\n    '''Background image of the button used for the default graphical\n    representation when the button is not pressed.\n\n    .. versionadded:: 1.0.4\n\n    :attr:`background_normal` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/button'.\n    '''\n\n    background_down = StringProperty(\n        'atlas://data/images/defaulttheme/button_pressed')\n    '''Background image of the button used for the default graphical\n    representation when the button is pressed.\n\n    .. versionadded:: 1.0.4\n\n    :attr:`background_down` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/button_pressed'.\n    '''\n\n    background_disabled_normal = StringProperty(\n        'atlas://data/images/defaulttheme/button_disabled')\n    '''Background image of the button used for the default graphical\n    representation when the button is disabled and not pressed.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`background_disabled_normal` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/button_disabled'.\n    '''\n\n    background_disabled_down = StringProperty(\n        'atlas://data/images/defaulttheme/button_disabled_pressed')\n    '''Background image of the button used for the default graphical\n    representation when the button is disabled and pressed.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`background_disabled_down` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/button_disabled_pressed'.\n    '''\n\n    border = ListProperty([16, 16, 16, 16])\n    '''Border used for :class:`~kivy.graphics.vertex_instructions.BorderImage`\n    graphics instruction. Used with :attr:`background_normal` and\n    :attr:`background_down`. Can be used for custom backgrounds.\n\n    It must be a list of four values: (bottom, right, top, left). Read the\n    BorderImage instruction for more information about how to use it.\n\n    :attr:`border` is a :class:`~kivy.properties.ListProperty` and defaults to\n    (16, 16, 16, 16)\n    '''",
  "class BoxLayout(Layout):\n    '''Box layout class. See module documentation for more information.\n    '''\n\n    spacing = NumericProperty(0)\n    '''Spacing between children, in pixels.\n\n    :attr:`spacing` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 0.\n    '''\n\n    padding = VariableListProperty([0, 0, 0, 0])\n    '''Padding between layout box and children: [padding_left, padding_top,\n    padding_right, padding_bottom].\n\n    padding also accepts a two argument form [padding_horizontal,\n    padding_vertical] and a one argument form [padding].\n\n    .. versionchanged:: 1.7.0\n        Replaced NumericProperty with VariableListProperty.\n\n    :attr:`padding` is a :class:`~kivy.properties.VariableListProperty` and\n    defaults to [0, 0, 0, 0].\n    '''\n\n    orientation = OptionProperty('horizontal', options=(\n        'horizontal', 'vertical'))\n    '''Orientation of the layout.\n\n    :attr:`orientation` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'horizontal'. Can be 'vertical' or 'horizontal'.\n    '''\n\n    minimum_width = NumericProperty(0)\n    '''Automatically computed minimum width needed to contain all children.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`minimum_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0. It is read only.\n    '''\n\n    minimum_height = NumericProperty(0)\n    '''Automatically computed minimum height needed to contain all children.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`minimum_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0. It is read only.\n    '''\n\n    minimum_size = ReferenceListProperty(minimum_width, minimum_height)\n    '''Automatically computed minimum size needed to contain all children.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`minimum_size` is a\n    :class:`~kivy.properties.ReferenceListProperty` of\n    (:attr:`minimum_width`, :attr:`minimum_height`) properties. It is read\n    only.\n    '''\n\n    def __init__(self, **kwargs):\n        super(BoxLayout, self).__init__(**kwargs)\n        update = self._trigger_layout\n        fbind = self.fbind\n        fbind('spacing', update)\n        fbind('padding', update)\n        fbind('children', update)\n        fbind('orientation', update)\n        fbind('parent', update)\n        fbind('size', update)\n        fbind('pos', update)\n\n    def _iterate_layout(self, sizes):\n        # optimize layout by preventing looking at the same attribute in a loop\n        len_children = len(sizes)\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n        spacing = self.spacing\n        orientation = self.orientation\n        padding_x = padding_left + padding_right\n        padding_y = padding_top + padding_bottom\n\n        # calculate maximum space used by size_hint\n        stretch_sum = 0.\n        has_bound = False\n        hint = [None] * len_children\n        # min size from all the None hint, and from those with sh_min\n        minimum_size_bounded = 0\n        if orientation == 'horizontal':\n            minimum_size_y = 0\n            minimum_size_none = padding_x + spacing * (len_children - 1)\n\n            for i, ((w, h), (shw, shh), _, (shw_min, shh_min),\n                    (shw_max, _)) in enumerate(sizes):\n                if shw is None:\n                    minimum_size_none += w\n                else:\n                    hint[i] = shw\n                    if shw_min:\n                        has_bound = True\n                        minimum_size_bounded += shw_min\n                    elif shw_max is not None:\n                        has_bound = True\n                    stretch_sum += shw\n\n                if shh is None:\n                    minimum_size_y = max(minimum_size_y, h)\n                elif shh_min:\n                    minimum_size_y = max(minimum_size_y, shh_min)\n\n            minimum_size_x = minimum_size_bounded + minimum_size_none\n            minimum_size_y += padding_y\n        else:\n            minimum_size_x = 0\n            minimum_size_none = padding_y + spacing * (len_children - 1)\n\n            for i, ((w, h), (shw, shh), _, (shw_min, shh_min),\n                    (_, shh_max)) in enumerate(sizes):\n                if shh is None:\n                    minimum_size_none += h\n                else:\n                    hint[i] = shh\n                    if shh_min:\n                        has_bound = True\n                        minimum_size_bounded += shh_min\n                    elif shh_max is not None:\n                        has_bound = True\n                    stretch_sum += shh\n\n                if shw is None:\n                    minimum_size_x = max(minimum_size_x, w)\n                elif shw_min:\n                    minimum_size_x = max(minimum_size_x, shw_min)\n\n            minimum_size_y = minimum_size_bounded + minimum_size_none\n            minimum_size_x += padding_x\n\n        self.minimum_size = minimum_size_x, minimum_size_y\n        # do not move the w/h get above, it's likely to change on above line\n        selfx = self.x\n        selfy = self.y\n\n        if orientation == 'horizontal':\n            stretch_space = max(0.0, self.width - minimum_size_none)\n            dim = 0\n        else:\n            stretch_space = max(0.0, self.height - minimum_size_none)\n            dim = 1\n\n        if has_bound:\n            # make sure the size_hint_min/max are not violated\n            if stretch_space < 1e-9:\n                # there's no space, so just set to min size or zero\n                stretch_sum = stretch_space = 1.\n\n                for i, val in enumerate(sizes):\n                    sh = val[1][dim]\n                    if sh is None:\n                        continue\n\n                    sh_min = val[3][dim]\n                    if sh_min is not None:\n                        hint[i] = sh_min\n                    else:\n                        hint[i] = 0.  # everything else is zero\n            else:\n                # hint gets updated in place\n                self.layout_hint_with_bounds(\n                    stretch_sum, stretch_space, minimum_size_bounded,\n                    (val[3][dim] for val in sizes),\n                    (elem[4][dim] for elem in sizes), hint)\n\n        if orientation == 'horizontal':\n            x = padding_left + selfx\n            size_y = self.height - padding_y\n            for i, (sh, ((w, h), (_, shh), pos_hint, _, _)) in enumerate(\n                    zip(reversed(hint), reversed(sizes))):\n                cy = selfy + padding_bottom\n\n                if sh:\n                    w = max(0., stretch_space * sh / stretch_sum)\n                if shh:\n                    h = max(0, shh * size_y)\n\n                for key, value in pos_hint.items():\n                    posy = value * size_y\n                    if key == 'y':\n                        cy += posy\n                    elif key == 'top':\n                        cy += posy - h\n                    elif key == 'center_y':\n                        cy += posy - (h / 2.)\n\n                yield len_children - i - 1, x, cy, w, h\n                x += w + spacing\n\n        else:\n            y = padding_bottom + selfy\n            size_x = self.width - padding_x\n            for i, (sh, ((w, h), (shw, _), pos_hint, _, _)) in enumerate(\n                    zip(hint, sizes)):\n                cx = selfx + padding_left\n\n                if sh:\n                    h = max(0., stretch_space * sh / stretch_sum)\n                if shw:\n                    w = max(0, shw * size_x)\n\n                for key, value in pos_hint.items():\n                    posx = value * size_x\n                    if key == 'x':\n                        cx += posx\n                    elif key == 'right':\n                        cx += posx - w\n                    elif key == 'center_x':\n                        cx += posx - (w / 2.)\n\n                yield i, cx, y, w, h\n                y += h + spacing\n\n    def do_layout(self, *largs):\n        children = self.children\n        if not children:\n            l, t, r, b = self.padding\n            self.minimum_size = l + r, t + b\n            return\n\n        for i, x, y, w, h in self._iterate_layout(\n                [(c.size, c.size_hint, c.pos_hint, c.size_hint_min,\n                  c.size_hint_max) for c in children]):\n            c = children[i]\n            c.pos = x, y\n            shw, shh = c.size_hint\n            if shw is None:\n                if shh is not None:\n                    c.height = h\n            else:\n                if shh is None:\n                    c.width = w\n                else:\n                    c.size = (w, h)\n\n    def add_widget(self, widget, *args, **kwargs):\n        widget.fbind('pos_hint', self._trigger_layout)\n        return super(BoxLayout, self).add_widget(widget, *args, **kwargs)\n\n    def remove_widget(self, widget, *args, **kwargs):\n        widget.funbind('pos_hint', self._trigger_layout)\n        return super(BoxLayout, self).remove_widget(widget, *args, **kwargs)",
  "def __init__(self, **kwargs):\n        super(BoxLayout, self).__init__(**kwargs)\n        update = self._trigger_layout\n        fbind = self.fbind\n        fbind('spacing', update)\n        fbind('padding', update)\n        fbind('children', update)\n        fbind('orientation', update)\n        fbind('parent', update)\n        fbind('size', update)\n        fbind('pos', update)",
  "def _iterate_layout(self, sizes):\n        # optimize layout by preventing looking at the same attribute in a loop\n        len_children = len(sizes)\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n        spacing = self.spacing\n        orientation = self.orientation\n        padding_x = padding_left + padding_right\n        padding_y = padding_top + padding_bottom\n\n        # calculate maximum space used by size_hint\n        stretch_sum = 0.\n        has_bound = False\n        hint = [None] * len_children\n        # min size from all the None hint, and from those with sh_min\n        minimum_size_bounded = 0\n        if orientation == 'horizontal':\n            minimum_size_y = 0\n            minimum_size_none = padding_x + spacing * (len_children - 1)\n\n            for i, ((w, h), (shw, shh), _, (shw_min, shh_min),\n                    (shw_max, _)) in enumerate(sizes):\n                if shw is None:\n                    minimum_size_none += w\n                else:\n                    hint[i] = shw\n                    if shw_min:\n                        has_bound = True\n                        minimum_size_bounded += shw_min\n                    elif shw_max is not None:\n                        has_bound = True\n                    stretch_sum += shw\n\n                if shh is None:\n                    minimum_size_y = max(minimum_size_y, h)\n                elif shh_min:\n                    minimum_size_y = max(minimum_size_y, shh_min)\n\n            minimum_size_x = minimum_size_bounded + minimum_size_none\n            minimum_size_y += padding_y\n        else:\n            minimum_size_x = 0\n            minimum_size_none = padding_y + spacing * (len_children - 1)\n\n            for i, ((w, h), (shw, shh), _, (shw_min, shh_min),\n                    (_, shh_max)) in enumerate(sizes):\n                if shh is None:\n                    minimum_size_none += h\n                else:\n                    hint[i] = shh\n                    if shh_min:\n                        has_bound = True\n                        minimum_size_bounded += shh_min\n                    elif shh_max is not None:\n                        has_bound = True\n                    stretch_sum += shh\n\n                if shw is None:\n                    minimum_size_x = max(minimum_size_x, w)\n                elif shw_min:\n                    minimum_size_x = max(minimum_size_x, shw_min)\n\n            minimum_size_y = minimum_size_bounded + minimum_size_none\n            minimum_size_x += padding_x\n\n        self.minimum_size = minimum_size_x, minimum_size_y\n        # do not move the w/h get above, it's likely to change on above line\n        selfx = self.x\n        selfy = self.y\n\n        if orientation == 'horizontal':\n            stretch_space = max(0.0, self.width - minimum_size_none)\n            dim = 0\n        else:\n            stretch_space = max(0.0, self.height - minimum_size_none)\n            dim = 1\n\n        if has_bound:\n            # make sure the size_hint_min/max are not violated\n            if stretch_space < 1e-9:\n                # there's no space, so just set to min size or zero\n                stretch_sum = stretch_space = 1.\n\n                for i, val in enumerate(sizes):\n                    sh = val[1][dim]\n                    if sh is None:\n                        continue\n\n                    sh_min = val[3][dim]\n                    if sh_min is not None:\n                        hint[i] = sh_min\n                    else:\n                        hint[i] = 0.  # everything else is zero\n            else:\n                # hint gets updated in place\n                self.layout_hint_with_bounds(\n                    stretch_sum, stretch_space, minimum_size_bounded,\n                    (val[3][dim] for val in sizes),\n                    (elem[4][dim] for elem in sizes), hint)\n\n        if orientation == 'horizontal':\n            x = padding_left + selfx\n            size_y = self.height - padding_y\n            for i, (sh, ((w, h), (_, shh), pos_hint, _, _)) in enumerate(\n                    zip(reversed(hint), reversed(sizes))):\n                cy = selfy + padding_bottom\n\n                if sh:\n                    w = max(0., stretch_space * sh / stretch_sum)\n                if shh:\n                    h = max(0, shh * size_y)\n\n                for key, value in pos_hint.items():\n                    posy = value * size_y\n                    if key == 'y':\n                        cy += posy\n                    elif key == 'top':\n                        cy += posy - h\n                    elif key == 'center_y':\n                        cy += posy - (h / 2.)\n\n                yield len_children - i - 1, x, cy, w, h\n                x += w + spacing\n\n        else:\n            y = padding_bottom + selfy\n            size_x = self.width - padding_x\n            for i, (sh, ((w, h), (shw, _), pos_hint, _, _)) in enumerate(\n                    zip(hint, sizes)):\n                cx = selfx + padding_left\n\n                if sh:\n                    h = max(0., stretch_space * sh / stretch_sum)\n                if shw:\n                    w = max(0, shw * size_x)\n\n                for key, value in pos_hint.items():\n                    posx = value * size_x\n                    if key == 'x':\n                        cx += posx\n                    elif key == 'right':\n                        cx += posx - w\n                    elif key == 'center_x':\n                        cx += posx - (w / 2.)\n\n                yield i, cx, y, w, h\n                y += h + spacing",
  "def do_layout(self, *largs):\n        children = self.children\n        if not children:\n            l, t, r, b = self.padding\n            self.minimum_size = l + r, t + b\n            return\n\n        for i, x, y, w, h in self._iterate_layout(\n                [(c.size, c.size_hint, c.pos_hint, c.size_hint_min,\n                  c.size_hint_max) for c in children]):\n            c = children[i]\n            c.pos = x, y\n            shw, shh = c.size_hint\n            if shw is None:\n                if shh is not None:\n                    c.height = h\n            else:\n                if shh is None:\n                    c.width = w\n                else:\n                    c.size = (w, h)",
  "def add_widget(self, widget, *args, **kwargs):\n        widget.fbind('pos_hint', self._trigger_layout)\n        return super(BoxLayout, self).add_widget(widget, *args, **kwargs)",
  "def remove_widget(self, widget, *args, **kwargs):\n        widget.funbind('pos_hint', self._trigger_layout)\n        return super(BoxLayout, self).remove_widget(widget, *args, **kwargs)",
  "class ScreenManagerException(Exception):\n    '''Exception for the :class:`ScreenManager`.\n    '''\n    pass",
  "class Screen(RelativeLayout):\n    '''Screen is an element intended to be used with a :class:`ScreenManager`.\n    Check module documentation for more information.\n\n    :Events:\n        `on_pre_enter`: ()\n            Event fired when the screen is about to be used: the entering\n            animation is started.\n        `on_enter`: ()\n            Event fired when the screen is displayed: the entering animation is\n            complete.\n        `on_pre_leave`: ()\n            Event fired when the screen is about to be removed: the leaving\n            animation is started.\n        `on_leave`: ()\n            Event fired when the screen is removed: the leaving animation is\n            finished.\n\n    .. versionchanged:: 1.6.0\n        Events `on_pre_enter`, `on_enter`, `on_pre_leave` and `on_leave` were\n        added.\n    '''\n\n    name = StringProperty('')\n    '''\n    Name of the screen which must be unique within a :class:`ScreenManager`.\n    This is the name used for :attr:`ScreenManager.current`.\n\n    :attr:`name` is a :class:`~kivy.properties.StringProperty` and defaults to\n    ''.\n    '''\n\n    manager = ObjectProperty(None, allownone=True)\n    ''':class:`ScreenManager` object, set when the screen is added to a\n    manager.\n\n    :attr:`manager` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None, read-only.\n\n    '''\n\n    transition_progress = NumericProperty(0.)\n    '''Value that represents the completion of the current transition, if any\n    is occurring.\n\n    If a transition is in progress, whatever the mode, the value will change\n    from 0 to 1. If you want to know if it's an entering or leaving animation,\n    check the :attr:`transition_state`.\n\n    :attr:`transition_progress` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 0.\n    '''\n\n    transition_state = OptionProperty('out', options=('in', 'out'))\n    '''Value that represents the state of the transition:\n\n    - 'in' if the transition is going to show your screen\n    - 'out' if the transition is going to hide your screen\n\n    After the transition is complete, the state will retain its last value (in\n    or out).\n\n    :attr:`transition_state` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'out'.\n    '''\n\n    __events__ = ('on_pre_enter', 'on_enter', 'on_pre_leave', 'on_leave')\n\n    def on_pre_enter(self, *args):\n        pass\n\n    def on_enter(self, *args):\n        pass\n\n    def on_pre_leave(self, *args):\n        pass\n\n    def on_leave(self, *args):\n        pass\n\n    def __repr__(self):\n        return '<Screen name=%r>' % self.name",
  "class TransitionBase(EventDispatcher):\n    '''TransitionBase is used to animate 2 screens within the\n    :class:`ScreenManager`. This class acts as a base for other\n    implementations like the :class:`SlideTransition` and\n    :class:`SwapTransition`.\n\n    :Events:\n        `on_progress`: Transition object, progression float\n            Fired during the animation of the transition.\n        `on_complete`: Transition object\n            Fired when the transition is finished.\n    '''\n\n    screen_out = ObjectProperty()\n    '''Property that contains the screen to hide.\n    Automatically set by the :class:`ScreenManager`.\n\n    :class:`screen_out` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    screen_in = ObjectProperty()\n    '''Property that contains the screen to show.\n    Automatically set by the :class:`ScreenManager`.\n\n    :class:`screen_in` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    duration = NumericProperty(.4)\n    '''Duration in seconds of the transition.\n\n    :class:`duration` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to .4 (= 400ms).\n\n    .. versionchanged:: 1.8.0\n\n        Default duration has been changed from 700ms to 400ms.\n    '''\n\n    manager = ObjectProperty()\n    ''':class:`ScreenManager` object, set when the screen is added to a\n    manager.\n\n    :attr:`manager` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None, read-only.\n\n    '''\n\n    is_active = BooleanProperty(False)\n    '''Indicate whether the transition is currently active or not.\n\n    :attr:`is_active` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False, read-only.\n    '''\n\n    # privates\n\n    _anim = ObjectProperty(allownone=True)\n\n    __events__ = ('on_progress', 'on_complete')\n\n    def start(self, manager):\n        '''(internal) Starts the transition. This is automatically\n        called by the :class:`ScreenManager`.\n        '''\n        if self.is_active:\n            raise ScreenManagerException('start() is called twice!')\n        self.manager = manager\n        self._anim = Animation(d=self.duration, s=0)\n        self._anim.bind(on_progress=self._on_progress,\n                        on_complete=self._on_complete)\n\n        self.add_screen(self.screen_in)\n        self.screen_in.transition_progress = 0.\n        self.screen_in.transition_state = 'in'\n        self.screen_out.transition_progress = 0.\n        self.screen_out.transition_state = 'out'\n        self.screen_in.dispatch('on_pre_enter')\n        self.screen_out.dispatch('on_pre_leave')\n\n        self.is_active = True\n        self._anim.start(self)\n        self.dispatch('on_progress', 0)\n\n    def stop(self):\n        '''(internal) Stops the transition. This is automatically called by the\n        :class:`ScreenManager`.\n        '''\n        if self._anim:\n            self._anim.cancel(self)\n            self.dispatch('on_complete')\n            self._anim = None\n        self.is_active = False\n\n    def add_screen(self, screen):\n        '''(internal) Used to add a screen to the :class:`ScreenManager`.\n        '''\n        self.manager.real_add_widget(screen)\n\n    def remove_screen(self, screen):\n        '''(internal) Used to remove a screen from the :class:`ScreenManager`.\n        '''\n        self.manager.real_remove_widget(screen)\n\n    def on_complete(self):\n        self.remove_screen(self.screen_out)\n\n    def on_progress(self, progression):\n        pass\n\n    def _on_progress(self, *l):\n        progress = l[-1]\n        self.screen_in.transition_progress = progress\n        self.screen_out.transition_progress = 1. - progress\n        self.dispatch('on_progress', progress)\n\n    def _on_complete(self, *l):\n        self.is_active = False\n        self.dispatch('on_complete')\n        self.screen_in.dispatch('on_enter')\n        self.screen_out.dispatch('on_leave')\n        self._anim = None",
  "class ShaderTransition(TransitionBase):\n    '''Transition class that uses a Shader for animating the transition between\n    2 screens. By default, this class doesn't assign any fragment/vertex\n    shader. If you want to create your own fragment shader for the transition,\n    you need to declare the header yourself and include the \"t\", \"tex_in\" and\n    \"tex_out\" uniform::\n\n        # Create your own transition. This shader implements a \"fading\"\n        # transition.\n        fs = \"\"\"$HEADER\n            uniform float t;\n            uniform sampler2D tex_in;\n            uniform sampler2D tex_out;\n\n            void main(void) {\n                vec4 cin = texture2D(tex_in, tex_coord0);\n                vec4 cout = texture2D(tex_out, tex_coord0);\n                gl_FragColor = mix(cout, cin, t);\n            }\n        \"\"\"\n\n        # And create your transition\n        tr = ShaderTransition(fs=fs)\n        sm = ScreenManager(transition=tr)\n\n    '''\n\n    fs = StringProperty(None)\n    '''Fragment shader to use.\n\n    :attr:`fs` is a :class:`~kivy.properties.StringProperty` and defaults to\n    None.'''\n\n    vs = StringProperty(None)\n    '''Vertex shader to use.\n\n    :attr:`vs` is a :class:`~kivy.properties.StringProperty` and defaults to\n    None.'''\n\n    clearcolor = ColorProperty([0, 0, 0, 1])\n    '''Sets the color of Fbo ClearColor.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`clearcolor` is a :class:`~kivy.properties.ColorProperty`\n    and defaults to [0, 0, 0, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    def make_screen_fbo(self, screen):\n        fbo = Fbo(size=screen.size, with_stencilbuffer=True)\n        with fbo:\n            ClearColor(*self.clearcolor)\n            ClearBuffers()\n        fbo.add(screen.canvas)\n        with fbo.before:\n            PushMatrix()\n            Translate(-screen.x, -screen.y, 0)\n        with fbo.after:\n            PopMatrix()\n        return fbo\n\n    def on_progress(self, progress):\n        self.render_ctx['t'] = progress\n\n    def on_complete(self):\n        self.render_ctx['t'] = 1.\n        super(ShaderTransition, self).on_complete()\n\n    def _remove_out_canvas(self, *args):\n        if (self.screen_out and\n                self.screen_out.canvas in self.manager.canvas.children and\n                self.screen_out not in self.manager.children):\n            self.manager.canvas.remove(self.screen_out.canvas)\n\n    def add_screen(self, screen):\n        self.screen_in.pos = self.screen_out.pos\n        self.screen_in.size = self.screen_out.size\n        self.manager.real_remove_widget(self.screen_out)\n        self.manager.canvas.add(self.screen_out.canvas)\n\n        def remove_screen_out(instr):\n            Clock.schedule_once(self._remove_out_canvas, -1)\n            self.render_ctx.remove(instr)\n\n        self.fbo_in = self.make_screen_fbo(self.screen_in)\n        self.fbo_out = self.make_screen_fbo(self.screen_out)\n        self.manager.canvas.add(self.fbo_in)\n        self.manager.canvas.add(self.fbo_out)\n\n        self.render_ctx = RenderContext(fs=self.fs, vs=self.vs,\n                                        use_parent_modelview=True,\n                                        use_parent_projection=True)\n        with self.render_ctx:\n            BindTexture(texture=self.fbo_out.texture, index=1)\n            BindTexture(texture=self.fbo_in.texture, index=2)\n            x, y = self.screen_in.pos\n            w, h = self.fbo_in.texture.size\n            Rectangle(size=(w, h), pos=(x, y),\n                      tex_coords=self.fbo_in.texture.tex_coords)\n            Callback(remove_screen_out)\n        self.render_ctx['tex_out'] = 1\n        self.render_ctx['tex_in'] = 2\n        self.manager.canvas.add(self.render_ctx)\n\n    def remove_screen(self, screen):\n        self.manager.canvas.remove(self.fbo_in)\n        self.manager.canvas.remove(self.fbo_out)\n        self.manager.canvas.remove(self.render_ctx)\n        self._remove_out_canvas()\n        self.manager.real_add_widget(self.screen_in)\n\n    def stop(self):\n        self._remove_out_canvas()\n        super(ShaderTransition, self).stop()",
  "class NoTransition(TransitionBase):\n    '''No transition, instantly switches to the next screen with no delay or\n    animation.\n\n    .. versionadded:: 1.8.0\n    '''\n\n    duration = NumericProperty(0.0)\n\n    def on_complete(self):\n        self.screen_in.pos = self.manager.pos\n        self.screen_out.pos = self.manager.pos\n        super(NoTransition, self).on_complete()",
  "class SlideTransition(TransitionBase):\n    '''Slide Transition, can be used to show a new screen from any direction:\n    left, right, up or down.\n    '''\n\n    direction = OptionProperty('left', options=('left', 'right', 'up', 'down'))\n    '''Direction of the transition.\n\n    :attr:`direction` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'left'. Can be one of 'left', 'right', 'up' or 'down'.\n    '''\n\n    def on_progress(self, progression):\n        a = self.screen_in\n        b = self.screen_out\n        manager = self.manager\n        x, y = manager.pos\n        width, height = manager.size\n        direction = self.direction\n        al = AnimationTransition.out_quad\n        progression = al(progression)\n        if direction == 'left':\n            a.y = b.y = y\n            a.x = x + width * (1 - progression)\n            b.x = x - width * progression\n        elif direction == 'right':\n            a.y = b.y = y\n            b.x = x + width * progression\n            a.x = x - width * (1 - progression)\n        elif direction == 'down':\n            a.x = b.x = x\n            a.y = y + height * (1 - progression)\n            b.y = y - height * progression\n        elif direction == 'up':\n            a.x = b.x = x\n            b.y = y + height * progression\n            a.y = y - height * (1 - progression)\n\n    def on_complete(self):\n        self.screen_in.pos = self.manager.pos\n        self.screen_out.pos = self.manager.pos\n        super(SlideTransition, self).on_complete()",
  "class CardTransition(SlideTransition):\n    '''Card transition that looks similar to Android 4.x application drawer\n    interface animation.\n\n    It supports 4 directions like SlideTransition: left, right, up and down,\n    and two modes, pop and push. If push mode is activated, the previous\n    screen does not move, and the new one slides in from the given direction.\n    If the pop mode is activated, the previous screen slides out, when the new\n    screen is already on the position of the ScreenManager.\n\n    .. versionadded:: 1.10\n    '''\n\n    mode = OptionProperty('push', options=['pop', 'push'])\n    '''Indicates if the transition should push or pop\n    the screen on/off the ScreenManager.\n\n    - 'push' means the screen slides in in the given direction\n    - 'pop' means the screen slides out in the given direction\n\n    :attr:`mode` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'push'.\n    '''\n\n    def start(self, manager):\n        '''(internal) Starts the transition. This is automatically\n        called by the :class:`ScreenManager`.\n        '''\n        super(CardTransition, self).start(manager)\n        mode = self.mode\n        a = self.screen_in\n        b = self.screen_out\n        # ensure that the correct widget is \"on top\"\n        if mode == 'push':\n            manager.canvas.remove(a.canvas)\n            manager.canvas.add(a.canvas)\n        elif mode == 'pop':\n            manager.canvas.remove(b.canvas)\n            manager.canvas.add(b.canvas)\n\n    def on_progress(self, progression):\n        a = self.screen_in\n        b = self.screen_out\n        manager = self.manager\n        x, y = manager.pos\n        width, height = manager.size\n        direction = self.direction\n        mode = self.mode\n        al = AnimationTransition.out_quad\n        progression = al(progression)\n        if mode == 'push':\n            b.pos = x, y\n            if direction == 'left':\n                a.pos = x + width * (1 - progression), y\n            elif direction == 'right':\n                a.pos = x - width * (1 - progression), y\n            elif direction == 'down':\n                a.pos = x, y + height * (1 - progression)\n            elif direction == 'up':\n                a.pos = x, y - height * (1 - progression)\n        elif mode == 'pop':\n            a.pos = x, y\n            if direction == 'left':\n                b.pos = x - width * progression, y\n            elif direction == 'right':\n                b.pos = x + width * progression, y\n            elif direction == 'down':\n                b.pos = x, y - height * progression\n            elif direction == 'up':\n                b.pos = x, y + height * progression",
  "class SwapTransition(TransitionBase):\n    '''Swap transition that looks like iOS transition when a new window\n    appears on the screen.\n    '''\n    def __init__(self, **kwargs):\n        super(SwapTransition, self).__init__(**kwargs)\n        self.scales = {}\n\n    def start(self, manager):\n        for screen in self.screen_in, self.screen_out:\n            with screen.canvas.before:\n                PushMatrix(group='swaptransition_scale')\n                scale = Scale(group='swaptransition_scale')\n            with screen.canvas.after:\n                PopMatrix(group='swaptransition_scale')\n\n            screen.bind(center=self.update_scale)\n            self.scales[screen] = scale\n        super(SwapTransition, self).start(manager)\n\n    def update_scale(self, screen, center):\n        self.scales[screen].origin = center\n\n    def add_screen(self, screen):\n        self.manager.real_add_widget(screen, 1)\n\n    def on_complete(self):\n        self.screen_in.pos = self.manager.pos\n        self.screen_out.pos = self.manager.pos\n        for screen in self.screen_in, self.screen_out:\n            for canvas in screen.canvas.before, screen.canvas.after:\n                canvas.remove_group('swaptransition_scale')\n        super(SwapTransition, self).on_complete()\n\n    def on_progress(self, progression):\n        a = self.screen_in\n        b = self.screen_out\n        manager = self.manager\n\n        self.scales[b].xyz = [1. - progression * 0.7 for xyz in 'xyz']\n        self.scales[a].xyz = [0.5 + progression * 0.5 for xyz in 'xyz']\n        a.center_y = b.center_y = manager.center_y\n\n        al = AnimationTransition.in_out_sine\n\n        if progression < 0.5:\n            p2 = al(progression * 2)\n            width = manager.width * 0.7\n            widthb = manager.width * 0.2\n            a.x = manager.center_x + p2 * width / 2.\n            b.center_x = manager.center_x - p2 * widthb / 2.\n        else:\n            if self.screen_in is self.manager.children[-1]:\n                self.manager.real_remove_widget(self.screen_in)\n                self.manager.real_add_widget(self.screen_in)\n            p2 = al((progression - 0.5) * 2)\n            width = manager.width * 0.85\n            widthb = manager.width * 0.2\n            a.x = manager.x + width * (1 - p2)\n            b.center_x = manager.center_x - (1 - p2) * widthb / 2.",
  "class WipeTransition(ShaderTransition):\n    '''Wipe transition, based on a fragment Shader.\n    '''\n\n    WIPE_TRANSITION_FS = '''$HEADER$\n    uniform float t;\n    uniform sampler2D tex_in;\n    uniform sampler2D tex_out;\n\n    void main(void) {\n        vec4 cin = texture2D(tex_in, tex_coord0);\n        vec4 cout = texture2D(tex_out, tex_coord0);\n        gl_FragColor = mix(cout, cin, clamp((-1.5 + 1.5*tex_coord0.x + 2.5*t),\n            0.0, 1.0));\n    }\n    '''\n    fs = StringProperty(WIPE_TRANSITION_FS)",
  "class FadeTransition(ShaderTransition):\n    '''Fade transition, based on a fragment Shader.\n    '''\n\n    FADE_TRANSITION_FS = '''$HEADER$\n    uniform float t;\n    uniform sampler2D tex_in;\n    uniform sampler2D tex_out;\n\n    void main(void) {\n        vec4 cin = vec4(texture2D(tex_in, tex_coord0.st));\n        vec4 cout = vec4(texture2D(tex_out, tex_coord0.st));\n        vec4 frag_col = vec4(t * cin) + vec4((1.0 - t) * cout);\n        gl_FragColor = frag_col;\n    }\n    '''\n    fs = StringProperty(FADE_TRANSITION_FS)",
  "class FallOutTransition(ShaderTransition):\n    '''Transition where the new screen 'falls' from the screen centre,\n    becoming smaller and more transparent until it disappears, and\n    revealing the new screen behind it. Mimics the popular/standard\n    Android transition.\n\n    .. versionadded:: 1.8.0\n\n    '''\n\n    duration = NumericProperty(0.15)\n    '''Duration in seconds of the transition, replacing the default of\n    :class:`TransitionBase`.\n\n    :class:`duration` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to .15 (= 150ms).\n    '''\n\n    FALLOUT_TRANSITION_FS = '''$HEADER$\n    uniform float t;\n    uniform sampler2D tex_in;\n    uniform sampler2D tex_out;\n\n    void main(void) {\n        /* quantities for position and opacity calculation */\n        float tr = 0.5*sin(t);  /* 'real' time */\n        vec2 diff = (tex_coord0.st - 0.5) * (1.0/(1.0-tr));\n        vec2 dist = diff + 0.5;\n        float max_dist = 1.0 - tr;\n\n        /* in and out colors */\n        vec4 cin = vec4(texture2D(tex_in, tex_coord0.st));\n        vec4 cout = vec4(texture2D(tex_out, dist));\n\n        /* opacities for in and out textures */\n        float oin = clamp(1.0-cos(t), 0.0, 1.0);\n        float oout = clamp(cos(t), 0.0, 1.0);\n\n        bvec2 outside_bounds = bvec2(abs(tex_coord0.s - 0.5) > 0.5*max_dist,\n                                     abs(tex_coord0.t - 0.5) > 0.5*max_dist);\n\n        vec4 frag_col;\n        if (any(outside_bounds) ){\n            frag_col = vec4(cin.x, cin.y, cin.z, 1.0);\n            }\n        else {\n            frag_col = vec4(oout*cout.x + oin*cin.x, oout*cout.y + oin*cin.y,\n                            oout*cout.z + oin*cin.z, 1.0);\n            }\n\n        gl_FragColor = frag_col;\n    }\n    '''\n\n    fs = StringProperty(FALLOUT_TRANSITION_FS)",
  "class RiseInTransition(ShaderTransition):\n    '''Transition where the new screen rises from the screen centre,\n    becoming larger and changing from transparent to opaque until it\n    fills the screen. Mimics the popular/standard Android transition.\n\n    .. versionadded:: 1.8.0\n    '''\n\n    duration = NumericProperty(0.2)\n    '''Duration in seconds of the transition, replacing the default of\n    :class:`TransitionBase`.\n\n    :class:`duration` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to .2 (= 200ms).\n    '''\n\n    RISEIN_TRANSITION_FS = '''$HEADER$\n    uniform float t;\n    uniform sampler2D tex_in;\n    uniform sampler2D tex_out;\n\n    void main(void) {\n        /* quantities for position and opacity calculation */\n        float tr = 0.5 - 0.5*sqrt(sin(t));  /* 'real' time */\n        vec2 diff = (tex_coord0.st - 0.5) * (1.0/(1.0-tr));\n        vec2 dist = diff + 0.5;\n        float max_dist = 1.0 - tr;\n\n        /* in and out colors */\n        vec4 cin = vec4(texture2D(tex_in, dist));\n        vec4 cout = vec4(texture2D(tex_out, tex_coord0.st));\n\n        /* opacities for in and out textures */\n        float oin = clamp(sin(2.0*t), 0.0, 1.0);\n        float oout = clamp(1.0 - sin(2.0*t), 0.0, 1.0);\n\n        bvec2 outside_bounds = bvec2(abs(tex_coord0.s - 0.5) > 0.5*max_dist,\n                                     abs(tex_coord0.t - 0.5) > 0.5*max_dist);\n\n        vec4 frag_col;\n        if (any(outside_bounds) ){\n            frag_col = vec4(cout.x, cout.y, cout.z, 1.0);\n            }\n        else {\n            frag_col = vec4(oout*cout.x + oin*cin.x, oout*cout.y + oin*cin.y,\n                            oout*cout.z + oin*cin.z, 1.0);\n            }\n\n        gl_FragColor = frag_col;\n    }\n    '''\n\n    fs = StringProperty(RISEIN_TRANSITION_FS)",
  "class ScreenManager(FloatLayout):\n    '''Screen manager. This is the main class that will control your\n    :class:`Screen` stack and memory.\n\n    By default, the manager will show only one screen at a time.\n    '''\n\n    current = StringProperty(None, allownone=True)\n    '''\n    Name of the screen currently shown, or the screen to show.\n\n    ::\n\n        from kivy.uix.screenmanager import ScreenManager, Screen\n\n        sm = ScreenManager()\n        sm.add_widget(Screen(name='first'))\n        sm.add_widget(Screen(name='second'))\n\n        # By default, the first added screen will be shown. If you want to\n        # show another one, just set the 'current' property.\n        sm.current = 'second'\n\n    :attr:`current` is a :class:`~kivy.properties.StringProperty` and defaults\n    to None.\n    '''\n\n    transition = ObjectProperty(baseclass=TransitionBase)\n    '''Transition object to use for animating the transition from the current\n    screen to the next one being shown.\n\n    For example, if you want to use a :class:`WipeTransition` between\n    slides::\n\n        from kivy.uix.screenmanager import ScreenManager, Screen,\n        WipeTransition\n\n        sm = ScreenManager(transition=WipeTransition())\n        sm.add_widget(Screen(name='first'))\n        sm.add_widget(Screen(name='second'))\n\n        # by default, the first added screen will be shown. If you want to\n        # show another one, just set the 'current' property.\n        sm.current = 'second'\n\n    :attr:`transition` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to a :class:`SlideTransition`.\n\n    .. versionchanged:: 1.8.0\n\n        Default transition has been changed from :class:`SwapTransition` to\n        :class:`SlideTransition`.\n    '''\n\n    screens = ListProperty()\n    '''List of all the :class:`Screen` widgets added. You should not change\n    this list manually. Use the\n    :meth:`add_widget <kivy.uix.widget.Widget.add_widget>` method instead.\n\n    :attr:`screens` is a :class:`~kivy.properties.ListProperty` and defaults to\n    [], read-only.\n    '''\n\n    current_screen = ObjectProperty(None, allownone=True)\n    '''Contains the currently displayed screen. You must not change this\n    property manually, use :attr:`current` instead.\n\n    :attr:`current_screen` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None, read-only.\n    '''\n\n    def _get_screen_names(self):\n        return [s.name for s in self.screens]\n\n    screen_names = AliasProperty(_get_screen_names, bind=('screens',))\n    '''List of the names of all the :class:`Screen` widgets added. The list\n    is read only.\n\n    :attr:`screens_names` is an :class:`~kivy.properties.AliasProperty` and\n    is read-only. It is updated if the screen list changes or the name\n    of a screen changes.\n    '''\n\n    def __init__(self, **kwargs):\n        if 'transition' not in kwargs:\n            self.transition = SlideTransition()\n        super(ScreenManager, self).__init__(**kwargs)\n        self.fbind('pos', self._update_pos)\n\n    def _screen_name_changed(self, screen, name):\n        self.property('screen_names').dispatch(self)\n        if screen == self.current_screen:\n            self.current = name\n\n    def add_widget(self, widget, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n            Renamed argument `screen` to `widget`.\n        '''\n        if not isinstance(widget, Screen):\n            raise ScreenManagerException(\n                'ScreenManager accepts only Screen widget.')\n        if widget.manager:\n            if widget.manager is self:\n                raise ScreenManagerException(\n                    'Screen already managed by this ScreenManager (are you '\n                    'calling `switch_to` when you should be setting '\n                    '`current`?)')\n            raise ScreenManagerException(\n                'Screen already managed by another ScreenManager.')\n        widget.manager = self\n        widget.bind(name=self._screen_name_changed)\n        self.screens.append(widget)\n        if self.current is None:\n            self.current = widget.name\n\n    def remove_widget(self, widget, *args, **kwargs):\n        if not isinstance(widget, Screen):\n            raise ScreenManagerException(\n                'ScreenManager uses remove_widget only for removing Screens.')\n\n        if widget not in self.screens:\n            return\n\n        if self.current_screen == widget:\n            other = next(self)\n            if widget.name == other:\n                self.current = None\n                widget.parent.real_remove_widget(widget)\n            else:\n                self.current = other\n\n        widget.manager = None\n        widget.unbind(name=self._screen_name_changed)\n        self.screens.remove(widget)\n\n    def clear_widgets(self, children=None, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n            Renamed argument `screens` to `children`.\n        '''\n        if children is None:\n            # iterate over a copy of screens, as self.remove_widget\n            # modifies self.screens in place\n            children = self.screens[:]\n        remove_widget = self.remove_widget\n        for widget in children:\n            remove_widget(widget)\n\n    def real_add_widget(self, screen, *args):\n        # ensure screen is removed from its previous parent\n        parent = screen.parent\n        if parent:\n            parent.real_remove_widget(screen)\n        super(ScreenManager, self).add_widget(screen)\n\n    def real_remove_widget(self, screen, *args):\n        super(ScreenManager, self).remove_widget(screen)\n\n    def on_current(self, instance, value):\n        if value is None:\n            self.transition.stop()\n            self.current_screen = None\n            return\n\n        screen = self.get_screen(value)\n        if screen == self.current_screen:\n            return\n\n        self.transition.stop()\n\n        previous_screen = self.current_screen\n        self.current_screen = screen\n        if previous_screen:\n            self.transition.screen_in = screen\n            self.transition.screen_out = previous_screen\n            self.transition.start(self)\n        else:\n            self.real_add_widget(screen)\n            screen.pos = self.pos\n            self.do_layout()\n            screen.dispatch('on_pre_enter')\n            screen.dispatch('on_enter')\n\n    def get_screen(self, name):\n        '''Return the screen widget associated with the name or raise a\n        :class:`ScreenManagerException` if not found.\n        '''\n        matches = [s for s in self.screens if s.name == name]\n        num_matches = len(matches)\n        if num_matches == 0:\n            raise ScreenManagerException('No Screen with name \"%s\".' % name)\n        if num_matches > 1:\n            Logger.warn('Multiple screens named \"%s\": %s' % (name, matches))\n        return matches[0]\n\n    def has_screen(self, name):\n        '''Return True if a screen with the `name` has been found.\n\n        .. versionadded:: 1.6.0\n        '''\n        return bool([s for s in self.screens if s.name == name])\n\n    def __next__(self):\n        '''Py2K backwards compatibility without six or other lib.\n        '''\n        screens = self.screens\n        if not screens:\n            return\n        try:\n            index = screens.index(self.current_screen)\n            index = (index + 1) % len(screens)\n            return screens[index].name\n        except ValueError:\n            return\n\n    def next(self):\n        '''Return the name of the next screen from the screen list.'''\n        return self.__next__()\n\n    def previous(self):\n        '''Return the name of the previous screen from the screen list.\n        '''\n        screens = self.screens\n        if not screens:\n            return\n        try:\n            index = screens.index(self.current_screen)\n            index = (index - 1) % len(screens)\n            return screens[index].name\n        except ValueError:\n            return\n\n    def switch_to(self, screen, **options):\n        '''Add a new or existing screen to the ScreenManager and switch to it.\n        The previous screen will be \"switched away\" from. `options` are the\n        :attr:`transition` options that will be changed before the animation\n        happens.\n\n        If no previous screens are available, the screen will be used as the\n        main one::\n\n            sm = ScreenManager()\n            sm.switch_to(screen1)\n            # later\n            sm.switch_to(screen2, direction='left')\n            # later\n            sm.switch_to(screen3, direction='right', duration=1.)\n\n        If any animation is in progress, it will be stopped and replaced by\n        this one: you should avoid this because the animation will just look\n        weird. Use either :meth:`switch_to` or :attr:`current` but not both.\n\n        The `screen` name will be changed if there is any conflict with the\n        current screen.\n\n        .. versionadded: 1.8.0\n        '''\n        assert screen is not None\n\n        if not isinstance(screen, Screen):\n            raise ScreenManagerException(\n                'ScreenManager accepts only Screen widget.')\n\n        # stop any transition that might be happening already\n        self.transition.stop()\n\n        # ensure the screen name will be unique\n        if screen not in self.screens:\n            if self.has_screen(screen.name):\n                screen.name = self._generate_screen_name()\n\n        # change the transition if given explicitly\n        old_transition = self.transition\n        specified_transition = options.pop(\"transition\", None)\n        if specified_transition:\n            self.transition = specified_transition\n\n        # change the transition options\n        for key, value in iteritems(options):\n            setattr(self.transition, key, value)\n\n        # add and leave if we are set as the current screen\n        if screen.manager is not self:\n            self.add_widget(screen)\n        if self.current_screen is screen:\n            return\n\n        old_current = self.current_screen\n\n        def remove_old_screen(transition):\n            if old_current in self.children:\n                self.remove_widget(old_current)\n                self.transition = old_transition\n            transition.unbind(on_complete=remove_old_screen)\n        self.transition.bind(on_complete=remove_old_screen)\n\n        self.current = screen.name\n\n    def _generate_screen_name(self):\n        i = 0\n        while True:\n            name = '_screen{}'.format(i)\n            if not self.has_screen(name):\n                return name\n            i += 1\n\n    def _update_pos(self, instance, value):\n        for child in self.children:\n            if self.transition.is_active and \\\n                (child == self.transition.screen_in or\n                 child == self.transition.screen_out):\n                continue\n            child.pos = value\n\n    def on_motion(self, etype, me):\n        if self.transition.is_active:\n            return False\n        return super().on_motion(etype, me)\n\n    def on_touch_down(self, touch):\n        if self.transition.is_active:\n            return False\n        return super(ScreenManager, self).on_touch_down(touch)\n\n    def on_touch_move(self, touch):\n        if self.transition.is_active:\n            return False\n        return super(ScreenManager, self).on_touch_move(touch)\n\n    def on_touch_up(self, touch):\n        if self.transition.is_active:\n            return False\n        return super(ScreenManager, self).on_touch_up(touch)",
  "def on_pre_enter(self, *args):\n        pass",
  "def on_enter(self, *args):\n        pass",
  "def on_pre_leave(self, *args):\n        pass",
  "def on_leave(self, *args):\n        pass",
  "def __repr__(self):\n        return '<Screen name=%r>' % self.name",
  "def start(self, manager):\n        '''(internal) Starts the transition. This is automatically\n        called by the :class:`ScreenManager`.\n        '''\n        if self.is_active:\n            raise ScreenManagerException('start() is called twice!')\n        self.manager = manager\n        self._anim = Animation(d=self.duration, s=0)\n        self._anim.bind(on_progress=self._on_progress,\n                        on_complete=self._on_complete)\n\n        self.add_screen(self.screen_in)\n        self.screen_in.transition_progress = 0.\n        self.screen_in.transition_state = 'in'\n        self.screen_out.transition_progress = 0.\n        self.screen_out.transition_state = 'out'\n        self.screen_in.dispatch('on_pre_enter')\n        self.screen_out.dispatch('on_pre_leave')\n\n        self.is_active = True\n        self._anim.start(self)\n        self.dispatch('on_progress', 0)",
  "def stop(self):\n        '''(internal) Stops the transition. This is automatically called by the\n        :class:`ScreenManager`.\n        '''\n        if self._anim:\n            self._anim.cancel(self)\n            self.dispatch('on_complete')\n            self._anim = None\n        self.is_active = False",
  "def add_screen(self, screen):\n        '''(internal) Used to add a screen to the :class:`ScreenManager`.\n        '''\n        self.manager.real_add_widget(screen)",
  "def remove_screen(self, screen):\n        '''(internal) Used to remove a screen from the :class:`ScreenManager`.\n        '''\n        self.manager.real_remove_widget(screen)",
  "def on_complete(self):\n        self.remove_screen(self.screen_out)",
  "def on_progress(self, progression):\n        pass",
  "def _on_progress(self, *l):\n        progress = l[-1]\n        self.screen_in.transition_progress = progress\n        self.screen_out.transition_progress = 1. - progress\n        self.dispatch('on_progress', progress)",
  "def _on_complete(self, *l):\n        self.is_active = False\n        self.dispatch('on_complete')\n        self.screen_in.dispatch('on_enter')\n        self.screen_out.dispatch('on_leave')\n        self._anim = None",
  "def make_screen_fbo(self, screen):\n        fbo = Fbo(size=screen.size, with_stencilbuffer=True)\n        with fbo:\n            ClearColor(*self.clearcolor)\n            ClearBuffers()\n        fbo.add(screen.canvas)\n        with fbo.before:\n            PushMatrix()\n            Translate(-screen.x, -screen.y, 0)\n        with fbo.after:\n            PopMatrix()\n        return fbo",
  "def on_progress(self, progress):\n        self.render_ctx['t'] = progress",
  "def on_complete(self):\n        self.render_ctx['t'] = 1.\n        super(ShaderTransition, self).on_complete()",
  "def _remove_out_canvas(self, *args):\n        if (self.screen_out and\n                self.screen_out.canvas in self.manager.canvas.children and\n                self.screen_out not in self.manager.children):\n            self.manager.canvas.remove(self.screen_out.canvas)",
  "def add_screen(self, screen):\n        self.screen_in.pos = self.screen_out.pos\n        self.screen_in.size = self.screen_out.size\n        self.manager.real_remove_widget(self.screen_out)\n        self.manager.canvas.add(self.screen_out.canvas)\n\n        def remove_screen_out(instr):\n            Clock.schedule_once(self._remove_out_canvas, -1)\n            self.render_ctx.remove(instr)\n\n        self.fbo_in = self.make_screen_fbo(self.screen_in)\n        self.fbo_out = self.make_screen_fbo(self.screen_out)\n        self.manager.canvas.add(self.fbo_in)\n        self.manager.canvas.add(self.fbo_out)\n\n        self.render_ctx = RenderContext(fs=self.fs, vs=self.vs,\n                                        use_parent_modelview=True,\n                                        use_parent_projection=True)\n        with self.render_ctx:\n            BindTexture(texture=self.fbo_out.texture, index=1)\n            BindTexture(texture=self.fbo_in.texture, index=2)\n            x, y = self.screen_in.pos\n            w, h = self.fbo_in.texture.size\n            Rectangle(size=(w, h), pos=(x, y),\n                      tex_coords=self.fbo_in.texture.tex_coords)\n            Callback(remove_screen_out)\n        self.render_ctx['tex_out'] = 1\n        self.render_ctx['tex_in'] = 2\n        self.manager.canvas.add(self.render_ctx)",
  "def remove_screen(self, screen):\n        self.manager.canvas.remove(self.fbo_in)\n        self.manager.canvas.remove(self.fbo_out)\n        self.manager.canvas.remove(self.render_ctx)\n        self._remove_out_canvas()\n        self.manager.real_add_widget(self.screen_in)",
  "def stop(self):\n        self._remove_out_canvas()\n        super(ShaderTransition, self).stop()",
  "def on_complete(self):\n        self.screen_in.pos = self.manager.pos\n        self.screen_out.pos = self.manager.pos\n        super(NoTransition, self).on_complete()",
  "def on_progress(self, progression):\n        a = self.screen_in\n        b = self.screen_out\n        manager = self.manager\n        x, y = manager.pos\n        width, height = manager.size\n        direction = self.direction\n        al = AnimationTransition.out_quad\n        progression = al(progression)\n        if direction == 'left':\n            a.y = b.y = y\n            a.x = x + width * (1 - progression)\n            b.x = x - width * progression\n        elif direction == 'right':\n            a.y = b.y = y\n            b.x = x + width * progression\n            a.x = x - width * (1 - progression)\n        elif direction == 'down':\n            a.x = b.x = x\n            a.y = y + height * (1 - progression)\n            b.y = y - height * progression\n        elif direction == 'up':\n            a.x = b.x = x\n            b.y = y + height * progression\n            a.y = y - height * (1 - progression)",
  "def on_complete(self):\n        self.screen_in.pos = self.manager.pos\n        self.screen_out.pos = self.manager.pos\n        super(SlideTransition, self).on_complete()",
  "def start(self, manager):\n        '''(internal) Starts the transition. This is automatically\n        called by the :class:`ScreenManager`.\n        '''\n        super(CardTransition, self).start(manager)\n        mode = self.mode\n        a = self.screen_in\n        b = self.screen_out\n        # ensure that the correct widget is \"on top\"\n        if mode == 'push':\n            manager.canvas.remove(a.canvas)\n            manager.canvas.add(a.canvas)\n        elif mode == 'pop':\n            manager.canvas.remove(b.canvas)\n            manager.canvas.add(b.canvas)",
  "def on_progress(self, progression):\n        a = self.screen_in\n        b = self.screen_out\n        manager = self.manager\n        x, y = manager.pos\n        width, height = manager.size\n        direction = self.direction\n        mode = self.mode\n        al = AnimationTransition.out_quad\n        progression = al(progression)\n        if mode == 'push':\n            b.pos = x, y\n            if direction == 'left':\n                a.pos = x + width * (1 - progression), y\n            elif direction == 'right':\n                a.pos = x - width * (1 - progression), y\n            elif direction == 'down':\n                a.pos = x, y + height * (1 - progression)\n            elif direction == 'up':\n                a.pos = x, y - height * (1 - progression)\n        elif mode == 'pop':\n            a.pos = x, y\n            if direction == 'left':\n                b.pos = x - width * progression, y\n            elif direction == 'right':\n                b.pos = x + width * progression, y\n            elif direction == 'down':\n                b.pos = x, y - height * progression\n            elif direction == 'up':\n                b.pos = x, y + height * progression",
  "def __init__(self, **kwargs):\n        super(SwapTransition, self).__init__(**kwargs)\n        self.scales = {}",
  "def start(self, manager):\n        for screen in self.screen_in, self.screen_out:\n            with screen.canvas.before:\n                PushMatrix(group='swaptransition_scale')\n                scale = Scale(group='swaptransition_scale')\n            with screen.canvas.after:\n                PopMatrix(group='swaptransition_scale')\n\n            screen.bind(center=self.update_scale)\n            self.scales[screen] = scale\n        super(SwapTransition, self).start(manager)",
  "def update_scale(self, screen, center):\n        self.scales[screen].origin = center",
  "def add_screen(self, screen):\n        self.manager.real_add_widget(screen, 1)",
  "def on_complete(self):\n        self.screen_in.pos = self.manager.pos\n        self.screen_out.pos = self.manager.pos\n        for screen in self.screen_in, self.screen_out:\n            for canvas in screen.canvas.before, screen.canvas.after:\n                canvas.remove_group('swaptransition_scale')\n        super(SwapTransition, self).on_complete()",
  "def on_progress(self, progression):\n        a = self.screen_in\n        b = self.screen_out\n        manager = self.manager\n\n        self.scales[b].xyz = [1. - progression * 0.7 for xyz in 'xyz']\n        self.scales[a].xyz = [0.5 + progression * 0.5 for xyz in 'xyz']\n        a.center_y = b.center_y = manager.center_y\n\n        al = AnimationTransition.in_out_sine\n\n        if progression < 0.5:\n            p2 = al(progression * 2)\n            width = manager.width * 0.7\n            widthb = manager.width * 0.2\n            a.x = manager.center_x + p2 * width / 2.\n            b.center_x = manager.center_x - p2 * widthb / 2.\n        else:\n            if self.screen_in is self.manager.children[-1]:\n                self.manager.real_remove_widget(self.screen_in)\n                self.manager.real_add_widget(self.screen_in)\n            p2 = al((progression - 0.5) * 2)\n            width = manager.width * 0.85\n            widthb = manager.width * 0.2\n            a.x = manager.x + width * (1 - p2)\n            b.center_x = manager.center_x - (1 - p2) * widthb / 2.",
  "def _get_screen_names(self):\n        return [s.name for s in self.screens]",
  "def __init__(self, **kwargs):\n        if 'transition' not in kwargs:\n            self.transition = SlideTransition()\n        super(ScreenManager, self).__init__(**kwargs)\n        self.fbind('pos', self._update_pos)",
  "def _screen_name_changed(self, screen, name):\n        self.property('screen_names').dispatch(self)\n        if screen == self.current_screen:\n            self.current = name",
  "def add_widget(self, widget, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n            Renamed argument `screen` to `widget`.\n        '''\n        if not isinstance(widget, Screen):\n            raise ScreenManagerException(\n                'ScreenManager accepts only Screen widget.')\n        if widget.manager:\n            if widget.manager is self:\n                raise ScreenManagerException(\n                    'Screen already managed by this ScreenManager (are you '\n                    'calling `switch_to` when you should be setting '\n                    '`current`?)')\n            raise ScreenManagerException(\n                'Screen already managed by another ScreenManager.')\n        widget.manager = self\n        widget.bind(name=self._screen_name_changed)\n        self.screens.append(widget)\n        if self.current is None:\n            self.current = widget.name",
  "def remove_widget(self, widget, *args, **kwargs):\n        if not isinstance(widget, Screen):\n            raise ScreenManagerException(\n                'ScreenManager uses remove_widget only for removing Screens.')\n\n        if widget not in self.screens:\n            return\n\n        if self.current_screen == widget:\n            other = next(self)\n            if widget.name == other:\n                self.current = None\n                widget.parent.real_remove_widget(widget)\n            else:\n                self.current = other\n\n        widget.manager = None\n        widget.unbind(name=self._screen_name_changed)\n        self.screens.remove(widget)",
  "def clear_widgets(self, children=None, *args, **kwargs):\n        '''\n        .. versionchanged:: 2.1.0\n            Renamed argument `screens` to `children`.\n        '''\n        if children is None:\n            # iterate over a copy of screens, as self.remove_widget\n            # modifies self.screens in place\n            children = self.screens[:]\n        remove_widget = self.remove_widget\n        for widget in children:\n            remove_widget(widget)",
  "def real_add_widget(self, screen, *args):\n        # ensure screen is removed from its previous parent\n        parent = screen.parent\n        if parent:\n            parent.real_remove_widget(screen)\n        super(ScreenManager, self).add_widget(screen)",
  "def real_remove_widget(self, screen, *args):\n        super(ScreenManager, self).remove_widget(screen)",
  "def on_current(self, instance, value):\n        if value is None:\n            self.transition.stop()\n            self.current_screen = None\n            return\n\n        screen = self.get_screen(value)\n        if screen == self.current_screen:\n            return\n\n        self.transition.stop()\n\n        previous_screen = self.current_screen\n        self.current_screen = screen\n        if previous_screen:\n            self.transition.screen_in = screen\n            self.transition.screen_out = previous_screen\n            self.transition.start(self)\n        else:\n            self.real_add_widget(screen)\n            screen.pos = self.pos\n            self.do_layout()\n            screen.dispatch('on_pre_enter')\n            screen.dispatch('on_enter')",
  "def get_screen(self, name):\n        '''Return the screen widget associated with the name or raise a\n        :class:`ScreenManagerException` if not found.\n        '''\n        matches = [s for s in self.screens if s.name == name]\n        num_matches = len(matches)\n        if num_matches == 0:\n            raise ScreenManagerException('No Screen with name \"%s\".' % name)\n        if num_matches > 1:\n            Logger.warn('Multiple screens named \"%s\": %s' % (name, matches))\n        return matches[0]",
  "def has_screen(self, name):\n        '''Return True if a screen with the `name` has been found.\n\n        .. versionadded:: 1.6.0\n        '''\n        return bool([s for s in self.screens if s.name == name])",
  "def __next__(self):\n        '''Py2K backwards compatibility without six or other lib.\n        '''\n        screens = self.screens\n        if not screens:\n            return\n        try:\n            index = screens.index(self.current_screen)\n            index = (index + 1) % len(screens)\n            return screens[index].name\n        except ValueError:\n            return",
  "def next(self):\n        '''Return the name of the next screen from the screen list.'''\n        return self.__next__()",
  "def previous(self):\n        '''Return the name of the previous screen from the screen list.\n        '''\n        screens = self.screens\n        if not screens:\n            return\n        try:\n            index = screens.index(self.current_screen)\n            index = (index - 1) % len(screens)\n            return screens[index].name\n        except ValueError:\n            return",
  "def switch_to(self, screen, **options):\n        '''Add a new or existing screen to the ScreenManager and switch to it.\n        The previous screen will be \"switched away\" from. `options` are the\n        :attr:`transition` options that will be changed before the animation\n        happens.\n\n        If no previous screens are available, the screen will be used as the\n        main one::\n\n            sm = ScreenManager()\n            sm.switch_to(screen1)\n            # later\n            sm.switch_to(screen2, direction='left')\n            # later\n            sm.switch_to(screen3, direction='right', duration=1.)\n\n        If any animation is in progress, it will be stopped and replaced by\n        this one: you should avoid this because the animation will just look\n        weird. Use either :meth:`switch_to` or :attr:`current` but not both.\n\n        The `screen` name will be changed if there is any conflict with the\n        current screen.\n\n        .. versionadded: 1.8.0\n        '''\n        assert screen is not None\n\n        if not isinstance(screen, Screen):\n            raise ScreenManagerException(\n                'ScreenManager accepts only Screen widget.')\n\n        # stop any transition that might be happening already\n        self.transition.stop()\n\n        # ensure the screen name will be unique\n        if screen not in self.screens:\n            if self.has_screen(screen.name):\n                screen.name = self._generate_screen_name()\n\n        # change the transition if given explicitly\n        old_transition = self.transition\n        specified_transition = options.pop(\"transition\", None)\n        if specified_transition:\n            self.transition = specified_transition\n\n        # change the transition options\n        for key, value in iteritems(options):\n            setattr(self.transition, key, value)\n\n        # add and leave if we are set as the current screen\n        if screen.manager is not self:\n            self.add_widget(screen)\n        if self.current_screen is screen:\n            return\n\n        old_current = self.current_screen\n\n        def remove_old_screen(transition):\n            if old_current in self.children:\n                self.remove_widget(old_current)\n                self.transition = old_transition\n            transition.unbind(on_complete=remove_old_screen)\n        self.transition.bind(on_complete=remove_old_screen)\n\n        self.current = screen.name",
  "def _generate_screen_name(self):\n        i = 0\n        while True:\n            name = '_screen{}'.format(i)\n            if not self.has_screen(name):\n                return name\n            i += 1",
  "def _update_pos(self, instance, value):\n        for child in self.children:\n            if self.transition.is_active and \\\n                (child == self.transition.screen_in or\n                 child == self.transition.screen_out):\n                continue\n            child.pos = value",
  "def on_motion(self, etype, me):\n        if self.transition.is_active:\n            return False\n        return super().on_motion(etype, me)",
  "def on_touch_down(self, touch):\n        if self.transition.is_active:\n            return False\n        return super(ScreenManager, self).on_touch_down(touch)",
  "def on_touch_move(self, touch):\n        if self.transition.is_active:\n            return False\n        return super(ScreenManager, self).on_touch_move(touch)",
  "def on_touch_up(self, touch):\n        if self.transition.is_active:\n            return False\n        return super(ScreenManager, self).on_touch_up(touch)",
  "class TestApp(App):\n\n        def change_view(self, *l):\n            # d = ('left', 'up', 'down', 'right')\n            # di = d.index(self.sm.transition.direction)\n            # self.sm.transition.direction = d[(di + 1) % len(d)]\n            self.sm.current = next(self.sm)\n\n        def remove_screen(self, *l):\n            self.sm.remove_widget(self.sm.get_screen('test1'))\n\n        def build(self):\n            root = FloatLayout()\n            self.sm = sm = ScreenManager(transition=SwapTransition())\n\n            sm.add_widget(Screen(name='test1'))\n            sm.add_widget(Screen(name='test2'))\n\n            btn = Button(size_hint=(None, None))\n            btn.bind(on_release=self.change_view)\n\n            btn2 = Button(size_hint=(None, None), x=100)\n            btn2.bind(on_release=self.remove_screen)\n\n            root.add_widget(sm)\n            root.add_widget(btn)\n            root.add_widget(btn2)\n            return root",
  "def remove_screen_out(instr):\n            Clock.schedule_once(self._remove_out_canvas, -1)\n            self.render_ctx.remove(instr)",
  "def remove_old_screen(transition):\n            if old_current in self.children:\n                self.remove_widget(old_current)\n                self.transition = old_transition\n            transition.unbind(on_complete=remove_old_screen)",
  "def change_view(self, *l):\n            # d = ('left', 'up', 'down', 'right')\n            # di = d.index(self.sm.transition.direction)\n            # self.sm.transition.direction = d[(di + 1) % len(d)]\n            self.sm.current = next(self.sm)",
  "def remove_screen(self, *l):\n            self.sm.remove_widget(self.sm.get_screen('test1'))",
  "def build(self):\n            root = FloatLayout()\n            self.sm = sm = ScreenManager(transition=SwapTransition())\n\n            sm.add_widget(Screen(name='test1'))\n            sm.add_widget(Screen(name='test2'))\n\n            btn = Button(size_hint=(None, None))\n            btn.bind(on_release=self.change_view)\n\n            btn2 = Button(size_hint=(None, None), x=100)\n            btn2.bind(on_release=self.remove_screen)\n\n            root.add_widget(sm)\n            root.add_widget(btn)\n            root.add_widget(btn2)\n            return root",
  "class ScatterLayout(Scatter):\n    '''ScatterLayout class, see module documentation for more information.\n    '''\n\n    content = ObjectProperty()\n\n    def __init__(self, **kw):\n        self.content = FloatLayout()\n        super(ScatterLayout, self).__init__(**kw)\n        if self.content.size != self.size:\n            self.content.size = self.size\n        super(ScatterLayout, self).add_widget(self.content)\n        self.fbind('size', self.update_size)\n\n    def update_size(self, instance, size):\n        self.content.size = size\n\n    def add_widget(self, *args, **kwargs):\n        self.content.add_widget(*args, **kwargs)\n\n    def remove_widget(self, *args, **kwargs):\n        self.content.remove_widget(*args, **kwargs)\n\n    def clear_widgets(self, *args, **kwargs):\n        self.content.clear_widgets(*args, **kwargs)",
  "class ScatterPlaneLayout(ScatterPlane):\n    '''ScatterPlaneLayout class, see module documentation for more information.\n\n    Similar to ScatterLayout, but based on ScatterPlane - so the input is not\n    bounded.\n\n    .. versionadded:: 1.9.0\n    '''\n\n    def collide_point(self, x, y):\n        return True",
  "def __init__(self, **kw):\n        self.content = FloatLayout()\n        super(ScatterLayout, self).__init__(**kw)\n        if self.content.size != self.size:\n            self.content.size = self.size\n        super(ScatterLayout, self).add_widget(self.content)\n        self.fbind('size', self.update_size)",
  "def update_size(self, instance, size):\n        self.content.size = size",
  "def add_widget(self, *args, **kwargs):\n        self.content.add_widget(*args, **kwargs)",
  "def remove_widget(self, *args, **kwargs):\n        self.content.remove_widget(*args, **kwargs)",
  "def clear_widgets(self, *args, **kwargs):\n        self.content.clear_widgets(*args, **kwargs)",
  "def collide_point(self, x, y):\n        return True",
  "class VideoPlayerVolume(Image):\n    video = ObjectProperty(None)\n\n    def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return False\n        touch.grab(self)\n        # save the current volume and delta to it\n        touch.ud[self.uid] = [self.video.volume, 0]\n        return True\n\n    def on_touch_move(self, touch):\n        if touch.grab_current is not self:\n            return\n        # calculate delta\n        dy = abs(touch.y - touch.oy)\n        if dy > 10:\n            dy = min(dy - 10, 100)\n            touch.ud[self.uid][1] = dy\n            self.video.volume = dy / 100.\n        return True\n\n    def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n        dy = abs(touch.y - touch.oy)\n        if dy < 10:\n            if self.video.volume > 0:\n                self.video.volume = 0\n            else:\n                self.video.volume = 1.",
  "class VideoPlayerPlayPause(Image):\n    video = ObjectProperty(None)\n\n    def on_touch_down(self, touch):\n        '''.. versionchanged:: 1.4.0'''\n        if self.collide_point(*touch.pos):\n            if self.video.state == 'play':\n                self.video.state = 'pause'\n            else:\n                self.video.state = 'play'\n            return True",
  "class VideoPlayerStop(Image):\n    video = ObjectProperty(None)\n\n    def on_touch_down(self, touch):\n        if self.collide_point(*touch.pos):\n            self.video.state = 'stop'\n            self.video.position = 0\n            return True",
  "class VideoPlayerProgressBar(ProgressBar):\n    video = ObjectProperty(None)\n    seek = NumericProperty(None, allownone=True)\n    alpha = NumericProperty(1.)\n\n    def __init__(self, **kwargs):\n        super(VideoPlayerProgressBar, self).__init__(**kwargs)\n        self.bubble = Factory.Bubble(size=(50, 44))\n        self.bubble_label = Factory.Label(text='0:00')\n        self.bubble.add_widget(self.bubble_label)\n        self.add_widget(self.bubble)\n\n        update = self._update_bubble\n        fbind = self.fbind\n        fbind('pos', update)\n        fbind('size', update)\n        fbind('seek', update)\n\n    def on_video(self, instance, value):\n        self.video.bind(position=self._update_bubble,\n                        state=self._showhide_bubble)\n\n    def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return\n        self._show_bubble()\n        touch.grab(self)\n        self._update_seek(touch.x)\n        return True\n\n    def on_touch_move(self, touch):\n        if touch.grab_current is not self:\n            return\n        self._update_seek(touch.x)\n        return True\n\n    def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n        if self.seek:\n            self.video.seek(self.seek)\n        self.seek = None\n        self._hide_bubble()\n        return True\n\n    def _update_seek(self, x):\n        if self.width == 0:\n            return\n        x = max(self.x, min(self.right, x)) - self.x\n        self.seek = x / float(self.width)\n\n    def _show_bubble(self):\n        self.alpha = 1\n        Animation.stop_all(self, 'alpha')\n\n    def _hide_bubble(self):\n        self.alpha = 1.\n        Animation(alpha=0, d=4, t='in_out_expo').start(self)\n\n    def on_alpha(self, instance, value):\n        self.bubble.background_color = (1, 1, 1, value)\n        self.bubble_label.color = (1, 1, 1, value)\n\n    def _update_bubble(self, *l):\n        seek = self.seek\n        if self.seek is None:\n            if self.video.duration == 0:\n                seek = 0\n            else:\n                seek = self.video.position / self.video.duration\n        # convert to minutes:seconds\n        d = self.video.duration * seek\n        minutes = int(d / 60)\n        seconds = int(d - (minutes * 60))\n        # fix bubble label & position\n        self.bubble_label.text = '%d:%02d' % (minutes, seconds)\n        self.bubble.center_x = self.x + seek * self.width\n        self.bubble.y = self.top\n\n    def _showhide_bubble(self, instance, value):\n        if value == 'play':\n            self._hide_bubble()\n        else:\n            self._show_bubble()",
  "class VideoPlayerPreview(FloatLayout):\n    source = ObjectProperty(None)\n    video = ObjectProperty(None)\n    click_done = BooleanProperty(False)\n\n    def on_touch_down(self, touch):\n        if self.collide_point(*touch.pos) and not self.click_done:\n            self.click_done = True\n            self.video.state = 'play'\n        return True",
  "class VideoPlayerAnnotation(Label):\n    '''Annotation class used for creating annotation labels.\n\n    Additional keys are available:\n\n    * bgcolor: [r, g, b, a] - background color of the text box\n    * bgsource: 'filename' - background image used for the background text box\n    * border: (n, e, s, w) - border used for the background image\n\n    '''\n    start = NumericProperty(0)\n    '''Start time of the annotation.\n\n    :attr:`start` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 0.\n    '''\n\n    duration = NumericProperty(1)\n    '''Duration of the annotation.\n\n    :attr:`duration` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 1.\n    '''\n\n    annotation = DictProperty({})\n\n    def on_annotation(self, instance, ann):\n        for key, value in ann.items():\n            setattr(self, key, value)",
  "class VideoPlayer(GridLayout):\n    '''VideoPlayer class. See module documentation for more information.\n    '''\n\n    source = StringProperty('')\n    '''Source of the video to read.\n\n    :attr:`source` is a :class:`~kivy.properties.StringProperty` and\n    defaults to ''.\n\n    .. versionchanged:: 1.4.0\n    '''\n\n    thumbnail = StringProperty('')\n    '''Thumbnail of the video to show. If None, VideoPlayer will try to find\n    the thumbnail from the :attr:`source` + '.png'.\n\n    :attr:`thumbnail` a :class:`~kivy.properties.StringProperty` and defaults\n    to ''.\n\n    .. versionchanged:: 1.4.0\n    '''\n\n    duration = NumericProperty(-1)\n    '''Duration of the video. The duration defaults to -1 and is set to the\n    real duration when the video is loaded.\n\n    :attr:`duration` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to -1.\n    '''\n\n    position = NumericProperty(0)\n    '''Position of the video between 0 and :attr:`duration`. The position\n    defaults to -1 and is set to the real position when the video is loaded.\n\n    :attr:`position` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to -1.\n    '''\n\n    volume = NumericProperty(1.0)\n    '''Volume of the video in the range 0-1. 1 means full volume and 0 means\n    mute.\n\n    :attr:`volume` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 1.\n    '''\n\n    state = OptionProperty('stop', options=('play', 'pause', 'stop'))\n    '''String, indicates whether to play, pause, or stop the video::\n\n        # start playing the video at creation\n        video = VideoPlayer(source='movie.mkv', state='play')\n\n        # create the video, and start later\n        video = VideoPlayer(source='movie.mkv')\n        # and later\n        video.state = 'play'\n\n    :attr:`state` is an :class:`~kivy.properties.OptionProperty` and defaults\n    to 'stop'.\n    '''\n\n    play = BooleanProperty(False, deprecated=True)\n    '''\n    .. deprecated:: 1.4.0\n        Use :attr:`state` instead.\n\n    Boolean, indicates whether the video is playing or not. You can start/stop\n    the video by setting this property::\n\n        # start playing the video at creation\n        video = VideoPlayer(source='movie.mkv', play=True)\n\n        # create the video, and start later\n        video = VideoPlayer(source='movie.mkv')\n        # and later\n        video.play = True\n\n    :attr:`play` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    image_overlay_play = StringProperty(\n        'atlas://data/images/defaulttheme/player-play-overlay')\n    '''Image filename used to show a \"play\" overlay when the video has not yet\n    started.\n\n    :attr:`image_overlay_play` is a\n    :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/player-play-overlay'.\n\n    '''\n\n    image_loading = StringProperty('data/images/image-loading.zip')\n    '''Image filename used when the video is loading.\n\n    :attr:`image_loading` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'data/images/image-loading.zip'.\n    '''\n\n    image_play = StringProperty(\n        'atlas://data/images/defaulttheme/media-playback-start')\n    '''Image filename used for the \"Play\" button.\n\n    :attr:`image_play` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/media-playback-start'.\n    '''\n\n    image_stop = StringProperty(\n        'atlas://data/images/defaulttheme/media-playback-stop')\n    '''Image filename used for the \"Stop\" button.\n\n    :attr:`image_stop` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/media-playback-stop'.\n    '''\n\n    image_pause = StringProperty(\n        'atlas://data/images/defaulttheme/media-playback-pause')\n    '''Image filename used for the \"Pause\" button.\n\n    :attr:`image_pause` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/media-playback-pause'.\n    '''\n\n    image_volumehigh = StringProperty(\n        'atlas://data/images/defaulttheme/audio-volume-high')\n    '''Image filename used for the volume icon when the volume is high.\n\n    :attr:`image_volumehigh` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/audio-volume-high'.\n    '''\n\n    image_volumemedium = StringProperty(\n        'atlas://data/images/defaulttheme/audio-volume-medium')\n    '''Image filename used for the volume icon when the volume is medium.\n\n    :attr:`image_volumemedium` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/audio-volume-medium'.\n    '''\n\n    image_volumelow = StringProperty(\n        'atlas://data/images/defaulttheme/audio-volume-low')\n    '''Image filename used for the volume icon when the volume is low.\n\n    :attr:`image_volumelow` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/audio-volume-low'.\n    '''\n\n    image_volumemuted = StringProperty(\n        'atlas://data/images/defaulttheme/audio-volume-muted')\n    '''Image filename used for the volume icon when the volume is muted.\n\n    :attr:`image_volumemuted` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/audio-volume-muted'.\n    '''\n\n    annotations = StringProperty('')\n    '''If set, it will be used for reading annotations box.\n\n    :attr:`annotations` is a :class:`~kivy.properties.StringProperty`\n    and defaults to ''.\n    '''\n\n    fullscreen = BooleanProperty(False)\n    '''Switch to fullscreen view. This should be used with care. When\n    activated, the widget will remove itself from its parent, remove all\n    children from the window and will add itself to it. When fullscreen is\n    unset, all the previous children are restored and the widget is restored to\n    its previous parent.\n\n    .. warning::\n\n        The re-add operation doesn't care about the index position of its\n        children within the parent.\n\n    :attr:`fullscreen` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to False.\n    '''\n\n    allow_fullscreen = BooleanProperty(True)\n    '''By default, you can double-tap on the video to make it fullscreen. Set\n    this property to False to prevent this behavior.\n\n    :attr:`allow_fullscreen` is a :class:`~kivy.properties.BooleanProperty`\n    defaults to True.\n    '''\n\n    options = DictProperty({})\n    '''Optional parameters can be passed to a :class:`~kivy.uix.video.Video`\n    instance with this property.\n\n    :attr:`options` a :class:`~kivy.properties.DictProperty` and\n    defaults to {}.\n    '''\n\n    # internals\n    container = ObjectProperty(None)\n\n    _video_load_ev = None\n\n    def __init__(self, **kwargs):\n        self._video = None\n        self._image = None\n        self._annotations = ''\n        self._annotations_labels = []\n        super(VideoPlayer, self).__init__(**kwargs)\n        update_thumbnail = self._update_thumbnail\n        update_annotations = self._update_annotations\n        fbind = self.fbind\n        fbind('thumbnail', update_thumbnail)\n        fbind('annotations', update_annotations)\n\n        if self.source:\n            self._trigger_video_load()\n\n    def _trigger_video_load(self, *largs):\n        ev = self._video_load_ev\n        if ev is None:\n            ev = self._video_load_ev = Clock.schedule_once(self._do_video_load,\n                                                           -1)\n        ev()\n\n    def _try_load_default_thumbnail(self, *largs):\n        if not self.thumbnail:\n            filename = self.source.rsplit('.', 1)\n            thumbnail = filename[0] + '.png'\n            if exists(thumbnail):\n                self._load_thumbnail(thumbnail)\n\n    def _try_load_default_annotations(self, *largs):\n        if not self.annotations:\n            filename = self.source.rsplit('.', 1)\n            annotations = filename[0] + '.jsa'\n            if exists(annotations):\n                self._load_annotations(annotations)\n\n    def on_source(self, instance, value):\n        # By default, VideoPlayer should look for thumbnail and annotations\n        # with the same filename (except extension) of the source (video) file.\n        Clock.schedule_once(self._try_load_default_thumbnail, -1)\n        Clock.schedule_once(self._try_load_default_annotations, -1)\n        if self._video is not None:\n            self._video.unload()\n            self._video = None\n        if value:\n            self._trigger_video_load()\n\n    def _update_thumbnail(self, *largs):\n        self._load_thumbnail(self.thumbnail)\n\n    def _update_annotations(self, *largs):\n        self._load_annotations(self.annotations)\n\n    def on_image_overlay_play(self, instance, value):\n        self._image.image_overlay_play = value\n\n    def on_image_loading(self, instance, value):\n        self._image.image_loading = value\n\n    def _load_thumbnail(self, thumbnail):\n        if not self.container:\n            return\n        self.container.clear_widgets()\n        if thumbnail:\n            self._image = VideoPlayerPreview(source=thumbnail, video=self)\n            self.container.add_widget(self._image)\n\n    def _load_annotations(self, annotations):\n        if not self.container:\n            return\n        self._annotations_labels = []\n        if annotations:\n            with open(annotations, 'r') as fd:\n                self._annotations = load(fd)\n            if self._annotations:\n                for ann in self._annotations:\n                    self._annotations_labels.append(\n                        VideoPlayerAnnotation(annotation=ann))\n\n    def on_state(self, instance, value):\n        if self._video is not None:\n            self._video.state = value\n\n    def _set_state(self, instance, value):\n        self.state = value\n\n    def _do_video_load(self, *largs):\n        self._video = Video(source=self.source, state=self.state,\n                            volume=self.volume, pos_hint={'x': 0, 'y': 0},\n                            **self.options)\n        self._video.bind(texture=self._play_started,\n                         duration=self.setter('duration'),\n                         position=self.setter('position'),\n                         volume=self.setter('volume'),\n                         state=self._set_state)\n\n    def on_play(self, instance, value):\n        value = 'play' if value else 'stop'\n        return self.on_state(instance, value)\n\n    def on_volume(self, instance, value):\n        if not self._video:\n            return\n        self._video.volume = value\n\n    def on_position(self, instance, value):\n        labels = self._annotations_labels\n        if not labels:\n            return\n        for label in labels:\n            start = label.start\n            duration = label.duration\n            if start > value or (start + duration) < value:\n                if label.parent:\n                    label.parent.remove_widget(label)\n            elif label.parent is None:\n                self.container.add_widget(label)\n\n    def seek(self, percent, precise=True):\n        '''Change the position to a percentage (strictly, a proportion)\n           of duration.\n\n        :Parameters:\n            `percent`: float or int\n                Position to seek as a proportion of total duration, must\n                be between 0-1.\n            `precise`: bool, defaults to True\n                Precise seeking is slower, but seeks to exact requested\n                percent.\n\n        .. warning::\n            Calling seek() before the video is loaded has no effect.\n\n        .. versionadded:: 1.2.0\n\n        .. versionchanged:: 1.10.1\n            The `precise` keyword argument has been added.\n        '''\n        if not self._video:\n            return\n        self._video.seek(percent, precise=precise)\n\n    def _play_started(self, instance, value):\n        self.container.clear_widgets()\n        self.container.add_widget(self._video)\n\n    def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return False\n        if touch.is_double_tap and self.allow_fullscreen:\n            self.fullscreen = not self.fullscreen\n            return True\n        return super(VideoPlayer, self).on_touch_down(touch)\n\n    def on_fullscreen(self, instance, value):\n        window = self.get_parent_window()\n        if not window:\n            Logger.warning('VideoPlayer: Cannot switch to fullscreen, '\n                           'window not found.')\n            if value:\n                self.fullscreen = False\n            return\n        if not self.parent:\n            Logger.warning('VideoPlayer: Cannot switch to fullscreen, '\n                           'no parent.')\n            if value:\n                self.fullscreen = False\n            return\n\n        if value:\n            self._fullscreen_state = state = {\n                'parent': self.parent,\n                'pos': self.pos,\n                'size': self.size,\n                'pos_hint': self.pos_hint,\n                'size_hint': self.size_hint,\n                'window_children': window.children[:]}\n\n            # remove all window children\n            for child in window.children[:]:\n                window.remove_widget(child)\n\n            # put the video in fullscreen\n            if state['parent'] is not window:\n                state['parent'].remove_widget(self)\n            window.add_widget(self)\n\n            # ensure the video widget is in 0, 0, and the size will be\n            # readjusted\n            self.pos = (0, 0)\n            self.size = (100, 100)\n            self.pos_hint = {}\n            self.size_hint = (1, 1)\n        else:\n            state = self._fullscreen_state\n            window.remove_widget(self)\n            for child in state['window_children']:\n                window.add_widget(child)\n            self.pos_hint = state['pos_hint']\n            self.size_hint = state['size_hint']\n            self.pos = state['pos']\n            self.size = state['size']\n            if state['parent'] is not window:\n                state['parent'].add_widget(self)",
  "def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return False\n        touch.grab(self)\n        # save the current volume and delta to it\n        touch.ud[self.uid] = [self.video.volume, 0]\n        return True",
  "def on_touch_move(self, touch):\n        if touch.grab_current is not self:\n            return\n        # calculate delta\n        dy = abs(touch.y - touch.oy)\n        if dy > 10:\n            dy = min(dy - 10, 100)\n            touch.ud[self.uid][1] = dy\n            self.video.volume = dy / 100.\n        return True",
  "def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n        dy = abs(touch.y - touch.oy)\n        if dy < 10:\n            if self.video.volume > 0:\n                self.video.volume = 0\n            else:\n                self.video.volume = 1.",
  "def on_touch_down(self, touch):\n        '''.. versionchanged:: 1.4.0'''\n        if self.collide_point(*touch.pos):\n            if self.video.state == 'play':\n                self.video.state = 'pause'\n            else:\n                self.video.state = 'play'\n            return True",
  "def on_touch_down(self, touch):\n        if self.collide_point(*touch.pos):\n            self.video.state = 'stop'\n            self.video.position = 0\n            return True",
  "def __init__(self, **kwargs):\n        super(VideoPlayerProgressBar, self).__init__(**kwargs)\n        self.bubble = Factory.Bubble(size=(50, 44))\n        self.bubble_label = Factory.Label(text='0:00')\n        self.bubble.add_widget(self.bubble_label)\n        self.add_widget(self.bubble)\n\n        update = self._update_bubble\n        fbind = self.fbind\n        fbind('pos', update)\n        fbind('size', update)\n        fbind('seek', update)",
  "def on_video(self, instance, value):\n        self.video.bind(position=self._update_bubble,\n                        state=self._showhide_bubble)",
  "def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return\n        self._show_bubble()\n        touch.grab(self)\n        self._update_seek(touch.x)\n        return True",
  "def on_touch_move(self, touch):\n        if touch.grab_current is not self:\n            return\n        self._update_seek(touch.x)\n        return True",
  "def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n        if self.seek:\n            self.video.seek(self.seek)\n        self.seek = None\n        self._hide_bubble()\n        return True",
  "def _update_seek(self, x):\n        if self.width == 0:\n            return\n        x = max(self.x, min(self.right, x)) - self.x\n        self.seek = x / float(self.width)",
  "def _show_bubble(self):\n        self.alpha = 1\n        Animation.stop_all(self, 'alpha')",
  "def _hide_bubble(self):\n        self.alpha = 1.\n        Animation(alpha=0, d=4, t='in_out_expo').start(self)",
  "def on_alpha(self, instance, value):\n        self.bubble.background_color = (1, 1, 1, value)\n        self.bubble_label.color = (1, 1, 1, value)",
  "def _update_bubble(self, *l):\n        seek = self.seek\n        if self.seek is None:\n            if self.video.duration == 0:\n                seek = 0\n            else:\n                seek = self.video.position / self.video.duration\n        # convert to minutes:seconds\n        d = self.video.duration * seek\n        minutes = int(d / 60)\n        seconds = int(d - (minutes * 60))\n        # fix bubble label & position\n        self.bubble_label.text = '%d:%02d' % (minutes, seconds)\n        self.bubble.center_x = self.x + seek * self.width\n        self.bubble.y = self.top",
  "def _showhide_bubble(self, instance, value):\n        if value == 'play':\n            self._hide_bubble()\n        else:\n            self._show_bubble()",
  "def on_touch_down(self, touch):\n        if self.collide_point(*touch.pos) and not self.click_done:\n            self.click_done = True\n            self.video.state = 'play'\n        return True",
  "def on_annotation(self, instance, ann):\n        for key, value in ann.items():\n            setattr(self, key, value)",
  "def __init__(self, **kwargs):\n        self._video = None\n        self._image = None\n        self._annotations = ''\n        self._annotations_labels = []\n        super(VideoPlayer, self).__init__(**kwargs)\n        update_thumbnail = self._update_thumbnail\n        update_annotations = self._update_annotations\n        fbind = self.fbind\n        fbind('thumbnail', update_thumbnail)\n        fbind('annotations', update_annotations)\n\n        if self.source:\n            self._trigger_video_load()",
  "def _trigger_video_load(self, *largs):\n        ev = self._video_load_ev\n        if ev is None:\n            ev = self._video_load_ev = Clock.schedule_once(self._do_video_load,\n                                                           -1)\n        ev()",
  "def _try_load_default_thumbnail(self, *largs):\n        if not self.thumbnail:\n            filename = self.source.rsplit('.', 1)\n            thumbnail = filename[0] + '.png'\n            if exists(thumbnail):\n                self._load_thumbnail(thumbnail)",
  "def _try_load_default_annotations(self, *largs):\n        if not self.annotations:\n            filename = self.source.rsplit('.', 1)\n            annotations = filename[0] + '.jsa'\n            if exists(annotations):\n                self._load_annotations(annotations)",
  "def on_source(self, instance, value):\n        # By default, VideoPlayer should look for thumbnail and annotations\n        # with the same filename (except extension) of the source (video) file.\n        Clock.schedule_once(self._try_load_default_thumbnail, -1)\n        Clock.schedule_once(self._try_load_default_annotations, -1)\n        if self._video is not None:\n            self._video.unload()\n            self._video = None\n        if value:\n            self._trigger_video_load()",
  "def _update_thumbnail(self, *largs):\n        self._load_thumbnail(self.thumbnail)",
  "def _update_annotations(self, *largs):\n        self._load_annotations(self.annotations)",
  "def on_image_overlay_play(self, instance, value):\n        self._image.image_overlay_play = value",
  "def on_image_loading(self, instance, value):\n        self._image.image_loading = value",
  "def _load_thumbnail(self, thumbnail):\n        if not self.container:\n            return\n        self.container.clear_widgets()\n        if thumbnail:\n            self._image = VideoPlayerPreview(source=thumbnail, video=self)\n            self.container.add_widget(self._image)",
  "def _load_annotations(self, annotations):\n        if not self.container:\n            return\n        self._annotations_labels = []\n        if annotations:\n            with open(annotations, 'r') as fd:\n                self._annotations = load(fd)\n            if self._annotations:\n                for ann in self._annotations:\n                    self._annotations_labels.append(\n                        VideoPlayerAnnotation(annotation=ann))",
  "def on_state(self, instance, value):\n        if self._video is not None:\n            self._video.state = value",
  "def _set_state(self, instance, value):\n        self.state = value",
  "def _do_video_load(self, *largs):\n        self._video = Video(source=self.source, state=self.state,\n                            volume=self.volume, pos_hint={'x': 0, 'y': 0},\n                            **self.options)\n        self._video.bind(texture=self._play_started,\n                         duration=self.setter('duration'),\n                         position=self.setter('position'),\n                         volume=self.setter('volume'),\n                         state=self._set_state)",
  "def on_play(self, instance, value):\n        value = 'play' if value else 'stop'\n        return self.on_state(instance, value)",
  "def on_volume(self, instance, value):\n        if not self._video:\n            return\n        self._video.volume = value",
  "def on_position(self, instance, value):\n        labels = self._annotations_labels\n        if not labels:\n            return\n        for label in labels:\n            start = label.start\n            duration = label.duration\n            if start > value or (start + duration) < value:\n                if label.parent:\n                    label.parent.remove_widget(label)\n            elif label.parent is None:\n                self.container.add_widget(label)",
  "def seek(self, percent, precise=True):\n        '''Change the position to a percentage (strictly, a proportion)\n           of duration.\n\n        :Parameters:\n            `percent`: float or int\n                Position to seek as a proportion of total duration, must\n                be between 0-1.\n            `precise`: bool, defaults to True\n                Precise seeking is slower, but seeks to exact requested\n                percent.\n\n        .. warning::\n            Calling seek() before the video is loaded has no effect.\n\n        .. versionadded:: 1.2.0\n\n        .. versionchanged:: 1.10.1\n            The `precise` keyword argument has been added.\n        '''\n        if not self._video:\n            return\n        self._video.seek(percent, precise=precise)",
  "def _play_started(self, instance, value):\n        self.container.clear_widgets()\n        self.container.add_widget(self._video)",
  "def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return False\n        if touch.is_double_tap and self.allow_fullscreen:\n            self.fullscreen = not self.fullscreen\n            return True\n        return super(VideoPlayer, self).on_touch_down(touch)",
  "def on_fullscreen(self, instance, value):\n        window = self.get_parent_window()\n        if not window:\n            Logger.warning('VideoPlayer: Cannot switch to fullscreen, '\n                           'window not found.')\n            if value:\n                self.fullscreen = False\n            return\n        if not self.parent:\n            Logger.warning('VideoPlayer: Cannot switch to fullscreen, '\n                           'no parent.')\n            if value:\n                self.fullscreen = False\n            return\n\n        if value:\n            self._fullscreen_state = state = {\n                'parent': self.parent,\n                'pos': self.pos,\n                'size': self.size,\n                'pos_hint': self.pos_hint,\n                'size_hint': self.size_hint,\n                'window_children': window.children[:]}\n\n            # remove all window children\n            for child in window.children[:]:\n                window.remove_widget(child)\n\n            # put the video in fullscreen\n            if state['parent'] is not window:\n                state['parent'].remove_widget(self)\n            window.add_widget(self)\n\n            # ensure the video widget is in 0, 0, and the size will be\n            # readjusted\n            self.pos = (0, 0)\n            self.size = (100, 100)\n            self.pos_hint = {}\n            self.size_hint = (1, 1)\n        else:\n            state = self._fullscreen_state\n            window.remove_widget(self)\n            for child in state['window_children']:\n                window.add_widget(child)\n            self.pos_hint = state['pos_hint']\n            self.size_hint = state['size_hint']\n            self.pos = state['pos']\n            self.size = state['size']\n            if state['parent'] is not window:\n                state['parent'].add_widget(self)",
  "class SettingSpacer(Widget):\n    # Internal class, not documented.\n    pass",
  "class SettingItem(FloatLayout):\n    '''Base class for individual settings (within a panel). This class cannot\n    be used directly; it is used for implementing the other setting classes.\n    It builds a row with a title/description (left) and a setting control\n    (right).\n\n    Look at :class:`SettingBoolean`, :class:`SettingNumeric` and\n    :class:`SettingOptions` for usage examples.\n\n    :Events:\n        `on_release`\n            Fired when the item is touched and then released.\n\n    '''\n\n    title = StringProperty('<No title set>')\n    '''Title of the setting, defaults to '<No title set>'.\n\n    :attr:`title` is a :class:`~kivy.properties.StringProperty` and defaults\n    to '<No title set>'.\n    '''\n\n    desc = StringProperty(None, allownone=True)\n    '''Description of the setting, rendered on the line below the title.\n\n    :attr:`desc` is a :class:`~kivy.properties.StringProperty` and defaults to\n    None.\n    '''\n\n    disabled = BooleanProperty(False)\n    '''Indicate if this setting is disabled. If True, all touches on the\n    setting item will be discarded.\n\n    :attr:`disabled` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    section = StringProperty(None)\n    '''Section of the token inside the :class:`~kivy.config.ConfigParser`\n    instance.\n\n    :attr:`section` is a :class:`~kivy.properties.StringProperty` and defaults\n    to None.\n    '''\n\n    key = StringProperty(None)\n    '''Key of the token inside the :attr:`section` in the\n    :class:`~kivy.config.ConfigParser` instance.\n\n    :attr:`key` is a :class:`~kivy.properties.StringProperty` and defaults to\n    None.\n    '''\n\n    value = ObjectProperty(None)\n    '''Value of the token according to the :class:`~kivy.config.ConfigParser`\n    instance. Any change to this value will trigger a\n    :meth:`Settings.on_config_change` event.\n\n    :attr:`value` is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    panel = ObjectProperty(None)\n    '''(internal) Reference to the SettingsPanel for this setting. You don't\n    need to use it.\n\n    :attr:`panel` is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    content = ObjectProperty(None)\n    '''(internal) Reference to the widget that contains the real setting.\n    As soon as the content object is set, any further call to add_widget will\n    call the content.add_widget. This is automatically set.\n\n    :attr:`content` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    selected_alpha = NumericProperty(0)\n    '''(internal) Float value from 0 to 1, used to animate the background when\n    the user touches the item.\n\n    :attr:`selected_alpha` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    __events__ = ('on_release', )\n\n    def __init__(self, **kwargs):\n        super(SettingItem, self).__init__(**kwargs)\n        self.value = self.panel.get_value(self.section, self.key)\n\n    def add_widget(self, *args, **kwargs):\n        if self.content is None:\n            return super(SettingItem, self).add_widget(*args, **kwargs)\n        return self.content.add_widget(*args, **kwargs)\n\n    def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return\n        if self.disabled:\n            return\n        touch.grab(self)\n        self.selected_alpha = 1\n        return super(SettingItem, self).on_touch_down(touch)\n\n    def on_touch_up(self, touch):\n        if touch.grab_current is self:\n            touch.ungrab(self)\n            self.dispatch('on_release')\n            Animation(selected_alpha=0, d=.25, t='out_quad').start(self)\n            return True\n        return super(SettingItem, self).on_touch_up(touch)\n\n    def on_release(self):\n        pass\n\n    def on_value(self, instance, value):\n        if not self.section or not self.key:\n            return\n        # get current value in config\n        panel = self.panel\n        if not isinstance(value, string_types):\n            value = str(value)\n        panel.set_value(self.section, self.key, value)",
  "class SettingBoolean(SettingItem):\n    '''Implementation of a boolean setting on top of a :class:`SettingItem`.\n    It is visualized with a :class:`~kivy.uix.switch.Switch` widget.\n    By default, 0 and 1 are used for values: you can change them by setting\n    :attr:`values`.\n    '''\n\n    values = ListProperty(['0', '1'])\n    '''Values used to represent the state of the setting. If you want to use\n    \"yes\" and \"no\" in your ConfigParser instance::\n\n        SettingBoolean(..., values=['no', 'yes'])\n\n    .. warning::\n\n        You need a minimum of two values, the index 0 will be used as False,\n        and index 1 as True\n\n    :attr:`values` is a :class:`~kivy.properties.ListProperty` and defaults to\n    ['0', '1']\n    '''",
  "class SettingString(SettingItem):\n    '''Implementation of a string setting on top of a :class:`SettingItem`.\n    It is visualized with a :class:`~kivy.uix.label.Label` widget that, when\n    clicked, will open a :class:`~kivy.uix.popup.Popup` with a\n    :class:`~kivy.uix.textinput.Textinput` so the user can enter a custom\n    value.\n    '''\n\n    popup = ObjectProperty(None, allownone=True)\n    '''(internal) Used to store the current popup when it's shown.\n\n    :attr:`popup` is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    textinput = ObjectProperty(None)\n    '''(internal) Used to store the current textinput from the popup and\n    to listen for changes.\n\n    :attr:`textinput` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    def on_panel(self, instance, value):\n        if value is None:\n            return\n        self.fbind('on_release', self._create_popup)\n\n    def _dismiss(self, *largs):\n        if self.textinput:\n            self.textinput.focus = False\n        if self.popup:\n            self.popup.dismiss()\n        self.popup = None\n\n    def _validate(self, instance):\n        self._dismiss()\n        value = self.textinput.text.strip()\n        self.value = value\n\n    def _create_popup(self, instance):\n        # create popup layout\n        content = BoxLayout(orientation='vertical', spacing='5dp')\n        popup_width = min(0.95 * Window.width, dp(500))\n        self.popup = popup = Popup(\n            title=self.title, content=content, size_hint=(None, None),\n            size=(popup_width, '250dp'))\n\n        # create the textinput used for numeric input\n        self.textinput = textinput = TextInput(\n            text=self.value, font_size='24sp', multiline=False,\n            size_hint_y=None, height='42sp')\n        textinput.bind(on_text_validate=self._validate)\n        self.textinput = textinput\n\n        # construct the content, widget are used as a spacer\n        content.add_widget(Widget())\n        content.add_widget(textinput)\n        content.add_widget(Widget())\n        content.add_widget(SettingSpacer())\n\n        # 2 buttons are created for accept or cancel the current value\n        btnlayout = BoxLayout(size_hint_y=None, height='50dp', spacing='5dp')\n        btn = Button(text='Ok')\n        btn.bind(on_release=self._validate)\n        btnlayout.add_widget(btn)\n        btn = Button(text='Cancel')\n        btn.bind(on_release=self._dismiss)\n        btnlayout.add_widget(btn)\n        content.add_widget(btnlayout)\n\n        # all done, open the popup !\n        popup.open()",
  "class SettingPath(SettingItem):\n    '''Implementation of a Path setting on top of a :class:`SettingItem`.\n    It is visualized with a :class:`~kivy.uix.label.Label` widget that, when\n    clicked, will open a :class:`~kivy.uix.popup.Popup` with a\n    :class:`~kivy.uix.filechooser.FileChooserListView` so the user can enter\n    a custom value.\n\n    .. versionadded:: 1.1.0\n    '''\n\n    popup = ObjectProperty(None, allownone=True)\n    '''(internal) Used to store the current popup when it is shown.\n\n    :attr:`popup` is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    textinput = ObjectProperty(None)\n    '''(internal) Used to store the current textinput from the popup and\n    to listen for changes.\n\n    :attr:`textinput` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    show_hidden = BooleanProperty(False)\n    '''Whether to show 'hidden' filenames. What that means is\n    operating-system-dependent.\n\n    :attr:`show_hidden` is an :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    dirselect = BooleanProperty(True)\n    '''Whether to allow selection of directories.\n\n    :attr:`dirselect` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    def on_panel(self, instance, value):\n        if value is None:\n            return\n        self.fbind('on_release', self._create_popup)\n\n    def _dismiss(self, *largs):\n        if self.textinput:\n            self.textinput.focus = False\n        if self.popup:\n            self.popup.dismiss()\n        self.popup = None\n\n    def _validate(self, instance):\n        self._dismiss()\n        value = self.textinput.selection\n\n        if not value:\n            return\n\n        self.value = os.path.realpath(value[0])\n\n    def _create_popup(self, instance):\n        # create popup layout\n        content = BoxLayout(orientation='vertical', spacing=5)\n        popup_width = min(0.95 * Window.width, dp(500))\n        self.popup = popup = Popup(\n            title=self.title, content=content, size_hint=(None, 0.9),\n            width=popup_width)\n\n        # create the filechooser\n        initial_path = self.value or os.getcwd()\n        self.textinput = textinput = FileChooserListView(\n            path=initial_path, size_hint=(1, 1),\n            dirselect=self.dirselect, show_hidden=self.show_hidden)\n        textinput.bind(on_path=self._validate)\n\n        # construct the content\n        content.add_widget(textinput)\n        content.add_widget(SettingSpacer())\n\n        # 2 buttons are created for accept or cancel the current value\n        btnlayout = BoxLayout(size_hint_y=None, height='50dp', spacing='5dp')\n        btn = Button(text='Ok')\n        btn.bind(on_release=self._validate)\n        btnlayout.add_widget(btn)\n        btn = Button(text='Cancel')\n        btn.bind(on_release=self._dismiss)\n        btnlayout.add_widget(btn)\n        content.add_widget(btnlayout)\n\n        # all done, open the popup !\n        popup.open()",
  "class SettingColor(SettingItem):\n    '''Implementation of a color setting on top of a :class:`SettingItem`.\n    It is visualized with a :class:`~kivy.uix.label.Label` widget and a\n    colored canvas rectangle that, when clicked, will open a\n    :class:`~kivy.uix.popup.Popup` with a\n    :class:`~kivy.uix.colorpicker.ColorPicker` so the user can choose a color.\n\n    .. versionadded:: 2.0.1\n    '''\n\n    popup = ObjectProperty(None, allownone=True)\n    '''(internal) Used to store the current popup when it's shown.\n\n    :attr:`popup` is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    def on_panel(self, instance, value):\n        if value is None:\n            return\n        self.bind(on_release=self._create_popup)\n\n    def _dismiss(self, *largs):\n        if self.popup:\n            self.popup.dismiss()\n        self.popup = None\n\n    def _validate(self, instance):\n        self._dismiss()\n        value = utils.get_hex_from_color(self.colorpicker.color)\n        self.value = value\n\n    def _create_popup(self, instance):\n        # create popup layout\n        content = BoxLayout(orientation='vertical', spacing='5dp')\n        popup_width = min(0.95 * Window.width, dp(500))\n        self.popup = popup = Popup(\n            title=self.title, content=content, size_hint=(None, 0.9),\n            width=popup_width)\n\n        self.colorpicker = colorpicker = \\\n            ColorPicker(color=utils.get_color_from_hex(self.value))\n        colorpicker.bind(on_color=self._validate)\n\n        self.colorpicker = colorpicker\n        content.add_widget(colorpicker)\n        content.add_widget(SettingSpacer())\n\n        # 2 buttons are created for accept or cancel the current value\n        btnlayout = BoxLayout(size_hint_y=None, height='50dp', spacing='5dp')\n        btn = Button(text='Ok')\n        btn.bind(on_release=self._validate)\n        btnlayout.add_widget(btn)\n        btn = Button(text='Cancel')\n        btn.bind(on_release=self._dismiss)\n        btnlayout.add_widget(btn)\n        content.add_widget(btnlayout)\n\n        # all done, open the popup !\n        popup.open()",
  "class SettingNumeric(SettingString):\n    '''Implementation of a numeric setting on top of a :class:`SettingString`.\n    It is visualized with a :class:`~kivy.uix.label.Label` widget that, when\n    clicked, will open a :class:`~kivy.uix.popup.Popup` with a\n    :class:`~kivy.uix.textinput.Textinput` so the user can enter a custom\n    value.\n    '''\n\n    def _validate(self, instance):\n        # we know the type just by checking if there is a '.' in the original\n        # value\n        is_float = '.' in str(self.value)\n        self._dismiss()\n        try:\n            if is_float:\n                self.value = text_type(float(self.textinput.text))\n            else:\n                self.value = text_type(int(self.textinput.text))\n        except ValueError:\n            return",
  "class SettingOptions(SettingItem):\n    '''Implementation of an option list on top of a :class:`SettingItem`.\n    It is visualized with a :class:`~kivy.uix.label.Label` widget that, when\n    clicked, will open a :class:`~kivy.uix.popup.Popup` with a\n    list of options from which the user can select.\n    '''\n\n    options = ListProperty([])\n    '''List of all availables options. This must be a list of \"string\" items.\n    Otherwise, it will crash. :)\n\n    :attr:`options` is a :class:`~kivy.properties.ListProperty` and defaults\n    to [].\n    '''\n\n    popup = ObjectProperty(None, allownone=True)\n    '''(internal) Used to store the current popup when it is shown.\n\n    :attr:`popup` is an :class:`~kivy.properties.ObjectProperty` and defaults\n    to None.\n    '''\n\n    def on_panel(self, instance, value):\n        if value is None:\n            return\n        self.fbind('on_release', self._create_popup)\n\n    def _set_option(self, instance):\n        self.value = instance.text\n        self.popup.dismiss()\n\n    def _create_popup(self, instance):\n        # create the popup\n        content = BoxLayout(orientation='vertical', spacing='5dp')\n        popup_width = min(0.95 * Window.width, dp(500))\n        self.popup = popup = Popup(\n            content=content, title=self.title, size_hint=(None, None),\n            size=(popup_width, '400dp'))\n        popup.height = len(self.options) * dp(55) + dp(150)\n\n        # add all the options\n        content.add_widget(Widget(size_hint_y=None, height=1))\n        uid = str(self.uid)\n        for option in self.options:\n            state = 'down' if option == self.value else 'normal'\n            btn = ToggleButton(text=option, state=state, group=uid)\n            btn.bind(on_release=self._set_option)\n            content.add_widget(btn)\n\n        # finally, add a cancel button to return on the previous panel\n        content.add_widget(SettingSpacer())\n        btn = Button(text='Cancel', size_hint_y=None, height=dp(50))\n        btn.bind(on_release=popup.dismiss)\n        content.add_widget(btn)\n\n        # and open the popup !\n        popup.open()",
  "class SettingTitle(Label):\n    '''A simple title label, used to organize the settings in sections.\n    '''\n\n    title = Label.text\n\n    panel = ObjectProperty(None)",
  "class SettingsPanel(GridLayout):\n    '''This class is used to construct panel settings, for use with a\n    :class:`Settings` instance or subclass.\n    '''\n\n    title = StringProperty('Default title')\n    '''Title of the panel. The title will be reused by the :class:`Settings` in\n    the sidebar.\n    '''\n\n    config = ObjectProperty(None, allownone=True)\n    '''A :class:`kivy.config.ConfigParser` instance. See module documentation\n    for more information.\n    '''\n\n    settings = ObjectProperty(None)\n    '''A :class:`Settings` instance that will be used to fire the\n    `on_config_change` event.\n    '''\n\n    def __init__(self, **kwargs):\n        kwargs.setdefault('cols', 1)\n        super(SettingsPanel, self).__init__(**kwargs)\n\n    def on_config(self, instance, value):\n        if value is None:\n            return\n        if not isinstance(value, ConfigParser):\n            raise Exception('Invalid config object, you must use a'\n                            'kivy.config.ConfigParser, not another one !')\n\n    def get_value(self, section, key):\n        '''Return the value of the section/key from the :attr:`config`\n        ConfigParser instance. This function is used by :class:`SettingItem` to\n        get the value for a given section/key.\n\n        If you don't want to use a ConfigParser instance, you might want to\n        override this function.\n        '''\n        config = self.config\n        if not config:\n            return\n        return config.get(section, key)\n\n    def set_value(self, section, key, value):\n        current = self.get_value(section, key)\n        if current == value:\n            return\n        config = self.config\n        if config:\n            config.set(section, key, value)\n            config.write()\n        settings = self.settings\n        if settings:\n            settings.dispatch('on_config_change',\n                              config, section, key, value)",
  "class InterfaceWithSidebar(BoxLayout):\n    '''The default Settings interface class. It displays a sidebar menu\n    with names of available settings panels, which may be used to switch\n    which one is currently displayed.\n\n    See :meth:`~InterfaceWithSidebar.add_panel` for information on the\n    method you must implement if creating your own interface.\n\n    This class also dispatches an event 'on_close', which is triggered\n    when the sidebar menu's close button is released. If creating your\n    own interface widget, it should also dispatch such an event which\n    will automatically be caught by :class:`Settings` and used to\n    trigger its own 'on_close' event.\n\n    '''\n\n    menu = ObjectProperty()\n    '''(internal) A reference to the sidebar menu widget.\n\n    :attr:`menu` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    content = ObjectProperty()\n    '''(internal) A reference to the panel display widget (a\n    :class:`ContentPanel`).\n\n    :attr:`content` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n\n    '''\n\n    __events__ = ('on_close', )\n\n    def __init__(self, *args, **kwargs):\n        super(InterfaceWithSidebar, self).__init__(*args, **kwargs)\n        self.menu.close_button.bind(\n            on_release=lambda j: self.dispatch('on_close'))\n\n    def add_panel(self, panel, name, uid):\n        '''This method is used by Settings to add new panels for possible\n        display. Any replacement for ContentPanel *must* implement\n        this method.\n\n        :Parameters:\n            `panel`: :class:`SettingsPanel`\n                It should be stored and the interface should provide a way to\n                switch between panels.\n            `name`:\n                The name of the panel as a string. It may be used to represent\n                the panel but isn't necessarily unique.\n            `uid`:\n                A unique int identifying the panel. It should be used to\n                identify and switch between panels.\n\n        '''\n        self.menu.add_item(name, uid)\n        self.content.add_panel(panel, name, uid)\n\n    def on_close(self, *args):\n        pass",
  "class InterfaceWithSpinner(BoxLayout):\n    '''A settings interface that displays a spinner at the top for\n    switching between panels.\n\n    The workings of this class are considered internal and are not\n    documented. See :meth:`InterfaceWithSidebar` for\n    information on implementing your own interface class.\n\n    '''\n\n    __events__ = ('on_close', )\n\n    menu = ObjectProperty()\n    '''(internal) A reference to the sidebar menu widget.\n\n    :attr:`menu` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n    '''\n\n    content = ObjectProperty()\n    '''(internal) A reference to the panel display widget (a\n    :class:`ContentPanel`).\n\n    :attr:`menu` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n\n    '''\n\n    def __init__(self, *args, **kwargs):\n        super(InterfaceWithSpinner, self).__init__(*args, **kwargs)\n        self.menu.close_button.bind(\n            on_release=lambda j: self.dispatch('on_close'))\n\n    def add_panel(self, panel, name, uid):\n        '''This method is used by Settings to add new panels for possible\n        display. Any replacement for ContentPanel *must* implement\n        this method.\n\n        :Parameters:\n            `panel`: :class:`SettingsPanel`\n                It should be stored and the interface should provide a way to\n                switch between panels.\n            `name`:\n                The name of the panel as a string. It may be used to represent\n                the panel but may not be unique.\n            `uid`:\n                A unique int identifying the panel. It should be used to\n                identify and switch between panels.\n\n        '''\n        self.content.add_panel(panel, name, uid)\n        self.menu.add_item(name, uid)\n\n    def on_close(self, *args):\n        pass",
  "class ContentPanel(ScrollView):\n    '''A class for displaying settings panels. It displays a single\n    settings panel at a time, taking up the full size and shape of the\n    ContentPanel. It is used by :class:`InterfaceWithSidebar` and\n    :class:`InterfaceWithSpinner` to display settings.\n\n    '''\n\n    panels = DictProperty({})\n    '''(internal) Stores a dictionary mapping settings panels to their uids.\n\n    :attr:`panels` is a :class:`~kivy.properties.DictProperty` and\n    defaults to {}.\n\n    '''\n\n    container = ObjectProperty()\n    '''(internal) A reference to the GridLayout that contains the\n    settings panel.\n\n    :attr:`container` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n\n    '''\n\n    current_panel = ObjectProperty(None)\n    '''(internal) A reference to the current settings panel.\n\n    :attr:`current_panel` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n\n    '''\n\n    current_uid = NumericProperty(0)\n    '''(internal) A reference to the uid of the current settings panel.\n\n    :attr:`current_uid` is a\n    :class:`~kivy.properties.NumericProperty` and defaults to 0.\n\n    '''\n\n    def add_panel(self, panel, name, uid):\n        '''This method is used by Settings to add new panels for possible\n        display. Any replacement for ContentPanel *must* implement\n        this method.\n\n        :Parameters:\n            `panel`: :class:`SettingsPanel`\n                It should be stored and displayed when requested.\n            `name`:\n                The name of the panel as a string. It may be used to represent\n                the panel.\n            `uid`:\n                A unique int identifying the panel. It should be stored and\n                used to identify panels when switching.\n\n        '''\n        self.panels[uid] = panel\n        if not self.current_uid:\n            self.current_uid = uid\n\n    def on_current_uid(self, *args):\n        '''The uid of the currently displayed panel. Changing this will\n        automatically change the displayed panel.\n\n        :Parameters:\n            `uid`:\n                A panel uid. It should be used to retrieve and display\n                a settings panel that has previously been added with\n                :meth:`add_panel`.\n\n        '''\n        uid = self.current_uid\n        if uid in self.panels:\n            if self.current_panel is not None:\n                self.remove_widget(self.current_panel)\n            new_panel = self.panels[uid]\n            self.add_widget(new_panel)\n            self.current_panel = new_panel\n            return True\n        return False  # New uid doesn't exist\n\n    def add_widget(self, *args, **kwargs):\n        if self.container is None:\n            super(ContentPanel, self).add_widget(*args, **kwargs)\n        else:\n            self.container.add_widget(*args, **kwargs)\n\n    def remove_widget(self, *args, **kwargs):\n        self.container.remove_widget(*args, **kwargs)",
  "class Settings(BoxLayout):\n\n    '''Settings UI. Check module documentation for more information on how\n    to use this class.\n\n    :Events:\n        `on_config_change`: ConfigParser instance, section, key, value\n            Fired when the section's key-value pair of a ConfigParser changes.\n\n            .. warning:\n\n                value will be str/unicode type, regardless of the setting\n                type (numeric, boolean, etc)\n        `on_close`\n            Fired by the default panel when the Close button is pressed.\n\n        '''\n\n    interface = ObjectProperty(None)\n    '''(internal) Reference to the widget that will contain, organise and\n    display the panel configuration panel widgets.\n\n    :attr:`interface` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to None.\n\n    '''\n\n    interface_cls = ObjectProperty(InterfaceWithSidebar)\n    '''The widget class that will be used to display the graphical\n    interface for the settings panel. By default, it displays one Settings\n    panel at a time with a sidebar to switch between them.\n\n    :attr:`interface_cls` is an\n    :class:`~kivy.properties.ObjectProperty` and defaults to\n    :class:`InterfaceWithSidebar`.\n\n    .. versionchanged:: 1.8.0\n        If you set a string, the :class:`~kivy.factory.Factory` will be used to\n        resolve the class.\n\n    '''\n\n    __events__ = ('on_close', 'on_config_change')\n\n    def __init__(self, *args, **kargs):\n        self._types = {}\n        super(Settings, self).__init__(*args, **kargs)\n        self.add_interface()\n        self.register_type('string', SettingString)\n        self.register_type('bool', SettingBoolean)\n        self.register_type('numeric', SettingNumeric)\n        self.register_type('options', SettingOptions)\n        self.register_type('title', SettingTitle)\n        self.register_type('path', SettingPath)\n        self.register_type('color', SettingColor)\n\n    def on_touch_down(self, touch):\n        if self.collide_point(*touch.pos):\n            super(Settings, self).on_touch_down(touch)\n            return True\n\n    def register_type(self, tp, cls):\n        '''Register a new type that can be used in the JSON definition.\n        '''\n        self._types[tp] = cls\n\n    def on_close(self, *args):\n        pass\n\n    def add_interface(self):\n        '''(Internal) creates an instance of :attr:`Settings.interface_cls`,\n        and sets it to :attr:`~Settings.interface`. When json panels are\n        created, they will be added to this interface which will display them\n        to the user.\n        '''\n        cls = self.interface_cls\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n        interface = cls()\n        self.interface = interface\n        self.add_widget(interface)\n        self.interface.bind(on_close=lambda j: self.dispatch('on_close'))\n\n    def on_config_change(self, config, section, key, value):\n        pass\n\n    def add_json_panel(self, title, config, filename=None, data=None):\n        '''Create and add a new :class:`SettingsPanel` using the configuration\n        `config` with the JSON definition `filename`. If `filename` is not set,\n        then the JSON definition is read from the `data` parameter instead.\n\n        Check the :ref:`settings_json` section in the documentation for more\n        information about JSON format and the usage of this function.\n        '''\n        panel = self.create_json_panel(title, config, filename, data)\n        uid = panel.uid\n        if self.interface is not None:\n            self.interface.add_panel(panel, title, uid)\n\n    def create_json_panel(self, title, config, filename=None, data=None):\n        '''Create new :class:`SettingsPanel`.\n\n        .. versionadded:: 1.5.0\n\n        Check the documentation of :meth:`add_json_panel` for more information.\n        '''\n        if filename is None and data is None:\n            raise Exception('You must specify either the filename or data')\n        if filename is not None:\n            with open(filename, 'r') as fd:\n                data = json.loads(fd.read())\n        else:\n            data = json.loads(data)\n        if isinstance(data, list):\n            raise ValueError('The first element must be a list')\n        panel = SettingsPanel(title=title, settings=self, config=config)\n\n        for setting in data:\n            # determine the type and the class to use\n            if 'type' not in setting:\n                raise ValueError('One setting are missing the \"type\" element')\n            ttype = setting['type']\n            cls = self._types.get(ttype)\n            if cls is None:\n                raise ValueError(\n                    'No class registered to handle the <%s> type' %\n                    setting['type'])\n\n            # create a instance of the class, without the type attribute\n            del setting['type']\n            str_settings = {}\n            for key, item in setting.items():\n                str_settings[str(key)] = item\n\n            instance = cls(panel=panel, **str_settings)\n\n            # instance created, add to the panel\n            panel.add_widget(instance)\n\n        return panel\n\n    def add_kivy_panel(self):\n        '''Add a panel for configuring Kivy. This panel acts directly on the\n        kivy configuration. Feel free to include or exclude it in your\n        configuration.\n\n        See :meth:`~kivy.app.App.use_kivy_settings` for information on\n        enabling/disabling the automatic kivy panel.\n\n        '''\n        from kivy import kivy_data_dir\n        from kivy.config import Config\n        from os.path import join\n        self.add_json_panel('Kivy', Config,\n                            join(kivy_data_dir, 'settings_kivy.json'))",
  "class SettingsWithSidebar(Settings):\n    '''A settings widget that displays settings panels with a sidebar to\n    switch between them. This is the default behavior of\n    :class:`Settings`, and this widget is a trivial wrapper subclass.\n\n    '''",
  "class SettingsWithSpinner(Settings):\n    '''A settings widget that displays one settings panel at a time with a\n    spinner at the top to switch between them.\n\n    '''\n    def __init__(self, *args, **kwargs):\n        self.interface_cls = InterfaceWithSpinner\n        super(SettingsWithSpinner, self).__init__(*args, **kwargs)",
  "class SettingsWithTabbedPanel(Settings):\n    '''A settings widget that displays settings panels as pages in a\n    :class:`~kivy.uix.tabbedpanel.TabbedPanel`.\n    '''\n\n    __events__ = ('on_close', )\n\n    def __init__(self, *args, **kwargs):\n        self.interface_cls = InterfaceWithTabbedPanel\n        super(SettingsWithTabbedPanel, self).__init__(*args, **kwargs)\n\n    def on_close(self, *args):\n        pass",
  "class SettingsWithNoMenu(Settings):\n    '''A settings widget that displays a single settings panel with *no*\n    Close button. It will not accept more than one Settings panel. It\n    is intended for use in programs with few enough settings that a\n    full panel switcher is not useful.\n\n    .. warning::\n\n        This Settings panel does *not* provide a Close\n        button, and so it is impossible to leave the settings screen\n        unless you also add other behavior or override\n        :meth:`~kivy.app.App.display_settings` and\n        :meth:`~kivy.app.App.close_settings`.\n\n    '''\n    def __init__(self, *args, **kwargs):\n        self.interface_cls = InterfaceWithNoMenu\n        super(SettingsWithNoMenu, self).__init__(*args, **kwargs)",
  "class InterfaceWithNoMenu(ContentPanel):\n    '''The interface widget used by :class:`SettingsWithNoMenu`. It\n    stores and displays a single settings panel.\n\n    This widget is considered internal and is not documented. See the\n    :class:`ContentPanel` for information on defining your own content\n    widget.\n\n    '''\n    def add_widget(self, *args, **kwargs):\n        if self.container is not None and len(self.container.children) > 0:\n            raise Exception(\n                'ContentNoMenu cannot accept more than one settings panel')\n        super(InterfaceWithNoMenu, self).add_widget(*args, **kwargs)",
  "class InterfaceWithTabbedPanel(FloatLayout):\n    '''The content widget used by :class:`SettingsWithTabbedPanel`. It\n    stores and displays Settings panels in tabs of a TabbedPanel.\n\n    This widget is considered internal and is not documented. See\n    :class:`InterfaceWithSidebar` for information on defining your own\n    interface widget.\n\n    '''\n    tabbedpanel = ObjectProperty()\n    close_button = ObjectProperty()\n\n    __events__ = ('on_close', )\n\n    def __init__(self, *args, **kwargs):\n        super(InterfaceWithTabbedPanel, self).__init__(*args, **kwargs)\n        self.close_button.bind(on_release=lambda j: self.dispatch('on_close'))\n\n    def add_panel(self, panel, name, uid):\n        scrollview = ScrollView()\n        scrollview.add_widget(panel)\n        if not self.tabbedpanel.default_tab_content:\n            self.tabbedpanel.default_tab_text = name\n            self.tabbedpanel.default_tab_content = scrollview\n        else:\n            panelitem = TabbedPanelHeader(text=name, content=scrollview)\n            self.tabbedpanel.add_widget(panelitem)\n\n    def on_close(self, *args):\n        pass",
  "class MenuSpinner(BoxLayout):\n    '''The menu class used by :class:`SettingsWithSpinner`. It provides a\n    sidebar with an entry for each settings panel.\n\n    This widget is considered internal and is not documented. See\n    :class:`MenuSidebar` for information on menus and creating your own menu\n    class.\n\n    '''\n    selected_uid = NumericProperty(0)\n    close_button = ObjectProperty(0)\n    spinner = ObjectProperty()\n    panel_names = DictProperty({})\n    spinner_text = StringProperty()\n    close_button = ObjectProperty()\n\n    def add_item(self, name, uid):\n        values = self.spinner.values\n        if name in values:\n            i = 2\n            while name + ' {}'.format(i) in values:\n                i += 1\n            name = name + ' {}'.format(i)\n        self.panel_names[name] = uid\n        self.spinner.values.append(name)\n        if not self.spinner.text:\n            self.spinner.text = name\n\n    def on_spinner_text(self, *args):\n        text = self.spinner_text\n        self.selected_uid = self.panel_names[text]",
  "class MenuSidebar(FloatLayout):\n    '''The menu used by :class:`InterfaceWithSidebar`. It provides a\n    sidebar with an entry for each settings panel, which the user may\n    click to select.\n\n    '''\n\n    selected_uid = NumericProperty(0)\n    '''The uid of the currently selected panel. This may be used to switch\n    between displayed panels, e.g. by binding it to the\n    :attr:`~ContentPanel.current_uid` of a :class:`ContentPanel`.\n\n    :attr:`selected_uid` is a\n    :class:`~kivy.properties.NumericProperty` and defaults to 0.\n\n    '''\n\n    buttons_layout = ObjectProperty(None)\n    '''(internal) Reference to the GridLayout that contains individual\n    settings panel menu buttons.\n\n    :attr:`buttons_layout` is an\n    :class:`~kivy.properties.ObjectProperty` and defaults to None.\n\n    '''\n\n    close_button = ObjectProperty(None)\n    '''(internal) Reference to the widget's Close button.\n\n    :attr:`buttons_layout` is an\n    :class:`~kivy.properties.ObjectProperty` and defaults to None.\n\n    '''\n\n    def add_item(self, name, uid):\n        '''This method is used to add new panels to the menu.\n\n        :Parameters:\n            `name`:\n                The name (a string) of the panel. It should be used\n                to represent the panel in the menu.\n            `uid`:\n                The name (an int) of the panel. It should be used internally\n                to represent the panel and used to set self.selected_uid when\n                the panel is changed.\n\n        '''\n\n        label = SettingSidebarLabel(text=name, uid=uid, menu=self)\n        if len(self.buttons_layout.children) == 0:\n            label.selected = True\n        if self.buttons_layout is not None:\n            self.buttons_layout.add_widget(label)\n\n    def on_selected_uid(self, *args):\n        '''(internal) unselects any currently selected menu buttons, unless\n        they represent the current panel.\n\n        '''\n        for button in self.buttons_layout.children:\n            if button.uid != self.selected_uid:\n                button.selected = False",
  "class SettingSidebarLabel(Label):\n    # Internal class, not documented.\n    selected = BooleanProperty(False)\n    uid = NumericProperty(0)\n    menu = ObjectProperty(None)\n\n    def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return\n        self.selected = True\n        self.menu.selected_uid = self.uid",
  "def __init__(self, **kwargs):\n        super(SettingItem, self).__init__(**kwargs)\n        self.value = self.panel.get_value(self.section, self.key)",
  "def add_widget(self, *args, **kwargs):\n        if self.content is None:\n            return super(SettingItem, self).add_widget(*args, **kwargs)\n        return self.content.add_widget(*args, **kwargs)",
  "def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return\n        if self.disabled:\n            return\n        touch.grab(self)\n        self.selected_alpha = 1\n        return super(SettingItem, self).on_touch_down(touch)",
  "def on_touch_up(self, touch):\n        if touch.grab_current is self:\n            touch.ungrab(self)\n            self.dispatch('on_release')\n            Animation(selected_alpha=0, d=.25, t='out_quad').start(self)\n            return True\n        return super(SettingItem, self).on_touch_up(touch)",
  "def on_release(self):\n        pass",
  "def on_value(self, instance, value):\n        if not self.section or not self.key:\n            return\n        # get current value in config\n        panel = self.panel\n        if not isinstance(value, string_types):\n            value = str(value)\n        panel.set_value(self.section, self.key, value)",
  "def on_panel(self, instance, value):\n        if value is None:\n            return\n        self.fbind('on_release', self._create_popup)",
  "def _dismiss(self, *largs):\n        if self.textinput:\n            self.textinput.focus = False\n        if self.popup:\n            self.popup.dismiss()\n        self.popup = None",
  "def _validate(self, instance):\n        self._dismiss()\n        value = self.textinput.text.strip()\n        self.value = value",
  "def _create_popup(self, instance):\n        # create popup layout\n        content = BoxLayout(orientation='vertical', spacing='5dp')\n        popup_width = min(0.95 * Window.width, dp(500))\n        self.popup = popup = Popup(\n            title=self.title, content=content, size_hint=(None, None),\n            size=(popup_width, '250dp'))\n\n        # create the textinput used for numeric input\n        self.textinput = textinput = TextInput(\n            text=self.value, font_size='24sp', multiline=False,\n            size_hint_y=None, height='42sp')\n        textinput.bind(on_text_validate=self._validate)\n        self.textinput = textinput\n\n        # construct the content, widget are used as a spacer\n        content.add_widget(Widget())\n        content.add_widget(textinput)\n        content.add_widget(Widget())\n        content.add_widget(SettingSpacer())\n\n        # 2 buttons are created for accept or cancel the current value\n        btnlayout = BoxLayout(size_hint_y=None, height='50dp', spacing='5dp')\n        btn = Button(text='Ok')\n        btn.bind(on_release=self._validate)\n        btnlayout.add_widget(btn)\n        btn = Button(text='Cancel')\n        btn.bind(on_release=self._dismiss)\n        btnlayout.add_widget(btn)\n        content.add_widget(btnlayout)\n\n        # all done, open the popup !\n        popup.open()",
  "def on_panel(self, instance, value):\n        if value is None:\n            return\n        self.fbind('on_release', self._create_popup)",
  "def _dismiss(self, *largs):\n        if self.textinput:\n            self.textinput.focus = False\n        if self.popup:\n            self.popup.dismiss()\n        self.popup = None",
  "def _validate(self, instance):\n        self._dismiss()\n        value = self.textinput.selection\n\n        if not value:\n            return\n\n        self.value = os.path.realpath(value[0])",
  "def _create_popup(self, instance):\n        # create popup layout\n        content = BoxLayout(orientation='vertical', spacing=5)\n        popup_width = min(0.95 * Window.width, dp(500))\n        self.popup = popup = Popup(\n            title=self.title, content=content, size_hint=(None, 0.9),\n            width=popup_width)\n\n        # create the filechooser\n        initial_path = self.value or os.getcwd()\n        self.textinput = textinput = FileChooserListView(\n            path=initial_path, size_hint=(1, 1),\n            dirselect=self.dirselect, show_hidden=self.show_hidden)\n        textinput.bind(on_path=self._validate)\n\n        # construct the content\n        content.add_widget(textinput)\n        content.add_widget(SettingSpacer())\n\n        # 2 buttons are created for accept or cancel the current value\n        btnlayout = BoxLayout(size_hint_y=None, height='50dp', spacing='5dp')\n        btn = Button(text='Ok')\n        btn.bind(on_release=self._validate)\n        btnlayout.add_widget(btn)\n        btn = Button(text='Cancel')\n        btn.bind(on_release=self._dismiss)\n        btnlayout.add_widget(btn)\n        content.add_widget(btnlayout)\n\n        # all done, open the popup !\n        popup.open()",
  "def on_panel(self, instance, value):\n        if value is None:\n            return\n        self.bind(on_release=self._create_popup)",
  "def _dismiss(self, *largs):\n        if self.popup:\n            self.popup.dismiss()\n        self.popup = None",
  "def _validate(self, instance):\n        self._dismiss()\n        value = utils.get_hex_from_color(self.colorpicker.color)\n        self.value = value",
  "def _create_popup(self, instance):\n        # create popup layout\n        content = BoxLayout(orientation='vertical', spacing='5dp')\n        popup_width = min(0.95 * Window.width, dp(500))\n        self.popup = popup = Popup(\n            title=self.title, content=content, size_hint=(None, 0.9),\n            width=popup_width)\n\n        self.colorpicker = colorpicker = \\\n            ColorPicker(color=utils.get_color_from_hex(self.value))\n        colorpicker.bind(on_color=self._validate)\n\n        self.colorpicker = colorpicker\n        content.add_widget(colorpicker)\n        content.add_widget(SettingSpacer())\n\n        # 2 buttons are created for accept or cancel the current value\n        btnlayout = BoxLayout(size_hint_y=None, height='50dp', spacing='5dp')\n        btn = Button(text='Ok')\n        btn.bind(on_release=self._validate)\n        btnlayout.add_widget(btn)\n        btn = Button(text='Cancel')\n        btn.bind(on_release=self._dismiss)\n        btnlayout.add_widget(btn)\n        content.add_widget(btnlayout)\n\n        # all done, open the popup !\n        popup.open()",
  "def _validate(self, instance):\n        # we know the type just by checking if there is a '.' in the original\n        # value\n        is_float = '.' in str(self.value)\n        self._dismiss()\n        try:\n            if is_float:\n                self.value = text_type(float(self.textinput.text))\n            else:\n                self.value = text_type(int(self.textinput.text))\n        except ValueError:\n            return",
  "def on_panel(self, instance, value):\n        if value is None:\n            return\n        self.fbind('on_release', self._create_popup)",
  "def _set_option(self, instance):\n        self.value = instance.text\n        self.popup.dismiss()",
  "def _create_popup(self, instance):\n        # create the popup\n        content = BoxLayout(orientation='vertical', spacing='5dp')\n        popup_width = min(0.95 * Window.width, dp(500))\n        self.popup = popup = Popup(\n            content=content, title=self.title, size_hint=(None, None),\n            size=(popup_width, '400dp'))\n        popup.height = len(self.options) * dp(55) + dp(150)\n\n        # add all the options\n        content.add_widget(Widget(size_hint_y=None, height=1))\n        uid = str(self.uid)\n        for option in self.options:\n            state = 'down' if option == self.value else 'normal'\n            btn = ToggleButton(text=option, state=state, group=uid)\n            btn.bind(on_release=self._set_option)\n            content.add_widget(btn)\n\n        # finally, add a cancel button to return on the previous panel\n        content.add_widget(SettingSpacer())\n        btn = Button(text='Cancel', size_hint_y=None, height=dp(50))\n        btn.bind(on_release=popup.dismiss)\n        content.add_widget(btn)\n\n        # and open the popup !\n        popup.open()",
  "def __init__(self, **kwargs):\n        kwargs.setdefault('cols', 1)\n        super(SettingsPanel, self).__init__(**kwargs)",
  "def on_config(self, instance, value):\n        if value is None:\n            return\n        if not isinstance(value, ConfigParser):\n            raise Exception('Invalid config object, you must use a'\n                            'kivy.config.ConfigParser, not another one !')",
  "def get_value(self, section, key):\n        '''Return the value of the section/key from the :attr:`config`\n        ConfigParser instance. This function is used by :class:`SettingItem` to\n        get the value for a given section/key.\n\n        If you don't want to use a ConfigParser instance, you might want to\n        override this function.\n        '''\n        config = self.config\n        if not config:\n            return\n        return config.get(section, key)",
  "def set_value(self, section, key, value):\n        current = self.get_value(section, key)\n        if current == value:\n            return\n        config = self.config\n        if config:\n            config.set(section, key, value)\n            config.write()\n        settings = self.settings\n        if settings:\n            settings.dispatch('on_config_change',\n                              config, section, key, value)",
  "def __init__(self, *args, **kwargs):\n        super(InterfaceWithSidebar, self).__init__(*args, **kwargs)\n        self.menu.close_button.bind(\n            on_release=lambda j: self.dispatch('on_close'))",
  "def add_panel(self, panel, name, uid):\n        '''This method is used by Settings to add new panels for possible\n        display. Any replacement for ContentPanel *must* implement\n        this method.\n\n        :Parameters:\n            `panel`: :class:`SettingsPanel`\n                It should be stored and the interface should provide a way to\n                switch between panels.\n            `name`:\n                The name of the panel as a string. It may be used to represent\n                the panel but isn't necessarily unique.\n            `uid`:\n                A unique int identifying the panel. It should be used to\n                identify and switch between panels.\n\n        '''\n        self.menu.add_item(name, uid)\n        self.content.add_panel(panel, name, uid)",
  "def on_close(self, *args):\n        pass",
  "def __init__(self, *args, **kwargs):\n        super(InterfaceWithSpinner, self).__init__(*args, **kwargs)\n        self.menu.close_button.bind(\n            on_release=lambda j: self.dispatch('on_close'))",
  "def add_panel(self, panel, name, uid):\n        '''This method is used by Settings to add new panels for possible\n        display. Any replacement for ContentPanel *must* implement\n        this method.\n\n        :Parameters:\n            `panel`: :class:`SettingsPanel`\n                It should be stored and the interface should provide a way to\n                switch between panels.\n            `name`:\n                The name of the panel as a string. It may be used to represent\n                the panel but may not be unique.\n            `uid`:\n                A unique int identifying the panel. It should be used to\n                identify and switch between panels.\n\n        '''\n        self.content.add_panel(panel, name, uid)\n        self.menu.add_item(name, uid)",
  "def on_close(self, *args):\n        pass",
  "def add_panel(self, panel, name, uid):\n        '''This method is used by Settings to add new panels for possible\n        display. Any replacement for ContentPanel *must* implement\n        this method.\n\n        :Parameters:\n            `panel`: :class:`SettingsPanel`\n                It should be stored and displayed when requested.\n            `name`:\n                The name of the panel as a string. It may be used to represent\n                the panel.\n            `uid`:\n                A unique int identifying the panel. It should be stored and\n                used to identify panels when switching.\n\n        '''\n        self.panels[uid] = panel\n        if not self.current_uid:\n            self.current_uid = uid",
  "def on_current_uid(self, *args):\n        '''The uid of the currently displayed panel. Changing this will\n        automatically change the displayed panel.\n\n        :Parameters:\n            `uid`:\n                A panel uid. It should be used to retrieve and display\n                a settings panel that has previously been added with\n                :meth:`add_panel`.\n\n        '''\n        uid = self.current_uid\n        if uid in self.panels:\n            if self.current_panel is not None:\n                self.remove_widget(self.current_panel)\n            new_panel = self.panels[uid]\n            self.add_widget(new_panel)\n            self.current_panel = new_panel\n            return True\n        return False",
  "def add_widget(self, *args, **kwargs):\n        if self.container is None:\n            super(ContentPanel, self).add_widget(*args, **kwargs)\n        else:\n            self.container.add_widget(*args, **kwargs)",
  "def remove_widget(self, *args, **kwargs):\n        self.container.remove_widget(*args, **kwargs)",
  "def __init__(self, *args, **kargs):\n        self._types = {}\n        super(Settings, self).__init__(*args, **kargs)\n        self.add_interface()\n        self.register_type('string', SettingString)\n        self.register_type('bool', SettingBoolean)\n        self.register_type('numeric', SettingNumeric)\n        self.register_type('options', SettingOptions)\n        self.register_type('title', SettingTitle)\n        self.register_type('path', SettingPath)\n        self.register_type('color', SettingColor)",
  "def on_touch_down(self, touch):\n        if self.collide_point(*touch.pos):\n            super(Settings, self).on_touch_down(touch)\n            return True",
  "def register_type(self, tp, cls):\n        '''Register a new type that can be used in the JSON definition.\n        '''\n        self._types[tp] = cls",
  "def on_close(self, *args):\n        pass",
  "def add_interface(self):\n        '''(Internal) creates an instance of :attr:`Settings.interface_cls`,\n        and sets it to :attr:`~Settings.interface`. When json panels are\n        created, they will be added to this interface which will display them\n        to the user.\n        '''\n        cls = self.interface_cls\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n        interface = cls()\n        self.interface = interface\n        self.add_widget(interface)\n        self.interface.bind(on_close=lambda j: self.dispatch('on_close'))",
  "def on_config_change(self, config, section, key, value):\n        pass",
  "def add_json_panel(self, title, config, filename=None, data=None):\n        '''Create and add a new :class:`SettingsPanel` using the configuration\n        `config` with the JSON definition `filename`. If `filename` is not set,\n        then the JSON definition is read from the `data` parameter instead.\n\n        Check the :ref:`settings_json` section in the documentation for more\n        information about JSON format and the usage of this function.\n        '''\n        panel = self.create_json_panel(title, config, filename, data)\n        uid = panel.uid\n        if self.interface is not None:\n            self.interface.add_panel(panel, title, uid)",
  "def create_json_panel(self, title, config, filename=None, data=None):\n        '''Create new :class:`SettingsPanel`.\n\n        .. versionadded:: 1.5.0\n\n        Check the documentation of :meth:`add_json_panel` for more information.\n        '''\n        if filename is None and data is None:\n            raise Exception('You must specify either the filename or data')\n        if filename is not None:\n            with open(filename, 'r') as fd:\n                data = json.loads(fd.read())\n        else:\n            data = json.loads(data)\n        if isinstance(data, list):\n            raise ValueError('The first element must be a list')\n        panel = SettingsPanel(title=title, settings=self, config=config)\n\n        for setting in data:\n            # determine the type and the class to use\n            if 'type' not in setting:\n                raise ValueError('One setting are missing the \"type\" element')\n            ttype = setting['type']\n            cls = self._types.get(ttype)\n            if cls is None:\n                raise ValueError(\n                    'No class registered to handle the <%s> type' %\n                    setting['type'])\n\n            # create a instance of the class, without the type attribute\n            del setting['type']\n            str_settings = {}\n            for key, item in setting.items():\n                str_settings[str(key)] = item\n\n            instance = cls(panel=panel, **str_settings)\n\n            # instance created, add to the panel\n            panel.add_widget(instance)\n\n        return panel",
  "def add_kivy_panel(self):\n        '''Add a panel for configuring Kivy. This panel acts directly on the\n        kivy configuration. Feel free to include or exclude it in your\n        configuration.\n\n        See :meth:`~kivy.app.App.use_kivy_settings` for information on\n        enabling/disabling the automatic kivy panel.\n\n        '''\n        from kivy import kivy_data_dir\n        from kivy.config import Config\n        from os.path import join\n        self.add_json_panel('Kivy', Config,\n                            join(kivy_data_dir, 'settings_kivy.json'))",
  "def __init__(self, *args, **kwargs):\n        self.interface_cls = InterfaceWithSpinner\n        super(SettingsWithSpinner, self).__init__(*args, **kwargs)",
  "def __init__(self, *args, **kwargs):\n        self.interface_cls = InterfaceWithTabbedPanel\n        super(SettingsWithTabbedPanel, self).__init__(*args, **kwargs)",
  "def on_close(self, *args):\n        pass",
  "def __init__(self, *args, **kwargs):\n        self.interface_cls = InterfaceWithNoMenu\n        super(SettingsWithNoMenu, self).__init__(*args, **kwargs)",
  "def add_widget(self, *args, **kwargs):\n        if self.container is not None and len(self.container.children) > 0:\n            raise Exception(\n                'ContentNoMenu cannot accept more than one settings panel')\n        super(InterfaceWithNoMenu, self).add_widget(*args, **kwargs)",
  "def __init__(self, *args, **kwargs):\n        super(InterfaceWithTabbedPanel, self).__init__(*args, **kwargs)\n        self.close_button.bind(on_release=lambda j: self.dispatch('on_close'))",
  "def add_panel(self, panel, name, uid):\n        scrollview = ScrollView()\n        scrollview.add_widget(panel)\n        if not self.tabbedpanel.default_tab_content:\n            self.tabbedpanel.default_tab_text = name\n            self.tabbedpanel.default_tab_content = scrollview\n        else:\n            panelitem = TabbedPanelHeader(text=name, content=scrollview)\n            self.tabbedpanel.add_widget(panelitem)",
  "def on_close(self, *args):\n        pass",
  "def add_item(self, name, uid):\n        values = self.spinner.values\n        if name in values:\n            i = 2\n            while name + ' {}'.format(i) in values:\n                i += 1\n            name = name + ' {}'.format(i)\n        self.panel_names[name] = uid\n        self.spinner.values.append(name)\n        if not self.spinner.text:\n            self.spinner.text = name",
  "def on_spinner_text(self, *args):\n        text = self.spinner_text\n        self.selected_uid = self.panel_names[text]",
  "def add_item(self, name, uid):\n        '''This method is used to add new panels to the menu.\n\n        :Parameters:\n            `name`:\n                The name (a string) of the panel. It should be used\n                to represent the panel in the menu.\n            `uid`:\n                The name (an int) of the panel. It should be used internally\n                to represent the panel and used to set self.selected_uid when\n                the panel is changed.\n\n        '''\n\n        label = SettingSidebarLabel(text=name, uid=uid, menu=self)\n        if len(self.buttons_layout.children) == 0:\n            label.selected = True\n        if self.buttons_layout is not None:\n            self.buttons_layout.add_widget(label)",
  "def on_selected_uid(self, *args):\n        '''(internal) unselects any currently selected menu buttons, unless\n        they represent the current panel.\n\n        '''\n        for button in self.buttons_layout.children:\n            if button.uid != self.selected_uid:\n                button.selected = False",
  "def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return\n        self.selected = True\n        self.menu.selected_uid = self.uid",
  "class SettingsApp(App):\n        demo_json_settings = json.dumps([\n            {\n                'type': 'color',\n                'title': 'Test color',\n                'desc': 'Your chosen Color',\n                'section': 'colorselection',\n                'key': 'testcolor'\n            }])\n\n        def build(self):\n            s = Settings()\n            s.add_kivy_panel()\n            s.add_json_panel('Color settings',\n                             self.config,\n                             data=self.demo_json_settings)\n            s.bind(on_close=self.stop)\n            return s\n\n        def build_config(self, config):\n            config.setdefaults('colorselection', {'testcolor': '#FF0000'})",
  "def build(self):\n            s = Settings()\n            s.add_kivy_panel()\n            s.add_json_panel('Color settings',\n                             self.config,\n                             data=self.demo_json_settings)\n            s.bind(on_close=self.stop)\n            return s",
  "def build_config(self, config):\n            config.setdefaults('colorselection', {'testcolor': '#FF0000'})",
  "class GestureContainer(EventDispatcher):\n    '''Container object that stores information about a gesture. It has\n    various properties that are updated by `GestureSurface` as drawing\n    progresses.\n\n    :Arguments:\n        `touch`\n            Touch object (as received by on_touch_down) used to initialize\n            the gesture container. Required.\n\n    :Properties:\n        `active`\n            Set to False once the gesture is complete (meets\n            `max_stroke` setting or `GestureSurface.temporal_window`)\n\n            :attr:`active` is a\n            :class:`~kivy.properties.BooleanProperty`\n\n        `active_strokes`\n            Number of strokes currently active in the gesture, ie\n            concurrent touches associated with this gesture.\n\n            :attr:`active_strokes` is a\n            :class:`~kivy.properties.NumericProperty`\n\n        `max_strokes`\n            Max number of strokes allowed in the gesture. This\n            is set by `GestureSurface.max_strokes` but can\n            be overridden for example from `on_gesture_start`.\n\n            :attr:`max_strokes` is a\n            :class:`~kivy.properties.NumericProperty`\n\n        `was_merged`\n            Indicates that this gesture has been merged with another\n            gesture and should be considered discarded.\n\n            :attr:`was_merged` is a\n            :class:`~kivy.properties.BooleanProperty`\n\n        `bbox`\n            Dictionary with keys minx, miny, maxx, maxy. Represents the size\n            of the gesture bounding box.\n\n            :attr:`bbox` is a\n            :class:`~kivy.properties.DictProperty`\n\n        `width`\n            Represents the width of the gesture.\n\n            :attr:`width` is a\n            :class:`~kivy.properties.NumericProperty`\n\n        `height`\n            Represents the height of the gesture.\n\n            :attr:`height` is a\n            :class:`~kivy.properties.NumericProperty`\n    '''\n    active = BooleanProperty(True)\n    active_strokes = NumericProperty(0)\n    max_strokes = NumericProperty(0)\n    was_merged = BooleanProperty(False)\n    bbox = DictProperty({'minx': float('inf'), 'miny': float('inf'),\n                         'maxx': float('-inf'), 'maxy': float('-inf')})\n    width = NumericProperty(0)\n    height = NumericProperty(0)\n\n    def __init__(self, touch, **kwargs):\n        # The color is applied to all canvas items of this gesture\n        self.color = kwargs.pop('color', [1., 1., 1.])\n\n        super(GestureContainer, self).__init__(**kwargs)\n\n        # This is the touch.uid of the oldest touch represented\n        self.id = str(touch.uid)\n\n        # Store various timestamps for decision making\n        self._create_time = Clock.get_time()\n        self._update_time = None\n        self._cleanup_time = None\n        self._cache_time = 0\n\n        # We can cache the candidate here to save zip()/Vector instantiation\n        self._vectors = None\n\n        # Key is touch.uid; value is a kivy.graphics.Line(); it's used even\n        # if line_width is 0 (i.e. not actually drawn anywhere)\n        self._strokes = {}\n\n        # Make sure the bbox is up to date with the first touch position\n        self.update_bbox(touch)\n\n    def get_vectors(self, **kwargs):\n        '''Return strokes in a format that is acceptable for\n        `kivy.multistroke.Recognizer` as a gesture candidate or template. The\n        result is cached automatically; the cache is invalidated at the start\n        and end of a stroke and if `update_bbox` is called. If you are going\n        to analyze a gesture mid-stroke, you may need to set the `no_cache`\n        argument to True.'''\n        if self._cache_time == self._update_time and \\\n                not kwargs.get('no_cache'):\n            return self._vectors\n\n        vecs = []\n        append = vecs.append\n        for tuid, l in self._strokes.items():\n            lpts = l.points\n            append([Vector(*pts) for pts in zip(lpts[::2], lpts[1::2])])\n\n        self._vectors = vecs\n        self._cache_time = self._update_time\n        return vecs\n\n    def handles(self, touch):\n        '''Returns True if this container handles the given touch'''\n        if not self.active:\n            return False\n        return str(touch.uid) in self._strokes\n\n    def accept_stroke(self, count=1):\n        '''Returns True if this container can accept `count` new strokes'''\n        if not self.max_strokes:\n            return True\n        return len(self._strokes) + count <= self.max_strokes\n\n    def update_bbox(self, touch):\n        '''Update gesture bbox from a touch coordinate'''\n        x, y = touch.x, touch.y\n        bb = self.bbox\n        if x < bb['minx']:\n            bb['minx'] = x\n        if y < bb['miny']:\n            bb['miny'] = y\n        if x > bb['maxx']:\n            bb['maxx'] = x\n        if y > bb['maxy']:\n            bb['maxy'] = y\n        self.width = bb['maxx'] - bb['minx']\n        self.height = bb['maxy'] - bb['miny']\n        self._update_time = Clock.get_time()\n\n    def add_stroke(self, touch, line):\n        '''Associate a list of points with a touch.uid; the line itself is\n        created by the caller, but subsequent move/up events look it\n        up via us. This is done to avoid problems during merge.'''\n        self._update_time = Clock.get_time()\n        self._strokes[str(touch.uid)] = line\n        self.active_strokes += 1\n\n    def complete_stroke(self):\n        '''Called on touch up events to keep track of how many strokes\n        are active in the gesture (we only want to dispatch event when\n        the *last* stroke in the gesture is released)'''\n        self._update_time = Clock.get_time()\n        self.active_strokes -= 1\n\n    def single_points_test(self):\n        '''Returns True if the gesture consists only of single-point strokes,\n        we must discard it in this case, or an exception will be raised'''\n        for tuid, l in self._strokes.items():\n            if len(l.points) > 2:\n                return False\n        return True",
  "class GestureSurface(FloatLayout):\n    '''Simple gesture surface to track/draw touch movements. Typically used\n    to gather user input suitable for :class:`kivy.multistroke.Recognizer`.\n\n    :Properties:\n        `temporal_window`\n            Time to wait from the last touch_up event before attempting\n            to recognize the gesture. If you set this to 0, the\n            `on_gesture_complete` event is not fired unless the\n            :attr:`max_strokes` condition is met.\n\n            :attr:`temporal_window` is a\n            :class:`~kivy.properties.NumericProperty` and defaults to 2.0\n\n        `max_strokes`\n            Max number of strokes in a single gesture; if this is reached,\n            recognition will start immediately on the final touch_up event.\n            If this is set to 0, the `on_gesture_complete` event is not\n            fired unless the :attr:`temporal_window` expires.\n\n            :attr:`max_strokes` is a\n            :class:`~kivy.properties.NumericProperty` and defaults to 2.0\n\n        `bbox_margin`\n            Bounding box margin for detecting gesture collisions, in\n            pixels.\n\n            :attr:`bbox_margin` is a\n            :class:`~kivy.properties.NumericProperty` and defaults to 30\n\n        `draw_timeout`\n            Number of seconds to keep lines/bbox on canvas after the\n            `on_gesture_complete` event is fired. If this is set to 0,\n            gestures are immediately removed from the surface when\n            complete.\n\n            :attr:`draw_timeout` is a\n            :class:`~kivy.properties.NumericProperty` and defaults to 3.0\n\n        `color`\n            Color used to draw the gesture, in RGB. This option does not\n            have an effect if :attr:`use_random_color` is True.\n\n            :attr:`color` is a\n            :class:`~kivy.properties.ColorProperty` and defaults to\n            [1, 1, 1, 1] (white)\n\n            .. versionchanged:: 2.0.0\n                Changed from :class:`~kivy.properties.ListProperty` to\n                :class:`~kivy.properties.ColorProperty`.\n\n        `use_random_color`\n            Set to True to pick a random color for each gesture, if you do\n            this then `color` is ignored. Defaults to False.\n\n            :attr:`use_random_color` is a\n            :class:`~kivy.properties.BooleanProperty` and defaults to False\n\n        `line_width`\n            Line width used for tracing touches on the surface. Set to 0\n            if you only want to detect gestures without drawing anything.\n            If you use 1.0, OpenGL GL_LINE is used for drawing; values > 1\n            will use an internal drawing method based on triangles (less\n            efficient), see :mod:`kivy.graphics`.\n\n            :attr:`line_width` is a\n            :class:`~kivy.properties.NumericProperty` and defaults to 2\n\n        `draw_bbox`\n            Set to True if you want to draw bounding box behind gestures.\n            This only works if `line_width` >= 1. Default is False.\n\n            :attr:`draw_bbox` is a\n            :class:`~kivy.properties.BooleanProperty` and defaults to True\n\n        `bbox_alpha`\n            Opacity for bounding box if `draw_bbox` is True. Default 0.1\n\n            :attr:`bbox_alpha` is a\n            :class:`~kivy.properties.NumericProperty` and defaults to 0.1\n\n    :Events:\n        `on_gesture_start` :class:`GestureContainer`\n            Fired when a new gesture is initiated on the surface, i.e. the\n            first on_touch_down that does not collide with an existing\n            gesture on the surface.\n\n        `on_gesture_extend` :class:`GestureContainer`\n            Fired when a touch_down event occurs within an existing gesture.\n\n        `on_gesture_merge` :class:`GestureContainer`, :class:`GestureContainer`\n            Fired when two gestures collide and get merged to one gesture.\n            The first argument is the gesture that has been merged (no longer\n            valid); the second is the combined (resulting) gesture.\n\n        `on_gesture_complete` :class:`GestureContainer`\n            Fired when a set of strokes is considered a complete gesture,\n            this happens when `temporal_window` expires or `max_strokes`\n            is reached. Typically you will bind to this event and use\n            the provided `GestureContainer` get_vectors() method to\n            match against your gesture database.\n\n        `on_gesture_cleanup` :class:`GestureContainer`\n            Fired `draw_timeout` seconds after `on_gesture_complete`,\n            The gesture will be removed from the canvas (if line_width > 0 or\n            draw_bbox is True) and the internal gesture list before this.\n\n        `on_gesture_discard` :class:`GestureContainer`\n            Fired when a gesture does not meet the minimum size requirements\n            for recognition (width/height < 5, or consists only of single-\n            point strokes).\n    '''\n\n    temporal_window = NumericProperty(2.0)\n    draw_timeout = NumericProperty(3.0)\n    max_strokes = NumericProperty(4)\n    bbox_margin = NumericProperty(30)\n\n    line_width = NumericProperty(2)\n    color = ColorProperty([1., 1., 1., 1.])\n    use_random_color = BooleanProperty(False)\n    draw_bbox = BooleanProperty(False)\n    bbox_alpha = NumericProperty(0.1)\n\n    def __init__(self, **kwargs):\n        super(GestureSurface, self).__init__(**kwargs)\n        # A list of GestureContainer objects (all gestures on the surface)\n        self._gestures = []\n        self.register_event_type('on_gesture_start')\n        self.register_event_type('on_gesture_extend')\n        self.register_event_type('on_gesture_merge')\n        self.register_event_type('on_gesture_complete')\n        self.register_event_type('on_gesture_cleanup')\n        self.register_event_type('on_gesture_discard')\n\n# -----------------------------------------------------------------------------\n# Touch Events\n# -----------------------------------------------------------------------------\n    def on_touch_down(self, touch):\n        '''When a new touch is registered, the first thing we do is to test if\n        it collides with the bounding box of another known gesture. If so, it\n        is assumed to be part of that gesture.\n        '''\n        # If the touch originates outside the surface, ignore it.\n        if not self.collide_point(touch.x, touch.y):\n            return\n\n        touch.grab(self)\n\n        # Add the stroke to existing gesture, or make a new one\n        g = self.find_colliding_gesture(touch)\n        new = False\n        if g is None:\n            g = self.init_gesture(touch)\n            new = True\n\n        # We now belong to a gesture (new or old); start a new stroke.\n        self.init_stroke(g, touch)\n\n        if new:\n            self.dispatch('on_gesture_start', g, touch)\n        else:\n            self.dispatch('on_gesture_extend', g, touch)\n\n        return True\n\n    def on_touch_move(self, touch):\n        '''When a touch moves, we add a point to the line on the canvas so the\n        path is updated. We must also check if the new point collides with the\n        bounding box of another gesture - if so, they should be merged.'''\n        if touch.grab_current is not self:\n            return\n        if not self.collide_point(touch.x, touch.y):\n            return\n\n        # Retrieve the GestureContainer object that handles this touch, and\n        # test for colliding gestures. If found, merge them to one.\n        g = self.get_gesture(touch)\n        collision = self.find_colliding_gesture(touch)\n        if collision is not None and g.accept_stroke(len(collision._strokes)):\n            merge = self.merge_gestures(g, collision)\n            if g.was_merged:\n                self.dispatch('on_gesture_merge', g, collision)\n            else:\n                self.dispatch('on_gesture_merge', collision, g)\n            g = merge\n        else:\n            g.update_bbox(touch)\n\n        # Add the new point to gesture stroke list and update the canvas line\n        g._strokes[str(touch.uid)].points += (touch.x, touch.y)\n\n        # Draw the gesture bounding box; if it is a single press that\n        # does not trigger a move event, we would miss it otherwise.\n        if self.draw_bbox:\n            self._update_canvas_bbox(g)\n        return True\n\n    def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n\n        g = self.get_gesture(touch)\n        g.complete_stroke()\n\n        # If this stroke hit the maximum limit, dispatch immediately\n        if not g.accept_stroke():\n            self._complete_dispatcher(0)\n\n        # dispatch later only if we have a window\n        elif self.temporal_window > 0:\n            Clock.schedule_once(self._complete_dispatcher,\n                                    self.temporal_window)\n\n# -----------------------------------------------------------------------------\n# Gesture related methods\n# -----------------------------------------------------------------------------\n    def init_gesture(self, touch):\n        '''Create a new gesture from touch, i.e. it's the first on\n        surface, or was not close enough to any existing gesture (yet)'''\n        col = self.color\n        if self.use_random_color:\n            col = hsv_to_rgb(random(), 1., 1.)\n\n        g = GestureContainer(touch, max_strokes=self.max_strokes, color=col)\n\n        # Create the bounding box Rectangle for the gesture\n        if self.draw_bbox:\n            bb = g.bbox\n            with self.canvas:\n                Color(col[0], col[1], col[2], self.bbox_alpha, mode='rgba',\n                      group=g.id)\n\n                g._bbrect = Rectangle(\n                    group=g.id,\n                    pos=(bb['minx'], bb['miny']),\n                    size=(bb['maxx'] - bb['minx'],\n                          bb['maxy'] - bb['miny']))\n\n        self._gestures.append(g)\n        return g\n\n    def init_stroke(self, g, touch):\n        points = [touch.x, touch.y]\n        col = g.color\n\n        new_line = Line(\n            points=points,\n            width=self.line_width,\n            group=g.id)\n        g._strokes[str(touch.uid)] = new_line\n\n        if self.line_width:\n            canvas_add = self.canvas.add\n            canvas_add(Color(col[0], col[1], col[2], mode='rgb', group=g.id))\n            canvas_add(new_line)\n\n        # Update the bbox in case; this will normally be done in on_touch_move,\n        # but we want to update it also for a single press, force that here:\n        g.update_bbox(touch)\n        if self.draw_bbox:\n            self._update_canvas_bbox(g)\n\n        # Register the stroke in GestureContainer so we can look it up later\n        g.add_stroke(touch, new_line)\n\n    def get_gesture(self, touch):\n        '''Returns GestureContainer associated with given touch'''\n        for g in self._gestures:\n            if g.active and g.handles(touch):\n                return g\n        raise Exception('get_gesture() failed to identify ' + str(touch.uid))\n\n    def find_colliding_gesture(self, touch):\n        '''Checks if a touch x/y collides with the bounding box of an existing\n        gesture. If so, return it (otherwise returns None)\n        '''\n        touch_x, touch_y = touch.pos\n        for g in self._gestures:\n            if g.active and not g.handles(touch) and g.accept_stroke():\n                bb = g.bbox\n                margin = self.bbox_margin\n                minx = bb['minx'] - margin\n                miny = bb['miny'] - margin\n                maxx = bb['maxx'] + margin\n                maxy = bb['maxy'] + margin\n                if minx <= touch_x <= maxx and miny <= touch_y <= maxy:\n                    return g\n        return None\n\n    def merge_gestures(self, g, other):\n        '''Merges two gestures together, the oldest one is retained and the\n        newer one gets the `GestureContainer.was_merged` flag raised.'''\n        # Swap order depending on gesture age (the merged gesture gets\n        # the color from the oldest one of the two).\n        swap = other._create_time < g._create_time\n        a = swap and other or g\n        b = swap and g or other\n\n        # Apply the outer limits of bbox to the merged gesture\n        abbox = a.bbox\n        bbbox = b.bbox\n        if bbbox['minx'] < abbox['minx']:\n            abbox['minx'] = bbbox['minx']\n        if bbbox['miny'] < abbox['miny']:\n            abbox['miny'] = bbbox['miny']\n        if bbbox['maxx'] > abbox['maxx']:\n            abbox['maxx'] = bbbox['maxx']\n        if bbbox['maxy'] > abbox['maxy']:\n            abbox['maxy'] = bbbox['maxy']\n\n        # Now transfer the coordinates from old to new gesture;\n        # FIXME: This can probably be copied more efficiently?\n        astrokes = a._strokes\n        lw = self.line_width\n        a_id = a.id\n        col = a.color\n\n        self.canvas.remove_group(b.id)\n        canv_add = self.canvas.add\n        for uid, old in b._strokes.items():\n            # FIXME: Can't figure out how to change group= for existing Line()\n            new_line = Line(\n                points=old.points,\n                width=old.width,\n                group=a_id)\n            astrokes[uid] = new_line\n            if lw:\n                canv_add(Color(col[0], col[1], col[2], mode='rgb', group=a_id))\n                canv_add(new_line)\n\n        b.active = False\n        b.was_merged = True\n        a.active_strokes += b.active_strokes\n        a._update_time = Clock.get_time()\n        return a\n\n    def _update_canvas_bbox(self, g):\n        # If draw_bbox is changed while two gestures are active,\n        # we might not have a bbrect member\n        if not hasattr(g, '_bbrect'):\n            return\n\n        bb = g.bbox\n        g._bbrect.pos = (bb['minx'], bb['miny'])\n        g._bbrect.size = (bb['maxx'] - bb['minx'],\n                          bb['maxy'] - bb['miny'])\n\n# -----------------------------------------------------------------------------\n# Timeout callbacks\n# -----------------------------------------------------------------------------\n    def _complete_dispatcher(self, dt):\n        '''This method is scheduled on all touch up events. It will dispatch\n        the `on_gesture_complete` event for all completed gestures, and remove\n        merged gestures from the internal gesture list.'''\n        need_cleanup = False\n        gest = self._gestures\n        timeout = self.draw_timeout\n        twin = self.temporal_window\n        get_time = Clock.get_time\n\n        for idx, g in enumerate(gest):\n            # Gesture is part of another gesture, just delete it\n            if g.was_merged:\n                del gest[idx]\n                continue\n\n            # Not active == already handled, or has active strokes (it cannot\n            # possibly be complete). Proceed to next gesture on surface.\n            if not g.active or g.active_strokes != 0:\n                continue\n\n            t1 = g._update_time + twin\n            t2 = get_time() + UNDERSHOOT_MARGIN\n\n            # max_strokes reached, or temporal window has expired. The gesture\n            # is complete; need to dispatch _complete or _discard event.\n            if not g.accept_stroke() or t1 <= t2:\n                discard = False\n                if g.width < 5 and g.height < 5:\n                    discard = True\n                elif g.single_points_test():\n                    discard = True\n\n                need_cleanup = True\n                g.active = False\n                g._cleanup_time = get_time() + timeout\n\n                if discard:\n                    self.dispatch('on_gesture_discard', g)\n                else:\n                    self.dispatch('on_gesture_complete', g)\n\n        if need_cleanup:\n            Clock.schedule_once(self._cleanup, timeout)\n\n    def _cleanup(self, dt):\n        '''This method is scheduled from _complete_dispatcher to clean up the\n        canvas and internal gesture list after a gesture is completed.'''\n        m = UNDERSHOOT_MARGIN\n        rg = self.canvas.remove_group\n        gestures = self._gestures\n        for idx, g in enumerate(gestures):\n            if g._cleanup_time is None:\n                continue\n            if g._cleanup_time <= Clock.get_time() + m:\n                rg(g.id)\n                del gestures[idx]\n                self.dispatch('on_gesture_cleanup', g)\n\n    def on_gesture_start(self, *l):\n        pass\n\n    def on_gesture_extend(self, *l):\n        pass\n\n    def on_gesture_merge(self, *l):\n        pass\n\n    def on_gesture_complete(self, *l):\n        pass\n\n    def on_gesture_discard(self, *l):\n        pass\n\n    def on_gesture_cleanup(self, *l):\n        pass",
  "def __init__(self, touch, **kwargs):\n        # The color is applied to all canvas items of this gesture\n        self.color = kwargs.pop('color', [1., 1., 1.])\n\n        super(GestureContainer, self).__init__(**kwargs)\n\n        # This is the touch.uid of the oldest touch represented\n        self.id = str(touch.uid)\n\n        # Store various timestamps for decision making\n        self._create_time = Clock.get_time()\n        self._update_time = None\n        self._cleanup_time = None\n        self._cache_time = 0\n\n        # We can cache the candidate here to save zip()/Vector instantiation\n        self._vectors = None\n\n        # Key is touch.uid; value is a kivy.graphics.Line(); it's used even\n        # if line_width is 0 (i.e. not actually drawn anywhere)\n        self._strokes = {}\n\n        # Make sure the bbox is up to date with the first touch position\n        self.update_bbox(touch)",
  "def get_vectors(self, **kwargs):\n        '''Return strokes in a format that is acceptable for\n        `kivy.multistroke.Recognizer` as a gesture candidate or template. The\n        result is cached automatically; the cache is invalidated at the start\n        and end of a stroke and if `update_bbox` is called. If you are going\n        to analyze a gesture mid-stroke, you may need to set the `no_cache`\n        argument to True.'''\n        if self._cache_time == self._update_time and \\\n                not kwargs.get('no_cache'):\n            return self._vectors\n\n        vecs = []\n        append = vecs.append\n        for tuid, l in self._strokes.items():\n            lpts = l.points\n            append([Vector(*pts) for pts in zip(lpts[::2], lpts[1::2])])\n\n        self._vectors = vecs\n        self._cache_time = self._update_time\n        return vecs",
  "def handles(self, touch):\n        '''Returns True if this container handles the given touch'''\n        if not self.active:\n            return False\n        return str(touch.uid) in self._strokes",
  "def accept_stroke(self, count=1):\n        '''Returns True if this container can accept `count` new strokes'''\n        if not self.max_strokes:\n            return True\n        return len(self._strokes) + count <= self.max_strokes",
  "def update_bbox(self, touch):\n        '''Update gesture bbox from a touch coordinate'''\n        x, y = touch.x, touch.y\n        bb = self.bbox\n        if x < bb['minx']:\n            bb['minx'] = x\n        if y < bb['miny']:\n            bb['miny'] = y\n        if x > bb['maxx']:\n            bb['maxx'] = x\n        if y > bb['maxy']:\n            bb['maxy'] = y\n        self.width = bb['maxx'] - bb['minx']\n        self.height = bb['maxy'] - bb['miny']\n        self._update_time = Clock.get_time()",
  "def add_stroke(self, touch, line):\n        '''Associate a list of points with a touch.uid; the line itself is\n        created by the caller, but subsequent move/up events look it\n        up via us. This is done to avoid problems during merge.'''\n        self._update_time = Clock.get_time()\n        self._strokes[str(touch.uid)] = line\n        self.active_strokes += 1",
  "def complete_stroke(self):\n        '''Called on touch up events to keep track of how many strokes\n        are active in the gesture (we only want to dispatch event when\n        the *last* stroke in the gesture is released)'''\n        self._update_time = Clock.get_time()\n        self.active_strokes -= 1",
  "def single_points_test(self):\n        '''Returns True if the gesture consists only of single-point strokes,\n        we must discard it in this case, or an exception will be raised'''\n        for tuid, l in self._strokes.items():\n            if len(l.points) > 2:\n                return False\n        return True",
  "def __init__(self, **kwargs):\n        super(GestureSurface, self).__init__(**kwargs)\n        # A list of GestureContainer objects (all gestures on the surface)\n        self._gestures = []\n        self.register_event_type('on_gesture_start')\n        self.register_event_type('on_gesture_extend')\n        self.register_event_type('on_gesture_merge')\n        self.register_event_type('on_gesture_complete')\n        self.register_event_type('on_gesture_cleanup')\n        self.register_event_type('on_gesture_discard')",
  "def on_touch_down(self, touch):\n        '''When a new touch is registered, the first thing we do is to test if\n        it collides with the bounding box of another known gesture. If so, it\n        is assumed to be part of that gesture.\n        '''\n        # If the touch originates outside the surface, ignore it.\n        if not self.collide_point(touch.x, touch.y):\n            return\n\n        touch.grab(self)\n\n        # Add the stroke to existing gesture, or make a new one\n        g = self.find_colliding_gesture(touch)\n        new = False\n        if g is None:\n            g = self.init_gesture(touch)\n            new = True\n\n        # We now belong to a gesture (new or old); start a new stroke.\n        self.init_stroke(g, touch)\n\n        if new:\n            self.dispatch('on_gesture_start', g, touch)\n        else:\n            self.dispatch('on_gesture_extend', g, touch)\n\n        return True",
  "def on_touch_move(self, touch):\n        '''When a touch moves, we add a point to the line on the canvas so the\n        path is updated. We must also check if the new point collides with the\n        bounding box of another gesture - if so, they should be merged.'''\n        if touch.grab_current is not self:\n            return\n        if not self.collide_point(touch.x, touch.y):\n            return\n\n        # Retrieve the GestureContainer object that handles this touch, and\n        # test for colliding gestures. If found, merge them to one.\n        g = self.get_gesture(touch)\n        collision = self.find_colliding_gesture(touch)\n        if collision is not None and g.accept_stroke(len(collision._strokes)):\n            merge = self.merge_gestures(g, collision)\n            if g.was_merged:\n                self.dispatch('on_gesture_merge', g, collision)\n            else:\n                self.dispatch('on_gesture_merge', collision, g)\n            g = merge\n        else:\n            g.update_bbox(touch)\n\n        # Add the new point to gesture stroke list and update the canvas line\n        g._strokes[str(touch.uid)].points += (touch.x, touch.y)\n\n        # Draw the gesture bounding box; if it is a single press that\n        # does not trigger a move event, we would miss it otherwise.\n        if self.draw_bbox:\n            self._update_canvas_bbox(g)\n        return True",
  "def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n\n        g = self.get_gesture(touch)\n        g.complete_stroke()\n\n        # If this stroke hit the maximum limit, dispatch immediately\n        if not g.accept_stroke():\n            self._complete_dispatcher(0)\n\n        # dispatch later only if we have a window\n        elif self.temporal_window > 0:\n            Clock.schedule_once(self._complete_dispatcher,\n                                    self.temporal_window)",
  "def init_gesture(self, touch):\n        '''Create a new gesture from touch, i.e. it's the first on\n        surface, or was not close enough to any existing gesture (yet)'''\n        col = self.color\n        if self.use_random_color:\n            col = hsv_to_rgb(random(), 1., 1.)\n\n        g = GestureContainer(touch, max_strokes=self.max_strokes, color=col)\n\n        # Create the bounding box Rectangle for the gesture\n        if self.draw_bbox:\n            bb = g.bbox\n            with self.canvas:\n                Color(col[0], col[1], col[2], self.bbox_alpha, mode='rgba',\n                      group=g.id)\n\n                g._bbrect = Rectangle(\n                    group=g.id,\n                    pos=(bb['minx'], bb['miny']),\n                    size=(bb['maxx'] - bb['minx'],\n                          bb['maxy'] - bb['miny']))\n\n        self._gestures.append(g)\n        return g",
  "def init_stroke(self, g, touch):\n        points = [touch.x, touch.y]\n        col = g.color\n\n        new_line = Line(\n            points=points,\n            width=self.line_width,\n            group=g.id)\n        g._strokes[str(touch.uid)] = new_line\n\n        if self.line_width:\n            canvas_add = self.canvas.add\n            canvas_add(Color(col[0], col[1], col[2], mode='rgb', group=g.id))\n            canvas_add(new_line)\n\n        # Update the bbox in case; this will normally be done in on_touch_move,\n        # but we want to update it also for a single press, force that here:\n        g.update_bbox(touch)\n        if self.draw_bbox:\n            self._update_canvas_bbox(g)\n\n        # Register the stroke in GestureContainer so we can look it up later\n        g.add_stroke(touch, new_line)",
  "def get_gesture(self, touch):\n        '''Returns GestureContainer associated with given touch'''\n        for g in self._gestures:\n            if g.active and g.handles(touch):\n                return g\n        raise Exception('get_gesture() failed to identify ' + str(touch.uid))",
  "def find_colliding_gesture(self, touch):\n        '''Checks if a touch x/y collides with the bounding box of an existing\n        gesture. If so, return it (otherwise returns None)\n        '''\n        touch_x, touch_y = touch.pos\n        for g in self._gestures:\n            if g.active and not g.handles(touch) and g.accept_stroke():\n                bb = g.bbox\n                margin = self.bbox_margin\n                minx = bb['minx'] - margin\n                miny = bb['miny'] - margin\n                maxx = bb['maxx'] + margin\n                maxy = bb['maxy'] + margin\n                if minx <= touch_x <= maxx and miny <= touch_y <= maxy:\n                    return g\n        return None",
  "def merge_gestures(self, g, other):\n        '''Merges two gestures together, the oldest one is retained and the\n        newer one gets the `GestureContainer.was_merged` flag raised.'''\n        # Swap order depending on gesture age (the merged gesture gets\n        # the color from the oldest one of the two).\n        swap = other._create_time < g._create_time\n        a = swap and other or g\n        b = swap and g or other\n\n        # Apply the outer limits of bbox to the merged gesture\n        abbox = a.bbox\n        bbbox = b.bbox\n        if bbbox['minx'] < abbox['minx']:\n            abbox['minx'] = bbbox['minx']\n        if bbbox['miny'] < abbox['miny']:\n            abbox['miny'] = bbbox['miny']\n        if bbbox['maxx'] > abbox['maxx']:\n            abbox['maxx'] = bbbox['maxx']\n        if bbbox['maxy'] > abbox['maxy']:\n            abbox['maxy'] = bbbox['maxy']\n\n        # Now transfer the coordinates from old to new gesture;\n        # FIXME: This can probably be copied more efficiently?\n        astrokes = a._strokes\n        lw = self.line_width\n        a_id = a.id\n        col = a.color\n\n        self.canvas.remove_group(b.id)\n        canv_add = self.canvas.add\n        for uid, old in b._strokes.items():\n            # FIXME: Can't figure out how to change group= for existing Line()\n            new_line = Line(\n                points=old.points,\n                width=old.width,\n                group=a_id)\n            astrokes[uid] = new_line\n            if lw:\n                canv_add(Color(col[0], col[1], col[2], mode='rgb', group=a_id))\n                canv_add(new_line)\n\n        b.active = False\n        b.was_merged = True\n        a.active_strokes += b.active_strokes\n        a._update_time = Clock.get_time()\n        return a",
  "def _update_canvas_bbox(self, g):\n        # If draw_bbox is changed while two gestures are active,\n        # we might not have a bbrect member\n        if not hasattr(g, '_bbrect'):\n            return\n\n        bb = g.bbox\n        g._bbrect.pos = (bb['minx'], bb['miny'])\n        g._bbrect.size = (bb['maxx'] - bb['minx'],\n                          bb['maxy'] - bb['miny'])",
  "def _complete_dispatcher(self, dt):\n        '''This method is scheduled on all touch up events. It will dispatch\n        the `on_gesture_complete` event for all completed gestures, and remove\n        merged gestures from the internal gesture list.'''\n        need_cleanup = False\n        gest = self._gestures\n        timeout = self.draw_timeout\n        twin = self.temporal_window\n        get_time = Clock.get_time\n\n        for idx, g in enumerate(gest):\n            # Gesture is part of another gesture, just delete it\n            if g.was_merged:\n                del gest[idx]\n                continue\n\n            # Not active == already handled, or has active strokes (it cannot\n            # possibly be complete). Proceed to next gesture on surface.\n            if not g.active or g.active_strokes != 0:\n                continue\n\n            t1 = g._update_time + twin\n            t2 = get_time() + UNDERSHOOT_MARGIN\n\n            # max_strokes reached, or temporal window has expired. The gesture\n            # is complete; need to dispatch _complete or _discard event.\n            if not g.accept_stroke() or t1 <= t2:\n                discard = False\n                if g.width < 5 and g.height < 5:\n                    discard = True\n                elif g.single_points_test():\n                    discard = True\n\n                need_cleanup = True\n                g.active = False\n                g._cleanup_time = get_time() + timeout\n\n                if discard:\n                    self.dispatch('on_gesture_discard', g)\n                else:\n                    self.dispatch('on_gesture_complete', g)\n\n        if need_cleanup:\n            Clock.schedule_once(self._cleanup, timeout)",
  "def _cleanup(self, dt):\n        '''This method is scheduled from _complete_dispatcher to clean up the\n        canvas and internal gesture list after a gesture is completed.'''\n        m = UNDERSHOOT_MARGIN\n        rg = self.canvas.remove_group\n        gestures = self._gestures\n        for idx, g in enumerate(gestures):\n            if g._cleanup_time is None:\n                continue\n            if g._cleanup_time <= Clock.get_time() + m:\n                rg(g.id)\n                del gestures[idx]\n                self.dispatch('on_gesture_cleanup', g)",
  "def on_gesture_start(self, *l):\n        pass",
  "def on_gesture_extend(self, *l):\n        pass",
  "def on_gesture_merge(self, *l):\n        pass",
  "def on_gesture_complete(self, *l):\n        pass",
  "def on_gesture_discard(self, *l):\n        pass",
  "def on_gesture_cleanup(self, *l):\n        pass",
  "def nmax(*args):\n    # merge into one list\n    args = [x for x in args if x is not None]\n    return max(args)",
  "def nmin(*args):\n    # merge into one list\n    args = [x for x in args if x is not None]\n    return min(args)",
  "class GridLayoutException(Exception):\n    '''Exception for errors if the grid layout manipulation fails.\n    '''\n    pass",
  "class GridLayout(Layout):\n    '''Grid layout class. See module documentation for more information.\n    '''\n\n    spacing = VariableListProperty([0, 0], length=2)\n    '''Spacing between children: [spacing_horizontal, spacing_vertical].\n\n    spacing also accepts a one argument form [spacing].\n\n    :attr:`spacing` is a\n    :class:`~kivy.properties.VariableListProperty` and defaults to [0, 0].\n    '''\n\n    padding = VariableListProperty([0, 0, 0, 0])\n    '''Padding between the layout box and its children: [padding_left,\n    padding_top, padding_right, padding_bottom].\n\n    padding also accepts a two argument form [padding_horizontal,\n    padding_vertical] and a one argument form [padding].\n\n    .. versionchanged:: 1.7.0\n        Replaced NumericProperty with VariableListProperty.\n\n    :attr:`padding` is a :class:`~kivy.properties.VariableListProperty` and\n    defaults to [0, 0, 0, 0].\n    '''\n\n    cols = BoundedNumericProperty(None, min=0, allownone=True)\n    '''Number of columns in the grid.\n\n    .. versionchanged:: 1.0.8\n        Changed from a NumericProperty to BoundedNumericProperty. You can no\n        longer set this to a negative value.\n\n    :attr:`cols` is a :class:`~kivy.properties.NumericProperty` and defaults to\n    None.\n    '''\n\n    rows = BoundedNumericProperty(None, min=0, allownone=True)\n    '''Number of rows in the grid.\n\n    .. versionchanged:: 1.0.8\n        Changed from a NumericProperty to a BoundedNumericProperty. You can no\n        longer set this to a negative value.\n\n    :attr:`rows` is a :class:`~kivy.properties.NumericProperty` and defaults to\n    None.\n    '''\n\n    col_default_width = NumericProperty(0)\n    '''Default minimum size to use for a column.\n\n    .. versionadded:: 1.0.7\n\n    :attr:`col_default_width` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 0.\n    '''\n\n    row_default_height = NumericProperty(0)\n    '''Default minimum size to use for row.\n\n    .. versionadded:: 1.0.7\n\n    :attr:`row_default_height` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 0.\n    '''\n\n    col_force_default = BooleanProperty(False)\n    '''If True, ignore the width and size_hint_x of the child and use the\n    default column width.\n\n    .. versionadded:: 1.0.7\n\n    :attr:`col_force_default` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to False.\n    '''\n\n    row_force_default = BooleanProperty(False)\n    '''If True, ignore the height and size_hint_y of the child and use the\n    default row height.\n\n    .. versionadded:: 1.0.7\n\n    :attr:`row_force_default` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to False.\n    '''\n\n    cols_minimum = DictProperty({})\n    '''Dict of minimum width for each column. The dictionary keys are the\n    column numbers, e.g. 0, 1, 2...\n\n    .. versionadded:: 1.0.7\n\n    :attr:`cols_minimum` is a :class:`~kivy.properties.DictProperty` and\n    defaults to {}.\n    '''\n\n    rows_minimum = DictProperty({})\n    '''Dict of minimum height for each row. The dictionary keys are the\n    row numbers, e.g. 0, 1, 2...\n\n    .. versionadded:: 1.0.7\n\n    :attr:`rows_minimum` is a :class:`~kivy.properties.DictProperty` and\n    defaults to {}.\n    '''\n\n    minimum_width = NumericProperty(0)\n    '''Automatically computed minimum width needed to contain all children.\n\n    .. versionadded:: 1.0.8\n\n    :attr:`minimum_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0. It is read only.\n    '''\n\n    minimum_height = NumericProperty(0)\n    '''Automatically computed minimum height needed to contain all children.\n\n    .. versionadded:: 1.0.8\n\n    :attr:`minimum_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0. It is read only.\n    '''\n\n    minimum_size = ReferenceListProperty(minimum_width, minimum_height)\n    '''Automatically computed minimum size needed to contain all children.\n\n    .. versionadded:: 1.0.8\n\n    :attr:`minimum_size` is a\n    :class:`~kivy.properties.ReferenceListProperty` of\n    (:attr:`minimum_width`, :attr:`minimum_height`) properties. It is read\n    only.\n    '''\n\n    orientation = OptionProperty('lr-tb', options=(\n        'lr-tb', 'tb-lr', 'rl-tb', 'tb-rl', 'lr-bt', 'bt-lr', 'rl-bt',\n        'bt-rl'))\n    '''Orientation of the layout.\n\n    :attr:`orientation` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'lr-tb'.\n\n    Valid orientations are 'lr-tb', 'tb-lr', 'rl-tb', 'tb-rl', 'lr-bt',\n    'bt-lr', 'rl-bt' and 'bt-rl'.\n\n    .. versionadded:: 2.0.0\n\n    .. note::\n\n        'lr' means Left to Right.\n        'rl' means Right to Left.\n        'tb' means Top to Bottom.\n        'bt' means Bottom to Top.\n    '''\n\n    def __init__(self, **kwargs):\n        self._cols = self._rows = None\n        super(GridLayout, self).__init__(**kwargs)\n        fbind = self.fbind\n        update = self._trigger_layout\n        fbind('col_default_width', update)\n        fbind('row_default_height', update)\n        fbind('col_force_default', update)\n        fbind('row_force_default', update)\n        fbind('cols', update)\n        fbind('rows', update)\n        fbind('parent', update)\n        fbind('spacing', update)\n        fbind('padding', update)\n        fbind('children', update)\n        fbind('size', update)\n        fbind('pos', update)\n        fbind('orientation', update)\n\n    def get_max_widgets(self):\n        if self.cols and self.rows:\n            return self.rows * self.cols\n        else:\n            return None\n\n    def on_children(self, instance, value):\n        # if that makes impossible to construct things with deferred method,\n        # migrate this test in do_layout, and/or issue a warning.\n        smax = self.get_max_widgets()\n        if smax and len(value) > smax:\n            raise GridLayoutException(\n                'Too many children in GridLayout. Increase rows/cols!')\n\n    @property\n    def _fills_row_first(self):\n        return self.orientation[0] in 'lr'\n\n    @property\n    def _fills_from_left_to_right(self):\n        return 'lr' in self.orientation\n\n    @property\n    def _fills_from_top_to_bottom(self):\n        return 'tb' in self.orientation\n\n    def _init_rows_cols_sizes(self, count):\n        # the goal here is to calculate the minimum size of every cols/rows\n        # and determine if they have stretch or not\n        current_cols = self.cols\n        current_rows = self.rows\n\n        # if no cols or rows are set, we can't calculate minimum size.\n        # the grid must be constrained at least on one side\n        if not current_cols and not current_rows:\n            Logger.warning('%r have no cols or rows set, '\n                           'layout is not triggered.' % self)\n            return\n\n        if current_cols is None:\n            current_cols = int(ceil(count / float(current_rows)))\n        elif current_rows is None:\n            current_rows = int(ceil(count / float(current_cols)))\n\n        current_cols = max(1, current_cols)\n        current_rows = max(1, current_rows)\n\n        self._has_hint_bound_x = False\n        self._has_hint_bound_y = False\n        self._cols_min_size_none = 0.  # min size from all the None hint\n        self._rows_min_size_none = 0.  # min size from all the None hint\n        self._cols = cols = [self.col_default_width] * current_cols\n        self._cols_sh = [None] * current_cols\n        self._cols_sh_min = [None] * current_cols\n        self._cols_sh_max = [None] * current_cols\n        self._rows = rows = [self.row_default_height] * current_rows\n        self._rows_sh = [None] * current_rows\n        self._rows_sh_min = [None] * current_rows\n        self._rows_sh_max = [None] * current_rows\n\n        # update minimum size from the dicts\n        items = (i for i in self.cols_minimum.items() if i[0] < len(cols))\n        for index, value in items:\n            cols[index] = max(value, cols[index])\n\n        items = (i for i in self.rows_minimum.items() if i[0] < len(rows))\n        for index, value in items:\n            rows[index] = max(value, rows[index])\n        return True\n\n    def _fill_rows_cols_sizes(self):\n        cols, rows = self._cols, self._rows\n        cols_sh, rows_sh = self._cols_sh, self._rows_sh\n        cols_sh_min, rows_sh_min = self._cols_sh_min, self._rows_sh_min\n        cols_sh_max, rows_sh_max = self._cols_sh_max, self._rows_sh_max\n\n        # calculate minimum size for each columns and rows\n        has_bound_y = has_bound_x = False\n        idx_iter = self._create_idx_iter(len(cols), len(rows))\n        for child, (col, row) in zip(reversed(self.children), idx_iter):\n            (shw, shh), (w, h) = child.size_hint, child.size\n            shw_min, shh_min = child.size_hint_min\n            shw_max, shh_max = child.size_hint_max\n\n            # compute minimum size / maximum stretch needed\n            if shw is None:\n                cols[col] = nmax(cols[col], w)\n            else:\n                cols_sh[col] = nmax(cols_sh[col], shw)\n                if shw_min is not None:\n                    has_bound_x = True\n                    cols_sh_min[col] = nmax(cols_sh_min[col], shw_min)\n                if shw_max is not None:\n                    has_bound_x = True\n                    cols_sh_max[col] = nmin(cols_sh_max[col], shw_max)\n\n            if shh is None:\n                rows[row] = nmax(rows[row], h)\n            else:\n                rows_sh[row] = nmax(rows_sh[row], shh)\n                if shh_min is not None:\n                    has_bound_y = True\n                    rows_sh_min[row] = nmax(rows_sh_min[row], shh_min)\n                if shh_max is not None:\n                    has_bound_y = True\n                    rows_sh_max[row] = nmin(rows_sh_max[row], shh_max)\n        self._has_hint_bound_x = has_bound_x\n        self._has_hint_bound_y = has_bound_y\n\n    def _update_minimum_size(self):\n        # calculate minimum width/height needed, starting from padding +\n        # spacing\n        l, t, r, b = self.padding\n        spacing_x, spacing_y = self.spacing\n        cols, rows = self._cols, self._rows\n\n        width = l + r + spacing_x * (len(cols) - 1)\n        self._cols_min_size_none = sum(cols) + width\n        # we need to subtract for the sh_max/min the already guaranteed size\n        # due to having a None in the col. So sh_min gets smaller by that size\n        # since it's already covered. Similarly for sh_max, because if we\n        # already exceeded the max, the subtracted max will be zero, so\n        # it won't get larger\n        if self._has_hint_bound_x:\n            cols_sh_min = self._cols_sh_min\n            cols_sh_max = self._cols_sh_max\n\n            for i, (c, sh_min, sh_max) in enumerate(\n                    zip(cols, cols_sh_min, cols_sh_max)):\n                if sh_min is not None:\n                    width += max(c, sh_min)\n                    cols_sh_min[i] = max(0., sh_min - c)\n                else:\n                    width += c\n\n                if sh_max is not None:\n                    cols_sh_max[i] = max(0., sh_max - c)\n        else:\n            width = self._cols_min_size_none\n\n        height = t + b + spacing_y * (len(rows) - 1)\n        self._rows_min_size_none = sum(rows) + height\n        if self._has_hint_bound_y:\n            rows_sh_min = self._rows_sh_min\n            rows_sh_max = self._rows_sh_max\n\n            for i, (r, sh_min, sh_max) in enumerate(\n                    zip(rows, rows_sh_min, rows_sh_max)):\n                if sh_min is not None:\n                    height += max(r, sh_min)\n                    rows_sh_min[i] = max(0., sh_min - r)\n                else:\n                    height += r\n\n                if sh_max is not None:\n                    rows_sh_max[i] = max(0., sh_max - r)\n        else:\n            height = self._rows_min_size_none\n\n        # finally, set the minimum size\n        self.minimum_size = (width, height)\n\n    def _finalize_rows_cols_sizes(self):\n        selfw = self.width\n        selfh = self.height\n\n        # resolve size for each column\n        if self.col_force_default:\n            cols = [self.col_default_width] * len(self._cols)\n            for index, value in self.cols_minimum.items():\n                cols[index] = value\n            self._cols = cols\n        else:\n            cols = self._cols\n            cols_sh = self._cols_sh\n            cols_sh_min = self._cols_sh_min\n            cols_weight = float(sum((x for x in cols_sh if x is not None)))\n            stretch_w = max(0., selfw - self._cols_min_size_none)\n\n            if stretch_w > 1e-9:\n                if self._has_hint_bound_x:\n                    # fix the hints to be within bounds\n                    self.layout_hint_with_bounds(\n                        cols_weight, stretch_w,\n                        sum((c for c in cols_sh_min if c is not None)),\n                        cols_sh_min, self._cols_sh_max, cols_sh)\n\n                for index, col_stretch in enumerate(cols_sh):\n                    # if the col don't have stretch information, nothing to do\n                    if not col_stretch:\n                        continue\n                    # add to the min width whatever remains from size_hint\n                    cols[index] += stretch_w * col_stretch / cols_weight\n\n        # same algo for rows\n        if self.row_force_default:\n            rows = [self.row_default_height] * len(self._rows)\n            for index, value in self.rows_minimum.items():\n                rows[index] = value\n            self._rows = rows\n        else:\n            rows = self._rows\n            rows_sh = self._rows_sh\n            rows_sh_min = self._rows_sh_min\n            rows_weight = float(sum((x for x in rows_sh if x is not None)))\n            stretch_h = max(0., selfh - self._rows_min_size_none)\n\n            if stretch_h > 1e-9:\n                if self._has_hint_bound_y:\n                    # fix the hints to be within bounds\n                    self.layout_hint_with_bounds(\n                        rows_weight, stretch_h,\n                        sum((r for r in rows_sh_min if r is not None)),\n                        rows_sh_min, self._rows_sh_max, rows_sh)\n\n                for index, row_stretch in enumerate(rows_sh):\n                    # if the row don't have stretch information, nothing to do\n                    if not row_stretch:\n                        continue\n                    # add to the min height whatever remains from size_hint\n                    rows[index] += stretch_h * row_stretch / rows_weight\n\n    def _iterate_layout(self, count):\n        orientation = self.orientation\n        padding = self.padding\n        spacing_x, spacing_y = self.spacing\n\n        cols = self._cols\n        if self._fills_from_left_to_right:\n            x_iter = accumulate(chain(\n                (self.x + padding[0], ),\n                (\n                    col_width + spacing_x\n                    for col_width in islice(cols, len(cols) - 1)\n                ),\n            ))\n        else:\n            x_iter = accumulate(chain(\n                (self.right - padding[2] - cols[-1], ),\n                (\n                    col_width + spacing_x\n                    for col_width in islice(reversed(cols), 1, None)\n                ),\n            ), sub)\n            cols = reversed(cols)\n\n        rows = self._rows\n        if self._fills_from_top_to_bottom:\n            y_iter = accumulate(chain(\n                (self.top - padding[1] - rows[0], ),\n                (\n                    row_height + spacing_y\n                    for row_height in islice(rows, 1, None)\n                ),\n            ), sub)\n        else:\n            y_iter = accumulate(chain(\n                (self.y + padding[3], ),\n                (\n                    row_height + spacing_y\n                    for row_height in islice(reversed(rows), len(rows) - 1)\n                ),\n            ))\n            rows = reversed(rows)\n\n        if self._fills_row_first:\n            for i, (y, x), (row_height, col_width) in zip(\n                    reversed(range(count)),\n                    product(y_iter, x_iter),\n                    product(rows, cols)):\n                yield i, x, y, col_width, row_height\n        else:\n            for i, (x, y), (col_width, row_height) in zip(\n                    reversed(range(count)),\n                    product(x_iter, y_iter),\n                    product(cols, rows)):\n                yield i, x, y, col_width, row_height\n\n    def do_layout(self, *largs):\n        children = self.children\n        if not children or not self._init_rows_cols_sizes(len(children)):\n            l, t, r, b = self.padding\n            self.minimum_size = l + r, t + b\n            return\n        self._fill_rows_cols_sizes()\n        self._update_minimum_size()\n        self._finalize_rows_cols_sizes()\n\n        for i, x, y, w, h in self._iterate_layout(len(children)):\n            c = children[i]\n            c.pos = x, y\n            shw, shh = c.size_hint\n            shw_min, shh_min = c.size_hint_min\n            shw_max, shh_max = c.size_hint_max\n\n            if shw_min is not None:\n                if shw_max is not None:\n                    w = max(min(w, shw_max), shw_min)\n                else:\n                    w = max(w, shw_min)\n            else:\n                if shw_max is not None:\n                    w = min(w, shw_max)\n\n            if shh_min is not None:\n                if shh_max is not None:\n                    h = max(min(h, shh_max), shh_min)\n                else:\n                    h = max(h, shh_min)\n            else:\n                if shh_max is not None:\n                    h = min(h, shh_max)\n\n            if shw is None:\n                if shh is not None:\n                    c.height = h\n            else:\n                if shh is None:\n                    c.width = w\n                else:\n                    c.size = (w, h)\n\n    def _create_idx_iter(self, n_cols, n_rows):\n        col_indices = range(n_cols) if self._fills_from_left_to_right \\\n            else range(n_cols - 1, -1, -1)\n        row_indices = range(n_rows) if self._fills_from_top_to_bottom \\\n            else range(n_rows - 1, -1, -1)\n\n        if self._fills_row_first:\n            return (\n                (col_index, row_index)\n                for row_index, col_index in product(row_indices, col_indices))\n        else:\n            return product(col_indices, row_indices)",
  "def __init__(self, **kwargs):\n        self._cols = self._rows = None\n        super(GridLayout, self).__init__(**kwargs)\n        fbind = self.fbind\n        update = self._trigger_layout\n        fbind('col_default_width', update)\n        fbind('row_default_height', update)\n        fbind('col_force_default', update)\n        fbind('row_force_default', update)\n        fbind('cols', update)\n        fbind('rows', update)\n        fbind('parent', update)\n        fbind('spacing', update)\n        fbind('padding', update)\n        fbind('children', update)\n        fbind('size', update)\n        fbind('pos', update)\n        fbind('orientation', update)",
  "def get_max_widgets(self):\n        if self.cols and self.rows:\n            return self.rows * self.cols\n        else:\n            return None",
  "def on_children(self, instance, value):\n        # if that makes impossible to construct things with deferred method,\n        # migrate this test in do_layout, and/or issue a warning.\n        smax = self.get_max_widgets()\n        if smax and len(value) > smax:\n            raise GridLayoutException(\n                'Too many children in GridLayout. Increase rows/cols!')",
  "def _fills_row_first(self):\n        return self.orientation[0] in 'lr'",
  "def _fills_from_left_to_right(self):\n        return 'lr' in self.orientation",
  "def _fills_from_top_to_bottom(self):\n        return 'tb' in self.orientation",
  "def _init_rows_cols_sizes(self, count):\n        # the goal here is to calculate the minimum size of every cols/rows\n        # and determine if they have stretch or not\n        current_cols = self.cols\n        current_rows = self.rows\n\n        # if no cols or rows are set, we can't calculate minimum size.\n        # the grid must be constrained at least on one side\n        if not current_cols and not current_rows:\n            Logger.warning('%r have no cols or rows set, '\n                           'layout is not triggered.' % self)\n            return\n\n        if current_cols is None:\n            current_cols = int(ceil(count / float(current_rows)))\n        elif current_rows is None:\n            current_rows = int(ceil(count / float(current_cols)))\n\n        current_cols = max(1, current_cols)\n        current_rows = max(1, current_rows)\n\n        self._has_hint_bound_x = False\n        self._has_hint_bound_y = False\n        self._cols_min_size_none = 0.  # min size from all the None hint\n        self._rows_min_size_none = 0.  # min size from all the None hint\n        self._cols = cols = [self.col_default_width] * current_cols\n        self._cols_sh = [None] * current_cols\n        self._cols_sh_min = [None] * current_cols\n        self._cols_sh_max = [None] * current_cols\n        self._rows = rows = [self.row_default_height] * current_rows\n        self._rows_sh = [None] * current_rows\n        self._rows_sh_min = [None] * current_rows\n        self._rows_sh_max = [None] * current_rows\n\n        # update minimum size from the dicts\n        items = (i for i in self.cols_minimum.items() if i[0] < len(cols))\n        for index, value in items:\n            cols[index] = max(value, cols[index])\n\n        items = (i for i in self.rows_minimum.items() if i[0] < len(rows))\n        for index, value in items:\n            rows[index] = max(value, rows[index])\n        return True",
  "def _fill_rows_cols_sizes(self):\n        cols, rows = self._cols, self._rows\n        cols_sh, rows_sh = self._cols_sh, self._rows_sh\n        cols_sh_min, rows_sh_min = self._cols_sh_min, self._rows_sh_min\n        cols_sh_max, rows_sh_max = self._cols_sh_max, self._rows_sh_max\n\n        # calculate minimum size for each columns and rows\n        has_bound_y = has_bound_x = False\n        idx_iter = self._create_idx_iter(len(cols), len(rows))\n        for child, (col, row) in zip(reversed(self.children), idx_iter):\n            (shw, shh), (w, h) = child.size_hint, child.size\n            shw_min, shh_min = child.size_hint_min\n            shw_max, shh_max = child.size_hint_max\n\n            # compute minimum size / maximum stretch needed\n            if shw is None:\n                cols[col] = nmax(cols[col], w)\n            else:\n                cols_sh[col] = nmax(cols_sh[col], shw)\n                if shw_min is not None:\n                    has_bound_x = True\n                    cols_sh_min[col] = nmax(cols_sh_min[col], shw_min)\n                if shw_max is not None:\n                    has_bound_x = True\n                    cols_sh_max[col] = nmin(cols_sh_max[col], shw_max)\n\n            if shh is None:\n                rows[row] = nmax(rows[row], h)\n            else:\n                rows_sh[row] = nmax(rows_sh[row], shh)\n                if shh_min is not None:\n                    has_bound_y = True\n                    rows_sh_min[row] = nmax(rows_sh_min[row], shh_min)\n                if shh_max is not None:\n                    has_bound_y = True\n                    rows_sh_max[row] = nmin(rows_sh_max[row], shh_max)\n        self._has_hint_bound_x = has_bound_x\n        self._has_hint_bound_y = has_bound_y",
  "def _update_minimum_size(self):\n        # calculate minimum width/height needed, starting from padding +\n        # spacing\n        l, t, r, b = self.padding\n        spacing_x, spacing_y = self.spacing\n        cols, rows = self._cols, self._rows\n\n        width = l + r + spacing_x * (len(cols) - 1)\n        self._cols_min_size_none = sum(cols) + width\n        # we need to subtract for the sh_max/min the already guaranteed size\n        # due to having a None in the col. So sh_min gets smaller by that size\n        # since it's already covered. Similarly for sh_max, because if we\n        # already exceeded the max, the subtracted max will be zero, so\n        # it won't get larger\n        if self._has_hint_bound_x:\n            cols_sh_min = self._cols_sh_min\n            cols_sh_max = self._cols_sh_max\n\n            for i, (c, sh_min, sh_max) in enumerate(\n                    zip(cols, cols_sh_min, cols_sh_max)):\n                if sh_min is not None:\n                    width += max(c, sh_min)\n                    cols_sh_min[i] = max(0., sh_min - c)\n                else:\n                    width += c\n\n                if sh_max is not None:\n                    cols_sh_max[i] = max(0., sh_max - c)\n        else:\n            width = self._cols_min_size_none\n\n        height = t + b + spacing_y * (len(rows) - 1)\n        self._rows_min_size_none = sum(rows) + height\n        if self._has_hint_bound_y:\n            rows_sh_min = self._rows_sh_min\n            rows_sh_max = self._rows_sh_max\n\n            for i, (r, sh_min, sh_max) in enumerate(\n                    zip(rows, rows_sh_min, rows_sh_max)):\n                if sh_min is not None:\n                    height += max(r, sh_min)\n                    rows_sh_min[i] = max(0., sh_min - r)\n                else:\n                    height += r\n\n                if sh_max is not None:\n                    rows_sh_max[i] = max(0., sh_max - r)\n        else:\n            height = self._rows_min_size_none\n\n        # finally, set the minimum size\n        self.minimum_size = (width, height)",
  "def _finalize_rows_cols_sizes(self):\n        selfw = self.width\n        selfh = self.height\n\n        # resolve size for each column\n        if self.col_force_default:\n            cols = [self.col_default_width] * len(self._cols)\n            for index, value in self.cols_minimum.items():\n                cols[index] = value\n            self._cols = cols\n        else:\n            cols = self._cols\n            cols_sh = self._cols_sh\n            cols_sh_min = self._cols_sh_min\n            cols_weight = float(sum((x for x in cols_sh if x is not None)))\n            stretch_w = max(0., selfw - self._cols_min_size_none)\n\n            if stretch_w > 1e-9:\n                if self._has_hint_bound_x:\n                    # fix the hints to be within bounds\n                    self.layout_hint_with_bounds(\n                        cols_weight, stretch_w,\n                        sum((c for c in cols_sh_min if c is not None)),\n                        cols_sh_min, self._cols_sh_max, cols_sh)\n\n                for index, col_stretch in enumerate(cols_sh):\n                    # if the col don't have stretch information, nothing to do\n                    if not col_stretch:\n                        continue\n                    # add to the min width whatever remains from size_hint\n                    cols[index] += stretch_w * col_stretch / cols_weight\n\n        # same algo for rows\n        if self.row_force_default:\n            rows = [self.row_default_height] * len(self._rows)\n            for index, value in self.rows_minimum.items():\n                rows[index] = value\n            self._rows = rows\n        else:\n            rows = self._rows\n            rows_sh = self._rows_sh\n            rows_sh_min = self._rows_sh_min\n            rows_weight = float(sum((x for x in rows_sh if x is not None)))\n            stretch_h = max(0., selfh - self._rows_min_size_none)\n\n            if stretch_h > 1e-9:\n                if self._has_hint_bound_y:\n                    # fix the hints to be within bounds\n                    self.layout_hint_with_bounds(\n                        rows_weight, stretch_h,\n                        sum((r for r in rows_sh_min if r is not None)),\n                        rows_sh_min, self._rows_sh_max, rows_sh)\n\n                for index, row_stretch in enumerate(rows_sh):\n                    # if the row don't have stretch information, nothing to do\n                    if not row_stretch:\n                        continue\n                    # add to the min height whatever remains from size_hint\n                    rows[index] += stretch_h * row_stretch / rows_weight",
  "def _iterate_layout(self, count):\n        orientation = self.orientation\n        padding = self.padding\n        spacing_x, spacing_y = self.spacing\n\n        cols = self._cols\n        if self._fills_from_left_to_right:\n            x_iter = accumulate(chain(\n                (self.x + padding[0], ),\n                (\n                    col_width + spacing_x\n                    for col_width in islice(cols, len(cols) - 1)\n                ),\n            ))\n        else:\n            x_iter = accumulate(chain(\n                (self.right - padding[2] - cols[-1], ),\n                (\n                    col_width + spacing_x\n                    for col_width in islice(reversed(cols), 1, None)\n                ),\n            ), sub)\n            cols = reversed(cols)\n\n        rows = self._rows\n        if self._fills_from_top_to_bottom:\n            y_iter = accumulate(chain(\n                (self.top - padding[1] - rows[0], ),\n                (\n                    row_height + spacing_y\n                    for row_height in islice(rows, 1, None)\n                ),\n            ), sub)\n        else:\n            y_iter = accumulate(chain(\n                (self.y + padding[3], ),\n                (\n                    row_height + spacing_y\n                    for row_height in islice(reversed(rows), len(rows) - 1)\n                ),\n            ))\n            rows = reversed(rows)\n\n        if self._fills_row_first:\n            for i, (y, x), (row_height, col_width) in zip(\n                    reversed(range(count)),\n                    product(y_iter, x_iter),\n                    product(rows, cols)):\n                yield i, x, y, col_width, row_height\n        else:\n            for i, (x, y), (col_width, row_height) in zip(\n                    reversed(range(count)),\n                    product(x_iter, y_iter),\n                    product(cols, rows)):\n                yield i, x, y, col_width, row_height",
  "def do_layout(self, *largs):\n        children = self.children\n        if not children or not self._init_rows_cols_sizes(len(children)):\n            l, t, r, b = self.padding\n            self.minimum_size = l + r, t + b\n            return\n        self._fill_rows_cols_sizes()\n        self._update_minimum_size()\n        self._finalize_rows_cols_sizes()\n\n        for i, x, y, w, h in self._iterate_layout(len(children)):\n            c = children[i]\n            c.pos = x, y\n            shw, shh = c.size_hint\n            shw_min, shh_min = c.size_hint_min\n            shw_max, shh_max = c.size_hint_max\n\n            if shw_min is not None:\n                if shw_max is not None:\n                    w = max(min(w, shw_max), shw_min)\n                else:\n                    w = max(w, shw_min)\n            else:\n                if shw_max is not None:\n                    w = min(w, shw_max)\n\n            if shh_min is not None:\n                if shh_max is not None:\n                    h = max(min(h, shh_max), shh_min)\n                else:\n                    h = max(h, shh_min)\n            else:\n                if shh_max is not None:\n                    h = min(h, shh_max)\n\n            if shw is None:\n                if shh is not None:\n                    c.height = h\n            else:\n                if shh is None:\n                    c.width = w\n                else:\n                    c.size = (w, h)",
  "def _create_idx_iter(self, n_cols, n_rows):\n        col_indices = range(n_cols) if self._fills_from_left_to_right \\\n            else range(n_cols - 1, -1, -1)\n        row_indices = range(n_rows) if self._fills_from_top_to_bottom \\\n            else range(n_rows - 1, -1, -1)\n\n        if self._fills_row_first:\n            return (\n                (col_index, row_index)\n                for row_index, col_index in product(row_indices, col_indices))\n        else:\n            return product(col_indices, row_indices)",
  "class RstVideoPlayer(VideoPlayer):\n    pass",
  "class RstDocument(ScrollView):\n    '''Base widget used to store an Rst document. See module documentation for\n    more information.\n    '''\n    source = StringProperty(None)\n    '''Filename of the RST document.\n\n    :attr:`source` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    source_encoding = StringProperty('utf-8')\n    '''Encoding to be used for the :attr:`source` file.\n\n    :attr:`source_encoding` is a :class:`~kivy.properties.StringProperty` and\n    defaults to `utf-8`.\n\n    .. Note::\n        It is your responsibility to ensure that the value provided is a\n        valid codec supported by python.\n    '''\n\n    source_error = OptionProperty('strict',\n                                  options=('strict', 'ignore', 'replace',\n                                           'xmlcharrefreplace',\n                                           'backslashreplac'))\n    '''Error handling to be used while encoding the :attr:`source` file.\n\n    :attr:`source_error` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to `strict`. Can be one of 'strict', 'ignore', 'replace',\n    'xmlcharrefreplace' or 'backslashreplac'.\n    '''\n\n    text = StringProperty(None)\n    '''RST markup text of the document.\n\n    :attr:`text` is a :class:`~kivy.properties.StringProperty` and defaults to\n    None.\n    '''\n\n    document_root = StringProperty(None)\n    '''Root path where :doc: will search for rst documents. If no path is\n    given, it will use the directory of the first loaded source file.\n\n    :attr:`document_root` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    base_font_size = NumericProperty(31)\n    '''Font size for the biggest title, 31 by default. All other font sizes are\n    derived from this.\n\n    .. versionadded:: 1.8.0\n    '''\n\n    show_errors = BooleanProperty(False)\n    '''Indicate whether RST parsers errors should be shown on the screen\n    or not.\n\n    :attr:`show_errors` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    def _get_bgc(self):\n        return get_color_from_hex(self.colors.background)\n\n    def _set_bgc(self, value):\n        self.colors.background = get_hex_from_color(value)[1:]\n\n    background_color = AliasProperty(_get_bgc, _set_bgc,\n                                     bind=('colors',),\n                                     cache=True)\n    '''Specifies the background_color to be used for the RstDocument.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`background_color` is an :class:`~kivy.properties.AliasProperty`\n    for colors['background'].\n    '''\n\n    colors = DictProperty({\n        'background': 'e5e6e9ff',\n        'link': 'ce5c00ff',\n        'paragraph': '202020ff',\n        'title': '204a87ff',\n        'bullet': '000000ff'})\n    '''Dictionary of all the colors used in the RST rendering.\n\n    .. warning::\n\n        This dictionary is needs special handling. You also need to call\n        :meth:`RstDocument.render` if you change them after loading.\n\n    :attr:`colors` is a :class:`~kivy.properties.DictProperty`.\n    '''\n\n    title = StringProperty('')\n    '''Title of the current document.\n\n    :attr:`title` is a :class:`~kivy.properties.StringProperty` and defaults to\n    ''. It is read-only.\n    '''\n\n    toctrees = DictProperty({})\n    '''Toctree of all loaded or preloaded documents. This dictionary is filled\n    when a rst document is explicitly loaded or where :meth:`preload` has been\n    called.\n\n    If the document has no filename, e.g. when the document is loaded from a\n    text file, the key will be ''.\n\n    :attr:`toctrees` is a :class:`~kivy.properties.DictProperty` and defaults\n    to {}.\n    '''\n\n    underline_color = StringProperty('204a9699')\n    '''underline color of the titles, expressed in html color notation\n\n    :attr:`underline_color` is a\n    :class:`~kivy.properties.StringProperty` and defaults to '204a9699'.\n\n    .. versionadded: 1.9.0\n    '''\n\n    # internals.\n    content = ObjectProperty(None)\n    scatter = ObjectProperty(None)\n    anchors_widgets = ListProperty([])\n    refs_assoc = DictProperty({})\n\n    def __init__(self, **kwargs):\n        self._trigger_load = Clock.create_trigger(self._load_from_text, -1)\n        self._parser = rst.Parser()\n        self._settings = frontend.OptionParser(\n            components=(rst.Parser, )).get_default_values()\n        super(RstDocument, self).__init__(**kwargs)\n\n    def on_source(self, instance, value):\n        if not value:\n            return\n        if self.document_root is None:\n            # set the documentation root to the directory name of the\n            # first tile\n            self.document_root = abspath(dirname(value))\n        self._load_from_source()\n\n    def on_text(self, instance, value):\n        self._trigger_load()\n\n    def render(self):\n        '''Force document rendering.\n        '''\n        self._load_from_text()\n\n    def resolve_path(self, filename):\n        '''Get the path for this filename. If the filename doesn't exist,\n        it returns the document_root + filename.\n        '''\n        if exists(filename):\n            return filename\n        return join(self.document_root, filename)\n\n    def preload(self, filename, encoding='utf-8', errors='strict'):\n        '''Preload a rst file to get its toctree and its title.\n\n        The result will be stored in :attr:`toctrees` with the ``filename`` as\n        key.\n        '''\n\n        with open(filename, 'rb') as fd:\n            text = fd.read().decode(encoding, errors)\n        # parse the source\n        document = utils.new_document('Document', self._settings)\n        self._parser.parse(text, document)\n        # fill the current document node\n        visitor = _ToctreeVisitor(document)\n        document.walkabout(visitor)\n        self.toctrees[filename] = visitor.toctree\n        return text\n\n    def _load_from_source(self):\n        filename = self.resolve_path(self.source)\n        self.text = self.preload(filename,\n                                 self.source_encoding,\n                                 self.source_error)\n\n    def _load_from_text(self, *largs):\n        try:\n            # clear the current widgets\n            self.content.clear_widgets()\n            self.anchors_widgets = []\n            self.refs_assoc = {}\n\n            # parse the source\n            document = utils.new_document('Document', self._settings)\n            text = self.text\n            if PY2 and type(text) is str:\n                text = text.decode('utf-8')\n            self._parser.parse(text, document)\n\n            # fill the current document node\n            visitor = _Visitor(self, document)\n            document.walkabout(visitor)\n\n            self.title = visitor.title or 'No title'\n        except:\n            Logger.exception('Rst: error while loading text')\n\n    def on_ref_press(self, node, ref):\n        self.goto(ref)\n\n    def goto(self, ref, *largs):\n        '''Scroll to the reference. If it's not found, nothing will be done.\n\n        For this text::\n\n            .. _myref:\n\n            This is something I always wanted.\n\n        You can do::\n\n            from kivy.clock import Clock\n            from functools import partial\n\n            doc = RstDocument(...)\n            Clock.schedule_once(partial(doc.goto, 'myref'), 0.1)\n\n        .. note::\n\n            It is preferable to delay the call of the goto if you just loaded\n            the document because the layout might not be finished or the\n            size of the RstDocument has not yet been determined. In\n            either case, the calculation of the scrolling would be\n            wrong.\n\n            You can, however, do a direct call if the document is already\n            loaded.\n\n        .. versionadded:: 1.3.0\n        '''\n        # check if it's a file ?\n        if ref.endswith('.rst'):\n            # whether it's a valid or invalid file, let source deal with it\n            self.source = ref\n            return\n\n        # get the association\n        ref = self.refs_assoc.get(ref, ref)\n\n        # search into all the nodes containing anchors\n        ax = ay = None\n        for node in self.anchors_widgets:\n            if ref in node.anchors:\n                ax, ay = node.anchors[ref]\n                break\n\n        # not found, stop here\n        if ax is None:\n            return\n\n        # found, calculate the real coordinate\n\n        # get the anchor coordinate inside widget space\n        ax += node.x\n        ay = node.top - ay\n        # ay += node.y\n\n        # what's the current coordinate for us?\n        sx, sy = self.scatter.x, self.scatter.top\n        # ax, ay = self.scatter.to_parent(ax, ay)\n\n        ay -= self.height\n\n        dx, dy = self.convert_distance_to_scroll(0, ay)\n        dy = max(0, min(1, dy))\n        Animation(scroll_y=dy, d=.25, t='in_out_expo').start(self)\n\n    def add_anchors(self, node):\n        self.anchors_widgets.append(node)",
  "class RstTitle(Label):\n\n    section = NumericProperty(0)\n\n    document = ObjectProperty(None)",
  "class RstParagraph(Label):\n\n    mx = NumericProperty(10)\n\n    my = NumericProperty(10)\n\n    document = ObjectProperty(None)",
  "class RstTerm(AnchorLayout):\n\n    text = StringProperty('')\n\n    document = ObjectProperty(None)",
  "class RstBlockQuote(GridLayout):\n    content = ObjectProperty(None)",
  "class RstLiteralBlock(GridLayout):\n    content = ObjectProperty(None)",
  "class RstList(GridLayout):\n    pass",
  "class RstListItem(GridLayout):\n    content = ObjectProperty(None)",
  "class RstListBullet(Label):\n\n    document = ObjectProperty(None)",
  "class RstSystemMessage(GridLayout):\n    pass",
  "class RstWarning(GridLayout):\n    content = ObjectProperty(None)",
  "class RstNote(GridLayout):\n    content = ObjectProperty(None)",
  "class RstImage(Image):\n    pass",
  "class RstAsyncImage(AsyncImage):\n    pass",
  "class RstDefinitionList(GridLayout):\n\n    document = ObjectProperty(None)",
  "class RstDefinition(GridLayout):\n\n    document = ObjectProperty(None)",
  "class RstFieldList(GridLayout):\n    pass",
  "class RstFieldName(Label):\n\n    document = ObjectProperty(None)",
  "class RstFieldBody(GridLayout):\n    pass",
  "class RstFootnote(GridLayout):\n    pass",
  "class RstFootName(Label):\n\n    document = ObjectProperty(None)",
  "class RstGridLayout(GridLayout):\n    pass",
  "class RstTable(GridLayout):\n    pass",
  "class RstEntry(GridLayout):\n    pass",
  "class RstTransition(Widget):\n    pass",
  "class RstEmptySpace(Widget):\n    pass",
  "class RstDefinitionSpace(Widget):\n\n    document = ObjectProperty(None)",
  "class _ToctreeVisitor(nodes.NodeVisitor):\n\n    def __init__(self, *largs):\n        self.toctree = self.current = []\n        self.queue = []\n        self.text = ''\n        nodes.NodeVisitor.__init__(self, *largs)\n\n    def push(self, tree):\n        self.queue.append(tree)\n        self.current = tree\n\n    def pop(self):\n        self.current = self.queue.pop()\n\n    def dispatch_visit(self, node):\n        cls = node.__class__\n        if cls is nodes.section:\n            section = {\n                'ids': node['ids'],\n                'names': node['names'],\n                'title': '',\n                'children': []}\n            if isinstance(self.current, dict):\n                self.current['children'].append(section)\n            else:\n                self.current.append(section)\n            self.push(section)\n        elif cls is nodes.title:\n            self.text = ''\n        elif cls is nodes.Text:\n            self.text += node\n\n    def dispatch_departure(self, node):\n        cls = node.__class__\n        if cls is nodes.section:\n            self.pop()\n        elif cls is nodes.title:\n            self.current['title'] = self.text",
  "class _Visitor(nodes.NodeVisitor):\n\n    def __init__(self, root, *largs):\n        self.root = root\n        self.title = None\n        self.current_list = []\n        self.current = None\n        self.idx_list = None\n        self.text = ''\n        self.text_have_anchor = False\n        self.section = 0\n        self.do_strip_text = False\n        self.substitution = {}\n\n        # store refblock here while building\n        self.foot_refblock = None\n\n        # store order for autonum/sym footnotes+refs\n        self.footnotes = {\n            'autonum': 0,\n            'autosym': 0,\n            'autonum_ref': 0,\n            'autosym_ref': 0,\n        }\n\n        # last four default chars aren't in our Roboto font,\n        # those were replaced with something else\n        self.footlist = [\n            '\\u002A',  # asterisk\n            '\\u2020',  # dagger\n            '\\u2021',  # doubledagger\n            '\\u00A7',  # section\n            '\\u00B6',  # pilcrow\n            '\\u0023',  # number\n            '\\u2206',  # cap delta\n            '\\u220F',  # cap pi\n            '\\u0470',  # cap psi\n            '\\u0466',  # cap yus\n        ]\n        nodes.NodeVisitor.__init__(self, *largs)\n\n    def push(self, widget):\n        self.current_list.append(self.current)\n        self.current = widget\n\n    def pop(self):\n        self.current = self.current_list.pop()\n\n    def brute_refs(self, node):\n        # get foot/cit refs manually because the output from\n        # docutils' parser doesn't contain any of these:\n        # node's refid, refname, backref, ... and/or are just ''/[]\n\n        def get_refs(condition, backref=False):\n            # backref=True is used in nodes.footnote\n            autonum = autosym = 0\n            _nodes = node.traverse(condition=condition, ascend=False)\n\n            for f in _nodes:\n                id = f['ids'][0]\n                auto = ''\n                if 'auto' in f:\n                    auto = f['auto']\n\n                # auto is either 1(int) or '*'\n                if auto == 1:\n                    autonum += 1\n                    key = 'backref' + str(autonum) if backref else str(autonum)\n                    self.root.refs_assoc[key] = id\n                elif auto == '*':\n                    sym = self.footlist[\n                        autosym % 10\n                    ] * (int(autosym / 10) + 1)\n                    key = 'backref' + sym if backref else sym\n                    self.root.refs_assoc[key] = id\n                    autosym += 1\n                else:\n                    if not backref:\n                        key = f['names'][0]\n                        if key:\n                            self.root.refs_assoc[key] = id\n                        continue\n\n                    key = 'backref' + f['refname'][0]\n\n                    if key in self.root.refs_assoc:\n                        self.root.refs_assoc[key].append(id)\n                    else:\n                        self.root.refs_assoc[key] = [id, ]\n\n        # these are unique and need to go FIRST\n        get_refs(nodes.footnote, backref=False)\n\n        # autonum & autosym are unique\n        get_refs(nodes.footnote_reference, backref=True)\n\n    def dispatch_visit(self, node):\n        cls = node.__class__\n        if cls is nodes.document:\n            self.push(self.root.content)\n            self.brute_refs(node)\n\n        elif cls is nodes.comment:\n            return\n\n        elif cls is nodes.section:\n            self.section += 1\n\n        elif cls is nodes.substitution_definition:\n            name = node.attributes['names'][0]\n            self.substitution[name] = node.children[0]\n\n        elif cls is nodes.substitution_reference:\n            node = self.substitution[node.attributes['refname']]\n            # it can be e.g. image or something else too!\n            if isinstance(node, nodes.Text):\n                self.text += node\n\n        elif cls is nodes.footnote:\n            # .. [x] footnote\n            text = ''\n            foot = RstFootnote()\n            ids = node.attributes['ids']\n            self.current.add_widget(foot)\n            self.push(foot)\n\n            # check if its autonumbered\n            auto = ''\n            if 'auto' in node.attributes:\n                auto = node.attributes['auto']\n\n            # auto is either 1(int) or '*'\n            if auto == 1:\n                self.footnotes['autonum'] += 1\n                name = str(self.footnotes['autonum'])\n                node_id = node.attributes['ids'][0]\n            elif auto == '*':\n                autosym = self.footnotes['autosym']\n                name = self.footlist[\n                    autosym % 10\n                ] * (int(autosym / 10) + 1)\n                self.footnotes['autosym'] += 1\n                node_id = node.attributes['ids'][0]\n            else:\n                # can have multiple refs:\n                # [8] (1, 2) Footnote ref\n                name = node.attributes['names'][0]\n                node_id = node['ids'][0]\n\n            # we can have a footnote without any link or ref\n            # .. [1] Empty footnote\n            link = self.root.refs_assoc.get(name, '')\n\n            # handle no refs\n            ref = self.root.refs_assoc.get('backref' + name, '')\n\n            # colorize only with refs\n            colorized = self.colorize(name, 'link') if ref else name\n\n            # has no refs\n            if not ref:\n                text = '&bl;%s&br;' % (colorized)\n            # list of refs\n            elif ref and isinstance(ref, list):\n                ref_block = [\n                    '[ref=%s][u]%s[/u][/ref]' % (r, i + 1)\n                    for i, r in enumerate(ref)\n                ]\n                # [1] ( 1, 2, ...) Footnote\n                self.foot_refblock = ''.join([\n                    '[i]( ', ', '.join(ref_block), ' )[/i]'\n                ])\n\n                text = '[anchor=%s]&bl;%s&br;' % (\n                    node['ids'][0], colorized\n                )\n            # single ref\n            else:\n                text = '[anchor=%s][ref=%s]&bl;%s&br;[/ref]' % (\n                    node['ids'][0], ref, colorized\n                )\n\n            name = RstFootName(\n                document=self.root,\n                text=text,\n            )\n            self.current.add_widget(name)\n            # give it anchor + event manually\n            self.root.add_anchors(name)\n            name.bind(on_ref_press=self.root.on_ref_press)\n\n        elif cls is nodes.footnote_reference:\n            self.text += '&bl;'\n            text = ''\n            name = ''\n\n            # check if its autonumbered\n            auto = ''\n            if 'auto' in node.attributes:\n                auto = node.attributes['auto']\n\n            # auto is either 1(int) or '*'\n            if auto == 1:\n                self.footnotes['autonum_ref'] += 1\n                name = str(self.footnotes['autonum_ref'])\n                node_id = node.attributes['ids'][0]\n            elif auto == '*':\n                autosym = self.footnotes['autosym_ref']\n                name = self.footlist[\n                    autosym % 10\n                ] * (int(autosym / 10) + 1)\n                self.footnotes['autosym_ref'] += 1\n                node_id = node.attributes['ids'][0]\n            else:\n                # can have multiple refs:\n                # [8] (1, 2) Footnote ref\n                name = node.children[0]\n                node_id = node['ids'][0]\n            text += name\n\n            refs = self.root.refs_assoc.get(name, '')\n            if not refs and auto in (1, '*'):\n                # parser should trigger it when checking\n                # for backlinks, but we don't have **any** refs\n                # to work with, so we have to trigger it manually\n                raise Exception(\n                    'Too many autonumbered or autosymboled '\n                    'footnote references!'\n                )\n\n            # has a single or no refs ( '' )\n            text = '[anchor=%s][ref=%s][color=%s]%s' % (\n                node_id, refs,\n                self.root.colors.get(\n                    'link', self.root.colors.get('paragraph')\n                ),\n                text\n            )\n            self.text += text\n            self.text_have_anchor = True\n\n        elif cls is nodes.title:\n            label = RstTitle(section=self.section, document=self.root)\n            self.current.add_widget(label)\n            self.push(label)\n            # assert self.text == ''\n\n        elif cls is nodes.Text:\n            # check if parent isn't a special directive\n            if hasattr(node, 'parent'):\n                if node.parent.tagname == 'substitution_definition':\n                    # .. |ref| replace:: something\n                    return\n                elif node.parent.tagname == 'substitution_reference':\n                    # |ref|\n                    return\n                elif node.parent.tagname == 'comment':\n                    # .. COMMENT\n                    return\n                elif node.parent.tagname == 'footnote_reference':\n                    # .. [#]_\n                    # .. [*]_\n                    # rewrite it to handle autonum/sym here\n                    # close tags with departure\n                    return\n\n            if self.do_strip_text:\n                node = node.replace('\\n', ' ')\n                node = node.replace('  ', ' ')\n                node = node.replace('\\t', ' ')\n                node = node.replace('  ', ' ')\n                if node.startswith(' '):\n                    node = ' ' + node.lstrip(' ')\n                if node.endswith(' '):\n                    node = node.rstrip(' ') + ' '\n                if self.text.endswith(' ') and node.startswith(' '):\n                    node = node[1:]\n            self.text += node\n\n        elif cls is nodes.paragraph:\n            self.do_strip_text = True\n\n            if isinstance(node.parent, nodes.footnote):\n                if self.foot_refblock:\n                    self.text = self.foot_refblock + ' '\n                self.foot_refblock = None\n                # self.do_strip_text = False\n\n            label = RstParagraph(document=self.root)\n            if isinstance(self.current, RstEntry):\n                label.mx = 10\n            self.current.add_widget(label)\n            self.push(label)\n\n        elif cls is nodes.literal_block:\n            box = RstLiteralBlock()\n            self.current.add_widget(box)\n            self.push(box)\n\n        elif cls is nodes.emphasis:\n            self.text += '[i]'\n\n        elif cls is nodes.strong:\n            self.text += '[b]'\n\n        elif cls is nodes.literal:\n            self.text += '[font=fonts/RobotoMono-Regular.ttf]'\n\n        elif cls is nodes.block_quote:\n            box = RstBlockQuote()\n            self.current.add_widget(box)\n            self.push(box.content)\n            assert self.text == ''\n\n        elif cls is nodes.enumerated_list:\n            box = RstList()\n            self.current.add_widget(box)\n            self.push(box)\n            self.idx_list = 0\n\n        elif cls is nodes.bullet_list:\n            box = RstList()\n            self.current.add_widget(box)\n            self.push(box)\n            self.idx_list = None\n\n        elif cls is nodes.list_item:\n            bullet = '-'\n            if self.idx_list is not None:\n                self.idx_list += 1\n                bullet = '%d.' % self.idx_list\n            bullet = self.colorize(bullet, 'bullet')\n            item = RstListItem()\n            self.current.add_widget(RstListBullet(\n                text=bullet, document=self.root))\n            self.current.add_widget(item)\n            self.push(item)\n\n        elif cls is nodes.system_message:\n            label = RstSystemMessage()\n            if self.root.show_errors:\n                self.current.add_widget(label)\n            self.push(label)\n\n        elif cls is nodes.warning:\n            label = RstWarning()\n            self.current.add_widget(label)\n            self.push(label.content)\n            assert self.text == ''\n\n        elif cls is nodes.note:\n            label = RstNote()\n            self.current.add_widget(label)\n            self.push(label.content)\n            assert self.text == ''\n\n        elif cls is nodes.image:\n            # docutils parser breaks path with spaces\n            # e.g. \"C:/my path\" -> \"C:/mypath\"\n            uri = node['uri']\n            align = node.get('align', 'center')\n            image_size = [\n                node.get('width'),\n                node.get('height')\n            ]\n\n            # use user's size if defined\n            def set_size(img, size):\n                img.size = [\n                    size[0] or img.width,\n                    size[1] or img.height\n                ]\n\n            if uri.startswith('/') and self.root.document_root:\n                uri = join(self.root.document_root, uri[1:])\n\n            if uri.startswith('http://') or uri.startswith('https://'):\n                image = RstAsyncImage(source=uri)\n                image.bind(on_load=lambda *a: set_size(image, image_size))\n            else:\n                image = RstImage(source=uri)\n                set_size(image, image_size)\n\n            root = AnchorLayout(\n                size_hint_y=None,\n                anchor_x=align,\n                height=image.height\n            )\n\n            image.bind(height=root.setter('height'))\n            root.add_widget(image)\n            self.current.add_widget(root)\n            # TODO:\n            # .. _img: <url>\n            # .. |img| image:: <img>\n            # |img|_ <- needs refs and on_ref_press\n\n        elif cls is nodes.definition_list:\n            lst = RstDefinitionList(document=self.root)\n            self.current.add_widget(lst)\n            self.push(lst)\n\n        elif cls is nodes.term:\n            assert isinstance(self.current, RstDefinitionList)\n            term = RstTerm(document=self.root)\n            self.current.add_widget(term)\n            self.push(term)\n\n        elif cls is nodes.definition:\n            assert isinstance(self.current, RstDefinitionList)\n            definition = RstDefinition(document=self.root)\n            definition.add_widget(RstDefinitionSpace(document=self.root))\n            self.current.add_widget(definition)\n            self.push(definition)\n\n        elif cls is nodes.field_list:\n            fieldlist = RstFieldList()\n            self.current.add_widget(fieldlist)\n            self.push(fieldlist)\n\n        elif cls is nodes.field_name:\n            name = RstFieldName(document=self.root)\n            self.current.add_widget(name)\n            self.push(name)\n\n        elif cls is nodes.field_body:\n            body = RstFieldBody()\n            self.current.add_widget(body)\n            self.push(body)\n\n        elif cls is nodes.table:\n            table = RstTable(cols=0)\n            self.current.add_widget(table)\n            self.push(table)\n\n        elif cls is nodes.colspec:\n            self.current.cols += 1\n\n        elif cls is nodes.entry:\n            entry = RstEntry()\n            self.current.add_widget(entry)\n            self.push(entry)\n\n        elif cls is nodes.transition:\n            self.current.add_widget(RstTransition())\n\n        elif cls is nodes.reference:\n            name = node.get('name', node.get('refuri'))\n            self.text += '[ref=%s][color=%s]' % (\n                name, self.root.colors.get(\n                    'link', self.root.colors.get('paragraph')))\n            if 'refname' in node and 'name' in node:\n                self.root.refs_assoc[node['name']] = node['refname']\n\n        elif cls is nodes.target:\n            name = None\n            if 'ids' in node:\n                name = node['ids'][0]\n            elif 'names' in node:\n                name = node['names'][0]\n            self.text += '[anchor=%s]' % name\n            self.text_have_anchor = True\n\n        elif cls is role_doc:\n            self.doc_index = len(self.text)\n\n        elif cls is role_video:\n            pass\n\n    def dispatch_departure(self, node):\n        cls = node.__class__\n        if cls is nodes.document:\n            self.pop()\n\n        elif cls is nodes.section:\n            self.section -= 1\n\n        elif cls is nodes.title:\n            assert isinstance(self.current, RstTitle)\n            if not self.title:\n                self.title = self.text\n            self.set_text(self.current, 'title')\n            self.pop()\n\n        elif cls is nodes.Text:\n            pass\n\n        elif cls is nodes.paragraph:\n            self.do_strip_text = False\n            assert isinstance(self.current, RstParagraph)\n            self.set_text(self.current, 'paragraph')\n            self.pop()\n\n        elif cls is nodes.literal_block:\n            assert isinstance(self.current, RstLiteralBlock)\n            self.set_text(self.current.content, 'literal_block')\n            self.pop()\n\n        elif cls is nodes.emphasis:\n            self.text += '[/i]'\n\n        elif cls is nodes.strong:\n            self.text += '[/b]'\n\n        elif cls is nodes.literal:\n            self.text += '[/font]'\n\n        elif cls is nodes.block_quote:\n            self.pop()\n\n        elif cls is nodes.enumerated_list:\n            self.idx_list = None\n            self.pop()\n\n        elif cls is nodes.bullet_list:\n            self.pop()\n\n        elif cls is nodes.list_item:\n            self.pop()\n\n        elif cls is nodes.system_message:\n            self.pop()\n\n        elif cls is nodes.warning:\n            self.pop()\n\n        elif cls is nodes.note:\n            self.pop()\n\n        elif cls is nodes.definition_list:\n            self.pop()\n\n        elif cls is nodes.term:\n            assert isinstance(self.current, RstTerm)\n            self.set_text(self.current, 'term')\n            self.pop()\n\n        elif cls is nodes.definition:\n            self.pop()\n\n        elif cls is nodes.field_list:\n            self.pop()\n\n        elif cls is nodes.field_name:\n            assert isinstance(self.current, RstFieldName)\n            self.set_text(self.current, 'field_name')\n            self.pop()\n\n        elif cls is nodes.field_body:\n            self.pop()\n\n        elif cls is nodes.table:\n            self.pop()\n\n        elif cls is nodes.colspec:\n            pass\n\n        elif cls is nodes.entry:\n            self.pop()\n\n        elif cls is nodes.reference:\n            self.text += '[/color][/ref]'\n\n        elif cls is nodes.footnote:\n            self.pop()\n            self.set_text(self.current, 'link')\n\n        elif cls is nodes.footnote_reference:\n            # close opened footnote [x]\n            # self.text += '[/ref]'\n            # self.set_text(self.current, 'link')\n            self.text += '[/color][/ref]'\n            # self.text += '[/color][/ref]'\n            self.text += '&br;'\n\n        elif cls is role_doc:\n            docname = self.text[self.doc_index:]\n            rst_docname = docname\n            if rst_docname.endswith('.rst'):\n                docname = docname[:-4]\n            else:\n                rst_docname += '.rst'\n\n            # try to preload it\n            filename = self.root.resolve_path(rst_docname)\n            self.root.preload(filename)\n\n            # if exist, use the title of the first section found in the\n            # document\n            title = docname\n            if filename in self.root.toctrees:\n                toctree = self.root.toctrees[filename]\n                if len(toctree):\n                    title = toctree[0]['title']\n\n            # replace the text with a good reference\n            text = '[ref=%s]%s[/ref]' % (\n                rst_docname,\n                self.colorize(title, 'link'))\n            self.text = self.text[:self.doc_index] + text\n\n        elif cls is role_video:\n            width = node['width'] if 'width' in node.attlist() else 400\n            height = node['height'] if 'height' in node.attlist() else 300\n            uri = node['source']\n            if uri.startswith('/') and self.root.document_root:\n                uri = join(self.root.document_root, uri[1:])\n            video = RstVideoPlayer(\n                source=uri,\n                size_hint=(None, None),\n                size=(width, height))\n            anchor = AnchorLayout(size_hint_y=None, height=height + 20)\n            anchor.add_widget(video)\n            self.current.add_widget(anchor)\n\n    def set_text(self, node, parent):\n        text = self.text\n        if parent == 'term' or parent == 'field_name':\n            text = '[b]%s[/b]' % text\n        # search anchors\n        node.text = self.colorize(text, parent)\n        node.bind(on_ref_press=self.root.on_ref_press)\n        if self.text_have_anchor:\n            self.root.add_anchors(node)\n        self.text = ''\n        self.text_have_anchor = False\n\n    def colorize(self, text, name):\n        return '[color=%s]%s[/color]' % (\n            self.root.colors.get(name, self.root.colors['paragraph']),\n            text)",
  "class role_doc(nodes.Inline, nodes.TextElement):\n        pass",
  "class role_video(nodes.General, nodes.TextElement):\n        pass",
  "class VideoDirective(Directive):\n        has_content = False\n        required_arguments = 1\n        optional_arguments = 0\n        final_argument_whitespace = True\n        option_spec = {'width': directives.nonnegative_int,\n                       'height': directives.nonnegative_int}\n\n        def run(self):\n            set_classes(self.options)\n            node = role_video(source=self.arguments[0], **self.options)\n            return [node]",
  "def _get_bgc(self):\n        return get_color_from_hex(self.colors.background)",
  "def _set_bgc(self, value):\n        self.colors.background = get_hex_from_color(value)[1:]",
  "def __init__(self, **kwargs):\n        self._trigger_load = Clock.create_trigger(self._load_from_text, -1)\n        self._parser = rst.Parser()\n        self._settings = frontend.OptionParser(\n            components=(rst.Parser, )).get_default_values()\n        super(RstDocument, self).__init__(**kwargs)",
  "def on_source(self, instance, value):\n        if not value:\n            return\n        if self.document_root is None:\n            # set the documentation root to the directory name of the\n            # first tile\n            self.document_root = abspath(dirname(value))\n        self._load_from_source()",
  "def on_text(self, instance, value):\n        self._trigger_load()",
  "def render(self):\n        '''Force document rendering.\n        '''\n        self._load_from_text()",
  "def resolve_path(self, filename):\n        '''Get the path for this filename. If the filename doesn't exist,\n        it returns the document_root + filename.\n        '''\n        if exists(filename):\n            return filename\n        return join(self.document_root, filename)",
  "def preload(self, filename, encoding='utf-8', errors='strict'):\n        '''Preload a rst file to get its toctree and its title.\n\n        The result will be stored in :attr:`toctrees` with the ``filename`` as\n        key.\n        '''\n\n        with open(filename, 'rb') as fd:\n            text = fd.read().decode(encoding, errors)\n        # parse the source\n        document = utils.new_document('Document', self._settings)\n        self._parser.parse(text, document)\n        # fill the current document node\n        visitor = _ToctreeVisitor(document)\n        document.walkabout(visitor)\n        self.toctrees[filename] = visitor.toctree\n        return text",
  "def _load_from_source(self):\n        filename = self.resolve_path(self.source)\n        self.text = self.preload(filename,\n                                 self.source_encoding,\n                                 self.source_error)",
  "def _load_from_text(self, *largs):\n        try:\n            # clear the current widgets\n            self.content.clear_widgets()\n            self.anchors_widgets = []\n            self.refs_assoc = {}\n\n            # parse the source\n            document = utils.new_document('Document', self._settings)\n            text = self.text\n            if PY2 and type(text) is str:\n                text = text.decode('utf-8')\n            self._parser.parse(text, document)\n\n            # fill the current document node\n            visitor = _Visitor(self, document)\n            document.walkabout(visitor)\n\n            self.title = visitor.title or 'No title'\n        except:\n            Logger.exception('Rst: error while loading text')",
  "def on_ref_press(self, node, ref):\n        self.goto(ref)",
  "def goto(self, ref, *largs):\n        '''Scroll to the reference. If it's not found, nothing will be done.\n\n        For this text::\n\n            .. _myref:\n\n            This is something I always wanted.\n\n        You can do::\n\n            from kivy.clock import Clock\n            from functools import partial\n\n            doc = RstDocument(...)\n            Clock.schedule_once(partial(doc.goto, 'myref'), 0.1)\n\n        .. note::\n\n            It is preferable to delay the call of the goto if you just loaded\n            the document because the layout might not be finished or the\n            size of the RstDocument has not yet been determined. In\n            either case, the calculation of the scrolling would be\n            wrong.\n\n            You can, however, do a direct call if the document is already\n            loaded.\n\n        .. versionadded:: 1.3.0\n        '''\n        # check if it's a file ?\n        if ref.endswith('.rst'):\n            # whether it's a valid or invalid file, let source deal with it\n            self.source = ref\n            return\n\n        # get the association\n        ref = self.refs_assoc.get(ref, ref)\n\n        # search into all the nodes containing anchors\n        ax = ay = None\n        for node in self.anchors_widgets:\n            if ref in node.anchors:\n                ax, ay = node.anchors[ref]\n                break\n\n        # not found, stop here\n        if ax is None:\n            return\n\n        # found, calculate the real coordinate\n\n        # get the anchor coordinate inside widget space\n        ax += node.x\n        ay = node.top - ay\n        # ay += node.y\n\n        # what's the current coordinate for us?\n        sx, sy = self.scatter.x, self.scatter.top\n        # ax, ay = self.scatter.to_parent(ax, ay)\n\n        ay -= self.height\n\n        dx, dy = self.convert_distance_to_scroll(0, ay)\n        dy = max(0, min(1, dy))\n        Animation(scroll_y=dy, d=.25, t='in_out_expo').start(self)",
  "def add_anchors(self, node):\n        self.anchors_widgets.append(node)",
  "def __init__(self, *largs):\n        self.toctree = self.current = []\n        self.queue = []\n        self.text = ''\n        nodes.NodeVisitor.__init__(self, *largs)",
  "def push(self, tree):\n        self.queue.append(tree)\n        self.current = tree",
  "def pop(self):\n        self.current = self.queue.pop()",
  "def dispatch_visit(self, node):\n        cls = node.__class__\n        if cls is nodes.section:\n            section = {\n                'ids': node['ids'],\n                'names': node['names'],\n                'title': '',\n                'children': []}\n            if isinstance(self.current, dict):\n                self.current['children'].append(section)\n            else:\n                self.current.append(section)\n            self.push(section)\n        elif cls is nodes.title:\n            self.text = ''\n        elif cls is nodes.Text:\n            self.text += node",
  "def dispatch_departure(self, node):\n        cls = node.__class__\n        if cls is nodes.section:\n            self.pop()\n        elif cls is nodes.title:\n            self.current['title'] = self.text",
  "def __init__(self, root, *largs):\n        self.root = root\n        self.title = None\n        self.current_list = []\n        self.current = None\n        self.idx_list = None\n        self.text = ''\n        self.text_have_anchor = False\n        self.section = 0\n        self.do_strip_text = False\n        self.substitution = {}\n\n        # store refblock here while building\n        self.foot_refblock = None\n\n        # store order for autonum/sym footnotes+refs\n        self.footnotes = {\n            'autonum': 0,\n            'autosym': 0,\n            'autonum_ref': 0,\n            'autosym_ref': 0,\n        }\n\n        # last four default chars aren't in our Roboto font,\n        # those were replaced with something else\n        self.footlist = [\n            '\\u002A',  # asterisk\n            '\\u2020',  # dagger\n            '\\u2021',  # doubledagger\n            '\\u00A7',  # section\n            '\\u00B6',  # pilcrow\n            '\\u0023',  # number\n            '\\u2206',  # cap delta\n            '\\u220F',  # cap pi\n            '\\u0470',  # cap psi\n            '\\u0466',  # cap yus\n        ]\n        nodes.NodeVisitor.__init__(self, *largs)",
  "def push(self, widget):\n        self.current_list.append(self.current)\n        self.current = widget",
  "def pop(self):\n        self.current = self.current_list.pop()",
  "def brute_refs(self, node):\n        # get foot/cit refs manually because the output from\n        # docutils' parser doesn't contain any of these:\n        # node's refid, refname, backref, ... and/or are just ''/[]\n\n        def get_refs(condition, backref=False):\n            # backref=True is used in nodes.footnote\n            autonum = autosym = 0\n            _nodes = node.traverse(condition=condition, ascend=False)\n\n            for f in _nodes:\n                id = f['ids'][0]\n                auto = ''\n                if 'auto' in f:\n                    auto = f['auto']\n\n                # auto is either 1(int) or '*'\n                if auto == 1:\n                    autonum += 1\n                    key = 'backref' + str(autonum) if backref else str(autonum)\n                    self.root.refs_assoc[key] = id\n                elif auto == '*':\n                    sym = self.footlist[\n                        autosym % 10\n                    ] * (int(autosym / 10) + 1)\n                    key = 'backref' + sym if backref else sym\n                    self.root.refs_assoc[key] = id\n                    autosym += 1\n                else:\n                    if not backref:\n                        key = f['names'][0]\n                        if key:\n                            self.root.refs_assoc[key] = id\n                        continue\n\n                    key = 'backref' + f['refname'][0]\n\n                    if key in self.root.refs_assoc:\n                        self.root.refs_assoc[key].append(id)\n                    else:\n                        self.root.refs_assoc[key] = [id, ]\n\n        # these are unique and need to go FIRST\n        get_refs(nodes.footnote, backref=False)\n\n        # autonum & autosym are unique\n        get_refs(nodes.footnote_reference, backref=True)",
  "def dispatch_visit(self, node):\n        cls = node.__class__\n        if cls is nodes.document:\n            self.push(self.root.content)\n            self.brute_refs(node)\n\n        elif cls is nodes.comment:\n            return\n\n        elif cls is nodes.section:\n            self.section += 1\n\n        elif cls is nodes.substitution_definition:\n            name = node.attributes['names'][0]\n            self.substitution[name] = node.children[0]\n\n        elif cls is nodes.substitution_reference:\n            node = self.substitution[node.attributes['refname']]\n            # it can be e.g. image or something else too!\n            if isinstance(node, nodes.Text):\n                self.text += node\n\n        elif cls is nodes.footnote:\n            # .. [x] footnote\n            text = ''\n            foot = RstFootnote()\n            ids = node.attributes['ids']\n            self.current.add_widget(foot)\n            self.push(foot)\n\n            # check if its autonumbered\n            auto = ''\n            if 'auto' in node.attributes:\n                auto = node.attributes['auto']\n\n            # auto is either 1(int) or '*'\n            if auto == 1:\n                self.footnotes['autonum'] += 1\n                name = str(self.footnotes['autonum'])\n                node_id = node.attributes['ids'][0]\n            elif auto == '*':\n                autosym = self.footnotes['autosym']\n                name = self.footlist[\n                    autosym % 10\n                ] * (int(autosym / 10) + 1)\n                self.footnotes['autosym'] += 1\n                node_id = node.attributes['ids'][0]\n            else:\n                # can have multiple refs:\n                # [8] (1, 2) Footnote ref\n                name = node.attributes['names'][0]\n                node_id = node['ids'][0]\n\n            # we can have a footnote without any link or ref\n            # .. [1] Empty footnote\n            link = self.root.refs_assoc.get(name, '')\n\n            # handle no refs\n            ref = self.root.refs_assoc.get('backref' + name, '')\n\n            # colorize only with refs\n            colorized = self.colorize(name, 'link') if ref else name\n\n            # has no refs\n            if not ref:\n                text = '&bl;%s&br;' % (colorized)\n            # list of refs\n            elif ref and isinstance(ref, list):\n                ref_block = [\n                    '[ref=%s][u]%s[/u][/ref]' % (r, i + 1)\n                    for i, r in enumerate(ref)\n                ]\n                # [1] ( 1, 2, ...) Footnote\n                self.foot_refblock = ''.join([\n                    '[i]( ', ', '.join(ref_block), ' )[/i]'\n                ])\n\n                text = '[anchor=%s]&bl;%s&br;' % (\n                    node['ids'][0], colorized\n                )\n            # single ref\n            else:\n                text = '[anchor=%s][ref=%s]&bl;%s&br;[/ref]' % (\n                    node['ids'][0], ref, colorized\n                )\n\n            name = RstFootName(\n                document=self.root,\n                text=text,\n            )\n            self.current.add_widget(name)\n            # give it anchor + event manually\n            self.root.add_anchors(name)\n            name.bind(on_ref_press=self.root.on_ref_press)\n\n        elif cls is nodes.footnote_reference:\n            self.text += '&bl;'\n            text = ''\n            name = ''\n\n            # check if its autonumbered\n            auto = ''\n            if 'auto' in node.attributes:\n                auto = node.attributes['auto']\n\n            # auto is either 1(int) or '*'\n            if auto == 1:\n                self.footnotes['autonum_ref'] += 1\n                name = str(self.footnotes['autonum_ref'])\n                node_id = node.attributes['ids'][0]\n            elif auto == '*':\n                autosym = self.footnotes['autosym_ref']\n                name = self.footlist[\n                    autosym % 10\n                ] * (int(autosym / 10) + 1)\n                self.footnotes['autosym_ref'] += 1\n                node_id = node.attributes['ids'][0]\n            else:\n                # can have multiple refs:\n                # [8] (1, 2) Footnote ref\n                name = node.children[0]\n                node_id = node['ids'][0]\n            text += name\n\n            refs = self.root.refs_assoc.get(name, '')\n            if not refs and auto in (1, '*'):\n                # parser should trigger it when checking\n                # for backlinks, but we don't have **any** refs\n                # to work with, so we have to trigger it manually\n                raise Exception(\n                    'Too many autonumbered or autosymboled '\n                    'footnote references!'\n                )\n\n            # has a single or no refs ( '' )\n            text = '[anchor=%s][ref=%s][color=%s]%s' % (\n                node_id, refs,\n                self.root.colors.get(\n                    'link', self.root.colors.get('paragraph')\n                ),\n                text\n            )\n            self.text += text\n            self.text_have_anchor = True\n\n        elif cls is nodes.title:\n            label = RstTitle(section=self.section, document=self.root)\n            self.current.add_widget(label)\n            self.push(label)\n            # assert self.text == ''\n\n        elif cls is nodes.Text:\n            # check if parent isn't a special directive\n            if hasattr(node, 'parent'):\n                if node.parent.tagname == 'substitution_definition':\n                    # .. |ref| replace:: something\n                    return\n                elif node.parent.tagname == 'substitution_reference':\n                    # |ref|\n                    return\n                elif node.parent.tagname == 'comment':\n                    # .. COMMENT\n                    return\n                elif node.parent.tagname == 'footnote_reference':\n                    # .. [#]_\n                    # .. [*]_\n                    # rewrite it to handle autonum/sym here\n                    # close tags with departure\n                    return\n\n            if self.do_strip_text:\n                node = node.replace('\\n', ' ')\n                node = node.replace('  ', ' ')\n                node = node.replace('\\t', ' ')\n                node = node.replace('  ', ' ')\n                if node.startswith(' '):\n                    node = ' ' + node.lstrip(' ')\n                if node.endswith(' '):\n                    node = node.rstrip(' ') + ' '\n                if self.text.endswith(' ') and node.startswith(' '):\n                    node = node[1:]\n            self.text += node\n\n        elif cls is nodes.paragraph:\n            self.do_strip_text = True\n\n            if isinstance(node.parent, nodes.footnote):\n                if self.foot_refblock:\n                    self.text = self.foot_refblock + ' '\n                self.foot_refblock = None\n                # self.do_strip_text = False\n\n            label = RstParagraph(document=self.root)\n            if isinstance(self.current, RstEntry):\n                label.mx = 10\n            self.current.add_widget(label)\n            self.push(label)\n\n        elif cls is nodes.literal_block:\n            box = RstLiteralBlock()\n            self.current.add_widget(box)\n            self.push(box)\n\n        elif cls is nodes.emphasis:\n            self.text += '[i]'\n\n        elif cls is nodes.strong:\n            self.text += '[b]'\n\n        elif cls is nodes.literal:\n            self.text += '[font=fonts/RobotoMono-Regular.ttf]'\n\n        elif cls is nodes.block_quote:\n            box = RstBlockQuote()\n            self.current.add_widget(box)\n            self.push(box.content)\n            assert self.text == ''\n\n        elif cls is nodes.enumerated_list:\n            box = RstList()\n            self.current.add_widget(box)\n            self.push(box)\n            self.idx_list = 0\n\n        elif cls is nodes.bullet_list:\n            box = RstList()\n            self.current.add_widget(box)\n            self.push(box)\n            self.idx_list = None\n\n        elif cls is nodes.list_item:\n            bullet = '-'\n            if self.idx_list is not None:\n                self.idx_list += 1\n                bullet = '%d.' % self.idx_list\n            bullet = self.colorize(bullet, 'bullet')\n            item = RstListItem()\n            self.current.add_widget(RstListBullet(\n                text=bullet, document=self.root))\n            self.current.add_widget(item)\n            self.push(item)\n\n        elif cls is nodes.system_message:\n            label = RstSystemMessage()\n            if self.root.show_errors:\n                self.current.add_widget(label)\n            self.push(label)\n\n        elif cls is nodes.warning:\n            label = RstWarning()\n            self.current.add_widget(label)\n            self.push(label.content)\n            assert self.text == ''\n\n        elif cls is nodes.note:\n            label = RstNote()\n            self.current.add_widget(label)\n            self.push(label.content)\n            assert self.text == ''\n\n        elif cls is nodes.image:\n            # docutils parser breaks path with spaces\n            # e.g. \"C:/my path\" -> \"C:/mypath\"\n            uri = node['uri']\n            align = node.get('align', 'center')\n            image_size = [\n                node.get('width'),\n                node.get('height')\n            ]\n\n            # use user's size if defined\n            def set_size(img, size):\n                img.size = [\n                    size[0] or img.width,\n                    size[1] or img.height\n                ]\n\n            if uri.startswith('/') and self.root.document_root:\n                uri = join(self.root.document_root, uri[1:])\n\n            if uri.startswith('http://') or uri.startswith('https://'):\n                image = RstAsyncImage(source=uri)\n                image.bind(on_load=lambda *a: set_size(image, image_size))\n            else:\n                image = RstImage(source=uri)\n                set_size(image, image_size)\n\n            root = AnchorLayout(\n                size_hint_y=None,\n                anchor_x=align,\n                height=image.height\n            )\n\n            image.bind(height=root.setter('height'))\n            root.add_widget(image)\n            self.current.add_widget(root)\n            # TODO:\n            # .. _img: <url>\n            # .. |img| image:: <img>\n            # |img|_ <- needs refs and on_ref_press\n\n        elif cls is nodes.definition_list:\n            lst = RstDefinitionList(document=self.root)\n            self.current.add_widget(lst)\n            self.push(lst)\n\n        elif cls is nodes.term:\n            assert isinstance(self.current, RstDefinitionList)\n            term = RstTerm(document=self.root)\n            self.current.add_widget(term)\n            self.push(term)\n\n        elif cls is nodes.definition:\n            assert isinstance(self.current, RstDefinitionList)\n            definition = RstDefinition(document=self.root)\n            definition.add_widget(RstDefinitionSpace(document=self.root))\n            self.current.add_widget(definition)\n            self.push(definition)\n\n        elif cls is nodes.field_list:\n            fieldlist = RstFieldList()\n            self.current.add_widget(fieldlist)\n            self.push(fieldlist)\n\n        elif cls is nodes.field_name:\n            name = RstFieldName(document=self.root)\n            self.current.add_widget(name)\n            self.push(name)\n\n        elif cls is nodes.field_body:\n            body = RstFieldBody()\n            self.current.add_widget(body)\n            self.push(body)\n\n        elif cls is nodes.table:\n            table = RstTable(cols=0)\n            self.current.add_widget(table)\n            self.push(table)\n\n        elif cls is nodes.colspec:\n            self.current.cols += 1\n\n        elif cls is nodes.entry:\n            entry = RstEntry()\n            self.current.add_widget(entry)\n            self.push(entry)\n\n        elif cls is nodes.transition:\n            self.current.add_widget(RstTransition())\n\n        elif cls is nodes.reference:\n            name = node.get('name', node.get('refuri'))\n            self.text += '[ref=%s][color=%s]' % (\n                name, self.root.colors.get(\n                    'link', self.root.colors.get('paragraph')))\n            if 'refname' in node and 'name' in node:\n                self.root.refs_assoc[node['name']] = node['refname']\n\n        elif cls is nodes.target:\n            name = None\n            if 'ids' in node:\n                name = node['ids'][0]\n            elif 'names' in node:\n                name = node['names'][0]\n            self.text += '[anchor=%s]' % name\n            self.text_have_anchor = True\n\n        elif cls is role_doc:\n            self.doc_index = len(self.text)\n\n        elif cls is role_video:\n            pass",
  "def dispatch_departure(self, node):\n        cls = node.__class__\n        if cls is nodes.document:\n            self.pop()\n\n        elif cls is nodes.section:\n            self.section -= 1\n\n        elif cls is nodes.title:\n            assert isinstance(self.current, RstTitle)\n            if not self.title:\n                self.title = self.text\n            self.set_text(self.current, 'title')\n            self.pop()\n\n        elif cls is nodes.Text:\n            pass\n\n        elif cls is nodes.paragraph:\n            self.do_strip_text = False\n            assert isinstance(self.current, RstParagraph)\n            self.set_text(self.current, 'paragraph')\n            self.pop()\n\n        elif cls is nodes.literal_block:\n            assert isinstance(self.current, RstLiteralBlock)\n            self.set_text(self.current.content, 'literal_block')\n            self.pop()\n\n        elif cls is nodes.emphasis:\n            self.text += '[/i]'\n\n        elif cls is nodes.strong:\n            self.text += '[/b]'\n\n        elif cls is nodes.literal:\n            self.text += '[/font]'\n\n        elif cls is nodes.block_quote:\n            self.pop()\n\n        elif cls is nodes.enumerated_list:\n            self.idx_list = None\n            self.pop()\n\n        elif cls is nodes.bullet_list:\n            self.pop()\n\n        elif cls is nodes.list_item:\n            self.pop()\n\n        elif cls is nodes.system_message:\n            self.pop()\n\n        elif cls is nodes.warning:\n            self.pop()\n\n        elif cls is nodes.note:\n            self.pop()\n\n        elif cls is nodes.definition_list:\n            self.pop()\n\n        elif cls is nodes.term:\n            assert isinstance(self.current, RstTerm)\n            self.set_text(self.current, 'term')\n            self.pop()\n\n        elif cls is nodes.definition:\n            self.pop()\n\n        elif cls is nodes.field_list:\n            self.pop()\n\n        elif cls is nodes.field_name:\n            assert isinstance(self.current, RstFieldName)\n            self.set_text(self.current, 'field_name')\n            self.pop()\n\n        elif cls is nodes.field_body:\n            self.pop()\n\n        elif cls is nodes.table:\n            self.pop()\n\n        elif cls is nodes.colspec:\n            pass\n\n        elif cls is nodes.entry:\n            self.pop()\n\n        elif cls is nodes.reference:\n            self.text += '[/color][/ref]'\n\n        elif cls is nodes.footnote:\n            self.pop()\n            self.set_text(self.current, 'link')\n\n        elif cls is nodes.footnote_reference:\n            # close opened footnote [x]\n            # self.text += '[/ref]'\n            # self.set_text(self.current, 'link')\n            self.text += '[/color][/ref]'\n            # self.text += '[/color][/ref]'\n            self.text += '&br;'\n\n        elif cls is role_doc:\n            docname = self.text[self.doc_index:]\n            rst_docname = docname\n            if rst_docname.endswith('.rst'):\n                docname = docname[:-4]\n            else:\n                rst_docname += '.rst'\n\n            # try to preload it\n            filename = self.root.resolve_path(rst_docname)\n            self.root.preload(filename)\n\n            # if exist, use the title of the first section found in the\n            # document\n            title = docname\n            if filename in self.root.toctrees:\n                toctree = self.root.toctrees[filename]\n                if len(toctree):\n                    title = toctree[0]['title']\n\n            # replace the text with a good reference\n            text = '[ref=%s]%s[/ref]' % (\n                rst_docname,\n                self.colorize(title, 'link'))\n            self.text = self.text[:self.doc_index] + text\n\n        elif cls is role_video:\n            width = node['width'] if 'width' in node.attlist() else 400\n            height = node['height'] if 'height' in node.attlist() else 300\n            uri = node['source']\n            if uri.startswith('/') and self.root.document_root:\n                uri = join(self.root.document_root, uri[1:])\n            video = RstVideoPlayer(\n                source=uri,\n                size_hint=(None, None),\n                size=(width, height))\n            anchor = AnchorLayout(size_hint_y=None, height=height + 20)\n            anchor.add_widget(video)\n            self.current.add_widget(anchor)",
  "def set_text(self, node, parent):\n        text = self.text\n        if parent == 'term' or parent == 'field_name':\n            text = '[b]%s[/b]' % text\n        # search anchors\n        node.text = self.colorize(text, parent)\n        node.bind(on_ref_press=self.root.on_ref_press)\n        if self.text_have_anchor:\n            self.root.add_anchors(node)\n        self.text = ''\n        self.text_have_anchor = False",
  "def colorize(self, text, name):\n        return '[color=%s]%s[/color]' % (\n            self.root.colors.get(name, self.root.colors['paragraph']),\n            text)",
  "def run(self):\n            set_classes(self.options)\n            node = role_video(source=self.arguments[0], **self.options)\n            return [node]",
  "def get_refs(condition, backref=False):\n            # backref=True is used in nodes.footnote\n            autonum = autosym = 0\n            _nodes = node.traverse(condition=condition, ascend=False)\n\n            for f in _nodes:\n                id = f['ids'][0]\n                auto = ''\n                if 'auto' in f:\n                    auto = f['auto']\n\n                # auto is either 1(int) or '*'\n                if auto == 1:\n                    autonum += 1\n                    key = 'backref' + str(autonum) if backref else str(autonum)\n                    self.root.refs_assoc[key] = id\n                elif auto == '*':\n                    sym = self.footlist[\n                        autosym % 10\n                    ] * (int(autosym / 10) + 1)\n                    key = 'backref' + sym if backref else sym\n                    self.root.refs_assoc[key] = id\n                    autosym += 1\n                else:\n                    if not backref:\n                        key = f['names'][0]\n                        if key:\n                            self.root.refs_assoc[key] = id\n                        continue\n\n                    key = 'backref' + f['refname'][0]\n\n                    if key in self.root.refs_assoc:\n                        self.root.refs_assoc[key].append(id)\n                    else:\n                        self.root.refs_assoc[key] = [id, ]",
  "def set_size(img, size):\n                img.size = [\n                    size[0] or img.width,\n                    size[1] or img.height\n                ]",
  "class Selector(ButtonBehavior, Image):\n    # Internal class for managing the selection Handles.\n\n    window = ObjectProperty()\n    target = ObjectProperty()\n    matrix = ObjectProperty()\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.always_release = True\n        self.matrix = self.target.get_window_matrix()\n\n        with self.canvas.before:\n            Callback(self.update_transform)\n            PushMatrix()\n            self.transform = Transform()\n\n        with self.canvas.after:\n            PopMatrix()\n\n    def update_transform(self, cb):\n        matrix = self.target.get_window_matrix()\n        if self.matrix != matrix:\n            self.matrix = matrix\n            self.transform.identity()\n            self.transform.transform(self.matrix)\n\n    def transform_touch(self, touch):\n        matrix = self.matrix.inverse()\n        touch.apply_transform_2d(\n            lambda x, y: matrix.transform_point(x, y, 0)[:2]\n        )\n\n    def on_touch_down(self, touch):\n        if self.parent is not EventLoop.window:\n            return\n\n        try:\n            touch.push()\n            self.transform_touch(touch)\n            self._touch_diff = self.top - touch.y\n            if self.collide_point(*touch.pos):\n                FocusBehavior.ignored_touch.append(touch)\n            return super().on_touch_down(touch)\n        finally:\n            touch.pop()",
  "class TextInputCutCopyPaste(Bubble):\n    # Internal class used for showing the little bubble popup when\n    # copy/cut/paste happen.\n\n    textinput = ObjectProperty(None)\n    ''' Holds a reference to the TextInput this Bubble belongs to.\n    '''\n\n    but_cut = ObjectProperty(None)\n    but_copy = ObjectProperty(None)\n    but_paste = ObjectProperty(None)\n    but_selectall = ObjectProperty(None)\n\n    matrix = ObjectProperty(None)\n\n    _check_parent_ev = None\n\n    def __init__(self, **kwargs):\n        self.mode = 'normal'\n        super().__init__(**kwargs)\n        self._check_parent_ev = Clock.schedule_interval(self._check_parent, .5)\n        self.matrix = self.textinput.get_window_matrix()\n\n        with self.canvas.before:\n            Callback(self.update_transform)\n            PushMatrix()\n            self.transform = Transform()\n\n        with self.canvas.after:\n            PopMatrix()\n\n    def update_transform(self, cb):\n        m = self.textinput.get_window_matrix()\n        if self.matrix != m:\n            self.matrix = m\n            self.transform.identity()\n            self.transform.transform(self.matrix)\n\n    def transform_touch(self, touch):\n        matrix = self.matrix.inverse()\n        touch.apply_transform_2d(\n            lambda x, y: matrix.transform_point(x, y, 0)[:2])\n\n    def on_touch_down(self, touch):\n        try:\n            touch.push()\n            self.transform_touch(touch)\n            if self.collide_point(*touch.pos):\n                FocusBehavior.ignored_touch.append(touch)\n            return super().on_touch_down(touch)\n        finally:\n            touch.pop()\n\n    def on_touch_up(self, touch):\n        try:\n            touch.push()\n            self.transform_touch(touch)\n            for child in self.content.children:\n                if ref(child) in touch.grab_list:\n                    touch.grab_current = child\n                    break\n            return super().on_touch_up(touch)\n        finally:\n            touch.pop()\n\n    def on_textinput(self, instance, value):\n        global Clipboard\n        if value and not Clipboard and not _is_desktop:\n            value._ensure_clipboard()\n\n    def _check_parent(self, dt):\n        # this is a prevention to get the Bubble staying on the screen, if the\n        # attached textinput is not on the screen anymore.\n        parent = self.textinput\n        while parent is not None:\n            if parent == parent.parent:\n                break\n            parent = parent.parent\n        if parent is None:\n            self._check_parent_ev.cancel()\n            if self.textinput:\n                self.textinput._hide_cut_copy_paste()\n\n    def on_parent(self, instance, value):\n        parent = self.textinput\n        mode = self.mode\n\n        if parent:\n            self.content.clear_widgets()\n            if mode == 'paste':\n                # show only paste on long touch\n                self.but_selectall.opacity = 1\n                widget_list = [self.but_selectall, ]\n                if not parent.readonly:\n                    widget_list.append(self.but_paste)\n            elif parent.readonly:\n                # show only copy for read only text input\n                widget_list = (self.but_copy, )\n            else:\n                # normal mode\n                widget_list = (self.but_cut, self.but_copy, self.but_paste)\n\n            for widget in widget_list:\n                self.content.add_widget(widget)\n\n    def do(self, action):\n        textinput = self.textinput\n\n        if action == 'cut':\n            textinput._cut(textinput.selection_text)\n        elif action == 'copy':\n            textinput.copy()\n        elif action == 'paste':\n            textinput.paste()\n        elif action == 'selectall':\n            textinput.select_all()\n            self.mode = ''\n            anim = Animation(opacity=0, d=.333)\n            anim.bind(on_complete=lambda *args:\n                      self.on_parent(self, self.parent))\n            anim.start(self.but_selectall)\n            return\n\n        self.hide()\n\n    def hide(self):\n        parent = self.parent\n        if not parent:\n            return\n\n        anim = Animation(opacity=0, d=.225)\n        anim.bind(on_complete=lambda *args: parent.remove_widget(self))\n        anim.start(self)",
  "class TextInput(FocusBehavior, Widget):\n    '''TextInput class. See module documentation for more information.\n\n    :Events:\n        `on_text_validate`\n            Fired only in multiline=False mode when the user hits 'enter'.\n            This will also unfocus the textinput.\n        `on_double_tap`\n            Fired when a double tap happens in the text input. The default\n            behavior selects the text around the cursor position. More info at\n            :meth:`on_double_tap`.\n        `on_triple_tap`\n            Fired when a triple tap happens in the text input. The default\n            behavior selects the line around the cursor position. More info at\n            :meth:`on_triple_tap`.\n        `on_quad_touch`\n            Fired when four fingers are touching the text input. The default\n            behavior selects the whole text. More info at\n            :meth:`on_quad_touch`.\n\n    .. warning::\n        When changing a :class:`TextInput` property that requires re-drawing,\n        e.g. modifying the :attr:`text`, the updates occur on the next\n        clock cycle and not instantly. This might cause any changes to the\n        :class:`TextInput` that occur between the modification and the next\n        cycle to be ignored, or to use previous values. For example, after\n        a update to the :attr:`text`, changing the cursor in the same clock\n        frame will move it using the previous text and will likely end up in an\n        incorrect position. The solution is to schedule any updates to occur\n        on the next clock cycle using\n        :meth:`~kivy.clock.ClockBase.schedule_once`.\n\n    .. Note::\n        Selection is cancelled when TextInput is focused. If you need to\n        show selection when TextInput is focused, you should delay\n        (use Clock.schedule) the call to the functions for selecting\n        text (select_all, select_text).\n\n    .. versionchanged:: 1.10.0\n        `background_disabled_active` has been removed.\n\n    .. versionchanged:: 1.9.0\n\n        :class:`TextInput` now inherits from\n        :class:`~kivy.uix.behaviors.FocusBehavior`.\n        :attr:`~kivy.uix.behaviors.FocusBehavior.keyboard_mode`,\n        :meth:`~kivy.uix.behaviors.FocusBehavior.show_keyboard`,\n        :meth:`~kivy.uix.behaviors.FocusBehavior.hide_keyboard`,\n        :meth:`~kivy.uix.behaviors.FocusBehavior.focus`,\n        and :attr:`~kivy.uix.behaviors.FocusBehavior.input_type`\n        have been removed since they are now inherited\n        from :class:`~kivy.uix.behaviors.FocusBehavior`.\n\n    .. versionchanged:: 1.7.0\n        `on_double_tap`, `on_triple_tap` and `on_quad_touch` events added.\n\n    .. versionchanged:: 2.1.0\n        :attr:`~kivy.uix.behaviors.FocusBehavior.keyboard_suggestions`\n        is now inherited from :class:`~kivy.uix.behaviors.FocusBehavior`.\n    '''\n\n    __events__ = ('on_text_validate', 'on_double_tap', 'on_triple_tap',\n                  'on_quad_touch')\n\n    _resolved_base_dir = None\n\n    def __init__(self, **kwargs):\n        self._update_graphics_ev = Clock.create_trigger(\n            self._update_graphics, -1)\n        self.is_focusable = kwargs.get('is_focusable', True)\n        self._cursor = [0, 0]\n        self._selection = False\n        self._selection_finished = True\n        self._selection_touch = None\n        self.selection_text = u''\n        self._selection_from = None\n        self._selection_to = None\n        self._selection_callback = None\n        self._handle_left = None\n        self._handle_right = None\n        self._handle_middle = None\n        self._bubble = None\n        self._lines_flags = []\n        self._lines_labels = []\n        self._lines_rects = []\n        self._hint_text_flags = []\n        self._hint_text_labels = []\n        self._hint_text_rects = []\n        self._label_cached = None\n        self._line_options = None\n        self._keyboard_mode = Config.get('kivy', 'keyboard_mode')\n        self._command_mode = False\n        self._command = ''\n        self.reset_undo()\n        self._touch_count = 0\n        self._ctrl_l = False\n        self._ctrl_r = False\n        self._alt_l = False\n        self._alt_r = False\n        self._refresh_text_from_property_ev = None\n        self._long_touch_ev = None\n        self._do_blink_cursor_ev = Clock.create_trigger(\n            self._do_blink_cursor, .5, interval=True)\n        self._refresh_line_options_ev = None\n        self._scroll_distance_x = 0\n        self._scroll_distance_y = 0\n        self._enable_scroll = True\n        self._have_scrolled = False\n\n        # [from; to) range of lines being partially or fully rendered\n        # in TextInput's viewport\n        self._visible_lines_range = 0, 0\n\n        self.interesting_keys = {\n            8: 'backspace',\n            13: 'enter',\n            127: 'del',\n            271: 'enter',\n            273: 'cursor_up',\n            274: 'cursor_down',\n            275: 'cursor_right',\n            276: 'cursor_left',\n            278: 'cursor_home',\n            279: 'cursor_end',\n            280: 'cursor_pgup',\n            281: 'cursor_pgdown',\n            303: 'shift_L',\n            304: 'shift_R',\n            305: 'ctrl_L',\n            306: 'ctrl_R',\n            308: 'alt_L',\n            307: 'alt_R'\n        }\n\n        super().__init__(**kwargs)\n\n        fbind = self.fbind\n        refresh_line_options = self._trigger_refresh_line_options\n        update_text_options = self._update_text_options\n        trigger_update_graphics = self._trigger_update_graphics\n\n        fbind('font_size', refresh_line_options)\n        fbind('font_name', refresh_line_options)\n        fbind('font_context', refresh_line_options)\n        fbind('font_family', refresh_line_options)\n        fbind('base_direction', refresh_line_options)\n        fbind('text_language', refresh_line_options)\n\n        def handle_readonly(instance, value):\n            if value and (not _is_desktop or not self.allow_copy):\n                self.is_focusable = False\n            if (not (value or self.disabled) or _is_desktop and\n                    self._keyboard_mode == 'system'):\n                self._editable = True\n            else:\n                self._editable = False\n\n        fbind('padding', update_text_options)\n        fbind('tab_width', update_text_options)\n        fbind('font_size', update_text_options)\n        fbind('font_name', update_text_options)\n        fbind('size', update_text_options)\n        fbind('password', update_text_options)\n        fbind('password_mask', update_text_options)\n\n        fbind('pos', trigger_update_graphics)\n        fbind('halign', trigger_update_graphics)\n        fbind('readonly', handle_readonly)\n        fbind('focus', self._on_textinput_focused)\n        handle_readonly(self, self.readonly)\n\n        handles = self._trigger_position_handles = Clock.create_trigger(\n            self._position_handles)\n        self._trigger_show_handles = Clock.create_trigger(\n            self._show_handles, .05)\n        self._trigger_cursor_reset = Clock.create_trigger(\n            self._reset_cursor_blink)\n        self._trigger_update_cutbuffer = Clock.create_trigger(\n            self._update_cutbuffer)\n        refresh_line_options()\n        self._trigger_refresh_text()\n\n        fbind('pos', handles)\n        fbind('size', handles)\n\n        # when the gl context is reloaded, trigger the text rendering again.\n        _textinput_list.append(ref(self, TextInput._reload_remove_observer))\n\n        if platform == 'linux':\n            self._ensure_clipboard()\n\n    def on_text_validate(self):\n        pass\n\n    def cursor_index(self, cursor=None):\n        '''Return the cursor index in the text/value.\n        '''\n        if not cursor:\n            cursor = self.cursor\n        try:\n            lines = self._lines\n            if not lines:\n                return 0\n\n            flags = self._lines_flags\n            index, cursor_row = cursor\n\n            for _, line, flag in zip(\n                range(min(cursor_row, len(lines))),\n                lines,\n                flags\n            ):\n                index += len(line)\n                if flag & FL_IS_LINEBREAK:\n                    index += 1\n\n            if flags[cursor_row] & FL_IS_LINEBREAK:\n                index += 1\n            return index\n\n        except IndexError:\n            return 0\n\n    def cursor_offset(self):\n        '''Get the cursor x offset on the current line.\n        '''\n        offset = 0\n        row = int(self.cursor_row)\n        col = int(self.cursor_col)\n        lines = self._lines\n        if col and row < len(lines):\n            offset = self._get_text_width(\n                lines[row][:col],\n                self.tab_width,\n                self._label_cached\n            )\n        return offset\n\n    def get_cursor_from_index(self, index):\n        '''Return the (col, row) of the cursor from text index.\n        '''\n        index = boundary(index, 0, len(self.text))\n        if index <= 0:\n            return 0, 0\n        flags = self._lines_flags\n        lines = self._lines\n        if not lines:\n            return 0, 0\n\n        i = 0\n        for row, line in enumerate(lines):\n            count = i + len(line)\n            if flags[row] & FL_IS_LINEBREAK:\n                count += 1\n                i += 1\n            if count >= index:\n                return index - i, row\n            i = count\n        return int(index), int(row)\n\n    def select_text(self, start, end):\n        ''' Select a portion of text displayed in this TextInput.\n\n        .. versionadded:: 1.4.0\n\n        :Parameters:\n            `start`\n                Index of textinput.text from where to start selection\n            `end`\n                Index of textinput.text till which the selection should be\n                displayed\n        '''\n        if end < start:\n            raise Exception('end must be superior to start')\n        text_length = len(self.text)\n        self._selection_from = boundary(start, 0, text_length)\n        self._selection_to = boundary(end, 0, text_length)\n        self._selection_finished = True\n        self._update_selection(True)\n        self._update_graphics_selection()\n\n    def select_all(self):\n        ''' Select all of the text displayed in this TextInput.\n\n        .. versionadded:: 1.4.0\n        '''\n        self.select_text(0, len(self.text))\n\n    re_indent = re.compile(r'^(\\s*|)')\n\n    def _auto_indent(self, substring):\n        index = self.cursor_index()\n        if index > 0:\n            _text = self.text\n            line_start = _text.rfind('\\n', 0, index)\n            if line_start > -1:\n                line = _text[line_start + 1:index]\n                indent = self.re_indent.match(line).group()\n                substring += indent\n        return substring\n\n    def insert_text(self, substring, from_undo=False):\n        '''Insert new text at the current cursor position. Override this\n        function in order to pre-process text for input validation.\n        '''\n        _lines = self._lines\n        _lines_flags = self._lines_flags\n\n        if self.readonly or not substring or not self._lines:\n            return\n\n        if isinstance(substring, bytes):\n            substring = substring.decode('utf8')\n\n        if self.replace_crlf:\n            substring = substring.replace(u'\\r\\n', u'\\n')\n\n        self._hide_handles(EventLoop.window)\n\n        if not from_undo and self.multiline and self.auto_indent \\\n                and substring == u'\\n':\n            substring = self._auto_indent(substring)\n\n        mode = self.input_filter\n        if mode not in (None, 'int', 'float'):\n            substring = mode(substring, from_undo)\n            if not substring:\n                return\n\n        col, row = self.cursor\n        cindex = self.cursor_index()\n        text = _lines[row]\n        len_str = len(substring)\n        new_text = text[:col] + substring + text[col:]\n        if mode is not None:\n            if mode == 'int':\n                if not re.match(self._insert_int_pat, new_text):\n                    return\n            elif mode == 'float':\n                if not re.match(self._insert_float_pat, new_text):\n                    return\n        self._set_line_text(row, new_text)\n\n        if len_str > 1 or substring == u'\\n' or\\\n            (substring == u' ' and _lines_flags[row] != FL_IS_LINEBREAK) or\\\n            (row + 1 < len(_lines) and\n             _lines_flags[row + 1] != FL_IS_LINEBREAK) or\\\n            (self._get_text_width(\n                new_text,\n                self.tab_width,\n                self._label_cached) > (self.width - self.padding[0] -\n                                       self.padding[2])):\n            # Avoid refreshing text on every keystroke.\n            # Allows for faster typing of text when the amount of text in\n            # TextInput gets large.\n\n            (\n                start, finish, lines, lines_flags, len_lines\n            ) = self._get_line_from_cursor(row, new_text)\n\n            # calling trigger here could lead to wrong cursor positioning\n            # and repeating of text when keys are added rapidly in a automated\n            # fashion. From Android Keyboard for example.\n            self._refresh_text_from_property(\n                'insert', start, finish, lines, lines_flags, len_lines\n            )\n\n        self.cursor = self.get_cursor_from_index(cindex + len_str)\n        # handle undo and redo\n        self._set_unredo_insert(cindex, cindex + len_str, substring, from_undo)\n\n    def _get_line_from_cursor(self, start, new_text, lines=None,\n                              lines_flags=None):\n        # get current paragraph from cursor position\n        if lines is None:\n            lines = self._lines\n        if lines_flags is None:\n            lines_flags = self._lines_flags\n        finish = start\n        _next = start + 1\n        if start > 0 and lines_flags[start] != FL_IS_LINEBREAK:\n            start -= 1\n            new_text = lines[start] + new_text\n        i = _next\n        for i in range(_next, len(lines_flags)):\n            if lines_flags[i] == FL_IS_LINEBREAK:\n                finish = i - 1\n                break\n        else:\n            finish = i\n\n        new_text = new_text + u''.join(lines[_next:finish + 1])\n        lines, lines_flags = self._split_smart(new_text)\n\n        len_lines = max(1, len(lines))\n        return start, finish, lines, lines_flags, len_lines\n\n    def _set_unredo_insert(self, ci, sci, substring, from_undo):\n        # handle undo and redo\n        if from_undo:\n            return\n        self._undo.append({\n            'undo_command': ('insert', ci, sci),\n            'redo_command': (ci, substring)\n        })\n        # reset redo when undo is appended to\n        self._redo = []\n\n    def reset_undo(self):\n        '''Reset undo and redo lists from memory.\n\n        .. versionadded:: 1.3.0\n\n        '''\n        self._redo = self._undo = []\n\n    def do_redo(self):\n        '''Do redo operation.\n\n        .. versionadded:: 1.3.0\n\n        This action re-does any command that has been un-done by\n        do_undo/ctrl+z. This function is automatically called when\n        `ctrl+r` keys are pressed.\n        '''\n        try:\n            x_item = self._redo.pop()\n            undo_type = x_item['undo_command'][0]\n            _get_cusror_from_index = self.get_cursor_from_index\n\n            if undo_type == 'insert':\n                cindex, substring = x_item['redo_command']\n                self.cursor = _get_cusror_from_index(cindex)\n                self.insert_text(substring, True)\n            elif undo_type == 'bkspc':\n                self.cursor = _get_cusror_from_index(x_item['redo_command'])\n                self.do_backspace(from_undo=True)\n            elif undo_type == 'shiftln':\n                direction, rows, cursor = x_item['redo_command'][1:]\n                self._shift_lines(direction, rows, cursor, True)\n            else:\n                # delsel\n                cindex, scindex = x_item['redo_command']\n                self._selection_from = cindex\n                self._selection_to = scindex\n                self._selection = True\n                self.delete_selection(True)\n                self.cursor = _get_cusror_from_index(cindex)\n            self._undo.append(x_item)\n        except IndexError:\n            # reached at top of undo list\n            pass\n\n    def do_undo(self):\n        '''Do undo operation.\n\n        .. versionadded:: 1.3.0\n\n        This action un-does any edits that have been made since the last\n        call to reset_undo().\n        This function is automatically called when `ctrl+z` keys are pressed.\n        '''\n        try:\n            x_item = self._undo.pop()\n            undo_type = x_item['undo_command'][0]\n            self.cursor = self.get_cursor_from_index(x_item['undo_command'][1])\n\n            if undo_type == 'insert':\n                cindex, scindex = x_item['undo_command'][1:]\n                self._selection_from = cindex\n                self._selection_to = scindex\n                self._selection = True\n                self.delete_selection(True)\n            elif undo_type == 'bkspc':\n                substring = x_item['undo_command'][2][0]\n                mode = x_item['undo_command'][3]\n                self.insert_text(substring, True)\n                if mode == 'del':\n                    self.cursor = self.get_cursor_from_index(\n                        self.cursor_index() - 1)\n            elif undo_type == 'shiftln':\n                direction, rows, cursor = x_item['undo_command'][1:]\n                self._shift_lines(direction, rows, cursor, True)\n            else:\n                # delsel\n                substring = x_item['undo_command'][2:][0]\n                self.insert_text(substring, True)\n            self._redo.append(x_item)\n        except IndexError:\n            # reached at top of undo list\n            pass\n\n    def do_backspace(self, from_undo=False, mode='bkspc'):\n        '''Do backspace operation from the current cursor position.\n        This action might do several things:\n\n            - removing the current selection if available.\n            - removing the previous char and move the cursor back.\n            - do nothing, if we are at the start.\n\n        '''\n        # IME system handles its own backspaces\n        if self.readonly or self._ime_composition:\n            return\n        col, row = self.cursor\n        _lines = self._lines\n        _lines_flags = self._lines_flags\n        text = _lines[row]\n        cursor_index = self.cursor_index()\n\n        if col == 0 and row == 0:\n            return\n        start = row\n        if col == 0:\n            if _lines_flags[row] == FL_IS_LINEBREAK:\n                substring = u'\\n'\n                new_text = _lines[row - 1] + text\n            else:\n                substring = _lines[row - 1][-1] if len(_lines[row - 1]) > 0 \\\n                    else u''\n                new_text = _lines[row - 1][:-1] + text\n            self._set_line_text(row - 1, new_text)\n            self._delete_line(row)\n            start = row - 1\n        else:\n            # ch = text[col-1]\n            substring = text[col - 1]\n            new_text = text[:col - 1] + text[col:]\n            self._set_line_text(row, new_text)\n\n        # refresh just the current line instead of the whole text\n        start, finish, lines, lineflags, len_lines = (\n            self._get_line_from_cursor(start, new_text)\n        )\n        # avoid trigger refresh, leads to issue with\n        # keys/text send rapidly through code.\n        self._refresh_text_from_property(\n            'insert' if col == 0 else 'del', start, finish,\n            lines, lineflags, len_lines\n        )\n\n        self.cursor = self.get_cursor_from_index(cursor_index - 1)\n        # handle undo and redo\n        self._set_unredo_bkspc(\n            cursor_index,\n            cursor_index - 1,\n            substring, from_undo, mode)\n\n    def _set_unredo_bkspc(self, ol_index, new_index, substring, from_undo,\n                          mode):\n        # handle undo and redo for backspace\n        if from_undo:\n            return\n        self._undo.append({\n            'undo_command': ('bkspc', new_index, substring, mode),\n            'redo_command': ol_index})\n        # reset redo when undo is appended to\n        self._redo = []\n\n    _re_whitespace = re.compile(r'\\s+')\n\n    def _move_cursor_word_left(self, index=None):\n        pos = index or self.cursor_index()\n        if pos == 0:\n            return self.cursor\n        lines = self._lines\n        col, row = self.get_cursor_from_index(pos)\n        if col == 0:\n            row -= 1\n            col = len(lines[row])\n\n        while True:\n            matches = list(self._re_whitespace.finditer(lines[row], 0, col))\n            if not matches:\n                if col == 0:\n                    if row == 0:\n                        return 0, 0\n                    row -= 1\n                    col = len(lines[row])\n                    continue\n                return 0, row\n\n            match = matches[-1]\n            mpos = match.end()\n            if mpos == col:\n                if len(matches) > 1:\n                    match = matches[-2]\n                    mpos = match.end()\n                else:\n                    if match.start() == 0:\n                        if row == 0:\n                            return 0, 0\n                        row -= 1\n                        col = len(lines[row])\n                        continue\n                    return 0, row\n            col = mpos\n            return col, row\n\n    def _move_cursor_word_right(self, index=None):\n        pos = index or self.cursor_index()\n        col, row = self.get_cursor_from_index(pos)\n        lines = self._lines\n        mrow = len(lines) - 1\n        if row == mrow and col == len(lines[row]):\n            return col, row\n        if col == len(lines[row]):\n            row += 1\n            col = 0\n\n        while True:\n            matches = list(self._re_whitespace.finditer(lines[row], col))\n            if not matches:\n                if col == len(lines[row]):\n                    if row == mrow:\n                        return col, row\n                    row += 1\n                    col = 0\n                    continue\n                return len(lines[row]), row\n\n            match = matches[0]\n            mpos = match.start()\n            if mpos == col:\n                if len(matches) > 1:\n                    match = matches[1]\n                    mpos = match.start()\n                else:\n                    if match.end() == len(lines[row]):\n                        if row == mrow:\n                            return col, row\n                        row += 1\n                        col = 0\n                        continue\n                    return len(lines[row]), row\n            col = mpos\n            return col, row\n\n    def _expand_range(self, ifrom, ito=None):\n        if ito is None:\n            ito = ifrom\n        rfrom = self.get_cursor_from_index(ifrom)[1]\n        rtcol, rto = self.get_cursor_from_index(ito)\n        rfrom, rto = self._expand_rows(rfrom, rto + 1 if rtcol else rto)\n\n        return (self.cursor_index((0, rfrom)),\n                self.cursor_index((0, rto)))\n\n    def _expand_rows(self, rfrom, rto=None):\n        if rto is None or rto == rfrom:\n            rto = rfrom + 1\n        lines = self._lines\n        flags = list(reversed(self._lines_flags))\n        while rfrom > 0 and not (flags[rfrom - 1] & FL_IS_NEWLINE):\n            rfrom -= 1\n        rmax = len(lines) - 1\n        while 0 < rto < rmax and not (flags[rto - 1] & FL_IS_NEWLINE):\n            rto += 1\n        return max(0, rfrom), min(rmax, rto)\n\n    def _shift_lines(\n        self, direction, rows=None, old_cursor=None, from_undo=False\n    ):\n        if self._selection_callback:\n            if from_undo:\n                self._selection_callback.cancel()\n            else:\n                return\n\n        lines = self._lines\n        flags = list(reversed(self._lines_flags))\n        labels = self._lines_labels\n        rects = self._lines_rects\n        orig_cursor = self.cursor\n        sel = None\n        if old_cursor is not None:\n            self.cursor = old_cursor\n\n        if not rows:\n            sindex = self.selection_from\n            eindex = self.selection_to\n            if (sindex or eindex) and sindex != eindex:\n                sindex, eindex = tuple(sorted((sindex, eindex)))\n                sindex, eindex = self._expand_range(sindex, eindex)\n            else:\n                sindex, eindex = self._expand_range(self.cursor_index())\n            srow = self.get_cursor_from_index(sindex)[1]\n            erow = self.get_cursor_from_index(eindex)[1]\n            sel = sindex, eindex\n\n            if direction < 0 and srow > 0:\n                psrow, perow = self._expand_rows(srow - 1)\n                rows = ((srow, erow), (psrow, perow))\n            elif direction > 0 and erow < len(lines) - 1:\n                psrow, perow = self._expand_rows(erow)\n                rows = ((srow, erow), (psrow, perow))\n\n        else:\n            (srow, erow), (psrow, perow) = rows\n            if direction < 0:\n                m1srow, m1erow = psrow, perow\n                m2srow, m2erow = srow, erow\n                cdiff = psrow - perow\n                xdiff = srow - erow\n            else:\n                m1srow, m1erow = srow, erow\n                m2srow, m2erow = psrow, perow\n                cdiff = perow - psrow\n                xdiff = erow - srow\n\n            self._lines_flags = list(reversed(chain(\n                flags[:m1srow],\n                flags[m2srow:m2erow],\n                flags[m1srow:m1erow],\n                flags[m2erow:],\n            )))\n            self._lines[:] = (\n                lines[:m1srow]\n                + lines[m2srow:m2erow]\n                + lines[m1srow:m1erow]\n                + lines[m2erow:]\n            )\n            self._lines_labels = (\n                labels[:m1srow]\n                + labels[m2srow:m2erow]\n                + labels[m1srow:m1erow]\n                + labels[m2erow:]\n            )\n            self._lines_rects = (\n                rects[:m1srow]\n                + rects[m2srow:m2erow]\n                + rects[m1srow:m1erow]\n                + rects[m2erow:]\n            )\n            self._trigger_update_graphics()\n            csrow = srow + cdiff\n            cerow = erow + cdiff\n            sel = (\n                self.cursor_index((0, csrow)),\n                self.cursor_index((0, cerow))\n            )\n            self.cursor = self.cursor_col, self.cursor_row + cdiff\n\n            if not from_undo:\n                undo_rows = ((srow + cdiff, erow + cdiff),\n                             (psrow - xdiff, perow - xdiff))\n                self._undo.append({\n                    'undo_command': ('shiftln', direction * -1, undo_rows,\n                                     self.cursor),\n                    'redo_command': ('shiftln', direction, rows, orig_cursor),\n                })\n                self._redo = []\n\n        if sel:\n            def cb(dt):\n                self.select_text(*sel)\n                self._selection_callback = None\n            self._selection_callback = Clock.schedule_once(cb)\n\n    @property\n    def pgmove_speed(self):\n        \"\"\"how much vertical distance hitting pg_up or pg_down will move\n        \"\"\"\n        return int(\n            self.height\n            / (self.line_height + self.line_spacing) - 1\n        )\n\n    def _move_cursor_up(self, col, row, control=False, alt=False):\n        if self.multiline and control:\n            self.scroll_y = max(0, self.scroll_y - self.line_height)\n        elif not self.readonly and self.multiline and alt:\n            self._shift_lines(-1)\n            return\n        else:\n            row = max(row - 1, 0)\n            col = min(len(self._lines[row]), col)\n\n        return col, row\n\n    def _move_cursor_down(self, col, row, control, alt):\n        if self.multiline and control:\n            maxy = self.minimum_height - self.height\n            self.scroll_y = max(\n                0,\n                min(maxy, self.scroll_y + self.line_height)\n            )\n        elif not self.readonly and self.multiline and alt:\n            self._shift_lines(1)\n            return\n        else:\n            row = min(row + 1, len(self._lines) - 1)\n            col = min(len(self._lines[row]), col)\n\n        return col, row\n\n    def do_cursor_movement(self, action, control=False, alt=False):\n        '''Move the cursor relative to its current position.\n        Action can be one of :\n\n            - cursor_left: move the cursor to the left\n            - cursor_right: move the cursor to the right\n            - cursor_up: move the cursor on the previous line\n            - cursor_down: move the cursor on the next line\n            - cursor_home: move the cursor at the start of the current line\n            - cursor_end: move the cursor at the end of current line\n            - cursor_pgup: move one \"page\" before\n            - cursor_pgdown: move one \"page\" after\n\n        In addition, the behavior of certain actions can be modified:\n\n            - control + cursor_left: move the cursor one word to the left\n            - control + cursor_right: move the cursor one word to the right\n            - control + cursor_up: scroll up one line\n            - control + cursor_down: scroll down one line\n            - control + cursor_home: go to beginning of text\n            - control + cursor_end: go to end of text\n            - alt + cursor_up: shift line(s) up\n            - alt + cursor_down: shift line(s) down\n\n        .. versionchanged:: 1.9.1\n\n        '''\n        if not self._lines:\n            return\n\n        col, row = self.cursor\n        if action == 'cursor_up':\n            result = self._move_cursor_up(col, row, control, alt)\n            if result:\n                col, row = result\n            else:\n                return\n\n        elif action == 'cursor_down':\n            result = self._move_cursor_down(col, row, control, alt)\n            if result:\n                col, row = result\n            else:\n                return\n\n        elif action == 'cursor_home':\n            col = 0\n            if control:\n                row = 0\n\n        elif action == 'cursor_end':\n            if control:\n                row = len(self._lines) - 1\n            col = len(self._lines[row])\n\n        elif action == 'cursor_pgup':\n            row = max(0, row - self.pgmove_speed)\n            col = min(len(self._lines[row]), col)\n\n        elif action == 'cursor_pgdown':\n            row = min(row + self.pgmove_speed, len(self._lines) - 1)\n            col = min(len(self._lines[row]), col)\n\n        elif (\n            self._selection and self._selection_finished\n            and self._selection_from < self._selection_to\n            and action == 'cursor_left'\n        ):\n            current_selection_to = self._selection_to\n            while self._selection_from != current_selection_to:\n                current_selection_to -= 1\n                if col:\n                    col -= 1\n                else:\n                    row -= 1\n                    col = len(self._lines[row])\n\n        elif (\n            self._selection and self._selection_finished\n            and self._selection_from > self._selection_to\n            and action == 'cursor_right'\n        ):\n            current_selection_to = self._selection_to\n            while self._selection_from != current_selection_to:\n                current_selection_to += 1\n                if len(self._lines[row]) > col:\n                    col += 1\n                else:\n                    row += 1\n                    col = 0\n\n        elif action == 'cursor_left':\n            if not self.password and control:\n                col, row = self._move_cursor_word_left()\n            else:\n                if col == 0:\n                    if row:\n                        row -= 1\n                        col = len(self._lines[row])\n                else:\n                    col, row = col - 1, row\n\n        elif action == 'cursor_right':\n            if not self.password and control:\n                col, row = self._move_cursor_word_right()\n            else:\n                if col == len(self._lines[row]):\n                    if row < len(self._lines) - 1:\n                        col = 0\n                        row += 1\n                else:\n                    col, row = col + 1, row\n\n        dont_move_cursor = control and action in ['cursor_up', 'cursor_down']\n        if dont_move_cursor:\n            self._trigger_update_graphics()\n        else:\n            self.cursor = col, row\n\n    def get_cursor_from_xy(self, x, y):\n        '''Return the (col, row) of the cursor from an (x, y) position.\n        '''\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n\n        lines = self._lines\n        dy = self.line_height + self.line_spacing\n        cursor_x = x - self.x\n        scroll_y = self.scroll_y\n        scroll_x = self.scroll_x\n        scroll_y = scroll_y / dy if scroll_y > 0 else 0\n\n        cursor_y = (self.top - padding_top + scroll_y * dy) - y\n        cursor_y = int(boundary(\n            round(cursor_y / dy - 0.5),\n            0,\n            len(lines) - 1\n        ))\n\n        get_text_width = self._get_text_width\n        tab_width = self.tab_width\n        label_cached = self._label_cached\n\n        # Offset for horizontal text alignment\n        xoff = 0\n        halign = self.halign\n        base_dir = self.base_direction or self._resolved_base_dir\n        auto_halign_r = halign == 'auto' and base_dir and 'rtl' in base_dir\n\n        if halign == 'center':\n            viewport_width = self.width - padding_left - padding_right\n            xoff = max(\n                0, int((viewport_width - self._get_row_width(cursor_y)) / 2)\n            )\n\n        elif halign == 'right' or auto_halign_r:\n            viewport_width = self.width - padding_left - padding_right\n            xoff = max(\n                0, int(viewport_width - self._get_row_width(cursor_y))\n            )\n\n        for i in range(0, len(lines[cursor_y])):\n            line_y = lines[cursor_y]\n\n            if cursor_x + scroll_x < (\n                xoff\n                + get_text_width(line_y[:i], tab_width, label_cached)\n                + get_text_width(line_y[i], tab_width, label_cached) * 0.6\n                + padding_left\n            ):\n                cursor_x = i\n                break\n        else:\n            cursor_x = len(lines[cursor_y])\n\n        return cursor_x, cursor_y\n\n    #\n    # Selection control\n    #\n    def cancel_selection(self):\n        '''Cancel current selection (if any).\n        '''\n        self._selection_from = self._selection_to = self.cursor_index()\n        self._selection = False\n        self._selection_finished = True\n        self._selection_touch = None\n        self.selection_text = u''\n        self._trigger_update_graphics()\n\n    def delete_selection(self, from_undo=False):\n        '''Delete the current text selection (if any).\n        '''\n        if self.readonly:\n            return\n        self._hide_handles(EventLoop.window)\n        scroll_x = self.scroll_x\n        scroll_y = self.scroll_y\n        cc, cr = self.cursor\n        if not self._selection:\n            return\n        text = self.text\n        a, b = sorted((self._selection_from, self._selection_to))\n\n        start = self.get_cursor_from_index(a)\n        finish = self.get_cursor_from_index(b)\n        cur_line = self._lines[start[1]][:start[0]] +\\\n            self._lines[finish[1]][finish[0]:]\n\n        self._set_line_text(start[1], cur_line)\n        start_del, finish_del, lines, lines_flags, len_lines = \\\n            self._get_line_from_cursor(start[1], cur_line,\n                                       lines=(self._lines[:(start[1] + 1)] +\n                                              self._lines[(finish[1] + 1):]),\n                                       lines_flags=(\n                                           self._lines_flags[:(start[1] + 1)] +\n                                           self._lines_flags[(finish[1] + 1):])\n                                       )\n        self._refresh_text_from_property('del', start_del,\n                                         finish_del + (finish[1] - start[1]),\n                                         lines, lines_flags, len_lines)\n\n        self.scroll_x = scroll_x\n        self.scroll_y = scroll_y\n        # handle undo and redo for delete selection\n        if text[a:b]:\n            self._set_unredo_delsel(a, b, text[a:b], from_undo)\n        self.cancel_selection()\n        self.cursor = self.get_cursor_from_index(a)\n\n    def _set_unredo_delsel(self, a, b, substring, from_undo):\n        # handle undo and redo for backspace\n        if from_undo:\n            return\n\n        self._undo.append({\n            'undo_command': ('delsel', a, substring),\n            'redo_command': (a, b)})\n        # reset redo when undo is appended to\n        self._redo = []\n\n    def _update_selection(self, finished=False):\n        '''Update selection text and order of from/to if finished is True.\n        Can be called multiple times until finished is True.\n        '''\n        a, b = int(self._selection_from), int(self._selection_to)\n        if a > b:\n            a, b = b, a\n        self._selection_finished = finished\n        _selection_text = self.text[a:b]\n        self.selection_text = (\"\" if not self.allow_copy else\n                               ((self.password_mask * (b - a)) if\n                                self.password else _selection_text))\n        if not finished:\n            self._selection = True\n        else:\n            self._selection = bool(len(_selection_text))\n            self._selection_touch = None\n        if a == 0:\n            # update graphics only on new line\n            # allows smoother scrolling, noticeably\n            # faster when dealing with large text.\n            self._update_graphics_selection()\n            # self._trigger_update_graphics()\n\n    #\n    # Touch control\n    #\n    def long_touch(self, dt):\n        self._long_touch_ev = None\n        if self._selection_to == self._selection_from:\n            pos = self.to_local(*self._touch_down.pos, relative=False)\n            self._show_cut_copy_paste(\n                pos, EventLoop.window, mode='paste')\n\n    def cancel_long_touch_event(self):\n        # schedule long touch for paste\n        if self._long_touch_ev is not None:\n            self._long_touch_ev.cancel()\n            self._long_touch_ev = None\n\n    def _select_word(self, delimiters=u' .,:;!?\\'\"<>()[]{}'):\n        cindex = self.cursor_index()\n        col = self.cursor_col\n        line = self._lines[self.cursor_row]\n        start = max(0, len(line[:col]) -\n                    max(line[:col].rfind(s) for s in delimiters) - 1)\n        end = min((line[col:].find(s) if line[col:].find(s) > -1\n                   else (len(line) - col)) for s in delimiters)\n        Clock.schedule_once(lambda dt: self.select_text(cindex - start,\n                                                        cindex + end))\n\n    def on_double_tap(self):\n        '''This event is dispatched when a double tap happens\n        inside TextInput. The default behavior is to select the\n        word around the current cursor position. Override this to provide\n        different behavior. Alternatively, you can bind to this\n        event to provide additional functionality.\n        '''\n        self._select_word()\n\n    def on_triple_tap(self):\n        '''This event is dispatched when a triple tap happens\n        inside TextInput. The default behavior is to select the\n        line around current cursor position. Override this to provide\n        different behavior. Alternatively, you can bind to this\n        event to provide additional functionality.\n        '''\n        ci = self.cursor_index()\n        sindex, eindex = self._expand_range(ci)\n        Clock.schedule_once(lambda dt: self.select_text(sindex, eindex))\n\n    def on_quad_touch(self):\n        '''This event is dispatched when four fingers are touching\n        inside TextInput. The default behavior is to select all text.\n        Override this to provide different behavior. Alternatively,\n        you can bind to this event to provide additional functionality.\n        '''\n        Clock.schedule_once(lambda dt: self.select_all())\n\n    def on_touch_down(self, touch):\n        if self.disabled:\n            return\n\n        touch_pos = touch.pos\n        if not self.collide_point(*touch_pos):\n            return False\n        if super().on_touch_down(touch):\n            return True\n\n        if self.focus:\n            self._trigger_cursor_reset()\n\n        # Check for scroll wheel\n        if 'button' in touch.profile and touch.button.startswith('scroll'):\n            # TODO: implement 'scrollleft' and 'scrollright'\n            scroll_type = touch.button[6:]\n            if scroll_type == 'down':\n                if self.multiline:\n                    if self.scroll_y > 0:\n                        self.scroll_y = max(0,\n                                            self.scroll_y - self.line_height *\n                                            self.lines_to_scroll)\n                        self._trigger_update_graphics()\n                else:\n                    if self.scroll_x > 0:\n                        self.scroll_x = max(0, self.scroll_x -\n                                            self.line_height)\n                        self._trigger_update_graphics()\n            if scroll_type == 'up':\n                if self.multiline:\n                    max_scroll_y = max(0, self.minimum_height - self.height)\n                    if self.scroll_y < max_scroll_y:\n                        self.scroll_y = min(max_scroll_y,\n                                            self.scroll_y + self.line_height *\n                                            self.lines_to_scroll)\n                        self._trigger_update_graphics()\n                else:\n                    minimum_width = (self._get_row_width(0) + self.padding[0] +\n                                     self.padding[2])\n                    max_scroll_x = max(0, minimum_width - self.width)\n                    if self.scroll_x < max_scroll_x:\n                        self.scroll_x = min(max_scroll_x, self.scroll_x +\n                                            self.line_height)\n                        self._trigger_update_graphics()\n            return True\n\n        touch.grab(self)\n        self._touch_count += 1\n        if touch.is_double_tap:\n            self.dispatch('on_double_tap')\n        if touch.is_triple_tap:\n            self.dispatch('on_triple_tap')\n        if self._touch_count == 4:\n            self.dispatch('on_quad_touch')\n\n        # stores the touch for later use\n        self._touch_down = touch\n\n        # Is a new touch_down, so previous scroll states needs to be reset\n        self._enable_scroll = True\n        self._have_scrolled = False\n        self._scroll_distance_x = 0\n        self._scroll_distance_y = 0\n\n        self._hide_cut_copy_paste(EventLoop.window)\n        # schedule long touch for paste\n        self._long_touch_ev = Clock.schedule_once(self.long_touch, .5)\n\n        self.cursor = self.get_cursor_from_xy(*touch_pos)\n        if not self.scroll_from_swipe:\n            self._cancel_update_selection(self._touch_down)\n\n        if CutBuffer and 'button' in touch.profile and \\\n                touch.button == 'middle':\n            self.insert_text(CutBuffer.get_cutbuffer())\n            return True\n\n        return True\n\n    # cancel/update existing selection after a single tap\n    def _cancel_update_selection(self, touch):\n        if not self._selection_touch:\n            self.cancel_selection()\n            self._selection_touch = touch\n            self._selection_from = self._selection_to = self.cursor_index()\n            self._update_selection()\n\n    def on_touch_move(self, touch):\n        if touch.grab_current is not self:\n            return\n        if not self.focus:\n            touch.ungrab(self)\n            if self._selection_touch is touch:\n                self._selection_touch = None\n            return False\n\n        if self.scroll_from_swipe:\n            self.scroll_text_from_swipe(touch)\n\n        if not self._have_scrolled and self._selection_touch is touch:\n            self.cursor = self.get_cursor_from_xy(touch.x, touch.y)\n            self._selection_to = self.cursor_index()\n            self._update_selection()\n            return True\n\n    def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n        self._touch_count -= 1\n\n        self.cancel_long_touch_event()\n\n        if not self.focus:\n            return False\n\n        # types of touch that will have higher priority in being recognized,\n        # compared to single tap\n        prioritized_touch_types = (\n            touch.is_double_tap\n            or touch.is_triple_tap\n            or self._touch_count == 4\n        )\n\n        if not self._have_scrolled and not prioritized_touch_types:\n            # Is a single tap and did not scrolled.\n            # Selection needs to be canceled.\n            self._cancel_update_selection(self._touch_down)\n\n        # show Bubble\n        win = EventLoop.window\n        if self._selection_to != self._selection_from:\n            self._show_cut_copy_paste(touch.pos, win)\n\n        if self._selection_touch is touch:\n            self._selection_to = self.cursor_index()\n            self._update_selection(True)\n            if self.use_handles and self._selection_to == self._selection_from:\n                self._hide_handles()\n                handle_middle = self._handle_middle\n                if handle_middle is None:\n                    self._handle_middle = handle_middle = Selector(\n                        source=self.handle_image_middle,\n                        window=win,\n                        target=self,\n                        size_hint=(None, None),\n                        size=('45dp', '45dp'))\n                    handle_middle.bind(on_press=self._handle_pressed,\n                                       on_touch_move=self._handle_move,\n                                       on_release=self._handle_released)\n                if not self._handle_middle.parent and self.text:\n                    EventLoop.window.add_widget(handle_middle, canvas='after')\n                self._position_handles(mode='middle')\n            return True\n\n    def scroll_text_from_swipe(self, touch):\n        _scroll_timeout = (touch.time_update - touch.time_start) * 1000\n        self._scroll_distance_x += abs(touch.dx)\n        self._scroll_distance_y += abs(touch.dy)\n        if not self._have_scrolled:\n            # To be considered a scroll, touch should travel more than\n            # scroll_distance in less than the scroll_timeout since touch_down\n            if not (\n                _scroll_timeout <= self.scroll_timeout\n                and (\n                    (self._scroll_distance_x >= self.scroll_distance)\n                    or (self._scroll_distance_y >= self.scroll_distance)\n                )\n            ):\n                # Distance isn't enough (yet) to consider it as a scroll\n                if _scroll_timeout <= self.scroll_timeout:\n                    # Timeout is not reached, scroll is still enabled.\n                    return False\n                else:\n                    self._enable_scroll = False\n                    self._cancel_update_selection(self._touch_down)\n                    return False\n            # We have a scroll!\n            self._have_scrolled = True\n\n        self.cancel_long_touch_event()\n\n        if self.multiline:\n            max_scroll_y = max(0, self.minimum_height - self.height)\n            self.scroll_y = min(\n                max(0, self.scroll_y + touch.dy),\n                max_scroll_y\n            )\n        else:\n            minimum_width = (\n                self._get_row_width(0)\n                + self.padding[0] + self.padding[2]\n            )\n            max_scroll_x = max(0, minimum_width - self.width)\n            self.scroll_x = min(\n                max(0, self.scroll_x - touch.dx),\n                max_scroll_x\n            )\n        self._trigger_update_graphics()\n        self._position_handles()\n        return True\n\n    def _handle_pressed(self, instance):\n        self._hide_cut_copy_paste()\n        from_, to_ = self._selection_from, self.selection_to\n        if from_ > to_:\n            self._selection_from, self._selection_to = to_, from_\n\n    def _handle_released(self, instance):\n        if self._selection_from == self.selection_to:\n            return\n\n        self._update_selection()\n        self._show_cut_copy_paste(\n            (\n                self.x + instance.right\n                if instance is self._handle_left\n                else self.x + instance.x,\n                self.y + instance.top + self.line_height\n            ),\n            EventLoop.window\n        )\n\n    def _handle_move(self, instance, touch):\n        if touch.grab_current != instance:\n            return\n        get_cursor = self.get_cursor_from_xy\n        handle_right = self._handle_right\n        handle_left = self._handle_left\n        handle_middle = self._handle_middle\n\n        try:\n            touch.push()\n            touch.apply_transform_2d(self.to_widget)\n            x, y = touch.pos\n        finally:\n            touch.pop()\n\n        cursor = get_cursor(\n            x,\n            y + instance._touch_diff + (self.line_height / 2)\n        )\n        self.cursor = cursor\n\n        if instance != touch.grab_current:\n            return\n\n        if instance == handle_middle:\n            self._position_handles(mode='middle')\n            return\n\n        cindex = self.cursor_index()\n\n        if instance == handle_left:\n            self._selection_from = cindex\n        elif instance == handle_right:\n            self._selection_to = cindex\n        self._update_selection()\n        self._trigger_update_graphics()\n        self._trigger_position_handles()\n\n    def _position_handles(self, *args, **kwargs):\n        if not self.text:\n            return\n        mode = kwargs.get('mode', 'both')\n\n        lh = self.line_height\n\n        handle_middle = self._handle_middle\n        if handle_middle:\n            hp_mid = self.cursor_pos\n            pos = self.to_local(*hp_mid, relative=True)\n            handle_middle.x = pos[0] - handle_middle.width / 2\n            handle_middle.top = max(self.padding[3],\n                                    min(self.height - self.padding[1],\n                                        pos[1] - lh))\n        if mode[0] == 'm':\n            return\n\n        group = self.canvas.get_group('selection')\n        if not group:\n            return\n\n        EventLoop.window.remove_widget(self._handle_middle)\n\n        handle_left = self._handle_left\n        if not handle_left:\n            return\n        hp_left = group[2].pos\n        handle_left.pos = self.to_local(*hp_left, relative=True)\n        handle_left.x -= handle_left.width\n        handle_left.y -= handle_left.height\n\n        handle_right = self._handle_right\n        last_rect = group[-1]\n        hp_right = last_rect.pos[0], last_rect.pos[1]\n        x, y = self.to_local(*hp_right, relative=True)\n        handle_right.x = x + last_rect.size[0]\n        handle_right.y = y - handle_right.height\n\n    def _hide_handles(self, win=None):\n        win = win or EventLoop.window\n        if win is None:\n            return\n        win.remove_widget(self._handle_right)\n        win.remove_widget(self._handle_left)\n        win.remove_widget(self._handle_middle)\n\n    def _show_handles(self, dt):\n        if not self.use_handles or not self.text:\n            return\n\n        win = EventLoop.window\n\n        handle_right = self._handle_right\n        handle_left = self._handle_left\n        if self._handle_left is None:\n            self._handle_left = handle_left = Selector(\n                source=self.handle_image_left,\n                target=self,\n                window=win,\n                size_hint=(None, None),\n                size=('45dp', '45dp'))\n            handle_left.bind(on_press=self._handle_pressed,\n                             on_touch_move=self._handle_move,\n                             on_release=self._handle_released)\n            self._handle_right = handle_right = Selector(\n                source=self.handle_image_right,\n                target=self,\n                window=win,\n                size_hint=(None, None),\n                size=('45dp', '45dp'))\n            handle_right.bind(on_press=self._handle_pressed,\n                              on_touch_move=self._handle_move,\n                              on_release=self._handle_released)\n        else:\n            if self._handle_left.parent:\n                self._position_handles()\n                return\n            if not self.parent:\n                return\n\n        self._trigger_position_handles()\n        if self.selection_from != self.selection_to:\n            self._handle_left.opacity = self._handle_right.opacity = 0\n            win.add_widget(self._handle_left, canvas='after')\n            win.add_widget(self._handle_right, canvas='after')\n            anim = Animation(opacity=1, d=.4)\n            anim.start(self._handle_right)\n            anim.start(self._handle_left)\n\n    def _show_cut_copy_paste(\n        self, pos, win, parent_changed=False, mode='', pos_in_window=False, *l\n    ):\n        \"\"\"Show a bubble with cut copy and paste buttons\"\"\"\n        if not self.use_bubble:\n            return\n\n        bubble = self._bubble\n        if bubble is None:\n            self._bubble = bubble = TextInputCutCopyPaste(textinput=self)\n            self.fbind('parent', self._show_cut_copy_paste, pos, win, True)\n\n            def hide_(*args):\n                return self._hide_cut_copy_paste(win)\n\n            self.bind(\n                focus=hide_,\n                cursor_pos=hide_,\n            )\n        else:\n            win.remove_widget(bubble)\n            if not self.parent:\n                return\n        if parent_changed:\n            return\n\n        # Search the position from the touch to the window\n        lh, ls = self.line_height, self.line_spacing\n\n        x, y = pos\n        t_pos = (x, y) if pos_in_window else self.to_window(x, y)\n        bubble_size = bubble.size\n        bubble_hw = bubble_size[0] / 2.\n        win_size = win.size\n        bubble_pos = (t_pos[0], t_pos[1] + inch(.25))\n\n        if (bubble_pos[0] - bubble_hw) < 0:\n            # bubble beyond left of window\n            if bubble_pos[1] > (win_size[1] - bubble_size[1]):\n                # bubble above window height\n                bubble_pos = (bubble_hw, (t_pos[1]) - (lh + ls + inch(.25)))\n                bubble.arrow_pos = 'top_left'\n            else:\n                bubble_pos = (bubble_hw, bubble_pos[1])\n                bubble.arrow_pos = 'bottom_left'\n        elif (bubble_pos[0] + bubble_hw) > win_size[0]:\n            # bubble beyond right of window\n            if bubble_pos[1] > (win_size[1] - bubble_size[1]):\n                # bubble above window height\n                bubble_pos = (\n                    win_size[0] - bubble_hw,\n                    (t_pos[1]) - (lh + ls + inch(.25))\n                )\n                bubble.arrow_pos = 'top_right'\n            else:\n                bubble_pos = (win_size[0] - bubble_hw, bubble_pos[1])\n                bubble.arrow_pos = 'bottom_right'\n        else:\n            if bubble_pos[1] > (win_size[1] - bubble_size[1]):\n                # bubble above window height\n                bubble_pos = (\n                    bubble_pos[0],\n                    (t_pos[1]) - (lh + ls + inch(.25))\n                )\n                bubble.arrow_pos = 'top_mid'\n            else:\n                bubble.arrow_pos = 'bottom_mid'\n\n        bubble_pos = self.to_widget(*bubble_pos, relative=True)\n        bubble.center_x = bubble_pos[0]\n        if bubble.arrow_pos[0] == 't':\n            bubble.top = bubble_pos[1]\n        else:\n            bubble.y = bubble_pos[1]\n        bubble.mode = mode\n        Animation.cancel_all(bubble)\n        bubble.opacity = 0\n        win.add_widget(bubble, canvas='after')\n        Animation(opacity=1, d=.225).start(bubble)\n\n    def _hide_cut_copy_paste(self, win=None):\n        bubble = self._bubble\n        if not bubble:\n            return\n\n        bubble.hide()\n\n    #\n    # Private\n    #\n\n    @staticmethod\n    def _reload_remove_observer(wr):\n        \"\"\"called when the textinput is deleted\"\"\"\n        if wr in _textinput_list:\n            _textinput_list.remove(wr)\n\n    def _on_textinput_focused(self, instance, value, *largs):\n        win = EventLoop.window\n        self.cancel_selection()\n        self._hide_cut_copy_paste(win)\n\n        if value:\n            if (\n                not (self.readonly or self.disabled)\n                or _is_desktop\n                and self._keyboard_mode == 'system'\n            ):\n                self._trigger_cursor_reset()\n                self._editable = True\n            else:\n                self._editable = False\n        else:\n            self._do_blink_cursor_ev.cancel()\n            self._hide_handles(win)\n\n    def _ensure_clipboard(self):\n        global Clipboard, CutBuffer\n        if not Clipboard:\n            from kivy.core.clipboard import Clipboard, CutBuffer\n\n    def cut(self):\n        ''' Copy current selection to clipboard then delete it from TextInput.\n\n        .. versionadded:: 1.8.0\n\n        '''\n        self._cut(self.selection_text)\n\n    def _cut(self, data):\n        self._ensure_clipboard()\n        Clipboard.copy(data)\n        self.delete_selection()\n\n    def copy(self, data=''):\n        ''' Copy the value provided in argument `data` into current clipboard.\n        If data is not of type string it will be converted to string.\n        If no data is provided then current selection if present is copied.\n\n        .. versionadded:: 1.8.0\n\n        '''\n        self._ensure_clipboard()\n        if data:\n            return Clipboard.copy(data)\n        if self.selection_text:\n            return Clipboard.copy(self.selection_text)\n\n    def paste(self):\n        ''' Insert text from system :class:`~kivy.core.clipboard.Clipboard`\n        into the :class:`~kivy.uix.textinput.TextInput` at current cursor\n        position.\n\n        .. versionadded:: 1.8.0\n\n        '''\n        self._ensure_clipboard()\n        data = Clipboard.paste()\n        self.delete_selection()\n        self.insert_text(data)\n\n    def _update_cutbuffer(self, *args):\n        CutBuffer.set_cutbuffer(self.selection_text)\n\n    def _get_text_width(self, text, tab_width, _label_cached):\n        \"\"\"Return the width of a text, according to the current line options\"\"\"\n        kw = self._get_line_options()\n\n        try:\n            cid = u'{}\\0{}\\0{}'.format(text, self.password, kw)\n        except UnicodeDecodeError:\n            cid = '{}\\0{}\\0{}'.format(text, self.password, kw)\n\n        width = Cache_get('textinput.width', cid)\n        if width:\n            return width\n        if not _label_cached:\n            _label_cached = self._label_cached\n        text = text.replace('\\t', ' ' * tab_width)\n        if not self.password:\n            width = _label_cached.get_extents(text)[0]\n        else:\n            width = _label_cached.get_extents(\n                self.password_mask * len(text))[0]\n        Cache_append('textinput.width', cid, width)\n        return width\n\n    def on_cursor_blink(self, instance, value):\n        \"\"\"trigger blink event reset to switch blinking while focused\"\"\"\n        self._reset_cursor_blink()\n\n    def _do_blink_cursor(self, dt):\n        if not self.cursor_blink:\n            # ignore event if not triggered,\n            # stop if cursor_blink value changed right now\n            if self._do_blink_cursor_ev.is_triggered:\n                self._do_blink_cursor_ev.cancel()\n            # don't blink, make cursor visible\n            self._cursor_blink = False\n            return\n\n        # Callback for blinking the cursor.\n        self._cursor_blink = not self._cursor_blink\n\n    def _reset_cursor_blink(self, *args):\n        self._do_blink_cursor_ev.cancel()\n        self._cursor_blink = False\n        self._do_blink_cursor_ev()\n\n    def on_cursor(self, instance, value):\n        \"\"\"\n        When the cursor is moved, reset cursor blinking to keep it showing,\n        and update all the graphics.\n        \"\"\"\n        if self.focus:\n            self._trigger_cursor_reset()\n        self._trigger_update_graphics()\n\n    def _delete_line(self, idx):\n        \"\"\"Delete current line, and fix cursor position\"\"\"\n        assert idx < len(self._lines)\n        self._lines_flags.pop(idx)\n        self._lines_labels.pop(idx)\n        self._lines.pop(idx)\n        self.cursor = self.cursor\n\n    def _set_line_text(self, line_num, text):\n        \"\"\"Set current line with other text than the default one.\"\"\"\n        self._lines_labels[line_num] = self._create_line_label(text)\n        self._lines[line_num] = text\n\n    def _trigger_refresh_line_options(self, *largs):\n        if self._refresh_line_options_ev is not None:\n            self._refresh_line_options_ev.cancel()\n        else:\n            self._refresh_line_options_ev = Clock.create_trigger(\n                self._refresh_line_options, 0)\n        self._refresh_line_options_ev()\n\n    def _refresh_line_options(self, *largs):\n        self._line_options = None\n        self._get_line_options()\n        self._refresh_text_from_property()\n        self._refresh_hint_text()\n        self.cursor = self.get_cursor_from_index(len(self.text))\n\n    def _trigger_refresh_text(self, *largs):\n        if len(largs) and largs[0] == self:\n            largs = ()\n        if self._refresh_text_from_property_ev is not None:\n            self._refresh_text_from_property_ev.cancel()\n        self._refresh_text_from_property_ev = Clock.schedule_once(\n            lambda dt: self._refresh_text_from_property(*largs))\n\n    def _update_text_options(self, *largs):\n        Cache_remove('textinput.width')\n        self._trigger_refresh_text()\n\n    def _refresh_text_from_trigger(self, dt, *largs):\n        self._refresh_text_from_property(*largs)\n\n    def _refresh_text_from_property(self, *largs):\n        self._refresh_text(self.text, *largs)\n\n    def _refresh_text(self, text, *largs):\n        \"\"\"\n        Refresh all the lines from a new text.\n        By using cache in internal functions, this method should be fast.\n        \"\"\"\n        mode = 'all'\n        if len(largs) > 1:\n            mode, start, finish, _lines, _lines_flags, len_lines = largs\n            # start = max(0, start)\n            cursor = None\n        else:\n            cursor = self.cursor_index()\n            _lines, self._lines_flags = self._split_smart(text)\n        _lines_labels = []\n        _line_rects = []\n        _create_label = self._create_line_label\n\n        for x in _lines:\n            lbl = _create_label(x)\n            _lines_labels.append(lbl)\n            _line_rects.append(Rectangle(size=lbl.size))\n\n        if mode == 'all':\n            self._lines_labels = _lines_labels\n            self._lines_rects = _line_rects\n            self._lines[:] = _lines\n        elif mode == 'del':\n            if finish > start:\n                self._insert_lines(start, finish + 1, len_lines,\n                                   _lines_flags, _lines, _lines_labels,\n                                   _line_rects)\n        elif mode == 'insert':\n            self._insert_lines(start, finish + 1, len_lines, _lines_flags,\n                               _lines, _lines_labels, _line_rects)\n\n        min_line_ht = self._label_cached.get_extents('_')[1]\n        # with markup texture can be of height `1`\n        self.line_height = max(_lines_labels[0].height, min_line_ht)\n        # self.line_spacing = 2\n        # now, if the text change, maybe the cursor is not at the same place as\n        # before. so, try to set the cursor on the good place\n        row = self.cursor_row\n        self.cursor = self.get_cursor_from_index(\n            self.cursor_index() if cursor is None else cursor\n        )\n\n        # if we back to a new line, reset the scroll, otherwise, the effect is\n        # ugly\n        if self.cursor_row != row:\n            self.scroll_x = 0\n        # with the new text don't forget to update graphics again\n        self._trigger_update_graphics()\n\n    def _insert_lines(self, start, finish, len_lines, _lines_flags,\n                      _lines, _lines_labels, _line_rects):\n        self_lines_flags = self._lines_flags\n        _lins_flags = []\n        _lins_flags.extend(self_lines_flags[:start])\n        if len_lines:\n            # if not inserting at first line then\n            if start:\n                # make sure line flags restored for first line\n                # _split_smart assumes first line to be not a new line\n                _lines_flags[0] = self_lines_flags[start]\n            _lins_flags.extend(_lines_flags)\n        _lins_flags.extend(self_lines_flags[finish:])\n        self._lines_flags = _lins_flags\n\n        _lins_lbls = []\n        _lins_lbls.extend(self._lines_labels[:start])\n        if len_lines:\n            _lins_lbls.extend(_lines_labels)\n        _lins_lbls.extend(self._lines_labels[finish:])\n        self._lines_labels = _lins_lbls\n\n        _lins_rcts = []\n        _lins_rcts.extend(self._lines_rects[:start])\n        if len_lines:\n            _lins_rcts.extend(_line_rects)\n        _lins_rcts.extend(self._lines_rects[finish:])\n        self._lines_rects = _lins_rcts\n\n        _lins = []\n        _lins.extend(self._lines[:start])\n        if len_lines:\n            _lins.extend(_lines)\n        _lins.extend(self._lines[finish:])\n        self._lines[:] = _lins\n\n    def _trigger_update_graphics(self, *largs):\n        self._update_graphics_ev.cancel()\n        self._update_graphics_ev()\n\n    def _update_graphics(self, *largs):\n        \"\"\"\n        Update all the graphics according to the current internal values.\n        \"\"\"\n\n        # This is a little bit complex, because we have to :\n        #     - handle scroll_x\n        #     - handle padding\n        #     - create rectangle for the lines matching the viewport\n        #     - crop the texture coordinates to match the viewport\n\n        # This is the first step of graphics, the second is the selection.\n\n        self.canvas.clear()\n\n        line_height = self.line_height\n        dy = line_height + self.line_spacing\n\n        # adjust view if the cursor is going outside the bounds\n        scroll_x = self.scroll_x\n        scroll_y = self.scroll_y\n\n        # draw labels\n        if (\n            not self._lines\n            or (not self._lines[0] and len(self._lines) == 1)\n        ):\n            rects = self._hint_text_rects\n            labels = self._hint_text_labels\n            lines = self._hint_text_lines\n        else:\n            rects = self._lines_rects\n            labels = self._lines_labels\n            lines = self._lines\n\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n        x = self.x + padding_left\n        y = self.top - padding_top + scroll_y\n        miny = self.y + padding_bottom\n        maxy = self.top - padding_top\n        halign = self.halign\n        base_dir = self.base_direction\n\n        auto_halign_r = halign == 'auto' and base_dir and 'rtl' in base_dir\n\n        fst_visible_ln = None\n        viewport_pos = scroll_x, 0\n        for line_num, value in enumerate(lines):\n            if miny < y < maxy + dy:\n                if fst_visible_ln is None:\n                    fst_visible_ln = line_num\n\n                y = self._draw_line(\n                    value,\n                    line_num,\n                    labels[line_num],\n                    viewport_pos,\n                    line_height,\n                    miny,\n                    maxy,\n                    x,\n                    y,\n                    base_dir,\n                    halign,\n                    rects,\n                    auto_halign_r,\n                )\n            elif y <= miny:\n                line_num -= 1\n                break\n\n            y -= dy\n\n        if fst_visible_ln is not None:\n            self._visible_lines_range = (fst_visible_ln, line_num + 1)\n        else:\n            self._visible_lines_range = 0, 0\n\n        self._update_graphics_selection()\n\n    def _draw_line(\n        self,\n        value,\n        line_num,\n        texture,\n        viewport_pos,\n        line_height,\n        miny,\n        maxy,\n        x,\n        y,\n        base_dir,\n        halign,\n        rects,\n        auto_halign_r,\n    ):\n        size = list(texture.size)\n        texcoords = texture.tex_coords[:]\n\n        # compute coordinate\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n        viewport_width = self.width - padding_left - padding_right\n        viewport_height = self.height - padding_top - padding_bottom\n        texture_width, texture_height = size\n        original_height, original_width = tch, tcw = texcoords[1:3]\n\n        # adjust size/texcoord according to viewport\n        if viewport_pos:\n            tcx, tcy = viewport_pos\n            tcx = tcx / texture_width * original_width\n            tcy = tcy / texture_height * original_height\n\n        else:\n            tcx, tcy = 0, 0\n\n        if texture_width * (1 - tcx) < viewport_width:\n            tcw = tcw - tcx\n            texture_width = tcw * texture_width\n        elif viewport_width < texture_width:\n            tcw = (viewport_width / texture_width) * tcw\n            texture_width = viewport_width\n\n        if viewport_height < texture_height:\n            tch = (viewport_height / texture_height) * tch\n            texture_height = viewport_height\n\n        # cropping\n        if y > maxy:\n            viewport_height = (maxy - y + line_height)\n            tch = (viewport_height / line_height) * original_height\n            tcy = original_height - tch\n            texture_height = viewport_height\n        if y - line_height < miny:\n            diff = miny - (y - line_height)\n            y += diff\n            viewport_height = line_height - diff\n            tch = (viewport_height / line_height) * original_height\n            texture_height = viewport_height\n\n        if tcw < 0:\n            # nothing to show\n            return y\n\n        top_left_corner = tcx, tcy + tch\n        top_right_corner = tcx + tcw, tcy + tch\n        bottom_right_corner = tcx + tcw, tcy\n        bottom_left_corner = tcx, tcy\n\n        texcoords = (\n            top_left_corner\n            + top_right_corner\n            + bottom_right_corner\n            + bottom_left_corner\n        )\n\n        # Horizontal alignment\n        xoffset = 0\n        if not base_dir:\n            base_dir = self._resolved_base_dir = Label.find_base_direction(value)  # noqa\n            if base_dir and halign == 'auto':\n                auto_halign_r = 'rtl' in base_dir\n        if halign == 'center':\n            xoffset = int((viewport_width - texture_width) / 2.)\n        elif halign == 'right' or auto_halign_r:\n            xoffset = max(0, int(viewport_width - texture_width))\n\n        # add rectangle\n        rect = rects[line_num]\n        rect.pos = int(xoffset + x), int(y - line_height)\n        rect.size = texture_width, texture_height\n        rect.texture = texture\n        rect.tex_coords = texcoords\n        # useful to debug rectangle sizes\n        # self.canvas.add(Color(0, .5, 0, .5, mode='rgba'))\n        # self.canvas.add(Rectangle(pos=rect.pos, size=rect.size))\n        # self.canvas.add(Color())\n        self.canvas.add(rect)\n\n        return y\n\n    def _update_graphics_selection(self):\n        if not self._selection:\n            return\n\n        # local references to avoid dot lookups later\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n        rects = self._lines_rects\n        label_cached = self._label_cached\n        lines = self._lines\n        tab_width = self.tab_width\n        top = self.top\n        get_text_width = self._get_text_width\n        get_cursor_from_index = self.get_cursor_from_index\n        draw_selection = self._draw_selection\n        canvas_add = self.canvas.add\n        selection_color = self.selection_color\n\n        # selection borders\n        a, b = sorted((self._selection_from, self._selection_to))\n        selection_start_col, selection_start_row = get_cursor_from_index(a)\n        selection_end_col, selection_end_row = get_cursor_from_index(b)\n\n        dy = self.line_height + self.line_spacing\n        x = self.x\n        y = top - padding_top + self.scroll_y - selection_start_row * dy\n        width = self.width\n\n        miny = self.y + padding_bottom\n        maxy = top - padding_top + dy\n\n        self.canvas.remove_group('selection')\n        first_visible_line = math.floor(self.scroll_y / dy)\n        last_visible_line = math.ceil((self.scroll_y + maxy - miny) / dy)\n        width_minus_padding = width - (padding_right + padding_left)\n\n        for line_num, rect in enumerate(\n            islice(\n                rects,\n                max(selection_start_row, first_visible_line),\n                min(selection_end_row + 1, last_visible_line - 1),\n            ),\n            start=max(selection_start_row, first_visible_line)\n        ):\n            draw_selection(\n                rect.pos,\n                rect.size,\n                line_num,\n                (selection_start_col, selection_start_row),\n                (selection_end_col, selection_end_row),\n                lines,\n                get_text_width,\n                tab_width,\n                label_cached,\n                width_minus_padding,\n                padding_left,\n                padding_right,\n                x,\n                canvas_add,\n                selection_color\n            )\n        self._position_handles('both')\n\n    def _draw_selection(\n        self,\n        pos,\n        size,\n        line_num,\n        selection_start,\n        selection_end,\n        lines,\n        get_text_width,\n        tab_width,\n        label_cached,\n        width_minus_padding,\n        padding_left,\n        padding_right,\n        x,\n        canvas_add,\n        selection_color\n    ):\n        selection_start_col, selection_start_row = selection_start\n        selection_end_col, selection_end_row = selection_end\n\n        # Draw the current selection on the widget.\n        if not selection_start_row <= line_num <= selection_end_row:\n            return\n        x, y = pos\n        w, h = size\n        beg = x\n        end = x + w\n\n        if line_num == selection_start_row:\n            line = lines[line_num]\n            beg -= self.scroll_x\n            beg += get_text_width(\n                line[:selection_start_col],\n                tab_width,\n                label_cached\n            )\n\n        if line_num == selection_end_row:\n            line = lines[line_num]\n            end = (x - self.scroll_x) + get_text_width(\n                line[:selection_end_col],\n                tab_width,\n                label_cached\n            )\n\n        beg = boundary(beg, x, x + width_minus_padding)\n        end = boundary(end, x, x + width_minus_padding)\n        if beg == end:\n            return\n\n        canvas_add(Color(*selection_color, group='selection'))\n        canvas_add(\n            Rectangle(\n                pos=(beg, y),\n                size=(end - beg, h),\n                group='selection'\n            )\n        )\n\n    def on_size(self, instance, value):\n        # if the size change, we might do invalid scrolling / text split\n        # size the text maybe be put after size_hint have been resolved.\n        self._trigger_refresh_text()\n        self._refresh_hint_text()\n        self.scroll_x = self.scroll_y = 0\n\n    def _get_row_width(self, row):\n        # Get the pixel width of the given row.\n        _labels = self._lines_labels\n        if row < len(_labels):\n            return _labels[row].width\n        return 0\n\n    def _get_cursor_pos(self):\n        # return the current cursor x/y from the row/col\n        dy = self.line_height + self.line_spacing\n        padding_left = self.padding[0]\n        padding_top = self.padding[1]\n        padding_right = self.padding[2]\n        left = self.x + padding_left\n        top = self.top - padding_top\n        y = top + self.scroll_y\n        y -= self.cursor_row * dy\n\n        # Horizontal alignment\n        halign = self.halign\n        viewport_width = self.width - padding_left - padding_right\n        cursor_offset = self.cursor_offset()\n        base_dir = self.base_direction or self._resolved_base_dir\n        auto_halign_r = halign == 'auto' and base_dir and 'rtl' in base_dir\n        if halign == 'center':\n            row_width = self._get_row_width(self.cursor_row)\n            x = (\n                left\n                + max(0, (viewport_width - row_width) // 2)\n                + cursor_offset\n                - self.scroll_x\n            )\n        elif halign == 'right' or auto_halign_r:\n            row_width = self._get_row_width(self.cursor_row)\n            x = (\n                left\n                + max(0, viewport_width - row_width)\n                + cursor_offset\n                - self.scroll_x\n            )\n        else:\n            x = left + cursor_offset - self.scroll_x\n\n        return x, y\n\n    def _get_cursor_visual_height(self):\n        # Return the height of the cursor's visible part\n        _, cy = map(int, self.cursor_pos)\n        max_y = self.top - self.padding[1]\n        min_y = self.y + self.padding[3]\n\n        lh = self.line_height\n        if cy > max_y:\n            return lh - min(lh, cy - max_y)\n        else:\n            return min(lh, max(0, cy - min_y))\n\n    def _get_cursor_visual_pos(self):\n        # Return the position of the cursor's top visible point\n        cx, cy = map(int, self.cursor_pos)\n        max_y = self.top - self.padding[3]\n        return [cx, min(max_y, cy)]\n\n    def _get_line_options(self):\n        # Get or create line options, to be used for Label creation\n        if self._line_options is None:\n            self._line_options = kw = {\n                'font_size': self.font_size,\n                'font_name': self.font_name,\n                'font_context': self.font_context,\n                'font_family': self.font_family,\n                'text_language': self.text_language,\n                'base_direction': self.base_direction,\n                'anchor_x': 'left',\n                'anchor_y': 'top',\n                'padding_x': 0,\n                'padding_y': 0,\n                'padding': (0, 0)\n            }\n            self._label_cached = Label(**kw)\n        return self._line_options\n\n    def _create_line_label(self, text, hint=False):\n        # Create a label from a text, using line options\n        ntext = text.replace(u'\\n', u'').replace(u'\\t', u' ' * self.tab_width)\n\n        if self.password and not hint:  # Don't replace hint_text with *\n            ntext = self.password_mask * len(ntext)\n\n        kw = self._get_line_options()\n        cid = '%s\\0%s' % (ntext, str(kw))\n        texture = Cache_get('textinput.label', cid)\n\n        if texture is None:\n            # FIXME right now, we can't render very long line...\n            # if we move on \"VBO\" version as fallback, we won't need to\n            # do this. try to find the maximum text we can handle\n            label = None\n            label_len = len(ntext)\n            ld = None\n\n            # check for blank line\n            if not ntext:\n                texture = Texture.create(size=(1, 1))\n                Cache_append('textinput.label', cid, texture)\n                return texture\n\n            while True:\n                try:\n                    label = Label(text=ntext[:label_len], **kw)\n                    label.refresh()\n                    if ld is not None and ld > 2:\n                        ld //= 2\n                        label_len += ld\n                    else:\n                        break\n\n                except:\n                    # exception happen when we tried to render the text\n                    # reduce it...\n                    if ld is None:\n                        ld = len(ntext)\n                    ld //= 2\n                    if ld < 2 and label_len:\n                        label_len -= 1\n                    label_len -= ld\n                    continue\n\n            # ok, we found it.\n            texture = label.texture\n            Cache_append('textinput.label', cid, texture)\n        return texture\n\n    _tokenize_delimiters = u' .,:;!?\\r\\t'\n\n    def _tokenize(self, text):\n        # Tokenize a text string from some delimiters\n        if text is None:\n            return\n        delimiters = self._tokenize_delimiters\n        old_index = 0\n        prev_char = ''\n        for index, char in enumerate(text):\n            if char not in delimiters:\n                if char != u'\\n':\n                    if index > 0 and (prev_char in delimiters):\n                        if old_index < index:\n                            yield text[old_index:index]\n                        old_index = index\n                else:\n                    if old_index < index:\n                        yield text[old_index:index]\n                    yield text[index:index + 1]\n                    old_index = index + 1\n            prev_char = char\n        yield text[old_index:]\n\n    def _split_smart(self, text):\n        \"\"\"\n        Do a \"smart\" split. If not multiline, or if wrap is set,\n        we are not doing smart split, just a split on line break.\n        Otherwise, we are trying to split as soon as possible, to prevent\n        overflow on the widget.\n        \"\"\"\n\n        # depend of the options, split the text on line, or word\n        if not self.multiline or not self.do_wrap:\n            lines = text.split(u'\\n')\n            lines_flags = [0] + [FL_IS_LINEBREAK] * (len(lines) - 1)\n            return lines, lines_flags\n\n        # no autosize, do wordwrap.\n        x = flags = 0\n        line = []\n        lines = []\n        lines_flags = []\n        _join = u''.join\n        lines_append, lines_flags_append = lines.append, lines_flags.append\n        padding_left = self.padding[0]\n        padding_right = self.padding[2]\n        width = self.width - padding_left - padding_right\n        text_width = self._get_text_width\n        _tab_width, _label_cached = self.tab_width, self._label_cached\n\n        # try to add each word on current line.\n        words_widths = {}\n        for word in self._tokenize(text):\n            is_newline = (word == u'\\n')\n            try:\n                w = words_widths[word]\n            except KeyError:\n                w = text_width(word, _tab_width, _label_cached)\n                words_widths[word] = w\n            # if we have more than the width, or if it's a newline,\n            # push the current line, and create a new one\n            if (x + w > width and line) or is_newline:\n                lines_append(_join(line))\n                lines_flags_append(flags)\n                flags = 0\n                line = []\n                x = 0\n            if is_newline:\n                flags |= FL_IS_LINEBREAK\n            elif width >= 1 and w > width:\n                while w > width:\n                    split_width = split_pos = 0\n                    # split the word\n                    for c in word:\n                        try:\n                            cw = words_widths[c]\n                        except KeyError:\n                            cw = text_width(c, _tab_width, _label_cached)\n                            words_widths[c] = cw\n                        if split_width + cw > width:\n                            break\n                        split_width += cw\n                        split_pos += 1\n                    if split_width == split_pos == 0:\n                        # can't fit the word in, give up\n                        break\n                    lines_append(word[:split_pos])\n                    lines_flags_append(flags)\n                    flags = FL_IS_WORDBREAK\n                    word = word[split_pos:]\n                    w -= split_width\n                x = w\n                line.append(word)\n            else:\n                x += w\n                line.append(word)\n        if line or flags & FL_IS_LINEBREAK:\n            lines_append(_join(line))\n            lines_flags_append(flags)\n\n        return lines, lines_flags\n\n    def _key_down(self, key, repeat=False):\n        displayed_str, internal_str, internal_action, scale = key\n\n        # handle deletion\n        if (\n            self._selection\n            and internal_action in (None, 'del', 'backspace', 'enter')\n            and (internal_action != 'enter' or self.multiline)\n        ):\n            self.delete_selection()\n\n        elif internal_action == 'del':\n            # Move cursor one char to the right. If that was successful,\n            # do a backspace (effectively deleting char right of cursor)\n            cursor = self.cursor\n            self.do_cursor_movement('cursor_right')\n            if cursor != self.cursor:\n                self.do_backspace(mode='del')\n\n        elif internal_action == 'backspace':\n            self.do_backspace()\n\n        # handle action keys and text insertion\n        if internal_action is None:\n            self.insert_text(displayed_str)\n\n        elif internal_action in ('shift', 'shift_L', 'shift_R'):\n            if not self._selection:\n                self._selection_from = self._selection_to = self.cursor_index()\n                self._selection = True\n            self._selection_finished = False\n\n        elif internal_action == 'ctrl_L':\n            self._ctrl_l = True\n\n        elif internal_action == 'ctrl_R':\n            self._ctrl_r = True\n\n        elif internal_action == 'alt_L':\n            self._alt_l = True\n\n        elif internal_action == 'alt_R':\n            self._alt_r = True\n\n        elif internal_action.startswith('cursor_'):\n            cc, cr = self.cursor\n            self.do_cursor_movement(\n                internal_action,\n                self._ctrl_l or self._ctrl_r,\n                self._alt_l or self._alt_r\n            )\n            if self._selection and not self._selection_finished:\n                self._selection_to = self.cursor_index()\n                self._update_selection()\n            else:\n                self.cancel_selection()\n\n        elif internal_action == 'enter':\n            if self.multiline:\n                self.insert_text(u'\\n')\n            else:\n                self.dispatch('on_text_validate')\n                if self.text_validate_unfocus:\n                    self.focus = False\n\n        elif internal_action == 'escape':\n            self.focus = False\n\n    def _key_up(self, key, repeat=False):\n        displayed_str, internal_str, internal_action, scale = key\n        if internal_action in ('shift', 'shift_L', 'shift_R'):\n            if self._selection:\n                self._update_selection(True)\n        elif internal_action == 'ctrl_L':\n            self._ctrl_l = False\n        elif internal_action == 'ctrl_R':\n            self._ctrl_r = False\n        elif internal_action == 'alt_L':\n            self._alt_l = False\n        elif internal_action == 'alt_R':\n            self._alt_r = False\n\n    def keyboard_on_key_down(self, window, keycode, text, modifiers):\n        key, _ = keycode\n        win = EventLoop.window\n\n        # This allows *either* ctrl *or* cmd, but not both.\n        modifiers = set(modifiers) - {'capslock', 'numlock'}\n        is_shortcut = (\n            modifiers == {'ctrl'}\n            or _is_osx and modifiers == {'meta'}\n        )\n        is_interesting_key = key in self.interesting_keys.keys()\n\n        if (\n            not self.write_tab\n            and super().keyboard_on_key_down(window, keycode, text, modifiers)\n        ):\n            return True\n\n        if text and is_shortcut and not is_interesting_key:\n            self._handle_shortcut(key)\n\n        elif self._editable and text and not is_interesting_key:\n            self._hide_handles(win)\n            self._hide_cut_copy_paste(win)\n            win.remove_widget(self._handle_middle)\n\n            # check for command modes\n            # we use \\x01INFO\\x02 to get info from IME on mobiles\n            # pygame seems to pass \\x01 as the unicode for ctrl+a\n            # checking for modifiers ensures conflict resolution.\n\n            first_char = ord(text[0])\n            if not modifiers and first_char == 1:\n                self._command_mode = True\n                self._command = ''\n            if not modifiers and first_char == 2:\n                self._command_mode = False\n                self._command = self._command[1:]\n\n            if self._command_mode:\n                self._command += text\n                return\n\n            _command = self._command\n            if _command and first_char == 2:\n                self._handle_command(_command)\n                return\n\n            else:\n                if EventLoop.window.managed_textinput:\n                    # we expect to get managed key input via on_textinput\n                    return\n                if self._selection:\n                    self.delete_selection()\n                self.insert_text(text)\n            # self._recalc_size()\n            return\n\n        if is_interesting_key:\n            self._hide_cut_copy_paste(win)\n            self._hide_handles(win)\n\n        if key == 27:  # escape\n            self.focus = False\n            return True\n        elif key == 9:  # tab\n            self.delete_selection()\n            self.insert_text(u'\\t')\n            return True\n\n        k = self.interesting_keys.get(key)\n        if k:\n            key = (None, None, k, 1)\n            self._key_down(key)\n\n    def _handle_command(self, command):\n        from_undo = True\n        command, data = command.split(':')\n        self._command = ''\n        if self._selection:\n            self.delete_selection()\n        if command == 'DEL':\n            count = int(data)\n            if not count:\n                self.delete_selection(from_undo=True)\n            end = self.cursor_index()\n            self._selection_from = max(end - count, 0)\n            self._selection_to = end\n            self._selection = True\n            self.delete_selection(from_undo=True)\n            return\n        elif command == 'INSERT':\n            self.insert_text(data, from_undo)\n        elif command == 'INSERTN':\n            from_undo = False\n            self.insert_text(data, from_undo)\n        elif command == 'SELWORD':\n            self.dispatch('on_double_tap')\n        elif command == 'SEL':\n            if data == '0':\n                Clock.schedule_once(lambda dt: self.cancel_selection())\n        elif command == 'CURCOL':\n            self.cursor = int(data), self.cursor_row\n\n    def _handle_shortcut(self, key):\n        # actions that can be done in readonly\n        if key == ord('a'):  # select all\n            self.select_all()\n        elif key == ord('c'):  # copy selection\n            self.copy()\n\n        if not self._editable:\n            return\n\n        # actions that can be done only if editable\n        if key == ord('x'):  # cut selection\n            self._cut(self.selection_text)\n        elif key == ord('v'):  # paste clipboard content\n            self.paste()\n        elif key == ord('z'):  # undo\n            self.do_undo()\n        elif key == ord('r'):  # redo\n            self.do_redo()\n\n    def keyboard_on_key_up(self, window, keycode):\n        key = keycode[0]\n        k = self.interesting_keys.get(key)\n        if k:\n            key = (None, None, k, 1)\n            self._key_up(key)\n\n    def keyboard_on_textinput(self, window, text):\n        if self._selection:\n            self.delete_selection()\n        self.insert_text(text, False)\n\n    # current IME composition in progress by the IME system, or '' if nothing\n    _ime_composition = StringProperty('')\n    # cursor position of last IME event\n    _ime_cursor = ListProperty(None, allownone=True)\n\n    def _bind_keyboard(self):\n        super()._bind_keyboard()\n        Window.bind(on_textedit=self.window_on_textedit)\n\n    def _unbind_keyboard(self):\n        super()._unbind_keyboard()\n        Window.unbind(on_textedit=self.window_on_textedit)\n\n    def window_on_textedit(self, window, ime_input):\n        text_lines = self._lines or ['']\n        if self._ime_composition:\n            pcc, pcr = self._ime_cursor\n            text = text_lines[pcr]\n            len_ime = len(self._ime_composition)\n            if text[pcc - len_ime:pcc] == self._ime_composition:  # always?\n                remove_old_ime_text = text[:pcc - len_ime] + text[pcc:]\n                ci = self.cursor_index()\n                self._refresh_text_from_property(\n                    \"insert\",\n                    *self._get_line_from_cursor(pcr, remove_old_ime_text)\n                )\n                self.cursor = self.get_cursor_from_index(ci - len_ime)\n\n        if ime_input:\n            if self._selection:\n                self.delete_selection()\n            cc, cr = self.cursor\n            text = text_lines[cr]\n            new_text = text[:cc] + ime_input + text[cc:]\n            self._refresh_text_from_property(\n                \"insert\", *self._get_line_from_cursor(cr, new_text)\n            )\n            self.cursor = self.get_cursor_from_index(\n                self.cursor_index() + len(ime_input)\n            )\n        self._ime_composition = ime_input\n        self._ime_cursor = self.cursor\n\n    def on__hint_text(self, instance, value):\n        self._refresh_hint_text()\n\n    def _refresh_hint_text(self):\n        _lines, self._hint_text_flags = self._split_smart(self.hint_text)\n        _hint_text_labels = []\n        _hint_text_rects = []\n        _create_label = self._create_line_label\n\n        for x in _lines:\n            lbl = _create_label(x, hint=True)\n            _hint_text_labels.append(lbl)\n            _hint_text_rects.append(Rectangle(size=lbl.size))\n\n        self._hint_text_lines[:] = _lines\n        self._hint_text_labels = _hint_text_labels\n        self._hint_text_rects = _hint_text_rects\n\n        # Remember to update graphics\n        self._trigger_update_graphics()\n\n    #\n    # Properties\n    #\n\n    _lines = ListProperty([])\n    _hint_text_lines = ListProperty([])\n    _editable = BooleanProperty(True)\n    _insert_int_pat = re.compile(u'^-?[0-9]*$')\n    _insert_float_pat = re.compile(u'^-?[0-9]*\\\\.?[0-9]*$')\n    _cursor_blink = BooleanProperty(False)\n    _cursor_visual_pos = AliasProperty(\n        _get_cursor_visual_pos, None, bind=['cursor_pos']\n    )\n    _cursor_visual_height = AliasProperty(\n        _get_cursor_visual_height, None, bind=['cursor_pos']\n    )\n\n    readonly = BooleanProperty(False)\n    '''If True, the user will not be able to change the content of a textinput.\n\n    .. versionadded:: 1.3.0\n\n    :attr:`readonly` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    text_validate_unfocus = BooleanProperty(True)\n    '''If True, the :meth:`TextInput.on_text_validate` event will unfocus the\n    widget, therefore make it stop listening to the keyboard. When disabled,\n    the :meth:`TextInput.on_text_validate` event can be fired multiple times\n    as the result of TextInput keeping the focus enabled.\n\n    .. versionadded:: 1.10.1\n\n    :attr:`text_validate_unfocus` is\n    a :class:`~kivy.properties.BooleanProperty` and defaults to True.\n    '''\n\n    multiline = BooleanProperty(True)\n    '''If True, the widget will be able show multiple lines of text. If False,\n    the \"enter\" keypress will defocus the textinput instead of adding a new\n    line.\n\n    :attr:`multiline` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    do_wrap = BooleanProperty(True)\n    '''If True, and the text is multiline, then lines larger than the width of\n    the widget will wrap around to the next line, avoiding the need for\n    horizontal scrolling. Disabling this option ensure one line is always\n    displayed as one line.\n\n    :attr:`do_wrap` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to True.\n\n    versionadded:: 2.1.0\n    '''\n\n    password = BooleanProperty(False)\n    '''If True, the widget will display its characters as the character\n    set in :attr:`password_mask`.\n\n    .. versionadded:: 1.2.0\n\n    :attr:`password` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    password_mask = StringProperty('*')\n    '''Sets the character used to mask the text when :attr:`password` is True.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`password_mask` is a :class:`~kivy.properties.StringProperty` and\n    defaults to `'*'`.\n    '''\n\n    cursor_blink = BooleanProperty(True)\n    '''This property is used to set whether the graphic cursor should blink\n    or not.\n\n    .. versionchanged:: 1.10.1\n        `cursor_blink` has been refactored to enable switching the blinking\n        on/off and the previous behavior has been moved to a private\n        `_cursor_blink` property. The previous default value `False` has been\n        changed to `True`.\n\n    :attr:`cursor_blink` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    def _get_cursor(self):\n        return self._cursor\n\n    def _set_cursor(self, pos):\n        if not self._lines:\n            self._trigger_refresh_text()\n            return\n        l = self._lines\n        cr = boundary(pos[1], 0, len(l) - 1)\n        cc = boundary(pos[0], 0, len(l[cr]))\n        cursor = cc, cr\n\n        # adjust scrollview to ensure that the cursor will be always inside our\n        # viewport.\n        self._adjust_viewport(cc, cr)\n\n        if self._cursor == cursor:\n            return\n\n        self._cursor = cursor\n        return True\n\n    @triggered(timeout=-1)\n    def _adjust_viewport(self, cc, cr):\n        padding_left = self.padding[0]\n        padding_right = self.padding[2]\n        viewport_width = self.width - padding_left - padding_right\n        sx = self.scroll_x\n        base_dir = self.base_direction or self._resolved_base_dir\n        auto_halign_r = (\n            self.halign == 'auto'\n            and base_dir\n            and 'rtl' in base_dir\n        )\n\n        offset = self.cursor_offset()\n        row_width = self._get_row_width(self.cursor_row)\n\n        # if offset is outside the current bounds, readjust\n        if offset - sx >= viewport_width:\n            self.scroll_x = offset - viewport_width\n        elif offset < sx + 1:\n            self.scroll_x = offset\n\n        # Avoid right/center horizontal alignment issues if the viewport is at\n        # the end of the line, if not multiline.\n        viewport_scroll_x = row_width - viewport_width\n        if (\n            not self.multiline\n            and offset >= viewport_scroll_x\n            and self.scroll_x >= viewport_scroll_x\n            and (\n                self.halign == \"center\"\n                or self.halign == \"right\"\n                or auto_halign_r\n            )\n        ):\n            self.scroll_x = max(0, viewport_scroll_x)\n\n        # do the same for Y\n        # this algo try to center the cursor as much as possible\n        dy = self.line_height + self.line_spacing\n        offsety = cr * dy\n\n        padding_top = self.padding[1]\n        padding_bottom = self.padding[3]\n        viewport_height = self.height - padding_top - padding_bottom - dy\n\n        sy = self.scroll_y\n        if offsety > viewport_height + sy:\n            self.scroll_y = offsety - viewport_height\n        elif offsety < sy:\n            self.scroll_y = offsety\n\n    cursor = AliasProperty(_get_cursor, _set_cursor)\n    '''Tuple of (col, row) values indicating the current cursor position.\n    You can set a new (col, row) if you want to move the cursor. The scrolling\n    area will be automatically updated to ensure that the cursor is\n    visible inside the viewport.\n\n    :attr:`cursor` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    def _get_cursor_col(self):\n        return self._cursor[0]\n\n    cursor_col = AliasProperty(_get_cursor_col, None, bind=('cursor', ))\n    '''Current column of the cursor.\n\n    :attr:`cursor_col` is an :class:`~kivy.properties.AliasProperty` to\n    cursor[0], read-only.\n    '''\n\n    def _get_cursor_row(self):\n        return self._cursor[1]\n\n    cursor_row = AliasProperty(_get_cursor_row, None, bind=('cursor', ))\n    '''Current row of the cursor.\n\n    :attr:`cursor_row` is an :class:`~kivy.properties.AliasProperty` to\n    cursor[1], read-only.\n    '''\n\n    cursor_pos = AliasProperty(_get_cursor_pos, None,\n                               bind=('cursor', 'padding', 'pos', 'size',\n                                     'focus', 'scroll_x', 'scroll_y',\n                                     'line_height', 'line_spacing'),\n                               cache=False)\n    '''Current position of the cursor, in (x, y).\n\n    :attr:`cursor_pos` is an :class:`~kivy.properties.AliasProperty`,\n    read-only.\n    '''\n\n    cursor_color = ColorProperty([1, 0, 0, 1])\n    '''Current color of the cursor, in (r, g, b, a) format.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`cursor_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [1, 0, 0, 1].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    cursor_width = NumericProperty('1sp')\n    '''Current width of the cursor.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`cursor_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to '1sp'.\n    '''\n\n    line_height = NumericProperty(1)\n    '''Height of a line. This property is automatically computed from the\n    :attr:`font_name`, :attr:`font_size`. Changing the line_height will have\n    no impact.\n\n    .. note::\n\n        :attr:`line_height` is the height of a single line of text.\n        Use :attr:`minimum_height`, which also includes padding, to\n        get the height required to display the text properly.\n\n    :attr:`line_height` is a :class:`~kivy.properties.NumericProperty`,\n    read-only.\n    '''\n\n    tab_width = NumericProperty(4)\n    '''By default, each tab will be replaced by four spaces on the text\n    input widget. You can set a lower or higher value.\n\n    :attr:`tab_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 4.\n    '''\n\n    padding_x = VariableListProperty([0, 0], length=2, deprecated=True)\n    '''Horizontal padding of the text: [padding_left, padding_right].\n\n    padding_x also accepts a one argument form [padding_horizontal].\n\n    :attr:`padding_x` is a :class:`~kivy.properties.VariableListProperty` and\n    defaults to [0, 0]. This might be changed by the current theme.\n\n    .. deprecated:: 1.7.0\n        Use :attr:`padding` instead.\n    '''\n\n    def on_padding_x(self, instance, value):\n        self.padding[0] = value[0]\n        self.padding[2] = value[1]\n\n    padding_y = VariableListProperty([0, 0], length=2, deprecated=True)\n    '''Vertical padding of the text: [padding_top, padding_bottom].\n\n    padding_y also accepts a one argument form [padding_vertical].\n\n    :attr:`padding_y` is a :class:`~kivy.properties.VariableListProperty` and\n    defaults to [0, 0]. This might be changed by the current theme.\n\n    .. deprecated:: 1.7.0\n        Use :attr:`padding` instead.\n    '''\n\n    def on_padding_y(self, instance, value):\n        self.padding[1] = value[0]\n        self.padding[3] = value[1]\n\n    padding = VariableListProperty([6, 6, 6, 6])\n    '''Padding of the text: [padding_left, padding_top, padding_right,\n    padding_bottom].\n\n    padding also accepts a two argument form [padding_horizontal,\n    padding_vertical] and a one argument form [padding].\n\n    .. versionchanged:: 1.7.0\n        Replaced AliasProperty with VariableListProperty.\n\n    :attr:`padding` is a :class:`~kivy.properties.VariableListProperty` and\n    defaults to [6, 6, 6, 6].\n    '''\n\n    halign = OptionProperty('auto', options=['left', 'center', 'right',\n                            'auto'])\n    '''Horizontal alignment of the text.\n\n    :attr:`halign` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'auto'. Available options are : auto, left, center and right.\n    Auto will attempt to autodetect horizontal alignment for RTL text (Pango\n    only), otherwise it behaves like `left`.\n\n    .. versionadded:: 1.10.1\n    '''\n\n    scroll_x = NumericProperty(0)\n    '''X scrolling value of the viewport. The scrolling is automatically\n    updated when the cursor is moved or text changed. If there is no\n    user input, the scroll_x and scroll_y properties may be changed.\n\n    :attr:`scroll_x` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    scroll_y = NumericProperty(0)\n    '''Y scrolling value of the viewport. See :attr:`scroll_x` for more\n    information.\n\n    :attr:`scroll_y` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    selection_color = ColorProperty([0.1843, 0.6549, 0.8313, .5])\n    '''Current color of the selection, in (r, g, b, a) format.\n\n    .. warning::\n\n        The color should always have an \"alpha\" component less than 1\n        since the selection is drawn after the text.\n\n    :attr:`selection_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [0.1843, 0.6549, 0.8313, .5].\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    border = ListProperty([4, 4, 4, 4])\n    '''Border used for :class:`~kivy.graphics.vertex_instructions.BorderImage`\n    graphics instruction. Used with :attr:`background_normal` and\n    :attr:`background_active`. Can be used for a custom background.\n\n    .. versionadded:: 1.4.1\n\n    It must be a list of four values: (bottom, right, top, left). Read the\n    BorderImage instruction for more information about how to use it.\n\n    :attr:`border` is a :class:`~kivy.properties.ListProperty` and defaults\n    to (4, 4, 4, 4).\n    '''\n\n    background_normal = StringProperty(\n        'atlas://data/images/defaulttheme/textinput')\n    '''Background image of the TextInput when it's not in focus.\n\n    .. versionadded:: 1.4.1\n\n    :attr:`background_normal` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/textinput'.\n    '''\n\n    background_disabled_normal = StringProperty(\n        'atlas://data/images/defaulttheme/textinput_disabled')\n    '''Background image of the TextInput when disabled.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`background_disabled_normal` is a\n    :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/textinput_disabled'.\n    '''\n\n    background_active = StringProperty(\n        'atlas://data/images/defaulttheme/textinput_active')\n    '''Background image of the TextInput when it's in focus.\n\n    .. versionadded:: 1.4.1\n\n    :attr:`background_active` is a\n    :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/textinput_active'.\n    '''\n\n    background_color = ColorProperty([1, 1, 1, 1])\n    '''Current color of the background, in (r, g, b, a) format.\n\n    .. versionadded:: 1.2.0\n\n    :attr:`background_color` is a :class:`~kivy.properties.ColorProperty`\n    and defaults to [1, 1, 1, 1] (white).\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    foreground_color = ColorProperty([0, 0, 0, 1])\n    '''Current color of the foreground, in (r, g, b, a) format.\n\n    .. versionadded:: 1.2.0\n\n    :attr:`foreground_color` is a :class:`~kivy.properties.ColorProperty`\n    and defaults to [0, 0, 0, 1] (black).\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    disabled_foreground_color = ColorProperty([0, 0, 0, .5])\n    '''Current color of the foreground when disabled, in (r, g, b, a) format.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`disabled_foreground_color` is a\n    :class:`~kivy.properties.ColorProperty` and\n    defaults to [0, 0, 0, 5] (50% transparent black).\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    use_bubble = BooleanProperty(not _is_desktop)\n    '''Indicates whether the cut/copy/paste bubble is used.\n\n    .. versionadded:: 1.7.0\n\n    :attr:`use_bubble` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True on mobile OS's, False on desktop OS's.\n    '''\n\n    use_handles = BooleanProperty(not _is_desktop)\n    '''Indicates whether the selection handles are displayed.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`use_handles` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True on mobile OS's, False on desktop OS's.\n    '''\n\n    scroll_from_swipe = BooleanProperty(not _is_desktop)\n    '''Allow to scroll the text using swipe gesture according to\n    :attr:`scroll_timeout` and :attr:`scroll_distance`.\n\n    .. versionadded:: 2.1.0\n\n    :attr:`scroll_from_swipe` is a BooleanProperty and defaults to True on\n    mobile OS\u2019s, False on desktop OS\u2019s.\n    '''\n\n    scroll_distance = NumericProperty(_scroll_distance)\n    '''Minimum distance to move before change from scroll to selection mode, in\n    pixels.\n    It is advisable that you base this value on the dpi of your target device's\n    screen.\n\n    .. versionadded:: 2.1.0\n\n    :attr:`scroll_distance` is a NumericProperty and defaults to  20 pixels.\n    '''\n\n    scroll_timeout = NumericProperty(_scroll_timeout)\n    '''Timeout allowed to trigger the :attr:`scroll_distance`, in milliseconds.\n    If the user has not moved :attr:`scroll_distance` within the timeout, the\n    scrolling will be disabled, and the selection mode will start.\n\n    .. versionadded:: 2.1.0\n\n    :attr:`scroll_timeout` is a NumericProperty and defaults to 250\n    milliseconds.\n    '''\n\n    def get_sel_from(self):\n        return self._selection_from\n\n    selection_from = AliasProperty(get_sel_from, None)\n    '''If a selection is in progress or complete, this property will represent\n    the cursor index where the selection started.\n\n    .. versionchanged:: 1.4.0\n        :attr:`selection_from` is an :class:`~kivy.properties.AliasProperty`\n        and defaults to None, readonly.\n    '''\n\n    def get_sel_to(self):\n        return self._selection_to\n\n    selection_to = AliasProperty(get_sel_to, None)\n    '''If a selection is in progress or complete, this property will represent\n    the cursor index where the selection started.\n\n    .. versionchanged:: 1.4.0\n        :attr:`selection_to` is an :class:`~kivy.properties.AliasProperty` and\n        defaults to None, readonly.\n    '''\n\n    selection_text = StringProperty(u'')\n    '''Current content selection.\n\n    :attr:`selection_text` is a :class:`~kivy.properties.StringProperty`\n    and defaults to '', readonly.\n    '''\n\n    def on_selection_text(self, instance, value):\n        if value:\n            if self.use_handles:\n                self._trigger_show_handles()\n            if CutBuffer and not self.password:\n                self._trigger_update_cutbuffer()\n\n    def _get_text(self):\n        flags = self._lines_flags\n        lines = self._lines\n        len_lines = len(lines)\n        less_flags = len(flags) < len_lines\n        if less_flags:\n            flags.append(1)\n        text = ''.join(\n            ('\\n' if (flags[i] & FL_IS_LINEBREAK) else '') + lines[i]\n            for i in range(len_lines)\n        )\n        if less_flags:\n            flags.pop()\n        return text\n\n    def _set_text(self, text):\n        if isinstance(text, bytes):\n            text = text.decode('utf8')\n        if self.replace_crlf:\n            text = text.replace(u'\\r\\n', u'\\n')\n        if self.text != text:\n            self._refresh_text(text)\n            self.cursor = self.get_cursor_from_index(len(text))\n\n    text = AliasProperty(_get_text, _set_text, bind=('_lines',), cache=True)\n    '''Text of the widget.\n\n    Creation of a simple hello world::\n\n        widget = TextInput(text='Hello world')\n\n    If you want to create the widget with an unicode string, use::\n\n        widget = TextInput(text=u'My unicode string')\n\n    :attr:`text` is an :class:`~kivy.properties.AliasProperty`.\n    '''\n\n    font_name = StringProperty(DEFAULT_FONT)\n    '''Filename of the font to use. The path can be absolute or relative.\n    Relative paths are resolved by the :func:`~kivy.resources.resource_find`\n    function.\n\n    .. warning::\n\n        Depending on your text provider, the font file may be ignored. However,\n        you can mostly use this without problems.\n\n        If the font used lacks the glyphs for the particular language/symbols\n        you are using, you will see '[]' blank box characters instead of the\n        actual glyphs. The solution is to use a font that has the glyphs you\n        need to display. For example, to display |unicodechar|, use a font like\n        freesans.ttf that has the glyph.\n\n        .. |unicodechar| image:: images/unicode-char.png\n\n    :attr:`font_name` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'Roboto'. This value is taken\n    from :class:`~kivy.config.Config`.\n    '''\n\n    font_size = NumericProperty('15sp')\n    '''Font size of the text in pixels.\n\n    :attr:`font_size` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 15 :attr:`~kivy.metrics.sp`.\n    '''\n\n    font_context = StringProperty(None, allownone=True)\n    '''Font context. `None` means the font is used in isolation, so you are\n    guaranteed to be drawing with the TTF file resolved by :attr:`font_name`.\n    Specifying a value here will load the font file into a named context,\n    enabling fallback between all fonts in the same context. If a font\n    context is set, you are not guaranteed that rendering will actually use\n    the specified TTF file for all glyphs (Pango will pick the one it\n    thinks is best).\n\n    If Kivy is linked against a system-wide installation of FontConfig,\n    you can load the system fonts by specifying a font context starting\n    with the special string `system://`. This will load the system\n    fontconfig configuration, and add your application-specific fonts on\n    top of it (this imposes a significant risk of family name collision,\n    Pango may not use your custom font file, but pick one from the system)\n\n    .. note::\n        This feature requires the Pango text provider.\n\n    .. versionadded:: 1.10.1\n\n    :attr:`font_context` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    font_family = StringProperty(None, allownone=True)\n    '''Font family, this is only applicable when using :attr:`font_context`\n    option. The specified font family will be requested, but note that it may\n    not be available, or there could be multiple fonts registered with the\n    same family. The value can be a family name (string) available in the\n    font context (for example a system font in a `system://` context, or a\n    custom font file added using :class:`kivy.core.text.FontContextManager`).\n    If set to `None`, font selection is controlled by the :attr:`font_name`\n    setting.\n\n    .. note::\n        If using :attr:`font_name` to reference a custom font file, you\n        should leave this as `None`. The family name is managed automatically\n        in this case.\n\n    .. note::\n        This feature requires the Pango text provider.\n\n    .. versionadded:: 1.10.1\n\n    :attr:`font_family` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    base_direction = OptionProperty(\n        None,\n        options=['ltr', 'rtl', 'weak_rtl', 'weak_ltr', None],\n        allownone=True\n    )\n    '''Base direction of text, this impacts horizontal alignment when\n    :attr:`halign` is `auto` (the default). Available options are: None,\n    \"ltr\" (left to right), \"rtl\" (right to left) plus \"weak_ltr\" and\n    \"weak_rtl\".\n\n    .. note::\n        This feature requires the Pango text provider.\n\n    .. note::\n        Weak modes are currently not implemented in Kivy text layout, and\n        have the same effect as setting strong mode.\n\n    .. versionadded:: 1.10.1\n\n    :attr:`base_direction` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to None (autodetect RTL if possible, otherwise LTR).\n    '''\n\n    text_language = StringProperty(None, allownone=True)\n    '''Language of the text, if None Pango will determine it from locale.\n    This is an RFC-3066 format language tag (as a string), for example\n    \"en_US\", \"zh_CN\", \"fr\" or \"ja\". This can impact font selection, metrics\n    and rendering. For example, the same bytes of text can look different\n    for `ur` and `ar` languages, though both use Arabic script.\n\n    .. note::\n        This feature requires the Pango text provider.\n\n    .. versionadded:: 1.10.1\n\n    :attr:`text_language` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    _hint_text = StringProperty('')\n\n    def _set_hint_text(self, value):\n        if isinstance(value, bytes):\n            value = value.decode('utf8')\n        self._hint_text = value\n\n    def _get_hint_text(self):\n        return self._hint_text\n\n    hint_text = AliasProperty(\n        _get_hint_text, _set_hint_text, bind=('_hint_text', ))\n    '''Hint text of the widget, shown if text is ''.\n\n    .. versionadded:: 1.6.0\n\n    .. versionchanged:: 1.10.0\n        The property is now an AliasProperty and byte values are decoded to\n        strings. The hint text will stay visible when the widget is focused.\n\n    :attr:`hint_text` a :class:`~kivy.properties.AliasProperty` and defaults\n    to ''.\n    '''\n\n    hint_text_color = ColorProperty([0.5, 0.5, 0.5, 1.0])\n    '''Current color of the hint_text text, in (r, g, b, a) format.\n\n    .. versionadded:: 1.6.0\n\n    :attr:`hint_text_color` is a :class:`~kivy.properties.ColorProperty` and\n    defaults to [0.5, 0.5, 0.5, 1.0] (grey).\n\n    .. versionchanged:: 2.0.0\n        Changed from :class:`~kivy.properties.ListProperty` to\n        :class:`~kivy.properties.ColorProperty`.\n    '''\n\n    auto_indent = BooleanProperty(False)\n    '''Automatically indent multiline text.\n\n    .. versionadded:: 1.7.0\n\n    :attr:`auto_indent` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    replace_crlf = BooleanProperty(True)\n    '''Automatically replace CRLF with LF.\n\n    .. versionadded:: 1.9.1\n\n    :attr:`replace_crlf` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    allow_copy = BooleanProperty(True)\n    '''Decides whether to allow copying the text.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`allow_copy` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True.\n    '''\n\n    def _get_min_height(self):\n        return (\n            len(self._lines) * (self.line_height + self.line_spacing)\n            + self.padding[1]\n            + self.padding[3]\n        )\n\n    minimum_height = AliasProperty(\n        _get_min_height,\n        bind=(\n            '_lines', 'line_spacing', 'padding', 'font_size', 'font_name',\n            'password', 'font_context', 'hint_text', 'line_height'\n        ),\n        cache=True\n    )\n    '''Minimum height of the content inside the TextInput.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`minimum_height` is a readonly\n    :class:`~kivy.properties.AliasProperty`.\n\n    .. warning::\n        :attr:`minimum_width` is calculated based on :attr:`width` therefore\n        code like this will lead to an infinite loop::\n\n            <FancyTextInput>:\n                height: self.minimum_height\n                width: self.height\n    '''\n\n    line_spacing = NumericProperty(0)\n    '''Space taken up between the lines.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`line_spacing` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    lines_to_scroll = BoundedNumericProperty(3, min=1)\n    '''Set how many lines will be scrolled at once when using the mouse scroll\n    wheel.\n\n    .. versionadded:: 2.2.0\n\n    :attr:`lines_to_scroll is a\n    :class:`~kivy.properties.BoundedNumericProperty` and defaults to 3, the\n    minimum is 1.\n    '''\n\n    input_filter = ObjectProperty(None, allownone=True)\n    ''' Filters the input according to the specified mode, if not None. If\n    None, no filtering is applied.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`input_filter` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to `None`. Can be one of `None`, `'int'` (string), or `'float'`\n    (string), or a callable. If it is `'int'`, it will only accept numbers.\n    If it is `'float'` it will also accept a single period. Finally, if it is\n    a callable it will be called with two parameters; the string to be added\n    and a bool indicating whether the string is a result of undo (True). The\n    callable should return a new substring that will be used instead.\n    '''\n\n    handle_image_middle = StringProperty(\n        'atlas://data/images/defaulttheme/selector_middle')\n    '''Image used to display the middle handle on the TextInput for cursor\n    positioning.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`handle_image_middle` is a :class:`~kivy.properties.StringProperty`\n    and defaults to 'atlas://data/images/defaulttheme/selector_middle'.\n    '''\n\n    def on_handle_image_middle(self, instance, value):\n        if self._handle_middle:\n            self._handle_middle.source = value\n\n    handle_image_left = StringProperty(\n        'atlas://data/images/defaulttheme/selector_left')\n    '''Image used to display the Left handle on the TextInput for selection.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`handle_image_left` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'atlas://data/images/defaulttheme/selector_left'.\n    '''\n\n    def on_handle_image_left(self, instance, value):\n        if self._handle_left:\n            self._handle_left.source = value\n\n    handle_image_right = StringProperty(\n        'atlas://data/images/defaulttheme/selector_right')\n    '''Image used to display the Right handle on the TextInput for selection.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`handle_image_right` is a\n    :class:`~kivy.properties.StringProperty` and defaults to\n    'atlas://data/images/defaulttheme/selector_right'.\n    '''\n\n    def on_handle_image_right(self, instance, value):\n        if self._handle_right:\n            self._handle_right.source = value\n\n    write_tab = BooleanProperty(True)\n    '''Whether the tab key should move focus to the next widget or if it should\n    enter a tab in the :class:`TextInput`. If `True` a tab will be written,\n    otherwise, focus will move to the next widget.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`write_tab` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to `True`.\n    '''",
  "def triggered(*_, **__):\n        def decorator_func(func):\n            def decorated_func(*args, **kwargs):\n                return func(*args, **kwargs)\n            return decorated_func\n        return decorator_func",
  "def _textinput_clear_cache(*l):\n        Cache_remove('textinput.label')\n        Cache_remove('textinput.width')\n        for wr in _textinput_list[:]:\n            textinput = wr()\n            if textinput is None:\n                _textinput_list.remove(wr)\n            else:\n                textinput._trigger_refresh_text()\n                textinput._refresh_hint_text()",
  "def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.always_release = True\n        self.matrix = self.target.get_window_matrix()\n\n        with self.canvas.before:\n            Callback(self.update_transform)\n            PushMatrix()\n            self.transform = Transform()\n\n        with self.canvas.after:\n            PopMatrix()",
  "def update_transform(self, cb):\n        matrix = self.target.get_window_matrix()\n        if self.matrix != matrix:\n            self.matrix = matrix\n            self.transform.identity()\n            self.transform.transform(self.matrix)",
  "def transform_touch(self, touch):\n        matrix = self.matrix.inverse()\n        touch.apply_transform_2d(\n            lambda x, y: matrix.transform_point(x, y, 0)[:2]\n        )",
  "def on_touch_down(self, touch):\n        if self.parent is not EventLoop.window:\n            return\n\n        try:\n            touch.push()\n            self.transform_touch(touch)\n            self._touch_diff = self.top - touch.y\n            if self.collide_point(*touch.pos):\n                FocusBehavior.ignored_touch.append(touch)\n            return super().on_touch_down(touch)\n        finally:\n            touch.pop()",
  "def __init__(self, **kwargs):\n        self.mode = 'normal'\n        super().__init__(**kwargs)\n        self._check_parent_ev = Clock.schedule_interval(self._check_parent, .5)\n        self.matrix = self.textinput.get_window_matrix()\n\n        with self.canvas.before:\n            Callback(self.update_transform)\n            PushMatrix()\n            self.transform = Transform()\n\n        with self.canvas.after:\n            PopMatrix()",
  "def update_transform(self, cb):\n        m = self.textinput.get_window_matrix()\n        if self.matrix != m:\n            self.matrix = m\n            self.transform.identity()\n            self.transform.transform(self.matrix)",
  "def transform_touch(self, touch):\n        matrix = self.matrix.inverse()\n        touch.apply_transform_2d(\n            lambda x, y: matrix.transform_point(x, y, 0)[:2])",
  "def on_touch_down(self, touch):\n        try:\n            touch.push()\n            self.transform_touch(touch)\n            if self.collide_point(*touch.pos):\n                FocusBehavior.ignored_touch.append(touch)\n            return super().on_touch_down(touch)\n        finally:\n            touch.pop()",
  "def on_touch_up(self, touch):\n        try:\n            touch.push()\n            self.transform_touch(touch)\n            for child in self.content.children:\n                if ref(child) in touch.grab_list:\n                    touch.grab_current = child\n                    break\n            return super().on_touch_up(touch)\n        finally:\n            touch.pop()",
  "def on_textinput(self, instance, value):\n        global Clipboard\n        if value and not Clipboard and not _is_desktop:\n            value._ensure_clipboard()",
  "def _check_parent(self, dt):\n        # this is a prevention to get the Bubble staying on the screen, if the\n        # attached textinput is not on the screen anymore.\n        parent = self.textinput\n        while parent is not None:\n            if parent == parent.parent:\n                break\n            parent = parent.parent\n        if parent is None:\n            self._check_parent_ev.cancel()\n            if self.textinput:\n                self.textinput._hide_cut_copy_paste()",
  "def on_parent(self, instance, value):\n        parent = self.textinput\n        mode = self.mode\n\n        if parent:\n            self.content.clear_widgets()\n            if mode == 'paste':\n                # show only paste on long touch\n                self.but_selectall.opacity = 1\n                widget_list = [self.but_selectall, ]\n                if not parent.readonly:\n                    widget_list.append(self.but_paste)\n            elif parent.readonly:\n                # show only copy for read only text input\n                widget_list = (self.but_copy, )\n            else:\n                # normal mode\n                widget_list = (self.but_cut, self.but_copy, self.but_paste)\n\n            for widget in widget_list:\n                self.content.add_widget(widget)",
  "def do(self, action):\n        textinput = self.textinput\n\n        if action == 'cut':\n            textinput._cut(textinput.selection_text)\n        elif action == 'copy':\n            textinput.copy()\n        elif action == 'paste':\n            textinput.paste()\n        elif action == 'selectall':\n            textinput.select_all()\n            self.mode = ''\n            anim = Animation(opacity=0, d=.333)\n            anim.bind(on_complete=lambda *args:\n                      self.on_parent(self, self.parent))\n            anim.start(self.but_selectall)\n            return\n\n        self.hide()",
  "def hide(self):\n        parent = self.parent\n        if not parent:\n            return\n\n        anim = Animation(opacity=0, d=.225)\n        anim.bind(on_complete=lambda *args: parent.remove_widget(self))\n        anim.start(self)",
  "def __init__(self, **kwargs):\n        self._update_graphics_ev = Clock.create_trigger(\n            self._update_graphics, -1)\n        self.is_focusable = kwargs.get('is_focusable', True)\n        self._cursor = [0, 0]\n        self._selection = False\n        self._selection_finished = True\n        self._selection_touch = None\n        self.selection_text = u''\n        self._selection_from = None\n        self._selection_to = None\n        self._selection_callback = None\n        self._handle_left = None\n        self._handle_right = None\n        self._handle_middle = None\n        self._bubble = None\n        self._lines_flags = []\n        self._lines_labels = []\n        self._lines_rects = []\n        self._hint_text_flags = []\n        self._hint_text_labels = []\n        self._hint_text_rects = []\n        self._label_cached = None\n        self._line_options = None\n        self._keyboard_mode = Config.get('kivy', 'keyboard_mode')\n        self._command_mode = False\n        self._command = ''\n        self.reset_undo()\n        self._touch_count = 0\n        self._ctrl_l = False\n        self._ctrl_r = False\n        self._alt_l = False\n        self._alt_r = False\n        self._refresh_text_from_property_ev = None\n        self._long_touch_ev = None\n        self._do_blink_cursor_ev = Clock.create_trigger(\n            self._do_blink_cursor, .5, interval=True)\n        self._refresh_line_options_ev = None\n        self._scroll_distance_x = 0\n        self._scroll_distance_y = 0\n        self._enable_scroll = True\n        self._have_scrolled = False\n\n        # [from; to) range of lines being partially or fully rendered\n        # in TextInput's viewport\n        self._visible_lines_range = 0, 0\n\n        self.interesting_keys = {\n            8: 'backspace',\n            13: 'enter',\n            127: 'del',\n            271: 'enter',\n            273: 'cursor_up',\n            274: 'cursor_down',\n            275: 'cursor_right',\n            276: 'cursor_left',\n            278: 'cursor_home',\n            279: 'cursor_end',\n            280: 'cursor_pgup',\n            281: 'cursor_pgdown',\n            303: 'shift_L',\n            304: 'shift_R',\n            305: 'ctrl_L',\n            306: 'ctrl_R',\n            308: 'alt_L',\n            307: 'alt_R'\n        }\n\n        super().__init__(**kwargs)\n\n        fbind = self.fbind\n        refresh_line_options = self._trigger_refresh_line_options\n        update_text_options = self._update_text_options\n        trigger_update_graphics = self._trigger_update_graphics\n\n        fbind('font_size', refresh_line_options)\n        fbind('font_name', refresh_line_options)\n        fbind('font_context', refresh_line_options)\n        fbind('font_family', refresh_line_options)\n        fbind('base_direction', refresh_line_options)\n        fbind('text_language', refresh_line_options)\n\n        def handle_readonly(instance, value):\n            if value and (not _is_desktop or not self.allow_copy):\n                self.is_focusable = False\n            if (not (value or self.disabled) or _is_desktop and\n                    self._keyboard_mode == 'system'):\n                self._editable = True\n            else:\n                self._editable = False\n\n        fbind('padding', update_text_options)\n        fbind('tab_width', update_text_options)\n        fbind('font_size', update_text_options)\n        fbind('font_name', update_text_options)\n        fbind('size', update_text_options)\n        fbind('password', update_text_options)\n        fbind('password_mask', update_text_options)\n\n        fbind('pos', trigger_update_graphics)\n        fbind('halign', trigger_update_graphics)\n        fbind('readonly', handle_readonly)\n        fbind('focus', self._on_textinput_focused)\n        handle_readonly(self, self.readonly)\n\n        handles = self._trigger_position_handles = Clock.create_trigger(\n            self._position_handles)\n        self._trigger_show_handles = Clock.create_trigger(\n            self._show_handles, .05)\n        self._trigger_cursor_reset = Clock.create_trigger(\n            self._reset_cursor_blink)\n        self._trigger_update_cutbuffer = Clock.create_trigger(\n            self._update_cutbuffer)\n        refresh_line_options()\n        self._trigger_refresh_text()\n\n        fbind('pos', handles)\n        fbind('size', handles)\n\n        # when the gl context is reloaded, trigger the text rendering again.\n        _textinput_list.append(ref(self, TextInput._reload_remove_observer))\n\n        if platform == 'linux':\n            self._ensure_clipboard()",
  "def on_text_validate(self):\n        pass",
  "def cursor_index(self, cursor=None):\n        '''Return the cursor index in the text/value.\n        '''\n        if not cursor:\n            cursor = self.cursor\n        try:\n            lines = self._lines\n            if not lines:\n                return 0\n\n            flags = self._lines_flags\n            index, cursor_row = cursor\n\n            for _, line, flag in zip(\n                range(min(cursor_row, len(lines))),\n                lines,\n                flags\n            ):\n                index += len(line)\n                if flag & FL_IS_LINEBREAK:\n                    index += 1\n\n            if flags[cursor_row] & FL_IS_LINEBREAK:\n                index += 1\n            return index\n\n        except IndexError:\n            return 0",
  "def cursor_offset(self):\n        '''Get the cursor x offset on the current line.\n        '''\n        offset = 0\n        row = int(self.cursor_row)\n        col = int(self.cursor_col)\n        lines = self._lines\n        if col and row < len(lines):\n            offset = self._get_text_width(\n                lines[row][:col],\n                self.tab_width,\n                self._label_cached\n            )\n        return offset",
  "def get_cursor_from_index(self, index):\n        '''Return the (col, row) of the cursor from text index.\n        '''\n        index = boundary(index, 0, len(self.text))\n        if index <= 0:\n            return 0, 0\n        flags = self._lines_flags\n        lines = self._lines\n        if not lines:\n            return 0, 0\n\n        i = 0\n        for row, line in enumerate(lines):\n            count = i + len(line)\n            if flags[row] & FL_IS_LINEBREAK:\n                count += 1\n                i += 1\n            if count >= index:\n                return index - i, row\n            i = count\n        return int(index), int(row)",
  "def select_text(self, start, end):\n        ''' Select a portion of text displayed in this TextInput.\n\n        .. versionadded:: 1.4.0\n\n        :Parameters:\n            `start`\n                Index of textinput.text from where to start selection\n            `end`\n                Index of textinput.text till which the selection should be\n                displayed\n        '''\n        if end < start:\n            raise Exception('end must be superior to start')\n        text_length = len(self.text)\n        self._selection_from = boundary(start, 0, text_length)\n        self._selection_to = boundary(end, 0, text_length)\n        self._selection_finished = True\n        self._update_selection(True)\n        self._update_graphics_selection()",
  "def select_all(self):\n        ''' Select all of the text displayed in this TextInput.\n\n        .. versionadded:: 1.4.0\n        '''\n        self.select_text(0, len(self.text))",
  "def _auto_indent(self, substring):\n        index = self.cursor_index()\n        if index > 0:\n            _text = self.text\n            line_start = _text.rfind('\\n', 0, index)\n            if line_start > -1:\n                line = _text[line_start + 1:index]\n                indent = self.re_indent.match(line).group()\n                substring += indent\n        return substring",
  "def insert_text(self, substring, from_undo=False):\n        '''Insert new text at the current cursor position. Override this\n        function in order to pre-process text for input validation.\n        '''\n        _lines = self._lines\n        _lines_flags = self._lines_flags\n\n        if self.readonly or not substring or not self._lines:\n            return\n\n        if isinstance(substring, bytes):\n            substring = substring.decode('utf8')\n\n        if self.replace_crlf:\n            substring = substring.replace(u'\\r\\n', u'\\n')\n\n        self._hide_handles(EventLoop.window)\n\n        if not from_undo and self.multiline and self.auto_indent \\\n                and substring == u'\\n':\n            substring = self._auto_indent(substring)\n\n        mode = self.input_filter\n        if mode not in (None, 'int', 'float'):\n            substring = mode(substring, from_undo)\n            if not substring:\n                return\n\n        col, row = self.cursor\n        cindex = self.cursor_index()\n        text = _lines[row]\n        len_str = len(substring)\n        new_text = text[:col] + substring + text[col:]\n        if mode is not None:\n            if mode == 'int':\n                if not re.match(self._insert_int_pat, new_text):\n                    return\n            elif mode == 'float':\n                if not re.match(self._insert_float_pat, new_text):\n                    return\n        self._set_line_text(row, new_text)\n\n        if len_str > 1 or substring == u'\\n' or\\\n            (substring == u' ' and _lines_flags[row] != FL_IS_LINEBREAK) or\\\n            (row + 1 < len(_lines) and\n             _lines_flags[row + 1] != FL_IS_LINEBREAK) or\\\n            (self._get_text_width(\n                new_text,\n                self.tab_width,\n                self._label_cached) > (self.width - self.padding[0] -\n                                       self.padding[2])):\n            # Avoid refreshing text on every keystroke.\n            # Allows for faster typing of text when the amount of text in\n            # TextInput gets large.\n\n            (\n                start, finish, lines, lines_flags, len_lines\n            ) = self._get_line_from_cursor(row, new_text)\n\n            # calling trigger here could lead to wrong cursor positioning\n            # and repeating of text when keys are added rapidly in a automated\n            # fashion. From Android Keyboard for example.\n            self._refresh_text_from_property(\n                'insert', start, finish, lines, lines_flags, len_lines\n            )\n\n        self.cursor = self.get_cursor_from_index(cindex + len_str)\n        # handle undo and redo\n        self._set_unredo_insert(cindex, cindex + len_str, substring, from_undo)",
  "def _get_line_from_cursor(self, start, new_text, lines=None,\n                              lines_flags=None):\n        # get current paragraph from cursor position\n        if lines is None:\n            lines = self._lines\n        if lines_flags is None:\n            lines_flags = self._lines_flags\n        finish = start\n        _next = start + 1\n        if start > 0 and lines_flags[start] != FL_IS_LINEBREAK:\n            start -= 1\n            new_text = lines[start] + new_text\n        i = _next\n        for i in range(_next, len(lines_flags)):\n            if lines_flags[i] == FL_IS_LINEBREAK:\n                finish = i - 1\n                break\n        else:\n            finish = i\n\n        new_text = new_text + u''.join(lines[_next:finish + 1])\n        lines, lines_flags = self._split_smart(new_text)\n\n        len_lines = max(1, len(lines))\n        return start, finish, lines, lines_flags, len_lines",
  "def _set_unredo_insert(self, ci, sci, substring, from_undo):\n        # handle undo and redo\n        if from_undo:\n            return\n        self._undo.append({\n            'undo_command': ('insert', ci, sci),\n            'redo_command': (ci, substring)\n        })\n        # reset redo when undo is appended to\n        self._redo = []",
  "def reset_undo(self):\n        '''Reset undo and redo lists from memory.\n\n        .. versionadded:: 1.3.0\n\n        '''\n        self._redo = self._undo = []",
  "def do_redo(self):\n        '''Do redo operation.\n\n        .. versionadded:: 1.3.0\n\n        This action re-does any command that has been un-done by\n        do_undo/ctrl+z. This function is automatically called when\n        `ctrl+r` keys are pressed.\n        '''\n        try:\n            x_item = self._redo.pop()\n            undo_type = x_item['undo_command'][0]\n            _get_cusror_from_index = self.get_cursor_from_index\n\n            if undo_type == 'insert':\n                cindex, substring = x_item['redo_command']\n                self.cursor = _get_cusror_from_index(cindex)\n                self.insert_text(substring, True)\n            elif undo_type == 'bkspc':\n                self.cursor = _get_cusror_from_index(x_item['redo_command'])\n                self.do_backspace(from_undo=True)\n            elif undo_type == 'shiftln':\n                direction, rows, cursor = x_item['redo_command'][1:]\n                self._shift_lines(direction, rows, cursor, True)\n            else:\n                # delsel\n                cindex, scindex = x_item['redo_command']\n                self._selection_from = cindex\n                self._selection_to = scindex\n                self._selection = True\n                self.delete_selection(True)\n                self.cursor = _get_cusror_from_index(cindex)\n            self._undo.append(x_item)\n        except IndexError:\n            # reached at top of undo list\n            pass",
  "def do_undo(self):\n        '''Do undo operation.\n\n        .. versionadded:: 1.3.0\n\n        This action un-does any edits that have been made since the last\n        call to reset_undo().\n        This function is automatically called when `ctrl+z` keys are pressed.\n        '''\n        try:\n            x_item = self._undo.pop()\n            undo_type = x_item['undo_command'][0]\n            self.cursor = self.get_cursor_from_index(x_item['undo_command'][1])\n\n            if undo_type == 'insert':\n                cindex, scindex = x_item['undo_command'][1:]\n                self._selection_from = cindex\n                self._selection_to = scindex\n                self._selection = True\n                self.delete_selection(True)\n            elif undo_type == 'bkspc':\n                substring = x_item['undo_command'][2][0]\n                mode = x_item['undo_command'][3]\n                self.insert_text(substring, True)\n                if mode == 'del':\n                    self.cursor = self.get_cursor_from_index(\n                        self.cursor_index() - 1)\n            elif undo_type == 'shiftln':\n                direction, rows, cursor = x_item['undo_command'][1:]\n                self._shift_lines(direction, rows, cursor, True)\n            else:\n                # delsel\n                substring = x_item['undo_command'][2:][0]\n                self.insert_text(substring, True)\n            self._redo.append(x_item)\n        except IndexError:\n            # reached at top of undo list\n            pass",
  "def do_backspace(self, from_undo=False, mode='bkspc'):\n        '''Do backspace operation from the current cursor position.\n        This action might do several things:\n\n            - removing the current selection if available.\n            - removing the previous char and move the cursor back.\n            - do nothing, if we are at the start.\n\n        '''\n        # IME system handles its own backspaces\n        if self.readonly or self._ime_composition:\n            return\n        col, row = self.cursor\n        _lines = self._lines\n        _lines_flags = self._lines_flags\n        text = _lines[row]\n        cursor_index = self.cursor_index()\n\n        if col == 0 and row == 0:\n            return\n        start = row\n        if col == 0:\n            if _lines_flags[row] == FL_IS_LINEBREAK:\n                substring = u'\\n'\n                new_text = _lines[row - 1] + text\n            else:\n                substring = _lines[row - 1][-1] if len(_lines[row - 1]) > 0 \\\n                    else u''\n                new_text = _lines[row - 1][:-1] + text\n            self._set_line_text(row - 1, new_text)\n            self._delete_line(row)\n            start = row - 1\n        else:\n            # ch = text[col-1]\n            substring = text[col - 1]\n            new_text = text[:col - 1] + text[col:]\n            self._set_line_text(row, new_text)\n\n        # refresh just the current line instead of the whole text\n        start, finish, lines, lineflags, len_lines = (\n            self._get_line_from_cursor(start, new_text)\n        )\n        # avoid trigger refresh, leads to issue with\n        # keys/text send rapidly through code.\n        self._refresh_text_from_property(\n            'insert' if col == 0 else 'del', start, finish,\n            lines, lineflags, len_lines\n        )\n\n        self.cursor = self.get_cursor_from_index(cursor_index - 1)\n        # handle undo and redo\n        self._set_unredo_bkspc(\n            cursor_index,\n            cursor_index - 1,\n            substring, from_undo, mode)",
  "def _set_unredo_bkspc(self, ol_index, new_index, substring, from_undo,\n                          mode):\n        # handle undo and redo for backspace\n        if from_undo:\n            return\n        self._undo.append({\n            'undo_command': ('bkspc', new_index, substring, mode),\n            'redo_command': ol_index})\n        # reset redo when undo is appended to\n        self._redo = []",
  "def _move_cursor_word_left(self, index=None):\n        pos = index or self.cursor_index()\n        if pos == 0:\n            return self.cursor\n        lines = self._lines\n        col, row = self.get_cursor_from_index(pos)\n        if col == 0:\n            row -= 1\n            col = len(lines[row])\n\n        while True:\n            matches = list(self._re_whitespace.finditer(lines[row], 0, col))\n            if not matches:\n                if col == 0:\n                    if row == 0:\n                        return 0, 0\n                    row -= 1\n                    col = len(lines[row])\n                    continue\n                return 0, row\n\n            match = matches[-1]\n            mpos = match.end()\n            if mpos == col:\n                if len(matches) > 1:\n                    match = matches[-2]\n                    mpos = match.end()\n                else:\n                    if match.start() == 0:\n                        if row == 0:\n                            return 0, 0\n                        row -= 1\n                        col = len(lines[row])\n                        continue\n                    return 0, row\n            col = mpos\n            return col, row",
  "def _move_cursor_word_right(self, index=None):\n        pos = index or self.cursor_index()\n        col, row = self.get_cursor_from_index(pos)\n        lines = self._lines\n        mrow = len(lines) - 1\n        if row == mrow and col == len(lines[row]):\n            return col, row\n        if col == len(lines[row]):\n            row += 1\n            col = 0\n\n        while True:\n            matches = list(self._re_whitespace.finditer(lines[row], col))\n            if not matches:\n                if col == len(lines[row]):\n                    if row == mrow:\n                        return col, row\n                    row += 1\n                    col = 0\n                    continue\n                return len(lines[row]), row\n\n            match = matches[0]\n            mpos = match.start()\n            if mpos == col:\n                if len(matches) > 1:\n                    match = matches[1]\n                    mpos = match.start()\n                else:\n                    if match.end() == len(lines[row]):\n                        if row == mrow:\n                            return col, row\n                        row += 1\n                        col = 0\n                        continue\n                    return len(lines[row]), row\n            col = mpos\n            return col, row",
  "def _expand_range(self, ifrom, ito=None):\n        if ito is None:\n            ito = ifrom\n        rfrom = self.get_cursor_from_index(ifrom)[1]\n        rtcol, rto = self.get_cursor_from_index(ito)\n        rfrom, rto = self._expand_rows(rfrom, rto + 1 if rtcol else rto)\n\n        return (self.cursor_index((0, rfrom)),\n                self.cursor_index((0, rto)))",
  "def _expand_rows(self, rfrom, rto=None):\n        if rto is None or rto == rfrom:\n            rto = rfrom + 1\n        lines = self._lines\n        flags = list(reversed(self._lines_flags))\n        while rfrom > 0 and not (flags[rfrom - 1] & FL_IS_NEWLINE):\n            rfrom -= 1\n        rmax = len(lines) - 1\n        while 0 < rto < rmax and not (flags[rto - 1] & FL_IS_NEWLINE):\n            rto += 1\n        return max(0, rfrom), min(rmax, rto)",
  "def _shift_lines(\n        self, direction, rows=None, old_cursor=None, from_undo=False\n    ):\n        if self._selection_callback:\n            if from_undo:\n                self._selection_callback.cancel()\n            else:\n                return\n\n        lines = self._lines\n        flags = list(reversed(self._lines_flags))\n        labels = self._lines_labels\n        rects = self._lines_rects\n        orig_cursor = self.cursor\n        sel = None\n        if old_cursor is not None:\n            self.cursor = old_cursor\n\n        if not rows:\n            sindex = self.selection_from\n            eindex = self.selection_to\n            if (sindex or eindex) and sindex != eindex:\n                sindex, eindex = tuple(sorted((sindex, eindex)))\n                sindex, eindex = self._expand_range(sindex, eindex)\n            else:\n                sindex, eindex = self._expand_range(self.cursor_index())\n            srow = self.get_cursor_from_index(sindex)[1]\n            erow = self.get_cursor_from_index(eindex)[1]\n            sel = sindex, eindex\n\n            if direction < 0 and srow > 0:\n                psrow, perow = self._expand_rows(srow - 1)\n                rows = ((srow, erow), (psrow, perow))\n            elif direction > 0 and erow < len(lines) - 1:\n                psrow, perow = self._expand_rows(erow)\n                rows = ((srow, erow), (psrow, perow))\n\n        else:\n            (srow, erow), (psrow, perow) = rows\n            if direction < 0:\n                m1srow, m1erow = psrow, perow\n                m2srow, m2erow = srow, erow\n                cdiff = psrow - perow\n                xdiff = srow - erow\n            else:\n                m1srow, m1erow = srow, erow\n                m2srow, m2erow = psrow, perow\n                cdiff = perow - psrow\n                xdiff = erow - srow\n\n            self._lines_flags = list(reversed(chain(\n                flags[:m1srow],\n                flags[m2srow:m2erow],\n                flags[m1srow:m1erow],\n                flags[m2erow:],\n            )))\n            self._lines[:] = (\n                lines[:m1srow]\n                + lines[m2srow:m2erow]\n                + lines[m1srow:m1erow]\n                + lines[m2erow:]\n            )\n            self._lines_labels = (\n                labels[:m1srow]\n                + labels[m2srow:m2erow]\n                + labels[m1srow:m1erow]\n                + labels[m2erow:]\n            )\n            self._lines_rects = (\n                rects[:m1srow]\n                + rects[m2srow:m2erow]\n                + rects[m1srow:m1erow]\n                + rects[m2erow:]\n            )\n            self._trigger_update_graphics()\n            csrow = srow + cdiff\n            cerow = erow + cdiff\n            sel = (\n                self.cursor_index((0, csrow)),\n                self.cursor_index((0, cerow))\n            )\n            self.cursor = self.cursor_col, self.cursor_row + cdiff\n\n            if not from_undo:\n                undo_rows = ((srow + cdiff, erow + cdiff),\n                             (psrow - xdiff, perow - xdiff))\n                self._undo.append({\n                    'undo_command': ('shiftln', direction * -1, undo_rows,\n                                     self.cursor),\n                    'redo_command': ('shiftln', direction, rows, orig_cursor),\n                })\n                self._redo = []\n\n        if sel:\n            def cb(dt):\n                self.select_text(*sel)\n                self._selection_callback = None\n            self._selection_callback = Clock.schedule_once(cb)",
  "def pgmove_speed(self):\n        \"\"\"how much vertical distance hitting pg_up or pg_down will move\n        \"\"\"\n        return int(\n            self.height\n            / (self.line_height + self.line_spacing) - 1\n        )",
  "def _move_cursor_up(self, col, row, control=False, alt=False):\n        if self.multiline and control:\n            self.scroll_y = max(0, self.scroll_y - self.line_height)\n        elif not self.readonly and self.multiline and alt:\n            self._shift_lines(-1)\n            return\n        else:\n            row = max(row - 1, 0)\n            col = min(len(self._lines[row]), col)\n\n        return col, row",
  "def _move_cursor_down(self, col, row, control, alt):\n        if self.multiline and control:\n            maxy = self.minimum_height - self.height\n            self.scroll_y = max(\n                0,\n                min(maxy, self.scroll_y + self.line_height)\n            )\n        elif not self.readonly and self.multiline and alt:\n            self._shift_lines(1)\n            return\n        else:\n            row = min(row + 1, len(self._lines) - 1)\n            col = min(len(self._lines[row]), col)\n\n        return col, row",
  "def do_cursor_movement(self, action, control=False, alt=False):\n        '''Move the cursor relative to its current position.\n        Action can be one of :\n\n            - cursor_left: move the cursor to the left\n            - cursor_right: move the cursor to the right\n            - cursor_up: move the cursor on the previous line\n            - cursor_down: move the cursor on the next line\n            - cursor_home: move the cursor at the start of the current line\n            - cursor_end: move the cursor at the end of current line\n            - cursor_pgup: move one \"page\" before\n            - cursor_pgdown: move one \"page\" after\n\n        In addition, the behavior of certain actions can be modified:\n\n            - control + cursor_left: move the cursor one word to the left\n            - control + cursor_right: move the cursor one word to the right\n            - control + cursor_up: scroll up one line\n            - control + cursor_down: scroll down one line\n            - control + cursor_home: go to beginning of text\n            - control + cursor_end: go to end of text\n            - alt + cursor_up: shift line(s) up\n            - alt + cursor_down: shift line(s) down\n\n        .. versionchanged:: 1.9.1\n\n        '''\n        if not self._lines:\n            return\n\n        col, row = self.cursor\n        if action == 'cursor_up':\n            result = self._move_cursor_up(col, row, control, alt)\n            if result:\n                col, row = result\n            else:\n                return\n\n        elif action == 'cursor_down':\n            result = self._move_cursor_down(col, row, control, alt)\n            if result:\n                col, row = result\n            else:\n                return\n\n        elif action == 'cursor_home':\n            col = 0\n            if control:\n                row = 0\n\n        elif action == 'cursor_end':\n            if control:\n                row = len(self._lines) - 1\n            col = len(self._lines[row])\n\n        elif action == 'cursor_pgup':\n            row = max(0, row - self.pgmove_speed)\n            col = min(len(self._lines[row]), col)\n\n        elif action == 'cursor_pgdown':\n            row = min(row + self.pgmove_speed, len(self._lines) - 1)\n            col = min(len(self._lines[row]), col)\n\n        elif (\n            self._selection and self._selection_finished\n            and self._selection_from < self._selection_to\n            and action == 'cursor_left'\n        ):\n            current_selection_to = self._selection_to\n            while self._selection_from != current_selection_to:\n                current_selection_to -= 1\n                if col:\n                    col -= 1\n                else:\n                    row -= 1\n                    col = len(self._lines[row])\n\n        elif (\n            self._selection and self._selection_finished\n            and self._selection_from > self._selection_to\n            and action == 'cursor_right'\n        ):\n            current_selection_to = self._selection_to\n            while self._selection_from != current_selection_to:\n                current_selection_to += 1\n                if len(self._lines[row]) > col:\n                    col += 1\n                else:\n                    row += 1\n                    col = 0\n\n        elif action == 'cursor_left':\n            if not self.password and control:\n                col, row = self._move_cursor_word_left()\n            else:\n                if col == 0:\n                    if row:\n                        row -= 1\n                        col = len(self._lines[row])\n                else:\n                    col, row = col - 1, row\n\n        elif action == 'cursor_right':\n            if not self.password and control:\n                col, row = self._move_cursor_word_right()\n            else:\n                if col == len(self._lines[row]):\n                    if row < len(self._lines) - 1:\n                        col = 0\n                        row += 1\n                else:\n                    col, row = col + 1, row\n\n        dont_move_cursor = control and action in ['cursor_up', 'cursor_down']\n        if dont_move_cursor:\n            self._trigger_update_graphics()\n        else:\n            self.cursor = col, row",
  "def get_cursor_from_xy(self, x, y):\n        '''Return the (col, row) of the cursor from an (x, y) position.\n        '''\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n\n        lines = self._lines\n        dy = self.line_height + self.line_spacing\n        cursor_x = x - self.x\n        scroll_y = self.scroll_y\n        scroll_x = self.scroll_x\n        scroll_y = scroll_y / dy if scroll_y > 0 else 0\n\n        cursor_y = (self.top - padding_top + scroll_y * dy) - y\n        cursor_y = int(boundary(\n            round(cursor_y / dy - 0.5),\n            0,\n            len(lines) - 1\n        ))\n\n        get_text_width = self._get_text_width\n        tab_width = self.tab_width\n        label_cached = self._label_cached\n\n        # Offset for horizontal text alignment\n        xoff = 0\n        halign = self.halign\n        base_dir = self.base_direction or self._resolved_base_dir\n        auto_halign_r = halign == 'auto' and base_dir and 'rtl' in base_dir\n\n        if halign == 'center':\n            viewport_width = self.width - padding_left - padding_right\n            xoff = max(\n                0, int((viewport_width - self._get_row_width(cursor_y)) / 2)\n            )\n\n        elif halign == 'right' or auto_halign_r:\n            viewport_width = self.width - padding_left - padding_right\n            xoff = max(\n                0, int(viewport_width - self._get_row_width(cursor_y))\n            )\n\n        for i in range(0, len(lines[cursor_y])):\n            line_y = lines[cursor_y]\n\n            if cursor_x + scroll_x < (\n                xoff\n                + get_text_width(line_y[:i], tab_width, label_cached)\n                + get_text_width(line_y[i], tab_width, label_cached) * 0.6\n                + padding_left\n            ):\n                cursor_x = i\n                break\n        else:\n            cursor_x = len(lines[cursor_y])\n\n        return cursor_x, cursor_y",
  "def cancel_selection(self):\n        '''Cancel current selection (if any).\n        '''\n        self._selection_from = self._selection_to = self.cursor_index()\n        self._selection = False\n        self._selection_finished = True\n        self._selection_touch = None\n        self.selection_text = u''\n        self._trigger_update_graphics()",
  "def delete_selection(self, from_undo=False):\n        '''Delete the current text selection (if any).\n        '''\n        if self.readonly:\n            return\n        self._hide_handles(EventLoop.window)\n        scroll_x = self.scroll_x\n        scroll_y = self.scroll_y\n        cc, cr = self.cursor\n        if not self._selection:\n            return\n        text = self.text\n        a, b = sorted((self._selection_from, self._selection_to))\n\n        start = self.get_cursor_from_index(a)\n        finish = self.get_cursor_from_index(b)\n        cur_line = self._lines[start[1]][:start[0]] +\\\n            self._lines[finish[1]][finish[0]:]\n\n        self._set_line_text(start[1], cur_line)\n        start_del, finish_del, lines, lines_flags, len_lines = \\\n            self._get_line_from_cursor(start[1], cur_line,\n                                       lines=(self._lines[:(start[1] + 1)] +\n                                              self._lines[(finish[1] + 1):]),\n                                       lines_flags=(\n                                           self._lines_flags[:(start[1] + 1)] +\n                                           self._lines_flags[(finish[1] + 1):])\n                                       )\n        self._refresh_text_from_property('del', start_del,\n                                         finish_del + (finish[1] - start[1]),\n                                         lines, lines_flags, len_lines)\n\n        self.scroll_x = scroll_x\n        self.scroll_y = scroll_y\n        # handle undo and redo for delete selection\n        if text[a:b]:\n            self._set_unredo_delsel(a, b, text[a:b], from_undo)\n        self.cancel_selection()\n        self.cursor = self.get_cursor_from_index(a)",
  "def _set_unredo_delsel(self, a, b, substring, from_undo):\n        # handle undo and redo for backspace\n        if from_undo:\n            return\n\n        self._undo.append({\n            'undo_command': ('delsel', a, substring),\n            'redo_command': (a, b)})\n        # reset redo when undo is appended to\n        self._redo = []",
  "def _update_selection(self, finished=False):\n        '''Update selection text and order of from/to if finished is True.\n        Can be called multiple times until finished is True.\n        '''\n        a, b = int(self._selection_from), int(self._selection_to)\n        if a > b:\n            a, b = b, a\n        self._selection_finished = finished\n        _selection_text = self.text[a:b]\n        self.selection_text = (\"\" if not self.allow_copy else\n                               ((self.password_mask * (b - a)) if\n                                self.password else _selection_text))\n        if not finished:\n            self._selection = True\n        else:\n            self._selection = bool(len(_selection_text))\n            self._selection_touch = None\n        if a == 0:\n            # update graphics only on new line\n            # allows smoother scrolling, noticeably\n            # faster when dealing with large text.\n            self._update_graphics_selection()",
  "def long_touch(self, dt):\n        self._long_touch_ev = None\n        if self._selection_to == self._selection_from:\n            pos = self.to_local(*self._touch_down.pos, relative=False)\n            self._show_cut_copy_paste(\n                pos, EventLoop.window, mode='paste')",
  "def cancel_long_touch_event(self):\n        # schedule long touch for paste\n        if self._long_touch_ev is not None:\n            self._long_touch_ev.cancel()\n            self._long_touch_ev = None",
  "def _select_word(self, delimiters=u' .,:;!?\\'\"<>()[]{}'):\n        cindex = self.cursor_index()\n        col = self.cursor_col\n        line = self._lines[self.cursor_row]\n        start = max(0, len(line[:col]) -\n                    max(line[:col].rfind(s) for s in delimiters) - 1)\n        end = min((line[col:].find(s) if line[col:].find(s) > -1\n                   else (len(line) - col)) for s in delimiters)\n        Clock.schedule_once(lambda dt: self.select_text(cindex - start,\n                                                        cindex + end))",
  "def on_double_tap(self):\n        '''This event is dispatched when a double tap happens\n        inside TextInput. The default behavior is to select the\n        word around the current cursor position. Override this to provide\n        different behavior. Alternatively, you can bind to this\n        event to provide additional functionality.\n        '''\n        self._select_word()",
  "def on_triple_tap(self):\n        '''This event is dispatched when a triple tap happens\n        inside TextInput. The default behavior is to select the\n        line around current cursor position. Override this to provide\n        different behavior. Alternatively, you can bind to this\n        event to provide additional functionality.\n        '''\n        ci = self.cursor_index()\n        sindex, eindex = self._expand_range(ci)\n        Clock.schedule_once(lambda dt: self.select_text(sindex, eindex))",
  "def on_quad_touch(self):\n        '''This event is dispatched when four fingers are touching\n        inside TextInput. The default behavior is to select all text.\n        Override this to provide different behavior. Alternatively,\n        you can bind to this event to provide additional functionality.\n        '''\n        Clock.schedule_once(lambda dt: self.select_all())",
  "def on_touch_down(self, touch):\n        if self.disabled:\n            return\n\n        touch_pos = touch.pos\n        if not self.collide_point(*touch_pos):\n            return False\n        if super().on_touch_down(touch):\n            return True\n\n        if self.focus:\n            self._trigger_cursor_reset()\n\n        # Check for scroll wheel\n        if 'button' in touch.profile and touch.button.startswith('scroll'):\n            # TODO: implement 'scrollleft' and 'scrollright'\n            scroll_type = touch.button[6:]\n            if scroll_type == 'down':\n                if self.multiline:\n                    if self.scroll_y > 0:\n                        self.scroll_y = max(0,\n                                            self.scroll_y - self.line_height *\n                                            self.lines_to_scroll)\n                        self._trigger_update_graphics()\n                else:\n                    if self.scroll_x > 0:\n                        self.scroll_x = max(0, self.scroll_x -\n                                            self.line_height)\n                        self._trigger_update_graphics()\n            if scroll_type == 'up':\n                if self.multiline:\n                    max_scroll_y = max(0, self.minimum_height - self.height)\n                    if self.scroll_y < max_scroll_y:\n                        self.scroll_y = min(max_scroll_y,\n                                            self.scroll_y + self.line_height *\n                                            self.lines_to_scroll)\n                        self._trigger_update_graphics()\n                else:\n                    minimum_width = (self._get_row_width(0) + self.padding[0] +\n                                     self.padding[2])\n                    max_scroll_x = max(0, minimum_width - self.width)\n                    if self.scroll_x < max_scroll_x:\n                        self.scroll_x = min(max_scroll_x, self.scroll_x +\n                                            self.line_height)\n                        self._trigger_update_graphics()\n            return True\n\n        touch.grab(self)\n        self._touch_count += 1\n        if touch.is_double_tap:\n            self.dispatch('on_double_tap')\n        if touch.is_triple_tap:\n            self.dispatch('on_triple_tap')\n        if self._touch_count == 4:\n            self.dispatch('on_quad_touch')\n\n        # stores the touch for later use\n        self._touch_down = touch\n\n        # Is a new touch_down, so previous scroll states needs to be reset\n        self._enable_scroll = True\n        self._have_scrolled = False\n        self._scroll_distance_x = 0\n        self._scroll_distance_y = 0\n\n        self._hide_cut_copy_paste(EventLoop.window)\n        # schedule long touch for paste\n        self._long_touch_ev = Clock.schedule_once(self.long_touch, .5)\n\n        self.cursor = self.get_cursor_from_xy(*touch_pos)\n        if not self.scroll_from_swipe:\n            self._cancel_update_selection(self._touch_down)\n\n        if CutBuffer and 'button' in touch.profile and \\\n                touch.button == 'middle':\n            self.insert_text(CutBuffer.get_cutbuffer())\n            return True\n\n        return True",
  "def _cancel_update_selection(self, touch):\n        if not self._selection_touch:\n            self.cancel_selection()\n            self._selection_touch = touch\n            self._selection_from = self._selection_to = self.cursor_index()\n            self._update_selection()",
  "def on_touch_move(self, touch):\n        if touch.grab_current is not self:\n            return\n        if not self.focus:\n            touch.ungrab(self)\n            if self._selection_touch is touch:\n                self._selection_touch = None\n            return False\n\n        if self.scroll_from_swipe:\n            self.scroll_text_from_swipe(touch)\n\n        if not self._have_scrolled and self._selection_touch is touch:\n            self.cursor = self.get_cursor_from_xy(touch.x, touch.y)\n            self._selection_to = self.cursor_index()\n            self._update_selection()\n            return True",
  "def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return\n        touch.ungrab(self)\n        self._touch_count -= 1\n\n        self.cancel_long_touch_event()\n\n        if not self.focus:\n            return False\n\n        # types of touch that will have higher priority in being recognized,\n        # compared to single tap\n        prioritized_touch_types = (\n            touch.is_double_tap\n            or touch.is_triple_tap\n            or self._touch_count == 4\n        )\n\n        if not self._have_scrolled and not prioritized_touch_types:\n            # Is a single tap and did not scrolled.\n            # Selection needs to be canceled.\n            self._cancel_update_selection(self._touch_down)\n\n        # show Bubble\n        win = EventLoop.window\n        if self._selection_to != self._selection_from:\n            self._show_cut_copy_paste(touch.pos, win)\n\n        if self._selection_touch is touch:\n            self._selection_to = self.cursor_index()\n            self._update_selection(True)\n            if self.use_handles and self._selection_to == self._selection_from:\n                self._hide_handles()\n                handle_middle = self._handle_middle\n                if handle_middle is None:\n                    self._handle_middle = handle_middle = Selector(\n                        source=self.handle_image_middle,\n                        window=win,\n                        target=self,\n                        size_hint=(None, None),\n                        size=('45dp', '45dp'))\n                    handle_middle.bind(on_press=self._handle_pressed,\n                                       on_touch_move=self._handle_move,\n                                       on_release=self._handle_released)\n                if not self._handle_middle.parent and self.text:\n                    EventLoop.window.add_widget(handle_middle, canvas='after')\n                self._position_handles(mode='middle')\n            return True",
  "def scroll_text_from_swipe(self, touch):\n        _scroll_timeout = (touch.time_update - touch.time_start) * 1000\n        self._scroll_distance_x += abs(touch.dx)\n        self._scroll_distance_y += abs(touch.dy)\n        if not self._have_scrolled:\n            # To be considered a scroll, touch should travel more than\n            # scroll_distance in less than the scroll_timeout since touch_down\n            if not (\n                _scroll_timeout <= self.scroll_timeout\n                and (\n                    (self._scroll_distance_x >= self.scroll_distance)\n                    or (self._scroll_distance_y >= self.scroll_distance)\n                )\n            ):\n                # Distance isn't enough (yet) to consider it as a scroll\n                if _scroll_timeout <= self.scroll_timeout:\n                    # Timeout is not reached, scroll is still enabled.\n                    return False\n                else:\n                    self._enable_scroll = False\n                    self._cancel_update_selection(self._touch_down)\n                    return False\n            # We have a scroll!\n            self._have_scrolled = True\n\n        self.cancel_long_touch_event()\n\n        if self.multiline:\n            max_scroll_y = max(0, self.minimum_height - self.height)\n            self.scroll_y = min(\n                max(0, self.scroll_y + touch.dy),\n                max_scroll_y\n            )\n        else:\n            minimum_width = (\n                self._get_row_width(0)\n                + self.padding[0] + self.padding[2]\n            )\n            max_scroll_x = max(0, minimum_width - self.width)\n            self.scroll_x = min(\n                max(0, self.scroll_x - touch.dx),\n                max_scroll_x\n            )\n        self._trigger_update_graphics()\n        self._position_handles()\n        return True",
  "def _handle_pressed(self, instance):\n        self._hide_cut_copy_paste()\n        from_, to_ = self._selection_from, self.selection_to\n        if from_ > to_:\n            self._selection_from, self._selection_to = to_, from_",
  "def _handle_released(self, instance):\n        if self._selection_from == self.selection_to:\n            return\n\n        self._update_selection()\n        self._show_cut_copy_paste(\n            (\n                self.x + instance.right\n                if instance is self._handle_left\n                else self.x + instance.x,\n                self.y + instance.top + self.line_height\n            ),\n            EventLoop.window\n        )",
  "def _handle_move(self, instance, touch):\n        if touch.grab_current != instance:\n            return\n        get_cursor = self.get_cursor_from_xy\n        handle_right = self._handle_right\n        handle_left = self._handle_left\n        handle_middle = self._handle_middle\n\n        try:\n            touch.push()\n            touch.apply_transform_2d(self.to_widget)\n            x, y = touch.pos\n        finally:\n            touch.pop()\n\n        cursor = get_cursor(\n            x,\n            y + instance._touch_diff + (self.line_height / 2)\n        )\n        self.cursor = cursor\n\n        if instance != touch.grab_current:\n            return\n\n        if instance == handle_middle:\n            self._position_handles(mode='middle')\n            return\n\n        cindex = self.cursor_index()\n\n        if instance == handle_left:\n            self._selection_from = cindex\n        elif instance == handle_right:\n            self._selection_to = cindex\n        self._update_selection()\n        self._trigger_update_graphics()\n        self._trigger_position_handles()",
  "def _position_handles(self, *args, **kwargs):\n        if not self.text:\n            return\n        mode = kwargs.get('mode', 'both')\n\n        lh = self.line_height\n\n        handle_middle = self._handle_middle\n        if handle_middle:\n            hp_mid = self.cursor_pos\n            pos = self.to_local(*hp_mid, relative=True)\n            handle_middle.x = pos[0] - handle_middle.width / 2\n            handle_middle.top = max(self.padding[3],\n                                    min(self.height - self.padding[1],\n                                        pos[1] - lh))\n        if mode[0] == 'm':\n            return\n\n        group = self.canvas.get_group('selection')\n        if not group:\n            return\n\n        EventLoop.window.remove_widget(self._handle_middle)\n\n        handle_left = self._handle_left\n        if not handle_left:\n            return\n        hp_left = group[2].pos\n        handle_left.pos = self.to_local(*hp_left, relative=True)\n        handle_left.x -= handle_left.width\n        handle_left.y -= handle_left.height\n\n        handle_right = self._handle_right\n        last_rect = group[-1]\n        hp_right = last_rect.pos[0], last_rect.pos[1]\n        x, y = self.to_local(*hp_right, relative=True)\n        handle_right.x = x + last_rect.size[0]\n        handle_right.y = y - handle_right.height",
  "def _hide_handles(self, win=None):\n        win = win or EventLoop.window\n        if win is None:\n            return\n        win.remove_widget(self._handle_right)\n        win.remove_widget(self._handle_left)\n        win.remove_widget(self._handle_middle)",
  "def _show_handles(self, dt):\n        if not self.use_handles or not self.text:\n            return\n\n        win = EventLoop.window\n\n        handle_right = self._handle_right\n        handle_left = self._handle_left\n        if self._handle_left is None:\n            self._handle_left = handle_left = Selector(\n                source=self.handle_image_left,\n                target=self,\n                window=win,\n                size_hint=(None, None),\n                size=('45dp', '45dp'))\n            handle_left.bind(on_press=self._handle_pressed,\n                             on_touch_move=self._handle_move,\n                             on_release=self._handle_released)\n            self._handle_right = handle_right = Selector(\n                source=self.handle_image_right,\n                target=self,\n                window=win,\n                size_hint=(None, None),\n                size=('45dp', '45dp'))\n            handle_right.bind(on_press=self._handle_pressed,\n                              on_touch_move=self._handle_move,\n                              on_release=self._handle_released)\n        else:\n            if self._handle_left.parent:\n                self._position_handles()\n                return\n            if not self.parent:\n                return\n\n        self._trigger_position_handles()\n        if self.selection_from != self.selection_to:\n            self._handle_left.opacity = self._handle_right.opacity = 0\n            win.add_widget(self._handle_left, canvas='after')\n            win.add_widget(self._handle_right, canvas='after')\n            anim = Animation(opacity=1, d=.4)\n            anim.start(self._handle_right)\n            anim.start(self._handle_left)",
  "def _show_cut_copy_paste(\n        self, pos, win, parent_changed=False, mode='', pos_in_window=False, *l\n    ):\n        \"\"\"Show a bubble with cut copy and paste buttons\"\"\"\n        if not self.use_bubble:\n            return\n\n        bubble = self._bubble\n        if bubble is None:\n            self._bubble = bubble = TextInputCutCopyPaste(textinput=self)\n            self.fbind('parent', self._show_cut_copy_paste, pos, win, True)\n\n            def hide_(*args):\n                return self._hide_cut_copy_paste(win)\n\n            self.bind(\n                focus=hide_,\n                cursor_pos=hide_,\n            )\n        else:\n            win.remove_widget(bubble)\n            if not self.parent:\n                return\n        if parent_changed:\n            return\n\n        # Search the position from the touch to the window\n        lh, ls = self.line_height, self.line_spacing\n\n        x, y = pos\n        t_pos = (x, y) if pos_in_window else self.to_window(x, y)\n        bubble_size = bubble.size\n        bubble_hw = bubble_size[0] / 2.\n        win_size = win.size\n        bubble_pos = (t_pos[0], t_pos[1] + inch(.25))\n\n        if (bubble_pos[0] - bubble_hw) < 0:\n            # bubble beyond left of window\n            if bubble_pos[1] > (win_size[1] - bubble_size[1]):\n                # bubble above window height\n                bubble_pos = (bubble_hw, (t_pos[1]) - (lh + ls + inch(.25)))\n                bubble.arrow_pos = 'top_left'\n            else:\n                bubble_pos = (bubble_hw, bubble_pos[1])\n                bubble.arrow_pos = 'bottom_left'\n        elif (bubble_pos[0] + bubble_hw) > win_size[0]:\n            # bubble beyond right of window\n            if bubble_pos[1] > (win_size[1] - bubble_size[1]):\n                # bubble above window height\n                bubble_pos = (\n                    win_size[0] - bubble_hw,\n                    (t_pos[1]) - (lh + ls + inch(.25))\n                )\n                bubble.arrow_pos = 'top_right'\n            else:\n                bubble_pos = (win_size[0] - bubble_hw, bubble_pos[1])\n                bubble.arrow_pos = 'bottom_right'\n        else:\n            if bubble_pos[1] > (win_size[1] - bubble_size[1]):\n                # bubble above window height\n                bubble_pos = (\n                    bubble_pos[0],\n                    (t_pos[1]) - (lh + ls + inch(.25))\n                )\n                bubble.arrow_pos = 'top_mid'\n            else:\n                bubble.arrow_pos = 'bottom_mid'\n\n        bubble_pos = self.to_widget(*bubble_pos, relative=True)\n        bubble.center_x = bubble_pos[0]\n        if bubble.arrow_pos[0] == 't':\n            bubble.top = bubble_pos[1]\n        else:\n            bubble.y = bubble_pos[1]\n        bubble.mode = mode\n        Animation.cancel_all(bubble)\n        bubble.opacity = 0\n        win.add_widget(bubble, canvas='after')\n        Animation(opacity=1, d=.225).start(bubble)",
  "def _hide_cut_copy_paste(self, win=None):\n        bubble = self._bubble\n        if not bubble:\n            return\n\n        bubble.hide()",
  "def _reload_remove_observer(wr):\n        \"\"\"called when the textinput is deleted\"\"\"\n        if wr in _textinput_list:\n            _textinput_list.remove(wr)",
  "def _on_textinput_focused(self, instance, value, *largs):\n        win = EventLoop.window\n        self.cancel_selection()\n        self._hide_cut_copy_paste(win)\n\n        if value:\n            if (\n                not (self.readonly or self.disabled)\n                or _is_desktop\n                and self._keyboard_mode == 'system'\n            ):\n                self._trigger_cursor_reset()\n                self._editable = True\n            else:\n                self._editable = False\n        else:\n            self._do_blink_cursor_ev.cancel()\n            self._hide_handles(win)",
  "def _ensure_clipboard(self):\n        global Clipboard, CutBuffer\n        if not Clipboard:\n            from kivy.core.clipboard import Clipboard, CutBuffer",
  "def cut(self):\n        ''' Copy current selection to clipboard then delete it from TextInput.\n\n        .. versionadded:: 1.8.0\n\n        '''\n        self._cut(self.selection_text)",
  "def _cut(self, data):\n        self._ensure_clipboard()\n        Clipboard.copy(data)\n        self.delete_selection()",
  "def copy(self, data=''):\n        ''' Copy the value provided in argument `data` into current clipboard.\n        If data is not of type string it will be converted to string.\n        If no data is provided then current selection if present is copied.\n\n        .. versionadded:: 1.8.0\n\n        '''\n        self._ensure_clipboard()\n        if data:\n            return Clipboard.copy(data)\n        if self.selection_text:\n            return Clipboard.copy(self.selection_text)",
  "def paste(self):\n        ''' Insert text from system :class:`~kivy.core.clipboard.Clipboard`\n        into the :class:`~kivy.uix.textinput.TextInput` at current cursor\n        position.\n\n        .. versionadded:: 1.8.0\n\n        '''\n        self._ensure_clipboard()\n        data = Clipboard.paste()\n        self.delete_selection()\n        self.insert_text(data)",
  "def _update_cutbuffer(self, *args):\n        CutBuffer.set_cutbuffer(self.selection_text)",
  "def _get_text_width(self, text, tab_width, _label_cached):\n        \"\"\"Return the width of a text, according to the current line options\"\"\"\n        kw = self._get_line_options()\n\n        try:\n            cid = u'{}\\0{}\\0{}'.format(text, self.password, kw)\n        except UnicodeDecodeError:\n            cid = '{}\\0{}\\0{}'.format(text, self.password, kw)\n\n        width = Cache_get('textinput.width', cid)\n        if width:\n            return width\n        if not _label_cached:\n            _label_cached = self._label_cached\n        text = text.replace('\\t', ' ' * tab_width)\n        if not self.password:\n            width = _label_cached.get_extents(text)[0]\n        else:\n            width = _label_cached.get_extents(\n                self.password_mask * len(text))[0]\n        Cache_append('textinput.width', cid, width)\n        return width",
  "def on_cursor_blink(self, instance, value):\n        \"\"\"trigger blink event reset to switch blinking while focused\"\"\"\n        self._reset_cursor_blink()",
  "def _do_blink_cursor(self, dt):\n        if not self.cursor_blink:\n            # ignore event if not triggered,\n            # stop if cursor_blink value changed right now\n            if self._do_blink_cursor_ev.is_triggered:\n                self._do_blink_cursor_ev.cancel()\n            # don't blink, make cursor visible\n            self._cursor_blink = False\n            return\n\n        # Callback for blinking the cursor.\n        self._cursor_blink = not self._cursor_blink",
  "def _reset_cursor_blink(self, *args):\n        self._do_blink_cursor_ev.cancel()\n        self._cursor_blink = False\n        self._do_blink_cursor_ev()",
  "def on_cursor(self, instance, value):\n        \"\"\"\n        When the cursor is moved, reset cursor blinking to keep it showing,\n        and update all the graphics.\n        \"\"\"\n        if self.focus:\n            self._trigger_cursor_reset()\n        self._trigger_update_graphics()",
  "def _delete_line(self, idx):\n        \"\"\"Delete current line, and fix cursor position\"\"\"\n        assert idx < len(self._lines)\n        self._lines_flags.pop(idx)\n        self._lines_labels.pop(idx)\n        self._lines.pop(idx)\n        self.cursor = self.cursor",
  "def _set_line_text(self, line_num, text):\n        \"\"\"Set current line with other text than the default one.\"\"\"\n        self._lines_labels[line_num] = self._create_line_label(text)\n        self._lines[line_num] = text",
  "def _trigger_refresh_line_options(self, *largs):\n        if self._refresh_line_options_ev is not None:\n            self._refresh_line_options_ev.cancel()\n        else:\n            self._refresh_line_options_ev = Clock.create_trigger(\n                self._refresh_line_options, 0)\n        self._refresh_line_options_ev()",
  "def _refresh_line_options(self, *largs):\n        self._line_options = None\n        self._get_line_options()\n        self._refresh_text_from_property()\n        self._refresh_hint_text()\n        self.cursor = self.get_cursor_from_index(len(self.text))",
  "def _trigger_refresh_text(self, *largs):\n        if len(largs) and largs[0] == self:\n            largs = ()\n        if self._refresh_text_from_property_ev is not None:\n            self._refresh_text_from_property_ev.cancel()\n        self._refresh_text_from_property_ev = Clock.schedule_once(\n            lambda dt: self._refresh_text_from_property(*largs))",
  "def _update_text_options(self, *largs):\n        Cache_remove('textinput.width')\n        self._trigger_refresh_text()",
  "def _refresh_text_from_trigger(self, dt, *largs):\n        self._refresh_text_from_property(*largs)",
  "def _refresh_text_from_property(self, *largs):\n        self._refresh_text(self.text, *largs)",
  "def _refresh_text(self, text, *largs):\n        \"\"\"\n        Refresh all the lines from a new text.\n        By using cache in internal functions, this method should be fast.\n        \"\"\"\n        mode = 'all'\n        if len(largs) > 1:\n            mode, start, finish, _lines, _lines_flags, len_lines = largs\n            # start = max(0, start)\n            cursor = None\n        else:\n            cursor = self.cursor_index()\n            _lines, self._lines_flags = self._split_smart(text)\n        _lines_labels = []\n        _line_rects = []\n        _create_label = self._create_line_label\n\n        for x in _lines:\n            lbl = _create_label(x)\n            _lines_labels.append(lbl)\n            _line_rects.append(Rectangle(size=lbl.size))\n\n        if mode == 'all':\n            self._lines_labels = _lines_labels\n            self._lines_rects = _line_rects\n            self._lines[:] = _lines\n        elif mode == 'del':\n            if finish > start:\n                self._insert_lines(start, finish + 1, len_lines,\n                                   _lines_flags, _lines, _lines_labels,\n                                   _line_rects)\n        elif mode == 'insert':\n            self._insert_lines(start, finish + 1, len_lines, _lines_flags,\n                               _lines, _lines_labels, _line_rects)\n\n        min_line_ht = self._label_cached.get_extents('_')[1]\n        # with markup texture can be of height `1`\n        self.line_height = max(_lines_labels[0].height, min_line_ht)\n        # self.line_spacing = 2\n        # now, if the text change, maybe the cursor is not at the same place as\n        # before. so, try to set the cursor on the good place\n        row = self.cursor_row\n        self.cursor = self.get_cursor_from_index(\n            self.cursor_index() if cursor is None else cursor\n        )\n\n        # if we back to a new line, reset the scroll, otherwise, the effect is\n        # ugly\n        if self.cursor_row != row:\n            self.scroll_x = 0\n        # with the new text don't forget to update graphics again\n        self._trigger_update_graphics()",
  "def _insert_lines(self, start, finish, len_lines, _lines_flags,\n                      _lines, _lines_labels, _line_rects):\n        self_lines_flags = self._lines_flags\n        _lins_flags = []\n        _lins_flags.extend(self_lines_flags[:start])\n        if len_lines:\n            # if not inserting at first line then\n            if start:\n                # make sure line flags restored for first line\n                # _split_smart assumes first line to be not a new line\n                _lines_flags[0] = self_lines_flags[start]\n            _lins_flags.extend(_lines_flags)\n        _lins_flags.extend(self_lines_flags[finish:])\n        self._lines_flags = _lins_flags\n\n        _lins_lbls = []\n        _lins_lbls.extend(self._lines_labels[:start])\n        if len_lines:\n            _lins_lbls.extend(_lines_labels)\n        _lins_lbls.extend(self._lines_labels[finish:])\n        self._lines_labels = _lins_lbls\n\n        _lins_rcts = []\n        _lins_rcts.extend(self._lines_rects[:start])\n        if len_lines:\n            _lins_rcts.extend(_line_rects)\n        _lins_rcts.extend(self._lines_rects[finish:])\n        self._lines_rects = _lins_rcts\n\n        _lins = []\n        _lins.extend(self._lines[:start])\n        if len_lines:\n            _lins.extend(_lines)\n        _lins.extend(self._lines[finish:])\n        self._lines[:] = _lins",
  "def _trigger_update_graphics(self, *largs):\n        self._update_graphics_ev.cancel()\n        self._update_graphics_ev()",
  "def _update_graphics(self, *largs):\n        \"\"\"\n        Update all the graphics according to the current internal values.\n        \"\"\"\n\n        # This is a little bit complex, because we have to :\n        #     - handle scroll_x\n        #     - handle padding\n        #     - create rectangle for the lines matching the viewport\n        #     - crop the texture coordinates to match the viewport\n\n        # This is the first step of graphics, the second is the selection.\n\n        self.canvas.clear()\n\n        line_height = self.line_height\n        dy = line_height + self.line_spacing\n\n        # adjust view if the cursor is going outside the bounds\n        scroll_x = self.scroll_x\n        scroll_y = self.scroll_y\n\n        # draw labels\n        if (\n            not self._lines\n            or (not self._lines[0] and len(self._lines) == 1)\n        ):\n            rects = self._hint_text_rects\n            labels = self._hint_text_labels\n            lines = self._hint_text_lines\n        else:\n            rects = self._lines_rects\n            labels = self._lines_labels\n            lines = self._lines\n\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n        x = self.x + padding_left\n        y = self.top - padding_top + scroll_y\n        miny = self.y + padding_bottom\n        maxy = self.top - padding_top\n        halign = self.halign\n        base_dir = self.base_direction\n\n        auto_halign_r = halign == 'auto' and base_dir and 'rtl' in base_dir\n\n        fst_visible_ln = None\n        viewport_pos = scroll_x, 0\n        for line_num, value in enumerate(lines):\n            if miny < y < maxy + dy:\n                if fst_visible_ln is None:\n                    fst_visible_ln = line_num\n\n                y = self._draw_line(\n                    value,\n                    line_num,\n                    labels[line_num],\n                    viewport_pos,\n                    line_height,\n                    miny,\n                    maxy,\n                    x,\n                    y,\n                    base_dir,\n                    halign,\n                    rects,\n                    auto_halign_r,\n                )\n            elif y <= miny:\n                line_num -= 1\n                break\n\n            y -= dy\n\n        if fst_visible_ln is not None:\n            self._visible_lines_range = (fst_visible_ln, line_num + 1)\n        else:\n            self._visible_lines_range = 0, 0\n\n        self._update_graphics_selection()",
  "def _draw_line(\n        self,\n        value,\n        line_num,\n        texture,\n        viewport_pos,\n        line_height,\n        miny,\n        maxy,\n        x,\n        y,\n        base_dir,\n        halign,\n        rects,\n        auto_halign_r,\n    ):\n        size = list(texture.size)\n        texcoords = texture.tex_coords[:]\n\n        # compute coordinate\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n        viewport_width = self.width - padding_left - padding_right\n        viewport_height = self.height - padding_top - padding_bottom\n        texture_width, texture_height = size\n        original_height, original_width = tch, tcw = texcoords[1:3]\n\n        # adjust size/texcoord according to viewport\n        if viewport_pos:\n            tcx, tcy = viewport_pos\n            tcx = tcx / texture_width * original_width\n            tcy = tcy / texture_height * original_height\n\n        else:\n            tcx, tcy = 0, 0\n\n        if texture_width * (1 - tcx) < viewport_width:\n            tcw = tcw - tcx\n            texture_width = tcw * texture_width\n        elif viewport_width < texture_width:\n            tcw = (viewport_width / texture_width) * tcw\n            texture_width = viewport_width\n\n        if viewport_height < texture_height:\n            tch = (viewport_height / texture_height) * tch\n            texture_height = viewport_height\n\n        # cropping\n        if y > maxy:\n            viewport_height = (maxy - y + line_height)\n            tch = (viewport_height / line_height) * original_height\n            tcy = original_height - tch\n            texture_height = viewport_height\n        if y - line_height < miny:\n            diff = miny - (y - line_height)\n            y += diff\n            viewport_height = line_height - diff\n            tch = (viewport_height / line_height) * original_height\n            texture_height = viewport_height\n\n        if tcw < 0:\n            # nothing to show\n            return y\n\n        top_left_corner = tcx, tcy + tch\n        top_right_corner = tcx + tcw, tcy + tch\n        bottom_right_corner = tcx + tcw, tcy\n        bottom_left_corner = tcx, tcy\n\n        texcoords = (\n            top_left_corner\n            + top_right_corner\n            + bottom_right_corner\n            + bottom_left_corner\n        )\n\n        # Horizontal alignment\n        xoffset = 0\n        if not base_dir:\n            base_dir = self._resolved_base_dir = Label.find_base_direction(value)  # noqa\n            if base_dir and halign == 'auto':\n                auto_halign_r = 'rtl' in base_dir\n        if halign == 'center':\n            xoffset = int((viewport_width - texture_width) / 2.)\n        elif halign == 'right' or auto_halign_r:\n            xoffset = max(0, int(viewport_width - texture_width))\n\n        # add rectangle\n        rect = rects[line_num]\n        rect.pos = int(xoffset + x), int(y - line_height)\n        rect.size = texture_width, texture_height\n        rect.texture = texture\n        rect.tex_coords = texcoords\n        # useful to debug rectangle sizes\n        # self.canvas.add(Color(0, .5, 0, .5, mode='rgba'))\n        # self.canvas.add(Rectangle(pos=rect.pos, size=rect.size))\n        # self.canvas.add(Color())\n        self.canvas.add(rect)\n\n        return y",
  "def _update_graphics_selection(self):\n        if not self._selection:\n            return\n\n        # local references to avoid dot lookups later\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n        rects = self._lines_rects\n        label_cached = self._label_cached\n        lines = self._lines\n        tab_width = self.tab_width\n        top = self.top\n        get_text_width = self._get_text_width\n        get_cursor_from_index = self.get_cursor_from_index\n        draw_selection = self._draw_selection\n        canvas_add = self.canvas.add\n        selection_color = self.selection_color\n\n        # selection borders\n        a, b = sorted((self._selection_from, self._selection_to))\n        selection_start_col, selection_start_row = get_cursor_from_index(a)\n        selection_end_col, selection_end_row = get_cursor_from_index(b)\n\n        dy = self.line_height + self.line_spacing\n        x = self.x\n        y = top - padding_top + self.scroll_y - selection_start_row * dy\n        width = self.width\n\n        miny = self.y + padding_bottom\n        maxy = top - padding_top + dy\n\n        self.canvas.remove_group('selection')\n        first_visible_line = math.floor(self.scroll_y / dy)\n        last_visible_line = math.ceil((self.scroll_y + maxy - miny) / dy)\n        width_minus_padding = width - (padding_right + padding_left)\n\n        for line_num, rect in enumerate(\n            islice(\n                rects,\n                max(selection_start_row, first_visible_line),\n                min(selection_end_row + 1, last_visible_line - 1),\n            ),\n            start=max(selection_start_row, first_visible_line)\n        ):\n            draw_selection(\n                rect.pos,\n                rect.size,\n                line_num,\n                (selection_start_col, selection_start_row),\n                (selection_end_col, selection_end_row),\n                lines,\n                get_text_width,\n                tab_width,\n                label_cached,\n                width_minus_padding,\n                padding_left,\n                padding_right,\n                x,\n                canvas_add,\n                selection_color\n            )\n        self._position_handles('both')",
  "def _draw_selection(\n        self,\n        pos,\n        size,\n        line_num,\n        selection_start,\n        selection_end,\n        lines,\n        get_text_width,\n        tab_width,\n        label_cached,\n        width_minus_padding,\n        padding_left,\n        padding_right,\n        x,\n        canvas_add,\n        selection_color\n    ):\n        selection_start_col, selection_start_row = selection_start\n        selection_end_col, selection_end_row = selection_end\n\n        # Draw the current selection on the widget.\n        if not selection_start_row <= line_num <= selection_end_row:\n            return\n        x, y = pos\n        w, h = size\n        beg = x\n        end = x + w\n\n        if line_num == selection_start_row:\n            line = lines[line_num]\n            beg -= self.scroll_x\n            beg += get_text_width(\n                line[:selection_start_col],\n                tab_width,\n                label_cached\n            )\n\n        if line_num == selection_end_row:\n            line = lines[line_num]\n            end = (x - self.scroll_x) + get_text_width(\n                line[:selection_end_col],\n                tab_width,\n                label_cached\n            )\n\n        beg = boundary(beg, x, x + width_minus_padding)\n        end = boundary(end, x, x + width_minus_padding)\n        if beg == end:\n            return\n\n        canvas_add(Color(*selection_color, group='selection'))\n        canvas_add(\n            Rectangle(\n                pos=(beg, y),\n                size=(end - beg, h),\n                group='selection'\n            )\n        )",
  "def on_size(self, instance, value):\n        # if the size change, we might do invalid scrolling / text split\n        # size the text maybe be put after size_hint have been resolved.\n        self._trigger_refresh_text()\n        self._refresh_hint_text()\n        self.scroll_x = self.scroll_y = 0",
  "def _get_row_width(self, row):\n        # Get the pixel width of the given row.\n        _labels = self._lines_labels\n        if row < len(_labels):\n            return _labels[row].width\n        return 0",
  "def _get_cursor_pos(self):\n        # return the current cursor x/y from the row/col\n        dy = self.line_height + self.line_spacing\n        padding_left = self.padding[0]\n        padding_top = self.padding[1]\n        padding_right = self.padding[2]\n        left = self.x + padding_left\n        top = self.top - padding_top\n        y = top + self.scroll_y\n        y -= self.cursor_row * dy\n\n        # Horizontal alignment\n        halign = self.halign\n        viewport_width = self.width - padding_left - padding_right\n        cursor_offset = self.cursor_offset()\n        base_dir = self.base_direction or self._resolved_base_dir\n        auto_halign_r = halign == 'auto' and base_dir and 'rtl' in base_dir\n        if halign == 'center':\n            row_width = self._get_row_width(self.cursor_row)\n            x = (\n                left\n                + max(0, (viewport_width - row_width) // 2)\n                + cursor_offset\n                - self.scroll_x\n            )\n        elif halign == 'right' or auto_halign_r:\n            row_width = self._get_row_width(self.cursor_row)\n            x = (\n                left\n                + max(0, viewport_width - row_width)\n                + cursor_offset\n                - self.scroll_x\n            )\n        else:\n            x = left + cursor_offset - self.scroll_x\n\n        return x, y",
  "def _get_cursor_visual_height(self):\n        # Return the height of the cursor's visible part\n        _, cy = map(int, self.cursor_pos)\n        max_y = self.top - self.padding[1]\n        min_y = self.y + self.padding[3]\n\n        lh = self.line_height\n        if cy > max_y:\n            return lh - min(lh, cy - max_y)\n        else:\n            return min(lh, max(0, cy - min_y))",
  "def _get_cursor_visual_pos(self):\n        # Return the position of the cursor's top visible point\n        cx, cy = map(int, self.cursor_pos)\n        max_y = self.top - self.padding[3]\n        return [cx, min(max_y, cy)]",
  "def _get_line_options(self):\n        # Get or create line options, to be used for Label creation\n        if self._line_options is None:\n            self._line_options = kw = {\n                'font_size': self.font_size,\n                'font_name': self.font_name,\n                'font_context': self.font_context,\n                'font_family': self.font_family,\n                'text_language': self.text_language,\n                'base_direction': self.base_direction,\n                'anchor_x': 'left',\n                'anchor_y': 'top',\n                'padding_x': 0,\n                'padding_y': 0,\n                'padding': (0, 0)\n            }\n            self._label_cached = Label(**kw)\n        return self._line_options",
  "def _create_line_label(self, text, hint=False):\n        # Create a label from a text, using line options\n        ntext = text.replace(u'\\n', u'').replace(u'\\t', u' ' * self.tab_width)\n\n        if self.password and not hint:  # Don't replace hint_text with *\n            ntext = self.password_mask * len(ntext)\n\n        kw = self._get_line_options()\n        cid = '%s\\0%s' % (ntext, str(kw))\n        texture = Cache_get('textinput.label', cid)\n\n        if texture is None:\n            # FIXME right now, we can't render very long line...\n            # if we move on \"VBO\" version as fallback, we won't need to\n            # do this. try to find the maximum text we can handle\n            label = None\n            label_len = len(ntext)\n            ld = None\n\n            # check for blank line\n            if not ntext:\n                texture = Texture.create(size=(1, 1))\n                Cache_append('textinput.label', cid, texture)\n                return texture\n\n            while True:\n                try:\n                    label = Label(text=ntext[:label_len], **kw)\n                    label.refresh()\n                    if ld is not None and ld > 2:\n                        ld //= 2\n                        label_len += ld\n                    else:\n                        break\n\n                except:\n                    # exception happen when we tried to render the text\n                    # reduce it...\n                    if ld is None:\n                        ld = len(ntext)\n                    ld //= 2\n                    if ld < 2 and label_len:\n                        label_len -= 1\n                    label_len -= ld\n                    continue\n\n            # ok, we found it.\n            texture = label.texture\n            Cache_append('textinput.label', cid, texture)\n        return texture",
  "def _tokenize(self, text):\n        # Tokenize a text string from some delimiters\n        if text is None:\n            return\n        delimiters = self._tokenize_delimiters\n        old_index = 0\n        prev_char = ''\n        for index, char in enumerate(text):\n            if char not in delimiters:\n                if char != u'\\n':\n                    if index > 0 and (prev_char in delimiters):\n                        if old_index < index:\n                            yield text[old_index:index]\n                        old_index = index\n                else:\n                    if old_index < index:\n                        yield text[old_index:index]\n                    yield text[index:index + 1]\n                    old_index = index + 1\n            prev_char = char\n        yield text[old_index:]",
  "def _split_smart(self, text):\n        \"\"\"\n        Do a \"smart\" split. If not multiline, or if wrap is set,\n        we are not doing smart split, just a split on line break.\n        Otherwise, we are trying to split as soon as possible, to prevent\n        overflow on the widget.\n        \"\"\"\n\n        # depend of the options, split the text on line, or word\n        if not self.multiline or not self.do_wrap:\n            lines = text.split(u'\\n')\n            lines_flags = [0] + [FL_IS_LINEBREAK] * (len(lines) - 1)\n            return lines, lines_flags\n\n        # no autosize, do wordwrap.\n        x = flags = 0\n        line = []\n        lines = []\n        lines_flags = []\n        _join = u''.join\n        lines_append, lines_flags_append = lines.append, lines_flags.append\n        padding_left = self.padding[0]\n        padding_right = self.padding[2]\n        width = self.width - padding_left - padding_right\n        text_width = self._get_text_width\n        _tab_width, _label_cached = self.tab_width, self._label_cached\n\n        # try to add each word on current line.\n        words_widths = {}\n        for word in self._tokenize(text):\n            is_newline = (word == u'\\n')\n            try:\n                w = words_widths[word]\n            except KeyError:\n                w = text_width(word, _tab_width, _label_cached)\n                words_widths[word] = w\n            # if we have more than the width, or if it's a newline,\n            # push the current line, and create a new one\n            if (x + w > width and line) or is_newline:\n                lines_append(_join(line))\n                lines_flags_append(flags)\n                flags = 0\n                line = []\n                x = 0\n            if is_newline:\n                flags |= FL_IS_LINEBREAK\n            elif width >= 1 and w > width:\n                while w > width:\n                    split_width = split_pos = 0\n                    # split the word\n                    for c in word:\n                        try:\n                            cw = words_widths[c]\n                        except KeyError:\n                            cw = text_width(c, _tab_width, _label_cached)\n                            words_widths[c] = cw\n                        if split_width + cw > width:\n                            break\n                        split_width += cw\n                        split_pos += 1\n                    if split_width == split_pos == 0:\n                        # can't fit the word in, give up\n                        break\n                    lines_append(word[:split_pos])\n                    lines_flags_append(flags)\n                    flags = FL_IS_WORDBREAK\n                    word = word[split_pos:]\n                    w -= split_width\n                x = w\n                line.append(word)\n            else:\n                x += w\n                line.append(word)\n        if line or flags & FL_IS_LINEBREAK:\n            lines_append(_join(line))\n            lines_flags_append(flags)\n\n        return lines, lines_flags",
  "def _key_down(self, key, repeat=False):\n        displayed_str, internal_str, internal_action, scale = key\n\n        # handle deletion\n        if (\n            self._selection\n            and internal_action in (None, 'del', 'backspace', 'enter')\n            and (internal_action != 'enter' or self.multiline)\n        ):\n            self.delete_selection()\n\n        elif internal_action == 'del':\n            # Move cursor one char to the right. If that was successful,\n            # do a backspace (effectively deleting char right of cursor)\n            cursor = self.cursor\n            self.do_cursor_movement('cursor_right')\n            if cursor != self.cursor:\n                self.do_backspace(mode='del')\n\n        elif internal_action == 'backspace':\n            self.do_backspace()\n\n        # handle action keys and text insertion\n        if internal_action is None:\n            self.insert_text(displayed_str)\n\n        elif internal_action in ('shift', 'shift_L', 'shift_R'):\n            if not self._selection:\n                self._selection_from = self._selection_to = self.cursor_index()\n                self._selection = True\n            self._selection_finished = False\n\n        elif internal_action == 'ctrl_L':\n            self._ctrl_l = True\n\n        elif internal_action == 'ctrl_R':\n            self._ctrl_r = True\n\n        elif internal_action == 'alt_L':\n            self._alt_l = True\n\n        elif internal_action == 'alt_R':\n            self._alt_r = True\n\n        elif internal_action.startswith('cursor_'):\n            cc, cr = self.cursor\n            self.do_cursor_movement(\n                internal_action,\n                self._ctrl_l or self._ctrl_r,\n                self._alt_l or self._alt_r\n            )\n            if self._selection and not self._selection_finished:\n                self._selection_to = self.cursor_index()\n                self._update_selection()\n            else:\n                self.cancel_selection()\n\n        elif internal_action == 'enter':\n            if self.multiline:\n                self.insert_text(u'\\n')\n            else:\n                self.dispatch('on_text_validate')\n                if self.text_validate_unfocus:\n                    self.focus = False\n\n        elif internal_action == 'escape':\n            self.focus = False",
  "def _key_up(self, key, repeat=False):\n        displayed_str, internal_str, internal_action, scale = key\n        if internal_action in ('shift', 'shift_L', 'shift_R'):\n            if self._selection:\n                self._update_selection(True)\n        elif internal_action == 'ctrl_L':\n            self._ctrl_l = False\n        elif internal_action == 'ctrl_R':\n            self._ctrl_r = False\n        elif internal_action == 'alt_L':\n            self._alt_l = False\n        elif internal_action == 'alt_R':\n            self._alt_r = False",
  "def keyboard_on_key_down(self, window, keycode, text, modifiers):\n        key, _ = keycode\n        win = EventLoop.window\n\n        # This allows *either* ctrl *or* cmd, but not both.\n        modifiers = set(modifiers) - {'capslock', 'numlock'}\n        is_shortcut = (\n            modifiers == {'ctrl'}\n            or _is_osx and modifiers == {'meta'}\n        )\n        is_interesting_key = key in self.interesting_keys.keys()\n\n        if (\n            not self.write_tab\n            and super().keyboard_on_key_down(window, keycode, text, modifiers)\n        ):\n            return True\n\n        if text and is_shortcut and not is_interesting_key:\n            self._handle_shortcut(key)\n\n        elif self._editable and text and not is_interesting_key:\n            self._hide_handles(win)\n            self._hide_cut_copy_paste(win)\n            win.remove_widget(self._handle_middle)\n\n            # check for command modes\n            # we use \\x01INFO\\x02 to get info from IME on mobiles\n            # pygame seems to pass \\x01 as the unicode for ctrl+a\n            # checking for modifiers ensures conflict resolution.\n\n            first_char = ord(text[0])\n            if not modifiers and first_char == 1:\n                self._command_mode = True\n                self._command = ''\n            if not modifiers and first_char == 2:\n                self._command_mode = False\n                self._command = self._command[1:]\n\n            if self._command_mode:\n                self._command += text\n                return\n\n            _command = self._command\n            if _command and first_char == 2:\n                self._handle_command(_command)\n                return\n\n            else:\n                if EventLoop.window.managed_textinput:\n                    # we expect to get managed key input via on_textinput\n                    return\n                if self._selection:\n                    self.delete_selection()\n                self.insert_text(text)\n            # self._recalc_size()\n            return\n\n        if is_interesting_key:\n            self._hide_cut_copy_paste(win)\n            self._hide_handles(win)\n\n        if key == 27:  # escape\n            self.focus = False\n            return True\n        elif key == 9:  # tab\n            self.delete_selection()\n            self.insert_text(u'\\t')\n            return True\n\n        k = self.interesting_keys.get(key)\n        if k:\n            key = (None, None, k, 1)\n            self._key_down(key)",
  "def _handle_command(self, command):\n        from_undo = True\n        command, data = command.split(':')\n        self._command = ''\n        if self._selection:\n            self.delete_selection()\n        if command == 'DEL':\n            count = int(data)\n            if not count:\n                self.delete_selection(from_undo=True)\n            end = self.cursor_index()\n            self._selection_from = max(end - count, 0)\n            self._selection_to = end\n            self._selection = True\n            self.delete_selection(from_undo=True)\n            return\n        elif command == 'INSERT':\n            self.insert_text(data, from_undo)\n        elif command == 'INSERTN':\n            from_undo = False\n            self.insert_text(data, from_undo)\n        elif command == 'SELWORD':\n            self.dispatch('on_double_tap')\n        elif command == 'SEL':\n            if data == '0':\n                Clock.schedule_once(lambda dt: self.cancel_selection())\n        elif command == 'CURCOL':\n            self.cursor = int(data), self.cursor_row",
  "def _handle_shortcut(self, key):\n        # actions that can be done in readonly\n        if key == ord('a'):  # select all\n            self.select_all()\n        elif key == ord('c'):  # copy selection\n            self.copy()\n\n        if not self._editable:\n            return\n\n        # actions that can be done only if editable\n        if key == ord('x'):  # cut selection\n            self._cut(self.selection_text)\n        elif key == ord('v'):  # paste clipboard content\n            self.paste()\n        elif key == ord('z'):  # undo\n            self.do_undo()\n        elif key == ord('r'):  # redo\n            self.do_redo()",
  "def keyboard_on_key_up(self, window, keycode):\n        key = keycode[0]\n        k = self.interesting_keys.get(key)\n        if k:\n            key = (None, None, k, 1)\n            self._key_up(key)",
  "def keyboard_on_textinput(self, window, text):\n        if self._selection:\n            self.delete_selection()\n        self.insert_text(text, False)",
  "def _bind_keyboard(self):\n        super()._bind_keyboard()\n        Window.bind(on_textedit=self.window_on_textedit)",
  "def _unbind_keyboard(self):\n        super()._unbind_keyboard()\n        Window.unbind(on_textedit=self.window_on_textedit)",
  "def window_on_textedit(self, window, ime_input):\n        text_lines = self._lines or ['']\n        if self._ime_composition:\n            pcc, pcr = self._ime_cursor\n            text = text_lines[pcr]\n            len_ime = len(self._ime_composition)\n            if text[pcc - len_ime:pcc] == self._ime_composition:  # always?\n                remove_old_ime_text = text[:pcc - len_ime] + text[pcc:]\n                ci = self.cursor_index()\n                self._refresh_text_from_property(\n                    \"insert\",\n                    *self._get_line_from_cursor(pcr, remove_old_ime_text)\n                )\n                self.cursor = self.get_cursor_from_index(ci - len_ime)\n\n        if ime_input:\n            if self._selection:\n                self.delete_selection()\n            cc, cr = self.cursor\n            text = text_lines[cr]\n            new_text = text[:cc] + ime_input + text[cc:]\n            self._refresh_text_from_property(\n                \"insert\", *self._get_line_from_cursor(cr, new_text)\n            )\n            self.cursor = self.get_cursor_from_index(\n                self.cursor_index() + len(ime_input)\n            )\n        self._ime_composition = ime_input\n        self._ime_cursor = self.cursor",
  "def on__hint_text(self, instance, value):\n        self._refresh_hint_text()",
  "def _refresh_hint_text(self):\n        _lines, self._hint_text_flags = self._split_smart(self.hint_text)\n        _hint_text_labels = []\n        _hint_text_rects = []\n        _create_label = self._create_line_label\n\n        for x in _lines:\n            lbl = _create_label(x, hint=True)\n            _hint_text_labels.append(lbl)\n            _hint_text_rects.append(Rectangle(size=lbl.size))\n\n        self._hint_text_lines[:] = _lines\n        self._hint_text_labels = _hint_text_labels\n        self._hint_text_rects = _hint_text_rects\n\n        # Remember to update graphics\n        self._trigger_update_graphics()",
  "def _get_cursor(self):\n        return self._cursor",
  "def _set_cursor(self, pos):\n        if not self._lines:\n            self._trigger_refresh_text()\n            return\n        l = self._lines\n        cr = boundary(pos[1], 0, len(l) - 1)\n        cc = boundary(pos[0], 0, len(l[cr]))\n        cursor = cc, cr\n\n        # adjust scrollview to ensure that the cursor will be always inside our\n        # viewport.\n        self._adjust_viewport(cc, cr)\n\n        if self._cursor == cursor:\n            return\n\n        self._cursor = cursor\n        return True",
  "def _adjust_viewport(self, cc, cr):\n        padding_left = self.padding[0]\n        padding_right = self.padding[2]\n        viewport_width = self.width - padding_left - padding_right\n        sx = self.scroll_x\n        base_dir = self.base_direction or self._resolved_base_dir\n        auto_halign_r = (\n            self.halign == 'auto'\n            and base_dir\n            and 'rtl' in base_dir\n        )\n\n        offset = self.cursor_offset()\n        row_width = self._get_row_width(self.cursor_row)\n\n        # if offset is outside the current bounds, readjust\n        if offset - sx >= viewport_width:\n            self.scroll_x = offset - viewport_width\n        elif offset < sx + 1:\n            self.scroll_x = offset\n\n        # Avoid right/center horizontal alignment issues if the viewport is at\n        # the end of the line, if not multiline.\n        viewport_scroll_x = row_width - viewport_width\n        if (\n            not self.multiline\n            and offset >= viewport_scroll_x\n            and self.scroll_x >= viewport_scroll_x\n            and (\n                self.halign == \"center\"\n                or self.halign == \"right\"\n                or auto_halign_r\n            )\n        ):\n            self.scroll_x = max(0, viewport_scroll_x)\n\n        # do the same for Y\n        # this algo try to center the cursor as much as possible\n        dy = self.line_height + self.line_spacing\n        offsety = cr * dy\n\n        padding_top = self.padding[1]\n        padding_bottom = self.padding[3]\n        viewport_height = self.height - padding_top - padding_bottom - dy\n\n        sy = self.scroll_y\n        if offsety > viewport_height + sy:\n            self.scroll_y = offsety - viewport_height\n        elif offsety < sy:\n            self.scroll_y = offsety",
  "def _get_cursor_col(self):\n        return self._cursor[0]",
  "def _get_cursor_row(self):\n        return self._cursor[1]",
  "def on_padding_x(self, instance, value):\n        self.padding[0] = value[0]\n        self.padding[2] = value[1]",
  "def on_padding_y(self, instance, value):\n        self.padding[1] = value[0]\n        self.padding[3] = value[1]",
  "def get_sel_from(self):\n        return self._selection_from",
  "def get_sel_to(self):\n        return self._selection_to",
  "def on_selection_text(self, instance, value):\n        if value:\n            if self.use_handles:\n                self._trigger_show_handles()\n            if CutBuffer and not self.password:\n                self._trigger_update_cutbuffer()",
  "def _get_text(self):\n        flags = self._lines_flags\n        lines = self._lines\n        len_lines = len(lines)\n        less_flags = len(flags) < len_lines\n        if less_flags:\n            flags.append(1)\n        text = ''.join(\n            ('\\n' if (flags[i] & FL_IS_LINEBREAK) else '') + lines[i]\n            for i in range(len_lines)\n        )\n        if less_flags:\n            flags.pop()\n        return text",
  "def _set_text(self, text):\n        if isinstance(text, bytes):\n            text = text.decode('utf8')\n        if self.replace_crlf:\n            text = text.replace(u'\\r\\n', u'\\n')\n        if self.text != text:\n            self._refresh_text(text)\n            self.cursor = self.get_cursor_from_index(len(text))",
  "def _set_hint_text(self, value):\n        if isinstance(value, bytes):\n            value = value.decode('utf8')\n        self._hint_text = value",
  "def _get_hint_text(self):\n        return self._hint_text",
  "def _get_min_height(self):\n        return (\n            len(self._lines) * (self.line_height + self.line_spacing)\n            + self.padding[1]\n            + self.padding[3]\n        )",
  "def on_handle_image_middle(self, instance, value):\n        if self._handle_middle:\n            self._handle_middle.source = value",
  "def on_handle_image_left(self, instance, value):\n        if self._handle_left:\n            self._handle_left.source = value",
  "def on_handle_image_right(self, instance, value):\n        if self._handle_right:\n            self._handle_right.source = value",
  "class TextInputApp(App):\n        time = NumericProperty()\n\n        def build(self):\n            Clock.schedule_interval(self.update_time, 0)\n            return Builder.load_string(KV)\n\n        def update_time(self, dt):\n            self.time += dt",
  "def decorator_func(func):\n            def decorated_func(*args, **kwargs):\n                return func(*args, **kwargs)\n            return decorated_func",
  "def handle_readonly(instance, value):\n            if value and (not _is_desktop or not self.allow_copy):\n                self.is_focusable = False\n            if (not (value or self.disabled) or _is_desktop and\n                    self._keyboard_mode == 'system'):\n                self._editable = True\n            else:\n                self._editable = False",
  "def build(self):\n            Clock.schedule_interval(self.update_time, 0)\n            return Builder.load_string(KV)",
  "def update_time(self, dt):\n            self.time += dt",
  "def decorated_func(*args, **kwargs):\n                return func(*args, **kwargs)",
  "def cb(dt):\n                self.select_text(*sel)\n                self._selection_callback = None",
  "def hide_(*args):\n                return self._hide_cut_copy_paste(win)",
  "class RecycleBoxLayout(RecycleLayout, BoxLayout):\n\n    _rv_positions = None\n\n    def __init__(self, **kwargs):\n        super(RecycleBoxLayout, self).__init__(**kwargs)\n        self.funbind('children', self._trigger_layout)\n\n    def _update_sizes(self, changed):\n        horizontal = self.orientation == 'horizontal'\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n        padding_x = padding_left + padding_right\n        padding_y = padding_top + padding_bottom\n        selfw = self.width\n        selfh = self.height\n        layout_w = max(0, selfw - padding_x)\n        layout_h = max(0, selfh - padding_y)\n        cx = self.x + padding_left\n        cy = self.y + padding_bottom\n        view_opts = self.view_opts\n        remove_view = self.remove_view\n\n        for (index, widget, (w, h), (wn, hn), (shw, shh), (shnw, shnh),\n             (shw_min, shh_min), (shwn_min, shhn_min), (shw_max, shh_max),\n             (shwn_max, shhn_max), ph, phn) in changed:\n            if (horizontal and\n                (shw != shnw or w != wn or shw_min != shwn_min or\n                 shw_max != shwn_max) or\n                not horizontal and\n                (shh != shnh or h != hn or shh_min != shhn_min or\n                 shh_max != shhn_max)):\n                return True\n\n            remove_view(widget, index)\n            opt = view_opts[index]\n            if horizontal:\n                wo, ho = opt['size']\n                if shnh is not None:\n                    _, h = opt['size'] = [wo, shnh * layout_h]\n                else:\n                    h = ho\n\n                xo, yo = opt['pos']\n                for key, value in phn.items():\n                    posy = value * layout_h\n                    if key == 'y':\n                        yo = posy + cy\n                    elif key == 'top':\n                        yo = posy - h\n                    elif key == 'center_y':\n                        yo = posy - (h / 2.)\n                opt['pos'] = [xo, yo]\n            else:\n                wo, ho = opt['size']\n                if shnw is not None:\n                    w, _ = opt['size'] = [shnw * layout_w, ho]\n                else:\n                    w = wo\n\n                xo, yo = opt['pos']\n                for key, value in phn.items():\n                    posx = value * layout_w\n                    if key == 'x':\n                        xo = posx + cx\n                    elif key == 'right':\n                        xo = posx - w\n                    elif key == 'center_x':\n                        xo = posx - (w / 2.)\n                opt['pos'] = [xo, yo]\n\n        return False\n\n    def compute_layout(self, data, flags):\n        super(RecycleBoxLayout, self).compute_layout(data, flags)\n\n        changed = self._changed_views\n        if (changed is None or\n                changed and not self._update_sizes(changed)):\n            return\n\n        self.clear_layout()\n        self._rv_positions = None\n        if not data:\n            l, t, r, b = self.padding\n            self.minimum_size = l + r, t + b\n            return\n\n        view_opts = self.view_opts\n        n = len(view_opts)\n        for i, x, y, w, h in self._iterate_layout(\n                [(opt['size'], opt['size_hint'], opt['pos_hint'],\n                  opt['size_hint_min'], opt['size_hint_max']) for\n                 opt in reversed(view_opts)]):\n            opt = view_opts[n - i - 1]\n            shw, shh = opt['size_hint']\n            opt['pos'] = x, y\n            wo, ho = opt['size']\n            # layout won't/shouldn't change previous size if size_hint is None\n            # which is what w/h being None means.\n            opt['size'] = [(wo if shw is None else w),\n                           (ho if shh is None else h)]\n\n        spacing = self.spacing\n        pos = self._rv_positions = [None, ] * len(data)\n\n        if self.orientation == 'horizontal':\n            pos[0] = self.x\n            last = pos[0] + self.padding[0] + view_opts[0]['size'][0] + \\\n                spacing / 2.\n            for i, val in enumerate(view_opts[1:], 1):\n                pos[i] = last\n                last += val['size'][0] + spacing\n        else:\n            last = pos[-1] = \\\n                self.y + self.height - self.padding[1] - \\\n                view_opts[0]['size'][1] - spacing / 2.\n            n = len(view_opts)\n            for i, val in enumerate(view_opts[1:], 1):\n                last -= spacing + val['size'][1]\n                pos[n - 1 - i] = last\n\n    def get_view_index_at(self, pos):\n        calc_pos = self._rv_positions\n        if not calc_pos:\n            return 0\n\n        x, y = pos\n\n        if self.orientation == 'horizontal':\n            if x >= calc_pos[-1] or len(calc_pos) == 1:\n                return len(calc_pos) - 1\n\n            ix = 0\n            for val in calc_pos[1:]:\n                if x < val:\n                    return ix\n                ix += 1\n        else:\n            if y >= calc_pos[-1] or len(calc_pos) == 1:\n                return 0\n\n            iy = 0\n            for val in calc_pos[1:]:\n                if y < val:\n                    return len(calc_pos) - iy - 1\n                iy += 1\n\n        assert False\n\n    def compute_visible_views(self, data, viewport):\n        if self._rv_positions is None or not data:\n            return []\n\n        x, y, w, h = viewport\n        at_idx = self.get_view_index_at\n        if self.orientation == 'horizontal':\n            a, b = at_idx((x, y)), at_idx((x + w, y))\n        else:\n            a, b = at_idx((x, y + h)), at_idx((x, y))\n        return list(range(a, b + 1))",
  "def __init__(self, **kwargs):\n        super(RecycleBoxLayout, self).__init__(**kwargs)\n        self.funbind('children', self._trigger_layout)",
  "def _update_sizes(self, changed):\n        horizontal = self.orientation == 'horizontal'\n        padding_left, padding_top, padding_right, padding_bottom = self.padding\n        padding_x = padding_left + padding_right\n        padding_y = padding_top + padding_bottom\n        selfw = self.width\n        selfh = self.height\n        layout_w = max(0, selfw - padding_x)\n        layout_h = max(0, selfh - padding_y)\n        cx = self.x + padding_left\n        cy = self.y + padding_bottom\n        view_opts = self.view_opts\n        remove_view = self.remove_view\n\n        for (index, widget, (w, h), (wn, hn), (shw, shh), (shnw, shnh),\n             (shw_min, shh_min), (shwn_min, shhn_min), (shw_max, shh_max),\n             (shwn_max, shhn_max), ph, phn) in changed:\n            if (horizontal and\n                (shw != shnw or w != wn or shw_min != shwn_min or\n                 shw_max != shwn_max) or\n                not horizontal and\n                (shh != shnh or h != hn or shh_min != shhn_min or\n                 shh_max != shhn_max)):\n                return True\n\n            remove_view(widget, index)\n            opt = view_opts[index]\n            if horizontal:\n                wo, ho = opt['size']\n                if shnh is not None:\n                    _, h = opt['size'] = [wo, shnh * layout_h]\n                else:\n                    h = ho\n\n                xo, yo = opt['pos']\n                for key, value in phn.items():\n                    posy = value * layout_h\n                    if key == 'y':\n                        yo = posy + cy\n                    elif key == 'top':\n                        yo = posy - h\n                    elif key == 'center_y':\n                        yo = posy - (h / 2.)\n                opt['pos'] = [xo, yo]\n            else:\n                wo, ho = opt['size']\n                if shnw is not None:\n                    w, _ = opt['size'] = [shnw * layout_w, ho]\n                else:\n                    w = wo\n\n                xo, yo = opt['pos']\n                for key, value in phn.items():\n                    posx = value * layout_w\n                    if key == 'x':\n                        xo = posx + cx\n                    elif key == 'right':\n                        xo = posx - w\n                    elif key == 'center_x':\n                        xo = posx - (w / 2.)\n                opt['pos'] = [xo, yo]\n\n        return False",
  "def compute_layout(self, data, flags):\n        super(RecycleBoxLayout, self).compute_layout(data, flags)\n\n        changed = self._changed_views\n        if (changed is None or\n                changed and not self._update_sizes(changed)):\n            return\n\n        self.clear_layout()\n        self._rv_positions = None\n        if not data:\n            l, t, r, b = self.padding\n            self.minimum_size = l + r, t + b\n            return\n\n        view_opts = self.view_opts\n        n = len(view_opts)\n        for i, x, y, w, h in self._iterate_layout(\n                [(opt['size'], opt['size_hint'], opt['pos_hint'],\n                  opt['size_hint_min'], opt['size_hint_max']) for\n                 opt in reversed(view_opts)]):\n            opt = view_opts[n - i - 1]\n            shw, shh = opt['size_hint']\n            opt['pos'] = x, y\n            wo, ho = opt['size']\n            # layout won't/shouldn't change previous size if size_hint is None\n            # which is what w/h being None means.\n            opt['size'] = [(wo if shw is None else w),\n                           (ho if shh is None else h)]\n\n        spacing = self.spacing\n        pos = self._rv_positions = [None, ] * len(data)\n\n        if self.orientation == 'horizontal':\n            pos[0] = self.x\n            last = pos[0] + self.padding[0] + view_opts[0]['size'][0] + \\\n                spacing / 2.\n            for i, val in enumerate(view_opts[1:], 1):\n                pos[i] = last\n                last += val['size'][0] + spacing\n        else:\n            last = pos[-1] = \\\n                self.y + self.height - self.padding[1] - \\\n                view_opts[0]['size'][1] - spacing / 2.\n            n = len(view_opts)\n            for i, val in enumerate(view_opts[1:], 1):\n                last -= spacing + val['size'][1]\n                pos[n - 1 - i] = last",
  "def get_view_index_at(self, pos):\n        calc_pos = self._rv_positions\n        if not calc_pos:\n            return 0\n\n        x, y = pos\n\n        if self.orientation == 'horizontal':\n            if x >= calc_pos[-1] or len(calc_pos) == 1:\n                return len(calc_pos) - 1\n\n            ix = 0\n            for val in calc_pos[1:]:\n                if x < val:\n                    return ix\n                ix += 1\n        else:\n            if y >= calc_pos[-1] or len(calc_pos) == 1:\n                return 0\n\n            iy = 0\n            for val in calc_pos[1:]:\n                if y < val:\n                    return len(calc_pos) - iy - 1\n                iy += 1\n\n        assert False",
  "def compute_visible_views(self, data, viewport):\n        if self._rv_positions is None or not data:\n            return []\n\n        x, y, w, h = viewport\n        at_idx = self.get_view_index_at\n        if self.orientation == 'horizontal':\n            a, b = at_idx((x, y)), at_idx((x + w, y))\n        else:\n            a, b = at_idx((x, y + h)), at_idx((x, y))\n        return list(range(a, b + 1))",
  "class Carousel(StencilView):\n    '''Carousel class. See module documentation for more information.\n    '''\n\n    slides = ListProperty([])\n    '''List of slides inside the Carousel. The slides are the\n    widgets added to the Carousel using the :attr:`add_widget` method.\n\n    :attr:`slides` is a :class:`~kivy.properties.ListProperty` and is\n    read-only.\n    '''\n\n    def _get_slides_container(self):\n        return [x.parent for x in self.slides]\n\n    slides_container = AliasProperty(_get_slides_container, bind=('slides',))\n\n    direction = OptionProperty('right',\n                               options=('right', 'left', 'top', 'bottom'))\n    '''Specifies the direction in which the slides are ordered. This\n    corresponds to the direction from which the user swipes to go from one\n    slide to the next. It\n    can be `right`, `left`, `top`, or `bottom`. For example, with\n    the default value of `right`, the second slide is to the right\n    of the first and the user would swipe from the right towards the\n    left to get to the second slide.\n\n    :attr:`direction` is an :class:`~kivy.properties.OptionProperty` and\n    defaults to 'right'.\n    '''\n\n    min_move = NumericProperty(0.2)\n    '''Defines the minimum distance to be covered before the touch is\n    considered a swipe gesture and the Carousel content changed.\n    This is a expressed as a fraction of the Carousel's width.\n    If the movement doesn't reach this minimum value, the movement is\n    cancelled and the content is restored to its original position.\n\n    :attr:`min_move` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.2.\n    '''\n\n    anim_move_duration = NumericProperty(0.5)\n    '''Defines the duration of the Carousel animation between pages.\n\n    :attr:`anim_move_duration` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 0.5.\n    '''\n\n    anim_cancel_duration = NumericProperty(0.3)\n    '''Defines the duration of the animation when a swipe movement is not\n    accepted. This is generally when the user does not make a large enough\n    swipe. See :attr:`min_move`.\n\n    :attr:`anim_cancel_duration` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to 0.3.\n    '''\n\n    loop = BooleanProperty(False)\n    '''Allow the Carousel to loop infinitely. If True, when the user tries to\n    swipe beyond last page, it will return to the first. If False, it will\n    remain on the last page.\n\n    :attr:`loop` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    def _get_index(self):\n        if self.slides:\n            return self._index % len(self.slides)\n        return None\n\n    def _set_index(self, value):\n        if self.slides:\n            self._index = value % len(self.slides)\n        else:\n            self._index = None\n\n    index = AliasProperty(_get_index, _set_index,\n                          bind=('_index', 'slides'),\n                          cache=True)\n    '''Get/Set the current slide based on the index.\n\n    :attr:`index` is an :class:`~kivy.properties.AliasProperty` and defaults\n    to 0 (the first item).\n    '''\n\n    def _prev_slide(self):\n        slides = self.slides\n        len_slides = len(slides)\n        index = self.index\n        if len_slides < 2:  # None, or 1 slide\n            return None\n        if self.loop and index == 0:\n            return slides[-1]\n        if index > 0:\n            return slides[index - 1]\n\n    previous_slide = AliasProperty(_prev_slide,\n                                   bind=('slides', 'index', 'loop'),\n                                   cache=True)\n    '''The previous slide in the Carousel. It is None if the current slide is\n    the first slide in the Carousel. This ordering reflects the order in which\n    the slides are added: their presentation varies according to the\n    :attr:`direction` property.\n\n    :attr:`previous_slide` is an :class:`~kivy.properties.AliasProperty`.\n\n    .. versionchanged:: 1.5.0\n        This property no longer exposes the slides container. It returns\n        the widget you have added.\n    '''\n\n    def _curr_slide(self):\n        if len(self.slides):\n            return self.slides[self.index or 0]\n\n    current_slide = AliasProperty(_curr_slide,\n                                  bind=('slides', 'index'),\n                                  cache=True)\n    '''The currently shown slide.\n\n    :attr:`current_slide` is an :class:`~kivy.properties.AliasProperty`.\n\n    .. versionchanged:: 1.5.0\n        The property no longer exposes the slides container. It returns\n        the widget you have added.\n    '''\n\n    def _next_slide(self):\n        if len(self.slides) < 2:  # None, or 1 slide\n            return None\n        if self.loop and self.index == len(self.slides) - 1:\n            return self.slides[0]\n        if self.index < len(self.slides) - 1:\n            return self.slides[self.index + 1]\n\n    next_slide = AliasProperty(_next_slide,\n                               bind=('slides', 'index', 'loop'),\n                               cache=True)\n    '''The next slide in the Carousel. It is None if the current slide is\n    the last slide in the Carousel. This ordering reflects the order in which\n    the slides are added: their presentation varies according to the\n    :attr:`direction` property.\n\n    :attr:`next_slide` is an :class:`~kivy.properties.AliasProperty`.\n\n    .. versionchanged:: 1.5.0\n        The property no longer exposes the slides container.\n        It returns the widget you have added.\n    '''\n\n    scroll_timeout = NumericProperty(200)\n    '''Timeout allowed to trigger the :attr:`scroll_distance`, in milliseconds.\n    If the user has not moved :attr:`scroll_distance` within the timeout,\n    no scrolling will occur and the touch event will go to the children.\n\n    :attr:`scroll_timeout` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 200 (milliseconds)\n\n    .. versionadded:: 1.5.0\n    '''\n\n    scroll_distance = NumericProperty('20dp')\n    '''Distance to move before scrolling the :class:`Carousel` in pixels. As\n    soon as the distance has been traveled, the :class:`Carousel` will start\n    to scroll, and no touch event will go to children.\n    It is advisable that you base this value on the dpi of your target device's\n    screen.\n\n    :attr:`scroll_distance` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 20dp.\n\n    .. versionadded:: 1.5.0\n    '''\n\n    anim_type = StringProperty('out_quad')\n    '''Type of animation to use while animating to the next/previous slide.\n    This should be the name of an\n    :class:`~kivy.animation.AnimationTransition` function.\n\n    :attr:`anim_type` is a :class:`~kivy.properties.StringProperty` and\n    defaults to 'out_quad'.\n\n    .. versionadded:: 1.8.0\n    '''\n\n    ignore_perpendicular_swipes = BooleanProperty(False)\n    '''Ignore swipes on axis perpendicular to direction.\n\n    :attr:`ignore_perpendicular_swipes` is a\n    :class:`~kivy.properties.BooleanProperty` and defaults to False.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    # private properties, for internal use only ###\n    _index = NumericProperty(0, allownone=True)\n    _prev = ObjectProperty(None, allownone=True)\n    _current = ObjectProperty(None, allownone=True)\n    _next = ObjectProperty(None, allownone=True)\n    _offset = NumericProperty(0)\n    _touch = ObjectProperty(None, allownone=True)\n\n    _change_touch_mode_ev = None\n\n    def __init__(self, **kwargs):\n        self._trigger_position_visible_slides = Clock.create_trigger(\n            self._position_visible_slides, -1)\n        super(Carousel, self).__init__(**kwargs)\n        self._skip_slide = None\n        self.touch_mode_change = False\n        self._prioritize_next = False\n        self.fbind('loop', lambda *args: self._insert_visible_slides())\n\n    def load_slide(self, slide):\n        '''Animate to the slide that is passed as the argument.\n\n        .. versionchanged:: 1.8.0\n        '''\n        slides = self.slides\n        start, stop = slides.index(self.current_slide), slides.index(slide)\n        if start == stop:\n            return\n\n        self._skip_slide = stop\n        if stop > start:\n            self._prioritize_next = True\n            self._insert_visible_slides(_next_slide=slide)\n            self.load_next()\n        else:\n            self._prioritize_next = False\n            self._insert_visible_slides(_prev_slide=slide)\n            self.load_previous()\n\n    def load_previous(self):\n        '''Animate to the previous slide.\n\n        .. versionadded:: 1.7.0\n        '''\n        self.load_next(mode='prev')\n\n    def load_next(self, mode='next'):\n        '''Animate to the next slide.\n\n        .. versionadded:: 1.7.0\n        '''\n        if self.index is not None:\n            w, h = self.size\n            _direction = {\n                'top': -h / 2,\n                'bottom': h / 2,\n                'left': w / 2,\n                'right': -w / 2}\n            _offset = _direction[self.direction]\n            if mode == 'prev':\n                _offset = -_offset\n\n            self._start_animation(min_move=0, offset=_offset)\n\n    def get_slide_container(self, slide):\n        return slide.parent\n\n    @property\n    def _prev_equals_next(self):\n        return self.loop and len(self.slides) == 2\n\n    def _insert_visible_slides(self, _next_slide=None, _prev_slide=None):\n        get_slide_container = self.get_slide_container\n\n        previous_slide = _prev_slide if _prev_slide else self.previous_slide\n        if previous_slide:\n            self._prev = get_slide_container(previous_slide)\n        else:\n            self._prev = None\n\n        current_slide = self.current_slide\n        if current_slide:\n            self._current = get_slide_container(current_slide)\n        else:\n            self._current = None\n\n        next_slide = _next_slide if _next_slide else self.next_slide\n        if next_slide:\n            self._next = get_slide_container(next_slide)\n        else:\n            self._next = None\n\n        if self._prev_equals_next:\n            setattr(self, '_prev' if self._prioritize_next else '_next', None)\n\n        super_remove = super(Carousel, self).remove_widget\n        for container in self.slides_container:\n            super_remove(container)\n\n        if self._prev and self._prev.parent is not self:\n            super(Carousel, self).add_widget(self._prev)\n        if self._next and self._next.parent is not self:\n            super(Carousel, self).add_widget(self._next)\n        if self._current:\n            super(Carousel, self).add_widget(self._current)\n\n    def _position_visible_slides(self, *args):\n        slides, index = self.slides, self.index\n        no_of_slides = len(slides) - 1\n        if not slides:\n            return\n        x, y, width, height = self.x, self.y, self.width, self.height\n        _offset, direction = self._offset, self.direction[0]\n        _prev, _next, _current = self._prev, self._next, self._current\n        get_slide_container = self.get_slide_container\n        last_slide = get_slide_container(slides[-1])\n        first_slide = get_slide_container(slides[0])\n        skip_next = False\n        _loop = self.loop\n\n        if direction in 'rl':\n            xoff = x + _offset\n            x_prev = {'l': xoff + width, 'r': xoff - width}\n            x_next = {'l': xoff - width, 'r': xoff + width}\n            if _prev:\n                _prev.pos = (x_prev[direction], y)\n            elif _loop and _next and index == 0:\n                # if first slide is moving to right with direction set to right\n                # or toward left with direction set to left\n                if ((_offset > 0 and direction == 'r') or\n                        (_offset < 0 and direction == 'l')):\n                    # put last_slide before first slide\n                    last_slide.pos = (x_prev[direction], y)\n                    skip_next = True\n            if _current:\n                _current.pos = (xoff, y)\n            if skip_next:\n                return\n            if _next:\n                _next.pos = (x_next[direction], y)\n            elif _loop and _prev and index == no_of_slides:\n                if ((_offset < 0 and direction == 'r') or\n                        (_offset > 0 and direction == 'l')):\n                    first_slide.pos = (x_next[direction], y)\n        if direction in 'tb':\n            yoff = y + _offset\n            y_prev = {'t': yoff - height, 'b': yoff + height}\n            y_next = {'t': yoff + height, 'b': yoff - height}\n            if _prev:\n                _prev.pos = (x, y_prev[direction])\n            elif _loop and _next and index == 0:\n                if ((_offset > 0 and direction == 't') or\n                        (_offset < 0 and direction == 'b')):\n                    last_slide.pos = (x, y_prev[direction])\n                    skip_next = True\n            if _current:\n                _current.pos = (x, yoff)\n            if skip_next:\n                return\n            if _next:\n                _next.pos = (x, y_next[direction])\n            elif _loop and _prev and index == no_of_slides:\n                if ((_offset < 0 and direction == 't') or\n                        (_offset > 0 and direction == 'b')):\n                    first_slide.pos = (x, y_next[direction])\n\n    def on_size(self, *args):\n        size = self.size\n        for slide in self.slides_container:\n            slide.size = size\n        self._trigger_position_visible_slides()\n\n    def on_pos(self, *args):\n        self._trigger_position_visible_slides()\n\n    def on_index(self, *args):\n        self._insert_visible_slides()\n        self._trigger_position_visible_slides()\n        self._offset = 0\n\n    def on_slides(self, *args):\n        if self.slides:\n            self.index = self.index % len(self.slides)\n        self._insert_visible_slides()\n        self._trigger_position_visible_slides()\n\n    def on__offset(self, *args):\n        self._trigger_position_visible_slides()\n        # if reached full offset, switch index to next or prev\n        direction = self.direction[0]\n        _offset = self._offset\n        width = self.width\n        height = self.height\n        index = self.index\n        if self._skip_slide is not None or index is None:\n            return\n\n        # Move to next slide?\n        if (direction == 'r' and _offset <= -width) or \\\n                (direction == 'l' and _offset >= width) or \\\n                (direction == 't' and _offset <= - height) or \\\n                (direction == 'b' and _offset >= height):\n            if self.next_slide:\n                self.index += 1\n\n        # Move to previous slide?\n        elif (direction == 'r' and _offset >= width) or \\\n                (direction == 'l' and _offset <= -width) or \\\n                (direction == 't' and _offset >= height) or \\\n                (direction == 'b' and _offset <= -height):\n            if self.previous_slide:\n                self.index -= 1\n\n        elif self._prev_equals_next:\n            new_value = (_offset < 0) is (direction in 'rt')\n            if self._prioritize_next is not new_value:\n                self._prioritize_next = new_value\n                if new_value is (self._next is None):\n                    self._prev, self._next = self._next, self._prev\n\n    def _start_animation(self, *args, **kwargs):\n        # compute target offset for ease back, next or prev\n        new_offset = 0\n        direction = kwargs.get('direction', self.direction)[0]\n        is_horizontal = direction in 'rl'\n        extent = self.width if is_horizontal else self.height\n        min_move = kwargs.get('min_move', self.min_move)\n        _offset = kwargs.get('offset', self._offset)\n\n        if _offset < min_move * -extent:\n            new_offset = -extent\n        elif _offset > min_move * extent:\n            new_offset = extent\n\n        # if new_offset is 0, it wasn't enough to go next/prev\n        dur = self.anim_move_duration\n        if new_offset == 0:\n            dur = self.anim_cancel_duration\n\n        # detect edge cases if not looping\n        len_slides = len(self.slides)\n        index = self.index\n        if not self.loop or len_slides == 1:\n            is_first = (index == 0)\n            is_last = (index == len_slides - 1)\n            if direction in 'rt':\n                towards_prev = (new_offset > 0)\n                towards_next = (new_offset < 0)\n            else:\n                towards_prev = (new_offset < 0)\n                towards_next = (new_offset > 0)\n            if (is_first and towards_prev) or (is_last and towards_next):\n                new_offset = 0\n\n        anim = Animation(_offset=new_offset, d=dur, t=self.anim_type)\n        anim.cancel_all(self)\n\n        def _cmp(*l):\n            if self._skip_slide is not None:\n                self.index = self._skip_slide\n                self._skip_slide = None\n\n        anim.bind(on_complete=_cmp)\n        anim.start(self)\n\n    def _get_uid(self, prefix='sv'):\n        return '{0}.{1}'.format(prefix, self.uid)\n\n    def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            touch.ud[self._get_uid('cavoid')] = True\n            return\n        if self.disabled:\n            return True\n        if self._touch:\n            return super(Carousel, self).on_touch_down(touch)\n        Animation.cancel_all(self)\n        self._touch = touch\n        uid = self._get_uid()\n        touch.grab(self)\n        touch.ud[uid] = {\n            'mode': 'unknown',\n            'time': touch.time_start}\n        self._change_touch_mode_ev = Clock.schedule_once(\n            self._change_touch_mode, self.scroll_timeout / 1000.)\n        self.touch_mode_change = False\n        return True\n\n    def on_touch_move(self, touch):\n        if not self.touch_mode_change:\n            if self.ignore_perpendicular_swipes and \\\n                    self.direction in ('top', 'bottom'):\n                if abs(touch.oy - touch.y) < self.scroll_distance:\n                    if abs(touch.ox - touch.x) > self.scroll_distance:\n                        self._change_touch_mode()\n                        self.touch_mode_change = True\n            elif self.ignore_perpendicular_swipes and \\\n                    self.direction in ('right', 'left'):\n                if abs(touch.ox - touch.x) < self.scroll_distance:\n                    if abs(touch.oy - touch.y) > self.scroll_distance:\n                        self._change_touch_mode()\n                        self.touch_mode_change = True\n\n        if self._get_uid('cavoid') in touch.ud:\n            return\n        if self._touch is not touch:\n            super(Carousel, self).on_touch_move(touch)\n            return self._get_uid() in touch.ud\n        if touch.grab_current is not self:\n            return True\n        ud = touch.ud[self._get_uid()]\n        direction = self.direction[0]\n        if ud['mode'] == 'unknown':\n            if direction in 'rl':\n                distance = abs(touch.ox - touch.x)\n            else:\n                distance = abs(touch.oy - touch.y)\n            if distance > self.scroll_distance:\n                ev = self._change_touch_mode_ev\n                if ev is not None:\n                    ev.cancel()\n                ud['mode'] = 'scroll'\n        else:\n            if direction in 'rl':\n                self._offset += touch.dx\n            if direction in 'tb':\n                self._offset += touch.dy\n        return True\n\n    def on_touch_up(self, touch):\n        if self._get_uid('cavoid') in touch.ud:\n            return\n        if self in [x() for x in touch.grab_list]:\n            touch.ungrab(self)\n            self._touch = None\n            ud = touch.ud[self._get_uid()]\n            if ud['mode'] == 'unknown':\n                ev = self._change_touch_mode_ev\n                if ev is not None:\n                    ev.cancel()\n                super(Carousel, self).on_touch_down(touch)\n                Clock.schedule_once(partial(self._do_touch_up, touch), .1)\n            else:\n                self._start_animation()\n\n        else:\n            if self._touch is not touch and self.uid not in touch.ud:\n                super(Carousel, self).on_touch_up(touch)\n        return self._get_uid() in touch.ud\n\n    def _do_touch_up(self, touch, *largs):\n        super(Carousel, self).on_touch_up(touch)\n        # don't forget about grab event!\n        for x in touch.grab_list[:]:\n            touch.grab_list.remove(x)\n            x = x()\n            if not x:\n                continue\n            touch.grab_current = x\n            super(Carousel, self).on_touch_up(touch)\n        touch.grab_current = None\n\n    def _change_touch_mode(self, *largs):\n        if not self._touch:\n            return\n        self._start_animation()\n        uid = self._get_uid()\n        touch = self._touch\n        ud = touch.ud[uid]\n        if ud['mode'] == 'unknown':\n            touch.ungrab(self)\n            self._touch = None\n            super(Carousel, self).on_touch_down(touch)\n            return\n\n    def add_widget(self, widget, index=0, *args, **kwargs):\n        container = RelativeLayout(\n            size=self.size, x=self.x - self.width, y=self.y)\n        container.add_widget(widget)\n        super(Carousel, self).add_widget(container, index, *args, **kwargs)\n        if index != 0:\n            self.slides.insert(index - len(self.slides), widget)\n        else:\n            self.slides.append(widget)\n\n    def remove_widget(self, widget, *args, **kwargs):\n        # XXX be careful, the widget.parent refer to the RelativeLayout\n        # added in add_widget(). But it will break if RelativeLayout\n        # implementation change.\n        # if we passed the real widget\n        slides = self.slides\n        if widget in slides:\n            if self.index >= slides.index(widget):\n                self.index = max(0, self.index - 1)\n            container = widget.parent\n            slides.remove(widget)\n            super(Carousel, self).remove_widget(container, *args, **kwargs)\n            container.remove_widget(widget)\n            return\n        super(Carousel, self).remove_widget(widget, *args, **kwargs)\n\n    def clear_widgets(self, children=None, *args, **kwargs):\n        # `children` must be a list of slides or None\n        if children is None:\n            children = self.slides[:]\n        remove_widget = self.remove_widget\n        for widget in children:\n            remove_widget(widget)\n        super(Carousel, self).clear_widgets()",
  "def _get_slides_container(self):\n        return [x.parent for x in self.slides]",
  "def _get_index(self):\n        if self.slides:\n            return self._index % len(self.slides)\n        return None",
  "def _set_index(self, value):\n        if self.slides:\n            self._index = value % len(self.slides)\n        else:\n            self._index = None",
  "def _prev_slide(self):\n        slides = self.slides\n        len_slides = len(slides)\n        index = self.index\n        if len_slides < 2:  # None, or 1 slide\n            return None\n        if self.loop and index == 0:\n            return slides[-1]\n        if index > 0:\n            return slides[index - 1]",
  "def _curr_slide(self):\n        if len(self.slides):\n            return self.slides[self.index or 0]",
  "def _next_slide(self):\n        if len(self.slides) < 2:  # None, or 1 slide\n            return None\n        if self.loop and self.index == len(self.slides) - 1:\n            return self.slides[0]\n        if self.index < len(self.slides) - 1:\n            return self.slides[self.index + 1]",
  "def __init__(self, **kwargs):\n        self._trigger_position_visible_slides = Clock.create_trigger(\n            self._position_visible_slides, -1)\n        super(Carousel, self).__init__(**kwargs)\n        self._skip_slide = None\n        self.touch_mode_change = False\n        self._prioritize_next = False\n        self.fbind('loop', lambda *args: self._insert_visible_slides())",
  "def load_slide(self, slide):\n        '''Animate to the slide that is passed as the argument.\n\n        .. versionchanged:: 1.8.0\n        '''\n        slides = self.slides\n        start, stop = slides.index(self.current_slide), slides.index(slide)\n        if start == stop:\n            return\n\n        self._skip_slide = stop\n        if stop > start:\n            self._prioritize_next = True\n            self._insert_visible_slides(_next_slide=slide)\n            self.load_next()\n        else:\n            self._prioritize_next = False\n            self._insert_visible_slides(_prev_slide=slide)\n            self.load_previous()",
  "def load_previous(self):\n        '''Animate to the previous slide.\n\n        .. versionadded:: 1.7.0\n        '''\n        self.load_next(mode='prev')",
  "def load_next(self, mode='next'):\n        '''Animate to the next slide.\n\n        .. versionadded:: 1.7.0\n        '''\n        if self.index is not None:\n            w, h = self.size\n            _direction = {\n                'top': -h / 2,\n                'bottom': h / 2,\n                'left': w / 2,\n                'right': -w / 2}\n            _offset = _direction[self.direction]\n            if mode == 'prev':\n                _offset = -_offset\n\n            self._start_animation(min_move=0, offset=_offset)",
  "def get_slide_container(self, slide):\n        return slide.parent",
  "def _prev_equals_next(self):\n        return self.loop and len(self.slides) == 2",
  "def _insert_visible_slides(self, _next_slide=None, _prev_slide=None):\n        get_slide_container = self.get_slide_container\n\n        previous_slide = _prev_slide if _prev_slide else self.previous_slide\n        if previous_slide:\n            self._prev = get_slide_container(previous_slide)\n        else:\n            self._prev = None\n\n        current_slide = self.current_slide\n        if current_slide:\n            self._current = get_slide_container(current_slide)\n        else:\n            self._current = None\n\n        next_slide = _next_slide if _next_slide else self.next_slide\n        if next_slide:\n            self._next = get_slide_container(next_slide)\n        else:\n            self._next = None\n\n        if self._prev_equals_next:\n            setattr(self, '_prev' if self._prioritize_next else '_next', None)\n\n        super_remove = super(Carousel, self).remove_widget\n        for container in self.slides_container:\n            super_remove(container)\n\n        if self._prev and self._prev.parent is not self:\n            super(Carousel, self).add_widget(self._prev)\n        if self._next and self._next.parent is not self:\n            super(Carousel, self).add_widget(self._next)\n        if self._current:\n            super(Carousel, self).add_widget(self._current)",
  "def _position_visible_slides(self, *args):\n        slides, index = self.slides, self.index\n        no_of_slides = len(slides) - 1\n        if not slides:\n            return\n        x, y, width, height = self.x, self.y, self.width, self.height\n        _offset, direction = self._offset, self.direction[0]\n        _prev, _next, _current = self._prev, self._next, self._current\n        get_slide_container = self.get_slide_container\n        last_slide = get_slide_container(slides[-1])\n        first_slide = get_slide_container(slides[0])\n        skip_next = False\n        _loop = self.loop\n\n        if direction in 'rl':\n            xoff = x + _offset\n            x_prev = {'l': xoff + width, 'r': xoff - width}\n            x_next = {'l': xoff - width, 'r': xoff + width}\n            if _prev:\n                _prev.pos = (x_prev[direction], y)\n            elif _loop and _next and index == 0:\n                # if first slide is moving to right with direction set to right\n                # or toward left with direction set to left\n                if ((_offset > 0 and direction == 'r') or\n                        (_offset < 0 and direction == 'l')):\n                    # put last_slide before first slide\n                    last_slide.pos = (x_prev[direction], y)\n                    skip_next = True\n            if _current:\n                _current.pos = (xoff, y)\n            if skip_next:\n                return\n            if _next:\n                _next.pos = (x_next[direction], y)\n            elif _loop and _prev and index == no_of_slides:\n                if ((_offset < 0 and direction == 'r') or\n                        (_offset > 0 and direction == 'l')):\n                    first_slide.pos = (x_next[direction], y)\n        if direction in 'tb':\n            yoff = y + _offset\n            y_prev = {'t': yoff - height, 'b': yoff + height}\n            y_next = {'t': yoff + height, 'b': yoff - height}\n            if _prev:\n                _prev.pos = (x, y_prev[direction])\n            elif _loop and _next and index == 0:\n                if ((_offset > 0 and direction == 't') or\n                        (_offset < 0 and direction == 'b')):\n                    last_slide.pos = (x, y_prev[direction])\n                    skip_next = True\n            if _current:\n                _current.pos = (x, yoff)\n            if skip_next:\n                return\n            if _next:\n                _next.pos = (x, y_next[direction])\n            elif _loop and _prev and index == no_of_slides:\n                if ((_offset < 0 and direction == 't') or\n                        (_offset > 0 and direction == 'b')):\n                    first_slide.pos = (x, y_next[direction])",
  "def on_size(self, *args):\n        size = self.size\n        for slide in self.slides_container:\n            slide.size = size\n        self._trigger_position_visible_slides()",
  "def on_pos(self, *args):\n        self._trigger_position_visible_slides()",
  "def on_index(self, *args):\n        self._insert_visible_slides()\n        self._trigger_position_visible_slides()\n        self._offset = 0",
  "def on_slides(self, *args):\n        if self.slides:\n            self.index = self.index % len(self.slides)\n        self._insert_visible_slides()\n        self._trigger_position_visible_slides()",
  "def on__offset(self, *args):\n        self._trigger_position_visible_slides()\n        # if reached full offset, switch index to next or prev\n        direction = self.direction[0]\n        _offset = self._offset\n        width = self.width\n        height = self.height\n        index = self.index\n        if self._skip_slide is not None or index is None:\n            return\n\n        # Move to next slide?\n        if (direction == 'r' and _offset <= -width) or \\\n                (direction == 'l' and _offset >= width) or \\\n                (direction == 't' and _offset <= - height) or \\\n                (direction == 'b' and _offset >= height):\n            if self.next_slide:\n                self.index += 1\n\n        # Move to previous slide?\n        elif (direction == 'r' and _offset >= width) or \\\n                (direction == 'l' and _offset <= -width) or \\\n                (direction == 't' and _offset >= height) or \\\n                (direction == 'b' and _offset <= -height):\n            if self.previous_slide:\n                self.index -= 1\n\n        elif self._prev_equals_next:\n            new_value = (_offset < 0) is (direction in 'rt')\n            if self._prioritize_next is not new_value:\n                self._prioritize_next = new_value\n                if new_value is (self._next is None):\n                    self._prev, self._next = self._next, self._prev",
  "def _start_animation(self, *args, **kwargs):\n        # compute target offset for ease back, next or prev\n        new_offset = 0\n        direction = kwargs.get('direction', self.direction)[0]\n        is_horizontal = direction in 'rl'\n        extent = self.width if is_horizontal else self.height\n        min_move = kwargs.get('min_move', self.min_move)\n        _offset = kwargs.get('offset', self._offset)\n\n        if _offset < min_move * -extent:\n            new_offset = -extent\n        elif _offset > min_move * extent:\n            new_offset = extent\n\n        # if new_offset is 0, it wasn't enough to go next/prev\n        dur = self.anim_move_duration\n        if new_offset == 0:\n            dur = self.anim_cancel_duration\n\n        # detect edge cases if not looping\n        len_slides = len(self.slides)\n        index = self.index\n        if not self.loop or len_slides == 1:\n            is_first = (index == 0)\n            is_last = (index == len_slides - 1)\n            if direction in 'rt':\n                towards_prev = (new_offset > 0)\n                towards_next = (new_offset < 0)\n            else:\n                towards_prev = (new_offset < 0)\n                towards_next = (new_offset > 0)\n            if (is_first and towards_prev) or (is_last and towards_next):\n                new_offset = 0\n\n        anim = Animation(_offset=new_offset, d=dur, t=self.anim_type)\n        anim.cancel_all(self)\n\n        def _cmp(*l):\n            if self._skip_slide is not None:\n                self.index = self._skip_slide\n                self._skip_slide = None\n\n        anim.bind(on_complete=_cmp)\n        anim.start(self)",
  "def _get_uid(self, prefix='sv'):\n        return '{0}.{1}'.format(prefix, self.uid)",
  "def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            touch.ud[self._get_uid('cavoid')] = True\n            return\n        if self.disabled:\n            return True\n        if self._touch:\n            return super(Carousel, self).on_touch_down(touch)\n        Animation.cancel_all(self)\n        self._touch = touch\n        uid = self._get_uid()\n        touch.grab(self)\n        touch.ud[uid] = {\n            'mode': 'unknown',\n            'time': touch.time_start}\n        self._change_touch_mode_ev = Clock.schedule_once(\n            self._change_touch_mode, self.scroll_timeout / 1000.)\n        self.touch_mode_change = False\n        return True",
  "def on_touch_move(self, touch):\n        if not self.touch_mode_change:\n            if self.ignore_perpendicular_swipes and \\\n                    self.direction in ('top', 'bottom'):\n                if abs(touch.oy - touch.y) < self.scroll_distance:\n                    if abs(touch.ox - touch.x) > self.scroll_distance:\n                        self._change_touch_mode()\n                        self.touch_mode_change = True\n            elif self.ignore_perpendicular_swipes and \\\n                    self.direction in ('right', 'left'):\n                if abs(touch.ox - touch.x) < self.scroll_distance:\n                    if abs(touch.oy - touch.y) > self.scroll_distance:\n                        self._change_touch_mode()\n                        self.touch_mode_change = True\n\n        if self._get_uid('cavoid') in touch.ud:\n            return\n        if self._touch is not touch:\n            super(Carousel, self).on_touch_move(touch)\n            return self._get_uid() in touch.ud\n        if touch.grab_current is not self:\n            return True\n        ud = touch.ud[self._get_uid()]\n        direction = self.direction[0]\n        if ud['mode'] == 'unknown':\n            if direction in 'rl':\n                distance = abs(touch.ox - touch.x)\n            else:\n                distance = abs(touch.oy - touch.y)\n            if distance > self.scroll_distance:\n                ev = self._change_touch_mode_ev\n                if ev is not None:\n                    ev.cancel()\n                ud['mode'] = 'scroll'\n        else:\n            if direction in 'rl':\n                self._offset += touch.dx\n            if direction in 'tb':\n                self._offset += touch.dy\n        return True",
  "def on_touch_up(self, touch):\n        if self._get_uid('cavoid') in touch.ud:\n            return\n        if self in [x() for x in touch.grab_list]:\n            touch.ungrab(self)\n            self._touch = None\n            ud = touch.ud[self._get_uid()]\n            if ud['mode'] == 'unknown':\n                ev = self._change_touch_mode_ev\n                if ev is not None:\n                    ev.cancel()\n                super(Carousel, self).on_touch_down(touch)\n                Clock.schedule_once(partial(self._do_touch_up, touch), .1)\n            else:\n                self._start_animation()\n\n        else:\n            if self._touch is not touch and self.uid not in touch.ud:\n                super(Carousel, self).on_touch_up(touch)\n        return self._get_uid() in touch.ud",
  "def _do_touch_up(self, touch, *largs):\n        super(Carousel, self).on_touch_up(touch)\n        # don't forget about grab event!\n        for x in touch.grab_list[:]:\n            touch.grab_list.remove(x)\n            x = x()\n            if not x:\n                continue\n            touch.grab_current = x\n            super(Carousel, self).on_touch_up(touch)\n        touch.grab_current = None",
  "def _change_touch_mode(self, *largs):\n        if not self._touch:\n            return\n        self._start_animation()\n        uid = self._get_uid()\n        touch = self._touch\n        ud = touch.ud[uid]\n        if ud['mode'] == 'unknown':\n            touch.ungrab(self)\n            self._touch = None\n            super(Carousel, self).on_touch_down(touch)\n            return",
  "def add_widget(self, widget, index=0, *args, **kwargs):\n        container = RelativeLayout(\n            size=self.size, x=self.x - self.width, y=self.y)\n        container.add_widget(widget)\n        super(Carousel, self).add_widget(container, index, *args, **kwargs)\n        if index != 0:\n            self.slides.insert(index - len(self.slides), widget)\n        else:\n            self.slides.append(widget)",
  "def remove_widget(self, widget, *args, **kwargs):\n        # XXX be careful, the widget.parent refer to the RelativeLayout\n        # added in add_widget(). But it will break if RelativeLayout\n        # implementation change.\n        # if we passed the real widget\n        slides = self.slides\n        if widget in slides:\n            if self.index >= slides.index(widget):\n                self.index = max(0, self.index - 1)\n            container = widget.parent\n            slides.remove(widget)\n            super(Carousel, self).remove_widget(container, *args, **kwargs)\n            container.remove_widget(widget)\n            return\n        super(Carousel, self).remove_widget(widget, *args, **kwargs)",
  "def clear_widgets(self, children=None, *args, **kwargs):\n        # `children` must be a list of slides or None\n        if children is None:\n            children = self.slides[:]\n        remove_widget = self.remove_widget\n        for widget in children:\n            remove_widget(widget)\n        super(Carousel, self).clear_widgets()",
  "class Example1(App):\n\n        def build(self):\n            carousel = Carousel(direction='left',\n                                loop=True)\n            for i in range(4):\n                src = \"http://placehold.it/480x270.png&text=slide-%d&.png\" % i\n                image = Factory.AsyncImage(source=src, fit_mode=\"contain\")\n                carousel.add_widget(image)\n            return carousel",
  "def _cmp(*l):\n            if self._skip_slide is not None:\n                self.index = self._skip_slide\n                self._skip_slide = None",
  "def build(self):\n            carousel = Carousel(direction='left',\n                                loop=True)\n            for i in range(4):\n                src = \"http://placehold.it/480x270.png&text=slide-%d&.png\" % i\n                image = Factory.AsyncImage(source=src, fit_mode=\"contain\")\n                carousel.add_widget(image)\n            return carousel",
  "class Camera(Image):\n    '''Camera class. See module documentation for more information.\n    '''\n\n    play = BooleanProperty(False)\n    '''Boolean indicating whether the camera is playing or not.\n    You can start/stop the camera by setting this property::\n\n        # start the camera playing at creation\n        cam = Camera(play=True)\n\n        # create the camera, and start later (default)\n        cam = Camera(play=False)\n        # and later\n        cam.play = True\n\n    :attr:`play` is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.\n    '''\n\n    index = NumericProperty(-1)\n    '''Index of the used camera, starting from 0.\n\n    :attr:`index` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to -1 to allow auto selection.\n    '''\n\n    resolution = ListProperty([-1, -1])\n    '''Preferred resolution to use when invoking the camera. If you are using\n    [-1, -1], the resolution will be the default one::\n\n        # create a camera object with the best image available\n        cam = Camera()\n\n        # create a camera object with an image of 320x240 if possible\n        cam = Camera(resolution=(320, 240))\n\n    .. warning::\n\n        Depending on the implementation, the camera may not respect this\n        property.\n\n    :attr:`resolution` is a :class:`~kivy.properties.ListProperty` and defaults\n    to [-1, -1].\n    '''\n\n    def __init__(self, **kwargs):\n        self._camera = None\n        super(Camera, self).__init__(**kwargs)\n        if self.index == -1:\n            self.index = 0\n        on_index = self._on_index\n        fbind = self.fbind\n        fbind('index', on_index)\n        fbind('resolution', on_index)\n        on_index()\n\n    def on_tex(self, camera):\n        self.texture = texture = camera.texture\n        self.texture_size = list(texture.size)\n        self.canvas.ask_update()\n\n    def _on_index(self, *largs):\n        self._camera = None\n        if self.index < 0:\n            return\n        if self.resolution[0] < 0 or self.resolution[1] < 0:\n            self._camera = CoreCamera(index=self.index, stopped=True)\n        else:\n            self._camera = CoreCamera(index=self.index,\n                                      resolution=self.resolution, stopped=True)\n        if self.play:\n            self._camera.start()\n\n        self._camera.bind(on_texture=self.on_tex)\n\n    def on_play(self, instance, value):\n        if not self._camera:\n            return\n        if value:\n            self._camera.start()\n        else:\n            self._camera.stop()",
  "def __init__(self, **kwargs):\n        self._camera = None\n        super(Camera, self).__init__(**kwargs)\n        if self.index == -1:\n            self.index = 0\n        on_index = self._on_index\n        fbind = self.fbind\n        fbind('index', on_index)\n        fbind('resolution', on_index)\n        on_index()",
  "def on_tex(self, camera):\n        self.texture = texture = camera.texture\n        self.texture_size = list(texture.size)\n        self.canvas.ask_update()",
  "def _on_index(self, *largs):\n        self._camera = None\n        if self.index < 0:\n            return\n        if self.resolution[0] < 0 or self.resolution[1] < 0:\n            self._camera = CoreCamera(index=self.index, stopped=True)\n        else:\n            self._camera = CoreCamera(index=self.index,\n                                      resolution=self.resolution, stopped=True)\n        if self.play:\n            self._camera.start()\n\n        self._camera.bind(on_texture=self.on_tex)",
  "def on_play(self, instance, value):\n        if not self._camera:\n            return\n        if value:\n            self._camera.start()\n        else:\n            self._camera.stop()",
  "class RelativeLayout(FloatLayout):\n    '''RelativeLayout class, see module documentation for more information.\n    '''\n\n    def __init__(self, **kw):\n        super(RelativeLayout, self).__init__(**kw)\n        funbind = self.funbind\n        trigger = self._trigger_layout\n        funbind('pos', trigger)\n        funbind('pos_hint', trigger)\n\n    def do_layout(self, *args):\n        super(RelativeLayout, self).do_layout(pos=(0, 0))\n\n    def to_parent(self, x, y, **k):\n        return (x + self.x, y + self.y)\n\n    def to_local(self, x, y, **k):\n        return (x - self.x, y - self.y)\n\n    def _apply_transform(self, m, pos=None):\n        m.translate(self.x, self.y, 0)\n        return super(RelativeLayout, self)._apply_transform(m, (0, 0))\n\n    def on_motion(self, etype, me):\n        if me.type_id in self.motion_filter and 'pos' in me.profile:\n            me.push()\n            me.apply_transform_2d(self.to_local)\n            ret = super().on_motion(etype, me)\n            me.pop()\n            return ret\n        return super().on_motion(etype, me)\n\n    def on_touch_down(self, touch):\n        x, y = touch.x, touch.y\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        ret = super(RelativeLayout, self).on_touch_down(touch)\n        touch.pop()\n        return ret\n\n    def on_touch_move(self, touch):\n        x, y = touch.x, touch.y\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        ret = super(RelativeLayout, self).on_touch_move(touch)\n        touch.pop()\n        return ret\n\n    def on_touch_up(self, touch):\n        x, y = touch.x, touch.y\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        ret = super(RelativeLayout, self).on_touch_up(touch)\n        touch.pop()\n        return ret",
  "def __init__(self, **kw):\n        super(RelativeLayout, self).__init__(**kw)\n        funbind = self.funbind\n        trigger = self._trigger_layout\n        funbind('pos', trigger)\n        funbind('pos_hint', trigger)",
  "def do_layout(self, *args):\n        super(RelativeLayout, self).do_layout(pos=(0, 0))",
  "def to_parent(self, x, y, **k):\n        return (x + self.x, y + self.y)",
  "def to_local(self, x, y, **k):\n        return (x - self.x, y - self.y)",
  "def _apply_transform(self, m, pos=None):\n        m.translate(self.x, self.y, 0)\n        return super(RelativeLayout, self)._apply_transform(m, (0, 0))",
  "def on_motion(self, etype, me):\n        if me.type_id in self.motion_filter and 'pos' in me.profile:\n            me.push()\n            me.apply_transform_2d(self.to_local)\n            ret = super().on_motion(etype, me)\n            me.pop()\n            return ret\n        return super().on_motion(etype, me)",
  "def on_touch_down(self, touch):\n        x, y = touch.x, touch.y\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        ret = super(RelativeLayout, self).on_touch_down(touch)\n        touch.pop()\n        return ret",
  "def on_touch_move(self, touch):\n        x, y = touch.x, touch.y\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        ret = super(RelativeLayout, self).on_touch_move(touch)\n        touch.pop()\n        return ret",
  "def on_touch_up(self, touch):\n        x, y = touch.x, touch.y\n        touch.push()\n        touch.apply_transform_2d(self.to_local)\n        ret = super(RelativeLayout, self).on_touch_up(touch)\n        touch.pop()\n        return ret",
  "class SpinnerOption(Button):\n    '''Special button used in the :class:`Spinner` dropdown list. By default,\n    this is just a :class:`~kivy.uix.button.Button` with a size_hint_y of None\n    and a height of :meth:`48dp <kivy.metrics.dp>`.\n    '''\n    pass",
  "class Spinner(Button):\n    '''Spinner class, see module documentation for more information.\n    '''\n\n    values = ListProperty()\n    '''Values that can be selected by the user. It must be a list of strings.\n\n    :attr:`values` is a :class:`~kivy.properties.ListProperty` and defaults to\n    [].\n    '''\n\n    text_autoupdate = BooleanProperty(False)\n    '''Indicates if the spinner's :attr:`text` should be automatically\n    updated with the first value of the :attr:`values` property.\n    Setting it to True will cause the spinner to update its :attr:`text`\n    property every time attr:`values` are changed.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`text_autoupdate` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    option_cls = ObjectProperty(SpinnerOption)\n    '''Class used to display the options within the dropdown list displayed\n    under the Spinner. The `text` property of the class will be used to\n    represent the value.\n\n    The option class requires:\n\n    - a `text` property, used to display the value.\n    - an `on_release` event, used to trigger the option when pressed/touched.\n    - a :attr:`~kivy.uix.widget.Widget.size_hint_y` of None.\n    - the :attr:`~kivy.uix.widget.Widget.height` to be set.\n\n    :attr:`option_cls` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to :class:`SpinnerOption`.\n\n    .. versionchanged:: 1.8.0\n        If you set a string, the :class:`~kivy.factory.Factory` will be used to\n        resolve the class.\n\n    '''\n\n    dropdown_cls = ObjectProperty(DropDown)\n    '''Class used to display the dropdown list when the Spinner is pressed.\n\n    :attr:`dropdown_cls` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to :class:`~kivy.uix.dropdown.DropDown`.\n\n    .. versionchanged:: 1.8.0\n        If set to a string, the :class:`~kivy.factory.Factory` will be used to\n        resolve the class name.\n\n    '''\n\n    is_open = BooleanProperty(False)\n    '''By default, the spinner is not open. Set to True to open it.\n\n    :attr:`is_open` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n\n    .. versionadded:: 1.4.0\n    '''\n\n    sync_height = BooleanProperty(False)\n    '''Each element in a dropdown list uses a default/user-supplied height.\n    Set to True to propagate the Spinner's height value to each dropdown\n    list element.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`sync_height` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    def __init__(self, **kwargs):\n        self._dropdown = None\n        super(Spinner, self).__init__(**kwargs)\n        fbind = self.fbind\n        build_dropdown = self._build_dropdown\n        fbind('on_release', self._toggle_dropdown)\n        fbind('dropdown_cls', build_dropdown)\n        fbind('option_cls', build_dropdown)\n        fbind('values', self._update_dropdown)\n        fbind('size', self._update_dropdown_size)\n        fbind('text_autoupdate', self._update_dropdown)\n        build_dropdown()\n\n    def _build_dropdown(self, *largs):\n        if self._dropdown:\n            self._dropdown.unbind(on_select=self._on_dropdown_select)\n            self._dropdown.unbind(on_dismiss=self._close_dropdown)\n            self._dropdown.dismiss()\n            self._dropdown = None\n        cls = self.dropdown_cls\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n        self._dropdown = cls()\n        self._dropdown.bind(on_select=self._on_dropdown_select)\n        self._dropdown.bind(on_dismiss=self._close_dropdown)\n        self._update_dropdown()\n\n    def _update_dropdown_size(self, *largs):\n        if not self.sync_height:\n            return\n        dp = self._dropdown\n        if not dp:\n            return\n\n        container = dp.container\n        if not container:\n            return\n        h = self.height\n        for item in container.children[:]:\n            item.height = h\n\n    def _update_dropdown(self, *largs):\n        dp = self._dropdown\n        cls = self.option_cls\n        values = self.values\n        text_autoupdate = self.text_autoupdate\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n        dp.clear_widgets()\n        for value in values:\n            item = cls(text=value)\n            item.height = self.height if self.sync_height else item.height\n            item.bind(on_release=lambda option: dp.select(option.text))\n            dp.add_widget(item)\n        if text_autoupdate:\n            if values:\n                if not self.text or self.text not in values:\n                    self.text = values[0]\n            else:\n                self.text = ''\n\n    def _toggle_dropdown(self, *largs):\n        if self.values:\n            self.is_open = not self.is_open\n\n    def _close_dropdown(self, *largs):\n        self.is_open = False\n\n    def _on_dropdown_select(self, instance, data, *largs):\n        self.text = data\n        self.is_open = False\n\n    def on_is_open(self, instance, value):\n        if value:\n            self._dropdown.open(self)\n        else:\n            if self._dropdown.attach_to:\n                self._dropdown.dismiss()",
  "def __init__(self, **kwargs):\n        self._dropdown = None\n        super(Spinner, self).__init__(**kwargs)\n        fbind = self.fbind\n        build_dropdown = self._build_dropdown\n        fbind('on_release', self._toggle_dropdown)\n        fbind('dropdown_cls', build_dropdown)\n        fbind('option_cls', build_dropdown)\n        fbind('values', self._update_dropdown)\n        fbind('size', self._update_dropdown_size)\n        fbind('text_autoupdate', self._update_dropdown)\n        build_dropdown()",
  "def _build_dropdown(self, *largs):\n        if self._dropdown:\n            self._dropdown.unbind(on_select=self._on_dropdown_select)\n            self._dropdown.unbind(on_dismiss=self._close_dropdown)\n            self._dropdown.dismiss()\n            self._dropdown = None\n        cls = self.dropdown_cls\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n        self._dropdown = cls()\n        self._dropdown.bind(on_select=self._on_dropdown_select)\n        self._dropdown.bind(on_dismiss=self._close_dropdown)\n        self._update_dropdown()",
  "def _update_dropdown_size(self, *largs):\n        if not self.sync_height:\n            return\n        dp = self._dropdown\n        if not dp:\n            return\n\n        container = dp.container\n        if not container:\n            return\n        h = self.height\n        for item in container.children[:]:\n            item.height = h",
  "def _update_dropdown(self, *largs):\n        dp = self._dropdown\n        cls = self.option_cls\n        values = self.values\n        text_autoupdate = self.text_autoupdate\n        if isinstance(cls, string_types):\n            cls = Factory.get(cls)\n        dp.clear_widgets()\n        for value in values:\n            item = cls(text=value)\n            item.height = self.height if self.sync_height else item.height\n            item.bind(on_release=lambda option: dp.select(option.text))\n            dp.add_widget(item)\n        if text_autoupdate:\n            if values:\n                if not self.text or self.text not in values:\n                    self.text = values[0]\n            else:\n                self.text = ''",
  "def _toggle_dropdown(self, *largs):\n        if self.values:\n            self.is_open = not self.is_open",
  "def _close_dropdown(self, *largs):\n        self.is_open = False",
  "def _on_dropdown_select(self, instance, data, *largs):\n        self.text = data\n        self.is_open = False",
  "def on_is_open(self, instance, value):\n        if value:\n            self._dropdown.open(self)\n        else:\n            if self._dropdown.attach_to:\n                self._dropdown.dismiss()",
  "class RecycleLayout(RecycleLayoutManagerBehavior, Layout):\n    \"\"\"\n    RecycleLayout provides the default layout for RecycleViews.\n    \"\"\"\n\n    default_width = NumericProperty(100, allownone=True)\n    '''Default width for items\n\n    :attr:`default_width` is a NumericProperty and default to 100\n    '''\n    default_height = NumericProperty(100, allownone=True)\n    '''Default height for items\n\n    :attr:`default_height` is a :class:`~kivy.properties.NumericProperty` and\n    default to 100.\n    '''\n    default_size = ReferenceListProperty(default_width, default_height)\n    '''size (width, height). Each value can be None.\n\n    :attr:`default_size` is an :class:`~kivy.properties.ReferenceListProperty`\n    to [:attr:`default_width`, :attr:`default_height`].\n    '''\n    default_size_hint_x = NumericProperty(None, allownone=True)\n    '''Default size_hint_x for items\n\n    :attr:`default_size_hint_x` is a :class:`~kivy.properties.NumericProperty`\n    and default to None.\n    '''\n    default_size_hint_y = NumericProperty(None, allownone=True)\n    '''Default size_hint_y for items\n\n    :attr:`default_size_hint_y` is a :class:`~kivy.properties.NumericProperty`\n    and default to None.\n    '''\n    default_size_hint = ReferenceListProperty(\n        default_size_hint_x, default_size_hint_y\n    )\n    '''size (width, height). Each value can be None.\n\n    :attr:`default_size_hint` is an\n    :class:`~kivy.properties.ReferenceListProperty` to\n    [:attr:`default_size_hint_x`, :attr:`default_size_hint_y`].\n    '''\n\n    key_size = StringProperty(None, allownone=True)\n    '''If set, which key in the dict should be used to set the size property of\n    the item.\n\n    :attr:`key_size` is a :class:`~kivy.properties.StringProperty` and defaults\n    to None.\n    '''\n    key_size_hint = StringProperty(None, allownone=True)\n    '''If set, which key in the dict should be used to set the size_hint\n    property of the item.\n\n    :attr:`key_size_hint` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    key_size_hint_min = StringProperty(None, allownone=True)\n    '''If set, which key in the dict should be used to set the size_hint_min\n    property of the item.\n\n    :attr:`key_size_hint_min` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n    default_size_hint_x_min = NumericProperty(None, allownone=True)\n    '''Default value for size_hint_x_min of items\n\n    :attr:`default_pos_hint_x_min` is a\n    :class:`~kivy.properties.NumericProperty` and defaults to None.\n    '''\n    default_size_hint_y_min = NumericProperty(None, allownone=True)\n    '''Default value for size_hint_y_min of items\n\n    :attr:`default_pos_hint_y_min` is a\n    :class:`~kivy.properties.NumericProperty` and defaults to None.\n    '''\n    default_size_hint_min = ReferenceListProperty(\n        default_size_hint_x_min,\n        default_size_hint_y_min\n    )\n    '''Default value for size_hint_min of items\n\n    :attr:`default_size_min` is a\n    :class:`~kivy.properties.ReferenceListProperty` to\n    [:attr:`default_size_hint_x_min`, :attr:`default_size_hint_y_min`].\n    '''\n\n    key_size_hint_max = StringProperty(None, allownone=True)\n    '''If set, which key in the dict should be used to set the size_hint_max\n    property of the item.\n\n    :attr:`key_size_hint_max` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n    default_size_hint_x_max = NumericProperty(None, allownone=True)\n    '''Default value for size_hint_x_max of items\n\n    :attr:`default_pos_hint_x_max` is a\n    :class:`~kivy.properties.NumericProperty` and defaults to None.\n    '''\n    default_size_hint_y_max = NumericProperty(None, allownone=True)\n    '''Default value for size_hint_y_max of items\n\n    :attr:`default_pos_hint_y_max` is a\n    :class:`~kivy.properties.NumericProperty` and defaults to None.\n    '''\n    default_size_hint_max = ReferenceListProperty(\n        default_size_hint_x_max,\n        default_size_hint_y_max\n    )\n    '''Default value for size_hint_max of items\n\n    :attr:`default_size_max` is a\n    :class:`~kivy.properties.ReferenceListProperty` to\n    [:attr:`default_size_hint_x_max`, :attr:`default_size_hint_y_max`].\n    '''\n\n    default_pos_hint = ObjectProperty({})\n    '''Default pos_hint value for items\n\n    :attr:`default_pos_hint` is a :class:`~kivy.properties.DictProperty` and\n    defaults to {}.\n    '''\n    key_pos_hint = StringProperty(None, allownone=True)\n    '''If set, which key in the dict should be used to set the pos_hint of\n    items.\n\n    :attr:`key_pos_hint` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n    '''\n\n    initial_width = NumericProperty(100)\n    '''Initial width for the items.\n\n    :attr:`initial_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 100.\n    '''\n    initial_height = NumericProperty(100)\n    '''Initial height for the items.\n\n    :attr:`initial_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 100.\n    '''\n    initial_size = ReferenceListProperty(initial_width, initial_height)\n    '''Initial size of items\n\n    :attr:`initial_size` is a :class:`~kivy.properties.ReferenceListProperty`\n    to [:attr:`initial_width`, :attr:`initial_height`].\n    '''\n\n    view_opts = []\n\n    _size_needs_update = False\n    _changed_views = []\n\n    view_indices = {}\n\n    def __init__(self, **kwargs):\n        self.view_indices = {}\n        self._updated_views = []\n        self._trigger_layout = self._catch_layout_trigger\n        super(RecycleLayout, self).__init__(**kwargs)\n\n    def attach_recycleview(self, rv):\n        super(RecycleLayout, self).attach_recycleview(rv)\n        if rv:\n            fbind = self.fbind\n            fbind('default_size', rv.refresh_from_data)\n            fbind('key_size', rv.refresh_from_data)\n            fbind('default_size_hint', rv.refresh_from_data)\n            fbind('key_size_hint', rv.refresh_from_data)\n            fbind('default_size_hint_min', rv.refresh_from_data)\n            fbind('key_size_hint_min', rv.refresh_from_data)\n            fbind('default_size_hint_max', rv.refresh_from_data)\n            fbind('key_size_hint_max', rv.refresh_from_data)\n            fbind('default_pos_hint', rv.refresh_from_data)\n            fbind('key_pos_hint', rv.refresh_from_data)\n\n    def detach_recycleview(self):\n        rv = self.recycleview\n        if rv:\n            funbind = self.funbind\n            funbind('default_size', rv.refresh_from_data)\n            funbind('key_size', rv.refresh_from_data)\n            funbind('default_size_hint', rv.refresh_from_data)\n            funbind('key_size_hint', rv.refresh_from_data)\n            funbind('default_size_hint_min', rv.refresh_from_data)\n            funbind('key_size_hint_min', rv.refresh_from_data)\n            funbind('default_size_hint_max', rv.refresh_from_data)\n            funbind('key_size_hint_max', rv.refresh_from_data)\n            funbind('default_pos_hint', rv.refresh_from_data)\n            funbind('key_pos_hint', rv.refresh_from_data)\n        super(RecycleLayout, self).detach_recycleview()\n\n    def _catch_layout_trigger(self, instance=None, value=None):\n        rv = self.recycleview\n        if rv is None:\n            return\n\n        idx = self.view_indices.get(instance)\n        if idx is not None:\n            if self._size_needs_update:\n                return\n            opt = self.view_opts[idx]\n            if (instance.size == opt['size'] and\n                    instance.size_hint == opt['size_hint'] and\n                    instance.size_hint_min == opt['size_hint_min'] and\n                    instance.size_hint_max == opt['size_hint_max'] and\n                    instance.pos_hint == opt['pos_hint']):\n                return\n            self._size_needs_update = True\n            rv.refresh_from_layout(view_size=True)\n        else:\n            rv.refresh_from_layout()\n\n    def compute_sizes_from_data(self, data, flags):\n        if [f for f in flags if not f]:\n            # at least one changed data unpredictably\n            self.clear_layout()\n            opts = self.view_opts = [None for _ in data]\n        else:\n            opts = self.view_opts\n            changed = False\n            for flag in flags:\n                for k, v in flag.items():\n                    changed = True\n                    if k == 'removed':\n                        del opts[v]\n                    elif k == 'appended':\n                        opts.extend([None, ] * (v.stop - v.start))\n                    elif k == 'inserted':\n                        opts.insert(v, None)\n                    elif k == 'modified':\n                        start, stop, step = v.start, v.stop, v.step\n                        r = range(start, stop) if step is None else \\\n                            range(start, stop, step)\n                        for i in r:\n                            opts[i] = None\n                    else:\n                        raise Exception('Unrecognized data flag {}'.format(k))\n\n            if changed:\n                self.clear_layout()\n\n        assert len(data) == len(opts)\n        ph_key = self.key_pos_hint\n        ph_def = self.default_pos_hint\n        sh_key = self.key_size_hint\n        sh_def = self.default_size_hint\n        sh_min_key = self.key_size_hint_min\n        sh_min_def = self.default_size_hint_min\n        sh_max_key = self.key_size_hint_max\n        sh_max_def = self.default_size_hint_max\n        s_key = self.key_size\n        s_def = self.default_size\n        viewcls_def = self.viewclass\n        viewcls_key = self.key_viewclass\n        iw, ih = self.initial_size\n\n        sh = []\n        for i, item in enumerate(data):\n            if opts[i] is not None:\n                continue\n\n            ph = ph_def if ph_key is None else item.get(ph_key, ph_def)\n            ph = item.get('pos_hint', ph)\n\n            sh = sh_def if sh_key is None else item.get(sh_key, sh_def)\n            sh = item.get('size_hint', sh)\n            sh = [item.get('size_hint_x', sh[0]),\n                  item.get('size_hint_y', sh[1])]\n\n            sh_min = sh_min_def if sh_min_key is None else item.get(sh_min_key,\n                                                                    sh_min_def)\n            sh_min = item.get('size_hint_min', sh_min)\n            sh_min = [item.get('size_hint_min_x', sh_min[0]),\n                      item.get('size_hint_min_y', sh_min[1])]\n\n            sh_max = sh_max_def if sh_max_key is None else item.get(sh_max_key,\n                                                                    sh_max_def)\n            sh_max = item.get('size_hint_max', sh_max)\n            sh_max = [item.get('size_hint_max_x', sh_max[0]),\n                      item.get('size_hint_max_y', sh_max[1])]\n\n            s = s_def if s_key is None else item.get(s_key, s_def)\n            s = item.get('size', s)\n            w, h = s = item.get('width', s[0]), item.get('height', s[1])\n\n            viewcls = None\n            if viewcls_key is not None:\n                viewcls = item.get(viewcls_key)\n                if viewcls is not None:\n                    viewcls = getattr(Factory, viewcls)\n            if viewcls is None:\n                viewcls = viewcls_def\n\n            opts[i] = {\n                'size': [(iw if w is None else w), (ih if h is None else h)],\n                'size_hint': sh, 'size_hint_min': sh_min,\n                'size_hint_max': sh_max, 'pos': None, 'pos_hint': ph,\n                'viewclass': viewcls, 'width_none': w is None,\n                'height_none': h is None}\n\n    def compute_layout(self, data, flags):\n        self._size_needs_update = False\n\n        opts = self.view_opts\n        changed = []\n        for widget, index in self.view_indices.items():\n            opt = opts[index]\n            s = opt['size']\n            w, h = sn = list(widget.size)\n            sh = opt['size_hint']\n            shnw, shnh = shn = list(widget.size_hint)\n            sh_min = opt['size_hint_min']\n            shn_min = list(widget.size_hint_min)\n            sh_max = opt['size_hint_max']\n            shn_max = list(widget.size_hint_max)\n            ph = opt['pos_hint']\n            phn = dict(widget.pos_hint)\n            if s != sn or sh != shn or ph != phn or sh_min != shn_min or \\\n                    sh_max != shn_max:\n                changed.append((index, widget, s, sn, sh, shn, sh_min, shn_min,\n                                sh_max, shn_max, ph, phn))\n                if shnw is None:\n                    if shnh is None:\n                        opt['size'] = sn\n                    else:\n                        opt['size'] = [w, s[1]]\n                elif shnh is None:\n                    opt['size'] = [s[0], h]\n                opt['size_hint'] = shn\n                opt['size_hint_min'] = shn_min\n                opt['size_hint_max'] = shn_max\n                opt['pos_hint'] = phn\n\n        if [f for f in flags if not f]:  # need to redo everything\n            self._changed_views = []\n        else:\n            self._changed_views = changed if changed else None\n\n    def do_layout(self, *largs):\n        assert False\n\n    def set_visible_views(self, indices, data, viewport):\n        view_opts = self.view_opts\n        new, remaining, old = self.recycleview.view_adapter.set_visible_views(\n            indices, data, view_opts)\n\n        remove = self.remove_widget\n        view_indices = self.view_indices\n        for _, widget in old:\n            remove(widget)\n            del view_indices[widget]\n\n        # first update the sizing info so that when we update the size\n        # the widgets are not bound and won't trigger a re-layout\n        refresh_view_layout = self.refresh_view_layout\n        for index, widget in new:\n            # make sure widget is added first so that any sizing updates\n            # will be recorded\n            opt = view_opts[index].copy()\n            del opt['width_none']\n            del opt['height_none']\n            refresh_view_layout(index, opt, widget, viewport)\n\n        # then add all the visible widgets, which binds size/size_hint\n        add = self.add_widget\n        for index, widget in new:\n            # add to the container if it's not already done\n            view_indices[widget] = index\n            if widget.parent is None:\n                add(widget)\n\n        # finally, make sure if the size has changed to cause a re-layout\n        changed = False\n        for index, widget in new:\n            opt = view_opts[index]\n            if (changed or widget.size == opt['size'] and\n                    widget.size_hint == opt['size_hint'] and\n                    widget.size_hint_min == opt['size_hint_min'] and\n                    widget.size_hint_max == opt['size_hint_max'] and\n                    widget.pos_hint == opt['pos_hint']):\n                continue\n            changed = True\n\n        if changed:\n            # we could use LayoutChangeException here, but refresh_views in rv\n            # needs to be updated to watch for it in the layout phase\n            self._size_needs_update = True\n            self.recycleview.refresh_from_layout(view_size=True)\n\n    def refresh_view_layout(self, index, layout, view, viewport):\n        opt = self.view_opts[index].copy()\n        width_none = opt.pop('width_none')\n        height_none = opt.pop('height_none')\n        opt.update(layout)\n\n        w, h = opt['size']\n        shw, shh = opt['size_hint']\n        if shw is None and width_none:\n            w = None\n        if shh is None and height_none:\n            h = None\n        opt['size'] = w, h\n        super(RecycleLayout, self).refresh_view_layout(\n            index, opt, view, viewport)\n\n    def remove_views(self):\n        super(RecycleLayout, self).remove_views()\n        self.clear_widgets()\n        self.view_indices = {}\n\n    def remove_view(self, view, index):\n        super(RecycleLayout, self).remove_view(view, index)\n        self.remove_widget(view)\n        del self.view_indices[view]\n\n    def clear_layout(self):\n        super(RecycleLayout, self).clear_layout()\n        self.clear_widgets()\n        self.view_indices = {}\n        self._size_needs_update = False",
  "def __init__(self, **kwargs):\n        self.view_indices = {}\n        self._updated_views = []\n        self._trigger_layout = self._catch_layout_trigger\n        super(RecycleLayout, self).__init__(**kwargs)",
  "def attach_recycleview(self, rv):\n        super(RecycleLayout, self).attach_recycleview(rv)\n        if rv:\n            fbind = self.fbind\n            fbind('default_size', rv.refresh_from_data)\n            fbind('key_size', rv.refresh_from_data)\n            fbind('default_size_hint', rv.refresh_from_data)\n            fbind('key_size_hint', rv.refresh_from_data)\n            fbind('default_size_hint_min', rv.refresh_from_data)\n            fbind('key_size_hint_min', rv.refresh_from_data)\n            fbind('default_size_hint_max', rv.refresh_from_data)\n            fbind('key_size_hint_max', rv.refresh_from_data)\n            fbind('default_pos_hint', rv.refresh_from_data)\n            fbind('key_pos_hint', rv.refresh_from_data)",
  "def detach_recycleview(self):\n        rv = self.recycleview\n        if rv:\n            funbind = self.funbind\n            funbind('default_size', rv.refresh_from_data)\n            funbind('key_size', rv.refresh_from_data)\n            funbind('default_size_hint', rv.refresh_from_data)\n            funbind('key_size_hint', rv.refresh_from_data)\n            funbind('default_size_hint_min', rv.refresh_from_data)\n            funbind('key_size_hint_min', rv.refresh_from_data)\n            funbind('default_size_hint_max', rv.refresh_from_data)\n            funbind('key_size_hint_max', rv.refresh_from_data)\n            funbind('default_pos_hint', rv.refresh_from_data)\n            funbind('key_pos_hint', rv.refresh_from_data)\n        super(RecycleLayout, self).detach_recycleview()",
  "def _catch_layout_trigger(self, instance=None, value=None):\n        rv = self.recycleview\n        if rv is None:\n            return\n\n        idx = self.view_indices.get(instance)\n        if idx is not None:\n            if self._size_needs_update:\n                return\n            opt = self.view_opts[idx]\n            if (instance.size == opt['size'] and\n                    instance.size_hint == opt['size_hint'] and\n                    instance.size_hint_min == opt['size_hint_min'] and\n                    instance.size_hint_max == opt['size_hint_max'] and\n                    instance.pos_hint == opt['pos_hint']):\n                return\n            self._size_needs_update = True\n            rv.refresh_from_layout(view_size=True)\n        else:\n            rv.refresh_from_layout()",
  "def compute_sizes_from_data(self, data, flags):\n        if [f for f in flags if not f]:\n            # at least one changed data unpredictably\n            self.clear_layout()\n            opts = self.view_opts = [None for _ in data]\n        else:\n            opts = self.view_opts\n            changed = False\n            for flag in flags:\n                for k, v in flag.items():\n                    changed = True\n                    if k == 'removed':\n                        del opts[v]\n                    elif k == 'appended':\n                        opts.extend([None, ] * (v.stop - v.start))\n                    elif k == 'inserted':\n                        opts.insert(v, None)\n                    elif k == 'modified':\n                        start, stop, step = v.start, v.stop, v.step\n                        r = range(start, stop) if step is None else \\\n                            range(start, stop, step)\n                        for i in r:\n                            opts[i] = None\n                    else:\n                        raise Exception('Unrecognized data flag {}'.format(k))\n\n            if changed:\n                self.clear_layout()\n\n        assert len(data) == len(opts)\n        ph_key = self.key_pos_hint\n        ph_def = self.default_pos_hint\n        sh_key = self.key_size_hint\n        sh_def = self.default_size_hint\n        sh_min_key = self.key_size_hint_min\n        sh_min_def = self.default_size_hint_min\n        sh_max_key = self.key_size_hint_max\n        sh_max_def = self.default_size_hint_max\n        s_key = self.key_size\n        s_def = self.default_size\n        viewcls_def = self.viewclass\n        viewcls_key = self.key_viewclass\n        iw, ih = self.initial_size\n\n        sh = []\n        for i, item in enumerate(data):\n            if opts[i] is not None:\n                continue\n\n            ph = ph_def if ph_key is None else item.get(ph_key, ph_def)\n            ph = item.get('pos_hint', ph)\n\n            sh = sh_def if sh_key is None else item.get(sh_key, sh_def)\n            sh = item.get('size_hint', sh)\n            sh = [item.get('size_hint_x', sh[0]),\n                  item.get('size_hint_y', sh[1])]\n\n            sh_min = sh_min_def if sh_min_key is None else item.get(sh_min_key,\n                                                                    sh_min_def)\n            sh_min = item.get('size_hint_min', sh_min)\n            sh_min = [item.get('size_hint_min_x', sh_min[0]),\n                      item.get('size_hint_min_y', sh_min[1])]\n\n            sh_max = sh_max_def if sh_max_key is None else item.get(sh_max_key,\n                                                                    sh_max_def)\n            sh_max = item.get('size_hint_max', sh_max)\n            sh_max = [item.get('size_hint_max_x', sh_max[0]),\n                      item.get('size_hint_max_y', sh_max[1])]\n\n            s = s_def if s_key is None else item.get(s_key, s_def)\n            s = item.get('size', s)\n            w, h = s = item.get('width', s[0]), item.get('height', s[1])\n\n            viewcls = None\n            if viewcls_key is not None:\n                viewcls = item.get(viewcls_key)\n                if viewcls is not None:\n                    viewcls = getattr(Factory, viewcls)\n            if viewcls is None:\n                viewcls = viewcls_def\n\n            opts[i] = {\n                'size': [(iw if w is None else w), (ih if h is None else h)],\n                'size_hint': sh, 'size_hint_min': sh_min,\n                'size_hint_max': sh_max, 'pos': None, 'pos_hint': ph,\n                'viewclass': viewcls, 'width_none': w is None,\n                'height_none': h is None}",
  "def compute_layout(self, data, flags):\n        self._size_needs_update = False\n\n        opts = self.view_opts\n        changed = []\n        for widget, index in self.view_indices.items():\n            opt = opts[index]\n            s = opt['size']\n            w, h = sn = list(widget.size)\n            sh = opt['size_hint']\n            shnw, shnh = shn = list(widget.size_hint)\n            sh_min = opt['size_hint_min']\n            shn_min = list(widget.size_hint_min)\n            sh_max = opt['size_hint_max']\n            shn_max = list(widget.size_hint_max)\n            ph = opt['pos_hint']\n            phn = dict(widget.pos_hint)\n            if s != sn or sh != shn or ph != phn or sh_min != shn_min or \\\n                    sh_max != shn_max:\n                changed.append((index, widget, s, sn, sh, shn, sh_min, shn_min,\n                                sh_max, shn_max, ph, phn))\n                if shnw is None:\n                    if shnh is None:\n                        opt['size'] = sn\n                    else:\n                        opt['size'] = [w, s[1]]\n                elif shnh is None:\n                    opt['size'] = [s[0], h]\n                opt['size_hint'] = shn\n                opt['size_hint_min'] = shn_min\n                opt['size_hint_max'] = shn_max\n                opt['pos_hint'] = phn\n\n        if [f for f in flags if not f]:  # need to redo everything\n            self._changed_views = []\n        else:\n            self._changed_views = changed if changed else None",
  "def do_layout(self, *largs):\n        assert False",
  "def set_visible_views(self, indices, data, viewport):\n        view_opts = self.view_opts\n        new, remaining, old = self.recycleview.view_adapter.set_visible_views(\n            indices, data, view_opts)\n\n        remove = self.remove_widget\n        view_indices = self.view_indices\n        for _, widget in old:\n            remove(widget)\n            del view_indices[widget]\n\n        # first update the sizing info so that when we update the size\n        # the widgets are not bound and won't trigger a re-layout\n        refresh_view_layout = self.refresh_view_layout\n        for index, widget in new:\n            # make sure widget is added first so that any sizing updates\n            # will be recorded\n            opt = view_opts[index].copy()\n            del opt['width_none']\n            del opt['height_none']\n            refresh_view_layout(index, opt, widget, viewport)\n\n        # then add all the visible widgets, which binds size/size_hint\n        add = self.add_widget\n        for index, widget in new:\n            # add to the container if it's not already done\n            view_indices[widget] = index\n            if widget.parent is None:\n                add(widget)\n\n        # finally, make sure if the size has changed to cause a re-layout\n        changed = False\n        for index, widget in new:\n            opt = view_opts[index]\n            if (changed or widget.size == opt['size'] and\n                    widget.size_hint == opt['size_hint'] and\n                    widget.size_hint_min == opt['size_hint_min'] and\n                    widget.size_hint_max == opt['size_hint_max'] and\n                    widget.pos_hint == opt['pos_hint']):\n                continue\n            changed = True\n\n        if changed:\n            # we could use LayoutChangeException here, but refresh_views in rv\n            # needs to be updated to watch for it in the layout phase\n            self._size_needs_update = True\n            self.recycleview.refresh_from_layout(view_size=True)",
  "def refresh_view_layout(self, index, layout, view, viewport):\n        opt = self.view_opts[index].copy()\n        width_none = opt.pop('width_none')\n        height_none = opt.pop('height_none')\n        opt.update(layout)\n\n        w, h = opt['size']\n        shw, shh = opt['size_hint']\n        if shw is None and width_none:\n            w = None\n        if shh is None and height_none:\n            h = None\n        opt['size'] = w, h\n        super(RecycleLayout, self).refresh_view_layout(\n            index, opt, view, viewport)",
  "def remove_views(self):\n        super(RecycleLayout, self).remove_views()\n        self.clear_widgets()\n        self.view_indices = {}",
  "def remove_view(self, view, index):\n        super(RecycleLayout, self).remove_view(view, index)\n        self.remove_widget(view)\n        del self.view_indices[view]",
  "def clear_layout(self):\n        super(RecycleLayout, self).clear_layout()\n        self.clear_widgets()\n        self.view_indices = {}\n        self._size_needs_update = False",
  "class Video(Image):\n    '''Video class. See module documentation for more information.\n    '''\n\n    preview = StringProperty(None, allownone=True)\n    '''Filename / source of a preview image displayed before video starts.\n\n    :attr:`preview` is a :class:`~kivy.properties.StringProperty` and\n    defaults to None.\n\n    If set, it gets displayed until the video is loaded/started.\n\n    .. versionadded:: 2.1.0\n    '''\n\n    state = OptionProperty('stop', options=('play', 'pause', 'stop'))\n    '''String, indicates whether to play, pause, or stop the video::\n\n        # start playing the video at creation\n        video = Video(source='movie.mkv', state='play')\n\n        # create the video, and start later\n        video = Video(source='movie.mkv')\n        # and later\n        video.state = 'play'\n\n    :attr:`state` is an :class:`~kivy.properties.OptionProperty` and defaults\n    to 'stop'.\n    '''\n\n    play = BooleanProperty(False, deprecated=True)\n    '''\n    .. deprecated:: 1.4.0\n        Use :attr:`state` instead.\n\n    Boolean, indicates whether the video is playing or not.\n    You can start/stop the video by setting this property::\n\n        # start playing the video at creation\n        video = Video(source='movie.mkv', play=True)\n\n        # create the video, and start later\n        video = Video(source='movie.mkv')\n        # and later\n        video.play = True\n\n    :attr:`play` is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.\n\n    .. deprecated:: 1.4.0\n        Use :attr:`state` instead.\n    '''\n\n    eos = BooleanProperty(False)\n    '''Boolean, indicates whether the video has finished playing or not\n    (reached the end of the stream).\n\n    :attr:`eos` is a :class:`~kivy.properties.BooleanProperty` and defaults to\n    False.\n    '''\n\n    loaded = BooleanProperty(False)\n    '''Boolean, indicates whether the video is loaded and ready for playback\n    or not.\n\n    .. versionadded:: 1.6.0\n\n    :attr:`loaded` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    position = NumericProperty(-1)\n    '''Position of the video between 0 and :attr:`duration`. The position\n    defaults to -1 and is set to a real position when the video is loaded.\n\n    :attr:`position` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to -1.\n    '''\n\n    duration = NumericProperty(-1)\n    '''Duration of the video. The duration defaults to -1, and is set to a real\n    duration when the video is loaded.\n\n    :attr:`duration` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to -1.\n    '''\n\n    volume = NumericProperty(1.)\n    '''Volume of the video, in the range 0-1. 1 means full volume, 0\n    means mute.\n\n    :attr:`volume` is a :class:`~kivy.properties.NumericProperty` and defaults\n    to 1.\n    '''\n\n    options = ObjectProperty({})\n    '''Options to pass at Video core object creation.\n\n    .. versionadded:: 1.0.4\n\n    :attr:`options` is an :class:`kivy.properties.ObjectProperty` and defaults\n    to {}.\n    '''\n\n    _video_load_event = None\n\n    def __init__(self, **kwargs):\n        self._video = None\n        super(Video, self).__init__(**kwargs)\n        self.fbind('source', self._trigger_video_load)\n\n        if \"eos\" in kwargs:\n            self.options[\"eos\"] = kwargs[\"eos\"]\n        if self.source:\n            self._trigger_video_load()\n\n    def texture_update(self, *largs):\n        if self.preview:\n            self.set_texture_from_resource(self.preview)\n        else:\n            self.set_texture_from_resource(self.source)\n\n    def seek(self, percent, precise=True):\n        '''Change the position to a percentage (strictly, a proportion)\n           of duration.\n\n        :Parameters:\n            `percent`: float or int\n                Position to seek as a proportion of the total duration,\n                must be between 0-1.\n            `precise`: bool, defaults to True\n                Precise seeking is slower, but seeks to exact requested\n                percent.\n\n        .. warning::\n            Calling seek() before the video is loaded has no effect.\n\n        .. versionadded:: 1.2.0\n\n        .. versionchanged:: 1.10.1\n            The `precise` keyword argument has been added.\n        '''\n        if self._video is None:\n            raise Exception('Video not loaded.')\n        self._video.seek(percent, precise=precise)\n\n    def _trigger_video_load(self, *largs):\n        ev = self._video_load_event\n        if ev is None:\n            ev = self._video_load_event = Clock.schedule_once(\n                self._do_video_load, -1)\n        ev()\n\n    def _do_video_load(self, *largs):\n        if CoreVideo is None:\n            return\n        self.unload()\n        if not self.source:\n            self._video = None\n            self.texture = None\n        else:\n            filename = self.source\n            # Check if filename is not url\n            if '://' not in filename:\n                filename = resource_find(filename)\n            self._video = CoreVideo(filename=filename, **self.options)\n            self._video.volume = self.volume\n            self._video.bind(on_load=self._on_load,\n                             on_frame=self._on_video_frame,\n                             on_eos=self._on_eos)\n            if self.state == 'play' or self.play:\n                self._video.play()\n            self.duration = 1.\n            self.position = 0.\n\n    def on_play(self, instance, value):\n        value = 'play' if value else 'stop'\n        return self.on_state(instance, value)\n\n    def on_state(self, instance, value):\n        if not self._video:\n            return\n        if value == 'play':\n            if self.eos:\n                self._video.stop()\n                self._video.position = 0.\n            self.eos = False\n            self._video.play()\n        elif value == 'pause':\n            self._video.pause()\n        else:\n            self._video.stop()\n            self._video.position = 0\n\n    def _on_video_frame(self, *largs):\n        video = self._video\n        if not video:\n            return\n        self.duration = video.duration\n        self.position = video.position\n        self.texture = video.texture\n        self.canvas.ask_update()\n\n    def _on_eos(self, *largs):\n        if not self._video or self._video.eos != 'loop':\n            self.state = 'stop'\n            self.eos = True\n\n    def _on_load(self, *largs):\n        self.loaded = True\n        self._on_video_frame(largs)\n\n    def on_volume(self, instance, value):\n        if self._video:\n            self._video.volume = value\n\n    def unload(self):\n        '''Unload the video. The playback will be stopped.\n\n        .. versionadded:: 1.8.0\n        '''\n        if self._video:\n            self._video.stop()\n            self._video.unload()\n            self._video = None\n        self.loaded = False",
  "def __init__(self, **kwargs):\n        self._video = None\n        super(Video, self).__init__(**kwargs)\n        self.fbind('source', self._trigger_video_load)\n\n        if \"eos\" in kwargs:\n            self.options[\"eos\"] = kwargs[\"eos\"]\n        if self.source:\n            self._trigger_video_load()",
  "def texture_update(self, *largs):\n        if self.preview:\n            self.set_texture_from_resource(self.preview)\n        else:\n            self.set_texture_from_resource(self.source)",
  "def seek(self, percent, precise=True):\n        '''Change the position to a percentage (strictly, a proportion)\n           of duration.\n\n        :Parameters:\n            `percent`: float or int\n                Position to seek as a proportion of the total duration,\n                must be between 0-1.\n            `precise`: bool, defaults to True\n                Precise seeking is slower, but seeks to exact requested\n                percent.\n\n        .. warning::\n            Calling seek() before the video is loaded has no effect.\n\n        .. versionadded:: 1.2.0\n\n        .. versionchanged:: 1.10.1\n            The `precise` keyword argument has been added.\n        '''\n        if self._video is None:\n            raise Exception('Video not loaded.')\n        self._video.seek(percent, precise=precise)",
  "def _trigger_video_load(self, *largs):\n        ev = self._video_load_event\n        if ev is None:\n            ev = self._video_load_event = Clock.schedule_once(\n                self._do_video_load, -1)\n        ev()",
  "def _do_video_load(self, *largs):\n        if CoreVideo is None:\n            return\n        self.unload()\n        if not self.source:\n            self._video = None\n            self.texture = None\n        else:\n            filename = self.source\n            # Check if filename is not url\n            if '://' not in filename:\n                filename = resource_find(filename)\n            self._video = CoreVideo(filename=filename, **self.options)\n            self._video.volume = self.volume\n            self._video.bind(on_load=self._on_load,\n                             on_frame=self._on_video_frame,\n                             on_eos=self._on_eos)\n            if self.state == 'play' or self.play:\n                self._video.play()\n            self.duration = 1.\n            self.position = 0.",
  "def on_play(self, instance, value):\n        value = 'play' if value else 'stop'\n        return self.on_state(instance, value)",
  "def on_state(self, instance, value):\n        if not self._video:\n            return\n        if value == 'play':\n            if self.eos:\n                self._video.stop()\n                self._video.position = 0.\n            self.eos = False\n            self._video.play()\n        elif value == 'pause':\n            self._video.pause()\n        else:\n            self._video.stop()\n            self._video.position = 0",
  "def _on_video_frame(self, *largs):\n        video = self._video\n        if not video:\n            return\n        self.duration = video.duration\n        self.position = video.position\n        self.texture = video.texture\n        self.canvas.ask_update()",
  "def _on_eos(self, *largs):\n        if not self._video or self._video.eos != 'loop':\n            self.state = 'stop'\n            self.eos = True",
  "def _on_load(self, *largs):\n        self.loaded = True\n        self._on_video_frame(largs)",
  "def on_volume(self, instance, value):\n        if self._video:\n            self._video.volume = value",
  "def unload(self):\n        '''Unload the video. The playback will be stopped.\n\n        .. versionadded:: 1.8.0\n        '''\n        if self._video:\n            self._video.stop()\n            self._video.unload()\n            self._video = None\n        self.loaded = False",
  "class VideoApp(App):\n        def build(self):\n            self.v = Video(source=sys.argv[1], state='play')\n            self.v.bind(state=self.replay)\n            return self.v\n\n        def replay(self, *args):\n            if self.v.state == 'stop':\n                self.v.state = 'play'",
  "def build(self):\n            self.v = Video(source=sys.argv[1], state='play')\n            self.v.bind(state=self.replay)\n            return self.v",
  "def replay(self, *args):\n            if self.v.state == 'stop':\n                self.v.state = 'play'",
  "class FloatLayout(Layout):\n    '''Float layout class. See module documentation for more information.\n    '''\n\n    def __init__(self, **kwargs):\n        super(FloatLayout, self).__init__(**kwargs)\n        fbind = self.fbind\n        update = self._trigger_layout\n        fbind('children', update)\n        fbind('pos', update)\n        fbind('pos_hint', update)\n        fbind('size_hint', update)\n        fbind('size', update)\n\n    def do_layout(self, *largs, **kwargs):\n        # optimize layout by preventing looking at the same attribute in a loop\n        w, h = kwargs.get('size', self.size)\n        x, y = kwargs.get('pos', self.pos)\n        for c in self.children:\n            # size\n            shw, shh = c.size_hint\n            shw_min, shh_min = c.size_hint_min\n            shw_max, shh_max = c.size_hint_max\n\n            if shw is not None and shh is not None:\n                c_w = shw * w\n                c_h = shh * h\n\n                if shw_min is not None and c_w < shw_min:\n                    c_w = shw_min\n                elif shw_max is not None and c_w > shw_max:\n                    c_w = shw_max\n\n                if shh_min is not None and c_h < shh_min:\n                    c_h = shh_min\n                elif shh_max is not None and c_h > shh_max:\n                    c_h = shh_max\n                c.size = c_w, c_h\n            elif shw is not None:\n                c_w = shw * w\n\n                if shw_min is not None and c_w < shw_min:\n                    c_w = shw_min\n                elif shw_max is not None and c_w > shw_max:\n                    c_w = shw_max\n                c.width = c_w\n            elif shh is not None:\n                c_h = shh * h\n\n                if shh_min is not None and c_h < shh_min:\n                    c_h = shh_min\n                elif shh_max is not None and c_h > shh_max:\n                    c_h = shh_max\n                c.height = c_h\n\n            # pos\n            for key, value in c.pos_hint.items():\n                if key == 'x':\n                    c.x = x + value * w\n                elif key == 'right':\n                    c.right = x + value * w\n                elif key == 'pos':\n                    c.pos = x + value[0] * w, y + value[1] * h\n                elif key == 'y':\n                    c.y = y + value * h\n                elif key == 'top':\n                    c.top = y + value * h\n                elif key == 'center':\n                    c.center = x + value[0] * w, y + value[1] * h\n                elif key == 'center_x':\n                    c.center_x = x + value * w\n                elif key == 'center_y':\n                    c.center_y = y + value * h\n\n    def add_widget(self, widget, *args, **kwargs):\n        widget.bind(\n            # size=self._trigger_layout,\n            # size_hint=self._trigger_layout,\n            pos=self._trigger_layout,\n            pos_hint=self._trigger_layout)\n        return super(FloatLayout, self).add_widget(widget, *args, **kwargs)\n\n    def remove_widget(self, widget, *args, **kwargs):\n        widget.unbind(\n            # size=self._trigger_layout,\n            # size_hint=self._trigger_layout,\n            pos=self._trigger_layout,\n            pos_hint=self._trigger_layout)\n        return super(FloatLayout, self).remove_widget(widget, *args, **kwargs)",
  "def __init__(self, **kwargs):\n        super(FloatLayout, self).__init__(**kwargs)\n        fbind = self.fbind\n        update = self._trigger_layout\n        fbind('children', update)\n        fbind('pos', update)\n        fbind('pos_hint', update)\n        fbind('size_hint', update)\n        fbind('size', update)",
  "def do_layout(self, *largs, **kwargs):\n        # optimize layout by preventing looking at the same attribute in a loop\n        w, h = kwargs.get('size', self.size)\n        x, y = kwargs.get('pos', self.pos)\n        for c in self.children:\n            # size\n            shw, shh = c.size_hint\n            shw_min, shh_min = c.size_hint_min\n            shw_max, shh_max = c.size_hint_max\n\n            if shw is not None and shh is not None:\n                c_w = shw * w\n                c_h = shh * h\n\n                if shw_min is not None and c_w < shw_min:\n                    c_w = shw_min\n                elif shw_max is not None and c_w > shw_max:\n                    c_w = shw_max\n\n                if shh_min is not None and c_h < shh_min:\n                    c_h = shh_min\n                elif shh_max is not None and c_h > shh_max:\n                    c_h = shh_max\n                c.size = c_w, c_h\n            elif shw is not None:\n                c_w = shw * w\n\n                if shw_min is not None and c_w < shw_min:\n                    c_w = shw_min\n                elif shw_max is not None and c_w > shw_max:\n                    c_w = shw_max\n                c.width = c_w\n            elif shh is not None:\n                c_h = shh * h\n\n                if shh_min is not None and c_h < shh_min:\n                    c_h = shh_min\n                elif shh_max is not None and c_h > shh_max:\n                    c_h = shh_max\n                c.height = c_h\n\n            # pos\n            for key, value in c.pos_hint.items():\n                if key == 'x':\n                    c.x = x + value * w\n                elif key == 'right':\n                    c.right = x + value * w\n                elif key == 'pos':\n                    c.pos = x + value[0] * w, y + value[1] * h\n                elif key == 'y':\n                    c.y = y + value * h\n                elif key == 'top':\n                    c.top = y + value * h\n                elif key == 'center':\n                    c.center = x + value[0] * w, y + value[1] * h\n                elif key == 'center_x':\n                    c.center_x = x + value * w\n                elif key == 'center_y':\n                    c.center_y = y + value * h",
  "def add_widget(self, widget, *args, **kwargs):\n        widget.bind(\n            # size=self._trigger_layout,\n            # size_hint=self._trigger_layout,\n            pos=self._trigger_layout,\n            pos_hint=self._trigger_layout)\n        return super(FloatLayout, self).add_widget(widget, *args, **kwargs)",
  "def remove_widget(self, widget, *args, **kwargs):\n        widget.unbind(\n            # size=self._trigger_layout,\n            # size_hint=self._trigger_layout,\n            pos=self._trigger_layout,\n            pos_hint=self._trigger_layout)\n        return super(FloatLayout, self).remove_widget(widget, *args, **kwargs)",
  "class CodeInput(CodeNavigationBehavior, TextInput):\n    '''CodeInput class, used for displaying highlighted code.\n    '''\n\n    lexer = ObjectProperty(None)\n    '''This holds the selected Lexer used by pygments to highlight the code.\n\n\n    :attr:`lexer` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to `PythonLexer`.\n    '''\n\n    style_name = OptionProperty(\n        'default', options=list(styles.get_all_styles())\n    )\n    '''Name of the pygments style to use for formatting.\n\n    :attr:`style_name` is an :class:`~kivy.properties.OptionProperty`\n    and defaults to ``'default'``.\n\n    '''\n\n    style = ObjectProperty(None)\n    '''The pygments style object to use for formatting.\n\n    When ``style_name`` is set, this will be changed to the\n    corresponding style object.\n\n    :attr:`style` is a :class:`~kivy.properties.ObjectProperty` and\n    defaults to ``None``\n\n    '''\n\n    def __init__(self, **kwargs):\n        stylename = kwargs.get('style_name', 'default')\n        style = kwargs['style'] if 'style' in kwargs \\\n            else styles.get_style_by_name(stylename)\n        self.formatter = BBCodeFormatter(style=style)\n        self.lexer = lexers.PythonLexer()\n        self.text_color = '#000000'\n        self._label_cached = Label()\n        self.use_text_color = True\n\n        super(CodeInput, self).__init__(**kwargs)\n\n        self._line_options = kw = self._get_line_options()\n        self._label_cached = Label(**kw)\n        # use text_color as foreground color\n        text_color = kwargs.get('foreground_color')\n        if text_color:\n            self.text_color = get_hex_from_color(text_color)\n        # set foreground to white to allow text colors to show\n        # use text_color as the default color in bbcodes\n        self.use_text_color = False\n        self.foreground_color = [1, 1, 1, .999]\n        if not kwargs.get('background_color'):\n            self.background_color = [.9, .92, .92, 1]\n\n    def on_style_name(self, *args):\n        self.style = styles.get_style_by_name(self.style_name)\n        self.background_color = get_color_from_hex(self.style.background_color)\n        self._trigger_refresh_text()\n\n    def on_style(self, *args):\n        self.formatter = BBCodeFormatter(style=self.style)\n        self._trigger_update_graphics()\n\n    def _create_line_label(self, text, hint=False):\n        # Create a label from a text, using line options\n        ntext = text.replace(u'\\n', u'').replace(u'\\t', u' ' * self.tab_width)\n        if self.password and not hint:  # Don't replace hint_text with *\n            ntext = u'*' * len(ntext)\n        ntext = self._get_bbcode(ntext)\n        kw = self._get_line_options()\n        cid = u'{}\\0{}\\0{}'.format(text, self.password, kw)\n        texture = Cache_get('textinput.label', cid)\n\n        if texture is None:\n            # FIXME right now, we can't render very long line...\n            # if we move on \"VBO\" version as fallback, we won't need to\n            # do this.\n            # try to find the maximum text we can handle\n            label = Label(text=ntext, **kw)\n            if text.find(u'\\n') > 0:\n                label.text = u''\n            else:\n                label.text = ntext\n            label.refresh()\n\n            # ok, we found it.\n            texture = label.texture\n            Cache_append('textinput.label', cid, texture)\n            label.text = ''\n        return texture\n\n    def _get_line_options(self):\n        kw = super(CodeInput, self)._get_line_options()\n        kw['markup'] = True\n        kw['valign'] = 'top'\n        kw['codeinput'] = repr(self.lexer)\n        return kw\n\n    def _get_text_width(self, text, tab_width, _label_cached):\n        # Return the width of a text, according to the current line options.\n        cid = u'{}\\0{}\\0{}'.format(text, self.password,\n                                   self._get_line_options())\n        width = Cache_get('textinput.width', cid)\n        if width is not None:\n            return width\n        lbl = self._create_line_label(text)\n        width = lbl.width\n        Cache_append('textinput.width', cid, width)\n        return width\n\n    def _get_bbcode(self, ntext):\n        # get bbcoded text for python\n        try:\n            ntext[0]\n            # replace brackets with special chars that aren't highlighted\n            # by pygment. can't use &bl; ... cause & is highlighted\n            ntext = ntext.replace(u'[', u'\\x01').replace(u']', u'\\x02')\n            ntext = highlight(ntext, self.lexer, self.formatter)\n            ntext = ntext.replace(u'\\x01', u'&bl;').replace(u'\\x02', u'&br;')\n            # replace special chars with &bl; and &br;\n            ntext = ''.join((u'[color=', str(self.text_color), u']',\n                             ntext, u'[/color]'))\n            ntext = ntext.replace(u'\\n', u'')\n            # remove possible extra highlight options\n            ntext = ntext.replace(u'[u]', '').replace(u'[/u]', '')\n            return ntext\n        except IndexError:\n            return ''\n\n    # overridden to prevent cursor position off screen\n    def _cursor_offset(self):\n        '''Get the cursor x offset on the current line\n        '''\n        offset = 0\n        try:\n            if self.cursor_col:\n                offset = self._get_text_width(\n                    self._lines[self.cursor_row][:self.cursor_col])\n                return offset\n        except:\n            pass\n        finally:\n            return offset\n\n    def on_lexer(self, instance, value):\n        self._trigger_refresh_text()\n\n    def on_foreground_color(self, instance, text_color):\n        if not self.use_text_color:\n            self.use_text_color = True\n            return\n        self.text_color = get_hex_from_color(text_color)\n        self.use_text_color = False\n        self.foreground_color = (1, 1, 1, .999)\n        self._trigger_refresh_text()",
  "def __init__(self, **kwargs):\n        stylename = kwargs.get('style_name', 'default')\n        style = kwargs['style'] if 'style' in kwargs \\\n            else styles.get_style_by_name(stylename)\n        self.formatter = BBCodeFormatter(style=style)\n        self.lexer = lexers.PythonLexer()\n        self.text_color = '#000000'\n        self._label_cached = Label()\n        self.use_text_color = True\n\n        super(CodeInput, self).__init__(**kwargs)\n\n        self._line_options = kw = self._get_line_options()\n        self._label_cached = Label(**kw)\n        # use text_color as foreground color\n        text_color = kwargs.get('foreground_color')\n        if text_color:\n            self.text_color = get_hex_from_color(text_color)\n        # set foreground to white to allow text colors to show\n        # use text_color as the default color in bbcodes\n        self.use_text_color = False\n        self.foreground_color = [1, 1, 1, .999]\n        if not kwargs.get('background_color'):\n            self.background_color = [.9, .92, .92, 1]",
  "def on_style_name(self, *args):\n        self.style = styles.get_style_by_name(self.style_name)\n        self.background_color = get_color_from_hex(self.style.background_color)\n        self._trigger_refresh_text()",
  "def on_style(self, *args):\n        self.formatter = BBCodeFormatter(style=self.style)\n        self._trigger_update_graphics()",
  "def _create_line_label(self, text, hint=False):\n        # Create a label from a text, using line options\n        ntext = text.replace(u'\\n', u'').replace(u'\\t', u' ' * self.tab_width)\n        if self.password and not hint:  # Don't replace hint_text with *\n            ntext = u'*' * len(ntext)\n        ntext = self._get_bbcode(ntext)\n        kw = self._get_line_options()\n        cid = u'{}\\0{}\\0{}'.format(text, self.password, kw)\n        texture = Cache_get('textinput.label', cid)\n\n        if texture is None:\n            # FIXME right now, we can't render very long line...\n            # if we move on \"VBO\" version as fallback, we won't need to\n            # do this.\n            # try to find the maximum text we can handle\n            label = Label(text=ntext, **kw)\n            if text.find(u'\\n') > 0:\n                label.text = u''\n            else:\n                label.text = ntext\n            label.refresh()\n\n            # ok, we found it.\n            texture = label.texture\n            Cache_append('textinput.label', cid, texture)\n            label.text = ''\n        return texture",
  "def _get_line_options(self):\n        kw = super(CodeInput, self)._get_line_options()\n        kw['markup'] = True\n        kw['valign'] = 'top'\n        kw['codeinput'] = repr(self.lexer)\n        return kw",
  "def _get_text_width(self, text, tab_width, _label_cached):\n        # Return the width of a text, according to the current line options.\n        cid = u'{}\\0{}\\0{}'.format(text, self.password,\n                                   self._get_line_options())\n        width = Cache_get('textinput.width', cid)\n        if width is not None:\n            return width\n        lbl = self._create_line_label(text)\n        width = lbl.width\n        Cache_append('textinput.width', cid, width)\n        return width",
  "def _get_bbcode(self, ntext):\n        # get bbcoded text for python\n        try:\n            ntext[0]\n            # replace brackets with special chars that aren't highlighted\n            # by pygment. can't use &bl; ... cause & is highlighted\n            ntext = ntext.replace(u'[', u'\\x01').replace(u']', u'\\x02')\n            ntext = highlight(ntext, self.lexer, self.formatter)\n            ntext = ntext.replace(u'\\x01', u'&bl;').replace(u'\\x02', u'&br;')\n            # replace special chars with &bl; and &br;\n            ntext = ''.join((u'[color=', str(self.text_color), u']',\n                             ntext, u'[/color]'))\n            ntext = ntext.replace(u'\\n', u'')\n            # remove possible extra highlight options\n            ntext = ntext.replace(u'[u]', '').replace(u'[/u]', '')\n            return ntext\n        except IndexError:\n            return ''",
  "def _cursor_offset(self):\n        '''Get the cursor x offset on the current line\n        '''\n        offset = 0\n        try:\n            if self.cursor_col:\n                offset = self._get_text_width(\n                    self._lines[self.cursor_row][:self.cursor_col])\n                return offset\n        except:\n            pass\n        finally:\n            return offset",
  "def on_lexer(self, instance, value):\n        self._trigger_refresh_text()",
  "def on_foreground_color(self, instance, text_color):\n        if not self.use_text_color:\n            self.use_text_color = True\n            return\n        self.text_color = get_hex_from_color(text_color)\n        self.use_text_color = False\n        self.foreground_color = (1, 1, 1, .999)\n        self._trigger_refresh_text()",
  "class CodeInputTest(App):\n        def build(self):\n            return CodeInput(lexer=KivyLexer(),\n                             font_size=12,\n                             text='''\n#:kivy 1.0\n\n<YourWidget>:\n    canvas:\n        Color:\n            rgb: .5, .5, .5\n        Rectangle:\n            pos: self.pos\n            size: self.size''')",
  "def build(self):\n            return CodeInput(lexer=KivyLexer(),\n                             font_size=12,\n                             text='''\n#:kivy 1.0\n\n<YourWidget>:\n    canvas:\n        Color:\n            rgb: .5, .5, .5\n        Rectangle:\n            pos: self.pos\n            size: self.size''')",
  "class DragBehavior(object):\n    '''\n    The DragBehavior `mixin <https://en.wikipedia.org/wiki/Mixin>`_ provides\n    Drag behavior. When combined with a widget, dragging in the rectangle\n    defined by :attr:`drag_rectangle` will drag the widget. Please see\n    the :mod:`drag behaviors module <kivy.uix.behaviors.drag>` documentation\n    for more information.\n\n    .. versionadded:: 1.8.0\n    '''\n\n    drag_distance = NumericProperty(_scroll_distance)\n    '''Distance to move before dragging the :class:`DragBehavior`, in pixels.\n    As soon as the distance has been traveled, the :class:`DragBehavior` will\n    start to drag, and no touch event will be dispatched to the children.\n    It is advisable that you base this value on the dpi of your target device's\n    screen.\n\n    :attr:`drag_distance` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to the `scroll_distance` as defined in the user\n    :class:`~kivy.config.Config` (20 pixels by default).\n    '''\n\n    drag_timeout = NumericProperty(_scroll_timeout)\n    '''Timeout allowed to trigger the :attr:`drag_distance`, in milliseconds.\n    If the user has not moved :attr:`drag_distance` within the timeout,\n    dragging will be disabled, and the touch event will be dispatched to the\n    children.\n\n    :attr:`drag_timeout` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to the `scroll_timeout` as defined in the user\n    :class:`~kivy.config.Config` (55 milliseconds by default).\n    '''\n\n    drag_rect_x = NumericProperty(0)\n    '''X position of the axis aligned bounding rectangle where dragging\n    is allowed (in window coordinates).\n\n    :attr:`drag_rect_x` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    drag_rect_y = NumericProperty(0)\n    '''Y position of the axis aligned bounding rectangle where dragging\n    is allowed (in window coordinates).\n\n    :attr:`drag_rect_Y` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    drag_rect_width = NumericProperty(100)\n    '''Width of the axis aligned bounding rectangle where dragging is allowed.\n\n    :attr:`drag_rect_width` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 100.\n    '''\n\n    drag_rect_height = NumericProperty(100)\n    '''Height of the axis aligned bounding rectangle where dragging is allowed.\n\n    :attr:`drag_rect_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 100.\n    '''\n\n    drag_rectangle = ReferenceListProperty(drag_rect_x, drag_rect_y,\n                                           drag_rect_width, drag_rect_height)\n    '''Position and size of the axis aligned bounding rectangle where dragging\n    is allowed.\n\n    :attr:`drag_rectangle` is a :class:`~kivy.properties.ReferenceListProperty`\n    of (:attr:`drag_rect_x`, :attr:`drag_rect_y`, :attr:`drag_rect_width`,\n    :attr:`drag_rect_height`) properties.\n    '''\n\n    def __init__(self, **kwargs):\n        self._drag_touch = None\n        super(DragBehavior, self).__init__(**kwargs)\n\n    def _get_uid(self, prefix='sv'):\n        return '{0}.{1}'.format(prefix, self.uid)\n\n    def on_touch_down(self, touch):\n        xx, yy, w, h = self.drag_rectangle\n        x, y = touch.pos\n        if not self.collide_point(x, y):\n            touch.ud[self._get_uid('svavoid')] = True\n            return super(DragBehavior, self).on_touch_down(touch)\n        if self._drag_touch or ('button' in touch.profile and\n                                touch.button.startswith('scroll')) or\\\n                not ((xx < x <= xx + w) and (yy < y <= yy + h)):\n            return super(DragBehavior, self).on_touch_down(touch)\n\n        # no mouse scrolling, so the user is going to drag with this touch.\n        self._drag_touch = touch\n        uid = self._get_uid()\n        touch.grab(self)\n        touch.ud[uid] = {\n            'mode': 'unknown',\n            'dx': 0,\n            'dy': 0}\n        Clock.schedule_once(self._change_touch_mode,\n                            self.drag_timeout / 1000.)\n        return True\n\n    def on_touch_move(self, touch):\n        if self._get_uid('svavoid') in touch.ud or\\\n                self._drag_touch is not touch:\n            return super(DragBehavior, self).on_touch_move(touch) or\\\n                self._get_uid() in touch.ud\n        if touch.grab_current is not self:\n            return True\n\n        uid = self._get_uid()\n        ud = touch.ud[uid]\n        mode = ud['mode']\n        if mode == 'unknown':\n            ud['dx'] += abs(touch.dx)\n            ud['dy'] += abs(touch.dy)\n            if ud['dx'] > sp(self.drag_distance):\n                mode = 'drag'\n            if ud['dy'] > sp(self.drag_distance):\n                mode = 'drag'\n            ud['mode'] = mode\n        if mode == 'drag':\n            self.x += touch.dx\n            self.y += touch.dy\n        return True\n\n    def on_touch_up(self, touch):\n        if self._get_uid('svavoid') in touch.ud:\n            return super(DragBehavior, self).on_touch_up(touch)\n\n        if self._drag_touch and self in [x() for x in touch.grab_list]:\n            touch.ungrab(self)\n            self._drag_touch = None\n            ud = touch.ud[self._get_uid()]\n            if ud['mode'] == 'unknown':\n                super(DragBehavior, self).on_touch_down(touch)\n                Clock.schedule_once(partial(self._do_touch_up, touch), .1)\n        else:\n            if self._drag_touch is not touch:\n                super(DragBehavior, self).on_touch_up(touch)\n        return self._get_uid() in touch.ud\n\n    def _do_touch_up(self, touch, *largs):\n        super(DragBehavior, self).on_touch_up(touch)\n        # don't forget about grab event!\n        for x in touch.grab_list[:]:\n            touch.grab_list.remove(x)\n            x = x()\n            if not x:\n                continue\n            touch.grab_current = x\n            super(DragBehavior, self).on_touch_up(touch)\n        touch.grab_current = None\n\n    def _change_touch_mode(self, *largs):\n        if not self._drag_touch:\n            return\n        uid = self._get_uid()\n        touch = self._drag_touch\n        ud = touch.ud[uid]\n        if ud['mode'] != 'unknown':\n            return\n        touch.ungrab(self)\n        self._drag_touch = None\n        touch.push()\n        touch.apply_transform_2d(self.parent.to_widget)\n        super(DragBehavior, self).on_touch_down(touch)\n        touch.pop()\n        return",
  "def __init__(self, **kwargs):\n        self._drag_touch = None\n        super(DragBehavior, self).__init__(**kwargs)",
  "def _get_uid(self, prefix='sv'):\n        return '{0}.{1}'.format(prefix, self.uid)",
  "def on_touch_down(self, touch):\n        xx, yy, w, h = self.drag_rectangle\n        x, y = touch.pos\n        if not self.collide_point(x, y):\n            touch.ud[self._get_uid('svavoid')] = True\n            return super(DragBehavior, self).on_touch_down(touch)\n        if self._drag_touch or ('button' in touch.profile and\n                                touch.button.startswith('scroll')) or\\\n                not ((xx < x <= xx + w) and (yy < y <= yy + h)):\n            return super(DragBehavior, self).on_touch_down(touch)\n\n        # no mouse scrolling, so the user is going to drag with this touch.\n        self._drag_touch = touch\n        uid = self._get_uid()\n        touch.grab(self)\n        touch.ud[uid] = {\n            'mode': 'unknown',\n            'dx': 0,\n            'dy': 0}\n        Clock.schedule_once(self._change_touch_mode,\n                            self.drag_timeout / 1000.)\n        return True",
  "def on_touch_move(self, touch):\n        if self._get_uid('svavoid') in touch.ud or\\\n                self._drag_touch is not touch:\n            return super(DragBehavior, self).on_touch_move(touch) or\\\n                self._get_uid() in touch.ud\n        if touch.grab_current is not self:\n            return True\n\n        uid = self._get_uid()\n        ud = touch.ud[uid]\n        mode = ud['mode']\n        if mode == 'unknown':\n            ud['dx'] += abs(touch.dx)\n            ud['dy'] += abs(touch.dy)\n            if ud['dx'] > sp(self.drag_distance):\n                mode = 'drag'\n            if ud['dy'] > sp(self.drag_distance):\n                mode = 'drag'\n            ud['mode'] = mode\n        if mode == 'drag':\n            self.x += touch.dx\n            self.y += touch.dy\n        return True",
  "def on_touch_up(self, touch):\n        if self._get_uid('svavoid') in touch.ud:\n            return super(DragBehavior, self).on_touch_up(touch)\n\n        if self._drag_touch and self in [x() for x in touch.grab_list]:\n            touch.ungrab(self)\n            self._drag_touch = None\n            ud = touch.ud[self._get_uid()]\n            if ud['mode'] == 'unknown':\n                super(DragBehavior, self).on_touch_down(touch)\n                Clock.schedule_once(partial(self._do_touch_up, touch), .1)\n        else:\n            if self._drag_touch is not touch:\n                super(DragBehavior, self).on_touch_up(touch)\n        return self._get_uid() in touch.ud",
  "def _do_touch_up(self, touch, *largs):\n        super(DragBehavior, self).on_touch_up(touch)\n        # don't forget about grab event!\n        for x in touch.grab_list[:]:\n            touch.grab_list.remove(x)\n            x = x()\n            if not x:\n                continue\n            touch.grab_current = x\n            super(DragBehavior, self).on_touch_up(touch)\n        touch.grab_current = None",
  "def _change_touch_mode(self, *largs):\n        if not self._drag_touch:\n            return\n        uid = self._get_uid()\n        touch = self._drag_touch\n        ud = touch.ud[uid]\n        if ud['mode'] != 'unknown':\n            return\n        touch.ungrab(self)\n        self._drag_touch = None\n        touch.push()\n        touch.apply_transform_2d(self.parent.to_widget)\n        super(DragBehavior, self).on_touch_down(touch)\n        touch.pop()\n        return",
  "class ToggleButtonBehavior(ButtonBehavior):\n    '''This `mixin <https://en.wikipedia.org/wiki/Mixin>`_ class provides\n    :mod:`~kivy.uix.togglebutton` behavior. Please see the\n    :mod:`togglebutton behaviors module <kivy.uix.behaviors.togglebutton>`\n    documentation for more information.\n\n    .. versionadded:: 1.8.0\n    '''\n\n    __groups = {}\n\n    group = ObjectProperty(None, allownone=True)\n    '''Group of the button. If `None`, no group will be used (the button will be\n    independent). If specified, :attr:`group` must be a hashable object, like\n    a string. Only one button in a group can be in a 'down' state.\n\n    :attr:`group` is a :class:`~kivy.properties.ObjectProperty` and defaults to\n    `None`.\n    '''\n\n    allow_no_selection = BooleanProperty(True)\n    '''This specifies whether the widgets in a group allow no selection i.e.\n    everything to be deselected.\n\n    .. versionadded:: 1.9.0\n\n    :attr:`allow_no_selection` is a :class:`BooleanProperty` and defaults to\n    `True`\n    '''\n\n    def __init__(self, **kwargs):\n        self._previous_group = None\n        super(ToggleButtonBehavior, self).__init__(**kwargs)\n\n    def on_group(self, *largs):\n        groups = ToggleButtonBehavior.__groups\n        if self._previous_group:\n            group = groups[self._previous_group]\n            for item in group[:]:\n                if item() is self:\n                    group.remove(item)\n                    break\n        group = self._previous_group = self.group\n        if group not in groups:\n            groups[group] = []\n        r = ref(self, ToggleButtonBehavior._clear_groups)\n        groups[group].append(r)\n\n    def _release_group(self, current):\n        if self.group is None:\n            return\n        group = self.__groups[self.group]\n        for item in group[:]:\n            widget = item()\n            if widget is None:\n                group.remove(item)\n            if widget is current:\n                continue\n            widget.state = 'normal'\n\n    def _do_press(self):\n        if (not self.allow_no_selection and\n                self.group and self.state == 'down'):\n            return\n\n        self._release_group(self)\n        self.state = 'normal' if self.state == 'down' else 'down'\n\n    def _do_release(self, *args):\n        pass\n\n    @staticmethod\n    def _clear_groups(wk):\n        # auto flush the element when the weak reference have been deleted\n        groups = ToggleButtonBehavior.__groups\n        for group in list(groups.values()):\n            if wk in group:\n                group.remove(wk)\n                break\n\n    @staticmethod\n    def get_widgets(groupname):\n        '''Return a list of the widgets contained in a specific group. If the\n        group doesn't exist, an empty list will be returned.\n\n        .. note::\n\n            Always release the result of this method! Holding a reference to\n            any of these widgets can prevent them from being garbage collected.\n            If in doubt, do::\n\n                l = ToggleButtonBehavior.get_widgets('mygroup')\n                # do your job\n                del l\n\n        .. warning::\n\n            It's possible that some widgets that you have previously\n            deleted are still in the list. The garbage collector might need\n            to release other objects before flushing them.\n        '''\n        groups = ToggleButtonBehavior.__groups\n        if groupname not in groups:\n            return []\n        return [x() for x in groups[groupname] if x()][:]",
  "def __init__(self, **kwargs):\n        self._previous_group = None\n        super(ToggleButtonBehavior, self).__init__(**kwargs)",
  "def on_group(self, *largs):\n        groups = ToggleButtonBehavior.__groups\n        if self._previous_group:\n            group = groups[self._previous_group]\n            for item in group[:]:\n                if item() is self:\n                    group.remove(item)\n                    break\n        group = self._previous_group = self.group\n        if group not in groups:\n            groups[group] = []\n        r = ref(self, ToggleButtonBehavior._clear_groups)\n        groups[group].append(r)",
  "def _release_group(self, current):\n        if self.group is None:\n            return\n        group = self.__groups[self.group]\n        for item in group[:]:\n            widget = item()\n            if widget is None:\n                group.remove(item)\n            if widget is current:\n                continue\n            widget.state = 'normal'",
  "def _do_press(self):\n        if (not self.allow_no_selection and\n                self.group and self.state == 'down'):\n            return\n\n        self._release_group(self)\n        self.state = 'normal' if self.state == 'down' else 'down'",
  "def _do_release(self, *args):\n        pass",
  "def _clear_groups(wk):\n        # auto flush the element when the weak reference have been deleted\n        groups = ToggleButtonBehavior.__groups\n        for group in list(groups.values()):\n            if wk in group:\n                group.remove(wk)\n                break",
  "def get_widgets(groupname):\n        '''Return a list of the widgets contained in a specific group. If the\n        group doesn't exist, an empty list will be returned.\n\n        .. note::\n\n            Always release the result of this method! Holding a reference to\n            any of these widgets can prevent them from being garbage collected.\n            If in doubt, do::\n\n                l = ToggleButtonBehavior.get_widgets('mygroup')\n                # do your job\n                del l\n\n        .. warning::\n\n            It's possible that some widgets that you have previously\n            deleted are still in the list. The garbage collector might need\n            to release other objects before flushing them.\n        '''\n        groups = ToggleButtonBehavior.__groups\n        if groupname not in groups:\n            return []\n        return [x() for x in groups[groupname] if x()][:]",
  "class ButtonBehavior(object):\n    '''\n    This `mixin <https://en.wikipedia.org/wiki/Mixin>`_ class provides\n    :class:`~kivy.uix.button.Button` behavior. Please see the\n    :mod:`button behaviors module <kivy.uix.behaviors.button>` documentation\n    for more information.\n\n    :Events:\n        `on_press`\n            Fired when the button is pressed.\n        `on_release`\n            Fired when the button is released (i.e. the touch/click that\n            pressed the button goes away).\n\n    '''\n\n    state = OptionProperty('normal', options=('normal', 'down'))\n    '''The state of the button, must be one of 'normal' or 'down'.\n    The state is 'down' only when the button is currently touched/clicked,\n    otherwise its 'normal'.\n\n    :attr:`state` is an :class:`~kivy.properties.OptionProperty` and defaults\n    to 'normal'.\n    '''\n\n    last_touch = ObjectProperty(None)\n    '''Contains the last relevant touch received by the Button. This can\n    be used in `on_press` or `on_release` in order to know which touch\n    dispatched the event.\n\n    .. versionadded:: 1.8.0\n\n    :attr:`last_touch` is a :class:`~kivy.properties.ObjectProperty` and\n    defaults to `None`.\n    '''\n\n    min_state_time = NumericProperty(0)\n    '''The minimum period of time which the widget must remain in the\n    `'down'` state.\n\n    .. versionadded:: 1.9.1\n\n    :attr:`min_state_time` is a float and defaults to 0.035. This value is\n    taken from :class:`~kivy.config.Config`.\n    '''\n\n    always_release = BooleanProperty(False)\n    '''This determines whether or not the widget fires an `on_release` event if\n    the touch_up is outside the widget.\n\n    .. versionadded:: 1.9.0\n\n    .. versionchanged:: 1.10.0\n        The default value is now False.\n\n    :attr:`always_release` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to `False`.\n    '''\n\n    def __init__(self, **kwargs):\n        self.register_event_type('on_press')\n        self.register_event_type('on_release')\n        if 'min_state_time' not in kwargs:\n            self.min_state_time = float(Config.get('graphics',\n                                                   'min_state_time'))\n        super(ButtonBehavior, self).__init__(**kwargs)\n        self.__state_event = None\n        self.__touch_time = None\n        self.fbind('state', self.cancel_event)\n\n    def _do_press(self):\n        self.state = 'down'\n\n    def _do_release(self, *args):\n        self.state = 'normal'\n\n    def cancel_event(self, *args):\n        if self.__state_event:\n            self.__state_event.cancel()\n            self.__state_event = None\n\n    def on_touch_down(self, touch):\n        if super(ButtonBehavior, self).on_touch_down(touch):\n            return True\n        if touch.is_mouse_scrolling:\n            return False\n        if not self.collide_point(touch.x, touch.y):\n            return False\n        if self in touch.ud:\n            return False\n        touch.grab(self)\n        touch.ud[self] = True\n        self.last_touch = touch\n        self.__touch_time = time()\n        self._do_press()\n        self.dispatch('on_press')\n        return True\n\n    def on_touch_move(self, touch):\n        if touch.grab_current is self:\n            return True\n        if super(ButtonBehavior, self).on_touch_move(touch):\n            return True\n        return self in touch.ud\n\n    def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return super(ButtonBehavior, self).on_touch_up(touch)\n        assert self in touch.ud\n        touch.ungrab(self)\n        self.last_touch = touch\n\n        if (not self.always_release and\n                not self.collide_point(*touch.pos)):\n            self._do_release()\n            return\n\n        touchtime = time() - self.__touch_time\n        if touchtime < self.min_state_time:\n            self.__state_event = Clock.schedule_once(\n                self._do_release, self.min_state_time - touchtime)\n        else:\n            self._do_release()\n        self.dispatch('on_release')\n        return True\n\n    def on_press(self):\n        pass\n\n    def on_release(self):\n        pass\n\n    def trigger_action(self, duration=0.1):\n        '''Trigger whatever action(s) have been bound to the button by calling\n        both the on_press and on_release callbacks.\n\n        This is similar to a quick button press without using any touch events,\n        but note that like most kivy code, this is not guaranteed to be safe to\n        call from external threads. If needed use\n        :class:`Clock <kivy.clock.Clock>` to safely schedule this function and\n        the resulting callbacks to be called from the main thread.\n\n        Duration is the length of the press in seconds. Pass 0 if you want\n        the action to happen instantly.\n\n        .. versionadded:: 1.8.0\n        '''\n        self._do_press()\n        self.dispatch('on_press')\n\n        def trigger_release(dt):\n            self._do_release()\n            self.dispatch('on_release')\n        if not duration:\n            trigger_release(0)\n        else:\n            Clock.schedule_once(trigger_release, duration)",
  "def __init__(self, **kwargs):\n        self.register_event_type('on_press')\n        self.register_event_type('on_release')\n        if 'min_state_time' not in kwargs:\n            self.min_state_time = float(Config.get('graphics',\n                                                   'min_state_time'))\n        super(ButtonBehavior, self).__init__(**kwargs)\n        self.__state_event = None\n        self.__touch_time = None\n        self.fbind('state', self.cancel_event)",
  "def _do_press(self):\n        self.state = 'down'",
  "def _do_release(self, *args):\n        self.state = 'normal'",
  "def cancel_event(self, *args):\n        if self.__state_event:\n            self.__state_event.cancel()\n            self.__state_event = None",
  "def on_touch_down(self, touch):\n        if super(ButtonBehavior, self).on_touch_down(touch):\n            return True\n        if touch.is_mouse_scrolling:\n            return False\n        if not self.collide_point(touch.x, touch.y):\n            return False\n        if self in touch.ud:\n            return False\n        touch.grab(self)\n        touch.ud[self] = True\n        self.last_touch = touch\n        self.__touch_time = time()\n        self._do_press()\n        self.dispatch('on_press')\n        return True",
  "def on_touch_move(self, touch):\n        if touch.grab_current is self:\n            return True\n        if super(ButtonBehavior, self).on_touch_move(touch):\n            return True\n        return self in touch.ud",
  "def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return super(ButtonBehavior, self).on_touch_up(touch)\n        assert self in touch.ud\n        touch.ungrab(self)\n        self.last_touch = touch\n\n        if (not self.always_release and\n                not self.collide_point(*touch.pos)):\n            self._do_release()\n            return\n\n        touchtime = time() - self.__touch_time\n        if touchtime < self.min_state_time:\n            self.__state_event = Clock.schedule_once(\n                self._do_release, self.min_state_time - touchtime)\n        else:\n            self._do_release()\n        self.dispatch('on_release')\n        return True",
  "def on_press(self):\n        pass",
  "def on_release(self):\n        pass",
  "def trigger_action(self, duration=0.1):\n        '''Trigger whatever action(s) have been bound to the button by calling\n        both the on_press and on_release callbacks.\n\n        This is similar to a quick button press without using any touch events,\n        but note that like most kivy code, this is not guaranteed to be safe to\n        call from external threads. If needed use\n        :class:`Clock <kivy.clock.Clock>` to safely schedule this function and\n        the resulting callbacks to be called from the main thread.\n\n        Duration is the length of the press in seconds. Pass 0 if you want\n        the action to happen instantly.\n\n        .. versionadded:: 1.8.0\n        '''\n        self._do_press()\n        self.dispatch('on_press')\n\n        def trigger_release(dt):\n            self._do_release()\n            self.dispatch('on_release')\n        if not duration:\n            trigger_release(0)\n        else:\n            Clock.schedule_once(trigger_release, duration)",
  "def trigger_release(dt):\n            self._do_release()\n            self.dispatch('on_release')",
  "class FocusBehavior(object):\n    '''Provides keyboard focus behavior. When combined with other\n    FocusBehavior widgets it allows one to cycle focus among them by pressing\n    tab. Please see the\n    :mod:`focus behavior module documentation <kivy.uix.behaviors.focus>`\n    for more information.\n\n    .. versionadded:: 1.9.0\n\n    '''\n\n    _requested_keyboard = False\n    _keyboard = ObjectProperty(None, allownone=True)\n    _keyboards = {}\n\n    ignored_touch = []\n    '''A list of touches that should not be used to defocus. After on_touch_up,\n    every touch that is not in :attr:`ignored_touch` will defocus all the\n    focused widgets if the config keyboard mode is not multi. Touches on\n    focusable widgets that were used to focus are automatically added here.\n\n    Example usage::\n\n        class Unfocusable(Widget):\n\n            def on_touch_down(self, touch):\n                if self.collide_point(*touch.pos):\n                    FocusBehavior.ignored_touch.append(touch)\n\n    Notice that you need to access this as a class, not an instance variable.\n    '''\n\n    def _set_keyboard(self, value):\n        focus = self.focus\n        keyboard = self._keyboard\n        keyboards = FocusBehavior._keyboards\n        if keyboard:\n            self.focus = False    # this'll unbind\n            if self._keyboard:  # remove assigned keyboard from dict\n                del keyboards[keyboard]\n        if value and value not in keyboards:\n            keyboards[value] = None\n        self._keyboard = value\n        self.focus = focus\n\n    def _get_keyboard(self):\n        return self._keyboard\n    keyboard = AliasProperty(_get_keyboard, _set_keyboard,\n                             bind=('_keyboard', ))\n    '''The keyboard to bind to (or bound to the widget) when focused.\n\n    When None, a keyboard is requested and released whenever the widget comes\n    into and out of focus. If not None, it must be a keyboard, which gets\n    bound and unbound from the widget whenever it's in or out of focus. It is\n    useful only when more than one keyboard is available, so it is recommended\n    to be set to None when only one keyboard is available.\n\n    If more than one keyboard is available, whenever an instance gets focused\n    a new keyboard will be requested if None. Unless the other instances lose\n    focus (e.g. if tab was used), a new keyboard will appear. When this is\n    undesired, the keyboard property can be used. For example, if there are\n    two users with two keyboards, then each keyboard can be assigned to\n    different groups of instances of FocusBehavior, ensuring that within\n    each group, only one FocusBehavior will have focus, and will receive input\n    from the correct keyboard. See `keyboard_mode` in :mod:`~kivy.config` for\n    more information on the keyboard modes.\n\n    **Keyboard and focus behavior**\n\n    When using the keyboard, there are some important default behaviors you\n    should keep in mind.\n\n    * When Config's `keyboard_mode` is multi, each new touch is considered\n      a touch by a different user and will set the focus (if clicked on a\n      focusable) with a new keyboard. Already focused elements will not lose\n      their focus (even if an unfocusable widget is touched).\n\n    * If the keyboard property is set, that keyboard will be used when the\n      instance gets focused. If widgets with different keyboards are linked\n      through :attr:`focus_next` and :attr:`focus_previous`, then as they are\n      tabbed through, different keyboards will become active. Therefore,\n      typically it's undesirable to link instances which are assigned\n      different keyboards.\n\n    * When a widget has focus, setting its keyboard to None will remove its\n      keyboard, but the widget will then immediately try to get\n      another keyboard. In order to remove its keyboard, rather set its\n      :attr:`focus` to False.\n\n    * When using a software keyboard, typical on mobile and touch devices, the\n      keyboard display behavior is determined by the\n      :attr:`~kivy.core.window.WindowBase.softinput_mode` property. You can use\n      this property to ensure the focused widget is not covered or obscured.\n\n    :attr:`keyboard` is an :class:`~kivy.properties.AliasProperty` and defaults\n    to None.\n\n    .. warning:\n\n        When assigning a keyboard, the keyboard must not be released while\n        it is still assigned to an instance. Similarly, the keyboard created\n        by the instance on focus and assigned to :attr:`keyboard` if None,\n        will be released by the instance when the instance loses focus.\n        Therefore, it is not safe to assign this keyboard to another instance's\n        :attr:`keyboard`.\n    '''\n\n    is_focusable = BooleanProperty(_is_desktop)\n    '''Whether the instance can become focused. If focused, it'll lose focus\n    when set to False.\n\n    :attr:`is_focusable` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to True on a desktop (i.e. `desktop` is True in\n    :mod:`~kivy.config`), False otherwise.\n    '''\n\n    focus = BooleanProperty(False)\n    '''Whether the instance currently has focus.\n\n    Setting it to True will bind to and/or request the keyboard, and input\n    will be forwarded to the instance. Setting it to False will unbind\n    and/or release the keyboard. For a given keyboard, only one widget can\n    have its focus, so focusing one will automatically unfocus the other\n    instance holding its focus.\n\n    When using a software keyboard, please refer to the\n    :attr:`~kivy.core.window.WindowBase.softinput_mode` property to determine\n    how the keyboard display is handled.\n\n    :attr:`focus` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n    '''\n\n    focused = focus\n    '''An alias of :attr:`focus`.\n\n    :attr:`focused` is a :class:`~kivy.properties.BooleanProperty` and defaults\n    to False.\n\n    .. warning::\n        :attr:`focused` is an alias of :attr:`focus` and will be removed in\n        2.0.0.\n    '''\n\n    keyboard_suggestions = BooleanProperty(True)\n    '''If True provides auto suggestions on top of keyboard.\n    This will only work if :attr:`input_type` is set to `text`, `url`, `mail` or\n    `address`.\n\n    .. warning::\n        On Android, `keyboard_suggestions` relies on\n        `InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS` to work, but some keyboards\n        just ignore this flag. If you want to disable suggestions at all on\n        Android, you can set `input_type` to `null`, which will request the\n        input method to run in a limited \"generate key events\" mode.\n\n    .. versionadded:: 2.1.0\n\n    :attr:`keyboard_suggestions` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True\n    '''\n\n    def _set_on_focus_next(self, instance, value):\n        '''If changing focus, ensure your code does not create an infinite loop.\n        eg:\n        ```python\n        widget.focus_next = widget\n        widget.focus_previous = widget\n        ```\n        '''\n        next_ = self._old_focus_next\n        if next_ is value:   # prevent infinite loop\n            return\n\n        if isinstance(next_, FocusBehavior):\n            next_.focus_previous = None\n        self._old_focus_next = value\n        if value is None or value is StopIteration:\n            return\n        if not isinstance(value, FocusBehavior):\n            raise ValueError('focus_next accepts only objects based on'\n                             ' FocusBehavior, or the `StopIteration` class.')\n        value.focus_previous = self\n\n    focus_next = ObjectProperty(None, allownone=True)\n    '''The :class:`FocusBehavior` instance to acquire focus when\n    tab is pressed and this instance has focus, if not `None` or\n    `StopIteration`.\n\n    When tab is pressed, focus cycles through all the :class:`FocusBehavior`\n    widgets that are linked through :attr:`focus_next` and are focusable. If\n    :attr:`focus_next` is `None`, it instead walks the children lists to find\n    the next focusable widget. Finally, if :attr:`focus_next` is\n    the `StopIteration` class, focus won't move forward, but end here.\n\n    .. note:\n\n        Setting :attr:`focus_next` automatically sets :attr:`focus_previous`\n        of the other instance to point to this instance, if not None or\n        `StopIteration`. Similarly, if it wasn't None or `StopIteration`, it\n        also sets the :attr:`focus_previous` property of the instance\n        previously in :attr:`focus_next` to `None`. Therefore, it is only\n        required to set one of the :attr:`focus_previous` or\n        :attr:`focus_next` links since the other side will be set\n        automatically.\n\n    :attr:`focus_next` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to `None`.\n    '''\n\n    def _set_on_focus_previous(self, instance, value):\n        prev = self._old_focus_previous\n        if prev is value:\n            return\n\n        if isinstance(prev, FocusBehavior):\n            prev.focus_next = None\n        self._old_focus_previous = value\n        if value is None or value is StopIteration:\n            return\n        if not isinstance(value, FocusBehavior):\n            raise ValueError('focus_previous accepts only objects based'\n                             'on FocusBehavior, or the `StopIteration` class.')\n        value.focus_next = self\n\n    focus_previous = ObjectProperty(None, allownone=True)\n    '''The :class:`FocusBehavior` instance to acquire focus when\n    shift+tab is pressed on this instance, if not None or `StopIteration`.\n\n    When shift+tab is pressed, focus cycles through all the\n    :class:`FocusBehavior` widgets that are linked through\n    :attr:`focus_previous` and are focusable. If :attr:`focus_previous` is\n    `None`, it instead walks the children tree to find the\n    previous focusable widget. Finally, if :attr:`focus_previous` is the\n    `StopIteration` class, focus won't move backward, but end here.\n\n    .. note:\n\n        Setting :attr:`focus_previous` automatically sets :attr:`focus_next`\n        of the other instance to point to this instance, if not None or\n        `StopIteration`. Similarly, if it wasn't None or `StopIteration`, it\n        also sets the :attr:`focus_next` property of the instance previously in\n        :attr:`focus_previous` to `None`. Therefore, it is only required\n        to set one of the :attr:`focus_previous` or :attr:`focus_next`\n        links since the other side will be set automatically.\n\n    :attr:`focus_previous` is an :class:`~kivy.properties.ObjectProperty` and\n    defaults to `None`.\n    '''\n\n    keyboard_mode = OptionProperty('auto', options=('auto', 'managed'))\n    '''Determines how the keyboard visibility should be managed. 'auto' will\n    result in the standard behavior of showing/hiding on focus. 'managed'\n    requires setting the keyboard visibility manually, or calling the helper\n    functions :meth:`show_keyboard` and :meth:`hide_keyboard`.\n\n    :attr:`keyboard_mode` is an :class:`~kivy.properties.OptionsProperty` and\n    defaults to 'auto'. Can be one of 'auto' or 'managed'.\n    '''\n\n    input_type = OptionProperty('null', options=('null', 'text', 'number',\n                                                 'url', 'mail', 'datetime',\n                                                 'tel', 'address'))\n    '''The kind of input keyboard to request.\n\n    .. versionadded:: 1.8.0\n\n    .. versionchanged:: 2.1.0\n        Changed default value from `text` to `null`. Added `null` to options.\n\n        .. warning::\n            As the default value has been changed, you may need to adjust\n            `input_type` in your code.\n\n    :attr:`input_type` is an :class:`~kivy.properties.OptionsProperty` and\n    defaults to 'null'. Can be one of 'null', 'text', 'number', 'url', 'mail',\n    'datetime', 'tel' or 'address'.\n    '''\n\n    unfocus_on_touch = BooleanProperty(_keyboard_mode not in\n                                       ('multi', 'systemandmulti'))\n    '''Whether a instance should lose focus when clicked outside the instance.\n\n    When a user clicks on a widget that is focus aware and shares the same\n    keyboard as this widget (which in the case with only one keyboard),\n    then as the other widgets gain focus, this widget loses focus. In addition\n    to that, if this property is `True`, clicking on any widget other than this\n    widget, will remove focus from this widget.\n\n    :attr:`unfocus_on_touch` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to `False` if the `keyboard_mode` in :attr:`~kivy.config.Config`\n    is `'multi'` or `'systemandmulti'`, otherwise it defaults to `True`.\n    '''\n\n    def __init__(self, **kwargs):\n        self._old_focus_next = None\n        self._old_focus_previous = None\n        super(FocusBehavior, self).__init__(**kwargs)\n\n        self._keyboard_mode = _keyboard_mode\n        fbind = self.fbind\n        fbind('focus', self._on_focus)\n        fbind('disabled', self._on_focusable)\n        fbind('is_focusable', self._on_focusable)\n        fbind('focus_next', self._set_on_focus_next)\n        fbind('focus_previous', self._set_on_focus_previous)\n\n    def _on_focusable(self, instance, value):\n        if self.disabled or not self.is_focusable:\n            self.focus = False\n\n    def _on_focus(self, instance, value, *largs):\n        if self.keyboard_mode == 'auto':\n            if value:\n                self._bind_keyboard()\n            else:\n                self._unbind_keyboard()\n\n    def _ensure_keyboard(self):\n        if self._keyboard is None:\n            self._requested_keyboard = True\n            keyboard = self._keyboard = EventLoop.window.request_keyboard(\n                self._keyboard_released,\n                self,\n                input_type=self.input_type,\n                keyboard_suggestions=self.keyboard_suggestions,\n            )\n            keyboards = FocusBehavior._keyboards\n            if keyboard not in keyboards:\n                keyboards[keyboard] = None\n\n    def _bind_keyboard(self):\n        self._ensure_keyboard()\n        keyboard = self._keyboard\n\n        if not keyboard or self.disabled or not self.is_focusable:\n            self.focus = False\n            return\n        keyboards = FocusBehavior._keyboards\n        old_focus = keyboards[keyboard]  # keyboard should be in dict\n        if old_focus:\n            old_focus.focus = False\n            # keyboard shouldn't have been released here, see keyboard warning\n        keyboards[keyboard] = self\n        keyboard.bind(on_key_down=self.keyboard_on_key_down,\n                      on_key_up=self.keyboard_on_key_up,\n                      on_textinput=self.keyboard_on_textinput)\n\n    def _unbind_keyboard(self):\n        keyboard = self._keyboard\n        if keyboard:\n            keyboard.unbind(on_key_down=self.keyboard_on_key_down,\n                            on_key_up=self.keyboard_on_key_up,\n                            on_textinput=self.keyboard_on_textinput)\n            if self._requested_keyboard:\n                keyboard.release()\n                self._keyboard = None\n                self._requested_keyboard = False\n                del FocusBehavior._keyboards[keyboard]\n            else:\n                FocusBehavior._keyboards[keyboard] = None\n\n    def keyboard_on_textinput(self, window, text):\n        pass\n\n    def _keyboard_released(self):\n        self.focus = False\n\n    def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return\n        if (not self.disabled and self.is_focusable and\n            ('button' not in touch.profile or\n             not touch.button.startswith('scroll'))):\n            self.focus = True\n            FocusBehavior.ignored_touch.append(touch)\n        return super(FocusBehavior, self).on_touch_down(touch)\n\n    @staticmethod\n    def _handle_post_on_touch_up(touch):\n        ''' Called by window after each touch has finished.\n        '''\n        touches = FocusBehavior.ignored_touch\n        if touch in touches:\n            touches.remove(touch)\n            return\n        if 'button' in touch.profile and touch.button in\\\n                ('scrollup', 'scrolldown', 'scrollleft', 'scrollright'):\n            return\n        for focusable in list(FocusBehavior._keyboards.values()):\n            if focusable is None or not focusable.unfocus_on_touch:\n                continue\n            focusable.focus = False\n\n    def _get_focus_next(self, focus_dir):\n        current = self\n        walk_tree = 'walk' if focus_dir == 'focus_next' else 'walk_reverse'\n\n        while 1:\n            # if we hit a focusable, walk through focus_xxx\n            while getattr(current, focus_dir) is not None:\n                current = getattr(current, focus_dir)\n                if current is self or current is StopIteration:\n                    return None  # make sure we don't loop forever\n                if current.is_focusable and not current.disabled:\n                    return current\n\n            # hit unfocusable, walk widget tree\n            itr = getattr(current, walk_tree)(loopback=True)\n            if focus_dir == 'focus_next':\n                next(itr)  # current is returned first  when walking forward\n            for current in itr:\n                if isinstance(current, FocusBehavior):\n                    break\n            # why did we stop\n            if isinstance(current, FocusBehavior):\n                if current is self:\n                    return None\n                if current.is_focusable and not current.disabled:\n                    return current\n            else:\n                return None\n\n    def get_focus_next(self):\n        '''Returns the next focusable widget using either :attr:`focus_next`\n           or the :attr:`children` similar to the order when tabbing forwards\n           with the ``tab`` key.\n        '''\n        return self._get_focus_next('focus_next')\n\n    def get_focus_previous(self):\n        '''Returns the previous focusable widget using either\n           :attr:`focus_previous` or the :attr:`children` similar to the\n           order when the ``tab`` + ``shift`` keys are triggered together.\n        '''\n        return self._get_focus_next('focus_previous')\n\n    def keyboard_on_key_down(self, window, keycode, text, modifiers):\n        '''The method bound to the keyboard when the instance has focus.\n\n        When the instance becomes focused, this method is bound to the\n        keyboard and will be called for every input press. The parameters are\n        the same as :meth:`kivy.core.window.WindowBase.on_key_down`.\n\n        When overwriting the method in the derived widget, super should be\n        called to enable tab cycling. If the derived widget wishes to use tab\n        for its own purposes, it can call super after it has processed the\n        character (if it does not wish to consume the tab).\n\n        Similar to other keyboard functions, it should return True if the\n        key was consumed.\n        '''\n        if keycode[1] == 'tab':  # deal with cycle\n            modifiers = set(modifiers)\n            if {'ctrl', 'alt', 'meta', 'super', 'compose'} & modifiers:\n                return False\n            if 'shift' in modifiers:\n                next = self.get_focus_previous()\n            else:\n                next = self.get_focus_next()\n            if next:\n                self.focus = False\n\n                next.focus = True\n\n            return True\n        return False\n\n    def keyboard_on_key_up(self, window, keycode):\n        '''The method bound to the keyboard when the instance has focus.\n\n        When the instance becomes focused, this method is bound to the\n        keyboard and will be called for every input release. The parameters are\n        the same as :meth:`kivy.core.window.WindowBase.on_key_up`.\n\n        When overwriting the method in the derived widget, super should be\n        called to enable de-focusing on escape. If the derived widget wishes\n        to use escape for its own purposes, it can call super after it has\n        processed the character (if it does not wish to consume the escape).\n\n        See :meth:`keyboard_on_key_down`\n        '''\n        if keycode[1] == 'escape':\n            self.focus = False\n            return True\n        return False\n\n    def show_keyboard(self):\n        '''\n        Convenience function to show the keyboard in managed mode.\n        '''\n        if self.keyboard_mode == 'managed':\n            self._bind_keyboard()\n\n    def hide_keyboard(self):\n        '''\n        Convenience function to hide the keyboard in managed mode.\n        '''\n        if self.keyboard_mode == 'managed':\n            self._unbind_keyboard()",
  "def _set_keyboard(self, value):\n        focus = self.focus\n        keyboard = self._keyboard\n        keyboards = FocusBehavior._keyboards\n        if keyboard:\n            self.focus = False    # this'll unbind\n            if self._keyboard:  # remove assigned keyboard from dict\n                del keyboards[keyboard]\n        if value and value not in keyboards:\n            keyboards[value] = None\n        self._keyboard = value\n        self.focus = focus",
  "def _get_keyboard(self):\n        return self._keyboard",
  "def _set_on_focus_next(self, instance, value):\n        '''If changing focus, ensure your code does not create an infinite loop.\n        eg:\n        ```python\n        widget.focus_next = widget\n        widget.focus_previous = widget\n        ```\n        '''\n        next_ = self._old_focus_next\n        if next_ is value:   # prevent infinite loop\n            return\n\n        if isinstance(next_, FocusBehavior):\n            next_.focus_previous = None\n        self._old_focus_next = value\n        if value is None or value is StopIteration:\n            return\n        if not isinstance(value, FocusBehavior):\n            raise ValueError('focus_next accepts only objects based on'\n                             ' FocusBehavior, or the `StopIteration` class.')\n        value.focus_previous = self",
  "def _set_on_focus_previous(self, instance, value):\n        prev = self._old_focus_previous\n        if prev is value:\n            return\n\n        if isinstance(prev, FocusBehavior):\n            prev.focus_next = None\n        self._old_focus_previous = value\n        if value is None or value is StopIteration:\n            return\n        if not isinstance(value, FocusBehavior):\n            raise ValueError('focus_previous accepts only objects based'\n                             'on FocusBehavior, or the `StopIteration` class.')\n        value.focus_next = self",
  "def __init__(self, **kwargs):\n        self._old_focus_next = None\n        self._old_focus_previous = None\n        super(FocusBehavior, self).__init__(**kwargs)\n\n        self._keyboard_mode = _keyboard_mode\n        fbind = self.fbind\n        fbind('focus', self._on_focus)\n        fbind('disabled', self._on_focusable)\n        fbind('is_focusable', self._on_focusable)\n        fbind('focus_next', self._set_on_focus_next)\n        fbind('focus_previous', self._set_on_focus_previous)",
  "def _on_focusable(self, instance, value):\n        if self.disabled or not self.is_focusable:\n            self.focus = False",
  "def _on_focus(self, instance, value, *largs):\n        if self.keyboard_mode == 'auto':\n            if value:\n                self._bind_keyboard()\n            else:\n                self._unbind_keyboard()",
  "def _ensure_keyboard(self):\n        if self._keyboard is None:\n            self._requested_keyboard = True\n            keyboard = self._keyboard = EventLoop.window.request_keyboard(\n                self._keyboard_released,\n                self,\n                input_type=self.input_type,\n                keyboard_suggestions=self.keyboard_suggestions,\n            )\n            keyboards = FocusBehavior._keyboards\n            if keyboard not in keyboards:\n                keyboards[keyboard] = None",
  "def _bind_keyboard(self):\n        self._ensure_keyboard()\n        keyboard = self._keyboard\n\n        if not keyboard or self.disabled or not self.is_focusable:\n            self.focus = False\n            return\n        keyboards = FocusBehavior._keyboards\n        old_focus = keyboards[keyboard]  # keyboard should be in dict\n        if old_focus:\n            old_focus.focus = False\n            # keyboard shouldn't have been released here, see keyboard warning\n        keyboards[keyboard] = self\n        keyboard.bind(on_key_down=self.keyboard_on_key_down,\n                      on_key_up=self.keyboard_on_key_up,\n                      on_textinput=self.keyboard_on_textinput)",
  "def _unbind_keyboard(self):\n        keyboard = self._keyboard\n        if keyboard:\n            keyboard.unbind(on_key_down=self.keyboard_on_key_down,\n                            on_key_up=self.keyboard_on_key_up,\n                            on_textinput=self.keyboard_on_textinput)\n            if self._requested_keyboard:\n                keyboard.release()\n                self._keyboard = None\n                self._requested_keyboard = False\n                del FocusBehavior._keyboards[keyboard]\n            else:\n                FocusBehavior._keyboards[keyboard] = None",
  "def keyboard_on_textinput(self, window, text):\n        pass",
  "def _keyboard_released(self):\n        self.focus = False",
  "def on_touch_down(self, touch):\n        if not self.collide_point(*touch.pos):\n            return\n        if (not self.disabled and self.is_focusable and\n            ('button' not in touch.profile or\n             not touch.button.startswith('scroll'))):\n            self.focus = True\n            FocusBehavior.ignored_touch.append(touch)\n        return super(FocusBehavior, self).on_touch_down(touch)",
  "def _handle_post_on_touch_up(touch):\n        ''' Called by window after each touch has finished.\n        '''\n        touches = FocusBehavior.ignored_touch\n        if touch in touches:\n            touches.remove(touch)\n            return\n        if 'button' in touch.profile and touch.button in\\\n                ('scrollup', 'scrolldown', 'scrollleft', 'scrollright'):\n            return\n        for focusable in list(FocusBehavior._keyboards.values()):\n            if focusable is None or not focusable.unfocus_on_touch:\n                continue\n            focusable.focus = False",
  "def _get_focus_next(self, focus_dir):\n        current = self\n        walk_tree = 'walk' if focus_dir == 'focus_next' else 'walk_reverse'\n\n        while 1:\n            # if we hit a focusable, walk through focus_xxx\n            while getattr(current, focus_dir) is not None:\n                current = getattr(current, focus_dir)\n                if current is self or current is StopIteration:\n                    return None  # make sure we don't loop forever\n                if current.is_focusable and not current.disabled:\n                    return current\n\n            # hit unfocusable, walk widget tree\n            itr = getattr(current, walk_tree)(loopback=True)\n            if focus_dir == 'focus_next':\n                next(itr)  # current is returned first  when walking forward\n            for current in itr:\n                if isinstance(current, FocusBehavior):\n                    break\n            # why did we stop\n            if isinstance(current, FocusBehavior):\n                if current is self:\n                    return None\n                if current.is_focusable and not current.disabled:\n                    return current\n            else:\n                return None",
  "def get_focus_next(self):\n        '''Returns the next focusable widget using either :attr:`focus_next`\n           or the :attr:`children` similar to the order when tabbing forwards\n           with the ``tab`` key.\n        '''\n        return self._get_focus_next('focus_next')",
  "def get_focus_previous(self):\n        '''Returns the previous focusable widget using either\n           :attr:`focus_previous` or the :attr:`children` similar to the\n           order when the ``tab`` + ``shift`` keys are triggered together.\n        '''\n        return self._get_focus_next('focus_previous')",
  "def keyboard_on_key_down(self, window, keycode, text, modifiers):\n        '''The method bound to the keyboard when the instance has focus.\n\n        When the instance becomes focused, this method is bound to the\n        keyboard and will be called for every input press. The parameters are\n        the same as :meth:`kivy.core.window.WindowBase.on_key_down`.\n\n        When overwriting the method in the derived widget, super should be\n        called to enable tab cycling. If the derived widget wishes to use tab\n        for its own purposes, it can call super after it has processed the\n        character (if it does not wish to consume the tab).\n\n        Similar to other keyboard functions, it should return True if the\n        key was consumed.\n        '''\n        if keycode[1] == 'tab':  # deal with cycle\n            modifiers = set(modifiers)\n            if {'ctrl', 'alt', 'meta', 'super', 'compose'} & modifiers:\n                return False\n            if 'shift' in modifiers:\n                next = self.get_focus_previous()\n            else:\n                next = self.get_focus_next()\n            if next:\n                self.focus = False\n\n                next.focus = True\n\n            return True\n        return False",
  "def keyboard_on_key_up(self, window, keycode):\n        '''The method bound to the keyboard when the instance has focus.\n\n        When the instance becomes focused, this method is bound to the\n        keyboard and will be called for every input release. The parameters are\n        the same as :meth:`kivy.core.window.WindowBase.on_key_up`.\n\n        When overwriting the method in the derived widget, super should be\n        called to enable de-focusing on escape. If the derived widget wishes\n        to use escape for its own purposes, it can call super after it has\n        processed the character (if it does not wish to consume the escape).\n\n        See :meth:`keyboard_on_key_down`\n        '''\n        if keycode[1] == 'escape':\n            self.focus = False\n            return True\n        return False",
  "def show_keyboard(self):\n        '''\n        Convenience function to show the keyboard in managed mode.\n        '''\n        if self.keyboard_mode == 'managed':\n            self._bind_keyboard()",
  "def hide_keyboard(self):\n        '''\n        Convenience function to hide the keyboard in managed mode.\n        '''\n        if self.keyboard_mode == 'managed':\n            self._unbind_keyboard()",
  "class CodeNavigationBehavior(EventDispatcher):\n    '''Code navigation behavior. Modifies the navigation behavior in TextInput\n    to work like an IDE instead of a word processor. Please see the\n    :mod:`code navigation behaviors module <kivy.uix.behaviors.codenavigation>`\n    documentation for more information.\n\n    .. versionadded:: 1.9.1\n    '''\n\n    def _move_cursor_word_left(self, index=None):\n        pos = index or self.cursor_index()\n        pos -= 1\n\n        if pos == 0:\n            return 0, 0\n\n        col, row = self.get_cursor_from_index(pos)\n        lines = self._lines\n\n        ucase = string.ascii_uppercase\n        lcase = string.ascii_lowercase\n        ws = string.whitespace\n        punct = string.punctuation\n\n        mode = 'normal'\n\n        rline = lines[row]\n        c = rline[col] if len(rline) > col else '\\n'\n        if c in ws:\n            mode = 'ws'\n        elif c == '_':\n            mode = 'us'\n        elif c in punct:\n            mode = 'punct'\n        elif c not in ucase:\n            mode = 'camel'\n\n        while True:\n            if col == -1:\n                if row == 0:\n                    return 0, 0\n                row -= 1\n                rline = lines[row]\n                col = len(rline)\n            lc = c\n            c = rline[col] if len(rline) > col else '\\n'\n            if c == '\\n':\n                if lc not in ws:\n                    col += 1\n                break\n            if mode in ('normal', 'camel') and c in ws:\n                col += 1\n                break\n            if mode in ('normal', 'camel') and c in punct:\n                col += 1\n                break\n            if mode == 'camel' and c in ucase:\n                break\n            if mode == 'punct' and (c == '_' or c not in punct):\n                col += 1\n                break\n            if mode == 'us' and c != '_' and (c in punct or c in ws):\n                col += 1\n                break\n\n            if mode == 'us' and c != '_':\n                mode = ('normal' if c in ucase\n                        else 'ws' if c in ws\n                else 'camel')\n            elif mode == 'ws' and c not in ws:\n                mode = ('normal' if c in ucase\n                        else 'us' if c == '_'\n                else 'punct' if c in punct\n                else 'camel')\n\n            col -= 1\n\n        if col > len(rline):\n            if row == len(lines) - 1:\n                return row, len(lines[row])\n            row += 1\n            col = 0\n\n        return col, row\n\n    def _move_cursor_word_right(self, index=None):\n        pos = index or self.cursor_index()\n        col, row = self.get_cursor_from_index(pos)\n        lines = self._lines\n        mrow = len(lines) - 1\n\n        if row == mrow and col == len(lines[row]):\n            return col, row\n\n        ucase = string.ascii_uppercase\n        lcase = string.ascii_lowercase\n        ws = string.whitespace\n        punct = string.punctuation\n\n        mode = 'normal'\n\n        rline = lines[row]\n        c = rline[col] if len(rline) > col else '\\n'\n        if c in ws:\n            mode = 'ws'\n        elif c == '_':\n            mode = 'us'\n        elif c in punct:\n            mode = 'punct'\n        elif c in lcase:\n            mode = 'camel'\n\n        while True:\n            if mode in ('normal', 'camel', 'punct') and c in ws:\n                mode = 'ws'\n            elif mode in ('normal', 'camel') and c == '_':\n                mode = 'us'\n            elif mode == 'normal' and c not in ucase:\n                mode = 'camel'\n\n            if mode == 'us':\n                if c in ws:\n                    mode = 'ws'\n                elif c != '_':\n                    break\n            if mode == 'ws' and c not in ws:\n                break\n            if mode == 'camel' and c in ucase:\n                break\n            if mode == 'punct' and (c == '_' or c not in punct):\n                break\n            if mode != 'punct' and c != '_' and c in punct:\n                break\n\n            col += 1\n\n            if col > len(rline):\n                if row == mrow:\n                    return len(rline), mrow\n                row += 1\n                rline = lines[row]\n                col = 0\n\n            c = rline[col] if len(rline) > col else '\\n'\n            if c == '\\n':\n                break\n\n        return col, row",
  "def _move_cursor_word_left(self, index=None):\n        pos = index or self.cursor_index()\n        pos -= 1\n\n        if pos == 0:\n            return 0, 0\n\n        col, row = self.get_cursor_from_index(pos)\n        lines = self._lines\n\n        ucase = string.ascii_uppercase\n        lcase = string.ascii_lowercase\n        ws = string.whitespace\n        punct = string.punctuation\n\n        mode = 'normal'\n\n        rline = lines[row]\n        c = rline[col] if len(rline) > col else '\\n'\n        if c in ws:\n            mode = 'ws'\n        elif c == '_':\n            mode = 'us'\n        elif c in punct:\n            mode = 'punct'\n        elif c not in ucase:\n            mode = 'camel'\n\n        while True:\n            if col == -1:\n                if row == 0:\n                    return 0, 0\n                row -= 1\n                rline = lines[row]\n                col = len(rline)\n            lc = c\n            c = rline[col] if len(rline) > col else '\\n'\n            if c == '\\n':\n                if lc not in ws:\n                    col += 1\n                break\n            if mode in ('normal', 'camel') and c in ws:\n                col += 1\n                break\n            if mode in ('normal', 'camel') and c in punct:\n                col += 1\n                break\n            if mode == 'camel' and c in ucase:\n                break\n            if mode == 'punct' and (c == '_' or c not in punct):\n                col += 1\n                break\n            if mode == 'us' and c != '_' and (c in punct or c in ws):\n                col += 1\n                break\n\n            if mode == 'us' and c != '_':\n                mode = ('normal' if c in ucase\n                        else 'ws' if c in ws\n                else 'camel')\n            elif mode == 'ws' and c not in ws:\n                mode = ('normal' if c in ucase\n                        else 'us' if c == '_'\n                else 'punct' if c in punct\n                else 'camel')\n\n            col -= 1\n\n        if col > len(rline):\n            if row == len(lines) - 1:\n                return row, len(lines[row])\n            row += 1\n            col = 0\n\n        return col, row",
  "def _move_cursor_word_right(self, index=None):\n        pos = index or self.cursor_index()\n        col, row = self.get_cursor_from_index(pos)\n        lines = self._lines\n        mrow = len(lines) - 1\n\n        if row == mrow and col == len(lines[row]):\n            return col, row\n\n        ucase = string.ascii_uppercase\n        lcase = string.ascii_lowercase\n        ws = string.whitespace\n        punct = string.punctuation\n\n        mode = 'normal'\n\n        rline = lines[row]\n        c = rline[col] if len(rline) > col else '\\n'\n        if c in ws:\n            mode = 'ws'\n        elif c == '_':\n            mode = 'us'\n        elif c in punct:\n            mode = 'punct'\n        elif c in lcase:\n            mode = 'camel'\n\n        while True:\n            if mode in ('normal', 'camel', 'punct') and c in ws:\n                mode = 'ws'\n            elif mode in ('normal', 'camel') and c == '_':\n                mode = 'us'\n            elif mode == 'normal' and c not in ucase:\n                mode = 'camel'\n\n            if mode == 'us':\n                if c in ws:\n                    mode = 'ws'\n                elif c != '_':\n                    break\n            if mode == 'ws' and c not in ws:\n                break\n            if mode == 'camel' and c in ucase:\n                break\n            if mode == 'punct' and (c == '_' or c not in punct):\n                break\n            if mode != 'punct' and c != '_' and c in punct:\n                break\n\n            col += 1\n\n            if col > len(rline):\n                if row == mrow:\n                    return len(rline), mrow\n                row += 1\n                rline = lines[row]\n                col = 0\n\n            c = rline[col] if len(rline) > col else '\\n'\n            if c == '\\n':\n                break\n\n        return col, row",
  "class TouchRippleBehavior(object):\n    '''Touch ripple behavior.\n\n    Supposed to be used as mixin on widget classes.\n\n    Ripple behavior does not trigger automatically, concrete implementation\n    needs to call :func:`ripple_show` respective :func:`ripple_fade` manually.\n\n    Example\n    -------\n\n    Here we create a Label which renders the touch ripple animation on\n    interaction::\n\n        class RippleLabel(TouchRippleBehavior, Label):\n\n            def __init__(self, **kwargs):\n                super(RippleLabel, self).__init__(**kwargs)\n\n            def on_touch_down(self, touch):\n                collide_point = self.collide_point(touch.x, touch.y)\n                if collide_point:\n                    touch.grab(self)\n                    self.ripple_show(touch)\n                    return True\n                return False\n\n            def on_touch_up(self, touch):\n                if touch.grab_current is self:\n                    touch.ungrab(self)\n                    self.ripple_fade()\n                    return True\n                return False\n    '''\n\n    ripple_rad_default = NumericProperty(10)\n    '''Default radius the animation starts from.\n\n    :attr:`ripple_rad_default` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to `10`.\n    '''\n\n    ripple_duration_in = NumericProperty(.5)\n    '''Animation duration taken to show the overlay.\n\n    :attr:`ripple_duration_in` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to `0.5`.\n    '''\n\n    ripple_duration_out = NumericProperty(.2)\n    '''Animation duration taken to fade the overlay.\n\n    :attr:`ripple_duration_out` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to `0.2`.\n    '''\n\n    ripple_fade_from_alpha = NumericProperty(.5)\n    '''Alpha channel for ripple color the animation starts with.\n\n    :attr:`ripple_fade_from_alpha` is a\n    :class:`~kivy.properties.NumericProperty` and defaults to `0.5`.\n    '''\n\n    ripple_fade_to_alpha = NumericProperty(.8)\n    '''Alpha channel for ripple color the animation targets to.\n\n    :attr:`ripple_fade_to_alpha` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to `0.8`.\n    '''\n\n    ripple_scale = NumericProperty(2.)\n    '''Max scale of the animation overlay calculated from max(width/height) of\n    the decorated widget.\n\n    :attr:`ripple_scale` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to `2.0`.\n    '''\n\n    ripple_func_in = StringProperty('in_cubic')\n    '''Animation callback for showing the overlay.\n\n    :attr:`ripple_func_in` is a :class:`~kivy.properties.StringProperty`\n    and defaults to `in_cubic`.\n    '''\n\n    ripple_func_out = StringProperty('out_quad')\n    '''Animation callback for hiding the overlay.\n\n    :attr:`ripple_func_out` is a :class:`~kivy.properties.StringProperty`\n    and defaults to `out_quad`.\n    '''\n\n    ripple_rad = NumericProperty(10)\n    ripple_pos = ListProperty([0, 0])\n    ripple_color = ListProperty((1., 1., 1., .5))\n\n    def __init__(self, **kwargs):\n        super(TouchRippleBehavior, self).__init__(**kwargs)\n        self.ripple_pane = CanvasBase()\n        self.canvas.add(self.ripple_pane)\n        self.bind(\n            ripple_color=self._ripple_set_color,\n            ripple_pos=self._ripple_set_ellipse,\n            ripple_rad=self._ripple_set_ellipse\n        )\n        self.ripple_ellipse = None\n        self.ripple_col_instruction = None\n\n    def ripple_show(self, touch):\n        '''Begin ripple animation on current widget.\n\n        Expects touch event as argument.\n        '''\n        Animation.cancel_all(self, 'ripple_rad', 'ripple_color')\n        self._ripple_reset_pane()\n        x, y = self.to_window(*self.pos)\n        width, height = self.size\n        if isinstance(self, RelativeLayout):\n            self.ripple_pos = ripple_pos = (touch.x - x, touch.y - y)\n        else:\n            self.ripple_pos = ripple_pos = (touch.x, touch.y)\n        rc = self.ripple_color\n        ripple_rad = self.ripple_rad\n        self.ripple_color = [rc[0], rc[1], rc[2], self.ripple_fade_from_alpha]\n        with self.ripple_pane:\n            ScissorPush(\n                x=int(round(x)),\n                y=int(round(y)),\n                width=int(round(width)),\n                height=int(round(height))\n            )\n            self.ripple_col_instruction = Color(rgba=self.ripple_color)\n            self.ripple_ellipse = Ellipse(\n                size=(ripple_rad, ripple_rad),\n                pos=(\n                    ripple_pos[0] - ripple_rad / 2.,\n                    ripple_pos[1] - ripple_rad / 2.\n                )\n            )\n            ScissorPop()\n        anim = Animation(\n            ripple_rad=max(width, height) * self.ripple_scale,\n            t=self.ripple_func_in,\n            ripple_color=[rc[0], rc[1], rc[2], self.ripple_fade_to_alpha],\n            duration=self.ripple_duration_in\n        )\n        anim.start(self)\n\n    def ripple_fade(self):\n        '''Finish ripple animation on current widget.\n        '''\n        Animation.cancel_all(self, 'ripple_rad', 'ripple_color')\n        width, height = self.size\n        rc = self.ripple_color\n        duration = self.ripple_duration_out\n        anim = Animation(\n            ripple_rad=max(width, height) * self.ripple_scale,\n            ripple_color=[rc[0], rc[1], rc[2], 0.],\n            t=self.ripple_func_out,\n            duration=duration\n        )\n        anim.bind(on_complete=self._ripple_anim_complete)\n        anim.start(self)\n\n    def _ripple_set_ellipse(self, instance, value):\n        ellipse = self.ripple_ellipse\n        if not ellipse:\n            return\n        ripple_pos = self.ripple_pos\n        ripple_rad = self.ripple_rad\n        ellipse.size = (ripple_rad, ripple_rad)\n        ellipse.pos = (\n            ripple_pos[0] - ripple_rad / 2.,\n            ripple_pos[1] - ripple_rad / 2.\n        )\n\n    def _ripple_set_color(self, instance, value):\n        if not self.ripple_col_instruction:\n            return\n        self.ripple_col_instruction.rgba = value\n\n    def _ripple_anim_complete(self, anim, instance):\n        self._ripple_reset_pane()\n\n    def _ripple_reset_pane(self):\n        self.ripple_rad = self.ripple_rad_default\n        self.ripple_pane.clear()",
  "class TouchRippleButtonBehavior(TouchRippleBehavior):\n    '''\n    This `mixin <https://en.wikipedia.org/wiki/Mixin>`_ class provides\n    a similar behavior to :class:`~kivy.uix.behaviors.button.ButtonBehavior`\n    but provides touch ripple animation instead of button pressed/released as\n    visual effect.\n\n    :Events:\n        `on_press`\n            Fired when the button is pressed.\n        `on_release`\n            Fired when the button is released (i.e. the touch/click that\n            pressed the button goes away).\n    '''\n\n    last_touch = ObjectProperty(None)\n    '''Contains the last relevant touch received by the Button. This can\n    be used in `on_press` or `on_release` in order to know which touch\n    dispatched the event.\n\n    :attr:`last_touch` is a :class:`~kivy.properties.ObjectProperty` and\n    defaults to `None`.\n    '''\n\n    always_release = BooleanProperty(False)\n    '''This determines whether or not the widget fires an `on_release` event if\n    the touch_up is outside the widget.\n\n    :attr:`always_release` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to `False`.\n    '''\n\n    def __init__(self, **kwargs):\n        self.register_event_type('on_press')\n        self.register_event_type('on_release')\n        super(TouchRippleButtonBehavior, self).__init__(**kwargs)\n\n    def on_touch_down(self, touch):\n        if super(TouchRippleButtonBehavior, self).on_touch_down(touch):\n            return True\n        if touch.is_mouse_scrolling:\n            return False\n        if not self.collide_point(touch.x, touch.y):\n            return False\n        if self in touch.ud:\n            return False\n        touch.grab(self)\n        touch.ud[self] = True\n        self.last_touch = touch\n        self.ripple_show(touch)\n        self.dispatch('on_press')\n        return True\n\n    def on_touch_move(self, touch):\n        if touch.grab_current is self:\n            return True\n        if super(TouchRippleButtonBehavior, self).on_touch_move(touch):\n            return True\n        return self in touch.ud\n\n    def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return super(TouchRippleButtonBehavior, self).on_touch_up(touch)\n        assert self in touch.ud\n        touch.ungrab(self)\n        self.last_touch = touch\n        if self.disabled:\n            return\n        self.ripple_fade()\n        if not self.always_release and not self.collide_point(*touch.pos):\n            return\n\n        # defer on_release until ripple_fade has completed\n        def defer_release(dt):\n            self.dispatch('on_release')\n        Clock.schedule_once(defer_release, self.ripple_duration_out)\n        return True\n\n    def on_disabled(self, instance, value):\n        # ensure ripple animation completes if disabled gets set to True\n        if value:\n            self.ripple_fade()\n        return super(TouchRippleButtonBehavior, self).on_disabled(\n            instance, value)\n\n    def on_press(self):\n        pass\n\n    def on_release(self):\n        pass",
  "def __init__(self, **kwargs):\n        super(TouchRippleBehavior, self).__init__(**kwargs)\n        self.ripple_pane = CanvasBase()\n        self.canvas.add(self.ripple_pane)\n        self.bind(\n            ripple_color=self._ripple_set_color,\n            ripple_pos=self._ripple_set_ellipse,\n            ripple_rad=self._ripple_set_ellipse\n        )\n        self.ripple_ellipse = None\n        self.ripple_col_instruction = None",
  "def ripple_show(self, touch):\n        '''Begin ripple animation on current widget.\n\n        Expects touch event as argument.\n        '''\n        Animation.cancel_all(self, 'ripple_rad', 'ripple_color')\n        self._ripple_reset_pane()\n        x, y = self.to_window(*self.pos)\n        width, height = self.size\n        if isinstance(self, RelativeLayout):\n            self.ripple_pos = ripple_pos = (touch.x - x, touch.y - y)\n        else:\n            self.ripple_pos = ripple_pos = (touch.x, touch.y)\n        rc = self.ripple_color\n        ripple_rad = self.ripple_rad\n        self.ripple_color = [rc[0], rc[1], rc[2], self.ripple_fade_from_alpha]\n        with self.ripple_pane:\n            ScissorPush(\n                x=int(round(x)),\n                y=int(round(y)),\n                width=int(round(width)),\n                height=int(round(height))\n            )\n            self.ripple_col_instruction = Color(rgba=self.ripple_color)\n            self.ripple_ellipse = Ellipse(\n                size=(ripple_rad, ripple_rad),\n                pos=(\n                    ripple_pos[0] - ripple_rad / 2.,\n                    ripple_pos[1] - ripple_rad / 2.\n                )\n            )\n            ScissorPop()\n        anim = Animation(\n            ripple_rad=max(width, height) * self.ripple_scale,\n            t=self.ripple_func_in,\n            ripple_color=[rc[0], rc[1], rc[2], self.ripple_fade_to_alpha],\n            duration=self.ripple_duration_in\n        )\n        anim.start(self)",
  "def ripple_fade(self):\n        '''Finish ripple animation on current widget.\n        '''\n        Animation.cancel_all(self, 'ripple_rad', 'ripple_color')\n        width, height = self.size\n        rc = self.ripple_color\n        duration = self.ripple_duration_out\n        anim = Animation(\n            ripple_rad=max(width, height) * self.ripple_scale,\n            ripple_color=[rc[0], rc[1], rc[2], 0.],\n            t=self.ripple_func_out,\n            duration=duration\n        )\n        anim.bind(on_complete=self._ripple_anim_complete)\n        anim.start(self)",
  "def _ripple_set_ellipse(self, instance, value):\n        ellipse = self.ripple_ellipse\n        if not ellipse:\n            return\n        ripple_pos = self.ripple_pos\n        ripple_rad = self.ripple_rad\n        ellipse.size = (ripple_rad, ripple_rad)\n        ellipse.pos = (\n            ripple_pos[0] - ripple_rad / 2.,\n            ripple_pos[1] - ripple_rad / 2.\n        )",
  "def _ripple_set_color(self, instance, value):\n        if not self.ripple_col_instruction:\n            return\n        self.ripple_col_instruction.rgba = value",
  "def _ripple_anim_complete(self, anim, instance):\n        self._ripple_reset_pane()",
  "def _ripple_reset_pane(self):\n        self.ripple_rad = self.ripple_rad_default\n        self.ripple_pane.clear()",
  "def __init__(self, **kwargs):\n        self.register_event_type('on_press')\n        self.register_event_type('on_release')\n        super(TouchRippleButtonBehavior, self).__init__(**kwargs)",
  "def on_touch_down(self, touch):\n        if super(TouchRippleButtonBehavior, self).on_touch_down(touch):\n            return True\n        if touch.is_mouse_scrolling:\n            return False\n        if not self.collide_point(touch.x, touch.y):\n            return False\n        if self in touch.ud:\n            return False\n        touch.grab(self)\n        touch.ud[self] = True\n        self.last_touch = touch\n        self.ripple_show(touch)\n        self.dispatch('on_press')\n        return True",
  "def on_touch_move(self, touch):\n        if touch.grab_current is self:\n            return True\n        if super(TouchRippleButtonBehavior, self).on_touch_move(touch):\n            return True\n        return self in touch.ud",
  "def on_touch_up(self, touch):\n        if touch.grab_current is not self:\n            return super(TouchRippleButtonBehavior, self).on_touch_up(touch)\n        assert self in touch.ud\n        touch.ungrab(self)\n        self.last_touch = touch\n        if self.disabled:\n            return\n        self.ripple_fade()\n        if not self.always_release and not self.collide_point(*touch.pos):\n            return\n\n        # defer on_release until ripple_fade has completed\n        def defer_release(dt):\n            self.dispatch('on_release')\n        Clock.schedule_once(defer_release, self.ripple_duration_out)\n        return True",
  "def on_disabled(self, instance, value):\n        # ensure ripple animation completes if disabled gets set to True\n        if value:\n            self.ripple_fade()\n        return super(TouchRippleButtonBehavior, self).on_disabled(\n            instance, value)",
  "def on_press(self):\n        pass",
  "def on_release(self):\n        pass",
  "def defer_release(dt):\n            self.dispatch('on_release')",
  "class CoverBehavior(object):\n    '''The CoverBehavior `mixin <https://en.wikipedia.org/wiki/Mixin>`_\n    provides rendering a texture covering full widget size keeping aspect ratio\n    of the original texture.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    reference_size = ListProperty([])\n    '''Reference size used for aspect ratio approximation calculation.\n\n    :attr:`reference_size` is a :class:`~kivy.properties.ListProperty` and\n    defaults to `[]`.\n    '''\n\n    cover_size = ListProperty([0, 0])\n    '''Size of the aspect ratio aware texture. Gets calculated in\n    ``CoverBehavior.calculate_cover``.\n\n    :attr:`cover_size` is a :class:`~kivy.properties.ListProperty` and\n    defaults to `[0, 0]`.\n    '''\n\n    cover_pos = ListProperty([0, 0])\n    '''Position of the aspect ratio aware texture. Gets calculated in\n    ``CoverBehavior.calculate_cover``.\n\n    :attr:`cover_pos` is a :class:`~kivy.properties.ListProperty` and\n    defaults to `[0, 0]`.\n    '''\n\n    def __init__(self, **kwargs):\n        super(CoverBehavior, self).__init__(**kwargs)\n        # bind covering\n        self.bind(\n            size=self.calculate_cover,\n            pos=self.calculate_cover\n        )\n\n    def _aspect_ratio_approximate(self, size):\n        # return a decimal approximation of an aspect ratio.\n        return Decimal('%.2f' % (float(size[0]) / size[1]))\n\n    def _scale_size(self, size, sizer):\n        # return scaled size based on sizer, where sizer (n, None) scales x\n        # to n and (None, n) scales y to n\n        size_new = list(sizer)\n        i = size_new.index(None)\n        j = i * -1 + 1\n        size_new[i] = (size_new[j] * size[i]) / size[j]\n        return tuple(size_new)\n\n    def calculate_cover(self, *args):\n        # return if no reference size yet\n        if not self.reference_size:\n            return\n        size = self.size\n        origin_appr = self._aspect_ratio_approximate(self.reference_size)\n        crop_appr = self._aspect_ratio_approximate(size)\n        # same aspect ratio\n        if origin_appr == crop_appr:\n            crop_size = self.size\n            offset = (0, 0)\n        # scale x\n        elif origin_appr < crop_appr:\n            crop_size = self._scale_size(self.reference_size, (size[0], None))\n            offset = (0, ((crop_size[1] - size[1]) / 2) * -1)\n        # scale y\n        else:\n            crop_size = self._scale_size(self.reference_size, (None, size[1]))\n            offset = (((crop_size[0] - size[0]) / 2) * -1, 0)\n        # set background size and position\n        self.cover_size = crop_size\n        self.cover_pos = offset",
  "def __init__(self, **kwargs):\n        super(CoverBehavior, self).__init__(**kwargs)\n        # bind covering\n        self.bind(\n            size=self.calculate_cover,\n            pos=self.calculate_cover\n        )",
  "def _aspect_ratio_approximate(self, size):\n        # return a decimal approximation of an aspect ratio.\n        return Decimal('%.2f' % (float(size[0]) / size[1]))",
  "def _scale_size(self, size, sizer):\n        # return scaled size based on sizer, where sizer (n, None) scales x\n        # to n and (None, n) scales y to n\n        size_new = list(sizer)\n        i = size_new.index(None)\n        j = i * -1 + 1\n        size_new[i] = (size_new[j] * size[i]) / size[j]\n        return tuple(size_new)",
  "def calculate_cover(self, *args):\n        # return if no reference size yet\n        if not self.reference_size:\n            return\n        size = self.size\n        origin_appr = self._aspect_ratio_approximate(self.reference_size)\n        crop_appr = self._aspect_ratio_approximate(size)\n        # same aspect ratio\n        if origin_appr == crop_appr:\n            crop_size = self.size\n            offset = (0, 0)\n        # scale x\n        elif origin_appr < crop_appr:\n            crop_size = self._scale_size(self.reference_size, (size[0], None))\n            offset = (0, ((crop_size[1] - size[1]) / 2) * -1)\n        # scale y\n        else:\n            crop_size = self._scale_size(self.reference_size, (None, size[1]))\n            offset = (((crop_size[0] - size[0]) / 2) * -1, 0)\n        # set background size and position\n        self.cover_size = crop_size\n        self.cover_pos = offset",
  "class KNSpace(EventDispatcher):\n    '''Each :class:`KNSpace` instance is a namespace that stores the named Kivy\n    objects associated with this namespace. Each named object is\n    stored as the value of a Kivy :class:`~kivy.properties.ObjectProperty` of\n    this instance whose property name is the object's given name. Both `rebind`\n    and `allownone` are set to `True` for the property.\n\n    See :attr:`KNSpaceBehavior.knspace` for details on how a namespace is\n    associated with a named object.\n\n    When storing an object in the namespace, the object's `proxy_ref` is\n    stored if the object has such an attribute.\n\n    :Parameters:\n\n        `parent`: (internal) A :class:`KNSpace` instance or None.\n            If specified, it's a parent namespace, in which case, the current\n            namespace will have in its namespace all its named objects\n            as well as the named objects of its parent and parent's parent\n            etc. See :meth:`fork` for more details.\n    '''\n\n    parent = None\n    '''(internal) The parent namespace instance, :class:`KNSpace`, or None. See\n    :meth:`fork`.\n    '''\n    __has_applied = None\n\n    keep_ref = False\n    '''Whether a direct reference should be kept to the stored objects.\n    If ``True``, we use the direct object, otherwise we use\n    :attr:`~kivy.uix.widget.proxy_ref` when present.\n\n    Defaults to False.\n    '''\n\n    def __init__(self, parent=None, keep_ref=False, **kwargs):\n        self.keep_ref = keep_ref\n        super(KNSpace, self).__init__(**kwargs)\n        self.parent = parent\n        self.__has_applied = set(self.properties().keys())\n\n    def __setattr__(self, name, value):\n        prop = super(KNSpace, self).property(name, quiet=True)\n        has_applied = self.__has_applied\n        if prop is None:\n            if hasattr(self, name):\n                super(KNSpace, self).__setattr__(name, value)\n            else:\n                self.apply_property(\n                    **{name:\n                       ObjectProperty(None, rebind=True, allownone=True)}\n                )\n                if not self.keep_ref:\n                    value = getattr(value, 'proxy_ref', value)\n                has_applied.add(name)\n                super(KNSpace, self).__setattr__(name, value)\n        elif name not in has_applied:\n            self.apply_property(**{name: prop})\n            has_applied.add(name)\n            if not self.keep_ref:\n                value = getattr(value, 'proxy_ref', value)\n            super(KNSpace, self).__setattr__(name, value)\n        else:\n            if not self.keep_ref:\n                value = getattr(value, 'proxy_ref', value)\n            super(KNSpace, self).__setattr__(name, value)\n\n    def __getattribute__(self, name):\n        if name in super(KNSpace, self).__getattribute__('__dict__'):\n            return super(KNSpace, self).__getattribute__(name)\n\n        try:\n            value = super(KNSpace, self).__getattribute__(name)\n        except AttributeError:\n            parent = super(KNSpace, self).__getattribute__('parent')\n            if parent is None:\n                raise AttributeError(name)\n            return getattr(parent, name)\n\n        if value is not None:\n            return value\n\n        parent = super(KNSpace, self).__getattribute__('parent')\n        if parent is None:\n            return None\n\n        try:\n            return getattr(parent, name)  # if parent doesn't have it\n        except AttributeError:\n            return None\n\n    def property(self, name, quiet=False):\n        # needs to overwrite EventDispatcher.property so kv lang will work\n        prop = super(KNSpace, self).property(name, quiet=True)\n        if prop is not None:\n            return prop\n\n        prop = ObjectProperty(None, rebind=True, allownone=True)\n        self.apply_property(**{name: prop})\n        self.__has_applied.add(name)\n        return prop\n\n    def fork(self):\n        '''Returns a new :class:`KNSpace` instance which will have access to\n        all the named objects in the current namespace but will also have a\n        namespace of its own that is unique to it.\n\n        For example:\n\n        .. code-block:: python\n\n            forked_knspace1 = knspace.fork()\n            forked_knspace2 = knspace.fork()\n\n        Now, any names added to `knspace` will be accessible by the\n        `forked_knspace1` and `forked_knspace2` namespaces by the normal means.\n        However, any names added to `forked_knspace1` will not be accessible\n        from `knspace` or `forked_knspace2`. Similar for `forked_knspace2`.\n        '''\n        return KNSpace(parent=self)",
  "class KNSpaceBehavior(object):\n    '''Inheriting from this class allows naming of the inherited objects, which\n    are then added to the associated namespace :attr:`knspace` and accessible\n    through it.\n\n    Please see the :mod:`knspace behaviors module <kivy.uix.behaviors.knspace>`\n    documentation for more information.\n    '''\n\n    _knspace = ObjectProperty(None, allownone=True)\n    _knsname = StringProperty('')\n    __last_knspace = None\n    __callbacks = None\n\n    def __init__(self, knspace=None, **kwargs):\n        self.knspace = knspace\n        super(KNSpaceBehavior, self).__init__(**kwargs)\n\n    def __knspace_clear_callbacks(self, *largs):\n        for obj, name, uid in self.__callbacks:\n            obj.unbind_uid(name, uid)\n        last = self.__last_knspace\n        self.__last_knspace = self.__callbacks = None\n\n        assert self._knspace is None\n        assert last\n\n        new = self.__set_parent_knspace()\n        if new is last:\n            return\n        self.property('_knspace').dispatch(self)\n\n        name = self.knsname\n        if not name:\n            return\n\n        if getattr(last, name) == self:\n            setattr(last, name, None)\n\n        if new:\n            setattr(new, name, self)\n        else:\n            raise ValueError('Object has name \"{}\", but no namespace'.\n                             format(name))\n\n    def __set_parent_knspace(self):\n        callbacks = self.__callbacks = []\n        fbind = self.fbind\n        append = callbacks.append\n        parent_key = self.knspace_key\n        clear = self.__knspace_clear_callbacks\n\n        append((self, 'knspace_key', fbind('knspace_key', clear)))\n        if not parent_key:\n            self.__last_knspace = knspace\n            return knspace\n\n        append((self, parent_key, fbind(parent_key, clear)))\n        parent = getattr(self, parent_key, None)\n        while parent is not None:\n            fbind = parent.fbind\n\n            parent_knspace = getattr(parent, 'knspace', 0)\n            if parent_knspace != 0:\n                append((parent, 'knspace', fbind('knspace', clear)))\n                self.__last_knspace = parent_knspace\n                return parent_knspace\n\n            append((parent, parent_key, fbind(parent_key, clear)))\n            new_parent = getattr(parent, parent_key, None)\n            if new_parent is parent:\n                break\n            parent = new_parent\n        self.__last_knspace = knspace\n        return knspace\n\n    def _get_knspace(self):\n        _knspace = self._knspace\n        if _knspace is not None:\n            return _knspace\n\n        if self.__callbacks is not None:\n            return self.__last_knspace\n\n        # we only get here if we never accessed our knspace\n        return self.__set_parent_knspace()\n\n    def _set_knspace(self, value):\n        if value is self._knspace:\n            return\n\n        knspace = self._knspace or self.__last_knspace\n        name = self.knsname\n        if name and knspace and getattr(knspace, name) == self:\n            setattr(knspace, name, None)  # reset old namespace\n\n        if value == 'fork':\n            if not knspace:\n                knspace = self.knspace  # get parents in case we haven't before\n            if knspace:\n                value = knspace.fork()\n            else:\n                raise ValueError('Cannot fork with no namespace')\n\n        for obj, prop_name, uid in self.__callbacks or []:\n            obj.unbind_uid(prop_name, uid)\n        self.__last_knspace = self.__callbacks = None\n\n        if name:\n            if value is None:  # if None, first update the recursive knspace\n                knspace = self.__set_parent_knspace()\n                if knspace:\n                    setattr(knspace, name, self)\n                self._knspace = None  # cause a kv trigger\n            else:\n                setattr(value, name, self)\n                knspace = self._knspace = value\n\n            if not knspace:\n                raise ValueError('Object has name \"{}\", but no namespace'.\n                                 format(name))\n        else:\n            if value is None:\n                self.__set_parent_knspace()  # update before trigger below\n            self._knspace = value\n\n    knspace = AliasProperty(\n        _get_knspace, _set_knspace, bind=('_knspace', ), cache=False,\n        rebind=True, allownone=True)\n    '''The namespace instance, :class:`KNSpace`, associated with this widget.\n    The :attr:`knspace` namespace stores this widget when naming this widget\n    with :attr:`knsname`.\n\n    If the namespace has been set with a :class:`KNSpace` instance, e.g. with\n    `self.knspace = KNSpace()`, then that instance is returned (setting with\n    `None` doesn't count). Otherwise, if :attr:`knspace_key` is not None, we\n    look for a namespace to use in the object that is stored in the property\n    named :attr:`knspace_key`, of this instance. I.e.\n    `object = getattr(self, self.knspace_key)`.\n\n    If that object has a knspace property, then we return its value. Otherwise,\n    we go further up, e.g. with `getattr(object, self.knspace_key)` and look\n    for its `knspace` property.\n\n    Finally, if we reach a value of `None`, or :attr:`knspace_key` was `None`,\n    the default :attr:`~kivy.uix.behaviors.knspace.knspace` namespace is\n    returned.\n\n    If :attr:`knspace` is set to the string `'fork'`, the current namespace\n    in :attr:`knspace` will be forked with :meth:`KNSpace.fork` and the\n    resulting namespace will be assigned to this instance's :attr:`knspace`.\n    See the module examples for a motivating example.\n\n    Both `rebind` and `allownone` are `True`.\n    '''\n\n    knspace_key = StringProperty('parent', allownone=True)\n    '''The name of the property of this instance, to use to search upwards for\n    a namespace to use by this instance. Defaults to `'parent'` so that we'll\n    search the parent tree. See :attr:`knspace`.\n\n    When `None`, we won't search the parent tree for the namespace.\n    `allownone` is `True`.\n    '''\n\n    def _get_knsname(self):\n        return self._knsname\n\n    def _set_knsname(self, value):\n        old_name = self._knsname\n        knspace = self.knspace\n        if old_name and knspace and getattr(knspace, old_name) == self:\n            setattr(knspace, old_name, None)\n\n        self._knsname = value\n        if value:\n            if knspace:\n                setattr(knspace, value, self)\n            else:\n                raise ValueError('Object has name \"{}\", but no namespace'.\n                                 format(value))\n\n    knsname = AliasProperty(\n        _get_knsname, _set_knsname, bind=('_knsname', ), cache=False)\n    '''The name given to this instance. If named, the name will be added to the\n    associated :attr:`knspace` namespace, which will then point to the\n    `proxy_ref` of this instance.\n\n    When named, one can access this object by e.g. self.knspace.name, where\n    `name` is the given name of this instance. See :attr:`knspace` and the\n    module description for more details.\n    '''",
  "def __init__(self, parent=None, keep_ref=False, **kwargs):\n        self.keep_ref = keep_ref\n        super(KNSpace, self).__init__(**kwargs)\n        self.parent = parent\n        self.__has_applied = set(self.properties().keys())",
  "def __setattr__(self, name, value):\n        prop = super(KNSpace, self).property(name, quiet=True)\n        has_applied = self.__has_applied\n        if prop is None:\n            if hasattr(self, name):\n                super(KNSpace, self).__setattr__(name, value)\n            else:\n                self.apply_property(\n                    **{name:\n                       ObjectProperty(None, rebind=True, allownone=True)}\n                )\n                if not self.keep_ref:\n                    value = getattr(value, 'proxy_ref', value)\n                has_applied.add(name)\n                super(KNSpace, self).__setattr__(name, value)\n        elif name not in has_applied:\n            self.apply_property(**{name: prop})\n            has_applied.add(name)\n            if not self.keep_ref:\n                value = getattr(value, 'proxy_ref', value)\n            super(KNSpace, self).__setattr__(name, value)\n        else:\n            if not self.keep_ref:\n                value = getattr(value, 'proxy_ref', value)\n            super(KNSpace, self).__setattr__(name, value)",
  "def __getattribute__(self, name):\n        if name in super(KNSpace, self).__getattribute__('__dict__'):\n            return super(KNSpace, self).__getattribute__(name)\n\n        try:\n            value = super(KNSpace, self).__getattribute__(name)\n        except AttributeError:\n            parent = super(KNSpace, self).__getattribute__('parent')\n            if parent is None:\n                raise AttributeError(name)\n            return getattr(parent, name)\n\n        if value is not None:\n            return value\n\n        parent = super(KNSpace, self).__getattribute__('parent')\n        if parent is None:\n            return None\n\n        try:\n            return getattr(parent, name)  # if parent doesn't have it\n        except AttributeError:\n            return None",
  "def property(self, name, quiet=False):\n        # needs to overwrite EventDispatcher.property so kv lang will work\n        prop = super(KNSpace, self).property(name, quiet=True)\n        if prop is not None:\n            return prop\n\n        prop = ObjectProperty(None, rebind=True, allownone=True)\n        self.apply_property(**{name: prop})\n        self.__has_applied.add(name)\n        return prop",
  "def fork(self):\n        '''Returns a new :class:`KNSpace` instance which will have access to\n        all the named objects in the current namespace but will also have a\n        namespace of its own that is unique to it.\n\n        For example:\n\n        .. code-block:: python\n\n            forked_knspace1 = knspace.fork()\n            forked_knspace2 = knspace.fork()\n\n        Now, any names added to `knspace` will be accessible by the\n        `forked_knspace1` and `forked_knspace2` namespaces by the normal means.\n        However, any names added to `forked_knspace1` will not be accessible\n        from `knspace` or `forked_knspace2`. Similar for `forked_knspace2`.\n        '''\n        return KNSpace(parent=self)",
  "def __init__(self, knspace=None, **kwargs):\n        self.knspace = knspace\n        super(KNSpaceBehavior, self).__init__(**kwargs)",
  "def __knspace_clear_callbacks(self, *largs):\n        for obj, name, uid in self.__callbacks:\n            obj.unbind_uid(name, uid)\n        last = self.__last_knspace\n        self.__last_knspace = self.__callbacks = None\n\n        assert self._knspace is None\n        assert last\n\n        new = self.__set_parent_knspace()\n        if new is last:\n            return\n        self.property('_knspace').dispatch(self)\n\n        name = self.knsname\n        if not name:\n            return\n\n        if getattr(last, name) == self:\n            setattr(last, name, None)\n\n        if new:\n            setattr(new, name, self)\n        else:\n            raise ValueError('Object has name \"{}\", but no namespace'.\n                             format(name))",
  "def __set_parent_knspace(self):\n        callbacks = self.__callbacks = []\n        fbind = self.fbind\n        append = callbacks.append\n        parent_key = self.knspace_key\n        clear = self.__knspace_clear_callbacks\n\n        append((self, 'knspace_key', fbind('knspace_key', clear)))\n        if not parent_key:\n            self.__last_knspace = knspace\n            return knspace\n\n        append((self, parent_key, fbind(parent_key, clear)))\n        parent = getattr(self, parent_key, None)\n        while parent is not None:\n            fbind = parent.fbind\n\n            parent_knspace = getattr(parent, 'knspace', 0)\n            if parent_knspace != 0:\n                append((parent, 'knspace', fbind('knspace', clear)))\n                self.__last_knspace = parent_knspace\n                return parent_knspace\n\n            append((parent, parent_key, fbind(parent_key, clear)))\n            new_parent = getattr(parent, parent_key, None)\n            if new_parent is parent:\n                break\n            parent = new_parent\n        self.__last_knspace = knspace\n        return knspace",
  "def _get_knspace(self):\n        _knspace = self._knspace\n        if _knspace is not None:\n            return _knspace\n\n        if self.__callbacks is not None:\n            return self.__last_knspace\n\n        # we only get here if we never accessed our knspace\n        return self.__set_parent_knspace()",
  "def _set_knspace(self, value):\n        if value is self._knspace:\n            return\n\n        knspace = self._knspace or self.__last_knspace\n        name = self.knsname\n        if name and knspace and getattr(knspace, name) == self:\n            setattr(knspace, name, None)  # reset old namespace\n\n        if value == 'fork':\n            if not knspace:\n                knspace = self.knspace  # get parents in case we haven't before\n            if knspace:\n                value = knspace.fork()\n            else:\n                raise ValueError('Cannot fork with no namespace')\n\n        for obj, prop_name, uid in self.__callbacks or []:\n            obj.unbind_uid(prop_name, uid)\n        self.__last_knspace = self.__callbacks = None\n\n        if name:\n            if value is None:  # if None, first update the recursive knspace\n                knspace = self.__set_parent_knspace()\n                if knspace:\n                    setattr(knspace, name, self)\n                self._knspace = None  # cause a kv trigger\n            else:\n                setattr(value, name, self)\n                knspace = self._knspace = value\n\n            if not knspace:\n                raise ValueError('Object has name \"{}\", but no namespace'.\n                                 format(name))\n        else:\n            if value is None:\n                self.__set_parent_knspace()  # update before trigger below\n            self._knspace = value",
  "def _get_knsname(self):\n        return self._knsname",
  "def _set_knsname(self, value):\n        old_name = self._knsname\n        knspace = self.knspace\n        if old_name and knspace and getattr(knspace, old_name) == self:\n            setattr(knspace, old_name, None)\n\n        self._knsname = value\n        if value:\n            if knspace:\n                setattr(knspace, value, self)\n            else:\n                raise ValueError('Object has name \"{}\", but no namespace'.\n                                 format(value))",
  "class EmacsBehavior(object):\n    '''\n    A `mixin <https://en.wikipedia.org/wiki/Mixin>`_ that enables Emacs-style\n    keyboard shortcuts for the :class:`~kivy.uix.textinput.TextInput` widget.\n    Please see the :mod:`Emacs behaviors module <kivy.uix.behaviors.emacs>`\n    documentation for more information.\n\n    .. versionadded:: 1.9.1\n    '''\n\n    key_bindings = StringProperty('emacs')\n    '''String name which determines the type of key bindings to use with the\n    :class:`~kivy.uix.textinput.TextInput`. This allows Emacs key bindings to\n    be enabled/disabled programmatically for widgets that inherit from\n    :class:`EmacsBehavior`. If the value is not ``'emacs'``, Emacs bindings\n    will be disabled. Use ``'default'`` for switching to the default key\n    bindings of TextInput.\n\n    :attr:`key_bindings` is a :class:`~kivy.properties.StringProperty`\n    and defaults to ``'emacs'``.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    def __init__(self, **kwargs):\n        super(EmacsBehavior, self).__init__(**kwargs)\n\n        self.bindings = {\n            'ctrl': {\n                'a': lambda: self.do_cursor_movement('cursor_home'),\n                'e': lambda: self.do_cursor_movement('cursor_end'),\n                'f': lambda: self.do_cursor_movement('cursor_right'),\n                'b': lambda: self.do_cursor_movement('cursor_left'),\n                'w': lambda: self._cut(self.selection_text),\n                'y': self.paste,\n            },\n            'alt': {\n                'w': self.copy,\n                'f': lambda: self.do_cursor_movement('cursor_right',\n                                                     control=True),\n                'b': lambda: self.do_cursor_movement('cursor_left',\n                                                     control=True),\n                'd': self.delete_word_right,\n                '\\x08': self.delete_word_left,  # alt + backspace\n            },\n        }\n\n    def keyboard_on_key_down(self, window, keycode, text, modifiers):\n\n        key, key_str = keycode\n\n        # join the modifiers e.g. ['alt', 'ctrl']\n        mod = '+'.join(modifiers) if modifiers else None\n        is_emacs_shortcut = False\n\n        if key in range(256) and self.key_bindings == 'emacs':\n            if mod == 'ctrl' and chr(key) in self.bindings['ctrl'].keys():\n                is_emacs_shortcut = True\n            elif mod == 'alt' and chr(key) in self.bindings['alt'].keys():\n                is_emacs_shortcut = True\n            else:  # e.g. ctrl+alt or alt+ctrl (alt-gr key)\n                is_emacs_shortcut = False\n\n        if is_emacs_shortcut:\n            # Look up mod and key\n            emacs_shortcut = self.bindings[mod][chr(key)]\n            emacs_shortcut()\n        else:\n            super(EmacsBehavior, self).keyboard_on_key_down(window, keycode,\n                                                            text, modifiers)\n\n    def delete_word_right(self):\n        '''Delete text right of the cursor to the end of the word'''\n        if self._selection:\n            return\n        start_index = self.cursor_index()\n        start_cursor = self.cursor\n        self.do_cursor_movement('cursor_right', control=True)\n        end_index = self.cursor_index()\n        if start_index != end_index:\n            s = self.text[start_index:end_index]\n            self._set_unredo_delsel(start_index, end_index, s, from_undo=False)\n            self.text = self.text[:start_index] + self.text[end_index:]\n            self._set_cursor(pos=start_cursor)\n\n    def delete_word_left(self):\n        '''Delete text left of the cursor to the beginning of word'''\n        if self._selection:\n            return\n        start_index = self.cursor_index()\n        self.do_cursor_movement('cursor_left', control=True)\n        end_cursor = self.cursor\n        end_index = self.cursor_index()\n        if start_index != end_index:\n            s = self.text[end_index:start_index]\n            self._set_unredo_delsel(end_index, start_index, s, from_undo=False)\n            self.text = self.text[:end_index] + self.text[start_index:]\n            self._set_cursor(pos=end_cursor)",
  "def __init__(self, **kwargs):\n        super(EmacsBehavior, self).__init__(**kwargs)\n\n        self.bindings = {\n            'ctrl': {\n                'a': lambda: self.do_cursor_movement('cursor_home'),\n                'e': lambda: self.do_cursor_movement('cursor_end'),\n                'f': lambda: self.do_cursor_movement('cursor_right'),\n                'b': lambda: self.do_cursor_movement('cursor_left'),\n                'w': lambda: self._cut(self.selection_text),\n                'y': self.paste,\n            },\n            'alt': {\n                'w': self.copy,\n                'f': lambda: self.do_cursor_movement('cursor_right',\n                                                     control=True),\n                'b': lambda: self.do_cursor_movement('cursor_left',\n                                                     control=True),\n                'd': self.delete_word_right,\n                '\\x08': self.delete_word_left,  # alt + backspace\n            },\n        }",
  "def keyboard_on_key_down(self, window, keycode, text, modifiers):\n\n        key, key_str = keycode\n\n        # join the modifiers e.g. ['alt', 'ctrl']\n        mod = '+'.join(modifiers) if modifiers else None\n        is_emacs_shortcut = False\n\n        if key in range(256) and self.key_bindings == 'emacs':\n            if mod == 'ctrl' and chr(key) in self.bindings['ctrl'].keys():\n                is_emacs_shortcut = True\n            elif mod == 'alt' and chr(key) in self.bindings['alt'].keys():\n                is_emacs_shortcut = True\n            else:  # e.g. ctrl+alt or alt+ctrl (alt-gr key)\n                is_emacs_shortcut = False\n\n        if is_emacs_shortcut:\n            # Look up mod and key\n            emacs_shortcut = self.bindings[mod][chr(key)]\n            emacs_shortcut()\n        else:\n            super(EmacsBehavior, self).keyboard_on_key_down(window, keycode,\n                                                            text, modifiers)",
  "def delete_word_right(self):\n        '''Delete text right of the cursor to the end of the word'''\n        if self._selection:\n            return\n        start_index = self.cursor_index()\n        start_cursor = self.cursor\n        self.do_cursor_movement('cursor_right', control=True)\n        end_index = self.cursor_index()\n        if start_index != end_index:\n            s = self.text[start_index:end_index]\n            self._set_unredo_delsel(start_index, end_index, s, from_undo=False)\n            self.text = self.text[:start_index] + self.text[end_index:]\n            self._set_cursor(pos=start_cursor)",
  "def delete_word_left(self):\n        '''Delete text left of the cursor to the beginning of word'''\n        if self._selection:\n            return\n        start_index = self.cursor_index()\n        self.do_cursor_movement('cursor_left', control=True)\n        end_cursor = self.cursor\n        end_index = self.cursor_index()\n        if start_index != end_index:\n            s = self.text[end_index:start_index]\n            self._set_unredo_delsel(end_index, start_index, s, from_undo=False)\n            self.text = self.text[:end_index] + self.text[start_index:]\n            self._set_cursor(pos=end_cursor)",
  "class CompoundSelectionBehavior(object):\n    '''The Selection behavior `mixin <https://en.wikipedia.org/wiki/Mixin>`_\n    implements the logic behind keyboard and touch\n    selection of selectable widgets managed by the derived widget. Please see\n    the :mod:`compound selection behaviors module\n    <kivy.uix.behaviors.compoundselection>` documentation\n    for more information.\n\n    .. versionadded:: 1.9.0\n    '''\n\n    selected_nodes = ListProperty([])\n    '''The list of selected nodes.\n\n    .. note::\n\n        Multiple nodes can be selected right after one another e.g. using the\n        keyboard. When listening to :attr:`selected_nodes`, one should be\n        aware of this.\n\n    :attr:`selected_nodes` is a :class:`~kivy.properties.ListProperty` and\n    defaults to the empty list, []. It is read-only and should not be modified.\n    '''\n\n    touch_multiselect = BooleanProperty(False)\n    '''A special touch mode which determines whether touch events, as\n    processed by :meth:`select_with_touch`, will add the currently touched\n    node to the selection, or if it will clear the selection before adding the\n    node. This allows the selection of multiple nodes by simply touching them.\n\n    This is different from :attr:`multiselect` because when it is True,\n    simply touching an unselected node will select it, even if ctrl is not\n    pressed. If it is False, however, ctrl must be pressed in order to\n    add to the selection when :attr:`multiselect` is True.\n\n    .. note::\n\n        :attr:`multiselect`, when False, will disable\n        :attr:`touch_multiselect`.\n\n    :attr:`touch_multiselect` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to False.\n    '''\n\n    multiselect = BooleanProperty(False)\n    '''Determines whether multiple nodes can be selected. If enabled, keyboard\n    shift and ctrl selection, optionally combined with touch, for example, will\n    be able to select multiple widgets in the normally expected manner.\n    This dominates :attr:`touch_multiselect` when False.\n\n    :attr:`multiselect` is a :class:`~kivy.properties.BooleanProperty` and\n    defaults to False.\n    '''\n\n    touch_deselect_last = BooleanProperty(not _is_desktop)\n    '''Determines whether the last selected node can be deselected when\n    :attr:`multiselect` or :attr:`touch_multiselect` is False.\n\n    .. versionadded:: 1.10.0\n\n    :attr:`touch_deselect_last` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True on mobile, False on desktop platforms.\n    '''\n\n    keyboard_select = BooleanProperty(True)\n    '''Determines whether the keyboard can be used for selection. If False,\n    keyboard inputs will be ignored.\n\n    :attr:`keyboard_select` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True.\n    '''\n\n    page_count = NumericProperty(10)\n    '''Determines by how much the selected node is moved up or down, relative\n    to the position of the last selected node, when pageup (or pagedown) is\n    pressed.\n\n    :attr:`page_count` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 10.\n    '''\n\n    up_count = NumericProperty(1)\n    '''Determines by how much the selected node is moved up or down, relative\n    to the position of the last selected node, when the up (or down) arrow on\n    the keyboard is pressed.\n\n    :attr:`up_count` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 1.\n    '''\n\n    right_count = NumericProperty(1)\n    '''Determines by how much the selected node is moved up or down, relative\n    to the position of the last selected node, when the right (or left) arrow\n    on the keyboard is pressed.\n\n    :attr:`right_count` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 1.\n    '''\n\n    scroll_count = NumericProperty(0)\n    '''Determines by how much the selected node is moved up or down, relative\n    to the position of the last selected node, when the mouse scroll wheel is\n    scrolled.\n\n    :attr:`right_count` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to 0.\n    '''\n\n    nodes_order_reversed = BooleanProperty(True)\n    ''' (Internal) Indicates whether the order of the nodes as displayed top-\n    down is reversed compared to their order in :meth:`get_selectable_nodes`\n    (e.g. how the children property is reversed compared to how\n    it's displayed).\n    '''\n\n    text_entry_timeout = NumericProperty(1.)\n    '''When typing characters in rapid succession (i.e. the time difference\n    since the last character is less than :attr:`text_entry_timeout`), the\n    keys get concatenated and the combined text is passed as the key argument\n    of :meth:`goto_node`.\n\n    .. versionadded:: 1.10.0\n    '''\n\n    _anchor = None  # the last anchor node selected (e.g. shift relative node)\n    # the idx may be out of sync\n    _anchor_idx = 0  # cache indexes in case list hasn't changed\n    _last_selected_node = None  # the absolute last node selected\n    _last_node_idx = 0\n    _ctrl_down = False  # if it's pressed - for e.g. shift selection\n    _shift_down = False\n    # holds str used to find node, e.g. if word is typed. passed to goto_node\n    _word_filter = ''\n    _last_key_time = 0  # time since last press, for finding whole strs in node\n    _key_list = []  # keys that are already pressed, to not press continuously\n    _offset_counts = {}  # cache of counts for faster access\n\n    def __init__(self, **kwargs):\n        super(CompoundSelectionBehavior, self).__init__(**kwargs)\n        self._key_list = []\n\n        def ensure_single_select(*l):\n            if (not self.multiselect) and len(self.selected_nodes) > 1:\n                self.clear_selection()\n        update_counts = self._update_counts\n        update_counts()\n        fbind = self.fbind\n        fbind('multiselect', ensure_single_select)\n        fbind('page_count', update_counts)\n        fbind('up_count', update_counts)\n        fbind('right_count', update_counts)\n        fbind('scroll_count', update_counts)\n\n    def select_with_touch(self, node, touch=None):\n        '''(internal) Processes a touch on the node. This should be called by\n        the derived widget when a node is touched and is to be used for\n        selection. Depending on the keyboard keys pressed and the\n        configuration, it could select or deslect this and other nodes in the\n        selectable nodes list, :meth:`get_selectable_nodes`.\n\n        :Parameters:\n            `node`\n                The node that received the touch. Can be None for a scroll\n                type touch.\n            `touch`\n                Optionally, the touch. Defaults to None.\n\n        :Returns:\n            bool, True if the touch was used, False otherwise.\n        '''\n        multi = self.multiselect\n        multiselect = multi and (self._ctrl_down or self.touch_multiselect)\n        range_select = multi and self._shift_down\n\n        if touch and 'button' in touch.profile and touch.button in\\\n            ('scrollup', 'scrolldown', 'scrollleft', 'scrollright'):\n            node_src, idx_src = self._resolve_last_node()\n            node, idx = self.goto_node(touch.button, node_src, idx_src)\n            if node == node_src:\n                return False\n            if range_select:\n                self._select_range(multiselect, True, node, idx)\n            else:\n                if not multiselect:\n                    self.clear_selection()\n                self.select_node(node)\n            return True\n        if node is None:\n            return False\n\n        if (node in self.selected_nodes and (not range_select)):  # selected\n            if multiselect:\n                self.deselect_node(node)\n            else:\n                selected_node_count = len(self.selected_nodes)\n                self.clear_selection()\n                if not self.touch_deselect_last or selected_node_count > 1:\n                    self.select_node(node)\n        elif range_select:\n            # keep anchor only if not multiselect (ctrl-type selection)\n            self._select_range(multiselect, not multiselect, node, 0)\n        else:   # it's not selected at this point\n            if not multiselect:\n                self.clear_selection()\n            self.select_node(node)\n        return True\n\n    def select_with_key_down(self, keyboard, scancode, codepoint, modifiers,\n                             **kwargs):\n        '''Processes a key press. This is called when a key press is to be used\n        for selection. Depending on the keyboard keys pressed and the\n        configuration, it could select or deselect nodes or node ranges\n        from the selectable nodes list, :meth:`get_selectable_nodes`.\n\n        The parameters are such that it could be bound directly to the\n        on_key_down event of a keyboard. Therefore, it is safe to be called\n        repeatedly when the key is held down as is done by the keyboard.\n\n        :Returns:\n            bool, True if the keypress was used, False otherwise.\n        '''\n        if not self.keyboard_select:\n            return False\n        keys = self._key_list\n        multi = self.multiselect\n        node_src, idx_src = self._resolve_last_node()\n        text = scancode[1]\n\n        if text == 'shift':\n            self._shift_down = True\n        elif text in ('ctrl', 'lctrl', 'rctrl'):\n            self._ctrl_down = True\n        elif (multi and 'ctrl' in modifiers and text in ('a', 'A') and\n              text not in keys):\n            sister_nodes = self.get_selectable_nodes()\n            select = self.select_node\n            for node in sister_nodes:\n                select(node)\n            keys.append(text)\n        else:\n            s = text\n            if len(text) > 1:\n                d = {'divide': '/', 'mul': '*', 'substract': '-', 'add': '+',\n                     'decimal': '.'}\n                if text.startswith('numpad'):\n                    s = text[6:]\n                    if len(s) > 1:\n                        if s in d:\n                            s = d[s]\n                        else:\n                            s = None\n                else:\n                    s = None\n\n            if s is not None:\n                if s not in keys:  # don't keep adding while holding down\n                    if time() - self._last_key_time <= self.text_entry_timeout:\n                        self._word_filter += s\n                    else:\n                        self._word_filter = s\n                    keys.append(s)\n\n                self._last_key_time = time()\n                node, idx = self.goto_node(self._word_filter, node_src,\n                                           idx_src)\n            else:\n                self._word_filter = ''\n                node, idx = self.goto_node(text, node_src, idx_src)\n\n            if node == node_src:\n                return False\n\n            multiselect = multi and 'ctrl' in modifiers\n            if multi and 'shift' in modifiers:\n                self._select_range(multiselect, True, node, idx)\n            else:\n                if not multiselect:\n                    self.clear_selection()\n                self.select_node(node)\n            return True\n        self._word_filter = ''\n        return False\n\n    def select_with_key_up(self, keyboard, scancode, **kwargs):\n        '''(internal) Processes a key release. This must be called by the\n        derived widget when a key that :meth:`select_with_key_down` returned\n        True is released.\n\n        The parameters are such that it could be bound directly to the\n        on_key_up event of a keyboard.\n\n        :Returns:\n            bool, True if the key release was used, False otherwise.\n        '''\n        if scancode[1] == 'shift':\n            self._shift_down = False\n        elif scancode[1] in ('ctrl', 'lctrl', 'rctrl'):\n            self._ctrl_down = False\n        else:\n            try:\n                self._key_list.remove(scancode[1])\n                return True\n            except ValueError:\n                return False\n        return True\n\n    def _update_counts(self, *largs):\n        # doesn't invert indices here\n        pc = self.page_count\n        uc = self.up_count\n        rc = self.right_count\n        sc = self.scroll_count\n        self._offset_counts = {'pageup': -pc, 'pagedown': pc, 'up': -uc,\n        'down': uc, 'right': rc, 'left': -rc, 'scrollup': sc,\n        'scrolldown': -sc, 'scrollright': -sc, 'scrollleft': sc}\n\n    def _resolve_last_node(self):\n        # for offset selection, we have a anchor, and we select everything\n        # between anchor and added offset relative to last node\n        sister_nodes = self.get_selectable_nodes()\n        if not len(sister_nodes):\n            return None, 0\n        last_node = self._last_selected_node\n        last_idx = self._last_node_idx\n        end = len(sister_nodes) - 1\n\n        if last_node is None:\n            last_node = self._anchor\n            last_idx = self._anchor_idx\n        if last_node is None:\n            return sister_nodes[end], end\n        if last_idx > end or sister_nodes[last_idx] != last_node:\n            try:\n                return last_node, self.get_index_of_node(last_node,\n                                                         sister_nodes)\n            except ValueError:\n                return sister_nodes[end], end\n        return last_node, last_idx\n\n    def _select_range(self, multiselect, keep_anchor, node, idx):\n        '''Selects a range between self._anchor and node or idx.\n        If multiselect is True, it will be added to the selection, otherwise\n        it will unselect everything before selecting the range. This is only\n        called if self.multiselect is True.\n        If keep anchor is False, the anchor is moved to node. This should\n        always be True for keyboard selection.\n        '''\n        select = self.select_node\n        sister_nodes = self.get_selectable_nodes()\n        end = len(sister_nodes) - 1\n        last_node = self._anchor\n        last_idx = self._anchor_idx\n\n        if last_node is None:\n            last_idx = end\n            last_node = sister_nodes[end]\n        else:\n            if last_idx > end or sister_nodes[last_idx] != last_node:\n                try:\n                    last_idx = self.get_index_of_node(last_node, sister_nodes)\n                except ValueError:\n                    # list changed - cannot do select across them\n                    return\n        if idx > end or sister_nodes[idx] != node:\n            try:    # just in case\n                idx = self.get_index_of_node(node, sister_nodes)\n            except ValueError:\n                return\n\n        if last_idx > idx:\n            last_idx, idx = idx, last_idx\n        if not multiselect:\n            self.clear_selection()\n        for item in sister_nodes[last_idx:idx + 1]:\n            select(item)\n\n        if keep_anchor:\n            self._anchor = last_node\n            self._anchor_idx = last_idx\n        else:\n            self._anchor = node  # in case idx was reversed, reset\n            self._anchor_idx = idx\n        self._last_selected_node = node\n        self._last_node_idx = idx\n\n    def clear_selection(self):\n        ''' Deselects all the currently selected nodes.\n        '''\n        # keep the anchor and last selected node\n        deselect = self.deselect_node\n        nodes = self.selected_nodes\n        # empty beforehand so lookup in deselect will be fast\n        for node in nodes[:]:\n            deselect(node)\n\n    def get_selectable_nodes(self):\n        '''(internal) Returns a list of the nodes that can be selected. It can\n        be overwritten by the derived widget to return the correct list.\n\n        This list is used to determine which nodes to select with group\n        selection. E.g. the last element in the list will be selected when\n        home is pressed, pagedown will move (or add to, if shift is held) the\n        selection from the current position by negative :attr:`page_count`\n        nodes starting from the position of the currently selected node in\n        this list and so on. Still, nodes can be selected even if they are not\n        in this list.\n\n        .. note::\n\n            It is safe to dynamically change this list including removing,\n            adding, or re-arranging its elements. Nodes can be selected even\n            if they are not on this list. And selected nodes removed from the\n            list will remain selected until :meth:`deselect_node` is called.\n\n        .. warning::\n\n            Layouts display their children in the reverse order. That is, the\n            contents of :attr:`~kivy.uix.widget.Widget.children` is displayed\n            form right to left, bottom to top. Therefore, internally, the\n            indices of the elements returned by this function are reversed to\n            make it work by default for most layouts so that the final result\n            is consistent e.g. home, although it will select the last element\n            in this list visually, will select the first element when\n            counting from top to bottom and left to right. If this behavior is\n            not desired, a reversed list should be returned instead.\n\n        Defaults to returning :attr:`~kivy.uix.widget.Widget.children`.\n        '''\n        return self.children\n\n    def get_index_of_node(self, node, selectable_nodes):\n        '''(internal) Returns the index of the `node` within the\n        `selectable_nodes` returned by :meth:`get_selectable_nodes`.\n        '''\n        return selectable_nodes.index(node)\n\n    def goto_node(self, key, last_node, last_node_idx):\n        '''(internal) Used by the controller to get the node at the position\n        indicated by key. The key can be keyboard inputs, e.g. pageup,\n        or scroll inputs from the mouse scroll wheel, e.g. scrollup.\n        'last_node' is the last node selected and is used to find the resulting\n        node. For example, if the key is up, the returned node is one node\n        up from the last node.\n\n        It can be overwritten by the derived widget.\n\n        :Parameters:\n            `key`\n                str, the string used to find the desired node. It can be any\n                of the keyboard keys, as well as the mouse scrollup,\n                scrolldown, scrollright, and scrollleft strings. If letters\n                are typed in quick succession, the letters will be combined\n                before it's passed in as key and can be used to find nodes that\n                have an associated string that starts with those letters.\n            `last_node`\n                The last node that was selected.\n            `last_node_idx`\n                The cached index of the last node selected in the\n                :meth:`get_selectable_nodes` list. If the list hasn't changed\n                it saves having to look up the index of `last_node` in that\n                list.\n\n        :Returns:\n            tuple, the node targeted by key and its index in the\n            :meth:`get_selectable_nodes` list. Returning\n            `(last_node, last_node_idx)` indicates a node wasn't found.\n        '''\n        sister_nodes = self.get_selectable_nodes()\n        end = len(sister_nodes) - 1\n        counts = self._offset_counts\n        if end == -1:\n            return last_node, last_node_idx\n        if last_node_idx > end or sister_nodes[last_node_idx] != last_node:\n            try:    # just in case\n                last_node_idx = self.get_index_of_node(last_node, sister_nodes)\n            except ValueError:\n                return last_node, last_node_idx\n\n        is_reversed = self.nodes_order_reversed\n        if key in counts:\n            count = -counts[key] if is_reversed else counts[key]\n            idx = max(min(count + last_node_idx, end), 0)\n            return sister_nodes[idx], idx\n        elif key == 'home':\n            if is_reversed:\n                return sister_nodes[end], end\n            return sister_nodes[0], 0\n        elif key == 'end':\n            if is_reversed:\n                return sister_nodes[0], 0\n            return sister_nodes[end], end\n        else:\n            return last_node, last_node_idx\n\n    def select_node(self, node):\n        ''' Selects a node.\n\n        It is called by the controller when it selects a node and can be\n        called from the outside to select a node directly. The derived widget\n        should overwrite this method and change the node state to selected\n        when called.\n\n        :Parameters:\n            `node`\n                The node to be selected.\n\n        :Returns:\n            bool, True if the node was selected, False otherwise.\n\n        .. warning::\n\n            This method must be called by the derived widget using super if it\n            is overwritten.\n        '''\n        nodes = self.selected_nodes\n        if node in nodes:\n            return False\n\n        if (not self.multiselect) and len(nodes):\n            self.clear_selection()\n        if node not in nodes:\n            nodes.append(node)\n        self._anchor = node\n        self._last_selected_node = node\n        return True\n\n    def deselect_node(self, node):\n        ''' Deselects a possibly selected node.\n\n        It is called by the controller when it deselects a node and can also\n        be called from the outside to deselect a node directly. The derived\n        widget should overwrite this method and change the node to its\n        unselected state when this is called\n\n        :Parameters:\n            `node`\n                The node to be deselected.\n\n        .. warning::\n\n            This method must be called by the derived widget using super if it\n            is overwritten.\n        '''\n        try:\n            self.selected_nodes.remove(node)\n            return True\n        except ValueError:\n            return False",
  "def __init__(self, **kwargs):\n        super(CompoundSelectionBehavior, self).__init__(**kwargs)\n        self._key_list = []\n\n        def ensure_single_select(*l):\n            if (not self.multiselect) and len(self.selected_nodes) > 1:\n                self.clear_selection()\n        update_counts = self._update_counts\n        update_counts()\n        fbind = self.fbind\n        fbind('multiselect', ensure_single_select)\n        fbind('page_count', update_counts)\n        fbind('up_count', update_counts)\n        fbind('right_count', update_counts)\n        fbind('scroll_count', update_counts)",
  "def select_with_touch(self, node, touch=None):\n        '''(internal) Processes a touch on the node. This should be called by\n        the derived widget when a node is touched and is to be used for\n        selection. Depending on the keyboard keys pressed and the\n        configuration, it could select or deslect this and other nodes in the\n        selectable nodes list, :meth:`get_selectable_nodes`.\n\n        :Parameters:\n            `node`\n                The node that received the touch. Can be None for a scroll\n                type touch.\n            `touch`\n                Optionally, the touch. Defaults to None.\n\n        :Returns:\n            bool, True if the touch was used, False otherwise.\n        '''\n        multi = self.multiselect\n        multiselect = multi and (self._ctrl_down or self.touch_multiselect)\n        range_select = multi and self._shift_down\n\n        if touch and 'button' in touch.profile and touch.button in\\\n            ('scrollup', 'scrolldown', 'scrollleft', 'scrollright'):\n            node_src, idx_src = self._resolve_last_node()\n            node, idx = self.goto_node(touch.button, node_src, idx_src)\n            if node == node_src:\n                return False\n            if range_select:\n                self._select_range(multiselect, True, node, idx)\n            else:\n                if not multiselect:\n                    self.clear_selection()\n                self.select_node(node)\n            return True\n        if node is None:\n            return False\n\n        if (node in self.selected_nodes and (not range_select)):  # selected\n            if multiselect:\n                self.deselect_node(node)\n            else:\n                selected_node_count = len(self.selected_nodes)\n                self.clear_selection()\n                if not self.touch_deselect_last or selected_node_count > 1:\n                    self.select_node(node)\n        elif range_select:\n            # keep anchor only if not multiselect (ctrl-type selection)\n            self._select_range(multiselect, not multiselect, node, 0)\n        else:   # it's not selected at this point\n            if not multiselect:\n                self.clear_selection()\n            self.select_node(node)\n        return True",
  "def select_with_key_down(self, keyboard, scancode, codepoint, modifiers,\n                             **kwargs):\n        '''Processes a key press. This is called when a key press is to be used\n        for selection. Depending on the keyboard keys pressed and the\n        configuration, it could select or deselect nodes or node ranges\n        from the selectable nodes list, :meth:`get_selectable_nodes`.\n\n        The parameters are such that it could be bound directly to the\n        on_key_down event of a keyboard. Therefore, it is safe to be called\n        repeatedly when the key is held down as is done by the keyboard.\n\n        :Returns:\n            bool, True if the keypress was used, False otherwise.\n        '''\n        if not self.keyboard_select:\n            return False\n        keys = self._key_list\n        multi = self.multiselect\n        node_src, idx_src = self._resolve_last_node()\n        text = scancode[1]\n\n        if text == 'shift':\n            self._shift_down = True\n        elif text in ('ctrl', 'lctrl', 'rctrl'):\n            self._ctrl_down = True\n        elif (multi and 'ctrl' in modifiers and text in ('a', 'A') and\n              text not in keys):\n            sister_nodes = self.get_selectable_nodes()\n            select = self.select_node\n            for node in sister_nodes:\n                select(node)\n            keys.append(text)\n        else:\n            s = text\n            if len(text) > 1:\n                d = {'divide': '/', 'mul': '*', 'substract': '-', 'add': '+',\n                     'decimal': '.'}\n                if text.startswith('numpad'):\n                    s = text[6:]\n                    if len(s) > 1:\n                        if s in d:\n                            s = d[s]\n                        else:\n                            s = None\n                else:\n                    s = None\n\n            if s is not None:\n                if s not in keys:  # don't keep adding while holding down\n                    if time() - self._last_key_time <= self.text_entry_timeout:\n                        self._word_filter += s\n                    else:\n                        self._word_filter = s\n                    keys.append(s)\n\n                self._last_key_time = time()\n                node, idx = self.goto_node(self._word_filter, node_src,\n                                           idx_src)\n            else:\n                self._word_filter = ''\n                node, idx = self.goto_node(text, node_src, idx_src)\n\n            if node == node_src:\n                return False\n\n            multiselect = multi and 'ctrl' in modifiers\n            if multi and 'shift' in modifiers:\n                self._select_range(multiselect, True, node, idx)\n            else:\n                if not multiselect:\n                    self.clear_selection()\n                self.select_node(node)\n            return True\n        self._word_filter = ''\n        return False",
  "def select_with_key_up(self, keyboard, scancode, **kwargs):\n        '''(internal) Processes a key release. This must be called by the\n        derived widget when a key that :meth:`select_with_key_down` returned\n        True is released.\n\n        The parameters are such that it could be bound directly to the\n        on_key_up event of a keyboard.\n\n        :Returns:\n            bool, True if the key release was used, False otherwise.\n        '''\n        if scancode[1] == 'shift':\n            self._shift_down = False\n        elif scancode[1] in ('ctrl', 'lctrl', 'rctrl'):\n            self._ctrl_down = False\n        else:\n            try:\n                self._key_list.remove(scancode[1])\n                return True\n            except ValueError:\n                return False\n        return True",
  "def _update_counts(self, *largs):\n        # doesn't invert indices here\n        pc = self.page_count\n        uc = self.up_count\n        rc = self.right_count\n        sc = self.scroll_count\n        self._offset_counts = {'pageup': -pc, 'pagedown': pc, 'up': -uc,\n        'down': uc, 'right': rc, 'left': -rc, 'scrollup': sc,\n        'scrolldown': -sc, 'scrollright': -sc, 'scrollleft': sc}",
  "def _resolve_last_node(self):\n        # for offset selection, we have a anchor, and we select everything\n        # between anchor and added offset relative to last node\n        sister_nodes = self.get_selectable_nodes()\n        if not len(sister_nodes):\n            return None, 0\n        last_node = self._last_selected_node\n        last_idx = self._last_node_idx\n        end = len(sister_nodes) - 1\n\n        if last_node is None:\n            last_node = self._anchor\n            last_idx = self._anchor_idx\n        if last_node is None:\n            return sister_nodes[end], end\n        if last_idx > end or sister_nodes[last_idx] != last_node:\n            try:\n                return last_node, self.get_index_of_node(last_node,\n                                                         sister_nodes)\n            except ValueError:\n                return sister_nodes[end], end\n        return last_node, last_idx",
  "def _select_range(self, multiselect, keep_anchor, node, idx):\n        '''Selects a range between self._anchor and node or idx.\n        If multiselect is True, it will be added to the selection, otherwise\n        it will unselect everything before selecting the range. This is only\n        called if self.multiselect is True.\n        If keep anchor is False, the anchor is moved to node. This should\n        always be True for keyboard selection.\n        '''\n        select = self.select_node\n        sister_nodes = self.get_selectable_nodes()\n        end = len(sister_nodes) - 1\n        last_node = self._anchor\n        last_idx = self._anchor_idx\n\n        if last_node is None:\n            last_idx = end\n            last_node = sister_nodes[end]\n        else:\n            if last_idx > end or sister_nodes[last_idx] != last_node:\n                try:\n                    last_idx = self.get_index_of_node(last_node, sister_nodes)\n                except ValueError:\n                    # list changed - cannot do select across them\n                    return\n        if idx > end or sister_nodes[idx] != node:\n            try:    # just in case\n                idx = self.get_index_of_node(node, sister_nodes)\n            except ValueError:\n                return\n\n        if last_idx > idx:\n            last_idx, idx = idx, last_idx\n        if not multiselect:\n            self.clear_selection()\n        for item in sister_nodes[last_idx:idx + 1]:\n            select(item)\n\n        if keep_anchor:\n            self._anchor = last_node\n            self._anchor_idx = last_idx\n        else:\n            self._anchor = node  # in case idx was reversed, reset\n            self._anchor_idx = idx\n        self._last_selected_node = node\n        self._last_node_idx = idx",
  "def clear_selection(self):\n        ''' Deselects all the currently selected nodes.\n        '''\n        # keep the anchor and last selected node\n        deselect = self.deselect_node\n        nodes = self.selected_nodes\n        # empty beforehand so lookup in deselect will be fast\n        for node in nodes[:]:\n            deselect(node)",
  "def get_selectable_nodes(self):\n        '''(internal) Returns a list of the nodes that can be selected. It can\n        be overwritten by the derived widget to return the correct list.\n\n        This list is used to determine which nodes to select with group\n        selection. E.g. the last element in the list will be selected when\n        home is pressed, pagedown will move (or add to, if shift is held) the\n        selection from the current position by negative :attr:`page_count`\n        nodes starting from the position of the currently selected node in\n        this list and so on. Still, nodes can be selected even if they are not\n        in this list.\n\n        .. note::\n\n            It is safe to dynamically change this list including removing,\n            adding, or re-arranging its elements. Nodes can be selected even\n            if they are not on this list. And selected nodes removed from the\n            list will remain selected until :meth:`deselect_node` is called.\n\n        .. warning::\n\n            Layouts display their children in the reverse order. That is, the\n            contents of :attr:`~kivy.uix.widget.Widget.children` is displayed\n            form right to left, bottom to top. Therefore, internally, the\n            indices of the elements returned by this function are reversed to\n            make it work by default for most layouts so that the final result\n            is consistent e.g. home, although it will select the last element\n            in this list visually, will select the first element when\n            counting from top to bottom and left to right. If this behavior is\n            not desired, a reversed list should be returned instead.\n\n        Defaults to returning :attr:`~kivy.uix.widget.Widget.children`.\n        '''\n        return self.children",
  "def get_index_of_node(self, node, selectable_nodes):\n        '''(internal) Returns the index of the `node` within the\n        `selectable_nodes` returned by :meth:`get_selectable_nodes`.\n        '''\n        return selectable_nodes.index(node)",
  "def goto_node(self, key, last_node, last_node_idx):\n        '''(internal) Used by the controller to get the node at the position\n        indicated by key. The key can be keyboard inputs, e.g. pageup,\n        or scroll inputs from the mouse scroll wheel, e.g. scrollup.\n        'last_node' is the last node selected and is used to find the resulting\n        node. For example, if the key is up, the returned node is one node\n        up from the last node.\n\n        It can be overwritten by the derived widget.\n\n        :Parameters:\n            `key`\n                str, the string used to find the desired node. It can be any\n                of the keyboard keys, as well as the mouse scrollup,\n                scrolldown, scrollright, and scrollleft strings. If letters\n                are typed in quick succession, the letters will be combined\n                before it's passed in as key and can be used to find nodes that\n                have an associated string that starts with those letters.\n            `last_node`\n                The last node that was selected.\n            `last_node_idx`\n                The cached index of the last node selected in the\n                :meth:`get_selectable_nodes` list. If the list hasn't changed\n                it saves having to look up the index of `last_node` in that\n                list.\n\n        :Returns:\n            tuple, the node targeted by key and its index in the\n            :meth:`get_selectable_nodes` list. Returning\n            `(last_node, last_node_idx)` indicates a node wasn't found.\n        '''\n        sister_nodes = self.get_selectable_nodes()\n        end = len(sister_nodes) - 1\n        counts = self._offset_counts\n        if end == -1:\n            return last_node, last_node_idx\n        if last_node_idx > end or sister_nodes[last_node_idx] != last_node:\n            try:    # just in case\n                last_node_idx = self.get_index_of_node(last_node, sister_nodes)\n            except ValueError:\n                return last_node, last_node_idx\n\n        is_reversed = self.nodes_order_reversed\n        if key in counts:\n            count = -counts[key] if is_reversed else counts[key]\n            idx = max(min(count + last_node_idx, end), 0)\n            return sister_nodes[idx], idx\n        elif key == 'home':\n            if is_reversed:\n                return sister_nodes[end], end\n            return sister_nodes[0], 0\n        elif key == 'end':\n            if is_reversed:\n                return sister_nodes[0], 0\n            return sister_nodes[end], end\n        else:\n            return last_node, last_node_idx",
  "def select_node(self, node):\n        ''' Selects a node.\n\n        It is called by the controller when it selects a node and can be\n        called from the outside to select a node directly. The derived widget\n        should overwrite this method and change the node state to selected\n        when called.\n\n        :Parameters:\n            `node`\n                The node to be selected.\n\n        :Returns:\n            bool, True if the node was selected, False otherwise.\n\n        .. warning::\n\n            This method must be called by the derived widget using super if it\n            is overwritten.\n        '''\n        nodes = self.selected_nodes\n        if node in nodes:\n            return False\n\n        if (not self.multiselect) and len(nodes):\n            self.clear_selection()\n        if node not in nodes:\n            nodes.append(node)\n        self._anchor = node\n        self._last_selected_node = node\n        return True",
  "def deselect_node(self, node):\n        ''' Deselects a possibly selected node.\n\n        It is called by the controller when it deselects a node and can also\n        be called from the outside to deselect a node directly. The derived\n        widget should overwrite this method and change the node to its\n        unselected state when this is called\n\n        :Parameters:\n            `node`\n                The node to be deselected.\n\n        .. warning::\n\n            This method must be called by the derived widget using super if it\n            is overwritten.\n        '''\n        try:\n            self.selected_nodes.remove(node)\n            return True\n        except ValueError:\n            return False",
  "def ensure_single_select(*l):\n            if (not self.multiselect) and len(self.selected_nodes) > 1:\n                self.clear_selection()",
  "def _clean_cache():\n    '''Trims _cached_views cache to half the size of `_max_cache_size`.\n    '''\n    # all keys will be reduced to max_size.\n    max_size = (_max_cache_size // 2) // len(_cached_views)\n    global _cache_count\n    for cls, instances in _cached_views.items():\n        _cache_count -= max(0, len(instances) - max_size)\n        del instances[max_size:]",
  "class RecycleDataViewBehavior(object):\n    '''A optional base class for data views (:attr:`RecycleView`.viewclass).\n    If a view inherits from this class, the class's functions will be called\n    when the view needs to be updated due to a data change or layout update.\n    '''\n\n    def refresh_view_attrs(self, rv, index, data):\n        '''Called by the :class:`RecycleAdapter` when the view is initially\n        populated with the values from the `data` dictionary for this item.\n\n        Any pos or size info should be removed because they are set\n        subsequently with :attr:`refresh_view_layout`.\n\n        :Parameters:\n\n            `rv`: :class:`RecycleView` instance\n                The :class:`RecycleView` that caused the update.\n            `data`: dict\n                The data dict used to populate this view.\n        '''\n        sizing_attrs = RecycleDataAdapter._sizing_attrs\n        for key, value in data.items():\n            if key not in sizing_attrs:\n                setattr(self, key, value)\n\n    def refresh_view_layout(self, rv, index, layout, viewport):\n        '''Called when the view's size is updated by the layout manager,\n        :class:`RecycleLayoutManagerBehavior`.\n\n        :Parameters:\n\n            `rv`: :class:`RecycleView` instance\n                The :class:`RecycleView` that caused the update.\n            `viewport`: 4-tuple\n                The coordinates of the bottom left and width height in layout\n                manager coordinates. This may be larger than this view item.\n\n        :raises:\n            `LayoutChangeException`: If the sizing or data changed during a\n            call to this method, raising a `LayoutChangeException` exception\n            will force a refresh. Useful when data changed and we don't want\n            to layout further since it'll be overwritten again soon.\n        '''\n        w, h = layout.pop('size')\n        if w is None:\n            if h is not None:\n                self.height = h\n        else:\n            if h is None:\n                self.width = w\n            else:\n                self.size = w, h\n\n        for name, value in layout.items():\n            setattr(self, name, value)\n\n    def apply_selection(self, rv, index, is_selected):\n        pass",
  "class RecycleKVIDsDataViewBehavior(RecycleDataViewBehavior):\n    \"\"\"Similar to :class:`RecycleDataViewBehavior`, except that the data keys\n    can signify properties of an object named with an id in the root KV rule.\n\n    E.g. given a KV rule::\n\n        <MyRule@RecycleKVIDsDataViewBehavior+BoxLayout>:\n            Label:\n                id: name\n            Label:\n                id: value\n\n    Then setting the data list with\n    ``rv.data = [{'name.text': 'Kivy user', 'value.text': '12'}]`` would\n    automatically set the corresponding labels.\n\n    So, if the key doesn't have a period, the named property of the root widget\n    will be set to the corresponding value. If there is a period, the named\n    property of the widget with the id listed before the period will be set to\n    the corresponding value.\n\n    .. versionadded:: 2.0.0\n    \"\"\"\n\n    def refresh_view_attrs(self, rv, index, data):\n        sizing_attrs = RecycleDataAdapter._sizing_attrs\n        for key, value in data.items():\n            if key not in sizing_attrs:\n                name, *ids = key.split('.')\n                if ids:\n                    if len(ids) != 1:\n                        raise ValueError(\n                            f'Data key \"{key}\" has more than one period')\n                    setattr(self.ids[name], ids[0], value)\n                else:\n                    setattr(self, name, value)",
  "class RecycleDataAdapter(EventDispatcher):\n    '''The class that converts data to a view.\n\n    --- Internal details ---\n    A view can have 3 states.\n\n        * It can be completely in sync with the data, which\n          occurs when the view is displayed. These are stored in :attr:`views`.\n        * It can be dirty, which occurs when the view is in sync with the data,\n          except for the size/pos parameters which is controlled by the layout.\n          This occurs when the view is not currently displayed but the data has\n          not changed. These views are stored in :attr:`dirty_views`.\n        * Finally the view can be dead which occurs when the data changes and\n          the view was not updated or when a view is just created. Such views\n          are typically added to the internal cache.\n\n    Typically what happens is that the layout manager lays out the data\n    and then asks for views, using :meth:`set_visible_views`, for some specific\n    data items that it displays.\n\n    These views are gotten from the current views, dirty or global cache. Then\n    depending on the view state :meth:`refresh_view_attrs` is called to bring\n    the view up to date with the data (except for sizing parameters). Finally,\n    the layout manager gets these views, updates their size and displays them.\n    '''\n\n    recycleview = ObjectProperty(None, allownone=True)\n    '''The :class:`~kivy.uix.recycleview.RecycleViewBehavior` associated\n    with this instance.\n    '''\n\n    # internals\n    views = {}  # current displayed items\n    # items whose attrs, except for pos/size is still accurate\n    dirty_views = defaultdict(dict)\n\n    _sizing_attrs = {\n        'size', 'width', 'height', 'size_hint', 'size_hint_x', 'size_hint_y',\n        'pos', 'x', 'y', 'center', 'center_x', 'center_y', 'pos_hint',\n        'size_hint_min', 'size_hint_min_x', 'size_hint_min_y', 'size_hint_max',\n        'size_hint_max_x', 'size_hint_max_y'}\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Fix for issue https://github.com/kivy/kivy/issues/5913:\n        Scrolling RV A, then Scrolling RV B, content of A and B seemed\n        to be getting mixed up\n        \"\"\"\n        self.views = {}\n        self.dirty_views = defaultdict(dict)\n        super(RecycleDataAdapter, self).__init__(**kwargs)\n\n    def attach_recycleview(self, rv):\n        '''Associates a :class:`~kivy.uix.recycleview.RecycleViewBehavior`\n        with this instance. It is stored in :attr:`recycleview`.\n        '''\n        self.recycleview = rv\n\n    def detach_recycleview(self):\n        '''Removes the :class:`~kivy.uix.recycleview.RecycleViewBehavior`\n        associated with this instance and clears :attr:`recycleview`.\n        '''\n        self.recycleview = None\n\n    def create_view(self, index, data_item, viewclass):\n        '''(internal) Creates and initializes the view for the data at `index`.\n\n        The returned view is synced with the data, except for the pos/size\n        information.\n        '''\n        if viewclass is None:\n            return\n\n        view = viewclass()\n        self.refresh_view_attrs(index, data_item, view)\n        return view\n\n    def get_view(self, index, data_item, viewclass):\n        '''(internal) Returns a view instance for the data at `index`\n\n        It looks through the various caches and finally creates a view if it\n        doesn't exist. The returned view is synced with the data, except for\n        the pos/size information.\n\n        If found in the cache it's removed from the source\n        before returning. It doesn't check the current views.\n        '''\n        # is it in the dirtied views?\n        dirty_views = self.dirty_views\n        if viewclass is None:\n            return\n        stale = False\n        view = None\n\n        if viewclass in dirty_views:  # get it first from dirty list\n            dirty_class = dirty_views[viewclass]\n            if index in dirty_class:\n                # we found ourself in the dirty list, no need to update data!\n                view = dirty_class.pop(index)\n            elif _cached_views[viewclass]:\n                # global cache has this class, update data\n                view, stale = _cached_views[viewclass].pop(), True\n            elif dirty_class:\n                # random any dirty view element - update data\n                view, stale = dirty_class.popitem()[1], True\n        elif _cached_views[viewclass]:  # otherwise go directly to cache\n            # global cache has this class, update data\n            view, stale = _cached_views[viewclass].pop(), True\n\n        if view is None:\n            view = self.create_view(index, data_item, viewclass)\n            if view is None:\n                return\n\n        if stale:\n            self.refresh_view_attrs(index, data_item, view)\n        return view\n\n    def refresh_view_attrs(self, index, data_item, view):\n        '''(internal) Syncs the view and brings it up to date with the data.\n\n        This method calls :meth:`RecycleDataViewBehavior.refresh_view_attrs`\n        if the view inherits from :class:`RecycleDataViewBehavior`. See that\n        method for more details.\n\n        .. note::\n            Any sizing and position info is skipped when syncing with the data.\n        '''\n        viewclass = view.__class__\n        if viewclass not in _view_base_cache:\n            _view_base_cache[viewclass] = isinstance(view,\n                                                     RecycleDataViewBehavior)\n\n        if _view_base_cache[viewclass]:\n            view.refresh_view_attrs(self.recycleview, index, data_item)\n        else:\n            sizing_attrs = RecycleDataAdapter._sizing_attrs\n            for key, value in data_item.items():\n                if key not in sizing_attrs:\n                    setattr(view, key, value)\n\n    def refresh_view_layout(self, index, layout, view, viewport):\n        '''Updates the sizing information of the view.\n\n        viewport is in coordinates of the layout manager.\n\n        This method calls :meth:`RecycleDataViewBehavior.refresh_view_attrs`\n        if the view inherits from :class:`RecycleDataViewBehavior`. See that\n        method for more details.\n\n        .. note::\n            Any sizing and position info is skipped when syncing with the data.\n        '''\n        if view.__class__ not in _view_base_cache:\n            _view_base_cache[view.__class__] = isinstance(\n                view, RecycleDataViewBehavior)\n\n        if _view_base_cache[view.__class__]:\n            view.refresh_view_layout(\n                self.recycleview, index, layout, viewport)\n        else:\n            w, h = layout.pop('size')\n            if w is None:\n                if h is not None:\n                    view.height = h\n            else:\n                if h is None:\n                    view.width = w\n                else:\n                    view.size = w, h\n\n            for name, value in layout.items():\n                setattr(view, name, value)\n\n    def make_view_dirty(self, view, index):\n        '''(internal) Used to flag this view as dirty, ready to be used for\n        others. See :meth:`make_views_dirty`.\n        '''\n        del self.views[index]\n        self.dirty_views[view.__class__][index] = view\n\n    def make_views_dirty(self):\n        '''Makes all the current views dirty.\n\n        Dirty views are still in sync with the corresponding data. However, the\n        size information may go out of sync. Therefore a dirty view can be\n        reused by the same index by just updating the sizing information.\n\n        Once the underlying data of this index changes, the view should be\n        removed from the dirty views and moved to the global cache with\n        :meth:`invalidate`.\n\n        This is typically called when the layout manager needs to re-layout all\n        the data.\n        '''\n        views = self.views\n        if not views:\n            return\n\n        dirty_views = self.dirty_views\n        for index, view in views.items():\n            dirty_views[view.__class__][index] = view\n        self.views = {}\n\n    def invalidate(self):\n        '''Moves all the current views into the global cache.\n\n        As opposed to making a view dirty where the view is in sync with the\n        data except for sizing information, this will completely disconnect the\n        view from the data, as it is assumed the data has gone out of sync with\n        the view.\n\n        This is typically called when the data changes.\n        '''\n        global _cache_count\n        for view in self.views.values():\n            _cached_views[view.__class__].append(view)\n            _cache_count += 1\n\n        for cls, views in self.dirty_views.items():\n            _cached_views[cls].extend(views.values())\n            _cache_count += len(views)\n\n        if _cache_count >= _max_cache_size:\n            _clean_cache()\n        self.views = {}\n        self.dirty_views.clear()\n\n    def set_visible_views(self, indices, data, viewclasses):\n        '''Gets a 3-tuple of the new, remaining, and old views for the current\n        viewport.\n\n        The new views are synced to the data except for the size/pos\n        properties.\n        The old views need to be removed from the layout, and the new views\n        added.\n\n        The new views are not necessarily *new*, but are all the currently\n        visible views.\n        '''\n        visible_views = {}\n        previous_views = self.views\n        ret_new = []\n        ret_remain = []\n        get_view = self.get_view\n\n        # iterate though the visible view\n        # add them into the container if not already done\n        for index in indices:\n            view = previous_views.pop(index, None)\n            if view is not None:  # was current view\n                visible_views[index] = view\n                ret_remain.append((index, view))\n            else:\n                view = get_view(index, data[index],\n                                viewclasses[index]['viewclass'])\n                if view is None:\n                    continue\n                visible_views[index] = view\n                ret_new.append((index, view))\n\n        old_views = previous_views.items()\n        self.make_views_dirty()\n        self.views = visible_views\n        return ret_new, ret_remain, old_views\n\n    def get_visible_view(self, index):\n        '''Returns the currently visible view associated with ``index``.\n\n        If no view is currently displayed for ``index`` it returns ``None``.\n        '''\n        return self.views.get(index)",
  "def refresh_view_attrs(self, rv, index, data):\n        '''Called by the :class:`RecycleAdapter` when the view is initially\n        populated with the values from the `data` dictionary for this item.\n\n        Any pos or size info should be removed because they are set\n        subsequently with :attr:`refresh_view_layout`.\n\n        :Parameters:\n\n            `rv`: :class:`RecycleView` instance\n                The :class:`RecycleView` that caused the update.\n            `data`: dict\n                The data dict used to populate this view.\n        '''\n        sizing_attrs = RecycleDataAdapter._sizing_attrs\n        for key, value in data.items():\n            if key not in sizing_attrs:\n                setattr(self, key, value)",
  "def refresh_view_layout(self, rv, index, layout, viewport):\n        '''Called when the view's size is updated by the layout manager,\n        :class:`RecycleLayoutManagerBehavior`.\n\n        :Parameters:\n\n            `rv`: :class:`RecycleView` instance\n                The :class:`RecycleView` that caused the update.\n            `viewport`: 4-tuple\n                The coordinates of the bottom left and width height in layout\n                manager coordinates. This may be larger than this view item.\n\n        :raises:\n            `LayoutChangeException`: If the sizing or data changed during a\n            call to this method, raising a `LayoutChangeException` exception\n            will force a refresh. Useful when data changed and we don't want\n            to layout further since it'll be overwritten again soon.\n        '''\n        w, h = layout.pop('size')\n        if w is None:\n            if h is not None:\n                self.height = h\n        else:\n            if h is None:\n                self.width = w\n            else:\n                self.size = w, h\n\n        for name, value in layout.items():\n            setattr(self, name, value)",
  "def apply_selection(self, rv, index, is_selected):\n        pass",
  "def refresh_view_attrs(self, rv, index, data):\n        sizing_attrs = RecycleDataAdapter._sizing_attrs\n        for key, value in data.items():\n            if key not in sizing_attrs:\n                name, *ids = key.split('.')\n                if ids:\n                    if len(ids) != 1:\n                        raise ValueError(\n                            f'Data key \"{key}\" has more than one period')\n                    setattr(self.ids[name], ids[0], value)\n                else:\n                    setattr(self, name, value)",
  "def __init__(self, **kwargs):\n        \"\"\"\n        Fix for issue https://github.com/kivy/kivy/issues/5913:\n        Scrolling RV A, then Scrolling RV B, content of A and B seemed\n        to be getting mixed up\n        \"\"\"\n        self.views = {}\n        self.dirty_views = defaultdict(dict)\n        super(RecycleDataAdapter, self).__init__(**kwargs)",
  "def attach_recycleview(self, rv):\n        '''Associates a :class:`~kivy.uix.recycleview.RecycleViewBehavior`\n        with this instance. It is stored in :attr:`recycleview`.\n        '''\n        self.recycleview = rv",
  "def detach_recycleview(self):\n        '''Removes the :class:`~kivy.uix.recycleview.RecycleViewBehavior`\n        associated with this instance and clears :attr:`recycleview`.\n        '''\n        self.recycleview = None",
  "def create_view(self, index, data_item, viewclass):\n        '''(internal) Creates and initializes the view for the data at `index`.\n\n        The returned view is synced with the data, except for the pos/size\n        information.\n        '''\n        if viewclass is None:\n            return\n\n        view = viewclass()\n        self.refresh_view_attrs(index, data_item, view)\n        return view",
  "def get_view(self, index, data_item, viewclass):\n        '''(internal) Returns a view instance for the data at `index`\n\n        It looks through the various caches and finally creates a view if it\n        doesn't exist. The returned view is synced with the data, except for\n        the pos/size information.\n\n        If found in the cache it's removed from the source\n        before returning. It doesn't check the current views.\n        '''\n        # is it in the dirtied views?\n        dirty_views = self.dirty_views\n        if viewclass is None:\n            return\n        stale = False\n        view = None\n\n        if viewclass in dirty_views:  # get it first from dirty list\n            dirty_class = dirty_views[viewclass]\n            if index in dirty_class:\n                # we found ourself in the dirty list, no need to update data!\n                view = dirty_class.pop(index)\n            elif _cached_views[viewclass]:\n                # global cache has this class, update data\n                view, stale = _cached_views[viewclass].pop(), True\n            elif dirty_class:\n                # random any dirty view element - update data\n                view, stale = dirty_class.popitem()[1], True\n        elif _cached_views[viewclass]:  # otherwise go directly to cache\n            # global cache has this class, update data\n            view, stale = _cached_views[viewclass].pop(), True\n\n        if view is None:\n            view = self.create_view(index, data_item, viewclass)\n            if view is None:\n                return\n\n        if stale:\n            self.refresh_view_attrs(index, data_item, view)\n        return view",
  "def refresh_view_attrs(self, index, data_item, view):\n        '''(internal) Syncs the view and brings it up to date with the data.\n\n        This method calls :meth:`RecycleDataViewBehavior.refresh_view_attrs`\n        if the view inherits from :class:`RecycleDataViewBehavior`. See that\n        method for more details.\n\n        .. note::\n            Any sizing and position info is skipped when syncing with the data.\n        '''\n        viewclass = view.__class__\n        if viewclass not in _view_base_cache:\n            _view_base_cache[viewclass] = isinstance(view,\n                                                     RecycleDataViewBehavior)\n\n        if _view_base_cache[viewclass]:\n            view.refresh_view_attrs(self.recycleview, index, data_item)\n        else:\n            sizing_attrs = RecycleDataAdapter._sizing_attrs\n            for key, value in data_item.items():\n                if key not in sizing_attrs:\n                    setattr(view, key, value)",
  "def refresh_view_layout(self, index, layout, view, viewport):\n        '''Updates the sizing information of the view.\n\n        viewport is in coordinates of the layout manager.\n\n        This method calls :meth:`RecycleDataViewBehavior.refresh_view_attrs`\n        if the view inherits from :class:`RecycleDataViewBehavior`. See that\n        method for more details.\n\n        .. note::\n            Any sizing and position info is skipped when syncing with the data.\n        '''\n        if view.__class__ not in _view_base_cache:\n            _view_base_cache[view.__class__] = isinstance(\n                view, RecycleDataViewBehavior)\n\n        if _view_base_cache[view.__class__]:\n            view.refresh_view_layout(\n                self.recycleview, index, layout, viewport)\n        else:\n            w, h = layout.pop('size')\n            if w is None:\n                if h is not None:\n                    view.height = h\n            else:\n                if h is None:\n                    view.width = w\n                else:\n                    view.size = w, h\n\n            for name, value in layout.items():\n                setattr(view, name, value)",
  "def make_view_dirty(self, view, index):\n        '''(internal) Used to flag this view as dirty, ready to be used for\n        others. See :meth:`make_views_dirty`.\n        '''\n        del self.views[index]\n        self.dirty_views[view.__class__][index] = view",
  "def make_views_dirty(self):\n        '''Makes all the current views dirty.\n\n        Dirty views are still in sync with the corresponding data. However, the\n        size information may go out of sync. Therefore a dirty view can be\n        reused by the same index by just updating the sizing information.\n\n        Once the underlying data of this index changes, the view should be\n        removed from the dirty views and moved to the global cache with\n        :meth:`invalidate`.\n\n        This is typically called when the layout manager needs to re-layout all\n        the data.\n        '''\n        views = self.views\n        if not views:\n            return\n\n        dirty_views = self.dirty_views\n        for index, view in views.items():\n            dirty_views[view.__class__][index] = view\n        self.views = {}",
  "def invalidate(self):\n        '''Moves all the current views into the global cache.\n\n        As opposed to making a view dirty where the view is in sync with the\n        data except for sizing information, this will completely disconnect the\n        view from the data, as it is assumed the data has gone out of sync with\n        the view.\n\n        This is typically called when the data changes.\n        '''\n        global _cache_count\n        for view in self.views.values():\n            _cached_views[view.__class__].append(view)\n            _cache_count += 1\n\n        for cls, views in self.dirty_views.items():\n            _cached_views[cls].extend(views.values())\n            _cache_count += len(views)\n\n        if _cache_count >= _max_cache_size:\n            _clean_cache()\n        self.views = {}\n        self.dirty_views.clear()",
  "def set_visible_views(self, indices, data, viewclasses):\n        '''Gets a 3-tuple of the new, remaining, and old views for the current\n        viewport.\n\n        The new views are synced to the data except for the size/pos\n        properties.\n        The old views need to be removed from the layout, and the new views\n        added.\n\n        The new views are not necessarily *new*, but are all the currently\n        visible views.\n        '''\n        visible_views = {}\n        previous_views = self.views\n        ret_new = []\n        ret_remain = []\n        get_view = self.get_view\n\n        # iterate though the visible view\n        # add them into the container if not already done\n        for index in indices:\n            view = previous_views.pop(index, None)\n            if view is not None:  # was current view\n                visible_views[index] = view\n                ret_remain.append((index, view))\n            else:\n                view = get_view(index, data[index],\n                                viewclasses[index]['viewclass'])\n                if view is None:\n                    continue\n                visible_views[index] = view\n                ret_new.append((index, view))\n\n        old_views = previous_views.items()\n        self.make_views_dirty()\n        self.views = visible_views\n        return ret_new, ret_remain, old_views",
  "def get_visible_view(self, index):\n        '''Returns the currently visible view associated with ``index``.\n\n        If no view is currently displayed for ``index`` it returns ``None``.\n        '''\n        return self.views.get(index)",
  "class LayoutChangeException(Exception):\n    pass",
  "class LayoutSelectionBehavior(CompoundSelectionBehavior):\n    '''The :class:`LayoutSelectionBehavior` can be combined with\n    :class:`RecycleLayoutManagerBehavior` to allow its derived classes\n    selection behaviors similarly to how\n    :class:`~kivy.uix.behaviors.compoundselection.CompoundSelectionBehavior`\n    can be used to add selection behaviors to normal layout.\n\n    :class:`RecycleLayoutManagerBehavior` manages its children\n    differently than normal layouts or widgets so this class adapts\n    :class:`~kivy.uix.behaviors.compoundselection.CompoundSelectionBehavior`\n    based selection to work with :class:`RecycleLayoutManagerBehavior` as well.\n\n    Similarly to\n    :class:`~kivy.uix.behaviors.compoundselection.CompoundSelectionBehavior`,\n    one can select using the keyboard or touch, which calls :meth:`select_node`\n    or :meth:`deselect_node`, or one can call these methods directly. When a\n    item is selected or deselected :meth:`apply_selection` is called. See\n    :meth:`apply_selection`.\n\n\n    '''\n\n    key_selection = StringProperty(None, allownone=True)\n    '''The key used to check whether a view of a data item can be selected\n    with touch or the keyboard.\n\n    :attr:`key_selection` is the key in data, which if present and ``True``\n    will enable selection for this item from the keyboard or with a touch.\n    When None, the default, not item will be selectable.\n\n    :attr:`key_selection` is a :class:`StringProperty` and defaults to None.\n\n    .. note::\n        All data items can be selected directly using :meth:`select_node` or\n        :meth:`deselect_node`, even if :attr:`key_selection` is False.\n    '''\n\n    _selectable_nodes = []\n    _nodes_map = {}\n\n    def __init__(self, **kwargs):\n        self.nodes_order_reversed = False\n        super(LayoutSelectionBehavior, self).__init__(**kwargs)\n\n    def compute_sizes_from_data(self, data, flags):\n        # overwrite this method so that when data changes we update\n        # selectable nodes.\n        key = self.key_selection\n        if key is None:\n            nodes = self._selectable_nodes = []\n        else:\n            nodes = self._selectable_nodes = [\n                i for i, d in enumerate(data) if d.get(key)]\n\n        self._nodes_map = {v: k for k, v in enumerate(nodes)}\n        return super(LayoutSelectionBehavior, self).compute_sizes_from_data(\n            data, flags)\n\n    def get_selectable_nodes(self):\n        # the indices of the data is used as the nodes\n        return self._selectable_nodes\n\n    def get_index_of_node(self, node, selectable_nodes):\n        # the indices of the data is used as the nodes, so node\n        return self._nodes_map[node]\n\n    def goto_node(self, key, last_node, last_node_idx):\n        node, idx = super(LayoutSelectionBehavior, self).goto_node(\n            key, last_node, last_node_idx)\n        if node is not last_node:\n            self.goto_view(node)\n        return node, idx\n\n    def select_node(self, node):\n        if super(LayoutSelectionBehavior, self).select_node(node):\n            view = self.recycleview.view_adapter.get_visible_view(node)\n            if view is not None:\n                self.apply_selection(node, view, True)\n\n    def deselect_node(self, node):\n        if super(LayoutSelectionBehavior, self).deselect_node(node):\n            view = self.recycleview.view_adapter.get_visible_view(node)\n            if view is not None:\n                self.apply_selection(node, view, False)\n\n    def apply_selection(self, index, view, is_selected):\n        '''Applies the selection to the view. This is called internally when\n        a view is displayed and it needs to be shown as selected or as not\n        selected.\n\n        It is called when :meth:`select_node` or :meth:`deselect_node` is\n        called or when a view needs to be refreshed. Its function is purely to\n        update the view to reflect the selection state. So the function may be\n        called multiple times even if the selection state may not have changed.\n\n        If the view is a instance of\n        :class:`~kivy.uix.recycleview.views.RecycleDataViewBehavior`, its\n        :meth:`~kivy.uix.recycleview.views.RecycleDataViewBehavior.\\\napply_selection` method will be called every time the view needs to refresh\n        the selection state. Otherwise, the this method is responsible\n        for applying the selection.\n\n        :Parameters:\n\n            `index`: int\n                The index of the data item that is associated with the view.\n            `view`: widget\n                The widget that is the view of this data item.\n            `is_selected`: bool\n                Whether the item is selected.\n        '''\n        viewclass = view.__class__\n        if viewclass not in _view_base_cache:\n            _view_base_cache[viewclass] = isinstance(view,\n                                                     RecycleDataViewBehavior)\n\n        if _view_base_cache[viewclass]:\n            view.apply_selection(self.recycleview, index, is_selected)\n\n    def refresh_view_layout(self, index, layout, view, viewport):\n        super(LayoutSelectionBehavior, self).refresh_view_layout(\n            index, layout, view, viewport)\n        self.apply_selection(index, view, index in self.selected_nodes)",
  "class RecycleLayoutManagerBehavior(object):\n    \"\"\"A RecycleLayoutManagerBehavior is responsible for positioning views into\n    the :attr:`RecycleView.data` within a :class:`RecycleView`. It adds new\n    views into the data when it becomes visible to the user, and removes them\n    when they leave the visible area.\n    \"\"\"\n\n    viewclass = ObjectProperty(None)\n    '''See :attr:`RecyclerView.viewclass`.\n    '''\n    key_viewclass = StringProperty(None)\n    '''See :attr:`RecyclerView.key_viewclass`.\n    '''\n\n    recycleview = ObjectProperty(None, allownone=True)\n\n    asked_sizes = None\n\n    def attach_recycleview(self, rv):\n        self.recycleview = rv\n        if rv:\n            fbind = self.fbind\n            # can be made more selective update than refresh_from_data which\n            # causes a full update. But this likely affects most of the data.\n            fbind('viewclass', rv.refresh_from_data)\n            fbind('key_viewclass', rv.refresh_from_data)\n            fbind('viewclass', rv._dispatch_prop_on_source, 'viewclass')\n            fbind('key_viewclass', rv._dispatch_prop_on_source,\n                  'key_viewclass')\n\n    def detach_recycleview(self):\n        self.clear_layout()\n        rv = self.recycleview\n        if rv:\n            funbind = self.funbind\n            funbind('viewclass', rv.refresh_from_data)\n            funbind('key_viewclass', rv.refresh_from_data)\n            funbind('viewclass', rv._dispatch_prop_on_source, 'viewclass')\n            funbind('key_viewclass', rv._dispatch_prop_on_source,\n                  'key_viewclass')\n        self.recycleview = None\n\n    def compute_sizes_from_data(self, data, flags):\n        pass\n\n    def compute_layout(self, data, flags):\n        pass\n\n    def compute_visible_views(self, data, viewport):\n        '''`viewport` is in coordinates of the layout manager.\n        '''\n        pass\n\n    def set_visible_views(self, indices, data, viewport):\n        '''`viewport` is in coordinates of the layout manager.\n        '''\n        pass\n\n    def refresh_view_layout(self, index, layout, view, viewport):\n        '''`See :meth:`~kivy.uix.recycleview.views.RecycleDataAdapter.\\\nrefresh_view_layout`.\n        '''\n        self.recycleview.view_adapter.refresh_view_layout(\n            index, layout, view, viewport)\n\n    def get_view_index_at(self, pos):\n        \"\"\"Return the view `index` on which position, `pos`, falls.\n\n        `pos` is in coordinates of the layout manager.\n        \"\"\"\n        pass\n\n    def remove_views(self):\n        rv = self.recycleview\n        if rv:\n            adapter = rv.view_adapter\n            if adapter:\n                adapter.make_views_dirty()\n\n    def remove_view(self, view, index):\n        rv = self.recycleview\n        if rv:\n            adapter = rv.view_adapter\n            if adapter:\n                adapter.make_view_dirty(view, index)\n\n    def clear_layout(self):\n        rv = self.recycleview\n        if rv:\n            adapter = rv.view_adapter\n            if adapter:\n                adapter.invalidate()\n\n    def goto_view(self, index):\n        '''Moves the views so that the view corresponding to `index` is\n        visible.\n        '''\n        pass\n\n    def on_viewclass(self, instance, value):\n        # resolve the real class if it was a string.\n        if isinstance(value, string_types):\n            self.viewclass = getattr(Factory, value)",
  "def __init__(self, **kwargs):\n        self.nodes_order_reversed = False\n        super(LayoutSelectionBehavior, self).__init__(**kwargs)",
  "def compute_sizes_from_data(self, data, flags):\n        # overwrite this method so that when data changes we update\n        # selectable nodes.\n        key = self.key_selection\n        if key is None:\n            nodes = self._selectable_nodes = []\n        else:\n            nodes = self._selectable_nodes = [\n                i for i, d in enumerate(data) if d.get(key)]\n\n        self._nodes_map = {v: k for k, v in enumerate(nodes)}\n        return super(LayoutSelectionBehavior, self).compute_sizes_from_data(\n            data, flags)",
  "def get_selectable_nodes(self):\n        # the indices of the data is used as the nodes\n        return self._selectable_nodes",
  "def get_index_of_node(self, node, selectable_nodes):\n        # the indices of the data is used as the nodes, so node\n        return self._nodes_map[node]",
  "def goto_node(self, key, last_node, last_node_idx):\n        node, idx = super(LayoutSelectionBehavior, self).goto_node(\n            key, last_node, last_node_idx)\n        if node is not last_node:\n            self.goto_view(node)\n        return node, idx",
  "def select_node(self, node):\n        if super(LayoutSelectionBehavior, self).select_node(node):\n            view = self.recycleview.view_adapter.get_visible_view(node)\n            if view is not None:\n                self.apply_selection(node, view, True)",
  "def deselect_node(self, node):\n        if super(LayoutSelectionBehavior, self).deselect_node(node):\n            view = self.recycleview.view_adapter.get_visible_view(node)\n            if view is not None:\n                self.apply_selection(node, view, False)",
  "def apply_selection(self, index, view, is_selected):\n        '''Applies the selection to the view. This is called internally when\n        a view is displayed and it needs to be shown as selected or as not\n        selected.\n\n        It is called when :meth:`select_node` or :meth:`deselect_node` is\n        called or when a view needs to be refreshed. Its function is purely to\n        update the view to reflect the selection state. So the function may be\n        called multiple times even if the selection state may not have changed.\n\n        If the view is a instance of\n        :class:`~kivy.uix.recycleview.views.RecycleDataViewBehavior`, its\n        :meth:`~kivy.uix.recycleview.views.RecycleDataViewBehavior.\\\napply_selection` method will be called every time the view needs to refresh\n        the selection state. Otherwise, the this method is responsible\n        for applying the selection.\n\n        :Parameters:\n\n            `index`: int\n                The index of the data item that is associated with the view.\n            `view`: widget\n                The widget that is the view of this data item.\n            `is_selected`: bool\n                Whether the item is selected.\n        '''\n        viewclass = view.__class__\n        if viewclass not in _view_base_cache:\n            _view_base_cache[viewclass] = isinstance(view,\n                                                     RecycleDataViewBehavior)\n\n        if _view_base_cache[viewclass]:\n            view.apply_selection(self.recycleview, index, is_selected)",
  "def refresh_view_layout(self, index, layout, view, viewport):\n        super(LayoutSelectionBehavior, self).refresh_view_layout(\n            index, layout, view, viewport)\n        self.apply_selection(index, view, index in self.selected_nodes)",
  "def attach_recycleview(self, rv):\n        self.recycleview = rv\n        if rv:\n            fbind = self.fbind\n            # can be made more selective update than refresh_from_data which\n            # causes a full update. But this likely affects most of the data.\n            fbind('viewclass', rv.refresh_from_data)\n            fbind('key_viewclass', rv.refresh_from_data)\n            fbind('viewclass', rv._dispatch_prop_on_source, 'viewclass')\n            fbind('key_viewclass', rv._dispatch_prop_on_source,\n                  'key_viewclass')",
  "def detach_recycleview(self):\n        self.clear_layout()\n        rv = self.recycleview\n        if rv:\n            funbind = self.funbind\n            funbind('viewclass', rv.refresh_from_data)\n            funbind('key_viewclass', rv.refresh_from_data)\n            funbind('viewclass', rv._dispatch_prop_on_source, 'viewclass')\n            funbind('key_viewclass', rv._dispatch_prop_on_source,\n                  'key_viewclass')\n        self.recycleview = None",
  "def compute_sizes_from_data(self, data, flags):\n        pass",
  "def compute_layout(self, data, flags):\n        pass",
  "def compute_visible_views(self, data, viewport):\n        '''`viewport` is in coordinates of the layout manager.\n        '''\n        pass",
  "def set_visible_views(self, indices, data, viewport):\n        '''`viewport` is in coordinates of the layout manager.\n        '''\n        pass",
  "def refresh_view_layout(self, index, layout, view, viewport):\n        '''`See :meth:`~kivy.uix.recycleview.views.RecycleDataAdapter.\\\nrefresh_view_layout`.\n        '''\n        self.recycleview.view_adapter.refresh_view_layout(\n            index, layout, view, viewport)",
  "def get_view_index_at(self, pos):\n        \"\"\"Return the view `index` on which position, `pos`, falls.\n\n        `pos` is in coordinates of the layout manager.\n        \"\"\"\n        pass",
  "def remove_views(self):\n        rv = self.recycleview\n        if rv:\n            adapter = rv.view_adapter\n            if adapter:\n                adapter.make_views_dirty()",
  "def remove_view(self, view, index):\n        rv = self.recycleview\n        if rv:\n            adapter = rv.view_adapter\n            if adapter:\n                adapter.make_view_dirty(view, index)",
  "def clear_layout(self):\n        rv = self.recycleview\n        if rv:\n            adapter = rv.view_adapter\n            if adapter:\n                adapter.invalidate()",
  "def goto_view(self, index):\n        '''Moves the views so that the view corresponding to `index` is\n        visible.\n        '''\n        pass",
  "def on_viewclass(self, instance, value):\n        # resolve the real class if it was a string.\n        if isinstance(value, string_types):\n            self.viewclass = getattr(Factory, value)",
  "def recondition_slice_assign(val, last_len, new_len):\n    if not isinstance(val, slice):\n        return slice(val, val + 1)\n\n    diff = new_len - last_len\n\n    start, stop, step = val.start, val.stop, val.step\n    if stop <= start:\n        return slice(0, 0)\n\n    if step is not None and step != 1:\n        assert last_len == new_len\n        if stop < 0:\n            stop = max(0, last_len + stop)\n        stop = min(last_len, stop)\n\n        if start < 0:\n            start = max(0, last_len + start)\n        start = min(last_len, start)\n\n        return slice(start, stop, step)\n\n    if start < 0:\n        start = last_len + start\n    if stop < 0:\n        stop = last_len + stop\n\n    # whatever, too complicated don't try to compute it\n    if (start < 0 or stop < 0 or start > last_len or stop > last_len or\n            new_len != last_len):\n        return None\n\n    return slice(start, stop)",
  "class RecycleDataModelBehavior(object):\n    \"\"\":class:`RecycleDataModelBehavior` is the base class for the models\n    that describes and provides the data for the\n    :class:`~kivy.uix.recycleview.RecycleViewBehavior`.\n\n    :Events:\n        `on_data_changed`:\n            Fired when the data changes. The event may dispatch\n            keyword arguments specific to each implementation of the data\n            model.\n            When dispatched, the event and keyword arguments are forwarded to\n            :meth:`~kivy.uix.recycleview.RecycleViewBehavior.\\\nrefresh_from_data`.\n    \"\"\"\n\n    __events__ = (\"on_data_changed\", )\n\n    recycleview = ObjectProperty(None, allownone=True)\n    '''The\n    :class:`~kivy.uix.recycleview.RecycleViewBehavior` instance\n    associated with this data model.\n    '''\n\n    def attach_recycleview(self, rv):\n        '''Associates a\n        :class:`~kivy.uix.recycleview.RecycleViewBehavior` with\n        this data model.\n        '''\n        self.recycleview = rv\n        if rv:\n            self.fbind('on_data_changed', rv.refresh_from_data)\n\n    def detach_recycleview(self):\n        '''Removes the\n        :class:`~kivy.uix.recycleview.RecycleViewBehavior`\n        associated with this data model.\n        '''\n        rv = self.recycleview\n        if rv:\n            self.funbind('on_data_changed', rv.refresh_from_data)\n        self.recycleview = None\n\n    def on_data_changed(self, *largs, **kwargs):\n        pass",
  "class RecycleDataModel(RecycleDataModelBehavior, EventDispatcher):\n    '''An implementation of :class:`RecycleDataModelBehavior` that keeps the\n    data in a indexable list. See :attr:`data`.\n\n    When data changes this class currently dispatches `on_data_changed`  with\n    one of the following additional keyword arguments.\n\n    `none`: no keyword argument\n        With no additional argument it means a generic data change.\n    `removed`: a slice or integer\n        The value is a slice or integer indicating the indices removed.\n    `appended`: a slice\n        The slice in :attr:`data` indicating the first and last new items\n        (i.e. the slice pointing to the new items added at the end).\n    `inserted`: a integer\n        The index in :attr:`data` where a new data item was inserted.\n    `modified`: a slice\n        The slice with the indices where the data has been modified.\n        This currently does not allow changing of size etc.\n    '''\n\n    data = ListProperty([])\n    '''Stores the model's data using a list.\n\n    The data for a item at index `i` can also be accessed with\n    :class:`RecycleDataModel` `[i]`.\n    '''\n\n    _last_len = 0\n\n    def __init__(self, **kwargs):\n        self.fbind('data', self._on_data_callback)\n        super(RecycleDataModel, self).__init__(**kwargs)\n\n    def __getitem__(self, index):\n        return self.data[index]\n\n    @property\n    def observable_dict(self):\n        '''A dictionary instance, which when modified will trigger a `data` and\n        consequently an `on_data_changed` dispatch.\n        '''\n        return partial(ObservableDict, self.__class__.data, self)\n\n    def attach_recycleview(self, rv):\n        super(RecycleDataModel, self).attach_recycleview(rv)\n        if rv:\n            self.fbind('data', rv._dispatch_prop_on_source, 'data')\n\n    def detach_recycleview(self):\n        rv = self.recycleview\n        if rv:\n            self.funbind('data', rv._dispatch_prop_on_source, 'data')\n        super(RecycleDataModel, self).detach_recycleview()\n\n    def _on_data_callback(self, instance, value):\n        last_len = self._last_len\n        new_len = self._last_len = len(self.data)\n        op, val = value.last_op\n\n        if op == '__setitem__':\n            val = recondition_slice_assign(val, last_len, new_len)\n            if val is not None:\n                self.dispatch('on_data_changed', modified=val)\n            else:\n                self.dispatch('on_data_changed')\n        elif op == '__delitem__':\n            self.dispatch('on_data_changed', removed=val)\n        elif op == '__setslice__':\n            val = recondition_slice_assign(slice(*val), last_len, new_len)\n            if val is not None:\n                self.dispatch('on_data_changed', modified=val)\n            else:\n                self.dispatch('on_data_changed')\n        elif op == '__delslice__':\n            self.dispatch('on_data_changed', removed=slice(*val))\n        elif op == '__iadd__' or op == '__imul__':\n            self.dispatch('on_data_changed', appended=slice(last_len, new_len))\n        elif op == 'append':\n            self.dispatch('on_data_changed', appended=slice(last_len, new_len))\n        elif op == 'insert':\n            self.dispatch('on_data_changed', inserted=val)\n        elif op == 'pop':\n            if val:\n                self.dispatch('on_data_changed', removed=val[0])\n            else:\n                self.dispatch('on_data_changed', removed=last_len - 1)\n        elif op == 'extend':\n            self.dispatch('on_data_changed', appended=slice(last_len, new_len))\n        else:\n            self.dispatch('on_data_changed')",
  "def attach_recycleview(self, rv):\n        '''Associates a\n        :class:`~kivy.uix.recycleview.RecycleViewBehavior` with\n        this data model.\n        '''\n        self.recycleview = rv\n        if rv:\n            self.fbind('on_data_changed', rv.refresh_from_data)",
  "def detach_recycleview(self):\n        '''Removes the\n        :class:`~kivy.uix.recycleview.RecycleViewBehavior`\n        associated with this data model.\n        '''\n        rv = self.recycleview\n        if rv:\n            self.funbind('on_data_changed', rv.refresh_from_data)\n        self.recycleview = None",
  "def on_data_changed(self, *largs, **kwargs):\n        pass",
  "def __init__(self, **kwargs):\n        self.fbind('data', self._on_data_callback)\n        super(RecycleDataModel, self).__init__(**kwargs)",
  "def __getitem__(self, index):\n        return self.data[index]",
  "def observable_dict(self):\n        '''A dictionary instance, which when modified will trigger a `data` and\n        consequently an `on_data_changed` dispatch.\n        '''\n        return partial(ObservableDict, self.__class__.data, self)",
  "def attach_recycleview(self, rv):\n        super(RecycleDataModel, self).attach_recycleview(rv)\n        if rv:\n            self.fbind('data', rv._dispatch_prop_on_source, 'data')",
  "def detach_recycleview(self):\n        rv = self.recycleview\n        if rv:\n            self.funbind('data', rv._dispatch_prop_on_source, 'data')\n        super(RecycleDataModel, self).detach_recycleview()",
  "def _on_data_callback(self, instance, value):\n        last_len = self._last_len\n        new_len = self._last_len = len(self.data)\n        op, val = value.last_op\n\n        if op == '__setitem__':\n            val = recondition_slice_assign(val, last_len, new_len)\n            if val is not None:\n                self.dispatch('on_data_changed', modified=val)\n            else:\n                self.dispatch('on_data_changed')\n        elif op == '__delitem__':\n            self.dispatch('on_data_changed', removed=val)\n        elif op == '__setslice__':\n            val = recondition_slice_assign(slice(*val), last_len, new_len)\n            if val is not None:\n                self.dispatch('on_data_changed', modified=val)\n            else:\n                self.dispatch('on_data_changed')\n        elif op == '__delslice__':\n            self.dispatch('on_data_changed', removed=slice(*val))\n        elif op == '__iadd__' or op == '__imul__':\n            self.dispatch('on_data_changed', appended=slice(last_len, new_len))\n        elif op == 'append':\n            self.dispatch('on_data_changed', appended=slice(last_len, new_len))\n        elif op == 'insert':\n            self.dispatch('on_data_changed', inserted=val)\n        elif op == 'pop':\n            if val:\n                self.dispatch('on_data_changed', removed=val[0])\n            else:\n                self.dispatch('on_data_changed', removed=last_len - 1)\n        elif op == 'extend':\n            self.dispatch('on_data_changed', appended=slice(last_len, new_len))\n        else:\n            self.dispatch('on_data_changed')",
  "class RecycleViewBehavior(object):\n    \"\"\"RecycleViewBehavior provides a behavioral model upon which the\n    :class:`RecycleView` is built. Together, they offer an extensible and\n    flexible way to produce views with limited windows over large data sets.\n\n    See the module documentation for more information.\n    \"\"\"\n\n    # internals\n    _view_adapter = None\n    _data_model = None\n    _layout_manager = None\n\n    _refresh_flags = {'data': [], 'layout': [], 'viewport': False}\n    _refresh_trigger = None\n\n    def __init__(self, **kwargs):\n        self._refresh_trigger = Clock.create_trigger(self.refresh_views, -1)\n        self._refresh_flags = deepcopy(self._refresh_flags)\n        super(RecycleViewBehavior, self).__init__(**kwargs)\n\n    def get_viewport(self):\n        pass\n\n    def save_viewport(self):\n        pass\n\n    def restore_viewport(self):\n        pass\n\n    def refresh_views(self, *largs):\n        lm = self.layout_manager\n        flags = self._refresh_flags\n        if lm is None or self.view_adapter is None or self.data_model is None:\n            return\n\n        data = self.data\n        f = flags['data']\n        if f:\n            self.save_viewport()\n            # lm.clear_layout()\n            flags['data'] = []\n            flags['layout'] = [{}]\n            lm.compute_sizes_from_data(data, f)\n\n        while flags['layout']:\n            # if `data` we were re-triggered so finish in the next call.\n            # Otherwise go until fully laid out.\n            self.save_viewport()\n            if flags['data']:\n                return\n            flags['viewport'] = True\n            f = flags['layout']\n            flags['layout'] = []\n\n            try:\n                lm.compute_layout(data, f)\n            except LayoutChangeException:\n                flags['layout'].append({})\n                continue\n\n        if flags['data']:  # in case that happened meanwhile\n            return\n\n        # make sure if we were re-triggered in the loop that we won't be\n        # called needlessly later.\n        self._refresh_trigger.cancel()\n\n        self.restore_viewport()\n\n        if flags['viewport']:\n            # TODO: make this also listen to LayoutChangeException\n            flags['viewport'] = False\n            viewport = self.get_viewport()\n            indices = lm.compute_visible_views(data, viewport)\n            lm.set_visible_views(indices, data, viewport)\n\n    def refresh_from_data(self, *largs, **kwargs):\n        \"\"\"\n        This should be called when data changes. Data changes typically\n        indicate that everything should be recomputed since the source data\n        changed.\n\n        This method is automatically bound to the\n        :attr:`~RecycleDataModelBehavior.on_data_changed` method of the\n        :class:`~RecycleDataModelBehavior` class and\n        therefore responds to and accepts the keyword arguments of that event.\n\n        It can be called manually to trigger an update.\n        \"\"\"\n        self._refresh_flags['data'].append(kwargs)\n        self._refresh_trigger()\n\n    def refresh_from_layout(self, *largs, **kwargs):\n        \"\"\"\n        This should be called when the layout changes or needs to change. It is\n        typically called when a layout parameter has changed and therefore the\n        layout needs to be recomputed.\n        \"\"\"\n        self._refresh_flags['layout'].append(kwargs)\n        self._refresh_trigger()\n\n    def refresh_from_viewport(self, *largs):\n        \"\"\"\n        This should be called when the viewport changes and the displayed data\n        must be updated. Neither the data nor the layout will be recomputed.\n        \"\"\"\n        self._refresh_flags['viewport'] = True\n        self._refresh_trigger()\n\n    def _dispatch_prop_on_source(self, prop_name, *largs):\n        # Dispatches the prop of this class when the\n        # view_adapter/layout_manager property changes.\n        getattr(self.__class__, prop_name).dispatch(self)\n\n    def _get_data_model(self):\n        return self._data_model\n\n    def _set_data_model(self, value):\n        data_model = self._data_model\n        if value is data_model:\n            return\n        if data_model is not None:\n            self._data_model = None\n            data_model.detach_recycleview()\n\n        if value is None:\n            return True\n\n        if not isinstance(value, RecycleDataModelBehavior):\n            raise ValueError(\n                'Expected object based on RecycleDataModelBehavior, got {}'.\n                format(value.__class__))\n\n        self._data_model = value\n        value.attach_recycleview(self)\n        self.refresh_from_data()\n        return True\n\n    data_model = AliasProperty(_get_data_model, _set_data_model)\n    \"\"\"\n    The Data model responsible for maintaining the data set.\n\n    data_model is an :class:`~kivy.properties.AliasProperty` that gets and sets\n    the current data model.\n    \"\"\"\n\n    def _get_view_adapter(self):\n        return self._view_adapter\n\n    def _set_view_adapter(self, value):\n        view_adapter = self._view_adapter\n        if value is view_adapter:\n            return\n        if view_adapter is not None:\n            self._view_adapter = None\n            view_adapter.detach_recycleview()\n\n        if value is None:\n            return True\n\n        if not isinstance(value, RecycleDataAdapter):\n            raise ValueError(\n                'Expected object based on RecycleAdapter, got {}'.\n                format(value.__class__))\n\n        self._view_adapter = value\n        value.attach_recycleview(self)\n        self.refresh_from_layout()\n        return True\n\n    view_adapter = AliasProperty(_get_view_adapter, _set_view_adapter)\n    \"\"\"\n    The adapter responsible for providing views that represent items in a data\n    set.\n\n    view_adapter is an :class:`~kivy.properties.AliasProperty` that gets and\n    sets the current view adapter.\n    \"\"\"\n\n    def _get_layout_manager(self):\n        return self._layout_manager\n\n    def _set_layout_manager(self, value):\n        lm = self._layout_manager\n        if value is lm:\n            return\n\n        if lm is not None:\n            self._layout_manager = None\n            lm.detach_recycleview()\n\n        if value is None:\n            return True\n\n        if not isinstance(value, RecycleLayoutManagerBehavior):\n            raise ValueError(\n                'Expected object based on RecycleLayoutManagerBehavior, '\n                'got {}'.format(value.__class__))\n\n        self._layout_manager = value\n        value.attach_recycleview(self)\n        self.refresh_from_layout()\n        return True\n\n    layout_manager = AliasProperty(_get_layout_manager, _set_layout_manager)\n    \"\"\"\n    The Layout manager responsible for positioning views within the\n    :class:`RecycleView`.\n\n    layout_manager is an :class:`~kivy.properties.AliasProperty` that gets\n    and sets the layout_manger.\n    \"\"\"",
  "class RecycleView(RecycleViewBehavior, ScrollView):\n    \"\"\"\n    RecycleView is a flexible view for providing a limited window\n    into a large data set.\n\n    See the module documentation for more information.\n    \"\"\"\n    def __init__(self, **kwargs):\n        if self.data_model is None:\n            kwargs.setdefault('data_model', RecycleDataModel())\n        if self.view_adapter is None:\n            kwargs.setdefault('view_adapter', RecycleDataAdapter())\n        super(RecycleView, self).__init__(**kwargs)\n\n        fbind = self.fbind\n        fbind('scroll_x', self.refresh_from_viewport)\n        fbind('scroll_y', self.refresh_from_viewport)\n        fbind('size', self.refresh_from_viewport)\n        self.refresh_from_data()\n\n    def _convert_sv_to_lm(self, x, y):\n        lm = self.layout_manager\n        tree = [lm]\n        parent = lm.parent\n        while parent is not None and parent is not self:\n            tree.append(parent)\n            parent = parent.parent\n\n        if parent is not self:\n            raise Exception(\n                'The layout manager must be a sub child of the recycleview. '\n                'Could not find {} in the parent tree of {}'.format(self, lm))\n\n        for widget in reversed(tree):\n            x, y = widget.to_local(x, y)\n\n        return x, y\n\n    def get_viewport(self):\n        lm = self.layout_manager\n        lm_w, lm_h = lm.size\n        w, h = self.size\n        scroll_y = min(1, max(self.scroll_y, 0))\n        scroll_x = min(1, max(self.scroll_x, 0))\n\n        if lm_h <= h:\n            bottom = 0\n        else:\n            above = (lm_h - h) * scroll_y\n            bottom = max(0, lm_h - above - h)\n\n        bottom = max(0, (lm_h - h) * scroll_y)\n        left = max(0, (lm_w - w) * scroll_x)\n        width = min(w, lm_w)\n        height = min(h, lm_h)\n\n        # now convert the sv coordinates into the coordinates of the lm. In\n        # case there's a relative layout type widget in the parent tree\n        # between the sv and the lm.\n        left, bottom = self._convert_sv_to_lm(left, bottom)\n        return left, bottom, width, height\n\n    def save_viewport(self):\n        pass\n\n    def restore_viewport(self):\n        pass\n\n    def add_widget(self, widget, *args, **kwargs):\n        super(RecycleView, self).add_widget(widget, *args, **kwargs)\n        if (isinstance(widget, RecycleLayoutManagerBehavior) and\n                not self.layout_manager):\n            self.layout_manager = widget\n\n    def remove_widget(self, widget, *args, **kwargs):\n        super(RecycleView, self).remove_widget(widget, *args, **kwargs)\n        if self.layout_manager == widget:\n            self.layout_manager = None\n\n    # or easier way to use\n    def _get_data(self):\n        d = self.data_model\n        return d and d.data\n\n    def _set_data(self, value):\n        d = self.data_model\n        if d is not None:\n            d.data = value\n\n    data = AliasProperty(_get_data, _set_data, bind=[\"data_model\"])\n    \"\"\"\n    The data used by the current view adapter. This is a list of dicts whose\n    keys map to the corresponding property names of the\n    :attr:`~RecycleView.viewclass`.\n\n    data is an :class:`~kivy.properties.AliasProperty` that gets and sets the\n    data used to generate the views.\n    \"\"\"\n\n    def _get_viewclass(self):\n        a = self.layout_manager\n        return a and a.viewclass\n\n    def _set_viewclass(self, value):\n        a = self.layout_manager\n        if a:\n            a.viewclass = value\n\n    viewclass = AliasProperty(_get_viewclass, _set_viewclass,\n                              bind=[\"layout_manager\"])\n    \"\"\"\n    The viewclass used by the current layout_manager.\n\n    viewclass is an :class:`~kivy.properties.AliasProperty` that gets and sets\n    the class used to generate the individual items presented in the view.\n    \"\"\"\n\n    def _get_key_viewclass(self):\n        a = self.layout_manager\n        return a and a.key_viewclass\n\n    def _set_key_viewclass(self, value):\n        a = self.layout_manager\n        if a:\n            a.key_viewclass = value\n\n    key_viewclass = AliasProperty(_get_key_viewclass, _set_key_viewclass,\n                                  bind=[\"layout_manager\"])\n    \"\"\"\n    key_viewclass is an :class:`~kivy.properties.AliasProperty` that gets and\n    sets the key viewclass for the current\n    :attr:`~kivy.uix.recycleview.layout_manager`.\n    \"\"\"",
  "def __init__(self, **kwargs):\n        self._refresh_trigger = Clock.create_trigger(self.refresh_views, -1)\n        self._refresh_flags = deepcopy(self._refresh_flags)\n        super(RecycleViewBehavior, self).__init__(**kwargs)",
  "def get_viewport(self):\n        pass",
  "def save_viewport(self):\n        pass",
  "def restore_viewport(self):\n        pass",
  "def refresh_views(self, *largs):\n        lm = self.layout_manager\n        flags = self._refresh_flags\n        if lm is None or self.view_adapter is None or self.data_model is None:\n            return\n\n        data = self.data\n        f = flags['data']\n        if f:\n            self.save_viewport()\n            # lm.clear_layout()\n            flags['data'] = []\n            flags['layout'] = [{}]\n            lm.compute_sizes_from_data(data, f)\n\n        while flags['layout']:\n            # if `data` we were re-triggered so finish in the next call.\n            # Otherwise go until fully laid out.\n            self.save_viewport()\n            if flags['data']:\n                return\n            flags['viewport'] = True\n            f = flags['layout']\n            flags['layout'] = []\n\n            try:\n                lm.compute_layout(data, f)\n            except LayoutChangeException:\n                flags['layout'].append({})\n                continue\n\n        if flags['data']:  # in case that happened meanwhile\n            return\n\n        # make sure if we were re-triggered in the loop that we won't be\n        # called needlessly later.\n        self._refresh_trigger.cancel()\n\n        self.restore_viewport()\n\n        if flags['viewport']:\n            # TODO: make this also listen to LayoutChangeException\n            flags['viewport'] = False\n            viewport = self.get_viewport()\n            indices = lm.compute_visible_views(data, viewport)\n            lm.set_visible_views(indices, data, viewport)",
  "def refresh_from_data(self, *largs, **kwargs):\n        \"\"\"\n        This should be called when data changes. Data changes typically\n        indicate that everything should be recomputed since the source data\n        changed.\n\n        This method is automatically bound to the\n        :attr:`~RecycleDataModelBehavior.on_data_changed` method of the\n        :class:`~RecycleDataModelBehavior` class and\n        therefore responds to and accepts the keyword arguments of that event.\n\n        It can be called manually to trigger an update.\n        \"\"\"\n        self._refresh_flags['data'].append(kwargs)\n        self._refresh_trigger()",
  "def refresh_from_layout(self, *largs, **kwargs):\n        \"\"\"\n        This should be called when the layout changes or needs to change. It is\n        typically called when a layout parameter has changed and therefore the\n        layout needs to be recomputed.\n        \"\"\"\n        self._refresh_flags['layout'].append(kwargs)\n        self._refresh_trigger()",
  "def refresh_from_viewport(self, *largs):\n        \"\"\"\n        This should be called when the viewport changes and the displayed data\n        must be updated. Neither the data nor the layout will be recomputed.\n        \"\"\"\n        self._refresh_flags['viewport'] = True\n        self._refresh_trigger()",
  "def _dispatch_prop_on_source(self, prop_name, *largs):\n        # Dispatches the prop of this class when the\n        # view_adapter/layout_manager property changes.\n        getattr(self.__class__, prop_name).dispatch(self)",
  "def _get_data_model(self):\n        return self._data_model",
  "def _set_data_model(self, value):\n        data_model = self._data_model\n        if value is data_model:\n            return\n        if data_model is not None:\n            self._data_model = None\n            data_model.detach_recycleview()\n\n        if value is None:\n            return True\n\n        if not isinstance(value, RecycleDataModelBehavior):\n            raise ValueError(\n                'Expected object based on RecycleDataModelBehavior, got {}'.\n                format(value.__class__))\n\n        self._data_model = value\n        value.attach_recycleview(self)\n        self.refresh_from_data()\n        return True",
  "def _get_view_adapter(self):\n        return self._view_adapter",
  "def _set_view_adapter(self, value):\n        view_adapter = self._view_adapter\n        if value is view_adapter:\n            return\n        if view_adapter is not None:\n            self._view_adapter = None\n            view_adapter.detach_recycleview()\n\n        if value is None:\n            return True\n\n        if not isinstance(value, RecycleDataAdapter):\n            raise ValueError(\n                'Expected object based on RecycleAdapter, got {}'.\n                format(value.__class__))\n\n        self._view_adapter = value\n        value.attach_recycleview(self)\n        self.refresh_from_layout()\n        return True",
  "def _get_layout_manager(self):\n        return self._layout_manager",
  "def _set_layout_manager(self, value):\n        lm = self._layout_manager\n        if value is lm:\n            return\n\n        if lm is not None:\n            self._layout_manager = None\n            lm.detach_recycleview()\n\n        if value is None:\n            return True\n\n        if not isinstance(value, RecycleLayoutManagerBehavior):\n            raise ValueError(\n                'Expected object based on RecycleLayoutManagerBehavior, '\n                'got {}'.format(value.__class__))\n\n        self._layout_manager = value\n        value.attach_recycleview(self)\n        self.refresh_from_layout()\n        return True",
  "def __init__(self, **kwargs):\n        if self.data_model is None:\n            kwargs.setdefault('data_model', RecycleDataModel())\n        if self.view_adapter is None:\n            kwargs.setdefault('view_adapter', RecycleDataAdapter())\n        super(RecycleView, self).__init__(**kwargs)\n\n        fbind = self.fbind\n        fbind('scroll_x', self.refresh_from_viewport)\n        fbind('scroll_y', self.refresh_from_viewport)\n        fbind('size', self.refresh_from_viewport)\n        self.refresh_from_data()",
  "def _convert_sv_to_lm(self, x, y):\n        lm = self.layout_manager\n        tree = [lm]\n        parent = lm.parent\n        while parent is not None and parent is not self:\n            tree.append(parent)\n            parent = parent.parent\n\n        if parent is not self:\n            raise Exception(\n                'The layout manager must be a sub child of the recycleview. '\n                'Could not find {} in the parent tree of {}'.format(self, lm))\n\n        for widget in reversed(tree):\n            x, y = widget.to_local(x, y)\n\n        return x, y",
  "def get_viewport(self):\n        lm = self.layout_manager\n        lm_w, lm_h = lm.size\n        w, h = self.size\n        scroll_y = min(1, max(self.scroll_y, 0))\n        scroll_x = min(1, max(self.scroll_x, 0))\n\n        if lm_h <= h:\n            bottom = 0\n        else:\n            above = (lm_h - h) * scroll_y\n            bottom = max(0, lm_h - above - h)\n\n        bottom = max(0, (lm_h - h) * scroll_y)\n        left = max(0, (lm_w - w) * scroll_x)\n        width = min(w, lm_w)\n        height = min(h, lm_h)\n\n        # now convert the sv coordinates into the coordinates of the lm. In\n        # case there's a relative layout type widget in the parent tree\n        # between the sv and the lm.\n        left, bottom = self._convert_sv_to_lm(left, bottom)\n        return left, bottom, width, height",
  "def save_viewport(self):\n        pass",
  "def restore_viewport(self):\n        pass",
  "def add_widget(self, widget, *args, **kwargs):\n        super(RecycleView, self).add_widget(widget, *args, **kwargs)\n        if (isinstance(widget, RecycleLayoutManagerBehavior) and\n                not self.layout_manager):\n            self.layout_manager = widget",
  "def remove_widget(self, widget, *args, **kwargs):\n        super(RecycleView, self).remove_widget(widget, *args, **kwargs)\n        if self.layout_manager == widget:\n            self.layout_manager = None",
  "def _get_data(self):\n        d = self.data_model\n        return d and d.data",
  "def _set_data(self, value):\n        d = self.data_model\n        if d is not None:\n            d.data = value",
  "def _get_viewclass(self):\n        a = self.layout_manager\n        return a and a.viewclass",
  "def _set_viewclass(self, value):\n        a = self.layout_manager\n        if a:\n            a.viewclass = value",
  "def _get_key_viewclass(self):\n        a = self.layout_manager\n        return a and a.key_viewclass",
  "def _set_key_viewclass(self, value):\n        a = self.layout_manager\n        if a:\n            a.key_viewclass = value",
  "class KvHandler(FileSystemEventHandler):\n    def __init__(self, callback, target, **kwargs):\n        super(KvHandler, self).__init__(**kwargs)\n        self.callback = callback\n        self.target = target\n\n    def on_any_event(self, event):\n        if basename(event.src_path) == self.target:\n            self.callback()",
  "class KvViewerApp(App):\n    def build(self):\n        o = Observer()\n        o.schedule(KvHandler(self.update, TARGET), PATH)\n        o.start()\n        Clock.schedule_once(self.update, 1)\n        return super(KvViewerApp, self).build()\n\n    @mainthread\n    def update(self, *args):\n        Builder.unload_file(join(PATH, TARGET))\n        for w in Window.children[:]:\n            Window.remove_widget(w)\n        try:\n            Window.add_widget(Builder.load_file(join(PATH, TARGET)))\n        except Exception as e:\n            Window.add_widget(Label(text=(\n                e.message if getattr(e, r'message', None) else str(e)\n            )))",
  "def __init__(self, callback, target, **kwargs):\n        super(KvHandler, self).__init__(**kwargs)\n        self.callback = callback\n        self.target = target",
  "def on_any_event(self, event):\n        if basename(event.src_path) == self.target:\n            self.callback()",
  "def build(self):\n        o = Observer()\n        o.schedule(KvHandler(self.update, TARGET), PATH)\n        o.start()\n        Clock.schedule_once(self.update, 1)\n        return super(KvViewerApp, self).build()",
  "def update(self, *args):\n        Builder.unload_file(join(PATH, TARGET))\n        for w in Window.children[:]:\n            Window.remove_widget(w)\n        try:\n            Window.add_widget(Builder.load_file(join(PATH, TARGET)))\n        except Exception as e:\n            Window.add_widget(Label(text=(\n                e.message if getattr(e, r'message', None) else str(e)\n            )))",
  "class Converter(object):\n\n    converters = {\n        'appstore': {\n            'directory_name': 'ios',\n            'sizes': [\n                ('App store high resolution', '{}-appstore-1024.png', 1024),\n                ('App store normal resolution', '{}-appstore-512.png', 512),\n                # iOS 7\n                ('iPhone (iOS 7)', '{}-60.png', 120),\n                ('iPhone @2 (iOS 7)', '{}-60@2x.png', 120),\n                ('iPad (iOS 7)', '{}-76.png', 76),\n                ('iPad @2 (iOS 7)', '{}-60@2x.png', 152),\n                # iOS 6.1 and earlier\n                ('iPhone (iOS >= 6.1)', '{}-57.png', 57),\n                ('iPhone @2 (iOS >= 6.1)', '{}-57@2x.png', 114),\n                ('iPad (iOS >= 6.1)', '{}-72.png', 72),\n                ('iPad @2 (iOS >= 6.1)', '{}-72@2x.png', 114),\n                # iTunes artwork (ad-hoc)\n                ('iTunes Artwork (ad-hoc)', 'iTunesArtwork', 512),\n                ('iTunes Artwork @2 (ad-hoc)', 'iTunesArtwork@2x', 1024),\n            ]},\n        'playstore': {\n            'directory_name': 'android',\n            'sizes': [\n                ('Google Play icon', '{}-googleplay-512.png', 512),\n                ('Launcher icon MDPI', '{}-48.png', 48),\n                ('Launcher icon HDPI', '{}-72.png', 72),\n                ('Launcher icon XHDPI', '{}-96.png', 96),\n                ('Launcher icon XXHDPI', '{}-144.png', 48),\n                ('Launcher icon XXXHDPI', '{}-192.png', 192),\n            ]},\n        'amazonstore': {\n            'directory_name': 'amazon',\n            'sizes': [\n                ('Small icon', '{}-114.png', 114),\n                ('Large icon', '{}-512.png', 512),\n            ]}}\n\n    def run(self):\n        parser = ArgumentParser(\n                description='Generate icons for various stores')\n        parser.add_argument('--dir', type=str, default=None,\n                help=('Output directory to generate all the icons,'\n                      'defaults to the directory of the source icon'))\n        parser.add_argument('--force', type=bool, default=False,\n                help=('Generate all icons even if the source is not perfect.'))\n        parser.add_argument('icon', type=str,\n                help='Base icon (must be 1024x1024 or 512x512)')\n\n        args = parser.parse_args()\n        if not exists(args.icon):\n            print('Error: No such icon file')\n            sys.exit(1)\n\n        # ensure the destination directory will be set\n        if args.dir is None:\n            args.dir = dirname(args.icon)\n\n        # read the source image, and do some quality checks\n        base_fn = basename(args.icon).rsplit('.', 1)[0]\n        source = Image.open(args.icon)\n        self.ensure_quality(source, args.force)\n\n        for directory_name, sizeinfo in self.iterate():\n            description, pattern_fn, size = sizeinfo\n            print('Generate {}: {}x{}'.format(description, size, size))\n            dest_dir = realpath(join(args.dir, directory_name))\n            if not exists(dest_dir):\n                makedirs(dest_dir)\n            icon_fn = join(dest_dir, pattern_fn.format('Icon'))\n            self.convert_to(source, icon_fn, size)\n\n    def convert_to(self, source, icon_fn, size):\n        dest = source.resize((size, size))\n        dest.save(icon_fn, 'png')\n\n    def ensure_quality(self, image, force=False):\n        messages = []\n        w, h = image.size\n        if w != h:\n            messages.append('Width and height should be the same')\n        if w not in (512, 1024):\n            messages.append(\n                'Source image is recommended to be 1024 (512 minimum)')\n        if not messages:\n            return\n\n        print('Quality check failed')\n        for message in messages:\n            print('- {}'.format(message))\n        if not force:\n            sys.exit(1)\n\n    def iterate(self):\n        for store, infos in Converter.converters.items():\n            for size in infos['sizes']:\n                yield infos['directory_name'], size",
  "def run(self):\n        parser = ArgumentParser(\n                description='Generate icons for various stores')\n        parser.add_argument('--dir', type=str, default=None,\n                help=('Output directory to generate all the icons,'\n                      'defaults to the directory of the source icon'))\n        parser.add_argument('--force', type=bool, default=False,\n                help=('Generate all icons even if the source is not perfect.'))\n        parser.add_argument('icon', type=str,\n                help='Base icon (must be 1024x1024 or 512x512)')\n\n        args = parser.parse_args()\n        if not exists(args.icon):\n            print('Error: No such icon file')\n            sys.exit(1)\n\n        # ensure the destination directory will be set\n        if args.dir is None:\n            args.dir = dirname(args.icon)\n\n        # read the source image, and do some quality checks\n        base_fn = basename(args.icon).rsplit('.', 1)[0]\n        source = Image.open(args.icon)\n        self.ensure_quality(source, args.force)\n\n        for directory_name, sizeinfo in self.iterate():\n            description, pattern_fn, size = sizeinfo\n            print('Generate {}: {}x{}'.format(description, size, size))\n            dest_dir = realpath(join(args.dir, directory_name))\n            if not exists(dest_dir):\n                makedirs(dest_dir)\n            icon_fn = join(dest_dir, pattern_fn.format('Icon'))\n            self.convert_to(source, icon_fn, size)",
  "def convert_to(self, source, icon_fn, size):\n        dest = source.resize((size, size))\n        dest.save(icon_fn, 'png')",
  "def ensure_quality(self, image, force=False):\n        messages = []\n        w, h = image.size\n        if w != h:\n            messages.append('Width and height should be the same')\n        if w not in (512, 1024):\n            messages.append(\n                'Source image is recommended to be 1024 (512 minimum)')\n        if not messages:\n            return\n\n        print('Quality check failed')\n        for message in messages:\n            print('- {}'.format(message))\n        if not force:\n            sys.exit(1)",
  "def iterate(self):\n        for store, infos in Converter.converters.items():\n            for size in infos['sizes']:\n                yield infos['directory_name'], size",
  "class FakeMotionEvent(MotionEvent):\n    pass",
  "class bench_widget_creation:\n    '''Widget: creation (10000 Widget)'''\n\n    def run(self):\n        o = []\n        for x in range(10000):\n            o.append(Widget())",
  "class bench_widget_creation_with_root:\n    '''Widget: creation (10000 Widget + 1 root)'''\n\n    def run(self):\n        o = Widget()\n        for x in range(10000):\n            o.add_widget(Widget())",
  "class bench_widget_draw:\n    '''Widget: empty drawing (10000 Widget + 1 root)'''\n\n    def __init__(self):\n        self.ctx = RenderContext()\n        self.root = root = Widget()\n        for x in range(10000):\n            root.add_widget(Widget())\n        self.ctx.add(self.root.canvas)\n\n    def run(self):\n        self.ctx.draw()",
  "class bench_widget_dispatch:\n    '''Widget: event dispatch (1000 on_update in 10*1000 Widget)'''\n\n    def __init__(self):\n        root = Widget()\n        for x in range(10):\n            parent = Widget()\n            for y in range(1000):\n                parent.add_widget(Widget())\n            root.add_widget(parent)\n        self.root = root\n\n    def run(self):\n        touch = FakeMotionEvent('fake', 1, [])\n        self.root.dispatch('on_touch_down', touch)\n        self.root.dispatch('on_touch_move', touch)\n        self.root.dispatch('on_touch_up', touch)",
  "class bench_label_creation:\n    '''Core: label creation (10000 * 10 a-z)'''\n\n    def __init__(self):\n        labels = []\n        for x in range(10000):\n            label = [chr(randint(ord('a'), ord('z'))) for x in range(10)]\n            labels.append(''.join(label))\n        self.labels = labels\n\n    def run(self):\n        o = []\n        for x in self.labels:\n            o.append(Label(text=x))",
  "class bench_button_creation:\n    '''Core: button creation (10000 * 10 a-z)'''\n\n    def __init__(self):\n        labels = []\n        for x in xrange(10000):\n            button = map(lambda x: chr(randint(ord('a'), ord('z'))),\n                         xrange(10))\n            labels.append(''.join(button))\n        self.labels = labels\n\n    def run(self):\n        o = []\n        for x in self.labels:\n            o.append(Button(text=x))",
  "class bench_label_creation_with_tick:\n    '''Core: label creation (10000 * 10 a-z), with Clock.tick'''\n\n    def __init__(self):\n        labels = []\n        for x in range(10000):\n            label = [chr(randint(ord('a'), ord('z'))) for x in range(10)]\n            labels.append(''.join(label))\n        self.labels = labels\n\n    def run(self):\n        o = []\n        for x in self.labels:\n            o.append(Label(text=x))\n        # tick for texture creation\n        Clock.tick()",
  "class bench_button_creation_with_tick:\n    '''Core: button creation (10000 * 10 a-z), with Clock.tick'''\n\n    def __init__(self):\n        labels = []\n        for x in xrange(10000):\n            button = map(lambda x: chr(randint(ord('a'), ord('z'))),\n                         xrange(10))\n            labels.append(''.join(button))\n        self.labels = labels\n\n    def run(self):\n        o = []\n        for x in self.labels:\n            o.append(Button(text=x))\n        # tick for texture creation\n        Clock.tick()",
  "def run(self):\n        o = []\n        for x in range(10000):\n            o.append(Widget())",
  "def run(self):\n        o = Widget()\n        for x in range(10000):\n            o.add_widget(Widget())",
  "def __init__(self):\n        self.ctx = RenderContext()\n        self.root = root = Widget()\n        for x in range(10000):\n            root.add_widget(Widget())\n        self.ctx.add(self.root.canvas)",
  "def run(self):\n        self.ctx.draw()",
  "def __init__(self):\n        root = Widget()\n        for x in range(10):\n            parent = Widget()\n            for y in range(1000):\n                parent.add_widget(Widget())\n            root.add_widget(parent)\n        self.root = root",
  "def run(self):\n        touch = FakeMotionEvent('fake', 1, [])\n        self.root.dispatch('on_touch_down', touch)\n        self.root.dispatch('on_touch_move', touch)\n        self.root.dispatch('on_touch_up', touch)",
  "def __init__(self):\n        labels = []\n        for x in range(10000):\n            label = [chr(randint(ord('a'), ord('z'))) for x in range(10)]\n            labels.append(''.join(label))\n        self.labels = labels",
  "def run(self):\n        o = []\n        for x in self.labels:\n            o.append(Label(text=x))",
  "def __init__(self):\n        labels = []\n        for x in xrange(10000):\n            button = map(lambda x: chr(randint(ord('a'), ord('z'))),\n                         xrange(10))\n            labels.append(''.join(button))\n        self.labels = labels",
  "def run(self):\n        o = []\n        for x in self.labels:\n            o.append(Button(text=x))",
  "def __init__(self):\n        labels = []\n        for x in range(10000):\n            label = [chr(randint(ord('a'), ord('z'))) for x in range(10)]\n            labels.append(''.join(label))\n        self.labels = labels",
  "def run(self):\n        o = []\n        for x in self.labels:\n            o.append(Label(text=x))\n        # tick for texture creation\n        Clock.tick()",
  "def __init__(self):\n        labels = []\n        for x in xrange(10000):\n            button = map(lambda x: chr(randint(ord('a'), ord('z'))),\n                         xrange(10))\n            labels.append(''.join(button))\n        self.labels = labels",
  "def run(self):\n        o = []\n        for x in self.labels:\n            o.append(Button(text=x))\n        # tick for texture creation\n        Clock.tick()",
  "def log(s, newline=True):\n        global report_newline\n        if not report_newline:\n            report[-1] = '%s %s' % (report[-1], s)\n        else:\n            report.append(s)\n        if newline:\n            print(s)\n            report_newline = True\n        else:\n            print(s, end=' ')\n            report_newline = False\n        sys.stdout.flush()",
  "class Tool(object):\n    def __init__(self, options):\n        super(Tool, self).__init__()\n        self.options = options\n        self.source_fn = options.image\n        self.dest_dir = options.dir or dirname(options.image)\n\n    @property\n    def tex_fn(self):\n        fn = basename(self.source_fn).rsplit('.', 1)[0] + '.tex'\n        return join(self.dest_dir, fn)\n\n    def compress(self):\n        pass\n\n    def nearest_pow2(self, v):\n        # Credits: Sean Anderson\n        v -= 1\n        v |= v >> 1\n        v |= v >> 2\n        v |= v >> 4\n        v |= v >> 8\n        v |= v >> 16\n        return v + 1\n\n    def runcmd(self, cmd):\n        print('Run: {}'.format(' '.join(cmd)))\n        Popen(cmd).communicate()\n\n    def write_tex(self, data, fmt, image_size, texture_size, mipmap=False,\n            formatinfo=None):\n        infos = {\n            'datalen': len(data),\n            'image_size': image_size,\n            'texture_size': texture_size,\n            'mipmap': mipmap,\n            'format': fmt}\n        if formatinfo:\n            infos['formatinfo'] = formatinfo\n        header = json.dumps(infos, indent=0, separators=(',', ':'))\n        header = header.replace('\\n', '')\n        with open(self.tex_fn, 'wb') as fd:\n            fd.write('KTEX')\n            fd.write(pack('I', len(header)))\n            fd.write(header)\n            fd.write(data)\n\n        print('Done! Compressed texture written at {}'.format(self.tex_fn))\n        pprint(infos)\n\n    @staticmethod\n    def run():\n        parser = ArgumentParser(\n                description='Convert images to compressed texture')\n        parser.add_argument('--mipmap', type=bool, default=False,\n                help='Auto generate mipmaps')\n        parser.add_argument('--dir', type=str, default=None,\n                help='Output directory to generate the compressed texture')\n        parser.add_argument('format', type=str, choices=['pvrtc', 'etc1'],\n                help='Format of the final texture')\n        parser.add_argument('image', type=str,\n                help='Image filename')\n        args = parser.parse_args()\n\n        if args.format == 'pvrtc':\n            PvrtcTool(args).compress()\n        elif args.format == 'etc1':\n            Etc1Tool(args).compress()\n        else:\n            print('Unknown compression format')\n            exit(1)",
  "class Etc1Tool(Tool):\n    def __init__(self, options):\n        super(Etc1Tool, self).__init__(options)\n        self.etc1tool = None\n        self.locate_etc1tool()\n\n    def locate_etc1tool(self):\n        search_directories = [environ.get('ANDROIDSDK', '/')]\n        search_directories += environ.get('PATH', '').split(':')\n        for directory in search_directories:\n            fn = join(directory, 'etc1tool')\n            if not exists(fn):\n                fn = join(directory, 'tools', 'etc1tool')\n                if not exists(fn):\n                    continue\n            print('Found texturetool at {}'.format(directory))\n            self.etc1tool = fn\n            return\n\n        if self.etc1tool is None:\n            print('Error: Unable to locate \"etc1tool\".\\n'\n                  'Make sure that \"etc1tool\" is available in your PATH.\\n'\n                  'Or export the path of your Android SDK to ANDROIDSDK')\n            exit(1)\n\n    def compress(self):\n        # 1. open the source image, and get the dimensions\n        image = Image.open(self.source_fn)\n        w, h = image.size\n        print('Image size is {}x{}'.format(*image.size))\n\n        # 2. search the nearest 2^\n        w2 = self.nearest_pow2(w)\n        h2 = self.nearest_pow2(h)\n        print('Nearest power-of-2 size is {}x{}'.format(w2, h2))\n\n        # 3. invoke etc1tool\n        raw_tex_fn = self.tex_fn + '.raw'\n        cmd = [self.etc1tool, self.source_fn, '--encodeNoHeader', '-o',\n               raw_tex_fn]\n        try:\n            self.runcmd(cmd)\n            with open(raw_tex_fn, 'rb') as fd:\n                data = fd.read()\n        finally:\n            if exists(raw_tex_fn):\n                unlink(raw_tex_fn)\n\n        # 5. write texture info\n        self.write_tex(data, 'etc1_rgb8', (w, h), (w2, h2),\n                        self.options.mipmap)",
  "class PvrtcTool(Tool):\n    def __init__(self, options):\n        super(PvrtcTool, self).__init__(options)\n        self.texturetool = None\n        self.locate_texturetool()\n\n    def locate_texturetool(self):\n        search_directories = [\n            ('/Applications/Xcode.app/Contents/Developer/Platforms/'\n             'iPhoneOS.platform/Developer/usr/bin/'),\n            '/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/']\n        search_directories += environ.get('PATH', '').split(':')\n\n        for directory in search_directories:\n            fn = join(directory, 'texturetool')\n            if not exists(fn):\n                continue\n            print('Found texturetool at {}'.format(directory))\n            self.texturetool = fn\n            return\n\n        print('Error: Unable to locate \"texturetool\".\\n'\n              'Please install the iPhone SDK, or the PowerVR SDK.\\n'\n              'Then make sure that \"texturetool\" is available in your PATH.')\n        exit(1)\n\n    def compress(self):\n        # 1. open the source image, and get the dimensions\n        image = Image.open(self.source_fn)\n        w, h = image.size\n        print('Image size is {}x{}'.format(*image.size))\n\n        # 2. search the nearest 2^\n        w2 = self.nearest_pow2(w)\n        h2 = self.nearest_pow2(h)\n        print('Nearest power-of-2 size is {}x{}'.format(w2, h2))\n\n        # 3. for PVR, the image MUST be a square. use the bigger size then\n        s2 = max(w2, h2)\n        print('PVR need a square image, the texture will be {0}x{0}'\n                .format(s2))\n\n        ext = self.source_fn.rsplit('.', 1)[-1]\n        tmpfile = '/tmp/ktexturecompress.{}'.format(ext)\n        image = image.resize((s2, s2))\n        image.save(tmpfile)\n\n        # 4. invoke texture tool\n        raw_tex_fn = self.tex_fn + '.raw'\n        cmd = [self.texturetool]\n        if self.options.mipmap:\n            cmd += ['-m']\n        cmd += ['-e', 'PVRTC', '-o', raw_tex_fn, '-f', 'RAW', tmpfile]\n        try:\n            self.runcmd(cmd)\n            with open(raw_tex_fn, 'rb') as fd:\n                data = fd.read()\n        finally:\n            if exists(raw_tex_fn):\n                unlink(raw_tex_fn)\n\n        # 5. write texture info\n        self.write_tex(data, 'pvrtc_rgba4', (w, h), (s2, s2),\n                       self.options.mipmap)",
  "def __init__(self, options):\n        super(Tool, self).__init__()\n        self.options = options\n        self.source_fn = options.image\n        self.dest_dir = options.dir or dirname(options.image)",
  "def tex_fn(self):\n        fn = basename(self.source_fn).rsplit('.', 1)[0] + '.tex'\n        return join(self.dest_dir, fn)",
  "def compress(self):\n        pass",
  "def nearest_pow2(self, v):\n        # Credits: Sean Anderson\n        v -= 1\n        v |= v >> 1\n        v |= v >> 2\n        v |= v >> 4\n        v |= v >> 8\n        v |= v >> 16\n        return v + 1",
  "def runcmd(self, cmd):\n        print('Run: {}'.format(' '.join(cmd)))\n        Popen(cmd).communicate()",
  "def write_tex(self, data, fmt, image_size, texture_size, mipmap=False,\n            formatinfo=None):\n        infos = {\n            'datalen': len(data),\n            'image_size': image_size,\n            'texture_size': texture_size,\n            'mipmap': mipmap,\n            'format': fmt}\n        if formatinfo:\n            infos['formatinfo'] = formatinfo\n        header = json.dumps(infos, indent=0, separators=(',', ':'))\n        header = header.replace('\\n', '')\n        with open(self.tex_fn, 'wb') as fd:\n            fd.write('KTEX')\n            fd.write(pack('I', len(header)))\n            fd.write(header)\n            fd.write(data)\n\n        print('Done! Compressed texture written at {}'.format(self.tex_fn))\n        pprint(infos)",
  "def run():\n        parser = ArgumentParser(\n                description='Convert images to compressed texture')\n        parser.add_argument('--mipmap', type=bool, default=False,\n                help='Auto generate mipmaps')\n        parser.add_argument('--dir', type=str, default=None,\n                help='Output directory to generate the compressed texture')\n        parser.add_argument('format', type=str, choices=['pvrtc', 'etc1'],\n                help='Format of the final texture')\n        parser.add_argument('image', type=str,\n                help='Image filename')\n        args = parser.parse_args()\n\n        if args.format == 'pvrtc':\n            PvrtcTool(args).compress()\n        elif args.format == 'etc1':\n            Etc1Tool(args).compress()\n        else:\n            print('Unknown compression format')\n            exit(1)",
  "def __init__(self, options):\n        super(Etc1Tool, self).__init__(options)\n        self.etc1tool = None\n        self.locate_etc1tool()",
  "def locate_etc1tool(self):\n        search_directories = [environ.get('ANDROIDSDK', '/')]\n        search_directories += environ.get('PATH', '').split(':')\n        for directory in search_directories:\n            fn = join(directory, 'etc1tool')\n            if not exists(fn):\n                fn = join(directory, 'tools', 'etc1tool')\n                if not exists(fn):\n                    continue\n            print('Found texturetool at {}'.format(directory))\n            self.etc1tool = fn\n            return\n\n        if self.etc1tool is None:\n            print('Error: Unable to locate \"etc1tool\".\\n'\n                  'Make sure that \"etc1tool\" is available in your PATH.\\n'\n                  'Or export the path of your Android SDK to ANDROIDSDK')\n            exit(1)",
  "def compress(self):\n        # 1. open the source image, and get the dimensions\n        image = Image.open(self.source_fn)\n        w, h = image.size\n        print('Image size is {}x{}'.format(*image.size))\n\n        # 2. search the nearest 2^\n        w2 = self.nearest_pow2(w)\n        h2 = self.nearest_pow2(h)\n        print('Nearest power-of-2 size is {}x{}'.format(w2, h2))\n\n        # 3. invoke etc1tool\n        raw_tex_fn = self.tex_fn + '.raw'\n        cmd = [self.etc1tool, self.source_fn, '--encodeNoHeader', '-o',\n               raw_tex_fn]\n        try:\n            self.runcmd(cmd)\n            with open(raw_tex_fn, 'rb') as fd:\n                data = fd.read()\n        finally:\n            if exists(raw_tex_fn):\n                unlink(raw_tex_fn)\n\n        # 5. write texture info\n        self.write_tex(data, 'etc1_rgb8', (w, h), (w2, h2),\n                        self.options.mipmap)",
  "def __init__(self, options):\n        super(PvrtcTool, self).__init__(options)\n        self.texturetool = None\n        self.locate_texturetool()",
  "def locate_texturetool(self):\n        search_directories = [\n            ('/Applications/Xcode.app/Contents/Developer/Platforms/'\n             'iPhoneOS.platform/Developer/usr/bin/'),\n            '/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/']\n        search_directories += environ.get('PATH', '').split(':')\n\n        for directory in search_directories:\n            fn = join(directory, 'texturetool')\n            if not exists(fn):\n                continue\n            print('Found texturetool at {}'.format(directory))\n            self.texturetool = fn\n            return\n\n        print('Error: Unable to locate \"texturetool\".\\n'\n              'Please install the iPhone SDK, or the PowerVR SDK.\\n'\n              'Then make sure that \"texturetool\" is available in your PATH.')\n        exit(1)",
  "def compress(self):\n        # 1. open the source image, and get the dimensions\n        image = Image.open(self.source_fn)\n        w, h = image.size\n        print('Image size is {}x{}'.format(*image.size))\n\n        # 2. search the nearest 2^\n        w2 = self.nearest_pow2(w)\n        h2 = self.nearest_pow2(h)\n        print('Nearest power-of-2 size is {}x{}'.format(w2, h2))\n\n        # 3. for PVR, the image MUST be a square. use the bigger size then\n        s2 = max(w2, h2)\n        print('PVR need a square image, the texture will be {0}x{0}'\n                .format(s2))\n\n        ext = self.source_fn.rsplit('.', 1)[-1]\n        tmpfile = '/tmp/ktexturecompress.{}'.format(ext)\n        image = image.resize((s2, s2))\n        image.save(tmpfile)\n\n        # 4. invoke texture tool\n        raw_tex_fn = self.tex_fn + '.raw'\n        cmd = [self.texturetool]\n        if self.options.mipmap:\n            cmd += ['-m']\n        cmd += ['-e', 'PVRTC', '-o', raw_tex_fn, '-f', 'RAW', tmpfile]\n        try:\n            self.runcmd(cmd)\n            with open(raw_tex_fn, 'rb') as fd:\n                data = fd.read()\n        finally:\n            if exists(raw_tex_fn):\n                unlink(raw_tex_fn)\n\n        # 5. write texture info\n        self.write_tex(data, 'pvrtc_rgba4', (w, h), (s2, s2),\n                       self.options.mipmap)",
  "def title(t):\n    report.append('')\n    report.append('=' * 80)\n    report.append(t)\n    report.append('=' * 80)\n    report.append('')",
  "def send_report(dict_report):\n    import requests\n    import json\n\n    gist_report = {\n        \"description\": \"Report\",\n        \"public\": \"true\",\n        \"files\": {\n            \"Global.txt\": {\n                \"content\": \"\\n\".join(dict_report['Global']),\n                \"type\": 'text'\n            },\n            \"OpenGL.txt\": {\n                \"content\": \"\\n\".join(dict_report['OpenGL']),\n                \"type\": 'text'\n\n            },\n            \"Core selection.txt\": {\n                \"content\": \"\\n\".join(dict_report['Core']),\n                \"type\": 'text'\n            },\n            \"Libraries.txt\": {\n                \"content\": \"\\n\".join(dict_report['Libraries']),\n                \"type\": 'text'\n            },\n            \"Configuration.txt\": {\n                \"content\": \"\\n\".join(dict_report['Configuration']),\n                \"type\": 'text'\n            },\n            \"Input Availability.txt\": {\n                \"content\": \"\\n\".join(dict_report['InputAvailability']),\n                \"type\": 'text'\n            },\n            \"Environ.txt\": {\n                \"content\": \"\\n\".join(dict_report['Environ']),\n                \"type\": 'text'\n            },\n            \"Options.txt\": {\n                \"content\": \"\\n\".join(dict_report['Options']),\n                \"type\": 'text'\n            },\n        }\n    }\n    report_json = json.dumps(gist_report)\n    response = requests.post(\"https://api.github.com/gists\", report_json)\n    return json.loads(response.text)['html_url']",
  "def testimport(libname):\n    try:\n        lib = __import__(libname)\n        report.append('%-20s exist at %s' % (libname, lib.__file__))\n    except ImportError:\n        report.append('%-20s is missing' % libname)",
  "class CoverageKVParser(Parser):\n\n    def execute_directives(self):\n        # don't actually execute anything\n        pass\n\n    def get_coverage_lines(self):\n        lines = set()\n        for parser_prop in walk_parser(self):\n            for line_num, line in enumerate(\n                    parser_prop.value.splitlines(),\n                    start=parser_prop.line + 1):\n                if line.strip():\n                    lines.add(line_num)\n\n        return lines",
  "def walk_parser_rules(parser_rule):\n    yield parser_rule\n\n    for child in parser_rule.children:\n        for rule in walk_parser_rules(child):\n            yield rule\n\n    if parser_rule.canvas_before is not None:\n        for rule in walk_parser_rules(parser_rule.canvas_before):\n            yield rule\n        yield parser_rule.canvas_before\n    if parser_rule.canvas_root is not None:\n        for rule in walk_parser_rules(parser_rule.canvas_root):\n            yield rule\n    if parser_rule.canvas_after is not None:\n        for rule in walk_parser_rules(parser_rule.canvas_after):\n            yield rule",
  "def walk_parser_rules_properties(parser_rule):\n    for rule in parser_rule.properties.values():\n        yield rule\n    for rule in parser_rule.handlers:\n        yield rule",
  "def walk_parser(parser):\n    if parser.root is not None:\n        for rule in walk_parser_rules(parser.root):\n            for prop in walk_parser_rules_properties(rule):\n                yield prop\n\n    for _, cls_rule in parser.rules:\n        for rule in walk_parser_rules(cls_rule):\n            for prop in walk_parser_rules_properties(rule):\n                yield prop",
  "class KivyCoveragePlugin(coverage.plugin.CoveragePlugin):\n\n    def file_tracer(self, filename):\n        if filename.endswith('.kv'):\n            return KivyFileTracer(filename=filename)\n        return None\n\n    def file_reporter(self, filename):\n        return KivyFileReporter(filename=filename)\n\n    def find_executable_files(self, src_dir):\n        for (dirpath, dirnames, filenames) in os.walk(src_dir):\n            for filename in filenames:\n                if filename.endswith('.kv'):\n                    yield os.path.join(dirpath, filename)",
  "class KivyFileTracer(coverage.plugin.FileTracer):\n\n    filename = ''\n\n    def __init__(self, filename, **kwargs):\n        super(KivyFileTracer, self).__init__(**kwargs)\n        self.filename = filename\n\n    def source_filename(self):\n        return self.filename",
  "class KivyFileReporter(coverage.plugin.FileReporter):\n\n    def lines(self):\n        with open(self.filename) as fh:\n            source = fh.read()\n\n        parser = CoverageKVParser(content=source, filename=self.filename)\n        return parser.get_coverage_lines()",
  "def coverage_init(reg, options):\n    reg.add_file_tracer(KivyCoveragePlugin())",
  "def execute_directives(self):\n        # don't actually execute anything\n        pass",
  "def get_coverage_lines(self):\n        lines = set()\n        for parser_prop in walk_parser(self):\n            for line_num, line in enumerate(\n                    parser_prop.value.splitlines(),\n                    start=parser_prop.line + 1):\n                if line.strip():\n                    lines.add(line_num)\n\n        return lines",
  "def file_tracer(self, filename):\n        if filename.endswith('.kv'):\n            return KivyFileTracer(filename=filename)\n        return None",
  "def file_reporter(self, filename):\n        return KivyFileReporter(filename=filename)",
  "def find_executable_files(self, src_dir):\n        for (dirpath, dirnames, filenames) in os.walk(src_dir):\n            for filename in filenames:\n                if filename.endswith('.kv'):\n                    yield os.path.join(dirpath, filename)",
  "def __init__(self, filename, **kwargs):\n        super(KivyFileTracer, self).__init__(**kwargs)\n        self.filename = filename",
  "def source_filename(self):\n        return self.filename",
  "def lines(self):\n        with open(self.filename) as fh:\n            source = fh.read()\n\n        parser = CoverageKVParser(content=source, filename=self.filename)\n        return parser.get_coverage_lines()",
  "def replace(s):\n    item = s.split(' ')\n    rettype = item[1]\n    item = item[2:]\n    for x in item:\n        x = x.strip()\n        if not x or x.startswith('GL'):\n            continue\n        if x.startswith('(GL'):\n            yield '('\n            continue\n        if x.startswith('gl'):\n            prefix = ''\n            if rettype != 'void':\n                prefix = 'return '\n            yield '%scgl.%s' % (prefix, x)\n            continue\n        yield x",
  "def write_special_section(fh, items, header):\n    items = sorted(items, key=lambda x: x[0])\n    if items:\n        fh.write(f'{header}\\n{\"-\" * len(header)}\\n\\n')\n        for n, title in items:\n            fh.write(f'- [:repo:`{n}`]: {title}\\n')\n        fh.write('\\n')",
  "def process_changelog(filename_in, filename_out):\n    if exists(filename_out):\n        raise ValueError(\n            '{} already exists and would be overwritten'.format(filename_out))\n\n    with open(filename_in, 'r') as fh:\n        data = json.load(fh)\n    prs = data[\"data\"][\"repository\"][\"milestone\"][\"pullRequests\"][\"nodes\"]\n\n    bad_pr = False\n    grouped = defaultdict(list)\n    highlighted = []\n    api_breaks = []\n    deprecates = []\n    for item in prs:\n        n = item['number']\n        title = item['title']\n        labels = [label['name'] for label in item['labels']['nodes']]\n        api_break = 'Notes: API-break' in labels\n        highlight = 'Notes: Release-highlight' in labels\n        deprecated = 'Notes: API-deprecation' in labels\n        component_str = 'Component: '\n        components = [\n            label[len(component_str):]\n            for label in labels if label.startswith(component_str)\n        ]\n\n        if not components:\n            print(f'Found no component label for #{n}')\n            bad_pr = True\n            continue\n        if len(components) > 1:\n            print(f'Found more than one component label for #{n}')\n            bad_pr = True\n            continue\n\n        grouped[components[0]].append((n, title))\n        if highlight:\n            highlighted.append((n, title))\n        if api_break:\n            api_breaks.append((n, title))\n        if deprecated:\n            deprecates.append((n, title))\n\n    if bad_pr:\n        raise ValueError(\n            'One or more PRs have no, or more than one component label')\n\n    with open(filename_out, 'w') as fh:\n        write_special_section(fh, highlighted, 'Highlights')\n        write_special_section(fh, deprecates, 'Deprecated')\n        write_special_section(fh, api_breaks, 'Breaking changes')\n\n        for group, items in sorted(grouped.items(), key=lambda x: x[0]):\n            write_special_section(fh, items, group.capitalize())",
  "def iter_filename_info(dir_name):\n    \"\"\"\n    Yield info (dict) of each matching screenshot found walking the\n    directory dir_name. A matching screenshot uses double underscores to\n    separate fields, i.e. path__to__filename__py.png as the screenshot for\n    examples/path/to/filename.py.\n\n    Files not ending with .png are ignored, others are either parsed or\n    yield an error.\n\n    Info fields 'dunder', 'dir', 'file', 'ext', 'source' if not 'error'\n    \"\"\"\n    pattern = re.compile(r'^((.+)__(.+)__([^-]+))\\.png')\n    for t in os.walk(dir_name):\n        for filename in t[2]:\n            if filename.endswith('.png'):\n                m = pattern.match(filename)\n                if m is None:\n                    yield {'error': 'png filename not following screenshot'\n                                    ' pattern: {}'.format(filename)}\n                else:\n                    d = m.group(2).replace('__', sep)\n                    yield {'dunder': m.group(1),\n                           'dir': d,\n                           'file': m.group(3),\n                           'ext': m.group(4),\n                           'source': slash(d, m.group(3) + '.' + m.group(4))\n                           }",
  "def parse_docstring_info(text):\n    ''' parse docstring from text (normal string with '\\n's) and return an info\n    dict. A docstring should the first triple quoted string, have a title\n    followed by a line of equal signs, and then a description at\n    least one sentence long.\n\n    fields are 'docstring', 'title', and 'first_sentence' if not 'error'\n    'first_sentence' is a single line without newlines.\n    '''\n    q = '\\\"\\\"\\\"|\\'\\'\\''\n    p = r'({})\\s+([^\\n]+)\\s+\\=+\\s+(.*?)(\\1)'.format(q)\n    m = re.search(p, text, re.S)\n    if m:\n        comment = m.group(3).replace('\\n', ' ')\n        first_sentence = comment[:comment.find('.') + 1]\n        return {'docstring': m.group(0), 'title': m.group(2),\n                'description': m.group(3), 'first_sentence': first_sentence}\n    else:\n        return {'error': 'Did not find docstring with title at top of file.'}",
  "def iter_docstring_info(dir_name):\n    ''' Iterate over screenshots in directory, yield info from the file\n     name and initial parse of the docstring. Errors are logged, but\n     files with errors are skipped.\n    '''\n    for file_info in iter_filename_info(dir_name):\n        if 'error' in file_info:\n            Logger.error(file_info['error'])\n            continue\n        source = slash(examples_dir, file_info['dir'],\n                       file_info['file'] + '.' + file_info['ext'])\n        if not os.path.exists(source):\n            Logger.error('Screen shot references source code that does '\n                         'not exist:  %s', source)\n            continue\n        with open(source) as f:\n            text = f.read()\n            docstring_info = parse_docstring_info(text)\n            if 'error' in docstring_info:\n                Logger.error(docstring_info['error'] + '  File: ' + source)\n                continue  # don't want to show ugly entries\n            else:\n                file_info.update(docstring_info)\n        yield file_info",
  "def enhance_info_description(info, line_length=79):\n    ''' Using the info['description'], add fields to info.\n\n    info['files'] is the source filename and any filenames referenced by the\n    magic words in the description, e.g. 'the file xxx.py' or\n    'The image this.png'. These are as written in the description, do\n    not allow ../dir notation, and are relative to the source directory.\n\n    info['enhanced_description'] is the description, as an array of\n    paragraphs where each paragraph is an array of lines wrapped to width\n    line_length. This enhanced description include the rst links to\n    the files of info['files'].\n    '''\n\n    # make text a set of long lines, one per paragraph.\n    paragraphs = info['description'].split('\\n\\n')\n    lines = [\n        paragraph.replace('\\n', '$newline$')\n        for paragraph in paragraphs\n    ]\n    text = '\\n'.join(lines)\n\n    info['files'] = [info['file'] + '.' + info['ext']]\n    regex = r'[tT]he (?:file|image) ([\\w\\/]+\\.\\w+)'\n    for name in re.findall(regex, text):\n        if name not in info['files']:\n            info['files'].append(name)\n\n    # add links where the files are referenced\n    folder = '_'.join(info['source'].split(sep)[:-1]) + '_'\n    text = re.sub(r'([tT]he (?:file|image) )([\\w\\/]+\\.\\w+)',\n                  r'\\1:ref:`\\2 <$folder$\\2>`', text)\n    text = text.replace('$folder$', folder)\n\n    # now break up text into array of paragraphs, each an array of lines.\n    lines = [line.replace('$newline$', '\\n') for line in text.split('\\n')]\n    paragraphs = [\n        textwrap.wrap(line, line_length)\n        # ignore wrapping if .. note:: or similar block\n        if not line.startswith(' ') else [line]\n        for line in lines\n    ]\n    info['enhanced_description'] = paragraphs",
  "def get_infos(dir_name):\n    ''' return infos, an array info dicts for each matching screenshot in the\n    dir, sorted by source file name, and adding the field 'num' as he unique\n    order in this array of dicts'.\n\n    '''\n    infos = [i for i in iter_docstring_info(dir_name)]\n    infos.sort(key=lambda x: x['source'])\n    for num, info in enumerate(infos):\n        info['num'] = num\n        enhance_info_description(info)\n    return infos",
  "def make_gallery_page(infos):\n    ''' return string of the rst (Restructured Text) of the gallery page,\n    showing information on all screenshots found.\n    '''\n\n    gallery_top = '''\nGallery\n-------\n\n.. _Tutorials:  ../tutorials-index.html\n\n.. container:: title\n\n    This gallery lets you explore the many examples included with Kivy.\n    Click on any screenshot to see the code.\n\nThis gallery contains:\n\n    * Examples from the examples/ directory that show specific capabilities of\n      different libraries and features of Kivy.\n    * Demonstrations from the examples/demos/ directory that explore many of\n      Kivy's abilities.\n\nThere are more Kivy programs elsewhere:\n\n    * Tutorials_ walks through the development of complete Kivy applications.\n    * Unit tests found in the source code under the subdirectory kivy/tests/\n      can also be useful.\n\nWe hope your journey into learning Kivy is exciting and fun!\n\n'''\n    output = [gallery_top]\n\n    for info in infos:\n        output.append(\n                \"\\n**{title}** (:doc:`{source}<gen__{dunder}>`)\\n\"\n                \"\\n{description}\"\n                \"\\n.. image:: ../images/examples/{dunder}.png\"\n                \"\\n  :width:  216pt\"\n                \"\\n  :align:  left\"\n                \"\\n  :target: gen__{dunder}.html\".format(**info))\n    return \"\\n\".join(output) + \"\\n\"",
  "def make_detail_page(info):\n    ''' return str of the rst text for the detail page of the file in info. '''\n\n    def a(s=''):\n        ''' append formatted s to output, which will be joined into lines '''\n        output.append(s.format(**info))\n\n    output = []\n    a('{title}')\n    a('=' * len(info['title']))\n    a('\\n.. |pic{num}| image:: /images/examples/{dunder}.png'\n      '\\n   :width: 50%'\n      '\\n   :align: middle')\n    a('\\n|pic{num}|')\n    a()\n    for paragraph in info['enhanced_description']:\n        for line in paragraph:\n            a(line)\n        a()\n\n    # include images\n    last_lang = '.py'\n    for fname in info['files']:\n        full_name = slash(info['dir'], fname)\n        ext = re.search(r'\\.\\w+$', fname).group(0)\n        a('\\n.. _`' + full_name.replace(sep, '_') + '`:')\n        # double separator if building on windows (sphinx skips backslash)\n        if '\\\\' in full_name:\n            full_name = full_name.replace(sep, sep * 2)\n\n        if ext in ['.png', '.jpg', '.jpeg']:\n            title = 'Image **' + full_name + '**'\n            a('\\n' + title)\n            a('~' * len(title))\n            a('\\n.. image:: ../../../examples/' + full_name)\n            a('    :align: ' ' center')\n        else:  # code\n            title = 'File **' + full_name + '**'\n            a('\\n' + title)\n            a('~' * len(title))\n            if ext != last_lang and ext != '.txt':\n                a('\\n.. highlight:: ' + ext[1:])\n                a('    :linenothreshold: 3')\n                last_lang = ext\n            # prevent highlight errors with 'none'\n            elif ext == '.txt':\n                a('\\n.. highlight:: none')\n                a('    :linenothreshold: 3')\n                last_lang = ext\n            a('\\n.. include:: ../../../examples/' + full_name)\n            a('    :code:')\n    return '\\n'.join(output) + '\\n'",
  "def write_file(name, s):\n    ''' write the string to the filename '''\n\n    # Make sure all the directories has been created before\n    # trying to write to the file\n    directory = os.path.dirname(name)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n\n    with open(name, 'w') as f:\n        f.write(s)",
  "def make_index(infos):\n    ''' return string of the rst for the gallery's index.rst file. '''\n    start_string = '''\nGallery of Examples\n===================\n\n.. toctree::\n    :maxdepth: 1\n\n    gallery'''\n    output = [start_string]\n    for info in infos:\n        output.append('    gen__{}'.format(info['dunder']))\n    return '\\n'.join(output) + '\\n'",
  "def write_all_rst_pages():\n    ''' Do the main task of writing the gallery,\n    detail, and index rst pages.\n    '''\n    infos = get_infos(screenshots_dir)\n    s = make_gallery_page(infos)\n    write_file(gallery_filename, s)\n\n    for info in infos:\n        s = make_detail_page(info)\n        detail_name = slash(generation_dir,\n                            'gen__{}.rst'.format(info['dunder']))\n        write_file(detail_name, s)\n\n    s = make_index(infos)\n    index_name = slash(generation_dir, 'index.rst')\n    write_file(index_name, s)\n    Logger.info('gallery.py: Created gallery rst documentation pages.')",
  "def a(s=''):\n        ''' append formatted s to output, which will be joined into lines '''\n        output.append(s.format(**info))",
  "def tabs_or_spaces(physical_line, indent_char):\n    r\"\"\"Never mix tabs and spaces.\n\n    The most popular way of indenting Python is with spaces only.  The\n    second-most popular way is with tabs only.  Code indented with a mixture\n    of tabs and spaces should be converted to using spaces exclusively.  When\n    invoking the Python command line interpreter with the -t option, it issues\n    warnings about code that illegally mixes tabs and spaces.  When using -tt\n    these warnings become errors.  These options are highly recommended!\n\n    Okay: if a == 0:\\n        a = 1\\n        b = 1\n    E101: if a == 0:\\n        a = 1\\n\\tb = 1\n    \"\"\"\n    indent = INDENT_REGEX.match(physical_line).group(1)\n    for offset, char in enumerate(indent):\n        if char != indent_char:\n            return offset, \"E101 indentation contains mixed spaces and tabs\"",
  "def tabs_obsolete(physical_line):\n    r\"\"\"For new projects, spaces-only are strongly recommended over tabs.\n\n    Okay: if True:\\n    return\n    W191: if True:\\n\\treturn\n    \"\"\"\n    indent = INDENT_REGEX.match(physical_line).group(1)\n    if '\\t' in indent:\n        return indent.index('\\t'), \"W191 indentation contains tabs\"",
  "def trailing_whitespace(physical_line):\n    r\"\"\"Trailing whitespace is superfluous.\n\n    The warning returned varies on whether the line itself is blank, for easier\n    filtering for those who want to indent their blank lines.\n\n    Okay: spam(1)\\n#\n    W291: spam(1) \\n#\n    W293: class Foo(object):\\n    \\n    bang = 12\n    \"\"\"\n    physical_line = physical_line.rstrip('\\n')    # chr(10), newline\n    physical_line = physical_line.rstrip('\\r')    # chr(13), carriage return\n    physical_line = physical_line.rstrip('\\x0c')  # chr(12), form feed, ^L\n    stripped = physical_line.rstrip(' \\t\\v')\n    if physical_line != stripped:\n        if stripped:\n            return len(stripped), \"W291 trailing whitespace\"\n        else:\n            return 0, \"W293 blank line contains whitespace\"",
  "def trailing_blank_lines(physical_line, lines, line_number, total_lines):\n    r\"\"\"Trailing blank lines are superfluous.\n\n    Okay: spam(1)\n    W391: spam(1)\\n\n\n    However the last line should end with a new line (warning W292).\n    \"\"\"\n    if line_number == total_lines:\n        stripped_last_line = physical_line.rstrip()\n        if not stripped_last_line:\n            return 0, \"W391 blank line at end of file\"\n        if stripped_last_line == physical_line:\n            return len(physical_line), \"W292 no newline at end of file\"",
  "def maximum_line_length(physical_line, max_line_length, multiline, noqa):\n    r\"\"\"Limit all lines to a maximum of 79 characters.\n\n    There are still many devices around that are limited to 80 character\n    lines; plus, limiting windows to 80 characters makes it possible to have\n    several windows side-by-side.  The default wrapping on such devices looks\n    ugly.  Therefore, please limit all lines to a maximum of 79 characters.\n    For flowing long blocks of text (docstrings or comments), limiting the\n    length to 72 characters is recommended.\n\n    Reports error E501.\n    \"\"\"\n    line = physical_line.rstrip()\n    length = len(line)\n    if length > max_line_length and not noqa:\n        # Special case for long URLs in multi-line docstrings or comments,\n        # but still report the error when the 72 first chars are whitespaces.\n        chunks = line.split()\n        if ((len(chunks) == 1 and multiline) or\n            (len(chunks) == 2 and chunks[0] == '#')) and \\\n                len(line) - len(chunks[-1]) < max_line_length - 7:\n            return\n        if hasattr(line, 'decode'):   # Python 2\n            # The line could contain multi-byte characters\n            try:\n                length = len(line.decode('utf-8'))\n            except UnicodeError:\n                pass\n        if length > max_line_length:\n            return (max_line_length, \"E501 line too long \"\n                    \"(%d > %d characters)\" % (length, max_line_length))",
  "def blank_lines(logical_line, blank_lines, indent_level, line_number,\n                blank_before, previous_logical,\n                previous_unindented_logical_line, previous_indent_level,\n                lines):\n    r\"\"\"Separate top-level function and class definitions with two blank lines.\n\n    Method definitions inside a class are separated by a single blank line.\n\n    Extra blank lines may be used (sparingly) to separate groups of related\n    functions.  Blank lines may be omitted between a bunch of related\n    one-liners (e.g. a set of dummy implementations).\n\n    Use blank lines in functions, sparingly, to indicate logical sections.\n\n    Okay: def a():\\n    pass\\n\\n\\ndef b():\\n    pass\n    Okay: def a():\\n    pass\\n\\n\\nasync def b():\\n    pass\n    Okay: def a():\\n    pass\\n\\n\\n# Foo\\n# Bar\\n\\ndef b():\\n    pass\n    Okay: default = 1\\nfoo = 1\n    Okay: classify = 1\\nfoo = 1\n\n    E301: class Foo:\\n    b = 0\\n    def bar():\\n        pass\n    E302: def a():\\n    pass\\n\\ndef b(n):\\n    pass\n    E302: def a():\\n    pass\\n\\nasync def b(n):\\n    pass\n    E303: def a():\\n    pass\\n\\n\\n\\ndef b(n):\\n    pass\n    E303: def a():\\n\\n\\n\\n    pass\n    E304: @decorator\\n\\ndef a():\\n    pass\n    E305: def a():\\n    pass\\na()\n    \"\"\"\n    if line_number < 3 and not previous_logical:\n        return  # Don't expect blank lines before the first line\n    if previous_logical.startswith('@'):\n        if blank_lines:\n            yield 0, \"E304 blank lines found after function decorator\"\n    elif blank_lines > 2 or (indent_level and blank_lines == 2):\n        yield 0, \"E303 too many blank lines (%d)\" % blank_lines\n    elif logical_line.startswith(('def ', 'async def', 'class ', '@')):\n        if indent_level:\n            if not (blank_before or previous_indent_level < indent_level or\n                    DOCSTRING_REGEX.match(previous_logical)):\n                ancestor_level = indent_level\n                nested = False\n                # Search backwards for a def ancestor or tree root (top level).\n                for line in lines[line_number - 2::-1]:\n                    if line.strip() and expand_indent(line) < ancestor_level:\n                        ancestor_level = expand_indent(line)\n                        nested = line.lstrip().startswith('def ')\n                        if nested or ancestor_level == 0:\n                            break\n                if nested:\n                    yield 0, \"E306 expected 1 blank line before a \" \\\n                        \"nested definition, found 0\"\n                else:\n                    yield 0, \"E301 expected 1 blank line, found 0\"\n        elif blank_before != 2:\n            yield 0, \"E302 expected 2 blank lines, found %d\" % blank_before\n    elif (logical_line and not indent_level and blank_before != 2 and\n          previous_unindented_logical_line.startswith(('def ', 'class '))):\n        yield 0, \"E305 expected 2 blank lines after \" \\\n            \"class or function definition, found %d\" % blank_before",
  "def extraneous_whitespace(logical_line):\n    r\"\"\"Avoid extraneous whitespace.\n\n    Avoid extraneous whitespace in these situations:\n    - Immediately inside parentheses, brackets or braces.\n    - Immediately before a comma, semicolon, or colon.\n\n    Okay: spam(ham[1], {eggs: 2})\n    E201: spam( ham[1], {eggs: 2})\n    E201: spam(ham[ 1], {eggs: 2})\n    E201: spam(ham[1], { eggs: 2})\n    E202: spam(ham[1], {eggs: 2} )\n    E202: spam(ham[1 ], {eggs: 2})\n    E202: spam(ham[1], {eggs: 2 })\n\n    E203: if x == 4: print(x, y); x, y = y , x\n    E203: if x == 4: print(x, y); x, y = y, x\n    E203: if x == 4 : print(x, y); x, y = y, x\n    \"\"\"\n    line = logical_line\n    for match in EXTRANEOUS_WHITESPACE_REGEX.finditer(line):\n        text = match.group()\n        char = text.strip()\n        found = match.start()\n        if text == char + ' ':\n            # assert char in '([{'\n            yield found + 1, \"E201 whitespace after '%s'\" % char\n        elif line[found - 1] != ',':\n            code = ('E202' if char in '}])' else 'E203')  # if char in ',;:'\n            yield found, \"%s whitespace before '%s'\" % (code, char)",
  "def whitespace_around_keywords(logical_line):\n    r\"\"\"Avoid extraneous whitespace around keywords.\n\n    Okay: True and False\n    E271: True and  False\n    E272: True  and False\n    E273: True and\\tFalse\n    E274: True\\tand False\n    \"\"\"\n    for match in KEYWORD_REGEX.finditer(logical_line):\n        before, after = match.groups()\n\n        if '\\t' in before:\n            yield match.start(1), \"E274 tab before keyword\"\n        elif len(before) > 1:\n            yield match.start(1), \"E272 multiple spaces before keyword\"\n\n        if '\\t' in after:\n            yield match.start(2), \"E273 tab after keyword\"\n        elif len(after) > 1:\n            yield match.start(2), \"E271 multiple spaces after keyword\"",
  "def missing_whitespace_after_import_keyword(logical_line):\n    r\"\"\"Multiple imports in form from x import (a, b, c) should have space\n    between import statement and parenthesised name list.\n\n    Okay: from foo import (bar, baz)\n    E275: from foo import(bar, baz)\n    E275: from importable.module import(bar, baz)\n    \"\"\"\n    line = logical_line\n    indicator = ' import('\n    if line.startswith('from '):\n        found = line.find(indicator)\n        if -1 < found:\n            pos = found + len(indicator) - 1\n            yield pos, \"E275 missing whitespace after keyword\"",
  "def missing_whitespace(logical_line):\n    r\"\"\"Each comma, semicolon or colon should be followed by whitespace.\n\n    Okay: [a, b]\n    Okay: (3,)\n    Okay: a[1:4]\n    Okay: a[:4]\n    Okay: a[1:]\n    Okay: a[1:4:2]\n    E231: ['a','b']\n    E231: foo(bar,baz)\n    E231: [{'a':'b'}]\n    \"\"\"\n    line = logical_line\n    for index in range(len(line) - 1):\n        char = line[index]\n        if char in ',;:' and line[index + 1] not in WHITESPACE:\n            before = line[:index]\n            if char == ':' and before.count('[') > before.count(']') and \\\n                    before.rfind('{') < before.rfind('['):\n                continue  # Slice syntax, no space required\n            if char == ',' and line[index + 1] == ')':\n                continue  # Allow tuple with only one element: (3,)\n            yield index, \"E231 missing whitespace after '%s'\" % char",
  "def indentation(logical_line, previous_logical, indent_char,\n                indent_level, previous_indent_level):\n    r\"\"\"Use 4 spaces per indentation level.\n\n    For really old code that you don't want to mess up, you can continue to\n    use 8-space tabs.\n\n    Okay: a = 1\n    Okay: if a == 0:\\n    a = 1\n    E111:   a = 1\n    E114:   # a = 1\n\n    Okay: for item in items:\\n    pass\n    E112: for item in items:\\npass\n    E115: for item in items:\\n# Hi\\n    pass\n\n    Okay: a = 1\\nb = 2\n    E113: a = 1\\n    b = 2\n    E116: a = 1\\n    # b = 2\n    \"\"\"\n    c = 0 if logical_line else 3\n    tmpl = \"E11%d %s\" if logical_line else \"E11%d %s (comment)\"\n    if indent_level % 4:\n        yield 0, tmpl % (1 + c, \"indentation is not a multiple of four\")\n    indent_expect = previous_logical.endswith(':')\n    if indent_expect and indent_level <= previous_indent_level:\n        yield 0, tmpl % (2 + c, \"expected an indented block\")\n    elif not indent_expect and indent_level > previous_indent_level:\n        yield 0, tmpl % (3 + c, \"unexpected indentation\")",
  "def continued_indentation(logical_line, tokens, indent_level, hang_closing,\n                          indent_char, noqa, verbose):\n    r\"\"\"Continuation lines indentation.\n\n    Continuation lines should align wrapped elements either vertically\n    using Python's implicit line joining inside parentheses, brackets\n    and braces, or using a hanging indent.\n\n    When using a hanging indent these considerations should be applied:\n    - there should be no arguments on the first line, and\n    - further indentation should be used to clearly distinguish itself as a\n      continuation line.\n\n    Okay: a = (\\n)\n    E123: a = (\\n    )\n\n    Okay: a = (\\n    42)\n    E121: a = (\\n   42)\n    E122: a = (\\n42)\n    E123: a = (\\n    42\\n    )\n    E124: a = (24,\\n     42\\n)\n    E125: if (\\n    b):\\n    pass\n    E126: a = (\\n        42)\n    E127: a = (24,\\n      42)\n    E128: a = (24,\\n    42)\n    E129: if (a or\\n    b):\\n    pass\n    E131: a = (\\n    42\\n 24)\n    \"\"\"\n    first_row = tokens[0][2][0]\n    nrows = 1 + tokens[-1][2][0] - first_row\n    if noqa or nrows == 1:\n        return\n\n    # indent_next tells us whether the next block is indented; assuming\n    # that it is indented by 4 spaces, then we should not allow 4-space\n    # indents on the final continuation line; in turn, some other\n    # indents are allowed to have an extra 4 spaces.\n    indent_next = logical_line.endswith(':')\n\n    row = depth = 0\n    valid_hangs = (4,) if indent_char != '\\t' else (4, 8)\n    # remember how many brackets were opened on each line\n    parens = [0] * nrows\n    # relative indents of physical lines\n    rel_indent = [0] * nrows\n    # for each depth, collect a list of opening rows\n    open_rows = [[0]]\n    # for each depth, memorize the hanging indentation\n    hangs = [None]\n    # visual indents\n    indent_chances = {}\n    last_indent = tokens[0][2]\n    visual_indent = None\n    last_token_multiline = False\n    # for each depth, memorize the visual indent column\n    indent = [last_indent[1]]\n    if verbose >= 3:\n        print(\">>> \" + tokens[0][4].rstrip())\n\n    for token_type, text, start, end, line in tokens:\n\n        newline = row < start[0] - first_row\n        if newline:\n            row = start[0] - first_row\n            newline = not last_token_multiline and token_type not in NEWLINE\n\n        if newline:\n            # this is the beginning of a continuation line.\n            last_indent = start\n            if verbose >= 3:\n                print(\"... \" + line.rstrip())\n\n            # record the initial indent.\n            rel_indent[row] = expand_indent(line) - indent_level\n\n            # identify closing bracket\n            close_bracket = (token_type == tokenize.OP and text in ']})')\n\n            # is the indent relative to an opening bracket line?\n            for open_row in reversed(open_rows[depth]):\n                hang = rel_indent[row] - rel_indent[open_row]\n                hanging_indent = hang in valid_hangs\n                if hanging_indent:\n                    break\n            if hangs[depth]:\n                hanging_indent = (hang == hangs[depth])\n            # is there any chance of visual indent?\n            visual_indent = (not close_bracket and hang > 0 and\n                             indent_chances.get(start[1]))\n\n            if close_bracket and indent[depth]:\n                # closing bracket for visual indent\n                if start[1] != indent[depth]:\n                    yield (start, \"E124 closing bracket does not match \"\n                           \"visual indentation\")\n            elif close_bracket and not hang:\n                # closing bracket matches indentation of opening bracket's line\n                if hang_closing:\n                    yield start, \"E133 closing bracket is missing indentation\"\n            elif indent[depth] and start[1] < indent[depth]:\n                if visual_indent is not True:\n                    # visual indent is broken\n                    yield (start, \"E128 continuation line \"\n                           \"under-indented for visual indent\")\n            elif hanging_indent or (indent_next and rel_indent[row] == 8):\n                # hanging indent is verified\n                if close_bracket and not hang_closing:\n                    yield (start, \"E123 closing bracket does not match \"\n                           \"indentation of opening bracket's line\")\n                hangs[depth] = hang\n            elif visual_indent is True:\n                # visual indent is verified\n                indent[depth] = start[1]\n            elif visual_indent in (text, str):\n                # ignore token lined up with matching one from a previous line\n                pass\n            else:\n                # indent is broken\n                if hang <= 0:\n                    error = \"E122\", \"missing indentation or outdented\"\n                elif indent[depth]:\n                    error = \"E127\", \"over-indented for visual indent\"\n                elif not close_bracket and hangs[depth]:\n                    error = \"E131\", \"unaligned for hanging indent\"\n                else:\n                    hangs[depth] = hang\n                    if hang > 4:\n                        error = \"E126\", \"over-indented for hanging indent\"\n                    else:\n                        error = \"E121\", \"under-indented for hanging indent\"\n                yield start, \"%s continuation line %s\" % error\n\n        # look for visual indenting\n        if (parens[row] and\n                token_type not in (tokenize.NL, tokenize.COMMENT) and\n                not indent[depth]):\n            indent[depth] = start[1]\n            indent_chances[start[1]] = True\n            if verbose >= 4:\n                print(\"bracket depth %s indent to %s\" % (depth, start[1]))\n        # deal with implicit string concatenation\n        elif (token_type in (tokenize.STRING, tokenize.COMMENT) or\n              text in ('u', 'ur', 'b', 'br')):\n            indent_chances[start[1]] = str\n        # special case for the \"if\" statement because len(\"if (\") == 4\n        elif not indent_chances and not row and not depth and text == 'if':\n            indent_chances[end[1] + 1] = True\n        elif text == ':' and line[end[1]:].isspace():\n            open_rows[depth].append(row)\n\n        # keep track of bracket depth\n        if token_type == tokenize.OP:\n            if text in '([{':\n                depth += 1\n                indent.append(0)\n                hangs.append(None)\n                if len(open_rows) == depth:\n                    open_rows.append([])\n                open_rows[depth].append(row)\n                parens[row] += 1\n                if verbose >= 4:\n                    print(\"bracket depth %s seen, col %s, visual min = %s\" %\n                          (depth, start[1], indent[depth]))\n            elif text in ')]}' and depth > 0:\n                # parent indents should not be more than this one\n                prev_indent = indent.pop() or last_indent[1]\n                hangs.pop()\n                for d in range(depth):\n                    if indent[d] > prev_indent:\n                        indent[d] = 0\n                for ind in list(indent_chances):\n                    if ind >= prev_indent:\n                        del indent_chances[ind]\n                del open_rows[depth + 1:]\n                depth -= 1\n                if depth:\n                    indent_chances[indent[depth]] = True\n                for idx in range(row, -1, -1):\n                    if parens[idx]:\n                        parens[idx] -= 1\n                        break\n            assert len(indent) == depth + 1\n            if start[1] not in indent_chances:\n                # allow lining up tokens\n                indent_chances[start[1]] = text\n\n        last_token_multiline = (start[0] != end[0])\n        if last_token_multiline:\n            rel_indent[end[0] - first_row] = rel_indent[row]\n\n    if indent_next and expand_indent(line) == indent_level + 4:\n        pos = (start[0], indent[0] + 4)\n        if visual_indent:\n            code = \"E129 visually indented line\"\n        else:\n            code = \"E125 continuation line\"\n        yield pos, \"%s with same indent as next logical line\" % code",
  "def whitespace_before_parameters(logical_line, tokens):\n    r\"\"\"Avoid extraneous whitespace.\n\n    Avoid extraneous whitespace in the following situations:\n    - before the open parenthesis that starts the argument list of a\n      function call.\n    - before the open parenthesis that starts an indexing or slicing.\n\n    Okay: spam(1)\n    E211: spam (1)\n\n    Okay: dict['key'] = list[index]\n    E211: dict ['key'] = list[index]\n    E211: dict['key'] = list [index]\n    \"\"\"\n    prev_type, prev_text, __, prev_end, __ = tokens[0]\n    for index in range(1, len(tokens)):\n        token_type, text, start, end, __ = tokens[index]\n        if (token_type == tokenize.OP and\n            text in '([' and\n            start != prev_end and\n            (prev_type == tokenize.NAME or prev_text in '}])') and\n            # Syntax \"class A (B):\" is allowed, but avoid it\n            (index < 2 or tokens[index - 2][1] != 'class') and\n                # Allow \"return (a.foo for a in range(5))\"\n                not keyword.iskeyword(prev_text)):\n            yield prev_end, \"E211 whitespace before '%s'\" % text\n        prev_type = token_type\n        prev_text = text\n        prev_end = end",
  "def whitespace_around_operator(logical_line):\n    r\"\"\"Avoid extraneous whitespace around an operator.\n\n    Okay: a = 12 + 3\n    E221: a = 4  + 5\n    E222: a = 4 +  5\n    E223: a = 4\\t+ 5\n    E224: a = 4 +\\t5\n    \"\"\"\n    for match in OPERATOR_REGEX.finditer(logical_line):\n        before, after = match.groups()\n\n        if '\\t' in before:\n            yield match.start(1), \"E223 tab before operator\"\n        elif len(before) > 1:\n            yield match.start(1), \"E221 multiple spaces before operator\"\n\n        if '\\t' in after:\n            yield match.start(2), \"E224 tab after operator\"\n        elif len(after) > 1:\n            yield match.start(2), \"E222 multiple spaces after operator\"",
  "def missing_whitespace_around_operator(logical_line, tokens):\n    r\"\"\"Surround operators with a single space on either side.\n\n    - Always surround these binary operators with a single space on\n      either side: assignment (=), augmented assignment (+=, -= etc.),\n      comparisons (==, <, >, !=, <=, >=, in, not in, is, is not),\n      Booleans (and, or, not).\n\n    - If operators with different priorities are used, consider adding\n      whitespace around the operators with the lowest priorities.\n\n    Okay: i = i + 1\n    Okay: submitted += 1\n    Okay: x = x * 2 - 1\n    Okay: hypot2 = x * x + y * y\n    Okay: c = (a + b) * (a - b)\n    Okay: foo(bar, key='word', *args, **kwargs)\n    Okay: alpha[:-i]\n\n    E225: i=i+1\n    E225: submitted +=1\n    E225: x = x /2 - 1\n    E225: z = x **y\n    E226: c = (a+b) * (a-b)\n    E226: hypot2 = x*x + y*y\n    E227: c = a|b\n    E228: msg = fmt%(errno, errmsg)\n    \"\"\"\n    parens = 0\n    need_space = False\n    prev_type = tokenize.OP\n    prev_text = prev_end = None\n    for token_type, text, start, end, line in tokens:\n        if token_type in SKIP_COMMENTS:\n            continue\n        if text in ('(', 'lambda'):\n            parens += 1\n        elif text == ')':\n            parens -= 1\n        if need_space:\n            if start != prev_end:\n                # Found a (probably) needed space\n                if need_space is not True and not need_space[1]:\n                    yield (need_space[0],\n                           \"E225 missing whitespace around operator\")\n                need_space = False\n            elif text == '>' and prev_text in ('<', '-'):\n                # Tolerate the \"<>\" operator, even if running Python 3\n                # Deal with Python 3's annotated return value \"->\"\n                pass\n            else:\n                if need_space is True or need_space[1]:\n                    # A needed trailing space was not found\n                    yield prev_end, \"E225 missing whitespace around operator\"\n                elif prev_text != '**':\n                    code, optype = 'E226', 'arithmetic'\n                    if prev_text == '%':\n                        code, optype = 'E228', 'modulo'\n                    elif prev_text not in ARITHMETIC_OP:\n                        code, optype = 'E227', 'bitwise or shift'\n                    yield (need_space[0], \"%s missing whitespace \"\n                           \"around %s operator\" % (code, optype))\n                need_space = False\n        elif token_type == tokenize.OP and prev_end is not None:\n            if text == '=' and parens:\n                # Allow keyword args or defaults: foo(bar=None).\n                pass\n            elif text in WS_NEEDED_OPERATORS:\n                need_space = True\n            elif text in UNARY_OPERATORS:\n                # Check if the operator is being used as a binary operator\n                # Allow unary operators: -123, -x, +1.\n                # Allow argument unpacking: foo(*args, **kwargs).\n                if (prev_text in '}])' if prev_type == tokenize.OP\n                        else prev_text not in KEYWORDS):\n                    need_space = None\n            elif text in WS_OPTIONAL_OPERATORS:\n                need_space = None\n\n            if need_space is None:\n                # Surrounding space is optional, but ensure that\n                # trailing space matches opening space\n                need_space = (prev_end, start != prev_end)\n            elif need_space and start == prev_end:\n                # A needed opening space was not found\n                yield prev_end, \"E225 missing whitespace around operator\"\n                need_space = False\n        prev_type = token_type\n        prev_text = text\n        prev_end = end",
  "def whitespace_around_comma(logical_line):\n    r\"\"\"Avoid extraneous whitespace after a comma or a colon.\n\n    Note: these checks are disabled by default\n\n    Okay: a = (1, 2)\n    E241: a = (1,  2)\n    E242: a = (1,\\t2)\n    \"\"\"\n    line = logical_line\n    for m in WHITESPACE_AFTER_COMMA_REGEX.finditer(line):\n        found = m.start() + 1\n        if '\\t' in m.group():\n            yield found, \"E242 tab after '%s'\" % m.group()[0]\n        else:\n            yield found, \"E241 multiple spaces after '%s'\" % m.group()[0]",
  "def whitespace_around_named_parameter_equals(logical_line, tokens):\n    r\"\"\"Don't use spaces around the '=' sign in function arguments.\n\n    Don't use spaces around the '=' sign when used to indicate a\n    keyword argument or a default parameter value.\n\n    Okay: def complex(real, imag=0.0):\n    Okay: return magic(r=real, i=imag)\n    Okay: boolean(a == b)\n    Okay: boolean(a != b)\n    Okay: boolean(a <= b)\n    Okay: boolean(a >= b)\n    Okay: def foo(arg: int = 42):\n    Okay: async def foo(arg: int = 42):\n\n    E251: def complex(real, imag = 0.0):\n    E251: return magic(r = real, i = imag)\n    \"\"\"\n    parens = 0\n    no_space = False\n    prev_end = None\n    annotated_func_arg = False\n    in_def = logical_line.startswith(('def', 'async def'))\n    message = \"E251 unexpected spaces around keyword / parameter equals\"\n    for token_type, text, start, end, line in tokens:\n        if token_type == tokenize.NL:\n            continue\n        if no_space:\n            no_space = False\n            if start != prev_end:\n                yield (prev_end, message)\n        if token_type == tokenize.OP:\n            if text in '([':\n                parens += 1\n            elif text in ')]':\n                parens -= 1\n            elif in_def and text == ':' and parens == 1:\n                annotated_func_arg = True\n            elif parens and text == ',' and parens == 1:\n                annotated_func_arg = False\n            elif parens and text == '=' and not annotated_func_arg:\n                no_space = True\n                if start != prev_end:\n                    yield (prev_end, message)\n            if not parens:\n                annotated_func_arg = False\n\n        prev_end = end",
  "def whitespace_before_comment(logical_line, tokens):\n    r\"\"\"Separate inline comments by at least two spaces.\n\n    An inline comment is a comment on the same line as a statement.  Inline\n    comments should be separated by at least two spaces from the statement.\n    They should start with a # and a single space.\n\n    Each line of a block comment starts with a # and a single space\n    (unless it is indented text inside the comment).\n\n    Okay: x = x + 1  # Increment x\n    Okay: x = x + 1    # Increment x\n    Okay: # Block comment\n    E261: x = x + 1 # Increment x\n    E262: x = x + 1  #Increment x\n    E262: x = x + 1  #  Increment x\n    E265: #Block comment\n    E266: ### Block comment\n    \"\"\"\n    prev_end = (0, 0)\n    for token_type, text, start, end, line in tokens:\n        if token_type == tokenize.COMMENT:\n            inline_comment = line[:start[1]].strip()\n            if inline_comment:\n                if prev_end[0] == start[0] and start[1] < prev_end[1] + 2:\n                    yield (prev_end,\n                           \"E261 at least two spaces before inline comment\")\n            symbol, sp, comment = text.partition(' ')\n            bad_prefix = symbol not in '#:' and (symbol.lstrip('#')[:1] or '#')\n            if inline_comment:\n                if bad_prefix or comment[:1] in WHITESPACE:\n                    yield start, \"E262 inline comment should start with '# '\"\n            elif bad_prefix and (bad_prefix != '!' or start[0] > 1):\n                if bad_prefix != '#':\n                    yield start, \"E265 block comment should start with '# '\"\n                elif comment:\n                    yield start, \"E266 too many leading '#' for block comment\"\n        elif token_type != tokenize.NL:\n            prev_end = end",
  "def imports_on_separate_lines(logical_line):\n    r\"\"\"Place imports on separate lines.\n\n    Okay: import os\\nimport sys\n    E401: import sys, os\n\n    Okay: from subprocess import Popen, PIPE\n    Okay: from myclas import MyClass\n    Okay: from foo.bar.yourclass import YourClass\n    Okay: import myclass\n    Okay: import foo.bar.yourclass\n    \"\"\"\n    line = logical_line\n    if line.startswith('import '):\n        found = line.find(',')\n        if -1 < found and ';' not in line[:found]:\n            yield found, \"E401 multiple imports on one line\"",
  "def module_imports_on_top_of_file(\n        logical_line, indent_level, checker_state, noqa):\n    r\"\"\"Place imports at the top of the file.\n\n    Always put imports at the top of the file, just after any module comments\n    and docstrings, and before module globals and constants.\n\n    Okay: import os\n    Okay: # this is a comment\\nimport os\n    Okay: '''this is a module docstring'''\\nimport os\n    Okay: r'''this is a module docstring'''\\nimport os\n    Okay: try:\\n    import x\\nexcept:\\n    pass\\nelse:\\n    pass\\nimport y\n    Okay: try:\\n    import x\\nexcept:\\n    pass\\nfinally:\\n    pass\\nimport y\n    E402: a=1\\nimport os\n    E402: 'One string'\\n\"Two string\"\\nimport os\n    E402: a=1\\nfrom sys import x\n\n    Okay: if x:\\n    import os\n    \"\"\"\n    def is_string_literal(line):\n        if line[0] in 'uUbB':\n            line = line[1:]\n        if line and line[0] in 'rR':\n            line = line[1:]\n        return line and (line[0] == '\"' or line[0] == \"'\")\n\n    allowed_try_keywords = ('try', 'except', 'else', 'finally')\n\n    if indent_level:  # Allow imports in conditional statements or functions\n        return\n    if not logical_line:  # Allow empty lines or comments\n        return\n    if noqa:\n        return\n    line = logical_line\n    if line.startswith('import ') or line.startswith('from '):\n        if checker_state.get('seen_non_imports', False):\n            yield 0, \"E402 module level import not at top of file\"\n    elif any(line.startswith(kw) for kw in allowed_try_keywords):\n        # Allow try, except, else, finally keywords intermixed with imports in\n        # order to support conditional importing\n        return\n    elif is_string_literal(line):\n        # The first literal is a docstring, allow it. Otherwise, report error.\n        if checker_state.get('seen_docstring', False):\n            checker_state['seen_non_imports'] = True\n        else:\n            checker_state['seen_docstring'] = True\n    else:\n        checker_state['seen_non_imports'] = True",
  "def compound_statements(logical_line):\n    r\"\"\"Compound statements (on the same line) are generally discouraged.\n\n    While sometimes it's okay to put an if/for/while with a small body\n    on the same line, never do this for multi-clause statements.\n    Also avoid folding such long lines!\n\n    Always use a def statement instead of an assignment statement that\n    binds a lambda expression directly to a name.\n\n    Okay: if foo == 'blah':\\n    do_blah_thing()\n    Okay: do_one()\n    Okay: do_two()\n    Okay: do_three()\n\n    E701: if foo == 'blah': do_blah_thing()\n    E701: for x in lst: total += x\n    E701: while t < 10: t = delay()\n    E701: if foo == 'blah': do_blah_thing()\n    E701: else: do_non_blah_thing()\n    E701: try: something()\n    E701: finally: cleanup()\n    E701: if foo == 'blah': one(); two(); three()\n    E702: do_one(); do_two(); do_three()\n    E703: do_four();  # useless semicolon\n    E704: def f(x): return 2*x\n    E731: f = lambda x: 2*x\n    \"\"\"\n    line = logical_line\n    last_char = len(line) - 1\n    found = line.find(':')\n    prev_found = 0\n    counts = dict((char, 0) for char in '{}[]()')\n    while -1 < found < last_char:\n        update_counts(line[prev_found:found], counts)\n        if ((counts['{'] <= counts['}'] and   # {'a': 1} (dict)\n             counts['['] <= counts[']'] and   # [1:2] (slice)\n             counts['('] <= counts[')'])):    # (annotation)\n            lambda_kw = LAMBDA_REGEX.search(line, 0, found)\n            if lambda_kw:\n                before = line[:lambda_kw.start()].rstrip()\n                if before[-1:] == '=' and isidentifier(before[:-1].strip()):\n                    yield 0, (\"E731 do not assign a lambda expression, use a \"\n                              \"def\")\n                break\n            if line.startswith('def '):\n                yield 0, \"E704 multiple statements on one line (def)\"\n            else:\n                yield found, \"E701 multiple statements on one line (colon)\"\n        prev_found = found\n        found = line.find(':', found + 1)\n    found = line.find(';')\n    while -1 < found:\n        if found < last_char:\n            yield found, \"E702 multiple statements on one line (semicolon)\"\n        else:\n            yield found, \"E703 statement ends with a semicolon\"\n        found = line.find(';', found + 1)",
  "def explicit_line_join(logical_line, tokens):\n    r\"\"\"Avoid explicit line join between brackets.\n\n    The preferred way of wrapping long lines is by using Python's implied line\n    continuation inside parentheses, brackets and braces.  Long lines can be\n    broken over multiple lines by wrapping expressions in parentheses.  These\n    should be used in preference to using a backslash for line continuation.\n\n    E502: aaa = [123, \\\\n       123]\n    E502: aaa = (\"bbb \" \\\\n       \"ccc\")\n\n    Okay: aaa = [123,\\n       123]\n    Okay: aaa = (\"bbb \"\\n       \"ccc\")\n    Okay: aaa = \"bbb \" \\\\n    \"ccc\"\n    Okay: aaa = 123  # \\\\\n    \"\"\"\n    prev_start = prev_end = parens = 0\n    comment = False\n    backslash = None\n    for token_type, text, start, end, line in tokens:\n        if token_type == tokenize.COMMENT:\n            comment = True\n        if start[0] != prev_start and parens and backslash and not comment:\n            yield backslash, \"E502 the backslash is redundant between brackets\"\n        if end[0] != prev_end:\n            if line.rstrip('\\r\\n').endswith('\\\\'):\n                backslash = (end[0], len(line.splitlines()[-1]) - 1)\n            else:\n                backslash = None\n            prev_start = prev_end = end[0]\n        else:\n            prev_start = start[0]\n        if token_type == tokenize.OP:\n            if text in '([{':\n                parens += 1\n            elif text in ')]}':\n                parens -= 1",
  "def break_around_binary_operator(logical_line, tokens):\n    r\"\"\"\n    Avoid breaks before binary operators.\n\n    The preferred place to break around a binary operator is after the\n    operator, not before it.\n\n    W503: (width == 0\\n + height == 0)\n    W503: (width == 0\\n and height == 0)\n\n    Okay: (width == 0 +\\n height == 0)\n    Okay: foo(\\n    -x)\n    Okay: foo(x\\n    [])\n    Okay: x = '''\\n''' + ''\n    Okay: foo(x,\\n    -y)\n    Okay: foo(x,  # comment\\n    -y)\n    Okay: var = (1 &\\n       ~2)\n    Okay: var = (1 /\\n       -2)\n    Okay: var = (1 +\\n       -1 +\\n       -2)\n    \"\"\"\n    def is_binary_operator(token_type, text):\n        # The % character is strictly speaking a binary operator, but the\n        # common usage seems to be to put it next to the format parameters,\n        # after a line break.\n        return ((token_type == tokenize.OP or text in ['and', 'or']) and\n                text not in \"()[]{},:.;@=%~\")\n\n    line_break = False\n    unary_context = True\n    # Previous non-newline token types and text\n    previous_token_type = None\n    previous_text = None\n    for token_type, text, start, end, line in tokens:\n        if token_type == tokenize.COMMENT:\n            continue\n        if ('\\n' in text or '\\r' in text) and token_type != tokenize.STRING:\n            line_break = True\n        else:\n            if (is_binary_operator(token_type, text) and line_break and\n                    not unary_context and\n                    not is_binary_operator(previous_token_type,\n                                           previous_text)):\n                yield start, \"W503 line break before binary operator\"\n            unary_context = text in '([{,;'\n            line_break = False\n            previous_token_type = token_type\n            previous_text = text",
  "def comparison_to_singleton(logical_line, noqa):\n    r\"\"\"Comparison to singletons should use \"is\" or \"is not\".\n\n    Comparisons to singletons like None should always be done\n    with \"is\" or \"is not\", never the equality operators.\n\n    Okay: if arg is not None:\n    E711: if arg != None:\n    E711: if None == arg:\n    E712: if arg == True:\n    E712: if False == arg:\n\n    Also, beware of writing if x when you really mean if x is not None --\n    e.g. when testing whether a variable or argument that defaults to None was\n    set to some other value.  The other value might have a type (such as a\n    container) that could be false in a boolean context!\n    \"\"\"\n    match = not noqa and COMPARE_SINGLETON_REGEX.search(logical_line)\n    if match:\n        singleton = match.group(1) or match.group(3)\n        same = (match.group(2) == '==')\n\n        msg = \"'if cond is %s:'\" % (('' if same else 'not ') + singleton)\n        if singleton in ('None',):\n            code = 'E711'\n        else:\n            code = 'E712'\n            nonzero = ((singleton == 'True' and same) or\n                       (singleton == 'False' and not same))\n            msg += \" or 'if %scond:'\" % ('' if nonzero else 'not ')\n        yield match.start(2), (\"%s comparison to %s should be %s\" %\n                               (code, singleton, msg))",
  "def comparison_negative(logical_line):\n    r\"\"\"Negative comparison should be done using \"not in\" and \"is not\".\n\n    Okay: if x not in y:\\n    pass\n    Okay: assert (X in Y or X is Z)\n    Okay: if not (X in Y):\\n    pass\n    Okay: zz = x is not y\n    E713: Z = not X in Y\n    E713: if not X.B in Y:\\n    pass\n    E714: if not X is Y:\\n    pass\n    E714: Z = not X.B is Y\n    \"\"\"\n    match = COMPARE_NEGATIVE_REGEX.search(logical_line)\n    if match:\n        pos = match.start(1)\n        if match.group(2) == 'in':\n            yield pos, \"E713 test for membership should be 'not in'\"\n        else:\n            yield pos, \"E714 test for object identity should be 'is not'\"",
  "def comparison_type(logical_line, noqa):\n    r\"\"\"Object type comparisons should always use isinstance().\n\n    Do not compare types directly.\n\n    Okay: if isinstance(obj, int):\n    E721: if type(obj) is type(1):\n\n    When checking if an object is a string, keep in mind that it might be a\n    unicode string too! In Python 2.3, str and unicode have a common base\n    class, basestring, so you can do:\n\n    Okay: if isinstance(obj, basestring):\n    Okay: if type(a1) is type(b1):\n    \"\"\"\n    match = COMPARE_TYPE_REGEX.search(logical_line)\n    if match and not noqa:\n        inst = match.group(1)\n        if inst and isidentifier(inst) and inst not in SINGLETONS:\n            return  # Allow comparison for types which are not obvious\n        yield match.start(), \"E721 do not compare types, use 'isinstance()'\"",
  "def ambiguous_identifier(logical_line, tokens):\n    r\"\"\"Never use the characters 'l', 'O', or 'I' as variable names.\n\n    In some fonts, these characters are indistinguishable from the numerals\n    one and zero. When tempted to use 'l', use 'L' instead.\n\n    Okay: L = 0\n    Okay: o = 123\n    Okay: i = 42\n    E741: l = 0\n    E741: O = 123\n    E741: I = 42\n\n    Variables can be bound in several other contexts, including class and\n    function definitions, 'global' and 'nonlocal' statements, exception\n    handlers, and 'with' statements.\n\n    Okay: except AttributeError as o:\n    Okay: with lock as L:\n    E741: except AttributeError as O:\n    E741: with lock as l:\n    E741: global I\n    E741: nonlocal l\n    E742: class I(object):\n    E743: def l(x):\n    \"\"\"\n    idents_to_avoid = ('l', 'O', 'I')\n    prev_type, prev_text, prev_start, prev_end, __ = tokens[0]\n    for token_type, text, start, end, line in tokens[1:]:\n        ident = pos = None\n        # identifiers on the lhs of an assignment operator\n        if token_type == tokenize.OP and '=' in text:\n            if prev_text in idents_to_avoid:\n                ident = prev_text\n                pos = prev_start\n        # identifiers bound to a value with 'as', 'global', or 'nonlocal'\n        if prev_text in ('as', 'global', 'nonlocal'):\n            if text in idents_to_avoid:\n                ident = text\n                pos = start\n        if prev_text == 'class':\n            if text in idents_to_avoid:\n                yield start, \"E742 ambiguous class definition '%s'\" % text\n        if prev_text == 'def':\n            if text in idents_to_avoid:\n                yield start, \"E743 ambiguous function definition '%s'\" % text\n        if ident:\n            yield pos, \"E741 ambiguous variable name '%s'\" % ident\n        prev_text = text\n        prev_start = start",
  "def python_3000_has_key(logical_line, noqa):\n    r\"\"\"The {}.has_key() method is removed in Python 3: use the 'in' operator.\n\n    Okay: if \"alph\" in d:\\n    print(d[\"alph\"])\n    W601: assert d.has_key('alph')\n    \"\"\"\n    pos = logical_line.find('.has_key(')\n    if pos > -1 and not noqa:\n        yield pos, \"W601 .has_key() is deprecated, use 'in'\"",
  "def python_3000_raise_comma(logical_line):\n    r\"\"\"When raising an exception, use \"raise ValueError('message')\".\n\n    The older form is removed in Python 3.\n\n    Okay: raise DummyError(\"Message\")\n    W602: raise DummyError, \"Message\"\n    \"\"\"\n    match = RAISE_COMMA_REGEX.match(logical_line)\n    if match and not RERAISE_COMMA_REGEX.match(logical_line):\n        yield match.end() - 1, \"W602 deprecated form of raising exception\"",
  "def python_3000_not_equal(logical_line):\n    r\"\"\"New code should always use != instead of <>.\n\n    The older syntax is removed in Python 3.\n\n    Okay: if a != 'no':\n    W603: if a <> 'no':\n    \"\"\"\n    pos = logical_line.find('<>')\n    if pos > -1:\n        yield pos, \"W603 '<>' is deprecated, use '!='\"",
  "def python_3000_backticks(logical_line):\n    r\"\"\"Use repr() instead of backticks in Python 3.\n\n    Okay: val = repr(1 + 2)\n    W604: val = `1 + 2`\n    \"\"\"\n    pos = logical_line.find('`')\n    if pos > -1:\n        yield pos, \"W604 backticks are deprecated, use 'repr()'\"",
  "def expand_indent(line):\n    r\"\"\"Return the amount of indentation.\n\n    Tabs are expanded to the next multiple of 8.\n\n    >>> expand_indent('    ')\n    4\n    >>> expand_indent('\\t')\n    8\n    >>> expand_indent('       \\t')\n    8\n    >>> expand_indent('        \\t')\n    16\n    \"\"\"\n    if '\\t' not in line:\n        return len(line) - len(line.lstrip())\n    result = 0\n    for char in line:\n        if char == '\\t':\n            result = result // 8 * 8 + 8\n        elif char == ' ':\n            result += 1\n        else:\n            break\n    return result",
  "def mute_string(text):\n    \"\"\"Replace contents with 'xxx' to prevent syntax matching.\n\n    >>> mute_string('\"abc\"')\n    '\"xxx\"'\n    >>> mute_string(\"'''abc'''\")\n    \"'''xxx'''\"\n    >>> mute_string(\"r'abc'\")\n    \"r'xxx'\"\n    \"\"\"\n    # String modifiers (e.g. u or r)\n    start = text.index(text[-1]) + 1\n    end = len(text) - 1\n    # Triple quotes\n    if text[-3:] in ('\"\"\"', \"'''\"):\n        start += 2\n        end -= 2\n    return text[:start] + 'x' * (end - start) + text[end:]",
  "def parse_udiff(diff, patterns=None, parent='.'):\n    \"\"\"Return a dictionary of matching lines.\"\"\"\n    # For each file of the diff, the entry key is the filename,\n    # and the value is a set of row numbers to consider.\n    rv = {}\n    path = nrows = None\n    for line in diff.splitlines():\n        if nrows:\n            if line[:1] != '-':\n                nrows -= 1\n            continue\n        if line[:3] == '@@ ':\n            hunk_match = HUNK_REGEX.match(line)\n            (row, nrows) = [int(g or '1') for g in hunk_match.groups()]\n            rv[path].update(range(row, row + nrows))\n        elif line[:3] == '+++':\n            path = line[4:].split('\\t', 1)[0]\n            if path[:2] == 'b/':\n                path = path[2:]\n            rv[path] = set()\n    return dict([(os.path.join(parent, path), rows)\n                 for (path, rows) in rv.items()\n                 if rows and filename_match(path, patterns)])",
  "def normalize_paths(value, parent=os.curdir):\n    \"\"\"Parse a comma-separated list of paths.\n\n    Return a list of absolute paths.\n    \"\"\"\n    if not value:\n        return []\n    if isinstance(value, list):\n        return value\n    paths = []\n    for path in value.split(','):\n        path = path.strip()\n        if '/' in path:\n            path = os.path.abspath(os.path.join(parent, path))\n        paths.append(path.rstrip('/'))\n    return paths",
  "def filename_match(filename, patterns, default=True):\n    \"\"\"Check if patterns contains a pattern that matches filename.\n\n    If patterns is unspecified, this always returns True.\n    \"\"\"\n    if not patterns:\n        return default\n    return any(fnmatch(filename, pattern) for pattern in patterns)",
  "def update_counts(s, counts):\n    r\"\"\"Adds one to the counts of each appearance of characters in s,\n        for characters in counts\"\"\"\n    for char in s:\n        if char in counts:\n            counts[char] += 1",
  "def _is_eol_token(token):\n    return token[0] in NEWLINE or token[4][token[3][1]:].lstrip() == '\\\\\\n'",
  "def _get_parameters(function):\n    if sys.version_info >= (3, 3):\n        return [parameter.name\n                for parameter\n                in inspect.signature(function).parameters.values()\n                if parameter.kind == parameter.POSITIONAL_OR_KEYWORD]\n    else:\n        return inspect.getargspec(function)[0]",
  "def register_check(check, codes=None):\n    \"\"\"Register a new check object.\"\"\"\n    def _add_check(check, kind, codes, args):\n        if check in _checks[kind]:\n            _checks[kind][check][0].extend(codes or [])\n        else:\n            _checks[kind][check] = (codes or [''], args)\n    if inspect.isfunction(check):\n        args = _get_parameters(check)\n        if args and args[0] in ('physical_line', 'logical_line'):\n            if codes is None:\n                codes = ERRORCODE_REGEX.findall(check.__doc__ or '')\n            _add_check(check, args[0], codes, args)\n    elif inspect.isclass(check):\n        if _get_parameters(check.__init__)[:2] == ['self', 'tree']:\n            _add_check(check, 'tree', codes, None)",
  "def init_checks_registry():\n    \"\"\"Register all globally visible functions.\n\n    The first argument name is either 'physical_line' or 'logical_line'.\n    \"\"\"\n    mod = inspect.getmodule(register_check)\n    for (name, function) in inspect.getmembers(mod, inspect.isfunction):\n        register_check(function)",
  "class Checker(object):\n    \"\"\"Load a Python source file, tokenize it, check coding style.\"\"\"\n\n    def __init__(self, filename=None, lines=None,\n                 options=None, report=None, **kwargs):\n        if options is None:\n            options = StyleGuide(kwargs).options\n        else:\n            assert not kwargs\n        self._io_error = None\n        self._physical_checks = options.physical_checks\n        self._logical_checks = options.logical_checks\n        self._ast_checks = options.ast_checks\n        self.max_line_length = options.max_line_length\n        self.multiline = False  # in a multiline string?\n        self.hang_closing = options.hang_closing\n        self.verbose = options.verbose\n        self.filename = filename\n        # Dictionary where a checker can store its custom state.\n        self._checker_states = {}\n        if filename is None:\n            self.filename = 'stdin'\n            self.lines = lines or []\n        elif filename == '-':\n            self.filename = 'stdin'\n            self.lines = stdin_get_value().splitlines(True)\n        elif lines is None:\n            try:\n                self.lines = readlines(filename)\n            except IOError:\n                (exc_type, exc) = sys.exc_info()[:2]\n                self._io_error = '%s: %s' % (exc_type.__name__, exc)\n                self.lines = []\n        else:\n            self.lines = lines\n        if self.lines:\n            ord0 = ord(self.lines[0][0])\n            if ord0 in (0xef, 0xfeff):  # Strip the UTF-8 BOM\n                if ord0 == 0xfeff:\n                    self.lines[0] = self.lines[0][1:]\n                elif self.lines[0][:3] == '\\xef\\xbb\\xbf':\n                    self.lines[0] = self.lines[0][3:]\n        self.report = report or options.report\n        self.report_error = self.report.error\n        self.noqa = False\n\n    def report_invalid_syntax(self):\n        \"\"\"Check if the syntax is valid.\"\"\"\n        (exc_type, exc) = sys.exc_info()[:2]\n        if len(exc.args) > 1:\n            offset = exc.args[1]\n            if len(offset) > 2:\n                offset = offset[1:3]\n        else:\n            offset = (1, 0)\n        self.report_error(offset[0], offset[1] or 0,\n                          'E901 %s: %s' % (exc_type.__name__, exc.args[0]),\n                          self.report_invalid_syntax)\n\n    def readline(self):\n        \"\"\"Get the next line from the input buffer.\"\"\"\n        if self.line_number >= self.total_lines:\n            return ''\n        line = self.lines[self.line_number]\n        self.line_number += 1\n        if self.indent_char is None and line[:1] in WHITESPACE:\n            self.indent_char = line[0]\n        return line\n\n    def run_check(self, check, argument_names):\n        \"\"\"Run a check plugin.\"\"\"\n        arguments = []\n        for name in argument_names:\n            arguments.append(getattr(self, name))\n        return check(*arguments)\n\n    def init_checker_state(self, name, argument_names):\n        \"\"\"Prepare custom state for the specific checker plugin.\"\"\"\n        if 'checker_state' in argument_names:\n            self.checker_state = self._checker_states.setdefault(name, {})\n\n    def check_physical(self, line):\n        \"\"\"Run all physical checks on a raw input line.\"\"\"\n        self.physical_line = line\n        for name, check, argument_names in self._physical_checks:\n            self.init_checker_state(name, argument_names)\n            result = self.run_check(check, argument_names)\n            if result is not None:\n                (offset, text) = result\n                self.report_error(self.line_number, offset, text, check)\n                if text[:4] == 'E101':\n                    self.indent_char = line[0]\n\n    def build_tokens_line(self):\n        \"\"\"Build a logical line from tokens.\"\"\"\n        logical = []\n        comments = []\n        length = 0\n        prev_row = prev_col = mapping = None\n        for token_type, text, start, end, line in self.tokens:\n            if token_type in SKIP_TOKENS:\n                continue\n            if not mapping:\n                mapping = [(0, start)]\n            if token_type == tokenize.COMMENT:\n                comments.append(text)\n                continue\n            if token_type == tokenize.STRING:\n                text = mute_string(text)\n            if prev_row:\n                (start_row, start_col) = start\n                if prev_row != start_row:    # different row\n                    prev_text = self.lines[prev_row - 1][prev_col - 1]\n                    if prev_text == ',' or (prev_text not in '{[(' and\n                                            text not in '}])'):\n                        text = ' ' + text\n                elif prev_col != start_col:  # different column\n                    text = line[prev_col:start_col] + text\n            logical.append(text)\n            length += len(text)\n            mapping.append((length, end))\n            (prev_row, prev_col) = end\n        self.logical_line = ''.join(logical)\n        self.noqa = comments and noqa(''.join(comments))\n        return mapping\n\n    def check_logical(self):\n        \"\"\"Build a line from tokens and run all logical checks on it.\"\"\"\n        self.report.increment_logical_line()\n        mapping = self.build_tokens_line()\n\n        if not mapping:\n            return\n\n        (start_row, start_col) = mapping[0][1]\n        start_line = self.lines[start_row - 1]\n        self.indent_level = expand_indent(start_line[:start_col])\n        if self.blank_before < self.blank_lines:\n            self.blank_before = self.blank_lines\n        if self.verbose >= 2:\n            print(self.logical_line[:80].rstrip())\n        for name, check, argument_names in self._logical_checks:\n            if self.verbose >= 4:\n                print('   ' + name)\n            self.init_checker_state(name, argument_names)\n            for offset, text in self.run_check(check, argument_names) or ():\n                if not isinstance(offset, tuple):\n                    for token_offset, pos in mapping:\n                        if offset <= token_offset:\n                            break\n                    offset = (pos[0], pos[1] + offset - token_offset)\n                self.report_error(offset[0], offset[1], text, check)\n        if self.logical_line:\n            self.previous_indent_level = self.indent_level\n            self.previous_logical = self.logical_line\n            if not self.indent_level:\n                self.previous_unindented_logical_line = self.logical_line\n        self.blank_lines = 0\n        self.tokens = []\n\n    def check_ast(self):\n        \"\"\"Build the file's AST and run all AST checks.\"\"\"\n        try:\n            tree = compile(''.join(self.lines), '', 'exec', PyCF_ONLY_AST)\n        except (ValueError, SyntaxError, TypeError):\n            return self.report_invalid_syntax()\n        for name, cls, __ in self._ast_checks:\n            checker = cls(tree, self.filename)\n            for lineno, offset, text, check in checker.run():\n                if not self.lines or not noqa(self.lines[lineno - 1]):\n                    self.report_error(lineno, offset, text, check)\n\n    def generate_tokens(self):\n        \"\"\"Tokenize the file, run physical line checks and yield tokens.\"\"\"\n        if self._io_error:\n            self.report_error(1, 0, 'E902 %s' % self._io_error, readlines)\n        tokengen = tokenize.generate_tokens(self.readline)\n        try:\n            for token in tokengen:\n                if token[2][0] > self.total_lines:\n                    return\n                self.noqa = token[4] and noqa(token[4])\n                self.maybe_check_physical(token)\n                yield token\n        except (SyntaxError, tokenize.TokenError):\n            self.report_invalid_syntax()\n\n    def maybe_check_physical(self, token):\n        \"\"\"If appropriate (based on token), check current physical line(s).\"\"\"\n        # Called after every token, but act only on end of line.\n        if _is_eol_token(token):\n            # Obviously, a newline token ends a single physical line.\n            self.check_physical(token[4])\n        elif token[0] == tokenize.STRING and '\\n' in token[1]:\n            # Less obviously, a string that contains newlines is a\n            # multiline string, either triple-quoted or with internal\n            # newlines backslash-escaped. Check every physical line in the\n            # string *except* for the last one: its newline is outside of\n            # the multiline string, so we consider it a regular physical\n            # line, and will check it like any other physical line.\n            #\n            # Subtleties:\n            # - we don't *completely* ignore the last line; if it contains\n            #   the magical \"# noqa\" comment, we disable all physical\n            #   checks for the entire multiline string\n            # - have to wind self.line_number back because initially it\n            #   points to the last line of the string, and we want\n            #   check_physical() to give accurate feedback\n            if noqa(token[4]):\n                return\n            self.multiline = True\n            self.line_number = token[2][0]\n            for line in token[1].split('\\n')[:-1]:\n                self.check_physical(line + '\\n')\n                self.line_number += 1\n            self.multiline = False\n\n    def check_all(self, expected=None, line_offset=0):\n        \"\"\"Run all checks on the input file.\"\"\"\n        self.report.init_file(self.filename, self.lines, expected, line_offset)\n        self.total_lines = len(self.lines)\n        if self._ast_checks:\n            self.check_ast()\n        self.line_number = 0\n        self.indent_char = None\n        self.indent_level = self.previous_indent_level = 0\n        self.previous_logical = ''\n        self.previous_unindented_logical_line = ''\n        self.tokens = []\n        self.blank_lines = self.blank_before = 0\n        parens = 0\n        for token in self.generate_tokens():\n            self.tokens.append(token)\n            token_type, text = token[0:2]\n            if self.verbose >= 3:\n                if token[2][0] == token[3][0]:\n                    pos = '[%s:%s]' % (token[2][1] or '', token[3][1])\n                else:\n                    pos = 'l.%s' % token[3][0]\n                print('l.%s\\t%s\\t%s\\t%r' %\n                      (token[2][0], pos, tokenize.tok_name[token[0]], text))\n            if token_type == tokenize.COMMENT or token_type == tokenize.STRING:\n                for sre in re.finditer(r\"[:.;,]   ?[A-Za-z]\", text):\n                    pos = sre.span()[0]\n                    part = text[:pos]\n                    line = token[2][0] + part.count('\\n')\n                    offset = 0 if part.count('\\n') > 0 else token[2][1]\n                    col = offset + pos - part.rfind('\\n') + 1\n                    if sre.group(0)[0] == '.':\n                        self.report_error(line, col,\n                           'E289 Too many spaces after period. Use only one.',\n                           check=None)\n                    elif sre.group(0)[0] == ',':\n                        self.report_error(line, col,\n                           'E288 Too many spaces after comma. Use only one.',\n                           check=None)\n                    else:\n                        self.report_error(line, col,\n                           'E287 Too many spaces after punctuation. '\n                           'Use only one.',\n                           check=None)\n            if token_type == tokenize.OP:\n                if text in '([{':\n                    parens += 1\n                elif text in '}])':\n                    parens -= 1\n            elif not parens:\n                if token_type in NEWLINE:\n                    if token_type == tokenize.NEWLINE:\n                        self.check_logical()\n                        self.blank_before = 0\n                    elif len(self.tokens) == 1:\n                        # The physical line contains only this token.\n                        self.blank_lines += 1\n                        del self.tokens[0]\n                    else:\n                        self.check_logical()\n                elif COMMENT_WITH_NL and token_type == tokenize.COMMENT:\n                    if len(self.tokens) == 1:\n                        # The comment also ends a physical line\n                        token = list(token)\n                        token[1] = text.rstrip('\\r\\n')\n                        token[3] = (token[2][0], token[2][1] + len(token[1]))\n                        self.tokens = [tuple(token)]\n                        self.check_logical()\n        if self.tokens:\n            self.check_physical(self.lines[-1])\n            self.check_logical()\n        if self.blank_lines > 1:\n            self.report_error(token[2][0], 0,\n                'E389 File ends in multiple blank lines',\n                check=None)\n        return self.report.get_file_results()",
  "class BaseReport(object):\n    \"\"\"Collect the results of the checks.\"\"\"\n\n    print_filename = False\n\n    def __init__(self, options):\n        self._benchmark_keys = options.benchmark_keys\n        self._ignore_code = options.ignore_code\n        # Results\n        self.elapsed = 0\n        self.total_errors = 0\n        self.counters = dict.fromkeys(self._benchmark_keys, 0)\n        self.messages = {}\n\n    def start(self):\n        \"\"\"Start the timer.\"\"\"\n        self._start_time = time.time()\n\n    def stop(self):\n        \"\"\"Stop the timer.\"\"\"\n        self.elapsed = time.time() - self._start_time\n\n    def init_file(self, filename, lines, expected, line_offset):\n        \"\"\"Signal a new file.\"\"\"\n        self.filename = filename\n        self.lines = lines\n        self.expected = expected or ()\n        self.line_offset = line_offset\n        self.file_errors = 0\n        self.counters['files'] += 1\n        self.counters['physical lines'] += len(lines)\n\n    def increment_logical_line(self):\n        \"\"\"Signal a new logical line.\"\"\"\n        self.counters['logical lines'] += 1\n\n    def error(self, line_number, offset, text, check):\n        \"\"\"Report an error, according to options.\"\"\"\n        code = text[:4]\n        if self._ignore_code(code):\n            return\n        if code in self.counters:\n            self.counters[code] += 1\n        else:\n            self.counters[code] = 1\n            self.messages[code] = text[5:]\n        # Don't care about expected errors or warnings\n        if code in self.expected:\n            return\n        if self.print_filename and not self.file_errors:\n            print(self.filename)\n        self.file_errors += 1\n        self.total_errors += 1\n        return code\n\n    def get_file_results(self):\n        \"\"\"Return the count of errors and warnings for this file.\"\"\"\n        return self.file_errors\n\n    def get_count(self, prefix=''):\n        \"\"\"Return the total count of errors and warnings.\"\"\"\n        return sum([self.counters[key]\n                    for key in self.messages if key.startswith(prefix)])\n\n    def get_statistics(self, prefix=''):\n        \"\"\"Get statistics for message codes that start with the prefix.\n\n        prefix='' matches all errors and warnings\n        prefix='E' matches all errors\n        prefix='W' matches all warnings\n        prefix='E4' matches all errors that have to do with imports\n        \"\"\"\n        return ['%-7s %s %s' % (self.counters[key], key, self.messages[key])\n                for key in sorted(self.messages) if key.startswith(prefix)]\n\n    def print_statistics(self, prefix=''):\n        \"\"\"Print overall statistics (number of errors and warnings).\"\"\"\n        for line in self.get_statistics(prefix):\n            print(line)\n\n    def print_benchmark(self):\n        \"\"\"Print benchmark numbers.\"\"\"\n        print('%-7.2f %s' % (self.elapsed, 'seconds elapsed'))\n        if self.elapsed:\n            for key in self._benchmark_keys:\n                print('%-7d %s per second (%d total)' %\n                      (self.counters[key] / self.elapsed, key,\n                       self.counters[key]))",
  "class FileReport(BaseReport):\n    \"\"\"Collect the results of the checks and print only the filenames.\"\"\"\n\n    print_filename = True",
  "class StandardReport(BaseReport):\n    \"\"\"Collect and print the results of the checks.\"\"\"\n\n    def __init__(self, options):\n        super(StandardReport, self).__init__(options)\n        self._fmt = REPORT_FORMAT.get(options.format.lower(),\n                                      options.format)\n        self._repeat = options.repeat\n        self._show_source = options.show_source\n        self._show_pep8 = options.show_pep8\n\n    def init_file(self, filename, lines, expected, line_offset):\n        \"\"\"Signal a new file.\"\"\"\n        self._deferred_print = []\n        return super(StandardReport, self).init_file(\n            filename, lines, expected, line_offset)\n\n    def error(self, line_number, offset, text, check):\n        \"\"\"Report an error, according to options.\"\"\"\n        code = super(StandardReport, self).error(line_number, offset,\n                                                 text, check)\n        if code and (self.counters[code] == 1 or self._repeat):\n            self._deferred_print.append(\n                (line_number, offset, code, text[5:], check.__doc__))\n        return code\n\n    def get_file_results(self):\n        \"\"\"Print the result and return the overall count for this file.\"\"\"\n        self._deferred_print.sort()\n        for line_number, offset, code, text, doc in self._deferred_print:\n            print(self._fmt % {\n                'path': self.filename,\n                'row': self.line_offset + line_number, 'col': offset + 1,\n                'code': code, 'text': text,\n            })\n            if self._show_source:\n                if line_number > len(self.lines):\n                    line = ''\n                else:\n                    line = self.lines[line_number - 1]\n                print(line.rstrip())\n                print(re.sub(r'\\S', ' ', line[:offset]) + '^')\n            if self._show_pep8 and doc:\n                print('    ' + doc.strip())\n\n            # stdout is block buffered when not stdout.isatty().\n            # line can be broken where buffer boundary since other processes\n            # write to same file.\n            # flush() after print() to avoid buffer boundary.\n            # Typical buffer size is 8192. line written safely when\n            # len(line) < 8192.\n            sys.stdout.flush()\n        return self.file_errors",
  "class DiffReport(StandardReport):\n    \"\"\"Collect and print the results for the changed lines only.\"\"\"\n\n    def __init__(self, options):\n        super(DiffReport, self).__init__(options)\n        self._selected = options.selected_lines\n\n    def error(self, line_number, offset, text, check):\n        if line_number not in self._selected[self.filename]:\n            return\n        return super(DiffReport, self).error(line_number, offset, text, check)",
  "class StyleGuide(object):\n    \"\"\"Initialize a PEP-8 instance with few options.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # build options from the command line\n        self.checker_class = kwargs.pop('checker_class', Checker)\n        parse_argv = kwargs.pop('parse_argv', False)\n        config_file = kwargs.pop('config_file', False)\n        parser = kwargs.pop('parser', None)\n        # build options from dict\n        options_dict = dict(*args, **kwargs)\n        arglist = None if parse_argv else options_dict.get('paths', None)\n        options, self.paths = process_options(\n            arglist, parse_argv, config_file, parser)\n        if options_dict:\n            options.__dict__.update(options_dict)\n            if 'paths' in options_dict:\n                self.paths = options_dict['paths']\n\n        self.runner = self.input_file\n        self.options = options\n\n        if not options.reporter:\n            options.reporter = BaseReport if options.quiet else StandardReport\n\n        options.select = tuple(options.select or ())\n        if not (options.select or options.ignore or\n                options.testsuite or options.doctest) and DEFAULT_IGNORE:\n            # The default choice: ignore controversial checks\n            options.ignore = tuple(DEFAULT_IGNORE.split(','))\n        else:\n            # Ignore all checks which are not explicitly selected\n            options.ignore = ('',) if options.select else tuple(options.ignore)\n        options.benchmark_keys = BENCHMARK_KEYS[:]\n        options.ignore_code = self.ignore_code\n        options.physical_checks = self.get_checks('physical_line')\n        options.logical_checks = self.get_checks('logical_line')\n        options.ast_checks = self.get_checks('tree')\n        self.init_report()\n\n    def init_report(self, reporter=None):\n        \"\"\"Initialize the report instance.\"\"\"\n        self.options.report = (reporter or self.options.reporter)(self.options)\n        return self.options.report\n\n    def check_files(self, paths=None):\n        \"\"\"Run all checks on the paths.\"\"\"\n        if paths is None:\n            paths = self.paths\n        report = self.options.report\n        runner = self.runner\n        report.start()\n        try:\n            for path in paths:\n                if os.path.isdir(path):\n                    self.input_dir(path)\n                elif not self.excluded(path):\n                    runner(path)\n        except KeyboardInterrupt:\n            print('... stopped')\n        report.stop()\n        return report\n\n    def input_file(self, filename, lines=None, expected=None, line_offset=0):\n        \"\"\"Run all checks on a Python source file.\"\"\"\n        if self.options.verbose:\n            print('checking %s' % filename)\n        fchecker = self.checker_class(\n            filename, lines=lines, options=self.options)\n        return fchecker.check_all(expected=expected, line_offset=line_offset)\n\n    def input_dir(self, dirname):\n        \"\"\"Check all files in this directory and all subdirectories.\"\"\"\n        dirname = dirname.rstrip('/')\n        if self.excluded(dirname):\n            return 0\n        counters = self.options.report.counters\n        verbose = self.options.verbose\n        filepatterns = self.options.filename\n        runner = self.runner\n        for root, dirs, files in os.walk(dirname):\n            if verbose:\n                print('directory ' + root)\n            counters['directories'] += 1\n            for subdir in sorted(dirs):\n                if self.excluded(subdir, root):\n                    dirs.remove(subdir)\n            for filename in sorted(files):\n                # contain a pattern that matches?\n                if ((filename_match(filename, filepatterns) and\n                     not self.excluded(filename, root))):\n                    runner(os.path.join(root, filename))\n\n    def excluded(self, filename, parent=None):\n        \"\"\"Check if the file should be excluded.\n\n        Check if 'options.exclude' contains a pattern that matches filename.\n        \"\"\"\n        if not self.options.exclude:\n            return False\n        basename = os.path.basename(filename)\n        if filename_match(basename, self.options.exclude):\n            return True\n        if parent:\n            filename = os.path.join(parent, filename)\n        filename = os.path.abspath(filename)\n        return filename_match(filename, self.options.exclude)\n\n    def ignore_code(self, code):\n        \"\"\"Check if the error code should be ignored.\n\n        If 'options.select' contains a prefix of the error code,\n        return False.  Else, if 'options.ignore' contains a prefix of\n        the error code, return True.\n        \"\"\"\n        if len(code) < 4 and any(s.startswith(code)\n                                 for s in self.options.select):\n            return False\n        return (code.startswith(self.options.ignore) and\n                not code.startswith(self.options.select))\n\n    def get_checks(self, argument_name):\n        \"\"\"Get all the checks for this category.\n\n        Find all globally visible functions where the first argument name\n        starts with argument_name and which contain selected tests.\n        \"\"\"\n        checks = []\n        for check, attrs in _checks[argument_name].items():\n            (codes, args) = attrs\n            if any(not (code and self.ignore_code(code)) for code in codes):\n                checks.append((check.__name__, check, args))\n        return sorted(checks)",
  "def get_parser(prog='pycodestyle', version=__version__):\n    \"\"\"Create the parser for the program.\"\"\"\n    parser = OptionParser(prog=prog, version=version,\n                          usage=\"%prog [options] input ...\")\n    parser.config_options = [\n        'exclude', 'filename', 'select', 'ignore', 'max-line-length',\n        'hang-closing', 'count', 'format', 'quiet', 'show-pep8',\n        'show-source', 'statistics', 'verbose']\n    parser.add_option('-v', '--verbose', default=0, action='count',\n                      help=\"print status messages, or debug with -vv\")\n    parser.add_option('-q', '--quiet', default=0, action='count',\n                      help=\"report only file names, or nothing with -qq\")\n    parser.add_option('-r', '--repeat', default=True, action='store_true',\n                      help=\"(obsolete) show all occurrences of the same error\")\n    parser.add_option('--first', action='store_false', dest='repeat',\n                      help=\"show first occurrence of each error\")\n    parser.add_option('--exclude', metavar='patterns', default=DEFAULT_EXCLUDE,\n                      help=\"exclude files or directories which match these \"\n                           \"comma separated patterns (default: %default)\")\n    parser.add_option('--filename', metavar='patterns', default='*.py',\n                      help=\"when parsing directories, only check filenames \"\n                           \"matching these comma separated patterns \"\n                           \"(default: %default)\")\n    parser.add_option('--select', metavar='errors', default='',\n                      help=\"select errors and warnings (e.g. E,W6)\")\n    parser.add_option('--ignore', metavar='errors', default='',\n                      help=\"skip errors and warnings (e.g. E4,W) \"\n                           \"(default: %s)\" % DEFAULT_IGNORE)\n    parser.add_option('--show-source', action='store_true',\n                      help=\"show source code for each error\")\n    parser.add_option('--show-pep8', action='store_true',\n                      help=\"show text of PEP 8 for each error \"\n                           \"(implies --first)\")\n    parser.add_option('--statistics', action='store_true',\n                      help=\"count errors and warnings\")\n    parser.add_option('--count', action='store_true',\n                      help=\"print total number of errors and warnings \"\n                           \"to standard error and set exit code to 1 if \"\n                           \"total is not null\")\n    parser.add_option('--max-line-length', type='int', metavar='n',\n                      default=MAX_LINE_LENGTH,\n                      help=\"set maximum allowed line length \"\n                           \"(default: %default)\")\n    parser.add_option('--hang-closing', action='store_true',\n                      help=\"hang closing bracket instead of matching \"\n                           \"indentation of opening bracket's line\")\n    parser.add_option('--format', metavar='format', default='default',\n                      help=\"set the error format [default|pylint|<custom>]\")\n    parser.add_option('--diff', action='store_true',\n                      help=\"report changes only within line number ranges in \"\n                           \"the unified diff received on STDIN\")\n    group = parser.add_option_group(\"Testing Options\")\n    if os.path.exists(TESTSUITE_PATH):\n        group.add_option('--testsuite', metavar='dir',\n                         help=\"run regression tests from dir\")\n        group.add_option('--doctest', action='store_true',\n                         help=\"run doctest on myself\")\n    group.add_option('--benchmark', action='store_true',\n                     help=\"measure processing speed\")\n    return parser",
  "def read_config(options, args, arglist, parser):\n    \"\"\"Read and parse configurations.\n\n    If a config file is specified on the command line with the \"--config\"\n    option, then only it is used for configuration.\n\n    Otherwise, the user configuration (~/.config/pycodestyle) and any local\n    configurations in the current directory or above will be merged together\n    (in that order) using the read method of ConfigParser.\n    \"\"\"\n    config = RawConfigParser()\n\n    cli_conf = options.config\n\n    local_dir = os.curdir\n\n    if USER_CONFIG and os.path.isfile(USER_CONFIG):\n        if options.verbose:\n            print('user configuration: %s' % USER_CONFIG)\n        config.read(USER_CONFIG)\n\n    parent = tail = args and os.path.abspath(os.path.commonprefix(args))\n    while tail:\n        if config.read(os.path.join(parent, fn) for fn in PROJECT_CONFIG):\n            local_dir = parent\n            if options.verbose:\n                print('local configuration: in %s' % parent)\n            break\n        (parent, tail) = os.path.split(parent)\n\n    if cli_conf and os.path.isfile(cli_conf):\n        if options.verbose:\n            print('cli configuration: %s' % cli_conf)\n        config.read(cli_conf)\n\n    pycodestyle_section = None\n    if config.has_section(parser.prog):\n        pycodestyle_section = parser.prog\n    elif config.has_section('pep8'):\n        pycodestyle_section = 'pep8'  # Deprecated\n        warnings.warn('[pep8] section is deprecated. Use [pycodestyle].')\n\n    if pycodestyle_section:\n        option_list = dict([(o.dest, o.type or o.action)\n                            for o in parser.option_list])\n\n        # First, read the default values\n        (new_options, __) = parser.parse_args([])\n\n        # Second, parse the configuration\n        for opt in config.options(pycodestyle_section):\n            if opt.replace('_', '-') not in parser.config_options:\n                print(\"  unknown option '%s' ignored\" % opt)\n                continue\n            if options.verbose > 1:\n                print(\"  %s = %s\" % (opt,\n                                     config.get(pycodestyle_section, opt)))\n            normalized_opt = opt.replace('-', '_')\n            opt_type = option_list[normalized_opt]\n            if opt_type in ('int', 'count'):\n                value = config.getint(pycodestyle_section, opt)\n            elif opt_type in ('store_true', 'store_false'):\n                value = config.getboolean(pycodestyle_section, opt)\n            else:\n                value = config.get(pycodestyle_section, opt)\n                if normalized_opt == 'exclude':\n                    value = normalize_paths(value, local_dir)\n            setattr(new_options, normalized_opt, value)\n\n        # Third, overwrite with the command-line options\n        (options, __) = parser.parse_args(arglist, values=new_options)\n    options.doctest = options.testsuite = False\n    return options",
  "def process_options(arglist=None, parse_argv=False, config_file=None,\n                    parser=None):\n    \"\"\"Process options passed either via arglist or via command line args.\n\n    Passing in the ``config_file`` parameter allows other tools, such as flake8\n    to specify their own options to be processed in pycodestyle.\n    \"\"\"\n    if not parser:\n        parser = get_parser()\n    if not parser.has_option('--config'):\n        group = parser.add_option_group(\"Configuration\", description=(\n            \"The project options are read from the [%s] section of the \"\n            \"tox.ini file or the setup.cfg file located in any parent folder \"\n            \"of the path(s) being processed.  Allowed options are: %s.\" %\n            (parser.prog, ', '.join(parser.config_options))))\n        group.add_option('--config', metavar='path', default=config_file,\n                         help=\"user config file location\")\n    # Don't read the command line if the module is used as a library.\n    if not arglist and not parse_argv:\n        arglist = []\n    # If parse_argv is True and arglist is None, arguments are\n    # parsed from the command line (sys.argv)\n    (options, args) = parser.parse_args(arglist)\n    options.reporter = None\n\n    if options.ensure_value('testsuite', False):\n        args.append(options.testsuite)\n    elif not options.ensure_value('doctest', False):\n        if parse_argv and not args:\n            if options.diff or any(os.path.exists(name)\n                                   for name in PROJECT_CONFIG):\n                args = ['.']\n            else:\n                parser.error('input not specified')\n        options = read_config(options, args, arglist, parser)\n        options.reporter = parse_argv and options.quiet == 1 and FileReport\n\n    options.filename = _parse_multi_options(options.filename)\n    options.exclude = normalize_paths(options.exclude)\n    options.select = _parse_multi_options(options.select)\n    options.ignore = _parse_multi_options(options.ignore)\n\n    if options.diff:\n        options.reporter = DiffReport\n        stdin = stdin_get_value()\n        options.selected_lines = parse_udiff(stdin, options.filename, args[0])\n        args = sorted(options.selected_lines)\n\n    return options, args",
  "def _parse_multi_options(options, split_token=','):\n    r\"\"\"Split and strip and discard empties.\n\n    Turns the following:\n\n    A,\n    B,\n\n    into [\"A\", \"B\"]\n    \"\"\"\n    if options:\n        return [o.strip() for o in options.split(split_token) if o.strip()]\n    else:\n        return options",
  "def _main():\n    \"\"\"Parse options and run checks on Python source.\"\"\"\n    import signal\n\n    # Handle \"Broken pipe\" gracefully\n    try:\n        signal.signal(signal.SIGPIPE, lambda signum, frame: sys.exit(1))\n    except AttributeError:\n        pass    # not supported on Windows\n\n    style_guide = StyleGuide(parse_argv=True)\n    options = style_guide.options\n\n    if options.doctest or options.testsuite:\n        from testsuite.support import run_tests\n        report = run_tests(style_guide)\n    else:\n        report = style_guide.check_files()\n\n    if options.statistics:\n        report.print_statistics()\n\n    if options.benchmark:\n        report.print_benchmark()\n\n    if options.testsuite and not options.quiet:\n        report.print_results()\n\n    if report.total_errors:\n        if options.count:\n            sys.stderr.write(str(report.total_errors) + '\\n')\n        sys.exit(1)",
  "def is_string_literal(line):\n        if line[0] in 'uUbB':\n            line = line[1:]\n        if line and line[0] in 'rR':\n            line = line[1:]\n        return line and (line[0] == '\"' or line[0] == \"'\")",
  "def is_binary_operator(token_type, text):\n        # The % character is strictly speaking a binary operator, but the\n        # common usage seems to be to put it next to the format parameters,\n        # after a line break.\n        return ((token_type == tokenize.OP or text in ['and', 'or']) and\n                text not in \"()[]{},:.;@=%~\")",
  "def readlines(filename):\n        \"\"\"Read the source code.\"\"\"\n        with open(filename, 'rU') as f:\n            return f.readlines()",
  "def readlines(filename):\n        \"\"\"Read the source code.\"\"\"\n        try:\n            with open(filename, 'rb') as f:\n                (coding, lines) = tokenize.detect_encoding(f.readline)\n                f = TextIOWrapper(f, coding, line_buffering=True)\n                return [line.decode(coding) for line in lines] + f.readlines()\n        except (LookupError, SyntaxError, UnicodeError):\n            # Fall back if file encoding is improperly declared\n            with open(filename, encoding='latin-1') as f:\n                return f.readlines()",
  "def stdin_get_value():\n        \"\"\"Read the value from stdin.\"\"\"\n        return TextIOWrapper(sys.stdin.buffer, errors='ignore').read()",
  "def _is_eol_token(token, _eol_token=_is_eol_token):\n        return _eol_token(token) or (token[0] == tokenize.COMMENT and\n                                     token[1] == token[4])",
  "def _add_check(check, kind, codes, args):\n        if check in _checks[kind]:\n            _checks[kind][check][0].extend(codes or [])\n        else:\n            _checks[kind][check] = (codes or [''], args)",
  "def __init__(self, filename=None, lines=None,\n                 options=None, report=None, **kwargs):\n        if options is None:\n            options = StyleGuide(kwargs).options\n        else:\n            assert not kwargs\n        self._io_error = None\n        self._physical_checks = options.physical_checks\n        self._logical_checks = options.logical_checks\n        self._ast_checks = options.ast_checks\n        self.max_line_length = options.max_line_length\n        self.multiline = False  # in a multiline string?\n        self.hang_closing = options.hang_closing\n        self.verbose = options.verbose\n        self.filename = filename\n        # Dictionary where a checker can store its custom state.\n        self._checker_states = {}\n        if filename is None:\n            self.filename = 'stdin'\n            self.lines = lines or []\n        elif filename == '-':\n            self.filename = 'stdin'\n            self.lines = stdin_get_value().splitlines(True)\n        elif lines is None:\n            try:\n                self.lines = readlines(filename)\n            except IOError:\n                (exc_type, exc) = sys.exc_info()[:2]\n                self._io_error = '%s: %s' % (exc_type.__name__, exc)\n                self.lines = []\n        else:\n            self.lines = lines\n        if self.lines:\n            ord0 = ord(self.lines[0][0])\n            if ord0 in (0xef, 0xfeff):  # Strip the UTF-8 BOM\n                if ord0 == 0xfeff:\n                    self.lines[0] = self.lines[0][1:]\n                elif self.lines[0][:3] == '\\xef\\xbb\\xbf':\n                    self.lines[0] = self.lines[0][3:]\n        self.report = report or options.report\n        self.report_error = self.report.error\n        self.noqa = False",
  "def report_invalid_syntax(self):\n        \"\"\"Check if the syntax is valid.\"\"\"\n        (exc_type, exc) = sys.exc_info()[:2]\n        if len(exc.args) > 1:\n            offset = exc.args[1]\n            if len(offset) > 2:\n                offset = offset[1:3]\n        else:\n            offset = (1, 0)\n        self.report_error(offset[0], offset[1] or 0,\n                          'E901 %s: %s' % (exc_type.__name__, exc.args[0]),\n                          self.report_invalid_syntax)",
  "def readline(self):\n        \"\"\"Get the next line from the input buffer.\"\"\"\n        if self.line_number >= self.total_lines:\n            return ''\n        line = self.lines[self.line_number]\n        self.line_number += 1\n        if self.indent_char is None and line[:1] in WHITESPACE:\n            self.indent_char = line[0]\n        return line",
  "def run_check(self, check, argument_names):\n        \"\"\"Run a check plugin.\"\"\"\n        arguments = []\n        for name in argument_names:\n            arguments.append(getattr(self, name))\n        return check(*arguments)",
  "def init_checker_state(self, name, argument_names):\n        \"\"\"Prepare custom state for the specific checker plugin.\"\"\"\n        if 'checker_state' in argument_names:\n            self.checker_state = self._checker_states.setdefault(name, {})",
  "def check_physical(self, line):\n        \"\"\"Run all physical checks on a raw input line.\"\"\"\n        self.physical_line = line\n        for name, check, argument_names in self._physical_checks:\n            self.init_checker_state(name, argument_names)\n            result = self.run_check(check, argument_names)\n            if result is not None:\n                (offset, text) = result\n                self.report_error(self.line_number, offset, text, check)\n                if text[:4] == 'E101':\n                    self.indent_char = line[0]",
  "def build_tokens_line(self):\n        \"\"\"Build a logical line from tokens.\"\"\"\n        logical = []\n        comments = []\n        length = 0\n        prev_row = prev_col = mapping = None\n        for token_type, text, start, end, line in self.tokens:\n            if token_type in SKIP_TOKENS:\n                continue\n            if not mapping:\n                mapping = [(0, start)]\n            if token_type == tokenize.COMMENT:\n                comments.append(text)\n                continue\n            if token_type == tokenize.STRING:\n                text = mute_string(text)\n            if prev_row:\n                (start_row, start_col) = start\n                if prev_row != start_row:    # different row\n                    prev_text = self.lines[prev_row - 1][prev_col - 1]\n                    if prev_text == ',' or (prev_text not in '{[(' and\n                                            text not in '}])'):\n                        text = ' ' + text\n                elif prev_col != start_col:  # different column\n                    text = line[prev_col:start_col] + text\n            logical.append(text)\n            length += len(text)\n            mapping.append((length, end))\n            (prev_row, prev_col) = end\n        self.logical_line = ''.join(logical)\n        self.noqa = comments and noqa(''.join(comments))\n        return mapping",
  "def check_logical(self):\n        \"\"\"Build a line from tokens and run all logical checks on it.\"\"\"\n        self.report.increment_logical_line()\n        mapping = self.build_tokens_line()\n\n        if not mapping:\n            return\n\n        (start_row, start_col) = mapping[0][1]\n        start_line = self.lines[start_row - 1]\n        self.indent_level = expand_indent(start_line[:start_col])\n        if self.blank_before < self.blank_lines:\n            self.blank_before = self.blank_lines\n        if self.verbose >= 2:\n            print(self.logical_line[:80].rstrip())\n        for name, check, argument_names in self._logical_checks:\n            if self.verbose >= 4:\n                print('   ' + name)\n            self.init_checker_state(name, argument_names)\n            for offset, text in self.run_check(check, argument_names) or ():\n                if not isinstance(offset, tuple):\n                    for token_offset, pos in mapping:\n                        if offset <= token_offset:\n                            break\n                    offset = (pos[0], pos[1] + offset - token_offset)\n                self.report_error(offset[0], offset[1], text, check)\n        if self.logical_line:\n            self.previous_indent_level = self.indent_level\n            self.previous_logical = self.logical_line\n            if not self.indent_level:\n                self.previous_unindented_logical_line = self.logical_line\n        self.blank_lines = 0\n        self.tokens = []",
  "def check_ast(self):\n        \"\"\"Build the file's AST and run all AST checks.\"\"\"\n        try:\n            tree = compile(''.join(self.lines), '', 'exec', PyCF_ONLY_AST)\n        except (ValueError, SyntaxError, TypeError):\n            return self.report_invalid_syntax()\n        for name, cls, __ in self._ast_checks:\n            checker = cls(tree, self.filename)\n            for lineno, offset, text, check in checker.run():\n                if not self.lines or not noqa(self.lines[lineno - 1]):\n                    self.report_error(lineno, offset, text, check)",
  "def generate_tokens(self):\n        \"\"\"Tokenize the file, run physical line checks and yield tokens.\"\"\"\n        if self._io_error:\n            self.report_error(1, 0, 'E902 %s' % self._io_error, readlines)\n        tokengen = tokenize.generate_tokens(self.readline)\n        try:\n            for token in tokengen:\n                if token[2][0] > self.total_lines:\n                    return\n                self.noqa = token[4] and noqa(token[4])\n                self.maybe_check_physical(token)\n                yield token\n        except (SyntaxError, tokenize.TokenError):\n            self.report_invalid_syntax()",
  "def maybe_check_physical(self, token):\n        \"\"\"If appropriate (based on token), check current physical line(s).\"\"\"\n        # Called after every token, but act only on end of line.\n        if _is_eol_token(token):\n            # Obviously, a newline token ends a single physical line.\n            self.check_physical(token[4])\n        elif token[0] == tokenize.STRING and '\\n' in token[1]:\n            # Less obviously, a string that contains newlines is a\n            # multiline string, either triple-quoted or with internal\n            # newlines backslash-escaped. Check every physical line in the\n            # string *except* for the last one: its newline is outside of\n            # the multiline string, so we consider it a regular physical\n            # line, and will check it like any other physical line.\n            #\n            # Subtleties:\n            # - we don't *completely* ignore the last line; if it contains\n            #   the magical \"# noqa\" comment, we disable all physical\n            #   checks for the entire multiline string\n            # - have to wind self.line_number back because initially it\n            #   points to the last line of the string, and we want\n            #   check_physical() to give accurate feedback\n            if noqa(token[4]):\n                return\n            self.multiline = True\n            self.line_number = token[2][0]\n            for line in token[1].split('\\n')[:-1]:\n                self.check_physical(line + '\\n')\n                self.line_number += 1\n            self.multiline = False",
  "def check_all(self, expected=None, line_offset=0):\n        \"\"\"Run all checks on the input file.\"\"\"\n        self.report.init_file(self.filename, self.lines, expected, line_offset)\n        self.total_lines = len(self.lines)\n        if self._ast_checks:\n            self.check_ast()\n        self.line_number = 0\n        self.indent_char = None\n        self.indent_level = self.previous_indent_level = 0\n        self.previous_logical = ''\n        self.previous_unindented_logical_line = ''\n        self.tokens = []\n        self.blank_lines = self.blank_before = 0\n        parens = 0\n        for token in self.generate_tokens():\n            self.tokens.append(token)\n            token_type, text = token[0:2]\n            if self.verbose >= 3:\n                if token[2][0] == token[3][0]:\n                    pos = '[%s:%s]' % (token[2][1] or '', token[3][1])\n                else:\n                    pos = 'l.%s' % token[3][0]\n                print('l.%s\\t%s\\t%s\\t%r' %\n                      (token[2][0], pos, tokenize.tok_name[token[0]], text))\n            if token_type == tokenize.COMMENT or token_type == tokenize.STRING:\n                for sre in re.finditer(r\"[:.;,]   ?[A-Za-z]\", text):\n                    pos = sre.span()[0]\n                    part = text[:pos]\n                    line = token[2][0] + part.count('\\n')\n                    offset = 0 if part.count('\\n') > 0 else token[2][1]\n                    col = offset + pos - part.rfind('\\n') + 1\n                    if sre.group(0)[0] == '.':\n                        self.report_error(line, col,\n                           'E289 Too many spaces after period. Use only one.',\n                           check=None)\n                    elif sre.group(0)[0] == ',':\n                        self.report_error(line, col,\n                           'E288 Too many spaces after comma. Use only one.',\n                           check=None)\n                    else:\n                        self.report_error(line, col,\n                           'E287 Too many spaces after punctuation. '\n                           'Use only one.',\n                           check=None)\n            if token_type == tokenize.OP:\n                if text in '([{':\n                    parens += 1\n                elif text in '}])':\n                    parens -= 1\n            elif not parens:\n                if token_type in NEWLINE:\n                    if token_type == tokenize.NEWLINE:\n                        self.check_logical()\n                        self.blank_before = 0\n                    elif len(self.tokens) == 1:\n                        # The physical line contains only this token.\n                        self.blank_lines += 1\n                        del self.tokens[0]\n                    else:\n                        self.check_logical()\n                elif COMMENT_WITH_NL and token_type == tokenize.COMMENT:\n                    if len(self.tokens) == 1:\n                        # The comment also ends a physical line\n                        token = list(token)\n                        token[1] = text.rstrip('\\r\\n')\n                        token[3] = (token[2][0], token[2][1] + len(token[1]))\n                        self.tokens = [tuple(token)]\n                        self.check_logical()\n        if self.tokens:\n            self.check_physical(self.lines[-1])\n            self.check_logical()\n        if self.blank_lines > 1:\n            self.report_error(token[2][0], 0,\n                'E389 File ends in multiple blank lines',\n                check=None)\n        return self.report.get_file_results()",
  "def __init__(self, options):\n        self._benchmark_keys = options.benchmark_keys\n        self._ignore_code = options.ignore_code\n        # Results\n        self.elapsed = 0\n        self.total_errors = 0\n        self.counters = dict.fromkeys(self._benchmark_keys, 0)\n        self.messages = {}",
  "def start(self):\n        \"\"\"Start the timer.\"\"\"\n        self._start_time = time.time()",
  "def stop(self):\n        \"\"\"Stop the timer.\"\"\"\n        self.elapsed = time.time() - self._start_time",
  "def init_file(self, filename, lines, expected, line_offset):\n        \"\"\"Signal a new file.\"\"\"\n        self.filename = filename\n        self.lines = lines\n        self.expected = expected or ()\n        self.line_offset = line_offset\n        self.file_errors = 0\n        self.counters['files'] += 1\n        self.counters['physical lines'] += len(lines)",
  "def increment_logical_line(self):\n        \"\"\"Signal a new logical line.\"\"\"\n        self.counters['logical lines'] += 1",
  "def error(self, line_number, offset, text, check):\n        \"\"\"Report an error, according to options.\"\"\"\n        code = text[:4]\n        if self._ignore_code(code):\n            return\n        if code in self.counters:\n            self.counters[code] += 1\n        else:\n            self.counters[code] = 1\n            self.messages[code] = text[5:]\n        # Don't care about expected errors or warnings\n        if code in self.expected:\n            return\n        if self.print_filename and not self.file_errors:\n            print(self.filename)\n        self.file_errors += 1\n        self.total_errors += 1\n        return code",
  "def get_file_results(self):\n        \"\"\"Return the count of errors and warnings for this file.\"\"\"\n        return self.file_errors",
  "def get_count(self, prefix=''):\n        \"\"\"Return the total count of errors and warnings.\"\"\"\n        return sum([self.counters[key]\n                    for key in self.messages if key.startswith(prefix)])",
  "def get_statistics(self, prefix=''):\n        \"\"\"Get statistics for message codes that start with the prefix.\n\n        prefix='' matches all errors and warnings\n        prefix='E' matches all errors\n        prefix='W' matches all warnings\n        prefix='E4' matches all errors that have to do with imports\n        \"\"\"\n        return ['%-7s %s %s' % (self.counters[key], key, self.messages[key])\n                for key in sorted(self.messages) if key.startswith(prefix)]",
  "def print_statistics(self, prefix=''):\n        \"\"\"Print overall statistics (number of errors and warnings).\"\"\"\n        for line in self.get_statistics(prefix):\n            print(line)",
  "def print_benchmark(self):\n        \"\"\"Print benchmark numbers.\"\"\"\n        print('%-7.2f %s' % (self.elapsed, 'seconds elapsed'))\n        if self.elapsed:\n            for key in self._benchmark_keys:\n                print('%-7d %s per second (%d total)' %\n                      (self.counters[key] / self.elapsed, key,\n                       self.counters[key]))",
  "def __init__(self, options):\n        super(StandardReport, self).__init__(options)\n        self._fmt = REPORT_FORMAT.get(options.format.lower(),\n                                      options.format)\n        self._repeat = options.repeat\n        self._show_source = options.show_source\n        self._show_pep8 = options.show_pep8",
  "def init_file(self, filename, lines, expected, line_offset):\n        \"\"\"Signal a new file.\"\"\"\n        self._deferred_print = []\n        return super(StandardReport, self).init_file(\n            filename, lines, expected, line_offset)",
  "def error(self, line_number, offset, text, check):\n        \"\"\"Report an error, according to options.\"\"\"\n        code = super(StandardReport, self).error(line_number, offset,\n                                                 text, check)\n        if code and (self.counters[code] == 1 or self._repeat):\n            self._deferred_print.append(\n                (line_number, offset, code, text[5:], check.__doc__))\n        return code",
  "def get_file_results(self):\n        \"\"\"Print the result and return the overall count for this file.\"\"\"\n        self._deferred_print.sort()\n        for line_number, offset, code, text, doc in self._deferred_print:\n            print(self._fmt % {\n                'path': self.filename,\n                'row': self.line_offset + line_number, 'col': offset + 1,\n                'code': code, 'text': text,\n            })\n            if self._show_source:\n                if line_number > len(self.lines):\n                    line = ''\n                else:\n                    line = self.lines[line_number - 1]\n                print(line.rstrip())\n                print(re.sub(r'\\S', ' ', line[:offset]) + '^')\n            if self._show_pep8 and doc:\n                print('    ' + doc.strip())\n\n            # stdout is block buffered when not stdout.isatty().\n            # line can be broken where buffer boundary since other processes\n            # write to same file.\n            # flush() after print() to avoid buffer boundary.\n            # Typical buffer size is 8192. line written safely when\n            # len(line) < 8192.\n            sys.stdout.flush()\n        return self.file_errors",
  "def __init__(self, options):\n        super(DiffReport, self).__init__(options)\n        self._selected = options.selected_lines",
  "def error(self, line_number, offset, text, check):\n        if line_number not in self._selected[self.filename]:\n            return\n        return super(DiffReport, self).error(line_number, offset, text, check)",
  "def __init__(self, *args, **kwargs):\n        # build options from the command line\n        self.checker_class = kwargs.pop('checker_class', Checker)\n        parse_argv = kwargs.pop('parse_argv', False)\n        config_file = kwargs.pop('config_file', False)\n        parser = kwargs.pop('parser', None)\n        # build options from dict\n        options_dict = dict(*args, **kwargs)\n        arglist = None if parse_argv else options_dict.get('paths', None)\n        options, self.paths = process_options(\n            arglist, parse_argv, config_file, parser)\n        if options_dict:\n            options.__dict__.update(options_dict)\n            if 'paths' in options_dict:\n                self.paths = options_dict['paths']\n\n        self.runner = self.input_file\n        self.options = options\n\n        if not options.reporter:\n            options.reporter = BaseReport if options.quiet else StandardReport\n\n        options.select = tuple(options.select or ())\n        if not (options.select or options.ignore or\n                options.testsuite or options.doctest) and DEFAULT_IGNORE:\n            # The default choice: ignore controversial checks\n            options.ignore = tuple(DEFAULT_IGNORE.split(','))\n        else:\n            # Ignore all checks which are not explicitly selected\n            options.ignore = ('',) if options.select else tuple(options.ignore)\n        options.benchmark_keys = BENCHMARK_KEYS[:]\n        options.ignore_code = self.ignore_code\n        options.physical_checks = self.get_checks('physical_line')\n        options.logical_checks = self.get_checks('logical_line')\n        options.ast_checks = self.get_checks('tree')\n        self.init_report()",
  "def init_report(self, reporter=None):\n        \"\"\"Initialize the report instance.\"\"\"\n        self.options.report = (reporter or self.options.reporter)(self.options)\n        return self.options.report",
  "def check_files(self, paths=None):\n        \"\"\"Run all checks on the paths.\"\"\"\n        if paths is None:\n            paths = self.paths\n        report = self.options.report\n        runner = self.runner\n        report.start()\n        try:\n            for path in paths:\n                if os.path.isdir(path):\n                    self.input_dir(path)\n                elif not self.excluded(path):\n                    runner(path)\n        except KeyboardInterrupt:\n            print('... stopped')\n        report.stop()\n        return report",
  "def input_file(self, filename, lines=None, expected=None, line_offset=0):\n        \"\"\"Run all checks on a Python source file.\"\"\"\n        if self.options.verbose:\n            print('checking %s' % filename)\n        fchecker = self.checker_class(\n            filename, lines=lines, options=self.options)\n        return fchecker.check_all(expected=expected, line_offset=line_offset)",
  "def input_dir(self, dirname):\n        \"\"\"Check all files in this directory and all subdirectories.\"\"\"\n        dirname = dirname.rstrip('/')\n        if self.excluded(dirname):\n            return 0\n        counters = self.options.report.counters\n        verbose = self.options.verbose\n        filepatterns = self.options.filename\n        runner = self.runner\n        for root, dirs, files in os.walk(dirname):\n            if verbose:\n                print('directory ' + root)\n            counters['directories'] += 1\n            for subdir in sorted(dirs):\n                if self.excluded(subdir, root):\n                    dirs.remove(subdir)\n            for filename in sorted(files):\n                # contain a pattern that matches?\n                if ((filename_match(filename, filepatterns) and\n                     not self.excluded(filename, root))):\n                    runner(os.path.join(root, filename))",
  "def excluded(self, filename, parent=None):\n        \"\"\"Check if the file should be excluded.\n\n        Check if 'options.exclude' contains a pattern that matches filename.\n        \"\"\"\n        if not self.options.exclude:\n            return False\n        basename = os.path.basename(filename)\n        if filename_match(basename, self.options.exclude):\n            return True\n        if parent:\n            filename = os.path.join(parent, filename)\n        filename = os.path.abspath(filename)\n        return filename_match(filename, self.options.exclude)",
  "def ignore_code(self, code):\n        \"\"\"Check if the error code should be ignored.\n\n        If 'options.select' contains a prefix of the error code,\n        return False.  Else, if 'options.ignore' contains a prefix of\n        the error code, return True.\n        \"\"\"\n        if len(code) < 4 and any(s.startswith(code)\n                                 for s in self.options.select):\n            return False\n        return (code.startswith(self.options.ignore) and\n                not code.startswith(self.options.select))",
  "def get_checks(self, argument_name):\n        \"\"\"Get all the checks for this category.\n\n        Find all globally visible functions where the first argument name\n        starts with argument_name and which contain selected tests.\n        \"\"\"\n        checks = []\n        for check, attrs in _checks[argument_name].items():\n            (codes, args) = attrs\n            if any(not (code and self.ignore_code(code)) for code in codes):\n                checks.append((check.__name__, check, args))\n        return sorted(checks)",
  "class KivyStyleChecker(pep8.Checker):\n\n    def __init__(self, filename):\n        pep8.Checker.__init__(self, filename, ignore=pep8_ignores)\n\n    def report_error(self, line_number, offset, text, check):\n        return pep8.Checker.report_error(\n            self, line_number, offset, text, check)",
  "def __init__(self, filename):\n        pep8.Checker.__init__(self, filename, ignore=pep8_ignores)",
  "def report_error(self, line_number, offset, text, check):\n        return pep8.Checker.report_error(\n            self, line_number, offset, text, check)",
  "def usage():\n        print('Usage: python pep8kivy.py <file_or_folder_to_check>*')\n        print('Folders will be checked recursively.')\n        sys.exit(1)",
  "def check(fn):\n        try:\n            checker = KivyStyleChecker(fn)\n        except IOError:\n            # File couldn't be opened, so was deleted apparently.\n            # Don't check deleted files.\n            return 0\n        return checker.check_all()",
  "def add_defines_to_set(header):\n    symbols = []\n    lineno = 0\n    for line in header:\n        symbol = None\n        hexcode = None\n        lineno += 1\n        line = line.strip()\n        try:\n            elements = line.split()\n            if line.startswith(\"#define\"):\n                symbol = elements[1]\n                for element in elements:\n                    if element.startswith(\"0x\"):\n                        hexcode = element\n            elif line.startswith(\"typedef\"):\n                symbol = elements[-1]\n            else:\n                for element in elements:\n                    if element.startswith(\"gl\"):\n                        symbol = element\n            if symbol:\n                symbols.append((symbol, lineno, line, hexcode))\n        except Exception as e:\n            print('error:', lineno, ':', line)\n            print(e)\n\n    return symbols",
  "def extract_common_symbols(symbols1, symbols2, already_extracted):\n    for symbol1, lineno1, line1, hexcode1 in symbols1:\n        for symbol2, lineno2, line2, hexcode2 in symbols2:\n            if symbol1 in already_extracted or symbol2 in already_extracted:\n                continue\n            if symbol1 == symbol2 + 'f':\n                # There is no `double` type in GLES; Functions that were using\n                # a double were renamed with the suffix 'f'.\n                print(\"// Different Name; Redefine\")\n                print(line2)\n                print(\"#define %s %s\" % (symbol1, symbol2))\n            elif symbol1 == symbol2:\n                already_extracted.append(symbol1)\n                print(line1)\n                if symbol1 == 'GLclampf;':\n                    # See explanation about doubles on GLES above.\n                    print('typedef GLclampf GLclampd;')\n            elif hexcode1 and hexcode2 and hexcode1 == hexcode2:\n                already_extracted.append(symbol1)\n                already_extracted.append(symbol2)\n                print(\"// Different Name; Redefine\")\n                print(line2)\n                print(\"#define %s %s\" % (symbol1, symbol2))",
  "class FactoryBuild(Command):\n    description = 'Build the factory relation file (for factory.py)'\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        print('--------------------------------------------')\n        print('Building factory relation file')\n        print('--------------------------------------------')\n\n        root_dir = os.path.dirname(kivy.__file__)\n        filename = os.path.join(root_dir, 'factory_registers.py')\n        with open(filename, 'w') as fd:\n            fd.close()\n\n        # ensure we don't have any thing like doc running\n        symbols = []\n        for root, dirnames, filenames in os.walk(root_dir):\n            if not root.startswith(root_dir):\n                raise Exception('Directory should start with the kivy'\n                                'directory')\n            root = 'kivy' + root[len(root_dir):].replace(os.path.sep, '.')\n            for filename in fnmatch.filter(filenames, '*.[ps][yo]'):\n                module = '%s.%s' % (root, filename[:-3])\n\n                # check ignore list first\n                ignore = False\n                for ignore in ignore_list:\n                    if module.startswith(ignore):\n                        ignore = True\n                        break\n                if ignore:\n                    # print('<<< ignored (ignore list)')\n                    continue\n\n                # special case, core providers\n                if root.startswith('kivy.core.'):\n                    if not root.endswith('__init__.py'):\n                        # print('<<< ignored (not a __init__.py)')\n                        continue\n\n                print('>>>', module, '::', end=' ')\n\n                try:\n                    m = __import__(name=module, fromlist='.')\n                except Exception as e:\n                    print()\n                    print('ERROR:', e)\n                    continue\n                if not hasattr(m, '__all__'):\n                    print()\n                    continue\n                for symbol in getattr(m, '__all__'):\n                    if symbol.startswith('_'):\n                        continue\n                    attr = getattr(m, symbol)\n                    if type(attr) not in (type, type):\n                        continue\n                    symbols.append((symbol, module))\n                    print(symbol, end=' ')\n                print()\n\n        print()\n        print('--------------------------------------------')\n        print('Found %d symbols, generating file' % len(symbols))\n        print('--------------------------------------------')\n\n        filename = os.path.join(root_dir, 'factory_registers.py')\n        with open(filename, 'w') as fd:\n            fd.write('# Auto-generated file by setup.py build_factory\\n')\n            fd.write('\\n')\n            fd.write('from kivy.factory import Factory\\n')\n            fd.write('\\n')\n            fd.write('r = Factory.register\\n')\n            for x in symbols:\n                fd.write(\"r('%s', module='%s')\\n\" % x)\n\n        print('File written at', filename)",
  "def initialize_options(self):\n        pass",
  "def finalize_options(self):\n        pass",
  "def run(self):\n        print('--------------------------------------------')\n        print('Building factory relation file')\n        print('--------------------------------------------')\n\n        root_dir = os.path.dirname(kivy.__file__)\n        filename = os.path.join(root_dir, 'factory_registers.py')\n        with open(filename, 'w') as fd:\n            fd.close()\n\n        # ensure we don't have any thing like doc running\n        symbols = []\n        for root, dirnames, filenames in os.walk(root_dir):\n            if not root.startswith(root_dir):\n                raise Exception('Directory should start with the kivy'\n                                'directory')\n            root = 'kivy' + root[len(root_dir):].replace(os.path.sep, '.')\n            for filename in fnmatch.filter(filenames, '*.[ps][yo]'):\n                module = '%s.%s' % (root, filename[:-3])\n\n                # check ignore list first\n                ignore = False\n                for ignore in ignore_list:\n                    if module.startswith(ignore):\n                        ignore = True\n                        break\n                if ignore:\n                    # print('<<< ignored (ignore list)')\n                    continue\n\n                # special case, core providers\n                if root.startswith('kivy.core.'):\n                    if not root.endswith('__init__.py'):\n                        # print('<<< ignored (not a __init__.py)')\n                        continue\n\n                print('>>>', module, '::', end=' ')\n\n                try:\n                    m = __import__(name=module, fromlist='.')\n                except Exception as e:\n                    print()\n                    print('ERROR:', e)\n                    continue\n                if not hasattr(m, '__all__'):\n                    print()\n                    continue\n                for symbol in getattr(m, '__all__'):\n                    if symbol.startswith('_'):\n                        continue\n                    attr = getattr(m, symbol)\n                    if type(attr) not in (type, type):\n                        continue\n                    symbols.append((symbol, module))\n                    print(symbol, end=' ')\n                print()\n\n        print()\n        print('--------------------------------------------')\n        print('Found %d symbols, generating file' % len(symbols))\n        print('--------------------------------------------')\n\n        filename = os.path.join(root_dir, 'factory_registers.py')\n        with open(filename, 'w') as fd:\n            fd.write('# Auto-generated file by setup.py build_factory\\n')\n            fd.write('\\n')\n            fd.write('from kivy.factory import Factory\\n')\n            fd.write('\\n')\n            fd.write('r = Factory.register\\n')\n            for x in symbols:\n                fd.write(\"r('%s', module='%s')\\n\" % x)\n\n        print('File written at', filename)",
  "def get_cython_versions(setup_cfg=''):\n    _cython_config = configparser.ConfigParser()\n    if setup_cfg:\n        _cython_config.read(setup_cfg)\n    else:\n        _cython_config.read(\n            join(dirname(__file__), '..', '..', '..', 'setup.cfg'))\n\n    cython_min = _cython_config['kivy']['cython_min']\n    cython_max = _cython_config['kivy']['cython_max']\n    cython_unsupported = _cython_config['kivy']['cython_exclude'].split(',')\n    # ref https://github.com/cython/cython/issues/1968\n\n    cython_requires = (\n        'cython>={min_version},<={max_version},{exclusion}'.format(\n            min_version=cython_min,\n            max_version=cython_max,\n            exclusion=','.join('!=%s' % excl for excl in cython_unsupported),\n        )\n    )\n\n    return cython_requires, cython_min, cython_max, cython_unsupported",
  "def get_cython_msg():\n    cython_requires, cython_min, cython_max, cython_unsupported = \\\n        get_cython_versions()\n    cython_unsupported_append = '''\n\n    Please note that the following versions of Cython are not supported\n    at all: {}'''.format(', '.join(map(str, cython_unsupported)))\n\n    cython_min_msg = textwrap.dedent('''\n    This version of Cython is not compatible with Kivy. Please upgrade to\n    at least version {0}, preferably the newest supported version {1}.\n\n    If your platform provides a Cython package, make sure you have upgraded\n    to the newest version. If the newest version available is still too low,\n    please remove it and install the newest supported Cython via pip:\n\n        pip install -I \"{3}\"{2}\n    '''.format(cython_min, cython_max,\n               cython_unsupported_append if cython_unsupported else '',\n               cython_requires))\n\n    cython_max_msg = textwrap.dedent('''\n    This version of Cython is untested with Kivy. While this version may\n    work perfectly fine, it is possible that you may experience issues.\n    Please downgrade to a supported version, or update cython_max in\n    setup.cfg to your version of Cython. It is best to use the newest\n    supported version, {1}, but the minimum supported version is {0}.\n\n    If your platform provides a Cython package, check if you can downgrade\n    to a supported version. Otherwise, uninstall the platform package and\n    install Cython via pip:\n\n        pip install -I \"{3}\"{2}\n    '''.format(cython_min, cython_max,\n               cython_unsupported_append if cython_unsupported else '',\n               cython_requires))\n\n    cython_unsupported_msg = textwrap.dedent('''\n    This version of Cython suffers from known bugs and is unsupported.\n    Please install the newest supported version, {1}, if possible, but\n    the minimum supported version is {0}.\n\n    If your platform provides a Cython package, check if you can install\n    a supported version. Otherwise, uninstall the platform package and\n    install Cython via pip:\n\n        pip install -I \"{3}\"{2}\n    '''.format(cython_min, cython_max, cython_unsupported_append,\n               cython_requires))\n\n    return cython_min_msg, cython_max_msg, cython_unsupported_msg",
  "def runtime_hooks():\n    '''Returns a list with the runtime hooks for kivy. It can be used with\n    ``runtime_hooks=runtime_hooks()`` in the spec file. Pyinstaller comes\n    preinstalled with this hook.\n    '''\n    return [join(curdir, 'pyi_rth_kivy.py')]",
  "def hookspath():\n    '''Returns a list with the directory that contains the alternate (not\n    the default included with pyinstaller) pyinstaller hook for kivy,\n    ``kivy/tools/packaging/pyinstaller_hooks/kivy-hook.py``. It is\n    typically used with ``hookspath=hookspath()`` in the spec\n    file.\n\n    The default pyinstaller hook returns all the core providers used using\n    :func:`get_deps_minimal` to add to its list of hidden imports. This\n    alternate hook only included the essential modules and leaves the core\n    providers to be included additionally with :func:`get_deps_minimal`\n    or :func:`get_deps_all`.\n    '''\n    return [curdir]",
  "def get_hooks():\n    '''Returns the dict for the spec ``hookspath`` and ``runtime_hooks``\n    values.\n    '''\n    return {'hookspath': hookspath(), 'runtime_hooks': runtime_hooks()}",
  "def get_deps_minimal(exclude_ignored=True, **kwargs):\n    '''Returns Kivy hidden modules as well as excluded modules to be used\n    with ``Analysis``.\n\n    The function takes core modules as keyword arguments and their value\n    indicates which of the providers to include/exclude from the compiled app.\n\n    The possible keyword names are ``audio, camera, clipboard, image, spelling,\n    text, video, and window``. Their values can be:\n\n        ``True``: Include current provider\n            The providers imported when the core module is\n            loaded on this system are added to hidden imports. This is the\n            default if the keyword name is not specified.\n        ``None``: Exclude\n            Don't return this core module at all.\n        ``A string or list of strings``: Providers to include\n            Each string is the name of a provider for this module to be\n            included.\n\n    For example, ``get_deps_minimal(video=None, window=True,\n    audio=['gstplayer', 'ffpyplayer'], spelling='enchant')`` will exclude all\n    the video providers, will include the gstreamer and ffpyplayer providers\n    for audio, will include the enchant provider for spelling, and will use the\n    current default provider for ``window``.\n\n    ``exclude_ignored``, if ``True`` (the default), if the value for a core\n    library is ``None``, then if ``exclude_ignored`` is True, not only will the\n    library not be included in the hiddenimports but it'll also added to the\n    excluded imports to prevent it being included accidentally by pyinstaller.\n\n    :returns:\n\n        A dict with three keys, ``hiddenimports``, ``excludes``, and\n        ``binaries``. Their values are a list of the corresponding modules to\n        include/exclude. This can be passed directly to `Analysis`` with\n        e.g. ::\n\n            a = Analysis(['..\\\\kivy\\\\examples\\\\demo\\\\touchtracer\\\\main.py'],\n                        ...\n                         hookspath=hookspath(),\n                         runtime_hooks=[],\n                         win_no_prefer_redirects=False,\n                         win_private_assemblies=False,\n                         cipher=block_cipher,\n                         **get_deps_minimal(video=None, audio=None))\n    '''\n    core_mods = ['audio', 'camera', 'clipboard', 'image', 'spelling', 'text',\n                 'video', 'window']\n    mods = kivy_modules[:]\n    excludes = excludedimports[:]\n\n    for mod_name, val in kwargs.items():\n        if mod_name not in core_mods:\n            raise KeyError('{} not found in {}'.format(mod_name, core_mods))\n\n        full_name = 'kivy.core.{}'.format(mod_name)\n        if not val:\n            core_mods.remove(mod_name)\n            if exclude_ignored:\n                excludes.extend(collect_submodules(full_name))\n            continue\n        if val is True:\n            continue\n        core_mods.remove(mod_name)\n\n        mods.append(full_name)\n        single_mod = False\n        if isinstance(val, (str, bytes)):\n            single_mod = True\n            mods.append('kivy.core.{0}.{0}_{1}'.format(mod_name, val))\n        if not single_mod:\n            for v in val:\n                mods.append('kivy.core.{0}.{0}_{1}'.format(mod_name, v))\n\n    for mod_name in core_mods:  # process remaining default modules\n        full_name = 'kivy.core.{}'.format(mod_name)\n        mods.append(full_name)\n        m = importlib.import_module(full_name)\n\n        if mod_name == 'clipboard' and m.CutBuffer:\n            mods.append(m.CutBuffer.__module__)\n        if hasattr(m, mod_name.capitalize()):  # e.g. video -> Video\n            val = getattr(m, mod_name.capitalize())\n            if val:\n                mods.append(getattr(val, '__module__'))\n\n        if hasattr(m, 'libs_loaded') and m.libs_loaded:\n            for name in m.libs_loaded:\n                mods.append('kivy.core.{}.{}'.format(mod_name, name))\n\n    mods = sorted(set(mods))\n\n    binaries = []\n    if any('gstplayer' in m for m in mods):\n        binaries = _find_gst_binaries()\n    elif exclude_ignored:\n        excludes.append('kivy.lib.gstplayer')\n\n    return {\n        'hiddenimports': mods,\n        'excludes': excludes,\n        'binaries': binaries,\n    }",
  "def get_deps_all():\n    '''Similar to :func:`get_deps_minimal`, but this returns all the\n    kivy modules that can indirectly imported. Which includes all\n    the possible kivy providers.\n\n    This can be used to get a list of all the possible providers\n    which can then manually be included/excluded by commenting out elements\n    in the list instead of passing on all the items. See module description.\n\n    :returns:\n\n        A dict with three keys, ``hiddenimports``, ``excludes``, and\n        ``binaries``. Their values are a list of the corresponding modules to\n        include/exclude. This can be passed directly to `Analysis`` with\n        e.g. ::\n\n            a = Analysis(['..\\\\kivy\\\\examples\\\\demo\\\\touchtracer\\\\main.py'],\n                        ...\n                         **get_deps_all())\n    '''\n    return {\n        'binaries': _find_gst_binaries(),\n        'hiddenimports': sorted(set(kivy_modules +\n                                    collect_submodules('kivy.core'))),\n        'excludes': []}",
  "def get_factory_modules():\n    '''Returns a list of all the modules registered in the kivy factory.\n    '''\n    mods = [x.get('module', None) for x in Factory.classes.values()]\n    return [m for m in mods if m]",
  "def add_dep_paths():\n    '''Should be called by the hook. It adds the paths with the binary\n    dependencies to the system path so that pyinstaller can find the binaries\n    during its crawling stage.\n    '''\n    paths = []\n    if old_deps is not None:\n        for importer, modname, ispkg in pkgutil.iter_modules(\n                old_deps.__path__):\n            if not ispkg:\n                continue\n            try:\n                module_spec = importer.find_spec(modname)\n                mod = importlib.util.module_from_spec(module_spec)\n                module_spec.loader.exec_module(mod)\n            except ImportError as e:\n                logging.warning(f\"deps: Error importing dependency: {e}\")\n                continue\n\n            if hasattr(mod, 'dep_bins'):\n                paths.extend(mod.dep_bins)\n    sys.path.extend(paths)\n\n    if kivy_deps is None:\n        return\n\n    paths = []\n    for importer, modname, ispkg in pkgutil.iter_modules(kivy_deps.__path__):\n        if not ispkg:\n            continue\n        try:\n            module_spec = importer.find_spec(modname)\n            mod = importlib.util.module_from_spec(module_spec)\n            module_spec.loader.exec_module(mod)\n        except ImportError as e:\n            logging.warning(f\"deps: Error importing dependency: {e}\")\n            continue\n\n        if hasattr(mod, 'dep_bins'):\n            paths.extend(mod.dep_bins)\n    sys.path.extend(paths)",
  "def _find_gst_plugin_path():\n    '''Returns a list of directories to search for GStreamer plugins.\n    '''\n    if 'GST_PLUGIN_PATH' in environ:\n        return [\n            os.path.abspath(os.path.expanduser(path))\n            for path in environ['GST_PLUGIN_PATH'].split(os.pathsep)\n        ]\n\n    try:\n        p = subprocess.Popen(\n            ['gst-inspect-1.0', 'coreelements'],\n            stdout=subprocess.PIPE, universal_newlines=True)\n    except:\n        return []\n    (stdoutdata, stderrdata) = p.communicate()\n\n    match = re.search(r'\\s+(\\S+libgstcoreelements\\.\\S+)', stdoutdata)\n\n    if not match:\n        return []\n\n    return [os.path.dirname(match.group(1))]",
  "def _find_gst_binaries():\n    '''Returns a list of GStreamer plugins and libraries to pass as the\n    ``binaries`` argument of ``Analysis``.\n    '''\n    gst_plugin_path = _find_gst_plugin_path()\n\n    plugin_filepaths = []\n    for plugin_dir in gst_plugin_path:\n        plugin_filepaths.extend(\n            glob.glob(os.path.join(plugin_dir, 'libgst*')))\n    if len(plugin_filepaths) == 0:\n        logging.warning('Could not find GStreamer plugins. ' +\n                     'Possible solution: set GST_PLUGIN_PATH')\n        return []\n\n    lib_filepaths = set()\n    for plugin_filepath in plugin_filepaths:\n        plugin_deps = bindepend.selectImports(plugin_filepath)\n        lib_filepaths.update([path for _, path in plugin_deps])\n\n    plugin_binaries = [(f, 'gst-plugins') for f in plugin_filepaths]\n    lib_binaries = [(f, '.') for f in lib_filepaths]\n\n    return plugin_binaries + lib_binaries",
  "class ProxyApp(object):\n    # proxy app object\n    # taken from http://code.activestate.com/recipes/496741-object-proxying/\n\n    __slots__ = ['_obj']\n\n    def __init__(self):\n        object.__init__(self)\n        object.__setattr__(self, '_obj', None)\n\n    def _ensure_app(self):\n        app = object.__getattribute__(self, '_obj')\n        if app is None:\n            from kivy.app import App\n            app = App.get_running_app()\n            object.__setattr__(self, '_obj', app)\n            # Clear cached application instance, when it stops\n            app.bind(on_stop=lambda instance:\n                     object.__setattr__(self, '_obj', None))\n        return app\n\n    def __getattribute__(self, name):\n        object.__getattribute__(self, '_ensure_app')()\n        return getattr(object.__getattribute__(self, '_obj'), name)\n\n    def __delattr__(self, name):\n        object.__getattribute__(self, '_ensure_app')()\n        delattr(object.__getattribute__(self, '_obj'), name)\n\n    def __setattr__(self, name, value):\n        object.__getattribute__(self, '_ensure_app')()\n        setattr(object.__getattribute__(self, '_obj'), name, value)\n\n    def __bool__(self):\n        object.__getattribute__(self, '_ensure_app')()\n        return bool(object.__getattribute__(self, '_obj'))\n\n    def __str__(self):\n        object.__getattribute__(self, '_ensure_app')()\n        return str(object.__getattribute__(self, '_obj'))\n\n    def __repr__(self):\n        object.__getattribute__(self, '_ensure_app')()\n        return repr(object.__getattribute__(self, '_obj'))",
  "class ParserException(Exception):\n    '''Exception raised when something wrong happened in a kv file.\n    '''\n\n    def __init__(self, context, line, message, cause=None):\n        self.filename = context.filename or '<inline>'\n        self.line = line\n        sourcecode = context.sourcecode\n        sc_start = max(0, line - 2)\n        sc_stop = min(len(sourcecode), line + 3)\n        sc = ['...']\n        for x in range(sc_start, sc_stop):\n            if x == line:\n                sc += ['>> %4d:%s' % (line + 1, sourcecode[line][1])]\n            else:\n                sc += ['   %4d:%s' % (x + 1, sourcecode[x][1])]\n        sc += ['...']\n        sc = '\\n'.join(sc)\n\n        message = 'Parser: File \"%s\", line %d:\\n%s\\n%s' % (\n            self.filename, self.line + 1, sc, message)\n        if cause:\n            message += '\\n' + ''.join(traceback.format_tb(cause))\n\n        super(ParserException, self).__init__(message)",
  "class ParserRuleProperty(object):\n    '''Represent a property inside a rule.\n    '''\n\n    __slots__ = ('ctx', 'line', 'name', 'value', 'co_value',\n                 'watched_keys', 'mode', 'count', 'ignore_prev')\n\n    def __init__(self, ctx, line, name, value, ignore_prev=False):\n        super(ParserRuleProperty, self).__init__()\n        #: Associated parser\n        self.ctx = ctx\n        #: Line of the rule\n        self.line = line\n        #: Name of the property\n        self.name = name\n        #: Value of the property\n        self.value = value\n        #: Compiled value\n        self.co_value = None\n        #: Compilation mode\n        self.mode = None\n        #: Watched keys\n        self.watched_keys = None\n        #: Stats\n        self.count = 0\n        #: whether previous rules targeting name should be cleared\n        self.ignore_prev = ignore_prev\n\n    def precompile(self):\n        name = self.name\n        value = self.value\n\n        # first, remove all the string from the value\n        tmp = sub(lang_str, '', self.value)\n\n        # detecting how to handle the value according to the key name\n        mode = self.mode\n        if self.mode is None:\n            self.mode = mode = 'exec' if name[:3] == 'on_' else 'eval'\n        if mode == 'eval':\n            # if we don't detect any string/key in it, we can eval and give the\n            # result\n            if re.search(lang_key, tmp) is None:\n                value = '\\n' * self.line + value\n                self.co_value = eval(\n                    compile(value, self.ctx.filename or '<string>', 'eval')\n                )\n                return\n\n        # ok, we can compile.\n        value = '\\n' * self.line + value\n        self.co_value = compile(value, self.ctx.filename or '<string>', mode)\n\n        # for exec mode, we don't need to watch any keys.\n        if mode == 'exec':\n            return\n\n        # now, detect obj.prop\n        # find all the fstrings in the  value\n        fstrings = lang_fstr.findall(value)\n        wk = set()\n        for s in fstrings:\n            expression = ast.parse(s)\n            wk |= set(self.get_names_from_expression(expression.body[0].value))\n\n        # first, remove all the string from the value\n        tmp = sub(lang_str, '', value)\n        idx = tmp.find('#')\n        if idx != -1:\n            tmp = tmp[:idx]\n        # detect key.value inside value, and split them\n        wk |= set(findall(lang_keyvalue, tmp))\n        if wk:\n            self.watched_keys = [x.split('.') for x in wk]\n        if findall(lang_tr, tmp):\n            if self.watched_keys:\n                self.watched_keys += [['_']]\n            else:\n                self.watched_keys = [['_']]\n\n    @classmethod\n    def get_names_from_expression(cls, node):\n        \"\"\"\n        Look for all the symbols used in an ast node.\n        \"\"\"\n        if isinstance(node, ast.Name):\n            yield node.id\n\n        if isinstance(node, (ast.JoinedStr, ast.BoolOp)):\n            for n in node.values:\n                if isinstance(n, ast.Str):\n                    # NOTE: required for python3.6\n                    yield from cls.get_names_from_expression(n.s)\n                else:\n                    yield from cls.get_names_from_expression(n.value)\n\n        if isinstance(node, ast.BinOp):\n            yield from cls.get_names_from_expression(node.right)\n            yield from cls.get_names_from_expression(node.left)\n\n        if isinstance(node, ast.IfExp):\n            yield from cls.get_names_from_expression(node.test)\n            yield from cls.get_names_from_expression(node.body)\n            yield from cls.get_names_from_expression(node.orelse)\n\n        if isinstance(node, ast.Subscript):\n            yield from cls.get_names_from_expression(node.value)\n            yield from cls.get_names_from_expression(node.slice)\n\n        if isinstance(node, ast.Slice):\n            yield from cls.get_names_from_expression(node.lower)\n            yield from cls.get_names_from_expression(node.upper)\n            yield from cls.get_names_from_expression(node.step)\n\n        if isinstance(\n            node,\n            (ast.ListComp, ast.DictComp, ast.SetComp, ast.GeneratorExp)\n        ):\n            for g in node.generators:\n                yield from cls.get_names_from_expression(g.iter)\n\n        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n            for elt in node.elts:\n                yield from cls.get_names_from_expression(elt)\n\n        if isinstance(node, ast.Dict):\n            for val in node.values:\n                yield from cls.get_names_from_expression(val)\n\n        if isinstance(node, ast.UnaryOp):\n            yield from cls.get_names_from_expression(node.operand)\n\n        if isinstance(node, ast.comprehension):\n            yield from cls.get_names_from_expression(node.iter.value)\n\n        if isinstance(node, ast.Attribute):\n            if isinstance(node.value, ast.Name):\n                yield f'{node.value.id}.{node.attr}'\n\n        if isinstance(node, ast.Call):\n            yield from cls.get_names_from_expression(node.func)\n\n            for arg in node.args:\n                yield from cls.get_names_from_expression(arg)\n            for keyword in node.keywords:\n                yield from cls.get_names_from_expression(keyword.value)\n\n    def __repr__(self):\n        return '<ParserRuleProperty name=%r filename=%s:%d ' \\\n               'value=%r watched_keys=%r>' % (\n                   self.name, self.ctx.filename, self.line + 1,\n                   self.value, self.watched_keys)",
  "class ParserRule(object):\n    '''Represents a rule, in terms of the Kivy internal language.\n    '''\n\n    __slots__ = ('ctx', 'line', 'name', 'children', 'id', 'properties',\n                 'canvas_before', 'canvas_root', 'canvas_after',\n                 'handlers', 'level', 'cache_marked', 'avoid_previous_rules')\n\n    def __init__(self, ctx, line, name, level):\n        super(ParserRule, self).__init__()\n        #: Level of the rule in the kv\n        self.level = level\n        #: Associated parser\n        self.ctx = ctx\n        #: Line of the rule\n        self.line = line\n        #: Name of the rule\n        self.name = name\n        #: List of children to create\n        self.children = []\n        #: Id given to the rule\n        self.id = None\n        #: Properties associated to the rule\n        self.properties = OrderedDict()\n        #: Canvas normal\n        self.canvas_root = None\n        #: Canvas before\n        self.canvas_before = None\n        #: Canvas after\n        self.canvas_after = None\n        #: Handlers associated to the rule\n        self.handlers = []\n        #: Properties cache list: mark which class have already been checked\n        self.cache_marked = []\n        #: Indicate if any previous rules should be avoided.\n        self.avoid_previous_rules = False\n\n        if level == 0:\n            self._detect_selectors()\n        else:\n            self._forbid_selectors()\n\n    def precompile(self):\n        for x in self.properties.values():\n            x.precompile()\n        for x in self.handlers:\n            x.precompile()\n        for x in self.children:\n            x.precompile()\n        if self.canvas_before:\n            self.canvas_before.precompile()\n        if self.canvas_root:\n            self.canvas_root.precompile()\n        if self.canvas_after:\n            self.canvas_after.precompile()\n\n    def create_missing(self, widget):\n        # check first if the widget class already been processed by this rule\n        cls = widget.__class__\n        if cls in self.cache_marked:\n            return\n        self.cache_marked.append(cls)\n        for name in self.properties:\n            if hasattr(widget, name):\n                continue\n            value = self.properties[name].co_value\n            if type(value) is CodeType:\n                value = None\n            widget.create_property(name, value, default_value=False)\n\n    def _forbid_selectors(self):\n        c = self.name[0]\n        if c == '<' or c == '[':\n            raise ParserException(\n                self.ctx, self.line,\n                'Selectors rules are allowed only at the first level')\n\n    def _detect_selectors(self):\n        c = self.name[0]\n        if c == '<':\n            self._build_rule()\n        elif c == '[':\n            self._build_template()\n        else:\n            if self.ctx.root is not None:\n                raise ParserException(\n                    self.ctx, self.line,\n                    'Only one root object is allowed by .kv')\n            self.ctx.root = self\n\n    def _build_rule(self):\n        name = self.name\n        if __debug__:\n            trace('Builder: build rule for %s' % name)\n        if name[0] != '<' or name[-1] != '>':\n            raise ParserException(self.ctx, self.line,\n                                  'Invalid rule (must be inside <>)')\n\n        # if the very first name start with a -, avoid previous rules\n        name = name[1:-1]\n        if name[:1] == '-':\n            self.avoid_previous_rules = True\n            name = name[1:]\n\n        for rule in re.split(lang_cls_split_pat, name):\n            crule = None\n\n            if not rule:\n                raise ParserException(self.ctx, self.line,\n                                      'Empty rule detected')\n\n            if '@' in rule:\n                # new class creation ?\n                # ensure the name is correctly written\n                rule, baseclasses = rule.split('@', 1)\n                if not re.match(lang_key, rule):\n                    raise ParserException(self.ctx, self.line,\n                                          'Invalid dynamic class name')\n\n                # save the name in the dynamic classes dict.\n                self.ctx.dynamic_classes[rule] = baseclasses\n                crule = ParserSelectorName(rule)\n\n            else:\n                # classical selectors.\n\n                if rule[0] == '.':\n                    crule = ParserSelectorClass(rule[1:])\n                else:\n                    crule = ParserSelectorName(rule)\n\n            self.ctx.rules.append((crule, self))\n\n    def _build_template(self):\n        name = self.name\n        exception = ParserException(\n            self.ctx, self.line,\n            'Deprecated Kivy lang template syntax used \"{}\". Templates will '\n            'be removed in a future version'.format(name))\n        if name not in ('[FileListEntry@FloatLayout+TreeViewNode]',\n                        '[FileIconEntry@Widget]',\n                        '[AccordionItemTitle@Label]'):\n            Logger.warning(exception)\n\n        if __debug__:\n            trace('Builder: build template for %s' % name)\n        if name[0] != '[' or name[-1] != ']':\n            raise ParserException(self.ctx, self.line,\n                                  'Invalid template (must be inside [])')\n        item_content = name[1:-1]\n        if '@' not in item_content:\n            raise ParserException(self.ctx, self.line,\n                                  'Invalid template name (missing @)')\n        template_name, template_root_cls = item_content.split('@')\n        self.ctx.templates.append((template_name, template_root_cls, self))\n\n    def __repr__(self):\n        return '<ParserRule name=%r>' % (self.name, )",
  "class Parser(object):\n    '''Create a Parser object to parse a Kivy language file or Kivy content.\n    '''\n\n    PROP_ALLOWED = ('canvas.before', 'canvas.after')\n    CLASS_RANGE = list(range(ord('A'), ord('Z') + 1))\n    PROP_RANGE = (\n        list(range(ord('A'), ord('Z') + 1)) +\n        list(range(ord('a'), ord('z') + 1)) +\n        list(range(ord('0'), ord('9') + 1)) + [ord('_')])\n\n    __slots__ = ('rules', 'templates', 'root', 'sourcecode',\n                 'directives', 'filename', 'dynamic_classes')\n\n    def __init__(self, **kwargs):\n        super(Parser, self).__init__()\n        self.rules = []\n        self.templates = []\n        self.root = None\n        self.sourcecode = []\n        self.directives = []\n        self.dynamic_classes = {}\n        self.filename = kwargs.get('filename', None)\n        content = kwargs.get('content', None)\n        if content is None:\n            raise ValueError('No content passed')\n        self.parse(content)\n\n    def execute_directives(self):\n        global __KV_INCLUDES__\n        for ln, cmd in self.directives:\n            cmd = cmd.strip()\n            if __debug__:\n                trace('Parser: got directive <%s>' % cmd)\n            if cmd[:5] == 'kivy ':\n                version = cmd[5:].strip()\n                if len(version.split('.')) == 2:\n                    version += '.0'\n                require(version)\n            elif cmd[:4] == 'set ':\n                try:\n                    name, value = cmd[4:].strip().split(' ', 1)\n                except:\n                    Logger.exception('')\n                    raise ParserException(self, ln, 'Invalid directive syntax')\n                try:\n                    value = eval(value, global_idmap)\n                except:\n                    Logger.exception('')\n                    raise ParserException(self, ln, 'Invalid value')\n                global_idmap[name] = value\n            elif cmd[:8] == 'include ':\n                ref = cmd[8:].strip()\n                force_load = False\n\n                if ref[:6] == 'force ':\n                    ref = ref[6:].strip()\n                    force_load = True\n\n                # if #:include [force] \"path with quotes around\"\n                if ref[0] == ref[-1] and ref[0] in ('\"', \"'\"):\n                    c = ref[:3].count(ref[0])\n                    ref = ref[c:-c] if c != 2 else ref\n\n                if ref[-3:] != '.kv':\n                    Logger.warning('Lang: {0} does not have a valid Kivy'\n                                'Language extension (.kv)'.format(ref))\n                    break\n                if ref in __KV_INCLUDES__:\n                    if not os.path.isfile(resource_find(ref) or ref):\n                        raise ParserException(self, ln,\n                                              'Invalid or unknown file: {0}'\n                                              .format(ref))\n                    if not force_load:\n                        Logger.warning('Lang: {0} has already been included!'\n                                    .format(ref))\n                        continue\n                    else:\n                        Logger.debug('Lang: Reloading {0} '\n                                     'because include was forced.'\n                                     .format(ref))\n                        kivy.lang.builder.Builder.unload_file(ref)\n                        kivy.lang.builder.Builder.load_file(ref)\n                        continue\n                Logger.debug('Lang: Including file: {0}'.format(0))\n                __KV_INCLUDES__.append(ref)\n                kivy.lang.builder.Builder.load_file(ref)\n            elif cmd[:7] == 'import ':\n                package = cmd[7:].strip()\n                z = package.split()\n                if len(z) != 2:\n                    raise ParserException(self, ln, 'Invalid import syntax')\n                alias, package = z\n                try:\n                    if package not in sys.modules:\n                        try:\n                            mod = importlib.__import__(package)\n                        except ImportError:\n                            module_name = '.'.join(package.split('.')[:-1])\n                            mod = importlib.__import__(module_name)\n                        # resolve the whole thing\n                        for part in package.split('.')[1:]:\n                            mod = getattr(mod, part)\n                    else:\n                        mod = sys.modules[package]\n                    global_idmap[alias] = mod\n                except ImportError:\n                    Logger.exception('')\n                    raise ParserException(self, ln,\n                                          'Unable to import package %r' %\n                                          package)\n            else:\n                raise ParserException(self, ln, 'Unknown directive')\n\n    def parse(self, content):\n        '''Parse the contents of a Parser file and return a list\n        of root objects.\n        '''\n        # Read and parse the lines of the file\n        lines = content.splitlines()\n        if not lines:\n            return\n        num_lines = len(lines)\n        lines = list(zip(list(range(num_lines)), lines))\n        self.sourcecode = lines[:]\n\n        if __debug__:\n            trace('Parser: parsing %d lines' % num_lines)\n\n        # Strip all comments\n        self.strip_comments(lines)\n\n        # Execute directives\n        self.execute_directives()\n\n        # Get object from the first level\n        objects, remaining_lines = self.parse_level(0, lines)\n\n        # Precompile rules tree\n        for rule in objects:\n            rule.precompile()\n\n        # After parsing, there should be no remaining lines\n        # or there's an error we did not catch earlier.\n        if remaining_lines:\n            ln, content = remaining_lines[0]\n            raise ParserException(self, ln, 'Invalid data (not parsed)')\n\n    def strip_comments(self, lines):\n        '''Remove all comments from all lines in-place.\n           Comments need to be on a single line and not at the end of a line.\n           i.e. a comment line's first non-whitespace character must be a #.\n        '''\n        # extract directives\n        for ln, line in lines[:]:\n            stripped = line.strip()\n            if stripped[:2] == '#:':\n                self.directives.append((ln, stripped[2:]))\n            if stripped[:1] == '#':\n                lines.remove((ln, line))\n            if not stripped:\n                lines.remove((ln, line))\n\n    def parse_level(self, level, lines, spaces=0):\n        '''Parse the current level (level * spaces) indentation.\n        '''\n        indent = spaces * level if spaces > 0 else 0\n        objects = []\n\n        current_object = None\n        current_property = None\n        current_propobject = None\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            ln, content = line\n\n            # Get the number of space\n            tmp = content.lstrip(' \\t')\n\n            # Replace any tab with 4 spaces\n            tmp = content[:len(content) - len(tmp)]\n            tmp = tmp.replace('\\t', '    ')\n\n            # first indent designates the indentation\n            if spaces == 0:\n                spaces = len(tmp)\n\n            count = len(tmp)\n\n            if spaces > 0 and count % spaces != 0:\n                raise ParserException(self, ln,\n                                      'Invalid indentation, '\n                                      'must be a multiple of '\n                                      '%s spaces' % spaces)\n            content = content.strip()\n            rlevel = count // spaces if spaces > 0 else 0\n\n            # Level finished\n            if count < indent:\n                return objects, lines[i - 1:]\n\n            # Current level, create an object\n            elif count == indent:\n                x = content.split(':', 1)\n                if not x[0]:\n                    raise ParserException(self, ln, 'Identifier missing')\n                if (len(x) == 2 and len(x[1]) and\n                        not x[1].lstrip().startswith('#')):\n                    raise ParserException(self, ln,\n                                          'Invalid data after declaration')\n                name = x[0].rstrip()\n                # if it's not a root rule, then we got some restriction\n                # aka, a valid name, without point or everything else\n                if count != 0:\n                    if False in [ord(z) in Parser.PROP_RANGE for z in name]:\n                        raise ParserException(self, ln, 'Invalid class name')\n\n                current_object = ParserRule(self, ln, name, rlevel)\n                current_property = None\n                objects.append(current_object)\n\n            # Next level, is it a property or an object ?\n            elif count == indent + spaces:\n                x = content.split(':', 1)\n                if not x[0]:\n                    raise ParserException(self, ln, 'Identifier missing')\n\n                # It's a class, add to the current object as a children\n                current_property = None\n                name = x[0].rstrip()\n                ignore_prev = name[0] == '-'\n                if ignore_prev:\n                    name = name[1:]\n\n                if ord(name[0]) in Parser.CLASS_RANGE:\n                    if ignore_prev:\n                        raise ParserException(\n                            self, ln, 'clear previous, `-`, not allowed here')\n                    _objects, _lines = self.parse_level(\n                        level + 1, lines[i:], spaces)\n                    current_object.children = _objects\n                    lines = _lines\n                    i = 0\n\n                # It's a property\n                else:\n                    if name not in Parser.PROP_ALLOWED:\n                        if not all(ord(z) in Parser.PROP_RANGE for z in name):\n                            raise ParserException(self, ln,\n                                                  'Invalid property name')\n                    if len(x) == 1:\n                        raise ParserException(self, ln, 'Syntax error')\n                    value = x[1].strip()\n                    if name == 'id':\n                        if len(value) <= 0:\n                            raise ParserException(self, ln, 'Empty id')\n                        if value in ('self', 'root'):\n                            raise ParserException(\n                                self, ln,\n                                'Invalid id, cannot be \"self\" or \"root\"')\n                        current_object.id = value\n                    elif len(value):\n                        rule = ParserRuleProperty(\n                            self, ln, name, value, ignore_prev)\n                        if name[:3] == 'on_':\n                            current_object.handlers.append(rule)\n                        else:\n                            ignore_prev = False\n                            current_object.properties[name] = rule\n                    else:\n                        current_property = name\n                        current_propobject = None\n\n                    if ignore_prev:  # it wasn't consumed\n                        raise ParserException(\n                            self, ln, 'clear previous, `-`, not allowed here')\n\n            # Two more levels?\n            elif count == indent + 2 * spaces:\n                if current_property in (\n                        'canvas', 'canvas.after', 'canvas.before'):\n                    _objects, _lines = self.parse_level(\n                        level + 2, lines[i:], spaces)\n                    rl = ParserRule(self, ln, current_property, rlevel)\n                    rl.children = _objects\n                    if current_property == 'canvas':\n                        current_object.canvas_root = rl\n                    elif current_property == 'canvas.before':\n                        current_object.canvas_before = rl\n                    else:\n                        current_object.canvas_after = rl\n                    current_property = None\n                    lines = _lines\n                    i = 0\n                else:\n                    if current_propobject is None:\n                        current_propobject = ParserRuleProperty(\n                            self, ln, current_property, content)\n                        if current_property[:3] == 'on_':\n                            current_object.handlers.append(current_propobject)\n                        else:\n                            current_object.properties[current_property] = \\\n                                current_propobject\n                    else:\n                        current_propobject.value += '\\n' + content\n\n            # Too much indentation, invalid\n            else:\n                raise ParserException(self, ln,\n                                      'Invalid indentation (too many levels)')\n\n            # Check the next line\n            i += 1\n\n        return objects, []",
  "class ParserSelector(object):\n\n    def __init__(self, key):\n        self.key = key.lower()\n\n    def match(self, widget):\n        raise NotImplementedError\n\n    def __repr__(self):\n        return '<%s key=%s>' % (self.__class__.__name__, self.key)",
  "class ParserSelectorClass(ParserSelector):\n\n    def match(self, widget):\n        return self.key in widget.cls",
  "class ParserSelectorName(ParserSelector):\n\n    parents = {}\n\n    def get_bases(self, cls):\n        for base in cls.__bases__:\n            if base.__name__ == 'object':\n                break\n            yield base\n            if base.__name__ == 'Widget':\n                break\n            for cbase in self.get_bases(base):\n                yield cbase\n\n    def match(self, widget):\n        parents = ParserSelectorName.parents\n        cls = widget.__class__\n        if cls not in parents:\n            classes = [x.__name__.lower() for x in\n                       [cls] + list(self.get_bases(cls))]\n            parents[cls] = classes\n        return self.key in parents[cls]\n\n    def match_rule_name(self, rule_name):\n        return self.key == rule_name.lower()",
  "def __init__(self):\n        object.__init__(self)\n        object.__setattr__(self, '_obj', None)",
  "def _ensure_app(self):\n        app = object.__getattribute__(self, '_obj')\n        if app is None:\n            from kivy.app import App\n            app = App.get_running_app()\n            object.__setattr__(self, '_obj', app)\n            # Clear cached application instance, when it stops\n            app.bind(on_stop=lambda instance:\n                     object.__setattr__(self, '_obj', None))\n        return app",
  "def __getattribute__(self, name):\n        object.__getattribute__(self, '_ensure_app')()\n        return getattr(object.__getattribute__(self, '_obj'), name)",
  "def __delattr__(self, name):\n        object.__getattribute__(self, '_ensure_app')()\n        delattr(object.__getattribute__(self, '_obj'), name)",
  "def __setattr__(self, name, value):\n        object.__getattribute__(self, '_ensure_app')()\n        setattr(object.__getattribute__(self, '_obj'), name, value)",
  "def __bool__(self):\n        object.__getattribute__(self, '_ensure_app')()\n        return bool(object.__getattribute__(self, '_obj'))",
  "def __str__(self):\n        object.__getattribute__(self, '_ensure_app')()\n        return str(object.__getattribute__(self, '_obj'))",
  "def __repr__(self):\n        object.__getattribute__(self, '_ensure_app')()\n        return repr(object.__getattribute__(self, '_obj'))",
  "def __init__(self, context, line, message, cause=None):\n        self.filename = context.filename or '<inline>'\n        self.line = line\n        sourcecode = context.sourcecode\n        sc_start = max(0, line - 2)\n        sc_stop = min(len(sourcecode), line + 3)\n        sc = ['...']\n        for x in range(sc_start, sc_stop):\n            if x == line:\n                sc += ['>> %4d:%s' % (line + 1, sourcecode[line][1])]\n            else:\n                sc += ['   %4d:%s' % (x + 1, sourcecode[x][1])]\n        sc += ['...']\n        sc = '\\n'.join(sc)\n\n        message = 'Parser: File \"%s\", line %d:\\n%s\\n%s' % (\n            self.filename, self.line + 1, sc, message)\n        if cause:\n            message += '\\n' + ''.join(traceback.format_tb(cause))\n\n        super(ParserException, self).__init__(message)",
  "def __init__(self, ctx, line, name, value, ignore_prev=False):\n        super(ParserRuleProperty, self).__init__()\n        #: Associated parser\n        self.ctx = ctx\n        #: Line of the rule\n        self.line = line\n        #: Name of the property\n        self.name = name\n        #: Value of the property\n        self.value = value\n        #: Compiled value\n        self.co_value = None\n        #: Compilation mode\n        self.mode = None\n        #: Watched keys\n        self.watched_keys = None\n        #: Stats\n        self.count = 0\n        #: whether previous rules targeting name should be cleared\n        self.ignore_prev = ignore_prev",
  "def precompile(self):\n        name = self.name\n        value = self.value\n\n        # first, remove all the string from the value\n        tmp = sub(lang_str, '', self.value)\n\n        # detecting how to handle the value according to the key name\n        mode = self.mode\n        if self.mode is None:\n            self.mode = mode = 'exec' if name[:3] == 'on_' else 'eval'\n        if mode == 'eval':\n            # if we don't detect any string/key in it, we can eval and give the\n            # result\n            if re.search(lang_key, tmp) is None:\n                value = '\\n' * self.line + value\n                self.co_value = eval(\n                    compile(value, self.ctx.filename or '<string>', 'eval')\n                )\n                return\n\n        # ok, we can compile.\n        value = '\\n' * self.line + value\n        self.co_value = compile(value, self.ctx.filename or '<string>', mode)\n\n        # for exec mode, we don't need to watch any keys.\n        if mode == 'exec':\n            return\n\n        # now, detect obj.prop\n        # find all the fstrings in the  value\n        fstrings = lang_fstr.findall(value)\n        wk = set()\n        for s in fstrings:\n            expression = ast.parse(s)\n            wk |= set(self.get_names_from_expression(expression.body[0].value))\n\n        # first, remove all the string from the value\n        tmp = sub(lang_str, '', value)\n        idx = tmp.find('#')\n        if idx != -1:\n            tmp = tmp[:idx]\n        # detect key.value inside value, and split them\n        wk |= set(findall(lang_keyvalue, tmp))\n        if wk:\n            self.watched_keys = [x.split('.') for x in wk]\n        if findall(lang_tr, tmp):\n            if self.watched_keys:\n                self.watched_keys += [['_']]\n            else:\n                self.watched_keys = [['_']]",
  "def get_names_from_expression(cls, node):\n        \"\"\"\n        Look for all the symbols used in an ast node.\n        \"\"\"\n        if isinstance(node, ast.Name):\n            yield node.id\n\n        if isinstance(node, (ast.JoinedStr, ast.BoolOp)):\n            for n in node.values:\n                if isinstance(n, ast.Str):\n                    # NOTE: required for python3.6\n                    yield from cls.get_names_from_expression(n.s)\n                else:\n                    yield from cls.get_names_from_expression(n.value)\n\n        if isinstance(node, ast.BinOp):\n            yield from cls.get_names_from_expression(node.right)\n            yield from cls.get_names_from_expression(node.left)\n\n        if isinstance(node, ast.IfExp):\n            yield from cls.get_names_from_expression(node.test)\n            yield from cls.get_names_from_expression(node.body)\n            yield from cls.get_names_from_expression(node.orelse)\n\n        if isinstance(node, ast.Subscript):\n            yield from cls.get_names_from_expression(node.value)\n            yield from cls.get_names_from_expression(node.slice)\n\n        if isinstance(node, ast.Slice):\n            yield from cls.get_names_from_expression(node.lower)\n            yield from cls.get_names_from_expression(node.upper)\n            yield from cls.get_names_from_expression(node.step)\n\n        if isinstance(\n            node,\n            (ast.ListComp, ast.DictComp, ast.SetComp, ast.GeneratorExp)\n        ):\n            for g in node.generators:\n                yield from cls.get_names_from_expression(g.iter)\n\n        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n            for elt in node.elts:\n                yield from cls.get_names_from_expression(elt)\n\n        if isinstance(node, ast.Dict):\n            for val in node.values:\n                yield from cls.get_names_from_expression(val)\n\n        if isinstance(node, ast.UnaryOp):\n            yield from cls.get_names_from_expression(node.operand)\n\n        if isinstance(node, ast.comprehension):\n            yield from cls.get_names_from_expression(node.iter.value)\n\n        if isinstance(node, ast.Attribute):\n            if isinstance(node.value, ast.Name):\n                yield f'{node.value.id}.{node.attr}'\n\n        if isinstance(node, ast.Call):\n            yield from cls.get_names_from_expression(node.func)\n\n            for arg in node.args:\n                yield from cls.get_names_from_expression(arg)\n            for keyword in node.keywords:\n                yield from cls.get_names_from_expression(keyword.value)",
  "def __repr__(self):\n        return '<ParserRuleProperty name=%r filename=%s:%d ' \\\n               'value=%r watched_keys=%r>' % (\n                   self.name, self.ctx.filename, self.line + 1,\n                   self.value, self.watched_keys)",
  "def __init__(self, ctx, line, name, level):\n        super(ParserRule, self).__init__()\n        #: Level of the rule in the kv\n        self.level = level\n        #: Associated parser\n        self.ctx = ctx\n        #: Line of the rule\n        self.line = line\n        #: Name of the rule\n        self.name = name\n        #: List of children to create\n        self.children = []\n        #: Id given to the rule\n        self.id = None\n        #: Properties associated to the rule\n        self.properties = OrderedDict()\n        #: Canvas normal\n        self.canvas_root = None\n        #: Canvas before\n        self.canvas_before = None\n        #: Canvas after\n        self.canvas_after = None\n        #: Handlers associated to the rule\n        self.handlers = []\n        #: Properties cache list: mark which class have already been checked\n        self.cache_marked = []\n        #: Indicate if any previous rules should be avoided.\n        self.avoid_previous_rules = False\n\n        if level == 0:\n            self._detect_selectors()\n        else:\n            self._forbid_selectors()",
  "def precompile(self):\n        for x in self.properties.values():\n            x.precompile()\n        for x in self.handlers:\n            x.precompile()\n        for x in self.children:\n            x.precompile()\n        if self.canvas_before:\n            self.canvas_before.precompile()\n        if self.canvas_root:\n            self.canvas_root.precompile()\n        if self.canvas_after:\n            self.canvas_after.precompile()",
  "def create_missing(self, widget):\n        # check first if the widget class already been processed by this rule\n        cls = widget.__class__\n        if cls in self.cache_marked:\n            return\n        self.cache_marked.append(cls)\n        for name in self.properties:\n            if hasattr(widget, name):\n                continue\n            value = self.properties[name].co_value\n            if type(value) is CodeType:\n                value = None\n            widget.create_property(name, value, default_value=False)",
  "def _forbid_selectors(self):\n        c = self.name[0]\n        if c == '<' or c == '[':\n            raise ParserException(\n                self.ctx, self.line,\n                'Selectors rules are allowed only at the first level')",
  "def _detect_selectors(self):\n        c = self.name[0]\n        if c == '<':\n            self._build_rule()\n        elif c == '[':\n            self._build_template()\n        else:\n            if self.ctx.root is not None:\n                raise ParserException(\n                    self.ctx, self.line,\n                    'Only one root object is allowed by .kv')\n            self.ctx.root = self",
  "def _build_rule(self):\n        name = self.name\n        if __debug__:\n            trace('Builder: build rule for %s' % name)\n        if name[0] != '<' or name[-1] != '>':\n            raise ParserException(self.ctx, self.line,\n                                  'Invalid rule (must be inside <>)')\n\n        # if the very first name start with a -, avoid previous rules\n        name = name[1:-1]\n        if name[:1] == '-':\n            self.avoid_previous_rules = True\n            name = name[1:]\n\n        for rule in re.split(lang_cls_split_pat, name):\n            crule = None\n\n            if not rule:\n                raise ParserException(self.ctx, self.line,\n                                      'Empty rule detected')\n\n            if '@' in rule:\n                # new class creation ?\n                # ensure the name is correctly written\n                rule, baseclasses = rule.split('@', 1)\n                if not re.match(lang_key, rule):\n                    raise ParserException(self.ctx, self.line,\n                                          'Invalid dynamic class name')\n\n                # save the name in the dynamic classes dict.\n                self.ctx.dynamic_classes[rule] = baseclasses\n                crule = ParserSelectorName(rule)\n\n            else:\n                # classical selectors.\n\n                if rule[0] == '.':\n                    crule = ParserSelectorClass(rule[1:])\n                else:\n                    crule = ParserSelectorName(rule)\n\n            self.ctx.rules.append((crule, self))",
  "def _build_template(self):\n        name = self.name\n        exception = ParserException(\n            self.ctx, self.line,\n            'Deprecated Kivy lang template syntax used \"{}\". Templates will '\n            'be removed in a future version'.format(name))\n        if name not in ('[FileListEntry@FloatLayout+TreeViewNode]',\n                        '[FileIconEntry@Widget]',\n                        '[AccordionItemTitle@Label]'):\n            Logger.warning(exception)\n\n        if __debug__:\n            trace('Builder: build template for %s' % name)\n        if name[0] != '[' or name[-1] != ']':\n            raise ParserException(self.ctx, self.line,\n                                  'Invalid template (must be inside [])')\n        item_content = name[1:-1]\n        if '@' not in item_content:\n            raise ParserException(self.ctx, self.line,\n                                  'Invalid template name (missing @)')\n        template_name, template_root_cls = item_content.split('@')\n        self.ctx.templates.append((template_name, template_root_cls, self))",
  "def __repr__(self):\n        return '<ParserRule name=%r>' % (self.name, )",
  "def __init__(self, **kwargs):\n        super(Parser, self).__init__()\n        self.rules = []\n        self.templates = []\n        self.root = None\n        self.sourcecode = []\n        self.directives = []\n        self.dynamic_classes = {}\n        self.filename = kwargs.get('filename', None)\n        content = kwargs.get('content', None)\n        if content is None:\n            raise ValueError('No content passed')\n        self.parse(content)",
  "def execute_directives(self):\n        global __KV_INCLUDES__\n        for ln, cmd in self.directives:\n            cmd = cmd.strip()\n            if __debug__:\n                trace('Parser: got directive <%s>' % cmd)\n            if cmd[:5] == 'kivy ':\n                version = cmd[5:].strip()\n                if len(version.split('.')) == 2:\n                    version += '.0'\n                require(version)\n            elif cmd[:4] == 'set ':\n                try:\n                    name, value = cmd[4:].strip().split(' ', 1)\n                except:\n                    Logger.exception('')\n                    raise ParserException(self, ln, 'Invalid directive syntax')\n                try:\n                    value = eval(value, global_idmap)\n                except:\n                    Logger.exception('')\n                    raise ParserException(self, ln, 'Invalid value')\n                global_idmap[name] = value\n            elif cmd[:8] == 'include ':\n                ref = cmd[8:].strip()\n                force_load = False\n\n                if ref[:6] == 'force ':\n                    ref = ref[6:].strip()\n                    force_load = True\n\n                # if #:include [force] \"path with quotes around\"\n                if ref[0] == ref[-1] and ref[0] in ('\"', \"'\"):\n                    c = ref[:3].count(ref[0])\n                    ref = ref[c:-c] if c != 2 else ref\n\n                if ref[-3:] != '.kv':\n                    Logger.warning('Lang: {0} does not have a valid Kivy'\n                                'Language extension (.kv)'.format(ref))\n                    break\n                if ref in __KV_INCLUDES__:\n                    if not os.path.isfile(resource_find(ref) or ref):\n                        raise ParserException(self, ln,\n                                              'Invalid or unknown file: {0}'\n                                              .format(ref))\n                    if not force_load:\n                        Logger.warning('Lang: {0} has already been included!'\n                                    .format(ref))\n                        continue\n                    else:\n                        Logger.debug('Lang: Reloading {0} '\n                                     'because include was forced.'\n                                     .format(ref))\n                        kivy.lang.builder.Builder.unload_file(ref)\n                        kivy.lang.builder.Builder.load_file(ref)\n                        continue\n                Logger.debug('Lang: Including file: {0}'.format(0))\n                __KV_INCLUDES__.append(ref)\n                kivy.lang.builder.Builder.load_file(ref)\n            elif cmd[:7] == 'import ':\n                package = cmd[7:].strip()\n                z = package.split()\n                if len(z) != 2:\n                    raise ParserException(self, ln, 'Invalid import syntax')\n                alias, package = z\n                try:\n                    if package not in sys.modules:\n                        try:\n                            mod = importlib.__import__(package)\n                        except ImportError:\n                            module_name = '.'.join(package.split('.')[:-1])\n                            mod = importlib.__import__(module_name)\n                        # resolve the whole thing\n                        for part in package.split('.')[1:]:\n                            mod = getattr(mod, part)\n                    else:\n                        mod = sys.modules[package]\n                    global_idmap[alias] = mod\n                except ImportError:\n                    Logger.exception('')\n                    raise ParserException(self, ln,\n                                          'Unable to import package %r' %\n                                          package)\n            else:\n                raise ParserException(self, ln, 'Unknown directive')",
  "def parse(self, content):\n        '''Parse the contents of a Parser file and return a list\n        of root objects.\n        '''\n        # Read and parse the lines of the file\n        lines = content.splitlines()\n        if not lines:\n            return\n        num_lines = len(lines)\n        lines = list(zip(list(range(num_lines)), lines))\n        self.sourcecode = lines[:]\n\n        if __debug__:\n            trace('Parser: parsing %d lines' % num_lines)\n\n        # Strip all comments\n        self.strip_comments(lines)\n\n        # Execute directives\n        self.execute_directives()\n\n        # Get object from the first level\n        objects, remaining_lines = self.parse_level(0, lines)\n\n        # Precompile rules tree\n        for rule in objects:\n            rule.precompile()\n\n        # After parsing, there should be no remaining lines\n        # or there's an error we did not catch earlier.\n        if remaining_lines:\n            ln, content = remaining_lines[0]\n            raise ParserException(self, ln, 'Invalid data (not parsed)')",
  "def strip_comments(self, lines):\n        '''Remove all comments from all lines in-place.\n           Comments need to be on a single line and not at the end of a line.\n           i.e. a comment line's first non-whitespace character must be a #.\n        '''\n        # extract directives\n        for ln, line in lines[:]:\n            stripped = line.strip()\n            if stripped[:2] == '#:':\n                self.directives.append((ln, stripped[2:]))\n            if stripped[:1] == '#':\n                lines.remove((ln, line))\n            if not stripped:\n                lines.remove((ln, line))",
  "def parse_level(self, level, lines, spaces=0):\n        '''Parse the current level (level * spaces) indentation.\n        '''\n        indent = spaces * level if spaces > 0 else 0\n        objects = []\n\n        current_object = None\n        current_property = None\n        current_propobject = None\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            ln, content = line\n\n            # Get the number of space\n            tmp = content.lstrip(' \\t')\n\n            # Replace any tab with 4 spaces\n            tmp = content[:len(content) - len(tmp)]\n            tmp = tmp.replace('\\t', '    ')\n\n            # first indent designates the indentation\n            if spaces == 0:\n                spaces = len(tmp)\n\n            count = len(tmp)\n\n            if spaces > 0 and count % spaces != 0:\n                raise ParserException(self, ln,\n                                      'Invalid indentation, '\n                                      'must be a multiple of '\n                                      '%s spaces' % spaces)\n            content = content.strip()\n            rlevel = count // spaces if spaces > 0 else 0\n\n            # Level finished\n            if count < indent:\n                return objects, lines[i - 1:]\n\n            # Current level, create an object\n            elif count == indent:\n                x = content.split(':', 1)\n                if not x[0]:\n                    raise ParserException(self, ln, 'Identifier missing')\n                if (len(x) == 2 and len(x[1]) and\n                        not x[1].lstrip().startswith('#')):\n                    raise ParserException(self, ln,\n                                          'Invalid data after declaration')\n                name = x[0].rstrip()\n                # if it's not a root rule, then we got some restriction\n                # aka, a valid name, without point or everything else\n                if count != 0:\n                    if False in [ord(z) in Parser.PROP_RANGE for z in name]:\n                        raise ParserException(self, ln, 'Invalid class name')\n\n                current_object = ParserRule(self, ln, name, rlevel)\n                current_property = None\n                objects.append(current_object)\n\n            # Next level, is it a property or an object ?\n            elif count == indent + spaces:\n                x = content.split(':', 1)\n                if not x[0]:\n                    raise ParserException(self, ln, 'Identifier missing')\n\n                # It's a class, add to the current object as a children\n                current_property = None\n                name = x[0].rstrip()\n                ignore_prev = name[0] == '-'\n                if ignore_prev:\n                    name = name[1:]\n\n                if ord(name[0]) in Parser.CLASS_RANGE:\n                    if ignore_prev:\n                        raise ParserException(\n                            self, ln, 'clear previous, `-`, not allowed here')\n                    _objects, _lines = self.parse_level(\n                        level + 1, lines[i:], spaces)\n                    current_object.children = _objects\n                    lines = _lines\n                    i = 0\n\n                # It's a property\n                else:\n                    if name not in Parser.PROP_ALLOWED:\n                        if not all(ord(z) in Parser.PROP_RANGE for z in name):\n                            raise ParserException(self, ln,\n                                                  'Invalid property name')\n                    if len(x) == 1:\n                        raise ParserException(self, ln, 'Syntax error')\n                    value = x[1].strip()\n                    if name == 'id':\n                        if len(value) <= 0:\n                            raise ParserException(self, ln, 'Empty id')\n                        if value in ('self', 'root'):\n                            raise ParserException(\n                                self, ln,\n                                'Invalid id, cannot be \"self\" or \"root\"')\n                        current_object.id = value\n                    elif len(value):\n                        rule = ParserRuleProperty(\n                            self, ln, name, value, ignore_prev)\n                        if name[:3] == 'on_':\n                            current_object.handlers.append(rule)\n                        else:\n                            ignore_prev = False\n                            current_object.properties[name] = rule\n                    else:\n                        current_property = name\n                        current_propobject = None\n\n                    if ignore_prev:  # it wasn't consumed\n                        raise ParserException(\n                            self, ln, 'clear previous, `-`, not allowed here')\n\n            # Two more levels?\n            elif count == indent + 2 * spaces:\n                if current_property in (\n                        'canvas', 'canvas.after', 'canvas.before'):\n                    _objects, _lines = self.parse_level(\n                        level + 2, lines[i:], spaces)\n                    rl = ParserRule(self, ln, current_property, rlevel)\n                    rl.children = _objects\n                    if current_property == 'canvas':\n                        current_object.canvas_root = rl\n                    elif current_property == 'canvas.before':\n                        current_object.canvas_before = rl\n                    else:\n                        current_object.canvas_after = rl\n                    current_property = None\n                    lines = _lines\n                    i = 0\n                else:\n                    if current_propobject is None:\n                        current_propobject = ParserRuleProperty(\n                            self, ln, current_property, content)\n                        if current_property[:3] == 'on_':\n                            current_object.handlers.append(current_propobject)\n                        else:\n                            current_object.properties[current_property] = \\\n                                current_propobject\n                    else:\n                        current_propobject.value += '\\n' + content\n\n            # Too much indentation, invalid\n            else:\n                raise ParserException(self, ln,\n                                      'Invalid indentation (too many levels)')\n\n            # Check the next line\n            i += 1\n\n        return objects, []",
  "def __init__(self, key):\n        self.key = key.lower()",
  "def match(self, widget):\n        raise NotImplementedError",
  "def __repr__(self):\n        return '<%s key=%s>' % (self.__class__.__name__, self.key)",
  "def match(self, widget):\n        return self.key in widget.cls",
  "def get_bases(self, cls):\n        for base in cls.__bases__:\n            if base.__name__ == 'object':\n                break\n            yield base\n            if base.__name__ == 'Widget':\n                break\n            for cbase in self.get_bases(base):\n                yield cbase",
  "def match(self, widget):\n        parents = ParserSelectorName.parents\n        cls = widget.__class__\n        if cls not in parents:\n            classes = [x.__name__.lower() for x in\n                       [cls] + list(self.get_bases(cls))]\n            parents[cls] = classes\n        return self.key in parents[cls]",
  "def match_rule_name(self, rule_name):\n        return self.key == rule_name.lower()",
  "class BuilderException(ParserException):\n    '''Exception raised when the Builder fails to apply a rule on a widget.\n    '''\n    pass",
  "def get_proxy(widget):\n    try:\n        return widget.proxy_ref\n    except AttributeError:\n        return widget",
  "def custom_callback(__kvlang__, idmap, *largs, **kwargs):\n    idmap['args'] = largs\n    exec(__kvlang__.co_value, idmap)",
  "def call_fn(args, instance, v):\n    element, key, value, rule, idmap = args\n    if __debug__:\n        trace('Lang: call_fn %s, key=%s, value=%r, %r' % (\n            element, key, value, rule.value))\n    rule.count += 1\n    e_value = eval(value, idmap)\n    if __debug__:\n        trace('Lang: call_fn => value=%r' % (e_value, ))\n    setattr(element, key, e_value)",
  "def delayed_call_fn(args, instance, v):\n    # it's already on the list\n    if args[-1] is not None:\n        return\n\n    global _delayed_start\n    if _delayed_start is None:\n        _delayed_start = args\n        args[-1] = StopIteration\n    else:\n        args[-1] = _delayed_start\n        _delayed_start = args",
  "def update_intermediates(base, keys, bound, s, fn, args, instance, value):\n    ''' Function that is called when an intermediate property is updated\n    and `rebind` of that property is True. In that case, we unbind\n    all bound funcs that were bound to attrs of the old value of the\n    property and rebind them to the new value of the property.\n\n    For example, if the rule is `self.a.b.c.d`, then when b is changed, we\n    unbind from `b`, `c` and `d`, if they were bound before (they were not\n    None and `rebind` of the respective properties was True) and we rebind\n    to the new values of the attrs `b`, `c``, `d` that are not None and\n    `rebind` is True.\n\n    :Parameters:\n        `base`\n            A (proxied) ref to the base widget, `self` in the example\n            above.\n        `keys`\n            A list of the name off the attrs of `base` being watched. In\n            the example above it'd be `['a', 'b', 'c', 'd']`.\n        `bound`\n            A list 4-tuples, each tuple being (widget, attr, callback, uid)\n            representing callback functions bound to the attributed `attr`\n            of `widget`. `uid` is returned by `fbind` when binding.\n            The callback may be None, in which case the attr\n            was not bound, but is there to be able to walk the attr tree.\n            E.g. in the example above, if `b` was not an eventdispatcher,\n            `(_b_ref_, `c`, None)` would be added to the list so we can get\n            to `c` and `d`, which may be eventdispatchers and their attrs.\n        `s`\n            The index in `keys` of the of the attr that needs to be\n            updated. That is all the keys from `s` and further will be\n            rebound, since the `s` key was changed. In bound, the\n            corresponding index is `s - 1`. If `s` is None, we start from\n            1 (first attr).\n        `fn`\n            The function to be called args, `args` on bound callback.\n    '''\n    # first remove all the old bound functions from `s` and down.\n    for f, k, fun, uid in bound[s:]:\n        if fun is None:\n            continue\n        try:\n            f.unbind_uid(k, uid)\n        except ReferenceError:\n            pass\n    del bound[s:]\n\n    # find the first attr from which we need to start rebinding.\n    f = getattr(*bound[-1][:2])\n    if f is None:\n        fn(args, None, None)\n        return\n    s += 1\n    append = bound.append\n\n    # bind all attrs, except last to update_intermediates\n    for val in keys[s:-1]:\n        # if we need to dynamically rebind, bindm otherwise just\n        # add the attr to the list\n        if isinstance(f, (EventDispatcher, Observable)):\n            prop = f.property(val, True)\n            if prop is not None and getattr(prop, 'rebind', False):\n                # fbind should not dispatch, otherwise\n                # update_intermediates might be called in the middle\n                # here messing things up\n                uid = f.fbind(\n                    val, update_intermediates, base, keys, bound, s, fn, args)\n                append([f.proxy_ref, val, update_intermediates, uid])\n            else:\n                append([f.proxy_ref, val, None, None])\n        else:\n            append([getattr(f, 'proxy_ref', f), val, None, None])\n\n        f = getattr(f, val, None)\n        if f is None:\n            break\n        s += 1\n\n    # for the last attr we bind directly to the setting function,\n    # because that attr sets the value of the rule.\n    if isinstance(f, (EventDispatcher, Observable)):\n        uid = f.fbind(keys[-1], fn, args)\n        if uid:\n            append([f.proxy_ref, keys[-1], fn, uid])\n    # when we rebind we have to update the\n    # rule with the most recent value, otherwise, the value might be wrong\n    # and wouldn't be updated since we might not have tracked it before.\n    # This only happens for a callback when rebind was True for the prop.\n    fn(args, None, None)",
  "def create_handler(iself, element, key, value, rule, idmap, delayed=False):\n    idmap = copy(idmap)\n    idmap.update(global_idmap)\n    idmap['self'] = iself.proxy_ref\n    bound_list = _handlers[iself.uid][key]\n    handler_append = bound_list.append\n\n    # we need a hash for when delayed, so we don't execute duplicate canvas\n    # callbacks from the same handler during a sync op\n    if delayed:\n        fn = delayed_call_fn\n        args = [element, key, value, rule, idmap, None]  # see _delayed_start\n    else:\n        fn = call_fn\n        args = (element, key, value, rule, idmap)\n\n    # bind every key.value\n    if rule.watched_keys is not None:\n        for keys in rule.watched_keys:\n            base = idmap.get(keys[0])\n            if base is None:\n                continue\n            f = base = getattr(base, 'proxy_ref', base)\n            bound = []\n            was_bound = False\n            append = bound.append\n\n            # bind all attrs, except last to update_intermediates\n            k = 1\n            for val in keys[1:-1]:\n                # if we need to dynamically rebind, bindm otherwise\n                # just add the attr to the list\n                if isinstance(f, (EventDispatcher, Observable)):\n                    prop = f.property(val, True)\n                    if prop is not None and getattr(prop, 'rebind', False):\n                        # fbind should not dispatch, otherwise\n                        # update_intermediates might be called in the middle\n                        # here messing things up\n                        uid = f.fbind(\n                            val, update_intermediates, base, keys, bound, k,\n                            fn, args)\n                        append([f.proxy_ref, val, update_intermediates, uid])\n                        was_bound = True\n                    else:\n                        append([f.proxy_ref, val, None, None])\n                elif not isinstance(f, type):\n                    append([getattr(f, 'proxy_ref', f), val, None, None])\n                else:\n                    append([f, val, None, None])\n                f = getattr(f, val, None)\n                if f is None:\n                    break\n                k += 1\n\n            # for the last attr we bind directly to the setting\n            # function, because that attr sets the value of the rule.\n            if isinstance(f, (EventDispatcher, Observable)):\n                uid = f.fbind(keys[-1], fn, args)  # f is not None\n                if uid:\n                    append([f.proxy_ref, keys[-1], fn, uid])\n                    was_bound = True\n            if was_bound:\n                handler_append(bound)\n\n    try:\n        return eval(value, idmap), bound_list\n    except Exception as e:\n        tb = sys.exc_info()[2]\n        raise BuilderException(rule.ctx, rule.line,\n                               '{}: {}'.format(e.__class__.__name__, e),\n                               cause=tb)",
  "class BuilderBase(object):\n    '''The Builder is responsible for creating a :class:`Parser` for parsing a\n    kv file, merging the results into its internal rules, templates, etc.\n\n    By default, :class:`Builder` is a global Kivy instance used in widgets\n    that you can use to load other kv files in addition to the default ones.\n    '''\n\n    def __init__(self):\n        super(BuilderBase, self).__init__()\n        self._match_cache = {}\n        self._match_name_cache = {}\n        self.files = []\n        self.dynamic_classes = {}\n        self.templates = {}\n        self.rules = []\n        self.rulectx = {}\n\n    @classmethod\n    def create_from(cls, builder):\n        \"\"\"Creates a instance of the class, and initializes to the state of\n        ``builder``.\n\n        :param builder: The builder to initialize from.\n        :return: A new instance of this class.\n        \"\"\"\n        obj = cls()\n        obj._match_cache = copy(builder._match_cache)\n        obj._match_name_cache = copy(builder._match_name_cache)\n        obj.files = copy(builder.files)\n        obj.dynamic_classes = copy(builder.dynamic_classes)\n        obj.templates = copy(builder.templates)\n        obj.rules = list(builder.rules)\n        assert not builder.rulectx\n        obj.rulectx = dict(builder.rulectx)\n\n        return obj\n\n    def load_file(self, filename, encoding='utf8', **kwargs):\n        '''Insert a file into the language builder and return the root widget\n        (if defined) of the kv file.\n\n        :parameters:\n            `rulesonly`: bool, defaults to False\n                If True, the Builder will raise an exception if you have a root\n                widget inside the definition.\n\n            `encoding`: File character encoding. Defaults to utf-8,\n        '''\n\n        filename = resource_find(filename) or filename\n        if __debug__:\n            trace('Lang: load file %s, using %s encoding', filename, encoding)\n\n        kwargs['filename'] = filename\n        with open(filename, 'r', encoding=encoding) as fd:\n            data = fd.read()\n            return self.load_string(data, **kwargs)\n\n    def unload_file(self, filename):\n        '''Unload all rules associated with a previously imported file.\n\n        .. versionadded:: 1.0.8\n\n        .. warning::\n\n            This will not remove rules or templates already applied/used on\n            current widgets. It will only effect the next widgets creation or\n            template invocation.\n        '''\n        # remove rules and templates\n        filename = resource_find(filename) or filename\n        self.rules = [x for x in self.rules if x[1].ctx.filename != filename]\n        self._clear_matchcache()\n        templates = {}\n        for x, y in self.templates.items():\n            if y[2] != filename:\n                templates[x] = y\n        self.templates = templates\n\n        if filename in self.files:\n            self.files.remove(filename)\n\n        # unregister all the dynamic classes\n        Factory.unregister_from_filename(filename)\n\n    def load_string(self, string, **kwargs):\n        '''Insert a string into the Language Builder and return the root widget\n        (if defined) of the kv string.\n\n        :Parameters:\n            `rulesonly`: bool, defaults to False\n                If True, the Builder will raise an exception if you have a root\n                widget inside the definition.\n            `filename`: str, defaults to None\n                If specified, the filename used to index the kv rules.\n\n        The filename parameter can be used to unload kv strings in the same way\n        as you unload kv files. This can be achieved using pseudo file names\n        e.g.::\n\n            Build.load_string(\"\"\"\n                <MyRule>:\n                    Label:\n                        text=\"Hello\"\n            \"\"\", filename=\"myrule.kv\")\n\n        can be unloaded via::\n\n            Build.unload_file(\"myrule.kv\")\n\n        '''\n\n        kwargs.setdefault('rulesonly', False)\n        self._current_filename = fn = kwargs.get('filename', None)\n\n        # put a warning if a file is loaded multiple times\n        if fn in self.files:\n            Logger.warning(\n                'Lang: The file {} is loaded multiples times, '\n                'you might have unwanted behaviors.'.format(fn))\n\n        try:\n            # parse the string\n            parser = Parser(content=string, filename=fn)\n\n            # merge rules with our rules\n            self.rules.extend(parser.rules)\n            self._clear_matchcache()\n\n            # add the template found by the parser into ours\n            for name, cls, template in parser.templates:\n                self.templates[name] = (cls, template, fn)\n                Factory.register(name,\n                                 cls=partial(self.template, name),\n                                 is_template=True, warn=True)\n\n            # register all the dynamic classes\n            for name, baseclasses in parser.dynamic_classes.items():\n                Factory.register(name, baseclasses=baseclasses, filename=fn,\n                                 warn=True)\n\n            # create root object is exist\n            if kwargs['rulesonly'] and parser.root:\n                filename = kwargs.get('rulesonly', '<string>')\n                raise Exception('The file <%s> contain also non-rules '\n                                'directives' % filename)\n\n            # save the loaded files only if there is a root without\n            # template/dynamic classes\n            if fn and (parser.templates or\n                       parser.dynamic_classes or parser.rules):\n                self.files.append(fn)\n\n            if parser.root:\n                widget = Factory.get(parser.root.name)(__no_builder=True)\n                rule_children = []\n                widget.apply_class_lang_rules(\n                    root=widget, rule_children=rule_children)\n                self._apply_rule(\n                    widget, parser.root, parser.root,\n                    rule_children=rule_children)\n\n                for child in rule_children:\n                    child.dispatch('on_kv_post', widget)\n                widget.dispatch('on_kv_post', widget)\n                return widget\n        finally:\n            self._current_filename = None\n\n    def template(self, *args, **ctx):\n        '''Create a specialized template using a specific context.\n\n        .. versionadded:: 1.0.5\n\n        With templates, you can construct custom widgets from a kv lang\n        definition by giving them a context. Check :ref:`Template usage\n        <template_usage>`.\n        '''\n        # Prevent naming clash with whatever the user might be putting into the\n        # ctx as key.\n        name = args[0]\n        if name not in self.templates:\n            raise Exception('Unknown <%s> template name' % name)\n        baseclasses, rule, fn = self.templates[name]\n        key = '%s|%s' % (name, baseclasses)\n        cls = Cache.get('kv.lang', key)\n        if cls is None:\n            rootwidgets = []\n            for basecls in baseclasses.split('+'):\n                rootwidgets.append(Factory.get(basecls))\n            cls = type(name, tuple(rootwidgets), {})\n            Cache.append('kv.lang', key, cls)\n        widget = cls()\n        # in previous versions, ``ctx`` is passed as is as ``template_ctx``\n        # preventing widgets in it from be collected by the GC. This was\n        # especially relevant to AccordionItem's title_template.\n        proxy_ctx = {k: get_proxy(v) for k, v in ctx.items()}\n        self._apply_rule(widget, rule, rule, template_ctx=proxy_ctx)\n        return widget\n\n    def apply_rules(\n            self, widget, rule_name, ignored_consts=set(), rule_children=None,\n            dispatch_kv_post=False):\n        '''Search all the rules that match the name `rule_name`\n        and apply them to `widget`.\n\n        .. versionadded:: 1.10.0\n\n        :Parameters:\n\n            `widget`: :class:`~kivy.uix.widget.Widget`\n                The widget to whom the matching rules should be applied to.\n            `ignored_consts`: set\n                A set or list type whose elements are property names for which\n                constant KV rules (i.e. those that don't create bindings) of\n                that widget will not be applied. This allows e.g. skipping\n                constant rules that overwrite a value initialized in python.\n            `rule_children`: list\n                If not ``None``, it should be a list that will be populated\n                with all the widgets created by the kv rules being applied.\n\n                .. versionchanged:: 1.11.0\n\n            `dispatch_kv_post`: bool\n                Normally the class `Widget` dispatches the `on_kv_post` event\n                to widgets created during kv rule application.\n                But if the rules are manually applied by calling :meth:`apply`,\n                that may not happen, so if this is `True`, we will dispatch the\n                `on_kv_post` event where needed after applying the rules to\n                `widget` (we won't dispatch it for `widget` itself).\n\n                Defaults to False.\n\n                .. versionchanged:: 1.11.0\n        '''\n        rules = self.match_rule_name(rule_name)\n        if __debug__:\n            trace('Lang: Found %d rules for %s' % (len(rules), rule_name))\n        if not rules:\n            return\n\n        if dispatch_kv_post:\n            rule_children = rule_children if rule_children is not None else []\n        for rule in rules:\n            self._apply_rule(\n                widget, rule, rule, ignored_consts=ignored_consts,\n                rule_children=rule_children)\n        if dispatch_kv_post:\n            for w in rule_children:\n                w.dispatch('on_kv_post', widget)\n\n    def apply(self, widget, ignored_consts=set(), rule_children=None,\n              dispatch_kv_post=False):\n        '''Search all the rules that match the widget and apply them.\n\n        :Parameters:\n\n            `widget`: :class:`~kivy.uix.widget.Widget`\n                The widget whose class rules should be applied to this widget.\n            `ignored_consts`: set\n                A set or list type whose elements are property names for which\n                constant KV rules (i.e. those that don't create bindings) of\n                that widget will not be applied. This allows e.g. skipping\n                constant rules that overwrite a value initialized in python.\n            `rule_children`: list\n                If not ``None``, it should be a list that will be populated\n                with all the widgets created by the kv rules being applied.\n\n                .. versionchanged:: 1.11.0\n\n            `dispatch_kv_post`: bool\n                Normally the class `Widget` dispatches the `on_kv_post` event\n                to widgets created during kv rule application.\n                But if the rules are manually applied by calling :meth:`apply`,\n                that may not happen, so if this is `True`, we will dispatch the\n                `on_kv_post` event where needed after applying the rules to\n                `widget` (we won't dispatch it for `widget` itself).\n\n                Defaults to False.\n\n                .. versionchanged:: 1.11.0\n        '''\n        rules = self.match(widget)\n        if __debug__:\n            trace('Lang: Found %d rules for %s' % (len(rules), widget))\n        if not rules:\n            return\n\n        if dispatch_kv_post:\n            rule_children = rule_children if rule_children is not None else []\n        for rule in rules:\n            self._apply_rule(\n                widget, rule, rule, ignored_consts=ignored_consts,\n                rule_children=rule_children)\n        if dispatch_kv_post:\n            for w in rule_children:\n                w.dispatch('on_kv_post', widget)\n\n    def _clear_matchcache(self):\n        self._match_cache.clear()\n        self._match_name_cache.clear()\n\n    def _apply_rule(self, widget, rule, rootrule, template_ctx=None,\n                    ignored_consts=set(), rule_children=None):\n        # widget: the current instantiated widget\n        # rule: the current rule\n        # rootrule: the current root rule (for children of a rule)\n\n        # will collect reference to all the id in children\n        assert rule not in self.rulectx\n        self.rulectx[rule] = rctx = {\n            'ids': {'root': widget.proxy_ref},\n            'set': [], 'hdl': []}\n\n        # extract the context of the rootrule (not rule!)\n        assert rootrule in self.rulectx\n        rctx = self.rulectx[rootrule]\n\n        # if a template context is passed, put it as \"ctx\"\n        if template_ctx is not None:\n            rctx['ids']['ctx'] = QueryDict(template_ctx)\n\n        # if we got an id, put it in the root rule for a later global usage\n        if rule.id:\n            # use only the first word as `id` discard the rest.\n            rule.id = rule.id.split('#', 1)[0].strip()\n            rctx['ids'][rule.id] = widget.proxy_ref\n            # set id name as a attribute for root widget so one can in python\n            # code simply access root_widget.id_name\n            _ids = dict(rctx['ids'])\n            _root = _ids.pop('root')\n            _new_ids = _root.ids\n            for _key, _value in _ids.items():\n                if _value == _root:\n                    # skip on self\n                    continue\n                _new_ids[_key] = _value\n            _root.ids = _new_ids\n\n        # first, ensure that the widget have all the properties used in\n        # the rule if not, they will be created as ObjectProperty.\n        rule.create_missing(widget)\n\n        # build the widget canvas\n        if rule.canvas_before:\n            with widget.canvas.before:\n                self._build_canvas(widget.canvas.before, widget,\n                                   rule.canvas_before, rootrule)\n        if rule.canvas_root:\n            with widget.canvas:\n                self._build_canvas(widget.canvas, widget,\n                                   rule.canvas_root, rootrule)\n        if rule.canvas_after:\n            with widget.canvas.after:\n                self._build_canvas(widget.canvas.after, widget,\n                                   rule.canvas_after, rootrule)\n\n        # create children tree\n        Factory_get = Factory.get\n        Factory_is_template = Factory.is_template\n        for crule in rule.children:\n            cname = crule.name\n\n            if cname in ('canvas', 'canvas.before', 'canvas.after'):\n                raise ParserException(\n                    crule.ctx, crule.line,\n                    'Canvas instructions added in kv must '\n                    'be declared before child widgets.')\n\n            # depending if the child rule is a template or not, we are not\n            # having the same approach\n            cls = Factory_get(cname)\n\n            if Factory_is_template(cname):\n                # we got a template, so extract all the properties and\n                # handlers, and push them in a \"ctx\" dictionary.\n                ctx = {}\n                idmap = copy(global_idmap)\n                idmap.update({'root': rctx['ids']['root']})\n                if 'ctx' in rctx['ids']:\n                    idmap.update({'ctx': rctx['ids']['ctx']})\n                try:\n                    for prule in crule.properties.values():\n                        value = prule.co_value\n                        if type(value) is CodeType:\n                            value = eval(value, idmap)\n                        ctx[prule.name] = value\n                    for prule in crule.handlers:\n                        value = eval(prule.value, idmap)\n                        ctx[prule.name] = value\n                except Exception as e:\n                    tb = sys.exc_info()[2]\n                    raise BuilderException(\n                        prule.ctx, prule.line,\n                        '{}: {}'.format(e.__class__.__name__, e), cause=tb)\n\n                # create the template with an explicit ctx\n                child = cls(**ctx)\n                widget.add_widget(child)\n\n                # reference it on our root rule context\n                if crule.id:\n                    rctx['ids'][crule.id] = child\n\n            else:\n                # we got a \"normal\" rule, construct it manually\n                # we can't construct it without __no_builder=True, because the\n                # previous implementation was doing the add_widget() before\n                # apply(), and so, we could use \"self.parent\".\n                child = cls(__no_builder=True)\n                widget.add_widget(child)\n                child.apply_class_lang_rules(\n                    root=rctx['ids']['root'], rule_children=rule_children)\n                self._apply_rule(\n                    child, crule, rootrule, rule_children=rule_children)\n\n                if rule_children is not None:\n                    rule_children.append(child)\n\n        # append the properties and handlers to our final resolution task\n        if rule.properties:\n            rctx['set'].append((widget.proxy_ref,\n                                list(rule.properties.values())))\n            for key, crule in rule.properties.items():\n                # clear previously applied rules if asked\n                if crule.ignore_prev:\n                    Builder.unbind_property(widget, key)\n        if rule.handlers:\n            rctx['hdl'].append((widget.proxy_ref, rule.handlers))\n\n        # if we are applying another rule that the root one, then it's done for\n        # us!\n        if rootrule is not rule:\n            del self.rulectx[rule]\n            return\n\n        # normally, we can apply a list of properties with a proper context\n        try:\n            rule = None\n            for widget_set, rules in reversed(rctx['set']):\n                for rule in rules:\n                    assert isinstance(rule, ParserRuleProperty)\n                    key = rule.name\n                    value = rule.co_value\n                    if type(value) is CodeType:\n                        value, bound = create_handler(\n                            widget_set, widget_set, key, value, rule,\n                            rctx['ids'])\n                        # if there's a rule\n                        if (widget_set != widget or bound or\n                                key not in ignored_consts):\n                            setattr(widget_set, key, value)\n                    else:\n                        if (widget_set != widget or\n                                key not in ignored_consts):\n                            setattr(widget_set, key, value)\n\n        except Exception as e:\n            if rule is not None:\n                tb = sys.exc_info()[2]\n                raise BuilderException(rule.ctx, rule.line,\n                                       '{}: {}'.format(e.__class__.__name__,\n                                                       e), cause=tb)\n            raise e\n\n        # build handlers\n        try:\n            crule = None\n            for widget_set, rules in rctx['hdl']:\n                for crule in rules:\n                    assert isinstance(crule, ParserRuleProperty)\n                    assert crule.name.startswith('on_')\n                    key = crule.name\n                    if not widget_set.is_event_type(key):\n                        key = key[3:]\n                    idmap = copy(global_idmap)\n                    idmap.update(rctx['ids'])\n                    idmap['self'] = widget_set.proxy_ref\n                    if not widget_set.fbind(key, custom_callback, crule,\n                                            idmap):\n                        raise AttributeError(key)\n                    # hack for on_parent\n                    if crule.name == 'on_parent':\n                        Factory.Widget.parent.dispatch(widget_set.__self__)\n        except Exception as e:\n            if crule is not None:\n                tb = sys.exc_info()[2]\n                raise BuilderException(\n                    crule.ctx, crule.line,\n                    '{}: {}'.format(e.__class__.__name__, e), cause=tb)\n            raise e\n\n        # rule finished, forget it\n        del self.rulectx[rootrule]\n\n    def match(self, widget):\n        '''Return a list of :class:`ParserRule` objects matching the widget.\n        '''\n        cache = self._match_cache\n        k = (widget.__class__, tuple(widget.cls))\n        if k in cache:\n            return cache[k]\n        rules = []\n        for selector, rule in self.rules:\n            if selector.match(widget):\n                if rule.avoid_previous_rules:\n                    del rules[:]\n                rules.append(rule)\n        cache[k] = rules\n        return rules\n\n    def match_rule_name(self, rule_name):\n        '''Return a list of :class:`ParserRule` objects matching the widget.\n        '''\n        cache = self._match_name_cache\n        rule_name = str(rule_name)\n        k = rule_name.lower()\n        if k in cache:\n            return cache[k]\n        rules = []\n        for selector, rule in self.rules:\n            if selector.match_rule_name(rule_name):\n                if rule.avoid_previous_rules:\n                    del rules[:]\n                rules.append(rule)\n        cache[k] = rules\n        return rules\n\n    def sync(self):\n        '''Execute all the waiting operations, such as the execution of all the\n        expressions related to the canvas.\n\n        .. versionadded:: 1.7.0\n        '''\n        global _delayed_start\n        next_args = _delayed_start\n        if next_args is None:\n            return\n\n        while next_args is not StopIteration:\n            # is this try/except still needed? yes, in case widget died in this\n            # frame after the call was scheduled\n            try:\n                call_fn(next_args[:-1], None, None)\n            except ReferenceError:\n                pass\n            args = next_args\n            next_args = args[-1]\n            args[-1] = None\n        _delayed_start = None\n\n    def unbind_widget(self, uid):\n        '''Unbind all the handlers created by the KV rules of the\n        widget. The :attr:`kivy.uix.widget.Widget.uid` is passed here\n        instead of the widget itself, because Builder is using it in the\n        widget destructor.\n\n        This effectively clears all the KV rules associated with this widget.\n        For example:\n\n        .. code-block:: python\n\n            >>> w = Builder.load_string(\\'''\n            ... Widget:\n            ...     height: self.width / 2. if self.disabled else self.width\n            ...     x: self.y + 50\n            ... \\''')\n            >>> w.size\n            [100, 100]\n            >>> w.pos\n            [50, 0]\n            >>> w.width = 500\n            >>> w.size\n            [500, 500]\n            >>> Builder.unbind_widget(w.uid)\n            >>> w.width = 222\n            >>> w.y = 500\n            >>> w.size\n            [222, 500]\n            >>> w.pos\n            [50, 500]\n\n        .. versionadded:: 1.7.2\n        '''\n        if uid not in _handlers:\n            return\n        for prop_callbacks in _handlers[uid].values():\n            for callbacks in prop_callbacks:\n                for f, k, fn, bound_uid in callbacks:\n                    if fn is None:  # it's not a kivy prop.\n                        continue\n                    try:\n                        f.unbind_uid(k, bound_uid)\n                    except ReferenceError:\n                        # proxy widget is already gone, that's cool :)\n                        pass\n        del _handlers[uid]\n\n    def unbind_property(self, widget, name):\n        '''Unbind the handlers created by all the rules of the widget that set\n        the name.\n\n        This effectively clears all the rules of widget that take the form::\n\n            name: rule\n\n        For example:\n\n        .. code-block:: python\n\n            >>> w = Builder.load_string(\\'''\n            ... Widget:\n            ...     height: self.width / 2. if self.disabled else self.width\n            ...     x: self.y + 50\n            ... \\''')\n            >>> w.size\n            [100, 100]\n            >>> w.pos\n            [50, 0]\n            >>> w.width = 500\n            >>> w.size\n            [500, 500]\n            >>> Builder.unbind_property(w, 'height')\n            >>> w.width = 222\n            >>> w.size\n            [222, 500]\n            >>> w.y = 500\n            >>> w.pos\n            [550, 500]\n\n        .. versionadded:: 1.9.1\n        '''\n        uid = widget.uid\n        if uid not in _handlers:\n            return\n\n        prop_handlers = _handlers[uid]\n        if name not in prop_handlers:\n            return\n\n        for callbacks in prop_handlers[name]:\n            for f, k, fn, bound_uid in callbacks:\n                if fn is None:  # it's not a kivy prop.\n                    continue\n                try:\n                    f.unbind_uid(k, bound_uid)\n                except ReferenceError:\n                    # proxy widget is already gone, that's cool :)\n                    pass\n        del prop_handlers[name]\n        if not prop_handlers:\n            del _handlers[uid]\n\n    def _build_canvas(self, canvas, widget, rule, rootrule):\n        global Instruction\n        if Instruction is None:\n            Instruction = Factory.get('Instruction')\n        idmap = copy(self.rulectx[rootrule]['ids'])\n        for crule in rule.children:\n            name = crule.name\n            if name == 'Clear':\n                canvas.clear()\n                continue\n            instr = Factory.get(name)()\n            if not isinstance(instr, Instruction):\n                raise BuilderException(\n                    crule.ctx, crule.line,\n                    'You can add only graphics Instruction in canvas.')\n            try:\n                for prule in crule.properties.values():\n                    key = prule.name\n                    value = prule.co_value\n                    if type(value) is CodeType:\n                        value, _ = create_handler(\n                            widget, instr.proxy_ref,\n                            key, value, prule, idmap, True)\n                    setattr(instr, key, value)\n            except Exception as e:\n                tb = sys.exc_info()[2]\n                raise BuilderException(\n                    prule.ctx, prule.line,\n                    '{}: {}'.format(e.__class__.__name__, e), cause=tb)",
  "def __init__(self):\n        super(BuilderBase, self).__init__()\n        self._match_cache = {}\n        self._match_name_cache = {}\n        self.files = []\n        self.dynamic_classes = {}\n        self.templates = {}\n        self.rules = []\n        self.rulectx = {}",
  "def create_from(cls, builder):\n        \"\"\"Creates a instance of the class, and initializes to the state of\n        ``builder``.\n\n        :param builder: The builder to initialize from.\n        :return: A new instance of this class.\n        \"\"\"\n        obj = cls()\n        obj._match_cache = copy(builder._match_cache)\n        obj._match_name_cache = copy(builder._match_name_cache)\n        obj.files = copy(builder.files)\n        obj.dynamic_classes = copy(builder.dynamic_classes)\n        obj.templates = copy(builder.templates)\n        obj.rules = list(builder.rules)\n        assert not builder.rulectx\n        obj.rulectx = dict(builder.rulectx)\n\n        return obj",
  "def load_file(self, filename, encoding='utf8', **kwargs):\n        '''Insert a file into the language builder and return the root widget\n        (if defined) of the kv file.\n\n        :parameters:\n            `rulesonly`: bool, defaults to False\n                If True, the Builder will raise an exception if you have a root\n                widget inside the definition.\n\n            `encoding`: File character encoding. Defaults to utf-8,\n        '''\n\n        filename = resource_find(filename) or filename\n        if __debug__:\n            trace('Lang: load file %s, using %s encoding', filename, encoding)\n\n        kwargs['filename'] = filename\n        with open(filename, 'r', encoding=encoding) as fd:\n            data = fd.read()\n            return self.load_string(data, **kwargs)",
  "def unload_file(self, filename):\n        '''Unload all rules associated with a previously imported file.\n\n        .. versionadded:: 1.0.8\n\n        .. warning::\n\n            This will not remove rules or templates already applied/used on\n            current widgets. It will only effect the next widgets creation or\n            template invocation.\n        '''\n        # remove rules and templates\n        filename = resource_find(filename) or filename\n        self.rules = [x for x in self.rules if x[1].ctx.filename != filename]\n        self._clear_matchcache()\n        templates = {}\n        for x, y in self.templates.items():\n            if y[2] != filename:\n                templates[x] = y\n        self.templates = templates\n\n        if filename in self.files:\n            self.files.remove(filename)\n\n        # unregister all the dynamic classes\n        Factory.unregister_from_filename(filename)",
  "def load_string(self, string, **kwargs):\n        '''Insert a string into the Language Builder and return the root widget\n        (if defined) of the kv string.\n\n        :Parameters:\n            `rulesonly`: bool, defaults to False\n                If True, the Builder will raise an exception if you have a root\n                widget inside the definition.\n            `filename`: str, defaults to None\n                If specified, the filename used to index the kv rules.\n\n        The filename parameter can be used to unload kv strings in the same way\n        as you unload kv files. This can be achieved using pseudo file names\n        e.g.::\n\n            Build.load_string(\"\"\"\n                <MyRule>:\n                    Label:\n                        text=\"Hello\"\n            \"\"\", filename=\"myrule.kv\")\n\n        can be unloaded via::\n\n            Build.unload_file(\"myrule.kv\")\n\n        '''\n\n        kwargs.setdefault('rulesonly', False)\n        self._current_filename = fn = kwargs.get('filename', None)\n\n        # put a warning if a file is loaded multiple times\n        if fn in self.files:\n            Logger.warning(\n                'Lang: The file {} is loaded multiples times, '\n                'you might have unwanted behaviors.'.format(fn))\n\n        try:\n            # parse the string\n            parser = Parser(content=string, filename=fn)\n\n            # merge rules with our rules\n            self.rules.extend(parser.rules)\n            self._clear_matchcache()\n\n            # add the template found by the parser into ours\n            for name, cls, template in parser.templates:\n                self.templates[name] = (cls, template, fn)\n                Factory.register(name,\n                                 cls=partial(self.template, name),\n                                 is_template=True, warn=True)\n\n            # register all the dynamic classes\n            for name, baseclasses in parser.dynamic_classes.items():\n                Factory.register(name, baseclasses=baseclasses, filename=fn,\n                                 warn=True)\n\n            # create root object is exist\n            if kwargs['rulesonly'] and parser.root:\n                filename = kwargs.get('rulesonly', '<string>')\n                raise Exception('The file <%s> contain also non-rules '\n                                'directives' % filename)\n\n            # save the loaded files only if there is a root without\n            # template/dynamic classes\n            if fn and (parser.templates or\n                       parser.dynamic_classes or parser.rules):\n                self.files.append(fn)\n\n            if parser.root:\n                widget = Factory.get(parser.root.name)(__no_builder=True)\n                rule_children = []\n                widget.apply_class_lang_rules(\n                    root=widget, rule_children=rule_children)\n                self._apply_rule(\n                    widget, parser.root, parser.root,\n                    rule_children=rule_children)\n\n                for child in rule_children:\n                    child.dispatch('on_kv_post', widget)\n                widget.dispatch('on_kv_post', widget)\n                return widget\n        finally:\n            self._current_filename = None",
  "def template(self, *args, **ctx):\n        '''Create a specialized template using a specific context.\n\n        .. versionadded:: 1.0.5\n\n        With templates, you can construct custom widgets from a kv lang\n        definition by giving them a context. Check :ref:`Template usage\n        <template_usage>`.\n        '''\n        # Prevent naming clash with whatever the user might be putting into the\n        # ctx as key.\n        name = args[0]\n        if name not in self.templates:\n            raise Exception('Unknown <%s> template name' % name)\n        baseclasses, rule, fn = self.templates[name]\n        key = '%s|%s' % (name, baseclasses)\n        cls = Cache.get('kv.lang', key)\n        if cls is None:\n            rootwidgets = []\n            for basecls in baseclasses.split('+'):\n                rootwidgets.append(Factory.get(basecls))\n            cls = type(name, tuple(rootwidgets), {})\n            Cache.append('kv.lang', key, cls)\n        widget = cls()\n        # in previous versions, ``ctx`` is passed as is as ``template_ctx``\n        # preventing widgets in it from be collected by the GC. This was\n        # especially relevant to AccordionItem's title_template.\n        proxy_ctx = {k: get_proxy(v) for k, v in ctx.items()}\n        self._apply_rule(widget, rule, rule, template_ctx=proxy_ctx)\n        return widget",
  "def apply_rules(\n            self, widget, rule_name, ignored_consts=set(), rule_children=None,\n            dispatch_kv_post=False):\n        '''Search all the rules that match the name `rule_name`\n        and apply them to `widget`.\n\n        .. versionadded:: 1.10.0\n\n        :Parameters:\n\n            `widget`: :class:`~kivy.uix.widget.Widget`\n                The widget to whom the matching rules should be applied to.\n            `ignored_consts`: set\n                A set or list type whose elements are property names for which\n                constant KV rules (i.e. those that don't create bindings) of\n                that widget will not be applied. This allows e.g. skipping\n                constant rules that overwrite a value initialized in python.\n            `rule_children`: list\n                If not ``None``, it should be a list that will be populated\n                with all the widgets created by the kv rules being applied.\n\n                .. versionchanged:: 1.11.0\n\n            `dispatch_kv_post`: bool\n                Normally the class `Widget` dispatches the `on_kv_post` event\n                to widgets created during kv rule application.\n                But if the rules are manually applied by calling :meth:`apply`,\n                that may not happen, so if this is `True`, we will dispatch the\n                `on_kv_post` event where needed after applying the rules to\n                `widget` (we won't dispatch it for `widget` itself).\n\n                Defaults to False.\n\n                .. versionchanged:: 1.11.0\n        '''\n        rules = self.match_rule_name(rule_name)\n        if __debug__:\n            trace('Lang: Found %d rules for %s' % (len(rules), rule_name))\n        if not rules:\n            return\n\n        if dispatch_kv_post:\n            rule_children = rule_children if rule_children is not None else []\n        for rule in rules:\n            self._apply_rule(\n                widget, rule, rule, ignored_consts=ignored_consts,\n                rule_children=rule_children)\n        if dispatch_kv_post:\n            for w in rule_children:\n                w.dispatch('on_kv_post', widget)",
  "def apply(self, widget, ignored_consts=set(), rule_children=None,\n              dispatch_kv_post=False):\n        '''Search all the rules that match the widget and apply them.\n\n        :Parameters:\n\n            `widget`: :class:`~kivy.uix.widget.Widget`\n                The widget whose class rules should be applied to this widget.\n            `ignored_consts`: set\n                A set or list type whose elements are property names for which\n                constant KV rules (i.e. those that don't create bindings) of\n                that widget will not be applied. This allows e.g. skipping\n                constant rules that overwrite a value initialized in python.\n            `rule_children`: list\n                If not ``None``, it should be a list that will be populated\n                with all the widgets created by the kv rules being applied.\n\n                .. versionchanged:: 1.11.0\n\n            `dispatch_kv_post`: bool\n                Normally the class `Widget` dispatches the `on_kv_post` event\n                to widgets created during kv rule application.\n                But if the rules are manually applied by calling :meth:`apply`,\n                that may not happen, so if this is `True`, we will dispatch the\n                `on_kv_post` event where needed after applying the rules to\n                `widget` (we won't dispatch it for `widget` itself).\n\n                Defaults to False.\n\n                .. versionchanged:: 1.11.0\n        '''\n        rules = self.match(widget)\n        if __debug__:\n            trace('Lang: Found %d rules for %s' % (len(rules), widget))\n        if not rules:\n            return\n\n        if dispatch_kv_post:\n            rule_children = rule_children if rule_children is not None else []\n        for rule in rules:\n            self._apply_rule(\n                widget, rule, rule, ignored_consts=ignored_consts,\n                rule_children=rule_children)\n        if dispatch_kv_post:\n            for w in rule_children:\n                w.dispatch('on_kv_post', widget)",
  "def _clear_matchcache(self):\n        self._match_cache.clear()\n        self._match_name_cache.clear()",
  "def _apply_rule(self, widget, rule, rootrule, template_ctx=None,\n                    ignored_consts=set(), rule_children=None):\n        # widget: the current instantiated widget\n        # rule: the current rule\n        # rootrule: the current root rule (for children of a rule)\n\n        # will collect reference to all the id in children\n        assert rule not in self.rulectx\n        self.rulectx[rule] = rctx = {\n            'ids': {'root': widget.proxy_ref},\n            'set': [], 'hdl': []}\n\n        # extract the context of the rootrule (not rule!)\n        assert rootrule in self.rulectx\n        rctx = self.rulectx[rootrule]\n\n        # if a template context is passed, put it as \"ctx\"\n        if template_ctx is not None:\n            rctx['ids']['ctx'] = QueryDict(template_ctx)\n\n        # if we got an id, put it in the root rule for a later global usage\n        if rule.id:\n            # use only the first word as `id` discard the rest.\n            rule.id = rule.id.split('#', 1)[0].strip()\n            rctx['ids'][rule.id] = widget.proxy_ref\n            # set id name as a attribute for root widget so one can in python\n            # code simply access root_widget.id_name\n            _ids = dict(rctx['ids'])\n            _root = _ids.pop('root')\n            _new_ids = _root.ids\n            for _key, _value in _ids.items():\n                if _value == _root:\n                    # skip on self\n                    continue\n                _new_ids[_key] = _value\n            _root.ids = _new_ids\n\n        # first, ensure that the widget have all the properties used in\n        # the rule if not, they will be created as ObjectProperty.\n        rule.create_missing(widget)\n\n        # build the widget canvas\n        if rule.canvas_before:\n            with widget.canvas.before:\n                self._build_canvas(widget.canvas.before, widget,\n                                   rule.canvas_before, rootrule)\n        if rule.canvas_root:\n            with widget.canvas:\n                self._build_canvas(widget.canvas, widget,\n                                   rule.canvas_root, rootrule)\n        if rule.canvas_after:\n            with widget.canvas.after:\n                self._build_canvas(widget.canvas.after, widget,\n                                   rule.canvas_after, rootrule)\n\n        # create children tree\n        Factory_get = Factory.get\n        Factory_is_template = Factory.is_template\n        for crule in rule.children:\n            cname = crule.name\n\n            if cname in ('canvas', 'canvas.before', 'canvas.after'):\n                raise ParserException(\n                    crule.ctx, crule.line,\n                    'Canvas instructions added in kv must '\n                    'be declared before child widgets.')\n\n            # depending if the child rule is a template or not, we are not\n            # having the same approach\n            cls = Factory_get(cname)\n\n            if Factory_is_template(cname):\n                # we got a template, so extract all the properties and\n                # handlers, and push them in a \"ctx\" dictionary.\n                ctx = {}\n                idmap = copy(global_idmap)\n                idmap.update({'root': rctx['ids']['root']})\n                if 'ctx' in rctx['ids']:\n                    idmap.update({'ctx': rctx['ids']['ctx']})\n                try:\n                    for prule in crule.properties.values():\n                        value = prule.co_value\n                        if type(value) is CodeType:\n                            value = eval(value, idmap)\n                        ctx[prule.name] = value\n                    for prule in crule.handlers:\n                        value = eval(prule.value, idmap)\n                        ctx[prule.name] = value\n                except Exception as e:\n                    tb = sys.exc_info()[2]\n                    raise BuilderException(\n                        prule.ctx, prule.line,\n                        '{}: {}'.format(e.__class__.__name__, e), cause=tb)\n\n                # create the template with an explicit ctx\n                child = cls(**ctx)\n                widget.add_widget(child)\n\n                # reference it on our root rule context\n                if crule.id:\n                    rctx['ids'][crule.id] = child\n\n            else:\n                # we got a \"normal\" rule, construct it manually\n                # we can't construct it without __no_builder=True, because the\n                # previous implementation was doing the add_widget() before\n                # apply(), and so, we could use \"self.parent\".\n                child = cls(__no_builder=True)\n                widget.add_widget(child)\n                child.apply_class_lang_rules(\n                    root=rctx['ids']['root'], rule_children=rule_children)\n                self._apply_rule(\n                    child, crule, rootrule, rule_children=rule_children)\n\n                if rule_children is not None:\n                    rule_children.append(child)\n\n        # append the properties and handlers to our final resolution task\n        if rule.properties:\n            rctx['set'].append((widget.proxy_ref,\n                                list(rule.properties.values())))\n            for key, crule in rule.properties.items():\n                # clear previously applied rules if asked\n                if crule.ignore_prev:\n                    Builder.unbind_property(widget, key)\n        if rule.handlers:\n            rctx['hdl'].append((widget.proxy_ref, rule.handlers))\n\n        # if we are applying another rule that the root one, then it's done for\n        # us!\n        if rootrule is not rule:\n            del self.rulectx[rule]\n            return\n\n        # normally, we can apply a list of properties with a proper context\n        try:\n            rule = None\n            for widget_set, rules in reversed(rctx['set']):\n                for rule in rules:\n                    assert isinstance(rule, ParserRuleProperty)\n                    key = rule.name\n                    value = rule.co_value\n                    if type(value) is CodeType:\n                        value, bound = create_handler(\n                            widget_set, widget_set, key, value, rule,\n                            rctx['ids'])\n                        # if there's a rule\n                        if (widget_set != widget or bound or\n                                key not in ignored_consts):\n                            setattr(widget_set, key, value)\n                    else:\n                        if (widget_set != widget or\n                                key not in ignored_consts):\n                            setattr(widget_set, key, value)\n\n        except Exception as e:\n            if rule is not None:\n                tb = sys.exc_info()[2]\n                raise BuilderException(rule.ctx, rule.line,\n                                       '{}: {}'.format(e.__class__.__name__,\n                                                       e), cause=tb)\n            raise e\n\n        # build handlers\n        try:\n            crule = None\n            for widget_set, rules in rctx['hdl']:\n                for crule in rules:\n                    assert isinstance(crule, ParserRuleProperty)\n                    assert crule.name.startswith('on_')\n                    key = crule.name\n                    if not widget_set.is_event_type(key):\n                        key = key[3:]\n                    idmap = copy(global_idmap)\n                    idmap.update(rctx['ids'])\n                    idmap['self'] = widget_set.proxy_ref\n                    if not widget_set.fbind(key, custom_callback, crule,\n                                            idmap):\n                        raise AttributeError(key)\n                    # hack for on_parent\n                    if crule.name == 'on_parent':\n                        Factory.Widget.parent.dispatch(widget_set.__self__)\n        except Exception as e:\n            if crule is not None:\n                tb = sys.exc_info()[2]\n                raise BuilderException(\n                    crule.ctx, crule.line,\n                    '{}: {}'.format(e.__class__.__name__, e), cause=tb)\n            raise e\n\n        # rule finished, forget it\n        del self.rulectx[rootrule]",
  "def match(self, widget):\n        '''Return a list of :class:`ParserRule` objects matching the widget.\n        '''\n        cache = self._match_cache\n        k = (widget.__class__, tuple(widget.cls))\n        if k in cache:\n            return cache[k]\n        rules = []\n        for selector, rule in self.rules:\n            if selector.match(widget):\n                if rule.avoid_previous_rules:\n                    del rules[:]\n                rules.append(rule)\n        cache[k] = rules\n        return rules",
  "def match_rule_name(self, rule_name):\n        '''Return a list of :class:`ParserRule` objects matching the widget.\n        '''\n        cache = self._match_name_cache\n        rule_name = str(rule_name)\n        k = rule_name.lower()\n        if k in cache:\n            return cache[k]\n        rules = []\n        for selector, rule in self.rules:\n            if selector.match_rule_name(rule_name):\n                if rule.avoid_previous_rules:\n                    del rules[:]\n                rules.append(rule)\n        cache[k] = rules\n        return rules",
  "def sync(self):\n        '''Execute all the waiting operations, such as the execution of all the\n        expressions related to the canvas.\n\n        .. versionadded:: 1.7.0\n        '''\n        global _delayed_start\n        next_args = _delayed_start\n        if next_args is None:\n            return\n\n        while next_args is not StopIteration:\n            # is this try/except still needed? yes, in case widget died in this\n            # frame after the call was scheduled\n            try:\n                call_fn(next_args[:-1], None, None)\n            except ReferenceError:\n                pass\n            args = next_args\n            next_args = args[-1]\n            args[-1] = None\n        _delayed_start = None",
  "def unbind_widget(self, uid):\n        '''Unbind all the handlers created by the KV rules of the\n        widget. The :attr:`kivy.uix.widget.Widget.uid` is passed here\n        instead of the widget itself, because Builder is using it in the\n        widget destructor.\n\n        This effectively clears all the KV rules associated with this widget.\n        For example:\n\n        .. code-block:: python\n\n            >>> w = Builder.load_string(\\'''\n            ... Widget:\n            ...     height: self.width / 2. if self.disabled else self.width\n            ...     x: self.y + 50\n            ... \\''')\n            >>> w.size\n            [100, 100]\n            >>> w.pos\n            [50, 0]\n            >>> w.width = 500\n            >>> w.size\n            [500, 500]\n            >>> Builder.unbind_widget(w.uid)\n            >>> w.width = 222\n            >>> w.y = 500\n            >>> w.size\n            [222, 500]\n            >>> w.pos\n            [50, 500]\n\n        .. versionadded:: 1.7.2\n        '''\n        if uid not in _handlers:\n            return\n        for prop_callbacks in _handlers[uid].values():\n            for callbacks in prop_callbacks:\n                for f, k, fn, bound_uid in callbacks:\n                    if fn is None:  # it's not a kivy prop.\n                        continue\n                    try:\n                        f.unbind_uid(k, bound_uid)\n                    except ReferenceError:\n                        # proxy widget is already gone, that's cool :)\n                        pass\n        del _handlers[uid]",
  "def unbind_property(self, widget, name):\n        '''Unbind the handlers created by all the rules of the widget that set\n        the name.\n\n        This effectively clears all the rules of widget that take the form::\n\n            name: rule\n\n        For example:\n\n        .. code-block:: python\n\n            >>> w = Builder.load_string(\\'''\n            ... Widget:\n            ...     height: self.width / 2. if self.disabled else self.width\n            ...     x: self.y + 50\n            ... \\''')\n            >>> w.size\n            [100, 100]\n            >>> w.pos\n            [50, 0]\n            >>> w.width = 500\n            >>> w.size\n            [500, 500]\n            >>> Builder.unbind_property(w, 'height')\n            >>> w.width = 222\n            >>> w.size\n            [222, 500]\n            >>> w.y = 500\n            >>> w.pos\n            [550, 500]\n\n        .. versionadded:: 1.9.1\n        '''\n        uid = widget.uid\n        if uid not in _handlers:\n            return\n\n        prop_handlers = _handlers[uid]\n        if name not in prop_handlers:\n            return\n\n        for callbacks in prop_handlers[name]:\n            for f, k, fn, bound_uid in callbacks:\n                if fn is None:  # it's not a kivy prop.\n                    continue\n                try:\n                    f.unbind_uid(k, bound_uid)\n                except ReferenceError:\n                    # proxy widget is already gone, that's cool :)\n                    pass\n        del prop_handlers[name]\n        if not prop_handlers:\n            del _handlers[uid]",
  "def _build_canvas(self, canvas, widget, rule, rootrule):\n        global Instruction\n        if Instruction is None:\n            Instruction = Factory.get('Instruction')\n        idmap = copy(self.rulectx[rootrule]['ids'])\n        for crule in rule.children:\n            name = crule.name\n            if name == 'Clear':\n                canvas.clear()\n                continue\n            instr = Factory.get(name)()\n            if not isinstance(instr, Instruction):\n                raise BuilderException(\n                    crule.ctx, crule.line,\n                    'You can add only graphics Instruction in canvas.')\n            try:\n                for prule in crule.properties.values():\n                    key = prule.name\n                    value = prule.co_value\n                    if type(value) is CodeType:\n                        value, _ = create_handler(\n                            widget, instr.proxy_ref,\n                            key, value, prule, idmap, True)\n                    setattr(instr, key, value)\n            except Exception as e:\n                tb = sys.exc_info()[2]\n                raise BuilderException(\n                    prule.ctx, prule.line,\n                    '{}: {}'.format(e.__class__.__name__, e), cause=tb)",
  "def match_rule(fn, index, rule):\n        if rule.ctx.filename != fn:\n            return\n        for prop, prp in rule.properties.items():\n            if prp.line != index:\n                continue\n            yield prp\n        for child in rule.children:\n            for r in match_rule(fn, index, child):\n                yield r\n        if rule.canvas_root:\n            for r in match_rule(fn, index, rule.canvas_root):\n                yield r\n        if rule.canvas_before:\n            for r in match_rule(fn, index, rule.canvas_before):\n                yield r\n        if rule.canvas_after:\n            for r in match_rule(fn, index, rule.canvas_after):\n                yield r",
  "def dump_builder_stats():\n        html = [\n            '<!doctype html>'\n            '<html><body>',\n            '<style type=\"text/css\">\\n',\n            'pre { margin: 0; }\\n',\n            '</style>']\n        files = {x[1].ctx.filename for x in Builder.rules}\n        for fn in files:\n            try:\n                with open(fn) as f:\n                    lines = f.readlines()\n            except (IOError, TypeError) as e:\n                continue\n            html += ['<h2>', fn, '</h2>', '<table>']\n            count = 0\n            for index, line in enumerate(lines):\n                line = line.rstrip()\n                line = escape(line)\n                matched_prp = []\n                for psn, rule in Builder.rules:\n                    matched_prp.extend(match_rule(fn, index, rule))\n\n                count = sum({x.count for x in matched_prp})\n\n                color = (255, 155, 155) if count else (255, 255, 255)\n                html += ['<tr style=\"background-color: rgb{}\">'.format(color),\n                         '<td>', str(index + 1), '</td>',\n                         '<td>', str(count), '</td>',\n                         '<td><pre>', line, '</pre></td>',\n                         '</tr>']\n            html += ['</table>']\n        html += ['</body></html>']\n        with open('builder_stats.html', 'w', encoding='utf-8') as fd:\n            fd.write(''.join(html))\n\n        print('Profiling written at builder_stats.html')",
  "def writefile(filename, data):\n    global dest_dir\n    # avoid to rewrite the file if the content didn't change\n    f = os.path.join(dest_dir, filename)\n    if not BE_QUIET:\n        print('write', filename)\n    if os.path.exists(f):\n        with open(f) as fd:\n            if fd.read() == data:\n                return\n    h = open(f, 'w')\n    h.write(data)\n    h.close()",
  "def extract_summary_line(doc):\n    \"\"\"\n    :param doc: the __doc__ field of a module\n    :return: a doc string suitable for a header or empty string\n    \"\"\"\n    if doc is None:\n        return ''\n    for line in doc.split('\\n'):\n        line = line.strip()\n        # don't take empty line\n        if len(line) < 1:\n            continue\n        # ref mark\n        if line.startswith('.. _'):\n            continue\n        return line",
  "class KivyStyle(Style):\n    # The background color is set in kivystyle.sty\n    background_color = \"\"\n    default_style = \"\"\n\n    styles = {\n        # No corresponding class for the following:\n        #Text:                     \"\", # class:  ''\n        Whitespace:                \"underline #ffffff\",      # class: 'w'\n        Error:                     \"#FF0000 border:#FF0000\", # class: 'err'\n        Other:                     \"#FF0000\",                # class 'x'\n\n        Comment:                   \"italic #666385\", # class: 'c'\n        Comment.Preproc:           \"noitalic\",       # class: 'cp'\n\n        Keyword:                   \"bold #000000\",   # class: 'k'\n        Keyword.Constant:          \"bold #000000\",   # class: 'kc'\n        Keyword.Declaration:       \"bold #000000\",   # class: 'kd'\n        Keyword.Namespace:         \"bold #000000\",   # class: 'kn'\n        Keyword.Pseudo:            \"bold #000000\",   # class: 'kp'\n        Keyword.Reserved:          \"bold #000000\",   # class: 'kr'\n        Keyword.Type:              \"bold #000000\",   # class: 'kt'\n\n        Operator:                  \"#582800\",   # class: 'o'\n        Operator.Word:             \"bold #000000\",   # class: 'ow' - like keywords\n\n        Punctuation:               \"bold #000000\",   # class: 'p'\n\n        # because special names such as Name.Class, Name.Function, etc.\n        # are not recognized as such later in the parsing, we choose them\n        # to look the same as ordinary variables.\n        Name:                      \"#000000\",        # class: 'n'\n        Name.Attribute:            \"#c4a000\",        # class: 'na' - to be revised\n        Name.Builtin:              \"#000000\",        # class: 'nb'\n        Name.Builtin.Pseudo:       \"#aa1105\",        # class: 'bp'\n        Name.Class:                \"#db6500\",        # class: 'nc' - to be revised\n        Name.Constant:             \"#000000\",        # class: 'no' - to be revised\n        Name.Decorator:            \"#888\",           # class: 'nd' - to be revised\n        Name.Entity:               \"#ce5c00\",        # class: 'ni'\n        Name.Exception:            \"bold #cc0000\",   # class: 'ne'\n        Name.Function:             \"#db6500\",        # class: 'nf'\n        Name.Property:             \"#000000\",        # class: 'py'\n        Name.Label:                \"#f57900\",        # class: 'nl'\n        Name.Namespace:            \"#000000\",        # class: 'nn' - to be revised\n        Name.Other:                \"#000000\",        # class: 'nx'\n        Name.Tag:                  \"bold #004461\",   # class: 'nt' - like a keyword\n        Name.Variable:             \"#000000\",        # class: 'nv' - to be revised\n        Name.Variable.Class:       \"#000000\",        # class: 'vc' - to be revised\n        Name.Variable.Global:      \"#000000\",        # class: 'vg' - to be revised\n        Name.Variable.Instance:    \"#000000\",        # class: 'vi' - to be revised\n\n        Number:                    \"#990000\",        # class: 'm'\n\n        Literal:                   \"#000000\",        # class: 'l'\n        Literal.Date:              \"#000000\",        # class: 'ld'\n\n        String:                    \"#74171b\",        # class: 's'\n        String.Backtick:           \"#4e9a06\",        # class: 'sb'\n        String.Char:               \"#4e9a06\",        # class: 'sc'\n        String.Doc:                \"italic #640000\", # class: 'sd' - like a comment\n        String.Double:             \"#74171b\",        # class: 's2'\n        String.Escape:             \"#74171b\",        # class: 'se'\n        String.Heredoc:            \"#74171b\",        # class: 'sh'\n        String.Interpol:           \"#74171b\",        # class: 'si'\n        String.Other:              \"#74171b\",        # class: 'sx'\n        String.Regex:              \"#74171b\",        # class: 'sr'\n        String.Single:             \"#74171b\",        # class: 's1'\n        String.Symbol:             \"#74171b\",        # class: 'ss'\n\n        Generic:                   \"#000000\",        # class: 'g'\n        Generic.Deleted:           \"#a40000\",        # class: 'gd'\n        Generic.Emph:              \"italic #000000\", # class: 'ge'\n        Generic.Error:             \"#ef2929\",        # class: 'gr'\n        Generic.Heading:           \"bold #000080\",   # class: 'gh'\n        Generic.Inserted:          \"#00A000\",        # class: 'gi'\n        Generic.Output:            \"#888\",           # class: 'go'\n        Generic.Prompt:            \"#745334\",        # class: 'gp'\n        Generic.Strong:            \"bold #000000\",   # class: 'gs'\n        Generic.Subheading:        \"bold #800080\",   # class: 'gu'\n        Generic.Traceback:         \"bold #a40000\",   # class: 'gt'\n    }",
  "class CythonMethodDocumenter(MethodDocumenter):\n    # XXX i don't understand the impact of having a priority more than the\n    # attribute or instance method but the things is, if it's a cython module,\n    # the attribute will be prefer over method.\n    priority = 12",
  "def is_cython_extension(what, obj):\n    # try to check if the first line of the doc is a signature\n    doc = obj.__doc__\n    if not doc:\n        return False\n    doc = doc.split('\\n')\n    if not len(doc):\n        return False\n    doc = doc[0]\n\n    # test for cython cpdef\n    if what in ('attribute', 'method') and hasattr(obj, '__objclass__'):\n        if not re.match('^([a-zA-Z_][a-zA-Z0-9_]*)\\.([a-zA-Z_][a-zA-Z0-9_]*)\\((.*)\\)', doc):\n            return False\n        return True\n    # test for cython class\n    if what == 'class' and hasattr(obj, '__pyx_vtable__'):\n        if not re.match('^([a-zA-Z_][a-zA-Z0-9_]*)\\((.*)\\)', doc):\n            return False\n        return True\n    # test for python method in cython class\n    if what in ('method', 'function') and obj.__class__ == types.BuiltinFunctionType:\n        if not re.match('^([a-zA-Z_][a-zA-Z0-9_]*)\\((.*)\\)', doc):\n            return False\n        return True",
  "def callback_docstring(app, what, name, obj, options, lines):\n    if what == 'module':\n        # remove empty lines\n        while len(lines):\n            line = lines[0].strip()\n            if not line.startswith('.. _') and line != '':\n                break\n            lines.pop(0)\n\n        # if we still have lines, remove the title\n        if len(lines):\n            lines.pop(0)\n\n        # if the title is followed by a separator, remove it.\n        if len(lines) and lines[0].startswith('=='):\n            lines.pop(0)\n\n    elif is_cython_extension(what, obj) and lines:\n        if what == 'class':\n            lines.pop(0)\n        line = lines.pop(0)\n\n        # trick to realign the first line to the second one.\n        # FIXME: fail if we finishing with::\n        line_with_text = [x for x in lines if len(x.strip())]\n        if len(line_with_text) and line is not None and len(lines):\n            l = len(line_with_text[0]) - len(line_with_text[0].lstrip())\n        else:\n            l = 0\n        lines.insert(0, ' ' * l + line)\n\n        # calculate the minimum space available\n        min_space = 999\n        for line in lines:\n            if not line.strip():\n                continue\n            min_space = min(min_space, len(line) - len(line.lstrip()))\n\n        # remove that kind of space now.\n        if min_space > 0:\n            spaces = ' ' * min_space\n            for idx, line in enumerate(lines):\n                if not line.strip():\n                    continue\n                if not line.startswith(spaces):\n                    continue\n                lines[idx] = line[min_space:]",
  "def callback_signature(app, what, name, obj, options, signature,\n                       return_annotation):\n    # remove the first 'self' argument, because python autodoc don't\n    # add it for python method class. So do the same for cython class.\n    if is_cython_extension(what, obj):\n        try:\n            doc = obj.__doc__.split('\\n').pop(0)\n            doc = '(%s' % doc.split('(')[1]\n            doc = doc.replace('(self, ', '(')\n            doc = doc.replace('(self)', '( )')\n            return (doc, None)\n        except AttributeError:\n            pass\n        except IndexError:\n            pass",
  "def setup(app):\n    import kivy\n    sys.path += [join(dirname(kivy.__file__), 'extras')]\n    from highlight import KivyLexer\n\n    if sphinx.version_info[0] >= 3:\n        app.add_lexer('kv', KivyLexer)\n    else:\n        app.add_lexer('kv', KivyLexer())\n    app.add_autodocumenter(CythonMethodDocumenter)\n    app.connect('autodoc-process-docstring', callback_docstring)\n    app.connect('autodoc-process-signature', callback_signature)",
  "class KivyClassDocumenter(ClassDocumenter):\n    def add_directive_header(self, sig):\n        if self.doc_as_attr:\n            self.directivetype = 'attribute'\n        Documenter.add_directive_header(self, sig)\n\n        def fix(mod):\n            if mod == 'kivy._event':\n                mod = 'kivy.event'\n            return mod\n\n        # add inheritance info, if wanted\n        if not self.doc_as_attr and self.options.show_inheritance:\n            self.add_line('', '<autodoc>')\n            if len(self.object.__bases__):\n                bases = [b.__module__ == '__builtin__' and\n                         ':class:`%s`' % b.__name__ or\n                         ':class:`%s.%s`' % (fix(b.__module__), b.__name__)\n                         for b in self.object.__bases__]\n                self.add_line(_('   Bases: %s') % ', '.join(bases),\n                              '<autodoc>')",
  "def setup(app):\n    core_setup(app)\n    app.add_autodocumenter(KivyClassDocumenter)",
  "def add_directive_header(self, sig):\n        if self.doc_as_attr:\n            self.directivetype = 'attribute'\n        Documenter.add_directive_header(self, sig)\n\n        def fix(mod):\n            if mod == 'kivy._event':\n                mod = 'kivy.event'\n            return mod\n\n        # add inheritance info, if wanted\n        if not self.doc_as_attr and self.options.show_inheritance:\n            self.add_line('', '<autodoc>')\n            if len(self.object.__bases__):\n                bases = [b.__module__ == '__builtin__' and\n                         ':class:`%s`' % b.__name__ or\n                         ':class:`%s.%s`' % (fix(b.__module__), b.__name__)\n                         for b in self.object.__bases__]\n                self.add_line(_('   Bases: %s') % ', '.join(bases),\n                              '<autodoc>')",
  "def fix(mod):\n            if mod == 'kivy._event':\n                mod = 'kivy.event'\n            return mod"
]