[
  "class DataContainer(ABC):\n    '''\n    Abstract base class for an abstract data container.\n    '''\n    def __init__(self):\n        self.handle = None\n\n    def __del__(self):\n        print(\"SIRF.DataContainer __del__ with handle {}.\".format(self.handle))\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def __neg__(self):\n        return self.multiply(-1.0)\n\n    def __add__(self, other):\n        '''\n        Overloads + for data containers.\n\n        Returns the sum of the container data with another container \n        data viewed as vectors.\n        other: DataContainer\n        '''\n        return self.add(other)\n\n    def __sub__(self, other):\n        '''\n        Overloads - for data containers.\n\n        Returns the difference of the container data with another container \n        data viewed as vectors.\n        other: DataContainer\n        '''\n        if isinstance(other, (DataContainer, Number) ):\n            return self.subtract(other)\n        return NotImplemented\n\n    def __mul__(self, other):\n        '''\n        Overloads * for data containers multiplication by a scalar or another\n        data container.\n\n        Returns the product self*other if other is a scalar\n        or the elementwise product if other is of the same type as self.\n        other: DataContainer or a (real or complex) scalar\n        '''\n        return self.multiply(other)\n\n    def __rmul__(self, other):\n        '''\n        Overloads * for data containers multiplication by a scalar from\n        the left, i.e. computes and returns the product other*self.\n        other: a real or complex scalar\n        '''\n        return self * other\n\n    def __truediv__(self, other):\n        '''\n        Overloads / for data containers division by a scalar or (elementwise)\n        another data container (Python 3.*)\n\n        Returns the ratio self/other if other is a scalar\n        or the elementwise ratio if other is of the same type as self.\n        other: DataContainer or a (real or complex) scalar\n        '''\n        return self.divide(other)\n\n    def __iadd__(self, other):\n        self.add(other, out=self)\n        return self\n\n    def __imul__(self, other):\n        self.multiply(other, out=self)\n        return self\n\n    def __isub__(self, other):\n        self.subtract(other, out=self)\n        return self\n\n    def __itruediv__(self, other):\n        self.divide(other, out=self)\n        return self\n\n    def same_object(self):\n        '''\n        Returns an object of the same type as self.\n\n        Since this class is abstract, its methods cannot itself create a new\n        object when e.g. adding two objects of this class, so new object is\n        created by the first object using its same_object() method - see\n        clone() below.\n        '''\n        return DataContainer()\n\n    def clone(self):\n        assert self.handle is not None\n        x = self.same_object()\n        x.handle = pysirf.cSIRF_clone(self.handle)\n        check_status(x.handle)\n        return x\n\n    def copy(self):\n        '''alias of clone'''\n        return self.clone()\n\n    def get_uniform_copy(self, value=1.0):\n        '''Initialises an instance of DataContainer based on the template'''\n        y = self.clone()\n        y.fill(value)\n        return y\n\n    def write(self, filename):\n        '''\n        Writes to file.\n        '''\n        try_calling(pysirf.cSIRF_write(self.handle, filename))\n\n    def number(self):\n        '''\n        Returns the number of items in the container.\n        '''\n        assert self.handle is not None\n        handle = pysirf.cSIRF_dataItems(self.handle)\n        check_status(handle)\n        n = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return n\n\n    def is_empty(self):\n        return self.number() < 1\n\n    def is_complex(self):\n        assert self.handle is not None\n        handle = pysirf.cSIRF_isComplex(self.handle)\n        check_status(handle)\n        i = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return i != 0\n\n    def conjugate(self, out=None):\n        ''' Computes complex conjugate of self.\n\n            Use y = x.conjugate() to get the conjugated copy of x.\n            Use x.conjugate(out=x) to conjugate in-place.\n        '''\n        if out is self:\n            try_calling(pysirf.cSIRF_conjugate(self.handle))\n            return\n        elif out is None:\n            x = self.same_object()\n        else:\n            x = out\n        if x.handle is not None:\n            pyiutil.deleteDataHandle(x.handle)\n        x.handle = pysirf.cSIRF_conjugated(self.handle)\n        check_status(x.handle)\n        if out is None:\n            return x\n\n    def norm(self):\n        '''\n        Returns the 2-norm of the container data viewed as a vector.\n        '''\n        handle = pysirf.cSIRF_norm(self.handle)\n        check_status(handle)\n        r = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return r;\n\n    def squared_norm(self):\n        '''Returns the squared norm of a DataContainer viewed as a vector\n\n        CIL/SIRF compatibility'''\n        return self.norm() ** 2\n\n    def dot(self, other):\n        '''\n        Returns the dot product of the container data with another container \n        data viewed as vectors.\n        other: DataContainer\n        '''\n        assert_validities(self, other)\n        # Check if input are the same size\n        if self.size != other.size:\n            raise ValueError(\"Input sizes are expected to be equal, got \" \\\n                + self.size + \" and \" + other.size + \" instead.\")\n        z = numpy.zeros((2,), dtype=numpy.float32)\n        try_calling(pysirf.cSIRF_compute_dot(self.handle, other.handle, z.ctypes.data))\n        if z[1] == 0:\n            return z[0]\n        return z[0] + 1j*z[1]\n\n    def sum(self):\n        '''\n        Returns the sum of the elements of self data\n        '''\n        z = numpy.zeros((2,), dtype=numpy.float32)\n        try_calling(pysirf.cSIRF_compute_sum(self.handle, z.ctypes.data))\n        if z[1] == 0:\n            return z[0]\n        return z[0] + 1j*z[1]\n\n    def max(self):\n        '''\n        Returns the maximum of the elements of self data\n        '''\n        z = numpy.zeros((2,), dtype=numpy.float32)\n        try_calling(pysirf.cSIRF_compute_max(self.handle, z.ctypes.data))\n        if z[1] == 0:\n            return z[0]\n        return z[0] + 1j*z[1]\n\n    def add(self, other, out=None):\n        '''\n        Addition for data containers.\n\n        If other is a DataContainer, returns the sum of data\n        stored in self and other viewed as vectors.\n        If other is a scalar, returns the same with the second vector filled\n        with the value of other.\n        other: DataContainer or scalar.\n        out:   DataContainer to store the result to.\n        '''\n        if out is None:\n            z = self.same_object()\n        else:\n            z = out\n            assert_validities(self, z)\n        if isinstance(other, Number):\n            a = numpy.asarray([other.real, other.imag], dtype=numpy.float32)\n            if out is None:\n                z.handle = pysirf.cSIRF_sum(self.handle, a.ctypes.data)\n                check_status(z.handle)\n            else:\n                try_calling(pysirf.cSIRF_add(self.handle, a.ctypes.data, z.handle))\n        else:\n            assert_validities(self, other)\n            one = numpy.asarray([1.0, 0.0], dtype = numpy.float32)\n            if out is None:\n                z.handle = pysirf.cSIRF_axpby(one.ctypes.data, self.handle, one.ctypes.data, other.handle)\n                check_status(z.handle)\n            else:\n                try_calling(pysirf.cSIRF_axpbyAlt(one.ctypes.data, self.handle, one.ctypes.data, other.handle, z.handle))\n        return z\n\n    def subtract(self, other, out=None):\n        '''\n        Subtraction for data containers.\n\n        If other is a DataContainer, returns the difference of data\n        stored in self and other viewed as vectors.\n        If other is a scalar, returns the same with the second vector filled\n        with the value of other.\n        other: DataContainer or scalar.\n        other: DataContainer\n        '''\n        if not isinstance (other, (DataContainer, Number)):\n            return NotImplemented\n        if isinstance(other, Number):\n            return self.add(-other, out=out)\n        assert_validities(self, other)\n        pl_one = numpy.asarray([1.0, 0.0], dtype = numpy.float32)\n        mn_one = numpy.asarray([-1.0, 0.0], dtype = numpy.float32)\n        if out is None:\n            z = self.same_object()\n            z.handle = pysirf.cSIRF_axpby \\\n                (pl_one.ctypes.data, self.handle, mn_one.ctypes.data, other.handle)\n            check_status(z.handle)\n            return z\n        else:\n            assert_validities(self, out)\n            z = out\n            try_calling(pysirf.cSIRF_axpbyAlt \\\n                (pl_one.ctypes.data, self.handle, mn_one.ctypes.data, other.handle, z.handle))\n\n    def multiply(self, other, out=None):\n        '''\n        Elementwise multiplication for data containers.\n\n        Returns the elementwise product of data stored in self and other.\n        other: DataContainer or scalar.\n        out:   DataContainer to store the result to.\n        '''\n        if out is None:\n            return self.binary(other, 'multiply')\n        self.binary(other, 'multiply', out=out)\n\n    def divide(self, other, out=None):\n        '''\n        Elementwise ratio for data containers.\n\n        Returns the elementwise ratio of data stored in self and other.\n        other: DataContainer or scalar.\n        out:   DataContainer to store the result to.\n        '''\n        if isinstance(other, Number):\n            if out is None:\n                return self.binary(1./other, 'multiply')\n            self.binary(1./other, 'multiply', out=out)\n        else:\n            if out is None:\n                return self.binary(other, 'divide')\n            self.binary(other, 'divide', out=out)\n\n    def maximum(self, other, out=None):\n        '''\n        Elementwise maximum for data containers.\n\n        Returns the elementwise maximum of data stored in self and other.\n        other: DataContainer or scalar.\n        out:   DataContainer to store the result to.\n        '''\n        if out is None:\n            return self.binary(other, 'maximum')\n        self.binary(other, 'maximum', out=out)\n\n    def minimum(self, other, out=None):\n        '''\n        Elementwise minimum for data containers.\n\n        Returns the elementwise minimum of data stored in self and other.\n        other: DataContainer or scalar.\n        out:   DataContainer to store the result to.\n        '''\n        if out is None:\n            return self.binary(other, 'minimum')\n        self.binary(other, 'minimum', out=out)\n\n    @deprecation.deprecated(details=\"Please use the sapyb method instead\")\n    def axpby(self, a, b, y, out=None, **kwargs):\n        '''\n        Linear combination for data containers.\n\n        Returns the linear combination of the self data with another container \n        data y viewed as vectors.\n        a: multiplier to self, can be a number or a DataContainer\n        b: multiplier to y, can be a number or a DataContainer \n        y: DataContainer\n        out:   DataContainer to store the result to.\n        '''\n        return self.sapyb(a, y, b, out=out, **kwargs)\n\n    def sapyb(self, a, y, b, out=None, **kwargs):\n        '''\n        Linear combination for data containers: new interface.\n\n        Returns the linear combination of the self data with another container \n        data y viewed as vectors.\n        a: multiplier to self, can be a number or a DataContainer\n        b: multiplier to y, can be a number or a DataContainer \n        y: DataContainer\n        out:   DataContainer to store the result to, can be self or y.\n        '''\n\n        assert_validities(self, y)\n\n        if out is not None:\n            assert_validities(self, out)\n            z = out\n        else:\n            z = self.same_object()\n\n        if isinstance(a, Number):\n            alpha = numpy.asarray([a.real, a.imag], dtype = numpy.float32)\n            if isinstance(b, Number):\n                #a is scalar, b is scalar\n                beta = numpy.asarray([b.real, b.imag], dtype = numpy.float32)\n                if out is None:\n                    z.handle = pysirf.cSIRF_axpby(alpha.ctypes.data, self.handle, beta.ctypes.data, y.handle)\n                else:\n                    try_calling(pysirf.cSIRF_axpbyAlt(alpha.ctypes.data, self.handle, beta.ctypes.data, y.handle, z.handle))\n            else:\n                #a is scalar, b is array\n                if out is None:\n                    z.handle = pysirf.cSIRF_XapYB(self.handle, alpha.ctypes.data, y.handle, b.handle)\n                else:\n                    try_calling(pysirf.cSIRF_XapYBAlt(self.handle, alpha.ctypes.data, y.handle, b.handle, z.handle))\n        else:\n            assert_validities(self, a)\n            if isinstance(b, Number):\n                #a is array, b is scalar\n                beta = numpy.asarray([b.real, b.imag], dtype = numpy.float32)\n                if out is None:\n                    z.handle = pysirf.cSIRF_XapYB(y.handle, beta.ctypes.data, self.handle, a.handle)\n                else:\n                    try_calling(pysirf.cSIRF_XapYBAlt(y.handle, beta.ctypes.data, self.handle, a.handle, z.handle))\n            else:\n                #a is array, b is array\n                assert_validities(self, b)\n                if out is None:\n                    z.handle = pysirf.cSIRF_xapyb(self.handle, a.handle, y.handle, b.handle)\n                else:\n                    try_calling(pysirf.cSIRF_xapybAlt(self.handle, a.handle, y.handle, b.handle, z.handle))\n\n        if out is None:\n            check_status(z.handle)\n            return z\n\n    def power(self, other, out=None):\n        '''Power function for DataContainers\n\n        SIRF/CIL compatibility\n        '''\n        if out is None:\n            return self.binary(other, 'power')\n        self.binary(other, 'power', out=out)\n\n    def abs(self, out=None):\n        '''Returns the element-wise absolute value of the DataContainer data\n\n        '''\n        if out is None:\n            return self.unary('abs')\n        self.unary('abs', out=out)\n\n    def sign(self, out=None):\n        '''Returns the element-wise sign of the DataContainer data\n\n        '''\n        if out is None:\n            return self.unary('sign')\n        self.unary('sign', out=out)\n\n    def sqrt(self, out=None):\n        '''Returns the element-wise sqrt of the DataContainer data\n\n        '''\n        if out is None:\n            return self.unary('sqrt')\n        self.unary('sqrt', out=out)\n\n    def exp(self, out=None):\n        '''Returns the element-wise exp of the DataContainer data\n\n        '''\n        if out is None:\n            return self.unary('exp')\n        self.unary('exp', out=out)\n\n    def log(self, out=None):\n        '''Returns the element-wise log of the DataContainer data\n\n        '''\n        if out is None:\n            return self.unary('log')\n        self.unary('log', out=out)\n\n    def binary(self, other, f, out=None):\n        '''Applies function f(x,y) element-wise to self and other.\n\n        other: DataContainer or Number\n        f: the name of the function to apply, Python str.\n        '''\n        if out is None:\n            out = self.same_object()\n        if isinstance(other, Number):\n            y = numpy.asarray([other.real, other.imag], dtype=numpy.float32)\n            if out.handle is None:\n                out.handle = pysirf.cSIRF_semibinary(self.handle, y.ctypes.data, f)\n                check_status(out.handle)\n                return out\n            else:\n                try_calling(pysirf.cSIRF_compute_semibinary(self.handle, y.ctypes.data, \\\n                                                        f, out.handle))\n        else:\n            assert_validities(self, other)\n            if out.handle is None:\n                out.handle = pysirf.cSIRF_binary(self.handle, other.handle, f)\n                check_status(out.handle)\n                return out\n            else:\n                try_calling(pysirf.cSIRF_compute_binary(self.handle, other.handle, \\\n                                                        f, out.handle))\n\n    def unary(self, f, out=None):\n        '''Applies function f(x) element-wise to self data.\n\n        f: the name of the function to apply, Python str.\n        '''\n        if out is None:\n            out = self.same_object()\n        if out.handle is None:\n            out.handle = pysirf.cSIRF_unary(self.handle, f)\n            check_status(out.handle)\n            return out\n        else:\n            assert_validities(self, out)\n            try_calling(pysirf.cSIRF_compute_unary(self.handle, f, out.handle))\n\n    @property\n    def shape(self):\n        '''Returns the shape of the data array\n        '''\n        return self.dimensions()\n\n    @property\n    def size(self):\n        '''Returns the (total) size of the data array.'''\n        return numpy.prod(self.dimensions())\n\n    @property\n    def dtype(self):\n        handle = pysirf.cSIRF_bits(self.handle)\n        check_status(handle)\n        bits = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        if self.is_complex():\n            dt = 'complex%s' % bits\n        else:\n            dt = 'float%s' % bits\n        return numpy.dtype(dt)",
  "class ImageData(DataContainer):\n    '''\n    Image data ABC\n    '''\n\n    def equal(self, other):\n        '''\n        Overloads == for ImageData.\n\n        other: ImageData\n        '''\n        assert_validity(self, ImageData)\n        assert_validity(other, ImageData)\n        handle = pysirf.cSIRF_equalImages(self.handle, other.handle)\n        check_status(handle)\n        same = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return same\n\n    def __eq__(self, other):\n        return self.equal(other)\n\n    def __ne__(self, other):\n        '''\n        Overloads != for ImageData.\n\n        other: ImageData\n        '''\n        return not (self == other)\n\n    def read(self, file, engine, verb):\n        self.handle = pysirf.cSIRF_readImageData(file, engine, verb)\n        check_status(self.handle)\n\n    def fill(self, image):\n        try_calling(pysirf.cSIRF_fillImageFromImage(self.handle, image.handle))\n        return self\n\n    def get_geometrical_info(self):\n        \"\"\"Get the image's geometrical info.\"\"\"\n        try:\n            import sirf.STIR\n            if isinstance(self, sirf.STIR.ImageData):\n                warnings.warn(\"geometrical info for STIR.ImageData might be incorrect\")\n        except:\n            pass\n        geom_info = GeometricalInfo()\n        geom_info.handle = pysirf.cSIRF_ImageData_get_geom_info(self.handle)\n        check_status(geom_info.handle)\n        return geom_info\n\n    def reorient(self, geom_info):\n        \"\"\"Reorient image. Requires that dimensions match.\"\"\"\n        if not isinstance(geom_info, GeometricalInfo):\n            raise AssertionError()\n        try_calling(pysirf.cSIRF_ImageData_reorient(self.handle, geom_info.handle))",
  "class DataHandleVector(object):\n    \"\"\"\n    DataHandle vector.\n    \"\"\"\n    def __init__(self):\n        self.name = 'DataHandleVector'\n        self.handle = pysirf.cSIRF_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def push_back(self, handle):\n        \"\"\"Push back new data handle.\"\"\"\n        try_calling(pysirf.cSIRF_DataHandleVector_push_back(self.handle, handle))\n        check_status(self.handle)",
  "class GeometricalInfo(object):\n    \"\"\"\n    Get the geometrical information in LPS space. These are encoded\n    as size (number of voxels), spacing, offset (distance to first voxel)\n    and a direction matrix.\n    \"\"\"\n    def __init__(self):\n        self.name = 'GeometricalInfo'\n        self.handle = None\n\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    @deprecation.deprecated(details=\"Please use get_info method instead\")\n    def print_info(self):\n        \"\"\"Print the geom info\"\"\"\n        print(self.get_info())\n\n    def get_info(self):\n        \"\"\"Return the geom info as string\"\"\"\n        handle = pysirf.cSIRF_GeomInfo_get(self.handle)\n        check_status(handle)\n        info = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return info\n\n    def get_offset(self):\n        \"\"\"Offset is the LPS coordinate of the centre of the first voxel.\"\"\"\n        arr = numpy.ndarray((3,), dtype = numpy.float32)\n        try_calling(pysirf.cSIRF_GeomInfo_get_offset(self.handle, arr.ctypes.data))\n        return tuple(arr)\n\n    def get_spacing(self):\n        \"\"\"Spacing is the physical distance between voxels in each dimension.\"\"\"\n        arr = numpy.ndarray((3,), dtype = numpy.float32)\n        try_calling (pysirf.cSIRF_GeomInfo_get_spacing(self.handle, arr.ctypes.data))\n        return tuple(arr)\n    \n    def get_size(self):\n        \"\"\"Size is the number of voxels in each dimension.\"\"\"\n        arr = numpy.ndarray((3,), dtype = cpp_int_dtype())\n        try_calling (pysirf.cSIRF_GeomInfo_get_size(self.handle, arr.ctypes.data))\n        return tuple(arr)\n\n    def get_direction_matrix(self):\n        \"\"\"Each row gives a vector dictating the direction of the axis in LPS physical space.\"\"\"\n        arr = numpy.ndarray((3,3), dtype = numpy.float32)\n        try_calling (pysirf.cSIRF_GeomInfo_get_direction_matrix(self.handle, arr.ctypes.data))\n        return arr\n\n    def get_index_to_physical_point_matrix(self):\n        \"\"\"Get the 4x4 affine matrix that converts an index to a point in LPS physical space.\"\"\"\n        arr = numpy.ndarray((4,4), dtype = numpy.float32)\n        try_calling (pysirf.cSIRF_GeomInfo_get_index_to_physical_point_matrix(self.handle, arr.ctypes.data))\n        return arr",
  "def __init__(self):\n        self.handle = None",
  "def __del__(self):\n        print(\"SIRF.DataContainer __del__ with handle {}.\".format(self.handle))\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def __neg__(self):\n        return self.multiply(-1.0)",
  "def __add__(self, other):\n        '''\n        Overloads + for data containers.\n\n        Returns the sum of the container data with another container \n        data viewed as vectors.\n        other: DataContainer\n        '''\n        return self.add(other)",
  "def __sub__(self, other):\n        '''\n        Overloads - for data containers.\n\n        Returns the difference of the container data with another container \n        data viewed as vectors.\n        other: DataContainer\n        '''\n        if isinstance(other, (DataContainer, Number) ):\n            return self.subtract(other)\n        return NotImplemented",
  "def __mul__(self, other):\n        '''\n        Overloads * for data containers multiplication by a scalar or another\n        data container.\n\n        Returns the product self*other if other is a scalar\n        or the elementwise product if other is of the same type as self.\n        other: DataContainer or a (real or complex) scalar\n        '''\n        return self.multiply(other)",
  "def __rmul__(self, other):\n        '''\n        Overloads * for data containers multiplication by a scalar from\n        the left, i.e. computes and returns the product other*self.\n        other: a real or complex scalar\n        '''\n        return self * other",
  "def __truediv__(self, other):\n        '''\n        Overloads / for data containers division by a scalar or (elementwise)\n        another data container (Python 3.*)\n\n        Returns the ratio self/other if other is a scalar\n        or the elementwise ratio if other is of the same type as self.\n        other: DataContainer or a (real or complex) scalar\n        '''\n        return self.divide(other)",
  "def __iadd__(self, other):\n        self.add(other, out=self)\n        return self",
  "def __imul__(self, other):\n        self.multiply(other, out=self)\n        return self",
  "def __isub__(self, other):\n        self.subtract(other, out=self)\n        return self",
  "def __itruediv__(self, other):\n        self.divide(other, out=self)\n        return self",
  "def same_object(self):\n        '''\n        Returns an object of the same type as self.\n\n        Since this class is abstract, its methods cannot itself create a new\n        object when e.g. adding two objects of this class, so new object is\n        created by the first object using its same_object() method - see\n        clone() below.\n        '''\n        return DataContainer()",
  "def clone(self):\n        assert self.handle is not None\n        x = self.same_object()\n        x.handle = pysirf.cSIRF_clone(self.handle)\n        check_status(x.handle)\n        return x",
  "def copy(self):\n        '''alias of clone'''\n        return self.clone()",
  "def get_uniform_copy(self, value=1.0):\n        '''Initialises an instance of DataContainer based on the template'''\n        y = self.clone()\n        y.fill(value)\n        return y",
  "def write(self, filename):\n        '''\n        Writes to file.\n        '''\n        try_calling(pysirf.cSIRF_write(self.handle, filename))",
  "def number(self):\n        '''\n        Returns the number of items in the container.\n        '''\n        assert self.handle is not None\n        handle = pysirf.cSIRF_dataItems(self.handle)\n        check_status(handle)\n        n = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return n",
  "def is_empty(self):\n        return self.number() < 1",
  "def is_complex(self):\n        assert self.handle is not None\n        handle = pysirf.cSIRF_isComplex(self.handle)\n        check_status(handle)\n        i = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return i != 0",
  "def conjugate(self, out=None):\n        ''' Computes complex conjugate of self.\n\n            Use y = x.conjugate() to get the conjugated copy of x.\n            Use x.conjugate(out=x) to conjugate in-place.\n        '''\n        if out is self:\n            try_calling(pysirf.cSIRF_conjugate(self.handle))\n            return\n        elif out is None:\n            x = self.same_object()\n        else:\n            x = out\n        if x.handle is not None:\n            pyiutil.deleteDataHandle(x.handle)\n        x.handle = pysirf.cSIRF_conjugated(self.handle)\n        check_status(x.handle)\n        if out is None:\n            return x",
  "def norm(self):\n        '''\n        Returns the 2-norm of the container data viewed as a vector.\n        '''\n        handle = pysirf.cSIRF_norm(self.handle)\n        check_status(handle)\n        r = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return r;",
  "def squared_norm(self):\n        '''Returns the squared norm of a DataContainer viewed as a vector\n\n        CIL/SIRF compatibility'''\n        return self.norm() ** 2",
  "def dot(self, other):\n        '''\n        Returns the dot product of the container data with another container \n        data viewed as vectors.\n        other: DataContainer\n        '''\n        assert_validities(self, other)\n        # Check if input are the same size\n        if self.size != other.size:\n            raise ValueError(\"Input sizes are expected to be equal, got \" \\\n                + self.size + \" and \" + other.size + \" instead.\")\n        z = numpy.zeros((2,), dtype=numpy.float32)\n        try_calling(pysirf.cSIRF_compute_dot(self.handle, other.handle, z.ctypes.data))\n        if z[1] == 0:\n            return z[0]\n        return z[0] + 1j*z[1]",
  "def sum(self):\n        '''\n        Returns the sum of the elements of self data\n        '''\n        z = numpy.zeros((2,), dtype=numpy.float32)\n        try_calling(pysirf.cSIRF_compute_sum(self.handle, z.ctypes.data))\n        if z[1] == 0:\n            return z[0]\n        return z[0] + 1j*z[1]",
  "def max(self):\n        '''\n        Returns the maximum of the elements of self data\n        '''\n        z = numpy.zeros((2,), dtype=numpy.float32)\n        try_calling(pysirf.cSIRF_compute_max(self.handle, z.ctypes.data))\n        if z[1] == 0:\n            return z[0]\n        return z[0] + 1j*z[1]",
  "def add(self, other, out=None):\n        '''\n        Addition for data containers.\n\n        If other is a DataContainer, returns the sum of data\n        stored in self and other viewed as vectors.\n        If other is a scalar, returns the same with the second vector filled\n        with the value of other.\n        other: DataContainer or scalar.\n        out:   DataContainer to store the result to.\n        '''\n        if out is None:\n            z = self.same_object()\n        else:\n            z = out\n            assert_validities(self, z)\n        if isinstance(other, Number):\n            a = numpy.asarray([other.real, other.imag], dtype=numpy.float32)\n            if out is None:\n                z.handle = pysirf.cSIRF_sum(self.handle, a.ctypes.data)\n                check_status(z.handle)\n            else:\n                try_calling(pysirf.cSIRF_add(self.handle, a.ctypes.data, z.handle))\n        else:\n            assert_validities(self, other)\n            one = numpy.asarray([1.0, 0.0], dtype = numpy.float32)\n            if out is None:\n                z.handle = pysirf.cSIRF_axpby(one.ctypes.data, self.handle, one.ctypes.data, other.handle)\n                check_status(z.handle)\n            else:\n                try_calling(pysirf.cSIRF_axpbyAlt(one.ctypes.data, self.handle, one.ctypes.data, other.handle, z.handle))\n        return z",
  "def subtract(self, other, out=None):\n        '''\n        Subtraction for data containers.\n\n        If other is a DataContainer, returns the difference of data\n        stored in self and other viewed as vectors.\n        If other is a scalar, returns the same with the second vector filled\n        with the value of other.\n        other: DataContainer or scalar.\n        other: DataContainer\n        '''\n        if not isinstance (other, (DataContainer, Number)):\n            return NotImplemented\n        if isinstance(other, Number):\n            return self.add(-other, out=out)\n        assert_validities(self, other)\n        pl_one = numpy.asarray([1.0, 0.0], dtype = numpy.float32)\n        mn_one = numpy.asarray([-1.0, 0.0], dtype = numpy.float32)\n        if out is None:\n            z = self.same_object()\n            z.handle = pysirf.cSIRF_axpby \\\n                (pl_one.ctypes.data, self.handle, mn_one.ctypes.data, other.handle)\n            check_status(z.handle)\n            return z\n        else:\n            assert_validities(self, out)\n            z = out\n            try_calling(pysirf.cSIRF_axpbyAlt \\\n                (pl_one.ctypes.data, self.handle, mn_one.ctypes.data, other.handle, z.handle))",
  "def multiply(self, other, out=None):\n        '''\n        Elementwise multiplication for data containers.\n\n        Returns the elementwise product of data stored in self and other.\n        other: DataContainer or scalar.\n        out:   DataContainer to store the result to.\n        '''\n        if out is None:\n            return self.binary(other, 'multiply')\n        self.binary(other, 'multiply', out=out)",
  "def divide(self, other, out=None):\n        '''\n        Elementwise ratio for data containers.\n\n        Returns the elementwise ratio of data stored in self and other.\n        other: DataContainer or scalar.\n        out:   DataContainer to store the result to.\n        '''\n        if isinstance(other, Number):\n            if out is None:\n                return self.binary(1./other, 'multiply')\n            self.binary(1./other, 'multiply', out=out)\n        else:\n            if out is None:\n                return self.binary(other, 'divide')\n            self.binary(other, 'divide', out=out)",
  "def maximum(self, other, out=None):\n        '''\n        Elementwise maximum for data containers.\n\n        Returns the elementwise maximum of data stored in self and other.\n        other: DataContainer or scalar.\n        out:   DataContainer to store the result to.\n        '''\n        if out is None:\n            return self.binary(other, 'maximum')\n        self.binary(other, 'maximum', out=out)",
  "def minimum(self, other, out=None):\n        '''\n        Elementwise minimum for data containers.\n\n        Returns the elementwise minimum of data stored in self and other.\n        other: DataContainer or scalar.\n        out:   DataContainer to store the result to.\n        '''\n        if out is None:\n            return self.binary(other, 'minimum')\n        self.binary(other, 'minimum', out=out)",
  "def axpby(self, a, b, y, out=None, **kwargs):\n        '''\n        Linear combination for data containers.\n\n        Returns the linear combination of the self data with another container \n        data y viewed as vectors.\n        a: multiplier to self, can be a number or a DataContainer\n        b: multiplier to y, can be a number or a DataContainer \n        y: DataContainer\n        out:   DataContainer to store the result to.\n        '''\n        return self.sapyb(a, y, b, out=out, **kwargs)",
  "def sapyb(self, a, y, b, out=None, **kwargs):\n        '''\n        Linear combination for data containers: new interface.\n\n        Returns the linear combination of the self data with another container \n        data y viewed as vectors.\n        a: multiplier to self, can be a number or a DataContainer\n        b: multiplier to y, can be a number or a DataContainer \n        y: DataContainer\n        out:   DataContainer to store the result to, can be self or y.\n        '''\n\n        assert_validities(self, y)\n\n        if out is not None:\n            assert_validities(self, out)\n            z = out\n        else:\n            z = self.same_object()\n\n        if isinstance(a, Number):\n            alpha = numpy.asarray([a.real, a.imag], dtype = numpy.float32)\n            if isinstance(b, Number):\n                #a is scalar, b is scalar\n                beta = numpy.asarray([b.real, b.imag], dtype = numpy.float32)\n                if out is None:\n                    z.handle = pysirf.cSIRF_axpby(alpha.ctypes.data, self.handle, beta.ctypes.data, y.handle)\n                else:\n                    try_calling(pysirf.cSIRF_axpbyAlt(alpha.ctypes.data, self.handle, beta.ctypes.data, y.handle, z.handle))\n            else:\n                #a is scalar, b is array\n                if out is None:\n                    z.handle = pysirf.cSIRF_XapYB(self.handle, alpha.ctypes.data, y.handle, b.handle)\n                else:\n                    try_calling(pysirf.cSIRF_XapYBAlt(self.handle, alpha.ctypes.data, y.handle, b.handle, z.handle))\n        else:\n            assert_validities(self, a)\n            if isinstance(b, Number):\n                #a is array, b is scalar\n                beta = numpy.asarray([b.real, b.imag], dtype = numpy.float32)\n                if out is None:\n                    z.handle = pysirf.cSIRF_XapYB(y.handle, beta.ctypes.data, self.handle, a.handle)\n                else:\n                    try_calling(pysirf.cSIRF_XapYBAlt(y.handle, beta.ctypes.data, self.handle, a.handle, z.handle))\n            else:\n                #a is array, b is array\n                assert_validities(self, b)\n                if out is None:\n                    z.handle = pysirf.cSIRF_xapyb(self.handle, a.handle, y.handle, b.handle)\n                else:\n                    try_calling(pysirf.cSIRF_xapybAlt(self.handle, a.handle, y.handle, b.handle, z.handle))\n\n        if out is None:\n            check_status(z.handle)\n            return z",
  "def power(self, other, out=None):\n        '''Power function for DataContainers\n\n        SIRF/CIL compatibility\n        '''\n        if out is None:\n            return self.binary(other, 'power')\n        self.binary(other, 'power', out=out)",
  "def abs(self, out=None):\n        '''Returns the element-wise absolute value of the DataContainer data\n\n        '''\n        if out is None:\n            return self.unary('abs')\n        self.unary('abs', out=out)",
  "def sign(self, out=None):\n        '''Returns the element-wise sign of the DataContainer data\n\n        '''\n        if out is None:\n            return self.unary('sign')\n        self.unary('sign', out=out)",
  "def sqrt(self, out=None):\n        '''Returns the element-wise sqrt of the DataContainer data\n\n        '''\n        if out is None:\n            return self.unary('sqrt')\n        self.unary('sqrt', out=out)",
  "def exp(self, out=None):\n        '''Returns the element-wise exp of the DataContainer data\n\n        '''\n        if out is None:\n            return self.unary('exp')\n        self.unary('exp', out=out)",
  "def log(self, out=None):\n        '''Returns the element-wise log of the DataContainer data\n\n        '''\n        if out is None:\n            return self.unary('log')\n        self.unary('log', out=out)",
  "def binary(self, other, f, out=None):\n        '''Applies function f(x,y) element-wise to self and other.\n\n        other: DataContainer or Number\n        f: the name of the function to apply, Python str.\n        '''\n        if out is None:\n            out = self.same_object()\n        if isinstance(other, Number):\n            y = numpy.asarray([other.real, other.imag], dtype=numpy.float32)\n            if out.handle is None:\n                out.handle = pysirf.cSIRF_semibinary(self.handle, y.ctypes.data, f)\n                check_status(out.handle)\n                return out\n            else:\n                try_calling(pysirf.cSIRF_compute_semibinary(self.handle, y.ctypes.data, \\\n                                                        f, out.handle))\n        else:\n            assert_validities(self, other)\n            if out.handle is None:\n                out.handle = pysirf.cSIRF_binary(self.handle, other.handle, f)\n                check_status(out.handle)\n                return out\n            else:\n                try_calling(pysirf.cSIRF_compute_binary(self.handle, other.handle, \\\n                                                        f, out.handle))",
  "def unary(self, f, out=None):\n        '''Applies function f(x) element-wise to self data.\n\n        f: the name of the function to apply, Python str.\n        '''\n        if out is None:\n            out = self.same_object()\n        if out.handle is None:\n            out.handle = pysirf.cSIRF_unary(self.handle, f)\n            check_status(out.handle)\n            return out\n        else:\n            assert_validities(self, out)\n            try_calling(pysirf.cSIRF_compute_unary(self.handle, f, out.handle))",
  "def shape(self):\n        '''Returns the shape of the data array\n        '''\n        return self.dimensions()",
  "def size(self):\n        '''Returns the (total) size of the data array.'''\n        return numpy.prod(self.dimensions())",
  "def dtype(self):\n        handle = pysirf.cSIRF_bits(self.handle)\n        check_status(handle)\n        bits = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        if self.is_complex():\n            dt = 'complex%s' % bits\n        else:\n            dt = 'float%s' % bits\n        return numpy.dtype(dt)",
  "def equal(self, other):\n        '''\n        Overloads == for ImageData.\n\n        other: ImageData\n        '''\n        assert_validity(self, ImageData)\n        assert_validity(other, ImageData)\n        handle = pysirf.cSIRF_equalImages(self.handle, other.handle)\n        check_status(handle)\n        same = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return same",
  "def __eq__(self, other):\n        return self.equal(other)",
  "def __ne__(self, other):\n        '''\n        Overloads != for ImageData.\n\n        other: ImageData\n        '''\n        return not (self == other)",
  "def read(self, file, engine, verb):\n        self.handle = pysirf.cSIRF_readImageData(file, engine, verb)\n        check_status(self.handle)",
  "def fill(self, image):\n        try_calling(pysirf.cSIRF_fillImageFromImage(self.handle, image.handle))\n        return self",
  "def get_geometrical_info(self):\n        \"\"\"Get the image's geometrical info.\"\"\"\n        try:\n            import sirf.STIR\n            if isinstance(self, sirf.STIR.ImageData):\n                warnings.warn(\"geometrical info for STIR.ImageData might be incorrect\")\n        except:\n            pass\n        geom_info = GeometricalInfo()\n        geom_info.handle = pysirf.cSIRF_ImageData_get_geom_info(self.handle)\n        check_status(geom_info.handle)\n        return geom_info",
  "def reorient(self, geom_info):\n        \"\"\"Reorient image. Requires that dimensions match.\"\"\"\n        if not isinstance(geom_info, GeometricalInfo):\n            raise AssertionError()\n        try_calling(pysirf.cSIRF_ImageData_reorient(self.handle, geom_info.handle))",
  "def __init__(self):\n        self.name = 'DataHandleVector'\n        self.handle = pysirf.cSIRF_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def push_back(self, handle):\n        \"\"\"Push back new data handle.\"\"\"\n        try_calling(pysirf.cSIRF_DataHandleVector_push_back(self.handle, handle))\n        check_status(self.handle)",
  "def __init__(self):\n        self.name = 'GeometricalInfo'\n        self.handle = None",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def print_info(self):\n        \"\"\"Print the geom info\"\"\"\n        print(self.get_info())",
  "def get_info(self):\n        \"\"\"Return the geom info as string\"\"\"\n        handle = pysirf.cSIRF_GeomInfo_get(self.handle)\n        check_status(handle)\n        info = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return info",
  "def get_offset(self):\n        \"\"\"Offset is the LPS coordinate of the centre of the first voxel.\"\"\"\n        arr = numpy.ndarray((3,), dtype = numpy.float32)\n        try_calling(pysirf.cSIRF_GeomInfo_get_offset(self.handle, arr.ctypes.data))\n        return tuple(arr)",
  "def get_spacing(self):\n        \"\"\"Spacing is the physical distance between voxels in each dimension.\"\"\"\n        arr = numpy.ndarray((3,), dtype = numpy.float32)\n        try_calling (pysirf.cSIRF_GeomInfo_get_spacing(self.handle, arr.ctypes.data))\n        return tuple(arr)",
  "def get_size(self):\n        \"\"\"Size is the number of voxels in each dimension.\"\"\"\n        arr = numpy.ndarray((3,), dtype = cpp_int_dtype())\n        try_calling (pysirf.cSIRF_GeomInfo_get_size(self.handle, arr.ctypes.data))\n        return tuple(arr)",
  "def get_direction_matrix(self):\n        \"\"\"Each row gives a vector dictating the direction of the axis in LPS physical space.\"\"\"\n        arr = numpy.ndarray((3,3), dtype = numpy.float32)\n        try_calling (pysirf.cSIRF_GeomInfo_get_direction_matrix(self.handle, arr.ctypes.data))\n        return arr",
  "def get_index_to_physical_point_matrix(self):\n        \"\"\"Get the 4x4 affine matrix that converts an index to a point in LPS physical space.\"\"\"\n        arr = numpy.ndarray((4,4), dtype = numpy.float32)\n        try_calling (pysirf.cSIRF_GeomInfo_get_index_to_physical_point_matrix(self.handle, arr.ctypes.data))\n        return arr",
  "def cpp_int_bits():\n    \"\"\"Returns the number of bits in a C++ integer.\"\"\"\n    return pyiutil.intBits()",
  "def cpp_int_dtype():\n    \"\"\"Returns numpy dtype corresponding to a C++ int.\"\"\"\n    dt = 'int%s' % cpp_int_bits()\n    return numpy.dtype(dt)",
  "def cpp_int_array(v):\n    \"\"\"Converts the input into numpy.ndarray compatible with C++ int array.\"\"\"\n    dt = numpy.dtype('int%s' % cpp_int_bits())\n    if not isinstance(v, numpy.ndarray):\n        v = numpy.array(v, dtype=dt)\n    elif dt != v.dtype:\n        v = v.astype(dt)\n    if not v.flags['C_CONTIGUOUS']:\n        v = numpy.ascontiguousarray(v)\n    return v",
  "def petmr_data_path(petmr):\n    '''\n    Returns the path to PET or MR data.\n    petmr: either 'PET' or 'MR'\n    '''\n    return examples_data_path( petmr.upper() )",
  "def examples_data_path(data_type):\n    '''\n    Returns the path to PET/MR/Registration data used by SIRF/examples demos.\n    data_type: either 'PET' or 'MR' or 'Registration'\n    '''\n    h = pysirf.cSIRF_examples_data_path(data_type)\n    check_status(h)\n    path = pyiutil.charDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return path",
  "def existing_filepath(data_path, file_name):\n    '''\n    Returns the filepath (path/name) to an existing file.\n    Raises error if the file does not exist.\n    data_path: path to the file\n    file_name: file name\n    '''\n    full_name = os.path.join(os.path.abspath(data_path), file_name)\n    if not os.path.isfile(full_name):\n        raise error('file %s not found' % full_name)\n    return full_name",
  "def show_2D_array(title, array, scale = None, colorbar = True):\n    '''\n    Displays a 2D array.\n    title   : the figure title\n    array   : 2D array\n    colorbar: flag specifying whether the colorbar is to be displayed\n    '''\n    try:\n        import matplotlib.pyplot as plt\n    except:\n        print('matplotlib not found, cannot plot the array')\n        return\n    if scale is None:\n        vmin = numpy.amin(array)\n        vmax = numpy.amax(array)\n    else:\n        vmin, vmax = scale\n    plt.figure()\n    plt.title(title)\n    if colorbar:\n        plt.imshow(array, vmin=vmin, vmax=vmax)\n        plt.colorbar()\n    else:\n        plt.imshow(array, cmap='gray', vmin=vmin, vmax=vmax)\n    fignums = plt.get_fignums()\n    print('You may need to close Figure %d window to continue...' % fignums[-1])\n    plt.show()",
  "def show_3D_array\\\n    (array, index=None, tile_shape=None, scale=None, power=None, \\\n     suptitle=None, titles=None, title_size=None, \\\n     zyx=None, xlabel=None, ylabel=None, label=None, \\\n     cmap=None, show=True):\n    '''\n    Displays a 3D array as a set of z-slice tiles.\n    On successful completion returns 0.\n    array     : 3D array\n    index     : z-slices index, either Python list or string of the form\n              : 'a, b-c, ...', where 'b-c' is decoded as 'b, b+1, ..., c';\n              : out-of-range index value causes error (non-zero) return\n    tile_shape: tuple (tile_rows, tile_columns);\n                if not present, the number of tile rows and columns is\n                computed based on the array dimensions\n    scale     : tuple (vmin, vmax) for imshow; defaults to the range of\n                array values\n    power     : if present, numpy.power(abs(array), power) is displayed\n                (power < 1 improves visibility of relatively small array values)\n    suptitle  : figure title; defaults to None\n    titles    : array of tile titles; if not present, each tile title is\n                label + tile_number\n    zyx       : tuple (z, y, x), where x, y, anad z are the dimensions of array\n                corresponding to the spatial dimensions x, y and z; zyx=None is\n                interpreted as (0, 1, 2)\n    xlabel    : label for x axis\n    ylabel    : label for y axis\n    label     : tile title prefix\n    cmap      : colormap\n    show      : flag specifying whether the array must be displayed immediately\n    '''\n    import math\n    try:\n        import matplotlib as mpl\n        import matplotlib.pyplot as plt\n    except:\n        print('matplotlib not found, cannot plot the array')\n        return\n    import numpy\n\n    current_title_size = mpl.rcParams['axes.titlesize']\n    current_label_size = mpl.rcParams['axes.labelsize']\n    current_xlabel_size = mpl.rcParams['xtick.labelsize']\n    current_ylabel_size = mpl.rcParams['ytick.labelsize']\n    mpl.rcParams['axes.titlesize'] = 'small'\n    mpl.rcParams['axes.labelsize'] = 'small'\n    mpl.rcParams['xtick.labelsize'] = 'small'\n    mpl.rcParams['ytick.labelsize'] = 'small'\n\n    if zyx is not None:\n        array = numpy.transpose(array, zyx)\n\n    nz = array.shape[0]\n    if index is None:\n        n = nz\n        index = range(n)\n    else:\n        if type(index) == type(' '):\n            try:\n                index = str_to_int_list(index)\n            except:\n                return 1\n        n = len(index)\n        for k in range(n):\n            z = index[k]\n            if z < 0 or z >= nz:\n                return k + 1\n    ny = array.shape[1]\n    nx = array.shape[2]\n    if tile_shape is None:\n        rows = int(round(math.sqrt(n*nx/ny)))\n        if rows < 1:\n            rows = 1\n        if rows > n:\n            rows = n\n        cols = (n - 1)//rows + 1\n        last_row = rows - 1\n    else:\n        rows, cols = tile_shape\n        assert rows*cols >= n, \\\n            \"tile rows x columns must be not less than the number of images\"\n        last_row = (n - 1)//cols\n    if scale is None:\n        if power is None:\n            vmin = numpy.amin(array)\n            vmax = numpy.amax(array)\n        else:\n            vmin = numpy.power(numpy.amin(abs(array)), power)\n            vmax = numpy.power(numpy.amax(abs(array)), power)\n    else:\n        vmin, vmax = scale\n    fig = plt.figure()\n    if suptitle is not None:\n        if title_size is None:\n            fig.suptitle(suptitle)\n        else:\n            fig.suptitle(suptitle, fontsize=title_size)\n    for k in range(n):\n        z = index[k] #- 1\n        ax = fig.add_subplot(rows, cols, k + 1)\n        if titles is None:\n            if label is not None and nz > 1:\n                ax.set_title(label + (' %d' % z))\n        else:\n            ax.set_title(titles[k])\n        row = k//cols\n        col = k - row*cols\n        if xlabel is None and ylabel is None or row < last_row or col > 0:\n            ax.set_axis_off()\n        else:\n            ax.set_axis_on()\n            if xlabel is not None:\n                plt.xlabel(xlabel)\n                plt.xticks([0, nx - 1], [0, nx - 1])\n            if ylabel is not None:\n                plt.ylabel(ylabel)\n                plt.yticks([0, ny - 1], [0, ny - 1])\n        if power is None:\n            imgplot = ax.imshow(array[z,:,:], cmap, vmin=vmin, vmax=vmax)\n        else:\n            imgplot = ax.imshow(numpy.power(abs(array[z,:,:]), power), cmap, \\\n                                vmin=vmin, vmax=vmax)\n    if show:\n        fignums = plt.get_fignums()\n        last = fignums[-1]\n        if last > 1:\n            print(\"You may need to close Figures' 1 - %d windows to continue...\" \\\n                  % last)\n        else:\n            print('You may need to close Figure 1 window to continue...')\n        plt.show()\n\n    mpl.rcParams['axes.titlesize'] = current_title_size\n    mpl.rcParams['axes.labelsize'] = current_label_size\n    mpl.rcParams['xtick.labelsize'] = current_xlabel_size\n    mpl.rcParams['ytick.labelsize'] = current_ylabel_size\n\n    return 0",
  "def format_numpy_array_for_setter(data, dtype_to_pass=numpy.float32):\n\n    if not isinstance(data, numpy.ndarray):\n        raise error('Wrong input format.' + \\\n            ' Should be numpy.ndarray. Got {}'.format(type(data)))\n\n    if data.dtype != dtype_to_pass:\n            data = data.astype(dtype_to_pass)\n\n    if not data.flags['C_CONTIGUOUS']:\n        data = numpy.ascontiguousarray(data)\n\n    return data",
  "def check_tolerance(expected, actual, abstol=0, reltol=2e-3):\n    '''\n    Check if 2 floats are equal within the specified tolerance, i.e.\n    abs(expected - actual) <= abstol + reltol*abs(expected).\n    Returns an error string if they are not and None otherwise.\n    '''\n    tol = abstol + reltol*abs(expected)\n    if abs(expected - actual) > tol:\n        return \"expected %.4g, got %.4g (tolerance %.3g)\" \\\n               % (expected, actual, tol)",
  "class pTest(object):\n    def __init__(self, filename, record, throw=False):\n        self.record = record\n        self.data = []\n        self.ntest = 0\n        self.nrec = 0\n        self.failed = 0\n        self.verbose = True\n        self.throw = throw\n        if record:\n            self.file = open(filename, 'w')\n        else:\n            with open(filename, 'r') as f:\n                self.data = [float(line.strip()) for line in f]\n            self.size = len(self.data)\n            self.file = None\n\n    def __del__(self):\n        msg = \"%d failures\" % self.failed\n        if self.failed:\n            if self.record:\n                self.file.write(msg + '\\n')\n        if self.record:\n            self.file.close()\n\n    def check(self, value, abs_tol=0, rel_tol=2e-3):\n        '''\n        Tests if value is equal to the recorded one (or record it)\n        value        : the value that was computed\n        abs_tol, rel_tol: see :func:`~Utilities.check_tolerance`\n        '''\n\n        if self.record:\n            self.file.write('%e\\n' % value)\n        else:\n            if self.nrec >= self.size:\n                raise IndexError('no data available for test %d' % self.ntest)\n            else:\n                expected = self.data[self.nrec]\n                self.check_if_equal_within_tolerance(expected, value, abs_tol, rel_tol)\n        self.nrec += 1\n\n    def check_if_equal(self, expected, value):\n        '''\n        Tests if value is equal to the expected one.\n        expected     : the true value\n        value        : the value that was computed\n        '''\n        if value != expected:\n            self.failed += 1\n            msg = '+++ test %d failed: expected %s, got %s' \\\n                  % (self.ntest, repr(expected), repr(value))\n            if self.throw:\n                raise ValueError(msg)\n            if self.verbose:\n                print(msg)\n        else:\n            if self.verbose:\n                print('+++ test %d passed' % self.ntest)\n        self.ntest += 1\n\n    def check_if_equal_within_tolerance(self, expected, value, abs_tol=0, rel_tol=2e-3):\n        '''\n        Tests if float value is equal to the expected one.\n        expected     : the true value\n        value        : the value that was computed\n        abs_tol, rel_tol: see :func:`~Utilities.check_tolerance`\n        '''\n        err = check_tolerance(expected, value, abs_tol, rel_tol)\n        if err is not None:\n            self.failed += 1\n            msg = ('+++ test %d failed: ' % self.ntest) + str(err)\n            if self.throw:\n                raise ValueError(msg)\n            if self.verbose:\n                print(msg)\n        else:\n            if self.verbose:\n                print('+++ test %d passed' % self.ntest)\n        self.ntest += 1\n\n    def check_if_zero_within_tolerance(self, value, abs_tol=1e-3):\n        '''\n        Tests if float value is equal to the expected one.\n        expected     : the true value\n        abs_tol: see :func:`~Utilities.check_tolerance`\n        '''\n        self.check_if_equal_within_tolerance(0, value, abs_tol)\n\n    def check_if_less(self, value, comp):\n        '''\n        Tests if value is (strictly) less than comp.\n        value        : the value that was computed\n        comp         : the maximum allowed value\n        '''\n        if value >= comp:\n            self.failed += 1\n            msg = ('+++ test %d failed: ' % self.ntest) + \\\n                  repr(value) + ' >= ' + repr(comp)\n            if self.throw:\n                raise ValueError(msg)\n            if self.verbose:\n                print(msg)\n        else:\n            if self.verbose:\n                print('+++ test %d passed' % self.ntest)\n        self.ntest += 1",
  "class CheckRaise(pTest):\n    def __init__(self, *a, **k):\n        k[\"throw\"] = True\n        super(CheckRaise, self).__init__(*a, **k)",
  "def runner(main_test, doc, version, author=\"\", licence=None):\n    \"\"\"\n    :param main_test: function(record : bool, verbose : bool, throw : bool)\n    \"\"\"\n    from docopt import docopt\n    args = docopt(doc.format(version=version,\n                             author=author,\n                             licence=licence or __licence__,\n                             license=licence or __licence__),\n                  version=version)\n\n    record = args['--record']\n    verbose = args['--verbose']\n\n    failed, ntest = main_test(record, verbose, throw=False)\n    if failed:\n        import sys\n        print('%d of %d tests failed' % (failed, ntest))\n        sys.exit(failed)\n    if record:\n        print('%d measurements recorded' % ntest)\n    else:\n        print('all %d tests passed' % ntest)",
  "class error(Exception):\n    def __init__(self, value):\n        self.value = value\n    def __str__(self):\n        return '??? ' + repr(self.value)",
  "def check_status(handle, stack=None):\n    if pyiutil.executionStatus(handle) != 0:\n        if stack is None:\n            stack = inspect.stack()[1]\n#        print('\\nFile: %s' % stack[1])\n#        print('Line: %d' % stack[2])\n#        print('check_status found the following message sent from the engine:')\n        msg = pyiutil.executionError(handle)\n        file = pyiutil.executionErrorFile(handle)\n        line = pyiutil.executionErrorLine(handle)\n        errorMsg = \\\n            repr(msg) + ' exception caught at line ' + \\\n            repr(line) + ' of ' + file + '; ' + \\\n            'the reconstruction engine output may provide more information'\n        raise error(errorMsg)",
  "def try_calling(returned_handle):\n    check_status(returned_handle, inspect.stack()[1])\n    pyiutil.deleteDataHandle(returned_handle)",
  "def assert_validity(obj, dtype):\n    if not isinstance(obj, dtype):\n        msg = 'Expecting object of type {}, got {}'\n        raise AssertionError(msg.format(dtype, type(obj)))\n    if obj.handle is None:\n        raise AssertionError('object handle is None.')",
  "def assert_validities(x, y):\n    if not (issubclass(type(x),type(y)) or issubclass(type(y),type(x))):\n        msg = 'Expecting same type input, got {} and {}'\n        raise AssertionError(msg.format(type(x), type(y)))\n    if x.handle is None:\n        raise AssertionError('handle for first parameter is None')\n    if y.handle is None:\n        raise AssertionError('handle for second parameter is None')\n    if callable(getattr(x, 'dimensions', None)):\n        xdim = x.dimensions()\n    else:\n        xdim = None\n    if callable(getattr(y, 'dimensions', None)):\n        ydim = y.dimensions()\n    else:\n        ydim = None\n    if xdim != ydim:\n        raise ValueError(\"Input shapes are expected to be equal, got \" \\\n                         + repr(xdim) + \" and \" \\\n                         + repr(ydim) + \" instead.\")",
  "def label_and_name(g):\n    name = g.lstrip()\n    name = name.rstrip()\n    i = name.find(':')\n    if i > -1:\n        label = name[: i].rstrip()\n        name = name[i + 1 :].lstrip()\n    else:\n        label = ''\n    return label, name",
  "def name_and_parameters(obj):\n    name = obj.lstrip()\n    name = name.rstrip()\n    i = name.find('(')\n    if i > -1:\n        j = name.find(')', i)\n        prop = name[i + 1 : j]\n        name = name[: i].rstrip()\n        i = 0\n    else:\n        prop = None\n    return name, prop",
  "def parse_arglist(arglist):\n    argdict = {}\n    while True:\n        arglist = arglist.lstrip()\n        ieq = arglist.find('=')\n        if ieq < 0:\n            return argdict\n        name = arglist[0:ieq].rstrip()\n        arglist = arglist[ieq + 1 :].lstrip()\n        ic = arglist.find(',')\n        if ic < 0:\n            argdict[name] = arglist.rstrip()\n            return argdict\n        else:\n            argdict[name] = arglist[0:ic].rstrip()\n            arglist = arglist[ic + 1 :]",
  "def str_to_int_list(str_list):\n    int_list = []\n    last = False\n    while not last:\n        ic = str_list.find(',')\n        if ic < 0:\n            ic = len(str_list)\n            last = True\n        str_item = str_list[0:ic]\n        str_list = str_list[ic + 1 :]\n        ic = str_item.find('-')\n        if ic < 0:\n            int_item = [int(str_item)]\n        else:\n            strt = int(str_item[0:ic])\n            stop = int(str_item[ic + 1 :])\n            int_item = list(range(strt, stop + 1))\n        int_list = int_list + int_item\n    return int_list",
  "def is_operator_adjoint(operator, num_tests=5, max_err=10e-5, verbose=True):\n    '''\n    Test if a given operator is adjoint.\n    The operator needs to have been already set_up() with valid objects.\n    The operator needs to have methods direct() and adjoint() implemented\n\n    Parameters\n    ----------\n    operator  :\n        Any SIRF operator that implements direct() and adjoint()\n    num_tests : int, optional\n        Square root of the number of tests with random data that will be executed. Default 5\n    max_err   : double, optional\n        Maximum allowed normalized error, tolerance. Change not recommended. Default 10e-5\n    verbose   : bool\n        Verbose option\n    '''\n    for iter1 in range(num_tests):\n        ## generate random data for x and direct()\n        x = operator.domain_geometry().allocate(value = 'random')\n        y_hat = operator.direct(x)\n        for iter2 in range(num_tests):\n            if verbose:\n                print(\"Testing \" + type(operator).__name__ + \": Iteration \" + str(iter1*num_tests+iter2+1) + \"/\" + str(num_tests**2))\n            ## generate random data and adjoint()\n            y = operator.range_geometry().allocate( value = 'random')\n            x_hat = operator.adjoint(y)\n            # Check dot product identity\n            norm_err = abs(numpy.conj(y_hat.dot(y)) - x_hat.dot(x))/(numpy.conj(abs(y_hat.dot(y)))*0.5 + abs(x_hat.dot(x))*0.5)\n            if norm_err > max_err:\n                if verbose:\n                    print(type(operator).__name__ + \" is not adjoint, with normalized error of \" + str(norm_err) + \" (max: \" + str(max_err) + \")\")\n                return False\n            elif verbose:\n                print(\"Pass, with a with normalized error of \" + str(norm_err) + \" (max: \" + str(max_err) + \")\")\n    return True",
  "def test_data_container_algebra(test, x, eps=1e-5):\n\n    ax = x.as_array()\n    ay = numpy.ones_like(ax)\n    y = x.clone()\n    y.fill(ay)\n\n    s = x.norm()\n    t = numpy.linalg.norm(ax)\n    # needs increased tolerance for large data size\n    test.check_if_equal_within_tolerance(t, s, 0, eps * 10);\n\n    s = x.max()\n    t = numpy.max(ax)\n    test.check_if_equal_within_tolerance(t, s, 0, eps);\n\n    s = x.sum()\n    t = numpy.sum(ax)\n    r = numpy.sum(abs(ax))\n    test.check_if_equal_within_tolerance(t, s, 0, eps);\n\n    s = x.dot(y)\n    t = numpy.vdot(ay, ax)\n    # needs increased tolerance for large data size\n    test.check_if_equal_within_tolerance(t, s, 0, eps * 10);\n\n    x2 = x.multiply(2)\n    ax2 = x2.as_array()\n    s = numpy.linalg.norm(ax2 - 2*ax)\n    t = numpy.linalg.norm(ax2)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    x2 *= 0\n    x.multiply(2, out=x2)\n    ax2 = x2.as_array()\n    s = numpy.linalg.norm(ax2 - 2*ax)\n    t = numpy.linalg.norm(ax2)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    t = x2.norm()\n    x2 -= x*2\n    s = x2.norm()\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y = x.multiply(x)\n    ay = y.as_array()\n    s = numpy.linalg.norm(ay - ax * ax)\n    t = numpy.linalg.norm(ay)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y *= 0\n    x.multiply(x, out=y)\n    ay = y.as_array()\n    s = numpy.linalg.norm(ay - ax * ax)\n    t = numpy.linalg.norm(ay)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    z = x*y\n    az = z.as_array()\n    s = numpy.linalg.norm(az - ax * ay)\n    t = numpy.linalg.norm(az)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y = x + 1\n    ay = y.as_array()\n    s = numpy.linalg.norm(ay - (ax + 1))\n    t = numpy.linalg.norm(ay)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y *= 0\n    x.add(1, out=y)\n    ay = y.as_array()\n    s = numpy.linalg.norm(ay - (ax + 1))\n    t = numpy.linalg.norm(ay)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    z = x/y\n    az = z.as_array()\n    s = numpy.linalg.norm(az - ax/ay)\n    t = numpy.linalg.norm(az)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    z = x/2\n    az = z.as_array()\n    s = numpy.linalg.norm(az - ax/2)\n    t = numpy.linalg.norm(az)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    z *= 0\n    x.divide(y, out=z)\n    az = z.as_array()\n    s = numpy.linalg.norm(az - ax/ay)\n    t = numpy.linalg.norm(az)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y = x.sapyb(1, x, -1)\n    s = y.norm()\n    test.check_if_equal(0, s)\n\n    y *= 0\n    x.sapyb(1, x, -1, out=y)\n    s = y.norm()\n    test.check_if_equal(0, s)\n\n    y = x.sapyb(z, x, -z)\n    s = y.norm()\n    test.check_if_equal(0, s)\n\n    y *= 0\n    x.sapyb(z, x, -z, out=y)\n    s = y.norm()\n    test.check_if_equal(0, s)\n\n    y = x.sapyb(x, x*x, -1)\n    s = y.norm()\n    test.check_if_equal(0, s)\n\n    y *= 0\n    x.sapyb(x, x*x, -1, out=y)\n    s = y.norm()\n    test.check_if_equal(0, s)\n\n    z = x*x\n    y = z.sapyb(1, x, -x)\n    s = y.norm()\n    test.check_if_equal(0, s)\n\n    y *= 0\n    z.sapyb(1, x, -x, out=y)\n    s = y.norm()\n    test.check_if_equal(0, s)\n\n    y = x.maximum(z)\n    ay = y.as_array()\n    az = z.as_array()\n    ay -= numpy.maximum(ax, az)\n    s = numpy.linalg.norm(ay)\n    test.check_if_equal(0, s)\n\n    y *= 0\n    x.maximum(z, out=y)\n    ay = y.as_array()\n    az = z.as_array()\n    ay -= numpy.maximum(ax, az)\n    s = numpy.linalg.norm(ay)\n    test.check_if_equal(0, s)\n\n    y = x.maximum(0)\n    ay = y.as_array()\n    ay -= numpy.maximum(ax, 0)\n    s = numpy.linalg.norm(ay)\n    test.check_if_equal(0, s)\n\n    y *= 0\n    x.maximum(0, out=y)\n    ay = y.as_array()\n    ay -= numpy.maximum(ax, 0)\n    s = numpy.linalg.norm(ay)\n    test.check_if_equal(0, s)\n\n    y = x.minimum(z)\n    ay = y.as_array()\n    az = z.as_array()\n    ay -= numpy.minimum(ax, az)\n    s = numpy.linalg.norm(ay)\n    test.check_if_equal(0, s)\n\n    y *= 0\n    x.minimum(z, out=y)\n    ay = y.as_array()\n    az = z.as_array()\n    ay -= numpy.minimum(ax, az)\n    s = numpy.linalg.norm(ay)\n    test.check_if_equal(0, s)\n\n    y = x.minimum(0)\n    ay = y.as_array()\n    ay -= numpy.minimum(ax, 0)\n    s = numpy.linalg.norm(ay)\n    test.check_if_equal(0, s)\n\n    y *= 0\n    x.minimum(0, out=y)\n    ay = y.as_array()\n    ay -= numpy.minimum(ax, 0)\n    s = numpy.linalg.norm(ay)\n    test.check_if_equal(0, s)\n\n    y = x.exp()\n    ay = y.as_array()\n    ay -= numpy.exp(ax)\n    s = numpy.linalg.norm(ay)\n    t = y.norm()\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y *= 0\n    x.exp(out=y)\n    ay = y.as_array()\n    ay -= numpy.exp(ax)\n    s = numpy.linalg.norm(ay)\n    t = y.norm()\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y = x.log()\n    ay = y.as_array()\n    az = numpy.log(ax)\n    numpy.nan_to_num(ay, copy=False, posinf=0.0, neginf=0.0)\n    numpy.nan_to_num(az, copy=False, posinf=0.0, neginf=0.0)\n    ay -= az\n    s = numpy.linalg.norm(ay)\n    t = numpy.linalg.norm(az)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y *= 0\n    x.log(out=y)\n    ay = y.as_array()\n    az = numpy.log(ax)\n    numpy.nan_to_num(ay, copy=False, posinf=0.0, neginf=0.0)\n    numpy.nan_to_num(az, copy=False, posinf=0.0, neginf=0.0)\n    ay -= az\n    s = numpy.linalg.norm(ay)\n    t = numpy.linalg.norm(az)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y = x.sqrt()\n    ay = y.as_array()\n    ay -= numpy.sqrt(ax)\n    s = numpy.linalg.norm(ay)\n    t = y.norm()\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y *= 0\n    x.sqrt(out=y)\n    ay = y.as_array()\n    ay -= numpy.sqrt(ax)\n    s = numpy.linalg.norm(ay)\n    t = y.norm()\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y = x.sign()\n    ay = y.as_array()\n    ay -= numpy.sign(ax)\n    s = numpy.linalg.norm(ay)\n    t = y.norm()\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y *= 0\n    x.sign(out=y)\n    ay = y.as_array()\n    ay -= numpy.sign(ax)\n    s = numpy.linalg.norm(ay)\n    t = y.norm()\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y = x.abs()\n    ay = y.as_array()\n    ay -= numpy.abs(ax)\n    s = numpy.linalg.norm(ay)\n    t = y.norm()\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    y *= 0\n    x.abs(out=y)\n    ay = y.as_array()\n    ay -= numpy.abs(ax)\n    s = numpy.linalg.norm(ay)\n    t = y.norm()\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    p = -0.5\n    z = x.power(p)\n    az = z.as_array()\n    numpy.nan_to_num(az, copy=False, posinf=0.0, neginf=0.0)\n    t = numpy.linalg.norm(az)\n    az -= numpy.power(ax, p)\n    numpy.nan_to_num(az, copy=False, posinf=0.0, neginf=0.0)\n    s = numpy.linalg.norm(az)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    z *= 0\n    x.power(p, out=z)\n    az = z.as_array()\n    numpy.nan_to_num(az, copy=False, posinf=0.0, neginf=0.0)\n    t = numpy.linalg.norm(az)\n    az -= numpy.power(ax, p)\n    numpy.nan_to_num(az, copy=False, posinf=0.0, neginf=0.0)\n    s = numpy.linalg.norm(az)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    ay = -numpy.ones_like(ax)/2\n    y.fill(ay)\n    z = x.power(y)\n    ay = y.as_array()\n    az = z.as_array()\n    numpy.nan_to_num(az, copy=False, posinf=0.0, neginf=0.0)\n    t = numpy.linalg.norm(az)\n    az -= numpy.power(ax, ay)\n    numpy.nan_to_num(az, copy=False, posinf=0.0, neginf=0.0)\n    s = numpy.linalg.norm(az)\n    test.check_if_zero_within_tolerance(s, eps * t)\n\n    z *= 0\n    x.power(y, out=z)\n    ay = y.as_array()\n    az = z.as_array()\n    numpy.nan_to_num(az, copy=False, posinf=0.0, neginf=0.0)\n    t = numpy.linalg.norm(az)\n    az -= numpy.power(ax, ay)\n    numpy.nan_to_num(az, copy=False, posinf=0.0, neginf=0.0)\n    s = numpy.linalg.norm(az)\n    test.check_if_zero_within_tolerance(s, eps * t)",
  "class DataContainerAlgebraTests(object):\n\n    '''A base class for unit test of DataContainer algebra.'''\n    def test_divide_scalar(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image1.fill(1.)\n        image2.fill(2.)\n        \n        tmp = image1/1.\n        numpy.testing.assert_array_equal(image1.as_array(), tmp.as_array())\n    \n        tmp1 = image1.divide(1.)\n        numpy.testing.assert_array_equal(tmp.as_array(), tmp1.as_array())\n        \n        image1.divide(1., out=image2)\n        numpy.testing.assert_array_equal(tmp.as_array(), image2.as_array())\n\n        image2.fill(2)\n        image2 /= 2.0\n        numpy.testing.assert_array_equal(image1.as_array(), image2.as_array())\n\n    def test_divide_datacontainer(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        # add 1 because the data contains zeros and divide is not going to be happy\n        image1 = self.image1 + 1\n        image2 = self.image2 + 1\n        \n        tmp = image1/image2\n\n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp.as_array()\n            )\n    \n        tmp1 = image1.divide(image2)\n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )\n        \n        tmp1.fill(2.)\n        image1.divide(image2, out=tmp1)\n        \n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )\n        \n        image1 /= image2\n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), image1.as_array()\n            )        \n\n    def test_multiply_scalar(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image2.fill(2.)\n        \n        tmp = image1 * 1.\n        numpy.testing.assert_array_equal(image1.as_array(), tmp.as_array())\n    \n        tmp1 = image1.multiply(1.)\n        numpy.testing.assert_array_equal(tmp.as_array(), tmp1.as_array())\n        \n        image1.multiply(1., out=image2)\n        numpy.testing.assert_array_equal(tmp.as_array(), image2.as_array())\n\n    def test_multiply_datacontainer(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image2.fill(1.)\n        tmp = image1 * image2\n\n        numpy.testing.assert_array_almost_equal(\n            image1.as_array(), tmp.as_array()\n            )\n    \n        tmp1 = image1.multiply(image2)\n        numpy.testing.assert_array_almost_equal(\n            image1.as_array(), tmp1.as_array()\n            )\n        \n        tmp1.fill(2.)\n        image1.multiply(image2, out=tmp1)\n        \n        numpy.testing.assert_array_almost_equal(\n            image1.as_array(), tmp1.as_array()\n            )\n\n    def test_add_scalar(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image1.fill(0)\n        image2.fill(1)\n        \n        tmp = image1 + 1.\n        numpy.testing.assert_array_equal(image2.as_array(), tmp.as_array())\n    \n        tmp1 = image1.add(1.)\n        numpy.testing.assert_array_equal(tmp.as_array(), tmp1.as_array())\n        \n        tmp1.fill(0)\n        image1.add(1., out=tmp1)\n        numpy.testing.assert_array_equal(tmp1.as_array(), image2.as_array())\n    \n    def test_add_datacontainer(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image1.fill(0.)\n        image2.fill(1.)\n        tmp = image1 + image2\n\n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp.as_array()\n            )\n    \n        tmp1 = image1.add(image2)\n        \n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )\n        \n        tmp1.fill(2.)\n        image1.add(image2, out=tmp1)\n        \n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )\n        \n    \n    def test_subtract_scalar(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image1.fill(2)\n        image2.fill(1)\n        \n        tmp = image1 - 1.\n        numpy.testing.assert_array_equal(image2.as_array(), tmp.as_array())\n    \n        tmp1 = image1.subtract(1.)\n        numpy.testing.assert_array_equal(tmp.as_array(), tmp1.as_array())\n        \n        tmp1.fill(0)\n        image1.subtract(1., out=tmp1)\n        numpy.testing.assert_array_equal(tmp1.as_array(), image2.as_array())\n\n    def test_subtract_datacontainer(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        \n        tmp = image1 - image2\n\n        numpy.testing.assert_array_almost_equal(\n            numpy.zeros(image1.shape, dtype=numpy.float32), tmp.as_array()\n            )\n    \n        tmp1 = image1.subtract(image2)\n        \n        numpy.testing.assert_array_almost_equal(\n            numpy.zeros(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )\n        \n        tmp1.fill(2.)\n        image1.subtract(image2, out=tmp1)\n        \n        numpy.testing.assert_array_almost_equal(\n            numpy.zeros(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )\n\n    def test_division_by_scalar_zero(self):\n        self.assertTrue(True)\n        return\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        try:\n            self.image1 / 0.\n            self.assertFalse(True)\n        except ZeroDivisionError:\n            self.assertTrue(True)\n        except error:\n            self.assertTrue(True)\n    \n    def test_division_by_datacontainer_zero(self):\n        self.assertTrue(True)\n        return\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        try:\n            self.image2 *= 0\n            tmp = self.image1 / self.image2\n            self.assertFalse(True)\n        except ZeroDivisionError:\n            self.assertTrue(True)\n        except error:\n            self.assertTrue(True)\n\n    def test_sapyb_scalars(self):\n\n        image1 = self.image1.copy()\n        image2 = self.image2.copy()\n\n        arr = numpy.arange(0,image1.size).reshape(image1.shape)\n        image1.fill(arr)\n        image2.fill(-arr)\n\n        #scalars\n        #check call methods with out\n\n        a = 2.0\n        b = -3.0\n        gold = a * arr - b * arr\n\n        out = image1.sapyb(a, image2, b)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(0)\n        image1.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(arr)\n        out.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(-arr)\n        image1.sapyb(a, out, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n\n    def test_sapyb_vectors(self):\n\n        image1 = self.image1.copy()\n        image2 = self.image2.copy()\n\n        arr = numpy.arange(0,image1.size).reshape(image1.shape)\n        image1.fill(arr)\n        image2.fill(-arr)\n\n        a = image1.copy()\n        a.fill(2)\n        b = image1.copy()\n        b.fill(-3)\n\n        gold = a.as_array() * arr - b.as_array() * arr\n\n        out = image1.sapyb(a, image2, b)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(0)\n        image1.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(arr)\n        out.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(-arr)\n        image1.sapyb(a, out, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n\n    def test_sapyb_mixed(self):\n\n        image1 = self.image1.copy()\n        image2 = self.image2.copy()\n\n        arr = numpy.arange(0,image1.size).reshape(image1.shape)\n        image1.fill(arr)\n        image2.fill(-arr)\n \n        a = 2.0\n        b = image1.copy()\n        b.fill(-3)\n\n        gold = a * arr - b.as_array() * arr\n\n        out = image1.sapyb(a, image2, b)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(0)\n        image1.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n       \n        out.fill(arr)\n        out.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(-arr)\n        image1.sapyb(a, out, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)",
  "def __init__(self, filename, record, throw=False):\n        self.record = record\n        self.data = []\n        self.ntest = 0\n        self.nrec = 0\n        self.failed = 0\n        self.verbose = True\n        self.throw = throw\n        if record:\n            self.file = open(filename, 'w')\n        else:\n            with open(filename, 'r') as f:\n                self.data = [float(line.strip()) for line in f]\n            self.size = len(self.data)\n            self.file = None",
  "def __del__(self):\n        msg = \"%d failures\" % self.failed\n        if self.failed:\n            if self.record:\n                self.file.write(msg + '\\n')\n        if self.record:\n            self.file.close()",
  "def check(self, value, abs_tol=0, rel_tol=2e-3):\n        '''\n        Tests if value is equal to the recorded one (or record it)\n        value        : the value that was computed\n        abs_tol, rel_tol: see :func:`~Utilities.check_tolerance`\n        '''\n\n        if self.record:\n            self.file.write('%e\\n' % value)\n        else:\n            if self.nrec >= self.size:\n                raise IndexError('no data available for test %d' % self.ntest)\n            else:\n                expected = self.data[self.nrec]\n                self.check_if_equal_within_tolerance(expected, value, abs_tol, rel_tol)\n        self.nrec += 1",
  "def check_if_equal(self, expected, value):\n        '''\n        Tests if value is equal to the expected one.\n        expected     : the true value\n        value        : the value that was computed\n        '''\n        if value != expected:\n            self.failed += 1\n            msg = '+++ test %d failed: expected %s, got %s' \\\n                  % (self.ntest, repr(expected), repr(value))\n            if self.throw:\n                raise ValueError(msg)\n            if self.verbose:\n                print(msg)\n        else:\n            if self.verbose:\n                print('+++ test %d passed' % self.ntest)\n        self.ntest += 1",
  "def check_if_equal_within_tolerance(self, expected, value, abs_tol=0, rel_tol=2e-3):\n        '''\n        Tests if float value is equal to the expected one.\n        expected     : the true value\n        value        : the value that was computed\n        abs_tol, rel_tol: see :func:`~Utilities.check_tolerance`\n        '''\n        err = check_tolerance(expected, value, abs_tol, rel_tol)\n        if err is not None:\n            self.failed += 1\n            msg = ('+++ test %d failed: ' % self.ntest) + str(err)\n            if self.throw:\n                raise ValueError(msg)\n            if self.verbose:\n                print(msg)\n        else:\n            if self.verbose:\n                print('+++ test %d passed' % self.ntest)\n        self.ntest += 1",
  "def check_if_zero_within_tolerance(self, value, abs_tol=1e-3):\n        '''\n        Tests if float value is equal to the expected one.\n        expected     : the true value\n        abs_tol: see :func:`~Utilities.check_tolerance`\n        '''\n        self.check_if_equal_within_tolerance(0, value, abs_tol)",
  "def check_if_less(self, value, comp):\n        '''\n        Tests if value is (strictly) less than comp.\n        value        : the value that was computed\n        comp         : the maximum allowed value\n        '''\n        if value >= comp:\n            self.failed += 1\n            msg = ('+++ test %d failed: ' % self.ntest) + \\\n                  repr(value) + ' >= ' + repr(comp)\n            if self.throw:\n                raise ValueError(msg)\n            if self.verbose:\n                print(msg)\n        else:\n            if self.verbose:\n                print('+++ test %d passed' % self.ntest)\n        self.ntest += 1",
  "def __init__(self, *a, **k):\n        k[\"throw\"] = True\n        super(CheckRaise, self).__init__(*a, **k)",
  "def __init__(self, value):\n        self.value = value",
  "def __str__(self):\n        return '??? ' + repr(self.value)",
  "def test_divide_scalar(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image1.fill(1.)\n        image2.fill(2.)\n        \n        tmp = image1/1.\n        numpy.testing.assert_array_equal(image1.as_array(), tmp.as_array())\n    \n        tmp1 = image1.divide(1.)\n        numpy.testing.assert_array_equal(tmp.as_array(), tmp1.as_array())\n        \n        image1.divide(1., out=image2)\n        numpy.testing.assert_array_equal(tmp.as_array(), image2.as_array())\n\n        image2.fill(2)\n        image2 /= 2.0\n        numpy.testing.assert_array_equal(image1.as_array(), image2.as_array())",
  "def test_divide_datacontainer(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        # add 1 because the data contains zeros and divide is not going to be happy\n        image1 = self.image1 + 1\n        image2 = self.image2 + 1\n        \n        tmp = image1/image2\n\n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp.as_array()\n            )\n    \n        tmp1 = image1.divide(image2)\n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )\n        \n        tmp1.fill(2.)\n        image1.divide(image2, out=tmp1)\n        \n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )\n        \n        image1 /= image2\n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), image1.as_array()\n            )",
  "def test_multiply_scalar(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image2.fill(2.)\n        \n        tmp = image1 * 1.\n        numpy.testing.assert_array_equal(image1.as_array(), tmp.as_array())\n    \n        tmp1 = image1.multiply(1.)\n        numpy.testing.assert_array_equal(tmp.as_array(), tmp1.as_array())\n        \n        image1.multiply(1., out=image2)\n        numpy.testing.assert_array_equal(tmp.as_array(), image2.as_array())",
  "def test_multiply_datacontainer(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image2.fill(1.)\n        tmp = image1 * image2\n\n        numpy.testing.assert_array_almost_equal(\n            image1.as_array(), tmp.as_array()\n            )\n    \n        tmp1 = image1.multiply(image2)\n        numpy.testing.assert_array_almost_equal(\n            image1.as_array(), tmp1.as_array()\n            )\n        \n        tmp1.fill(2.)\n        image1.multiply(image2, out=tmp1)\n        \n        numpy.testing.assert_array_almost_equal(\n            image1.as_array(), tmp1.as_array()\n            )",
  "def test_add_scalar(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image1.fill(0)\n        image2.fill(1)\n        \n        tmp = image1 + 1.\n        numpy.testing.assert_array_equal(image2.as_array(), tmp.as_array())\n    \n        tmp1 = image1.add(1.)\n        numpy.testing.assert_array_equal(tmp.as_array(), tmp1.as_array())\n        \n        tmp1.fill(0)\n        image1.add(1., out=tmp1)\n        numpy.testing.assert_array_equal(tmp1.as_array(), image2.as_array())",
  "def test_add_datacontainer(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image1.fill(0.)\n        image2.fill(1.)\n        tmp = image1 + image2\n\n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp.as_array()\n            )\n    \n        tmp1 = image1.add(image2)\n        \n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )\n        \n        tmp1.fill(2.)\n        image1.add(image2, out=tmp1)\n        \n        numpy.testing.assert_array_almost_equal(\n            numpy.ones(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )",
  "def test_subtract_scalar(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        image1.fill(2)\n        image2.fill(1)\n        \n        tmp = image1 - 1.\n        numpy.testing.assert_array_equal(image2.as_array(), tmp.as_array())\n    \n        tmp1 = image1.subtract(1.)\n        numpy.testing.assert_array_equal(tmp.as_array(), tmp1.as_array())\n        \n        tmp1.fill(0)\n        image1.subtract(1., out=tmp1)\n        numpy.testing.assert_array_equal(tmp1.as_array(), image2.as_array())",
  "def test_subtract_datacontainer(self):\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        image1 = self.image1\n        image2 = self.image2\n        \n        tmp = image1 - image2\n\n        numpy.testing.assert_array_almost_equal(\n            numpy.zeros(image1.shape, dtype=numpy.float32), tmp.as_array()\n            )\n    \n        tmp1 = image1.subtract(image2)\n        \n        numpy.testing.assert_array_almost_equal(\n            numpy.zeros(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )\n        \n        tmp1.fill(2.)\n        image1.subtract(image2, out=tmp1)\n        \n        numpy.testing.assert_array_almost_equal(\n            numpy.zeros(image1.shape, dtype=numpy.float32), tmp1.as_array()\n            )",
  "def test_division_by_scalar_zero(self):\n        self.assertTrue(True)\n        return\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        try:\n            self.image1 / 0.\n            self.assertFalse(True)\n        except ZeroDivisionError:\n            self.assertTrue(True)\n        except error:\n            self.assertTrue(True)",
  "def test_division_by_datacontainer_zero(self):\n        self.assertTrue(True)\n        return\n        if hasattr(self, 'cwd'):\n            os.chdir(self.cwd)\n        try:\n            self.image2 *= 0\n            tmp = self.image1 / self.image2\n            self.assertFalse(True)\n        except ZeroDivisionError:\n            self.assertTrue(True)\n        except error:\n            self.assertTrue(True)",
  "def test_sapyb_scalars(self):\n\n        image1 = self.image1.copy()\n        image2 = self.image2.copy()\n\n        arr = numpy.arange(0,image1.size).reshape(image1.shape)\n        image1.fill(arr)\n        image2.fill(-arr)\n\n        #scalars\n        #check call methods with out\n\n        a = 2.0\n        b = -3.0\n        gold = a * arr - b * arr\n\n        out = image1.sapyb(a, image2, b)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(0)\n        image1.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(arr)\n        out.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(-arr)\n        image1.sapyb(a, out, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)",
  "def test_sapyb_vectors(self):\n\n        image1 = self.image1.copy()\n        image2 = self.image2.copy()\n\n        arr = numpy.arange(0,image1.size).reshape(image1.shape)\n        image1.fill(arr)\n        image2.fill(-arr)\n\n        a = image1.copy()\n        a.fill(2)\n        b = image1.copy()\n        b.fill(-3)\n\n        gold = a.as_array() * arr - b.as_array() * arr\n\n        out = image1.sapyb(a, image2, b)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(0)\n        image1.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(arr)\n        out.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(-arr)\n        image1.sapyb(a, out, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)",
  "def test_sapyb_mixed(self):\n\n        image1 = self.image1.copy()\n        image2 = self.image2.copy()\n\n        arr = numpy.arange(0,image1.size).reshape(image1.shape)\n        image1.fill(arr)\n        image2.fill(-arr)\n \n        a = 2.0\n        b = image1.copy()\n        b.fill(-3)\n\n        gold = a * arr - b.as_array() * arr\n\n        out = image1.sapyb(a, image2, b)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(0)\n        image1.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n       \n        out.fill(arr)\n        out.sapyb(a, image2, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image2.as_array(), -arr)\n\n        out.fill(-arr)\n        image1.sapyb(a, out, b, out=out)\n        numpy.testing.assert_allclose(out.as_array(), gold)\n        numpy.testing.assert_allclose(image1.as_array(), arr)",
  "def show(image_file):\n    i = image_file.find('.h5')\n    if i > 0:\n        from sirf.Gadgetron import ImageData\n        image_data = ImageData(image_file)\n        image_data.show(title='Image data', cmap=None)\n    else:\n        from sirf.STIR import ImageData\n        image_data = ImageData(image_file)\n        image_data.show(title='Image data')",
  "def set_parameter(hs, group, par, hv, stack = None):\n    if stack is None:\n        stack = inspect.stack()[1]\n    h = setParameter(hs, group, par, hv)\n    check_status(h, stack)\n    pyiutil.deleteDataHandle(h)",
  "def set_bool_par(handle, group, par, value):\n    h = pyiutil.boolDataHandle(value)\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def set_char_par(handle, group, par, value):\n    h = pyiutil.charDataHandle(value)\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def set_int_par(handle, group, par, value):\n    h = pyiutil.intDataHandle(value)\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def set_float_par(handle, group, par, value):\n    h = pyiutil.floatDataHandle(value)\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def bool_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.boolDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def char_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = pyiutil.charDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def int_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.intDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def int_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.intDataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def uint16_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.uint16DataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def uint32_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.uint32DataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def uint64_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.uint64DataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def float_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h)\n    v = pyiutil.floatDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return v",
  "def float_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.floatDataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def parameter_handle(hs, group, par):\n    handle = parameter(hs, group, par)\n    check_status(handle, inspect.stack()[1])\n    return handle",
  "class MessageRedirector(object):\n    \"\"\"Class for registration printing redirection to files/stdout/stderr.\"\"\"\n\n    def __init__(self, info=None, warn='stdout', errr='stdout'):\n        \"\"\"Create MessageRedirector object.\n\n        This redirects Reg's ouput\n        produced by info(), warning() and error(0 functions to destinations\n        specified respectively by info, warn and err arguments.\n        The argument values other than None, stdout, stderr, cout and cerr\n        are interpreted as filenames.\n        None and empty string value suppresses printing.\n        \"\"\"\n        if info is None:\n            info = ''\n        if not isinstance(info, str):\n            raise error(\n                'wrong info argument for MessageRedirector constructor')\n        elif info in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.info = pyreg.newTextPrinter(info)\n            self.info_case = 0\n        else:\n            self.info = pyreg.newTextWriter(info)\n            self.info_case = 1\n        pyreg.openChannel(0, self.info)\n\n        if warn is None:\n            warn = ''\n        if not isinstance(warn, str):\n            raise error(\n                'wrong warn argument for MessageRedirector constructor')\n        elif warn in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.warn = pyreg.newTextPrinter(warn)\n            self.warn_case = 0\n        else:\n            self.warn = pyreg.newTextWriter(warn)\n            self.warn_case = 1\n        pyreg.openChannel(1, self.warn)\n\n        if errr is None:\n            errr = ''\n        if not isinstance(errr, str):\n            raise error(\n                'wrong errr argument for MessageRedirector constructor')\n        elif errr in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.errr = pyreg.newTextPrinter(errr)\n            self.errr_case = 0\n        else:\n            self.errr = pyreg.newTextWriter(errr)\n            self.errr_case = 1\n        pyreg.openChannel(2, self.errr)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.info_case == 0:\n            try_calling(pyreg.deleteTextPrinter(self.info))\n        else:\n            try_calling(pyreg.deleteTextWriter(self.info))\n        pyreg.closeChannel(0, self.info)\n        if self.warn_case == 0:\n            try_calling(pyreg.deleteTextPrinter(self.warn))\n        else:\n            try_calling(pyreg.deleteTextWriter(self.warn))\n        pyreg.closeChannel(1, self.warn)\n        if self.errr_case == 0:\n            try_calling(pyreg.deleteTextPrinter(self.errr))\n        else:\n            try_calling(pyreg.deleteTextWriter(self.errr))\n        pyreg.closeChannel(2, self.errr)",
  "class _Transformation(ABC):\n    \"\"\"Abstract base class for transformations.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'Transformation'\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def get_as_deformation_field(self, ref):\n        \"\"\"Get any type of transformation as a deformation field.\n\n        This is useful for joining them together. Require a reference\n        image for converting transformation matrices to deformations.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if not isinstance(ref, NiftiImageData3D):\n            raise AssertionError()\n        output = NiftiImageData3DDeformation()\n        output.handle = pyreg.cReg_Transformation_get_as_deformation_field(\n            self.handle, self.name, ref.handle)\n        check_status(output.handle)\n        return output",
  "class NiftiImageData(SIRF.ImageData):\n    \"\"\"General class for nifti image data.\"\"\"\n    _ADD      = 0\n    _SUBTRACT = 1\n    _MULTIPLY = 2\n    _DIVIDE   = 3\n    def __init__(self, src=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'NiftiImageData'\n        if src is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src)\n        elif isinstance(src, SIRF.ImageData):\n            # src is ImageData\n            dim = src.dimensions()\n            self.handle = pyreg.cReg_NiftiImageData_from_SIRFImageData(\n                src.handle, int(dim[0] > 1))\n        else:\n            raise error('Wrong source in NiftiImageData constructor')\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def equal(self, other):\n        \"\"\"Overload comparison operator.\"\"\"\n        if not isinstance(other, NiftiImageData):\n            raise AssertionError()\n        if self.handle is None or other.handle is None:\n            error('Cannot compare images as at least one is uninitialised')\n        h = pyreg.cReg_NiftiImageData_equal(self.handle, other.handle)\n        check_status(h, inspect.stack()[1])\n        value = pyiutil.intDataFromHandle(h)\n        pyiutil.deleteDataHandle(h)\n        return value\n\n    def __eq__(self, other):\n        \"\"\"Overload == operator.\"\"\"\n        try:\n            return self.equal(other)\n        except:\n            return super(NiftiImageData, self).equal(other)\n\n    def __ne__(self, other):\n        \"\"\"Overload comparison operator.\"\"\"\n        return not self == other\n\n    def write(self, filename, datatype=-1):\n        \"\"\"Save to file.\n\n        See nifti1.h for datatypes (e.g., float (NIFTI_TYPE_FLOAT32) = 16).\n        Image's original datatpye is used by default.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        try_calling(pyreg.cReg_NiftiImageData_write(self.handle, filename,\n                                                    datatype))\n\n    def get_max(self):\n        \"\"\"Get max.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'max')\n\n    def get_min(self):\n        \"\"\"Get min.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'min')\n\n    def get_mean(self):\n        \"\"\"Get mean.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'mean')\n\n    def get_variance(self):\n        \"\"\"Get variance.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'variance')\n\n    def get_standard_deviation(self):\n        \"\"\"Get standard deviation.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'std')\n\n    def get_sum(self):\n        \"\"\"Get sum.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'sum')\n\n    def dimensions(self):\n        \"\"\"Return image dimensions as a tuple.\"\"\"\n        dim = self.get_dimensions()\n        return tuple(dim[1:1+dim[0]])  # dim[0] tells us how many dimensions\n\n    def get_dimensions(self):\n        \"\"\"Get dimensions.\n\n        Returns nifti format.\n        i.e., dim[0]=ndims, dim[1]=nx, dim[2]=ny,...\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        dim = numpy.ndarray((8,), dtype=cpp_int_dtype())\n        try_calling(pyreg.cReg_NiftiImageData_get_dimensions(\n            self.handle, dim.ctypes.data))\n        return dim\n\n    def get_voxel_sizes(self):\n        \"\"\"Get voxel sizes.\n\n        Returns nifti format.\n        i.e., dim[0]=?, dim[1]=dx, dim[2]=dy,...\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        out = numpy.ndarray((8,), dtype=numpy.float32)\n        try_calling(pyreg.cReg_NiftiImageData_get_voxel_sizes(\n            self.handle, out.ctypes.data))\n        return out\n\n    def fill(self, val):\n        \"\"\"Fill image with single value or numpy array.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if isinstance(val, numpy.ndarray):\n            if val.dtype is numpy.dtype('float32'):\n                v = val\n            else:\n                v = val.astype(numpy.float32)\n            if not v.flags['F_CONTIGUOUS']:\n                v = numpy.asfortranarray(v)\n            try_calling(pyreg.cReg_NiftiImageData_fill_arr(\n                self.handle, v.ctypes.data))\n        elif isinstance(val, float):\n            try_calling(pyreg.cReg_NiftiImageData_fill(self.handle, val))\n        elif isinstance(val, int):\n            try_calling(pyreg.cReg_NiftiImageData_fill(\n                self.handle, float(val)))\n        else:\n            raise error(\"\"\"wrong fill value. Should be numpy.ndarray,\n                        float or int\"\"\")\n\n    def deep_copy(self):\n        \"\"\"Deep copy image.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if self.name == 'NiftiImageData':\n            image = NiftiImageData()\n        elif self.name == 'NiftiImageData3D':\n            image = NiftiImageData3D()\n        elif self.name == 'NiftiImageData3DTensor':\n            image = NiftiImageData3DTensor()\n        elif self.name == 'NiftiImageData3DDeformation':\n            image = NiftiImageData3DDeformation()\n        elif self.name == 'NiftiImageData3DDisplacement':\n            image = NiftiImageData3DDisplacement()\n        try_calling(pyreg.cReg_NiftiImageData_deep_copy(\n            image.handle, self.handle))\n        return image\n\n    def allocate(self, value=0, **kwargs):\n        \"\"\"Alias to get_uniform_copy for CIL/SIRF compatibility.\"\"\"\n        if value in ['random', 'random_int']:\n            out = self.deep_copy()\n            shape = out.as_array().shape\n            seed = kwargs.get('seed', None)\n            if seed is not None:\n                numpy.random.seed(seed)\n            if value == 'random':\n                out.fill(numpy.random.random_sample(shape))\n            elif value == 'random_int':\n                max_value = kwargs.get('max_value', 100)\n                out.fill(numpy.random.randint(max_value, size=shape))\n        else:\n            out = self.deep_copy()\n            out *= 0\n            out.fill(value * numpy.ones_like(out.as_array()))\n        return out\n\n    def as_array(self):\n        \"\"\"Get data as numpy array.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        dim = self.get_dimensions()\n        dim = dim[1:dim[0]+1]\n        array = numpy.ndarray(dim, dtype=numpy.float32, order='F')\n        try_calling(pyreg.cReg_NiftiImageData_as_array(\n            self.handle, array.ctypes.data))\n        return numpy.ascontiguousarray(array)\n\n    def get_original_datatype(self):\n        \"\"\"Get original image datatype.\n\n        (internally everything is converted to float).\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        handle = pyreg.cReg_NiftiImageData_get_original_datatype(self.handle)\n        check_status(handle)\n        datatype = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return datatype\n\n    def crop(self, min_, max_):\n        \"\"\"Crop image.\n\n        Give minimum and maximum indices.\n        Min and max indicies can be anywhere between\n        (x,y,z) and (x,y,z,t,u,v,w).\n        Use values of -1 for no change.\n        \"\"\"\n        if len(min_) < 3 or len(min_) > 7:\n            raise AssertionError(\"\"\"Min bounds should be at least (x,y,z),\n                                 and up to (x,y,z,t,u,v,w)\"\"\")\n        if len(max_) < 3 or len(max_) > 7:\n            raise AssertionError(\"\"\"Max bounds should be at least (x,y,z),\n                                 and up to (x,y,z,t,u,v,w)\"\"\")\n        # Fill in any missing indices with -1's\n        min_.extend([-1] * (7-len(min_)))\n        max_.extend([-1] * (7-len(max_)))\n        min_np = numpy.array(min_, dtype=cpp_int_dtype())\n        max_np = numpy.array(max_, dtype=cpp_int_dtype())\n        try_calling(pyreg.cReg_NiftiImageData_crop(\n            self.handle, min_np.ctypes.data, max_np.ctypes.data))\n\n    def pad(self, min_, max_, val=0):\n        \"\"\"Pad image.\n\n        Give minimum and maximum indices.\n        Min and max indicies can be anywhere between\n        (x,y,z) and (x,y,z,t,u,v,w).\n        Use values of -1 for no change.\n        \"\"\"\n        if len(min_) < 3 or len(min_) > 7:\n            raise AssertionError(\"\"\"Min bounds should be at least (x,y,z),\n                                 and up to (x,y,z,t,u,v,w)\"\"\")\n        if len(max_) < 3 or len(max_) > 7:\n            raise AssertionError(\"\"\"Max bounds should be at least (x,y,z),\n                                 and up to (x,y,z,t,u,v,w)\"\"\")\n        # Fill in any missing indices with -1's\n        min_.extend([-1] * (7-len(min_)))\n        max_.extend([-1] * (7-len(max_)))\n        min_np = numpy.array(min_, dtype=cpp_int_dtype())\n        max_np = numpy.array(max_, dtype=cpp_int_dtype())\n        try_calling(pyreg.cReg_NiftiImageData_pad(\n            self.handle, min_np.ctypes.data, max_np.ctypes.data, float(val)))\n\n    def print_header(self):\n        \"\"\"Print nifti header metadata.\"\"\"\n        print(self.get_header())\n\n    def get_header(self):\n        \"\"\"Print nifti header metadata.\"\"\"\n        vec = SIRF.DataHandleVector()\n        vec.push_back(self.handle)\n#        try_calling(pyreg.cReg_NiftiImageData_print_headers(vec.handle))\n        handle = pyreg.cReg_NiftiImageData_get_headers(vec.handle)\n        check_status(handle)\n        s = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return s\n\n    def same_object(self):\n        \"\"\"See DataContainer method.\"\"\"\n        obj = ImageData()\n        if obj.handle is not None:\n            pyiutil.deleteDataHandle(obj.handle)\n            obj.handle = None\n        return obj\n        #return NiftiImageData()\n\n    def set_voxel_spacing(self, spacing, interpolation_order):\n        \"\"\"Set the voxel spacing.\n\n        Requires resampling image,\n        and so interpolation order is required.\n        As per NiftyReg, interpolation_order can be either 0, 1 or 3\n        meaning nearest neighbor, linear or cubic spline interpolation.\n        \"\"\"\n        if len(spacing) != 3:\n            raise AssertionError(\"New spacing should be array of 3 numbers.\")\n        try_calling(pyreg.cReg_NiftiImageData_set_voxel_spacing(\n            self.handle, float(spacing[0]), float(spacing[1]),\n            float(spacing[2]), int(interpolation_order)))\n\n    def get_contains_nans(self):\n        \"\"\"Return true if image contains any voxels with NaNs.\"\"\"\n        return parms.bool_par(self.handle, 'NiftiImageData', 'contains_nans')\n\n    def normalise_zero_and_one(self):\n        \"\"\"Normalise image between 0 and 1.\"\"\"\n        try_calling(pyreg.cReg_NiftiImageData_normalise_zero_and_one(\n            self.handle))\n        check_status(self.handle)\n\n    def standardise(self):\n        \"\"\"Standardise (subtract mean and divide by standard deviation).\"\"\"\n        try_calling(pyreg.cReg_NiftiImageData_standardise(self.handle))\n        check_status(self.handle)\n\n    def get_inner_product(self, other):\n        \"\"\"Get inner product between two images. Must be same size.\"\"\"\n        if not isinstance(other, NiftiImageData):\n            raise AssertionError()\n        handle = pyreg.cReg_NiftiImageData_get_inner_product(\n            self.handle, other.handle)\n        check_status(handle)\n        inner_product = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return inner_product\n\n    def kernel_convolution(self, sigma, convolution_type=2):\n        \"\"\"Kernel convolution.\n\n        convolution_type:\n            - MEAN_KERNEL         = 0\n            - LINEAR_KERNEL       = 1\n            - GAUSSIAN_KERNEL     = 2\n            - CUBIC_SPLINE_KERNEL = 3\n        \"\"\"\n        try_calling(pyreg.cReg_NiftiImageData_kernel_convolution(\n            self.handle, float(sigma), int(convolution_type)))\n\n    @staticmethod\n    def print_headers(to_print):\n        \"\"\"Print nifti header metadata of one or multiple nifti images.\"\"\"\n        print(NiftiImageData.get_headers(to_print))\n\n    @staticmethod\n    def get_headers(to_print):\n        if not all(isinstance(n, NiftiImageData) for n in to_print):\n            raise AssertionError()\n        vec = SIRF.DataHandleVector()\n        for n in to_print:\n            vec.push_back(n.handle)\n#        try_calling(pyreg.cReg_NiftiImageData_print_headers(vec.handle))\n        handle = pyreg.cReg_NiftiImageData_get_headers(vec.handle)\n        check_status(handle)\n        s = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return s\n\n    @staticmethod\n    def construct_from_complex_image(complex_im):\n        \"\"\"Construct two NiftiImageData from a complex image.\"\"\"\n        if not isinstance(complex_im, SIRF.ImageData):\n            raise AssertionError()\n        im_real = NiftiImageData()\n        im_imag = NiftiImageData()\n        im_real.handle = \\\n            pyreg.cReg_NiftiImageData_from_complex_ImageData_real_component(\n                complex_im.handle)\n        im_imag.handle = \\\n            pyreg.cReg_NiftiImageData_from_complex_ImageData_imag_component(\n                complex_im.handle)\n        return [im_real, im_imag]\n\n    @staticmethod\n    def are_equal_to_given_accuracy(im1, im2, accuracy):\n        \"\"\"Check if two images match to a given accuracy.\"\"\"\n        if not isinstance(im1, NiftiImageData) or not \\\n                isinstance(im2, NiftiImageData):\n            raise AssertionError()\n        if im1.handle is None or im2.handle is None:\n            error('Cannot compare images as at least one is uninitialised')\n        h = pyreg.cReg_NiftiImageData_are_equal_to_given_accuracy(\n            im1.handle, im2.handle, float(accuracy))\n        check_status(h, inspect.stack()[1])\n        value = pyiutil.intDataFromHandle(h)\n        pyiutil.deleteDataHandle(h)\n        return value\n\n    @property\n    def shape(self):\n        return self.dimensions()",
  "class NiftiImageData3D(NiftiImageData):\n    \"\"\"Class for 3D nifti image data.\"\"\"\n\n    def __init__(self, src=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'NiftiImageData3D'\n        if src is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src)\n        elif isinstance(src, SIRF.ImageData):\n            # src is ImageData\n            self.handle = pyreg.cReg_NiftiImageData_from_SIRFImageData(\n                src.handle, 1)\n        else:\n            raise error('Wrong source in NiftiImageData3D constructor')\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "class ImageData(NiftiImageData3D):\n    \"\"\"Alias class for nifti image data.\"\"\"",
  "class NiftiImageData3DTensor(NiftiImageData):\n    \"\"\"Class for 3D tensor nifti image data.\"\"\"\n\n    def __init__(self, src1=None, src2=None, src3=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'NiftiImageData3DTensor'\n        if src1 is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src1, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src1)\n        elif isinstance(src1, NiftiImageData3D) and \\\n            isinstance(src2, NiftiImageData3D) and \\\n                isinstance(src3, NiftiImageData3D):\n            self.handle = pyreg.\\\n                cReg_NiftiImageData3DTensor_construct_from_3_components(\n                    self.name, src1.handle, src2.handle, src3.handle)\n        else:\n            raise error('Wrong source in NiftiImageData3DTensor constructor')\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def write_split_xyz_components(self, filename, datatype=-1):\n        \"\"\"Save to file.\n\n        See nifti1.h for datatypes\n        (e.g., float (NIFTI_TYPE_FLOAT32) = 16).\n        Image's original datatpye is used by default.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if not isinstance(filename, str):\n            raise AssertionError()\n        try_calling(pyreg.\n                    cReg_NiftiImageData3DTensor_write_split_xyz_components(\n                        self.handle, filename, datatype))\n\n    def create_from_3D_image(self, src):\n        \"\"\"Create tensor/deformation/displacement field from 3D image.\"\"\"\n        if not isinstance(src, NiftiImageData3D):\n            raise AssertionError()\n        if src.handle is None:\n            raise AssertionError()\n        try_calling(pyreg.cReg_NiftiImageData3DTensor_create_from_3D_image(\n            self.handle, src.handle))\n        check_status(self.handle)\n\n    def flip_component(self, dim):\n        \"\"\"Flip component of nu.\"\"\"\n        if 0 < dim or dim > 2:\n            raise AssertionError(\n                \"Dimension to flip should be between 0 and 2.\")\n        try_calling(pyreg.cReg_NiftiImageData3DTensor_flip_component(\n            self.handle, dim))\n        check_status(self.handle)",
  "class NiftiImageData3DDisplacement(NiftiImageData3DTensor, _Transformation):\n    \"\"\"Class for 3D displacement nifti image data.\n\n    Displacement fields (as opposed to Deformation fields) describe the change\n    (in real world units) of the pixel locations between images.\n    A displacement field of an identity transformation will be of zero value.\n    \"\"\"\n\n    def __init__(self, src1=None, src2=None, src3=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'NiftiImageData3DDisplacement'\n        if src1 is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src1, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src1)\n        elif isinstance(src1, NiftiImageData3D) and \\\n                isinstance(src2, NiftiImageData3D) and \\\n                isinstance(src3, NiftiImageData3D):\n            self.handle = pyreg.\\\n                cReg_NiftiImageData3DTensor_construct_from_3_components(\n                    self.name, src1.handle, src2.handle, src3.handle)\n        elif isinstance(src1, NiftiImageData3DDeformation):\n            self.handle = pyreg.\\\n                cReg_NiftiImageData3DDisplacement_create_from_def(src1.handle)\n        else:\n            raise error(\n                    'Wrong source in NiftiImageData3DDisplacement constructor')\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "class NiftiImageData3DDeformation(NiftiImageData3DTensor, _Transformation):\n    \"\"\"Class for 3D deformation nifti image data.\n\n    Deformation fields (as opposed to Displacement fields) describe the\n    absolute position (in real world units) of the pixel locations on the\n    reference image.\n    A deformation field of an identity transformation will contain the\n    location of each of the pixels centroids in the world coordinates.\n    \"\"\"\n\n    def __init__(self, src1=None, src2=None, src3=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'NiftiImageData3DDeformation'\n        if src1 is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src1, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src1)\n        elif isinstance(src1, NiftiImageData3D) and \\\n                isinstance(src2, NiftiImageData3D) and \\\n                isinstance(src3, NiftiImageData3D):\n            self.handle = pyreg.\\\n                cReg_NiftiImageData3DTensor_construct_from_3_components(\n                    self.name, src1.handle, src2.handle, src3.handle)\n        elif isinstance(src1, NiftiImageData3DDisplacement):\n            self.handle = pyreg.\\\n                cReg_NiftiImageData3DDeformation_create_from_disp(src1.handle)\n        else:\n            raise error(\n                'Wrong source in NiftiImageData3DDeformation constructor')\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def get_inverse(self, floating=None):\n        \"\"\"\n        Get inverse (potentially based on another image).\n\n        Why would you want to base it on another image? Well, we might have a\n        deformation that takes us from image A to B. We'll probably want the\n        inverse to take us from image B back to A. In this case, use\n        get_inverse(A). This is because the the deformation field is defined\n        for the reference image. In the second case, A is the reference,\n        and B is the floating image.\n        \"\"\"\n        if floating is None:\n            floating = self\n        if not isinstance(floating, SIRF.ImageData):\n            raise AssertionError()\n        if self is None:\n            raise AssertionError()\n        output = NiftiImageData3DDeformation()\n        output.handle = pyreg.cReg_NiftiImageData3DDeformation_get_inverse(\n            self.handle, floating.handle)\n        check_status(output.handle)\n        return output\n\n    @staticmethod\n    def compose_single_deformation(trans, ref):\n        \"\"\"Compose transformations into single deformation.\"\"\"\n        if not isinstance(ref, NiftiImageData3D):\n            raise AssertionError()\n        if not all(isinstance(n, _Transformation) for n in trans):\n            raise AssertionError()\n        if len(trans) == 1:\n            return trans[0].get_as_deformation_field(ref)\n        # This is ugly. Store each type in a single string (need to do this\n        # because I can't get virtual methods to work for multiple inheritance\n        # (deformation/displacement are both nifti images and transformations).\n        types = ''\n        for n in trans:\n            if isinstance(n, AffineTransformation):\n                types += '1'\n            elif isinstance(n, NiftiImageData3DDisplacement):\n                types += '2'\n            elif isinstance(n, NiftiImageData3DDeformation):\n                types += '3'\n        # Convert transformations into SIRF vector\n        vec = SIRF.DataHandleVector()\n        for n in trans:\n            vec.push_back(n.handle)\n        z = NiftiImageData3DDeformation()\n        z.handle = pyreg.\\\n            cReg_NiftiImageData3DDeformation_compose_single_deformation(\n                ref.handle, types, vec.handle)\n        check_status(z.handle)\n        return z",
  "class _Registration(ABC):\n    \"\"\"Abstract base class for registration.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'Registration'\n        self.reference_image = None\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_reference_image(self, reference_image):\n        \"\"\"Set the reference image.\"\"\"\n        if not isinstance(reference_image, SIRF.ImageData):\n            raise AssertionError()\n        self.reference_image = reference_image\n        parms.set_parameter(self.handle, 'Registration', 'reference_image',\n                            reference_image.handle)\n\n    def set_floating_image(self, floating_image):\n        \"\"\"Set the floating image. Will clear any previous floating images.\"\"\"\n        if not isinstance(floating_image, SIRF.ImageData):\n            raise AssertionError()\n        parms.set_parameter(self.handle, 'Registration', 'floating_image',\n                            floating_image.handle)\n\n    def add_floating_image(self, floating_image):\n        \"\"\"Add floating image.\"\"\"\n        if not isinstance(floating_image, SIRF.ImageData):\n            raise AssertionError()\n        try_calling(pyreg.cReg_Registration_add_floating(\n            self.handle, floating_image.handle))\n\n    def set_reference_image_filename(self, filename):\n        \"\"\"Set reference image filename.\"\"\"\n        if not isinstance(filename, str):\n            raise AssertionError()\n        self.reference_image = NiftiImageData(filename)\n        try_calling(pyreg.cReg_Registration_set_reference_image_filename(\n            self.handle, filename))\n\n    def set_floating_image_filename(self, filename):\n        \"\"\"Set floating image filename.\"\"\"\n        if not isinstance(filename, str):\n            raise AssertionError()\n        try_calling(pyreg.cReg_Registration_set_floating_image_filename(\n            self.handle, filename))\n\n    def add_floating_image_filename(self, filename):\n        \"\"\"Add floating image filename.\"\"\"\n        if not isinstance(filename, str):\n            raise AssertionError()\n        try_calling(pyreg.cReg_Registration_add_floating_image_filename(\n            self.handle, filename))\n\n    def clear_floating_images(self):\n        \"\"\"Clear floating images.\"\"\"\n        try_calling(pyreg.cReg_Registration_clear_floatings(self.handle))\n\n    def get_output(self, idx=0):\n        \"\"\"Get the registered image.\"\"\"\n        output = self.reference_image.same_object()\n        output.handle = pyreg.cReg_Registration_get_output(\n            self.handle, int(idx))\n        check_status(output.handle)\n        return output\n\n    def process(self):\n        \"\"\"Run the registration.\"\"\"\n        try_calling(pyreg.cReg_Registration_process(self.handle))\n\n    def get_deformation_field_forward(self, idx=0):\n        \"\"\"Get the forward deformation field image.\"\"\"\n        output = NiftiImageData3DDeformation()\n        output.handle = pyreg.\\\n            cReg_Registration_get_deformation_displacement_image(\n                self.handle, 'forward_deformation', int(idx))\n        check_status(output.handle)\n        return output\n\n    def get_deformation_field_inverse(self, idx=0):\n        \"\"\"Get the inverse deformation field image.\"\"\"\n        output = NiftiImageData3DDeformation()\n        output.handle = pyreg.\\\n            cReg_Registration_get_deformation_displacement_image(\n                self.handle, 'inverse_deformation', int(idx))\n        check_status(output.handle)\n        return output\n\n    def get_displacement_field_forward(self, idx=0):\n        \"\"\"Get the forward displacement field image.\"\"\"\n        output = NiftiImageData3DDisplacement()\n        output.handle = pyreg.\\\n            cReg_Registration_get_deformation_displacement_image(\n                self.handle, 'forward_displacement', int(idx))\n        check_status(output.handle)\n        return output\n\n    def get_displacement_field_inverse(self, idx=0):\n        \"\"\"Get the inverse displacement field image.\"\"\"\n        output = NiftiImageData3DDisplacement()\n        output.handle = pyreg.\\\n            cReg_Registration_get_deformation_displacement_image(\n                self.handle, 'inverse_displacement', int(idx))\n        check_status(output.handle)\n        return output",
  "class _NiftyRegistration(_Registration):\n    \"\"\"Abstract base class for NiftyReg registration.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        super(_NiftyRegistration, self).__init__()\n        self.name = 'NiftyRegistration'\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_parameter_file(self, filename):\n        \"\"\"Set the parameter filename.\"\"\"\n        parms.set_char_par(self.handle, 'NiftyRegistration', 'parameter_file',\n                           filename)\n\n    def set_reference_mask(self, reference_mask):\n        \"\"\"Set the reference mask.\"\"\"\n        if not isinstance(reference_mask, SIRF.ImageData):\n            raise AssertionError()\n        parms.set_parameter(self.handle, 'NiftyRegistration', 'reference_mask',\n                            reference_mask.handle)\n\n    def set_floating_mask(self, floating_mask):\n        \"\"\"Set the floating mask.\"\"\"\n        if not isinstance(floating_mask, SIRF.ImageData):\n            raise AssertionError()\n        parms.set_parameter(self.handle, 'NiftyRegistration', 'floating_mask',\n                            floating_mask.handle)\n\n    def set_parameter(self, par, arg1=\"\", arg2=\"\"):\n        \"\"\"Set string parameter.\n\n        Check if any set methods match the method\n        given by par. If so, set the value given by arg. Convert to float/int\n        etc., as necessary. Up to 2 arguments, leave blank if unneeded.\n        These are applied after parsing the parameter file.\n        \"\"\"\n        try_calling(pyreg.cReg_NiftyRegistration_set_parameter(\n            self.handle, par, arg1, arg2))",
  "class NiftyAladinSym(_NiftyRegistration):\n    \"\"\"Registration using NiftyReg aladin.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        super(NiftyAladinSym, self).__init__()\n        self.name = 'NiftyAladinSym'\n        self.handle = pyreg.cReg_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def get_transformation_matrix_forward(self):\n        \"\"\"Get forward transformation matrix.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        tm = AffineTransformation()\n        tm.handle = pyreg.cReg_NiftyAladin_get_TM(self.handle, 'forward')\n        return tm\n\n    def get_transformation_matrix_inverse(self):\n        \"\"\"Get inverse transformation matrix.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        tm = AffineTransformation()\n        tm.handle = pyreg.cReg_NiftyAladin_get_TM(self.handle, 'inverse')\n        return tm\n\n    @staticmethod\n    def print_all_wrapped_methods():\n        \"\"\"Print all wrapped methods.\"\"\"\n        print(\"\"\"In C++, this class is templated. \\\"dataType\\\"\n              corresponds to \\\"float\\\" for Matlab and python.\"\"\")\n        try_calling(pyreg.cReg_NiftyRegistration_print_all_wrapped_methods(\n            'NiftyAladinSym'))",
  "class NiftyF3dSym(_NiftyRegistration):\n    \"\"\"Registration using NiftyReg f3d.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        super(NiftyF3dSym, self).__init__()\n        self.name = 'NiftyF3dSym'\n        self.handle = pyreg.cReg_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_floating_time_point(self, floating_time_point):\n        \"\"\"Set floating time point.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'floating_time_point',\n                          floating_time_point)\n\n    def set_reference_time_point(self, reference_time_point):\n        \"\"\"Set reference time point.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'reference_time_point',\n                          reference_time_point)\n\n    def set_initial_affine_transformation(self, src):\n        \"\"\"Set initial affine transformation.\"\"\"\n        if not isinstance(src, AffineTransformation):\n            raise AssertionError()\n        parms.set_parameter(self.handle, self.name,\n                            'initial_affine_transformation', src.handle)\n\n    @staticmethod\n    def print_all_wrapped_methods():\n        \"\"\"Print all wrapped methods.\"\"\"\n        print(\"\"\"In C++, this class is templated. \\\"dataType\\\"\n              corresponds to \\\"float\\\" for Matlab and python.\"\"\")\n        try_calling(pyreg.cReg_NiftyRegistration_print_all_wrapped_methods(\n            'NiftyF3dSym'))",
  "class NiftyResampler(object):\n    \"\"\"Resample using NiftyReg.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.name = 'NiftyResampler'\n        self.handle = pyreg.cReg_newObject(self.name)\n        self.reference_image = None\n        self.floating_image = None\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_reference_image(self, reference_image):\n        \"\"\"Set reference image.\n\n        This is the image that would be the reference\n        if you were doing a forward transformation.\n        \"\"\"\n        if not isinstance(reference_image, SIRF.ImageData):\n            raise AssertionError()\n        self.reference_image = reference_image\n        parms.set_parameter(\n            self.handle, self.name, 'reference_image', reference_image.handle)\n\n    def set_floating_image(self, floating_image):\n        \"\"\"Set floating image.\n\n        This is the image that would be the floating if\n        you were doing a forward transformation.\n        \"\"\"\n        if not isinstance(floating_image, SIRF.ImageData):\n            raise AssertionError()\n        self.floating_image = floating_image\n        parms.set_parameter(\n            self.handle, self.name, 'floating_image', floating_image.handle)\n\n    def add_transformation(self, src):\n        \"\"\"Add transformation.\"\"\"\n        if isinstance(src, AffineTransformation):\n            try_calling(pyreg.cReg_NiftyResampler_add_transformation(\n                self.handle, src.handle, 'affine'))\n        elif isinstance(src, NiftiImageData3DDisplacement):\n            try_calling(pyreg.cReg_NiftyResampler_add_transformation(\n                self.handle, src.handle, 'displacement'))\n        elif isinstance(src, NiftiImageData3DDeformation):\n            try_calling(pyreg.cReg_NiftyResampler_add_transformation(\n                self.handle, src.handle, 'deformation'))\n        else:\n            raise AssertionError()\n\n    def clear_transformations(self):\n        \"\"\"Clear transformations.\"\"\"\n        if self.handle is not None:\n            try_calling(pyreg.cReg_NiftyResampler_clear_transformations(\n                self.handle))\n\n    def set_interpolation_type(self, interp_type):\n        \"\"\"Set interpolation type.\n\n        0=nearest neighbour, 1=linear, 3=cubic, 4=sinc.\n        \"\"\"\n        if not isinstance(interp_type, int):\n            raise AssertionError()\n        parms.set_int_par(self.handle, self.name,\n                          'interpolation_type', interp_type)\n\n    def set_interpolation_type_to_nearest_neighbour(self):\n        \"\"\"Set interpolation type to nearest neighbour.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'interpolation_type', 0)\n\n    def set_interpolation_type_to_linear(self):\n        \"\"\"Set interpolation type to linear.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'interpolation_type', 1)\n\n    def set_interpolation_type_to_cubic_spline(self):\n        \"\"\"Set interpolation type to cubic spline.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'interpolation_type', 3)\n\n    def set_interpolation_type_to_sinc(self):\n        \"\"\"Set interpolation type to sinc.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'interpolation_type', 4)\n\n    def set_padding_value(self, val):\n        \"\"\"Set padding value.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'padding', val)\n\n    def norm(self, num_iter=2, verb=0):\n        '''Computes the norm of the forward projection operator.\n        '''\n        handle = pyreg.cReg_NiftyResampler_norm(self.handle, num_iter, verb)\n        check_status(handle)\n        r = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return r;\n\n    def process(self):\n        \"\"\"Process.\n\n        Equivalent of calling forward(floating_image).\n        Use get_output to get resampled image.\n        \"\"\"\n        try_calling(pyreg.cReg_NiftyResampler_process(self.handle))\n\n    def get_output(self):\n        \"\"\"Get output.\"\"\"\n        image = self.reference_image.same_object()\n        image.handle = parms.parameter_handle(self.handle, self.name, 'output')\n        check_status(image.handle)\n        return image\n\n    def forward(self, x, out=None):\n        \"\"\"\n        Forward transformation.\n\n        Usage:\n            output = forward(x), OR\n            forward(x=input,out=output)\n        \"\"\"\n        if out is None:\n            if self.reference_image is None:\n                raise RuntimeError('reference_image needs to be set first, or you should specify an out argument')\n            out = self.reference_image.clone()\n        # Check image validity\n        if not isinstance(x, SIRF.ImageData):\n            raise TypeError('{} expecting input as SIRF.ImageData, got {}'.\n                            format(self.__class__.__name__, type(x)))\n\n        if not isinstance(out, SIRF.ImageData):\n            raise TypeError('{} expecting output as SIRF.ImageData, got {}'.\n                            format(self.__class__.__name__, type(out)))\n        # Forward\n        try_calling(pyreg.cReg_NiftyResampler_forward(\n            out.handle, x.handle, self.handle))\n        return out\n\n    def direct(self, x, out=None):\n        \"\"\"Alias to forward.\"\"\"\n        return self.forward(x=x, out=out)\n\n    def adjoint(self, x, out=None):\n        \"\"\"\n        Adjoint transformation.\n\n        Usage:\n            output = adjoint(x), OR\n            adjoint(x=input,out=output)\n        \"\"\"\n        if out is None:\n            out = self.floating_image.clone()\n        if not isinstance(x, SIRF.ImageData):\n            raise TypeError(\"\"\"{} expecting input as subclass of\n                            SIRF.ImageData, got {}\"\"\".format(\n                                self.__class__.__name__, type(x)))\n\n        if not isinstance(out, SIRF.ImageData):\n            raise TypeError('{} expecting output as SIRF.ImageData, got {}'.\n                            format(self.__class__.__name__, type(out)))\n        # Forward\n        try_calling(pyreg.cReg_NiftyResampler_adjoint(\n            out.handle, x.handle, self.handle))\n        return out\n\n    def backward(self, x, out=None):\n        \"\"\"\n        Backward transformation.\n\n        Alias of adjoint to align terms with\n        AcquisitionModel's forward and backward.\n        \"\"\"\n        return self.adjoint(x=x, out=out)\n\n    def is_linear(self):\n        \"\"\"Return whether the transformation is linear.\"\"\"\n        return True\n\n    def domain_geometry(self):\n        \"\"\"Get domain geometry.\"\"\"\n        return self.floating_image\n\n    def range_geometry(self):\n        \"\"\"Get range geometry.\"\"\"\n        return self.reference_image",
  "class ImageWeightedMean(object):\n    \"\"\"Class for performing weighted mean of images.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.name = 'ImageWeightedMean'\n        self.handle = pyreg.cReg_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def add_image(self, image, weight):\n        \"\"\"Add an image and its corresponding weight.\n\n        Image should be via filename or NiftiImageData.\n        \"\"\"\n        if isinstance(image, NiftiImageData):\n            try_calling(pyreg.cReg_ImageWeightedMean_add_image(\n                self.handle, image.handle, weight))\n        elif isinstance(image, str):\n            try_calling(pyreg.cReg_ImageWeightedMean_add_image_filename(\n                self.handle, image, weight))\n        else:\n            raise error(\"\"\"sirf.Reg.ImageWeightedMean.add_image: image must be\n                        NiftiImageData or filename.\"\"\")\n\n    def process(self):\n        \"\"\"Process.\"\"\"\n        try_calling(pyreg.cReg_ImageWeightedMean_process(self.handle))\n\n    def get_output(self):\n        \"\"\"Get output.\"\"\"\n        image = NiftiImageData()\n        image.handle = parms.parameter_handle(self.handle, self.name, 'output')\n        check_status(image.handle)\n        return image",
  "class AffineTransformation(_Transformation):\n    \"\"\"Class for affine transformations.\"\"\"\n\n    def __init__(self, src1=None, src2=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'AffineTransformation'\n        if src1 is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src1, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src1)\n        elif isinstance(src1, numpy.ndarray) and src2 is None:\n            src1 = format_numpy_array_for_setter(src1)\n            if src1.shape != (4, 4):\n                raise AssertionError()\n            # Need to transpose relative to MATLAB\n            trans = numpy.zeros((4, 4), dtype=numpy.float32)\n            for i in range(4):\n                for j in range(4):\n                    trans[i, j] = src1[j, i]\n                self.handle = pyreg.\\\n                    cReg_AffineTransformation_construct_from_TM(\n                        trans.ctypes.data)\n        elif isinstance(src1, numpy.ndarray) and src2 is not None and \\\n                isinstance(src2, Quaternion):\n            src1 = format_numpy_array_for_setter(src1)\n            self.handle = pyreg.\\\n                cReg_AffineTransformation_construct_from_trans_and_quaternion(\n                    src1.ctypes.data, src2.handle)\n        elif isinstance(src1, numpy.ndarray) and \\\n                isinstance(src2, numpy.ndarray):\n            src1 = format_numpy_array_for_setter(src1)\n            src2 = format_numpy_array_for_setter(src2)\n            self.handle = pyreg.\\\n                cReg_AffineTransformation_construct_from_trans_and_euler(\n                    src1.ctypes.data, src2.ctypes.data)\n        else:\n            raise error(\"\"\"AffineTransformation accepts no args, filename,\n                        4x4 array or translation with quaternion.\"\"\")\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def __eq__(self, other):\n        \"\"\"Overload comparison operator.\"\"\"\n        if not isinstance(other, AffineTransformation):\n            raise AssertionError()\n        h = pyreg.cReg_AffineTransformation_equal(self.handle, other.handle)\n        check_status(h, inspect.stack()[1])\n        value = pyiutil.intDataFromHandle(h)\n        pyiutil.deleteDataHandle(h)\n        return value\n\n    def __ne__(self, other):\n        \"\"\"Overload comparison operator.\"\"\"\n        return not self == other\n\n    def __mul__(self, other):\n        \"\"\"Overload multiplication operator.\"\"\"\n        if not isinstance(other, AffineTransformation):\n            raise AssertionError()\n        mat = AffineTransformation()\n        mat.handle = pyreg.cReg_AffineTransformation_mul(\n            self.handle, other.handle)\n        check_status(mat.handle)\n        return mat\n\n    def deep_copy(self):\n        \"\"\"Deep copy.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        mat = AffineTransformation()\n        mat.handle = pyreg.cReg_AffineTransformation_deep_copy(self.handle)\n        check_status(mat.handle)\n        return mat\n\n    def write(self, filename):\n        \"\"\"Save to file.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        try_calling(pyreg.cReg_AffineTransformation_write(\n            self.handle, filename))\n\n    def get_determinant(self):\n        \"\"\"Get determinant.\"\"\"\n        return parms.float_par(self.handle, self.name, 'determinant')\n\n    def as_array(self):\n        \"\"\"Get forward transformation matrix.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        tm = numpy.ndarray((4, 4), dtype=numpy.float32)\n        try_calling(pyreg.cReg_AffineTransformation_as_array(\n            self.handle, tm.ctypes.data))\n        return tm\n\n    def get_inverse(self):\n        \"\"\"Get inverse matrix.\"\"\"\n        tm = AffineTransformation()\n        tm.handle = pyreg.cReg_AffineTransformation_get_inverse(self.handle)\n        check_status(tm.handle)\n        return tm\n\n    def get_Euler_angles(self):\n        \"\"\"Get Euler angles of transformation matrix (XYZ).\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        eul = numpy.ndarray(3, dtype=numpy.float32)\n        try_calling(pyreg.cReg_AffineTransformation_get_Euler_angles(\n            self.handle, eul.ctypes.data))\n        return eul\n\n    def get_quaternion(self):\n        \"\"\"Get quaternion.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        quat_zeros = numpy.array([0., 0., 0., 0.], dtype=numpy.float32)\n        quat = Quaternion(quat_zeros)\n        quat.handle = pyreg.cReg_AffineTransformation_get_quaternion(\n            self.handle)\n        check_status(quat.handle)\n        return quat\n\n    @staticmethod\n    def get_identity():\n        \"\"\"Get identity matrix.\"\"\"\n        mat = AffineTransformation()\n        mat.handle = pyreg.cReg_AffineTransformation_get_identity()\n        return mat\n\n    @staticmethod\n    def get_average(to_average):\n        \"\"\"Get average of transformations.\"\"\"\n        if not all(isinstance(n, AffineTransformation) for n in to_average):\n            raise AssertionError(\"\"\"AffineTransformation:get_average() input\n                                 list should only contain\n                                 AffineTransformations.\"\"\")\n        tm = AffineTransformation()\n        vec = SIRF.DataHandleVector()\n        for n in to_average:\n            vec.push_back(n.handle)\n        tm.handle = pyreg.cReg_AffineTransformation_get_average(vec.handle)\n        check_status(tm.handle)\n        return tm",
  "class Quaternion(object):\n    \"\"\"Class for quaternions.\"\"\"\n\n    def __init__(self, src=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'Quaternion'\n        if isinstance(src, numpy.ndarray):\n            if src.size != 4:\n                raise AssertionError(\"\"\"Quaternion constructor from numpy\n                                     array is wrong size.\"\"\")\n            if src.dtype is not numpy.float32:\n                src = src.astype(numpy.float32)\n            self.handle = pyreg.cReg_Quaternion_construct_from_array(\n                src.ctypes.data)\n        elif isinstance(src, AffineTransformation):\n            self.handle = pyreg.\\\n                cReg_Quaternion_construct_from_AffineTransformation(src.handle)\n        else:\n            raise error('Wrong source in quaternion constructor')\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def as_array(self):\n        \"\"\"Get quaternion as array.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        arr = numpy.ndarray(4, dtype=numpy.float32)\n        try_calling(pyreg.cReg_Quaternion_as_array(\n            self.handle, arr.ctypes.data))\n        return arr\n\n    @staticmethod\n    def get_average(to_average):\n        \"\"\"Get average of quaternions.\"\"\"\n        if not all(isinstance(n, Quaternion) for n in to_average):\n            raise AssertionError()\n        quat_zeros = numpy.array([0., 0., 0., 0.], dtype=numpy.float32)\n        quat = Quaternion(quat_zeros)\n        if not all(isinstance(n, Quaternion) for n in to_average):\n            raise AssertionError()\n        vec = SIRF.DataHandleVector()\n        for n in to_average:\n            vec.push_back(n.handle)\n        quat.handle = pyreg.cReg_Quaternion_get_average(vec.handle)\n        return quat",
  "def __init__(self, info=None, warn='stdout', errr='stdout'):\n        \"\"\"Create MessageRedirector object.\n\n        This redirects Reg's ouput\n        produced by info(), warning() and error(0 functions to destinations\n        specified respectively by info, warn and err arguments.\n        The argument values other than None, stdout, stderr, cout and cerr\n        are interpreted as filenames.\n        None and empty string value suppresses printing.\n        \"\"\"\n        if info is None:\n            info = ''\n        if not isinstance(info, str):\n            raise error(\n                'wrong info argument for MessageRedirector constructor')\n        elif info in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.info = pyreg.newTextPrinter(info)\n            self.info_case = 0\n        else:\n            self.info = pyreg.newTextWriter(info)\n            self.info_case = 1\n        pyreg.openChannel(0, self.info)\n\n        if warn is None:\n            warn = ''\n        if not isinstance(warn, str):\n            raise error(\n                'wrong warn argument for MessageRedirector constructor')\n        elif warn in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.warn = pyreg.newTextPrinter(warn)\n            self.warn_case = 0\n        else:\n            self.warn = pyreg.newTextWriter(warn)\n            self.warn_case = 1\n        pyreg.openChannel(1, self.warn)\n\n        if errr is None:\n            errr = ''\n        if not isinstance(errr, str):\n            raise error(\n                'wrong errr argument for MessageRedirector constructor')\n        elif errr in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.errr = pyreg.newTextPrinter(errr)\n            self.errr_case = 0\n        else:\n            self.errr = pyreg.newTextWriter(errr)\n            self.errr_case = 1\n        pyreg.openChannel(2, self.errr)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.info_case == 0:\n            try_calling(pyreg.deleteTextPrinter(self.info))\n        else:\n            try_calling(pyreg.deleteTextWriter(self.info))\n        pyreg.closeChannel(0, self.info)\n        if self.warn_case == 0:\n            try_calling(pyreg.deleteTextPrinter(self.warn))\n        else:\n            try_calling(pyreg.deleteTextWriter(self.warn))\n        pyreg.closeChannel(1, self.warn)\n        if self.errr_case == 0:\n            try_calling(pyreg.deleteTextPrinter(self.errr))\n        else:\n            try_calling(pyreg.deleteTextWriter(self.errr))\n        pyreg.closeChannel(2, self.errr)",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'Transformation'",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def get_as_deformation_field(self, ref):\n        \"\"\"Get any type of transformation as a deformation field.\n\n        This is useful for joining them together. Require a reference\n        image for converting transformation matrices to deformations.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if not isinstance(ref, NiftiImageData3D):\n            raise AssertionError()\n        output = NiftiImageData3DDeformation()\n        output.handle = pyreg.cReg_Transformation_get_as_deformation_field(\n            self.handle, self.name, ref.handle)\n        check_status(output.handle)\n        return output",
  "def __init__(self, src=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'NiftiImageData'\n        if src is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src)\n        elif isinstance(src, SIRF.ImageData):\n            # src is ImageData\n            dim = src.dimensions()\n            self.handle = pyreg.cReg_NiftiImageData_from_SIRFImageData(\n                src.handle, int(dim[0] > 1))\n        else:\n            raise error('Wrong source in NiftiImageData constructor')\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def equal(self, other):\n        \"\"\"Overload comparison operator.\"\"\"\n        if not isinstance(other, NiftiImageData):\n            raise AssertionError()\n        if self.handle is None or other.handle is None:\n            error('Cannot compare images as at least one is uninitialised')\n        h = pyreg.cReg_NiftiImageData_equal(self.handle, other.handle)\n        check_status(h, inspect.stack()[1])\n        value = pyiutil.intDataFromHandle(h)\n        pyiutil.deleteDataHandle(h)\n        return value",
  "def __eq__(self, other):\n        \"\"\"Overload == operator.\"\"\"\n        try:\n            return self.equal(other)\n        except:\n            return super(NiftiImageData, self).equal(other)",
  "def __ne__(self, other):\n        \"\"\"Overload comparison operator.\"\"\"\n        return not self == other",
  "def write(self, filename, datatype=-1):\n        \"\"\"Save to file.\n\n        See nifti1.h for datatypes (e.g., float (NIFTI_TYPE_FLOAT32) = 16).\n        Image's original datatpye is used by default.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        try_calling(pyreg.cReg_NiftiImageData_write(self.handle, filename,\n                                                    datatype))",
  "def get_max(self):\n        \"\"\"Get max.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'max')",
  "def get_min(self):\n        \"\"\"Get min.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'min')",
  "def get_mean(self):\n        \"\"\"Get mean.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'mean')",
  "def get_variance(self):\n        \"\"\"Get variance.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'variance')",
  "def get_standard_deviation(self):\n        \"\"\"Get standard deviation.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'std')",
  "def get_sum(self):\n        \"\"\"Get sum.\"\"\"\n        return parms.float_par(self.handle, 'NiftiImageData', 'sum')",
  "def dimensions(self):\n        \"\"\"Return image dimensions as a tuple.\"\"\"\n        dim = self.get_dimensions()\n        return tuple(dim[1:1+dim[0]])",
  "def get_dimensions(self):\n        \"\"\"Get dimensions.\n\n        Returns nifti format.\n        i.e., dim[0]=ndims, dim[1]=nx, dim[2]=ny,...\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        dim = numpy.ndarray((8,), dtype=cpp_int_dtype())\n        try_calling(pyreg.cReg_NiftiImageData_get_dimensions(\n            self.handle, dim.ctypes.data))\n        return dim",
  "def get_voxel_sizes(self):\n        \"\"\"Get voxel sizes.\n\n        Returns nifti format.\n        i.e., dim[0]=?, dim[1]=dx, dim[2]=dy,...\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        out = numpy.ndarray((8,), dtype=numpy.float32)\n        try_calling(pyreg.cReg_NiftiImageData_get_voxel_sizes(\n            self.handle, out.ctypes.data))\n        return out",
  "def fill(self, val):\n        \"\"\"Fill image with single value or numpy array.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if isinstance(val, numpy.ndarray):\n            if val.dtype is numpy.dtype('float32'):\n                v = val\n            else:\n                v = val.astype(numpy.float32)\n            if not v.flags['F_CONTIGUOUS']:\n                v = numpy.asfortranarray(v)\n            try_calling(pyreg.cReg_NiftiImageData_fill_arr(\n                self.handle, v.ctypes.data))\n        elif isinstance(val, float):\n            try_calling(pyreg.cReg_NiftiImageData_fill(self.handle, val))\n        elif isinstance(val, int):\n            try_calling(pyreg.cReg_NiftiImageData_fill(\n                self.handle, float(val)))\n        else:\n            raise error(\"\"\"wrong fill value. Should be numpy.ndarray,\n                        float or int\"\"\")",
  "def deep_copy(self):\n        \"\"\"Deep copy image.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if self.name == 'NiftiImageData':\n            image = NiftiImageData()\n        elif self.name == 'NiftiImageData3D':\n            image = NiftiImageData3D()\n        elif self.name == 'NiftiImageData3DTensor':\n            image = NiftiImageData3DTensor()\n        elif self.name == 'NiftiImageData3DDeformation':\n            image = NiftiImageData3DDeformation()\n        elif self.name == 'NiftiImageData3DDisplacement':\n            image = NiftiImageData3DDisplacement()\n        try_calling(pyreg.cReg_NiftiImageData_deep_copy(\n            image.handle, self.handle))\n        return image",
  "def allocate(self, value=0, **kwargs):\n        \"\"\"Alias to get_uniform_copy for CIL/SIRF compatibility.\"\"\"\n        if value in ['random', 'random_int']:\n            out = self.deep_copy()\n            shape = out.as_array().shape\n            seed = kwargs.get('seed', None)\n            if seed is not None:\n                numpy.random.seed(seed)\n            if value == 'random':\n                out.fill(numpy.random.random_sample(shape))\n            elif value == 'random_int':\n                max_value = kwargs.get('max_value', 100)\n                out.fill(numpy.random.randint(max_value, size=shape))\n        else:\n            out = self.deep_copy()\n            out *= 0\n            out.fill(value * numpy.ones_like(out.as_array()))\n        return out",
  "def as_array(self):\n        \"\"\"Get data as numpy array.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        dim = self.get_dimensions()\n        dim = dim[1:dim[0]+1]\n        array = numpy.ndarray(dim, dtype=numpy.float32, order='F')\n        try_calling(pyreg.cReg_NiftiImageData_as_array(\n            self.handle, array.ctypes.data))\n        return numpy.ascontiguousarray(array)",
  "def get_original_datatype(self):\n        \"\"\"Get original image datatype.\n\n        (internally everything is converted to float).\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        handle = pyreg.cReg_NiftiImageData_get_original_datatype(self.handle)\n        check_status(handle)\n        datatype = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return datatype",
  "def crop(self, min_, max_):\n        \"\"\"Crop image.\n\n        Give minimum and maximum indices.\n        Min and max indicies can be anywhere between\n        (x,y,z) and (x,y,z,t,u,v,w).\n        Use values of -1 for no change.\n        \"\"\"\n        if len(min_) < 3 or len(min_) > 7:\n            raise AssertionError(\"\"\"Min bounds should be at least (x,y,z),\n                                 and up to (x,y,z,t,u,v,w)\"\"\")\n        if len(max_) < 3 or len(max_) > 7:\n            raise AssertionError(\"\"\"Max bounds should be at least (x,y,z),\n                                 and up to (x,y,z,t,u,v,w)\"\"\")\n        # Fill in any missing indices with -1's\n        min_.extend([-1] * (7-len(min_)))\n        max_.extend([-1] * (7-len(max_)))\n        min_np = numpy.array(min_, dtype=cpp_int_dtype())\n        max_np = numpy.array(max_, dtype=cpp_int_dtype())\n        try_calling(pyreg.cReg_NiftiImageData_crop(\n            self.handle, min_np.ctypes.data, max_np.ctypes.data))",
  "def pad(self, min_, max_, val=0):\n        \"\"\"Pad image.\n\n        Give minimum and maximum indices.\n        Min and max indicies can be anywhere between\n        (x,y,z) and (x,y,z,t,u,v,w).\n        Use values of -1 for no change.\n        \"\"\"\n        if len(min_) < 3 or len(min_) > 7:\n            raise AssertionError(\"\"\"Min bounds should be at least (x,y,z),\n                                 and up to (x,y,z,t,u,v,w)\"\"\")\n        if len(max_) < 3 or len(max_) > 7:\n            raise AssertionError(\"\"\"Max bounds should be at least (x,y,z),\n                                 and up to (x,y,z,t,u,v,w)\"\"\")\n        # Fill in any missing indices with -1's\n        min_.extend([-1] * (7-len(min_)))\n        max_.extend([-1] * (7-len(max_)))\n        min_np = numpy.array(min_, dtype=cpp_int_dtype())\n        max_np = numpy.array(max_, dtype=cpp_int_dtype())\n        try_calling(pyreg.cReg_NiftiImageData_pad(\n            self.handle, min_np.ctypes.data, max_np.ctypes.data, float(val)))",
  "def print_header(self):\n        \"\"\"Print nifti header metadata.\"\"\"\n        print(self.get_header())",
  "def get_header(self):\n        \"\"\"Print nifti header metadata.\"\"\"\n        vec = SIRF.DataHandleVector()\n        vec.push_back(self.handle)\n#        try_calling(pyreg.cReg_NiftiImageData_print_headers(vec.handle))\n        handle = pyreg.cReg_NiftiImageData_get_headers(vec.handle)\n        check_status(handle)\n        s = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return s",
  "def same_object(self):\n        \"\"\"See DataContainer method.\"\"\"\n        obj = ImageData()\n        if obj.handle is not None:\n            pyiutil.deleteDataHandle(obj.handle)\n            obj.handle = None\n        return obj",
  "def set_voxel_spacing(self, spacing, interpolation_order):\n        \"\"\"Set the voxel spacing.\n\n        Requires resampling image,\n        and so interpolation order is required.\n        As per NiftyReg, interpolation_order can be either 0, 1 or 3\n        meaning nearest neighbor, linear or cubic spline interpolation.\n        \"\"\"\n        if len(spacing) != 3:\n            raise AssertionError(\"New spacing should be array of 3 numbers.\")\n        try_calling(pyreg.cReg_NiftiImageData_set_voxel_spacing(\n            self.handle, float(spacing[0]), float(spacing[1]),\n            float(spacing[2]), int(interpolation_order)))",
  "def get_contains_nans(self):\n        \"\"\"Return true if image contains any voxels with NaNs.\"\"\"\n        return parms.bool_par(self.handle, 'NiftiImageData', 'contains_nans')",
  "def normalise_zero_and_one(self):\n        \"\"\"Normalise image between 0 and 1.\"\"\"\n        try_calling(pyreg.cReg_NiftiImageData_normalise_zero_and_one(\n            self.handle))\n        check_status(self.handle)",
  "def standardise(self):\n        \"\"\"Standardise (subtract mean and divide by standard deviation).\"\"\"\n        try_calling(pyreg.cReg_NiftiImageData_standardise(self.handle))\n        check_status(self.handle)",
  "def get_inner_product(self, other):\n        \"\"\"Get inner product between two images. Must be same size.\"\"\"\n        if not isinstance(other, NiftiImageData):\n            raise AssertionError()\n        handle = pyreg.cReg_NiftiImageData_get_inner_product(\n            self.handle, other.handle)\n        check_status(handle)\n        inner_product = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return inner_product",
  "def kernel_convolution(self, sigma, convolution_type=2):\n        \"\"\"Kernel convolution.\n\n        convolution_type:\n            - MEAN_KERNEL         = 0\n            - LINEAR_KERNEL       = 1\n            - GAUSSIAN_KERNEL     = 2\n            - CUBIC_SPLINE_KERNEL = 3\n        \"\"\"\n        try_calling(pyreg.cReg_NiftiImageData_kernel_convolution(\n            self.handle, float(sigma), int(convolution_type)))",
  "def print_headers(to_print):\n        \"\"\"Print nifti header metadata of one or multiple nifti images.\"\"\"\n        print(NiftiImageData.get_headers(to_print))",
  "def get_headers(to_print):\n        if not all(isinstance(n, NiftiImageData) for n in to_print):\n            raise AssertionError()\n        vec = SIRF.DataHandleVector()\n        for n in to_print:\n            vec.push_back(n.handle)\n#        try_calling(pyreg.cReg_NiftiImageData_print_headers(vec.handle))\n        handle = pyreg.cReg_NiftiImageData_get_headers(vec.handle)\n        check_status(handle)\n        s = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return s",
  "def construct_from_complex_image(complex_im):\n        \"\"\"Construct two NiftiImageData from a complex image.\"\"\"\n        if not isinstance(complex_im, SIRF.ImageData):\n            raise AssertionError()\n        im_real = NiftiImageData()\n        im_imag = NiftiImageData()\n        im_real.handle = \\\n            pyreg.cReg_NiftiImageData_from_complex_ImageData_real_component(\n                complex_im.handle)\n        im_imag.handle = \\\n            pyreg.cReg_NiftiImageData_from_complex_ImageData_imag_component(\n                complex_im.handle)\n        return [im_real, im_imag]",
  "def are_equal_to_given_accuracy(im1, im2, accuracy):\n        \"\"\"Check if two images match to a given accuracy.\"\"\"\n        if not isinstance(im1, NiftiImageData) or not \\\n                isinstance(im2, NiftiImageData):\n            raise AssertionError()\n        if im1.handle is None or im2.handle is None:\n            error('Cannot compare images as at least one is uninitialised')\n        h = pyreg.cReg_NiftiImageData_are_equal_to_given_accuracy(\n            im1.handle, im2.handle, float(accuracy))\n        check_status(h, inspect.stack()[1])\n        value = pyiutil.intDataFromHandle(h)\n        pyiutil.deleteDataHandle(h)\n        return value",
  "def shape(self):\n        return self.dimensions()",
  "def __init__(self, src=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'NiftiImageData3D'\n        if src is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src)\n        elif isinstance(src, SIRF.ImageData):\n            # src is ImageData\n            self.handle = pyreg.cReg_NiftiImageData_from_SIRFImageData(\n                src.handle, 1)\n        else:\n            raise error('Wrong source in NiftiImageData3D constructor')\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def __init__(self, src1=None, src2=None, src3=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'NiftiImageData3DTensor'\n        if src1 is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src1, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src1)\n        elif isinstance(src1, NiftiImageData3D) and \\\n            isinstance(src2, NiftiImageData3D) and \\\n                isinstance(src3, NiftiImageData3D):\n            self.handle = pyreg.\\\n                cReg_NiftiImageData3DTensor_construct_from_3_components(\n                    self.name, src1.handle, src2.handle, src3.handle)\n        else:\n            raise error('Wrong source in NiftiImageData3DTensor constructor')\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def write_split_xyz_components(self, filename, datatype=-1):\n        \"\"\"Save to file.\n\n        See nifti1.h for datatypes\n        (e.g., float (NIFTI_TYPE_FLOAT32) = 16).\n        Image's original datatpye is used by default.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if not isinstance(filename, str):\n            raise AssertionError()\n        try_calling(pyreg.\n                    cReg_NiftiImageData3DTensor_write_split_xyz_components(\n                        self.handle, filename, datatype))",
  "def create_from_3D_image(self, src):\n        \"\"\"Create tensor/deformation/displacement field from 3D image.\"\"\"\n        if not isinstance(src, NiftiImageData3D):\n            raise AssertionError()\n        if src.handle is None:\n            raise AssertionError()\n        try_calling(pyreg.cReg_NiftiImageData3DTensor_create_from_3D_image(\n            self.handle, src.handle))\n        check_status(self.handle)",
  "def flip_component(self, dim):\n        \"\"\"Flip component of nu.\"\"\"\n        if 0 < dim or dim > 2:\n            raise AssertionError(\n                \"Dimension to flip should be between 0 and 2.\")\n        try_calling(pyreg.cReg_NiftiImageData3DTensor_flip_component(\n            self.handle, dim))\n        check_status(self.handle)",
  "def __init__(self, src1=None, src2=None, src3=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'NiftiImageData3DDisplacement'\n        if src1 is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src1, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src1)\n        elif isinstance(src1, NiftiImageData3D) and \\\n                isinstance(src2, NiftiImageData3D) and \\\n                isinstance(src3, NiftiImageData3D):\n            self.handle = pyreg.\\\n                cReg_NiftiImageData3DTensor_construct_from_3_components(\n                    self.name, src1.handle, src2.handle, src3.handle)\n        elif isinstance(src1, NiftiImageData3DDeformation):\n            self.handle = pyreg.\\\n                cReg_NiftiImageData3DDisplacement_create_from_def(src1.handle)\n        else:\n            raise error(\n                    'Wrong source in NiftiImageData3DDisplacement constructor')\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def __init__(self, src1=None, src2=None, src3=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'NiftiImageData3DDeformation'\n        if src1 is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src1, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src1)\n        elif isinstance(src1, NiftiImageData3D) and \\\n                isinstance(src2, NiftiImageData3D) and \\\n                isinstance(src3, NiftiImageData3D):\n            self.handle = pyreg.\\\n                cReg_NiftiImageData3DTensor_construct_from_3_components(\n                    self.name, src1.handle, src2.handle, src3.handle)\n        elif isinstance(src1, NiftiImageData3DDisplacement):\n            self.handle = pyreg.\\\n                cReg_NiftiImageData3DDeformation_create_from_disp(src1.handle)\n        else:\n            raise error(\n                'Wrong source in NiftiImageData3DDeformation constructor')\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def get_inverse(self, floating=None):\n        \"\"\"\n        Get inverse (potentially based on another image).\n\n        Why would you want to base it on another image? Well, we might have a\n        deformation that takes us from image A to B. We'll probably want the\n        inverse to take us from image B back to A. In this case, use\n        get_inverse(A). This is because the the deformation field is defined\n        for the reference image. In the second case, A is the reference,\n        and B is the floating image.\n        \"\"\"\n        if floating is None:\n            floating = self\n        if not isinstance(floating, SIRF.ImageData):\n            raise AssertionError()\n        if self is None:\n            raise AssertionError()\n        output = NiftiImageData3DDeformation()\n        output.handle = pyreg.cReg_NiftiImageData3DDeformation_get_inverse(\n            self.handle, floating.handle)\n        check_status(output.handle)\n        return output",
  "def compose_single_deformation(trans, ref):\n        \"\"\"Compose transformations into single deformation.\"\"\"\n        if not isinstance(ref, NiftiImageData3D):\n            raise AssertionError()\n        if not all(isinstance(n, _Transformation) for n in trans):\n            raise AssertionError()\n        if len(trans) == 1:\n            return trans[0].get_as_deformation_field(ref)\n        # This is ugly. Store each type in a single string (need to do this\n        # because I can't get virtual methods to work for multiple inheritance\n        # (deformation/displacement are both nifti images and transformations).\n        types = ''\n        for n in trans:\n            if isinstance(n, AffineTransformation):\n                types += '1'\n            elif isinstance(n, NiftiImageData3DDisplacement):\n                types += '2'\n            elif isinstance(n, NiftiImageData3DDeformation):\n                types += '3'\n        # Convert transformations into SIRF vector\n        vec = SIRF.DataHandleVector()\n        for n in trans:\n            vec.push_back(n.handle)\n        z = NiftiImageData3DDeformation()\n        z.handle = pyreg.\\\n            cReg_NiftiImageData3DDeformation_compose_single_deformation(\n                ref.handle, types, vec.handle)\n        check_status(z.handle)\n        return z",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'Registration'\n        self.reference_image = None",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_reference_image(self, reference_image):\n        \"\"\"Set the reference image.\"\"\"\n        if not isinstance(reference_image, SIRF.ImageData):\n            raise AssertionError()\n        self.reference_image = reference_image\n        parms.set_parameter(self.handle, 'Registration', 'reference_image',\n                            reference_image.handle)",
  "def set_floating_image(self, floating_image):\n        \"\"\"Set the floating image. Will clear any previous floating images.\"\"\"\n        if not isinstance(floating_image, SIRF.ImageData):\n            raise AssertionError()\n        parms.set_parameter(self.handle, 'Registration', 'floating_image',\n                            floating_image.handle)",
  "def add_floating_image(self, floating_image):\n        \"\"\"Add floating image.\"\"\"\n        if not isinstance(floating_image, SIRF.ImageData):\n            raise AssertionError()\n        try_calling(pyreg.cReg_Registration_add_floating(\n            self.handle, floating_image.handle))",
  "def set_reference_image_filename(self, filename):\n        \"\"\"Set reference image filename.\"\"\"\n        if not isinstance(filename, str):\n            raise AssertionError()\n        self.reference_image = NiftiImageData(filename)\n        try_calling(pyreg.cReg_Registration_set_reference_image_filename(\n            self.handle, filename))",
  "def set_floating_image_filename(self, filename):\n        \"\"\"Set floating image filename.\"\"\"\n        if not isinstance(filename, str):\n            raise AssertionError()\n        try_calling(pyreg.cReg_Registration_set_floating_image_filename(\n            self.handle, filename))",
  "def add_floating_image_filename(self, filename):\n        \"\"\"Add floating image filename.\"\"\"\n        if not isinstance(filename, str):\n            raise AssertionError()\n        try_calling(pyreg.cReg_Registration_add_floating_image_filename(\n            self.handle, filename))",
  "def clear_floating_images(self):\n        \"\"\"Clear floating images.\"\"\"\n        try_calling(pyreg.cReg_Registration_clear_floatings(self.handle))",
  "def get_output(self, idx=0):\n        \"\"\"Get the registered image.\"\"\"\n        output = self.reference_image.same_object()\n        output.handle = pyreg.cReg_Registration_get_output(\n            self.handle, int(idx))\n        check_status(output.handle)\n        return output",
  "def process(self):\n        \"\"\"Run the registration.\"\"\"\n        try_calling(pyreg.cReg_Registration_process(self.handle))",
  "def get_deformation_field_forward(self, idx=0):\n        \"\"\"Get the forward deformation field image.\"\"\"\n        output = NiftiImageData3DDeformation()\n        output.handle = pyreg.\\\n            cReg_Registration_get_deformation_displacement_image(\n                self.handle, 'forward_deformation', int(idx))\n        check_status(output.handle)\n        return output",
  "def get_deformation_field_inverse(self, idx=0):\n        \"\"\"Get the inverse deformation field image.\"\"\"\n        output = NiftiImageData3DDeformation()\n        output.handle = pyreg.\\\n            cReg_Registration_get_deformation_displacement_image(\n                self.handle, 'inverse_deformation', int(idx))\n        check_status(output.handle)\n        return output",
  "def get_displacement_field_forward(self, idx=0):\n        \"\"\"Get the forward displacement field image.\"\"\"\n        output = NiftiImageData3DDisplacement()\n        output.handle = pyreg.\\\n            cReg_Registration_get_deformation_displacement_image(\n                self.handle, 'forward_displacement', int(idx))\n        check_status(output.handle)\n        return output",
  "def get_displacement_field_inverse(self, idx=0):\n        \"\"\"Get the inverse displacement field image.\"\"\"\n        output = NiftiImageData3DDisplacement()\n        output.handle = pyreg.\\\n            cReg_Registration_get_deformation_displacement_image(\n                self.handle, 'inverse_displacement', int(idx))\n        check_status(output.handle)\n        return output",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        super(_NiftyRegistration, self).__init__()\n        self.name = 'NiftyRegistration'",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_parameter_file(self, filename):\n        \"\"\"Set the parameter filename.\"\"\"\n        parms.set_char_par(self.handle, 'NiftyRegistration', 'parameter_file',\n                           filename)",
  "def set_reference_mask(self, reference_mask):\n        \"\"\"Set the reference mask.\"\"\"\n        if not isinstance(reference_mask, SIRF.ImageData):\n            raise AssertionError()\n        parms.set_parameter(self.handle, 'NiftyRegistration', 'reference_mask',\n                            reference_mask.handle)",
  "def set_floating_mask(self, floating_mask):\n        \"\"\"Set the floating mask.\"\"\"\n        if not isinstance(floating_mask, SIRF.ImageData):\n            raise AssertionError()\n        parms.set_parameter(self.handle, 'NiftyRegistration', 'floating_mask',\n                            floating_mask.handle)",
  "def set_parameter(self, par, arg1=\"\", arg2=\"\"):\n        \"\"\"Set string parameter.\n\n        Check if any set methods match the method\n        given by par. If so, set the value given by arg. Convert to float/int\n        etc., as necessary. Up to 2 arguments, leave blank if unneeded.\n        These are applied after parsing the parameter file.\n        \"\"\"\n        try_calling(pyreg.cReg_NiftyRegistration_set_parameter(\n            self.handle, par, arg1, arg2))",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        super(NiftyAladinSym, self).__init__()\n        self.name = 'NiftyAladinSym'\n        self.handle = pyreg.cReg_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def get_transformation_matrix_forward(self):\n        \"\"\"Get forward transformation matrix.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        tm = AffineTransformation()\n        tm.handle = pyreg.cReg_NiftyAladin_get_TM(self.handle, 'forward')\n        return tm",
  "def get_transformation_matrix_inverse(self):\n        \"\"\"Get inverse transformation matrix.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        tm = AffineTransformation()\n        tm.handle = pyreg.cReg_NiftyAladin_get_TM(self.handle, 'inverse')\n        return tm",
  "def print_all_wrapped_methods():\n        \"\"\"Print all wrapped methods.\"\"\"\n        print(\"\"\"In C++, this class is templated. \\\"dataType\\\"\n              corresponds to \\\"float\\\" for Matlab and python.\"\"\")\n        try_calling(pyreg.cReg_NiftyRegistration_print_all_wrapped_methods(\n            'NiftyAladinSym'))",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        super(NiftyF3dSym, self).__init__()\n        self.name = 'NiftyF3dSym'\n        self.handle = pyreg.cReg_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_floating_time_point(self, floating_time_point):\n        \"\"\"Set floating time point.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'floating_time_point',\n                          floating_time_point)",
  "def set_reference_time_point(self, reference_time_point):\n        \"\"\"Set reference time point.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'reference_time_point',\n                          reference_time_point)",
  "def set_initial_affine_transformation(self, src):\n        \"\"\"Set initial affine transformation.\"\"\"\n        if not isinstance(src, AffineTransformation):\n            raise AssertionError()\n        parms.set_parameter(self.handle, self.name,\n                            'initial_affine_transformation', src.handle)",
  "def print_all_wrapped_methods():\n        \"\"\"Print all wrapped methods.\"\"\"\n        print(\"\"\"In C++, this class is templated. \\\"dataType\\\"\n              corresponds to \\\"float\\\" for Matlab and python.\"\"\")\n        try_calling(pyreg.cReg_NiftyRegistration_print_all_wrapped_methods(\n            'NiftyF3dSym'))",
  "class SPMRegistration(_Registration):\n        \"\"\"Registration using SPM.\"\"\"\n\n        def __init__(self):\n            \"\"\"init.\"\"\"\n            super(SPMRegistration, self).__init__()\n            self.name = 'SPMRegistration'\n            self.handle = pyreg.cReg_newObject(self.name)\n            check_status(self.handle)\n\n        def __del__(self):\n            \"\"\"del.\"\"\"\n            if self.handle is not None:\n                pyiutil.deleteDataHandle(self.handle)\n\n        def get_transformation_matrix_forward(self, idx=0):\n            \"\"\"Get forward transformation matrix.\"\"\"\n            if self.handle is None:\n                raise AssertionError()\n            tm = AffineTransformation()\n            tm.handle = pyreg.cReg_SPMRegistration_get_TM(\n                self.handle, 'forward', int(idx))\n            return tm\n\n        def get_transformation_matrix_inverse(self, idx=0):\n            \"\"\"Get inverse transformation matrix.\"\"\"\n            if self.handle is None:\n                raise AssertionError()\n            tm = AffineTransformation()\n            tm.handle = pyreg.cReg_SPMRegistration_get_TM(\n                self.handle, 'inverse', int(idx))\n            return tm\n\n        def set_working_folder(self, working_folder):\n            \"\"\"Set working folder.\"\"\"\n            parms.set_char_par(self.handle, self.name,\n                               'working_folder', working_folder)\n\n        def set_working_folder_file_overwrite(\n                self, working_folder_file_overwrite=True):\n            \"\"\"Set file overwrite in working folder.\"\"\"\n            if working_folder_file_overwrite:\n                working_folder_file_overwrite = 1\n            else:\n                working_folder_file_overwrite = 0\n            parms.set_int_par(self.handle, self.name,\n                              'working_folder_file_overwrite',\n                              working_folder_file_overwrite)\n\n        def set_delete_temp_files(self, delete_temp_files=True):\n            \"\"\"Delete temporary files.\"\"\"\n            if delete_temp_files:\n                delete_temp_files = 1\n            else:\n                delete_temp_files = 0\n            parms.set_int_par(self.handle, self.name,\n                              'delete_temp_files', delete_temp_files)",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.name = 'NiftyResampler'\n        self.handle = pyreg.cReg_newObject(self.name)\n        self.reference_image = None\n        self.floating_image = None\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_reference_image(self, reference_image):\n        \"\"\"Set reference image.\n\n        This is the image that would be the reference\n        if you were doing a forward transformation.\n        \"\"\"\n        if not isinstance(reference_image, SIRF.ImageData):\n            raise AssertionError()\n        self.reference_image = reference_image\n        parms.set_parameter(\n            self.handle, self.name, 'reference_image', reference_image.handle)",
  "def set_floating_image(self, floating_image):\n        \"\"\"Set floating image.\n\n        This is the image that would be the floating if\n        you were doing a forward transformation.\n        \"\"\"\n        if not isinstance(floating_image, SIRF.ImageData):\n            raise AssertionError()\n        self.floating_image = floating_image\n        parms.set_parameter(\n            self.handle, self.name, 'floating_image', floating_image.handle)",
  "def add_transformation(self, src):\n        \"\"\"Add transformation.\"\"\"\n        if isinstance(src, AffineTransformation):\n            try_calling(pyreg.cReg_NiftyResampler_add_transformation(\n                self.handle, src.handle, 'affine'))\n        elif isinstance(src, NiftiImageData3DDisplacement):\n            try_calling(pyreg.cReg_NiftyResampler_add_transformation(\n                self.handle, src.handle, 'displacement'))\n        elif isinstance(src, NiftiImageData3DDeformation):\n            try_calling(pyreg.cReg_NiftyResampler_add_transformation(\n                self.handle, src.handle, 'deformation'))\n        else:\n            raise AssertionError()",
  "def clear_transformations(self):\n        \"\"\"Clear transformations.\"\"\"\n        if self.handle is not None:\n            try_calling(pyreg.cReg_NiftyResampler_clear_transformations(\n                self.handle))",
  "def set_interpolation_type(self, interp_type):\n        \"\"\"Set interpolation type.\n\n        0=nearest neighbour, 1=linear, 3=cubic, 4=sinc.\n        \"\"\"\n        if not isinstance(interp_type, int):\n            raise AssertionError()\n        parms.set_int_par(self.handle, self.name,\n                          'interpolation_type', interp_type)",
  "def set_interpolation_type_to_nearest_neighbour(self):\n        \"\"\"Set interpolation type to nearest neighbour.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'interpolation_type', 0)",
  "def set_interpolation_type_to_linear(self):\n        \"\"\"Set interpolation type to linear.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'interpolation_type', 1)",
  "def set_interpolation_type_to_cubic_spline(self):\n        \"\"\"Set interpolation type to cubic spline.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'interpolation_type', 3)",
  "def set_interpolation_type_to_sinc(self):\n        \"\"\"Set interpolation type to sinc.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'interpolation_type', 4)",
  "def set_padding_value(self, val):\n        \"\"\"Set padding value.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'padding', val)",
  "def norm(self, num_iter=2, verb=0):\n        '''Computes the norm of the forward projection operator.\n        '''\n        handle = pyreg.cReg_NiftyResampler_norm(self.handle, num_iter, verb)\n        check_status(handle)\n        r = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return r;",
  "def process(self):\n        \"\"\"Process.\n\n        Equivalent of calling forward(floating_image).\n        Use get_output to get resampled image.\n        \"\"\"\n        try_calling(pyreg.cReg_NiftyResampler_process(self.handle))",
  "def get_output(self):\n        \"\"\"Get output.\"\"\"\n        image = self.reference_image.same_object()\n        image.handle = parms.parameter_handle(self.handle, self.name, 'output')\n        check_status(image.handle)\n        return image",
  "def forward(self, x, out=None):\n        \"\"\"\n        Forward transformation.\n\n        Usage:\n            output = forward(x), OR\n            forward(x=input,out=output)\n        \"\"\"\n        if out is None:\n            if self.reference_image is None:\n                raise RuntimeError('reference_image needs to be set first, or you should specify an out argument')\n            out = self.reference_image.clone()\n        # Check image validity\n        if not isinstance(x, SIRF.ImageData):\n            raise TypeError('{} expecting input as SIRF.ImageData, got {}'.\n                            format(self.__class__.__name__, type(x)))\n\n        if not isinstance(out, SIRF.ImageData):\n            raise TypeError('{} expecting output as SIRF.ImageData, got {}'.\n                            format(self.__class__.__name__, type(out)))\n        # Forward\n        try_calling(pyreg.cReg_NiftyResampler_forward(\n            out.handle, x.handle, self.handle))\n        return out",
  "def direct(self, x, out=None):\n        \"\"\"Alias to forward.\"\"\"\n        return self.forward(x=x, out=out)",
  "def adjoint(self, x, out=None):\n        \"\"\"\n        Adjoint transformation.\n\n        Usage:\n            output = adjoint(x), OR\n            adjoint(x=input,out=output)\n        \"\"\"\n        if out is None:\n            out = self.floating_image.clone()\n        if not isinstance(x, SIRF.ImageData):\n            raise TypeError(\"\"\"{} expecting input as subclass of\n                            SIRF.ImageData, got {}\"\"\".format(\n                                self.__class__.__name__, type(x)))\n\n        if not isinstance(out, SIRF.ImageData):\n            raise TypeError('{} expecting output as SIRF.ImageData, got {}'.\n                            format(self.__class__.__name__, type(out)))\n        # Forward\n        try_calling(pyreg.cReg_NiftyResampler_adjoint(\n            out.handle, x.handle, self.handle))\n        return out",
  "def backward(self, x, out=None):\n        \"\"\"\n        Backward transformation.\n\n        Alias of adjoint to align terms with\n        AcquisitionModel's forward and backward.\n        \"\"\"\n        return self.adjoint(x=x, out=out)",
  "def is_linear(self):\n        \"\"\"Return whether the transformation is linear.\"\"\"\n        return True",
  "def domain_geometry(self):\n        \"\"\"Get domain geometry.\"\"\"\n        return self.floating_image",
  "def range_geometry(self):\n        \"\"\"Get range geometry.\"\"\"\n        return self.reference_image",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.name = 'ImageWeightedMean'\n        self.handle = pyreg.cReg_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def add_image(self, image, weight):\n        \"\"\"Add an image and its corresponding weight.\n\n        Image should be via filename or NiftiImageData.\n        \"\"\"\n        if isinstance(image, NiftiImageData):\n            try_calling(pyreg.cReg_ImageWeightedMean_add_image(\n                self.handle, image.handle, weight))\n        elif isinstance(image, str):\n            try_calling(pyreg.cReg_ImageWeightedMean_add_image_filename(\n                self.handle, image, weight))\n        else:\n            raise error(\"\"\"sirf.Reg.ImageWeightedMean.add_image: image must be\n                        NiftiImageData or filename.\"\"\")",
  "def process(self):\n        \"\"\"Process.\"\"\"\n        try_calling(pyreg.cReg_ImageWeightedMean_process(self.handle))",
  "def get_output(self):\n        \"\"\"Get output.\"\"\"\n        image = NiftiImageData()\n        image.handle = parms.parameter_handle(self.handle, self.name, 'output')\n        check_status(image.handle)\n        return image",
  "def __init__(self, src1=None, src2=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'AffineTransformation'\n        if src1 is None:\n            self.handle = pyreg.cReg_newObject(self.name)\n        elif isinstance(src1, str):\n            self.handle = pyreg.cReg_objectFromFile(self.name, src1)\n        elif isinstance(src1, numpy.ndarray) and src2 is None:\n            src1 = format_numpy_array_for_setter(src1)\n            if src1.shape != (4, 4):\n                raise AssertionError()\n            # Need to transpose relative to MATLAB\n            trans = numpy.zeros((4, 4), dtype=numpy.float32)\n            for i in range(4):\n                for j in range(4):\n                    trans[i, j] = src1[j, i]\n                self.handle = pyreg.\\\n                    cReg_AffineTransformation_construct_from_TM(\n                        trans.ctypes.data)\n        elif isinstance(src1, numpy.ndarray) and src2 is not None and \\\n                isinstance(src2, Quaternion):\n            src1 = format_numpy_array_for_setter(src1)\n            self.handle = pyreg.\\\n                cReg_AffineTransformation_construct_from_trans_and_quaternion(\n                    src1.ctypes.data, src2.handle)\n        elif isinstance(src1, numpy.ndarray) and \\\n                isinstance(src2, numpy.ndarray):\n            src1 = format_numpy_array_for_setter(src1)\n            src2 = format_numpy_array_for_setter(src2)\n            self.handle = pyreg.\\\n                cReg_AffineTransformation_construct_from_trans_and_euler(\n                    src1.ctypes.data, src2.ctypes.data)\n        else:\n            raise error(\"\"\"AffineTransformation accepts no args, filename,\n                        4x4 array or translation with quaternion.\"\"\")\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def __eq__(self, other):\n        \"\"\"Overload comparison operator.\"\"\"\n        if not isinstance(other, AffineTransformation):\n            raise AssertionError()\n        h = pyreg.cReg_AffineTransformation_equal(self.handle, other.handle)\n        check_status(h, inspect.stack()[1])\n        value = pyiutil.intDataFromHandle(h)\n        pyiutil.deleteDataHandle(h)\n        return value",
  "def __ne__(self, other):\n        \"\"\"Overload comparison operator.\"\"\"\n        return not self == other",
  "def __mul__(self, other):\n        \"\"\"Overload multiplication operator.\"\"\"\n        if not isinstance(other, AffineTransformation):\n            raise AssertionError()\n        mat = AffineTransformation()\n        mat.handle = pyreg.cReg_AffineTransformation_mul(\n            self.handle, other.handle)\n        check_status(mat.handle)\n        return mat",
  "def deep_copy(self):\n        \"\"\"Deep copy.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        mat = AffineTransformation()\n        mat.handle = pyreg.cReg_AffineTransformation_deep_copy(self.handle)\n        check_status(mat.handle)\n        return mat",
  "def write(self, filename):\n        \"\"\"Save to file.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        try_calling(pyreg.cReg_AffineTransformation_write(\n            self.handle, filename))",
  "def get_determinant(self):\n        \"\"\"Get determinant.\"\"\"\n        return parms.float_par(self.handle, self.name, 'determinant')",
  "def as_array(self):\n        \"\"\"Get forward transformation matrix.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        tm = numpy.ndarray((4, 4), dtype=numpy.float32)\n        try_calling(pyreg.cReg_AffineTransformation_as_array(\n            self.handle, tm.ctypes.data))\n        return tm",
  "def get_inverse(self):\n        \"\"\"Get inverse matrix.\"\"\"\n        tm = AffineTransformation()\n        tm.handle = pyreg.cReg_AffineTransformation_get_inverse(self.handle)\n        check_status(tm.handle)\n        return tm",
  "def get_Euler_angles(self):\n        \"\"\"Get Euler angles of transformation matrix (XYZ).\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        eul = numpy.ndarray(3, dtype=numpy.float32)\n        try_calling(pyreg.cReg_AffineTransformation_get_Euler_angles(\n            self.handle, eul.ctypes.data))\n        return eul",
  "def get_quaternion(self):\n        \"\"\"Get quaternion.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        quat_zeros = numpy.array([0., 0., 0., 0.], dtype=numpy.float32)\n        quat = Quaternion(quat_zeros)\n        quat.handle = pyreg.cReg_AffineTransformation_get_quaternion(\n            self.handle)\n        check_status(quat.handle)\n        return quat",
  "def get_identity():\n        \"\"\"Get identity matrix.\"\"\"\n        mat = AffineTransformation()\n        mat.handle = pyreg.cReg_AffineTransformation_get_identity()\n        return mat",
  "def get_average(to_average):\n        \"\"\"Get average of transformations.\"\"\"\n        if not all(isinstance(n, AffineTransformation) for n in to_average):\n            raise AssertionError(\"\"\"AffineTransformation:get_average() input\n                                 list should only contain\n                                 AffineTransformations.\"\"\")\n        tm = AffineTransformation()\n        vec = SIRF.DataHandleVector()\n        for n in to_average:\n            vec.push_back(n.handle)\n        tm.handle = pyreg.cReg_AffineTransformation_get_average(vec.handle)\n        check_status(tm.handle)\n        return tm",
  "def __init__(self, src=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'Quaternion'\n        if isinstance(src, numpy.ndarray):\n            if src.size != 4:\n                raise AssertionError(\"\"\"Quaternion constructor from numpy\n                                     array is wrong size.\"\"\")\n            if src.dtype is not numpy.float32:\n                src = src.astype(numpy.float32)\n            self.handle = pyreg.cReg_Quaternion_construct_from_array(\n                src.ctypes.data)\n        elif isinstance(src, AffineTransformation):\n            self.handle = pyreg.\\\n                cReg_Quaternion_construct_from_AffineTransformation(src.handle)\n        else:\n            raise error('Wrong source in quaternion constructor')\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def as_array(self):\n        \"\"\"Get quaternion as array.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        arr = numpy.ndarray(4, dtype=numpy.float32)\n        try_calling(pyreg.cReg_Quaternion_as_array(\n            self.handle, arr.ctypes.data))\n        return arr",
  "def get_average(to_average):\n        \"\"\"Get average of quaternions.\"\"\"\n        if not all(isinstance(n, Quaternion) for n in to_average):\n            raise AssertionError()\n        quat_zeros = numpy.array([0., 0., 0., 0.], dtype=numpy.float32)\n        quat = Quaternion(quat_zeros)\n        if not all(isinstance(n, Quaternion) for n in to_average):\n            raise AssertionError()\n        vec = SIRF.DataHandleVector()\n        for n in to_average:\n            vec.push_back(n.handle)\n        quat.handle = pyreg.cReg_Quaternion_get_average(vec.handle)\n        return quat",
  "def __init__(self):\n            \"\"\"init.\"\"\"\n            super(SPMRegistration, self).__init__()\n            self.name = 'SPMRegistration'\n            self.handle = pyreg.cReg_newObject(self.name)\n            check_status(self.handle)",
  "def __del__(self):\n            \"\"\"del.\"\"\"\n            if self.handle is not None:\n                pyiutil.deleteDataHandle(self.handle)",
  "def get_transformation_matrix_forward(self, idx=0):\n            \"\"\"Get forward transformation matrix.\"\"\"\n            if self.handle is None:\n                raise AssertionError()\n            tm = AffineTransformation()\n            tm.handle = pyreg.cReg_SPMRegistration_get_TM(\n                self.handle, 'forward', int(idx))\n            return tm",
  "def get_transformation_matrix_inverse(self, idx=0):\n            \"\"\"Get inverse transformation matrix.\"\"\"\n            if self.handle is None:\n                raise AssertionError()\n            tm = AffineTransformation()\n            tm.handle = pyreg.cReg_SPMRegistration_get_TM(\n                self.handle, 'inverse', int(idx))\n            return tm",
  "def set_working_folder(self, working_folder):\n            \"\"\"Set working folder.\"\"\"\n            parms.set_char_par(self.handle, self.name,\n                               'working_folder', working_folder)",
  "def set_working_folder_file_overwrite(\n                self, working_folder_file_overwrite=True):\n            \"\"\"Set file overwrite in working folder.\"\"\"\n            if working_folder_file_overwrite:\n                working_folder_file_overwrite = 1\n            else:\n                working_folder_file_overwrite = 0\n            parms.set_int_par(self.handle, self.name,\n                              'working_folder_file_overwrite',\n                              working_folder_file_overwrite)",
  "def set_delete_temp_files(self, delete_temp_files=True):\n            \"\"\"Delete temporary files.\"\"\"\n            if delete_temp_files:\n                delete_temp_files = 1\n            else:\n                delete_temp_files = 0\n            parms.set_int_par(self.handle, self.name,\n                              'delete_temp_files', delete_temp_files)",
  "def set_parameter(hs, group, par, hv, stack = None):\n    if stack is None:\n        stack = inspect.stack()[1]\n    h = setParameter(hs, group, par, hv)\n    check_status(h, stack)\n    pyiutil.deleteDataHandle(h)",
  "def set_char_par(handle, group, par, value):\n    h = pyiutil.charDataHandle(value)\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def set_int_par(handle, group, par, value):\n    h = pyiutil.intDataHandle(value)\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def set_float_par(handle, group, par, value):\n    h = pyiutil.floatDataHandle(value)\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def bool_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.boolDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def char_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = pyiutil.charDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def int_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.intDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def int_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.intDataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def uint16_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.uint16DataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def uint32_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.uint32DataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def uint64_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.uint64DataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def float_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h)\n    v = pyiutil.floatDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return v",
  "def float_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.floatDataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def parameter_handle(hs, group, par):\n    handle = parameter(hs, group, par)\n    check_status(handle, inspect.stack()[1])\n    return handle",
  "def mr_data_path():\n    '''\n    Returns default path to MR raw data files.\n    '''\n    return examples_data_path('MR')",
  "class Image(object):\n    '''\n    Provides access to ISMRMRD::Image parameters (cf. ismrmrd.h).\n    '''\n    def __init__(self, image_data = None, image_num = 0):\n        self.handle = None\n        if image_data is not None:\n            self.handle = pygadgetron.cGT_imageWrapFromContainer \\\n                          (image_data.handle, image_num)\n            check_status(self.handle)\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def is_real(self):\n        assert self.handle is not None\n        t = self.data_type()\n        return t is not ISMRMRD_CXFLOAT and t is not ISMRMRD_CXDOUBLE\n    def version(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'version')\n    def flags(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'flags')\n        #return _int_par(self.handle, 'image', 'flags')\n    def data_type(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'data_type')\n    def measurement_uid(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'measurement_uid')\n    def channels(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'channels')\n    def average(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'average')\n    def slice(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'slice')\n    def contrast(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'contrast')\n    def phase(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'phase')\n    def repetition(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'repetition')\n    def set(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'set')\n    def acquisition_time_stamp(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'acquisition_time_stamp')\n    def image_type(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'image_type')\n    def image_index(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'image_index')\n    def image_series_index(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'image_series_index')\n    def attribute_string_len(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'attribute_string_len')\n    def matrix_size(self):\n        assert self.handle is not None\n        return parms.uint16_pars(self.handle, 'image', 'matrix_size', 3)[::-1]\n        #return _uint16_pars(self.handle, 'image', 'matrix_size', 3)[::-1]\n    def physiology_time_stamp(self):\n        assert self.handle is not None\n        return parms.uint32_pars(self.handle, 'image', 'physiology_time_stamp', 3)\n    def field_of_view(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'image', 'field_of_view', 3)\n    def position(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'image', 'position', 3)\n    def read_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'image', 'read_dir', 3)\n    def phase_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'image', 'phase_dir', 3)\n    def slice_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'image', 'slice_dir', 3)\n    def patient_table_position(self):\n        assert self.handle is not None\n        #return parms.float_pars \\\n        return parms.float_pars \\\n               (self.handle, 'image', 'patient_table_position', 3)\n    def info(self, method):\n        return eval('self.' + method + '()')",
  "class ImageData(SIRF.ImageData):\n    '''\n    Class for an MR images container.\n    Each item in the container is a 3D complex or float array of the image\n    values on an xyz-slice (z-dimension is normally 1).\n    '''\n    def __init__(self, file = None):\n        self.handle = None\n        if file is None:\n            return\n        self.handle = pygadgetron.cGT_readImages(file)\n        check_status(self.handle)\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def same_object(self):\n        return ImageData()\n\n    def real_abs(self, out=None):\n        ''' WARNING: this method produces images of type different from that\n            of self.\n        '''\n        if out is None:\n            images = ImageData()\n        else:\n            images = out\n        images.handle = pygadgetron.cGT_realImageData(self.handle, 'abs')\n        check_status(images.handle)\n        if out is None:\n            return images\n\n    def real(self):\n        ''' WARNING: this method produces images of type different from that\n            of self.\n        '''\n        images = ImageData()\n        images.handle = pygadgetron.cGT_realImageData(self.handle, 'real')\n        check_status(images.handle)\n        return images\n\n    def read_from_file(self, file):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pygadgetron.cGT_readImages(file)\n        check_status(self.handle)\n\n    def from_acquisition_data(self, ad):\n        assert isinstance(ad, AcquisitionData), \"Please pass a AcquisitionData object\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pygadgetron.cGT_ImageFromAcquisitiondata(ad.handle)\n        check_status(self.handle)\n\n    def data_type(self, im_num):\n        '''\n        Returns the data type for a specified image (see 8 data types above).\n        im_num: image (slice)\n        '''\n        assert self.handle is not None\n        handle = pygadgetron.cGT_imageDataType(self.handle, im_num)\n        check_status(handle)\n        n = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return n\n\n    def set_ISMRMRD_image_type(self, imtype):\n        assert self.handle is not None\n        try_calling(pygadgetron.cGT_setImageType(self.handle, imtype))\n\n    def is_real(self):\n        assert self.handle is not None\n        t = self.data_type(0)\n        return t is not ISMRMRD_CXFLOAT and t is not ISMRMRD_CXDOUBLE\n\n    def process(self, list):\n        '''\n        Returns processed self with an image processor specified by\n        a list of gadgets.\n        list: Python list of gadget description strings, each gadget\n              description being a string of the form\n                '[label:]gadget_name[(property1=value1[,...])]'\n              (square brackets embrace optional items, ... stands for etc.)\n        '''\n        assert self.handle is not None\n        ip = ImageDataProcessor(list)\n        return ip.process(self)\n\n    def image(self, im_num):\n        return Image(self, im_num)\n\n    def select(self, attr, value):\n        '''\n        Creates an images container with images from self with the specified\n        value of specified attribute.\n        attr : the name of the attribute (Python string)\n        value: the value of the attribute (Python string)\n        '''\n        assert self.handle is not None\n        images = ImageData()\n        images.handle = pygadgetron.cGT_selectImages(self.handle, attr, value)\n        check_status(images.handle)\n        return images\n\n    def get_ISMRMRD_info(self, par):\n        '''\n        Returns the array of values of the specified image information\n        parameter. Parameters names are the same as the names of sirf.Gadgetron.Image class\n        public methods (except is_real and info).\n\n        par: parameter name (as a string)\n\n        Examples:\n\n        # to get information on the timing:\n        slice = image.get_ISMRMRD_info('acquisition_time_stamp')\n\n        # to get the unit vector orthogonal to the slice and directed\n        # to the next slice (in ISMRMRD coordinate system):\n        slice_dir = image.get_ISMRMRD_info('slice_dir')\n        '''\n        ni = self.number()\n        info = numpy.empty((ni,), dtype = object)\n        for i in range(ni):\n            image = self.image(i)\n            info[i] = image.info(par)\n        return info\n\n    @deprecated(details=\"Please use get_ISMRMRD_info method instead\")\n    def get_info(self, par):\n        return self.get_ISMRMRD_info(par)\n\n    def fill(self, data):\n        '''\n        Fills self's image data with specified values.\n        data: Python Numpy array or ImageData\n        '''\n        assert self.handle is not None\n        \n        if isinstance(data, ImageData):\n            return super(ImageData, self).fill(data)\n        \n        if isinstance(data, numpy.ndarray):\n            dims = self.dimensions()\n            shape = data.shape\n            if numpy.prod(shape) != numpy.prod(dims):\n                msg = 'cannot fill ImageData of size %s with data of size %s'\n                raise ValueError(msg % (repr(dims), repr(shape)))\n\n            nc, nz, ny, nx = dims if len(dims) > 3 else (1,) + dims\n            ns = self.number() # number of total dynamics (slices, contrasts, etc.)\n            nz = nz//ns        # z-dimension of a slice\n            data = numpy.reshape(data, (nc, ns, nz, ny, nx))\n            data = numpy.swapaxes(data, 0, 1)\n            the_data = data\n            if self.is_real():\n                if data.dtype != numpy.float32:\n                    the_data = data.astype(numpy.float32)\n            else:\n                if data.dtype != numpy.complex64:\n                    the_data = data.astype(numpy.complex64)\n            convert = not data.flags['C_CONTIGUOUS']\n            if convert:\n                the_data = numpy.ascontiguousarray(the_data)\n            if self.is_real():\n                try_calling(pygadgetron.cGT_setImageDataFromFloatArray\\\n                    (self.handle, the_data.ctypes.data))\n            else:\n                try_calling(pygadgetron.cGT_setImageDataFromCmplxArray\\\n                    (self.handle, the_data.ctypes.data))\n        elif isinstance (data, Complex):\n            arr = data + numpy.zeros(self.shape, dtype=numpy.complex64)\n            return self.fill(arr)\n        elif isinstance (data, Number):\n            arr = data + numpy.zeros(self.shape, dtype=numpy.float32)\n            return self.fill(arr)\n        else:\n            raise error('wrong fill value.' + \\\n                        ' Should be ImageData, numpy.ndarray or number. Got {}'.format(type(data)))\n        return self\n\n    def dimensions(self):\n        '''\n        Returns the dimensions of 3D/4D Numpy ndarray of all self's images.\n        '''\n        if self.number() < 1:\n            return 0\n        assert self.handle is not None\n        dim = numpy.ndarray((4,), dtype=cpp_int_dtype())\n        image = Image(self)\n        pygadgetron.cGT_getImageDim(image.handle, dim.ctypes.data)\n        nx = dim[0]\n        ny = dim[1]\n        nz = dim[2]\n        nc = dim[3]\n        \n        nz = nz*self.number()\n        \n        if nc == 1: # for backward compatibility\n            return nz, ny, nx\n        else:\n            return nc, nz, ny, nx\n        \n    def as_array(self):\n        '''\n        Returns all self's images as a 3D or 4D Numpy ndarray.\n        '''\n        dims = self.dimensions()\n        \n        assert self.handle is not None\n        if self.number() < 1:\n            return numpy.ndarray((0,), dtype = numpy.float32)\n        if self.is_real():\n            array = numpy.ndarray(dims, dtype = numpy.float32)\n            try_calling(pygadgetron.cGT_getImageDataAsFloatArray\\\n                (self.handle, array.ctypes.data))\n        else:\n            array = numpy.ndarray(dims, dtype = numpy.complex64)\n            try_calling(pygadgetron.cGT_getImageDataAsCmplxArray\\\n                (self.handle, array.ctypes.data))\n                \n        if len(dims) != 4:\n            return array\n\n        nc, nz, ny, nx = dims\n        ns = self.number() # number of total dynamics (slices, contrasts, etc.)\n        nz = nz//ns        # z-dimension of a slice\n\n        # hope Numpy is clever enough to do all this in-place:\n        array = numpy.reshape(array, (ns, nc, nz, ny, nx))\n        array = numpy.swapaxes(array, 0, 1)\n        array = numpy.reshape(array, (nc, ns*nz, ny, nx))\n\n        return array\n                \n    def copy(self):\n        '''alias of clone'''\n        return self.clone()\n    def show(self, zyx=None, slice=None, title=None, cmap='gray', postpone=False):\n        '''Displays xy-cross-section(s) of images.'''\n        assert self.handle is not None\n        if not HAVE_PYLAB:\n            print('pylab not found')\n            return\n        data = self.as_array()\n        nz = data.shape[0]\n        if isinstance(slice, (Integral,numpy.integer)):\n            if slice < 0 or slice >= nz:\n                return\n            ni = 1\n            slice = [slice]\n        elif slice is None:\n            ni = nz\n            slice = range(nz)\n        else:\n            try:\n                ni = len(slice)\n            except:\n                raise error('wrong slice list')\n        if title is None:\n            title = 'Selected images'\n        if ni >= 16:\n            tiles = (4, 4)\n        else:\n            tiles = None\n        f = 0\n        while f < ni:\n            t = min(f + 16, ni)\n            err = show_3D_array(abs(data), index=slice[f : t], \\\n                                tile_shape=tiles, cmap=cmap, \\\n                                zyx=zyx, label='image', \\\n                                xlabel='samples', ylabel='readouts', \\\n                                suptitle=title, \\\n                                show=(t == ni) and not postpone)\n            f = t\n    def allocate(self, value=0, **kwargs):\n        '''Method to allocate an ImageData and set its values\n        \n        CIL/SIRF compatibility\n        '''\n        if value in ['random', 'random_int']:\n            out = self.clone()\n            shape = out.as_array().shape\n            seed = kwargs.get('seed', None)\n            if seed is not None:\n                numpy.random.seed(seed)\n            if value == 'random':\n                out.fill(numpy.random.random_sample(shape))\n            elif value == 'random_int':\n                max_value = kwargs.get('max_value', 100)\n                out.fill(numpy.random.randint(max_value,size=shape))\n        else:\n            out = self.clone()\n            tmp = value * numpy.ones(out.as_array().shape)\n            out.fill(tmp)\n        return out\n\n    def print_header(self, im_num):\n        \"\"\"Print the header of one of the images. zero based.\"\"\"\n        try_calling(pygadgetron.cGT_print_header(self.handle, im_num))\n\n    @property\n    def shape(self):\n        return self.dimensions()",
  "class CoilImagesData(ImageData):\n    '''\n    Class for a coil images (ci) container.\n    Each item in the container is a 4D complex array of coil images values\n    on an xyz-slice.\n    '''\n    def __init__(self):\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject('CoilImages')\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def same_object(self):\n        return CoilImagesData()\n    def calculate(self, acq):\n        dcw = compute_kspace_density(acq)\n        acq = acq * dcw\n        try_calling(pygadgetron.cGT_computeCoilImages(self.handle, acq.handle))",
  "class CoilSensitivityData(ImageData):\n    '''\n    Class for a coil sensitivity maps (csm) container.\n    Each item in the container is a 4D complex array of csm values on an\n    xyz-slice (z-dimension is normally 1).\n    '''\n    def __init__(self):\n        self.handle = None\n        self.smoothness = 0\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def same_object(self):\n        return CoilSensitivityData()\n    def read(self, file):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pygadgetron.cGT_CoilSensitivities(file)\n        check_status(self.handle)\n    def calculate(self, data, method=None):\n        '''\n        Calculates coil sensitivity maps from coil images or sorted\n        acquisitions.\n        data  : either AcquisitionData or CoilImages\n        method: either SRSS (Square Root of the Sum of Squares, default) or\n                Inati\n        '''\n        if isinstance(data, AcquisitionData):\n            if data.is_sorted() is False:\n                print('WARNING: acquisitions may be in a wrong order')\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pygadgetron.cGT_CoilSensitivities('')\n        check_status(self.handle)\n        nit = self.smoothness\n        \n        if method is not None:\n            method_name, parm_list = name_and_parameters(method)\n            parm = parse_arglist(parm_list)\n            if 'niter' in parm:\n                nit = int(parm['niter'])\n        else:\n            method_name = 'SRSS'\n            parm = {}\n        \n        parms.set_int_par(self.handle, 'coil_sensitivity', 'smoothness', nit)\n\n        if isinstance(data, AcquisitionData):\n            self.__calc_from_acquisitions(data, method_name)\n        elif isinstance(data, CoilImagesData):\n            self.__calc_from_images(data, method_name)\n        else:\n            raise error('Cannot calculate coil sensitivities from %s' % \\\n                        repr(type(data)))\n\n    def __calc_from_acquisitions(self, data, method_name):\n\n        if data.handle is None:\n            raise AssertionError(\"The handle for data is None. Please pass valid acquisition data.\")\n\n        dcw = compute_kspace_density(data)\n\n        data = data * dcw\n        if method_name == 'Inati':\n\n            try:\n                from ismrmrdtools import coils\n            except:\n                raise error('Inati method requires ismrmrd-python-tools')\n\n            cis = CoilImagesData()\n            try_calling(pygadgetron.cGT_computeCoilImages(cis.handle, data.handle))\n            cis_array = cis.as_array()\n            csm, _ = coils.calculate_csm_inati_iter(cis_array)\n\n            if self.handle is not None:\n                pyiutil.deleteDataHandle(self.handle)\n            self.handle = pysirf.cSIRF_clone(cis.handle)\n\n            self.fill(csm.astype(numpy.complex64))\n        \n        elif method_name == 'SRSS':\n            try_calling(pygadgetron.cGT_computeCoilSensitivities(self.handle, data.handle))\n\n    def __calc_from_images(self, data, method_name):\n\n        if data.handle is None:\n            raise AssertionError(\"The handle for data is None. Please pass valid image data.\")\n\n        if method_name == 'Inati':\n\n            try:\n                from ismrmrdtools import coils\n            except:\n                raise error('Inati method requires ismrmrd-python-tools')\n                \n            cis_array = data.as_array()\n            csm, _ = coils.calculate_csm_inati_iter(cis_array)\n\n            if self.handle is not None:\n                pyiutil.deleteDataHandle(self.handle)\n            self.handle = pysirf.cSIRF_clone(data.handle)\n\n            self.fill(csm.astype(numpy.complex64))\n\n        elif method_name == 'SRSS':\n\n            try_calling(pygadgetron.cGT_computeCoilSensitivitiesFromCoilImages \\\n                (self.handle, data.handle))\n\n        else:\n            raise error('Unknown method %s' % method_name)\n\n    def __calc_from_acquisitions(self, data, method_name):\n        assert data.handle is not None\n        dcw = compute_kspace_density(data)\n        data = data * dcw\n        cis = CoilImagesData()\n        try_calling(pygadgetron.cGT_computeCoilImages(cis.handle, data.handle))\n        self.__calc_from_images(cis, method_name)",
  "class Acquisition(object):\n    ''' Provides access to ISMRMRD::Acquisition parameters (cf. ismrmrd.h).\n    '''\n    def __init__(self, file = None):\n        self.handle = None\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def version(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'version')\n    def flags(self):\n        '''\n        Returns acquisition flags as an integer (each bit corresponding to a\n        flag).\n        '''\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'flags')\n        #return _int_par(self.handle, 'acquisition', 'flags')\n    def measurement_uid(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'measurement_uid')\n    def scan_counter(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'scan_counter')\n    def acquisition_time_stamp(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'acquisition_time_stamp')\n    def number_of_samples(self):\n        '''\n        returns the number of samples in the readout direction.\n        '''\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'number_of_samples')\n    def available_channels(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'available_channels')\n    def active_channels(self):\n        '''\n        Returns the number of active channels (coils).\n        '''\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'active_channels')\n    def discard_pre(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'discard_pre')\n    def discard_post(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'discard_post')\n    def center_sample(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'center_sample')\n    def encoding_space_ref(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'encoding_space_ref')\n    def trajectory_dimensions(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'trajectory_dimensions')\n    def kspace_encode_step_1(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_kspace_encode_step_1')\n    def kspace_encode_step_2(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_kspace_encode_step_2')\n    def average(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_average')\n    def slice(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_slice')\n    def contrast(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_contrast')\n    def phase(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_phase')\n    def repetition(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_repetition')\n    def set(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_set')\n    def segment(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_segment')\n    def physiology_time_stamp(self):\n        assert self.handle is not None\n        return parms.uint32_pars(self.handle, 'acquisition', 'physiology_time_stamp', 3)\n    def channel_mask(self):\n        assert self.handle is not None\n        return parms.uint64_pars(self.handle, 'acquisition', 'channel_mask', 16)\n    def sample_time_us(self):\n        assert self.handle is not None\n        return parms.float_par(self.handle, 'acquisition', 'sample_time_us')\n    def position(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'acquisition', 'position', 3)\n    def read_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'acquisition', 'read_dir', 3)\n    def phase_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'acquisition', 'phase_dir', 3)\n    def slice_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'acquisition', 'slice_dir', 3)\n    def patient_table_position(self):\n        assert self.handle is not None\n        return parms.float_pars \\\n               (self.handle, 'acquisition', 'patient_table_position', 3)\n    def info(self, method):\n        return eval('self.' + method + '()')\n\n\n    def set_kspace_encode_step_1(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_kspace_encode_step_1', int(val))\n    def set_kspace_encode_step_2(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_kspace_encode_step_2', int(val))\n    def set_average(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_average', int(val))\n    def set_slice(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_slice', int(val))\n    def set_contrast(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_contrast', int(val))\n    def set_phase(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_phase', int(val))\n    def set_repetition(self, val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_repetition', val)\n    def set_set(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_set', int(val))\n    def set_segment(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_segment', int(val))\n\n    def set_physiology_time_stamp(self,val,stampnum):\n        '''\n        Setter for acquisitions physiology time stamp.\n        input: \n            val: time in tics! (1 tic usually corresponds to 2.5ms for SIEMENS data).\n            stampnum: which physiology time stamp is set, 0, 1 or 2 (stampnum=0 corresponds to trigger delay).\n        '''\n        assert self.handle is not None\n        if stampnum <0 or stampnum >2:\n            raise AssertionError(f\"stampnum must be either 0, 1 or 2. You gave {stampnum}.\")\n        attribute = f\"physiology_time_stamp{stampnum}\"\n        return parms.set_int_par(self.handle, 'acquisition', attribute, int(val))",
  "class AcquisitionData(DataContainer):\n    '''\n    Class for an MR acquisitions container.\n    Each item is a 2D complex array of acquisition samples for each coil.\n    '''\n    def __init__(self, file=None, all_=False):\n        self.handle = None\n        self.sorted = False\n        self.info = None\n        if file is not None:\n            self.handle = pygadgetron.cGT_ISMRMRDAcquisitionsFromFile(file, 1*all_)\n            check_status(self.handle)\n\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    @staticmethod\n    def set_storage_scheme(scheme):\n        '''Sets acquisition data storage scheme.'''\n        if scheme != 'memory':\n            msg = 'WARNING: storage scheme ' + repr(scheme) + ' not supported,'\n            msg += ' using memory storage scheme instead'\n            print(msg)\n    @staticmethod\n    def get_storage_scheme():\n        '''Returns acquisition data storage scheme.\n        '''\n        return 'memory'\n    def same_object(self):\n        return AcquisitionData()\n    def new_acquisition_data(self, empty=True):\n        new_ad = AcquisitionData()\n        if empty:\n            new_ad.handle = pygadgetron.cGT_createEmptyAcquisitionData(self.handle)\n        else:\n            new_ad.handle = pygadgetron.cGT_cloneAcquisitions(self.handle)\n        check_status(new_ad.handle)\n        return new_ad\n    def number_of_readouts(self, select='image'):\n        if select == 'image':\n            dim = self.dimensions()\n            return dim[0]\n        else:\n            return self.number()\n    def number_of_acquisitions(self, select='image'):\n        return self.number_of_readouts\n\n    def check_traj_type(self, trajname):\n        '''\n        Checks if the data is of the trajectory type trajname.\n        trajname: string with trajectory name.\n        Possible choices are:\n            - cartesian\n            - radial\n            - epi\n            - goldenangle\n            - spiral\n            - other\n        '''\n        list_available_trajs = ('cartesian', 'epi', 'radial', 'goldenangle', 'spiral', 'other')\n        if trajname not in list_available_trajs:\n            raise AssertionError(\"The trajectory you asked for is not among the available trajectoryies\")\n\n        xml_hdr = self.get_header()\n        traj_id_substring = \"<trajectory>\"+trajname+\"</trajectory>\"\n\n        return traj_id_substring in xml_hdr\n     \n    def sort(self):\n        '''\n        Sorts acquisitions (currently, with respect to acquisition_time_stamp)\n        '''\n        assert self.handle is not None\n        try_calling(pygadgetron.cGT_sortAcquisitions(self.handle))\n        self.sorted = True\n    def sort_by_time(self):\n        '''\n        Sorts acquisitions with respect to acquisition_time_stamp\n        '''\n        assert self.handle is not None\n        try_calling(pygadgetron.cGT_sortAcquisitionsByTime(self.handle))\n    def is_sorted(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisitions', 'sorted')\n        #return self.sorted\n    def is_undersampled(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisitions', 'undersampled')\n    def set_header(self, header):\n        assert self.handle is not None\n        try_calling(pygadgetron.cGT_setAcquisitionsInfo(self.handle, header))\n    def set_encoding_limit(self, name:str, limit:tuple):\n        if len(limit)!=3:\n            raise AssertionError(\"Please give three values, min, max and ctr\")\n        try_calling(pygadgetron.cGT_setEncodingLimits(self.handle, name, int(limit[0]), int(limit[1]), int(limit[2])))\n    def get_header(self):\n        assert self.handle is not None\n        return parms.char_par(self.handle, 'acquisitions', 'info')\n    def process(self, list):\n        '''\n        Returns processed self with an acquisition processor specified by\n        a list of gadgets.\n        list: Python list of gadget description strings, each gadget\n              description being a string of the form\n                '[label:]gadget_name[(property1=value1[,...])]'\n              (square brackets embrace optional items, ... stands for etc.)\n        '''\n        ap = AcquisitionDataProcessor(list)\n        return ap.process(self)\n    def acquisition(self, num):\n        '''\n        Returns the specified acquisition.\n        num: acquisition number\n        '''\n        assert self.handle is not None\n        acq = Acquisition()\n        acq.handle = pygadgetron.cGT_acquisitionFromContainer(self.handle, int(num))\n        check_status(acq.handle)\n        return acq\n    def append_acquisition(self, acq):\n        '''\n        Appends acquistion to AcquisitionData.\n        '''\n        assert self.handle is not None\n        try_calling( pygadgetron.cGT_appendAcquisition(self.handle, acq.handle))\n    \n    def get_subset(self, idx):\n        '''\n        Returns AcquisitionData object with subset of acquisitions defined by idx\n        '''\n        assert self.handle is not None\n        subset = AcquisitionData()\n        idx = numpy.array(idx, dtype = cpp_int_dtype())\n        subset.handle = pygadgetron.cGT_getAcquisitionsSubset(self.handle, idx.ctypes.data, idx.size)\n        check_status(subset.handle)\n        \n        return subset\n    \n    def set_user_floats(self, data, idx):\n        '''\n        Writes the data into the user_float[idx] data field of the acquisition\n        data header of each acquisition in the container to pass additional data\n        into the raw data.\n        data: numpy array\n        idx: integer in range 0 to 7\n        '''\n        if self.handle is None:\n            raise AssertionError('self.handle is None')\n                    \n        if data.size != self.number():\n            raise AssertionError('Please give as many datapoints as there are acquisitions')\n        \n        if idx > 7 or idx < 0 or not isinstance(idx,int):\n            raise AssertionError('Please give an integer from [0,...,7]')\n\n        if data.dtype is not numpy.float32:\n            data = data.astype(numpy.float32)\n\n        try_calling(pygadgetron.cGT_setAcquisitionUserFloat\\\n                    (self.handle, data.ctypes.data, idx))\n\n    def dimensions(self):\n        '''\n        Returns acquisitions dimensions as a tuple (na, nc, ns), where na is\n        the number of acquisitions, nc the number of coils and ns the number of\n        samples.\n        '''\n        assert self.handle is not None\n        if self.number() < 1:\n            return numpy.zeros((MAX_ACQ_DIMENSIONS,), dtype=cpp_int_dtype())\n        dim = numpy.ones((MAX_ACQ_DIMENSIONS,), dtype=cpp_int_dtype())\n        try_calling(pygadgetron.cGT_getAcquisitionDataDimensions\\\n             (self.handle, dim.ctypes.data))\n        dim[2] = numpy.prod(dim[2:])\n        return tuple(dim[2::-1])\n\n    def get_ISMRMRD_info(self, par, which='all'):\n        '''\n        Returns the array of values of the specified acquisition information\n        parameter.\n\n        par: parameter name (see sirf.Gadgetron.Acquisition class methods except info)\n        which: specifies the range of acquisitions whose parameters are returned\n\n        Example:\n        # to retrieve readouts flags for acquisitions 0 to 10:\n        flags = acq_data.get_ISMRMRD_info('flags', range(10))\n\n        # for phase encoding information\n        encoding = acq_data.get_ISMRMRD_info('kspace_encode_step_1')\n\n        '''\n        #na, nc, ns = self.dimensions()\n        if which == 'all':\n            na = self.number()\n            rng = range(na)\n        else:\n            rng = which\n            na = len(rng)\n        f = min(rng)\n        t = max(rng) + 1\n        info = numpy.ndarray((2,), dtype=cpp_int_dtype())\n        try_calling(pygadgetron.cGT_acquisitionParameterInfo \\\n                    (self.handle, par, info.ctypes.data))\n        n = int(info[1])\n        if info[0] == 0:\n            values = numpy.ndarray((na, n), dtype=numpy.uint64)\n            try_calling(pygadgetron.cGT_acquisitionParameterValuesInt \\\n                        (self.handle, par, f, t, n, values.ctypes.data))\n        else:\n            values = numpy.ndarray((na, n), dtype=numpy.float32)\n            try_calling(pygadgetron.cGT_acquisitionParameterValuesFloat \\\n                        (self.handle, par, f, t, n, values.ctypes.data))\n        if n == 1:\n            values = numpy.reshape(values, (na,))\n        return values\n\n        # Python way is much slower for large data\n        info = numpy.empty((na,), dtype = object)\n        i = 0\n        for a in rng:\n            acq = self.acquisition(a)\n            info[i] = acq.info(par)\n            i += 1\n        return info\n\n    @deprecated(details=\"Please use the get_ISMRMRD_info method instead\")\n    def get_info(self, par, which='all'):\n        return self.get_ISMRMRD_info(par, which)\n\n    def fill(self, data, select='image'):\n        '''\n        Fills self's acquisitions with specified values.\n        data: Python Numpy array or AcquisitionData\n        select: specifies whether all or only image-related acquisitions are\n                filled with values from the array data.\n        '''\n        assert self.handle is not None\n        if isinstance(data, AcquisitionData):\n            try_calling(pygadgetron.cGT_fillAcquisitionDataFromAcquisitionData\\\n                (self.handle, data.handle))\n            return\n        elif isinstance(data, numpy.ndarray):\n            dims = self.dimensions()\n            shape = data.shape\n            if shape != dims:\n                msg = 'cannot fill AcquisitionData of size %s' \\\n                      + ' with data of size %s'\n                raise ValueError(msg % (repr(dims), repr(shape)))\n            if data.dtype is not numpy.complex64:\n                the_data = data.astype(numpy.complex64)\n            else:\n                the_data = data\n            convert = not data.flags['C_CONTIGUOUS']\n            if convert:\n                the_data = numpy.ascontiguousarray(the_data)\n            if select == 'all':\n                fill_all = 1\n            else: # fill only image-related\n                fill_all = 0\n            try_calling(pygadgetron.cGT_fillAcquisitionData\\\n                (self.handle, the_data.ctypes.data, fill_all))\n        elif isinstance (data, Complex):\n            arr = data + numpy.zeros(self.shape, dtype=numpy.complex64)\n            return self.fill(arr)\n        elif isinstance (data, Number):\n            arr = data + numpy.zeros(self.shape, dtype=numpy.float32)\n            return self.fill(arr)\n        else:\n            raise error('wrong fill value.' + \\\n                        ' Should be AcquisitionData, numpy.ndarray or number. Got {}'.format(type(data)))\n        return self\n\n    def as_array(self, acq=None):\n        '''\n        Returns selected self's acquisition(s) data as a 2D or 3D Numpy ndarray.\n        acq: acquisition number; if None all acquisitions data is returned.\n        '''\n        assert self.handle is not None\n        if acq is None:\n            ''' return 3D array of all acquisition data\n            '''\n            na, nc, ns = self.dimensions()\n            z = numpy.ndarray((na, nc, ns), dtype = numpy.complex64)\n            acq = -1\n        else:\n            ''' return 2D array of the specified acquisition data\n            '''\n            a = self.acquisition(acq)\n            nc = a.active_channels()\n            ns = a.number_of_samples()\n            z = numpy.ndarray((nc, ns), dtype = numpy.complex64)\n        try_calling(pygadgetron.cGT_acquisitionDataAsArray\\\n            (self.handle, z.ctypes.data, acq))\n        return z\n\n    def show(self, slice=None, title=None, cmap='gray', power=0.2, \\\n             postpone=False):\n        '''Displays xy-cross-section(s) of images.'''\n        assert self.handle is not None\n        if not HAVE_PYLAB:\n            print('pylab not found')\n            return\n        data = numpy.transpose(self.as_array(), (1, 0, 2))\n        nz = data.shape[0]\n        if isinstance(slice, (Integral,numpy.integer)):\n            if slice < 0 or slice >= nz:\n                return\n            ns = 1\n            slice = [slice]\n##            show_2D_array('slice %d' % slice, data[slice,:,:])\n##            return\n        elif slice is None:\n            ns = nz\n            slice = range(nz)\n        else:\n            try:\n                ns = len(slice)\n            except:\n                raise error('wrong slice list')\n        if title is None:\n            title = 'Selected images'\n        if ns >= 16:\n            tiles = (4, 4)\n        else:\n            tiles = None\n        f = 0\n        while f < ns:\n            t = min(f + 16, ns)\n            err = show_3D_array(abs(data), index = slice[f : t], \\\n                                tile_shape = tiles, \\\n                                label = 'coil', xlabel = 'samples', \\\n                                ylabel = 'readouts', \\\n                                suptitle = title, cmap = cmap, power = power, \\\n                                show = (t == ns) and not postpone)\n            f = t\n    \n    def allocate(self, value=0, **kwargs):\n        '''Method to allocate an AcquisitionData and set its values\n        \n        CIL/SIRF compatibility\n        '''\n        if value in ['random', 'random_int']:\n            out = self.clone()\n            shape = out.as_array().shape\n            seed = kwargs.get('seed', None)\n            if seed is not None:\n                numpy.random.seed(seed)\n            if value == 'random':\n                out.fill(numpy.random.random_sample(shape))\n            elif value == 'random_int':\n                max_value = kwargs.get('max_value', 100)\n                out.fill(numpy.random.randint(max_value,size=shape))\n        else:\n            out = self.clone()\n            tmp = value * numpy.ones(out.as_array().shape)\n            out.fill(tmp)\n        return out\n\n    @property\n    def shape(self):\n        return self.dimensions()",
  "class AcquisitionModel(object):\n    '''\n    Class for MR acquisition model, an operator that maps images into\n    simulated acquisitions.\n    '''\n    def __init__(self, acqs = None, imgs = None):\n        self.handle = None\n        if acqs == None:\n            self.handle = pygadgetron.cGT_newObject('AcquisitionModel')\n        else:\n            assert_validity(acqs, AcquisitionData)\n            assert_validity(imgs, ImageData)\n            self.handle = \\\n                pygadgetron.cGT_AcquisitionModel(acqs.handle, imgs.handle)\n        check_status(self.handle)\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def set_up(self, acqs, imgs):\n        assert_validity(acqs, AcquisitionData)\n        assert_validity(imgs, ImageData)\n        try_calling(pygadgetron.cGT_setUpAcquisitionModel \\\n            (self.handle, acqs.handle, imgs.handle))\n    def set_coil_sensitivity_maps(self, csm):\n        '''\n        Specifies the coil sensitivity maps to be used by the model.\n        csm: CoilSensitivityData\n        '''\n        assert_validity(csm, CoilSensitivityData)\n        try_calling(pygadgetron.cGT_setAcquisitionModelParameter \\\n            (self.handle, 'coil_sensitivity_maps', csm.handle))\n    def norm(self, num_iter=2, verb=0):\n        '''Computes the norm of the forward projection operator.\n        '''\n        assert self.handle is not None\n        handle = pygadgetron.cGT_acquisitionModelNorm(self.handle, num_iter, verb)\n        check_status(handle)\n        r = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return r;\n    def forward(self, image):\n        '''\n        Projects an image into (simulated) acquisitions space.\n        The resulting acquisition data simulates the actual data\n        expected to be received from the scanner.\n        image: ImageData\n        '''\n        assert_validity(image, ImageData)\n        ad = AcquisitionData()\n        ad.handle = pygadgetron.cGT_AcquisitionModelForward\\\n            (self.handle, image.handle)\n        check_status(ad.handle)\n        return ad;\n    def backward(self, ad):\n        '''\n        Back-projects acquisition data into image space using a complex\n        transpose of the forward projection.\n        ad: AcquisitionData\n        '''\n        assert_validity(ad, AcquisitionData)\n        image = ImageData()\n        image.handle = pygadgetron.cGT_AcquisitionModelBackward\\\n            (self.handle, ad.handle)\n        check_status(image.handle)\n        return image\n    def inverse(self, ad, dcw=None):\n        '''\n        Weights acquisition data with k-space density prior to back-projection\n        into image space using a complex transpose of the forward projection.\n        ad: AcquisitionData\n        dcw: AcquisitionData\n        '''\n        assert_validity(ad, AcquisitionData)\n        \n        if dcw is not None:\n            assert_validity(dcw, AcquisitionData)\n            if ad.shape != dcw.shape:\n                raise AssertionError(\"The shape of the density weights and the acquisition data must be the same.\")\n\n        if dcw is None:\n            dcw = compute_kspace_density(ad)\n            \n        ad = ad * dcw\n\n        image = ImageData()\n        image.handle = pygadgetron.cGT_AcquisitionModelBackward\\\n            (self.handle, ad.handle)\n        check_status(image.handle)\n        return image\n\n    def direct(self, image, out = None):\n        '''Alias of forward\n\n           Added for CCPi CIL compatibility\n           https://github.com/CCPPETMR/SIRF/pull/237#issuecomment-439894266\n        '''\n        if out is not None:\n            #raise error('out is not supported')\n            tmp = self.forward(image)\n            out.fill(tmp)\n            return\n        return self.forward(image)\n    def adjoint(self, ad , out = None):\n        '''Alias of backward\n\n           Added for CCPi CIL compatibility\n           https://github.com/CCPPETMR/SIRF/pull/237#issuecomment-439894266\n        '''\n        if out is not None:\n            #raise error('out is not supported')\n            tmp = self.backward(ad)\n            out.fill(tmp)\n            return\n        return self.backward(ad)\n    def is_affine(self):\n        '''Returns if the acquisition model is affine (i.e. corresponding to A*x+b)'''\n        return True\n    def is_linear(self):\n        '''Returns whether the acquisition model is linear (i.e. corresponding to A*x, with zero background term)'''\n        return True\n\n    def range_geometry(self):\n        '''Returns the template of AcquisitionData'''\n        geom = AcquisitionData()\n        geom.handle = pygadgetron.cGT_parameter(\n            self.handle, 'AcquisitionModel', 'range geometry')\n        check_status(geom.handle)\n        return geom\n\n    def domain_geometry(self):\n        '''Returns the template of ImageData'''\n        geom = ImageData()\n        geom.handle = pygadgetron.cGT_parameter(\n            self.handle, 'AcquisitionModel', 'domain geometry')\n        check_status(geom.handle)\n        return geom",
  "class Gadget(object):\n    '''\n    Class for Gadgetron gadgets.\n    '''\n    def __init__(self, name):\n        '''\n        Creates a gadget of specified type and properties.\n        name: a string of the form gadget_type(property1=value1, ...)\n        '''\n        self.handle = None\n        name, prop = name_and_parameters(name)\n        self.handle = pygadgetron.cGT_newObject(name)\n        check_status(self.handle)\n        if prop is not None:\n            self.set_properties(prop)\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def set_property(self, prop, value):\n        '''\n        Assigns specified value to specified gadget property.\n        prop : property name (string)\n        value: property value (string)\n        '''\n        try_calling(pygadgetron.cGT_setGadgetProperty(self.handle, prop, value))\n    def set_properties(self, prop):\n        '''\n        Assigns specified values to specified gadget properties.\n        prop: a string with comma-separated list of property value assignments\n              prop_name=prop_value\n        '''\n        try_calling(pygadgetron.cGT_setGadgetProperties(self.handle, prop))\n    def value_of(self, prop):\n        '''\n        Returns the string representation of the value of specified property.\n        prop: property name (string)\n        '''\n        return parms.char_par(self.handle, 'gadget', prop)",
  "class GadgetChain(object):\n    '''\n    Class for Gadgetron chains.\n    '''\n    def __init__(self):\n        self.handle = pygadgetron.cGT_newObject('GadgetChain')\n        check_status(self.handle)\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n##    def add_reader(self, id, reader):\n##        '''\n##        Adds reader gadget (a gadget that receives data from the client) to the\n##        chain.\n##        id    : gadget id (string)\n##        reader: Gadget of reader type\n##        '''\n##        assert isinstance(reader, Gadget)\n##        try_calling(pygadgetron.cGT_addReader(self.handle, id, reader.handle))\n##    def add_writer(self, id, writer):\n##        '''\n##        Adds writer gadget (a gadget that sends data to the client) to the\n##        chain.\n##        id    : gadget id (string)\n##        writer: Gadget of writer type\n##        '''\n##        assert isinstance(writer, Gadget)\n##        try_calling(pygadgetron.cGT_addWriter(self.handle, id, writer.handle))\n    def set_host(self, host):\n        '''\n        Sets Gadgetron server host.\n        host : host name (string)\n        '''\n        try_calling(pygadgetron.cGT_setHost(self.handle, host))\n    def set_port(self, port):\n        '''\n        Sets Gadgetron server port.\n        port : port number (as a string)\n        '''\n        try_calling(pygadgetron.cGT_setPort(self.handle, port))\n    def add_gadget(self, id, gadget):\n        '''\n        Adds a gadget to the chain.\n        id    : gadget id (string)\n        writer: Gadget\n        '''\n        assert isinstance(gadget, Gadget)\n        try_calling(pygadgetron.cGT_addGadget(self.handle, id, gadget.handle))\n    def set_gadget_property(self, id, prop, value):\n        '''\n        Assigns specified value to specified gadget property.\n        id   : gadget id\n        prop : property name (string)\n        value: property value (string)\n        '''\n        if type(value) == type('abc'):\n            v = value\n        else:\n            v = repr(value).lower()\n        hg = parms.parameter_handle(self.handle, 'gadget_chain', id)\n        try_calling(pygadgetron.cGT_setGadgetProperty(hg, prop, v))\n        pyiutil.deleteDataHandle(hg)\n    def value_of_gadget_property(self, id, prop):\n        '''\n        Returns the string representation of the value of specified property.\n        id  : gadget id\n        prop: property name (string)\n        '''\n        hg = parms.parameter_handle(self.handle, 'gadget_chain', id)\n        hv = parms.parameter_handle(hg, 'gadget', prop)\n        value = pyiutil.charDataFromHandle(hv)\n        pyiutil.deleteDataHandle(hg)\n        pyiutil.deleteDataHandle(hv)\n        return value",
  "class Reconstructor(GadgetChain):\n    '''\n    Class for a chain of gadgets that has AcquisitionData on input and\n    ImageData on output.\n    '''\n    def __init__(self, list=None):\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject('ImagesReconstructor')\n        check_status(self.handle)\n        self.input_data = None\n        self.dcm_prefix = \"\"\n        if list is None:\n            return\n        for i in range(len(list)):\n            label, name = label_and_name(list[i])\n            self.add_gadget(label, Gadget(name))\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def set_input(self, input_data):\n        '''\n        Sets the input.\n        input_data: AcquisitionData\n        '''\n        assert isinstance(input_data, AcquisitionData)\n        self.input_data = input_data\n    def set_dcm_prefix(self, dcm_prefix):\n        self.dcm_prefix = dcm_prefix\n    def process(self):\n        '''\n        Processes the input with the gadget chain.\n        dcm_prefix: Python text string.\n        If dcm_prefix is not \"\", the reconstructed images are written to\n        files <dcm_prefix>_<image number>.dcm.\n        Otherwise, they are stored in memory and can be retrieved by\n        get_output().\n        '''\n        if self.input_data is None:\n            raise error('no input data')\n        try_calling(pygadgetron.cGT_reconstructImages\\\n             (self.handle, self.input_data.handle, self.dcm_prefix))\n    def get_output(self, subset = None):\n        '''\n        Returns specified subset of the output ImageData. If no subset is\n        specified, returns all output.\n        subset: the name of the subset (e.g. images, gfactors,...)\n        '''\n        output = ImageData()\n        output.handle = pygadgetron.cGT_reconstructedImages(self.handle)\n        check_status(output.handle)\n        if subset is None:\n            return output\n        else:\n            return output.select('GADGETRON_DataRole', subset)\n    def reconstruct(self, input_data):\n        '''\n        Returns the output from the chain for specified input.\n        input_data: AcquisitionData\n        '''\n        assert_validity(input_data, AcquisitionData)\n        handle = pygadgetron.cGT_reconstructImages\\\n             (self.handle, input_data.handle, self.dcm_prefix)\n        check_status(handle)\n        pyiutil.deleteDataHandle(handle)\n        images = ImageData()\n        images.handle = pygadgetron.cGT_reconstructedImages(self.handle)\n        check_status(images.handle)\n        return images",
  "class ImageDataProcessor(GadgetChain):\n    '''\n    Class for a chain of gadgets that has ImageData on input and output.\n    '''\n    def __init__(self, list = None):\n        '''\n        Creates an image processor specified by a list of gadgets.\n        list: Python list of gadget description strings, each gadget\n              description being a string of the form\n                '[label:]gadget_name[(property1=value1[,...])]'\n              (square brackets embrace optional items, ... stands for etc.)\n        '''\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject('ImagesProcessor')\n        check_status(self.handle)\n        # TODO: handle input and output in cSTIR\n        self.input_data = None\n        self.output_data = None\n        if list is None:\n            return\n        for i in range(len(list)):\n            label, name = label_and_name(list[i])\n            self.add_gadget(label, Gadget(name))\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def set_input(self, input_data):\n        '''\n        Sets the input data.\n        '''\n        assert isinstance(input_data, ImageData)\n        self.input_data = input_data\n    def process(self, input_data = None):\n        '''\n        Returns the output from the chain.\n        input_data: ImageData\n        '''\n        if input_data is not None:\n            self.set_input(input_data)\n        if self.input_data is None:\n            raise error('input data not set')\n        assert_validity(self.input_data, ImageData)\n        image = ImageData()\n        image.handle = pygadgetron.cGT_processImages\\\n             (self.handle, self.input_data.handle)\n        check_status(image.handle)\n        self.output_data = image\n        return image\n    def get_output(self):\n        '''\n        Returns the output data.\n        '''\n        return self.output_data",
  "class AcquisitionDataProcessor(GadgetChain):\n    '''\n    Class for a chain of gadgets that has AcquisitionData on input and output.\n    '''\n    def __init__(self, list = None):\n        '''\n        Creates an acquisition processor specified by a list of gadgets.\n        list: Python list of gadget description strings, each gadget\n              description being a string of the form\n                '[label:]gadget_name[(property1=value1[,...])]'\n              (square brackets embrace optional items, ... stands for etc.)\n        '''\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject('AcquisitionsProcessor')\n        check_status(self.handle)\n        self.input_data = None\n        self.output_data = None\n        if list is None:\n            return\n        for i in range(len(list)):\n            label, name = label_and_name(list[i])\n            self.add_gadget(label, Gadget(name))\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def set_input(self, input_data):\n        '''\n        Sets the input data.\n        '''\n        assert isinstance(input_data, AcquisitionData)\n        self.input_data = input_data\n    def process(self, input_data = None):\n        '''\n        Returns the output from the chain for specified input.\n        input_data: AcquisitionData\n        '''\n        if input_data is not None:\n            self.set_input(input_data)\n        if self.input_data is None:\n            raise error('input data not set')\n        assert_validity(self.input_data, AcquisitionData)\n        acquisitions = AcquisitionData()\n        acquisitions.handle = pygadgetron.cGT_processAcquisitions\\\n             (self.handle, self.input_data.handle)\n        check_status(acquisitions.handle)\n        self.output_data = acquisitions\n        return acquisitions\n    def get_output(self):\n        '''\n        Returns the output data.\n        '''\n        return self.output_data",
  "class FullySampledReconstructor(Reconstructor):\n    '''\n    Class for a reconstructor from fully sampled Cartesian raw data.\n    '''\n    def __init__(self):\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject('SimpleReconstructionprocessor')\n        check_status(self.handle)\n        self.input_data = None\n        self.dcm_prefix = \"\"\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "class CartesianGRAPPAReconstructor(Reconstructor):\n    '''\n    Class for a reconstructor from undersampled Cartesian raw data.\n    '''\n    def __init__(self):\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject\\\n            ('SimpleGRAPPAReconstructionprocessor')\n        check_status(self.handle)\n        self.input_data = None\n        self.dcm_prefix = \"\"\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def compute_gfactors(self, flag):\n        self.set_gadget_property('gadget4', 'send_out_gfactor', flag)",
  "def preprocess_acquisition_data(input_data):\n    '''\n    Acquisition processor function that adjusts noise and asymmetric echo and\n    removes readout oversampling.\n    '''\n    assert_validity(input_data, AcquisitionData)\n    return input_data.process(\\\n        ['NoiseAdjustGadget', \\\n         'AsymmetricEchoAdjustROGadget', \\\n         'RemoveROOversamplingGadget'])",
  "def set_grpe_trajectory(ad, traj=None):\n    '''\n    Function that fills the trajectory of AcquisitionData with golden angle radial\n    phase encoding trajectory (traj=None) or fills in a precalculated RPE trajectory.\n    ad: AcquisitionData\n    '''\n    assert_validity(ad, AcquisitionData)\n\n    if traj is None:\n        try_calling(pygadgetron.cGT_setGRPETrajectory(ad.handle))\n    else:\n        ad = set_data_trajectory(ad, traj, 'rpe')\n    return ad",
  "def set_radial2D_trajectory(ad, traj=None):\n    '''\n    Function that fills the trajectory of AcquisitionData with linear increment 2D radial\n    readout trajectory (traj=None) or fills in a precalculated radial trajectory.\n    ad: AcquisitionData\n    '''\n    assert_validity(ad, AcquisitionData)\n\n    if traj is None:\n        try_calling(pygadgetron.cGT_setRadial2DTrajectory(ad.handle))\n    else:\n        ad = set_data_trajectory(ad, traj, 'radial')\n    return ad",
  "def set_goldenangle2D_trajectory(ad, traj=None):\n    '''\n    Function that fills the trajectory of AcquisitionData with golden angle increment 2D radial\n    readout trajectory (traj=None) or fills in a precalculated radial trajectory.\n    ad: AcquisitionData\n    '''\n    assert_validity(ad, AcquisitionData)\n\n    if traj is None:\n        try_calling(pygadgetron.cGT_setGoldenAngle2DTrajectory(ad.handle))\n    else:\n        ad = set_data_trajectory(ad, traj, 'goldenangle')\n    return ad",
  "def set_spiral2D_trajectory(ad, traj):\n    '''\n    Function that fills in a precalculated spiral trajectory\n    '''\n    if traj is None:\n        raise NotImplementedError(\"Spiral trajectories cannot be calculated but need to be provided by you.\")\n    else:\n        return(set_data_trajectory(ad, traj, 'spiral'))",
  "def set_data_trajectory(ad, traj, traj_type_str):\n    '''\n    Function that sets the trajectory of AcquisitionData with traj.\n    ad: AcquisitionData\n    traj: k-space trajectory as numpy array\n    traj_type_str: String identifying trajectory type\n                    Possible choices are:\n                            - radial\n                            - goldenangle\n                            - spiral\n                            - rpe\n    '''\n    assert_validity(ad, AcquisitionData)\n    if isinstance(traj, numpy.ndarray):\n\n        # Check trajectory type\n        supported_traj = ['radial', 'goldenangle', 'spiral', 'rpe']\n        if traj_type_str not in supported_traj:\n            raise error(\"Trajectory type {} cannot be set. Only {} can be set.\".format(traj_type_str, supported_traj))\n        \n        # Check dimensions of trajectory\n        dims = ad.dimensions()\n        if traj_type_str == 'radial' or traj_type_str == 'goldenangle' or traj_type_str == 'spiral':\n            traj_dim = int(2)\n            expected_traj_shape = (dims[0], dims[2], traj_dim)\n        elif traj_type_str == 'rpe':\n            traj_dim = int(3)\n            expected_traj_shape = (dims[0], traj_dim)\n        if traj.shape != expected_traj_shape:\n            raise AssertionError(\"Pass the {} trajectory in the shape {}. You gave a shape of {}\".format(traj_type_str, expected_traj_shape, traj.shape))\n\n        if traj_type_str == 'rpe':\n            # Same phase encoding trajectory for each readout\n            traj = numpy.tile(traj[:, numpy.newaxis, :], (1, dims[2], 1))\n            \n        traj = numpy.array(traj, numpy.float32)\n        convert = not traj.flags['C_CONTIGUOUS']\n        if convert:\n            traj = numpy.ascontiguousarray(traj)\n        pygadgetron.cGT_setDataTrajectory(ad.handle, traj_dim, traj.ctypes.data)\n        \n        return(ad)\n    else:\n        raise error('Trajectory should be numpy array. Got {}'.format(type(traj)))",
  "def get_data_trajectory(ad):\n    '''\n    Function that gets the trajectory of AcquisitionData depending on the rawdata trajectory.\n    ad: AcquisitionData\n    '''\n    assert_validity(ad, AcquisitionData)\n    \n    if ad.check_traj_type('cartesian'):\n        num_traj_pts = ad.number()\n        traj_dim = 2\n    elif ad.check_traj_type('other'):\n        num_traj_pts = ad.number()\n        traj_dim = 3\n    elif ad.check_traj_type('radial') or ad.check_traj_type('goldenangle') or ad.check_traj_type('spiral') :\n        num_traj_pts = ad.number() * ad.dimensions()[2]\n        traj_dim = 2\n        \n    dims = (num_traj_pts, traj_dim)\n    traj = numpy.ndarray(dims, dtype = numpy.float32)\n    \n    try_calling(pygadgetron.cGT_getDataTrajectory(ad.handle, traj.ctypes.data))\n    \n    return traj",
  "def compute_kspace_density(ad):\n    '''\n    Function that computes the kspace density depending the\n    ad: AcquisitionData\n    '''\n    assert_validity(ad, AcquisitionData)\n\n    if ad.check_traj_type('cartesian'):\n        return calc_cartesian_dcw(ad)\n    elif ad.check_traj_type('other'):\n        return calc_rpe_dcw(ad)\n    elif ad.check_traj_type('radial') or ad.check_traj_type('goldenangle'):\n        return calc_radial_dcw(ad)\n    elif ad.check_traj_type('spiral'):\n        raise NotImplementedError(\"Spiral density can not be computed yet. Potentially compute it externally and pass it as an argument where it is required.\")\n    else:\n        raise AssertionError(\"Please only try to recon trajectory types cartesian, radial, goldenangle, spiral or other\")",
  "def calc_cartesian_dcw(ad):\n    '''\n    Function that computes the kspace weight for a cartesian acquisition by\n    averaging out phase encoding points that were acquired multiple times.\n    ad: AcquisitionData\n    '''\n    traj = numpy.transpose(get_data_trajectory(ad))\n    traj, inverse, counts = numpy.unique(traj, return_inverse=True, return_counts=True, axis=1)\n    \n    density_weight = (1.0 / counts)[inverse]\n    \n    density_weight = numpy.expand_dims(density_weight, axis=1)\n    density_weight = numpy.expand_dims(density_weight, axis=2)\n    density_weight = numpy.tile(density_weight, (1, ad.shape[1], ad.shape[2]))\n    \n    dcw = ad.copy()\n    dcw.fill(density_weight)\n    \n    return dcw",
  "def calc_rpe_dcw(ad):\n    '''\n    Function that computes the kspace weight depending on the distance to the center\n    as in a filtered back-projection. Strictly valid only for equally angular-spaced\n    radially distributed points\n    ad: AcquisitionData\n    '''\n\n    traj = numpy.transpose(get_data_trajectory(ad))\n    traj = traj[1:3,:]\n    ramp_filter = numpy.linalg.norm(traj, axis=0)\n\n    traj, inverse, counts = numpy.unique(traj, return_inverse=True, return_counts=True, axis=1)\n    \n    num_angles = numpy.max(counts)\n    \n    density_weight = ( 1.0 / counts)[inverse]  + num_angles * ramp_filter\n    \n    max_traj_rad = numpy.max(numpy.linalg.norm(traj, axis=0))\n    density_weight_norm =  numpy.sum(density_weight) / (max_traj_rad**2 * numpy.pi)\n    density_weight = density_weight / density_weight_norm\n\n#    density_weight = numpy.expand_dims(density_weight, axis=(1,2))\n    density_weight = numpy.expand_dims(density_weight, axis=1)\n    density_weight = numpy.expand_dims(density_weight, axis=2)\n    density_weight = numpy.tile(density_weight, (1, ad.shape[1], ad.shape[2]))\n    \n    dcw = ad.copy()\n    dcw.fill(density_weight)\n    \n    return dcw",
  "def calc_radial_dcw(ad):\n    '''\n    Function that computes the kspace weight depending on the distance to the center\n    as in a filtered back-projection. Stricly valid only for equally angular-spaced\n    radially distributed points\n    ad: AcquisitionData\n    '''\n\n    traj = numpy.transpose(get_data_trajectory(ad))\n    (na, nc, ns) = ad.dimensions()\n  \n    ramp_filter = numpy.linalg.norm(traj, axis=0)\n    traj, inverse, counts = numpy.unique(traj, return_inverse=True, return_counts=True, axis=1)\n    num_angles = numpy.max(counts)\n    \n    density_weight = ( 1.0 / counts)[inverse]  + num_angles * ramp_filter\n    \n    max_traj_rad = numpy.max(numpy.linalg.norm(traj, axis=0))\n    density_weight_norm =  numpy.sum(density_weight) / (max_traj_rad**2 * numpy.pi)\n    density_weight = density_weight / density_weight_norm\n\n    density_weight = numpy.transpose(density_weight)\n#    density_weight = numpy.expand_dims(density_weight, axis=(1,2))\n    density_weight = numpy.expand_dims(density_weight, axis=1)\n    density_weight = numpy.expand_dims(density_weight, axis=2)\n    density_weight = numpy.reshape(density_weight, (na, 1, ns))\n    density_weight = numpy.tile(density_weight, (1, nc, 1))\n    \n    dcw = ad.copy()\n    dcw.fill(density_weight)\n    \n    return dcw",
  "def __init__(self, image_data = None, image_num = 0):\n        self.handle = None\n        if image_data is not None:\n            self.handle = pygadgetron.cGT_imageWrapFromContainer \\\n                          (image_data.handle, image_num)\n            check_status(self.handle)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def is_real(self):\n        assert self.handle is not None\n        t = self.data_type()\n        return t is not ISMRMRD_CXFLOAT and t is not ISMRMRD_CXDOUBLE",
  "def version(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'version')",
  "def flags(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'flags')",
  "def data_type(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'data_type')",
  "def measurement_uid(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'measurement_uid')",
  "def channels(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'channels')",
  "def average(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'average')",
  "def slice(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'slice')",
  "def contrast(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'contrast')",
  "def phase(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'phase')",
  "def repetition(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'repetition')",
  "def set(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'set')",
  "def acquisition_time_stamp(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'acquisition_time_stamp')",
  "def image_type(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'image_type')",
  "def image_index(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'image_index')",
  "def image_series_index(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'image_series_index')",
  "def attribute_string_len(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'image', 'attribute_string_len')",
  "def matrix_size(self):\n        assert self.handle is not None\n        return parms.uint16_pars(self.handle, 'image', 'matrix_size', 3)[::-1]",
  "def physiology_time_stamp(self):\n        assert self.handle is not None\n        return parms.uint32_pars(self.handle, 'image', 'physiology_time_stamp', 3)",
  "def field_of_view(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'image', 'field_of_view', 3)",
  "def position(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'image', 'position', 3)",
  "def read_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'image', 'read_dir', 3)",
  "def phase_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'image', 'phase_dir', 3)",
  "def slice_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'image', 'slice_dir', 3)",
  "def patient_table_position(self):\n        assert self.handle is not None\n        #return parms.float_pars \\\n        return parms.float_pars \\\n               (self.handle, 'image', 'patient_table_position', 3)",
  "def info(self, method):\n        return eval('self.' + method + '()')",
  "def __init__(self, file = None):\n        self.handle = None\n        if file is None:\n            return\n        self.handle = pygadgetron.cGT_readImages(file)\n        check_status(self.handle)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def same_object(self):\n        return ImageData()",
  "def real_abs(self, out=None):\n        ''' WARNING: this method produces images of type different from that\n            of self.\n        '''\n        if out is None:\n            images = ImageData()\n        else:\n            images = out\n        images.handle = pygadgetron.cGT_realImageData(self.handle, 'abs')\n        check_status(images.handle)\n        if out is None:\n            return images",
  "def real(self):\n        ''' WARNING: this method produces images of type different from that\n            of self.\n        '''\n        images = ImageData()\n        images.handle = pygadgetron.cGT_realImageData(self.handle, 'real')\n        check_status(images.handle)\n        return images",
  "def read_from_file(self, file):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pygadgetron.cGT_readImages(file)\n        check_status(self.handle)",
  "def from_acquisition_data(self, ad):\n        assert isinstance(ad, AcquisitionData), \"Please pass a AcquisitionData object\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pygadgetron.cGT_ImageFromAcquisitiondata(ad.handle)\n        check_status(self.handle)",
  "def data_type(self, im_num):\n        '''\n        Returns the data type for a specified image (see 8 data types above).\n        im_num: image (slice)\n        '''\n        assert self.handle is not None\n        handle = pygadgetron.cGT_imageDataType(self.handle, im_num)\n        check_status(handle)\n        n = pyiutil.intDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return n",
  "def set_ISMRMRD_image_type(self, imtype):\n        assert self.handle is not None\n        try_calling(pygadgetron.cGT_setImageType(self.handle, imtype))",
  "def is_real(self):\n        assert self.handle is not None\n        t = self.data_type(0)\n        return t is not ISMRMRD_CXFLOAT and t is not ISMRMRD_CXDOUBLE",
  "def process(self, list):\n        '''\n        Returns processed self with an image processor specified by\n        a list of gadgets.\n        list: Python list of gadget description strings, each gadget\n              description being a string of the form\n                '[label:]gadget_name[(property1=value1[,...])]'\n              (square brackets embrace optional items, ... stands for etc.)\n        '''\n        assert self.handle is not None\n        ip = ImageDataProcessor(list)\n        return ip.process(self)",
  "def image(self, im_num):\n        return Image(self, im_num)",
  "def select(self, attr, value):\n        '''\n        Creates an images container with images from self with the specified\n        value of specified attribute.\n        attr : the name of the attribute (Python string)\n        value: the value of the attribute (Python string)\n        '''\n        assert self.handle is not None\n        images = ImageData()\n        images.handle = pygadgetron.cGT_selectImages(self.handle, attr, value)\n        check_status(images.handle)\n        return images",
  "def get_ISMRMRD_info(self, par):\n        '''\n        Returns the array of values of the specified image information\n        parameter. Parameters names are the same as the names of sirf.Gadgetron.Image class\n        public methods (except is_real and info).\n\n        par: parameter name (as a string)\n\n        Examples:\n\n        # to get information on the timing:\n        slice = image.get_ISMRMRD_info('acquisition_time_stamp')\n\n        # to get the unit vector orthogonal to the slice and directed\n        # to the next slice (in ISMRMRD coordinate system):\n        slice_dir = image.get_ISMRMRD_info('slice_dir')\n        '''\n        ni = self.number()\n        info = numpy.empty((ni,), dtype = object)\n        for i in range(ni):\n            image = self.image(i)\n            info[i] = image.info(par)\n        return info",
  "def get_info(self, par):\n        return self.get_ISMRMRD_info(par)",
  "def fill(self, data):\n        '''\n        Fills self's image data with specified values.\n        data: Python Numpy array or ImageData\n        '''\n        assert self.handle is not None\n        \n        if isinstance(data, ImageData):\n            return super(ImageData, self).fill(data)\n        \n        if isinstance(data, numpy.ndarray):\n            dims = self.dimensions()\n            shape = data.shape\n            if numpy.prod(shape) != numpy.prod(dims):\n                msg = 'cannot fill ImageData of size %s with data of size %s'\n                raise ValueError(msg % (repr(dims), repr(shape)))\n\n            nc, nz, ny, nx = dims if len(dims) > 3 else (1,) + dims\n            ns = self.number() # number of total dynamics (slices, contrasts, etc.)\n            nz = nz//ns        # z-dimension of a slice\n            data = numpy.reshape(data, (nc, ns, nz, ny, nx))\n            data = numpy.swapaxes(data, 0, 1)\n            the_data = data\n            if self.is_real():\n                if data.dtype != numpy.float32:\n                    the_data = data.astype(numpy.float32)\n            else:\n                if data.dtype != numpy.complex64:\n                    the_data = data.astype(numpy.complex64)\n            convert = not data.flags['C_CONTIGUOUS']\n            if convert:\n                the_data = numpy.ascontiguousarray(the_data)\n            if self.is_real():\n                try_calling(pygadgetron.cGT_setImageDataFromFloatArray\\\n                    (self.handle, the_data.ctypes.data))\n            else:\n                try_calling(pygadgetron.cGT_setImageDataFromCmplxArray\\\n                    (self.handle, the_data.ctypes.data))\n        elif isinstance (data, Complex):\n            arr = data + numpy.zeros(self.shape, dtype=numpy.complex64)\n            return self.fill(arr)\n        elif isinstance (data, Number):\n            arr = data + numpy.zeros(self.shape, dtype=numpy.float32)\n            return self.fill(arr)\n        else:\n            raise error('wrong fill value.' + \\\n                        ' Should be ImageData, numpy.ndarray or number. Got {}'.format(type(data)))\n        return self",
  "def dimensions(self):\n        '''\n        Returns the dimensions of 3D/4D Numpy ndarray of all self's images.\n        '''\n        if self.number() < 1:\n            return 0\n        assert self.handle is not None\n        dim = numpy.ndarray((4,), dtype=cpp_int_dtype())\n        image = Image(self)\n        pygadgetron.cGT_getImageDim(image.handle, dim.ctypes.data)\n        nx = dim[0]\n        ny = dim[1]\n        nz = dim[2]\n        nc = dim[3]\n        \n        nz = nz*self.number()\n        \n        if nc == 1: # for backward compatibility\n            return nz, ny, nx\n        else:\n            return nc, nz, ny, nx",
  "def as_array(self):\n        '''\n        Returns all self's images as a 3D or 4D Numpy ndarray.\n        '''\n        dims = self.dimensions()\n        \n        assert self.handle is not None\n        if self.number() < 1:\n            return numpy.ndarray((0,), dtype = numpy.float32)\n        if self.is_real():\n            array = numpy.ndarray(dims, dtype = numpy.float32)\n            try_calling(pygadgetron.cGT_getImageDataAsFloatArray\\\n                (self.handle, array.ctypes.data))\n        else:\n            array = numpy.ndarray(dims, dtype = numpy.complex64)\n            try_calling(pygadgetron.cGT_getImageDataAsCmplxArray\\\n                (self.handle, array.ctypes.data))\n                \n        if len(dims) != 4:\n            return array\n\n        nc, nz, ny, nx = dims\n        ns = self.number() # number of total dynamics (slices, contrasts, etc.)\n        nz = nz//ns        # z-dimension of a slice\n\n        # hope Numpy is clever enough to do all this in-place:\n        array = numpy.reshape(array, (ns, nc, nz, ny, nx))\n        array = numpy.swapaxes(array, 0, 1)\n        array = numpy.reshape(array, (nc, ns*nz, ny, nx))\n\n        return array",
  "def copy(self):\n        '''alias of clone'''\n        return self.clone()",
  "def show(self, zyx=None, slice=None, title=None, cmap='gray', postpone=False):\n        '''Displays xy-cross-section(s) of images.'''\n        assert self.handle is not None\n        if not HAVE_PYLAB:\n            print('pylab not found')\n            return\n        data = self.as_array()\n        nz = data.shape[0]\n        if isinstance(slice, (Integral,numpy.integer)):\n            if slice < 0 or slice >= nz:\n                return\n            ni = 1\n            slice = [slice]\n        elif slice is None:\n            ni = nz\n            slice = range(nz)\n        else:\n            try:\n                ni = len(slice)\n            except:\n                raise error('wrong slice list')\n        if title is None:\n            title = 'Selected images'\n        if ni >= 16:\n            tiles = (4, 4)\n        else:\n            tiles = None\n        f = 0\n        while f < ni:\n            t = min(f + 16, ni)\n            err = show_3D_array(abs(data), index=slice[f : t], \\\n                                tile_shape=tiles, cmap=cmap, \\\n                                zyx=zyx, label='image', \\\n                                xlabel='samples', ylabel='readouts', \\\n                                suptitle=title, \\\n                                show=(t == ni) and not postpone)\n            f = t",
  "def allocate(self, value=0, **kwargs):\n        '''Method to allocate an ImageData and set its values\n        \n        CIL/SIRF compatibility\n        '''\n        if value in ['random', 'random_int']:\n            out = self.clone()\n            shape = out.as_array().shape\n            seed = kwargs.get('seed', None)\n            if seed is not None:\n                numpy.random.seed(seed)\n            if value == 'random':\n                out.fill(numpy.random.random_sample(shape))\n            elif value == 'random_int':\n                max_value = kwargs.get('max_value', 100)\n                out.fill(numpy.random.randint(max_value,size=shape))\n        else:\n            out = self.clone()\n            tmp = value * numpy.ones(out.as_array().shape)\n            out.fill(tmp)\n        return out",
  "def print_header(self, im_num):\n        \"\"\"Print the header of one of the images. zero based.\"\"\"\n        try_calling(pygadgetron.cGT_print_header(self.handle, im_num))",
  "def shape(self):\n        return self.dimensions()",
  "def __init__(self):\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject('CoilImages')",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def same_object(self):\n        return CoilImagesData()",
  "def calculate(self, acq):\n        dcw = compute_kspace_density(acq)\n        acq = acq * dcw\n        try_calling(pygadgetron.cGT_computeCoilImages(self.handle, acq.handle))",
  "def __init__(self):\n        self.handle = None\n        self.smoothness = 0",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def same_object(self):\n        return CoilSensitivityData()",
  "def read(self, file):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pygadgetron.cGT_CoilSensitivities(file)\n        check_status(self.handle)",
  "def calculate(self, data, method=None):\n        '''\n        Calculates coil sensitivity maps from coil images or sorted\n        acquisitions.\n        data  : either AcquisitionData or CoilImages\n        method: either SRSS (Square Root of the Sum of Squares, default) or\n                Inati\n        '''\n        if isinstance(data, AcquisitionData):\n            if data.is_sorted() is False:\n                print('WARNING: acquisitions may be in a wrong order')\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pygadgetron.cGT_CoilSensitivities('')\n        check_status(self.handle)\n        nit = self.smoothness\n        \n        if method is not None:\n            method_name, parm_list = name_and_parameters(method)\n            parm = parse_arglist(parm_list)\n            if 'niter' in parm:\n                nit = int(parm['niter'])\n        else:\n            method_name = 'SRSS'\n            parm = {}\n        \n        parms.set_int_par(self.handle, 'coil_sensitivity', 'smoothness', nit)\n\n        if isinstance(data, AcquisitionData):\n            self.__calc_from_acquisitions(data, method_name)\n        elif isinstance(data, CoilImagesData):\n            self.__calc_from_images(data, method_name)\n        else:\n            raise error('Cannot calculate coil sensitivities from %s' % \\\n                        repr(type(data)))",
  "def __calc_from_acquisitions(self, data, method_name):\n\n        if data.handle is None:\n            raise AssertionError(\"The handle for data is None. Please pass valid acquisition data.\")\n\n        dcw = compute_kspace_density(data)\n\n        data = data * dcw\n        if method_name == 'Inati':\n\n            try:\n                from ismrmrdtools import coils\n            except:\n                raise error('Inati method requires ismrmrd-python-tools')\n\n            cis = CoilImagesData()\n            try_calling(pygadgetron.cGT_computeCoilImages(cis.handle, data.handle))\n            cis_array = cis.as_array()\n            csm, _ = coils.calculate_csm_inati_iter(cis_array)\n\n            if self.handle is not None:\n                pyiutil.deleteDataHandle(self.handle)\n            self.handle = pysirf.cSIRF_clone(cis.handle)\n\n            self.fill(csm.astype(numpy.complex64))\n        \n        elif method_name == 'SRSS':\n            try_calling(pygadgetron.cGT_computeCoilSensitivities(self.handle, data.handle))",
  "def __calc_from_images(self, data, method_name):\n\n        if data.handle is None:\n            raise AssertionError(\"The handle for data is None. Please pass valid image data.\")\n\n        if method_name == 'Inati':\n\n            try:\n                from ismrmrdtools import coils\n            except:\n                raise error('Inati method requires ismrmrd-python-tools')\n                \n            cis_array = data.as_array()\n            csm, _ = coils.calculate_csm_inati_iter(cis_array)\n\n            if self.handle is not None:\n                pyiutil.deleteDataHandle(self.handle)\n            self.handle = pysirf.cSIRF_clone(data.handle)\n\n            self.fill(csm.astype(numpy.complex64))\n\n        elif method_name == 'SRSS':\n\n            try_calling(pygadgetron.cGT_computeCoilSensitivitiesFromCoilImages \\\n                (self.handle, data.handle))\n\n        else:\n            raise error('Unknown method %s' % method_name)",
  "def __calc_from_acquisitions(self, data, method_name):\n        assert data.handle is not None\n        dcw = compute_kspace_density(data)\n        data = data * dcw\n        cis = CoilImagesData()\n        try_calling(pygadgetron.cGT_computeCoilImages(cis.handle, data.handle))\n        self.__calc_from_images(cis, method_name)",
  "def __init__(self, file = None):\n        self.handle = None",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def version(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'version')",
  "def flags(self):\n        '''\n        Returns acquisition flags as an integer (each bit corresponding to a\n        flag).\n        '''\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'flags')",
  "def measurement_uid(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'measurement_uid')",
  "def scan_counter(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'scan_counter')",
  "def acquisition_time_stamp(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'acquisition_time_stamp')",
  "def number_of_samples(self):\n        '''\n        returns the number of samples in the readout direction.\n        '''\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'number_of_samples')",
  "def available_channels(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'available_channels')",
  "def active_channels(self):\n        '''\n        Returns the number of active channels (coils).\n        '''\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'active_channels')",
  "def discard_pre(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'discard_pre')",
  "def discard_post(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'discard_post')",
  "def center_sample(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'center_sample')",
  "def encoding_space_ref(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'encoding_space_ref')",
  "def trajectory_dimensions(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'trajectory_dimensions')",
  "def kspace_encode_step_1(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_kspace_encode_step_1')",
  "def kspace_encode_step_2(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_kspace_encode_step_2')",
  "def average(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_average')",
  "def slice(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_slice')",
  "def contrast(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_contrast')",
  "def phase(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_phase')",
  "def repetition(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_repetition')",
  "def set(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_set')",
  "def segment(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisition', 'idx_segment')",
  "def physiology_time_stamp(self):\n        assert self.handle is not None\n        return parms.uint32_pars(self.handle, 'acquisition', 'physiology_time_stamp', 3)",
  "def channel_mask(self):\n        assert self.handle is not None\n        return parms.uint64_pars(self.handle, 'acquisition', 'channel_mask', 16)",
  "def sample_time_us(self):\n        assert self.handle is not None\n        return parms.float_par(self.handle, 'acquisition', 'sample_time_us')",
  "def position(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'acquisition', 'position', 3)",
  "def read_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'acquisition', 'read_dir', 3)",
  "def phase_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'acquisition', 'phase_dir', 3)",
  "def slice_dir(self):\n        assert self.handle is not None\n        return parms.float_pars(self.handle, 'acquisition', 'slice_dir', 3)",
  "def patient_table_position(self):\n        assert self.handle is not None\n        return parms.float_pars \\\n               (self.handle, 'acquisition', 'patient_table_position', 3)",
  "def info(self, method):\n        return eval('self.' + method + '()')",
  "def set_kspace_encode_step_1(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_kspace_encode_step_1', int(val))",
  "def set_kspace_encode_step_2(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_kspace_encode_step_2', int(val))",
  "def set_average(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_average', int(val))",
  "def set_slice(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_slice', int(val))",
  "def set_contrast(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_contrast', int(val))",
  "def set_phase(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_phase', int(val))",
  "def set_repetition(self, val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_repetition', val)",
  "def set_set(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_set', int(val))",
  "def set_segment(self,val):\n        assert self.handle is not None\n        return parms.set_int_par(self.handle, 'acquisition', 'idx_segment', int(val))",
  "def set_physiology_time_stamp(self,val,stampnum):\n        '''\n        Setter for acquisitions physiology time stamp.\n        input: \n            val: time in tics! (1 tic usually corresponds to 2.5ms for SIEMENS data).\n            stampnum: which physiology time stamp is set, 0, 1 or 2 (stampnum=0 corresponds to trigger delay).\n        '''\n        assert self.handle is not None\n        if stampnum <0 or stampnum >2:\n            raise AssertionError(f\"stampnum must be either 0, 1 or 2. You gave {stampnum}.\")\n        attribute = f\"physiology_time_stamp{stampnum}\"\n        return parms.set_int_par(self.handle, 'acquisition', attribute, int(val))",
  "def __init__(self, file=None, all_=False):\n        self.handle = None\n        self.sorted = False\n        self.info = None\n        if file is not None:\n            self.handle = pygadgetron.cGT_ISMRMRDAcquisitionsFromFile(file, 1*all_)\n            check_status(self.handle)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_storage_scheme(scheme):\n        '''Sets acquisition data storage scheme.'''\n        if scheme != 'memory':\n            msg = 'WARNING: storage scheme ' + repr(scheme) + ' not supported,'\n            msg += ' using memory storage scheme instead'\n            print(msg)",
  "def get_storage_scheme():\n        '''Returns acquisition data storage scheme.\n        '''\n        return 'memory'",
  "def same_object(self):\n        return AcquisitionData()",
  "def new_acquisition_data(self, empty=True):\n        new_ad = AcquisitionData()\n        if empty:\n            new_ad.handle = pygadgetron.cGT_createEmptyAcquisitionData(self.handle)\n        else:\n            new_ad.handle = pygadgetron.cGT_cloneAcquisitions(self.handle)\n        check_status(new_ad.handle)\n        return new_ad",
  "def number_of_readouts(self, select='image'):\n        if select == 'image':\n            dim = self.dimensions()\n            return dim[0]\n        else:\n            return self.number()",
  "def number_of_acquisitions(self, select='image'):\n        return self.number_of_readouts",
  "def check_traj_type(self, trajname):\n        '''\n        Checks if the data is of the trajectory type trajname.\n        trajname: string with trajectory name.\n        Possible choices are:\n            - cartesian\n            - radial\n            - epi\n            - goldenangle\n            - spiral\n            - other\n        '''\n        list_available_trajs = ('cartesian', 'epi', 'radial', 'goldenangle', 'spiral', 'other')\n        if trajname not in list_available_trajs:\n            raise AssertionError(\"The trajectory you asked for is not among the available trajectoryies\")\n\n        xml_hdr = self.get_header()\n        traj_id_substring = \"<trajectory>\"+trajname+\"</trajectory>\"\n\n        return traj_id_substring in xml_hdr",
  "def sort(self):\n        '''\n        Sorts acquisitions (currently, with respect to acquisition_time_stamp)\n        '''\n        assert self.handle is not None\n        try_calling(pygadgetron.cGT_sortAcquisitions(self.handle))\n        self.sorted = True",
  "def sort_by_time(self):\n        '''\n        Sorts acquisitions with respect to acquisition_time_stamp\n        '''\n        assert self.handle is not None\n        try_calling(pygadgetron.cGT_sortAcquisitionsByTime(self.handle))",
  "def is_sorted(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisitions', 'sorted')",
  "def is_undersampled(self):\n        assert self.handle is not None\n        return parms.int_par(self.handle, 'acquisitions', 'undersampled')",
  "def set_header(self, header):\n        assert self.handle is not None\n        try_calling(pygadgetron.cGT_setAcquisitionsInfo(self.handle, header))",
  "def set_encoding_limit(self, name:str, limit:tuple):\n        if len(limit)!=3:\n            raise AssertionError(\"Please give three values, min, max and ctr\")\n        try_calling(pygadgetron.cGT_setEncodingLimits(self.handle, name, int(limit[0]), int(limit[1]), int(limit[2])))",
  "def get_header(self):\n        assert self.handle is not None\n        return parms.char_par(self.handle, 'acquisitions', 'info')",
  "def process(self, list):\n        '''\n        Returns processed self with an acquisition processor specified by\n        a list of gadgets.\n        list: Python list of gadget description strings, each gadget\n              description being a string of the form\n                '[label:]gadget_name[(property1=value1[,...])]'\n              (square brackets embrace optional items, ... stands for etc.)\n        '''\n        ap = AcquisitionDataProcessor(list)\n        return ap.process(self)",
  "def acquisition(self, num):\n        '''\n        Returns the specified acquisition.\n        num: acquisition number\n        '''\n        assert self.handle is not None\n        acq = Acquisition()\n        acq.handle = pygadgetron.cGT_acquisitionFromContainer(self.handle, int(num))\n        check_status(acq.handle)\n        return acq",
  "def append_acquisition(self, acq):\n        '''\n        Appends acquistion to AcquisitionData.\n        '''\n        assert self.handle is not None\n        try_calling( pygadgetron.cGT_appendAcquisition(self.handle, acq.handle))",
  "def get_subset(self, idx):\n        '''\n        Returns AcquisitionData object with subset of acquisitions defined by idx\n        '''\n        assert self.handle is not None\n        subset = AcquisitionData()\n        idx = numpy.array(idx, dtype = cpp_int_dtype())\n        subset.handle = pygadgetron.cGT_getAcquisitionsSubset(self.handle, idx.ctypes.data, idx.size)\n        check_status(subset.handle)\n        \n        return subset",
  "def set_user_floats(self, data, idx):\n        '''\n        Writes the data into the user_float[idx] data field of the acquisition\n        data header of each acquisition in the container to pass additional data\n        into the raw data.\n        data: numpy array\n        idx: integer in range 0 to 7\n        '''\n        if self.handle is None:\n            raise AssertionError('self.handle is None')\n                    \n        if data.size != self.number():\n            raise AssertionError('Please give as many datapoints as there are acquisitions')\n        \n        if idx > 7 or idx < 0 or not isinstance(idx,int):\n            raise AssertionError('Please give an integer from [0,...,7]')\n\n        if data.dtype is not numpy.float32:\n            data = data.astype(numpy.float32)\n\n        try_calling(pygadgetron.cGT_setAcquisitionUserFloat\\\n                    (self.handle, data.ctypes.data, idx))",
  "def dimensions(self):\n        '''\n        Returns acquisitions dimensions as a tuple (na, nc, ns), where na is\n        the number of acquisitions, nc the number of coils and ns the number of\n        samples.\n        '''\n        assert self.handle is not None\n        if self.number() < 1:\n            return numpy.zeros((MAX_ACQ_DIMENSIONS,), dtype=cpp_int_dtype())\n        dim = numpy.ones((MAX_ACQ_DIMENSIONS,), dtype=cpp_int_dtype())\n        try_calling(pygadgetron.cGT_getAcquisitionDataDimensions\\\n             (self.handle, dim.ctypes.data))\n        dim[2] = numpy.prod(dim[2:])\n        return tuple(dim[2::-1])",
  "def get_ISMRMRD_info(self, par, which='all'):\n        '''\n        Returns the array of values of the specified acquisition information\n        parameter.\n\n        par: parameter name (see sirf.Gadgetron.Acquisition class methods except info)\n        which: specifies the range of acquisitions whose parameters are returned\n\n        Example:\n        # to retrieve readouts flags for acquisitions 0 to 10:\n        flags = acq_data.get_ISMRMRD_info('flags', range(10))\n\n        # for phase encoding information\n        encoding = acq_data.get_ISMRMRD_info('kspace_encode_step_1')\n\n        '''\n        #na, nc, ns = self.dimensions()\n        if which == 'all':\n            na = self.number()\n            rng = range(na)\n        else:\n            rng = which\n            na = len(rng)\n        f = min(rng)\n        t = max(rng) + 1\n        info = numpy.ndarray((2,), dtype=cpp_int_dtype())\n        try_calling(pygadgetron.cGT_acquisitionParameterInfo \\\n                    (self.handle, par, info.ctypes.data))\n        n = int(info[1])\n        if info[0] == 0:\n            values = numpy.ndarray((na, n), dtype=numpy.uint64)\n            try_calling(pygadgetron.cGT_acquisitionParameterValuesInt \\\n                        (self.handle, par, f, t, n, values.ctypes.data))\n        else:\n            values = numpy.ndarray((na, n), dtype=numpy.float32)\n            try_calling(pygadgetron.cGT_acquisitionParameterValuesFloat \\\n                        (self.handle, par, f, t, n, values.ctypes.data))\n        if n == 1:\n            values = numpy.reshape(values, (na,))\n        return values\n\n        # Python way is much slower for large data\n        info = numpy.empty((na,), dtype = object)\n        i = 0\n        for a in rng:\n            acq = self.acquisition(a)\n            info[i] = acq.info(par)\n            i += 1\n        return info",
  "def get_info(self, par, which='all'):\n        return self.get_ISMRMRD_info(par, which)",
  "def fill(self, data, select='image'):\n        '''\n        Fills self's acquisitions with specified values.\n        data: Python Numpy array or AcquisitionData\n        select: specifies whether all or only image-related acquisitions are\n                filled with values from the array data.\n        '''\n        assert self.handle is not None\n        if isinstance(data, AcquisitionData):\n            try_calling(pygadgetron.cGT_fillAcquisitionDataFromAcquisitionData\\\n                (self.handle, data.handle))\n            return\n        elif isinstance(data, numpy.ndarray):\n            dims = self.dimensions()\n            shape = data.shape\n            if shape != dims:\n                msg = 'cannot fill AcquisitionData of size %s' \\\n                      + ' with data of size %s'\n                raise ValueError(msg % (repr(dims), repr(shape)))\n            if data.dtype is not numpy.complex64:\n                the_data = data.astype(numpy.complex64)\n            else:\n                the_data = data\n            convert = not data.flags['C_CONTIGUOUS']\n            if convert:\n                the_data = numpy.ascontiguousarray(the_data)\n            if select == 'all':\n                fill_all = 1\n            else: # fill only image-related\n                fill_all = 0\n            try_calling(pygadgetron.cGT_fillAcquisitionData\\\n                (self.handle, the_data.ctypes.data, fill_all))\n        elif isinstance (data, Complex):\n            arr = data + numpy.zeros(self.shape, dtype=numpy.complex64)\n            return self.fill(arr)\n        elif isinstance (data, Number):\n            arr = data + numpy.zeros(self.shape, dtype=numpy.float32)\n            return self.fill(arr)\n        else:\n            raise error('wrong fill value.' + \\\n                        ' Should be AcquisitionData, numpy.ndarray or number. Got {}'.format(type(data)))\n        return self",
  "def as_array(self, acq=None):\n        '''\n        Returns selected self's acquisition(s) data as a 2D or 3D Numpy ndarray.\n        acq: acquisition number; if None all acquisitions data is returned.\n        '''\n        assert self.handle is not None\n        if acq is None:\n            ''' return 3D array of all acquisition data\n            '''\n            na, nc, ns = self.dimensions()\n            z = numpy.ndarray((na, nc, ns), dtype = numpy.complex64)\n            acq = -1\n        else:\n            ''' return 2D array of the specified acquisition data\n            '''\n            a = self.acquisition(acq)\n            nc = a.active_channels()\n            ns = a.number_of_samples()\n            z = numpy.ndarray((nc, ns), dtype = numpy.complex64)\n        try_calling(pygadgetron.cGT_acquisitionDataAsArray\\\n            (self.handle, z.ctypes.data, acq))\n        return z",
  "def show(self, slice=None, title=None, cmap='gray', power=0.2, \\\n             postpone=False):\n        '''Displays xy-cross-section(s) of images.'''\n        assert self.handle is not None\n        if not HAVE_PYLAB:\n            print('pylab not found')\n            return\n        data = numpy.transpose(self.as_array(), (1, 0, 2))\n        nz = data.shape[0]\n        if isinstance(slice, (Integral,numpy.integer)):\n            if slice < 0 or slice >= nz:\n                return\n            ns = 1\n            slice = [slice]\n##            show_2D_array('slice %d' % slice, data[slice,:,:])\n##            return\n        elif slice is None:\n            ns = nz\n            slice = range(nz)\n        else:\n            try:\n                ns = len(slice)\n            except:\n                raise error('wrong slice list')\n        if title is None:\n            title = 'Selected images'\n        if ns >= 16:\n            tiles = (4, 4)\n        else:\n            tiles = None\n        f = 0\n        while f < ns:\n            t = min(f + 16, ns)\n            err = show_3D_array(abs(data), index = slice[f : t], \\\n                                tile_shape = tiles, \\\n                                label = 'coil', xlabel = 'samples', \\\n                                ylabel = 'readouts', \\\n                                suptitle = title, cmap = cmap, power = power, \\\n                                show = (t == ns) and not postpone)\n            f = t",
  "def allocate(self, value=0, **kwargs):\n        '''Method to allocate an AcquisitionData and set its values\n        \n        CIL/SIRF compatibility\n        '''\n        if value in ['random', 'random_int']:\n            out = self.clone()\n            shape = out.as_array().shape\n            seed = kwargs.get('seed', None)\n            if seed is not None:\n                numpy.random.seed(seed)\n            if value == 'random':\n                out.fill(numpy.random.random_sample(shape))\n            elif value == 'random_int':\n                max_value = kwargs.get('max_value', 100)\n                out.fill(numpy.random.randint(max_value,size=shape))\n        else:\n            out = self.clone()\n            tmp = value * numpy.ones(out.as_array().shape)\n            out.fill(tmp)\n        return out",
  "def shape(self):\n        return self.dimensions()",
  "def __init__(self, acqs = None, imgs = None):\n        self.handle = None\n        if acqs == None:\n            self.handle = pygadgetron.cGT_newObject('AcquisitionModel')\n        else:\n            assert_validity(acqs, AcquisitionData)\n            assert_validity(imgs, ImageData)\n            self.handle = \\\n                pygadgetron.cGT_AcquisitionModel(acqs.handle, imgs.handle)\n        check_status(self.handle)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_up(self, acqs, imgs):\n        assert_validity(acqs, AcquisitionData)\n        assert_validity(imgs, ImageData)\n        try_calling(pygadgetron.cGT_setUpAcquisitionModel \\\n            (self.handle, acqs.handle, imgs.handle))",
  "def set_coil_sensitivity_maps(self, csm):\n        '''\n        Specifies the coil sensitivity maps to be used by the model.\n        csm: CoilSensitivityData\n        '''\n        assert_validity(csm, CoilSensitivityData)\n        try_calling(pygadgetron.cGT_setAcquisitionModelParameter \\\n            (self.handle, 'coil_sensitivity_maps', csm.handle))",
  "def norm(self, num_iter=2, verb=0):\n        '''Computes the norm of the forward projection operator.\n        '''\n        assert self.handle is not None\n        handle = pygadgetron.cGT_acquisitionModelNorm(self.handle, num_iter, verb)\n        check_status(handle)\n        r = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return r;",
  "def forward(self, image):\n        '''\n        Projects an image into (simulated) acquisitions space.\n        The resulting acquisition data simulates the actual data\n        expected to be received from the scanner.\n        image: ImageData\n        '''\n        assert_validity(image, ImageData)\n        ad = AcquisitionData()\n        ad.handle = pygadgetron.cGT_AcquisitionModelForward\\\n            (self.handle, image.handle)\n        check_status(ad.handle)\n        return ad;",
  "def backward(self, ad):\n        '''\n        Back-projects acquisition data into image space using a complex\n        transpose of the forward projection.\n        ad: AcquisitionData\n        '''\n        assert_validity(ad, AcquisitionData)\n        image = ImageData()\n        image.handle = pygadgetron.cGT_AcquisitionModelBackward\\\n            (self.handle, ad.handle)\n        check_status(image.handle)\n        return image",
  "def inverse(self, ad, dcw=None):\n        '''\n        Weights acquisition data with k-space density prior to back-projection\n        into image space using a complex transpose of the forward projection.\n        ad: AcquisitionData\n        dcw: AcquisitionData\n        '''\n        assert_validity(ad, AcquisitionData)\n        \n        if dcw is not None:\n            assert_validity(dcw, AcquisitionData)\n            if ad.shape != dcw.shape:\n                raise AssertionError(\"The shape of the density weights and the acquisition data must be the same.\")\n\n        if dcw is None:\n            dcw = compute_kspace_density(ad)\n            \n        ad = ad * dcw\n\n        image = ImageData()\n        image.handle = pygadgetron.cGT_AcquisitionModelBackward\\\n            (self.handle, ad.handle)\n        check_status(image.handle)\n        return image",
  "def direct(self, image, out = None):\n        '''Alias of forward\n\n           Added for CCPi CIL compatibility\n           https://github.com/CCPPETMR/SIRF/pull/237#issuecomment-439894266\n        '''\n        if out is not None:\n            #raise error('out is not supported')\n            tmp = self.forward(image)\n            out.fill(tmp)\n            return\n        return self.forward(image)",
  "def adjoint(self, ad , out = None):\n        '''Alias of backward\n\n           Added for CCPi CIL compatibility\n           https://github.com/CCPPETMR/SIRF/pull/237#issuecomment-439894266\n        '''\n        if out is not None:\n            #raise error('out is not supported')\n            tmp = self.backward(ad)\n            out.fill(tmp)\n            return\n        return self.backward(ad)",
  "def is_affine(self):\n        '''Returns if the acquisition model is affine (i.e. corresponding to A*x+b)'''\n        return True",
  "def is_linear(self):\n        '''Returns whether the acquisition model is linear (i.e. corresponding to A*x, with zero background term)'''\n        return True",
  "def range_geometry(self):\n        '''Returns the template of AcquisitionData'''\n        geom = AcquisitionData()\n        geom.handle = pygadgetron.cGT_parameter(\n            self.handle, 'AcquisitionModel', 'range geometry')\n        check_status(geom.handle)\n        return geom",
  "def domain_geometry(self):\n        '''Returns the template of ImageData'''\n        geom = ImageData()\n        geom.handle = pygadgetron.cGT_parameter(\n            self.handle, 'AcquisitionModel', 'domain geometry')\n        check_status(geom.handle)\n        return geom",
  "def __init__(self, name):\n        '''\n        Creates a gadget of specified type and properties.\n        name: a string of the form gadget_type(property1=value1, ...)\n        '''\n        self.handle = None\n        name, prop = name_and_parameters(name)\n        self.handle = pygadgetron.cGT_newObject(name)\n        check_status(self.handle)\n        if prop is not None:\n            self.set_properties(prop)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_property(self, prop, value):\n        '''\n        Assigns specified value to specified gadget property.\n        prop : property name (string)\n        value: property value (string)\n        '''\n        try_calling(pygadgetron.cGT_setGadgetProperty(self.handle, prop, value))",
  "def set_properties(self, prop):\n        '''\n        Assigns specified values to specified gadget properties.\n        prop: a string with comma-separated list of property value assignments\n              prop_name=prop_value\n        '''\n        try_calling(pygadgetron.cGT_setGadgetProperties(self.handle, prop))",
  "def value_of(self, prop):\n        '''\n        Returns the string representation of the value of specified property.\n        prop: property name (string)\n        '''\n        return parms.char_par(self.handle, 'gadget', prop)",
  "def __init__(self):\n        self.handle = pygadgetron.cGT_newObject('GadgetChain')\n        check_status(self.handle)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_host(self, host):\n        '''\n        Sets Gadgetron server host.\n        host : host name (string)\n        '''\n        try_calling(pygadgetron.cGT_setHost(self.handle, host))",
  "def set_port(self, port):\n        '''\n        Sets Gadgetron server port.\n        port : port number (as a string)\n        '''\n        try_calling(pygadgetron.cGT_setPort(self.handle, port))",
  "def add_gadget(self, id, gadget):\n        '''\n        Adds a gadget to the chain.\n        id    : gadget id (string)\n        writer: Gadget\n        '''\n        assert isinstance(gadget, Gadget)\n        try_calling(pygadgetron.cGT_addGadget(self.handle, id, gadget.handle))",
  "def set_gadget_property(self, id, prop, value):\n        '''\n        Assigns specified value to specified gadget property.\n        id   : gadget id\n        prop : property name (string)\n        value: property value (string)\n        '''\n        if type(value) == type('abc'):\n            v = value\n        else:\n            v = repr(value).lower()\n        hg = parms.parameter_handle(self.handle, 'gadget_chain', id)\n        try_calling(pygadgetron.cGT_setGadgetProperty(hg, prop, v))\n        pyiutil.deleteDataHandle(hg)",
  "def value_of_gadget_property(self, id, prop):\n        '''\n        Returns the string representation of the value of specified property.\n        id  : gadget id\n        prop: property name (string)\n        '''\n        hg = parms.parameter_handle(self.handle, 'gadget_chain', id)\n        hv = parms.parameter_handle(hg, 'gadget', prop)\n        value = pyiutil.charDataFromHandle(hv)\n        pyiutil.deleteDataHandle(hg)\n        pyiutil.deleteDataHandle(hv)\n        return value",
  "def __init__(self, list=None):\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject('ImagesReconstructor')\n        check_status(self.handle)\n        self.input_data = None\n        self.dcm_prefix = \"\"\n        if list is None:\n            return\n        for i in range(len(list)):\n            label, name = label_and_name(list[i])\n            self.add_gadget(label, Gadget(name))",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_input(self, input_data):\n        '''\n        Sets the input.\n        input_data: AcquisitionData\n        '''\n        assert isinstance(input_data, AcquisitionData)\n        self.input_data = input_data",
  "def set_dcm_prefix(self, dcm_prefix):\n        self.dcm_prefix = dcm_prefix",
  "def process(self):\n        '''\n        Processes the input with the gadget chain.\n        dcm_prefix: Python text string.\n        If dcm_prefix is not \"\", the reconstructed images are written to\n        files <dcm_prefix>_<image number>.dcm.\n        Otherwise, they are stored in memory and can be retrieved by\n        get_output().\n        '''\n        if self.input_data is None:\n            raise error('no input data')\n        try_calling(pygadgetron.cGT_reconstructImages\\\n             (self.handle, self.input_data.handle, self.dcm_prefix))",
  "def get_output(self, subset = None):\n        '''\n        Returns specified subset of the output ImageData. If no subset is\n        specified, returns all output.\n        subset: the name of the subset (e.g. images, gfactors,...)\n        '''\n        output = ImageData()\n        output.handle = pygadgetron.cGT_reconstructedImages(self.handle)\n        check_status(output.handle)\n        if subset is None:\n            return output\n        else:\n            return output.select('GADGETRON_DataRole', subset)",
  "def reconstruct(self, input_data):\n        '''\n        Returns the output from the chain for specified input.\n        input_data: AcquisitionData\n        '''\n        assert_validity(input_data, AcquisitionData)\n        handle = pygadgetron.cGT_reconstructImages\\\n             (self.handle, input_data.handle, self.dcm_prefix)\n        check_status(handle)\n        pyiutil.deleteDataHandle(handle)\n        images = ImageData()\n        images.handle = pygadgetron.cGT_reconstructedImages(self.handle)\n        check_status(images.handle)\n        return images",
  "def __init__(self, list = None):\n        '''\n        Creates an image processor specified by a list of gadgets.\n        list: Python list of gadget description strings, each gadget\n              description being a string of the form\n                '[label:]gadget_name[(property1=value1[,...])]'\n              (square brackets embrace optional items, ... stands for etc.)\n        '''\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject('ImagesProcessor')\n        check_status(self.handle)\n        # TODO: handle input and output in cSTIR\n        self.input_data = None\n        self.output_data = None\n        if list is None:\n            return\n        for i in range(len(list)):\n            label, name = label_and_name(list[i])\n            self.add_gadget(label, Gadget(name))",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_input(self, input_data):\n        '''\n        Sets the input data.\n        '''\n        assert isinstance(input_data, ImageData)\n        self.input_data = input_data",
  "def process(self, input_data = None):\n        '''\n        Returns the output from the chain.\n        input_data: ImageData\n        '''\n        if input_data is not None:\n            self.set_input(input_data)\n        if self.input_data is None:\n            raise error('input data not set')\n        assert_validity(self.input_data, ImageData)\n        image = ImageData()\n        image.handle = pygadgetron.cGT_processImages\\\n             (self.handle, self.input_data.handle)\n        check_status(image.handle)\n        self.output_data = image\n        return image",
  "def get_output(self):\n        '''\n        Returns the output data.\n        '''\n        return self.output_data",
  "def __init__(self, list = None):\n        '''\n        Creates an acquisition processor specified by a list of gadgets.\n        list: Python list of gadget description strings, each gadget\n              description being a string of the form\n                '[label:]gadget_name[(property1=value1[,...])]'\n              (square brackets embrace optional items, ... stands for etc.)\n        '''\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject('AcquisitionsProcessor')\n        check_status(self.handle)\n        self.input_data = None\n        self.output_data = None\n        if list is None:\n            return\n        for i in range(len(list)):\n            label, name = label_and_name(list[i])\n            self.add_gadget(label, Gadget(name))",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_input(self, input_data):\n        '''\n        Sets the input data.\n        '''\n        assert isinstance(input_data, AcquisitionData)\n        self.input_data = input_data",
  "def process(self, input_data = None):\n        '''\n        Returns the output from the chain for specified input.\n        input_data: AcquisitionData\n        '''\n        if input_data is not None:\n            self.set_input(input_data)\n        if self.input_data is None:\n            raise error('input data not set')\n        assert_validity(self.input_data, AcquisitionData)\n        acquisitions = AcquisitionData()\n        acquisitions.handle = pygadgetron.cGT_processAcquisitions\\\n             (self.handle, self.input_data.handle)\n        check_status(acquisitions.handle)\n        self.output_data = acquisitions\n        return acquisitions",
  "def get_output(self):\n        '''\n        Returns the output data.\n        '''\n        return self.output_data",
  "def __init__(self):\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject('SimpleReconstructionprocessor')\n        check_status(self.handle)\n        self.input_data = None\n        self.dcm_prefix = \"\"",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def __init__(self):\n        self.handle = None\n        self.handle = pygadgetron.cGT_newObject\\\n            ('SimpleGRAPPAReconstructionprocessor')\n        check_status(self.handle)\n        self.input_data = None\n        self.dcm_prefix = \"\"",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def compute_gfactors(self, flag):\n        self.set_gadget_property('gadget4', 'send_out_gfactor', flag)",
  "def set_parameter(hs, group, par, hv, stack = None):\n    if stack is None:\n        stack = inspect.stack()[1]\n    h = setParameter(hs, group, par, hv)\n    check_status(h, stack)\n    pyiutil.deleteDataHandle(h)",
  "def set_char_par(handle, group, par, value):\n    h = pyiutil.charDataHandle(value)\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def set_int_par(handle, group, par, value):\n    h = pyiutil.intDataHandle(int(value))\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def set_bool_par(handle, group, par, value):\n    h = pyiutil.boolDataHandle(bool(value))\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def set_float_par(handle, group, par, value):\n    h = pyiutil.floatDataHandle(float(value))\n    set_parameter(handle, group, par, h, inspect.stack()[1])\n    pyiutil.deleteDataHandle(h)",
  "def bool_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.boolDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def char_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = pyiutil.charDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def int_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.intDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def int_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.intDataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def uint16_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.uint16DataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def uint32_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.uint32DataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def uint64_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.uint64DataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def float_par(handle, group, par):\n    h = parameter(handle, group, par)\n    check_status(h)\n    v = pyiutil.floatDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return v",
  "def float_pars(handle, group, par, n):\n    h = parameter(handle, group, par)\n    check_status(h)\n    value = ()\n    for i in range(n):\n        value += (pyiutil.floatDataItemFromHandle(h, i),)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def parameter_handle(hs, group, par):\n    handle = parameter(hs, group, par)\n    check_status(handle, inspect.stack()[1])\n    return handle",
  "def get_STIR_version_string():\n    \"\"\"Returns STIR engine version as Python str.\"\"\"\n    handle = pystir.cSTIR_STIR_version_string()\n    check_status(handle)\n    version = pyiutil.charDataFromHandle(handle)\n    pyiutil.deleteDataHandle(handle)\n    return version",
  "def get_STIR_doc_dir():\n    \"\"\"Returns STIR engine version as Python str.\"\"\"\n    handle = pystir.cSTIR_get_STIR_doc_dir()\n    check_status(handle)\n    path = pyiutil.charDataFromHandle(handle)\n    pyiutil.deleteDataHandle(handle)\n    return path",
  "def get_STIR_examples_dir():\n    \"\"\"Returns STIR engine version as Python str.\"\"\"\n    handle = pystir.cSTIR_get_STIR_examples_dir()\n    check_status(handle)\n    path = pyiutil.charDataFromHandle(handle)\n    pyiutil.deleteDataHandle(handle)\n    return path",
  "def set_verbosity(verbosity):\n    \"\"\"Set the verbosity of all STIR output.\"\"\"\n    try_calling(pystir.cSTIR_setVerbosity(verbosity))",
  "def get_verbosity():\n    \"\"\"Get the verbosity of all STIR output.\"\"\"\n    h = pystir.cSTIR_getVerbosity()\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.intDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def scanner_names():\n    h = pystir.cSTIR_scannerNames()\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.charDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def set_max_omp_threads(threads):\n    \"\"\"Set the maximum number of OpenMP threads.\"\"\"\n    try_calling(pystir.cSTIR_setOMPThreads(int(threads)))",
  "def get_max_omp_threads():\n    \"\"\"Get the maximum number of OpenMP threads.\"\"\"\n    h = pystir.cSTIR_getOMPThreads()\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.intDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def set_default_num_omp_threads():\n    \"\"\"Use the default number of OpenMP threads.\"\"\"\n    try_calling(pystir.cSTIR_useDefaultOMPThreads())",
  "def get_default_num_omp_threads():\n    \"\"\"Get default num of OpenMP threads.\"\"\"\n    h = pystir.cSTIR_getDefaultOMPThreads()\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.intDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "def scanner_names():\n    h = pystir.cSTIR_scannerNames()\n    check_status(h, inspect.stack()[1])\n    value = pyiutil.charDataFromHandle(h)\n    pyiutil.deleteDataHandle(h)\n    return value",
  "class MessageRedirector(object):\n    \"\"\"Class for STIR printing redirection to files/stdout/stderr.\"\"\"\n\n    def __init__(self, info=None, warn='stdout', errr='stderr'):\n        \"\"\"Create MessageRedirector object that redirects STIR's ouput.\n\n        Output produced by info(), warning() and error(0 functions to\n        destinations specified respectively by info, warn and err arguments.\n        The argument values other than None, stdout, stderr, cout and cerr\n        are interpreted as filenames.\n        None and empty string value suppresses printing.\n        \"\"\"\n        if info is None:\n            info = ''\n        if not isinstance(info, str):\n            raise error(\n                'wrong info argument for MessageRedirector constructor')\n        elif info in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.info = pystir.newTextPrinter(info)\n            self.info_case = 0\n        else:\n            self.info = pystir.newTextWriter(info)\n            self.info_case = 1\n        pystir.openChannel(0, self.info)\n\n        if warn is None:\n            warn = ''\n        if not isinstance(warn, str):\n            raise error(\n                'wrong warn argument for MessageRedirector constructor')\n        elif warn in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.warn = pystir.newTextPrinter(warn)\n            self.warn_case = 0\n        else:\n            self.warn = pystir.newTextWriter(warn)\n            self.warn_case = 1\n        pystir.openChannel(1, self.warn)\n\n        if errr is None:\n            errr = ''\n        if not isinstance(errr, str):\n            raise error(\n                'wrong errr argument for MessageRedirector constructor')\n        elif errr in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.errr = pystir.newTextPrinter(errr)\n            self.errr_case = 0\n        else:\n            self.errr = pystir.newTextWriter(errr)\n            self.errr_case = 1\n        pystir.openChannel(2, self.errr)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.info_case == 0:\n            try_calling(pystir.deleteTextPrinter(self.info))\n        else:\n            try_calling(pystir.deleteTextWriter(self.info))\n        pystir.closeChannel(0, self.info)\n        if self.warn_case == 0:\n            try_calling(pystir.deleteTextPrinter(self.warn))\n        else:\n            try_calling(pystir.deleteTextWriter(self.warn))\n        pystir.closeChannel(1, self.warn)\n        if self.errr_case == 0:\n            try_calling(pystir.deleteTextPrinter(self.errr))\n        else:\n            try_calling(pystir.deleteTextWriter(self.errr))\n        pystir.closeChannel(2, self.errr)",
  "class Shape(object):\n    \"\"\"Base class for an abstract geometric shape.\n\n    Used as a building block for creating phantom images.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_origin(self, origin):\n        \"\"\"Sets origin.\n\n        Sets the (discrete) coordinates of\n        the shape centre on a voxel grid.\n        \"\"\"\n        parms.set_float_par(self.handle, 'Shape', 'x', origin[2])\n        parms.set_float_par(self.handle, 'Shape', 'y', origin[1])\n        parms.set_float_par(self.handle, 'Shape', 'z', origin[0])\n\n    def get_origin(self):\n        \"\"\"Returns the coordinates of the shape centre on a voxel grid.\"\"\"\n        x = parms.float_par(self.handle, 'Shape', 'x')\n        y = parms.float_par(self.handle, 'Shape', 'y')\n        z = parms.float_par(self.handle, 'Shape', 'z')\n        return (x, y, z)",
  "class Box3D(Shape):\n    \"\"\"Class for elliptic cylinder shape.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'Box3D'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_length_x(self, value):\n        \"\"\"Sets dimension x length in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'length_x', value)\n\n    def get_length_x(self):\n        \"\"\"Returns dimension x length in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'length_x')\n\n    def set_length_y(self, value):\n        \"\"\"Sets dimension y length in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'length_y', value)\n\n    def get_length_y(self):\n        \"\"\"Returns dimension y length in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'length_y')\n\n    def set_length_z(self, value):\n        \"\"\"Sets dimension z length in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'length_z', value)\n\n    def get_length_z(self):\n        \"\"\"Returns dimension z length in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'length_z')\n\n    def set_lengths(self, value):\n        \"\"\"Sets lengths in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'length_x', value[0])\n        parms.set_float_par(self.handle, self.name, 'length_y', value[1])\n        parms.set_float_par(self.handle, self.name, 'length_z', value[2])\n\n    def get_lengths(self):\n        \"\"\"Returns lengths in mm.\"\"\"\n        length_x = parms.float_par(self.handle, self.name, 'length_x')\n        length_y = parms.float_par(self.handle, self.name, 'length_y')\n        length_z = parms.float_par(self.handle, self.name, 'length_z')\n        return (length_x, length_y, length_z)",
  "class Ellipsoid(Shape):\n    \"\"\"Class for ellipsoid shape.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'Ellipsoid'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_radius_x(self, value):\n        \"\"\"Sets x radius in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_x', value)\n\n    def get_radius_x(self):\n        \"\"\"Returns x radius in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'radius_x')\n\n    def set_radius_y(self, value):\n        \"\"\"Sets y radius in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_y', value)\n\n    def get_radius_y(self):\n        \"\"\"Returns y radius in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'radius_y')\n\n    def set_radius_z(self, value):\n        \"\"\"Sets z radius in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_z', value)\n\n    def get_radius_z(self):\n        \"\"\"Returns z radius in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'radius_z')",
  "class EllipticCylinder(Shape):\n    \"\"\"Class for elliptic cylinder shape.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'EllipsoidalCylinder'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_length(self, value):\n        \"\"\"Sets length in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'length', value)\n\n    def get_length(self):\n        \"\"\"Returns length in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'length')\n\n    def set_radius_x(self, value):\n        \"\"\"Sets x radius in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_x', value)\n\n    def get_radius_x(self):\n        \"\"\"Returns x radius in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'radius_x')\n\n    def set_radius_y(self, value):\n        \"\"\"Sets y radius in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_y', value)\n\n    def get_radius_y(self):\n        \"\"\"Returns y radius in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'radius_y')\n\n    def set_radii(self, radii):\n        \"\"\"Sets radii in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_x', radii[1])\n        parms.set_float_par(self.handle, self.name, 'radius_y', radii[0])\n\n    def get_radii(self):\n        \"\"\"Returns radii in mm.\"\"\"\n        rx = parms.float_par(self.handle, self.name, 'radius_x')\n        ry = parms.float_par(self.handle, self.name, 'radius_y')\n        return (rx, ry)",
  "class ImageData(SIRF.ImageData):\n    \"\"\"Class for PET image data objects.\n\n    ImageData objects contain both geometric data and the actual voxel\n    values. You have to use the `as_array` method to get an array with\n    the voxel values, and use the `fill` function to change the voxel values.\n    \"\"\"\n\n    def __init__(self, arg=None):\n        \"\"\"Creates an ImageData object.\n\n        Arguments:\n            arg : Python str or AcquisitionData or None, interpreted as follows:\n        str            : read the object from a file specified by <arg>\n                         (the file format has to be support by STIR).\n        STIR.AcquisitionData: create an object compatible with the scanner data\n                         recorded in an AcquisitionData object <arg>.\n                         This sets default voxel sizes.\n        SIRF.ImageData : (attempt to) convert data from another SIRF ImageData container.\n        None           : create an empty ImageData object. Call initialise()\n                         method before using it.\n        \"\"\"\n        self.handle = None\n        if isinstance(arg, str):\n            self.handle = pystir.cSTIR_objectFromFile('Image', arg)\n            check_status(self.handle)\n        elif isinstance(arg, AcquisitionData):\n            if arg.handle is None:\n                raise AssertionError()\n            self.handle = pystir.cSTIR_imageFromAcquisitionData(arg.handle)\n            check_status(self.handle)\n        elif isinstance(arg, SIRF.ImageData):\n            if arg.handle is None:\n                raise AssertionError()\n            self.handle = pystir.cSTIR_imageFromImageData(arg.handle)\n            check_status(self.handle)\n        elif arg is not None:\n            raise error(\n                'wrong argument ' + repr(arg) + ' for ImageData constructor')\n        self.name = 'ImageData'\n        self.rimsize = -1\n\n    def __del__(self):\n        \"\"\"Deallocates this ImageData object.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def same_object(self):\n        \"\"\"See DataContainer method.\"\"\"\n        return ImageData()\n\n    def modality(self):\n        \"\"\"Returns imaging modality as Python string.\"\"\"\n        return parms.char_par(self.handle, 'ImageData', 'modality')\n\n    def set_modality(self, mod):\n        \"\"\"Sets imaging modality.\n\n        mod: \"PT\" or \"NM\" or \"MR\" or \"CT\" or \"US\" or \"Optical\"\n        \"\"\"\n        return parms.set_char_par(self.handle, 'ImageData', 'modality', mod)\n\n    def initialise(self, dim, vsize=(1., 1., 1.), origin=(0., 0., 0.)):\n        \"\"\"\n        Sets image size and geometric information.\n\n        If self is not an empty ImageData, its contents are erased.\n        Dimemsions (number of voxels) are required,\n        spacing and offset are optional.\n        Spacing and offset are to be given in mm.\n        All should be given as (z,y,x).\n        \"\"\"\n        if not isinstance(dim, tuple):\n            raise error(\n                \"sirf.STIR.Imagedata.initialise: dim should be a tuple\")\n        if not isinstance(vsize, tuple):\n            raise error(\n                \"sirf.STIR.Imagedata.initialise: vsize should be a tuple\")\n        if not isinstance(origin, tuple):\n            raise error(\n                \"sirf.STIR.Imagedata.initialise: origin should be a tuple\")\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = None\n        voxels = pystir.cSTIR_voxels3DF(\n            int(dim[2]), int(dim[1]), int(dim[0]),\n            float(vsize[2]), float(vsize[1]), float(vsize[0]),\n            float(origin[2]), float(origin[1]), float(origin[0]))\n        check_status(voxels)\n        self.handle = pystir.cSTIR_imageFromVoxels(voxels)\n        check_status(self.handle)\n        pyiutil.deleteDataHandle(voxels)\n\n    def fill(self, value):\n        \"\"\"Sets the voxel values.\n\n        The argument is either ImageData or 3D Numpy ndarray of values or a\n        scalar to be assigned at each voxel. When using an ndarray, the array\n        must have the same size as an array returned by `as_array`.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if isinstance(value, ImageData):\n            super(ImageData, self).fill(value)\n#            try_calling(pystir.cSTIR_setImageDataFromImage \\\n#                        (self.handle, value.handle))\n        elif isinstance(value, numpy.ndarray):\n            dims = self.dimensions()\n            shape = value.shape\n            if shape != dims:\n                msg = 'cannot fill ImageData of size %s' \\\n                      + ' with data of size %s'\n                raise ValueError(msg % (repr(dims), repr(shape)))\n            if value.dtype is numpy.dtype('float32'):\n                # print('keeping dtype float32')\n                v = value\n            else:\n                # print('changing dtype to float32')\n                v = value.astype(numpy.float32)\n            if not v.flags['C_CONTIGUOUS']:\n                v = numpy.ascontiguousarray(v)\n            try_calling(pystir.cSTIR_setImageData(self.handle, v.ctypes.data))\n        elif isinstance(value, (Number, numpy.number)):\n            try_calling(pystir.cSTIR_fillImage(self.handle, float(value)))\n        else:\n            raise TypeError('wrong fill value.' + \\\n                        ' Should be ImageData, numpy.ndarray, float or int. Got {}'\\\n                        .format(type(value)))\n        return self\n\n    def get_uniform_copy(self, value=1.0):\n        \"\"\"Creates a copy of this image filled with <value>.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        image = ImageData()\n        image.handle = pystir.cSTIR_imageFromImage(self.handle)\n        check_status(image.handle)\n        image.fill(value)\n        return image\n\n    def add_shape(self, shape, scale, num_samples_in_each_direction=1):\n        \"\"\"Adds a shape to self - see Shape above.\n\n        If a shape partially fills a voxel, it is possible to choose the\n        number of samples that will be used in each direction to determine the\n        fraction of the voxel that is filled by the shape. For a 3D image,\n        using num_samples_in_each_direction=2 would result in 2^3=8 samples.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(shape, Shape)\n        try_calling(pystir.cSTIR_addShape(\n            self.handle, shape.handle, scale,\n            int(num_samples_in_each_direction)))\n\n    def read_from_file(self, filename):\n        \"\"\"\n        Reads data from file.\n\n        Replaces the current content of the object.\n        \"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pystir.cSTIR_objectFromFile('Image', filename)\n        check_status(self.handle)\n\n    def dimensions(self):\n        \"\"\"Returns image dimensions as a tuple (nz, ny, nx).\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        dim = numpy.ndarray((MAX_IMG_DIMS,), dtype=cpp_int_dtype())\n        try_calling(\n            pystir.cSTIR_getImageDimensions(self.handle, dim.ctypes.data))\n        return tuple(dim[:3])  # [::-1])\n\n    def voxel_sizes(self):\n        \"\"\"Returns image voxel sizes as a tuple (vz, vy, vx).\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        vs = numpy.ndarray((3,), dtype=numpy.float32)\n        try_calling(\n            pystir.cSTIR_getImageVoxelSizes(self.handle, vs.ctypes.data))\n        return tuple(vs)  # [::-1])\n\n    @property\n    def spacing(self):\n        return self.voxel_sizes()\n\n    def transf_matrix(self):\n        \"\"\"Returns transformation matrix.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        tm = numpy.ndarray((4, 4), dtype=numpy.float32)\n        try_calling(\n            pystir.cSTIR_getImageTransformMatrix(self.handle, tm.ctypes.data))\n        return tm\n\n    def as_array(self):\n        \"\"\"Returns 3D Numpy ndarray with values at the voxels.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        array = numpy.ndarray(self.dimensions(), dtype=numpy.float32)\n        try_calling(pystir.cSTIR_getImageData(self.handle, array.ctypes.data))\n        return array\n\n    def write_par(self, filename, par):\n        \"\"\"Writes with parameter file.\"\"\"\n        try_calling(pystir.cSTIR_writeImage_par(self.handle, filename, par))\n\n    def show(self, slice=None, title=None):\n        \"\"\"Displays xy-cross-section(s) of this image.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if not HAVE_PYLAB:\n            print('pylab not found')\n            return\n        data = self.as_array()\n        nz = data.shape[0]\n        if isinstance(slice, (Integral,numpy.integer)):\n            if slice < 0 or slice >= nz:\n                raise IndexError('Slice index out of range')\n            show_2D_array('slice %d' % slice, data[slice, :, :])\n            return\n        elif slice is None:\n            ni = nz\n            slice = range(nz)\n        else:\n            try:\n                ni = len(slice)\n            except:\n                raise error('wrong slice list')\n        if title is None:\n            title = 'Selected images'\n        if ni >= 16:\n            tiles = (4, 4)\n        else:\n            tiles = None\n        f = 0\n        while f < ni:\n            t = min(f + 16, ni)\n            show_3D_array(data, index=slice[f : t], tile_shape=tiles,\n                          label='slice', xlabel='x', ylabel='y',\n                          suptitle=title, show=(t == ni))\n            f = t\n\n    def allocate(self, value=0, **kwargs):\n        \"\"\"Alias to get_uniform_copy for CIL/SIRF compatibility.\"\"\"\n        if value in ['random', 'random_int']:\n            out = self.get_uniform_copy()\n            shape = out.as_array().shape\n            seed = kwargs.get('seed', None)\n            if seed is not None:\n                numpy.random.seed(seed)\n            if value == 'random':\n                out.fill(numpy.random.random_sample(shape))\n            elif value == 'random_int':\n                max_value = kwargs.get('max_value', 100)\n                out.fill(numpy.random.randint(max_value, size=shape))\n        elif value is None:\n            if self.is_empty():\n                out = self.get_uniform_copy(0)\n            else:\n                out = self.copy()\n        else:\n            out = self.get_uniform_copy(value)\n        return out\n\n    def zoom_image(self, zooms=(1., 1., 1.), offsets_in_mm=(0., 0., 0.),\n                   size=(-1, -1, -1), scaling='preserve_sum'):\n        \"\"\"\n        Returns a zoomed image.\n\n        All coordinates and indices are given as (z,y,x).\n        To leave the size unchanged in any dimension, set the\n        corresponding size to -1\n        Supported scaling options are: 'preserve_sum', 'preserve_values' and\n        'preserve_projections'\n        \"\"\"\n        zoomed_im = self.clone()\n\n        if not isinstance(zooms, tuple):\n            raise error('zoom_image: zooms should be tuple')\n        if not isinstance(offsets_in_mm, tuple):\n            raise error('zoom_image: offsets_in_mm should be tuple')\n        if not isinstance(size, tuple):\n            raise error('zoom_image: size should be tuple')\n        np_zooms = numpy.asarray(zooms, dtype=numpy.float32)\n        np_offsets_in_mm = numpy.asarray(offsets_in_mm, dtype=numpy.float32)\n        np_size = numpy.asarray(size, dtype=cpp_int_dtype())\n\n        try_calling(pystir.cSTIR_ImageData_zoom_image(\n            zoomed_im.handle, np_zooms.ctypes.data,\n            np_offsets_in_mm.ctypes.data, np_size.ctypes.data, scaling))\n\n        return zoomed_im\n\n    def move_to_scanner_centre(self, proj_data):\n        \"\"\"Moves the image to the scanner centre.\n\n        AcquisitionData is required as bed shift etc. will be taken into\n        account when available.\n        \"\"\"\n        if not isinstance(proj_data, AcquisitionData):\n            raise error('move_to_scanner_centre: proj_data should' +\n                        'be of type AcquisitionData')\n        if proj_data.handle is None:\n            raise error('move_to_scanner_centre: proj_data is not initialised')\n        if self.handle is None:\n            raise error('move_to_scanner_centre: image is not initialised')\n        moved_im = self.clone()\n        try_calling(pystir.cSTIR_ImageData_move_to_scanner_centre(\n            moved_im.handle, proj_data.handle))\n\n        return moved_im\n\n    @property\n    def shape(self):\n        return self.dimensions()",
  "class ImageDataProcessor(object):\n    \"\"\"Class for image processors.\n\n    An ImageDataProcessor changes an image in some way, e.g. by filtering.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        # TODO: handle input and output in cSTIR\n        self.input = None\n        self.output = None\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def apply(self, image):\n        \"\"\"Applies this filter to the specified image.\"\"\"\n        assert_validity(image, ImageData)\n        try_calling(pystir.cSTIR_applyImageDataProcessor(\n            self.handle, image.handle))\n\n    def set_input(self, input):\n        \"\"\"Sets the input data.\"\"\"\n        assert_validity(input, ImageData)\n        self.input = input\n\n    def process(self, input=None):\n        \"\"\"Processes data.\"\"\"\n        if input is not None:\n            self.input = input\n        if self.input is None:\n            raise error('input image not set')\n        assert_validity(self.input, ImageData)\n        self.output = self.input.clone()\n        self.apply(self.output)\n        return self.output\n\n    def get_output(self):\n        \"\"\"Returns the output data.\"\"\"\n        return self.output",
  "class SeparableGaussianImageFilter(ImageDataProcessor):\n    \"\"\"Implements Gaussian filtering.\n\n    The filtering operation is performed as 3 separate one-dimensional filters\n    in each spacial direction.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.input = None\n        self.output = None\n        self.name = 'SeparableGaussianImageFilter'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_up(self, image):\n        \"\"\"Sets up.\"\"\"\n        assert_validity(image, ImageData)\n        try_calling(pystir.cSTIR_setupImageDataProcessor(\n            self.handle, image.handle))\n\n    def set_fwhms(self, fwhms):\n        \"\"\"Sets FWHM in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'fwhms_x', fwhms[2])\n        parms.set_float_par(self.handle, self.name, 'fwhms_y', fwhms[1])\n        parms.set_float_par(self.handle, self.name, 'fwhms_z', fwhms[0])\n\n    def set_max_kernel_sizes(self, mks):\n        \"\"\"Sets max kernel sizes in voxels.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'max_kernel_size_x', mks[2])\n        parms.set_int_par(self.handle, self.name, 'max_kernel_size_y', mks[1])\n        parms.set_int_par(self.handle, self.name, 'max_kernel_size_z', mks[0])\n\n    def set_normalise(self, norm=True):\n        \"\"\"Sets normalise.\"\"\"\n        v = 1 if norm else 0\n        parms.set_int_par(self.handle, self.name, 'normalise', v)",
  "class TruncateToCylinderProcessor(ImageDataProcessor):\n    \"\"\"Class for the image filter that zeroes the image outside the cylinder\n       of the same xy-diameter and z-size as those of the image.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'TruncateToCylindricalFOVImageProcessor'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_strictly_less_than_radius(self, flag):\n        \"\"\"Specifies the behaviour on the boundary.\n\n        Specifies whether the area not affected by filtering is strictly\n        inside the cylinder (flag = True) or not (flag = False).\n        \"\"\"\n        parms.set_char_par(\n            self.handle, 'TruncateToCylindricalFOVImageProcessor',\n            'strictly_less_than_radius', repr(flag))\n\n    def get_strictly_less_than_radius(self):\n        \"\"\"Returns the boundary behaviour flag.\n\n        Returns the answer to the question: Is the area not affected by\n        filtering strictly inside the cylinder?\n        \"\"\"\n        return parms.int_par(\n            self.handle, 'TruncateToCylindricalFOVImageProcessor',\n            'strictly_less_than_radius') != 0",
  "class RayTracingMatrix(object):\n    \"\"\"Sparse matrix ray-tracting projector.\n\n    Class for objects holding sparse matrix representation of the ray\n    tracing projector G (see AcquisitionModel class).\n    \"\"\"\n\n    name = 'RayTracingMatrix'\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n        parms.set_int_par(self.handle, self.name, 'num_tangential_LORs', 2)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def get_info(self):\n        \"\"\"Returns the metadata from STIR as Python str.\"\"\"\n        handle = pystir.cSTIR_get_MatrixInfo(self.handle)\n        check_status(handle)\n        info = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return info\n\n    def set_num_tangential_LORs(self, value):\n        \"\"\"Sets the number of tangential LORs.\n\n        Sets the number of LORs (or rays) for each bin in the sinogram.\n        They are currently (approximately) parallel and spaced in the\n        tangential direction (i.e. orthogonal to the axial direction).\n        \"\"\"\n        parms.set_int_par(self.handle, self.name, 'num_tangential_LORs', value)\n        return self\n\n    def get_num_tangential_LORs(self):\n        \"\"\"Returns the number of LORs for each bin in the sinogram.\"\"\"\n        return parms.int_par(self.handle, self.name, 'num_tangential_LORs')\n\n    def enable_cache(self, value=True):\n        \"\"\"Enables or disables the caching mechanism.\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'enable_cache', value)\n        return self\n\n    def set_restrict_to_cylindrical_FOV(self, value=True):\n        \"\"\"Enables or disables using a circular axial FOV (vs rectangular).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'restrict_to_cylindrical_FOV', value)\n        return self\n\n    def set_do_symmetry_90degrees_min_phi(self, value=True):\n        \"\"\"Enables or disables a symmetry (disabling saves memory but might increase computation time).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'do_symmetry_90degrees_min_phi', value)\n        return self\n\n    def set_do_symmetry_180degrees_min_phi(self, value=True):\n        \"\"\"Enables or disables a symmetry (disabling saves memory but might increase computation time).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'do_symmetry_180degrees_min_phi', value)\n        return self\n\n    def set_do_symmetry_swap_segment(self, value=True):\n        \"\"\"Enables or disables a symmetry (disabling saves memory but might increase computation time).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'do_symmetry_swap_segment', value)\n        return self\n\n    def set_do_symmetry_swap_s(self, value=True):\n        \"\"\"Enables or disables a symmetry (disabling saves memory but might increase computation time).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'do_symmetry_swap_s', value)\n        return self\n\n    def set_do_symmetry_shift_z(self, value=True):\n        \"\"\"Enables or disables a symmetry (disabling saves memory but might increase computation time).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'do_symmetry_shift_z', value)\n        return self",
  "class SPECTUBMatrix:\n    '''\n    Class for objects holding sparse matrix representation of a SPECT\n    projector (developed at the University of Barcelona) (see AcquisitionModel class).\n    '''\n    name = 'SPECTUBMatrix'\n\n    def __init__(self):\n        '''\n        Create a new matrix. Default settings use neither attenuation nor resolution modelling.\n        '''\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n    def set_keep_all_views_in_cache(self, value):\n        '''\n        Enable keeping the matrix in memory.\n\n        This speeds-up the calculations, but can use a lot of memory.\n\n        You have to call set_up() after this (unless the value didn't change).\n        '''\n        parms.set_int_par(self.handle, self.name, 'keep_all_views_in_cache', value)\n        return self\n    def get_keep_all_views_in_cache(self):\n        '''\n        Returns a bool checking if we're keeping the whole matrix in memory or not.\n        '''\n        return parms.int_par(self.handle, self.name, 'keep_all_views_in_cache') != 0\n    def set_attenuation_image(self, value):\n        '''\n        Sets the attenuation image used by the projector.\n        '''\n        assert_validity(value, ImageData)\n        parms.set_parameter(self.handle, self.name, 'attenuation_image', value.handle)\n        return self\n    def get_attenuation_image(self):\n        '''\n        Returns the attenuation image used by the projector.\n        '''\n        image = ImageData()\n        image.handle = parms.parameter_handle(self.handle, self.name, 'attenuation_image')\n        return image\n\n    def set_resolution_model(self, collimator_sigma_0_in_mm, collimator_slope_in_mm, full_3D = True):\n        '''\n        Set the parameters for the depth-dependent resolution model\n\n        The detector and collimator blurring is modelled as a Gaussian with sigma dependent on the\n        distance from the collimator.\n\n        sigma_at_depth = collimator_slope * depth_in_mm + collimator sigma 0\n\n        Set slope and sigma_0 to zero to avoid resolution modelling.\n\n        You have to call set_up() after this.\n        '''\n        try_calling(pystir.cSTIR_SPECTUBMatrixSetResolution(self.handle, collimator_sigma_0_in_mm, collimator_slope_in_mm, full_3D))\n\n    def set_up(self, acq, img):\n        try_calling(pystir.cSTIR_setupSPECTUBMatrix(self.handle, acq.handle, img.handle))",
  "class PinholeSPECTUBMatrix:\n    \"\"\"\n    Class for objects holding sparse matrix representation of a pinhole SPECT\n    projector (developed at the University of Barcelona) (see AcquisitionModel class).\n    \"\"\"\n    name = 'PinholeSPECTUBMatrix'\n\n    def __init__(self):\n        \"\"\"Create a new matrix. Default settings use neither attenuation, PSF, or DOI modelling.\"\"\"\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n            \n    def get_maximum_number_of_sigmas(self):\n        \"\"\"Returns the number of sigmas to consider when correcting for intrinsic PSF.\"\"\"\n        return parms.float_par(self.handle, self.name, 'maximum_number_of_sigmas')\n    \n    def set_maximum_number_of_sigmas(self, value):\n        \"\"\"Sets the number of sigmas to consider when correcting for intrinsic PSF.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'maximum_number_of_sigmas', value)\n        \n    def get_spatial_resolution_PSF(self):\n        \"\"\"Returns the spatial high resolution in which to sample distributions (in cm).\"\"\"\n        return parms.float_par(self.handle, self.name, 'spatial_resolution_PSF')\n    \n    def set_spatial_resolution_PSF(self, value):\n        \"\"\"Sets the spatial high resolution in which to sample distributions (in cm).\"\"\"\n        parms.set_float_par(self.handle, self.name, 'spatial_resolution_PSF', value)\n        \n    def get_subsampling_factor_PSF(self):\n        \"\"\"Returns the subsampling factor to compute convolutions when PSF or DOI corrections are enabled.\"\"\"\n        return parms.int_par(self.handle, self.name, 'subsampling_factor_PSF')\n    \n    def set_subsampling_factor_PSF(self, value):\n        \"\"\"Sets the subsampling factor to compute convolutions when PSF or DOI corrections are enabled.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'subsampling_factor_PSF', value)\n\n    def set_detector_file(self, filename):\n        \"\"\"Sets the name of the file containing the detector information.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'detector_file', filename)\n    \n    def set_collimator_file(self, filename):\n        \"\"\"Sets the name of the file containing the collimator information.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'collimator_file', filename)\n        \n    def get_psf_correction(self):\n        \"\"\"Returns the setting for enabling corrections for intrinsic PSF.\"\"\"\n        return parms.char_par(self.handle, self.name, 'psf_correction')\n        \n    def set_psf_correction(self, value):\n        \"\"\"Enable or disable corrections for intrinsic PSF.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'psf_correction', value)\n        \n    def get_doi_correction(self):\n        \"\"\"Returns the setting for enabling corrections for depth of interaction.\"\"\"\n        return parms.char_par(self.handle, self.name, 'doi_correction')\n        \n    def set_doi_correction(self, value):\n        \"\"\"Enable or disable corrections for depth of interaction.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'doi_correction', value)\n        \n    def get_attenuation_type(self):\n        \"\"\"Returns the attenuation type: full, simple, or no.\"\"\"\n        return parms.char_par(self.handle, self.name, 'attenuation_type')\n        \n    def set_attenuation_type(self, value):\n        \"\"\"Set the attenuation type to full, simple, or no.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'attenuation_type', value)\n        \n    def get_attenuation_image(self):\n        \"\"\"Returns the attenuation image used by the projector.\"\"\"\n        image = ImageData()\n        image.handle = parms.parameter_handle(self.handle, self.name, 'attenuation_image')\n        return image\n\n    def set_attenuation_image(self, value):\n        \"\"\"Sets the attenuation image used by the projector.\"\"\"\n        assert_validity(value, ImageData)\n        parms.set_parameter(self.handle, self.name, 'attenuation_image', value.handle)\n        return self\n        \n    def get_object_radius(self):\n        \"\"\"Returns the radius of the object in the xy plane of the image volume.\"\"\"\n        return parms.float_par(self.handle, self.name, 'object_radius')\n    \n    def set_object_radius(self, value):\n        \"\"\"Sets the radius of the object in the xy plane of the image volume. Could be used for masking.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'object_radius', value)\n        \n    def get_mask_image(self):\n        \"\"\"Returns the mask image used by the projector.\"\"\"\n        image = ImageData()\n        image.handle = parms.parameter_handle(self.handle, self.name, 'mask_image')\n        return image\n\n    def set_mask_image(self, value):\n        \"\"\"Sets the mask image used by the projector.\"\"\"\n        assert_validity(value, ImageData)\n        parms.set_parameter(self.handle, self.name, 'mask_image', value.handle)\n        return self\n        \n    def get_keep_all_views_in_cache(self):\n        \"\"\"Returns a bool checking if we're keeping the whole matrix in memory or not.\"\"\"\n        return parms.bool_par(self.handle, self.name, 'keep_all_views_in_cache')\n            \n    def set_keep_all_views_in_cache(self, value):\n        \"\"\"Enable keeping the matrix in memory to speed-up calculations (can use lots of memory).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'keep_all_views_in_cache', value)\n        return self\n        \n    def get_mask_from_attenuation_map(self):\n        \"\"\"Returns a bool checking if we're masking with the attenuation map or not.\"\"\"\n        return parms.bool_par(self.handle, self.name, 'mask_from_attenuation_map')\n            \n    def set_mask_from_attenuation_map(self, value):\n        \"\"\"Enable masking from attenuation map if mask file is not set.\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'mask_from_attenuation_map', value)\n        return self",
  "class AcquisitionData(DataContainer):\n    \"\"\"Class for PET acquisition data.\"\"\"\n\n    def __init__(self, src=None, span=1, max_ring_diff=-1, view_mash_factor=1, tof_mash_factor=1):\n        \"\"\"Creates new AcquisitionData.\n\n        Can create object from a file or another AcquisitionData object.\n        src:  file name (Python str) or AcquisitionData object or scanner name\n        \"\"\"\n        self.handle = None\n        self.name = 'AcquisitionData'\n        self.read_only = False\n        self.src = None\n        if src is None:\n            return\n        if isinstance(src, str):\n            i = src.find('.')\n            if i > -1:\n                # src is a file name\n                self.handle = pystir.cSTIR_objectFromFile(\n                    'AcquisitionData', src)\n                self.read_only = self.get_storage_scheme() == 'file'\n                self.src = 'file'\n            else:\n                # src is a scanner name\n                self.handle = pystir.cSTIR_acquisitionDataFromScannerInfo(\n                    src, span, max_ring_diff, view_mash_factor, tof_mash_factor)\n                if pyiutil.executionStatus(self.handle) != 0:\n                    msg = pyiutil.executionError(self.handle)\n                    if msg == 'Unknown scanner':\n                        raise error(\n                            'Unknown scanner ' + src +\n                            ' or missing raw data file extension')\n                self.src = 'scanner'\n        elif isinstance(src, AcquisitionData):\n            # src is AcquisitionData\n            if src.handle is None:\n                raise AssertionError()\n            self.handle = pystir.cSTIR_acquisitionDataFromTemplate(src.handle)\n            self.src = 'template'\n        else:\n            raise error('Wrong source in AcquisitionData constructor')\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        # print('deleting AcquisitionData object originated from ', self.src)\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    @staticmethod\n    def set_storage_scheme(scheme):\n        \"\"\"Sets acquisition data storage scheme.\n\n        scheme = 'file' (default):\n            all acquisition data generated from now on will be kept in\n            scratch files deleted after the user's script terminates\n        scheme = 'memory':\n            all acquisition data generated from now on will be kept in RAM\n            (avoid if data is very large)\n        \"\"\"\n        try_calling(pystir.cSTIR_setAcquisitionDataStorageScheme(scheme))\n\n    @staticmethod\n    def get_storage_scheme():\n        \"\"\"Returns acquisition data storage scheme.\"\"\"\n        handle = pystir.cSTIR_getAcquisitionDataStorageScheme()\n        check_status(handle)\n        scheme = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return scheme\n\n    def same_object(self):\n        \"\"\"See DataContainer method.\"\"\"\n        return AcquisitionData()\n\n    def read_from_file(self, filename):  # 'read_from_file' is misleading\n        \"\"\"\n        Reads data from file.\n\n        Replaces the current content of the object.\n        \"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pystir.cSTIR_objectFromFile('AcquisitionData', filename)\n        check_status(self.handle)\n        self.read_only = True\n\n    def create_uniform_image(self, value=0, xy=None):\n        \"\"\"Crates uniform image.\n\n        Creates ImageData object containing PET image of z-dimension\n        and voxel sizes compatible with the scanner geometry stored\n        in this AcquisitionData object and assigns a given value\n        to all voxels;\n        value: a Python float.\n        xy   : x and y dimensions tuple (if None, set by STIR)\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        image = ImageData()\n        if xy is None:\n            image.handle = pystir.cSTIR_imageFromAcquisitionData(self.handle)\n        elif isinstance(xy, tuple):\n            image.handle = pystir.cSTIR_imageFromAcquisitionDataAndNxNy(\n                self.handle, xy[1], xy[0])\n        elif isinstance(xy, int):\n            image.handle = pystir.cSTIR_imageFromAcquisitionDataAndNxNy(\n                self.handle, xy, xy)\n        else:\n            raise error('Wrong second argument in create_uniform_image')\n        check_status(image.handle)\n        image.fill(value)\n        return image\n\n    def dimensions(self):\n        \"\"\"Returns a tuple of the data dimensions.\n\n        Contains:\n        - number of TOF bins\n        - number of sinograms\n        - number of views\n        - number of tangential positions.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        dim = numpy.ndarray((MAX_ACQ_DIMS,), dtype=cpp_int_dtype())\n        try_calling(pystir.cSTIR_getAcquisitionDataDimensions(\n            self.handle, dim.ctypes.data))\n        dim = dim[:4]\n        return tuple(dim[::-1])\n\n    def get_tof_mash_factor(self):\n        '''Returns TOF mashing factor.'''\n        return parms.int_par(self.handle, 'AcquisitionData', 'tof_mash_factor')\n\n    def as_array(self):\n        \"\"\"Returns bin values as ndarray.\n\n        Return a copy of acquisition data stored in this object as a\n        NumPy ndarray of 4 dimensions (in default C ordering of data):\n        - number of TOF bins\n        - number of sinograms\n        - number of views\n        - number of tangential positions.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        array = numpy.ndarray(self.dimensions(), dtype=numpy.float32)\n        try_calling(pystir.cSTIR_getAcquisitionData(\n            self.handle, array.ctypes.data))\n        return array\n\n    def fill(self, value):\n        \"\"\"Fills the object with values.\n\n        value:  either NumPy ndarray or another AcquisitionData object\n                or Python float.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if self.read_only:\n            raise error(\n                'Cannot fill read-only object, consider filling a clone')\n        if isinstance(value, numpy.ndarray):\n            dims = self.dimensions()\n            shape = value.shape\n            if shape != dims:\n                msg = 'cannot fill AcquisitionData of size %s' \\\n                      + ' with data of size %s'\n                raise ValueError(msg % (repr(dims), repr(shape)))\n            if value.dtype is numpy.dtype('float32'):\n                # print('keeping dtype float32')\n                v = value\n            else:\n                # print('changing dtype to float32')\n                v = value.astype(numpy.float32)\n            if not v.flags['C_CONTIGUOUS']:\n                v = numpy.ascontiguousarray(v)\n            try_calling(pystir.cSTIR_setAcquisitionData(\n                self.handle, v.ctypes.data))\n        elif isinstance(value, AcquisitionData):\n            if value.handle is None:\n                raise AssertionError()\n            try_calling(pystir.cSTIR_fillAcquisitionDataFromAcquisitionData(\n                self.handle, value.handle))\n        elif isinstance(value, float):\n            try_calling(pystir.cSTIR_fillAcquisitionData(self.handle, value))\n        elif isinstance(value, (Integral,numpy.number)):\n            try_calling(pystir.cSTIR_fillAcquisitionData(\n                self.handle, float(value)))\n        else:\n            raise TypeError('Wrong fill value.' + \\\n                ' Should be numpy.ndarray, AcquisitionData, float or int, got {}'\\\n                .format(type(value)))\n        return self\n\n    def get_uniform_copy(self, value=0):\n        \"\"\"Returns a copy of this object filled with given value.\n\n        Returns a true copy of this object filled with a given value;\n        value:  a Python float.\n        \"\"\"\n        ad = AcquisitionData(self)\n        ad.fill(value)\n        ad.src = 'copy'\n        return ad\n\n    def rebin(self, num_segments_to_combine,\n              num_views_to_combine=1, num_tang_poss_to_trim=0,\n              do_normalisation=True, max_in_segment_num_to_process=-1,\n              num_tof_bins_to_combine=1):\n        \"\"\"Re-bins the data to lower resolution.\n\n        Keyword arguments:\n\t\tnum_segments_to_combine -- combines multiple oblique 'segments' together. If set to the\n\t\t    total number of segments, this corresponds to SSRB. Another example is if the input data\n\t\t\thas 'span=1', the output span will be equal to the \\c num_segments_to_combine.\n\t\tnum_views_to_combine -- combines neighbouring views. Needs to be a divisor of the total\n\t\t    number of views in the data.\n\t\tnum_tang_poss_to_trim -- removes a number of tangential positions (horizontal direction\n\t\t    in the sinogram) at each end\n\t\tdo_normalisation -- if True, averages the data, otherwise it adds the data. Often\n\t\t    the latter is required for emission data (as it preserves Poisson statistics),\n\t\t\twhile the former should be used for corrected data (or for attenuation correction factors).\n\t\tmax_in_segment_num_to_process -- by default all input data are used. If set to a non-negative\n\t\t    number, it will remove the most oblique segments.\n\t\tnum_tof_bins_to_combine -- number of TOF bins to combine.\n        \"\"\"\n        ad = AcquisitionData()\n        ad.handle = pystir.cSTIR_rebinnedAcquisitionData(\n            self.handle,\n            num_segments_to_combine, num_views_to_combine,\n            num_tang_poss_to_trim, do_normalisation,\n            max_in_segment_num_to_process, num_tof_bins_to_combine)\n        check_status(ad.handle)\n        return ad\n\n    def show(self, sino=None, tof=0, title=None):\n        '''Displays selected sinograms.'''\n        if self.handle is None:\n            raise AssertionError()\n        if not HAVE_PYLAB:\n            print('pylab not found')\n            return\n        data = self.as_array()\n        if tof <0 or tof >= data.shape[0]:\n            raise IndexError('TOF bin index out of range')\n        nz = data.shape[1]\n        if isinstance(sino, (Integral,numpy.integer)):\n            if sino < 0 or sino >= nz:\n                raise IndexError('Slice index out of range')\n            show_2D_array('sinogram %d' % sino, data[tof, sino, :, :])\n            return\n        elif sino is None:\n            ns = nz\n            sino = range(nz)\n        else:\n            try:\n                ns = len(sino)\n            except:\n                raise error('wrong sinograms list')\n        if title is None:\n            title = 'Selected sinograms'\n        if ns >= 16:\n            tiles = (4, 4)\n        else:\n            tiles = None\n        f = 0\n        while f < ns:\n            t = min(f + 16, ns)\n            show_3D_array(\n                data[0, :, :, :],\n                index=sino[f: t], tile_shape=tiles,\n                label='sinogram',\n                xlabel='tang.pos', ylabel='view',\n                suptitle=title, show=(t == ns))\n            f = t\n\n    def allocate(self, value=0, **kwargs):\n        \"\"\"Alias to get_uniform_copy.\n\n        CIL/SIRF compatibility\n        \"\"\"\n        if value in ['random', 'random_int']:\n            out = self.get_uniform_copy()\n            shape = out.as_array().shape\n            seed = kwargs.get('seed', None)\n            if seed is not None:\n                numpy.random.seed(seed)\n            if value == 'random':\n                out.fill(numpy.random.random_sample(shape))\n            elif value == 'random_int':\n                max_value = kwargs.get('max_value', 100)\n                out.fill(numpy.random.randint(max_value,size=shape))\n        elif value is None:\n            out = self.get_uniform_copy(0)\n        else:\n            out = self.get_uniform_copy(value)\n        return out\n\n    def get_info(self):\n        \"\"\"Returns the AcquisitionData's metadata as Python str.\"\"\"\n        handle = pystir.cSTIR_get_ProjDataInfo(self.handle)\n        check_status(handle)\n        info = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return info\n\n    def get_subset(self, views):\n        \"\"\"Returns the subset of self data formed by specified views\n\n        views: array of views (will be converted to numpy ndarray)\n        \"\"\"\n        # Ensure the array passed to C++ is a contiguous array of C++ int's\n        v = cpp_int_array(views)\n        n = len(views)\n        subset = AcquisitionData()\n        subset.handle = pystir.cSTIR_get_subset(self.handle, n, v.ctypes.data)\n        check_status(subset.handle)\n        return subset\n\n    @property\n    def shape(self):\n        return self.dimensions()",
  "class ListmodeToSinograms(object):\n    \"\"\"\n    Class for listmode-to-sinogram converter.\n\n    This class reads list mode data and produces corresponding *sinograms*,\n    i.e. histogrammed data in the format of PETAcquisitionData.\n\n    It has two main functions:\n      - process() can be used to read prompts and/or delayed coincidences to\n        produce a single PETAcquisitionData.\n        Two conversion flags decide what is to be done with 3 possible cases:\n        - `store_prompts`=`true`, `store_delayeds`=`false`:\n        only prompts stored\n        - `store_prompts`=`false`, `store_delayeds`=`true`:\n        only delayeds stored\n        - `store_prompts`=`true`, `store_delayeds`=`true`:\n        prompts-delayeds stored\n        Clearly, enabling the `store_delayeds` option only makes sense if the\n        data was acquired accordingly.\n      - estimate_randoms() can be used to get a relatively noiseless estimate\n        of the random coincidences.\n\n    Currently, the randoms are estimated from the delayed coincidences using\n    the following strategy:\n       1. singles (one per detector) are estimated using a Maximum Likelihood\n          estimator\n       2. randoms-from-singles are computed per detector-pair via the usual\n          product formula. These are then added together for all detector pairs\n          in a certain histogram-bin in the data (accommodating for view\n          mashing and axial compression).\n\n    The actual algorithm is described in\n\n    D. Hogg, K. Thielemans, S. Mustafovic, and T. J. Spinks,\n    \"A study of bias for various iterative reconstruction methods in PET,\"\n    in 2002 IEEE Nuclear Science Symposium Conference Record, vol. 3. IEEE,\n    Nov. 2002, pp. 1519-1523 (http://dx.doi.org/10.1109/nssmic.2002.1239610).\n    \"\"\"\n\n    def __init__(self, file=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'ListmodeToSinograms'\n        if file is None:\n            self.handle = pystir.cSTIR_newObject(self.name)\n        else:\n            self.handle = pystir.cSTIR_objectFromFile(self.name, file)\n        self.output = None\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_input(self, lm_file):\n        \"\"\"Sets the listmode file name.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'input', lm_file)\n\n    def set_output_prefix(self, sino_file):\n        \"\"\"Sets the sinograms file names prefix.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'output', sino_file)\n\n    def set_template(self, templ):\n        \"\"\"Sets the sinograms template.\n\n        templ: either file name or AcquisitionData\n        \"\"\"\n        if type(templ) == type('a'):\n            parms.set_char_par(self.handle, self.name, 'template_file', templ)\n        else:\n            parms.set_parameter(self.handle, self.name, 'template', templ.handle)\n\n    def set_time_interval(self, start, stop):\n        \"\"\"Sets the time interval.\n\n        Only data scanned during this time interval will be converted.\n        \"\"\"\n        interval = numpy.ndarray((2,), dtype=numpy.float32)\n        interval[0] = start\n        interval[1] = stop\n        try_calling(pystir.cSTIR_setListmodeToSinogramsInterval(\n            self.handle, interval.ctypes.data))\n\n    def flag_on(self, flag):\n        \"\"\"Switches on (sets to 'true') a conversion flag.\n\n        (see conversion flags description above).\n        \"\"\"\n        try_calling(pystir.cSTIR_setListmodeToSinogramsFlag(\n            self.handle, flag, 1))\n\n    def flag_off(self, flag):\n        \"\"\"Switches off (sets to 'false') a conversion flag.\n\n        (see conversion flags description above).\n        \"\"\"\n        try_calling(pystir.cSTIR_setListmodeToSinogramsFlag(\n            self.handle, flag, 0))\n\n    def set_up(self):\n        \"\"\"Sets up the conversion.\"\"\"\n        try_calling(\n            pystir.cSTIR_setupListmodeToSinogramsConverter(self.handle))\n\n    def process(self):\n        \"\"\"Performs the conversion.\"\"\"\n        self.output = AcquisitionData()\n        self.output.handle = pystir.cSTIR_convertListmodeToSinograms(\n            self.handle)\n        check_status(self.output.handle)\n\n    def get_output(self):\n        \"\"\"Returns the sinograms as an AcquisitionData object.\"\"\"\n        if self.output is None:\n            raise error('Conversion to sinograms not done')\n        return self.output\n\n    def estimate_randoms(self):\n        \"\"\"Returns an estimate of the randoms as an AcquisitionData object.\"\"\"\n        randoms = AcquisitionData()\n        randoms.handle = pystir.cSTIR_computeRandoms(self.handle)\n        check_status(randoms.handle)\n        return randoms\n\n    def get_time_at_which_num_prompts_exceeds_threshold(self, threshold):\n        \"\"\"Returns the time at which the number of prompts exceeds <threshold>.\n\n        Returns -1 if no corresponding time is found.\n        \"\"\"\n        h = pystir.cSTIR_lm_num_prompts_exceeds_threshold(\n            self.handle, float(threshold))\n        check_status(h, inspect.stack()[1])\n        v = pyiutil.floatDataFromHandle(h)\n        pyiutil.deleteDataHandle(h)\n        return v",
  "class AcquisitionSensitivityModel(object):\n    \"\"\"\n    Class that handles PET scanner detector efficiencies and attenuation.\n\n    Is used by AcquisitionModel (see below).\n    \"\"\"\n\n    def __init__(self, src, other_src=None):\n        \"\"\"\n        Create new AcquisitionSensitivityModel object.\n\n        Sources:\n        - from a manufacturer normalisation file (supported by STIR) or\n        - from ImageData object containing attenuation image (units: 1/cm) or\n        - from AcquisitionData object containing bin efficiencies or\n        - by chaining two existing AcquisitionSensitivityModel objects\n        src: file name or ImageData object or AcquisitionData object\n        other_src: AcquisitionSensitivityModel object (optional)\n        \"\"\"\n        self.handle = None\n        self.name = 'AcquisitionSensitivityModel'\n        if src is None:\n            return\n        if isinstance(src, str):\n            # create from ECAT8/GE norm file\n            print('Reading manufacturer PET normalisation file from ' + src)\n            handle = pyiutil.charDataHandle(src)\n            self.handle = pystir.cSTIR_createPETAcquisitionSensitivityModel(\n                handle, 'n')\n            pyiutil.deleteDataHandle(handle)\n        elif isinstance(src, ImageData):\n            # create from attenuation image\n            if src.handle is None:\n                raise AssertionError()\n            if other_src is None:\n                raise AssertionError('AcquisitionSensitivityModel constructor' +\n                ' with attenuation image needs an AcquisitionModel' +\n                ' as second argument (for ray tracing)')\n            assert_validity(other_src, AcquisitionModel)\n            self.handle = pystir.cSTIR_createPETAttenuationModel(\n                src.handle, other_src.handle)\n        elif isinstance(src, AcquisitionData):\n            # create from bin efficiencies (cf. AcquisitionModel)\n            if src.handle is None:\n                raise AssertionError()\n            self.handle = pystir.cSTIR_createPETAcquisitionSensitivityModel(\n                src.handle, 's')\n        elif isinstance(src, AcquisitionSensitivityModel) and \\\n                isinstance(other_src, AcquisitionSensitivityModel):\n            # chain two acquisition sensitivity models\n            if src.handle is None:\n                raise AssertionError()\n            if other_src.handle is None:\n                raise AssertionError()\n            self.handle = pystir.cSTIR_chainPETAcquisitionSensitivityModels(\n                src.handle, other_src.handle)\n        else:\n            raise error(\n                'Wrong source in AcquisitionSensitivityModel constructor')\n        check_status(self.handle)\n\n    def set_up(self, ad):\n        \"\"\"Sets up the object.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(ad, AcquisitionData)\n        try_calling(pystir.cSTIR_setupAcquisitionSensitivityModel(\n            self.handle, ad.handle))\n\n    def normalise(self, ad):\n        \"\"\"Multiplies ad by the inverse n of S from AcquisitionModel (F).\n\n        If self is a chain of two AcquisitionSensitivityModels, then n is\n        a product of two normalisations.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(ad, AcquisitionData)\n        try_calling(pystir.cSTIR_applyAcquisitionSensitivityModel(\n            self.handle, ad.handle, 'normalise'))\n\n    def unnormalise(self, ad):\n        \"\"\"Multiply the argument by S from AcquisitionModel (F).\n\n        If self is a chain of two AcquisitionSensitivityModels, then S is\n        a product of two un-normalisations.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(ad, AcquisitionData)\n        try_calling(pystir.cSTIR_applyAcquisitionSensitivityModel(\n            self.handle, ad.handle, 'unnormalise'))\n\n    def forward(self, ad):\n        \"\"\"Alias of unnormalise except the argument remains unchanged\n\n        and a new AcquisitionData equal to the argument multiplied\n        by S is returned.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(ad, AcquisitionData)\n        fd = AcquisitionData()\n        fd.handle = pystir.cSTIR_applyAcquisitionSensitivityModel(\n            self.handle, ad.handle, 'fwd')\n        check_status(fd.handle)\n        return fd\n\n    def invert(self, ad):\n        \"\"\"Alias of normalise except that the argument remains unchanged\n\n        and a new AcquisitionData equal to the argument multiplied\n        by the inverse of S is returned.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(ad, AcquisitionData)\n        fd = AcquisitionData()\n        fd.handle = pystir.cSTIR_applyAcquisitionSensitivityModel(\n            self.handle, ad.handle, 'inv')\n        check_status(fd.handle)\n        return fd\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "class AcquisitionModel(object):\n    \"\"\"Class for PET acquisition model.\n\n    Class for a PET acquisition model that relates an image x to the\n    acquisition data y as\n\n    (F)    y = [S] (G [P] x + [a]) + [b]\n\n    where:\n    square brackets embrace optional terms;\n    P is an ImageDataProcessor, assumed to be the identity\n    if not present;\n    G is the geometric (ray tracing) projector from the image voxels\n    to the scanner's pairs of detectors (bins);\n    a and b are the additive and background terms representing\n    the effects of accidental coincidences and scattering, assumed\n    to be 0 if not present;\n    S is the acquisition sensitivity map representing the\n    detector (bin) efficiencies (see AcquisitionSensitivityModel),\n    assumed to be the identity if not present.\n\n    The computation of y for a given x by the above formula (F) is\n    referred to as the forward projection, and the computation of\n\n    (B)    z = P' G' S y\n\n    where P' and G' are the transposes of P and G, is referred to as\n    the backprojection.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.acq_templ = None\n        self.img_templ = None\n        # reference to the background term\n        self.bt = None\n        # reference to the additive term\n        self.at = None\n        # reference to the acquisition sensitivity model\n        self.asm = None\n        # default values of subset number and selected subset\n        self._num_subsets = 1\n        self._subset_num = 0\n        # constness flag for const reference\n        self.const = False\n\n    def set_up(self, acq_templ, img_templ):\n        \"\"\"Sets up.\n\n        Prepares this object for performing forward and backward\n        projections;\n        acq_templ:  an AcquisitionData object used as a template for\n                    creating an AcquisitionData object to store forward\n                    projection;\n        img_templ:  an ImageData object used as a template for creating an\n                    ImageData object to store backward projection.\n        \"\"\"\n        if self.const:\n            raise RuntimeError('cannot set_up const object')\n\n        assert_validity(acq_templ, AcquisitionData)\n        assert_validity(img_templ, ImageData)\n\n        try_calling(pystir.cSTIR_setupAcquisitionModel(\n            self.handle, acq_templ.handle, img_templ.handle))\n\n        self.acq_templ = acq_templ\n        self.img_templ = img_templ\n\n    def norm(self, subset_num=0, num_subsets=1, num_iter=2, verb=0):\n        \"\"\"Computes the norm of a part the linear operator S G.\n\n        See the docstring for method forward for the desciption of\n        the partial forward projection and the arguments.\n        \"\"\"\n        assert self.handle is not None\n        handle = pystir.cSTIR_acquisitionModelNorm \\\n                 (self.handle, subset_num, num_subsets, num_iter, verb)\n        check_status(handle)\n        r = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return r;\n\n    def set_additive_term(self, at):\n        \"\"\"Sets additive term.\n\n        Sets the additive term a in the acquisition model;\n        at:  an AcquisitionData object containing a.\n        \"\"\"\n        if self.const:\n            raise RuntimeError('cannot set_additive_term for a const object')\n        assert_validity(at, AcquisitionData)\n        parms.set_parameter(\n            self.handle, 'AcquisitionModel', 'additive_term', at.handle)\n        # save reference to the additive term\n        self.at = at\n\n    def set_background_term(self, bt):\n        \"\"\"\n        Sets the background term b in the acquisition model.\n\n        bt:  an AcquisitionData object containing b.\n        \"\"\"\n        if self.const:\n            raise RuntimeError('cannot set_background_term for a const object')\n        assert_validity(bt, AcquisitionData)\n        parms.set_parameter(\n            self.handle, 'AcquisitionModel', 'background_term', bt.handle)\n        # save reference to the background term\n        self.bt = bt\n\n    def set_image_data_processor(self, processor):\n        \"\"\"\n        Sets the image processor P in the acquisition model.\n\n        processor:  an ImageDataProcessor object.\n        \"\"\"\n        if self.const:\n            msg = 'cannot set_image_data_processor'\n            raise RuntimeError(msg + ' for a const object')\n        assert_validity(processor, ImageDataProcessor)\n        parms.set_parameter(\n            self.handle, 'AcquisitionModel', 'image_data_processor',\n            processor.handle)\n\n    def get_background_term(self):\n        \"\"\"Returns the background term b of the AcquisitionModel (F).\n        \"\"\"\n        if self.bt is None:\n            if self.acq_templ is None:\n                raise RuntimeError('AcquisitionModel.set_up() call missing')\n            self.bt = AcquisitionData(self.acq_templ)\n            self.bt.fill(0)\n        return self.bt\n\n    def get_additive_term(self):\n        \"\"\"Returns the additive term a of the AcquisitionModel (F).\n        \"\"\"\n        if self.at is None:\n            if self.acq_templ is None:\n                raise RuntimeError('AcquisitionModel.set_up() call missing')\n            self.at = AcquisitionData(self.acq_templ)\n            self.at.fill(0)\n        return self.at\n\n    def get_constant_term(self):\n        \"\"\"Returns the constant term S a + b in (F).\n        \"\"\"\n        if self.asm is not None:\n            return self.asm.forward(self.get_additive_term()) + \\\n                   self.get_background_term()\n        else:\n            return self.get_additive_term() + self.get_background_term()\n\n    def set_acquisition_sensitivity(self, asm):\n        \"\"\"Sets S in the AcquisitionModel (F).\n\n        asm:  an AcquisitionSensitivityModel object.\n        \"\"\"\n        if self.const:\n            msg = 'cannot set_acquisition_sensitivity'\n            raise RuntimeError(msg + ' for a const object')\n        assert_validity(asm, AcquisitionSensitivityModel)\n        parms.set_parameter(\n            self.handle, 'AcquisitionModel', 'asm', asm.handle)\n        # save reference to the Acquisition Sensitivity Model\n        self.asm = asm\n\n    def forward(self, image, subset_num=None, num_subsets=None, out=None):\n        \"\"\"Returns the [partial] forward projection of image.\n\n        If <num_subsets> is greater than 1, then the forward projection data\n        y in AcquisitionModel (F) is divided into <num_subsets> subsets and\n        only subset <subset_num> is computed; otherwise the full forward\n        projection is computed.\n        image      : an ImageData object.\n        subset_num : int, optional\n                     subset number to forward project to; if None, subset_num\n                     is set to self.subset_num.\n        num_subsets: int, optional\n                     number of subsets y is divided into; if None, num_subsets\n                     is set to self.num_subsets.\n        out        : an existing AcquisitionData object, optional\n                     the destination for the projection; if None a new\n                     AcquisitionData object will be returned.\n        \"\"\"\n        assert_validity(image, ImageData)\n        if subset_num is None:\n            subset_num = self.subset_num\n        if num_subsets is None:\n            num_subsets = self.num_subsets\n        if out is None:\n            ad = AcquisitionData()\n            ad.handle = pystir.cSTIR_acquisitionModelFwd(\n                self.handle, image.handle, subset_num, num_subsets)\n            check_status(ad.handle)\n            return ad\n        ad = out\n        assert_validity(ad, AcquisitionData)\n        try_calling(pystir.cSTIR_acquisitionModelFwdReplace(\n            self.handle, image.handle, subset_num, num_subsets, ad.handle))\n\n    def backward(self, ad, subset_num=None, num_subsets=None, out=None):\n        \"\"\"\n        Return the [partial] backward projection of ad.\n\n        ad         : an AcquisitionData object.\n        subset_num : int, optional\n                     subset number to backproject; if None, is set to\n                     self.subset_num.\n        num_subsets: int, optional\n                     the number of subsets of ad; if None, is set to\n                     self.num_subsets.\n        out        : optional AcquisitionData to store the result into. \n                     Default None, if None a new AcquisitionData will be \n                     returned.\n        \"\"\"\n        assert_validity(ad, AcquisitionData)\n        if subset_num is None:\n            subset_num = self.subset_num\n        if num_subsets is None:\n            num_subsets = self.num_subsets\n        if out is None:\n            image = ImageData()\n            image.handle = pystir.cSTIR_acquisitionModelBwd(\n                self.handle, ad.handle, subset_num, num_subsets)\n            check_status(image.handle)\n            return image\n        assert_validity(out, ImageData)\n        try_calling(pystir.cSTIR_acquisitionModelBwdReplace(\n                self.handle, ad.handle, subset_num, num_subsets, out.handle))\n\n    def get_linear_acquisition_model(self):\n        \"\"\"Returns the linear part L = S G P of self.\n        \"\"\"\n        am = AcquisitionModel()\n        am.handle = pystir.cSTIR_linearAcquisitionModel(self.handle)\n        check_status(am.handle)\n        am.const = True # am to be a const reference of self\n        return am\n\n    def direct(self, image, out=None):\n        '''Projects an image into the (simulated) acquisition space,\n           calls forward with num_subset and on subset_num members\n\n           Added for CCPi CIL compatibility\n           https://github.com/CCPPETMR/SIRF/pull/237#issuecomment-439894266\n        '''\n        if self.is_linear():\n            return self.forward(image, \\\n                                subset_num=self.subset_num, \\\n                                num_subsets=self.num_subsets, \\\n                                out=out)\n        else:\n            raise error('AcquisitionModel is not linear\\nYou can get the ' +\n                        'linear part of the AcquisitionModel with ' +\n                        'get_linear_acquisition_model')\n        \n    def adjoint(self, ad, out=None):\n        '''Back-projects acquisition data into image space, if the\n           AcquisitionModel is linear\n\n           calls backward with num_subset and on subset_num members\n           Added for CCPi CIL compatibility\n           https://github.com/CCPPETMR/SIRF/pull/237#issuecomment-439894266\n        '''\n        return self.backward(ad, subset_num=self.subset_num, \n                             num_subsets=self.num_subsets, out=out)\n\n    def is_affine(self):\n        \"\"\"Returns True if the acquisition model is affine.\n        \"\"\"\n        return True\n\n    def is_linear(self):\n        \"\"\"Return true if the acquisition model constant term is zero.\n\n        i.e. corresponding to\n        A*x, with zero background term.\n        \"\"\"\n        if self.bt is None and self.at is None:\n            return True\n        else:\n            if self.bt is None and self.at is not None:\n                return self.at.norm() == 0\n            elif self.bt is not None and self.at is None:\n                return self.bt.norm() == 0\n            else:\n                return self.bt.norm() == 0 and self.at.norm() == 0\n\n    def range_geometry(self):\n        \"\"\"Return the template of AcquisitionData.\"\"\"\n        geom = AcquisitionData()\n        geom.handle = pystir.cSTIR_parameter(\n            self.handle, 'AcquisitionModel', 'range geometry')\n        check_status(geom.handle)\n        return geom\n\n    def domain_geometry(self):\n        \"\"\"Return the template of ImageData.\"\"\"\n        geom = ImageData()\n        geom.handle = pystir.cSTIR_parameter(\n            self.handle, 'AcquisitionModel', 'domain geometry')\n        check_status(geom.handle)\n        return geom\n\n    @property\n    def subset_num(self):\n        '''Selected subset number\n \n        This value is used by direct and adjoint methods and are the \n        default values used by forward and back projection for their \n        parameter subset_num.\n        \n        Default value is 0.\n        '''\n        return self._subset_num\n    \n    @property\n    def num_subsets(self):\n        '''Number of subsets to divide the AcquisitionData during projection\n\n        This value is used by the direct and adjoint methods. Additionally, \n        this value is the default value used by forward and back projection\n        for the parameter num_subsets.\n        \n        Default value is 1 and corresponds to forward/backward projecting\n        the whole dataset.\n\n        '''\n        return self._num_subsets\n    \n    @subset_num.setter\n    def subset_num(self, value):\n        '''setter for subset_num\n        \n        value: int >= 0 and < num_subsets\n        '''\n        if isinstance (value, Integral):\n            if value < self.num_subsets and value >= 0:\n                self._subset_num = value\n            else:\n                raise ValueError(\"Expected a subset number below {} and larger or equal than 0. Got {}\"\\\n                    .format(self.subset_num, value))\n        else:\n            raise ValueError(\"Expected an integer. Got {}\".format(type(value)))\n    \n    @num_subsets.setter\n    def num_subsets(self, value):\n        '''setter for num_subsets\n\n        value: int > 0.\n        Allows to set the number of subsets the AcquisitionModel operates on. \n        Notice that reassigning the num_subsets to any valid number will also \n        set the property subset_num to 0.\n        '''\n        if isinstance (value, Integral):\n            if value > 0:\n                self._num_subsets = value\n                self.subset_num = 0\n                \n            else:\n                raise ValueError(\"Expected a subset number larger than 0. Got {}\"\\\n                    .format(value))\n        else:\n            raise ValueError(\"Expected an integer. Got {}\".format(type(value)))",
  "class AcquisitionModelUsingMatrix(AcquisitionModel):\n    \"\"\"PET acquisition model with sparse matrix.\n\n    Class for a PET acquisition model that uses (implicitly) a sparse\n    matrix for G in AcquisitionModel (F).\n    \"\"\"\n\n    def __init__(self, matrix=None):\n        \"\"\"Creates an AcquisitionModelUsingMatrix object,\n\n        optionally setting the ray tracing matrix to be used for projecting.\n        matrix: an object to represent G in (F).\n        # TODO will need to try different matrices here\n        \"\"\"\n        super(AcquisitionModelUsingMatrix, self).__init__()\n        self.handle = None\n        self.name = 'AcqModUsingMatrix'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n        if matrix is None:\n            matrix = RayTracingMatrix()\n        self.set_matrix(matrix)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_matrix(self, matrix):\n        '''\n        Sets the matrix G to be used for projecting;\n        matrix:  a matrix object to represent G in acquisition model (F).\n        '''\n        # The following allows for different matrices\n        try:\n            parms.set_parameter(self.handle, self.name, 'matrix', matrix.handle)\n        except:\n            raise AssertionError('Unknown matrix type.')",
  "class AcquisitionModelUsingRayTracingMatrix(AcquisitionModelUsingMatrix):\n    \"\"\"PET acquisition model with RayTracingMatrix.\n\n    Class for a PET acquisition model that uses (implicitly) a RayTracingMatrix\n    for G in AcquisitionModel (F).\n    \"\"\"\n\n    def __init__(self, matrix=None):\n        \"\"\"Create an AcquisitionModelUsingMatrix object,\n\n        optionally setting the ray tracing matrix to be used for projecting;\n        matrix: a RayTracingMatrix object to represent G in (F).\n        \"\"\"\n        if matrix is None:\n            matrix = RayTracingMatrix()\n        assert_validity(matrix, RayTracingMatrix)\n        super(AcquisitionModelUsingRayTracingMatrix, self).__init__(matrix)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_matrix(self, matrix):\n        \"\"\"Sets the ray tracing matrix to be used for projecting.\n\n        matrix: a RayTracingMatrix object to represent G in (F).\n        \"\"\"\n        assert_validity(matrix, RayTracingMatrix)\n        parms.set_parameter(self.handle, self.name, 'matrix', matrix.handle)\n\n    def get_matrix(self):\n        \"\"\"Returns the ray tracing matrix used for projecting.\n\n        matrix: a RayTracingMatrix object representing G in (F).\n        \"\"\"\n        matrix = RayTracingMatrix()\n        matrix.handle = pystir.cSTIR_parameter(\n            self.handle, self.name, 'matrix')\n        check_status(matrix.handle)\n        return matrix\n\n    def set_num_tangential_LORs(self, value):\n        \"\"\"See :func:`~sirf.STIR.RayTracingMatrix.set_num_tangential_LORs`.\"\"\"\n        return self.get_matrix().set_num_tangential_LORs(value)\n\n    def get_num_tangential_LORs(self):\n        \"\"\"See :func:`~sirf.STIR.RayTracingMatrix.get_num_tangential_LORs`.\"\"\"\n        return self.get_matrix().get_num_tangential_LORs()",
  "class Prior(object):\n    \"\"\"Class for objects handling the prior, a penalty term\n\n    to be added to the objective function maximized by iterative\n    reconstruction algorithms.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def __call__(self, image):\n        '''Returns the prior value on the specified image (alias of value()).\n\n        image: ImageData object'''\n        return self.value(image)\n\n    def set_penalisation_factor(self, value):\n        \"\"\"Sets penalisation factor.\n\n        Sets the factor by which the penalty term (prior) is to be multiplied\n        before adding to the objective function.\n        \"\"\"\n        parms.set_float_par(\n            self.handle, 'GeneralisedPrior', 'penalisation_factor', value)\n        return self\n\n    def get_penalisation_factor(self):\n        \"\"\"Returns the penalty factor in front of the prior.\"\"\"\n        return parms.float_par(\n            self.handle, 'GeneralisedPrior', 'penalisation_factor')\n\n    def get_value(self, image):\n        \"\"\"Returns the value of the prior.\n\n        Returns the value of the prior for the specified image.\n        image: ImageData object\n        \"\"\"\n        assert_validity(image, ImageData)\n        handle = pystir.cSTIR_priorValue(self.handle, image.handle)\n        check_status(handle)\n        v = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return v\n\n    def value(self, image):\n        \"\"\"Returns the value of the prior (alias of get_value()).\"\"\"\n        return self.get_value(image)\n\n    def get_gradient(self, image):\n        \"\"\"Returns gradient of the prior.\n\n        Returns the value of the gradient of the prior for the specified image.\n        image: ImageData object\n        \"\"\"\n        assert_validity(image, ImageData)\n        grad = ImageData()\n        grad.handle = pystir.cSTIR_priorGradient(self.handle, image.handle)\n        check_status(grad.handle)\n        return grad\n\n    def gradient(self, image):\n        \"\"\"Returns the gradient of the prior (alias of get_gradient()).\"\"\"\n\n        return self.get_gradient(image)\n\n    def set_up(self, image):\n        \"\"\"Sets up.\"\"\"\n        try_calling(pystir.cSTIR_setupPrior(self.handle, image.handle))",
  "class QuadraticPrior(Prior):\n    r\"\"\"Class for the prior that is a quadratic function of the image values.\n\n    Implements a quadratic Gibbs prior.\n\n    The gradient of the prior for the image lambda is computed at voxel r as\n    the sum of\n\n        delta(r, s) = w(s - r)*kappa(r)*kappa(s)*(lambda(r) - lambda(s))\n\n    over all voxels s where the weight w(s - r) is non-zero, kappa being an\n    image used to have spatially-varying penalties such as in Jeff Fessler's\n    papers.It should have identical dimensions to the image for which the\n    penalty is computed. If kappa is not set, this class will\n    effectively use 1 for all kappa's.\n\n    By default, a 3x3 or 3x3x3 neigbourhood is used where the weights are set\n    to x-voxel_size divided by the Euclidean distance between the points.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'QuadraticPrior'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_kappa(self, image):\n        \"\"\"Sets kappa.\"\"\"\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, 'QuadraticPrior', 'kappa', image.handle)\n\n    def get_kappa(self):\n        \"\"\"Returns kappa.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(self.handle, 'QuadraticPrior', 'kappa')\n        check_status(image.handle)\n        return image",
  "class LogcoshPrior(Prior):\n    r\"\"\"Class for Log-cosh Prior.\n\n    Implements the prior, Log-cosh Prior, one of the earliest uses in P. J. \n    Green's paper \"Bayesian reconstructions from emission tomography data using \n    a modified EM algorithm,\" in IEEE Transactions on Medical Imaging, vol. 9, \n    no. 1, pp. 84-93, March 1990, doi: 10.1109/42.52985.\n\n    The prior has one parameter the scalar, it is the edge-preservation parameter.\n\n    The log-cosh function is given by:\n    \\f[\n        f = \\sum_{r,dr} w_{dr} \\frac{1}{2 s^2}  log(cosh(s(\\lambda_r - \\lambda_{r+dr}))) * \\kappa_r * \\kappa_{r+dr}$\n    \\f]\n\n    Kappa is a spatially varying penalty strength.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'LogcoshPrior'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_scalar(self, v):\n        \"\"\"Sets scalar.\"\"\"\n        parms.set_float_par(self.handle, 'LogcoshPrior', 'scalar', v)\n\n    def get_scalar(self):\n        \"\"\"Returns scalar.\"\"\"\n        return parms.float_par(self.handle, 'LogcoshPrior', 'scalar')\n\n    def set_kappa(self, image):\n        \"\"\"Sets kappa.\"\"\"\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, 'LogcoshPrior', 'kappa', image.handle)\n\n    def get_kappa(self):\n        \"\"\"Returns kappa.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(self.handle, 'LogcoshPrior', 'kappa')\n        check_status(image.handle)\n        return image",
  "class RelativeDifferencePrior(Prior):\n    r\"\"\"Class for Relative Difference Prior.\n\n    Implements the prior, Relative Difference Prior, proposed by Johan Nuyts et.\n    al in \"A concave prior penalizing relative differences for \n    maximum-a-posteriori reconstruction in emission tomography,\" in IEEE \n    Transactions on Nuclear Science, vol. 49, no. 1, pp. 56-60, Feb. 2002, \n    doi: 10.1109/TNS.2002.998681.\n\n    The value of the prior is computed as follows:\n\n    \\f[\n    f = \\sum_{r,dr} \\frac{w_{dr}}{2} \\frac{(\\lambda_r - \\lambda_{r+dr})^2}{(\\lambda_r+ \\lambda_{r+dr} + \\gamma |\\lambda_r - \\lambda_{r+dr}| + \\epsilon)} * \\kappa_r * \\kappa_{r+dr}\n    \\f]\n\n    The prior has 2 parameters epsilon and gamma. The former is to ensure\n    numerical stability and the gamma is the edge-preservation parameters\n    typically set as 2 in clinical practice (citation required).\n\n    Kappa is a spatially varying penalty strength.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'RelativeDifferencePrior'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_gamma(self, v):\n        \"\"\"Sets gamma.\"\"\"\n        parms.set_float_par(self.handle, 'RelativeDifferencePrior', 'gamma', v)\n\n    def get_gamma(self):\n        \"\"\"Returns gamma.\"\"\"\n        return parms.float_par(self.handle, 'RelativeDifferencePrior', 'gamma')\n\n    def set_epsilon(self, v):\n        \"\"\"Sets epsilon.\"\"\"\n        parms.set_float_par(self.handle, 'RelativeDifferencePrior', 'epsilon', v)\n\n    def get_epsilon(self):\n        \"\"\"Returns epsilon.\"\"\"\n        return parms.float_par(self.handle, 'RelativeDifferencePrior', 'epsilon')\n\n    def set_kappa(self, image):\n        \"\"\"Sets kappa.\"\"\"\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, 'RelativeDifferencePrior', 'kappa', image.handle)\n\n    def get_kappa(self):\n        \"\"\"Returns kappa.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(self.handle, 'RelativeDifferencePrior', 'kappa')\n        check_status(image.handle)\n        return image",
  "class PLSPrior(Prior):\n    r\"\"\"Class for Parallel Level Sets prior.\n\n    Implements the anatomical penalty function, Parallel Level Sets (PLS),\n    proposed by Matthias J. Ehrhardt et. al in \"PET Reconstruction With an\n    Anatomical MRI Prior Using Parallel Level Sets\", IEEE Trans. med. Imag.,\n    vol. 35, no. 9, Sep 2016 (https://doi.org/10.1109/TMI.2016.2549601).\n    Note that PLS becomes smoothed TV when a uniform anatomical image is\n    provided.\n\n    The prior has 2 parameters alpha and eta. It is computed for an image \\f$\n    f f$ as\n\n        phi(f) = sqrt(alpha^2 + |grad f|^2 - <grad f, xi>^2)\n\n    where f is the PET image, alpha controls the edge-preservation property\n    of PLS, and depends on the scale of the emission image, xi is the\n    normalised gradient of the anatomical image calculated as follows:\n\n        xi = 1/sqrt(|grad v|^2 + eta^2) grad v\n\n    where v is the anatomical image, and eta safeguards against the division\n    by zero and depends on the scale of the anatomical image.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'PLSPrior'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_only_2D(self, tf):\n        \"\"\"Sets only_2D parameter.\"\"\"\n        v = 1 if tf else 0\n        parms.set_int_par(self.handle, 'PLSPrior', 'only_2D', v)\n\n    def get_only_2D(self):\n        \"\"\"Returns only_2D value.\"\"\"\n        v = parms.int_par(self.handle, 'PLSPrior', 'only_2D')\n        return v != 0\n\n    def set_alpha(self, v):\n        \"\"\"Sets alpha.\"\"\"\n        parms.set_float_par(self.handle, 'PLSPrior', 'alpha', v)\n\n    def get_alpha(self):\n        \"\"\"Returns alpha.\"\"\"\n        return parms.float_par(self.handle, 'PLSPrior', 'alpha')\n\n    def set_eta(self, v):\n        \"\"\"Sets eta.\"\"\"\n        parms.set_float_par(self.handle, 'PLSPrior', 'eta', v)\n\n    def get_eta(self):\n        \"\"\"Returns eta.\"\"\"\n        return parms.float_par(self.handle, 'PLSPrior', 'eta')\n\n    def set_anatomical_image(self, image):\n        \"\"\"Sets anatomical image.\"\"\"\n        assert_validity(image, ImageData)\n        parms.set_parameter(\n            self.handle, 'PLSPrior', 'anatomical_image', image.handle)\n\n    def get_anatomical_image(self):\n        \"\"\"Returns anatomical image.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(\n            self.handle, 'PLSPrior', 'anatomical_image')\n        check_status(image.handle)\n        return image\n\n    def get_anatomical_grad(self, direction):\n        \"\"\"Returns anatomical gradient.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_PLSPriorGradient(self.handle, direction)\n        check_status(image.handle)\n        return image\n\n    def set_anatomical_filename(self, filename):\n        \"\"\"Sets anatomical filename.\"\"\"\n        parms.set_char_par(\n            self.handle, 'PLSPrior', 'anatomical_filename', filename)\n\n    def set_kappa(self, image):\n        \"\"\"Sets kappa.\"\"\"\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, 'PLSPrior', 'kappa', image.handle)\n\n    def get_kappa(self):\n        \"\"\"Returns kappa.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(self.handle, 'PLSPrior', 'kappa')\n        check_status(image.handle)\n        return image\n\n    def set_kappa_filename(self, filename):\n        \"\"\"Sets kappa filename.\"\"\"\n        parms.set_char_par(self.handle, 'PLSPrior', 'kappa_filename', filename)\n\n    def get_norm(self):\n        \"\"\"Returns norm.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(self.handle, 'PLSPrior', 'norm')\n        check_status(image.handle)\n        return image",
  "class ObjectiveFunction(object):\n    \"\"\"Class for the objective function\n\n    maximised by the iterative reconstruction algorithms.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_prior(self, prior):\n        \"\"\"Sets the prior,\n\n        a penalty term to be added to the objective function.\"\"\"\n        assert_validity(prior, Prior)\n        parms.set_parameter(self.handle, 'GeneralisedObjectiveFunction',\n                            'prior', prior.handle)\n        self.prior = prior\n\n    def get_prior(self):\n        \"\"\"Returns the prior currently used by this objective function.\"\"\"\n        prior = Prior()\n        prior.handle = pystir.cSTIR_parameter(\n            self.handle, 'GeneralisedObjectiveFunction', 'prior')\n        check_status(prior.handle)\n        return prior\n\n    def set_num_subsets(self, n):\n        \"\"\"Sets the number of subsets.\n\n        Sets the number of subsets of ray projections to be used for computing\n        additive components of the gradient used by Ordered Subset algorithms\n        for maximizing this objective function.\n        If the ray tracing projector G is a matrix, the subsets in question are\n        subsets of its rows.\n        n: number of subsets, Python integer scalar\n        \"\"\"\n        parms.set_int_par(\n            self.handle, 'GeneralisedObjectiveFunction', 'num_subsets', n)\n\n    def get_num_subsets(self):\n        \"\"\"Returns the number of subsets.\"\"\"\n        return parms.int_par(\n            self.handle, 'GeneralisedObjectiveFunction', 'num_subsets')\n\n    def set_up(self, image):\n        \"\"\"Prepares this object for use.\n\n        image: ImageData object\n        \"\"\"\n        assert_validity(image, ImageData)\n        try_calling(pystir.cSTIR_setupObjectiveFunction(\n            self.handle, image.handle))\n\n    def value(self, image):\n        \"\"\"Returns the value of this objective function on the specified image.\n\n        image: ImageData object\n        \"\"\"\n        assert_validity(image, ImageData)\n        handle = pystir.cSTIR_objectiveFunctionValue(self.handle, image.handle)\n        check_status(handle)\n        v = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return v\n\n    def __call__(self, image):\n        '''Alias of value: Returns the value of this objective function on the specified image.\n\n        image: ImageData object'''\n        return self.value(image)\n\n    def get_value(self, image):\n        \"\"\"Returns the value of this objective function on the specified image.\n\n        image: ImageData object\n        \"\"\"\n        return self.value(image)\n\n    def gradient(self, image, subset=-1):\n        \"\"\"Returns the value of the additive component of the gradient\n\n        of this objective function on the specified image corresponding to the\n        specified subset (see set_num_subsets() method).\n        If no subset is specified, returns the full gradient, i.e. the sum of\n        the subset components.\n        image: ImageData object\n        subset: Python integer scalar\n        \"\"\"\n        assert_validity(image, ImageData)\n        grad = ImageData()\n        grad.handle = pystir.cSTIR_objectiveFunctionGradient(\n            self.handle, image.handle, subset)\n        check_status(grad.handle)\n        return grad\n\n    def get_gradient(self, image):\n        \"\"\"Returns the gradient of the objective function on specified image.\n\n        image: ImageData object\n        \"\"\"\n        return self.gradient(image)\n\n    def get_subset_gradient(self, image, subset):\n        \"\"\"Returns the value of the additive component of the gradient\n\n        of this objective function on <image> corresponding to the specified\n        subset (see set_num_subsets() method).\n        image: ImageData object\n        subset: Python integer scalar\n        \"\"\"\n        return self.gradient(image, subset)\n\n    @abc.abstractmethod\n    def get_subset_sensitivity(self, subset):\n        #print('in base class ObjectiveFunction')\n        pass",
  "class PoissonLogLikelihoodWithLinearModelForMean(ObjectiveFunction):\n    \"\"\"Class for STIR PoissonLogLikelihoodWithLinearModelForMean object.\n\n    See:\n    http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n#    def set_sensitivity_filename(self, name):\n#        parms.set_char_par\\\n#            (self.handle, 'PoissonLogLikelihoodWithLinearModelForMean',\\\n#             'sensitivity_filename', name)\n#    def set_use_subset_sensitivities(self, flag):\n#        parms.set_char_par\\\n#            (self.handle, 'PoissonLogLikelihoodWithLinearModelForMean',\\\n#             'use_subset_sensitivities', repr(flag))\n\n    def set_recompute_sensitivity(self, flag):\n        \"\"\"Sets recompute sensitivity flag.\"\"\"\n        parms.set_char_par(\n            self.handle, 'PoissonLogLikelihoodWithLinearModelForMean',\n            'recompute_sensitivity', repr(flag))\n\n    def get_subset_sensitivity(self, subset):\n        \"\"\"Returns subset sensitivity.\n\n        Returns an ImageData object containing sensitivity image for the\n        specified subset.\n        \"\"\"\n        ss = ImageData()\n        ss.handle = pystir.cSTIR_subsetSensitivity(self.handle, subset)\n        check_status(ss.handle)\n        return ss\n\n    def get_backprojection_of_acquisition_ratio(self, image, subset):\n        \"\"\"Returns backprojection of measured to estimated acquisition ratio.\n\n        Returns the back-projection of the ratio of the measured and estimated\n        acquisition data.\n        \"\"\"\n        assert_validity(image, ImageData)\n        grad = ImageData()\n        grad.handle = pystir.cSTIR_objectiveFunctionGradientNotDivided(\n            self.handle, image.handle, subset)\n        check_status(grad.handle)\n        return grad",
  "class PoissonLogLikelihoodWithLinearModelForMeanAndProjData(\n        PoissonLogLikelihoodWithLinearModelForMean):\n    \"\"\"Class for STIR type of Poisson loglikelihood object.\n\n    Specifically, PoissonLogLikelihoodWithLinearModelForMeanAndProjData. See:\n    http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'PoissonLogLikelihoodWithLinearModelForMeanAndProjData'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_input_filename(self, name):\n        \"\"\"Sets the name of the file containing acquisition data.\"\"\"\n        parms.set_char_par(\n            self.handle, self.name, 'input_filename', name)\n#    def set_zero_seg0_end_planes(self, flag):\n#        parms.set_char_par\\\n#            (self.handle, self.name, 'zero_seg0_end_planes', repr(flag))\n#    def set_max_segment_num_to_process(self, n):\n#        parms.set_int_par(\n#           self.handle, self.name, 'max_segment_num_to_process', n)\n\n    def set_acquisition_model(self, am):\n        \"\"\"Sets the acquisition model to be used by this objective function.\"\"\"\n        assert_validity(am, AcquisitionModel)\n        parms.set_parameter(\n            self.handle, self.name, 'acquisition_model', am.handle)\n#    def get_acquisition_model(self):\n#        \"\"\"\n#        Returns the acquisition model used by this objective function.\n#        \"\"\"\n#        am = AcquisitionModelUsingMatrix()\n#        if am.handle is not None:\n#            pyiutil.deleteDataHandle(am.handle)\n#        am.handle = pystir.cSTIR_parameter\\\n#            (self.handle, self.name, 'acquisition_model')\n#        check_status(am.handle)\n#        return am\n\n    def set_acquisition_data(self, ad):\n        \"\"\"Sets the acquisition data to be used by this objective function.\"\"\"\n        assert_validity(ad, AcquisitionData)\n        parms.set_parameter(\n            self.handle, self.name, 'acquisition_data', ad.handle)",
  "class Reconstructor(object):\n    \"\"\"Base class for a generic PET reconstructor.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.input = None\n        self.image = None\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_input(self, input_data):\n        \"\"\"Sets the acquisition data to use for reconstruction.\"\"\"\n        assert_validity(input_data, AcquisitionData)\n        parms.set_parameter(\n            self.handle, 'Reconstruction',\n            'input_data', input_data.handle)\n\n    def set_output_filename_prefix(self, prefix):\n        \"\"\"Sets the output file name prefix.\"\"\"\n        parms.set_char_par(\n            self.handle, 'Reconstruction', 'output_filename_prefix', prefix)\n\n    def disable_output(self):\n        \"\"\"Disables output.\"\"\"\n        parms.set_int_par(self.handle, 'Reconstruction', 'disable_output', 1)\n\n    def enable_output(self):\n        \"\"\"Enables output.\"\"\"\n        parms.set_int_par(self.handle, 'Reconstruction', 'enable_output', 1)\n\n    def reconstruct(self, image):\n        \"\"\"Performs reconstruction (will update the image argument)\"\"\"\n        assert_validity(image, ImageData)\n        try_calling(pystir.cSTIR_runReconstruction(self.handle, image.handle))\n        self.image = image\n\n    def get_output(self):\n        \"\"\"Returns the reconstructed image.\"\"\"\n        assert self.image is not None, 'current estimate not set. Did you run a reconstruction already?'\n        # TODO: move to C++\n        return self.image.clone()",
  "class FBP2DReconstructor(object):\n    \"\"\"Class for 2D Filtered Back Projection reconstructor.\n\n    This is an implementation of the 2D FBP algorithm.\n    Oblique angles in data will be ignored. The exception is the span=1 case,\n    where the ring differences +1 and -1 are first combined to give indirect\n    sinograms.\n    By default, the algorithm uses the ramp filter. An apodizing filter can be\n    added by using set_alpha_cosine_window and/or set_frequency_cut_off.\n    The apodizing filter in frequency space has the form\n\n        (alpha + (1 - alpha) * cos(pi * f / fc))\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.handle = pystir.cSTIR_newObject('FBP2D')\n        check_status(self.handle)\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_input(self, input_data):\n        \"\"\"Sets the acquisition data to use for reconstruction.\"\"\"\n        assert_validity(input_data, AcquisitionData)\n        parms.set_parameter(self.handle, 'FBP2D', 'input', input_data.handle)\n\n    def set_zoom(self, v):\n        \"\"\"Sets zoom.\"\"\"\n        parms.set_float_par(self.handle, 'FBP2D', 'zoom', v)\n\n    def set_alpha_cosine_window(self, v):\n        \"\"\"Sets alpha in the apodizing filter.\n\n        See the class documentation for the filter. The value of alpha should\n        be between 0.5 and 1. alpha=0.5 corresponds to the Hann filter, while\n        0.54 corresponds to the Hamming filter.\n        \"\"\"\n        parms.set_float_par(self.handle, 'FBP2D', 'alpha', v)\n\n    def set_frequency_cut_off(self, v):\n        \"\"\"Sets the cut-off frequency for the apodizing filter.\n\n        See the class documentation for the filter. The value of fc should be\n        between 0 and 0.5.\n        \"\"\"\n        parms.set_float_par(self.handle, 'FBP2D', 'fc', v)\n\n    def set_output_image_size_xy(self, xy):\n        \"\"\"Sets output image size (xy).\"\"\"\n        parms.set_int_par(self.handle, 'FBP2D', 'xy', xy)\n\n    def set_up(self, image):\n        \"\"\"Sets up the reconstructor.\"\"\"\n        try_calling(pystir.cSTIR_setupFBP2DReconstruction(\n            self.handle, image.handle))\n\n    def process(self):\n        \"\"\"Performs reconstruction.\"\"\"\n        try_calling(pystir.cSTIR_runFBP2DReconstruction(self.handle))\n\n    def get_output(self):\n        \"\"\"Returns the reconstructed image.\"\"\"\n        image = ImageData()\n        image.handle = parms.parameter_handle(self.handle, 'FBP2D', 'output')\n        check_status(image.handle)\n        return image",
  "class IterativeReconstructor(Reconstructor):\n    \"\"\"Base class for a generic iterative PET reconstructor.\"\"\"\n\n    def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.image = None\n        self.subset = 0\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_num_subsets(self, n):\n        \"\"\"See method in ObjectiveFunction.\"\"\"\n        parms.set_int_par(\n            self.handle, 'IterativeReconstruction', 'num_subsets', n)\n\n    def get_num_subsets(self):\n        \"\"\"Returns number of subsets.\"\"\"\n        return parms.int_par(\n            self.handle, 'IterativeReconstruction', 'num_subsets')\n#    def set_start_subset_num(self, n):\n#        parms.set_int_par\\\n#            (self.handle, 'IterativeReconstruction', 'start_subset_num', n)\n#    def get_start_subset_num(self):\n#        return parms.int_par\\\n#            (self.handle, 'IterativeReconstruction', 'start_subset_num')\n\n    def set_num_subiterations(self, n):\n        \"\"\"Sets number of subiterations.\n\n        In subset iterative methods, each iteration works with a subset,\n        and is therefore referred to as a subiteration.\n        \"\"\"\n        parms.set_int_par(\n            self.handle, 'IterativeReconstruction', 'num_subiterations', n)\n\n    def get_num_subiterations(self):\n        \"\"\"Returns the number of subiterations.\"\"\"\n        return parms.int_par(\n            self.handle, 'IterativeReconstruction', 'num_subiterations')\n#    def set_start_subiteration_num(self, n):\n#        parms.set_int_par(\n#           self.handle, 'IterativeReconstruction',\n#           'start_subiteration_num', n)\n#    def get_start_subiteration_num(self):\n#        return parms.int_par\\\n#            (self.handle, 'IterativeReconstruction', 'start_subiteration_num')\n#    def set_subiteration_num(self, iter):\n#        parms.set_int_par\\\n#            (self.handle, 'IterativeReconstruction', 'subiteration_num', iter)\n\n    def get_subiteration_num(self):\n        \"\"\"Returns the current subiteration number.\"\"\"\n        return parms.int_par(\n            self.handle, 'IterativeReconstruction', 'subiteration_num')\n\n    def set_save_interval(self, n):\n        \"\"\"Sets save interval.\n\n        Defines how often to save image iterates (n = 1: on each\n        subiteration, n = 2: every other subiteration etc.)\n        \"\"\"\n        if n > 0:\n            self.enable_output()\n        else:\n            self.disable_output()\n        parms.set_int_par(\n            self.handle, 'IterativeReconstruction', 'save_interval', n)\n#    def set_inter_iteration_filter_interval(self, n):\n#        parms.set_int_par\\\n#            (self.handle, 'IterativeReconstruction',\\\n#             'inter_iteration_filter_interval', n)\n\n    def set_objective_function(self, obj):\n        \"\"\"Specifies the objective function to be maximized.\"\"\"\n        assert_validity(obj, ObjectiveFunction)\n        parms.set_parameter(self.handle, 'IterativeReconstruction',\n            'objective_function', obj.handle)\n\n    abc.abstractmethod\n    def get_objective_function(self):\n        pass\n#        obj_fun = ObjectiveFunction()\n#        obj_fun.handle = pystir.cSTIR_parameter\\\n#            (self.handle, 'IterativeReconstruction', 'objective_function')\n#        check_status(obj_fun.handle)\n#        return obj_fun\n#    def set_inter_iteration_filter(self, f):\n#        pystir.cSTIR_setParameter\\\n#            (self.handle, 'IterativeReconstruction',\\\n#             'inter_iteration_filter_type', f.handle)\n#    def get_inter_iteration_filter(self):\n#        filter = DataProcessor()\n#        filter.handle = pystir.cSTIR_parameter\\\n#            (self.handle, 'IterativeReconstruction',\\\n#             'inter_iteration_filter_type')\n#        check_status(filter.handle)\n#        return filter\n\n    def set_up(self, image):\n        \"\"\"Sets up the reconstructor.\"\"\"\n        assert_validity(image, ImageData)\n        try_calling(pystir.cSTIR_setupReconstruction(\n            self.handle, image.handle))\n\n    def set_current_estimate(self, image):\n        \"\"\"Sets image estimate for further iterations.\n\n        image will be cloned.\n        \"\"\"\n        assert_validity(image, ImageData)\n        self.image = image.clone()\n\n    #def set_estimate(self, image):\n    #    \"\"\"Sets image estimate as a variable that will be updated.\"\"\"\n    #    assert_validity(image, ImageData)\n    #    self.image = image\n\n    def process(self):\n        \"\"\"Performs reconstruction.\"\"\"\n        assert self.image is not None, 'current estimate not set.'\n        try_calling(pystir.cSTIR_runReconstruction(\n            self.handle, self.image.handle))\n\n    def get_current_estimate(self):\n        \"\"\"Return current image estimate.\"\"\"\n        assert self.image is not None, 'current estimate not set.'\n        return self.image.clone()\n\n    def update_current_estimate(self):\n        \"\"\"Updates current image estimate by performing one subiteration.\"\"\"\n        if self.image is None:\n            raise error('current estimate not set')\n        assert_validity(self.image, ImageData)\n        try_calling(pystir.cSTIR_updateReconstruction(\n            self.handle, self.image.handle))\n\n    def set_current_subset_num(self, subset):\n        \"\"\"Sets the subset to be used on the next subiteration.\"\"\"\n        self.subset = subset\n\n    def get_subset_sensitivity(self):\n        \"\"\"Returns the current subset sensitivity.\n\n        Returns an ImageData object containing sensitivity image for the\n        current subset.\n        \"\"\"\n        obj_fun = self.get_objective_function()\n        return obj_fun.get_subset_sensitivity(self.subset)\n\n    def update(self, image):\n        \"\"\"Updates the image estimate.\n\n        Applies one subiteration to the image estimate passed as the\n        argument.\n        \"\"\"\n        assert_validity(image, ImageData)\n        #self.set_estimate(image)\n        self.image = image;\n        self.update_current_estimate()\n        return image",
  "class OSMAPOSLReconstructor(IterativeReconstructor):\n    \"\"\"OSMAPOSL reconstruction class.\n\n    Class for reconstructor objects using Ordered Subsets Maximum A Posteriori\n    One Step Late reconstruction algorithm, see\n    http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1OSMAPOSLReconstruction.html\n    \"\"\"\n\n    def __init__(self, filename=''):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.image = None\n        self.name = 'OSMAPOSL'\n        self.handle = pystir.cSTIR_objectFromFile(\n            'OSMAPOSLReconstruction', filename)\n        check_status(self.handle)\n        self.disable_output()\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_maximum_relative_change(self, value):\n        \"\"\"Sets maximum relative change.\"\"\"\n        parms.set_float_par(\n            self.handle, self.name, 'set_maximum_relative_change', value)\n\n    def set_minimum_relative_change(self, value):\n        \"\"\"Sets minimum relative change.\"\"\"\n        parms.set_float_par(\n            self.handle, self.name, 'set_minimum_relative_change', value)\n#    def set_MAP_model(self, model):\n#        parms.set_char_par\\\n#            (self.handle, self.name, 'MAP_model', model)\n    def get_objective_function(self):\n        obj_fun = PoissonLogLikelihoodWithLinearModelForMean()\n        obj_fun.handle = pystir.cSTIR_parameter\\\n            (self.handle, self.name, 'objective_function')\n        check_status(obj_fun.handle)\n        return obj_fun",
  "class KOSMAPOSLReconstructor(IterativeReconstructor):\n    \"\"\"KOSMAPOSL recontstructor class.\n\n    Class for reconstructor objects using Kernel Ordered Subsets Maximum\n    A Posteriori One Step Late reconstruction algorithm.\n\n    This class implements the iterative algorithm obtained using the Kernel\n    method (KEM) and Hybrid kernel method (HKEM). This implementation\n    corresponds to the one presented by Deidda D et al, \"Hybrid PET-MR\n    list-mode kernelized expectation maximization  reconstruction\", Inverse\n    Problems, 2019, DOI: https://doi.org/10.1088/1361-6420/ab013f.\n    However, this allows also sinogram-based reconstruction. Each voxel value\n    of the image X can be represented as a linear combination using the kernel\n    method.  If we have an image with prior information, we can construct for\n    each voxel j of the emission image a feature vector, v, using the prior\n    information. The image X can then be described using the kernel matrix\n\n    X = A*K\n\n    where K is the kernel matrix. The resulting algorithm with OSEM,\n    for example, is the following:\n\n    A^(n+1) =  A^n/(K^n * S) * K^n * P * Y/(P * K^n *A^n + S)\n\n    where kernel can be written as:\n\n    K^n = K_m * K_p;\n\n    with\n\n    K_m = exp(-(v_j - v_l)^2/(2*sigma_m^2)) *\n          exp(-(x_j - x_l)^2 /(2*sigma_dm^2))\n\n    being the MR component of the kernel and\n\n    K_p = exp(-(z_j - z_l)^2/(2*sigma_p^2)) *\n          exp(-(x_j - x_l)^2 /(2*sigma_dp^2))\n\n    is the part coming from the emission iterative update. Here, the Gaussian\n    kernel functions have been modulated by the distance between voxels in the\n    image space.\n    \"\"\"\n\n    def __init__(self, filename=''):\n        \"\"\"init.\"\"\"\n        IterativeReconstructor.__init__(self)\n        self.handle = None\n        self.image = None\n        self.name = 'KOSMAPOSL'\n        self.handle = pystir.cSTIR_objectFromFile(\n            'KOSMAPOSLReconstruction', filename)\n        check_status(self.handle)\n        self.disable_output()\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_anatomical_prior(self, ap):\n        \"\"\"Sets anatomical prior.\"\"\"\n        assert_validity(ap, ImageData)\n        parms.set_parameter(\n            self.handle, 'KOSMAPOSL', 'anatomical_prior', ap.handle)\n\n    def set_num_neighbours(self, n):\n        \"\"\"Sets number of neighbours.\"\"\"\n        parms.set_int_par(\n            self.handle, 'KOSMAPOSL', 'num_neighbours', n)\n\n    def set_num_non_zero_features(self, n):\n        \"\"\"Sets number of non-zero features.\"\"\"\n        parms.set_int_par(\n            self.handle, 'KOSMAPOSL', 'num_non_zero_features', n)\n\n    def set_sigma_m(self, v):\n        \"\"\"Sets sigma m.\"\"\"\n        parms.set_float_par(self.handle, 'KOSMAPOSL', 'sigma_m', v)\n\n    def set_sigma_p(self, v):\n        \"\"\"Sets sigma p.\"\"\"\n        parms.set_float_par(self.handle, 'KOSMAPOSL', 'sigma_p', v)\n\n    def set_sigma_dm(self, v):\n        \"\"\"Sets sigma dm.\"\"\"\n        parms.set_float_par(self.handle, 'KOSMAPOSL', 'sigma_dm', v)\n\n    def set_sigma_dp(self, v):\n        \"\"\"Sets sigma dp.\"\"\"\n        parms.set_float_par(self.handle, 'KOSMAPOSL', 'sigma_dp', v)\n\n    def set_only_2D(self, tf):\n        \"\"\"Sets only_2D flag.\"\"\"\n        v = 1 if tf else 0\n        parms.set_int_par(self.handle, 'KOSMAPOSL', 'only_2D', v)\n\n    def set_hybrid(self, tf):\n        \"\"\"Sets use hybrid mode flag.\"\"\"\n        v = 1 if tf else 0\n        parms.set_int_par(self.handle, 'KOSMAPOSL', 'hybrid', v)\n\n    def compute_kernelised_image(self, image, alpha):\n        assert_validity(image, ImageData)\n        assert_validity(alpha, ImageData)\n        ki = ImageData()\n        ki.handle = pystir.cSTIR_computeKernelisedImage \\\n            (self.handle, image.handle, alpha.handle)\n        check_status(ki.handle)\n        return ki\n\n    def get_objective_function(self):\n        obj_fun = PoissonLogLikelihoodWithLinearModelForMean()\n        obj_fun.handle = pystir.cSTIR_parameter\\\n            (self.handle, self.name, 'objective_function')\n        check_status(obj_fun.handle)\n        return obj_fun",
  "class SingleScatterSimulator():\n    '''\n    Class for simulating the scatter contribution to PET data.\n\n    This class uses the STIR Single Scatter simulation, taking as input an\n    activity and attenuation image, and a acquisition data template.\n\n    WARNING: Currently this class does not use the low-resolution sampling\n    mechanism of STIR. This means that if you give it a full resolution acq_data,\n    you will likely run out of memory and/or time.\n    '''\n    def __init__(self, filename = ''):\n        self.handle = None\n        self.image = None\n        self.name = 'PETSingleScatterSimulator'\n        self.filename = filename\n\n        if not self.filename:\n            self.handle = pystir.cSTIR_newObject(self.name)\n        else:\n            self.handle = pystir.cSTIR_objectFromFile(self.name, self.filename)\n        check_status(self.handle)\n\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_up(self, acq_templ, img_templ):\n        \"\"\"Set up.\n\n        Prepare this object for performing forward operations;\n        acq_templ:  an AcquisitionData object used as a template for\n                    creating an AcquisitionData object to store forward\n                    projection;\n        img_templ:  an ImageData object used as a template for checking geometry etc\n\n        attenuation image has to be set first\n        \"\"\"\n        assert_validity(acq_templ, AcquisitionData)\n        assert_validity(img_templ, ImageData)\n\n        # temporarily save the templates in the class\n        self.acq_templ = acq_templ\n        #self.img_templ = img_templ\n\n        try_calling(pystir.cSTIR_setupScatterSimulator(\n            self.handle, acq_templ.handle, img_templ.handle))\n\n    def forward(self, image,  out=None):\n        \"\"\"Return the scatter estimation for the input activity image.\n\n        image   :  an ImageData object.\n\n        set_up() has to be called first.\n        \"\"\"\n        assert_validity(image, ImageData)\n        if out is None:\n            ad = AcquisitionData()\n            ad.handle = pystir.cSTIR_scatterSimulatorFwd(\n                self.handle, image.handle);\n            check_status(ad.handle)\n            return ad\n        ad = out\n        assert_validity(ad, AcquisitionData)\n        try_calling(pystir.cSTIR_scatterSimulatorFwdReplace(\n            self.handle, image.handle, ad.handle))\n\n    def set_attenuation_image(self, image):\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, self.name, 'setAttenuationImage', image.handle)",
  "class ScatterEstimator():\n    '''\n    Class for estimating the scatter contribution in PET projection data\n\n    This class implements the SSS iterative algorithm from STIR. It\n    is an iterative loop of reconstruction, single scatter estimation,\n    upsampling, tail-fitting.\n\n    Output is an acquisition_data object with the scatter contribution.\n    This can then be added to the randoms to use in PETAcquisitionModel.set_background_term().\n    '''\n    def __init__(self, filename = ''):\n        self.handle = None\n        self.image = None\n        self.name = 'PETScatterEstimator'\n        self.filename = filename\n\n        if not self.filename:\n            self.handle = pystir.cSTIR_newObject(self.name)\n        else:\n            self.handle = pystir.cSTIR_objectFromFile(self.name, self.filename)\n\n        check_status(self.handle)\n\n    def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_up(self):\n        \"\"\"\n        Set up.\n\n        Prepare this object for performing scatter estimation;\n        All input has to be set before calling this function.\n        \"\"\"\n        try_calling(pystir.cSTIR_setupScatterEstimator(\n            self.handle))\n\n    def process(self):\n        \"\"\"\n        Runs the scatter estimation.\n\n        You need to run set_up() first.\n        \"\"\"\n        print('ScatterEstimator:: Waiting for the scatter estimation to finish ...')\n        self.output = AcquisitionData()\n        self.output.handle = pystir.cSTIR_runScatterEstimator(self.handle)\n        check_status(self.output.handle)\n        print('ScatterEstimator:: estimation finished.')\n\n    def get_output(self):\n        \"\"\"\n        Return the final scatter estimate.\n        \"\"\"\n        data = AcquisitionData()\n        data.handle = parms.parameter_handle(self.handle, 'PETScatterEstimator', 'output')\n        check_status(data.handle)\n        return data\n\n    def get_num_iterations(self):\n        \"\"\"Get number of iterations of the SSS algorithm to use.\"\"\"\n        return parms.int_par(self.handle, 'PETScatterEstimator', 'num_iterations')\n\n    def set_attenuation_image(self, image):\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, self.name, 'setAttenuationImage', image.handle)\n\n    def set_attenuation_correction_factors(self, arg):\n        assert_validity(arg, AcquisitionData)\n        parms.set_parameter(self.handle, self.name, 'setAttenuationCorrectionFactors', arg.handle)\n\n    def set_input(self, acq_data):\n        assert_validity(acq_data, AcquisitionData)\n        parms.set_parameter(self.handle, self.name, 'setInput', acq_data.handle)\n\n    def set_randoms(self, acq_data):\n        assert_validity(acq_data, AcquisitionData)\n        parms.set_parameter(self.handle, self.name, 'setRandoms', acq_data.handle)\n\n    def set_asm(self, asm):\n        '''Set acquisition sensitivity model (without attenuation!)'''\n        assert_validity(asm, AcquisitionSensitivityModel)\n        parms.set_parameter(self.handle, self.name, 'setASM', asm.handle)\n\n    def set_num_iterations(self, v):\n        \"\"\"Set number of iterations of the SSS algorithm to use.\"\"\"\n        parms.set_int_par(self.handle, 'PETScatterEstimator', 'set_num_iterations', v)\n\n    def set_output_prefix(self, v):\n        \"\"\"\n        Set prefix for filenames with scatter estimates.\n\n        Actual filenames will append the iteration number and the .hs extension\n        as common for STIR Interfile data.\n\n        Set it to the empty string to prevent any output.\n        \"\"\"\n        parms.set_char_par(self.handle, 'PETScatterEstimator', 'set_output_prefix', v)",
  "class OSSPSReconstructor(IterativeReconstructor):\n    \"\"\"OSSPS reconstructor class.\n\n    Class for reconstructor objects using Ordered Subsets Separable\n    Paraboloidal Surrogate reconstruction algorithm, see\n    http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1OSSPSReconstruction.html\n    \"\"\"\n\n    def __init__(self, filename=''):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.image = None\n        self.name = 'OSSPS'\n        self.handle = pystir.cSTIR_objectFromFile(\n            'OSSPSReconstruction', filename)\n        check_status(self.handle)\n        self.disable_output()\n\n    def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n\n    def set_relaxation_parameter(self, value):\n        \"\"\"Sets relaxation parameter.\"\"\"\n        parms.set_float_par(\n            self.handle, self.name, 'relaxation_parameter', value)",
  "def make_Poisson_loglikelihood(acq_data, likelihood_type='LinearModelForMean',\n                               acq_model=None):\n    \"\"\"Makes Poisson loglikelihood.\n\n    Selects the objective function based on the acquisition data and likelihood\n    model types.\n    \"\"\"\n    # only this objective function is implemented for now\n    if likelihood_type == 'LinearModelForMean':\n        obj_fun = PoissonLogLikelihoodWithLinearModelForMeanAndProjData()\n        obj_fun.set_acquisition_data(acq_data)\n    else:\n        raise error(\n            'only PoissonLogLikelihoodWithLinearModelForMeanAndProjData ' +\n            'is currently implemented in SIRF')\n    if acq_model is not None:\n        obj_fun.set_acquisition_model(acq_model)\n    return obj_fun",
  "def __init__(self, info=None, warn='stdout', errr='stderr'):\n        \"\"\"Create MessageRedirector object that redirects STIR's ouput.\n\n        Output produced by info(), warning() and error(0 functions to\n        destinations specified respectively by info, warn and err arguments.\n        The argument values other than None, stdout, stderr, cout and cerr\n        are interpreted as filenames.\n        None and empty string value suppresses printing.\n        \"\"\"\n        if info is None:\n            info = ''\n        if not isinstance(info, str):\n            raise error(\n                'wrong info argument for MessageRedirector constructor')\n        elif info in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.info = pystir.newTextPrinter(info)\n            self.info_case = 0\n        else:\n            self.info = pystir.newTextWriter(info)\n            self.info_case = 1\n        pystir.openChannel(0, self.info)\n\n        if warn is None:\n            warn = ''\n        if not isinstance(warn, str):\n            raise error(\n                'wrong warn argument for MessageRedirector constructor')\n        elif warn in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.warn = pystir.newTextPrinter(warn)\n            self.warn_case = 0\n        else:\n            self.warn = pystir.newTextWriter(warn)\n            self.warn_case = 1\n        pystir.openChannel(1, self.warn)\n\n        if errr is None:\n            errr = ''\n        if not isinstance(errr, str):\n            raise error(\n                'wrong errr argument for MessageRedirector constructor')\n        elif errr in {'stdout', 'stderr', 'cout', 'cerr'}:\n            self.errr = pystir.newTextPrinter(errr)\n            self.errr_case = 0\n        else:\n            self.errr = pystir.newTextWriter(errr)\n            self.errr_case = 1\n        pystir.openChannel(2, self.errr)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.info_case == 0:\n            try_calling(pystir.deleteTextPrinter(self.info))\n        else:\n            try_calling(pystir.deleteTextWriter(self.info))\n        pystir.closeChannel(0, self.info)\n        if self.warn_case == 0:\n            try_calling(pystir.deleteTextPrinter(self.warn))\n        else:\n            try_calling(pystir.deleteTextWriter(self.warn))\n        pystir.closeChannel(1, self.warn)\n        if self.errr_case == 0:\n            try_calling(pystir.deleteTextPrinter(self.errr))\n        else:\n            try_calling(pystir.deleteTextWriter(self.errr))\n        pystir.closeChannel(2, self.errr)",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_origin(self, origin):\n        \"\"\"Sets origin.\n\n        Sets the (discrete) coordinates of\n        the shape centre on a voxel grid.\n        \"\"\"\n        parms.set_float_par(self.handle, 'Shape', 'x', origin[2])\n        parms.set_float_par(self.handle, 'Shape', 'y', origin[1])\n        parms.set_float_par(self.handle, 'Shape', 'z', origin[0])",
  "def get_origin(self):\n        \"\"\"Returns the coordinates of the shape centre on a voxel grid.\"\"\"\n        x = parms.float_par(self.handle, 'Shape', 'x')\n        y = parms.float_par(self.handle, 'Shape', 'y')\n        z = parms.float_par(self.handle, 'Shape', 'z')\n        return (x, y, z)",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'Box3D'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_length_x(self, value):\n        \"\"\"Sets dimension x length in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'length_x', value)",
  "def get_length_x(self):\n        \"\"\"Returns dimension x length in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'length_x')",
  "def set_length_y(self, value):\n        \"\"\"Sets dimension y length in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'length_y', value)",
  "def get_length_y(self):\n        \"\"\"Returns dimension y length in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'length_y')",
  "def set_length_z(self, value):\n        \"\"\"Sets dimension z length in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'length_z', value)",
  "def get_length_z(self):\n        \"\"\"Returns dimension z length in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'length_z')",
  "def set_lengths(self, value):\n        \"\"\"Sets lengths in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'length_x', value[0])\n        parms.set_float_par(self.handle, self.name, 'length_y', value[1])\n        parms.set_float_par(self.handle, self.name, 'length_z', value[2])",
  "def get_lengths(self):\n        \"\"\"Returns lengths in mm.\"\"\"\n        length_x = parms.float_par(self.handle, self.name, 'length_x')\n        length_y = parms.float_par(self.handle, self.name, 'length_y')\n        length_z = parms.float_par(self.handle, self.name, 'length_z')\n        return (length_x, length_y, length_z)",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'Ellipsoid'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_radius_x(self, value):\n        \"\"\"Sets x radius in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_x', value)",
  "def get_radius_x(self):\n        \"\"\"Returns x radius in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'radius_x')",
  "def set_radius_y(self, value):\n        \"\"\"Sets y radius in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_y', value)",
  "def get_radius_y(self):\n        \"\"\"Returns y radius in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'radius_y')",
  "def set_radius_z(self, value):\n        \"\"\"Sets z radius in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_z', value)",
  "def get_radius_z(self):\n        \"\"\"Returns z radius in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'radius_z')",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'EllipsoidalCylinder'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_length(self, value):\n        \"\"\"Sets length in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'length', value)",
  "def get_length(self):\n        \"\"\"Returns length in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'length')",
  "def set_radius_x(self, value):\n        \"\"\"Sets x radius in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_x', value)",
  "def get_radius_x(self):\n        \"\"\"Returns x radius in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'radius_x')",
  "def set_radius_y(self, value):\n        \"\"\"Sets y radius in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_y', value)",
  "def get_radius_y(self):\n        \"\"\"Returns y radius in mm.\"\"\"\n        return parms.float_par(self.handle, self.name, 'radius_y')",
  "def set_radii(self, radii):\n        \"\"\"Sets radii in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'radius_x', radii[1])\n        parms.set_float_par(self.handle, self.name, 'radius_y', radii[0])",
  "def get_radii(self):\n        \"\"\"Returns radii in mm.\"\"\"\n        rx = parms.float_par(self.handle, self.name, 'radius_x')\n        ry = parms.float_par(self.handle, self.name, 'radius_y')\n        return (rx, ry)",
  "def __init__(self, arg=None):\n        \"\"\"Creates an ImageData object.\n\n        Arguments:\n            arg : Python str or AcquisitionData or None, interpreted as follows:\n        str            : read the object from a file specified by <arg>\n                         (the file format has to be support by STIR).\n        STIR.AcquisitionData: create an object compatible with the scanner data\n                         recorded in an AcquisitionData object <arg>.\n                         This sets default voxel sizes.\n        SIRF.ImageData : (attempt to) convert data from another SIRF ImageData container.\n        None           : create an empty ImageData object. Call initialise()\n                         method before using it.\n        \"\"\"\n        self.handle = None\n        if isinstance(arg, str):\n            self.handle = pystir.cSTIR_objectFromFile('Image', arg)\n            check_status(self.handle)\n        elif isinstance(arg, AcquisitionData):\n            if arg.handle is None:\n                raise AssertionError()\n            self.handle = pystir.cSTIR_imageFromAcquisitionData(arg.handle)\n            check_status(self.handle)\n        elif isinstance(arg, SIRF.ImageData):\n            if arg.handle is None:\n                raise AssertionError()\n            self.handle = pystir.cSTIR_imageFromImageData(arg.handle)\n            check_status(self.handle)\n        elif arg is not None:\n            raise error(\n                'wrong argument ' + repr(arg) + ' for ImageData constructor')\n        self.name = 'ImageData'\n        self.rimsize = -1",
  "def __del__(self):\n        \"\"\"Deallocates this ImageData object.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def same_object(self):\n        \"\"\"See DataContainer method.\"\"\"\n        return ImageData()",
  "def modality(self):\n        \"\"\"Returns imaging modality as Python string.\"\"\"\n        return parms.char_par(self.handle, 'ImageData', 'modality')",
  "def set_modality(self, mod):\n        \"\"\"Sets imaging modality.\n\n        mod: \"PT\" or \"NM\" or \"MR\" or \"CT\" or \"US\" or \"Optical\"\n        \"\"\"\n        return parms.set_char_par(self.handle, 'ImageData', 'modality', mod)",
  "def initialise(self, dim, vsize=(1., 1., 1.), origin=(0., 0., 0.)):\n        \"\"\"\n        Sets image size and geometric information.\n\n        If self is not an empty ImageData, its contents are erased.\n        Dimemsions (number of voxels) are required,\n        spacing and offset are optional.\n        Spacing and offset are to be given in mm.\n        All should be given as (z,y,x).\n        \"\"\"\n        if not isinstance(dim, tuple):\n            raise error(\n                \"sirf.STIR.Imagedata.initialise: dim should be a tuple\")\n        if not isinstance(vsize, tuple):\n            raise error(\n                \"sirf.STIR.Imagedata.initialise: vsize should be a tuple\")\n        if not isinstance(origin, tuple):\n            raise error(\n                \"sirf.STIR.Imagedata.initialise: origin should be a tuple\")\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = None\n        voxels = pystir.cSTIR_voxels3DF(\n            int(dim[2]), int(dim[1]), int(dim[0]),\n            float(vsize[2]), float(vsize[1]), float(vsize[0]),\n            float(origin[2]), float(origin[1]), float(origin[0]))\n        check_status(voxels)\n        self.handle = pystir.cSTIR_imageFromVoxels(voxels)\n        check_status(self.handle)\n        pyiutil.deleteDataHandle(voxels)",
  "def fill(self, value):\n        \"\"\"Sets the voxel values.\n\n        The argument is either ImageData or 3D Numpy ndarray of values or a\n        scalar to be assigned at each voxel. When using an ndarray, the array\n        must have the same size as an array returned by `as_array`.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if isinstance(value, ImageData):\n            super(ImageData, self).fill(value)\n#            try_calling(pystir.cSTIR_setImageDataFromImage \\\n#                        (self.handle, value.handle))\n        elif isinstance(value, numpy.ndarray):\n            dims = self.dimensions()\n            shape = value.shape\n            if shape != dims:\n                msg = 'cannot fill ImageData of size %s' \\\n                      + ' with data of size %s'\n                raise ValueError(msg % (repr(dims), repr(shape)))\n            if value.dtype is numpy.dtype('float32'):\n                # print('keeping dtype float32')\n                v = value\n            else:\n                # print('changing dtype to float32')\n                v = value.astype(numpy.float32)\n            if not v.flags['C_CONTIGUOUS']:\n                v = numpy.ascontiguousarray(v)\n            try_calling(pystir.cSTIR_setImageData(self.handle, v.ctypes.data))\n        elif isinstance(value, (Number, numpy.number)):\n            try_calling(pystir.cSTIR_fillImage(self.handle, float(value)))\n        else:\n            raise TypeError('wrong fill value.' + \\\n                        ' Should be ImageData, numpy.ndarray, float or int. Got {}'\\\n                        .format(type(value)))\n        return self",
  "def get_uniform_copy(self, value=1.0):\n        \"\"\"Creates a copy of this image filled with <value>.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        image = ImageData()\n        image.handle = pystir.cSTIR_imageFromImage(self.handle)\n        check_status(image.handle)\n        image.fill(value)\n        return image",
  "def add_shape(self, shape, scale, num_samples_in_each_direction=1):\n        \"\"\"Adds a shape to self - see Shape above.\n\n        If a shape partially fills a voxel, it is possible to choose the\n        number of samples that will be used in each direction to determine the\n        fraction of the voxel that is filled by the shape. For a 3D image,\n        using num_samples_in_each_direction=2 would result in 2^3=8 samples.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(shape, Shape)\n        try_calling(pystir.cSTIR_addShape(\n            self.handle, shape.handle, scale,\n            int(num_samples_in_each_direction)))",
  "def read_from_file(self, filename):\n        \"\"\"\n        Reads data from file.\n\n        Replaces the current content of the object.\n        \"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pystir.cSTIR_objectFromFile('Image', filename)\n        check_status(self.handle)",
  "def dimensions(self):\n        \"\"\"Returns image dimensions as a tuple (nz, ny, nx).\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        dim = numpy.ndarray((MAX_IMG_DIMS,), dtype=cpp_int_dtype())\n        try_calling(\n            pystir.cSTIR_getImageDimensions(self.handle, dim.ctypes.data))\n        return tuple(dim[:3])",
  "def voxel_sizes(self):\n        \"\"\"Returns image voxel sizes as a tuple (vz, vy, vx).\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        vs = numpy.ndarray((3,), dtype=numpy.float32)\n        try_calling(\n            pystir.cSTIR_getImageVoxelSizes(self.handle, vs.ctypes.data))\n        return tuple(vs)",
  "def spacing(self):\n        return self.voxel_sizes()",
  "def transf_matrix(self):\n        \"\"\"Returns transformation matrix.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        tm = numpy.ndarray((4, 4), dtype=numpy.float32)\n        try_calling(\n            pystir.cSTIR_getImageTransformMatrix(self.handle, tm.ctypes.data))\n        return tm",
  "def as_array(self):\n        \"\"\"Returns 3D Numpy ndarray with values at the voxels.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        array = numpy.ndarray(self.dimensions(), dtype=numpy.float32)\n        try_calling(pystir.cSTIR_getImageData(self.handle, array.ctypes.data))\n        return array",
  "def write_par(self, filename, par):\n        \"\"\"Writes with parameter file.\"\"\"\n        try_calling(pystir.cSTIR_writeImage_par(self.handle, filename, par))",
  "def show(self, slice=None, title=None):\n        \"\"\"Displays xy-cross-section(s) of this image.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if not HAVE_PYLAB:\n            print('pylab not found')\n            return\n        data = self.as_array()\n        nz = data.shape[0]\n        if isinstance(slice, (Integral,numpy.integer)):\n            if slice < 0 or slice >= nz:\n                raise IndexError('Slice index out of range')\n            show_2D_array('slice %d' % slice, data[slice, :, :])\n            return\n        elif slice is None:\n            ni = nz\n            slice = range(nz)\n        else:\n            try:\n                ni = len(slice)\n            except:\n                raise error('wrong slice list')\n        if title is None:\n            title = 'Selected images'\n        if ni >= 16:\n            tiles = (4, 4)\n        else:\n            tiles = None\n        f = 0\n        while f < ni:\n            t = min(f + 16, ni)\n            show_3D_array(data, index=slice[f : t], tile_shape=tiles,\n                          label='slice', xlabel='x', ylabel='y',\n                          suptitle=title, show=(t == ni))\n            f = t",
  "def allocate(self, value=0, **kwargs):\n        \"\"\"Alias to get_uniform_copy for CIL/SIRF compatibility.\"\"\"\n        if value in ['random', 'random_int']:\n            out = self.get_uniform_copy()\n            shape = out.as_array().shape\n            seed = kwargs.get('seed', None)\n            if seed is not None:\n                numpy.random.seed(seed)\n            if value == 'random':\n                out.fill(numpy.random.random_sample(shape))\n            elif value == 'random_int':\n                max_value = kwargs.get('max_value', 100)\n                out.fill(numpy.random.randint(max_value, size=shape))\n        elif value is None:\n            if self.is_empty():\n                out = self.get_uniform_copy(0)\n            else:\n                out = self.copy()\n        else:\n            out = self.get_uniform_copy(value)\n        return out",
  "def zoom_image(self, zooms=(1., 1., 1.), offsets_in_mm=(0., 0., 0.),\n                   size=(-1, -1, -1), scaling='preserve_sum'):\n        \"\"\"\n        Returns a zoomed image.\n\n        All coordinates and indices are given as (z,y,x).\n        To leave the size unchanged in any dimension, set the\n        corresponding size to -1\n        Supported scaling options are: 'preserve_sum', 'preserve_values' and\n        'preserve_projections'\n        \"\"\"\n        zoomed_im = self.clone()\n\n        if not isinstance(zooms, tuple):\n            raise error('zoom_image: zooms should be tuple')\n        if not isinstance(offsets_in_mm, tuple):\n            raise error('zoom_image: offsets_in_mm should be tuple')\n        if not isinstance(size, tuple):\n            raise error('zoom_image: size should be tuple')\n        np_zooms = numpy.asarray(zooms, dtype=numpy.float32)\n        np_offsets_in_mm = numpy.asarray(offsets_in_mm, dtype=numpy.float32)\n        np_size = numpy.asarray(size, dtype=cpp_int_dtype())\n\n        try_calling(pystir.cSTIR_ImageData_zoom_image(\n            zoomed_im.handle, np_zooms.ctypes.data,\n            np_offsets_in_mm.ctypes.data, np_size.ctypes.data, scaling))\n\n        return zoomed_im",
  "def move_to_scanner_centre(self, proj_data):\n        \"\"\"Moves the image to the scanner centre.\n\n        AcquisitionData is required as bed shift etc. will be taken into\n        account when available.\n        \"\"\"\n        if not isinstance(proj_data, AcquisitionData):\n            raise error('move_to_scanner_centre: proj_data should' +\n                        'be of type AcquisitionData')\n        if proj_data.handle is None:\n            raise error('move_to_scanner_centre: proj_data is not initialised')\n        if self.handle is None:\n            raise error('move_to_scanner_centre: image is not initialised')\n        moved_im = self.clone()\n        try_calling(pystir.cSTIR_ImageData_move_to_scanner_centre(\n            moved_im.handle, proj_data.handle))\n\n        return moved_im",
  "def shape(self):\n        return self.dimensions()",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        # TODO: handle input and output in cSTIR\n        self.input = None\n        self.output = None",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def apply(self, image):\n        \"\"\"Applies this filter to the specified image.\"\"\"\n        assert_validity(image, ImageData)\n        try_calling(pystir.cSTIR_applyImageDataProcessor(\n            self.handle, image.handle))",
  "def set_input(self, input):\n        \"\"\"Sets the input data.\"\"\"\n        assert_validity(input, ImageData)\n        self.input = input",
  "def process(self, input=None):\n        \"\"\"Processes data.\"\"\"\n        if input is not None:\n            self.input = input\n        if self.input is None:\n            raise error('input image not set')\n        assert_validity(self.input, ImageData)\n        self.output = self.input.clone()\n        self.apply(self.output)\n        return self.output",
  "def get_output(self):\n        \"\"\"Returns the output data.\"\"\"\n        return self.output",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.input = None\n        self.output = None\n        self.name = 'SeparableGaussianImageFilter'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_up(self, image):\n        \"\"\"Sets up.\"\"\"\n        assert_validity(image, ImageData)\n        try_calling(pystir.cSTIR_setupImageDataProcessor(\n            self.handle, image.handle))",
  "def set_fwhms(self, fwhms):\n        \"\"\"Sets FWHM in mm.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'fwhms_x', fwhms[2])\n        parms.set_float_par(self.handle, self.name, 'fwhms_y', fwhms[1])\n        parms.set_float_par(self.handle, self.name, 'fwhms_z', fwhms[0])",
  "def set_max_kernel_sizes(self, mks):\n        \"\"\"Sets max kernel sizes in voxels.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'max_kernel_size_x', mks[2])\n        parms.set_int_par(self.handle, self.name, 'max_kernel_size_y', mks[1])\n        parms.set_int_par(self.handle, self.name, 'max_kernel_size_z', mks[0])",
  "def set_normalise(self, norm=True):\n        \"\"\"Sets normalise.\"\"\"\n        v = 1 if norm else 0\n        parms.set_int_par(self.handle, self.name, 'normalise', v)",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'TruncateToCylindricalFOVImageProcessor'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_strictly_less_than_radius(self, flag):\n        \"\"\"Specifies the behaviour on the boundary.\n\n        Specifies whether the area not affected by filtering is strictly\n        inside the cylinder (flag = True) or not (flag = False).\n        \"\"\"\n        parms.set_char_par(\n            self.handle, 'TruncateToCylindricalFOVImageProcessor',\n            'strictly_less_than_radius', repr(flag))",
  "def get_strictly_less_than_radius(self):\n        \"\"\"Returns the boundary behaviour flag.\n\n        Returns the answer to the question: Is the area not affected by\n        filtering strictly inside the cylinder?\n        \"\"\"\n        return parms.int_par(\n            self.handle, 'TruncateToCylindricalFOVImageProcessor',\n            'strictly_less_than_radius') != 0",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n        parms.set_int_par(self.handle, self.name, 'num_tangential_LORs', 2)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def get_info(self):\n        \"\"\"Returns the metadata from STIR as Python str.\"\"\"\n        handle = pystir.cSTIR_get_MatrixInfo(self.handle)\n        check_status(handle)\n        info = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return info",
  "def set_num_tangential_LORs(self, value):\n        \"\"\"Sets the number of tangential LORs.\n\n        Sets the number of LORs (or rays) for each bin in the sinogram.\n        They are currently (approximately) parallel and spaced in the\n        tangential direction (i.e. orthogonal to the axial direction).\n        \"\"\"\n        parms.set_int_par(self.handle, self.name, 'num_tangential_LORs', value)\n        return self",
  "def get_num_tangential_LORs(self):\n        \"\"\"Returns the number of LORs for each bin in the sinogram.\"\"\"\n        return parms.int_par(self.handle, self.name, 'num_tangential_LORs')",
  "def enable_cache(self, value=True):\n        \"\"\"Enables or disables the caching mechanism.\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'enable_cache', value)\n        return self",
  "def set_restrict_to_cylindrical_FOV(self, value=True):\n        \"\"\"Enables or disables using a circular axial FOV (vs rectangular).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'restrict_to_cylindrical_FOV', value)\n        return self",
  "def set_do_symmetry_90degrees_min_phi(self, value=True):\n        \"\"\"Enables or disables a symmetry (disabling saves memory but might increase computation time).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'do_symmetry_90degrees_min_phi', value)\n        return self",
  "def set_do_symmetry_180degrees_min_phi(self, value=True):\n        \"\"\"Enables or disables a symmetry (disabling saves memory but might increase computation time).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'do_symmetry_180degrees_min_phi', value)\n        return self",
  "def set_do_symmetry_swap_segment(self, value=True):\n        \"\"\"Enables or disables a symmetry (disabling saves memory but might increase computation time).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'do_symmetry_swap_segment', value)\n        return self",
  "def set_do_symmetry_swap_s(self, value=True):\n        \"\"\"Enables or disables a symmetry (disabling saves memory but might increase computation time).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'do_symmetry_swap_s', value)\n        return self",
  "def set_do_symmetry_shift_z(self, value=True):\n        \"\"\"Enables or disables a symmetry (disabling saves memory but might increase computation time).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'do_symmetry_shift_z', value)\n        return self",
  "def __init__(self):\n        '''\n        Create a new matrix. Default settings use neither attenuation nor resolution modelling.\n        '''\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_keep_all_views_in_cache(self, value):\n        '''\n        Enable keeping the matrix in memory.\n\n        This speeds-up the calculations, but can use a lot of memory.\n\n        You have to call set_up() after this (unless the value didn't change).\n        '''\n        parms.set_int_par(self.handle, self.name, 'keep_all_views_in_cache', value)\n        return self",
  "def get_keep_all_views_in_cache(self):\n        '''\n        Returns a bool checking if we're keeping the whole matrix in memory or not.\n        '''\n        return parms.int_par(self.handle, self.name, 'keep_all_views_in_cache') != 0",
  "def set_attenuation_image(self, value):\n        '''\n        Sets the attenuation image used by the projector.\n        '''\n        assert_validity(value, ImageData)\n        parms.set_parameter(self.handle, self.name, 'attenuation_image', value.handle)\n        return self",
  "def get_attenuation_image(self):\n        '''\n        Returns the attenuation image used by the projector.\n        '''\n        image = ImageData()\n        image.handle = parms.parameter_handle(self.handle, self.name, 'attenuation_image')\n        return image",
  "def set_resolution_model(self, collimator_sigma_0_in_mm, collimator_slope_in_mm, full_3D = True):\n        '''\n        Set the parameters for the depth-dependent resolution model\n\n        The detector and collimator blurring is modelled as a Gaussian with sigma dependent on the\n        distance from the collimator.\n\n        sigma_at_depth = collimator_slope * depth_in_mm + collimator sigma 0\n\n        Set slope and sigma_0 to zero to avoid resolution modelling.\n\n        You have to call set_up() after this.\n        '''\n        try_calling(pystir.cSTIR_SPECTUBMatrixSetResolution(self.handle, collimator_sigma_0_in_mm, collimator_slope_in_mm, full_3D))",
  "def set_up(self, acq, img):\n        try_calling(pystir.cSTIR_setupSPECTUBMatrix(self.handle, acq.handle, img.handle))",
  "def __init__(self):\n        \"\"\"Create a new matrix. Default settings use neither attenuation, PSF, or DOI modelling.\"\"\"\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def get_maximum_number_of_sigmas(self):\n        \"\"\"Returns the number of sigmas to consider when correcting for intrinsic PSF.\"\"\"\n        return parms.float_par(self.handle, self.name, 'maximum_number_of_sigmas')",
  "def set_maximum_number_of_sigmas(self, value):\n        \"\"\"Sets the number of sigmas to consider when correcting for intrinsic PSF.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'maximum_number_of_sigmas', value)",
  "def get_spatial_resolution_PSF(self):\n        \"\"\"Returns the spatial high resolution in which to sample distributions (in cm).\"\"\"\n        return parms.float_par(self.handle, self.name, 'spatial_resolution_PSF')",
  "def set_spatial_resolution_PSF(self, value):\n        \"\"\"Sets the spatial high resolution in which to sample distributions (in cm).\"\"\"\n        parms.set_float_par(self.handle, self.name, 'spatial_resolution_PSF', value)",
  "def get_subsampling_factor_PSF(self):\n        \"\"\"Returns the subsampling factor to compute convolutions when PSF or DOI corrections are enabled.\"\"\"\n        return parms.int_par(self.handle, self.name, 'subsampling_factor_PSF')",
  "def set_subsampling_factor_PSF(self, value):\n        \"\"\"Sets the subsampling factor to compute convolutions when PSF or DOI corrections are enabled.\"\"\"\n        parms.set_int_par(self.handle, self.name, 'subsampling_factor_PSF', value)",
  "def set_detector_file(self, filename):\n        \"\"\"Sets the name of the file containing the detector information.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'detector_file', filename)",
  "def set_collimator_file(self, filename):\n        \"\"\"Sets the name of the file containing the collimator information.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'collimator_file', filename)",
  "def get_psf_correction(self):\n        \"\"\"Returns the setting for enabling corrections for intrinsic PSF.\"\"\"\n        return parms.char_par(self.handle, self.name, 'psf_correction')",
  "def set_psf_correction(self, value):\n        \"\"\"Enable or disable corrections for intrinsic PSF.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'psf_correction', value)",
  "def get_doi_correction(self):\n        \"\"\"Returns the setting for enabling corrections for depth of interaction.\"\"\"\n        return parms.char_par(self.handle, self.name, 'doi_correction')",
  "def set_doi_correction(self, value):\n        \"\"\"Enable or disable corrections for depth of interaction.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'doi_correction', value)",
  "def get_attenuation_type(self):\n        \"\"\"Returns the attenuation type: full, simple, or no.\"\"\"\n        return parms.char_par(self.handle, self.name, 'attenuation_type')",
  "def set_attenuation_type(self, value):\n        \"\"\"Set the attenuation type to full, simple, or no.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'attenuation_type', value)",
  "def get_attenuation_image(self):\n        \"\"\"Returns the attenuation image used by the projector.\"\"\"\n        image = ImageData()\n        image.handle = parms.parameter_handle(self.handle, self.name, 'attenuation_image')\n        return image",
  "def set_attenuation_image(self, value):\n        \"\"\"Sets the attenuation image used by the projector.\"\"\"\n        assert_validity(value, ImageData)\n        parms.set_parameter(self.handle, self.name, 'attenuation_image', value.handle)\n        return self",
  "def get_object_radius(self):\n        \"\"\"Returns the radius of the object in the xy plane of the image volume.\"\"\"\n        return parms.float_par(self.handle, self.name, 'object_radius')",
  "def set_object_radius(self, value):\n        \"\"\"Sets the radius of the object in the xy plane of the image volume. Could be used for masking.\"\"\"\n        parms.set_float_par(self.handle, self.name, 'object_radius', value)",
  "def get_mask_image(self):\n        \"\"\"Returns the mask image used by the projector.\"\"\"\n        image = ImageData()\n        image.handle = parms.parameter_handle(self.handle, self.name, 'mask_image')\n        return image",
  "def set_mask_image(self, value):\n        \"\"\"Sets the mask image used by the projector.\"\"\"\n        assert_validity(value, ImageData)\n        parms.set_parameter(self.handle, self.name, 'mask_image', value.handle)\n        return self",
  "def get_keep_all_views_in_cache(self):\n        \"\"\"Returns a bool checking if we're keeping the whole matrix in memory or not.\"\"\"\n        return parms.bool_par(self.handle, self.name, 'keep_all_views_in_cache')",
  "def set_keep_all_views_in_cache(self, value):\n        \"\"\"Enable keeping the matrix in memory to speed-up calculations (can use lots of memory).\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'keep_all_views_in_cache', value)\n        return self",
  "def get_mask_from_attenuation_map(self):\n        \"\"\"Returns a bool checking if we're masking with the attenuation map or not.\"\"\"\n        return parms.bool_par(self.handle, self.name, 'mask_from_attenuation_map')",
  "def set_mask_from_attenuation_map(self, value):\n        \"\"\"Enable masking from attenuation map if mask file is not set.\"\"\"\n        parms.set_bool_par(self.handle, self.name, 'mask_from_attenuation_map', value)\n        return self",
  "def __init__(self, src=None, span=1, max_ring_diff=-1, view_mash_factor=1, tof_mash_factor=1):\n        \"\"\"Creates new AcquisitionData.\n\n        Can create object from a file or another AcquisitionData object.\n        src:  file name (Python str) or AcquisitionData object or scanner name\n        \"\"\"\n        self.handle = None\n        self.name = 'AcquisitionData'\n        self.read_only = False\n        self.src = None\n        if src is None:\n            return\n        if isinstance(src, str):\n            i = src.find('.')\n            if i > -1:\n                # src is a file name\n                self.handle = pystir.cSTIR_objectFromFile(\n                    'AcquisitionData', src)\n                self.read_only = self.get_storage_scheme() == 'file'\n                self.src = 'file'\n            else:\n                # src is a scanner name\n                self.handle = pystir.cSTIR_acquisitionDataFromScannerInfo(\n                    src, span, max_ring_diff, view_mash_factor, tof_mash_factor)\n                if pyiutil.executionStatus(self.handle) != 0:\n                    msg = pyiutil.executionError(self.handle)\n                    if msg == 'Unknown scanner':\n                        raise error(\n                            'Unknown scanner ' + src +\n                            ' or missing raw data file extension')\n                self.src = 'scanner'\n        elif isinstance(src, AcquisitionData):\n            # src is AcquisitionData\n            if src.handle is None:\n                raise AssertionError()\n            self.handle = pystir.cSTIR_acquisitionDataFromTemplate(src.handle)\n            self.src = 'template'\n        else:\n            raise error('Wrong source in AcquisitionData constructor')\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        # print('deleting AcquisitionData object originated from ', self.src)\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_storage_scheme(scheme):\n        \"\"\"Sets acquisition data storage scheme.\n\n        scheme = 'file' (default):\n            all acquisition data generated from now on will be kept in\n            scratch files deleted after the user's script terminates\n        scheme = 'memory':\n            all acquisition data generated from now on will be kept in RAM\n            (avoid if data is very large)\n        \"\"\"\n        try_calling(pystir.cSTIR_setAcquisitionDataStorageScheme(scheme))",
  "def get_storage_scheme():\n        \"\"\"Returns acquisition data storage scheme.\"\"\"\n        handle = pystir.cSTIR_getAcquisitionDataStorageScheme()\n        check_status(handle)\n        scheme = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return scheme",
  "def same_object(self):\n        \"\"\"See DataContainer method.\"\"\"\n        return AcquisitionData()",
  "def read_from_file(self, filename):  # 'read_from_file' is misleading\n        \"\"\"\n        Reads data from file.\n\n        Replaces the current content of the object.\n        \"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)\n        self.handle = pystir.cSTIR_objectFromFile('AcquisitionData', filename)\n        check_status(self.handle)\n        self.read_only = True",
  "def create_uniform_image(self, value=0, xy=None):\n        \"\"\"Crates uniform image.\n\n        Creates ImageData object containing PET image of z-dimension\n        and voxel sizes compatible with the scanner geometry stored\n        in this AcquisitionData object and assigns a given value\n        to all voxels;\n        value: a Python float.\n        xy   : x and y dimensions tuple (if None, set by STIR)\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        image = ImageData()\n        if xy is None:\n            image.handle = pystir.cSTIR_imageFromAcquisitionData(self.handle)\n        elif isinstance(xy, tuple):\n            image.handle = pystir.cSTIR_imageFromAcquisitionDataAndNxNy(\n                self.handle, xy[1], xy[0])\n        elif isinstance(xy, int):\n            image.handle = pystir.cSTIR_imageFromAcquisitionDataAndNxNy(\n                self.handle, xy, xy)\n        else:\n            raise error('Wrong second argument in create_uniform_image')\n        check_status(image.handle)\n        image.fill(value)\n        return image",
  "def dimensions(self):\n        \"\"\"Returns a tuple of the data dimensions.\n\n        Contains:\n        - number of TOF bins\n        - number of sinograms\n        - number of views\n        - number of tangential positions.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        dim = numpy.ndarray((MAX_ACQ_DIMS,), dtype=cpp_int_dtype())\n        try_calling(pystir.cSTIR_getAcquisitionDataDimensions(\n            self.handle, dim.ctypes.data))\n        dim = dim[:4]\n        return tuple(dim[::-1])",
  "def get_tof_mash_factor(self):\n        '''Returns TOF mashing factor.'''\n        return parms.int_par(self.handle, 'AcquisitionData', 'tof_mash_factor')",
  "def as_array(self):\n        \"\"\"Returns bin values as ndarray.\n\n        Return a copy of acquisition data stored in this object as a\n        NumPy ndarray of 4 dimensions (in default C ordering of data):\n        - number of TOF bins\n        - number of sinograms\n        - number of views\n        - number of tangential positions.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        array = numpy.ndarray(self.dimensions(), dtype=numpy.float32)\n        try_calling(pystir.cSTIR_getAcquisitionData(\n            self.handle, array.ctypes.data))\n        return array",
  "def fill(self, value):\n        \"\"\"Fills the object with values.\n\n        value:  either NumPy ndarray or another AcquisitionData object\n                or Python float.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        if self.read_only:\n            raise error(\n                'Cannot fill read-only object, consider filling a clone')\n        if isinstance(value, numpy.ndarray):\n            dims = self.dimensions()\n            shape = value.shape\n            if shape != dims:\n                msg = 'cannot fill AcquisitionData of size %s' \\\n                      + ' with data of size %s'\n                raise ValueError(msg % (repr(dims), repr(shape)))\n            if value.dtype is numpy.dtype('float32'):\n                # print('keeping dtype float32')\n                v = value\n            else:\n                # print('changing dtype to float32')\n                v = value.astype(numpy.float32)\n            if not v.flags['C_CONTIGUOUS']:\n                v = numpy.ascontiguousarray(v)\n            try_calling(pystir.cSTIR_setAcquisitionData(\n                self.handle, v.ctypes.data))\n        elif isinstance(value, AcquisitionData):\n            if value.handle is None:\n                raise AssertionError()\n            try_calling(pystir.cSTIR_fillAcquisitionDataFromAcquisitionData(\n                self.handle, value.handle))\n        elif isinstance(value, float):\n            try_calling(pystir.cSTIR_fillAcquisitionData(self.handle, value))\n        elif isinstance(value, (Integral,numpy.number)):\n            try_calling(pystir.cSTIR_fillAcquisitionData(\n                self.handle, float(value)))\n        else:\n            raise TypeError('Wrong fill value.' + \\\n                ' Should be numpy.ndarray, AcquisitionData, float or int, got {}'\\\n                .format(type(value)))\n        return self",
  "def get_uniform_copy(self, value=0):\n        \"\"\"Returns a copy of this object filled with given value.\n\n        Returns a true copy of this object filled with a given value;\n        value:  a Python float.\n        \"\"\"\n        ad = AcquisitionData(self)\n        ad.fill(value)\n        ad.src = 'copy'\n        return ad",
  "def rebin(self, num_segments_to_combine,\n              num_views_to_combine=1, num_tang_poss_to_trim=0,\n              do_normalisation=True, max_in_segment_num_to_process=-1,\n              num_tof_bins_to_combine=1):\n        \"\"\"Re-bins the data to lower resolution.\n\n        Keyword arguments:\n\t\tnum_segments_to_combine -- combines multiple oblique 'segments' together. If set to the\n\t\t    total number of segments, this corresponds to SSRB. Another example is if the input data\n\t\t\thas 'span=1', the output span will be equal to the \\c num_segments_to_combine.\n\t\tnum_views_to_combine -- combines neighbouring views. Needs to be a divisor of the total\n\t\t    number of views in the data.\n\t\tnum_tang_poss_to_trim -- removes a number of tangential positions (horizontal direction\n\t\t    in the sinogram) at each end\n\t\tdo_normalisation -- if True, averages the data, otherwise it adds the data. Often\n\t\t    the latter is required for emission data (as it preserves Poisson statistics),\n\t\t\twhile the former should be used for corrected data (or for attenuation correction factors).\n\t\tmax_in_segment_num_to_process -- by default all input data are used. If set to a non-negative\n\t\t    number, it will remove the most oblique segments.\n\t\tnum_tof_bins_to_combine -- number of TOF bins to combine.\n        \"\"\"\n        ad = AcquisitionData()\n        ad.handle = pystir.cSTIR_rebinnedAcquisitionData(\n            self.handle,\n            num_segments_to_combine, num_views_to_combine,\n            num_tang_poss_to_trim, do_normalisation,\n            max_in_segment_num_to_process, num_tof_bins_to_combine)\n        check_status(ad.handle)\n        return ad",
  "def show(self, sino=None, tof=0, title=None):\n        '''Displays selected sinograms.'''\n        if self.handle is None:\n            raise AssertionError()\n        if not HAVE_PYLAB:\n            print('pylab not found')\n            return\n        data = self.as_array()\n        if tof <0 or tof >= data.shape[0]:\n            raise IndexError('TOF bin index out of range')\n        nz = data.shape[1]\n        if isinstance(sino, (Integral,numpy.integer)):\n            if sino < 0 or sino >= nz:\n                raise IndexError('Slice index out of range')\n            show_2D_array('sinogram %d' % sino, data[tof, sino, :, :])\n            return\n        elif sino is None:\n            ns = nz\n            sino = range(nz)\n        else:\n            try:\n                ns = len(sino)\n            except:\n                raise error('wrong sinograms list')\n        if title is None:\n            title = 'Selected sinograms'\n        if ns >= 16:\n            tiles = (4, 4)\n        else:\n            tiles = None\n        f = 0\n        while f < ns:\n            t = min(f + 16, ns)\n            show_3D_array(\n                data[0, :, :, :],\n                index=sino[f: t], tile_shape=tiles,\n                label='sinogram',\n                xlabel='tang.pos', ylabel='view',\n                suptitle=title, show=(t == ns))\n            f = t",
  "def allocate(self, value=0, **kwargs):\n        \"\"\"Alias to get_uniform_copy.\n\n        CIL/SIRF compatibility\n        \"\"\"\n        if value in ['random', 'random_int']:\n            out = self.get_uniform_copy()\n            shape = out.as_array().shape\n            seed = kwargs.get('seed', None)\n            if seed is not None:\n                numpy.random.seed(seed)\n            if value == 'random':\n                out.fill(numpy.random.random_sample(shape))\n            elif value == 'random_int':\n                max_value = kwargs.get('max_value', 100)\n                out.fill(numpy.random.randint(max_value,size=shape))\n        elif value is None:\n            out = self.get_uniform_copy(0)\n        else:\n            out = self.get_uniform_copy(value)\n        return out",
  "def get_info(self):\n        \"\"\"Returns the AcquisitionData's metadata as Python str.\"\"\"\n        handle = pystir.cSTIR_get_ProjDataInfo(self.handle)\n        check_status(handle)\n        info = pyiutil.charDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return info",
  "def get_subset(self, views):\n        \"\"\"Returns the subset of self data formed by specified views\n\n        views: array of views (will be converted to numpy ndarray)\n        \"\"\"\n        # Ensure the array passed to C++ is a contiguous array of C++ int's\n        v = cpp_int_array(views)\n        n = len(views)\n        subset = AcquisitionData()\n        subset.handle = pystir.cSTIR_get_subset(self.handle, n, v.ctypes.data)\n        check_status(subset.handle)\n        return subset",
  "def shape(self):\n        return self.dimensions()",
  "def __init__(self, file=None):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'ListmodeToSinograms'\n        if file is None:\n            self.handle = pystir.cSTIR_newObject(self.name)\n        else:\n            self.handle = pystir.cSTIR_objectFromFile(self.name, file)\n        self.output = None",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_input(self, lm_file):\n        \"\"\"Sets the listmode file name.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'input', lm_file)",
  "def set_output_prefix(self, sino_file):\n        \"\"\"Sets the sinograms file names prefix.\"\"\"\n        parms.set_char_par(self.handle, self.name, 'output', sino_file)",
  "def set_template(self, templ):\n        \"\"\"Sets the sinograms template.\n\n        templ: either file name or AcquisitionData\n        \"\"\"\n        if type(templ) == type('a'):\n            parms.set_char_par(self.handle, self.name, 'template_file', templ)\n        else:\n            parms.set_parameter(self.handle, self.name, 'template', templ.handle)",
  "def set_time_interval(self, start, stop):\n        \"\"\"Sets the time interval.\n\n        Only data scanned during this time interval will be converted.\n        \"\"\"\n        interval = numpy.ndarray((2,), dtype=numpy.float32)\n        interval[0] = start\n        interval[1] = stop\n        try_calling(pystir.cSTIR_setListmodeToSinogramsInterval(\n            self.handle, interval.ctypes.data))",
  "def flag_on(self, flag):\n        \"\"\"Switches on (sets to 'true') a conversion flag.\n\n        (see conversion flags description above).\n        \"\"\"\n        try_calling(pystir.cSTIR_setListmodeToSinogramsFlag(\n            self.handle, flag, 1))",
  "def flag_off(self, flag):\n        \"\"\"Switches off (sets to 'false') a conversion flag.\n\n        (see conversion flags description above).\n        \"\"\"\n        try_calling(pystir.cSTIR_setListmodeToSinogramsFlag(\n            self.handle, flag, 0))",
  "def set_up(self):\n        \"\"\"Sets up the conversion.\"\"\"\n        try_calling(\n            pystir.cSTIR_setupListmodeToSinogramsConverter(self.handle))",
  "def process(self):\n        \"\"\"Performs the conversion.\"\"\"\n        self.output = AcquisitionData()\n        self.output.handle = pystir.cSTIR_convertListmodeToSinograms(\n            self.handle)\n        check_status(self.output.handle)",
  "def get_output(self):\n        \"\"\"Returns the sinograms as an AcquisitionData object.\"\"\"\n        if self.output is None:\n            raise error('Conversion to sinograms not done')\n        return self.output",
  "def estimate_randoms(self):\n        \"\"\"Returns an estimate of the randoms as an AcquisitionData object.\"\"\"\n        randoms = AcquisitionData()\n        randoms.handle = pystir.cSTIR_computeRandoms(self.handle)\n        check_status(randoms.handle)\n        return randoms",
  "def get_time_at_which_num_prompts_exceeds_threshold(self, threshold):\n        \"\"\"Returns the time at which the number of prompts exceeds <threshold>.\n\n        Returns -1 if no corresponding time is found.\n        \"\"\"\n        h = pystir.cSTIR_lm_num_prompts_exceeds_threshold(\n            self.handle, float(threshold))\n        check_status(h, inspect.stack()[1])\n        v = pyiutil.floatDataFromHandle(h)\n        pyiutil.deleteDataHandle(h)\n        return v",
  "def __init__(self, src, other_src=None):\n        \"\"\"\n        Create new AcquisitionSensitivityModel object.\n\n        Sources:\n        - from a manufacturer normalisation file (supported by STIR) or\n        - from ImageData object containing attenuation image (units: 1/cm) or\n        - from AcquisitionData object containing bin efficiencies or\n        - by chaining two existing AcquisitionSensitivityModel objects\n        src: file name or ImageData object or AcquisitionData object\n        other_src: AcquisitionSensitivityModel object (optional)\n        \"\"\"\n        self.handle = None\n        self.name = 'AcquisitionSensitivityModel'\n        if src is None:\n            return\n        if isinstance(src, str):\n            # create from ECAT8/GE norm file\n            print('Reading manufacturer PET normalisation file from ' + src)\n            handle = pyiutil.charDataHandle(src)\n            self.handle = pystir.cSTIR_createPETAcquisitionSensitivityModel(\n                handle, 'n')\n            pyiutil.deleteDataHandle(handle)\n        elif isinstance(src, ImageData):\n            # create from attenuation image\n            if src.handle is None:\n                raise AssertionError()\n            if other_src is None:\n                raise AssertionError('AcquisitionSensitivityModel constructor' +\n                ' with attenuation image needs an AcquisitionModel' +\n                ' as second argument (for ray tracing)')\n            assert_validity(other_src, AcquisitionModel)\n            self.handle = pystir.cSTIR_createPETAttenuationModel(\n                src.handle, other_src.handle)\n        elif isinstance(src, AcquisitionData):\n            # create from bin efficiencies (cf. AcquisitionModel)\n            if src.handle is None:\n                raise AssertionError()\n            self.handle = pystir.cSTIR_createPETAcquisitionSensitivityModel(\n                src.handle, 's')\n        elif isinstance(src, AcquisitionSensitivityModel) and \\\n                isinstance(other_src, AcquisitionSensitivityModel):\n            # chain two acquisition sensitivity models\n            if src.handle is None:\n                raise AssertionError()\n            if other_src.handle is None:\n                raise AssertionError()\n            self.handle = pystir.cSTIR_chainPETAcquisitionSensitivityModels(\n                src.handle, other_src.handle)\n        else:\n            raise error(\n                'Wrong source in AcquisitionSensitivityModel constructor')\n        check_status(self.handle)",
  "def set_up(self, ad):\n        \"\"\"Sets up the object.\"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(ad, AcquisitionData)\n        try_calling(pystir.cSTIR_setupAcquisitionSensitivityModel(\n            self.handle, ad.handle))",
  "def normalise(self, ad):\n        \"\"\"Multiplies ad by the inverse n of S from AcquisitionModel (F).\n\n        If self is a chain of two AcquisitionSensitivityModels, then n is\n        a product of two normalisations.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(ad, AcquisitionData)\n        try_calling(pystir.cSTIR_applyAcquisitionSensitivityModel(\n            self.handle, ad.handle, 'normalise'))",
  "def unnormalise(self, ad):\n        \"\"\"Multiply the argument by S from AcquisitionModel (F).\n\n        If self is a chain of two AcquisitionSensitivityModels, then S is\n        a product of two un-normalisations.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(ad, AcquisitionData)\n        try_calling(pystir.cSTIR_applyAcquisitionSensitivityModel(\n            self.handle, ad.handle, 'unnormalise'))",
  "def forward(self, ad):\n        \"\"\"Alias of unnormalise except the argument remains unchanged\n\n        and a new AcquisitionData equal to the argument multiplied\n        by S is returned.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(ad, AcquisitionData)\n        fd = AcquisitionData()\n        fd.handle = pystir.cSTIR_applyAcquisitionSensitivityModel(\n            self.handle, ad.handle, 'fwd')\n        check_status(fd.handle)\n        return fd",
  "def invert(self, ad):\n        \"\"\"Alias of normalise except that the argument remains unchanged\n\n        and a new AcquisitionData equal to the argument multiplied\n        by the inverse of S is returned.\n        \"\"\"\n        if self.handle is None:\n            raise AssertionError()\n        assert_validity(ad, AcquisitionData)\n        fd = AcquisitionData()\n        fd.handle = pystir.cSTIR_applyAcquisitionSensitivityModel(\n            self.handle, ad.handle, 'inv')\n        check_status(fd.handle)\n        return fd",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.acq_templ = None\n        self.img_templ = None\n        # reference to the background term\n        self.bt = None\n        # reference to the additive term\n        self.at = None\n        # reference to the acquisition sensitivity model\n        self.asm = None\n        # default values of subset number and selected subset\n        self._num_subsets = 1\n        self._subset_num = 0\n        # constness flag for const reference\n        self.const = False",
  "def set_up(self, acq_templ, img_templ):\n        \"\"\"Sets up.\n\n        Prepares this object for performing forward and backward\n        projections;\n        acq_templ:  an AcquisitionData object used as a template for\n                    creating an AcquisitionData object to store forward\n                    projection;\n        img_templ:  an ImageData object used as a template for creating an\n                    ImageData object to store backward projection.\n        \"\"\"\n        if self.const:\n            raise RuntimeError('cannot set_up const object')\n\n        assert_validity(acq_templ, AcquisitionData)\n        assert_validity(img_templ, ImageData)\n\n        try_calling(pystir.cSTIR_setupAcquisitionModel(\n            self.handle, acq_templ.handle, img_templ.handle))\n\n        self.acq_templ = acq_templ\n        self.img_templ = img_templ",
  "def norm(self, subset_num=0, num_subsets=1, num_iter=2, verb=0):\n        \"\"\"Computes the norm of a part the linear operator S G.\n\n        See the docstring for method forward for the desciption of\n        the partial forward projection and the arguments.\n        \"\"\"\n        assert self.handle is not None\n        handle = pystir.cSTIR_acquisitionModelNorm \\\n                 (self.handle, subset_num, num_subsets, num_iter, verb)\n        check_status(handle)\n        r = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return r;",
  "def set_additive_term(self, at):\n        \"\"\"Sets additive term.\n\n        Sets the additive term a in the acquisition model;\n        at:  an AcquisitionData object containing a.\n        \"\"\"\n        if self.const:\n            raise RuntimeError('cannot set_additive_term for a const object')\n        assert_validity(at, AcquisitionData)\n        parms.set_parameter(\n            self.handle, 'AcquisitionModel', 'additive_term', at.handle)\n        # save reference to the additive term\n        self.at = at",
  "def set_background_term(self, bt):\n        \"\"\"\n        Sets the background term b in the acquisition model.\n\n        bt:  an AcquisitionData object containing b.\n        \"\"\"\n        if self.const:\n            raise RuntimeError('cannot set_background_term for a const object')\n        assert_validity(bt, AcquisitionData)\n        parms.set_parameter(\n            self.handle, 'AcquisitionModel', 'background_term', bt.handle)\n        # save reference to the background term\n        self.bt = bt",
  "def set_image_data_processor(self, processor):\n        \"\"\"\n        Sets the image processor P in the acquisition model.\n\n        processor:  an ImageDataProcessor object.\n        \"\"\"\n        if self.const:\n            msg = 'cannot set_image_data_processor'\n            raise RuntimeError(msg + ' for a const object')\n        assert_validity(processor, ImageDataProcessor)\n        parms.set_parameter(\n            self.handle, 'AcquisitionModel', 'image_data_processor',\n            processor.handle)",
  "def get_background_term(self):\n        \"\"\"Returns the background term b of the AcquisitionModel (F).\n        \"\"\"\n        if self.bt is None:\n            if self.acq_templ is None:\n                raise RuntimeError('AcquisitionModel.set_up() call missing')\n            self.bt = AcquisitionData(self.acq_templ)\n            self.bt.fill(0)\n        return self.bt",
  "def get_additive_term(self):\n        \"\"\"Returns the additive term a of the AcquisitionModel (F).\n        \"\"\"\n        if self.at is None:\n            if self.acq_templ is None:\n                raise RuntimeError('AcquisitionModel.set_up() call missing')\n            self.at = AcquisitionData(self.acq_templ)\n            self.at.fill(0)\n        return self.at",
  "def get_constant_term(self):\n        \"\"\"Returns the constant term S a + b in (F).\n        \"\"\"\n        if self.asm is not None:\n            return self.asm.forward(self.get_additive_term()) + \\\n                   self.get_background_term()\n        else:\n            return self.get_additive_term() + self.get_background_term()",
  "def set_acquisition_sensitivity(self, asm):\n        \"\"\"Sets S in the AcquisitionModel (F).\n\n        asm:  an AcquisitionSensitivityModel object.\n        \"\"\"\n        if self.const:\n            msg = 'cannot set_acquisition_sensitivity'\n            raise RuntimeError(msg + ' for a const object')\n        assert_validity(asm, AcquisitionSensitivityModel)\n        parms.set_parameter(\n            self.handle, 'AcquisitionModel', 'asm', asm.handle)\n        # save reference to the Acquisition Sensitivity Model\n        self.asm = asm",
  "def forward(self, image, subset_num=None, num_subsets=None, out=None):\n        \"\"\"Returns the [partial] forward projection of image.\n\n        If <num_subsets> is greater than 1, then the forward projection data\n        y in AcquisitionModel (F) is divided into <num_subsets> subsets and\n        only subset <subset_num> is computed; otherwise the full forward\n        projection is computed.\n        image      : an ImageData object.\n        subset_num : int, optional\n                     subset number to forward project to; if None, subset_num\n                     is set to self.subset_num.\n        num_subsets: int, optional\n                     number of subsets y is divided into; if None, num_subsets\n                     is set to self.num_subsets.\n        out        : an existing AcquisitionData object, optional\n                     the destination for the projection; if None a new\n                     AcquisitionData object will be returned.\n        \"\"\"\n        assert_validity(image, ImageData)\n        if subset_num is None:\n            subset_num = self.subset_num\n        if num_subsets is None:\n            num_subsets = self.num_subsets\n        if out is None:\n            ad = AcquisitionData()\n            ad.handle = pystir.cSTIR_acquisitionModelFwd(\n                self.handle, image.handle, subset_num, num_subsets)\n            check_status(ad.handle)\n            return ad\n        ad = out\n        assert_validity(ad, AcquisitionData)\n        try_calling(pystir.cSTIR_acquisitionModelFwdReplace(\n            self.handle, image.handle, subset_num, num_subsets, ad.handle))",
  "def backward(self, ad, subset_num=None, num_subsets=None, out=None):\n        \"\"\"\n        Return the [partial] backward projection of ad.\n\n        ad         : an AcquisitionData object.\n        subset_num : int, optional\n                     subset number to backproject; if None, is set to\n                     self.subset_num.\n        num_subsets: int, optional\n                     the number of subsets of ad; if None, is set to\n                     self.num_subsets.\n        out        : optional AcquisitionData to store the result into. \n                     Default None, if None a new AcquisitionData will be \n                     returned.\n        \"\"\"\n        assert_validity(ad, AcquisitionData)\n        if subset_num is None:\n            subset_num = self.subset_num\n        if num_subsets is None:\n            num_subsets = self.num_subsets\n        if out is None:\n            image = ImageData()\n            image.handle = pystir.cSTIR_acquisitionModelBwd(\n                self.handle, ad.handle, subset_num, num_subsets)\n            check_status(image.handle)\n            return image\n        assert_validity(out, ImageData)\n        try_calling(pystir.cSTIR_acquisitionModelBwdReplace(\n                self.handle, ad.handle, subset_num, num_subsets, out.handle))",
  "def get_linear_acquisition_model(self):\n        \"\"\"Returns the linear part L = S G P of self.\n        \"\"\"\n        am = AcquisitionModel()\n        am.handle = pystir.cSTIR_linearAcquisitionModel(self.handle)\n        check_status(am.handle)\n        am.const = True # am to be a const reference of self\n        return am",
  "def direct(self, image, out=None):\n        '''Projects an image into the (simulated) acquisition space,\n           calls forward with num_subset and on subset_num members\n\n           Added for CCPi CIL compatibility\n           https://github.com/CCPPETMR/SIRF/pull/237#issuecomment-439894266\n        '''\n        if self.is_linear():\n            return self.forward(image, \\\n                                subset_num=self.subset_num, \\\n                                num_subsets=self.num_subsets, \\\n                                out=out)\n        else:\n            raise error('AcquisitionModel is not linear\\nYou can get the ' +\n                        'linear part of the AcquisitionModel with ' +\n                        'get_linear_acquisition_model')",
  "def adjoint(self, ad, out=None):\n        '''Back-projects acquisition data into image space, if the\n           AcquisitionModel is linear\n\n           calls backward with num_subset and on subset_num members\n           Added for CCPi CIL compatibility\n           https://github.com/CCPPETMR/SIRF/pull/237#issuecomment-439894266\n        '''\n        return self.backward(ad, subset_num=self.subset_num, \n                             num_subsets=self.num_subsets, out=out)",
  "def is_affine(self):\n        \"\"\"Returns True if the acquisition model is affine.\n        \"\"\"\n        return True",
  "def is_linear(self):\n        \"\"\"Return true if the acquisition model constant term is zero.\n\n        i.e. corresponding to\n        A*x, with zero background term.\n        \"\"\"\n        if self.bt is None and self.at is None:\n            return True\n        else:\n            if self.bt is None and self.at is not None:\n                return self.at.norm() == 0\n            elif self.bt is not None and self.at is None:\n                return self.bt.norm() == 0\n            else:\n                return self.bt.norm() == 0 and self.at.norm() == 0",
  "def range_geometry(self):\n        \"\"\"Return the template of AcquisitionData.\"\"\"\n        geom = AcquisitionData()\n        geom.handle = pystir.cSTIR_parameter(\n            self.handle, 'AcquisitionModel', 'range geometry')\n        check_status(geom.handle)\n        return geom",
  "def domain_geometry(self):\n        \"\"\"Return the template of ImageData.\"\"\"\n        geom = ImageData()\n        geom.handle = pystir.cSTIR_parameter(\n            self.handle, 'AcquisitionModel', 'domain geometry')\n        check_status(geom.handle)\n        return geom",
  "def subset_num(self):\n        '''Selected subset number\n \n        This value is used by direct and adjoint methods and are the \n        default values used by forward and back projection for their \n        parameter subset_num.\n        \n        Default value is 0.\n        '''\n        return self._subset_num",
  "def num_subsets(self):\n        '''Number of subsets to divide the AcquisitionData during projection\n\n        This value is used by the direct and adjoint methods. Additionally, \n        this value is the default value used by forward and back projection\n        for the parameter num_subsets.\n        \n        Default value is 1 and corresponds to forward/backward projecting\n        the whole dataset.\n\n        '''\n        return self._num_subsets",
  "def subset_num(self, value):\n        '''setter for subset_num\n        \n        value: int >= 0 and < num_subsets\n        '''\n        if isinstance (value, Integral):\n            if value < self.num_subsets and value >= 0:\n                self._subset_num = value\n            else:\n                raise ValueError(\"Expected a subset number below {} and larger or equal than 0. Got {}\"\\\n                    .format(self.subset_num, value))\n        else:\n            raise ValueError(\"Expected an integer. Got {}\".format(type(value)))",
  "def num_subsets(self, value):\n        '''setter for num_subsets\n\n        value: int > 0.\n        Allows to set the number of subsets the AcquisitionModel operates on. \n        Notice that reassigning the num_subsets to any valid number will also \n        set the property subset_num to 0.\n        '''\n        if isinstance (value, Integral):\n            if value > 0:\n                self._num_subsets = value\n                self.subset_num = 0\n                \n            else:\n                raise ValueError(\"Expected a subset number larger than 0. Got {}\"\\\n                    .format(value))\n        else:\n            raise ValueError(\"Expected an integer. Got {}\".format(type(value)))",
  "def __init__(self, matrix=None):\n        \"\"\"Creates an AcquisitionModelUsingMatrix object,\n\n        optionally setting the ray tracing matrix to be used for projecting.\n        matrix: an object to represent G in (F).\n        # TODO will need to try different matrices here\n        \"\"\"\n        super(AcquisitionModelUsingMatrix, self).__init__()\n        self.handle = None\n        self.name = 'AcqModUsingMatrix'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)\n        if matrix is None:\n            matrix = RayTracingMatrix()\n        self.set_matrix(matrix)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_matrix(self, matrix):\n        '''\n        Sets the matrix G to be used for projecting;\n        matrix:  a matrix object to represent G in acquisition model (F).\n        '''\n        # The following allows for different matrices\n        try:\n            parms.set_parameter(self.handle, self.name, 'matrix', matrix.handle)\n        except:\n            raise AssertionError('Unknown matrix type.')",
  "def __init__(self, matrix=None):\n        \"\"\"Create an AcquisitionModelUsingMatrix object,\n\n        optionally setting the ray tracing matrix to be used for projecting;\n        matrix: a RayTracingMatrix object to represent G in (F).\n        \"\"\"\n        if matrix is None:\n            matrix = RayTracingMatrix()\n        assert_validity(matrix, RayTracingMatrix)\n        super(AcquisitionModelUsingRayTracingMatrix, self).__init__(matrix)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_matrix(self, matrix):\n        \"\"\"Sets the ray tracing matrix to be used for projecting.\n\n        matrix: a RayTracingMatrix object to represent G in (F).\n        \"\"\"\n        assert_validity(matrix, RayTracingMatrix)\n        parms.set_parameter(self.handle, self.name, 'matrix', matrix.handle)",
  "def get_matrix(self):\n        \"\"\"Returns the ray tracing matrix used for projecting.\n\n        matrix: a RayTracingMatrix object representing G in (F).\n        \"\"\"\n        matrix = RayTracingMatrix()\n        matrix.handle = pystir.cSTIR_parameter(\n            self.handle, self.name, 'matrix')\n        check_status(matrix.handle)\n        return matrix",
  "def set_num_tangential_LORs(self, value):\n        \"\"\"See :func:`~sirf.STIR.RayTracingMatrix.set_num_tangential_LORs`.\"\"\"\n        return self.get_matrix().set_num_tangential_LORs(value)",
  "def get_num_tangential_LORs(self):\n        \"\"\"See :func:`~sirf.STIR.RayTracingMatrix.get_num_tangential_LORs`.\"\"\"\n        return self.get_matrix().get_num_tangential_LORs()",
  "class AcquisitionModelUsingNiftyPET(AcquisitionModel):\n        \"\"\"PET acquisition model that uses NiftyPET projector.\n\n        Class for a PET acquisition model that uses the NiftyPET projector\n        for G in AcquisitionModel (F).\n        \"\"\"\n\n        def __init__(self):\n            \"\"\"Create an AcquisitionModelUsingNiftyPET object.\"\"\"\n            super(AcquisitionModelUsingNiftyPET, self).__init__()\n            self.name = 'AcqModUsingNiftyPET'\n            self.handle = pystir.cSTIR_newObject(self.name)\n            check_status(self.handle)\n\n        def __del__(self):\n            \"\"\"del.\"\"\"\n            if self.handle is not None:\n                pyiutil.deleteDataHandle(self.handle)\n\n        def set_cuda_verbosity(self, verbosity):\n            \"\"\"Set the verbosity of the CUDA code.\"\"\"\n            if verbosity:\n                v = 1\n            else:\n                v = 0\n            parms.set_int_par(self.handle, self.name, 'cuda_verbosity', v)\n\n        def set_use_truncation(self, use_truncation):\n            \"\"\"Set use truncation.\n\n            Whether or not to truncate FOV before forward- and\n            after back-projection.\n            \"\"\"\n            if use_truncation:\n                v = 1\n            else:\n                v = 0\n            parms.set_int_par(self.handle, self.name, 'use_truncation', v)",
  "class AcquisitionModelUsingParallelproj(AcquisitionModel):\n        \"\"\"PET acquisition model that uses Parallelproj projector.\n\n        Class for a PET acquisition model that uses the Parallelproj projector\n        (see https://github.com/gschramm/parallelproj) for G in\n        AcquisitionModel (F).\n        \"\"\"\n\n        def __init__(self):\n            \"\"\"Create an AcquisitionModelUsingNiftyPET object.\"\"\"\n            super(AcquisitionModelUsingParallelproj, self).__init__()\n            self.name = 'AcqModUsingParallelproj'\n            self.handle = pystir.cSTIR_newObject(self.name)\n            check_status(self.handle)\n\n        def __del__(self):\n            \"\"\"del.\"\"\"\n            if self.handle is not None:\n                pyiutil.deleteDataHandle(self.handle)",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def __call__(self, image):\n        '''Returns the prior value on the specified image (alias of value()).\n\n        image: ImageData object'''\n        return self.value(image)",
  "def set_penalisation_factor(self, value):\n        \"\"\"Sets penalisation factor.\n\n        Sets the factor by which the penalty term (prior) is to be multiplied\n        before adding to the objective function.\n        \"\"\"\n        parms.set_float_par(\n            self.handle, 'GeneralisedPrior', 'penalisation_factor', value)\n        return self",
  "def get_penalisation_factor(self):\n        \"\"\"Returns the penalty factor in front of the prior.\"\"\"\n        return parms.float_par(\n            self.handle, 'GeneralisedPrior', 'penalisation_factor')",
  "def get_value(self, image):\n        \"\"\"Returns the value of the prior.\n\n        Returns the value of the prior for the specified image.\n        image: ImageData object\n        \"\"\"\n        assert_validity(image, ImageData)\n        handle = pystir.cSTIR_priorValue(self.handle, image.handle)\n        check_status(handle)\n        v = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return v",
  "def value(self, image):\n        \"\"\"Returns the value of the prior (alias of get_value()).\"\"\"\n        return self.get_value(image)",
  "def get_gradient(self, image):\n        \"\"\"Returns gradient of the prior.\n\n        Returns the value of the gradient of the prior for the specified image.\n        image: ImageData object\n        \"\"\"\n        assert_validity(image, ImageData)\n        grad = ImageData()\n        grad.handle = pystir.cSTIR_priorGradient(self.handle, image.handle)\n        check_status(grad.handle)\n        return grad",
  "def gradient(self, image):\n        \"\"\"Returns the gradient of the prior (alias of get_gradient()).\"\"\"\n\n        return self.get_gradient(image)",
  "def set_up(self, image):\n        \"\"\"Sets up.\"\"\"\n        try_calling(pystir.cSTIR_setupPrior(self.handle, image.handle))",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'QuadraticPrior'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_kappa(self, image):\n        \"\"\"Sets kappa.\"\"\"\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, 'QuadraticPrior', 'kappa', image.handle)",
  "def get_kappa(self):\n        \"\"\"Returns kappa.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(self.handle, 'QuadraticPrior', 'kappa')\n        check_status(image.handle)\n        return image",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'LogcoshPrior'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_scalar(self, v):\n        \"\"\"Sets scalar.\"\"\"\n        parms.set_float_par(self.handle, 'LogcoshPrior', 'scalar', v)",
  "def get_scalar(self):\n        \"\"\"Returns scalar.\"\"\"\n        return parms.float_par(self.handle, 'LogcoshPrior', 'scalar')",
  "def set_kappa(self, image):\n        \"\"\"Sets kappa.\"\"\"\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, 'LogcoshPrior', 'kappa', image.handle)",
  "def get_kappa(self):\n        \"\"\"Returns kappa.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(self.handle, 'LogcoshPrior', 'kappa')\n        check_status(image.handle)\n        return image",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'RelativeDifferencePrior'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_gamma(self, v):\n        \"\"\"Sets gamma.\"\"\"\n        parms.set_float_par(self.handle, 'RelativeDifferencePrior', 'gamma', v)",
  "def get_gamma(self):\n        \"\"\"Returns gamma.\"\"\"\n        return parms.float_par(self.handle, 'RelativeDifferencePrior', 'gamma')",
  "def set_epsilon(self, v):\n        \"\"\"Sets epsilon.\"\"\"\n        parms.set_float_par(self.handle, 'RelativeDifferencePrior', 'epsilon', v)",
  "def get_epsilon(self):\n        \"\"\"Returns epsilon.\"\"\"\n        return parms.float_par(self.handle, 'RelativeDifferencePrior', 'epsilon')",
  "def set_kappa(self, image):\n        \"\"\"Sets kappa.\"\"\"\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, 'RelativeDifferencePrior', 'kappa', image.handle)",
  "def get_kappa(self):\n        \"\"\"Returns kappa.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(self.handle, 'RelativeDifferencePrior', 'kappa')\n        check_status(image.handle)\n        return image",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'PLSPrior'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_only_2D(self, tf):\n        \"\"\"Sets only_2D parameter.\"\"\"\n        v = 1 if tf else 0\n        parms.set_int_par(self.handle, 'PLSPrior', 'only_2D', v)",
  "def get_only_2D(self):\n        \"\"\"Returns only_2D value.\"\"\"\n        v = parms.int_par(self.handle, 'PLSPrior', 'only_2D')\n        return v != 0",
  "def set_alpha(self, v):\n        \"\"\"Sets alpha.\"\"\"\n        parms.set_float_par(self.handle, 'PLSPrior', 'alpha', v)",
  "def get_alpha(self):\n        \"\"\"Returns alpha.\"\"\"\n        return parms.float_par(self.handle, 'PLSPrior', 'alpha')",
  "def set_eta(self, v):\n        \"\"\"Sets eta.\"\"\"\n        parms.set_float_par(self.handle, 'PLSPrior', 'eta', v)",
  "def get_eta(self):\n        \"\"\"Returns eta.\"\"\"\n        return parms.float_par(self.handle, 'PLSPrior', 'eta')",
  "def set_anatomical_image(self, image):\n        \"\"\"Sets anatomical image.\"\"\"\n        assert_validity(image, ImageData)\n        parms.set_parameter(\n            self.handle, 'PLSPrior', 'anatomical_image', image.handle)",
  "def get_anatomical_image(self):\n        \"\"\"Returns anatomical image.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(\n            self.handle, 'PLSPrior', 'anatomical_image')\n        check_status(image.handle)\n        return image",
  "def get_anatomical_grad(self, direction):\n        \"\"\"Returns anatomical gradient.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_PLSPriorGradient(self.handle, direction)\n        check_status(image.handle)\n        return image",
  "def set_anatomical_filename(self, filename):\n        \"\"\"Sets anatomical filename.\"\"\"\n        parms.set_char_par(\n            self.handle, 'PLSPrior', 'anatomical_filename', filename)",
  "def set_kappa(self, image):\n        \"\"\"Sets kappa.\"\"\"\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, 'PLSPrior', 'kappa', image.handle)",
  "def get_kappa(self):\n        \"\"\"Returns kappa.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(self.handle, 'PLSPrior', 'kappa')\n        check_status(image.handle)\n        return image",
  "def set_kappa_filename(self, filename):\n        \"\"\"Sets kappa filename.\"\"\"\n        parms.set_char_par(self.handle, 'PLSPrior', 'kappa_filename', filename)",
  "def get_norm(self):\n        \"\"\"Returns norm.\"\"\"\n        image = ImageData()\n        image.handle = pystir.cSTIR_parameter(self.handle, 'PLSPrior', 'norm')\n        check_status(image.handle)\n        return image",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_prior(self, prior):\n        \"\"\"Sets the prior,\n\n        a penalty term to be added to the objective function.\"\"\"\n        assert_validity(prior, Prior)\n        parms.set_parameter(self.handle, 'GeneralisedObjectiveFunction',\n                            'prior', prior.handle)\n        self.prior = prior",
  "def get_prior(self):\n        \"\"\"Returns the prior currently used by this objective function.\"\"\"\n        prior = Prior()\n        prior.handle = pystir.cSTIR_parameter(\n            self.handle, 'GeneralisedObjectiveFunction', 'prior')\n        check_status(prior.handle)\n        return prior",
  "def set_num_subsets(self, n):\n        \"\"\"Sets the number of subsets.\n\n        Sets the number of subsets of ray projections to be used for computing\n        additive components of the gradient used by Ordered Subset algorithms\n        for maximizing this objective function.\n        If the ray tracing projector G is a matrix, the subsets in question are\n        subsets of its rows.\n        n: number of subsets, Python integer scalar\n        \"\"\"\n        parms.set_int_par(\n            self.handle, 'GeneralisedObjectiveFunction', 'num_subsets', n)",
  "def get_num_subsets(self):\n        \"\"\"Returns the number of subsets.\"\"\"\n        return parms.int_par(\n            self.handle, 'GeneralisedObjectiveFunction', 'num_subsets')",
  "def set_up(self, image):\n        \"\"\"Prepares this object for use.\n\n        image: ImageData object\n        \"\"\"\n        assert_validity(image, ImageData)\n        try_calling(pystir.cSTIR_setupObjectiveFunction(\n            self.handle, image.handle))",
  "def value(self, image):\n        \"\"\"Returns the value of this objective function on the specified image.\n\n        image: ImageData object\n        \"\"\"\n        assert_validity(image, ImageData)\n        handle = pystir.cSTIR_objectiveFunctionValue(self.handle, image.handle)\n        check_status(handle)\n        v = pyiutil.floatDataFromHandle(handle)\n        pyiutil.deleteDataHandle(handle)\n        return v",
  "def __call__(self, image):\n        '''Alias of value: Returns the value of this objective function on the specified image.\n\n        image: ImageData object'''\n        return self.value(image)",
  "def get_value(self, image):\n        \"\"\"Returns the value of this objective function on the specified image.\n\n        image: ImageData object\n        \"\"\"\n        return self.value(image)",
  "def gradient(self, image, subset=-1):\n        \"\"\"Returns the value of the additive component of the gradient\n\n        of this objective function on the specified image corresponding to the\n        specified subset (see set_num_subsets() method).\n        If no subset is specified, returns the full gradient, i.e. the sum of\n        the subset components.\n        image: ImageData object\n        subset: Python integer scalar\n        \"\"\"\n        assert_validity(image, ImageData)\n        grad = ImageData()\n        grad.handle = pystir.cSTIR_objectiveFunctionGradient(\n            self.handle, image.handle, subset)\n        check_status(grad.handle)\n        return grad",
  "def get_gradient(self, image):\n        \"\"\"Returns the gradient of the objective function on specified image.\n\n        image: ImageData object\n        \"\"\"\n        return self.gradient(image)",
  "def get_subset_gradient(self, image, subset):\n        \"\"\"Returns the value of the additive component of the gradient\n\n        of this objective function on <image> corresponding to the specified\n        subset (see set_num_subsets() method).\n        image: ImageData object\n        subset: Python integer scalar\n        \"\"\"\n        return self.gradient(image, subset)",
  "def get_subset_sensitivity(self, subset):\n        #print('in base class ObjectiveFunction')\n        pass",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_recompute_sensitivity(self, flag):\n        \"\"\"Sets recompute sensitivity flag.\"\"\"\n        parms.set_char_par(\n            self.handle, 'PoissonLogLikelihoodWithLinearModelForMean',\n            'recompute_sensitivity', repr(flag))",
  "def get_subset_sensitivity(self, subset):\n        \"\"\"Returns subset sensitivity.\n\n        Returns an ImageData object containing sensitivity image for the\n        specified subset.\n        \"\"\"\n        ss = ImageData()\n        ss.handle = pystir.cSTIR_subsetSensitivity(self.handle, subset)\n        check_status(ss.handle)\n        return ss",
  "def get_backprojection_of_acquisition_ratio(self, image, subset):\n        \"\"\"Returns backprojection of measured to estimated acquisition ratio.\n\n        Returns the back-projection of the ratio of the measured and estimated\n        acquisition data.\n        \"\"\"\n        assert_validity(image, ImageData)\n        grad = ImageData()\n        grad.handle = pystir.cSTIR_objectiveFunctionGradientNotDivided(\n            self.handle, image.handle, subset)\n        check_status(grad.handle)\n        return grad",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.name = 'PoissonLogLikelihoodWithLinearModelForMeanAndProjData'\n        self.handle = pystir.cSTIR_newObject(self.name)\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_input_filename(self, name):\n        \"\"\"Sets the name of the file containing acquisition data.\"\"\"\n        parms.set_char_par(\n            self.handle, self.name, 'input_filename', name)",
  "def set_acquisition_model(self, am):\n        \"\"\"Sets the acquisition model to be used by this objective function.\"\"\"\n        assert_validity(am, AcquisitionModel)\n        parms.set_parameter(\n            self.handle, self.name, 'acquisition_model', am.handle)",
  "def set_acquisition_data(self, ad):\n        \"\"\"Sets the acquisition data to be used by this objective function.\"\"\"\n        assert_validity(ad, AcquisitionData)\n        parms.set_parameter(\n            self.handle, self.name, 'acquisition_data', ad.handle)",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.input = None\n        self.image = None",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_input(self, input_data):\n        \"\"\"Sets the acquisition data to use for reconstruction.\"\"\"\n        assert_validity(input_data, AcquisitionData)\n        parms.set_parameter(\n            self.handle, 'Reconstruction',\n            'input_data', input_data.handle)",
  "def set_output_filename_prefix(self, prefix):\n        \"\"\"Sets the output file name prefix.\"\"\"\n        parms.set_char_par(\n            self.handle, 'Reconstruction', 'output_filename_prefix', prefix)",
  "def disable_output(self):\n        \"\"\"Disables output.\"\"\"\n        parms.set_int_par(self.handle, 'Reconstruction', 'disable_output', 1)",
  "def enable_output(self):\n        \"\"\"Enables output.\"\"\"\n        parms.set_int_par(self.handle, 'Reconstruction', 'enable_output', 1)",
  "def reconstruct(self, image):\n        \"\"\"Performs reconstruction (will update the image argument)\"\"\"\n        assert_validity(image, ImageData)\n        try_calling(pystir.cSTIR_runReconstruction(self.handle, image.handle))\n        self.image = image",
  "def get_output(self):\n        \"\"\"Returns the reconstructed image.\"\"\"\n        assert self.image is not None, 'current estimate not set. Did you run a reconstruction already?'\n        # TODO: move to C++\n        return self.image.clone()",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.handle = pystir.cSTIR_newObject('FBP2D')\n        check_status(self.handle)",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_input(self, input_data):\n        \"\"\"Sets the acquisition data to use for reconstruction.\"\"\"\n        assert_validity(input_data, AcquisitionData)\n        parms.set_parameter(self.handle, 'FBP2D', 'input', input_data.handle)",
  "def set_zoom(self, v):\n        \"\"\"Sets zoom.\"\"\"\n        parms.set_float_par(self.handle, 'FBP2D', 'zoom', v)",
  "def set_alpha_cosine_window(self, v):\n        \"\"\"Sets alpha in the apodizing filter.\n\n        See the class documentation for the filter. The value of alpha should\n        be between 0.5 and 1. alpha=0.5 corresponds to the Hann filter, while\n        0.54 corresponds to the Hamming filter.\n        \"\"\"\n        parms.set_float_par(self.handle, 'FBP2D', 'alpha', v)",
  "def set_frequency_cut_off(self, v):\n        \"\"\"Sets the cut-off frequency for the apodizing filter.\n\n        See the class documentation for the filter. The value of fc should be\n        between 0 and 0.5.\n        \"\"\"\n        parms.set_float_par(self.handle, 'FBP2D', 'fc', v)",
  "def set_output_image_size_xy(self, xy):\n        \"\"\"Sets output image size (xy).\"\"\"\n        parms.set_int_par(self.handle, 'FBP2D', 'xy', xy)",
  "def set_up(self, image):\n        \"\"\"Sets up the reconstructor.\"\"\"\n        try_calling(pystir.cSTIR_setupFBP2DReconstruction(\n            self.handle, image.handle))",
  "def process(self):\n        \"\"\"Performs reconstruction.\"\"\"\n        try_calling(pystir.cSTIR_runFBP2DReconstruction(self.handle))",
  "def get_output(self):\n        \"\"\"Returns the reconstructed image.\"\"\"\n        image = ImageData()\n        image.handle = parms.parameter_handle(self.handle, 'FBP2D', 'output')\n        check_status(image.handle)\n        return image",
  "def __init__(self):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.image = None\n        self.subset = 0",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_num_subsets(self, n):\n        \"\"\"See method in ObjectiveFunction.\"\"\"\n        parms.set_int_par(\n            self.handle, 'IterativeReconstruction', 'num_subsets', n)",
  "def get_num_subsets(self):\n        \"\"\"Returns number of subsets.\"\"\"\n        return parms.int_par(\n            self.handle, 'IterativeReconstruction', 'num_subsets')",
  "def set_num_subiterations(self, n):\n        \"\"\"Sets number of subiterations.\n\n        In subset iterative methods, each iteration works with a subset,\n        and is therefore referred to as a subiteration.\n        \"\"\"\n        parms.set_int_par(\n            self.handle, 'IterativeReconstruction', 'num_subiterations', n)",
  "def get_num_subiterations(self):\n        \"\"\"Returns the number of subiterations.\"\"\"\n        return parms.int_par(\n            self.handle, 'IterativeReconstruction', 'num_subiterations')",
  "def get_subiteration_num(self):\n        \"\"\"Returns the current subiteration number.\"\"\"\n        return parms.int_par(\n            self.handle, 'IterativeReconstruction', 'subiteration_num')",
  "def set_save_interval(self, n):\n        \"\"\"Sets save interval.\n\n        Defines how often to save image iterates (n = 1: on each\n        subiteration, n = 2: every other subiteration etc.)\n        \"\"\"\n        if n > 0:\n            self.enable_output()\n        else:\n            self.disable_output()\n        parms.set_int_par(\n            self.handle, 'IterativeReconstruction', 'save_interval', n)",
  "def set_objective_function(self, obj):\n        \"\"\"Specifies the objective function to be maximized.\"\"\"\n        assert_validity(obj, ObjectiveFunction)\n        parms.set_parameter(self.handle, 'IterativeReconstruction',\n            'objective_function', obj.handle)",
  "def get_objective_function(self):\n        pass",
  "def set_up(self, image):\n        \"\"\"Sets up the reconstructor.\"\"\"\n        assert_validity(image, ImageData)\n        try_calling(pystir.cSTIR_setupReconstruction(\n            self.handle, image.handle))",
  "def set_current_estimate(self, image):\n        \"\"\"Sets image estimate for further iterations.\n\n        image will be cloned.\n        \"\"\"\n        assert_validity(image, ImageData)\n        self.image = image.clone()",
  "def process(self):\n        \"\"\"Performs reconstruction.\"\"\"\n        assert self.image is not None, 'current estimate not set.'\n        try_calling(pystir.cSTIR_runReconstruction(\n            self.handle, self.image.handle))",
  "def get_current_estimate(self):\n        \"\"\"Return current image estimate.\"\"\"\n        assert self.image is not None, 'current estimate not set.'\n        return self.image.clone()",
  "def update_current_estimate(self):\n        \"\"\"Updates current image estimate by performing one subiteration.\"\"\"\n        if self.image is None:\n            raise error('current estimate not set')\n        assert_validity(self.image, ImageData)\n        try_calling(pystir.cSTIR_updateReconstruction(\n            self.handle, self.image.handle))",
  "def set_current_subset_num(self, subset):\n        \"\"\"Sets the subset to be used on the next subiteration.\"\"\"\n        self.subset = subset",
  "def get_subset_sensitivity(self):\n        \"\"\"Returns the current subset sensitivity.\n\n        Returns an ImageData object containing sensitivity image for the\n        current subset.\n        \"\"\"\n        obj_fun = self.get_objective_function()\n        return obj_fun.get_subset_sensitivity(self.subset)",
  "def update(self, image):\n        \"\"\"Updates the image estimate.\n\n        Applies one subiteration to the image estimate passed as the\n        argument.\n        \"\"\"\n        assert_validity(image, ImageData)\n        #self.set_estimate(image)\n        self.image = image;\n        self.update_current_estimate()\n        return image",
  "def __init__(self, filename=''):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.image = None\n        self.name = 'OSMAPOSL'\n        self.handle = pystir.cSTIR_objectFromFile(\n            'OSMAPOSLReconstruction', filename)\n        check_status(self.handle)\n        self.disable_output()",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_maximum_relative_change(self, value):\n        \"\"\"Sets maximum relative change.\"\"\"\n        parms.set_float_par(\n            self.handle, self.name, 'set_maximum_relative_change', value)",
  "def set_minimum_relative_change(self, value):\n        \"\"\"Sets minimum relative change.\"\"\"\n        parms.set_float_par(\n            self.handle, self.name, 'set_minimum_relative_change', value)",
  "def get_objective_function(self):\n        obj_fun = PoissonLogLikelihoodWithLinearModelForMean()\n        obj_fun.handle = pystir.cSTIR_parameter\\\n            (self.handle, self.name, 'objective_function')\n        check_status(obj_fun.handle)\n        return obj_fun",
  "def __init__(self, filename=''):\n        \"\"\"init.\"\"\"\n        IterativeReconstructor.__init__(self)\n        self.handle = None\n        self.image = None\n        self.name = 'KOSMAPOSL'\n        self.handle = pystir.cSTIR_objectFromFile(\n            'KOSMAPOSLReconstruction', filename)\n        check_status(self.handle)\n        self.disable_output()",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_anatomical_prior(self, ap):\n        \"\"\"Sets anatomical prior.\"\"\"\n        assert_validity(ap, ImageData)\n        parms.set_parameter(\n            self.handle, 'KOSMAPOSL', 'anatomical_prior', ap.handle)",
  "def set_num_neighbours(self, n):\n        \"\"\"Sets number of neighbours.\"\"\"\n        parms.set_int_par(\n            self.handle, 'KOSMAPOSL', 'num_neighbours', n)",
  "def set_num_non_zero_features(self, n):\n        \"\"\"Sets number of non-zero features.\"\"\"\n        parms.set_int_par(\n            self.handle, 'KOSMAPOSL', 'num_non_zero_features', n)",
  "def set_sigma_m(self, v):\n        \"\"\"Sets sigma m.\"\"\"\n        parms.set_float_par(self.handle, 'KOSMAPOSL', 'sigma_m', v)",
  "def set_sigma_p(self, v):\n        \"\"\"Sets sigma p.\"\"\"\n        parms.set_float_par(self.handle, 'KOSMAPOSL', 'sigma_p', v)",
  "def set_sigma_dm(self, v):\n        \"\"\"Sets sigma dm.\"\"\"\n        parms.set_float_par(self.handle, 'KOSMAPOSL', 'sigma_dm', v)",
  "def set_sigma_dp(self, v):\n        \"\"\"Sets sigma dp.\"\"\"\n        parms.set_float_par(self.handle, 'KOSMAPOSL', 'sigma_dp', v)",
  "def set_only_2D(self, tf):\n        \"\"\"Sets only_2D flag.\"\"\"\n        v = 1 if tf else 0\n        parms.set_int_par(self.handle, 'KOSMAPOSL', 'only_2D', v)",
  "def set_hybrid(self, tf):\n        \"\"\"Sets use hybrid mode flag.\"\"\"\n        v = 1 if tf else 0\n        parms.set_int_par(self.handle, 'KOSMAPOSL', 'hybrid', v)",
  "def compute_kernelised_image(self, image, alpha):\n        assert_validity(image, ImageData)\n        assert_validity(alpha, ImageData)\n        ki = ImageData()\n        ki.handle = pystir.cSTIR_computeKernelisedImage \\\n            (self.handle, image.handle, alpha.handle)\n        check_status(ki.handle)\n        return ki",
  "def get_objective_function(self):\n        obj_fun = PoissonLogLikelihoodWithLinearModelForMean()\n        obj_fun.handle = pystir.cSTIR_parameter\\\n            (self.handle, self.name, 'objective_function')\n        check_status(obj_fun.handle)\n        return obj_fun",
  "def __init__(self, filename = ''):\n        self.handle = None\n        self.image = None\n        self.name = 'PETSingleScatterSimulator'\n        self.filename = filename\n\n        if not self.filename:\n            self.handle = pystir.cSTIR_newObject(self.name)\n        else:\n            self.handle = pystir.cSTIR_objectFromFile(self.name, self.filename)\n        check_status(self.handle)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_up(self, acq_templ, img_templ):\n        \"\"\"Set up.\n\n        Prepare this object for performing forward operations;\n        acq_templ:  an AcquisitionData object used as a template for\n                    creating an AcquisitionData object to store forward\n                    projection;\n        img_templ:  an ImageData object used as a template for checking geometry etc\n\n        attenuation image has to be set first\n        \"\"\"\n        assert_validity(acq_templ, AcquisitionData)\n        assert_validity(img_templ, ImageData)\n\n        # temporarily save the templates in the class\n        self.acq_templ = acq_templ\n        #self.img_templ = img_templ\n\n        try_calling(pystir.cSTIR_setupScatterSimulator(\n            self.handle, acq_templ.handle, img_templ.handle))",
  "def forward(self, image,  out=None):\n        \"\"\"Return the scatter estimation for the input activity image.\n\n        image   :  an ImageData object.\n\n        set_up() has to be called first.\n        \"\"\"\n        assert_validity(image, ImageData)\n        if out is None:\n            ad = AcquisitionData()\n            ad.handle = pystir.cSTIR_scatterSimulatorFwd(\n                self.handle, image.handle);\n            check_status(ad.handle)\n            return ad\n        ad = out\n        assert_validity(ad, AcquisitionData)\n        try_calling(pystir.cSTIR_scatterSimulatorFwdReplace(\n            self.handle, image.handle, ad.handle))",
  "def set_attenuation_image(self, image):\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, self.name, 'setAttenuationImage', image.handle)",
  "def __init__(self, filename = ''):\n        self.handle = None\n        self.image = None\n        self.name = 'PETScatterEstimator'\n        self.filename = filename\n\n        if not self.filename:\n            self.handle = pystir.cSTIR_newObject(self.name)\n        else:\n            self.handle = pystir.cSTIR_objectFromFile(self.name, self.filename)\n\n        check_status(self.handle)",
  "def __del__(self):\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_up(self):\n        \"\"\"\n        Set up.\n\n        Prepare this object for performing scatter estimation;\n        All input has to be set before calling this function.\n        \"\"\"\n        try_calling(pystir.cSTIR_setupScatterEstimator(\n            self.handle))",
  "def process(self):\n        \"\"\"\n        Runs the scatter estimation.\n\n        You need to run set_up() first.\n        \"\"\"\n        print('ScatterEstimator:: Waiting for the scatter estimation to finish ...')\n        self.output = AcquisitionData()\n        self.output.handle = pystir.cSTIR_runScatterEstimator(self.handle)\n        check_status(self.output.handle)\n        print('ScatterEstimator:: estimation finished.')",
  "def get_output(self):\n        \"\"\"\n        Return the final scatter estimate.\n        \"\"\"\n        data = AcquisitionData()\n        data.handle = parms.parameter_handle(self.handle, 'PETScatterEstimator', 'output')\n        check_status(data.handle)\n        return data",
  "def get_num_iterations(self):\n        \"\"\"Get number of iterations of the SSS algorithm to use.\"\"\"\n        return parms.int_par(self.handle, 'PETScatterEstimator', 'num_iterations')",
  "def set_attenuation_image(self, image):\n        assert_validity(image, ImageData)\n        parms.set_parameter(self.handle, self.name, 'setAttenuationImage', image.handle)",
  "def set_attenuation_correction_factors(self, arg):\n        assert_validity(arg, AcquisitionData)\n        parms.set_parameter(self.handle, self.name, 'setAttenuationCorrectionFactors', arg.handle)",
  "def set_input(self, acq_data):\n        assert_validity(acq_data, AcquisitionData)\n        parms.set_parameter(self.handle, self.name, 'setInput', acq_data.handle)",
  "def set_randoms(self, acq_data):\n        assert_validity(acq_data, AcquisitionData)\n        parms.set_parameter(self.handle, self.name, 'setRandoms', acq_data.handle)",
  "def set_asm(self, asm):\n        '''Set acquisition sensitivity model (without attenuation!)'''\n        assert_validity(asm, AcquisitionSensitivityModel)\n        parms.set_parameter(self.handle, self.name, 'setASM', asm.handle)",
  "def set_num_iterations(self, v):\n        \"\"\"Set number of iterations of the SSS algorithm to use.\"\"\"\n        parms.set_int_par(self.handle, 'PETScatterEstimator', 'set_num_iterations', v)",
  "def set_output_prefix(self, v):\n        \"\"\"\n        Set prefix for filenames with scatter estimates.\n\n        Actual filenames will append the iteration number and the .hs extension\n        as common for STIR Interfile data.\n\n        Set it to the empty string to prevent any output.\n        \"\"\"\n        parms.set_char_par(self.handle, 'PETScatterEstimator', 'set_output_prefix', v)",
  "def __init__(self, filename=''):\n        \"\"\"init.\"\"\"\n        self.handle = None\n        self.image = None\n        self.name = 'OSSPS'\n        self.handle = pystir.cSTIR_objectFromFile(\n            'OSSPSReconstruction', filename)\n        check_status(self.handle)\n        self.disable_output()",
  "def __del__(self):\n        \"\"\"del.\"\"\"\n        if self.handle is not None:\n            pyiutil.deleteDataHandle(self.handle)",
  "def set_relaxation_parameter(self, value):\n        \"\"\"Sets relaxation parameter.\"\"\"\n        parms.set_float_par(\n            self.handle, self.name, 'relaxation_parameter', value)",
  "def __init__(self):\n            \"\"\"Create an AcquisitionModelUsingNiftyPET object.\"\"\"\n            super(AcquisitionModelUsingNiftyPET, self).__init__()\n            self.name = 'AcqModUsingNiftyPET'\n            self.handle = pystir.cSTIR_newObject(self.name)\n            check_status(self.handle)",
  "def __del__(self):\n            \"\"\"del.\"\"\"\n            if self.handle is not None:\n                pyiutil.deleteDataHandle(self.handle)",
  "def set_cuda_verbosity(self, verbosity):\n            \"\"\"Set the verbosity of the CUDA code.\"\"\"\n            if verbosity:\n                v = 1\n            else:\n                v = 0\n            parms.set_int_par(self.handle, self.name, 'cuda_verbosity', v)",
  "def set_use_truncation(self, use_truncation):\n            \"\"\"Set use truncation.\n\n            Whether or not to truncate FOV before forward- and\n            after back-projection.\n            \"\"\"\n            if use_truncation:\n                v = 1\n            else:\n                v = 0\n            parms.set_int_par(self.handle, self.name, 'use_truncation', v)",
  "def __init__(self):\n            \"\"\"Create an AcquisitionModelUsingNiftyPET object.\"\"\"\n            super(AcquisitionModelUsingParallelproj, self).__init__()\n            self.name = 'AcqModUsingParallelproj'\n            self.handle = pystir.cSTIR_newObject(self.name)\n            check_status(self.handle)",
  "def __del__(self):\n            \"\"\"del.\"\"\"\n            if self.handle is not None:\n                pyiutil.deleteDataHandle(self.handle)"
]