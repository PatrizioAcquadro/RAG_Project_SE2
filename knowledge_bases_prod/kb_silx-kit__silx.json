[
  "class TestResult(unittest.TestResult):\n    logger = logging.getLogger(\"memProf\")\n    logger.setLevel(logging.DEBUG)\n    logger.handlers.append(logging.FileHandler(\"profile.log\"))\n\n    def startTest(self, test):\n        if resource:\n            self.__mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss\n        self.__time_start = time.time()\n        unittest.TestResult.startTest(self, test)\n\n    def stopTest(self, test):\n        unittest.TestResult.stopTest(self, test)\n        if resource:\n            memusage = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - self.__mem_start) * 0.001\n        else:\n            memusage = 0\n        self.logger.info(\"Time: %.3fs \\t RAM: %.3f Mb\\t%s\" % (\n            time.time() - self.__time_start,\n            (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss -\n                self.__mem_start) / 1e3,\n            test.id()))",
  "class ProfileTestRunner(unittest.TextTestRunner):\n    def _makeResult(self):\n        return TestResult(stream=sys.stderr, descriptions=True, verbosity=1)",
  "def report_rst(cov, package, version=\"0.0.0\"):\n    \"\"\"\n    Generate a report of test coverage in RST (for Sphinx inclusion)\n\n    :param cov: test coverage instance\n    :param str package: Name of the package\n    :return: RST string\n    \"\"\"\n    import tempfile\n    fd, fn = tempfile.mkstemp(suffix=\".xml\")\n    os.close(fd)\n    cov.xml_report(outfile=fn)\n\n    from lxml import etree\n    xml = etree.parse(fn)\n    classes = xml.xpath(\"//class\")\n\n    line0 = \"Test coverage report for %s\" % package\n    res = [line0, \"=\" * len(line0), \"\"]\n    res.append(\"Measured on *%s* version %s, %s\" %\n               (package, version, time.strftime(\"%d/%m/%Y\")))\n    res += [\"\",\n            \".. csv-table:: Test suite coverage\",\n            '   :header: \"Name\", \"Stmts\", \"Exec\", \"Cover\"',\n            '   :widths: 35, 8, 8, 8',\n            '']\n    tot_sum_lines = 0\n    tot_sum_hits = 0\n\n    for cl in classes:\n        name = cl.get(\"name\")\n        # fname = cl.get(\"filename\")\n        lines = cl.find(\"lines\").getchildren()\n        hits = [int(i.get(\"hits\")) for i in lines]\n\n        sum_hits = sum(hits)\n        sum_lines = len(lines)\n\n        cover = 100.0 * sum_hits / sum_lines if sum_lines else 0\n\n        res.append('   \"%s\", \"%s\", \"%s\", \"%.1f %%\"' %\n                   (name, sum_lines, sum_hits, cover))\n        tot_sum_lines += sum_lines\n        tot_sum_hits += sum_hits\n    res.append(\"\")\n    res.append('   \"%s total\", \"%s\", \"%s\", \"%.1f %%\"' %\n               (package, tot_sum_lines, tot_sum_hits,\n                100.0 * tot_sum_hits / tot_sum_lines if tot_sum_lines else 0))\n    res.append(\"\")\n    return os.linesep.join(res)",
  "def get_project_name(root_dir):\n    \"\"\"Retrieve project name by running python setup.py --name in root_dir.\n\n    :param str root_dir: Directory where to run the command.\n    :return: The name of the project stored in root_dir\n    \"\"\"\n    logger.debug(\"Getting project name in %s\" % root_dir)\n    p = subprocess.Popen([sys.executable, \"setup.py\", \"--name\"],\n                         shell=False, cwd=root_dir, stdout=subprocess.PIPE)\n    name, stderr_data = p.communicate()\n    logger.debug(\"subprocess ended with rc= %s\" % p.returncode)\n    return name.split()[-1].decode('ascii')",
  "def build_project(name, root_dir):\n    \"\"\"Run python setup.py build for the project.\n\n    Build directory can be modified by environment variables.\n\n    :param str name: Name of the project.\n    :param str root_dir: Root directory of the project\n    :return: The path to the directory were build was performed\n    \"\"\"\n    platform = distutils.util.get_platform()\n    architecture = \"lib.%s-%i.%i\" % (platform,\n                                     sys.version_info[0], sys.version_info[1])\n\n    if os.environ.get(\"PYBUILD_NAME\") == name:\n        # we are in the debian packaging way\n        home = os.environ.get(\"PYTHONPATH\", \"\").split(os.pathsep)[-1]\n    elif os.environ.get(\"BUILDPYTHONPATH\"):\n        home = os.path.abspath(os.environ.get(\"BUILDPYTHONPATH\", \"\"))\n    else:\n        home = os.path.join(root_dir, \"build\", architecture)\n\n    logger.warning(\"Building %s to %s\" % (name, home))\n    p = subprocess.Popen([sys.executable, \"setup.py\", \"build\"],\n                         shell=False, cwd=root_dir)\n    logger.debug(\"subprocess ended with rc= %s\" % p.wait())\n    return home",
  "def startTest(self, test):\n        if resource:\n            self.__mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss\n        self.__time_start = time.time()\n        unittest.TestResult.startTest(self, test)",
  "def stopTest(self, test):\n        unittest.TestResult.stopTest(self, test)\n        if resource:\n            memusage = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - self.__mem_start) * 0.001\n        else:\n            memusage = 0\n        self.logger.info(\"Time: %.3fs \\t RAM: %.3f Mb\\t%s\" % (\n            time.time() - self.__time_start,\n            (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss -\n                self.__mem_start) / 1e3,\n            test.id()))",
  "def _makeResult(self):\n        return TestResult(stream=sys.stderr, descriptions=True, verbosity=1)",
  "def get_version():\n    import version\n    return version.strictversion",
  "def get_readme():\n    dirname = os.path.dirname(os.path.abspath(__file__))\n    with open(os.path.join(dirname, \"README.rst\"), \"r\") as fp:\n        long_description = fp.read()\n    return long_description",
  "class build_py(_build_py):\n    \"\"\"\n    Enhanced build_py which copies version.py to <PROJECT>._version.py\n    \"\"\"\n    def find_package_modules(self, package, package_dir):\n        modules = _build_py.find_package_modules(self, package, package_dir)\n        if package == PROJECT:\n            modules.append((PROJECT, '_version', 'version.py'))\n        return modules",
  "class PyTest(Command):\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        import subprocess\n        errno = subprocess.call([sys.executable, 'run_tests.py', '-i'])\n        if errno != 0:\n            raise SystemExit(errno)",
  "def check_openmp():\n    \"\"\"Do we compile with OpenMP?\n\n    Store the result in WITH_OPENMP environment variable\n\n    :return: True if available and not disabled.\n    \"\"\"\n    if \"WITH_OPENMP\" in os.environ:\n        return os.environ[\"WITH_OPENMP\"] == \"False\"\n\n    elif \"--no-openmp\" in sys.argv:\n        sys.argv.remove(\"--no-openmp\")\n        os.environ[\"WITH_OPENMP\"] = \"False\"\n        print(\"No OpenMP requested by command line\")\n        return False\n\n    elif (\"--openmp\" in sys.argv):\n        sys.argv.remove(\"--openmp\")\n        os.environ[\"WITH_OPENMP\"] = \"True\"\n        print(\"OpenMP requested by command line\")\n        return True\n\n    if platform.system() == \"Darwin\":\n        # By default Xcode5 & XCode6 do not support OpenMP, Xcode4 is OK.\n        osx = tuple([int(i) for i in platform.mac_ver()[0].split(\".\")])\n        if osx >= (10, 8):\n            os.environ[\"WITH_OPENMP\"] = \"False\"\n            return False\n\n    os.environ[\"WITH_OPENMP\"] = \"True\"\n    return True",
  "def check_cython():\n    \"\"\"\n    Check if cython must be activated fron te command line or the environment.\n\n    Store the result in WITH_CYTHON environment variable.\n\n    :return: True if available and not disabled.\n    \"\"\"\n\n    if \"WITH_CYTHON\" in os.environ:\n        if os.environ[\"WITH_CYTHON\"] in [\"False\", \"0\", 0]:\n            os.environ[\"WITH_CYTHON\"] = \"False\"\n            return False\n\n    if \"--no-cython\" in sys.argv:\n        sys.argv.remove(\"--no-cython\")\n        print(\"No Cython requested by command line\")\n        os.environ[\"WITH_CYTHON\"] = \"False\"\n        return False\n\n    try:\n        import Cython.Compiler.Version\n    except ImportError:\n        os.environ[\"WITH_CYTHON\"] = \"False\"\n        return False\n    else:\n        if Cython.Compiler.Version.version < CYTHON_MIN_VERSION:\n            os.environ[\"WITH_CYTHON\"] = \"False\"\n            return False\n\n    os.environ[\"WITH_CYTHON\"] = \"True\"\n\n    if \"--force-cython\" in sys.argv:\n        sys.argv.remove(\"--force-cython\")\n        print(\"Force Cython re-generation requested by command line\")\n        os.environ[\"FORCE_CYTHON\"] = \"True\"\n    return True",
  "def configuration(parent_package='', top_path=None):\n    \"\"\"Recursive construction of package info to be used in setup().\n\n    See http://docs.scipy.org/doc/numpy/reference/distutils.html#numpy.distutils.misc_util.Configuration\n    \"\"\"  # noqa\n    config = Configuration(None, parent_package, top_path)\n    config.set_options(\n        ignore_setup_xxx_py=True,\n        assume_default_configuration=True,\n        delegate_options_to_subpackages=True,\n        quiet=True)\n    config.add_subpackage(PROJECT)\n    return config",
  "class BuildExtFlags(build_ext):\n    \"\"\"Handle compiler and linker flags.\n\n    If OpenMP is disabled, it removes OpenMP compile flags.\n    If building with MSVC, compiler flags are converted from gcc flags.\n    \"\"\"\n\n    COMPILE_ARGS_CONVERTER = {'-fopenmp': '/openmp'}\n\n    LINK_ARGS_CONVERTER = {'-fopenmp': ' '}\n\n    def build_extensions(self):\n        # Remove OpenMP flags if OpenMP is disabled\n        if not USE_OPENMP:\n            for ext in self.extensions:\n                ext.extra_compile_args = [\n                    f for f in ext.extra_compile_args if f != '-fopenmp']\n                ext.extra_link_args = [\n                    f for f in ext.extra_link_args if f != '-fopenmp']\n\n        # Convert flags from gcc to MSVC if required\n        if self.compiler.compiler_type == 'msvc':\n            for ext in self.extensions:\n                ext.extra_compile_args = [self.COMPILE_ARGS_CONVERTER.get(f, f)\n                                          for f in ext.extra_compile_args]\n                ext.extra_link_args = [self.LINK_ARGS_CONVERTER.get(f, f)\n                                       for f in ext.extra_link_args]\n\n        build_ext.build_extensions(self)",
  "def fake_cythonize(extensions):\n    \"\"\"Replace cython files by .c or .cpp files in extension's sources.\n\n    It replaces the *.pyx and *.py source files of the extensions\n    to either *.cpp or *.c source files.\n    No compilation is performed.\n\n    :param iterable extensions: List of extensions to patch.\n    \"\"\"\n    for ext_module in extensions:\n        new_sources = []\n        for source in ext_module.sources:\n            base, ext = os.path.splitext(source)\n            if ext in ('.pyx', '.py'):\n                if ext_module.language == 'c++':\n                    source = base + '.cpp'\n                else:\n                    source = base + '.c'\n                if not os.path.isfile(source):\n                    raise RuntimeError(\"Source file not found: %s\" % source)\n            new_sources.append(source)\n        ext_module.sources = new_sources",
  "class sdist_debian(sdist):\n    \"\"\"\n    Tailor made sdist for debian\n    * remove auto-generated doc\n    * remove cython generated .c files\n    \"\"\"\n    def prune_file_list(self):\n        sdist.prune_file_list(self)\n        to_remove = [\"doc/build\", \"doc/pdf\", \"doc/html\", \"pylint\", \"epydoc\"]\n        print(\"Removing files for debian\")\n        for rm in to_remove:\n            self.filelist.exclude_pattern(pattern=\"*\", anchor=False, prefix=rm)\n\n        # this is for Cython files specifically: remove C & html files\n        search_root = os.path.dirname(os.path.abspath(__file__))\n        for root, _, files in os.walk(search_root):\n            for afile in files:\n                if os.path.splitext(afile)[1].lower() == \".pyx\":\n                    base_file = os.path.join(root, afile)[len(search_root) + 1:-4]\n                    self.filelist.exclude_pattern(pattern=base_file + \".c\")\n                    self.filelist.exclude_pattern(pattern=base_file + \".cpp\")\n                    self.filelist.exclude_pattern(pattern=base_file + \".html\")\n\n    def make_distribution(self):\n        self.prune_file_list()\n        sdist.make_distribution(self)\n        dest = self.archive_files[0]\n        dirname, basename = os.path.split(dest)\n        base, ext = os.path.splitext(basename)\n        while ext in [\".zip\", \".tar\", \".bz2\", \".gz\", \".Z\", \".lz\", \".orig\"]:\n            base, ext = os.path.splitext(base)\n        if ext:\n            dest = \"\".join((base, ext))\n        else:\n            dest = base\n        sp = dest.split(\"-\")\n        base = sp[:-1]\n        nr = sp[-1]\n        debian_arch = os.path.join(dirname, \"-\".join(base) + \"_\" + nr + \".orig.tar.gz\")\n        os.rename(self.archive_files[0], debian_arch)\n        self.archive_files = [debian_arch]\n        print(\"Building debian .orig.tar.gz in %s\" % self.archive_files[0])",
  "def find_package_modules(self, package, package_dir):\n        modules = _build_py.find_package_modules(self, package, package_dir)\n        if package == PROJECT:\n            modules.append((PROJECT, '_version', 'version.py'))\n        return modules",
  "def initialize_options(self):\n        pass",
  "def finalize_options(self):\n        pass",
  "def run(self):\n        import subprocess\n        errno = subprocess.call([sys.executable, 'run_tests.py', '-i'])\n        if errno != 0:\n            raise SystemExit(errno)",
  "class build_doc(BuildDoc):\n\n        def run(self):\n            # make sure the python path is pointing to the newly built\n            # code so that the documentation is built on this and not a\n            # previously installed version\n\n            build = self.get_finalized_command('build')\n            sys.path.insert(0, os.path.abspath(build.build_lib))\n\n#             # Copy .ui files to the path:\n#             dst = os.path.join(\n#                 os.path.abspath(build.build_lib), \"silx\", \"gui\")\n#             if not os.path.isdir(dst):\n#                 os.makedirs(dst)\n#             for i in os.listdir(\"gui\"):\n#                 if i.endswith(\".ui\"):\n#                     src = os.path.join(\"gui\", i)\n#                     idst = os.path.join(dst, i)\n#                     if not os.path.exists(idst):\n#                         shutil.copy(src, idst)\n\n            # Build the Users Guide in HTML and TeX format\n            for builder in ('html', 'latex'):\n                self.builder = builder\n                self.builder_target_dir = os.path.join(self.build_dir, builder)\n                self.mkpath(self.builder_target_dir)\n                BuildDoc.run(self)\n            sys.path.pop(0)",
  "def build_extensions(self):\n        # Remove OpenMP flags if OpenMP is disabled\n        if not USE_OPENMP:\n            for ext in self.extensions:\n                ext.extra_compile_args = [\n                    f for f in ext.extra_compile_args if f != '-fopenmp']\n                ext.extra_link_args = [\n                    f for f in ext.extra_link_args if f != '-fopenmp']\n\n        # Convert flags from gcc to MSVC if required\n        if self.compiler.compiler_type == 'msvc':\n            for ext in self.extensions:\n                ext.extra_compile_args = [self.COMPILE_ARGS_CONVERTER.get(f, f)\n                                          for f in ext.extra_compile_args]\n                ext.extra_link_args = [self.LINK_ARGS_CONVERTER.get(f, f)\n                                       for f in ext.extra_link_args]\n\n        build_ext.build_extensions(self)",
  "def prune_file_list(self):\n        sdist.prune_file_list(self)\n        to_remove = [\"doc/build\", \"doc/pdf\", \"doc/html\", \"pylint\", \"epydoc\"]\n        print(\"Removing files for debian\")\n        for rm in to_remove:\n            self.filelist.exclude_pattern(pattern=\"*\", anchor=False, prefix=rm)\n\n        # this is for Cython files specifically: remove C & html files\n        search_root = os.path.dirname(os.path.abspath(__file__))\n        for root, _, files in os.walk(search_root):\n            for afile in files:\n                if os.path.splitext(afile)[1].lower() == \".pyx\":\n                    base_file = os.path.join(root, afile)[len(search_root) + 1:-4]\n                    self.filelist.exclude_pattern(pattern=base_file + \".c\")\n                    self.filelist.exclude_pattern(pattern=base_file + \".cpp\")\n                    self.filelist.exclude_pattern(pattern=base_file + \".html\")",
  "def make_distribution(self):\n        self.prune_file_list()\n        sdist.make_distribution(self)\n        dest = self.archive_files[0]\n        dirname, basename = os.path.split(dest)\n        base, ext = os.path.splitext(basename)\n        while ext in [\".zip\", \".tar\", \".bz2\", \".gz\", \".Z\", \".lz\", \".orig\"]:\n            base, ext = os.path.splitext(base)\n        if ext:\n            dest = \"\".join((base, ext))\n        else:\n            dest = base\n        sp = dest.split(\"-\")\n        base = sp[:-1]\n        nr = sp[-1]\n        debian_arch = os.path.join(dirname, \"-\".join(base) + \"_\" + nr + \".orig.tar.gz\")\n        os.rename(self.archive_files[0], debian_arch)\n        self.archive_files = [debian_arch]\n        print(\"Building debian .orig.tar.gz in %s\" % self.archive_files[0])",
  "def run(self):\n            # make sure the python path is pointing to the newly built\n            # code so that the documentation is built on this and not a\n            # previously installed version\n\n            build = self.get_finalized_command('build')\n            sys.path.insert(0, os.path.abspath(build.build_lib))\n\n#             # Copy .ui files to the path:\n#             dst = os.path.join(\n#                 os.path.abspath(build.build_lib), \"silx\", \"gui\")\n#             if not os.path.isdir(dst):\n#                 os.makedirs(dst)\n#             for i in os.listdir(\"gui\"):\n#                 if i.endswith(\".ui\"):\n#                     src = os.path.join(\"gui\", i)\n#                     idst = os.path.join(dst, i)\n#                     if not os.path.exists(idst):\n#                         shutil.copy(src, idst)\n\n            # Build the Users Guide in HTML and TeX format\n            for builder in ('html', 'latex'):\n                self.builder = builder\n                self.builder_target_dir = os.path.join(self.build_dir, builder)\n                self.mkpath(self.builder_target_dir)\n                BuildDoc.run(self)\n            sys.path.pop(0)",
  "def _copy(infile, outfile):\n    \"link or copy file according to the OS. Nota those are HARD_LINKS\"\n    if \"link\" in dir(os):\n        os.link(infile, outfile)\n    else:\n        shutil.copy(infile, outfile)",
  "def _distutils_dir_name(dname=\"lib\"):\n    \"\"\"\n    Returns the name of a distutils build directory\n    \"\"\"\n    platform = distutils.util.get_platform()\n    architecture = \"%s.%s-%i.%i\" % (dname, platform,\n                                    sys.version_info[0], sys.version_info[1])\n    return architecture",
  "def _distutils_scripts_name():\n    \"\"\"Return the name of the distrutils scripts sirectory\"\"\"\n    f = \"scripts-{version[0]}.{version[1]}\"\n    return f.format(version=sys.version_info)",
  "def _get_available_scripts(path):\n    res = []\n    try:\n        res = \" \".join([s.rstrip('.py') for s in os.listdir(path)])\n    except OSError:\n        res = [\"no script available, did you ran \"\n               \"'python setup.py build' before bootstrapping ?\"]\n    return res",
  "def _copy_files(source, dest, extn):\n    \"\"\"\n    copy all files with a given extension from source to destination\n    \"\"\"\n    if not os.path.isdir(dest):\n        os.makedirs(dest)\n    full_src = os.path.join(os.path.dirname(__file__), source)\n    for clf in os.listdir(full_src):\n        if clf.endswith(extn) and clf not in os.listdir(dest):\n            _copy(os.path.join(full_src, clf), os.path.join(dest, clf))",
  "def runfile(fname):\n    try:\n        execfile(fname)\n    except SyntaxError as error:\n        print(error)\n        env = os.environ.copy()\n        env.update({\"PYTHONPATH\": LIBPATH + os.pathsep + os.environ.get(\"PYTHONPATH\", \"\"),\n                    \"PATH\": SCRIPTSPATH + os.pathsep + os.environ.get(\"PATH\", \"\")})\n        run = subprocess.Popen(sys.argv, shell=False, env=env)\n        run.wait()",
  "def execfile(fullpath):\n        \"Python3 implementation for execfile\"\n        with open(fullpath) as f:\n            code = compile(f.read(), fullpath, 'exec')\n            exec(code)",
  "def configuration(parent_package='', top_path=None):\n    config = Configuration('silx', parent_package, top_path)\n    config.add_subpackage('gui')\n    config.add_subpackage('io')\n    config.add_subpackage('math')\n    config.add_subpackage('image')\n    config.add_subpackage('resources')\n    config.add_subpackage('test')\n    config.add_subpackage('third_party')\n\n    return config",
  "def resource_filename(resource):\n    \"\"\"Return filename corresponding to resource.\n\n    resource can be the name of either a file or a directory.\n    The existence of the resource is not checked.\n\n    :param str resource: Resource path relative to resource directory\n                         using '/' path separator.\n    :return: Absolute resource path in the file system\n    \"\"\"\n    # Not in use, uncomment when functionnality is needed\n    # If _RESOURCES_DOC_DIR is set, use it to get resources in doc/ subflodler\n    # from an alternative directory.\n    # if _RESOURCES_DOC_DIR is not None and (resource is 'doc' or\n    #         resource.startswith('doc/')):\n    #     # Remove doc folder from resource relative path\n    #     return os.path.join(_RESOURCES_DOC_DIR, *resource.split('/')[1:])\n\n    if _RESOURCES_DIR is not None:  # if set, use this directory\n        return os.path.join(_RESOURCES_DIR, *resource.split('/'))\n    elif pkg_resources is None:  # Fallback if pkg_resources is not available\n        return os.path.join(os.path.abspath(os.path.dirname(__file__)),\n                            *resource.split('/'))\n    else:  # Preferred way to get resources as it supports zipfile package\n        return pkg_resources.resource_filename(__name__, resource)",
  "def configuration(parent_package='', top_path=None):\n    config = Configuration('image', parent_package, top_path)\n    config.add_subpackage('test')\n    config.add_extension('bilinear',\n                         sources=[\"bilinear.pyx\"],\n                         language='c')\n    return config",
  "def configuration(parent_package='', top_path=None):\n    config = Configuration('math', parent_package, top_path)\n    config.add_subpackage('test')\n\n    # =====================================\n    # histogramnd\n    # =====================================\n    histo_dir = 'histogramnd'\n    histo_src = ['/'.join([histo_dir, srcf])\n                 for srcf in ['histogramnd.pyx',\n                              'src/histogramnd_c.c']]\n    histo_inc = ['/'.join([histo_dir, 'include']),\n                 numpy.get_include()]\n\n    config.add_extension('histogramnd',\n                         sources=histo_src,\n                         include_dirs=histo_inc,\n                         language='c')\n    # =====================================\n    # =====================================\n\n    return config",
  "class TiffIO(object):\n    def __init__(self, filename, mode=None, cache_length=20, mono_output=False):\n        if mode is None:\n            mode = 'rb'\n        if 'b' not in mode:\n            mode = mode + 'b'\n        if 'a' in mode.lower():\n            raise IOError(\"Mode %s makes no sense on TIFF files. Consider 'rb+'\" % mode)\n        if ('w' in mode):\n            if '+' not in mode:\n                mode += '+'\n\n        if hasattr(filename, \"seek\") and\\\n           hasattr(filename, \"read\"):\n            fd = filename\n            self._access = None\n        else:\n            #the b is needed for windows and python 3\n            fd = open(filename, mode)\n            self._access = mode\n\n        self._initInternalVariables(fd)\n        self._maxImageCacheLength = cache_length\n        self._forceMonoOutput = mono_output\n\n    def _initInternalVariables(self, fd=None):\n        if fd is None:\n            fd = self.fd\n        else:\n            self.fd = fd\n        # read the order\n        fd.seek(0)\n        order = fd.read(2).decode()\n        if len(order):\n            if order == \"II\":\n                #intel, little endian\n                fileOrder = \"little\"\n                self._structChar = '<'\n            elif order == \"MM\":\n                #motorola, high endian\n                fileOrder = \"big\"\n                self._structChar = '>'\n            else:\n                raise IOError(\"File is not a Mar CCD file, nor a TIFF file\")\n            a = fd.read(2)\n            fortyTwo = struct.unpack(self._structChar+\"H\",a)[0]\n            if fortyTwo != 42:\n                raise IOError(\"Invalid TIFF version %d\" % fortyTwo)\n            else:\n                if DEBUG:\n                    print(\"VALID TIFF VERSION\")\n            if sys.byteorder != fileOrder:\n                swap = True\n            else:\n                swap = False\n        else:\n            if sys.byteorder == \"little\":\n                self._structChar = '<'\n            else:\n                self._structChar = '>'\n            swap = False\n        self._swap = swap\n        self._IFD = []\n        self._imageDataCacheIndex = []\n        self._imageDataCache  = []\n        self._imageInfoCacheIndex  = []\n        self._imageInfoCache  = []\n        self.getImageFileDirectories(fd)\n\n    def __makeSureFileIsOpen(self):\n        if not self.fd.closed:\n            return\n        if DEBUG:\n            print(\"Reopening closed file\")\n        fileName = self.fd.name\n        if self._access is None:\n            #we do not own the file\n            #open in read mode\n            newFile = open(fileName,'rb')\n        else:\n            newFile = open(fileName, self._access)\n        self.fd  = newFile\n\n    def __makeSureFileIsClosed(self):\n        if self._access is None:\n            #we do not own the file\n            if DEBUG:\n                print(\"Not closing not owned file\")\n            return\n\n        if not self.fd.closed:\n            self.fd.close()\n\n    def close(self):\n        return self.__makeSureFileIsClosed()\n\n    def getNumberOfImages(self):\n        #update for the case someone has done anything?\n        self._updateIFD()\n        return len(self._IFD)\n\n    def _updateIFD(self):\n        self.__makeSureFileIsOpen()\n        self.getImageFileDirectories()\n        self.__makeSureFileIsClosed()\n\n    def getImageFileDirectories(self, fd=None):\n        if fd is None:\n            fd = self.fd\n        else:\n            self.fd = fd\n        st = self._structChar\n        fd.seek(4)\n        self._IFD = []\n        nImages = 0\n        fmt = st + 'I'\n        inStr = fd.read(struct.calcsize(fmt))\n        if not len(inStr):\n            offsetToIFD = 0\n        else:\n            offsetToIFD = struct.unpack(fmt, inStr)[0]\n        if DEBUG:\n            print(\"Offset to first IFD = %d\" % offsetToIFD)\n        while offsetToIFD != 0:\n            self._IFD.append(offsetToIFD)\n            nImages += 1\n            fd.seek(offsetToIFD)\n            fmt = st + 'H'\n            numberOfDirectoryEntries = struct.unpack(fmt,fd.read(struct.calcsize(fmt)))[0]\n            if DEBUG:\n                print(\"Number of directory entries = %d\" % numberOfDirectoryEntries)\n\n            fmt = st + 'I'\n            fd.seek(offsetToIFD + 2 + 12 * numberOfDirectoryEntries)\n            offsetToIFD = struct.unpack(fmt,fd.read(struct.calcsize(fmt)))[0]\n            if DEBUG:\n                print(\"Next Offset to IFD = %d\" % offsetToIFD)\n            #offsetToIFD = 0\n        if DEBUG:\n            print(\"Number of images found = %d\" % nImages)\n        return nImages\n\n    def _parseImageFileDirectory(self, nImage):\n        offsetToIFD = self._IFD[nImage]\n        st = self._structChar\n        fd = self.fd\n        fd.seek(offsetToIFD)\n        fmt = st + 'H'\n        numberOfDirectoryEntries = struct.unpack(fmt,fd.read(struct.calcsize(fmt)))[0]\n        if DEBUG:\n            print(\"Number of directory entries = %d\" % numberOfDirectoryEntries)\n\n        fmt = st + 'HHI4s'\n        tagIDList = []\n        fieldTypeList = []\n        nValuesList = []\n        valueOffsetList = []\n        for i in range(numberOfDirectoryEntries):\n            tagID, fieldType, nValues, valueOffset = struct.unpack(fmt, fd.read(12))\n            tagIDList.append(tagID)\n            fieldTypeList.append(fieldType)\n            nValuesList.append(nValues)\n            if nValues == 1:\n                ftype, vfmt = FIELD_TYPE[fieldType]\n                if ftype not in ['ASCII', 'RATIONAL', 'SRATIONAL']:\n                    vfmt = st + vfmt\n                    actualValue = struct.unpack(vfmt, valueOffset[0: struct.calcsize(vfmt)])[0]\n                    valueOffsetList.append(actualValue)\n                else:\n                    valueOffsetList.append(valueOffset)\n            elif (nValues < 5) and (fieldType == 2):\n                ftype, vfmt = FIELD_TYPE[fieldType]\n                vfmt = st + \"%d%s\" % (nValues,vfmt)\n                actualValue = struct.unpack(vfmt, valueOffset[0: struct.calcsize(vfmt)])[0]\n                valueOffsetList.append(actualValue)\n            else:\n                valueOffsetList.append(valueOffset)\n            if DEBUG:\n                if tagID in TAG_ID:\n                    print(\"tagID = %s\" % TAG_ID[tagID])\n                else:\n                    print(\"tagID        = %d\" % tagID)\n                print(\"fieldType    = %s\" % FIELD_TYPE[fieldType][0])\n                print(\"nValues      = %d\" % nValues)\n                #if nValues == 1:\n                #    print(\"valueOffset =  %s\" % valueOffset)\n        return tagIDList, fieldTypeList, nValuesList, valueOffsetList\n\n\n\n    def _readIFDEntry(self, tag, tagIDList, fieldTypeList, nValuesList, valueOffsetList):\n        fd = self.fd\n        st = self._structChar\n        idx = tagIDList.index(tag)\n        nValues = nValuesList[idx]\n        output = []\n        ftype, vfmt = FIELD_TYPE[fieldTypeList[idx]]\n        vfmt = st + \"%d%s\" % (nValues, vfmt)\n        requestedBytes = struct.calcsize(vfmt)\n        if nValues ==  1:\n            output.append(valueOffsetList[idx])\n        elif requestedBytes < 5:\n            output.append(valueOffsetList[idx])\n        else:\n            fd.seek(struct.unpack(st+\"I\", valueOffsetList[idx])[0])\n            output = struct.unpack(vfmt, fd.read(requestedBytes))\n        return output\n\n    def getData(self, nImage, **kw):\n        if nImage >= len(self._IFD):\n            #update prior to raise an index error error\n            self._updateIFD()\n        return self._readImage(nImage, **kw)\n\n    def getImage(self, nImage):\n        return self.getData(nImage)\n\n    def getInfo(self, nImage, **kw):\n        if nImage >= len(self._IFD):\n            #update prior to raise an index error error\n            self._updateIFD()\n        # current = self._IFD[nImage]\n        return self._readInfo(nImage)\n\n    def _readInfo(self, nImage, close=True):\n        if nImage in self._imageInfoCacheIndex:\n            if DEBUG:\n                print(\"Reading info from cache\")\n            return self._imageInfoCache[self._imageInfoCacheIndex.index(nImage)]\n\n        #read the header\n        self.__makeSureFileIsOpen()\n        tagIDList, fieldTypeList, nValuesList, valueOffsetList = self._parseImageFileDirectory(nImage)\n\n        #rows and columns\n        nColumns = valueOffsetList[tagIDList.index(TAG_NUMBER_OF_COLUMNS)]\n        nRows    = valueOffsetList[tagIDList.index(TAG_NUMBER_OF_ROWS)]\n\n        #bits per sample\n        idx = tagIDList.index(TAG_BITS_PER_SAMPLE)\n        nBits = valueOffsetList[idx]\n        if nValuesList[idx] != 1:\n            #this happens with RGB and friends, nBits is not a single value\n            nBits = self._readIFDEntry(TAG_BITS_PER_SAMPLE,\n                                          tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n\n\n        if TAG_COLORMAP in tagIDList:\n            idx = tagIDList.index(TAG_COLORMAP)\n            tmpColormap = self._readIFDEntry(TAG_COLORMAP,\n                                          tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n            if max(tmpColormap) > 255:\n                tmpColormap = numpy.array(tmpColormap, dtype=numpy.uint16)\n                tmpColormap = (tmpColormap/256.).astype(numpy.uint8)\n            else:\n                tmpColormap = numpy.array(tmpColormap, dtype=numpy.uint8)\n            tmpColormap.shape = 3, -1\n            colormap = numpy.zeros((tmpColormap.shape[-1], 3), tmpColormap.dtype)\n            colormap[:,:] = tmpColormap.T\n            tmpColormap = None\n        else:\n            colormap = None\n\n        #sample format\n        if TAG_SAMPLE_FORMAT in tagIDList:\n            sampleFormat = valueOffsetList[tagIDList.index(TAG_SAMPLE_FORMAT)]\n        else:\n            #set to unknown\n            sampleFormat = SAMPLE_FORMAT_VOID\n\n        # compression\n        compression = False\n        compression_type = 1\n        if TAG_COMPRESSION in tagIDList:\n            compression_type = valueOffsetList[tagIDList.index(TAG_COMPRESSION)]\n            if compression_type == 1:\n                compression = False\n            else:\n                compression = True\n\n        #photometric interpretation\n        interpretation = 1\n        if TAG_PHOTOMETRIC_INTERPRETATION in tagIDList:\n            interpretation = valueOffsetList[tagIDList.index(TAG_PHOTOMETRIC_INTERPRETATION)]\n        else:\n            print(\"WARNING: Non standard TIFF. Photometric interpretation TAG missing\")\n        helpString = \"\"\n        if sys.version > '2.6':\n            helpString = eval('b\"\"')\n\n        if TAG_IMAGE_DESCRIPTION in tagIDList:\n            imageDescription = self._readIFDEntry(TAG_IMAGE_DESCRIPTION,\n                    tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n            if type(imageDescription) in [type([1]), type((1,))]:\n                imageDescription =helpString.join(imageDescription)\n        else:\n            imageDescription = \"%d/%d\" % (nImage+1, len(self._IFD))\n\n        if sys.version < '3.0':\n            defaultSoftware = \"Unknown Software\"\n        else:\n            defaultSoftware = bytes(\"Unknown Software\",\n                                    encoding='utf-8')\n        if TAG_SOFTWARE in tagIDList:\n            software = self._readIFDEntry(TAG_SOFTWARE,\n                    tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n            if type(software) in [type([1]), type((1,))]:\n                software =helpString.join(software)\n        else:\n            software = defaultSoftware\n\n        if software == defaultSoftware:\n            try:\n                if sys.version < '3.0':\n                    if imageDescription.upper().startswith(\"IMAGEJ\"):\n                        software = imageDescription.split(\"=\")[0]\n                else:\n                    tmpString = imageDescription.decode()\n                    if tmpString.upper().startswith(\"IMAGEJ\"):\n                        software = bytes(tmpString.split(\"=\")[0],\n                                         encoding='utf-8')\n            except:\n                pass\n\n        if TAG_DATE in tagIDList:\n            date = self._readIFDEntry(TAG_DATE,\n                    tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n            if type(date) in [type([1]), type((1,))]:\n                date =helpString.join(date)\n        else:\n            date = \"Unknown Date\"\n\n        stripOffsets = self._readIFDEntry(TAG_STRIP_OFFSETS,\n                        tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n        if TAG_ROWS_PER_STRIP in tagIDList:\n            rowsPerStrip = self._readIFDEntry(TAG_ROWS_PER_STRIP,\n                        tagIDList, fieldTypeList, nValuesList, valueOffsetList)[0]\n        else:\n            rowsPerStrip = nRows\n            print(\"WARNING: Non standard TIFF. Rows per strip TAG missing\")\n\n        if TAG_STRIP_BYTE_COUNTS in tagIDList:\n            stripByteCounts = self._readIFDEntry(TAG_STRIP_BYTE_COUNTS,\n                        tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n        else:\n            print(\"WARNING: Non standard TIFF. Strip byte counts TAG missing\")\n            if hasattr(nBits, 'index'):\n                expectedSum = 0\n                for n in nBits:\n                    expectedSum += int(nRows * nColumns * n / 8)\n            else:\n                expectedSum = int(nRows * nColumns * nBits / 8)\n            stripByteCounts = [expectedSum]\n\n        if close:\n            self.__makeSureFileIsClosed()\n\n        if self._forceMonoOutput and (interpretation > 1):\n            #color image but asked monochrome output\n            nBits = 32\n            colormap = None\n            sampleFormat = SAMPLE_FORMAT_FLOAT\n            interpretation = 1\n            #we cannot rely on any cache in this case\n            useInfoCache = False\n            if DEBUG:\n                print(\"FORCED MONO\")\n        else:\n            useInfoCache = True\n\n        info = {}\n        info[\"nRows\"] = nRows\n        info[\"nColumns\"] = nColumns\n        info[\"nBits\"] = nBits\n        info[\"compression\"] = compression\n        info[\"compression_type\"] = compression_type\n        info[\"imageDescription\"] = imageDescription\n        info[\"stripOffsets\"] = stripOffsets #This contains the file offsets to the data positions\n        info[\"rowsPerStrip\"] = rowsPerStrip\n        info[\"stripByteCounts\"] = stripByteCounts #bytes in strip since I do not support compression\n        info[\"software\"] = software\n        info[\"date\"] = date\n        info[\"colormap\"] = colormap\n        info[\"sampleFormat\"] = sampleFormat\n        info[\"photometricInterpretation\"] = interpretation\n        infoDict = {}\n        if sys.version < '3.0':\n            testString = 'PyMca'\n        else:\n            testString = eval('b\"PyMca\"')\n        if software.startswith(testString):\n            #str to make sure python 2.x sees it as string and not unicode\n            if sys.version < '3.0':\n                descriptionString = imageDescription\n            else:\n                descriptionString = str(imageDescription.decode())\n            #interpret the image description in terms of supplied\n            #information at writing time\n            items = descriptionString.split('=')\n            for i in range(int(len(items)/2)):\n                key = \"%s\" % items[i*2]\n                #get rid of the \\n at the end of the value\n                value = \"%s\" % items[i*2+1][:-1]\n                infoDict[key] = value\n        info['info'] = infoDict\n\n        if (self._maxImageCacheLength > 0) and useInfoCache:\n            self._imageInfoCacheIndex.insert(0,nImage)\n            self._imageInfoCache.insert(0, info)\n            if len(self._imageInfoCacheIndex) > self._maxImageCacheLength:\n                self._imageInfoCacheIndex = self._imageInfoCacheIndex[:self._maxImageCacheLength]\n                self._imageInfoCache = self._imageInfoCache[:self._maxImageCacheLength]\n        return info\n\n    def _readImage(self, nImage, **kw):\n        if DEBUG:\n            print(\"Reading image %d\" % nImage)\n        if 'close' in kw:\n            close = kw['close']\n        else:\n            close = True\n        rowMin = kw.get('rowMin', None)\n        rowMax = kw.get('rowMax', None)\n        if nImage in self._imageDataCacheIndex:\n            if DEBUG:\n                print(\"Reading image data from cache\")\n            return self._imageDataCache[self._imageDataCacheIndex.index(nImage)]\n\n        self.__makeSureFileIsOpen()\n        if self._forceMonoOutput:\n            oldMono = True\n        else:\n            oldMono = False\n        try:\n            self._forceMonoOutput = False\n            info = self._readInfo(nImage, close=False)\n            self._forceMonoOutput = oldMono\n        except:\n            self._forceMonoOutput = oldMono\n            raise\n        compression = info['compression']\n        compression_type = info['compression_type']\n        if compression:\n            if compression_type != 32773:\n                raise IOError(\"Compressed TIFF images not supported except packbits\")\n            else:\n                #PackBits compression\n                if DEBUG:\n                    print(\"Using PackBits compression\")\n\n        interpretation = info[\"photometricInterpretation\"]\n        if interpretation == 2:\n            #RGB\n            pass\n            #raise IOError(\"RGB Image. Only grayscale images supported\")\n        elif interpretation == 3:\n            #Palette Color Image\n            pass\n            #raise IOError(\"Palette-color Image. Only grayscale images supported\")\n        elif interpretation > 2:\n            #Palette Color Image\n            raise IOError(\"Only grayscale images supported\")\n\n        nRows    = info[\"nRows\"]\n        nColumns = info[\"nColumns\"]\n        nBits    = info[\"nBits\"]\n        colormap = info[\"colormap\"]\n        sampleFormat = info[\"sampleFormat\"]\n\n        if rowMin is None:\n            rowMin = 0\n\n        if rowMax is None:\n            rowMax = nRows - 1\n\n        if rowMin < 0:\n            rowMin = nRows - rowMin\n\n        if rowMax < 0:\n            rowMax = nRows - rowMax\n\n        if rowMax < rowMin:\n            txt = \"Max Row smaller than Min Row. Reverse selection not supported\"\n            raise NotImplemented(txt)\n\n        if rowMin >= nRows:\n            raise IndexError(\"Image only has %d rows\" % nRows)\n\n        if rowMax >= nRows:\n            raise IndexError(\"Image only has %d rows\" % nRows)\n\n        if sampleFormat == SAMPLE_FORMAT_FLOAT:\n            if nBits == 32:\n                dtype = numpy.float32\n            elif nBits == 64:\n                dtype = numpy.float64\n            else:\n                raise ValueError(\"Unsupported number of bits for a float: %d\" % nBits)\n        elif sampleFormat in [SAMPLE_FORMAT_UINT, SAMPLE_FORMAT_VOID]:\n            if nBits in [8, (8, 8, 8), [8, 8, 8]]:\n                dtype = numpy.uint8\n            elif nBits in [16, (16, 16, 16), [16, 16, 16]]:\n                dtype = numpy.uint16\n            elif nBits in [32, (32, 32, 32), [32, 32, 32]]:\n                dtype = numpy.uint32\n            elif nBits in [64, (64, 64, 64), [64, 64, 64]]:\n                dtype = numpy.uint64\n            else:\n                raise ValueError(\"Unsupported number of bits for unsigned int: %s\" % (nBits,))\n        elif sampleFormat == SAMPLE_FORMAT_INT:\n            if nBits in [8, (8, 8, 8), [8, 8, 8]]:\n                dtype = numpy.int8\n            elif nBits in [16, (16, 16, 16), [16, 16, 16]]:\n                dtype = numpy.int16\n            elif nBits in [32, (32, 32, 32), [32, 32, 32]]:\n                dtype = numpy.int32\n            elif nBits in [64, (64, 64, 64), [64, 64, 64]]:\n                dtype = numpy.int64\n            else:\n                raise ValueError(\"Unsupported number of bits for signed int: %s\" % (nBits,))\n        else:\n            raise ValueError(\"Unsupported combination. Bits = %s  Format = %d\" % (nBits, sampleFormat))\n        if hasattr(nBits, 'index'):\n            image = numpy.zeros((nRows, nColumns, len(nBits)), dtype=dtype)\n        elif colormap is not None:\n            #should I use colormap dtype?\n            image = numpy.zeros((nRows, nColumns, 3), dtype=dtype)\n        else:\n            image = numpy.zeros((nRows, nColumns), dtype=dtype)\n\n        fd = self.fd\n        st = self._structChar\n        stripOffsets = info[\"stripOffsets\"] #This contains the file offsets to the data positions\n        rowsPerStrip = info[\"rowsPerStrip\"]\n        stripByteCounts = info[\"stripByteCounts\"] #bytes in strip since I do not support compression\n\n        rowStart = 0\n        if len(stripOffsets) == 1:\n            bytesPerRow = int(stripByteCounts[0]/rowsPerStrip)\n            if nRows == rowsPerStrip:\n                actualBytesPerRow = int(image.nbytes/nRows)\n                if actualBytesPerRow != bytesPerRow:\n                    print(\"Warning: Bogus StripByteCounts information\")\n                    bytesPerRow = actualBytesPerRow \n            fd.seek(stripOffsets[0] + rowMin * bytesPerRow)\n            nBytes = (rowMax-rowMin+1) * bytesPerRow\n            if self._swap:\n                readout = numpy.fromstring(fd.read(nBytes), dtype).byteswap()\n            else:\n                readout = numpy.fromstring(fd.read(nBytes), dtype)\n            if hasattr(nBits, 'index'):\n                readout.shape = -1, nColumns, len(nBits)\n            elif info['colormap'] is not None:\n                readout = colormap[readout]\n            else:\n                readout.shape = -1, nColumns\n            image[rowMin:rowMax+1, :] = readout\n        else:\n            for i in range(len(stripOffsets)):\n                #the amount of rows\n                nRowsToRead = rowsPerStrip\n                rowEnd = int(min(rowStart+nRowsToRead, nRows))\n                if rowEnd < rowMin:\n                    rowStart += nRowsToRead\n                    continue\n                if (rowStart > rowMax):\n                    break\n                #we are in position\n                fd.seek(stripOffsets[i])\n                #the amount of bytes to read\n                nBytes = stripByteCounts[i]\n                if compression_type == 32773:\n                    try:\n                        bufferBytes = bytes()\n                    except:\n                        #python 2.5 ...\n                        bufferBytes = \"\"\n                    #packBits\n                    readBytes = 0\n                    #intermediate buffer\n                    tmpBuffer = fd.read(nBytes)\n                    while readBytes < nBytes:\n                        n = struct.unpack('b', tmpBuffer[readBytes:(readBytes+1)])[0]\n                        readBytes += 1\n                        if n >= 0:\n                            #should I prevent reading more than the\n                            #length of the chain? Let's python raise\n                            #the exception...\n                            bufferBytes +=  tmpBuffer[readBytes:\\\n                                                      readBytes+(n+1)]\n                            readBytes += (n+1)\n                        elif n > -128:\n                            bufferBytes += (-n+1) * tmpBuffer[readBytes:(readBytes+1)]\n                            readBytes += 1\n                        else:\n                            #if read -128 ignore the byte\n                            continue\n                    if self._swap:\n                        readout = numpy.fromstring(bufferBytes, dtype).byteswap()\n                    else:\n                        readout = numpy.fromstring(bufferBytes, dtype)\n                    if hasattr(nBits, 'index'):\n                        readout.shape = -1, nColumns, len(nBits)\n                    elif info['colormap'] is not None:\n                        readout = colormap[readout]\n                        readout.shape = -1, nColumns, 3\n                    else:\n                        readout.shape = -1, nColumns\n                    image[rowStart:rowEnd, :] = readout\n                else:\n                    if 1:\n                        #use numpy\n                        if self._swap:\n                            readout = numpy.fromstring(fd.read(nBytes), dtype).byteswap()\n                        else:\n                            readout = numpy.fromstring(fd.read(nBytes), dtype)\n                        if hasattr(nBits, 'index'):\n                            readout.shape = -1, nColumns, len(nBits)\n                        elif colormap is not None:\n                            readout = colormap[readout]\n                            readout.shape = -1, nColumns, 3\n                        else:\n                            readout.shape = -1, nColumns\n                        image[rowStart:rowEnd, :] = readout\n                    else:\n                        #using struct\n                        readout = numpy.array(struct.unpack(st+\"%df\" % int(nBytes/4), fd.read(nBytes)),\n                                              dtype=dtype)\n                        if hasattr(nBits, 'index'):\n                            readout.shape = -1, nColumns, len(nBits)\n                        elif colormap is not None:\n                            readout = colormap[readout]\n                            readout.shape = -1, nColumns, 3\n                        else:\n                            readout.shape = -1, nColumns\n                        image[rowStart:rowEnd, :] = readout\n                rowStart += nRowsToRead\n        if close:\n            self.__makeSureFileIsClosed()\n\n        if len(image.shape) == 3:\n            #color image\n            if self._forceMonoOutput:\n                #color image, convert to monochrome\n                image = (image[:,:,0] * 0.114 +\\\n                         image[:,:,1] * 0.587 +\\\n                         image[:,:,2] * 0.299).astype(numpy.float32)\n\n        if (rowMin == 0) and (rowMax == (nRows-1)):\n            self._imageDataCacheIndex.insert(0,nImage)\n            self._imageDataCache.insert(0, image)\n            if len(self._imageDataCacheIndex) > self._maxImageCacheLength:\n                self._imageDataCacheIndex = self._imageDataCacheIndex[:self._maxImageCacheLength]\n                self._imageDataCache = self._imageDataCache[:self._maxImageCacheLength]\n\n        return image\n\n    def writeImage(self, image0, info=None, software=None, date=None):\n        if software is None:\n            software = 'PyMca.TiffIO'\n        #if date is None:\n        #    date = time.ctime()\n\n        self.__makeSureFileIsOpen()\n        fd = self.fd\n        #prior to do anything, perform some tests\n        if not len(image0.shape):\n            raise ValueError(\"Empty image\")\n        if len(image0.shape) == 1:\n            #get a different view\n            image = image0[:]\n            image.shape = 1, -1\n        else:\n            image = image0\n\n        if image.dtype == numpy.float64:\n            image = image.astype(numpy.float32)\n        fd.seek(0)\n        mode = fd.mode\n        name = fd.name\n        if 'w' in mode:\n            #we have to overwrite the file\n            self.__makeSureFileIsClosed()\n            fd = None\n            if os.path.exists(name):\n                os.remove(name)\n            fd = open(name, mode='wb+')\n            self._initEmptyFile(fd)\n        self.fd = fd\n\n        #read the file size\n        self.__makeSureFileIsOpen()\n        fd = self.fd\n        fd.seek(0, os.SEEK_END)\n        endOfFile = fd.tell()\n        if fd.tell() == 0:\n            self._initEmptyFile(fd)\n            fd.seek(0, os.SEEK_END)\n            endOfFile = fd.tell()\n\n        #init internal variables\n        self._initInternalVariables(fd)\n        st = self._structChar\n\n        #get the image file directories\n        nImages = self.getImageFileDirectories()\n        if DEBUG:\n            print(\"File contains %d images\" % nImages)\n        if nImages == 0:\n            fd.seek(4)\n            fmt = st + 'I'\n            fd.write(struct.pack(fmt, endOfFile))\n        else:\n            fd.seek(self._IFD[-1])\n            fmt = st + 'H'\n            numberOfDirectoryEntries = struct.unpack(fmt,fd.read(struct.calcsize(fmt)))[0]\n            fmt = st + 'I'\n            pos = self._IFD[-1] + 2 + 12 * numberOfDirectoryEntries\n            fd.seek(pos)\n            fmt = st + 'I'\n            fd.write(struct.pack(fmt, endOfFile))\n        fd.flush()\n\n        #and we can write at the end of the file, find out the file length\n        fd.seek(0, os.SEEK_END)\n\n        #get the description information from the input information\n        if info is None:\n            description = info\n        else:\n            description = \"%s\" % \"\"\n            for key in info.keys():\n                description += \"%s=%s\\n\"  % (key, info[key])\n\n        #get the image file directory\n        outputIFD = self._getOutputIFD(image, description=description,\n                                              software=software,\n                                              date=date)\n\n        #write the new IFD\n        fd.write(outputIFD)\n\n        #write the image\n        if self._swap:\n            fd.write(image.byteswap().tostring())\n        else:\n            fd.write(image.tostring())\n\n        fd.flush()\n        self.fd=fd\n        self.__makeSureFileIsClosed()\n\n    def _initEmptyFile(self, fd=None):\n        if fd is None:\n            fd = self.fd\n        if sys.byteorder == \"little\":\n            order = \"II\"\n            #intel, little endian\n            fileOrder = \"little\"\n            self._structChar = '<'\n        else:\n            order = \"MM\"\n            #motorola, high endian\n            fileOrder = \"big\"\n            self._structChar = '>'\n        st = self._structChar\n        if fileOrder == sys.byteorder:\n            self._swap = False\n        else:\n            self._swap = True\n        fd.seek(0)\n        if sys.version < '3.0':\n            fd.write(struct.pack(st+'2s', order))\n            fd.write(struct.pack(st+'H', 42))\n            fd.write(struct.pack(st+'I', 0))\n        else:\n            fd.write(struct.pack(st+'2s', bytes(order,'utf-8')))\n            fd.write(struct.pack(st+'H', 42))\n            fd.write(struct.pack(st+'I', 0))\n        fd.flush()\n\n    def _getOutputIFD(self, image, description=None, software=None, date=None):\n        #the tags have to be in order\n        #the very minimum is\n        #256:\"NumberOfColumns\",           # S or L ImageWidth\n        #257:\"NumberOfRows\",              # S or L ImageHeight\n        #258:\"BitsPerSample\",             # S Number of bits per component\n        #259:\"Compression\",               # SHORT (1 - NoCompression, ...\n        #262:\"PhotometricInterpretation\", # SHORT (0 - WhiteIsZero, 1 -BlackIsZero, 2 - RGB, 3 - Palette color\n        #270:\"ImageDescription\",          # ASCII\n        #273:\"StripOffsets\",              # S or L, for each strip, the byte offset of the strip\n        #277:\"SamplesPerPixel\",           # SHORT (>=3) only for RGB images\n        #278:\"RowsPerStrip\",              # S or L, number of rows in each back may be not for the last\n        #279:\"StripByteCounts\",           # S or L, The number of bytes in the strip AFTER any compression\n        #305:\"Software\",                  # ASCII\n        #306:\"Date\",                      # ASCII\n        #339:\"SampleFormat\",              # SHORT Interpretation of data in each pixel\n\n        nDirectoryEntries = 9\n        imageDescription = None\n        if description is not None:\n            descriptionLength = len(description)\n            while descriptionLength < 4:\n                description = description + \" \"\n                descriptionLength = len(description)\n            if sys.version >= '3.0':\n                description = bytes(description, 'utf-8')\n            elif type(description) != type(\"\"):\n                try:\n                    description = description.decode('utf-8')\n                except UnicodeDecodeError:\n                    try:\n                        description = description.decode('latin-1')\n                    except UnicodeDecodeError:\n                        description = \"%s\" % description\n                if sys.version > '2.6':\n                    description=description.encode('utf-8', errors=\"ignore\")\n                description = \"%s\" % description\n            descriptionLength = len(description)\n            imageDescription = struct.pack(\"%ds\" % descriptionLength, description)\n            nDirectoryEntries += 1\n\n        #software\n        if software is not None:\n            softwareLength = len(software)\n            while softwareLength < 4:\n                software = software + \" \"\n                softwareLength = len(software)\n            if sys.version >= '3.0':\n                software = bytes(software, 'utf-8')\n            softwarePackedString = struct.pack(\"%ds\" % softwareLength, software)\n            nDirectoryEntries += 1\n        else:\n            softwareLength = 0\n\n        if date is not None:\n            dateLength = len(date)\n            if sys.version >= '3.0':\n                date = bytes(date, 'utf-8')\n            datePackedString = struct.pack(\"%ds\" % dateLength, date)\n            dateLength = len(datePackedString)\n            nDirectoryEntries += 1\n        else:\n            dateLength = 0\n\n        if len(image.shape) == 2:\n            nRows, nColumns = image.shape\n            nChannels = 1\n        elif len(image.shape) == 3:\n            nRows, nColumns, nChannels = image.shape\n        else:\n            raise RuntimeError(\"Image does not have the right shape\")\n        dtype = image.dtype\n        bitsPerSample = int(dtype.str[-1]) * 8\n\n        #only uncompressed data\n        compression = 1\n\n        #interpretation, black is zero\n        if nChannels == 1:\n            interpretation = 1\n            bitsPerSampleLength = 0\n        elif nChannels == 3:\n            interpretation = 2\n            bitsPerSampleLength = 3 * 2  # To store 3 shorts\n            nDirectoryEntries += 1  # For SamplesPerPixel\n        else:\n            raise RuntimeError(\n                \"Image with %d color channel(s) not supported\" % nChannels)\n\n        #image description\n        if imageDescription is not None:\n            descriptionLength = len(imageDescription)\n        else:\n            descriptionLength = 0\n\n        #strip offsets\n        #we are putting them after the directory and the directory is\n        #at the end of the file\n        self.fd.seek(0, os.SEEK_END)\n        endOfFile = self.fd.tell()\n        if endOfFile == 0:\n            #empty file\n            endOfFile = 8\n\n        #rows per strip\n        if ALLOW_MULTIPLE_STRIPS:\n            #try to segment the image in several pieces\n            if not (nRows % 4):\n                rowsPerStrip = int(nRows/4)\n            elif not (nRows % 10):\n                rowsPerStrip = int(nRows/10)\n            elif not (nRows % 8):\n                rowsPerStrip = int(nRows/8)\n            elif not (nRows % 4):\n                rowsPerStrip = int(nRows/4)\n            elif not (nRows % 2):\n                rowsPerStrip = int(nRows/2)\n            else:\n                rowsPerStrip = nRows\n        else:\n            rowsPerStrip = nRows\n\n        #stripByteCounts\n        stripByteCounts = int(nColumns * rowsPerStrip *\n                              bitsPerSample * nChannels / 8)\n\n        if descriptionLength > 4:\n            stripOffsets0 = endOfFile + dateLength + descriptionLength +\\\n                        2 + 12 * nDirectoryEntries + 4\n        else:\n            stripOffsets0 = endOfFile + dateLength + \\\n                        2 + 12 * nDirectoryEntries + 4\n\n        if softwareLength > 4:\n            stripOffsets0 += softwareLength\n\n        stripOffsets0 += bitsPerSampleLength\n\n        stripOffsets = [stripOffsets0]\n        stripOffsetsLength = 0\n        stripOffsetsString = None\n\n        st = self._structChar\n\n        if rowsPerStrip != nRows:\n            nStripOffsets = int(nRows/rowsPerStrip)\n            fmt = st + 'I'\n            stripOffsetsLength = struct.calcsize(fmt) * nStripOffsets\n            stripOffsets0 += stripOffsetsLength\n            #the length for the stripByteCounts will be the same\n            stripOffsets0 += stripOffsetsLength\n            stripOffsets = []\n            for i in range(nStripOffsets):\n                value = stripOffsets0 + i * stripByteCounts\n                stripOffsets.append(value)\n                if i == 0:\n                    stripOffsetsString  = struct.pack(fmt, value)\n                    stripByteCountsString = struct.pack(fmt, stripByteCounts)\n                else:\n                    stripOffsetsString += struct.pack(fmt, value)\n                    stripByteCountsString += struct.pack(fmt, stripByteCounts)\n\n        if DEBUG:\n            print(\"IMAGE WILL START AT %d\" % stripOffsets[0])\n\n        #sample format\n        if dtype in [numpy.float32, numpy.float64] or\\\n           dtype.str[-2] == 'f':\n            sampleFormat = SAMPLE_FORMAT_FLOAT\n        elif dtype in [numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64]:\n            sampleFormat = SAMPLE_FORMAT_UINT\n        elif dtype in [numpy.int8, numpy.int16, numpy.int32, numpy.int64]:\n            sampleFormat = SAMPLE_FORMAT_INT\n        else:\n            raise ValueError(\"Unsupported data type %s\" % dtype)\n\n        info = {}\n        info[\"nColumns\"] = nColumns\n        info[\"nRows\"] = nRows\n        info[\"nBits\"] = bitsPerSample\n        info[\"compression\"] = compression\n        info[\"photometricInterpretation\"] = interpretation\n        info[\"stripOffsets\"] = stripOffsets\n        if interpretation == 2:\n            info[\"samplesPerPixel\"] = 3  # No support for extra samples\n        info[\"rowsPerStrip\"] = rowsPerStrip\n        info[\"stripByteCounts\"] = stripByteCounts\n        info[\"date\"] = date\n        info[\"sampleFormat\"] = sampleFormat\n\n        outputIFD = \"\"\n        if sys.version > '2.6':\n            outputIFD = eval('b\"\"')\n\n        fmt = st + \"H\"\n        outputIFD += struct.pack(fmt, nDirectoryEntries)\n\n        fmt = st + \"HHII\"\n        outputIFD += struct.pack(fmt, TAG_NUMBER_OF_COLUMNS,\n                                         FIELD_TYPE_OUT['I'],\n                                         1,\n                                         info[\"nColumns\"])\n        outputIFD += struct.pack(fmt, TAG_NUMBER_OF_ROWS,\n                                         FIELD_TYPE_OUT['I'],\n                                         1,\n                                         info[\"nRows\"])\n\n        if info[\"photometricInterpretation\"] == 1:\n            fmt = st + 'HHIHH'\n            outputIFD += struct.pack(fmt, TAG_BITS_PER_SAMPLE,\n                                             FIELD_TYPE_OUT['H'],\n                                             1,\n                                             info[\"nBits\"], 0)\n        elif info[\"photometricInterpretation\"] == 2:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_BITS_PER_SAMPLE,\n                                             FIELD_TYPE_OUT['H'],\n                                             3,\n                                             info[\"stripOffsets\"][0] - \\\n                                             2 * stripOffsetsLength - \\\n                                             descriptionLength - \\\n                                             dateLength - \\\n                                             softwareLength - \\\n                                             bitsPerSampleLength)\n        else:\n            raise RuntimeError(\"Unsupported photometric interpretation\")\n\n        fmt = st + 'HHIHH'\n        outputIFD += struct.pack(fmt, TAG_COMPRESSION,\n                                         FIELD_TYPE_OUT['H'],\n                                         1,\n                                         info[\"compression\"],0)\n        fmt = st + 'HHIHH'\n        outputIFD += struct.pack(fmt, TAG_PHOTOMETRIC_INTERPRETATION,\n                                         FIELD_TYPE_OUT['H'],\n                                         1,\n                                         info[\"photometricInterpretation\"],0)\n\n        if imageDescription is not None:\n            descriptionLength = len(imageDescription)\n            if descriptionLength > 4:\n                fmt = st + 'HHII'\n                outputIFD += struct.pack(fmt, TAG_IMAGE_DESCRIPTION,\n                                         FIELD_TYPE_OUT['s'],\n                                         descriptionLength,\n                                         info[\"stripOffsets\"][0]-\\\n                                         2*stripOffsetsLength-\\\n                                         descriptionLength)\n            else:\n                #it has to have length 4\n                fmt = st + 'HHI%ds' % descriptionLength\n                outputIFD += struct.pack(fmt, TAG_IMAGE_DESCRIPTION,\n                                         FIELD_TYPE_OUT['s'],\n                                         descriptionLength,\n                                         description)\n\n        if len(stripOffsets) == 1:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_STRIP_OFFSETS,\n                                             FIELD_TYPE_OUT['I'],\n                                             1,\n                                             info[\"stripOffsets\"][0])\n        else:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_STRIP_OFFSETS,\n                                             FIELD_TYPE_OUT['I'],\n                                             len(stripOffsets),\n                    info[\"stripOffsets\"][0]-2*stripOffsetsLength)\n\n        if info[\"photometricInterpretation\"] == 2:\n            fmt = st + 'HHIHH'\n            outputIFD += struct.pack(fmt, TAG_SAMPLES_PER_PIXEL,\n                                             FIELD_TYPE_OUT['H'],\n                                             1,\n                                             info[\"samplesPerPixel\"], 0)\n\n        fmt = st + 'HHII'\n        outputIFD += struct.pack(fmt, TAG_ROWS_PER_STRIP,\n                                         FIELD_TYPE_OUT['I'],\n                                         1,\n                                         info[\"rowsPerStrip\"])\n\n        if len(stripOffsets) == 1:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_STRIP_BYTE_COUNTS,\n                                             FIELD_TYPE_OUT['I'],\n                                             1,\n                                             info[\"stripByteCounts\"])\n        else:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_STRIP_BYTE_COUNTS,\n                                             FIELD_TYPE_OUT['I'],\n                                             len(stripOffsets),\n                    info[\"stripOffsets\"][0]-stripOffsetsLength)\n\n        if software is not None:\n            if softwareLength > 4:\n                fmt = st + 'HHII'\n                outputIFD += struct.pack(fmt, TAG_SOFTWARE,\n                                         FIELD_TYPE_OUT['s'],\n                                         softwareLength,\n                                         info[\"stripOffsets\"][0]-\\\n                                         2*stripOffsetsLength-\\\n                            descriptionLength-softwareLength-dateLength)\n            else:\n                #it has to have length 4\n                fmt = st + 'HHI%ds' % softwareLength\n                outputIFD += struct.pack(fmt, TAG_SOFTWARE,\n                                         FIELD_TYPE_OUT['s'],\n                                         softwareLength,\n                                         softwarePackedString)\n\n        if date is not None:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_DATE,\n                                      FIELD_TYPE_OUT['s'],\n                                      dateLength,\n                                      info[\"stripOffsets\"][0]-\\\n                                         2*stripOffsetsLength-\\\n                                      descriptionLength-dateLength)\n\n        fmt = st + 'HHIHH'\n        outputIFD += struct.pack(fmt, TAG_SAMPLE_FORMAT,\n                                         FIELD_TYPE_OUT['H'],\n                                         1,\n                                         info[\"sampleFormat\"],0)\n        fmt = st + 'I'\n        outputIFD += struct.pack(fmt, 0)\n\n        if info[\"photometricInterpretation\"] == 2:\n            outputIFD += struct.pack('HHH', info[\"nBits\"],\n                                     info[\"nBits\"], info[\"nBits\"])\n\n        if softwareLength > 4:\n            outputIFD += softwarePackedString\n\n        if date is not None:\n            outputIFD += datePackedString\n\n        if imageDescription is not None:\n            if descriptionLength > 4:\n                outputIFD += imageDescription\n\n        if stripOffsetsString is not None:\n            outputIFD += stripOffsetsString\n            outputIFD += stripByteCountsString\n\n        return outputIFD",
  "def __init__(self, filename, mode=None, cache_length=20, mono_output=False):\n        if mode is None:\n            mode = 'rb'\n        if 'b' not in mode:\n            mode = mode + 'b'\n        if 'a' in mode.lower():\n            raise IOError(\"Mode %s makes no sense on TIFF files. Consider 'rb+'\" % mode)\n        if ('w' in mode):\n            if '+' not in mode:\n                mode += '+'\n\n        if hasattr(filename, \"seek\") and\\\n           hasattr(filename, \"read\"):\n            fd = filename\n            self._access = None\n        else:\n            #the b is needed for windows and python 3\n            fd = open(filename, mode)\n            self._access = mode\n\n        self._initInternalVariables(fd)\n        self._maxImageCacheLength = cache_length\n        self._forceMonoOutput = mono_output",
  "def _initInternalVariables(self, fd=None):\n        if fd is None:\n            fd = self.fd\n        else:\n            self.fd = fd\n        # read the order\n        fd.seek(0)\n        order = fd.read(2).decode()\n        if len(order):\n            if order == \"II\":\n                #intel, little endian\n                fileOrder = \"little\"\n                self._structChar = '<'\n            elif order == \"MM\":\n                #motorola, high endian\n                fileOrder = \"big\"\n                self._structChar = '>'\n            else:\n                raise IOError(\"File is not a Mar CCD file, nor a TIFF file\")\n            a = fd.read(2)\n            fortyTwo = struct.unpack(self._structChar+\"H\",a)[0]\n            if fortyTwo != 42:\n                raise IOError(\"Invalid TIFF version %d\" % fortyTwo)\n            else:\n                if DEBUG:\n                    print(\"VALID TIFF VERSION\")\n            if sys.byteorder != fileOrder:\n                swap = True\n            else:\n                swap = False\n        else:\n            if sys.byteorder == \"little\":\n                self._structChar = '<'\n            else:\n                self._structChar = '>'\n            swap = False\n        self._swap = swap\n        self._IFD = []\n        self._imageDataCacheIndex = []\n        self._imageDataCache  = []\n        self._imageInfoCacheIndex  = []\n        self._imageInfoCache  = []\n        self.getImageFileDirectories(fd)",
  "def __makeSureFileIsOpen(self):\n        if not self.fd.closed:\n            return\n        if DEBUG:\n            print(\"Reopening closed file\")\n        fileName = self.fd.name\n        if self._access is None:\n            #we do not own the file\n            #open in read mode\n            newFile = open(fileName,'rb')\n        else:\n            newFile = open(fileName, self._access)\n        self.fd  = newFile",
  "def __makeSureFileIsClosed(self):\n        if self._access is None:\n            #we do not own the file\n            if DEBUG:\n                print(\"Not closing not owned file\")\n            return\n\n        if not self.fd.closed:\n            self.fd.close()",
  "def close(self):\n        return self.__makeSureFileIsClosed()",
  "def getNumberOfImages(self):\n        #update for the case someone has done anything?\n        self._updateIFD()\n        return len(self._IFD)",
  "def _updateIFD(self):\n        self.__makeSureFileIsOpen()\n        self.getImageFileDirectories()\n        self.__makeSureFileIsClosed()",
  "def getImageFileDirectories(self, fd=None):\n        if fd is None:\n            fd = self.fd\n        else:\n            self.fd = fd\n        st = self._structChar\n        fd.seek(4)\n        self._IFD = []\n        nImages = 0\n        fmt = st + 'I'\n        inStr = fd.read(struct.calcsize(fmt))\n        if not len(inStr):\n            offsetToIFD = 0\n        else:\n            offsetToIFD = struct.unpack(fmt, inStr)[0]\n        if DEBUG:\n            print(\"Offset to first IFD = %d\" % offsetToIFD)\n        while offsetToIFD != 0:\n            self._IFD.append(offsetToIFD)\n            nImages += 1\n            fd.seek(offsetToIFD)\n            fmt = st + 'H'\n            numberOfDirectoryEntries = struct.unpack(fmt,fd.read(struct.calcsize(fmt)))[0]\n            if DEBUG:\n                print(\"Number of directory entries = %d\" % numberOfDirectoryEntries)\n\n            fmt = st + 'I'\n            fd.seek(offsetToIFD + 2 + 12 * numberOfDirectoryEntries)\n            offsetToIFD = struct.unpack(fmt,fd.read(struct.calcsize(fmt)))[0]\n            if DEBUG:\n                print(\"Next Offset to IFD = %d\" % offsetToIFD)\n            #offsetToIFD = 0\n        if DEBUG:\n            print(\"Number of images found = %d\" % nImages)\n        return nImages",
  "def _parseImageFileDirectory(self, nImage):\n        offsetToIFD = self._IFD[nImage]\n        st = self._structChar\n        fd = self.fd\n        fd.seek(offsetToIFD)\n        fmt = st + 'H'\n        numberOfDirectoryEntries = struct.unpack(fmt,fd.read(struct.calcsize(fmt)))[0]\n        if DEBUG:\n            print(\"Number of directory entries = %d\" % numberOfDirectoryEntries)\n\n        fmt = st + 'HHI4s'\n        tagIDList = []\n        fieldTypeList = []\n        nValuesList = []\n        valueOffsetList = []\n        for i in range(numberOfDirectoryEntries):\n            tagID, fieldType, nValues, valueOffset = struct.unpack(fmt, fd.read(12))\n            tagIDList.append(tagID)\n            fieldTypeList.append(fieldType)\n            nValuesList.append(nValues)\n            if nValues == 1:\n                ftype, vfmt = FIELD_TYPE[fieldType]\n                if ftype not in ['ASCII', 'RATIONAL', 'SRATIONAL']:\n                    vfmt = st + vfmt\n                    actualValue = struct.unpack(vfmt, valueOffset[0: struct.calcsize(vfmt)])[0]\n                    valueOffsetList.append(actualValue)\n                else:\n                    valueOffsetList.append(valueOffset)\n            elif (nValues < 5) and (fieldType == 2):\n                ftype, vfmt = FIELD_TYPE[fieldType]\n                vfmt = st + \"%d%s\" % (nValues,vfmt)\n                actualValue = struct.unpack(vfmt, valueOffset[0: struct.calcsize(vfmt)])[0]\n                valueOffsetList.append(actualValue)\n            else:\n                valueOffsetList.append(valueOffset)\n            if DEBUG:\n                if tagID in TAG_ID:\n                    print(\"tagID = %s\" % TAG_ID[tagID])\n                else:\n                    print(\"tagID        = %d\" % tagID)\n                print(\"fieldType    = %s\" % FIELD_TYPE[fieldType][0])\n                print(\"nValues      = %d\" % nValues)\n                #if nValues == 1:\n                #    print(\"valueOffset =  %s\" % valueOffset)\n        return tagIDList, fieldTypeList, nValuesList, valueOffsetList",
  "def _readIFDEntry(self, tag, tagIDList, fieldTypeList, nValuesList, valueOffsetList):\n        fd = self.fd\n        st = self._structChar\n        idx = tagIDList.index(tag)\n        nValues = nValuesList[idx]\n        output = []\n        ftype, vfmt = FIELD_TYPE[fieldTypeList[idx]]\n        vfmt = st + \"%d%s\" % (nValues, vfmt)\n        requestedBytes = struct.calcsize(vfmt)\n        if nValues ==  1:\n            output.append(valueOffsetList[idx])\n        elif requestedBytes < 5:\n            output.append(valueOffsetList[idx])\n        else:\n            fd.seek(struct.unpack(st+\"I\", valueOffsetList[idx])[0])\n            output = struct.unpack(vfmt, fd.read(requestedBytes))\n        return output",
  "def getData(self, nImage, **kw):\n        if nImage >= len(self._IFD):\n            #update prior to raise an index error error\n            self._updateIFD()\n        return self._readImage(nImage, **kw)",
  "def getImage(self, nImage):\n        return self.getData(nImage)",
  "def getInfo(self, nImage, **kw):\n        if nImage >= len(self._IFD):\n            #update prior to raise an index error error\n            self._updateIFD()\n        # current = self._IFD[nImage]\n        return self._readInfo(nImage)",
  "def _readInfo(self, nImage, close=True):\n        if nImage in self._imageInfoCacheIndex:\n            if DEBUG:\n                print(\"Reading info from cache\")\n            return self._imageInfoCache[self._imageInfoCacheIndex.index(nImage)]\n\n        #read the header\n        self.__makeSureFileIsOpen()\n        tagIDList, fieldTypeList, nValuesList, valueOffsetList = self._parseImageFileDirectory(nImage)\n\n        #rows and columns\n        nColumns = valueOffsetList[tagIDList.index(TAG_NUMBER_OF_COLUMNS)]\n        nRows    = valueOffsetList[tagIDList.index(TAG_NUMBER_OF_ROWS)]\n\n        #bits per sample\n        idx = tagIDList.index(TAG_BITS_PER_SAMPLE)\n        nBits = valueOffsetList[idx]\n        if nValuesList[idx] != 1:\n            #this happens with RGB and friends, nBits is not a single value\n            nBits = self._readIFDEntry(TAG_BITS_PER_SAMPLE,\n                                          tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n\n\n        if TAG_COLORMAP in tagIDList:\n            idx = tagIDList.index(TAG_COLORMAP)\n            tmpColormap = self._readIFDEntry(TAG_COLORMAP,\n                                          tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n            if max(tmpColormap) > 255:\n                tmpColormap = numpy.array(tmpColormap, dtype=numpy.uint16)\n                tmpColormap = (tmpColormap/256.).astype(numpy.uint8)\n            else:\n                tmpColormap = numpy.array(tmpColormap, dtype=numpy.uint8)\n            tmpColormap.shape = 3, -1\n            colormap = numpy.zeros((tmpColormap.shape[-1], 3), tmpColormap.dtype)\n            colormap[:,:] = tmpColormap.T\n            tmpColormap = None\n        else:\n            colormap = None\n\n        #sample format\n        if TAG_SAMPLE_FORMAT in tagIDList:\n            sampleFormat = valueOffsetList[tagIDList.index(TAG_SAMPLE_FORMAT)]\n        else:\n            #set to unknown\n            sampleFormat = SAMPLE_FORMAT_VOID\n\n        # compression\n        compression = False\n        compression_type = 1\n        if TAG_COMPRESSION in tagIDList:\n            compression_type = valueOffsetList[tagIDList.index(TAG_COMPRESSION)]\n            if compression_type == 1:\n                compression = False\n            else:\n                compression = True\n\n        #photometric interpretation\n        interpretation = 1\n        if TAG_PHOTOMETRIC_INTERPRETATION in tagIDList:\n            interpretation = valueOffsetList[tagIDList.index(TAG_PHOTOMETRIC_INTERPRETATION)]\n        else:\n            print(\"WARNING: Non standard TIFF. Photometric interpretation TAG missing\")\n        helpString = \"\"\n        if sys.version > '2.6':\n            helpString = eval('b\"\"')\n\n        if TAG_IMAGE_DESCRIPTION in tagIDList:\n            imageDescription = self._readIFDEntry(TAG_IMAGE_DESCRIPTION,\n                    tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n            if type(imageDescription) in [type([1]), type((1,))]:\n                imageDescription =helpString.join(imageDescription)\n        else:\n            imageDescription = \"%d/%d\" % (nImage+1, len(self._IFD))\n\n        if sys.version < '3.0':\n            defaultSoftware = \"Unknown Software\"\n        else:\n            defaultSoftware = bytes(\"Unknown Software\",\n                                    encoding='utf-8')\n        if TAG_SOFTWARE in tagIDList:\n            software = self._readIFDEntry(TAG_SOFTWARE,\n                    tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n            if type(software) in [type([1]), type((1,))]:\n                software =helpString.join(software)\n        else:\n            software = defaultSoftware\n\n        if software == defaultSoftware:\n            try:\n                if sys.version < '3.0':\n                    if imageDescription.upper().startswith(\"IMAGEJ\"):\n                        software = imageDescription.split(\"=\")[0]\n                else:\n                    tmpString = imageDescription.decode()\n                    if tmpString.upper().startswith(\"IMAGEJ\"):\n                        software = bytes(tmpString.split(\"=\")[0],\n                                         encoding='utf-8')\n            except:\n                pass\n\n        if TAG_DATE in tagIDList:\n            date = self._readIFDEntry(TAG_DATE,\n                    tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n            if type(date) in [type([1]), type((1,))]:\n                date =helpString.join(date)\n        else:\n            date = \"Unknown Date\"\n\n        stripOffsets = self._readIFDEntry(TAG_STRIP_OFFSETS,\n                        tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n        if TAG_ROWS_PER_STRIP in tagIDList:\n            rowsPerStrip = self._readIFDEntry(TAG_ROWS_PER_STRIP,\n                        tagIDList, fieldTypeList, nValuesList, valueOffsetList)[0]\n        else:\n            rowsPerStrip = nRows\n            print(\"WARNING: Non standard TIFF. Rows per strip TAG missing\")\n\n        if TAG_STRIP_BYTE_COUNTS in tagIDList:\n            stripByteCounts = self._readIFDEntry(TAG_STRIP_BYTE_COUNTS,\n                        tagIDList, fieldTypeList, nValuesList, valueOffsetList)\n        else:\n            print(\"WARNING: Non standard TIFF. Strip byte counts TAG missing\")\n            if hasattr(nBits, 'index'):\n                expectedSum = 0\n                for n in nBits:\n                    expectedSum += int(nRows * nColumns * n / 8)\n            else:\n                expectedSum = int(nRows * nColumns * nBits / 8)\n            stripByteCounts = [expectedSum]\n\n        if close:\n            self.__makeSureFileIsClosed()\n\n        if self._forceMonoOutput and (interpretation > 1):\n            #color image but asked monochrome output\n            nBits = 32\n            colormap = None\n            sampleFormat = SAMPLE_FORMAT_FLOAT\n            interpretation = 1\n            #we cannot rely on any cache in this case\n            useInfoCache = False\n            if DEBUG:\n                print(\"FORCED MONO\")\n        else:\n            useInfoCache = True\n\n        info = {}\n        info[\"nRows\"] = nRows\n        info[\"nColumns\"] = nColumns\n        info[\"nBits\"] = nBits\n        info[\"compression\"] = compression\n        info[\"compression_type\"] = compression_type\n        info[\"imageDescription\"] = imageDescription\n        info[\"stripOffsets\"] = stripOffsets #This contains the file offsets to the data positions\n        info[\"rowsPerStrip\"] = rowsPerStrip\n        info[\"stripByteCounts\"] = stripByteCounts #bytes in strip since I do not support compression\n        info[\"software\"] = software\n        info[\"date\"] = date\n        info[\"colormap\"] = colormap\n        info[\"sampleFormat\"] = sampleFormat\n        info[\"photometricInterpretation\"] = interpretation\n        infoDict = {}\n        if sys.version < '3.0':\n            testString = 'PyMca'\n        else:\n            testString = eval('b\"PyMca\"')\n        if software.startswith(testString):\n            #str to make sure python 2.x sees it as string and not unicode\n            if sys.version < '3.0':\n                descriptionString = imageDescription\n            else:\n                descriptionString = str(imageDescription.decode())\n            #interpret the image description in terms of supplied\n            #information at writing time\n            items = descriptionString.split('=')\n            for i in range(int(len(items)/2)):\n                key = \"%s\" % items[i*2]\n                #get rid of the \\n at the end of the value\n                value = \"%s\" % items[i*2+1][:-1]\n                infoDict[key] = value\n        info['info'] = infoDict\n\n        if (self._maxImageCacheLength > 0) and useInfoCache:\n            self._imageInfoCacheIndex.insert(0,nImage)\n            self._imageInfoCache.insert(0, info)\n            if len(self._imageInfoCacheIndex) > self._maxImageCacheLength:\n                self._imageInfoCacheIndex = self._imageInfoCacheIndex[:self._maxImageCacheLength]\n                self._imageInfoCache = self._imageInfoCache[:self._maxImageCacheLength]\n        return info",
  "def _readImage(self, nImage, **kw):\n        if DEBUG:\n            print(\"Reading image %d\" % nImage)\n        if 'close' in kw:\n            close = kw['close']\n        else:\n            close = True\n        rowMin = kw.get('rowMin', None)\n        rowMax = kw.get('rowMax', None)\n        if nImage in self._imageDataCacheIndex:\n            if DEBUG:\n                print(\"Reading image data from cache\")\n            return self._imageDataCache[self._imageDataCacheIndex.index(nImage)]\n\n        self.__makeSureFileIsOpen()\n        if self._forceMonoOutput:\n            oldMono = True\n        else:\n            oldMono = False\n        try:\n            self._forceMonoOutput = False\n            info = self._readInfo(nImage, close=False)\n            self._forceMonoOutput = oldMono\n        except:\n            self._forceMonoOutput = oldMono\n            raise\n        compression = info['compression']\n        compression_type = info['compression_type']\n        if compression:\n            if compression_type != 32773:\n                raise IOError(\"Compressed TIFF images not supported except packbits\")\n            else:\n                #PackBits compression\n                if DEBUG:\n                    print(\"Using PackBits compression\")\n\n        interpretation = info[\"photometricInterpretation\"]\n        if interpretation == 2:\n            #RGB\n            pass\n            #raise IOError(\"RGB Image. Only grayscale images supported\")\n        elif interpretation == 3:\n            #Palette Color Image\n            pass\n            #raise IOError(\"Palette-color Image. Only grayscale images supported\")\n        elif interpretation > 2:\n            #Palette Color Image\n            raise IOError(\"Only grayscale images supported\")\n\n        nRows    = info[\"nRows\"]\n        nColumns = info[\"nColumns\"]\n        nBits    = info[\"nBits\"]\n        colormap = info[\"colormap\"]\n        sampleFormat = info[\"sampleFormat\"]\n\n        if rowMin is None:\n            rowMin = 0\n\n        if rowMax is None:\n            rowMax = nRows - 1\n\n        if rowMin < 0:\n            rowMin = nRows - rowMin\n\n        if rowMax < 0:\n            rowMax = nRows - rowMax\n\n        if rowMax < rowMin:\n            txt = \"Max Row smaller than Min Row. Reverse selection not supported\"\n            raise NotImplemented(txt)\n\n        if rowMin >= nRows:\n            raise IndexError(\"Image only has %d rows\" % nRows)\n\n        if rowMax >= nRows:\n            raise IndexError(\"Image only has %d rows\" % nRows)\n\n        if sampleFormat == SAMPLE_FORMAT_FLOAT:\n            if nBits == 32:\n                dtype = numpy.float32\n            elif nBits == 64:\n                dtype = numpy.float64\n            else:\n                raise ValueError(\"Unsupported number of bits for a float: %d\" % nBits)\n        elif sampleFormat in [SAMPLE_FORMAT_UINT, SAMPLE_FORMAT_VOID]:\n            if nBits in [8, (8, 8, 8), [8, 8, 8]]:\n                dtype = numpy.uint8\n            elif nBits in [16, (16, 16, 16), [16, 16, 16]]:\n                dtype = numpy.uint16\n            elif nBits in [32, (32, 32, 32), [32, 32, 32]]:\n                dtype = numpy.uint32\n            elif nBits in [64, (64, 64, 64), [64, 64, 64]]:\n                dtype = numpy.uint64\n            else:\n                raise ValueError(\"Unsupported number of bits for unsigned int: %s\" % (nBits,))\n        elif sampleFormat == SAMPLE_FORMAT_INT:\n            if nBits in [8, (8, 8, 8), [8, 8, 8]]:\n                dtype = numpy.int8\n            elif nBits in [16, (16, 16, 16), [16, 16, 16]]:\n                dtype = numpy.int16\n            elif nBits in [32, (32, 32, 32), [32, 32, 32]]:\n                dtype = numpy.int32\n            elif nBits in [64, (64, 64, 64), [64, 64, 64]]:\n                dtype = numpy.int64\n            else:\n                raise ValueError(\"Unsupported number of bits for signed int: %s\" % (nBits,))\n        else:\n            raise ValueError(\"Unsupported combination. Bits = %s  Format = %d\" % (nBits, sampleFormat))\n        if hasattr(nBits, 'index'):\n            image = numpy.zeros((nRows, nColumns, len(nBits)), dtype=dtype)\n        elif colormap is not None:\n            #should I use colormap dtype?\n            image = numpy.zeros((nRows, nColumns, 3), dtype=dtype)\n        else:\n            image = numpy.zeros((nRows, nColumns), dtype=dtype)\n\n        fd = self.fd\n        st = self._structChar\n        stripOffsets = info[\"stripOffsets\"] #This contains the file offsets to the data positions\n        rowsPerStrip = info[\"rowsPerStrip\"]\n        stripByteCounts = info[\"stripByteCounts\"] #bytes in strip since I do not support compression\n\n        rowStart = 0\n        if len(stripOffsets) == 1:\n            bytesPerRow = int(stripByteCounts[0]/rowsPerStrip)\n            if nRows == rowsPerStrip:\n                actualBytesPerRow = int(image.nbytes/nRows)\n                if actualBytesPerRow != bytesPerRow:\n                    print(\"Warning: Bogus StripByteCounts information\")\n                    bytesPerRow = actualBytesPerRow \n            fd.seek(stripOffsets[0] + rowMin * bytesPerRow)\n            nBytes = (rowMax-rowMin+1) * bytesPerRow\n            if self._swap:\n                readout = numpy.fromstring(fd.read(nBytes), dtype).byteswap()\n            else:\n                readout = numpy.fromstring(fd.read(nBytes), dtype)\n            if hasattr(nBits, 'index'):\n                readout.shape = -1, nColumns, len(nBits)\n            elif info['colormap'] is not None:\n                readout = colormap[readout]\n            else:\n                readout.shape = -1, nColumns\n            image[rowMin:rowMax+1, :] = readout\n        else:\n            for i in range(len(stripOffsets)):\n                #the amount of rows\n                nRowsToRead = rowsPerStrip\n                rowEnd = int(min(rowStart+nRowsToRead, nRows))\n                if rowEnd < rowMin:\n                    rowStart += nRowsToRead\n                    continue\n                if (rowStart > rowMax):\n                    break\n                #we are in position\n                fd.seek(stripOffsets[i])\n                #the amount of bytes to read\n                nBytes = stripByteCounts[i]\n                if compression_type == 32773:\n                    try:\n                        bufferBytes = bytes()\n                    except:\n                        #python 2.5 ...\n                        bufferBytes = \"\"\n                    #packBits\n                    readBytes = 0\n                    #intermediate buffer\n                    tmpBuffer = fd.read(nBytes)\n                    while readBytes < nBytes:\n                        n = struct.unpack('b', tmpBuffer[readBytes:(readBytes+1)])[0]\n                        readBytes += 1\n                        if n >= 0:\n                            #should I prevent reading more than the\n                            #length of the chain? Let's python raise\n                            #the exception...\n                            bufferBytes +=  tmpBuffer[readBytes:\\\n                                                      readBytes+(n+1)]\n                            readBytes += (n+1)\n                        elif n > -128:\n                            bufferBytes += (-n+1) * tmpBuffer[readBytes:(readBytes+1)]\n                            readBytes += 1\n                        else:\n                            #if read -128 ignore the byte\n                            continue\n                    if self._swap:\n                        readout = numpy.fromstring(bufferBytes, dtype).byteswap()\n                    else:\n                        readout = numpy.fromstring(bufferBytes, dtype)\n                    if hasattr(nBits, 'index'):\n                        readout.shape = -1, nColumns, len(nBits)\n                    elif info['colormap'] is not None:\n                        readout = colormap[readout]\n                        readout.shape = -1, nColumns, 3\n                    else:\n                        readout.shape = -1, nColumns\n                    image[rowStart:rowEnd, :] = readout\n                else:\n                    if 1:\n                        #use numpy\n                        if self._swap:\n                            readout = numpy.fromstring(fd.read(nBytes), dtype).byteswap()\n                        else:\n                            readout = numpy.fromstring(fd.read(nBytes), dtype)\n                        if hasattr(nBits, 'index'):\n                            readout.shape = -1, nColumns, len(nBits)\n                        elif colormap is not None:\n                            readout = colormap[readout]\n                            readout.shape = -1, nColumns, 3\n                        else:\n                            readout.shape = -1, nColumns\n                        image[rowStart:rowEnd, :] = readout\n                    else:\n                        #using struct\n                        readout = numpy.array(struct.unpack(st+\"%df\" % int(nBytes/4), fd.read(nBytes)),\n                                              dtype=dtype)\n                        if hasattr(nBits, 'index'):\n                            readout.shape = -1, nColumns, len(nBits)\n                        elif colormap is not None:\n                            readout = colormap[readout]\n                            readout.shape = -1, nColumns, 3\n                        else:\n                            readout.shape = -1, nColumns\n                        image[rowStart:rowEnd, :] = readout\n                rowStart += nRowsToRead\n        if close:\n            self.__makeSureFileIsClosed()\n\n        if len(image.shape) == 3:\n            #color image\n            if self._forceMonoOutput:\n                #color image, convert to monochrome\n                image = (image[:,:,0] * 0.114 +\\\n                         image[:,:,1] * 0.587 +\\\n                         image[:,:,2] * 0.299).astype(numpy.float32)\n\n        if (rowMin == 0) and (rowMax == (nRows-1)):\n            self._imageDataCacheIndex.insert(0,nImage)\n            self._imageDataCache.insert(0, image)\n            if len(self._imageDataCacheIndex) > self._maxImageCacheLength:\n                self._imageDataCacheIndex = self._imageDataCacheIndex[:self._maxImageCacheLength]\n                self._imageDataCache = self._imageDataCache[:self._maxImageCacheLength]\n\n        return image",
  "def writeImage(self, image0, info=None, software=None, date=None):\n        if software is None:\n            software = 'PyMca.TiffIO'\n        #if date is None:\n        #    date = time.ctime()\n\n        self.__makeSureFileIsOpen()\n        fd = self.fd\n        #prior to do anything, perform some tests\n        if not len(image0.shape):\n            raise ValueError(\"Empty image\")\n        if len(image0.shape) == 1:\n            #get a different view\n            image = image0[:]\n            image.shape = 1, -1\n        else:\n            image = image0\n\n        if image.dtype == numpy.float64:\n            image = image.astype(numpy.float32)\n        fd.seek(0)\n        mode = fd.mode\n        name = fd.name\n        if 'w' in mode:\n            #we have to overwrite the file\n            self.__makeSureFileIsClosed()\n            fd = None\n            if os.path.exists(name):\n                os.remove(name)\n            fd = open(name, mode='wb+')\n            self._initEmptyFile(fd)\n        self.fd = fd\n\n        #read the file size\n        self.__makeSureFileIsOpen()\n        fd = self.fd\n        fd.seek(0, os.SEEK_END)\n        endOfFile = fd.tell()\n        if fd.tell() == 0:\n            self._initEmptyFile(fd)\n            fd.seek(0, os.SEEK_END)\n            endOfFile = fd.tell()\n\n        #init internal variables\n        self._initInternalVariables(fd)\n        st = self._structChar\n\n        #get the image file directories\n        nImages = self.getImageFileDirectories()\n        if DEBUG:\n            print(\"File contains %d images\" % nImages)\n        if nImages == 0:\n            fd.seek(4)\n            fmt = st + 'I'\n            fd.write(struct.pack(fmt, endOfFile))\n        else:\n            fd.seek(self._IFD[-1])\n            fmt = st + 'H'\n            numberOfDirectoryEntries = struct.unpack(fmt,fd.read(struct.calcsize(fmt)))[0]\n            fmt = st + 'I'\n            pos = self._IFD[-1] + 2 + 12 * numberOfDirectoryEntries\n            fd.seek(pos)\n            fmt = st + 'I'\n            fd.write(struct.pack(fmt, endOfFile))\n        fd.flush()\n\n        #and we can write at the end of the file, find out the file length\n        fd.seek(0, os.SEEK_END)\n\n        #get the description information from the input information\n        if info is None:\n            description = info\n        else:\n            description = \"%s\" % \"\"\n            for key in info.keys():\n                description += \"%s=%s\\n\"  % (key, info[key])\n\n        #get the image file directory\n        outputIFD = self._getOutputIFD(image, description=description,\n                                              software=software,\n                                              date=date)\n\n        #write the new IFD\n        fd.write(outputIFD)\n\n        #write the image\n        if self._swap:\n            fd.write(image.byteswap().tostring())\n        else:\n            fd.write(image.tostring())\n\n        fd.flush()\n        self.fd=fd\n        self.__makeSureFileIsClosed()",
  "def _initEmptyFile(self, fd=None):\n        if fd is None:\n            fd = self.fd\n        if sys.byteorder == \"little\":\n            order = \"II\"\n            #intel, little endian\n            fileOrder = \"little\"\n            self._structChar = '<'\n        else:\n            order = \"MM\"\n            #motorola, high endian\n            fileOrder = \"big\"\n            self._structChar = '>'\n        st = self._structChar\n        if fileOrder == sys.byteorder:\n            self._swap = False\n        else:\n            self._swap = True\n        fd.seek(0)\n        if sys.version < '3.0':\n            fd.write(struct.pack(st+'2s', order))\n            fd.write(struct.pack(st+'H', 42))\n            fd.write(struct.pack(st+'I', 0))\n        else:\n            fd.write(struct.pack(st+'2s', bytes(order,'utf-8')))\n            fd.write(struct.pack(st+'H', 42))\n            fd.write(struct.pack(st+'I', 0))\n        fd.flush()",
  "def _getOutputIFD(self, image, description=None, software=None, date=None):\n        #the tags have to be in order\n        #the very minimum is\n        #256:\"NumberOfColumns\",           # S or L ImageWidth\n        #257:\"NumberOfRows\",              # S or L ImageHeight\n        #258:\"BitsPerSample\",             # S Number of bits per component\n        #259:\"Compression\",               # SHORT (1 - NoCompression, ...\n        #262:\"PhotometricInterpretation\", # SHORT (0 - WhiteIsZero, 1 -BlackIsZero, 2 - RGB, 3 - Palette color\n        #270:\"ImageDescription\",          # ASCII\n        #273:\"StripOffsets\",              # S or L, for each strip, the byte offset of the strip\n        #277:\"SamplesPerPixel\",           # SHORT (>=3) only for RGB images\n        #278:\"RowsPerStrip\",              # S or L, number of rows in each back may be not for the last\n        #279:\"StripByteCounts\",           # S or L, The number of bytes in the strip AFTER any compression\n        #305:\"Software\",                  # ASCII\n        #306:\"Date\",                      # ASCII\n        #339:\"SampleFormat\",              # SHORT Interpretation of data in each pixel\n\n        nDirectoryEntries = 9\n        imageDescription = None\n        if description is not None:\n            descriptionLength = len(description)\n            while descriptionLength < 4:\n                description = description + \" \"\n                descriptionLength = len(description)\n            if sys.version >= '3.0':\n                description = bytes(description, 'utf-8')\n            elif type(description) != type(\"\"):\n                try:\n                    description = description.decode('utf-8')\n                except UnicodeDecodeError:\n                    try:\n                        description = description.decode('latin-1')\n                    except UnicodeDecodeError:\n                        description = \"%s\" % description\n                if sys.version > '2.6':\n                    description=description.encode('utf-8', errors=\"ignore\")\n                description = \"%s\" % description\n            descriptionLength = len(description)\n            imageDescription = struct.pack(\"%ds\" % descriptionLength, description)\n            nDirectoryEntries += 1\n\n        #software\n        if software is not None:\n            softwareLength = len(software)\n            while softwareLength < 4:\n                software = software + \" \"\n                softwareLength = len(software)\n            if sys.version >= '3.0':\n                software = bytes(software, 'utf-8')\n            softwarePackedString = struct.pack(\"%ds\" % softwareLength, software)\n            nDirectoryEntries += 1\n        else:\n            softwareLength = 0\n\n        if date is not None:\n            dateLength = len(date)\n            if sys.version >= '3.0':\n                date = bytes(date, 'utf-8')\n            datePackedString = struct.pack(\"%ds\" % dateLength, date)\n            dateLength = len(datePackedString)\n            nDirectoryEntries += 1\n        else:\n            dateLength = 0\n\n        if len(image.shape) == 2:\n            nRows, nColumns = image.shape\n            nChannels = 1\n        elif len(image.shape) == 3:\n            nRows, nColumns, nChannels = image.shape\n        else:\n            raise RuntimeError(\"Image does not have the right shape\")\n        dtype = image.dtype\n        bitsPerSample = int(dtype.str[-1]) * 8\n\n        #only uncompressed data\n        compression = 1\n\n        #interpretation, black is zero\n        if nChannels == 1:\n            interpretation = 1\n            bitsPerSampleLength = 0\n        elif nChannels == 3:\n            interpretation = 2\n            bitsPerSampleLength = 3 * 2  # To store 3 shorts\n            nDirectoryEntries += 1  # For SamplesPerPixel\n        else:\n            raise RuntimeError(\n                \"Image with %d color channel(s) not supported\" % nChannels)\n\n        #image description\n        if imageDescription is not None:\n            descriptionLength = len(imageDescription)\n        else:\n            descriptionLength = 0\n\n        #strip offsets\n        #we are putting them after the directory and the directory is\n        #at the end of the file\n        self.fd.seek(0, os.SEEK_END)\n        endOfFile = self.fd.tell()\n        if endOfFile == 0:\n            #empty file\n            endOfFile = 8\n\n        #rows per strip\n        if ALLOW_MULTIPLE_STRIPS:\n            #try to segment the image in several pieces\n            if not (nRows % 4):\n                rowsPerStrip = int(nRows/4)\n            elif not (nRows % 10):\n                rowsPerStrip = int(nRows/10)\n            elif not (nRows % 8):\n                rowsPerStrip = int(nRows/8)\n            elif not (nRows % 4):\n                rowsPerStrip = int(nRows/4)\n            elif not (nRows % 2):\n                rowsPerStrip = int(nRows/2)\n            else:\n                rowsPerStrip = nRows\n        else:\n            rowsPerStrip = nRows\n\n        #stripByteCounts\n        stripByteCounts = int(nColumns * rowsPerStrip *\n                              bitsPerSample * nChannels / 8)\n\n        if descriptionLength > 4:\n            stripOffsets0 = endOfFile + dateLength + descriptionLength +\\\n                        2 + 12 * nDirectoryEntries + 4\n        else:\n            stripOffsets0 = endOfFile + dateLength + \\\n                        2 + 12 * nDirectoryEntries + 4\n\n        if softwareLength > 4:\n            stripOffsets0 += softwareLength\n\n        stripOffsets0 += bitsPerSampleLength\n\n        stripOffsets = [stripOffsets0]\n        stripOffsetsLength = 0\n        stripOffsetsString = None\n\n        st = self._structChar\n\n        if rowsPerStrip != nRows:\n            nStripOffsets = int(nRows/rowsPerStrip)\n            fmt = st + 'I'\n            stripOffsetsLength = struct.calcsize(fmt) * nStripOffsets\n            stripOffsets0 += stripOffsetsLength\n            #the length for the stripByteCounts will be the same\n            stripOffsets0 += stripOffsetsLength\n            stripOffsets = []\n            for i in range(nStripOffsets):\n                value = stripOffsets0 + i * stripByteCounts\n                stripOffsets.append(value)\n                if i == 0:\n                    stripOffsetsString  = struct.pack(fmt, value)\n                    stripByteCountsString = struct.pack(fmt, stripByteCounts)\n                else:\n                    stripOffsetsString += struct.pack(fmt, value)\n                    stripByteCountsString += struct.pack(fmt, stripByteCounts)\n\n        if DEBUG:\n            print(\"IMAGE WILL START AT %d\" % stripOffsets[0])\n\n        #sample format\n        if dtype in [numpy.float32, numpy.float64] or\\\n           dtype.str[-2] == 'f':\n            sampleFormat = SAMPLE_FORMAT_FLOAT\n        elif dtype in [numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64]:\n            sampleFormat = SAMPLE_FORMAT_UINT\n        elif dtype in [numpy.int8, numpy.int16, numpy.int32, numpy.int64]:\n            sampleFormat = SAMPLE_FORMAT_INT\n        else:\n            raise ValueError(\"Unsupported data type %s\" % dtype)\n\n        info = {}\n        info[\"nColumns\"] = nColumns\n        info[\"nRows\"] = nRows\n        info[\"nBits\"] = bitsPerSample\n        info[\"compression\"] = compression\n        info[\"photometricInterpretation\"] = interpretation\n        info[\"stripOffsets\"] = stripOffsets\n        if interpretation == 2:\n            info[\"samplesPerPixel\"] = 3  # No support for extra samples\n        info[\"rowsPerStrip\"] = rowsPerStrip\n        info[\"stripByteCounts\"] = stripByteCounts\n        info[\"date\"] = date\n        info[\"sampleFormat\"] = sampleFormat\n\n        outputIFD = \"\"\n        if sys.version > '2.6':\n            outputIFD = eval('b\"\"')\n\n        fmt = st + \"H\"\n        outputIFD += struct.pack(fmt, nDirectoryEntries)\n\n        fmt = st + \"HHII\"\n        outputIFD += struct.pack(fmt, TAG_NUMBER_OF_COLUMNS,\n                                         FIELD_TYPE_OUT['I'],\n                                         1,\n                                         info[\"nColumns\"])\n        outputIFD += struct.pack(fmt, TAG_NUMBER_OF_ROWS,\n                                         FIELD_TYPE_OUT['I'],\n                                         1,\n                                         info[\"nRows\"])\n\n        if info[\"photometricInterpretation\"] == 1:\n            fmt = st + 'HHIHH'\n            outputIFD += struct.pack(fmt, TAG_BITS_PER_SAMPLE,\n                                             FIELD_TYPE_OUT['H'],\n                                             1,\n                                             info[\"nBits\"], 0)\n        elif info[\"photometricInterpretation\"] == 2:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_BITS_PER_SAMPLE,\n                                             FIELD_TYPE_OUT['H'],\n                                             3,\n                                             info[\"stripOffsets\"][0] - \\\n                                             2 * stripOffsetsLength - \\\n                                             descriptionLength - \\\n                                             dateLength - \\\n                                             softwareLength - \\\n                                             bitsPerSampleLength)\n        else:\n            raise RuntimeError(\"Unsupported photometric interpretation\")\n\n        fmt = st + 'HHIHH'\n        outputIFD += struct.pack(fmt, TAG_COMPRESSION,\n                                         FIELD_TYPE_OUT['H'],\n                                         1,\n                                         info[\"compression\"],0)\n        fmt = st + 'HHIHH'\n        outputIFD += struct.pack(fmt, TAG_PHOTOMETRIC_INTERPRETATION,\n                                         FIELD_TYPE_OUT['H'],\n                                         1,\n                                         info[\"photometricInterpretation\"],0)\n\n        if imageDescription is not None:\n            descriptionLength = len(imageDescription)\n            if descriptionLength > 4:\n                fmt = st + 'HHII'\n                outputIFD += struct.pack(fmt, TAG_IMAGE_DESCRIPTION,\n                                         FIELD_TYPE_OUT['s'],\n                                         descriptionLength,\n                                         info[\"stripOffsets\"][0]-\\\n                                         2*stripOffsetsLength-\\\n                                         descriptionLength)\n            else:\n                #it has to have length 4\n                fmt = st + 'HHI%ds' % descriptionLength\n                outputIFD += struct.pack(fmt, TAG_IMAGE_DESCRIPTION,\n                                         FIELD_TYPE_OUT['s'],\n                                         descriptionLength,\n                                         description)\n\n        if len(stripOffsets) == 1:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_STRIP_OFFSETS,\n                                             FIELD_TYPE_OUT['I'],\n                                             1,\n                                             info[\"stripOffsets\"][0])\n        else:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_STRIP_OFFSETS,\n                                             FIELD_TYPE_OUT['I'],\n                                             len(stripOffsets),\n                    info[\"stripOffsets\"][0]-2*stripOffsetsLength)\n\n        if info[\"photometricInterpretation\"] == 2:\n            fmt = st + 'HHIHH'\n            outputIFD += struct.pack(fmt, TAG_SAMPLES_PER_PIXEL,\n                                             FIELD_TYPE_OUT['H'],\n                                             1,\n                                             info[\"samplesPerPixel\"], 0)\n\n        fmt = st + 'HHII'\n        outputIFD += struct.pack(fmt, TAG_ROWS_PER_STRIP,\n                                         FIELD_TYPE_OUT['I'],\n                                         1,\n                                         info[\"rowsPerStrip\"])\n\n        if len(stripOffsets) == 1:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_STRIP_BYTE_COUNTS,\n                                             FIELD_TYPE_OUT['I'],\n                                             1,\n                                             info[\"stripByteCounts\"])\n        else:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_STRIP_BYTE_COUNTS,\n                                             FIELD_TYPE_OUT['I'],\n                                             len(stripOffsets),\n                    info[\"stripOffsets\"][0]-stripOffsetsLength)\n\n        if software is not None:\n            if softwareLength > 4:\n                fmt = st + 'HHII'\n                outputIFD += struct.pack(fmt, TAG_SOFTWARE,\n                                         FIELD_TYPE_OUT['s'],\n                                         softwareLength,\n                                         info[\"stripOffsets\"][0]-\\\n                                         2*stripOffsetsLength-\\\n                            descriptionLength-softwareLength-dateLength)\n            else:\n                #it has to have length 4\n                fmt = st + 'HHI%ds' % softwareLength\n                outputIFD += struct.pack(fmt, TAG_SOFTWARE,\n                                         FIELD_TYPE_OUT['s'],\n                                         softwareLength,\n                                         softwarePackedString)\n\n        if date is not None:\n            fmt = st + 'HHII'\n            outputIFD += struct.pack(fmt, TAG_DATE,\n                                      FIELD_TYPE_OUT['s'],\n                                      dateLength,\n                                      info[\"stripOffsets\"][0]-\\\n                                         2*stripOffsetsLength-\\\n                                      descriptionLength-dateLength)\n\n        fmt = st + 'HHIHH'\n        outputIFD += struct.pack(fmt, TAG_SAMPLE_FORMAT,\n                                         FIELD_TYPE_OUT['H'],\n                                         1,\n                                         info[\"sampleFormat\"],0)\n        fmt = st + 'I'\n        outputIFD += struct.pack(fmt, 0)\n\n        if info[\"photometricInterpretation\"] == 2:\n            outputIFD += struct.pack('HHH', info[\"nBits\"],\n                                     info[\"nBits\"], info[\"nBits\"])\n\n        if softwareLength > 4:\n            outputIFD += softwarePackedString\n\n        if date is not None:\n            outputIFD += datePackedString\n\n        if imageDescription is not None:\n            if descriptionLength > 4:\n                outputIFD += imageDescription\n\n        if stripOffsetsString is not None:\n            outputIFD += stripOffsetsString\n            outputIFD += stripByteCountsString\n\n        return outputIFD",
  "class Image(object):\n    \"\"\"\n    \"\"\"\n    def __init__(self):\n        \"\"\" Constructor\n        \"\"\"\n        self.Header = {}\n        self.StaticHeader = {}\n        self.HeaderPosition = 0\n        self.DataPosition = 0\n        self.Size = 0\n        self.NumDim = 1\n        self.Dim1 = 0\n        self.Dim2 = 0\n        self.Dim3 = 0\n        self.DataType = \"\"",
  "class  EdfFile(object):\n    \"\"\"\n    \"\"\"\n    ############################################################################\n    #Interface\n    def __init__(self, FileName, access=None, fastedf=None):\n        \"\"\" Constructor\n\n        @param  FileName:   Name of the file (either existing or to be created)\n        @type FileName: string\n        @param access: access mode \"r\" for reading (the file should exist) or\n                                   \"w\" for writing (if the file does not exist, it does not matter).\n        @type access: string\n        @type fastedf= True to use the fastedf module\n        @param fastedf= boolean\n        \"\"\"\n        self.Images = []\n        self.NumImages = 0\n        self.FileName = FileName\n        self.File = 0\n        if fastedf is None:\n            fastedf = 0\n        self.fastedf = fastedf\n        self.ADSC = False\n        self.MARCCD = False\n        self.TIFF = False\n        self.PILATUS_CBF = False\n        self.SPE = False\n        if sys.byteorder == \"big\":\n            self.SysByteOrder = \"HighByteFirst\"\n        else:\n            self.SysByteOrder = \"LowByteFirst\"\n\n        if hasattr(FileName, \"seek\") and\\\n           hasattr(FileName, \"read\"):\n            # this looks like a file descriptor ...\n            self.__ownedOpen = False\n            self.File = FileName\n            try:\n                self.FileName = self.File.name\n            except AttributeError:\n                self.FileName = self.File.filename\n        elif FileName.lower().endswith('.gz'):\n            if GZIP:\n                self.__ownedOpen = False\n                self.File = gzip.GzipFile(FileName)\n            else:\n                raise IOError(\"No gzip module support in this system\")\n        elif FileName.lower().endswith('.bz2'):\n            if BZ2:\n                self.__ownedOpen = False\n                self.File = bz2.BZ2File(FileName)\n            else:\n                raise IOError(\"No bz2 module support in this system\")\n        else:\n            self.__ownedOpen = True\n\n        if self.File in [0, None]:\n            if access is not None:\n                if access[0].upper() == \"R\":\n                    if not os.path.isfile(self.FileName):\n                        raise IOError(\"File %s not found\" % FileName)\n                if 'b' not in access:\n                    access += 'b'\n            if 1: #try:\n                if not os.path.isfile(self.FileName):\n                    #write access\n                    if access is None:\n                        #allow writing and reading\n                        access = \"ab+\"\n                        self.File = open(self.FileName, access)\n                        self.File.seek(0, 0)\n                        return\n                    if 'b' not in access:\n                        access += 'b'\n                    self.File = open(self.FileName, access)\n                    return\n                else:\n                    if access is None:\n                        if (os.access(self.FileName, os.W_OK)):\n                            access = \"r+b\"\n                        else:\n                            access = \"rb\"\n                    self.File = open(self.FileName, access)\n                    self.File.seek(0, 0)\n                    twoChars = self.File.read(2)\n                    tiff = False\n                    if sys.version < '3.0':\n                        if twoChars in [\"II\", \"MM\"]:\n                            tiff = True\n                    elif twoChars in [eval('b\"II\"'), eval('b\"MM\"')]:\n                            tiff = True\n                    if tiff:\n                        fileExtension = os.path.splitext(self.FileName)[-1]\n                        if fileExtension.lower() in [\".tif\", \".tiff\"] or\\\n                           sys.version > '2.9':\n                            if not TIFF_SUPPORT:\n                                raise IOError(\"TIFF support not implemented\")\n                            else:\n                                self.TIFF = True\n                        elif not MARCCD_SUPPORT:\n                            if not TIFF_SUPPORT:\n                                raise IOError(\"MarCCD support not implemented\")\n                            else:\n                                self.TIFF = True\n                        else:\n                            self.MARCCD = True\n                    if os.path.basename(FileName).upper().endswith('.CBF'):\n                        if not PILATUS_CBF_SUPPORT:\n                            raise IOError(\"CBF support not implemented\")\n                        if twoChars[0] != \"{\":\n                            self.PILATUS_CBF = True\n                    elif os.path.basename(FileName).upper().endswith('.SPE'):\n                        if twoChars[0] != \"$\":\n                            self.SPE = True\n                    elif os.path.basename(FileName).upper().endswith('EDF.GZ') or\\\n                         os.path.basename(FileName).upper().endswith('CCD.GZ'):\n                        self.GZIP = True\n            else: #except:\n                try:\n                    self.File.close()\n                except:\n                    pass\n                raise IOError(\"EdfFile: Error opening file\")\n\n        self.File.seek(0, 0)\n        if self.TIFF:\n            self._wrapTIFF()\n            self.File.close()\n            return\n        if self.MARCCD:\n            self._wrapMarCCD()\n            self.File.close()\n            return\n        if self.PILATUS_CBF:\n            self._wrapPilatusCBF()\n            self.File.close()\n            return\n        if self.SPE:\n            self._wrapSPE()\n            self.File.close()\n            return\n\n        Index = 0\n        line = self.File.readline()\n        selectedLines = [\"\"]\n        if sys.version > '2.6':\n            selectedLines.append(eval('b\"\"'))\n        parsingHeader = False\n        while line not in selectedLines:\n            #decode to make sure I have character string\n            #str to make sure python 2.x sees it as string and not unicode\n            if sys.version < '3.0':\n                if type(line) != type(str(\"\")):\n                    line = \"%s\" % line\n            else:\n                try:\n                    line = str(line.decode())\n                except UnicodeDecodeError:\n                    try:\n                        line = str(line.decode('utf-8'))\n                    except UnicodeDecodeError:\n                        try:\n                            line = str(line.decode('latin-1'))\n                        except UnicodeDecodeError:\n                            line = \"%s\" % line\n            if (line.count(\"{\\n\") >= 1) or (line.count(\"{\\r\\n\") >= 1):\n                parsingHeader = True\n                Index = self.NumImages\n                self.NumImages = self.NumImages + 1\n                self.Images.append(Image())\n#            Position = self.File.tell()\n\n            if line.count(\"=\") >= 1:\n                listItems = line.split(\"=\", 1)\n                typeItem = listItems[0].strip()\n                listItems = listItems[1].split(\";\", 1)\n                valueItem = listItems[0].strip()\n                if (typeItem == \"HEADER_BYTES\") and (Index == 0):\n                    self.ADSC = True\n                    break\n\n                #if typeItem in self.Images[Index].StaticHeader.keys():\n                if typeItem.upper() in STATIC_HEADER_ELEMENTS_CAPS:\n                    self.Images[Index].StaticHeader[typeItem] = valueItem\n                else:\n                    self.Images[Index].Header[typeItem] = valueItem\n            if ((line.count(\"}\\n\") >= 1) or (line.count(\"}\\r\") >= 1)) and (parsingHeader):\n                parsingHeader = False\n                #for i in STATIC_HEADER_ELEMENTS_CAPS:\n                #    if self.Images[Index].StaticHeader[i]==\"\":\n                #        raise \"Bad File Format\"\n                self.Images[Index].DataPosition = self.File.tell()\n                #self.File.seek(int(self.Images[Index].StaticHeader[\"Size\"]), 1)\n                StaticPar = SetDictCase(self.Images[Index].StaticHeader, UPPER_CASE, KEYS)\n                if \"SIZE\" in StaticPar.keys():\n                    self.Images[Index].Size = int(StaticPar[\"SIZE\"])\n                    if self.Images[Index].Size <= 0:\n                        self.NumImages = Index\n                        line = self.File.readline()\n                        continue\n                else:\n                    raise TypeError(\"EdfFile: Image doesn't have size information\")\n                if \"DIM_1\" in StaticPar.keys():\n                    self.Images[Index].Dim1 = int(StaticPar[\"DIM_1\"])\n                    self.Images[Index].Offset1 = int(\\\n                                            StaticPar.get(\"Offset_1\", \"0\"))\n                else:\n                    raise TypeError(\"EdfFile: Image doesn't have dimension information\")\n                if \"DIM_2\" in StaticPar.keys():\n                    self.Images[Index].NumDim = 2\n                    self.Images[Index].Dim2 = int(StaticPar[\"DIM_2\"])\n                    self.Images[Index].Offset2 = int(\\\n                                            StaticPar.get(\"Offset_2\", \"0\"))\n                if \"DIM_3\" in StaticPar.keys():\n                    self.Images[Index].NumDim = 3\n                    self.Images[Index].Dim3 = int(StaticPar[\"DIM_3\"])\n                    self.Images[Index].Offset3 = int(\\\n                                            StaticPar.get(\"Offset_3\", \"0\"))\n                if \"DATATYPE\" in StaticPar.keys():\n                    self.Images[Index].DataType = StaticPar[\"DATATYPE\"]\n                else:\n                    raise TypeError(\"EdfFile: Image doesn't have datatype information\")\n                if \"BYTEORDER\" in StaticPar.keys():\n                    self.Images[Index].ByteOrder = StaticPar[\"BYTEORDER\"]\n                else:\n                    raise TypeError(\"EdfFile: Image doesn't have byteorder information\")\n\n\n\n                self.File.seek(self.Images[Index].Size, 1)\n\n            line = self.File.readline()\n\n        if self.ADSC:\n            self.File.seek(0, 0)\n            self.NumImages = 1\n            #this is a bad implementation of fabio adscimage\n            #please take a look at the fabio module of fable at sourceforge\n            infile = self.File\n            header_keys = []\n            header = {}\n            try:\n                \"\"\" read an adsc header \"\"\"\n                line = infile.readline()\n                bytesread = len(line)\n                while '}' not in line:\n                    if '=' in line:\n                        (key, val) = line.split('=')\n                        header_keys.append(key.strip())\n                        header[key.strip()] = val.strip(' ;\\n')\n                    line = infile.readline()\n                    bytesread = bytesread + len(line)\n            except:\n                raise Exception(\"Error processing adsc header\")\n            # banned by bzip/gzip???\n            try:\n                infile.seek(int(header['HEADER_BYTES']), 0)\n            except TypeError:\n                # Gzipped does not allow a seek and read header is not\n                # promising to stop in the right place\n                infile.close()\n                infile = self._open(fname, \"rb\")\n                infile.read(int(header['HEADER_BYTES']))\n            binary = infile.read()\n            infile.close()\n\n            #now read the data into the array\n            self.Images[Index].Dim1 = int(header['SIZE1'])\n            self.Images[Index].Dim2 = int(header['SIZE2'])\n            self.Images[Index].NumDim = 2\n            self.Images[Index].DataType = 'UnsignedShort'\n            try:\n                self.__data = numpy.reshape(\n                    numpy.fromstring(binary, numpy.uint16),\n                    (self.Images[Index].Dim2, self.Images[Index].Dim1))\n            except ValueError:\n                raise IOError('Size spec in ADSC-header does not match ' + \\\n                    'size of image data field')\n            if 'little' in header['BYTE_ORDER']:\n                self.Images[Index].ByteOrder = 'LowByteFirst'\n            else:\n                self.Images[Index].ByteOrder = 'HighByteFirst'\n            if self.SysByteOrder.upper() != self.Images[Index].ByteOrder.upper():\n                self.__data = self.__data.byteswap()\n                self.Images[Index].ByteOrder = self.SysByteOrder\n\n            self.Images[Index].StaticHeader['Dim_1'] = self.Images[Index].Dim1\n            self.Images[Index].StaticHeader['Dim_2'] = self.Images[Index].Dim2\n            self.Images[Index].StaticHeader['Offset_1'] = 0\n            self.Images[Index].StaticHeader['Offset_2'] = 0\n            self.Images[Index].StaticHeader['DataType'] = self.Images[Index].DataType\n\n        self.__makeSureFileIsClosed()\n\n    def _wrapTIFF(self):\n        self._wrappedInstance = TiffIO.TiffIO(self.File, cache_length = 0, mono_output=True)\n        self.NumImages = self._wrappedInstance.getNumberOfImages()\n        if self.NumImages < 1:\n            return\n\n        # wrapped image objects have to provide getInfo and getData\n        # info = self._wrappedInstance.getInfo( index)\n        # data = self._wrappedInstance.getData( index)\n        # for the time being I am going to assume all the images\n        # in the file have the same data type type\n        data = None\n\n        for Index in range(self.NumImages):\n            info = self._wrappedInstance.getInfo(Index)\n            self.Images.append(Image())\n            self.Images[Index].Dim1 = info['nRows']\n            self.Images[Index].Dim2 = info['nColumns']\n            self.Images[Index].NumDim = 2\n            if data is None:\n                data = self._wrappedInstance.getData(0)\n            self.Images[Index].DataType = self.__GetDefaultEdfType__(data.dtype)\n            self.Images[Index].StaticHeader['Dim_1'] = self.Images[Index].Dim1\n            self.Images[Index].StaticHeader['Dim_2'] = self.Images[Index].Dim2\n            self.Images[Index].StaticHeader['Offset_1'] = 0\n            self.Images[Index].StaticHeader['Offset_2'] = 0\n            self.Images[Index].StaticHeader['DataType'] = self.Images[Index].DataType\n            self.Images[Index].Header.update(info)\n\n    def _wrapMarCCD(self):\n        mccd = MarCCD.MarCCD(self.File)\n        self.NumImages = 1\n        self.__data = mccd.getData()\n        self.__info = mccd.getInfo()\n        self.Images.append(Image())\n        Index = 0\n        self.Images[Index].Dim1 = self.__data.shape[0]\n        self.Images[Index].Dim2 = self.__data.shape[1]\n        self.Images[Index].NumDim = 2\n        if self.__data.dtype == numpy.uint8:\n            self.Images[Index].DataType = 'UnsignedByte'\n        elif self.__data.dtype == numpy.uint16:\n            self.Images[Index].DataType = 'UnsignedShort'\n        else:\n            self.Images[Index].DataType = 'UnsignedInteger'\n        self.Images[Index].StaticHeader['Dim_1'] = self.Images[Index].Dim1\n        self.Images[Index].StaticHeader['Dim_2'] = self.Images[Index].Dim2\n        self.Images[Index].StaticHeader['Offset_1'] = 0\n        self.Images[Index].StaticHeader['Offset_2'] = 0\n        self.Images[Index].StaticHeader['DataType'] = self.Images[Index].DataType\n        self.Images[Index].Header.update(self.__info)\n\n    def _wrapPilatusCBF(self):\n        mccd = PilatusCBF.PilatusCBF(self.File)\n        self.NumImages = 1\n        self.__data = mccd.getData()\n        self.__info = mccd.getInfo()\n        self.Images.append(Image())\n        Index = 0\n        self.Images[Index].Dim1 = self.__data.shape[0]\n        self.Images[Index].Dim2 = self.__data.shape[1]\n        self.Images[Index].NumDim = 2\n        if self.__data.dtype == numpy.uint8:\n            self.Images[Index].DataType = 'UnsignedByte'\n        elif self.__data.dtype == numpy.uint16:\n            self.Images[Index].DataType = 'UnsignedShort'\n        else:\n            self.Images[Index].DataType = 'UnsignedInteger'\n        self.Images[Index].StaticHeader['Dim_1'] = self.Images[Index].Dim1\n        self.Images[Index].StaticHeader['Dim_2'] = self.Images[Index].Dim2\n        self.Images[Index].StaticHeader['Offset_1'] = 0\n        self.Images[Index].StaticHeader['Offset_2'] = 0\n        self.Images[Index].StaticHeader['DataType'] = self.Images[Index].DataType\n        self.Images[Index].Header.update(self.__info)\n\n    def _wrapSPE(self):\n        if 0 and sys.version < '3.0':\n            self.File.seek(42)\n            xdim = numpy.int64(numpy.fromfile(self.File, numpy.int16, 1)[0])\n            self.File.seek(656)\n            ydim = numpy.int64(numpy.fromfile(self.File, numpy.int16, 1))\n            self.File.seek(4100)\n            self.__data = numpy.fromfile(self.File, numpy.uint16, int(xdim * ydim))\n        else:\n            import struct\n            self.File.seek(0)\n            a = self.File.read()\n            xdim = numpy.int64(struct.unpack('<h', a[42:44])[0])\n            ydim = numpy.int64(struct.unpack('<h', a[656:658])[0])\n            fmt = '<%dH' % int(xdim * ydim)\n            self.__data = numpy.array(struct.unpack(fmt, a[4100:int(4100+ int(2 * xdim * ydim))])).astype(numpy.uint16)\n        self.__data.shape = ydim, xdim\n        Index = 0\n        self.Images.append(Image())\n        self.NumImages = 1\n        self.Images[Index].Dim1 = ydim\n        self.Images[Index].Dim2 = xdim\n        self.Images[Index].NumDim = 2\n        self.Images[Index].DataType = 'UnsignedShort'\n        self.Images[Index].ByteOrder = 'LowByteFirst'\n        if self.SysByteOrder.upper() != self.Images[Index].ByteOrder.upper():\n            self.__data = self.__data.byteswap()\n        self.Images[Index].StaticHeader['Dim_1'] = self.Images[Index].Dim1\n        self.Images[Index].StaticHeader['Dim_2'] = self.Images[Index].Dim2\n        self.Images[Index].StaticHeader['Offset_1'] = 0\n        self.Images[Index].StaticHeader['Offset_2'] = 0\n        self.Images[Index].StaticHeader['DataType'] = self.Images[Index].DataType\n\n    def GetNumImages(self):\n        \"\"\" Returns number of images of the object (and associated file)\n        \"\"\"\n        return self.NumImages\n\n    def GetData(self, *var, **kw):\n        try:\n            self.__makeSureFileIsOpen()\n            return self._GetData(*var, **kw)\n        finally:\n            self.__makeSureFileIsClosed()\n\n    def _GetData(self, Index, DataType=\"\", Pos=None, Size=None):\n        \"\"\" Returns numpy array with image data\n            Index:          The zero-based index of the image in the file\n            DataType:       The edf type of the array to be returnd\n                            If ommited, it is used the default one for the type\n                            indicated in the image header\n                            Attention to the absence of UnsignedShort,\n                            UnsignedInteger and UnsignedLong types in\n                            Numpy Python\n                            Default relation between Edf types and NumPy's typecodes:\n                                SignedByte          int8   b\n                                UnsignedByte        uint8  B\n                                SignedShort         int16  h\n                                UnsignedShort       uint16 H\n                                SignedInteger       int32  i\n                                UnsignedInteger     uint32 I\n                                SignedLong          int32  i\n                                UnsignedLong        uint32 I\n                                Signed64            int64  (l in 64bit, q in 32 bit)\n                                Unsigned64          uint64 (L in 64bit, Q in 32 bit)\n                                FloatValue          float32 f\n                                DoubleValue         float64 d\n            Pos:            Tuple (x) or (x,y) or (x,y,z) that indicates the begining\n                            of data to be read. If ommited, set to the origin (0),\n                            (0,0) or (0,0,0)\n            Size:           Tuple, size of the data to be returned as x) or (x,y) or\n                            (x,y,z) if ommited, is the distance from Pos to the end.\n\n            If Pos and Size not mentioned, returns the whole data.\n        \"\"\"\n        fastedf = self.fastedf\n        if Index < 0 or Index >= self.NumImages:\n            raise ValueError(\"EdfFile: Index out of limit\")\n        if fastedf is None:fastedf = 0\n        if Pos is None and Size is None:\n            if self.ADSC or self.MARCCD or self.PILATUS_CBF or self.SPE:\n                return self.__data\n            elif self.TIFF:\n                data = self._wrappedInstance.getData(Index)\n                return data\n            else:\n                self.File.seek(self.Images[Index].DataPosition, 0)\n                datatype = self.__GetDefaultNumpyType__(self.Images[Index].DataType, index=Index)\n                try:\n                    datasize = self.__GetSizeNumpyType__(datatype)\n                except TypeError:\n                    print(\"What is the meaning of this error?\")\n                    datasize = 8\n                if self.Images[Index].NumDim == 3:\n                    sizeToRead = self.Images[Index].Dim1 * \\\n                                 self.Images[Index].Dim2 * \\\n                                 self.Images[Index].Dim3 * datasize\n                    Data = numpy.fromstring(self.File.read(sizeToRead),\n                                datatype)\n                    Data = numpy.reshape(Data, (self.Images[Index].Dim3, self.Images[Index].Dim2, self.Images[Index].Dim1))\n                elif self.Images[Index].NumDim == 2:\n                    sizeToRead = self.Images[Index].Dim1 * \\\n                                 self.Images[Index].Dim2 * datasize\n                    Data = numpy.fromstring(self.File.read(sizeToRead),\n                                datatype)\n                    #print \"datatype = \",datatype\n                    #print \"Data.type = \", Data.dtype.char\n                    #print \"self.Images[Index].DataType \", self.Images[Index].DataType\n                    #print \"Data.shape\",Data.shape\n                    #print \"datasize = \",datasize\n                    #print \"sizeToRead \",sizeToRead\n                    #print \"lenData = \", len(Data)\n                    Data = numpy.reshape(Data, (self.Images[Index].Dim2, self.Images[Index].Dim1))\n                elif self.Images[Index].NumDim == 1:\n                    sizeToRead = self.Images[Index].Dim1 * datasize\n                    Data = numpy.fromstring(self.File.read(sizeToRead),\n                                datatype)\n        elif self.ADSC or self.MARCCD or self.PILATUS_CBF or self.SPE:\n            return self.__data[Pos[1]:(Pos[1] + Size[1]),\n                               Pos[0]:(Pos[0] + Size[0])]\n        elif self.TIFF:\n            data = self._wrappedInstance.getData(Index)\n            return data[Pos[1]:(Pos[1] + Size[1]),\n                               Pos[0]:(Pos[0] + Size[0])]\n        elif fastedf and CAN_USE_FASTEDF:\n            type = self.__GetDefaultNumpyType__(self.Images[Index].DataType, index=Index)\n            size_pixel = self.__GetSizeNumpyType__(type)\n            Data = numpy.array([], type)\n            if self.Images[Index].NumDim == 1:\n                if Pos == None: Pos = (0,)\n                if Size == None: Size = (0,)\n                sizex = self.Images[Index].Dim1\n                Size = list(Size)\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                self.File.seek((Pos[0] * size_pixel) + self.Images[Index].DataPosition, 0)\n                Data = numpy.fromstring(self.File.read(Size[0] * size_pixel), type)\n            elif self.Images[Index].NumDim == 2:\n                if Pos == None: Pos = (0, 0)\n                if Size == None: Size = (0, 0)\n                Size = list(Size)\n                sizex, sizey = self.Images[Index].Dim1, self.Images[Index].Dim2\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                if Size[1] == 0:Size[1] = sizey - Pos[1]\n                Data = numpy.zeros([Size[1], Size[0]], type)\n                self.File.seek((((Pos[1] * sizex) + Pos[0]) * size_pixel) + self.Images[Index].DataPosition, 0)\n                extended_fread(Data, Size[0] * size_pixel , numpy.array([Size[1]]),\n                               numpy.array([sizex * size_pixel]) , self.File)\n\n            elif self.Images[Index].NumDim == 3:\n                if Pos == None: Pos = (0, 0, 0)\n                if Size == None: Size = (0, 0, 0)\n                Size = list(Size)\n                sizex, sizey, sizez = self.Images[Index].Dim1, self.Images[Index].Dim2, self.Images[Index].Dim3\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                if Size[1] == 0:Size[1] = sizey - Pos[1]\n                if Size[2] == 0:Size[2] = sizez - Pos[2]\n                Data = numpy.zeros([Size[2], Size[1], Size[0]], type)\n                self.File.seek(((((Pos[2] * sizey + Pos[1]) * sizex) + Pos[0]) * size_pixel) + self.Images[Index].DataPosition, 0)\n                extended_fread(Data, Size[0] * size_pixel , numpy.array([Size[2], Size[1]]),\n                        numpy.array([ sizey * sizex * size_pixel , sizex * size_pixel]) , self.File)\n\n        else:\n            if fastedf:\n                print(\"I could not use fast routines\")\n            type = self.__GetDefaultNumpyType__(self.Images[Index].DataType, index=Index)\n            size_pixel = self.__GetSizeNumpyType__(type)\n            Data = numpy.array([], type)\n            if self.Images[Index].NumDim == 1:\n                if Pos == None: Pos = (0,)\n                if Size == None: Size = (0,)\n                sizex = self.Images[Index].Dim1\n                Size = list(Size)\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                self.File.seek((Pos[0] * size_pixel) + self.Images[Index].DataPosition, 0)\n                Data = numpy.fromstring(self.File.read(Size[0] * size_pixel), type)\n            elif self.Images[Index].NumDim == 2:\n                if Pos == None: Pos = (0, 0)\n                if Size == None: Size = (0, 0)\n                Size = list(Size)\n                sizex, sizey = self.Images[Index].Dim1, self.Images[Index].Dim2\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                if Size[1] == 0:Size[1] = sizey - Pos[1]\n                #print len(range(Pos[1],Pos[1]+Size[1])), \"LECTURES OF \", Size[0], \"POINTS\"\n                #print \"sizex = \", sizex, \"sizey = \", sizey\n                Data = numpy.zeros((Size[1], Size[0]), type)\n                dataindex = 0\n                for y in range(Pos[1], Pos[1] + Size[1]):\n                    self.File.seek((((y * sizex) + Pos[0]) * size_pixel) + self.Images[Index].DataPosition, 0)\n                    line = numpy.fromstring(self.File.read(Size[0] * size_pixel), type)\n                    Data[dataindex, :] = line[:]\n                    #Data=numpy.concatenate((Data,line))\n                    dataindex += 1\n                #print \"DataSize = \",Data.shape\n                #print \"Requested reshape = \",Size[1],'x',Size[0]\n                #Data = numpy.reshape(Data, (Size[1],Size[0]))\n            elif self.Images[Index].NumDim == 3:\n                if Pos == None: Pos = (0, 0, 0)\n                if Size == None: Size = (0, 0, 0)\n                Size = list(Size)\n                sizex, sizey, sizez = self.Images[Index].Dim1, self.Images[Index].Dim2, self.Images[Index].Dim3\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                if Size[1] == 0:Size[1] = sizey - Pos[1]\n                if Size[2] == 0:Size[2] = sizez - Pos[2]\n                for z in range(Pos[2], Pos[2] + Size[2]):\n                    for y in range(Pos[1], Pos[1] + Size[1]):\n                        self.File.seek(((((z * sizey + y) * sizex) + Pos[0]) * size_pixel) + self.Images[Index].DataPosition, 0)\n                        line = numpy.fromstring(self.File.read(Size[0] * size_pixel), type)\n                        Data = numpy.concatenate((Data, line))\n                Data = numpy.reshape(Data, (Size[2], Size[1], Size[0]))\n\n        if self.SysByteOrder.upper() != self.Images[Index].ByteOrder.upper():\n            Data = Data.byteswap()\n        if DataType != \"\":\n            Data = self.__SetDataType__ (Data, DataType)\n        return Data\n\n\n\n    def GetPixel(self, Index, Position):\n        \"\"\" Returns double value of the pixel, regardless the format of the array\n            Index:      The zero-based index of the image in the file\n            Position:   Tuple with the coordinete (x), (x,y) or (x,y,z)\n        \"\"\"\n        if Index < 0 or Index >= self.NumImages:\n            raise ValueError(\"EdfFile: Index out of limit\")\n        if len(Position) != self.Images[Index].NumDim:\n            raise ValueError(\"EdfFile: coordinate with wrong dimension \")\n\n        size_pixel = self.__GetSizeNumpyType__(self.__GetDefaultNumpyType__(self.Images[Index].DataType), index=Index)\n        offset = Position[0] * size_pixel\n        if self.Images[Index].NumDim > 1:\n            size_row = size_pixel * self.Images[Index].Dim1\n            offset = offset + (Position[1] * size_row)\n            if self.Images[Index].NumDim == 3:\n                size_img = size_row * self.Images[Index].Dim2\n                offset = offset + (Position[2] * size_img)\n        self.File.seek(self.Images[Index].DataPosition + offset, 0)\n        Data = numpy.fromstring(self.File.read(size_pixel), self.__GetDefaultNumpyType__(self.Images[Index].DataType, index=Index))\n        if self.SysByteOrder.upper() != self.Images[Index].ByteOrder.upper():\n            Data = Data.byteswap()\n        Data = self.__SetDataType__ (Data, \"DoubleValue\")\n        return Data[0]\n\n\n    def GetHeader(self, Index):\n        \"\"\" Returns dictionary with image header fields.\n            Does not include the basic fields (static) defined by data shape,\n            type and file position. These are get with GetStaticHeader\n            method.\n            Index:          The zero-based index of the image in the file\n        \"\"\"\n        if Index < 0 or Index >= self.NumImages:\n            raise ValueError(\"Index out of limit\")\n        #return self.Images[Index].Header\n        ret = {}\n        for i in self.Images[Index].Header.keys():\n            ret[i] = self.Images[Index].Header[i]\n        return ret\n\n\n    def GetStaticHeader(self, Index):\n        \"\"\" Returns dictionary with static parameters\n            Data format and file position dependent information\n            (dim1,dim2,size,datatype,byteorder,headerId,Image)\n            Index:          The zero-based index of the image in the file\n        \"\"\"\n        if Index < 0 or Index >= self.NumImages:\n            raise ValueError(\"Index out of limit\")\n        #return self.Images[Index].StaticHeader\n        ret = {}\n        for i in self.Images[Index].StaticHeader.keys():\n            ret[i] = self.Images[Index].StaticHeader[i]\n        return ret\n\n    def WriteImage(self, *var, **kw):\n        try:\n            self.__makeSureFileIsOpen()\n            return self._WriteImage(*var, **kw)\n        finally:\n            self.__makeSureFileIsClosed()\n\n    def _WriteImage (self, Header, Data, Append=1, DataType=\"\", ByteOrder=\"\"):\n        \"\"\" Writes image to the file.\n            Header:         Dictionary containing the non-static header\n                            information (static information is generated\n                            according to position of image and data format\n            Append:         If equals to 0, overwrites the file. Otherwise, appends\n                            to the end of the file\n            DataType:       The data type to be saved to the file:\n                                SignedByte\n                                UnsignedByte\n                                SignedShort\n                                UnsignedShort\n                                SignedInteger\n                                UnsignedInteger\n                                SignedLong\n                                UnsignedLong\n                                FloatValue\n                                DoubleValue\n                            Default: according to Data array typecode:\n                                    1:  SignedByte\n                                    b:  UnsignedByte\n                                    s:  SignedShort\n\t\t\t\t    w:  UnsignedShort\n                                    i:  SignedInteger\n                                    l:  SignedLong\n\t\t\t\t    u:  UnsignedLong\n                                    f:  FloatValue\n                                    d:  DoubleValue\n            ByteOrder:      Byte order of the data in file:\n                                HighByteFirst\n                                LowByteFirst\n                            Default: system's byte order\n        \"\"\"\n        if Append == 0:\n            self.File.truncate(0)\n            self.Images = []\n            self.NumImages = 0\n        Index = self.NumImages\n        self.NumImages = self.NumImages + 1\n        self.Images.append(Image())\n\n        #self.Images[Index].StaticHeader[\"Dim_1\"] = \"%d\" % Data.shape[1]\n        #self.Images[Index].StaticHeader[\"Dim_2\"] = \"%d\" % Data.shape[0]\n        if len(Data.shape) == 1:\n            self.Images[Index].Dim1 = Data.shape[0]\n            self.Images[Index].StaticHeader[\"Dim_1\"] = \"%d\" % self.Images[Index].Dim1\n            self.Images[Index].Size = (Data.shape[0] * \\\n                                     self.__GetSizeNumpyType__(Data.dtype))\n        elif len(Data.shape) == 2:\n            self.Images[Index].Dim1 = Data.shape[1]\n            self.Images[Index].Dim2 = Data.shape[0]\n            self.Images[Index].StaticHeader[\"Dim_1\"] = \"%d\" % self.Images[Index].Dim1\n            self.Images[Index].StaticHeader[\"Dim_2\"] = \"%d\" % self.Images[Index].Dim2\n            self.Images[Index].Size = (Data.shape[0] * Data.shape[1] * \\\n                                     self.__GetSizeNumpyType__(Data.dtype))\n            self.Images[Index].NumDim = 2\n        elif len(Data.shape) == 3:\n            self.Images[Index].Dim1 = Data.shape[2]\n            self.Images[Index].Dim2 = Data.shape[1]\n            self.Images[Index].Dim3 = Data.shape[0]\n            self.Images[Index].StaticHeader[\"Dim_1\"] = \"%d\" % self.Images[Index].Dim1\n            self.Images[Index].StaticHeader[\"Dim_2\"] = \"%d\" % self.Images[Index].Dim2\n            self.Images[Index].StaticHeader[\"Dim_3\"] = \"%d\" % self.Images[Index].Dim3\n            self.Images[Index].Size = (Data.shape[0] * Data.shape[1] * Data.shape[2] * \\\n                                     self.__GetSizeNumpyType__(Data.dtype))\n            self.Images[Index].NumDim = 3\n        elif len(Data.shape) > 3:\n            raise TypeError(\"EdfFile: Data dimension not suported\")\n\n\n        if DataType == \"\":\n            self.Images[Index].DataType = self.__GetDefaultEdfType__(Data.dtype)\n        else:\n            self.Images[Index].DataType = DataType\n            Data = self.__SetDataType__ (Data, DataType)\n\n        if ByteOrder == \"\":\n            self.Images[Index].ByteOrder = self.SysByteOrder\n        else:\n            self.Images[Index].ByteOrder = ByteOrder\n\n        self.Images[Index].StaticHeader[\"Size\"] = \"%d\" % self.Images[Index].Size\n        self.Images[Index].StaticHeader[\"Image\"] = Index + 1\n        self.Images[Index].StaticHeader[\"HeaderID\"] = \"EH:%06d:000000:000000\" % self.Images[Index].StaticHeader[\"Image\"]\n        self.Images[Index].StaticHeader[\"ByteOrder\"] = self.Images[Index].ByteOrder\n        self.Images[Index].StaticHeader[\"DataType\"] = self.Images[Index].DataType\n\n\n        self.Images[Index].Header = {}\n        self.File.seek(0, 2)\n        StrHeader = \"{\\n\"\n        for i in STATIC_HEADER_ELEMENTS:\n            if i in self.Images[Index].StaticHeader.keys():\n                StrHeader = StrHeader + (\"%s = %s ;\\n\" % (i , self.Images[Index].StaticHeader[i]))\n        for i in Header.keys():\n            StrHeader = StrHeader + (\"%s = %s ;\\n\" % (i, Header[i]))\n            self.Images[Index].Header[i] = Header[i]\n        newsize = (((len(StrHeader) + 1) / HEADER_BLOCK_SIZE) + 1) * HEADER_BLOCK_SIZE - 2\n        newsize = int(newsize)\n        StrHeader = StrHeader.ljust(newsize)\n        StrHeader = StrHeader + \"}\\n\"\n\n        self.Images[Index].HeaderPosition = self.File.tell()\n        self.File.write(StrHeader.encode())\n        self.Images[Index].DataPosition = self.File.tell()\n\n        #if self.Images[Index].StaticHeader[\"ByteOrder\"] != self.SysByteOrder:\n        if self.Images[Index].ByteOrder.upper() != self.SysByteOrder.upper():\n            self.File.write((Data.byteswap()).tostring())\n        else:\n            self.File.write(Data.tostring())\n\n\n\n    ############################################################################\n    #Internal Methods\n\n    def __makeSureFileIsOpen(self):\n        if DEBUG:\n            print(\"Making sure file is open\")\n        if not self.__ownedOpen:\n            return\n        if self.ADSC or self.MARCCD or self.PILATUS_CBF or self.SPE:\n            if DEBUG:\n                print(\"Special case. Image is buffered\")\n            return\n        if self.File in [0, None]:\n            if DEBUG:\n                print(\"File is None\")\n        elif self.File.closed:\n            if DEBUG:\n                print(\"Reopening closed file\")\n            accessMode = self.File.mode\n            fileName = self.File.name\n            newFile = open(fileName, accessMode)\n            self.File  = newFile\n        return\n\n    def __makeSureFileIsClosed(self):\n        if DEBUG:\n            print(\"Making sure file is closed\")\n        if not self.__ownedOpen:\n            return\n        if self.ADSC or self.MARCCD or self.PILATUS_CBF or self.SPE:\n            if DEBUG:\n                print(\"Special case. Image is buffered\")\n            return\n        if self.File in [0, None]:\n            if DEBUG:\n                print(\"File is None\")\n        elif not self.File.closed:\n            if DEBUG:\n                print(\"Closing file\")\n            self.File.close()\n        return\n\n\n    def __GetDefaultNumpyType__(self, EdfType, index=None):\n        \"\"\" Internal method: returns NumPy type according to Edf type\n        \"\"\"\n        return self.GetDefaultNumpyType(EdfType, index)\n\n    def __GetDefaultEdfType__(self, NumpyType):\n        \"\"\" Internal method: returns Edf type according Numpy type\n        \"\"\"\n        if   NumpyType in [\"b\", numpy.int8]:            return \"SignedByte\"\n        elif NumpyType in [\"B\", numpy.uint8]:            return \"UnsignedByte\"\n        elif NumpyType in [\"h\", numpy.int16]:            return \"SignedShort\"\n        elif NumpyType in [\"H\", numpy.uint16]:            return \"UnsignedShort\"\n        elif NumpyType in [\"i\", numpy.int32]:            return \"SignedInteger\"\n        elif NumpyType in [\"I\", numpy.uint32]:            return \"UnsignedInteger\"\n        elif NumpyType == \"l\":\n            if sys.platform == 'linux2':\n                return \"Signed64\"\n            else:\n                return \"SignedLong\"\n        elif NumpyType == \"L\":\n            if sys.platform == 'linux2':\n                return \"Unsigned64\"\n            else:\n                return \"UnsignedLong\"\n        elif NumpyType == numpy.int64:\n            return \"Signed64\"\n        elif NumpyType == numpy.uint64:\n            return \"Unsigned64\"\n        elif NumpyType in [\"f\", numpy.float32]:\n            return \"FloatValue\"\n        elif NumpyType in [\"d\", numpy.float64]:\n            return \"DoubleValue\"\n        else:\n            raise TypeError(\"unknown NumpyType %s\" % NumpyType)\n\n\n    def __GetSizeNumpyType__(self, NumpyType):\n        \"\"\" Internal method: returns size of NumPy's Array Types\n        \"\"\"\n        if   NumpyType in [\"b\", numpy.int8]:  return 1\n        elif NumpyType in [\"B\", numpy.uint8]:  return 1\n        elif NumpyType in [\"h\", numpy.int16]:  return 2\n        elif NumpyType in [\"H\", numpy.uint16]:  return 2\n        elif NumpyType in [\"i\", numpy.int32]:  return 4\n        elif NumpyType in [\"I\", numpy.uint32]:  return 4\n        elif NumpyType == \"l\":\n            if sys.platform == 'linux2':\n                return 8    #64 bit\n            else:\n                return 4    #32 bit\n        elif NumpyType == \"L\":\n            if sys.platform == 'linux2':\n                return 8    #64 bit\n            else:\n                return 4    #32 bit\n        elif NumpyType in [\"f\", numpy.float32]: return 4\n        elif NumpyType in [\"d\", numpy.float64]: return 8\n        elif NumpyType == \"Q\":            return 8 #unsigned 64 in 32 bit\n        elif NumpyType == \"q\":            return 8 #signed 64 in 32 bit\n        elif NumpyType == numpy.uint64:   return 8\n        elif NumpyType == numpy.int64:    return 8\n        else:\n            raise TypeError(\"unknown NumpyType %s\" % NumpyType)\n\n\n    def __SetDataType__ (self, Array, DataType):\n        \"\"\" Internal method: array type convertion\n        \"\"\"\n        # AVOID problems not using FromEdfType= Array.dtype.char\n        FromEdfType = Array.dtype\n        ToEdfType = self.__GetDefaultNumpyType__(DataType)\n        if ToEdfType != FromEdfType:\n            aux = Array.astype(self.__GetDefaultNumpyType__(DataType))\n            return aux\n        return Array\n\n    def __del__(self):\n        try:\n            self.__makeSureFileIsClosed()\n        except:\n            pass\n\n    def GetDefaultNumpyType(self, EdfType, index=None):\n        \"\"\" Returns NumPy type according Edf type\n        \"\"\"\n        if index is None:return GetDefaultNumpyType(EdfType)\n        EdfType = EdfType.upper()\n        if EdfType in ['SIGNED64']  :return numpy.int64\n        if EdfType in ['UNSIGNED64']:return numpy.uint64\n        if EdfType in [\"SIGNEDLONG\", \"UNSIGNEDLONG\"]:\n            dim1 = 1\n            dim2 = 1\n            dim3 = 1\n            if hasattr(self.Images[index], \"Dim1\"):\n                dim1 = self.Images[index].Dim1\n                if hasattr(self.Images[index], \"Dim2\"):\n                    dim2 = self.Images[index].Dim2\n                    if dim2 <= 0: dim2 = 1\n                    if hasattr(self.Images[index], \"Dim3\"):\n                        dim3 = self.Images[index].Dim3\n                        if dim3 <= 0: dim3 = 1\n                if hasattr(self.Images[index], \"Size\"):\n                    size = self.Images[index].Size\n                    if size / (dim1 * dim2 * dim3) == 8:\n                        if EdfType == \"UNSIGNEDLONG\":\n                            return numpy.uint64\n                        else:\n                            return numpy.int64\n            if EdfType == \"UNSIGNEDLONG\":\n                return numpy.uint32\n            else:\n                return numpy.int32\n\n        return GetDefaultNumpyType(EdfType)",
  "def GetDefaultNumpyType(EdfType):\n    \"\"\" Returns NumPy type according Edf type\n    \"\"\"\n    EdfType = EdfType.upper()\n    if   EdfType == \"SIGNEDBYTE\":       return numpy.int8   # \"b\"\n    elif EdfType == \"UNSIGNEDBYTE\":     return numpy.uint8  # \"B\"\n    elif EdfType == \"SIGNEDSHORT\":      return numpy.int16  # \"h\"\n    elif EdfType == \"UNSIGNEDSHORT\":    return numpy.uint16 # \"H\"\n    elif EdfType == \"SIGNEDINTEGER\":    return numpy.int32  # \"i\"\n    elif EdfType == \"UNSIGNEDINTEGER\":  return numpy.uint32 # \"I\"\n    elif EdfType == \"SIGNEDLONG\":       return numpy.int32  # \"i\" #ESRF acquisition is made in 32bit\n    elif EdfType == \"UNSIGNEDLONG\":     return numpy.uint32 # \"I\" #ESRF acquisition is made in 32bit\n    elif EdfType == \"SIGNED64\":         return numpy.int64  # \"l\"\n    elif EdfType == \"UNSIGNED64\":       return numpy.uint64 # \"L\"\n    elif EdfType == \"FLOATVALUE\":       return numpy.float32 # \"f\"\n    elif EdfType == \"FLOAT\":            return numpy.float32 # \"f\"\n    elif EdfType == \"DOUBLEVALUE\":      return numpy.float64 # \"d\"\n    else: raise TypeError(\"unknown EdfType %s\" % EdfType)",
  "def SetDictCase(Dict, Case, Flag):\n    \"\"\" Returns dictionary with keys and/or values converted into upper or lowercase\n        Dict:   input dictionary\n        Case:   LOWER_CASE, UPPER_CASE\n        Flag:   KEYS, VALUES or KEYS | VALUES\n    \"\"\"\n    newdict = {}\n    for i in Dict.keys():\n        newkey = i\n        newvalue = Dict[i]\n        if Flag & KEYS:\n            if Case == LOWER_CASE:  newkey = newkey.lower()\n            else:                   newkey = newkey.upper()\n        if Flag & VALUES:\n            if Case == LOWER_CASE:  newvalue = newvalue.lower()\n            else:                   newvalue = newvalue.upper()\n        newdict[newkey] = newvalue\n    return newdict",
  "def GetRegion(Arr, Pos, Size):\n    \"\"\"Returns array with refion of Arr.\n       Arr must be 1d, 2d or 3d\n       Pos and Size are tuples in the format (x) or (x,y) or (x,y,z)\n       Both parameters must have the same size as the dimention of Arr\n    \"\"\"\n    Dim = len(Arr.shape)\n    if len(Pos) != Dim:  return None\n    if len(Size) != Dim: return None\n\n    if (Dim == 1):\n        SizeX = Size[0]\n        if SizeX == 0: SizeX = Arr.shape[0] - Pos[0]\n        ArrRet = numpy.take(Arr, range(Pos[0], Pos[0] + SizeX))\n    elif (Dim == 2):\n        SizeX = Size[0]\n        SizeY = Size[1]\n        if SizeX == 0: SizeX = Arr.shape[1] - Pos[0]\n        if SizeY == 0: SizeY = Arr.shape[0] - Pos[1]\n        ArrRet = numpy.take(Arr, range(Pos[1], Pos[1] + SizeY))\n        ArrRet = numpy.take(ArrRet, range(Pos[0], Pos[0] + SizeX), 1)\n    elif (Dim == 3):\n        SizeX = Size[0]\n        SizeY = Size[1]\n        SizeZ = Size[2]\n        if SizeX == 0: SizeX = Arr.shape[2] - Pos[0]\n        if SizeY == 0: SizeX = Arr.shape[1] - Pos[1]\n        if SizeZ == 0: SizeZ = Arr.shape[0] - Pos[2]\n        ArrRet = numpy.take(Arr, range(Pos[2], Pos[2] + SizeZ))\n        ArrRet = numpy.take(ArrRet, range(Pos[1], Pos[1] + SizeY), 1)\n        ArrRet = numpy.take(ArrRet, range(Pos[0], Pos[0] + SizeX), 2)\n    else:\n        ArrRet = None\n    return ArrRet",
  "def __init__(self):\n        \"\"\" Constructor\n        \"\"\"\n        self.Header = {}\n        self.StaticHeader = {}\n        self.HeaderPosition = 0\n        self.DataPosition = 0\n        self.Size = 0\n        self.NumDim = 1\n        self.Dim1 = 0\n        self.Dim2 = 0\n        self.Dim3 = 0\n        self.DataType = \"\"",
  "def __init__(self, FileName, access=None, fastedf=None):\n        \"\"\" Constructor\n\n        @param  FileName:   Name of the file (either existing or to be created)\n        @type FileName: string\n        @param access: access mode \"r\" for reading (the file should exist) or\n                                   \"w\" for writing (if the file does not exist, it does not matter).\n        @type access: string\n        @type fastedf= True to use the fastedf module\n        @param fastedf= boolean\n        \"\"\"\n        self.Images = []\n        self.NumImages = 0\n        self.FileName = FileName\n        self.File = 0\n        if fastedf is None:\n            fastedf = 0\n        self.fastedf = fastedf\n        self.ADSC = False\n        self.MARCCD = False\n        self.TIFF = False\n        self.PILATUS_CBF = False\n        self.SPE = False\n        if sys.byteorder == \"big\":\n            self.SysByteOrder = \"HighByteFirst\"\n        else:\n            self.SysByteOrder = \"LowByteFirst\"\n\n        if hasattr(FileName, \"seek\") and\\\n           hasattr(FileName, \"read\"):\n            # this looks like a file descriptor ...\n            self.__ownedOpen = False\n            self.File = FileName\n            try:\n                self.FileName = self.File.name\n            except AttributeError:\n                self.FileName = self.File.filename\n        elif FileName.lower().endswith('.gz'):\n            if GZIP:\n                self.__ownedOpen = False\n                self.File = gzip.GzipFile(FileName)\n            else:\n                raise IOError(\"No gzip module support in this system\")\n        elif FileName.lower().endswith('.bz2'):\n            if BZ2:\n                self.__ownedOpen = False\n                self.File = bz2.BZ2File(FileName)\n            else:\n                raise IOError(\"No bz2 module support in this system\")\n        else:\n            self.__ownedOpen = True\n\n        if self.File in [0, None]:\n            if access is not None:\n                if access[0].upper() == \"R\":\n                    if not os.path.isfile(self.FileName):\n                        raise IOError(\"File %s not found\" % FileName)\n                if 'b' not in access:\n                    access += 'b'\n            if 1: #try:\n                if not os.path.isfile(self.FileName):\n                    #write access\n                    if access is None:\n                        #allow writing and reading\n                        access = \"ab+\"\n                        self.File = open(self.FileName, access)\n                        self.File.seek(0, 0)\n                        return\n                    if 'b' not in access:\n                        access += 'b'\n                    self.File = open(self.FileName, access)\n                    return\n                else:\n                    if access is None:\n                        if (os.access(self.FileName, os.W_OK)):\n                            access = \"r+b\"\n                        else:\n                            access = \"rb\"\n                    self.File = open(self.FileName, access)\n                    self.File.seek(0, 0)\n                    twoChars = self.File.read(2)\n                    tiff = False\n                    if sys.version < '3.0':\n                        if twoChars in [\"II\", \"MM\"]:\n                            tiff = True\n                    elif twoChars in [eval('b\"II\"'), eval('b\"MM\"')]:\n                            tiff = True\n                    if tiff:\n                        fileExtension = os.path.splitext(self.FileName)[-1]\n                        if fileExtension.lower() in [\".tif\", \".tiff\"] or\\\n                           sys.version > '2.9':\n                            if not TIFF_SUPPORT:\n                                raise IOError(\"TIFF support not implemented\")\n                            else:\n                                self.TIFF = True\n                        elif not MARCCD_SUPPORT:\n                            if not TIFF_SUPPORT:\n                                raise IOError(\"MarCCD support not implemented\")\n                            else:\n                                self.TIFF = True\n                        else:\n                            self.MARCCD = True\n                    if os.path.basename(FileName).upper().endswith('.CBF'):\n                        if not PILATUS_CBF_SUPPORT:\n                            raise IOError(\"CBF support not implemented\")\n                        if twoChars[0] != \"{\":\n                            self.PILATUS_CBF = True\n                    elif os.path.basename(FileName).upper().endswith('.SPE'):\n                        if twoChars[0] != \"$\":\n                            self.SPE = True\n                    elif os.path.basename(FileName).upper().endswith('EDF.GZ') or\\\n                         os.path.basename(FileName).upper().endswith('CCD.GZ'):\n                        self.GZIP = True\n            else: #except:\n                try:\n                    self.File.close()\n                except:\n                    pass\n                raise IOError(\"EdfFile: Error opening file\")\n\n        self.File.seek(0, 0)\n        if self.TIFF:\n            self._wrapTIFF()\n            self.File.close()\n            return\n        if self.MARCCD:\n            self._wrapMarCCD()\n            self.File.close()\n            return\n        if self.PILATUS_CBF:\n            self._wrapPilatusCBF()\n            self.File.close()\n            return\n        if self.SPE:\n            self._wrapSPE()\n            self.File.close()\n            return\n\n        Index = 0\n        line = self.File.readline()\n        selectedLines = [\"\"]\n        if sys.version > '2.6':\n            selectedLines.append(eval('b\"\"'))\n        parsingHeader = False\n        while line not in selectedLines:\n            #decode to make sure I have character string\n            #str to make sure python 2.x sees it as string and not unicode\n            if sys.version < '3.0':\n                if type(line) != type(str(\"\")):\n                    line = \"%s\" % line\n            else:\n                try:\n                    line = str(line.decode())\n                except UnicodeDecodeError:\n                    try:\n                        line = str(line.decode('utf-8'))\n                    except UnicodeDecodeError:\n                        try:\n                            line = str(line.decode('latin-1'))\n                        except UnicodeDecodeError:\n                            line = \"%s\" % line\n            if (line.count(\"{\\n\") >= 1) or (line.count(\"{\\r\\n\") >= 1):\n                parsingHeader = True\n                Index = self.NumImages\n                self.NumImages = self.NumImages + 1\n                self.Images.append(Image())\n#            Position = self.File.tell()\n\n            if line.count(\"=\") >= 1:\n                listItems = line.split(\"=\", 1)\n                typeItem = listItems[0].strip()\n                listItems = listItems[1].split(\";\", 1)\n                valueItem = listItems[0].strip()\n                if (typeItem == \"HEADER_BYTES\") and (Index == 0):\n                    self.ADSC = True\n                    break\n\n                #if typeItem in self.Images[Index].StaticHeader.keys():\n                if typeItem.upper() in STATIC_HEADER_ELEMENTS_CAPS:\n                    self.Images[Index].StaticHeader[typeItem] = valueItem\n                else:\n                    self.Images[Index].Header[typeItem] = valueItem\n            if ((line.count(\"}\\n\") >= 1) or (line.count(\"}\\r\") >= 1)) and (parsingHeader):\n                parsingHeader = False\n                #for i in STATIC_HEADER_ELEMENTS_CAPS:\n                #    if self.Images[Index].StaticHeader[i]==\"\":\n                #        raise \"Bad File Format\"\n                self.Images[Index].DataPosition = self.File.tell()\n                #self.File.seek(int(self.Images[Index].StaticHeader[\"Size\"]), 1)\n                StaticPar = SetDictCase(self.Images[Index].StaticHeader, UPPER_CASE, KEYS)\n                if \"SIZE\" in StaticPar.keys():\n                    self.Images[Index].Size = int(StaticPar[\"SIZE\"])\n                    if self.Images[Index].Size <= 0:\n                        self.NumImages = Index\n                        line = self.File.readline()\n                        continue\n                else:\n                    raise TypeError(\"EdfFile: Image doesn't have size information\")\n                if \"DIM_1\" in StaticPar.keys():\n                    self.Images[Index].Dim1 = int(StaticPar[\"DIM_1\"])\n                    self.Images[Index].Offset1 = int(\\\n                                            StaticPar.get(\"Offset_1\", \"0\"))\n                else:\n                    raise TypeError(\"EdfFile: Image doesn't have dimension information\")\n                if \"DIM_2\" in StaticPar.keys():\n                    self.Images[Index].NumDim = 2\n                    self.Images[Index].Dim2 = int(StaticPar[\"DIM_2\"])\n                    self.Images[Index].Offset2 = int(\\\n                                            StaticPar.get(\"Offset_2\", \"0\"))\n                if \"DIM_3\" in StaticPar.keys():\n                    self.Images[Index].NumDim = 3\n                    self.Images[Index].Dim3 = int(StaticPar[\"DIM_3\"])\n                    self.Images[Index].Offset3 = int(\\\n                                            StaticPar.get(\"Offset_3\", \"0\"))\n                if \"DATATYPE\" in StaticPar.keys():\n                    self.Images[Index].DataType = StaticPar[\"DATATYPE\"]\n                else:\n                    raise TypeError(\"EdfFile: Image doesn't have datatype information\")\n                if \"BYTEORDER\" in StaticPar.keys():\n                    self.Images[Index].ByteOrder = StaticPar[\"BYTEORDER\"]\n                else:\n                    raise TypeError(\"EdfFile: Image doesn't have byteorder information\")\n\n\n\n                self.File.seek(self.Images[Index].Size, 1)\n\n            line = self.File.readline()\n\n        if self.ADSC:\n            self.File.seek(0, 0)\n            self.NumImages = 1\n            #this is a bad implementation of fabio adscimage\n            #please take a look at the fabio module of fable at sourceforge\n            infile = self.File\n            header_keys = []\n            header = {}\n            try:\n                \"\"\" read an adsc header \"\"\"\n                line = infile.readline()\n                bytesread = len(line)\n                while '}' not in line:\n                    if '=' in line:\n                        (key, val) = line.split('=')\n                        header_keys.append(key.strip())\n                        header[key.strip()] = val.strip(' ;\\n')\n                    line = infile.readline()\n                    bytesread = bytesread + len(line)\n            except:\n                raise Exception(\"Error processing adsc header\")\n            # banned by bzip/gzip???\n            try:\n                infile.seek(int(header['HEADER_BYTES']), 0)\n            except TypeError:\n                # Gzipped does not allow a seek and read header is not\n                # promising to stop in the right place\n                infile.close()\n                infile = self._open(fname, \"rb\")\n                infile.read(int(header['HEADER_BYTES']))\n            binary = infile.read()\n            infile.close()\n\n            #now read the data into the array\n            self.Images[Index].Dim1 = int(header['SIZE1'])\n            self.Images[Index].Dim2 = int(header['SIZE2'])\n            self.Images[Index].NumDim = 2\n            self.Images[Index].DataType = 'UnsignedShort'\n            try:\n                self.__data = numpy.reshape(\n                    numpy.fromstring(binary, numpy.uint16),\n                    (self.Images[Index].Dim2, self.Images[Index].Dim1))\n            except ValueError:\n                raise IOError('Size spec in ADSC-header does not match ' + \\\n                    'size of image data field')\n            if 'little' in header['BYTE_ORDER']:\n                self.Images[Index].ByteOrder = 'LowByteFirst'\n            else:\n                self.Images[Index].ByteOrder = 'HighByteFirst'\n            if self.SysByteOrder.upper() != self.Images[Index].ByteOrder.upper():\n                self.__data = self.__data.byteswap()\n                self.Images[Index].ByteOrder = self.SysByteOrder\n\n            self.Images[Index].StaticHeader['Dim_1'] = self.Images[Index].Dim1\n            self.Images[Index].StaticHeader['Dim_2'] = self.Images[Index].Dim2\n            self.Images[Index].StaticHeader['Offset_1'] = 0\n            self.Images[Index].StaticHeader['Offset_2'] = 0\n            self.Images[Index].StaticHeader['DataType'] = self.Images[Index].DataType\n\n        self.__makeSureFileIsClosed()",
  "def _wrapTIFF(self):\n        self._wrappedInstance = TiffIO.TiffIO(self.File, cache_length = 0, mono_output=True)\n        self.NumImages = self._wrappedInstance.getNumberOfImages()\n        if self.NumImages < 1:\n            return\n\n        # wrapped image objects have to provide getInfo and getData\n        # info = self._wrappedInstance.getInfo( index)\n        # data = self._wrappedInstance.getData( index)\n        # for the time being I am going to assume all the images\n        # in the file have the same data type type\n        data = None\n\n        for Index in range(self.NumImages):\n            info = self._wrappedInstance.getInfo(Index)\n            self.Images.append(Image())\n            self.Images[Index].Dim1 = info['nRows']\n            self.Images[Index].Dim2 = info['nColumns']\n            self.Images[Index].NumDim = 2\n            if data is None:\n                data = self._wrappedInstance.getData(0)\n            self.Images[Index].DataType = self.__GetDefaultEdfType__(data.dtype)\n            self.Images[Index].StaticHeader['Dim_1'] = self.Images[Index].Dim1\n            self.Images[Index].StaticHeader['Dim_2'] = self.Images[Index].Dim2\n            self.Images[Index].StaticHeader['Offset_1'] = 0\n            self.Images[Index].StaticHeader['Offset_2'] = 0\n            self.Images[Index].StaticHeader['DataType'] = self.Images[Index].DataType\n            self.Images[Index].Header.update(info)",
  "def _wrapMarCCD(self):\n        mccd = MarCCD.MarCCD(self.File)\n        self.NumImages = 1\n        self.__data = mccd.getData()\n        self.__info = mccd.getInfo()\n        self.Images.append(Image())\n        Index = 0\n        self.Images[Index].Dim1 = self.__data.shape[0]\n        self.Images[Index].Dim2 = self.__data.shape[1]\n        self.Images[Index].NumDim = 2\n        if self.__data.dtype == numpy.uint8:\n            self.Images[Index].DataType = 'UnsignedByte'\n        elif self.__data.dtype == numpy.uint16:\n            self.Images[Index].DataType = 'UnsignedShort'\n        else:\n            self.Images[Index].DataType = 'UnsignedInteger'\n        self.Images[Index].StaticHeader['Dim_1'] = self.Images[Index].Dim1\n        self.Images[Index].StaticHeader['Dim_2'] = self.Images[Index].Dim2\n        self.Images[Index].StaticHeader['Offset_1'] = 0\n        self.Images[Index].StaticHeader['Offset_2'] = 0\n        self.Images[Index].StaticHeader['DataType'] = self.Images[Index].DataType\n        self.Images[Index].Header.update(self.__info)",
  "def _wrapPilatusCBF(self):\n        mccd = PilatusCBF.PilatusCBF(self.File)\n        self.NumImages = 1\n        self.__data = mccd.getData()\n        self.__info = mccd.getInfo()\n        self.Images.append(Image())\n        Index = 0\n        self.Images[Index].Dim1 = self.__data.shape[0]\n        self.Images[Index].Dim2 = self.__data.shape[1]\n        self.Images[Index].NumDim = 2\n        if self.__data.dtype == numpy.uint8:\n            self.Images[Index].DataType = 'UnsignedByte'\n        elif self.__data.dtype == numpy.uint16:\n            self.Images[Index].DataType = 'UnsignedShort'\n        else:\n            self.Images[Index].DataType = 'UnsignedInteger'\n        self.Images[Index].StaticHeader['Dim_1'] = self.Images[Index].Dim1\n        self.Images[Index].StaticHeader['Dim_2'] = self.Images[Index].Dim2\n        self.Images[Index].StaticHeader['Offset_1'] = 0\n        self.Images[Index].StaticHeader['Offset_2'] = 0\n        self.Images[Index].StaticHeader['DataType'] = self.Images[Index].DataType\n        self.Images[Index].Header.update(self.__info)",
  "def _wrapSPE(self):\n        if 0 and sys.version < '3.0':\n            self.File.seek(42)\n            xdim = numpy.int64(numpy.fromfile(self.File, numpy.int16, 1)[0])\n            self.File.seek(656)\n            ydim = numpy.int64(numpy.fromfile(self.File, numpy.int16, 1))\n            self.File.seek(4100)\n            self.__data = numpy.fromfile(self.File, numpy.uint16, int(xdim * ydim))\n        else:\n            import struct\n            self.File.seek(0)\n            a = self.File.read()\n            xdim = numpy.int64(struct.unpack('<h', a[42:44])[0])\n            ydim = numpy.int64(struct.unpack('<h', a[656:658])[0])\n            fmt = '<%dH' % int(xdim * ydim)\n            self.__data = numpy.array(struct.unpack(fmt, a[4100:int(4100+ int(2 * xdim * ydim))])).astype(numpy.uint16)\n        self.__data.shape = ydim, xdim\n        Index = 0\n        self.Images.append(Image())\n        self.NumImages = 1\n        self.Images[Index].Dim1 = ydim\n        self.Images[Index].Dim2 = xdim\n        self.Images[Index].NumDim = 2\n        self.Images[Index].DataType = 'UnsignedShort'\n        self.Images[Index].ByteOrder = 'LowByteFirst'\n        if self.SysByteOrder.upper() != self.Images[Index].ByteOrder.upper():\n            self.__data = self.__data.byteswap()\n        self.Images[Index].StaticHeader['Dim_1'] = self.Images[Index].Dim1\n        self.Images[Index].StaticHeader['Dim_2'] = self.Images[Index].Dim2\n        self.Images[Index].StaticHeader['Offset_1'] = 0\n        self.Images[Index].StaticHeader['Offset_2'] = 0\n        self.Images[Index].StaticHeader['DataType'] = self.Images[Index].DataType",
  "def GetNumImages(self):\n        \"\"\" Returns number of images of the object (and associated file)\n        \"\"\"\n        return self.NumImages",
  "def GetData(self, *var, **kw):\n        try:\n            self.__makeSureFileIsOpen()\n            return self._GetData(*var, **kw)\n        finally:\n            self.__makeSureFileIsClosed()",
  "def _GetData(self, Index, DataType=\"\", Pos=None, Size=None):\n        \"\"\" Returns numpy array with image data\n            Index:          The zero-based index of the image in the file\n            DataType:       The edf type of the array to be returnd\n                            If ommited, it is used the default one for the type\n                            indicated in the image header\n                            Attention to the absence of UnsignedShort,\n                            UnsignedInteger and UnsignedLong types in\n                            Numpy Python\n                            Default relation between Edf types and NumPy's typecodes:\n                                SignedByte          int8   b\n                                UnsignedByte        uint8  B\n                                SignedShort         int16  h\n                                UnsignedShort       uint16 H\n                                SignedInteger       int32  i\n                                UnsignedInteger     uint32 I\n                                SignedLong          int32  i\n                                UnsignedLong        uint32 I\n                                Signed64            int64  (l in 64bit, q in 32 bit)\n                                Unsigned64          uint64 (L in 64bit, Q in 32 bit)\n                                FloatValue          float32 f\n                                DoubleValue         float64 d\n            Pos:            Tuple (x) or (x,y) or (x,y,z) that indicates the begining\n                            of data to be read. If ommited, set to the origin (0),\n                            (0,0) or (0,0,0)\n            Size:           Tuple, size of the data to be returned as x) or (x,y) or\n                            (x,y,z) if ommited, is the distance from Pos to the end.\n\n            If Pos and Size not mentioned, returns the whole data.\n        \"\"\"\n        fastedf = self.fastedf\n        if Index < 0 or Index >= self.NumImages:\n            raise ValueError(\"EdfFile: Index out of limit\")\n        if fastedf is None:fastedf = 0\n        if Pos is None and Size is None:\n            if self.ADSC or self.MARCCD or self.PILATUS_CBF or self.SPE:\n                return self.__data\n            elif self.TIFF:\n                data = self._wrappedInstance.getData(Index)\n                return data\n            else:\n                self.File.seek(self.Images[Index].DataPosition, 0)\n                datatype = self.__GetDefaultNumpyType__(self.Images[Index].DataType, index=Index)\n                try:\n                    datasize = self.__GetSizeNumpyType__(datatype)\n                except TypeError:\n                    print(\"What is the meaning of this error?\")\n                    datasize = 8\n                if self.Images[Index].NumDim == 3:\n                    sizeToRead = self.Images[Index].Dim1 * \\\n                                 self.Images[Index].Dim2 * \\\n                                 self.Images[Index].Dim3 * datasize\n                    Data = numpy.fromstring(self.File.read(sizeToRead),\n                                datatype)\n                    Data = numpy.reshape(Data, (self.Images[Index].Dim3, self.Images[Index].Dim2, self.Images[Index].Dim1))\n                elif self.Images[Index].NumDim == 2:\n                    sizeToRead = self.Images[Index].Dim1 * \\\n                                 self.Images[Index].Dim2 * datasize\n                    Data = numpy.fromstring(self.File.read(sizeToRead),\n                                datatype)\n                    #print \"datatype = \",datatype\n                    #print \"Data.type = \", Data.dtype.char\n                    #print \"self.Images[Index].DataType \", self.Images[Index].DataType\n                    #print \"Data.shape\",Data.shape\n                    #print \"datasize = \",datasize\n                    #print \"sizeToRead \",sizeToRead\n                    #print \"lenData = \", len(Data)\n                    Data = numpy.reshape(Data, (self.Images[Index].Dim2, self.Images[Index].Dim1))\n                elif self.Images[Index].NumDim == 1:\n                    sizeToRead = self.Images[Index].Dim1 * datasize\n                    Data = numpy.fromstring(self.File.read(sizeToRead),\n                                datatype)\n        elif self.ADSC or self.MARCCD or self.PILATUS_CBF or self.SPE:\n            return self.__data[Pos[1]:(Pos[1] + Size[1]),\n                               Pos[0]:(Pos[0] + Size[0])]\n        elif self.TIFF:\n            data = self._wrappedInstance.getData(Index)\n            return data[Pos[1]:(Pos[1] + Size[1]),\n                               Pos[0]:(Pos[0] + Size[0])]\n        elif fastedf and CAN_USE_FASTEDF:\n            type = self.__GetDefaultNumpyType__(self.Images[Index].DataType, index=Index)\n            size_pixel = self.__GetSizeNumpyType__(type)\n            Data = numpy.array([], type)\n            if self.Images[Index].NumDim == 1:\n                if Pos == None: Pos = (0,)\n                if Size == None: Size = (0,)\n                sizex = self.Images[Index].Dim1\n                Size = list(Size)\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                self.File.seek((Pos[0] * size_pixel) + self.Images[Index].DataPosition, 0)\n                Data = numpy.fromstring(self.File.read(Size[0] * size_pixel), type)\n            elif self.Images[Index].NumDim == 2:\n                if Pos == None: Pos = (0, 0)\n                if Size == None: Size = (0, 0)\n                Size = list(Size)\n                sizex, sizey = self.Images[Index].Dim1, self.Images[Index].Dim2\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                if Size[1] == 0:Size[1] = sizey - Pos[1]\n                Data = numpy.zeros([Size[1], Size[0]], type)\n                self.File.seek((((Pos[1] * sizex) + Pos[0]) * size_pixel) + self.Images[Index].DataPosition, 0)\n                extended_fread(Data, Size[0] * size_pixel , numpy.array([Size[1]]),\n                               numpy.array([sizex * size_pixel]) , self.File)\n\n            elif self.Images[Index].NumDim == 3:\n                if Pos == None: Pos = (0, 0, 0)\n                if Size == None: Size = (0, 0, 0)\n                Size = list(Size)\n                sizex, sizey, sizez = self.Images[Index].Dim1, self.Images[Index].Dim2, self.Images[Index].Dim3\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                if Size[1] == 0:Size[1] = sizey - Pos[1]\n                if Size[2] == 0:Size[2] = sizez - Pos[2]\n                Data = numpy.zeros([Size[2], Size[1], Size[0]], type)\n                self.File.seek(((((Pos[2] * sizey + Pos[1]) * sizex) + Pos[0]) * size_pixel) + self.Images[Index].DataPosition, 0)\n                extended_fread(Data, Size[0] * size_pixel , numpy.array([Size[2], Size[1]]),\n                        numpy.array([ sizey * sizex * size_pixel , sizex * size_pixel]) , self.File)\n\n        else:\n            if fastedf:\n                print(\"I could not use fast routines\")\n            type = self.__GetDefaultNumpyType__(self.Images[Index].DataType, index=Index)\n            size_pixel = self.__GetSizeNumpyType__(type)\n            Data = numpy.array([], type)\n            if self.Images[Index].NumDim == 1:\n                if Pos == None: Pos = (0,)\n                if Size == None: Size = (0,)\n                sizex = self.Images[Index].Dim1\n                Size = list(Size)\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                self.File.seek((Pos[0] * size_pixel) + self.Images[Index].DataPosition, 0)\n                Data = numpy.fromstring(self.File.read(Size[0] * size_pixel), type)\n            elif self.Images[Index].NumDim == 2:\n                if Pos == None: Pos = (0, 0)\n                if Size == None: Size = (0, 0)\n                Size = list(Size)\n                sizex, sizey = self.Images[Index].Dim1, self.Images[Index].Dim2\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                if Size[1] == 0:Size[1] = sizey - Pos[1]\n                #print len(range(Pos[1],Pos[1]+Size[1])), \"LECTURES OF \", Size[0], \"POINTS\"\n                #print \"sizex = \", sizex, \"sizey = \", sizey\n                Data = numpy.zeros((Size[1], Size[0]), type)\n                dataindex = 0\n                for y in range(Pos[1], Pos[1] + Size[1]):\n                    self.File.seek((((y * sizex) + Pos[0]) * size_pixel) + self.Images[Index].DataPosition, 0)\n                    line = numpy.fromstring(self.File.read(Size[0] * size_pixel), type)\n                    Data[dataindex, :] = line[:]\n                    #Data=numpy.concatenate((Data,line))\n                    dataindex += 1\n                #print \"DataSize = \",Data.shape\n                #print \"Requested reshape = \",Size[1],'x',Size[0]\n                #Data = numpy.reshape(Data, (Size[1],Size[0]))\n            elif self.Images[Index].NumDim == 3:\n                if Pos == None: Pos = (0, 0, 0)\n                if Size == None: Size = (0, 0, 0)\n                Size = list(Size)\n                sizex, sizey, sizez = self.Images[Index].Dim1, self.Images[Index].Dim2, self.Images[Index].Dim3\n                if Size[0] == 0:Size[0] = sizex - Pos[0]\n                if Size[1] == 0:Size[1] = sizey - Pos[1]\n                if Size[2] == 0:Size[2] = sizez - Pos[2]\n                for z in range(Pos[2], Pos[2] + Size[2]):\n                    for y in range(Pos[1], Pos[1] + Size[1]):\n                        self.File.seek(((((z * sizey + y) * sizex) + Pos[0]) * size_pixel) + self.Images[Index].DataPosition, 0)\n                        line = numpy.fromstring(self.File.read(Size[0] * size_pixel), type)\n                        Data = numpy.concatenate((Data, line))\n                Data = numpy.reshape(Data, (Size[2], Size[1], Size[0]))\n\n        if self.SysByteOrder.upper() != self.Images[Index].ByteOrder.upper():\n            Data = Data.byteswap()\n        if DataType != \"\":\n            Data = self.__SetDataType__ (Data, DataType)\n        return Data",
  "def GetPixel(self, Index, Position):\n        \"\"\" Returns double value of the pixel, regardless the format of the array\n            Index:      The zero-based index of the image in the file\n            Position:   Tuple with the coordinete (x), (x,y) or (x,y,z)\n        \"\"\"\n        if Index < 0 or Index >= self.NumImages:\n            raise ValueError(\"EdfFile: Index out of limit\")\n        if len(Position) != self.Images[Index].NumDim:\n            raise ValueError(\"EdfFile: coordinate with wrong dimension \")\n\n        size_pixel = self.__GetSizeNumpyType__(self.__GetDefaultNumpyType__(self.Images[Index].DataType), index=Index)\n        offset = Position[0] * size_pixel\n        if self.Images[Index].NumDim > 1:\n            size_row = size_pixel * self.Images[Index].Dim1\n            offset = offset + (Position[1] * size_row)\n            if self.Images[Index].NumDim == 3:\n                size_img = size_row * self.Images[Index].Dim2\n                offset = offset + (Position[2] * size_img)\n        self.File.seek(self.Images[Index].DataPosition + offset, 0)\n        Data = numpy.fromstring(self.File.read(size_pixel), self.__GetDefaultNumpyType__(self.Images[Index].DataType, index=Index))\n        if self.SysByteOrder.upper() != self.Images[Index].ByteOrder.upper():\n            Data = Data.byteswap()\n        Data = self.__SetDataType__ (Data, \"DoubleValue\")\n        return Data[0]",
  "def GetHeader(self, Index):\n        \"\"\" Returns dictionary with image header fields.\n            Does not include the basic fields (static) defined by data shape,\n            type and file position. These are get with GetStaticHeader\n            method.\n            Index:          The zero-based index of the image in the file\n        \"\"\"\n        if Index < 0 or Index >= self.NumImages:\n            raise ValueError(\"Index out of limit\")\n        #return self.Images[Index].Header\n        ret = {}\n        for i in self.Images[Index].Header.keys():\n            ret[i] = self.Images[Index].Header[i]\n        return ret",
  "def GetStaticHeader(self, Index):\n        \"\"\" Returns dictionary with static parameters\n            Data format and file position dependent information\n            (dim1,dim2,size,datatype,byteorder,headerId,Image)\n            Index:          The zero-based index of the image in the file\n        \"\"\"\n        if Index < 0 or Index >= self.NumImages:\n            raise ValueError(\"Index out of limit\")\n        #return self.Images[Index].StaticHeader\n        ret = {}\n        for i in self.Images[Index].StaticHeader.keys():\n            ret[i] = self.Images[Index].StaticHeader[i]\n        return ret",
  "def WriteImage(self, *var, **kw):\n        try:\n            self.__makeSureFileIsOpen()\n            return self._WriteImage(*var, **kw)\n        finally:\n            self.__makeSureFileIsClosed()",
  "def _WriteImage (self, Header, Data, Append=1, DataType=\"\", ByteOrder=\"\"):\n        \"\"\" Writes image to the file.\n            Header:         Dictionary containing the non-static header\n                            information (static information is generated\n                            according to position of image and data format\n            Append:         If equals to 0, overwrites the file. Otherwise, appends\n                            to the end of the file\n            DataType:       The data type to be saved to the file:\n                                SignedByte\n                                UnsignedByte\n                                SignedShort\n                                UnsignedShort\n                                SignedInteger\n                                UnsignedInteger\n                                SignedLong\n                                UnsignedLong\n                                FloatValue\n                                DoubleValue\n                            Default: according to Data array typecode:\n                                    1:  SignedByte\n                                    b:  UnsignedByte\n                                    s:  SignedShort\n\t\t\t\t    w:  UnsignedShort\n                                    i:  SignedInteger\n                                    l:  SignedLong\n\t\t\t\t    u:  UnsignedLong\n                                    f:  FloatValue\n                                    d:  DoubleValue\n            ByteOrder:      Byte order of the data in file:\n                                HighByteFirst\n                                LowByteFirst\n                            Default: system's byte order\n        \"\"\"\n        if Append == 0:\n            self.File.truncate(0)\n            self.Images = []\n            self.NumImages = 0\n        Index = self.NumImages\n        self.NumImages = self.NumImages + 1\n        self.Images.append(Image())\n\n        #self.Images[Index].StaticHeader[\"Dim_1\"] = \"%d\" % Data.shape[1]\n        #self.Images[Index].StaticHeader[\"Dim_2\"] = \"%d\" % Data.shape[0]\n        if len(Data.shape) == 1:\n            self.Images[Index].Dim1 = Data.shape[0]\n            self.Images[Index].StaticHeader[\"Dim_1\"] = \"%d\" % self.Images[Index].Dim1\n            self.Images[Index].Size = (Data.shape[0] * \\\n                                     self.__GetSizeNumpyType__(Data.dtype))\n        elif len(Data.shape) == 2:\n            self.Images[Index].Dim1 = Data.shape[1]\n            self.Images[Index].Dim2 = Data.shape[0]\n            self.Images[Index].StaticHeader[\"Dim_1\"] = \"%d\" % self.Images[Index].Dim1\n            self.Images[Index].StaticHeader[\"Dim_2\"] = \"%d\" % self.Images[Index].Dim2\n            self.Images[Index].Size = (Data.shape[0] * Data.shape[1] * \\\n                                     self.__GetSizeNumpyType__(Data.dtype))\n            self.Images[Index].NumDim = 2\n        elif len(Data.shape) == 3:\n            self.Images[Index].Dim1 = Data.shape[2]\n            self.Images[Index].Dim2 = Data.shape[1]\n            self.Images[Index].Dim3 = Data.shape[0]\n            self.Images[Index].StaticHeader[\"Dim_1\"] = \"%d\" % self.Images[Index].Dim1\n            self.Images[Index].StaticHeader[\"Dim_2\"] = \"%d\" % self.Images[Index].Dim2\n            self.Images[Index].StaticHeader[\"Dim_3\"] = \"%d\" % self.Images[Index].Dim3\n            self.Images[Index].Size = (Data.shape[0] * Data.shape[1] * Data.shape[2] * \\\n                                     self.__GetSizeNumpyType__(Data.dtype))\n            self.Images[Index].NumDim = 3\n        elif len(Data.shape) > 3:\n            raise TypeError(\"EdfFile: Data dimension not suported\")\n\n\n        if DataType == \"\":\n            self.Images[Index].DataType = self.__GetDefaultEdfType__(Data.dtype)\n        else:\n            self.Images[Index].DataType = DataType\n            Data = self.__SetDataType__ (Data, DataType)\n\n        if ByteOrder == \"\":\n            self.Images[Index].ByteOrder = self.SysByteOrder\n        else:\n            self.Images[Index].ByteOrder = ByteOrder\n\n        self.Images[Index].StaticHeader[\"Size\"] = \"%d\" % self.Images[Index].Size\n        self.Images[Index].StaticHeader[\"Image\"] = Index + 1\n        self.Images[Index].StaticHeader[\"HeaderID\"] = \"EH:%06d:000000:000000\" % self.Images[Index].StaticHeader[\"Image\"]\n        self.Images[Index].StaticHeader[\"ByteOrder\"] = self.Images[Index].ByteOrder\n        self.Images[Index].StaticHeader[\"DataType\"] = self.Images[Index].DataType\n\n\n        self.Images[Index].Header = {}\n        self.File.seek(0, 2)\n        StrHeader = \"{\\n\"\n        for i in STATIC_HEADER_ELEMENTS:\n            if i in self.Images[Index].StaticHeader.keys():\n                StrHeader = StrHeader + (\"%s = %s ;\\n\" % (i , self.Images[Index].StaticHeader[i]))\n        for i in Header.keys():\n            StrHeader = StrHeader + (\"%s = %s ;\\n\" % (i, Header[i]))\n            self.Images[Index].Header[i] = Header[i]\n        newsize = (((len(StrHeader) + 1) / HEADER_BLOCK_SIZE) + 1) * HEADER_BLOCK_SIZE - 2\n        newsize = int(newsize)\n        StrHeader = StrHeader.ljust(newsize)\n        StrHeader = StrHeader + \"}\\n\"\n\n        self.Images[Index].HeaderPosition = self.File.tell()\n        self.File.write(StrHeader.encode())\n        self.Images[Index].DataPosition = self.File.tell()\n\n        #if self.Images[Index].StaticHeader[\"ByteOrder\"] != self.SysByteOrder:\n        if self.Images[Index].ByteOrder.upper() != self.SysByteOrder.upper():\n            self.File.write((Data.byteswap()).tostring())\n        else:\n            self.File.write(Data.tostring())",
  "def __makeSureFileIsOpen(self):\n        if DEBUG:\n            print(\"Making sure file is open\")\n        if not self.__ownedOpen:\n            return\n        if self.ADSC or self.MARCCD or self.PILATUS_CBF or self.SPE:\n            if DEBUG:\n                print(\"Special case. Image is buffered\")\n            return\n        if self.File in [0, None]:\n            if DEBUG:\n                print(\"File is None\")\n        elif self.File.closed:\n            if DEBUG:\n                print(\"Reopening closed file\")\n            accessMode = self.File.mode\n            fileName = self.File.name\n            newFile = open(fileName, accessMode)\n            self.File  = newFile\n        return",
  "def __makeSureFileIsClosed(self):\n        if DEBUG:\n            print(\"Making sure file is closed\")\n        if not self.__ownedOpen:\n            return\n        if self.ADSC or self.MARCCD or self.PILATUS_CBF or self.SPE:\n            if DEBUG:\n                print(\"Special case. Image is buffered\")\n            return\n        if self.File in [0, None]:\n            if DEBUG:\n                print(\"File is None\")\n        elif not self.File.closed:\n            if DEBUG:\n                print(\"Closing file\")\n            self.File.close()\n        return",
  "def __GetDefaultNumpyType__(self, EdfType, index=None):\n        \"\"\" Internal method: returns NumPy type according to Edf type\n        \"\"\"\n        return self.GetDefaultNumpyType(EdfType, index)",
  "def __GetDefaultEdfType__(self, NumpyType):\n        \"\"\" Internal method: returns Edf type according Numpy type\n        \"\"\"\n        if   NumpyType in [\"b\", numpy.int8]:            return \"SignedByte\"\n        elif NumpyType in [\"B\", numpy.uint8]:            return \"UnsignedByte\"\n        elif NumpyType in [\"h\", numpy.int16]:            return \"SignedShort\"\n        elif NumpyType in [\"H\", numpy.uint16]:            return \"UnsignedShort\"\n        elif NumpyType in [\"i\", numpy.int32]:            return \"SignedInteger\"\n        elif NumpyType in [\"I\", numpy.uint32]:            return \"UnsignedInteger\"\n        elif NumpyType == \"l\":\n            if sys.platform == 'linux2':\n                return \"Signed64\"\n            else:\n                return \"SignedLong\"\n        elif NumpyType == \"L\":\n            if sys.platform == 'linux2':\n                return \"Unsigned64\"\n            else:\n                return \"UnsignedLong\"\n        elif NumpyType == numpy.int64:\n            return \"Signed64\"\n        elif NumpyType == numpy.uint64:\n            return \"Unsigned64\"\n        elif NumpyType in [\"f\", numpy.float32]:\n            return \"FloatValue\"\n        elif NumpyType in [\"d\", numpy.float64]:\n            return \"DoubleValue\"\n        else:\n            raise TypeError(\"unknown NumpyType %s\" % NumpyType)",
  "def __GetSizeNumpyType__(self, NumpyType):\n        \"\"\" Internal method: returns size of NumPy's Array Types\n        \"\"\"\n        if   NumpyType in [\"b\", numpy.int8]:  return 1\n        elif NumpyType in [\"B\", numpy.uint8]:  return 1\n        elif NumpyType in [\"h\", numpy.int16]:  return 2\n        elif NumpyType in [\"H\", numpy.uint16]:  return 2\n        elif NumpyType in [\"i\", numpy.int32]:  return 4\n        elif NumpyType in [\"I\", numpy.uint32]:  return 4\n        elif NumpyType == \"l\":\n            if sys.platform == 'linux2':\n                return 8    #64 bit\n            else:\n                return 4    #32 bit\n        elif NumpyType == \"L\":\n            if sys.platform == 'linux2':\n                return 8    #64 bit\n            else:\n                return 4    #32 bit\n        elif NumpyType in [\"f\", numpy.float32]: return 4\n        elif NumpyType in [\"d\", numpy.float64]: return 8\n        elif NumpyType == \"Q\":            return 8 #unsigned 64 in 32 bit\n        elif NumpyType == \"q\":            return 8 #signed 64 in 32 bit\n        elif NumpyType == numpy.uint64:   return 8\n        elif NumpyType == numpy.int64:    return 8\n        else:\n            raise TypeError(\"unknown NumpyType %s\" % NumpyType)",
  "def __SetDataType__ (self, Array, DataType):\n        \"\"\" Internal method: array type convertion\n        \"\"\"\n        # AVOID problems not using FromEdfType= Array.dtype.char\n        FromEdfType = Array.dtype\n        ToEdfType = self.__GetDefaultNumpyType__(DataType)\n        if ToEdfType != FromEdfType:\n            aux = Array.astype(self.__GetDefaultNumpyType__(DataType))\n            return aux\n        return Array",
  "def __del__(self):\n        try:\n            self.__makeSureFileIsClosed()\n        except:\n            pass",
  "def GetDefaultNumpyType(self, EdfType, index=None):\n        \"\"\" Returns NumPy type according Edf type\n        \"\"\"\n        if index is None:return GetDefaultNumpyType(EdfType)\n        EdfType = EdfType.upper()\n        if EdfType in ['SIGNED64']  :return numpy.int64\n        if EdfType in ['UNSIGNED64']:return numpy.uint64\n        if EdfType in [\"SIGNEDLONG\", \"UNSIGNEDLONG\"]:\n            dim1 = 1\n            dim2 = 1\n            dim3 = 1\n            if hasattr(self.Images[index], \"Dim1\"):\n                dim1 = self.Images[index].Dim1\n                if hasattr(self.Images[index], \"Dim2\"):\n                    dim2 = self.Images[index].Dim2\n                    if dim2 <= 0: dim2 = 1\n                    if hasattr(self.Images[index], \"Dim3\"):\n                        dim3 = self.Images[index].Dim3\n                        if dim3 <= 0: dim3 = 1\n                if hasattr(self.Images[index], \"Size\"):\n                    size = self.Images[index].Size\n                    if size / (dim1 * dim2 * dim3) == 8:\n                        if EdfType == \"UNSIGNEDLONG\":\n                            return numpy.uint64\n                        else:\n                            return numpy.int64\n            if EdfType == \"UNSIGNEDLONG\":\n                return numpy.uint32\n            else:\n                return numpy.int32\n\n        return GetDefaultNumpyType(EdfType)",
  "def _add_doc(func, doc):\n    \"\"\"Add documentation to a function.\"\"\"\n    func.__doc__ = doc",
  "def _import_module(name):\n    \"\"\"Import module, returning the module after the last dot.\"\"\"\n    __import__(name)\n    return sys.modules[name]",
  "class _LazyDescr(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __get__(self, obj, tp):\n        result = self._resolve()\n        setattr(obj, self.name, result)  # Invokes __set__.\n        try:\n            # This is a bit ugly, but it avoids running this again by\n            # removing this descriptor.\n            delattr(obj.__class__, self.name)\n        except AttributeError:\n            pass\n        return result",
  "class MovedModule(_LazyDescr):\n\n    def __init__(self, name, old, new=None):\n        super(MovedModule, self).__init__(name)\n        if PY3:\n            if new is None:\n                new = name\n            self.mod = new\n        else:\n            self.mod = old\n\n    def _resolve(self):\n        return _import_module(self.mod)\n\n    def __getattr__(self, attr):\n        _module = self._resolve()\n        value = getattr(_module, attr)\n        setattr(self, attr, value)\n        return value",
  "class _LazyModule(types.ModuleType):\n\n    def __init__(self, name):\n        super(_LazyModule, self).__init__(name)\n        self.__doc__ = self.__class__.__doc__\n\n    def __dir__(self):\n        attrs = [\"__doc__\", \"__name__\"]\n        attrs += [attr.name for attr in self._moved_attributes]\n        return attrs\n\n    # Subclasses should override this\n    _moved_attributes = []",
  "class MovedAttribute(_LazyDescr):\n\n    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):\n        super(MovedAttribute, self).__init__(name)\n        if PY3:\n            if new_mod is None:\n                new_mod = name\n            self.mod = new_mod\n            if new_attr is None:\n                if old_attr is None:\n                    new_attr = name\n                else:\n                    new_attr = old_attr\n            self.attr = new_attr\n        else:\n            self.mod = old_mod\n            if old_attr is None:\n                old_attr = name\n            self.attr = old_attr\n\n    def _resolve(self):\n        module = _import_module(self.mod)\n        return getattr(module, self.attr)",
  "class _SixMetaPathImporter(object):\n\n    \"\"\"\n    A meta path importer to import six.moves and its submodules.\n\n    This class implements a PEP302 finder and loader. It should be compatible\n    with Python 2.5 and all existing versions of Python3\n    \"\"\"\n\n    def __init__(self, six_module_name):\n        self.name = six_module_name\n        self.known_modules = {}\n\n    def _add_module(self, mod, *fullnames):\n        for fullname in fullnames:\n            self.known_modules[self.name + \".\" + fullname] = mod\n\n    def _get_module(self, fullname):\n        return self.known_modules[self.name + \".\" + fullname]\n\n    def find_module(self, fullname, path=None):\n        if fullname in self.known_modules:\n            return self\n        return None\n\n    def __get_module(self, fullname):\n        try:\n            return self.known_modules[fullname]\n        except KeyError:\n            raise ImportError(\"This loader does not know module \" + fullname)\n\n    def load_module(self, fullname):\n        try:\n            # in case of a reload\n            return sys.modules[fullname]\n        except KeyError:\n            pass\n        mod = self.__get_module(fullname)\n        if isinstance(mod, MovedModule):\n            mod = mod._resolve()\n        else:\n            mod.__loader__ = self\n        sys.modules[fullname] = mod\n        return mod\n\n    def is_package(self, fullname):\n        \"\"\"\n        Return true, if the named module is a package.\n\n        We need this method to get correct spec objects with\n        Python 3.4 (see PEP451)\n        \"\"\"\n        return hasattr(self.__get_module(fullname), \"__path__\")\n\n    def get_code(self, fullname):\n        \"\"\"Return None\n\n        Required, if is_package is implemented\"\"\"\n        self.__get_module(fullname)  # eventually raises ImportError\n        return None\n    get_source = get_code",
  "class _MovedItems(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects\"\"\"\n    __path__ = []",
  "class Module_six_moves_urllib_parse(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_parse\"\"\"",
  "class Module_six_moves_urllib_error(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_error\"\"\"",
  "class Module_six_moves_urllib_request(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_request\"\"\"",
  "class Module_six_moves_urllib_response(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_response\"\"\"",
  "class Module_six_moves_urllib_robotparser(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_robotparser\"\"\"",
  "class Module_six_moves_urllib(types.ModuleType):\n\n    \"\"\"Create a six.moves.urllib namespace that resembles the Python 3 namespace\"\"\"\n    __path__ = []  # mark as package\n    parse = _importer._get_module(\"moves.urllib_parse\")\n    error = _importer._get_module(\"moves.urllib_error\")\n    request = _importer._get_module(\"moves.urllib_request\")\n    response = _importer._get_module(\"moves.urllib_response\")\n    robotparser = _importer._get_module(\"moves.urllib_robotparser\")\n\n    def __dir__(self):\n        return ['parse', 'error', 'request', 'response', 'robotparser']",
  "def add_move(move):\n    \"\"\"Add an item to six.moves.\"\"\"\n    setattr(_MovedItems, move.name, move)",
  "def remove_move(name):\n    \"\"\"Remove item from six.moves.\"\"\"\n    try:\n        delattr(_MovedItems, name)\n    except AttributeError:\n        try:\n            del moves.__dict__[name]\n        except KeyError:\n            raise AttributeError(\"no such move, %r\" % (name,))",
  "def assertCountEqual(self, *args, **kwargs):\n    return getattr(self, _assertCountEqual)(*args, **kwargs)",
  "def assertRaisesRegex(self, *args, **kwargs):\n    return getattr(self, _assertRaisesRegex)(*args, **kwargs)",
  "def assertRegex(self, *args, **kwargs):\n    return getattr(self, _assertRegex)(*args, **kwargs)",
  "def with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    # This requires a bit of explanation: the basic idea is to make a dummy\n    # metaclass for one level of class instantiation that replaces itself with\n    # the actual metaclass.\n    class metaclass(meta):\n\n        def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)\n    return type.__new__(metaclass, 'temporary_class', (), {})",
  "def add_metaclass(metaclass):\n    \"\"\"Class decorator for creating a class with a metaclass.\"\"\"\n    def wrapper(cls):\n        orig_vars = cls.__dict__.copy()\n        slots = orig_vars.get('__slots__')\n        if slots is not None:\n            if isinstance(slots, str):\n                slots = [slots]\n            for slots_var in slots:\n                orig_vars.pop(slots_var)\n        orig_vars.pop('__dict__', None)\n        orig_vars.pop('__weakref__', None)\n        return metaclass(cls.__name__, cls.__bases__, orig_vars)\n    return wrapper",
  "def python_2_unicode_compatible(klass):\n    \"\"\"\n    A decorator that defines __unicode__ and __str__ methods under Python 2.\n    Under Python 3 it does nothing.\n\n    To support Python 2 and 3 with a single code base, define a __str__ method\n    returning text and apply this decorator to the class.\n    \"\"\"\n    if PY2:\n        if '__str__' not in klass.__dict__:\n            raise ValueError(\"@python_2_unicode_compatible cannot be applied \"\n                             \"to %s because it doesn't define __str__().\" %\n                             klass.__name__)\n        klass.__unicode__ = klass.__str__\n        klass.__str__ = lambda self: self.__unicode__().encode('utf-8')\n    return klass",
  "def __init__(self, name):\n        self.name = name",
  "def __get__(self, obj, tp):\n        result = self._resolve()\n        setattr(obj, self.name, result)  # Invokes __set__.\n        try:\n            # This is a bit ugly, but it avoids running this again by\n            # removing this descriptor.\n            delattr(obj.__class__, self.name)\n        except AttributeError:\n            pass\n        return result",
  "def __init__(self, name, old, new=None):\n        super(MovedModule, self).__init__(name)\n        if PY3:\n            if new is None:\n                new = name\n            self.mod = new\n        else:\n            self.mod = old",
  "def _resolve(self):\n        return _import_module(self.mod)",
  "def __getattr__(self, attr):\n        _module = self._resolve()\n        value = getattr(_module, attr)\n        setattr(self, attr, value)\n        return value",
  "def __init__(self, name):\n        super(_LazyModule, self).__init__(name)\n        self.__doc__ = self.__class__.__doc__",
  "def __dir__(self):\n        attrs = [\"__doc__\", \"__name__\"]\n        attrs += [attr.name for attr in self._moved_attributes]\n        return attrs",
  "def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):\n        super(MovedAttribute, self).__init__(name)\n        if PY3:\n            if new_mod is None:\n                new_mod = name\n            self.mod = new_mod\n            if new_attr is None:\n                if old_attr is None:\n                    new_attr = name\n                else:\n                    new_attr = old_attr\n            self.attr = new_attr\n        else:\n            self.mod = old_mod\n            if old_attr is None:\n                old_attr = name\n            self.attr = old_attr",
  "def _resolve(self):\n        module = _import_module(self.mod)\n        return getattr(module, self.attr)",
  "def __init__(self, six_module_name):\n        self.name = six_module_name\n        self.known_modules = {}",
  "def _add_module(self, mod, *fullnames):\n        for fullname in fullnames:\n            self.known_modules[self.name + \".\" + fullname] = mod",
  "def _get_module(self, fullname):\n        return self.known_modules[self.name + \".\" + fullname]",
  "def find_module(self, fullname, path=None):\n        if fullname in self.known_modules:\n            return self\n        return None",
  "def __get_module(self, fullname):\n        try:\n            return self.known_modules[fullname]\n        except KeyError:\n            raise ImportError(\"This loader does not know module \" + fullname)",
  "def load_module(self, fullname):\n        try:\n            # in case of a reload\n            return sys.modules[fullname]\n        except KeyError:\n            pass\n        mod = self.__get_module(fullname)\n        if isinstance(mod, MovedModule):\n            mod = mod._resolve()\n        else:\n            mod.__loader__ = self\n        sys.modules[fullname] = mod\n        return mod",
  "def is_package(self, fullname):\n        \"\"\"\n        Return true, if the named module is a package.\n\n        We need this method to get correct spec objects with\n        Python 3.4 (see PEP451)\n        \"\"\"\n        return hasattr(self.__get_module(fullname), \"__path__\")",
  "def get_code(self, fullname):\n        \"\"\"Return None\n\n        Required, if is_package is implemented\"\"\"\n        self.__get_module(fullname)  # eventually raises ImportError\n        return None",
  "def __dir__(self):\n        return ['parse', 'error', 'request', 'response', 'robotparser']",
  "def get_unbound_function(unbound):\n        return unbound",
  "def create_unbound_method(func, cls):\n        return func",
  "def get_unbound_function(unbound):\n        return unbound.im_func",
  "def create_bound_method(func, obj):\n        return types.MethodType(func, obj, obj.__class__)",
  "def create_unbound_method(func, cls):\n        return types.MethodType(func, None, cls)",
  "class Iterator(object):\n\n        def next(self):\n            return type(self).__next__(self)",
  "def iterkeys(d, **kw):\n        return iter(d.keys(**kw))",
  "def itervalues(d, **kw):\n        return iter(d.values(**kw))",
  "def iteritems(d, **kw):\n        return iter(d.items(**kw))",
  "def iterlists(d, **kw):\n        return iter(d.lists(**kw))",
  "def iterkeys(d, **kw):\n        return d.iterkeys(**kw)",
  "def itervalues(d, **kw):\n        return d.itervalues(**kw)",
  "def iteritems(d, **kw):\n        return d.iteritems(**kw)",
  "def iterlists(d, **kw):\n        return d.iterlists(**kw)",
  "def b(s):\n        return s.encode(\"latin-1\")",
  "def u(s):\n        return s",
  "def b(s):\n        return s",
  "def u(s):\n        return unicode(s.replace(r'\\\\', r'\\\\\\\\'), \"unicode_escape\")",
  "def byte2int(bs):\n        return ord(bs[0])",
  "def indexbytes(buf, i):\n        return ord(buf[i])",
  "def reraise(tp, value, tb=None):\n        if value is None:\n            value = tp()\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        raise value",
  "def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")",
  "def print_(*args, **kwargs):\n        \"\"\"The new-style print function for Python 2.4 and 2.5.\"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            # If the file has an encoding, encode unicode with it.\n            if (isinstance(fp, file) and\n                    isinstance(data, unicode) and\n                    fp.encoding is not None):\n                errors = getattr(fp, \"errors\", None)\n                if errors is None:\n                    errors = \"strict\"\n                data = data.encode(fp.encoding, errors)\n            fp.write(data)\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)",
  "def print_(*args, **kwargs):\n        fp = kwargs.get(\"file\", sys.stdout)\n        flush = kwargs.pop(\"flush\", False)\n        _print(*args, **kwargs)\n        if flush and fp is not None:\n            fp.flush()",
  "def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,\n              updated=functools.WRAPPER_UPDATES):\n        def wrapper(f):\n            f = functools.wraps(wrapped, assigned, updated)(f)\n            f.__wrapped__ = wrapped\n            return f\n        return wrapper",
  "class metaclass(meta):\n\n        def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)",
  "def wrapper(cls):\n        orig_vars = cls.__dict__.copy()\n        slots = orig_vars.get('__slots__')\n        if slots is not None:\n            if isinstance(slots, str):\n                slots = [slots]\n            for slots_var in slots:\n                orig_vars.pop(slots_var)\n        orig_vars.pop('__dict__', None)\n        orig_vars.pop('__weakref__', None)\n        return metaclass(cls.__name__, cls.__bases__, orig_vars)",
  "class X(object):\n\n            def __len__(self):\n                return 1 << 31",
  "def advance_iterator(it):\n        return it.next()",
  "def callable(obj):\n        return any(\"__call__\" in klass.__dict__ for klass in type(obj).__mro__)",
  "def next(self):\n            return type(self).__next__(self)",
  "def raise_from(value, from_value):\n        raise value",
  "def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            # If the file has an encoding, encode unicode with it.\n            if (isinstance(fp, file) and\n                    isinstance(data, unicode) and\n                    fp.encoding is not None):\n                errors = getattr(fp, \"errors\", None)\n                if errors is None:\n                    errors = \"strict\"\n                data = data.encode(fp.encoding, errors)\n            fp.write(data)",
  "def wrapper(f):\n            f = functools.wraps(wrapped, assigned, updated)(f)\n            f.__wrapped__ = wrapped\n            return f",
  "def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)",
  "def __len__(self):\n                return 1 << 31",
  "def _bulk_match(string_, list_of_patterns):\n    \"\"\"Check whether a string matches any regular expression pattern in a list\n    \"\"\"\n    for pattern in list_of_patterns:\n        if pattern.match(string_):\n            return True\n    return False",
  "def is_group(name):\n    \"\"\"Check if ``name`` matches a valid group name pattern in a\n    :class:`SpecH5`.\n\n    :param name: Full name of member\n    :type name: str\n    \"\"\"\n    group_patterns = (\n        root_pattern, scan_pattern, instrument_pattern,\n        specfile_group_pattern, positioners_group_pattern,\n        measurement_group_pattern, measurement_mca_group_pattern,\n        instrument_mca_group_pattern\n    )\n    return _bulk_match(name, group_patterns)",
  "def is_dataset(name):\n    \"\"\"Check if ``name`` matches a valid dataset name pattern in a\n    :class:`SpecH5`.\n\n    :param name: Full name of member\n    :type name: str\n    \"\"\"\n    # /1.1/measurement/mca_0 could be interpreted as a data column\n    # with label \"mca_0\"\n    if measurement_mca_group_pattern.match(name):\n        return False\n\n    data_patterns = (\n        header_pattern, title_pattern, start_time_pattern,\n        file_header_data_pattern, scan_header_data_pattern,\n        positioners_data_pattern, measurement_data_pattern,\n        instrument_mca_data_pattern, instrument_mca_calib_pattern,\n        instrument_mca_chann_pattern,\n        instrument_mca_preset_t_pattern, instrument_mca_elapsed_t_pattern,\n        instrument_mca_live_t_pattern\n    )\n    return _bulk_match(name, data_patterns)",
  "def is_link_to_group(name):\n    \"\"\"Check if ``name`` is a valid link to a group in a :class:`SpecH5`.\n    Return ``True`` or ``False``\n\n    :param name: Full name of member\n    :type name: str\n    \"\"\"\n    # so far we only have one type of link to a group\n    if measurement_mca_info_pattern.match(name):\n        return True\n    return False",
  "def is_link_to_dataset(name):\n    \"\"\"Check if ``name`` is a valid link to a dataset in a :class:`SpecH5`.\n    Return ``True`` or ``False``\n\n    :param name: Full name of member\n    :type name: str\n    \"\"\"\n    list_of_link_patterns = (\n        measurement_mca_data_pattern, measurement_mca_info_dataset_pattern,\n    )\n    return _bulk_match(name, list_of_link_patterns)",
  "def _get_attrs_dict(name):\n    \"\"\"Return attributes dictionary corresponding to the group or dataset\n    pointed to by name.\n\n    :param name: Full name/path to data or group\n    :return: attributes dictionary\n    \"\"\"\n    # Associate group and dataset patterns to their attributes\n    pattern_attrs = {\n        root_pattern:\n            {\"NX_class\": \"NXroot\",\n             },\n        scan_pattern:\n            {\"NX_class\": \"NXentry\", },\n        title_pattern:\n            {},\n        start_time_pattern:\n            {},\n        instrument_pattern:\n            {\"NX_class\": \"NXinstrument\", },\n        specfile_group_pattern:\n            {\"NX_class\": \"NXcollection\", },\n        file_header_data_pattern:\n            {},\n        scan_header_data_pattern:\n            {},\n        positioners_group_pattern:\n            {\"NX_class\": \"NXcollection\", },\n        positioners_data_pattern:\n            {},\n        instrument_mca_group_pattern:\n            {\"NX_class\": \"NXdetector\", },\n        instrument_mca_data_pattern:\n            {\"interpretation\": \"spectrum\", },\n        instrument_mca_calib_pattern:\n            {},\n        instrument_mca_chann_pattern:\n            {},\n        instrument_mca_preset_t_pattern:\n            {},\n        instrument_mca_elapsed_t_pattern:\n            {},\n        instrument_mca_live_t_pattern:\n            {},\n        measurement_group_pattern:\n            {\"NX_class\": \"NXcollection\", },\n        measurement_data_pattern:\n            {},\n        measurement_mca_group_pattern:\n            {},\n        measurement_mca_data_pattern:\n            {\"interpretation\": \"spectrum\", },\n        measurement_mca_info_pattern:\n            {\"NX_class\": \"NXdetector\", }\n    }\n\n    for pattern in pattern_attrs:\n        if pattern.match(name):\n            return pattern_attrs[pattern]",
  "def _get_scan_key_in_name(item_name):\n    \"\"\"\n    :param item_name: Name of a group or dataset\n    :return: Scan identification key (e.g. ``\"1.1\"``)\n    :rtype: str on None\n    \"\"\"\n    scan_match = re.match(r\"/([0-9]+\\.[0-9]+)\", item_name)\n    if not scan_match:\n        return None\n    return scan_match.group(1)",
  "def _get_mca_index_in_name(item_name):\n    \"\"\"\n    :param item_name: Name of a group or dataset\n    :return: MCA analyser index, ``None`` if item name does not reference\n        a mca dataset\n    :rtype: int or None\n    \"\"\"\n    mca_match = re.match(r\"/.*/mca_([0-9]+)[^0-9]*\", item_name)\n    if not mca_match:\n        return None\n    return int(mca_match.group(1))",
  "def _get_motor_in_name(item_name):\n    \"\"\"\n    :param item_name: Name of a group or dataset\n    :return: Motor name or ``None``\n    :rtype: str on None\n    \"\"\"\n    motor_match = positioners_data_pattern.match(item_name)\n    if not motor_match:\n        return None\n    return motor_match.group(1)",
  "def _get_data_column_label_in_name(item_name):\n    \"\"\"\n    :param item_name: Name of a group or dataset\n    :return: Data column label or ``None``\n    :rtype: str on None\n    \"\"\"\n    # /1.1/measurement/mca_0 should not be interpreted as the label of a\n    # data column (let's hope no-one ever uses mca_0 as a label)\n    if measurement_mca_group_pattern.match(item_name):\n        return None\n    data_column_match = measurement_data_pattern.match(item_name)\n    if not data_column_match:\n        return None\n    return data_column_match.group(1)",
  "def _mca_analyser_in_scan(sf, scan_key, mca_analyser_index):\n    \"\"\"\n    :param sf: :class:`SpecFile` instance\n    :param scan_key: Scan identification key (e.g. ``1.1``)\n    :param mca_analyser_index: 0-based index of MCA analyser\n    :return: ``True`` if MCA analyser exists in Scan, else ``False``\n    :raise: ``KeyError`` if scan_key not found in SpecFile\n    :raise: ``AssertionError`` if number of MCA spectra is not a multiple\n          of the number of data lines\n    \"\"\"\n    if scan_key not in sf:\n        raise KeyError(\"Scan key %s \" % scan_key +\n                       \"does not exist in SpecFile %s\" % sf.filename)\n\n    number_of_MCA_spectra = len(sf[scan_key].mca)\n    number_of_data_lines = sf[scan_key].data.shape[0]\n\n    # Number of MCA spectra must be a multiple of number of data lines\n    assert number_of_MCA_spectra % number_of_data_lines == 0\n    number_of_MCA_analysers = number_of_MCA_spectra // number_of_data_lines\n\n    return 0 <= mca_analyser_index < number_of_MCA_analysers",
  "def _motor_in_scan(sf, scan_key, motor_name):\n    \"\"\"\n    :param sf: :class:`SpecFile` instance\n    :param scan_key: Scan identification key (e.g. ``1.1``)\n    :param motor_name: Name of motor as defined in file header lines\n    :return: ``True`` if motor exists in scan, else ``False``\n    :raise: ``KeyError`` if scan_key not found in SpecFile\n    \"\"\"\n    if scan_key not in sf:\n        raise KeyError(\"Scan key %s \" % scan_key +\n                       \"does not exist in SpecFile %s\" % sf.filename)\n    return motor_name in sf[scan_key].motor_names",
  "def _column_label_in_scan(sf, scan_key, column_label):\n    \"\"\"\n    :param sf: :class:`SpecFile` instance\n    :param scan_key: Scan identification key (e.g. ``1.1``)\n    :param column_label: Column label as defined in scan header\n    :return: ``True`` if data column label exists in scan, else ``False``\n    :raise: ``KeyError`` if scan_key not found in SpecFile\n    \"\"\"\n    if scan_key not in sf:\n        raise KeyError(\"Scan key %s \" % scan_key +\n                       \"does not exist in SpecFile %s\" % sf.filename)\n    return column_label in sf[scan_key].labels",
  "def _parse_ctime(ctime_line):\n    \"\"\"\n    :param ctime_line: e.g ``@CTIME %f %f %f``, first word ``@CTIME`` optional\n    :return: (preset_time, live_time, elapsed_time)\n    \"\"\"\n    ctime_line = ctime_line.lstrip(\"@CTIME \")\n    if not len(ctime_line.split()) == 3:\n        raise ValueError(\"Incorrect format for @CTIME header line \" +\n                         '(expected \"@CTIME %f %f %f\").')\n    return map(float, ctime_line.split())",
  "def spec_date_to_iso8601(date, zone=None):\n    \"\"\"Convert SpecFile date to Iso8601.\n\n    :param date: Date (see supported formats below)\n    :type date: str\n    :param zone: Time zone as it appears in a ISO8601 date\n\n    Supported formats:\n\n    * ``DDD MMM dd hh:mm:ss YYYY``\n    * ``DDD YYYY/MM/dd hh:mm:ss YYYY``\n\n    where `DDD` is the abbreviated weekday, `MMM` is the month abbreviated\n    name, `MM` is the month number (zero padded), `dd` is the weekday number\n    (zero padded) `YYYY` is the year, `hh` the hour (zero padded), `mm` the\n    minute (zero padded) and `ss` the second (zero padded).\n    All names are expected to be in english.\n\n    Examples::\n\n        >>> spec_date_to_iso8601(\"Thu Feb 11 09:54:35 2016\")\n        '2016-02-11T09:54:35'\n\n        >>> spec_date_to_iso8601(\"Sat 2015/03/14 03:53:50\")\n        '2015-03-14T03:53:50'\n    \"\"\"\n    months = ['Jan', 'Feb', 'Mar', 'Apr', 'Jun', 'Jul',\n              'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n\n    days_rx = '(?P<day>' + '|'.join(days) + ')'\n    months_rx = '(?P<month>' + '|'.join(months) + ')'\n    year_rx = '(?P<year>\\d{4})'\n    day_nb_rx = '(?P<day_nb>[0-3]\\d)'\n    month_nb_rx = '(?P<month_nb>[0-1]\\d)'\n    hh_rx = '(?P<hh>[0-2]\\d)'\n    mm_rx = '(?P<mm>[0-5]\\d)'\n    ss_rx = '(?P<ss>[0-5]\\d)'\n    tz_rx = '(?P<tz>[+-]\\d\\d:\\d\\d){0,1}'\n\n    # date formats must have either month_nb (1..12) or month (Jan, Feb, ...)\n    re_tpls = ['{days} {months} {day_nb} {hh}:{mm}:{ss}{tz} {year}',\n               '{days} {year}/{month_nb}/{day_nb} {hh}:{mm}:{ss}{tz}']\n\n    grp_d = None\n\n    for rx in re_tpls:\n        full_rx = rx.format(days=days_rx,\n                            months=months_rx,\n                            year=year_rx,\n                            day_nb=day_nb_rx,\n                            month_nb=month_nb_rx,\n                            hh=hh_rx,\n                            mm=mm_rx,\n                            ss=ss_rx,\n                            tz=tz_rx)\n        m = re.match(full_rx, date)\n\n        if m:\n            grp_d = m.groupdict()\n            break\n\n    if not grp_d:\n        raise ValueError('Date format not recognized : {0}'.format(date))\n\n    year = grp_d['year']\n\n    month = grp_d.get('month_nb')\n\n    if not month:\n        month = '{0:02d}'.format(months.index(grp_d.get('month')) + 1)\n\n    day = grp_d['day_nb']\n\n    tz = grp_d['tz']\n    if not tz:\n        tz = zone\n\n    time = '{0}:{1}:{2}'.format(grp_d['hh'],\n                                grp_d['mm'],\n                                grp_d['ss'])\n\n    full_date = '{0}-{1}-{2}T{3}{4}'.format(year,\n                                            month,\n                                            day,\n                                            time,\n                                            tz if tz else '')\n    return full_date",
  "def _fixed_length_strings(strings, length=0):\n    \"\"\"Return list of fixed length strings, left-justified and right-padded\n    with spaces.\n\n    :param strings: List of variable length strings\n    :param length: Length of strings in returned list, defaults to the maximum\n         length in the original list if set to 0.\n    :type length: int or None\n    \"\"\"\n    if length == 0 and strings:\n        length = max(len(s) for s in strings)\n    return [s.ljust(length) for s in strings]",
  "class SpecH5Dataset(numpy.ndarray):\n    \"\"\"Emulate :class:`h5py.Dataset` for a SpecFile object\n\n    :param array_like: Input dataset in a type that can be digested by\n        ``numpy.array()`` (`str`, `list`, `numpy.ndarray`\u2026)\n    :param name: Dataset full name (posix path format, starting with ``/``)\n    :type name: str\n    :param file_: Parent :class:`SpecH5`\n    :param parent: Parent :class:`SpecH5Group` which contains this dataset\n\n    This class inherits from :class:`numpy.ndarray` and adds ``name`` and\n    ``value`` attributes for HDF5 compatibility. ``value`` is a reference\n    to the class instance (``value = self``).\n\n    Data is stored in float32 format, unless it is a string.\n    \"\"\"\n    # For documentation on subclassing numpy.ndarray,\n    # see http://docs.scipy.org/doc/numpy-1.10.1/user/basics.subclassing.html\n    def __new__(cls, array_like, name, file_, parent):\n        # unicode can't be stored in hdf5, we need to use bytes\n        if isinstance(array_like, string_types):\n            array_like = numpy.string_(array_like)\n\n        # Ensure our data is a numpy.ndarray\n        if not isinstance(array_like, numpy.ndarray):\n            array = numpy.array(array_like)\n        else:\n            array = array_like\n\n        data_kind = array.dtype.kind\n        # unicode: convert to byte strings\n        # (http://docs.h5py.org/en/latest/strings.html)\n        if data_kind in [\"S\", \"U\"]:\n            obj = numpy.asarray(array, dtype=numpy.string_).view(cls)\n        # enforce float32 for int, unsigned int, float\n        elif data_kind in [\"i\", \"u\", \"f\"]:\n            obj = numpy.asarray(array, dtype=numpy.float32).view(cls)\n        # reject boolean (b), complex (c), object (O), void/data block (V)\n        else:\n            raise TypeError(\"Unexpected data type \" + data_kind +\n                            \" (expected int-, string- or float-like data)\")\n\n        obj.name = name\n        obj.value = obj\n        obj.parent = parent\n        obj.file = file_\n\n        obj.attrs = _get_attrs_dict(name)\n\n        return obj\n\n    def __array_finalize__(self, obj):\n        if obj is None:\n            return\n        self.name = getattr(obj, 'name', None)\n        self.value = getattr(obj, 'value', None)\n        self.parent = getattr(obj, 'parent', None)\n        self.file = getattr(obj, 'file', None)\n        self.attrs = getattr(obj, 'attrs', None)",
  "class SpecH5LinkToDataset(SpecH5Dataset):\n    \"\"\"Special :class:`SpecH5Dataset` representing a link to a dataset. It\n    works exactly like a regular dataset, but :meth:`SpecH5Group.visit`\n    and :meth:`SpecH5Group.visititems` methods will recognize that it is\n    a link and will ignore it.\n    \"\"\"\n    pass",
  "def _dataset_builder(name, specfileh5, parent_group):\n    \"\"\"Retrieve dataset from :class:`SpecFile`, based on dataset name, as a\n    subclass of :class:`numpy.ndarray`.\n\n    :param name: Datatset full name (posix path format, starting with ``/``)\n    :type name: str\n    :param specfileh5: parent :class:`SpecH5` object\n    :type specfileh5: :class:`SpecH5`\n    :param parent_group: Parent :class:`SpecH5Group`\n\n    :return: Array with the requested data\n    :rtype: :class:`SpecH5Dataset`.\n    \"\"\"\n    scan_key = _get_scan_key_in_name(name)\n    scan = specfileh5._sf[scan_key]\n\n    # get dataset in an array-like format (ndarray, str, list\u2026)\n    array_like = None\n\n    if title_pattern.match(name):\n        array_like = scan.scan_header_dict[\"S\"]\n\n    elif start_time_pattern.match(name):\n        if \"D\" in scan.scan_header_dict:\n            array_like = spec_date_to_iso8601(scan.scan_header_dict[\"D\"])\n        elif \"D\" in scan.file_header_dict:\n            logger1.warn(\"No #D line in scan header. \" +\n                         \"Using file header for start_time.\")\n            array_like = spec_date_to_iso8601(scan.file_header[\"D\"])\n        else:\n            logger1.warn(\"No #D line in header. \" +\n                         \"Using current system time for start_time.\")\n            array_like = time.ctime(time.time())\n\n    elif file_header_data_pattern.match(name):\n        array_like = _fixed_length_strings(scan.file_header)\n\n    elif scan_header_data_pattern.match(name):\n        array_like = _fixed_length_strings(scan.scan_header)\n\n    elif positioners_data_pattern.match(name):\n        m = positioners_data_pattern.match(name)\n        motor_name = m.group(1)\n        # if a motor is recorded as a data column, ignore its position in\n        # header and return the data column instead\n        if motor_name in scan.labels:\n            array_like = scan.data_column_by_name(motor_name)\n        else:\n            # may return float(\"inf\") if #P line is missing from scan hdr\n            array_like = scan.motor_position_by_name(motor_name)\n\n    elif measurement_data_pattern.match(name):\n        m = measurement_data_pattern.match(name)\n        column_name = m.group(1)\n        array_like = scan.data_column_by_name(column_name)\n\n    elif instrument_mca_data_pattern.match(name):\n        m = instrument_mca_data_pattern.match(name)\n\n        analyser_index = int(m.group(1))\n        # retrieve 2D array of all MCA spectra from one analyser\n        array_like = _demultiplex_mca(scan, analyser_index)\n\n    elif instrument_mca_calib_pattern.match(name):\n        array_like = scan.mca.calibration\n\n    elif instrument_mca_chann_pattern.match(name):\n        array_like = scan.mca.channels\n\n    elif \"CTIME\" in scan.mca_header_dict:\n        ctime_line = scan.mca_header_dict['CTIME']\n        (preset_time, live_time, elapsed_time) = _parse_ctime(ctime_line)\n        if instrument_mca_preset_t_pattern.match(name):\n            array_like = preset_time\n        elif instrument_mca_live_t_pattern.match(name):\n            array_like = live_time\n        elif instrument_mca_elapsed_t_pattern.match(name):\n            array_like = elapsed_time\n\n    if array_like is None:\n        raise KeyError(\"Name \" + name + \" does not match any known dataset.\")\n\n    return SpecH5Dataset(array_like, name,\n                         file_=specfileh5, parent=parent_group)",
  "def _link_to_dataset_builder(name, specfileh5, parent_group):\n    \"\"\"Same as :func:`_dataset_builder`, but returns a\n    :class:`SpecH5LinkToDataset`\n\n    :param name: Datatset full name (posix path format, starting with ``/``)\n    :type name: str\n    :param specfileh5: parent :class:`SpecH5` object\n    :type specfileh5: :class:`SpecH5`\n    :param parent_group: Parent :class:`SpecH5Group`\n\n    :return: Array with the requested data\n    :rtype: :class:`SpecH5LinkToDataset`.\n    \"\"\"\n    scan_key = _get_scan_key_in_name(name)\n    scan = specfileh5._sf[scan_key]\n\n    # get dataset in an array-like format (ndarray, str, list\u2026)\n    array_like = None\n\n    if measurement_mca_data_pattern.match(name):\n        m = measurement_mca_data_pattern.match(name)\n        analyser_index = int(m.group(1))\n        array_like = _demultiplex_mca(scan, analyser_index)\n\n    elif measurement_mca_info_dataset_pattern:\n        m = measurement_mca_info_dataset_pattern.match(name)\n\n        mca_hdr_type = m.group(1)\n        if mca_hdr_type == \"calibration\":\n            array_like = scan.mca.calibration\n        elif mca_hdr_type == \"channels\":\n            array_like = scan.mca.channels\n        elif \"CTIME\" in scan.mca_header_dict:\n            ctime_line = scan.mca_header_dict['CTIME']\n            (preset_time, live_time, elapsed_time) = _parse_ctime(ctime_line)\n            if instrument_mca_preset_t_pattern.match(name):\n                array_like = preset_time\n            elif instrument_mca_live_t_pattern.match(name):\n                array_like = live_time\n            elif instrument_mca_elapsed_t_pattern.match(name):\n                array_like = elapsed_time\n\n    if array_like is None:\n        raise KeyError(\"Name \" + name + \" does not match any known dataset.\")\n\n    return SpecH5LinkToDataset(array_like, name,\n                               file_=specfileh5, parent=parent_group)",
  "def _demultiplex_mca(scan, analyser_index):\n    \"\"\"Return MCA data for a single analyser.\n\n    Each MCA spectrum is a 1D array. For each analyser, there is one\n    spectrum recorded per scan data line. When there are more than a single\n    MCA analyser in a scan, the data will be multiplexed. For instance if\n    there are 3 analysers, the consecutive spectra for the first analyser must\n    be accessed as ``mca[0], mca[3], mca[6]\u2026``.\n\n    :param scan: :class:`Scan` instance containing the MCA data\n    :param analyser_index: 0-based index referencing the analyser\n    :type analyser_index: int\n    :return: 2D numpy array containing all spectra for one analyser\n    \"\"\"\n    mca_data = scan.mca\n\n    number_of_MCA_spectra = len(mca_data)\n    number_of_scan_data_lines = scan.data.shape[0]\n\n    # Number of MCA spectra must be a multiple of number of scan data lines\n    assert number_of_MCA_spectra % number_of_scan_data_lines == 0\n    number_of_analysers = number_of_MCA_spectra // number_of_scan_data_lines\n\n    list_of_1D_arrays = []\n    for i in range(analyser_index,\n                   number_of_MCA_spectra,\n                   number_of_analysers):\n        list_of_1D_arrays.append(mca_data[i])\n    # convert list to 2D array\n    return numpy.array(list_of_1D_arrays)",
  "class SpecH5Group(object):\n    \"\"\"Emulate :class:`h5py.Group` for a SpecFile object\n\n    :param name: Group full name (posix path format, starting with ``/``)\n    :type name: str\n    :param specfileh5: parent :class:`SpecH5` instance\n\n    \"\"\"\n    def __init__(self, name, specfileh5):\n        self.name = name\n        \"\"\"Full name/path of group\"\"\"\n\n        self.file = specfileh5\n        \"\"\"Parent SpecH5 object\"\"\"\n\n        self.attrs = _get_attrs_dict(name)\n        \"\"\"Attributes dictionary\"\"\"\n\n        if name != \"/\":\n            scan_key = _get_scan_key_in_name(name)\n            self._scan = self.file._sf[scan_key]\n\n    @property\n    def parent(self):\n        \"\"\"Parent group (group that contains this group)\"\"\"\n        if not self.name.strip(\"/\"):\n            return None\n\n        parent_name = posixpath.dirname(self.name.rstrip(\"/\"))\n        return SpecH5Group(parent_name, self.file)\n\n    def __contains__(self, key):\n        \"\"\"\n        :param key: Path to child element (e.g. ``\"mca_0/info\"``) or full name\n            of group or dataset (e.g. ``\"/2.1/instrument/positioners\"``)\n        :return: True if key refers to a valid member of this group,\n            else False\n        \"\"\"\n        # Absolute path to an item outside this group\n        if key.startswith(\"/\"):\n            if not key.startswith(self.name):\n                return False\n        # Make sure key is an absolute path by prepending this group's name\n        else:\n            key = self.name.rstrip(\"/\") + \"/\" + key\n\n        # key not matching any known pattern\n        if not is_group(key) and not is_dataset(key) and\\\n           not is_link_to_group(key) and not is_link_to_dataset(key):\n            return False\n\n        # nonexistent scan in specfile\n        scan_key = _get_scan_key_in_name(key)\n        if scan_key not in self.file._sf:\n            return False\n\n        # nonexistent MCA analyser in scan\n        mca_analyser_index = _get_mca_index_in_name(key)\n        if mca_analyser_index is not None:\n            if not _mca_analyser_in_scan(self.file._sf,\n                                         scan_key,\n                                         mca_analyser_index):\n                return False\n\n        # nonexistent motor name\n        motor_name = _get_motor_in_name(key)\n        if motor_name is not None:\n            if not _motor_in_scan(self.file._sf,\n                                  scan_key,\n                                  motor_name):\n                return False\n\n        # nonexistent data column\n        column_label = _get_data_column_label_in_name(key)\n        if column_label is not None:\n            if not _column_label_in_scan(self.file._sf,\n                                         scan_key,\n                                         column_label):\n                return False\n\n        if key.endswith(\"preset_time\") or\\\n           key.endswith(\"elapsed_time\") or\\\n           key.endswith(\"live_time\"):\n            return \"CTIME\" in self.file._sf[scan_key].mca_header_dict\n\n        # header, title, start_time, existing scan/mca/motor/measurement\n        return True\n\n    def __eq__(self, other):\n        return (isinstance(other, SpecH5Group) and\n                self.name == other.name and\n                self.file.filename == other.file.filename and\n                self.keys() == other.keys())\n\n    def __getitem__(self, key):\n        \"\"\"Return a :class:`SpecH5Group` or a :class:`SpecH5Dataset`\n        if ``key`` is a valid name of a group or dataset.\n\n        ``key`` can be a member of ``self.keys()``, i.e. an immediate child of\n        the group, or a path reaching into subgroups (e.g.\n        ``\"instrument/positioners\"``)\n\n        In the special case were this group is the root group, ``key`` can\n        start with a ``/`` character.\n\n        :param key: Name of member\n        :type key: str\n        :raise: KeyError if ``key`` is not a known member of this group.\n        \"\"\"\n        # Relative path starting from this group (e.g \"mca_0/info\")\n        if not key.startswith(\"/\"):\n            full_key = self.name.rstrip(\"/\") + \"/\" + key\n        # Absolute path called from the root group or from a parent group\n        elif key.startswith(self.name):\n            full_key = key\n        # Absolute path to an element called from a non-parent group\n        else:\n            raise KeyError(key + \" is not a child of \" + self.__repr__())\n\n        if is_group(full_key):\n            return SpecH5Group(full_key, self.file)\n        elif is_dataset(full_key):\n            return _dataset_builder(full_key, self.file, self)\n        elif is_link_to_group(full_key):\n            return SpecH5LinkToGroup(full_key, self.file)\n        elif is_link_to_dataset(full_key):\n            return _link_to_dataset_builder(full_key, self.file, self)\n        else:\n            raise KeyError(\"unrecognized group or dataset: \" + full_key)\n\n    def __iter__(self):\n        for key in self.keys():\n            yield key\n\n    def __len__(self):\n        \"\"\"Return number of members,subgroups and datasets, attached to this\n         group.\n         \"\"\"\n        return len(self.keys())\n\n    def __repr__(self):\n        return '<SpecH5Group \"%s\" (%d members)>' % (self.name, len(self))\n\n    def keys(self):\n        \"\"\":return: List of all names of members attached to this group\n        \"\"\"\n        # keys in hdf5 are unicode\n        if self.name == \"/\":\n            return self.file.keys()\n\n        if scan_pattern.match(self.name):\n            return static_items[\"scan\"]\n\n        if positioners_group_pattern.match(self.name):\n            return self._scan.motor_names\n\n        if specfile_group_pattern.match(self.name):\n            return static_items[\"scan/instrument/specfile\"]\n\n        if measurement_mca_group_pattern.match(self.name):\n            return static_items[\"scan/measurement/mca\"]\n\n        if instrument_mca_group_pattern.match(self.name):\n            ret = static_items[\"scan/instrument/mca\"]\n            if \"CTIME\" in self._scan.mca_header_dict:\n                ret += [\"preset_time\", \"elapsed_time\", \"live_time\"]\n            return ret\n\n        # number of data columns must be equal to number of labels\n        assert self._scan.data.shape[1] == len(self._scan.labels)\n\n        number_of_MCA_spectra = len(self._scan.mca)\n        number_of_data_lines = self._scan.data.shape[0]\n\n        # Number of MCA spectra must be a multiple of number of data lines\n        assert number_of_MCA_spectra % number_of_data_lines == 0\n        number_of_MCA_analysers = number_of_MCA_spectra // number_of_data_lines\n        mca_list = [\"mca_%d\" % i for i in range(number_of_MCA_analysers)]\n\n        if measurement_group_pattern.match(self.name):\n            return self._scan.labels + mca_list\n\n        if instrument_pattern.match(self.name):\n            return static_items[\"scan/instrument\"] + mca_list\n\n    def visit(self, func):\n        \"\"\"Recursively visit all names in this group and subgroups.\n\n        :param func: Callable (function, method or callable object)\n        :type func: function\n\n        You supply a callable (function, method or callable object); it\n        will be called exactly once for each link in this group and every\n        group below it. Your callable must conform to the signature:\n\n            ``func(<member name>) => <None or return value>``\n\n        Returning ``None`` continues iteration, returning anything else stops\n        and immediately returns that value from the visit method.  No\n        particular order of iteration within groups is guaranteed.\n\n        Example:\n\n        .. code-block:: python\n\n            # Get a list of all contents (groups and datasets) in a SpecFile\n            mylist = []\n            f = File('foo.dat')\n            f.visit(mylist.append)\n        \"\"\"\n        for member_name in self.keys():\n            member = self[member_name]\n            ret = None\n            if not is_link_to_dataset(member.name) and\\\n               not is_link_to_group(member.name):\n                ret = func(member.name)\n            if ret is not None:\n                return ret\n            # recurse into subgroups\n            if isinstance(self[member_name], SpecH5Group) and\\\n               not isinstance(self[member_name], SpecH5LinkToGroup):\n                self[member_name].visit(func)\n\n    def visititems(self, func):\n        \"\"\"Recursively visit names and objects in this group.\n\n        :param func: Callable (function, method or callable object)\n        :type func: function\n\n        You supply a callable (function, method or callable object); it\n        will be called exactly once for each link in this group and every\n        group below it. Your callable must conform to the signature:\n\n            ``func(<member name>, <object>) => <None or return value>``\n\n        Returning ``None`` continues iteration, returning anything else stops\n        and immediately returns that value from the visit method.  No\n        particular order of iteration within groups is guaranteed.\n\n        Example:\n\n        .. code-block:: python\n\n            # Get a list of all datasets in a specific scan\n            mylist = []\n            def func(name, obj):\n                if isinstance(obj, SpecH5Dataset):\n                    mylist.append(name)\n\n            f = File('foo.dat')\n            f[\"1.1\"].visititems(func)\n        \"\"\"\n        for member_name in self.keys():\n            member = self[member_name]\n            ret = None\n            if not is_link_to_dataset(member.name):\n                ret = func(member.name, member)\n            if ret is not None:\n                return ret\n            # recurse into subgroups\n            if isinstance(self[member_name], SpecH5Group) and\\\n               not isinstance(self[member_name], SpecH5LinkToGroup):\n                self[member_name].visititems(func)",
  "class SpecH5LinkToGroup(SpecH5Group):\n    \"\"\"Special :class:`SpecH5Group` representing a link to a group.\n\n    It works exactly like a regular group but :meth:`SpecH5Group.visit`\n    and :meth:`SpecH5Group.visititems` methods will recognize it as a\n    link and will ignore it.\n    \"\"\"\n    def keys(self):\n        \"\"\":return: List of all names of members attached to the target group\n        \"\"\"\n        # we only have a single type of link to a group:\n        # /1.1/measurement/mca_0/info/ -> /1.1/instrument/mca_0/\n        if measurement_mca_info_pattern.match(self.name):\n            link_target = self.name.replace(\"measurement\", \"instrument\").rstrip(\"/\")[:-4]\n            return SpecH5Group(link_target, self.file).keys()",
  "class SpecH5(SpecH5Group):\n    \"\"\"Special :class:`SpecH5Group` representing the root of a SpecFile.\n\n    :param filename: Path to SpecFile in filesystem\n    :type filename: str\n\n    In addition to all generic :class:`SpecH5Group` attributes, this class\n    also keeps a reference to the original :class:`SpecFile` object and\n    has a :attr:`filename` attribute.\n\n    Its immediate children are scans, but it also gives access to any group\n    or dataset in the entire SpecFile tree by specifying the full path.\n    \"\"\"\n    def __init__(self, filename):\n        self.filename = filename\n        self.attrs = _get_attrs_dict(\"/\")\n        self._sf = SpecFile(filename)\n\n        SpecH5Group.__init__(self, name=\"/\", specfileh5=self)\n\n    def keys(self):\n        \"\"\"\n        :return: List of all scan keys in this SpecFile\n            (e.g. ``[\"1.1\", \"2.1\"\u2026]``)\n        \"\"\"\n        return self._sf.keys()\n\n    def __repr__(self):\n        return '<SpecH5 \"%s\" (%d members)>' % (self.filename, len(self))\n\n    def __eq__(self, other):\n        return (isinstance(other, SpecH5) and\n                self.filename == other.filename and\n                self.keys() == other.keys())",
  "def __new__(cls, array_like, name, file_, parent):\n        # unicode can't be stored in hdf5, we need to use bytes\n        if isinstance(array_like, string_types):\n            array_like = numpy.string_(array_like)\n\n        # Ensure our data is a numpy.ndarray\n        if not isinstance(array_like, numpy.ndarray):\n            array = numpy.array(array_like)\n        else:\n            array = array_like\n\n        data_kind = array.dtype.kind\n        # unicode: convert to byte strings\n        # (http://docs.h5py.org/en/latest/strings.html)\n        if data_kind in [\"S\", \"U\"]:\n            obj = numpy.asarray(array, dtype=numpy.string_).view(cls)\n        # enforce float32 for int, unsigned int, float\n        elif data_kind in [\"i\", \"u\", \"f\"]:\n            obj = numpy.asarray(array, dtype=numpy.float32).view(cls)\n        # reject boolean (b), complex (c), object (O), void/data block (V)\n        else:\n            raise TypeError(\"Unexpected data type \" + data_kind +\n                            \" (expected int-, string- or float-like data)\")\n\n        obj.name = name\n        obj.value = obj\n        obj.parent = parent\n        obj.file = file_\n\n        obj.attrs = _get_attrs_dict(name)\n\n        return obj",
  "def __array_finalize__(self, obj):\n        if obj is None:\n            return\n        self.name = getattr(obj, 'name', None)\n        self.value = getattr(obj, 'value', None)\n        self.parent = getattr(obj, 'parent', None)\n        self.file = getattr(obj, 'file', None)\n        self.attrs = getattr(obj, 'attrs', None)",
  "def __init__(self, name, specfileh5):\n        self.name = name\n        \"\"\"Full name/path of group\"\"\"\n\n        self.file = specfileh5\n        \"\"\"Parent SpecH5 object\"\"\"\n\n        self.attrs = _get_attrs_dict(name)\n        \"\"\"Attributes dictionary\"\"\"\n\n        if name != \"/\":\n            scan_key = _get_scan_key_in_name(name)\n            self._scan = self.file._sf[scan_key]",
  "def parent(self):\n        \"\"\"Parent group (group that contains this group)\"\"\"\n        if not self.name.strip(\"/\"):\n            return None\n\n        parent_name = posixpath.dirname(self.name.rstrip(\"/\"))\n        return SpecH5Group(parent_name, self.file)",
  "def __contains__(self, key):\n        \"\"\"\n        :param key: Path to child element (e.g. ``\"mca_0/info\"``) or full name\n            of group or dataset (e.g. ``\"/2.1/instrument/positioners\"``)\n        :return: True if key refers to a valid member of this group,\n            else False\n        \"\"\"\n        # Absolute path to an item outside this group\n        if key.startswith(\"/\"):\n            if not key.startswith(self.name):\n                return False\n        # Make sure key is an absolute path by prepending this group's name\n        else:\n            key = self.name.rstrip(\"/\") + \"/\" + key\n\n        # key not matching any known pattern\n        if not is_group(key) and not is_dataset(key) and\\\n           not is_link_to_group(key) and not is_link_to_dataset(key):\n            return False\n\n        # nonexistent scan in specfile\n        scan_key = _get_scan_key_in_name(key)\n        if scan_key not in self.file._sf:\n            return False\n\n        # nonexistent MCA analyser in scan\n        mca_analyser_index = _get_mca_index_in_name(key)\n        if mca_analyser_index is not None:\n            if not _mca_analyser_in_scan(self.file._sf,\n                                         scan_key,\n                                         mca_analyser_index):\n                return False\n\n        # nonexistent motor name\n        motor_name = _get_motor_in_name(key)\n        if motor_name is not None:\n            if not _motor_in_scan(self.file._sf,\n                                  scan_key,\n                                  motor_name):\n                return False\n\n        # nonexistent data column\n        column_label = _get_data_column_label_in_name(key)\n        if column_label is not None:\n            if not _column_label_in_scan(self.file._sf,\n                                         scan_key,\n                                         column_label):\n                return False\n\n        if key.endswith(\"preset_time\") or\\\n           key.endswith(\"elapsed_time\") or\\\n           key.endswith(\"live_time\"):\n            return \"CTIME\" in self.file._sf[scan_key].mca_header_dict\n\n        # header, title, start_time, existing scan/mca/motor/measurement\n        return True",
  "def __eq__(self, other):\n        return (isinstance(other, SpecH5Group) and\n                self.name == other.name and\n                self.file.filename == other.file.filename and\n                self.keys() == other.keys())",
  "def __getitem__(self, key):\n        \"\"\"Return a :class:`SpecH5Group` or a :class:`SpecH5Dataset`\n        if ``key`` is a valid name of a group or dataset.\n\n        ``key`` can be a member of ``self.keys()``, i.e. an immediate child of\n        the group, or a path reaching into subgroups (e.g.\n        ``\"instrument/positioners\"``)\n\n        In the special case were this group is the root group, ``key`` can\n        start with a ``/`` character.\n\n        :param key: Name of member\n        :type key: str\n        :raise: KeyError if ``key`` is not a known member of this group.\n        \"\"\"\n        # Relative path starting from this group (e.g \"mca_0/info\")\n        if not key.startswith(\"/\"):\n            full_key = self.name.rstrip(\"/\") + \"/\" + key\n        # Absolute path called from the root group or from a parent group\n        elif key.startswith(self.name):\n            full_key = key\n        # Absolute path to an element called from a non-parent group\n        else:\n            raise KeyError(key + \" is not a child of \" + self.__repr__())\n\n        if is_group(full_key):\n            return SpecH5Group(full_key, self.file)\n        elif is_dataset(full_key):\n            return _dataset_builder(full_key, self.file, self)\n        elif is_link_to_group(full_key):\n            return SpecH5LinkToGroup(full_key, self.file)\n        elif is_link_to_dataset(full_key):\n            return _link_to_dataset_builder(full_key, self.file, self)\n        else:\n            raise KeyError(\"unrecognized group or dataset: \" + full_key)",
  "def __iter__(self):\n        for key in self.keys():\n            yield key",
  "def __len__(self):\n        \"\"\"Return number of members,subgroups and datasets, attached to this\n         group.\n         \"\"\"\n        return len(self.keys())",
  "def __repr__(self):\n        return '<SpecH5Group \"%s\" (%d members)>' % (self.name, len(self))",
  "def keys(self):\n        \"\"\":return: List of all names of members attached to this group\n        \"\"\"\n        # keys in hdf5 are unicode\n        if self.name == \"/\":\n            return self.file.keys()\n\n        if scan_pattern.match(self.name):\n            return static_items[\"scan\"]\n\n        if positioners_group_pattern.match(self.name):\n            return self._scan.motor_names\n\n        if specfile_group_pattern.match(self.name):\n            return static_items[\"scan/instrument/specfile\"]\n\n        if measurement_mca_group_pattern.match(self.name):\n            return static_items[\"scan/measurement/mca\"]\n\n        if instrument_mca_group_pattern.match(self.name):\n            ret = static_items[\"scan/instrument/mca\"]\n            if \"CTIME\" in self._scan.mca_header_dict:\n                ret += [\"preset_time\", \"elapsed_time\", \"live_time\"]\n            return ret\n\n        # number of data columns must be equal to number of labels\n        assert self._scan.data.shape[1] == len(self._scan.labels)\n\n        number_of_MCA_spectra = len(self._scan.mca)\n        number_of_data_lines = self._scan.data.shape[0]\n\n        # Number of MCA spectra must be a multiple of number of data lines\n        assert number_of_MCA_spectra % number_of_data_lines == 0\n        number_of_MCA_analysers = number_of_MCA_spectra // number_of_data_lines\n        mca_list = [\"mca_%d\" % i for i in range(number_of_MCA_analysers)]\n\n        if measurement_group_pattern.match(self.name):\n            return self._scan.labels + mca_list\n\n        if instrument_pattern.match(self.name):\n            return static_items[\"scan/instrument\"] + mca_list",
  "def visit(self, func):\n        \"\"\"Recursively visit all names in this group and subgroups.\n\n        :param func: Callable (function, method or callable object)\n        :type func: function\n\n        You supply a callable (function, method or callable object); it\n        will be called exactly once for each link in this group and every\n        group below it. Your callable must conform to the signature:\n\n            ``func(<member name>) => <None or return value>``\n\n        Returning ``None`` continues iteration, returning anything else stops\n        and immediately returns that value from the visit method.  No\n        particular order of iteration within groups is guaranteed.\n\n        Example:\n\n        .. code-block:: python\n\n            # Get a list of all contents (groups and datasets) in a SpecFile\n            mylist = []\n            f = File('foo.dat')\n            f.visit(mylist.append)\n        \"\"\"\n        for member_name in self.keys():\n            member = self[member_name]\n            ret = None\n            if not is_link_to_dataset(member.name) and\\\n               not is_link_to_group(member.name):\n                ret = func(member.name)\n            if ret is not None:\n                return ret\n            # recurse into subgroups\n            if isinstance(self[member_name], SpecH5Group) and\\\n               not isinstance(self[member_name], SpecH5LinkToGroup):\n                self[member_name].visit(func)",
  "def visititems(self, func):\n        \"\"\"Recursively visit names and objects in this group.\n\n        :param func: Callable (function, method or callable object)\n        :type func: function\n\n        You supply a callable (function, method or callable object); it\n        will be called exactly once for each link in this group and every\n        group below it. Your callable must conform to the signature:\n\n            ``func(<member name>, <object>) => <None or return value>``\n\n        Returning ``None`` continues iteration, returning anything else stops\n        and immediately returns that value from the visit method.  No\n        particular order of iteration within groups is guaranteed.\n\n        Example:\n\n        .. code-block:: python\n\n            # Get a list of all datasets in a specific scan\n            mylist = []\n            def func(name, obj):\n                if isinstance(obj, SpecH5Dataset):\n                    mylist.append(name)\n\n            f = File('foo.dat')\n            f[\"1.1\"].visititems(func)\n        \"\"\"\n        for member_name in self.keys():\n            member = self[member_name]\n            ret = None\n            if not is_link_to_dataset(member.name):\n                ret = func(member.name, member)\n            if ret is not None:\n                return ret\n            # recurse into subgroups\n            if isinstance(self[member_name], SpecH5Group) and\\\n               not isinstance(self[member_name], SpecH5LinkToGroup):\n                self[member_name].visititems(func)",
  "def keys(self):\n        \"\"\":return: List of all names of members attached to the target group\n        \"\"\"\n        # we only have a single type of link to a group:\n        # /1.1/measurement/mca_0/info/ -> /1.1/instrument/mca_0/\n        if measurement_mca_info_pattern.match(self.name):\n            link_target = self.name.replace(\"measurement\", \"instrument\").rstrip(\"/\")[:-4]\n            return SpecH5Group(link_target, self.file).keys()",
  "def __init__(self, filename):\n        self.filename = filename\n        self.attrs = _get_attrs_dict(\"/\")\n        self._sf = SpecFile(filename)\n\n        SpecH5Group.__init__(self, name=\"/\", specfileh5=self)",
  "def keys(self):\n        \"\"\"\n        :return: List of all scan keys in this SpecFile\n            (e.g. ``[\"1.1\", \"2.1\"\u2026]``)\n        \"\"\"\n        return self._sf.keys()",
  "def __repr__(self):\n        return '<SpecH5 \"%s\" (%d members)>' % (self.filename, len(self))",
  "def __eq__(self, other):\n        return (isinstance(other, SpecH5) and\n                self.filename == other.filename and\n                self.keys() == other.keys())",
  "def save1D(fname, x, y, xlabel=None, ylabels=None, filetype=None,\n           fmt=\"%.7g\", csvdelim=\";\", newline=\"\\n\", header=\"\",\n           footer=\"\", comments=\"#\", autoheader=False):\n    \"\"\"Saves any number of curves to various formats: `Specfile`, `CSV`,\n    `txt` or `npy`. All curves must have the same number of points and share\n    the same ``x`` values.\n\n    :param fname: Output file path, or file handle open in write mode.\n        If ``fname`` is a path, file is opened in ``w`` mode. Existing file\n        with a same name will be overwritten.\n    :param x: 1D-Array (or list) of abscissa values.\n    :param y: 2D-array (or list of lists) of ordinates values. First index\n        is the curve index, second index is the sample index. The length\n        of the second dimension (number of samples) must be equal to\n        ``len(x)``. ``y`` can be a 1D-array in case there is only one curve\n        to be saved.\n    :param filetype: Filetype: ``\"spec\", \"csv\", \"txt\", \"ndarray\"``.\n        If ``None``, filetype is detected from file name extension\n        (``.dat, .csv, .txt, .npy``)\n    :param xlabel: Abscissa label\n    :param ylabels: List of `y` labels\n    :param fmt: Format string for data. You can specify a short format\n        string that defines a single format for both ``x`` and ``y`` values,\n        or a list of two different format strings (e.g. ``[\"%d\", \"%.7g\"]``).\n        Default is ``\"%.7g\"``.\n        This parameter does not apply to the `npy` format.\n    :param csvdelim: String or character separating columns in `txt` and\n        `CSV` formats. The user is responsible for ensuring that this\n        delimiter is not used in data labels when writing a `CSV` file.\n    :param newline: String or character separating lines/records in `txt`\n        format (default is line break character ``\\\\n``).\n    :param header: String that will be written at the beginning of the file in\n        `txt` format.\n    :param footer: String that will be written at the end of the file in `txt`\n         format.\n    :param comments: String that will be prepended to the ``header`` and\n        ``footer`` strings, to mark them as comments. Default: ``#``.\n    :param autoheader: In `CSV` or `txt`, ``True`` causes the first header\n         line to be written as a standard CSV header line with column labels\n         separated by the specified CSV delimiter.\n\n    When saving to Specfile format, each curve is saved as a separate scan\n    with two data columns (``x`` and ``y``).\n\n    `CSV` and `txt` formats are similar, except that the `txt` format allows\n    user defined header and footer text blocks, whereas the `CSV` format has\n    only a single header line with columns labels separated by field\n    delimiters and no footer. The `txt` format also allows defining a record\n    separator different from a line break.\n\n    The `npy` format is written with ``numpy.save`` and can be read back with\n    ``numpy.load``. If ``xlabel`` and ``ylabels`` are undefined, data is saved\n    as a regular 2D ``numpy.ndarray`` (contatenation of ``x`` and ``y``). If\n    both ``xlabel`` and ``ylabels`` are defined, the data is saved as a\n    ``numpy.recarray`` after being transposed and having labels assigned to\n    columns.\n    \"\"\"\n\n    available_formats = [\"spec\", \"csv\", \"txt\", \"ndarray\"]\n\n    if filetype is None:\n        exttypes = {\".dat\": \"spec\",\n                    \".csv\": \"csv\",\n                    \".txt\": \"txt\",\n                    \".npy\": \"ndarray\"}\n        outfname = (fname if not hasattr(fname, \"name\") else\n                    fname.name)\n        fileext = os.path.splitext(outfname)[1]\n        if fileext in exttypes:\n            filetype = exttypes[fileext]\n    else:\n        filetype = filetype.lower()\n\n    if filetype not in available_formats:\n        raise IOError(\"File type %s is not supported\" % (filetype))\n\n    if filetype.lower() == \"spec\":\n        y_array = numpy.asarray(y)\n\n        # make sure y_array is a 2D array even for a single curve\n        if len(y_array.shape) == 1:\n            y_array.shape = (1, y_array.shape[0])\n        elif len(y_array.shape) > 2 or len(y_array.shape) < 1:\n            raise IndexError(\"y must be a 1D or 2D array\")\n\n        # First curve\n        specf = savespec(fname, x, y_array[0], xlabel, ylabels[0], fmt=fmt,\n                         scan_number=1, mode=\"w\", write_file_header=True,\n                         close_file=False)\n        # Other curves\n        for i in range(1, y_array.shape[0]):\n            specf = savespec(specf, x, y_array[i], xlabel, ylabels[i],\n                             fmt=fmt, scan_number=i+1, mode=\"w\",\n                             write_file_header=False, close_file=False)\n        # close file if we created it\n        if not hasattr(fname, \"write\"):\n            specf.close()\n\n    else:\n        autoheader_line = xlabel + csvdelim + csvdelim.join(ylabels)\n        if xlabel is not None and ylabels is not None and filetype == \"csv\":\n            # csv format: optional single header line with labels, no footer\n            if autoheader:\n                header = autoheader_line + newline\n            else:\n                header = \"\"\n            comments = \"\"\n            footer = \"\"\n            newline = \"\\n\"\n        elif filetype == \"txt\" and autoheader:\n            # Comments string is added at the beginning of header string in\n            # savetxt(). We add another one after the first header line and\n            # before the rest of the header.\n            if header:\n                header = autoheader_line + newline + comments + header\n            else:\n                header = autoheader_line + newline\n\n        # Concatenate x and y in a single 2D array\n        X = numpy.vstack((x, y))\n\n        if filetype.lower() in [\"csv\", \"txt\"]:\n            X = X.transpose()\n            savetxt(fname, X, fmt=fmt, delimiter=csvdelim,\n                    newline=newline, header=header, footer=footer,\n                    comments=comments)\n\n        elif filetype.lower() == \"ndarray\":\n            if xlabel is not None and ylabels is not None:\n                labels = [xlabel] + ylabels\n\n                # .transpose is needed here because recarray labels\n                # apply to columns\n                X = numpy.core.records.fromrecords(X.transpose(),\n                                                   names=labels)\n            numpy.save(fname, X)",
  "def savetxt(fname, X, fmt=\"%.7g\", delimiter=\";\", newline=\"\\n\",\n            header=\"\", footer=\"\", comments=\"#\"):\n    \"\"\"``numpy.savetxt`` backport of header and footer arguments from\n    numpy=1.7.0.\n\n    See ``numpy.savetxt`` help:\n    http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.savetxt.html\n    \"\"\"\n    if not hasattr(fname, \"name\"):\n        ffile = open(fname, 'wb')\n    else:\n        ffile = fname\n\n    if header:\n        if sys.version_info[0] >= 3:\n            header = header.encode(\"utf-8\")\n        ffile.write(header)\n\n    numpy.savetxt(ffile, X, fmt, delimiter, newline)\n\n    if footer:\n        footer = (comments + footer.replace(newline, newline + comments) +\n                  newline)\n        if sys.version_info[0] >= 3:\n            footer = footer.encode(\"utf-8\")\n        ffile.write(footer)\n\n    if not hasattr(fname, \"name\"):\n        ffile.close()",
  "def savespec(specfile, x, y, xlabel=\"X\", ylabel=\"Y\", fmt=\"%.7g\",\n             scan_number=1, mode=\"w\", write_file_header=True,\n             close_file=False):\n    \"\"\"Saves one curve to a SpecFile.\n\n    The curve is saved as a scan with two data columns. To save multiple\n    curves to a single SpecFile, call this function for each curve by\n    providing the same file handle each time.\n\n    :param specfile: Output SpecFile name, or file handle open in write\n        or append mode. If a file name is provided, a new file is open in\n        write mode (existing file with the same name will be lost)\n    :param x: 1D-Array (or list) of abscissa values\n    :param y: 1D-array (or list) of ordinates values\n    :param xlabel: Abscissa label (default ``\"X\"``)\n    :param ylabel: Ordinate label\n    :param fmt: Format string for data. You can specify a short format\n        string that defines a single format for both ``x`` and ``y`` values,\n        or a list of two different format strings (e.g. ``[\"%d\", \"%.7g\"]``).\n        Default is ``\"%.7g\"``.\n    :param scan_number: Scan number (default 1).\n    :param mode: Mode for opening file: ``w`` (default), ``a``,  ``r+``,\n        ``w+``, ``a+``. This parameter is only relevant if ``specfile`` is a\n        path.\n    :param write_file_header: If ``True``, write a file header before writing\n        the scan (``#F`` and ``#D`` line).\n    :param close_file: If ``True``, close the file after saving curve.\n    :return: ``None`` if ``close_file`` is ``True``, else return the file\n        handle.\n    \"\"\"\n    x_array = numpy.asarray(x)\n    y_array = numpy.asarray(y)\n\n    if y_array.shape[0] != x_array.shape[0]:\n        raise IndexError(\"X and Y columns must have the same length\")\n\n    if isinstance(fmt, string_types) and fmt.count(\"%\") == 1:\n        full_fmt_string = fmt + \"  \" + fmt + \"\\n\"\n    elif isinstance(fmt, (list, tuple)) and len(fmt) == 2:\n        full_fmt_string = \"  \".join(fmt) + \"\\n\"\n    else:\n        raise ValueError(\"fmt must be a single format string or a list of \" +\n                         \"two format strings\")\n\n    if not hasattr(specfile, \"write\"):\n        f = open(specfile, mode)\n    else:\n        f = specfile\n\n    current_date = \"#D %s\\n\" % (time.ctime(time.time()))\n\n    if write_file_header:\n        f.write(\"#F %s\\n\" % f.name)\n        f.write(current_date)\n        f.write(\"\\n\")\n\n    f.write(\"#S %d %s\\n\" % (scan_number, ylabel))\n    f.write(current_date)\n    f.write(\"#N 2\\n\")\n    f.write(\"#L %s  %s\\n\" % (xlabel, ylabel))\n    for i in range(y_array.shape[0]):\n        f.write(full_fmt_string % (x_array[i], y_array[i]))\n    f.write(\"\\n\")\n\n    if close_file:\n        f.close()\n        return None\n    return f",
  "def h5ls(h5group, lvl=0):\n    \"\"\"Return a simple string representation of a HDF5 tree structure.\n\n    :param h5group: Any :class:`h5py.Group` or :class:`h5py.File` instance,\n        or a HDF5 file name\n    :param lvl: Number of tabulations added to the group. ``lvl`` is\n        incremented as we recursively process sub-groups.\n    :return: String representation of an HDF5 tree structure\n\n\n    Group names and dataset representation are printed preceded by a number of\n    tabulations corresponding to their depth in the tree structure.\n    Datasets are represented as :class:`h5py.Dataset` objects.\n\n    Example::\n\n        >>> print(h5ls(\"Downloads/sample.h5\"))\n        +fields\n            +fieldB\n                <HDF5 dataset \"z\": shape (256, 256), type \"<f4\">\n            +fieldE\n                <HDF5 dataset \"x\": shape (256, 256), type \"<f4\">\n                <HDF5 dataset \"y\": shape (256, 256), type \"<f4\">\n\n    .. note:: This function requires `h5py <http://www.h5py.org/>`_ to be\n        installed.\n    \"\"\"\n    if h5py_missing:\n        logger.error(\"h5ls requires h5py\")\n        raise h5py_import_error\n\n    repr = ''\n    if isinstance(h5group, (h5py.File, h5py.Group)):\n        h5f = h5group\n    elif isinstance(h5group, string_types):\n        h5f = h5py.File(h5group, \"r\")\n    else:\n        raise TypeError(\"h5group must be a h5py.group object or a file name.\")\n\n    for key in h5f.keys():\n        if hasattr(h5f[key], 'keys'):\n            repr += '\\t' * lvl + '+' + key\n            repr += '\\n'\n            repr += h5ls(h5f[key], lvl + 1)\n        else:\n            repr += '\\t' * lvl\n            repr += str(h5f[key])\n            repr += '\\n'\n\n    if isinstance(h5group, string_types):\n        h5f.close()\n\n    return repr",
  "def _boolean(sstr):\n    \"\"\"Coerce a string to a boolean following the same convention as\n    :meth:`configparser.ConfigParser.getboolean`:\n     - '1', 'yes', 'true' and 'on' cause this function to return ``True``\n     - '0', 'no', 'false' and 'off' cause this function to return ``False``\n\n    :param sstr: String representation of a boolean\n    :return: ``True`` or ``False``\n    :raise: ``ValueError`` if ``sstr`` is not a valid string representation \n        of a boolean\n    \"\"\"\n    if sstr.lower() in ['1', 'yes', 'true', 'on']:\n        return True\n    if sstr.lower() in ['0', 'no', 'false', 'off']:\n        return False\n    msg = \"Cannot coerce string '%s' to a boolean value. \" % sstr\n    msg += \"Valid boolean strings: '1', 'yes', 'true', 'on',  \"\n    msg += \"'0', 'no', 'false', 'off'\"\n    raise ValueError(msg)",
  "def _parse_simple_types(sstr):\n    \"\"\"Coerce a string representation of a value to the most appropriate data\n    type, by trial and error.\n\n    Typecasting is attempted to following data types (in this order):\n    `int`, `float`, `boolean`. If all of these conversions fail, ``sstr``\n    is assumed to be a string.\n\n    :param sstr: String representation of an unknown data type\n    :return: Value coerced into the most appropriate data type\n    \"\"\"\n    try:\n        return int(sstr)\n    except ValueError:\n        try:\n            return float(sstr)\n        except ValueError:\n            try:\n                return _boolean(sstr)\n            except ValueError:\n                if sstr.strip() == \"None\":\n                    return None\n                # un-escape string\n                sstr = sstr.lstrip(\"\\\\\")\n                # un-escape commas\n                sstr = sstr.replace(\"\\,\", \",\").replace(\"^@\", \",\")\n                return sstr",
  "def _parse_container(sstr):\n    \"\"\"Parse a string representation of a list or a numpy array.\n\n    A string such as ``\"-1, Hello World, 3.0\"`` is interpreted as the list\n    ``[-1, \"Hello World\", 3.0]``. ``\"-1, \"no\", 3.0\\n\\t1, 2\"`` is interpreted\n    a list of 2 lists ``[[-1, False, 3.0], [1, 2]]``\n\n    Strings such as ``\"[ [ 1.  2.  3.] [ 4.  5.  6.] ]\"`` or\n    ``[ 1.0 2.0 3.0 ]`` are interpreted as numpy arrays. Only 1D and 2D\n    arrays are permitted.\n\n    :param sstr: String representation of an container type\n    :return: List or array\n    :raise: ``ValueError`` if string is not a list or an array\n    \"\"\"\n    sstr = sstr.strip()\n\n    if not sstr:\n        raise ValueError\n\n    if sstr.find(',') == -1:\n        # it is not a list\n        if (sstr[0] == '[') and (sstr[-1] == ']'):\n            # this looks like an array\n            try:\n                # try parsing as a 1D array\n                return numpy.array([float(x) for x in sstr[1:-1].split()])\n            except ValueError:\n                # try parsing as a 2D array\n                if (sstr[2] == '[') and (sstr[-3] == ']'):\n                    nrows = len(sstr[3:-3].split('] ['))\n                    data = sstr[3:-3].replace('] [', ' ')\n                    data = numpy.array([float(x) for x in\n                                        data.split()])\n                    data.shape = nrows, -1\n                    return data\n        # not a list and not an array\n        raise ValueError\n    else:\n        # if all commas are escaped, it is a strinq, not a list\n        if sstr.count(\",\") == sstr.count(\"\\,\"):\n            raise ValueError\n\n        dataline = [line for line in sstr.splitlines()]\n        if len(dataline) == 1:\n            return _parse_list_line(dataline[0])\n        else:\n            return [_parse_list_line(line) for line in dataline]",
  "def _parse_list_line(sstr):\n    \"\"\"Parse the string representation of a simple 1D list:\n\n    ``\"12, 13.1, True, Hello\"`` ``->`` ``[12, 13.1, True, \"Hello\"]``\n\n    :param sstr: String\n    :return: List\n    \"\"\"\n    sstr = sstr.strip()\n\n    # preserve escaped commas in strings before splitting list\n    # (_parse_simple_types recognizes ^@ as a comma)\n    sstr.replace(\"\\,\", \"^@\")\n    # it is a list\n    if sstr.endswith(','):\n        if ',' in sstr[:-1]:\n            return [_parse_simple_types(sstr2.strip())\n                    for sstr2 in sstr[:-1].split(',')]\n        else:\n            return [_parse_simple_types(sstr[:-1].strip())]\n    else:\n        return [_parse_simple_types(sstr2.strip())\n                for sstr2 in sstr.split(',')]",
  "class OptionStr(str):\n    \"\"\"String class providing typecasting methods to parse values in a\n    :class:`ConfigDict` generated configuration file.\n    \"\"\"\n    def toint(self):\n        \"\"\"\n        :return: integer\n        :raise: ``ValueError`` if conversion to ``int`` failed\n        \"\"\"\n        return int(self)\n\n    def tofloat(self):\n        \"\"\"\n        :return: Floating point value\n        :raise: ``ValueError`` if conversion to ``float`` failed\n        \"\"\"\n        return float(self)\n\n    def toboolean(self):\n        \"\"\"\n        '1', 'yes', 'true' and 'on' are interpreted as ``True``\n\n        '0', 'no', 'false' and 'off' are interpreted as ``False``\n\n        :return: Boolean\n        :raise: ``ValueError`` if conversion to ``bool`` failed\n        \"\"\"\n        return _boolean(self)\n\n    def tostr(self):\n        \"\"\"Return string after replacing escaped commas ``\\,`` with regular\n        commas ``,`` and removing leading backslash.\n\n        :return: str(self)\n        \"\"\"\n        return str(self.replace(\"\\,\", \",\").lstrip(\"\\\\\"))\n\n    def tocontainer(self):\n        \"\"\"Return a list or a numpy array.\n\n        Any string containing a comma (``,``) character will be interpreted\n        as a list: for instance ``-1, Hello World, 3.0``, or ``\"2.0,``\n\n        The format for numpy arrays is a blank space delimited list of values\n        between square brackets: ``[ 1.3 2.2 3.1 ]``, or\n        ``[ [ 1 2 3 ] [ 1 4 9 ] ]``\"\"\"\n        return _parse_container(self)\n\n    def tobestguess(self):\n        \"\"\"Parse string without prior knowledge of type.\n\n        Conversion to following types is attempted, in this order:\n        `list`, `numpy array`, `int`, `float`, `boolean`.\n        If all of these conversions fail, the string is returned unchanged.\n        \"\"\"\n        try:\n            return _parse_container(self)\n        except ValueError:\n            return _parse_simple_types(self)",
  "class ConfigDict(dict):\n    \"\"\"Store configuration parameters as a dictionary.\n\n    Parameters can be grouped into sections, by storing them as\n    sub-dictionaries.\n\n    Keys must be strings. Values can be: integers, booleans, lists,\n    numpy arrays, floats, strings.\n\n    Methods are provided to write a configuration file in a variant of INI\n    format. A :class:`ConfigDict` can load (or be initialized from) a list of files.\n\n    The main differences between files written/read by this class and standard\n    ``ConfigParser`` files are:\n\n        - sections can be nested to any depth\n        - value types are guessed when the file is read back\n        - to prevent strings from being interpreted as lists, commas are\n          escaped with a backslash (``\\,``)\n        - strings are prefixed with a leading backslash (``\\,``) to prevent\n          conversion to numeric or boolean values\n    \"\"\"\n    def __init__(self, defaultdict=None, initdict=None, filelist=None):\n        if defaultdict is None:\n            defaultdict = {}\n        dict.__init__(self, defaultdict)\n        self.default = defaultdict\n        self.filelist = []\n\n        if initdict is not None:\n            self.update(initdict)\n        if filelist is not None:\n            self.read(filelist)\n\n    def reset(self):\n        \"\"\" Revert to default values\n        \"\"\"\n        self.clear()\n        self.update(self.default)\n\n    def clear(self):\n        \"\"\" Clear dictionnary\n        \"\"\"\n        dict.clear(self)\n        self.filelist = []\n\n    def __tolist(self, mylist):\n        \"\"\" If ``mylist` is not a list, encapsulate it in a list.\n        \"\"\"\n        if mylist is None:\n            return None\n        if not isinstance(mylist, list):\n            return [mylist]\n        else:\n            return mylist\n\n    def getfiles(self):\n        \"\"\"Return list of configuration file names\"\"\"\n        return self.filelist\n\n    def getlastfile(self):\n        \"\"\"Return last configuration file name\"\"\"\n        return self.filelist[len(self.filelist) - 1]\n\n    def __convert(self, option):\n        \"\"\"Used as configparser.ConfigParser().optionxform to transform\n        option names on every read, get, or set operation.\n\n        This overrides the default ConfigParser behavior to preserve case\n        instead of converting names to lowercase.\"\"\"\n        return option\n\n    def read(self, filelist, sections=None):\n        \"\"\"\n        read the input filename into the internal dictionary\n        \"\"\"\n        filelist = self.__tolist(filelist)\n        sections = self.__tolist(sections)\n        cfg = configparser.ConfigParser()\n        cfg.optionxform = self.__convert\n        cfg.read(filelist)\n        self.__read(cfg, sections)\n\n        for ffile in filelist:\n            self.filelist.append([ffile, sections])\n\n    def __read(self, cfg, sections=None):\n        cfgsect = cfg.sections()\n\n        if sections is None:\n            readsect = cfgsect\n        else:\n            readsect = [sect for sect in cfgsect if sect in sections]\n\n        for sect in readsect:\n            ddict = self\n            for subsectw in sect.split('.'):\n                subsect = subsectw.replace(\"_|_\", \".\")\n                if not (subsect in ddict):\n                    ddict[subsect] = {}\n                ddict = ddict[subsect]\n            for opt in cfg.options(sect):\n                ddict[opt] = self.__parse_data(cfg.get(sect, opt))\n\n    def __parse_data(self, data):\n        \"\"\"Parse an option retuned by ``ConfigParser``.\n\n        The original option is a string, we try to parse it as one of\n        following types: `numpx array`, `list`, `float`, `int`, `boolean`,\n        `string`\"\"\"\n        return OptionStr(data).tobestguess()\n\n    def tostring(self):\n        \"\"\"Return INI file content generated by :meth:`write` as a string\n        \"\"\"\n        import StringIO\n        tmp = StringIO.StringIO()\n        self.__write(tmp, self)\n        return tmp.getvalue()\n\n    def write(self, ffile):\n        \"\"\"Write the current dictionary to the given filename or\n        file handle.\n\n        :param ffile: Output file name or file handle. If a file name is\n            provided, the method opens it, writes it and closes it again.\n        \"\"\"\n        if not hasattr(ffile, \"write\"):\n            fp = open(ffile, \"w\")\n        else:\n            fp = ffile\n\n        self.__write(fp, self)\n\n        if not hasattr(ffile, \"write\"):\n            fp.close()\n\n    def _escape_str(self, sstr):\n        \"\"\"Escape strings and special characters in strings with a ``\\``\n        character.\n\n        This way, we ensure these strings cannot be interpreted as a numeric\n        or boolean types and commas in strings are not interpreted as list\n        items separators. We also escape ``%`` when it is not followed by a\n        ``(``, as required by ``configparser`` because ``%`` is used in\n        the interpolation syntax\n        (https://docs.python.org/3/library/configparser.html#interpolation-of-values).\n        \"\"\"\n        non_str = r'^([0-9]+|[0-9]*\\.[0-9]*|none|false|true|on|off|yes|no)$'\n        if re.match(non_str, sstr.lower()):\n            sstr = \"\\\\\" + sstr\n        # Escape commas\n        sstr = sstr.replace(\",\", \"\\,\")\n\n        if sys.version > '3.0':\n            # Escape % except in \"%%\" and \"%(\"\n            # argparse will handle converting %% back to %\n            sstr = re.sub(r'%([^%\\(])', r'%%\\1', sstr)\n\n        return sstr\n\n    def __write(self, fp, ddict, secthead=None):\n        \"\"\"Do the actual file writing when called by the ``write`` method.\n\n        :param fp: File handle\n        :param ddict: Dictionary to be written to file\n        :param secthead: Prefix for section name, used for handling nested\n            dictionaries recursively.\n        \"\"\"\n        dictkey = []\n        listkey = []\n        valkey = []\n        strkey = []\n\n        for key in ddict.keys():\n            if isinstance(ddict[key], list):\n                listkey.append(key)\n            elif hasattr(ddict[key], 'keys'):\n                dictkey.append(key)\n            elif isinstance(ddict[key], string_types):\n                strkey.append(key)\n            else:\n                valkey.append(key)\n\n        for key in valkey:\n            if isinstance(ddict[key], numpy.ndarray):\n                fp.write('%s =' % key + ' [ ' +\n                         ' '.join([str(val) for val in ddict[key]]) +\n                         ' ]\\n')\n            else:\n                fp.write('%s = %s\\n' % (key, ddict[key]))\n\n        for key in strkey:\n            fp.write('%s = %s\\n' % (key, self._escape_str(ddict[key])))\n\n        for key in listkey:\n            fp.write('%s = ' % key)\n            llist = []\n            sep = ', '\n            for item in ddict[key]:\n                if isinstance(item, list):\n                    if len(item) == 1:\n                        if isinstance(item[0], string_types):\n                            self._escape_str(item[0])\n                            llist.append('%s,' % self._escape_str(item[0]))\n                        else:\n                            llist.append('%s,' % item[0])\n                    else:\n                        item2 = []\n                        for val in item:\n                            if isinstance(val, string_types):\n                                val = self._escape_str(val)\n                            item2.append(val)\n                        llist.append(', '.join([str(val) for val in item2]))\n                    sep = '\\n\\t'\n                elif isinstance(item, string_types):\n                    llist.append(self._escape_str(item))\n                else:\n                    llist.append(str(item))\n            fp.write('%s\\n' % (sep.join(llist)))\n\n        for key in dictkey:\n            if secthead is None:\n                newsecthead = key.replace(\".\", \"_|_\")\n            else:\n                newsecthead = '%s.%s' % (secthead, key.replace(\".\", \"_|_\"))\n\n            fp.write('\\n[%s]\\n' % newsecthead)\n            self.__write(fp, ddict[key], newsecthead)",
  "def toint(self):\n        \"\"\"\n        :return: integer\n        :raise: ``ValueError`` if conversion to ``int`` failed\n        \"\"\"\n        return int(self)",
  "def tofloat(self):\n        \"\"\"\n        :return: Floating point value\n        :raise: ``ValueError`` if conversion to ``float`` failed\n        \"\"\"\n        return float(self)",
  "def toboolean(self):\n        \"\"\"\n        '1', 'yes', 'true' and 'on' are interpreted as ``True``\n\n        '0', 'no', 'false' and 'off' are interpreted as ``False``\n\n        :return: Boolean\n        :raise: ``ValueError`` if conversion to ``bool`` failed\n        \"\"\"\n        return _boolean(self)",
  "def tostr(self):\n        \"\"\"Return string after replacing escaped commas ``\\,`` with regular\n        commas ``,`` and removing leading backslash.\n\n        :return: str(self)\n        \"\"\"\n        return str(self.replace(\"\\,\", \",\").lstrip(\"\\\\\"))",
  "def tocontainer(self):\n        \"\"\"Return a list or a numpy array.\n\n        Any string containing a comma (``,``) character will be interpreted\n        as a list: for instance ``-1, Hello World, 3.0``, or ``\"2.0,``\n\n        The format for numpy arrays is a blank space delimited list of values\n        between square brackets: ``[ 1.3 2.2 3.1 ]``, or\n        ``[ [ 1 2 3 ] [ 1 4 9 ] ]``\"\"\"\n        return _parse_container(self)",
  "def tobestguess(self):\n        \"\"\"Parse string without prior knowledge of type.\n\n        Conversion to following types is attempted, in this order:\n        `list`, `numpy array`, `int`, `float`, `boolean`.\n        If all of these conversions fail, the string is returned unchanged.\n        \"\"\"\n        try:\n            return _parse_container(self)\n        except ValueError:\n            return _parse_simple_types(self)",
  "def __init__(self, defaultdict=None, initdict=None, filelist=None):\n        if defaultdict is None:\n            defaultdict = {}\n        dict.__init__(self, defaultdict)\n        self.default = defaultdict\n        self.filelist = []\n\n        if initdict is not None:\n            self.update(initdict)\n        if filelist is not None:\n            self.read(filelist)",
  "def reset(self):\n        \"\"\" Revert to default values\n        \"\"\"\n        self.clear()\n        self.update(self.default)",
  "def clear(self):\n        \"\"\" Clear dictionnary\n        \"\"\"\n        dict.clear(self)\n        self.filelist = []",
  "def __tolist(self, mylist):\n        \"\"\" If ``mylist` is not a list, encapsulate it in a list.\n        \"\"\"\n        if mylist is None:\n            return None\n        if not isinstance(mylist, list):\n            return [mylist]\n        else:\n            return mylist",
  "def getfiles(self):\n        \"\"\"Return list of configuration file names\"\"\"\n        return self.filelist",
  "def getlastfile(self):\n        \"\"\"Return last configuration file name\"\"\"\n        return self.filelist[len(self.filelist) - 1]",
  "def __convert(self, option):\n        \"\"\"Used as configparser.ConfigParser().optionxform to transform\n        option names on every read, get, or set operation.\n\n        This overrides the default ConfigParser behavior to preserve case\n        instead of converting names to lowercase.\"\"\"\n        return option",
  "def read(self, filelist, sections=None):\n        \"\"\"\n        read the input filename into the internal dictionary\n        \"\"\"\n        filelist = self.__tolist(filelist)\n        sections = self.__tolist(sections)\n        cfg = configparser.ConfigParser()\n        cfg.optionxform = self.__convert\n        cfg.read(filelist)\n        self.__read(cfg, sections)\n\n        for ffile in filelist:\n            self.filelist.append([ffile, sections])",
  "def __read(self, cfg, sections=None):\n        cfgsect = cfg.sections()\n\n        if sections is None:\n            readsect = cfgsect\n        else:\n            readsect = [sect for sect in cfgsect if sect in sections]\n\n        for sect in readsect:\n            ddict = self\n            for subsectw in sect.split('.'):\n                subsect = subsectw.replace(\"_|_\", \".\")\n                if not (subsect in ddict):\n                    ddict[subsect] = {}\n                ddict = ddict[subsect]\n            for opt in cfg.options(sect):\n                ddict[opt] = self.__parse_data(cfg.get(sect, opt))",
  "def __parse_data(self, data):\n        \"\"\"Parse an option retuned by ``ConfigParser``.\n\n        The original option is a string, we try to parse it as one of\n        following types: `numpx array`, `list`, `float`, `int`, `boolean`,\n        `string`\"\"\"\n        return OptionStr(data).tobestguess()",
  "def tostring(self):\n        \"\"\"Return INI file content generated by :meth:`write` as a string\n        \"\"\"\n        import StringIO\n        tmp = StringIO.StringIO()\n        self.__write(tmp, self)\n        return tmp.getvalue()",
  "def write(self, ffile):\n        \"\"\"Write the current dictionary to the given filename or\n        file handle.\n\n        :param ffile: Output file name or file handle. If a file name is\n            provided, the method opens it, writes it and closes it again.\n        \"\"\"\n        if not hasattr(ffile, \"write\"):\n            fp = open(ffile, \"w\")\n        else:\n            fp = ffile\n\n        self.__write(fp, self)\n\n        if not hasattr(ffile, \"write\"):\n            fp.close()",
  "def _escape_str(self, sstr):\n        \"\"\"Escape strings and special characters in strings with a ``\\``\n        character.\n\n        This way, we ensure these strings cannot be interpreted as a numeric\n        or boolean types and commas in strings are not interpreted as list\n        items separators. We also escape ``%`` when it is not followed by a\n        ``(``, as required by ``configparser`` because ``%`` is used in\n        the interpolation syntax\n        (https://docs.python.org/3/library/configparser.html#interpolation-of-values).\n        \"\"\"\n        non_str = r'^([0-9]+|[0-9]*\\.[0-9]*|none|false|true|on|off|yes|no)$'\n        if re.match(non_str, sstr.lower()):\n            sstr = \"\\\\\" + sstr\n        # Escape commas\n        sstr = sstr.replace(\",\", \"\\,\")\n\n        if sys.version > '3.0':\n            # Escape % except in \"%%\" and \"%(\"\n            # argparse will handle converting %% back to %\n            sstr = re.sub(r'%([^%\\(])', r'%%\\1', sstr)\n\n        return sstr",
  "def __write(self, fp, ddict, secthead=None):\n        \"\"\"Do the actual file writing when called by the ``write`` method.\n\n        :param fp: File handle\n        :param ddict: Dictionary to be written to file\n        :param secthead: Prefix for section name, used for handling nested\n            dictionaries recursively.\n        \"\"\"\n        dictkey = []\n        listkey = []\n        valkey = []\n        strkey = []\n\n        for key in ddict.keys():\n            if isinstance(ddict[key], list):\n                listkey.append(key)\n            elif hasattr(ddict[key], 'keys'):\n                dictkey.append(key)\n            elif isinstance(ddict[key], string_types):\n                strkey.append(key)\n            else:\n                valkey.append(key)\n\n        for key in valkey:\n            if isinstance(ddict[key], numpy.ndarray):\n                fp.write('%s =' % key + ' [ ' +\n                         ' '.join([str(val) for val in ddict[key]]) +\n                         ' ]\\n')\n            else:\n                fp.write('%s = %s\\n' % (key, ddict[key]))\n\n        for key in strkey:\n            fp.write('%s = %s\\n' % (key, self._escape_str(ddict[key])))\n\n        for key in listkey:\n            fp.write('%s = ' % key)\n            llist = []\n            sep = ', '\n            for item in ddict[key]:\n                if isinstance(item, list):\n                    if len(item) == 1:\n                        if isinstance(item[0], string_types):\n                            self._escape_str(item[0])\n                            llist.append('%s,' % self._escape_str(item[0]))\n                        else:\n                            llist.append('%s,' % item[0])\n                    else:\n                        item2 = []\n                        for val in item:\n                            if isinstance(val, string_types):\n                                val = self._escape_str(val)\n                            item2.append(val)\n                        llist.append(', '.join([str(val) for val in item2]))\n                    sep = '\\n\\t'\n                elif isinstance(item, string_types):\n                    llist.append(self._escape_str(item))\n                else:\n                    llist.append(str(item))\n            fp.write('%s\\n' % (sep.join(llist)))\n\n        for key in dictkey:\n            if secthead is None:\n                newsecthead = key.replace(\".\", \"_|_\")\n            else:\n                newsecthead = '%s.%s' % (secthead, key.replace(\".\", \"_|_\"))\n\n            fp.write('\\n[%s]\\n' % newsecthead)\n            self.__write(fp, ddict[key], newsecthead)",
  "def configuration(parent_package='', top_path=None):\n    config = Configuration('io', parent_package, top_path)\n    config.add_subpackage('test')\n\n    srcfiles = ['sfheader','sfinit','sflists','sfdata','sfindex',\n                'sflabel' ,'sfmca', 'sftools','locale_management']\n    sources = [os.path.join('specfile', 'src', ffile + '.c') for ffile in srcfiles]\n    sources.append(os.path.join('specfile', 'specfile.pyx'))\n\n\n    config.add_extension('specfile',\n                         sources=sources,\n                         define_macros = define_macros,\n                         include_dirs = [os.path.join('specfile', 'include'),\n                                         numpy.get_include()],\n                         language='c')\n    return config",
  "def write_spec_to_h5(specfile, h5file, h5path='/',\n                     mode=\"a\", overwrite_data=False,\n                     link_type=\"hard\", create_dataset_args=None):\n    \"\"\"Write content of a SpecFile in a HDF5 file.\n\n    :param specfile: Path of input SpecFile or :class:`SpecH5` instance\n    :param h5file: Path of output HDF5 file or HDF5 file handle\n    :param h5path: Target path in HDF5 file in which scan groups are created.\n        Default is root (``\"/\"``)\n    :param mode: Can be ``\"r+\"`` (read/write, file must exist),\n        ``\"w\"`` (write, existing file is lost), ``\"w-\"`` (write, fail\n        if exists) or ``\"a\"`` (read/write if exists, create otherwise).\n        This parameter is ignored if ``h5file`` is a file handle.\n    :param overwrite_data: If ``True``, existing groups and datasets can be\n        overwritten, if ``False`` they are skipped. This parameter is only\n        relevant if ``file_mode`` is ``\"r+\"`` or ``\"a\"``.\n    :param link_type: ``\"hard\"`` (default) or ``\"soft\"``\n    :param create_dataset_args: Dictionary of args you want to pass to\n        ``h5f.create_dataset``. This allows you to specify filters and\n        compression parameters. Don't specify ``name`` and ``data``.\n        These arguments don't apply to scalar datasets.\n\n    The structure of the spec data in an HDF5 file is described in the\n    documentation of :mod:`silx.io.spech5`.\n    \"\"\"\n    if not isinstance(specfile, SpecH5):\n        sfh5 = SpecH5(specfile)\n    else:\n        sfh5 = specfile\n\n    if not isinstance(h5file, h5py.File):\n        h5f = h5py.File(h5file, mode)\n    else:\n        h5f = h5file\n\n    if not h5path.endswith(\"/\"):\n        h5path += \"/\"\n\n    if create_dataset_args is None:\n        create_dataset_args = {}\n\n    def create_link(link_name, target):\n        \"\"\"Create link\n\n        If member with name ``link_name`` already exists, delete it first or\n        ignore link depending on global param ``overwrite_data``.\n\n        :param link_name: Link path\n        :param target: Handle for target group or dataset\n        \"\"\"\n        if link_name not in h5f:\n            logger.debug(\"Creating link \" + link_name + \" -> \" + target.name)\n        elif overwrite_data:\n            logger.warn(\"Overwriting \" + link_name + \" with link to\" +\n                        target.name)\n            del h5f[link_name]\n        else:\n            logger.warn(link_name + \" already exist. Can't create link to \" +\n                        target.name)\n            return None\n\n        if link_type == \"hard\":\n            h5f[link_name] = target\n        elif link_type == \"soft\":\n            h5f[link_name] = h5py.SoftLink(target.name)\n        else:\n            raise ValueError(\"link_type  must be 'hard' or 'soft'\")\n\n    def append_spec_member_to_h5(spec_h5_name, obj):\n        h5_name = h5path + spec_h5_name.lstrip(\"/\")\n\n        if isinstance(obj, SpecH5LinkToGroup) or\\\n                isinstance(obj, SpecH5LinkToDataset):\n            # links are created at the same time as their targets\n            logger.debug(\"Ignoring link: \" + h5_name)\n            pass\n\n        elif isinstance(obj, SpecH5Dataset):\n            logger.debug(\"Saving dataset: \" + h5_name)\n\n            member_initially_exists = h5_name in h5f\n\n            if overwrite_data and member_initially_exists:\n                logger.warn(\"Overwriting dataset: \" + h5_name)\n                del h5f[h5_name]\n\n            if overwrite_data or not member_initially_exists:\n                # fancy arguments don't apply to scalars (shape==())\n                if obj.shape == ():\n                    ds = h5f.create_dataset(h5_name, data=obj)\n                else:\n                    ds = h5f.create_dataset(h5_name, data=obj,\n                                            **create_dataset_args)\n            else:\n                ds = h5f[h5_name]\n\n            # link:\n            #  /1.1/measurement/mca_0/data  --> /1.1/instrument/mca_0/data\n            if re.match(r\".*/([0-9]+\\.[0-9]+)/instrument/mca_([0-9]+)/?data$\",\n                        h5_name):\n                link_name = h5_name.replace(\"instrument\", \"measurement\")\n                create_link(link_name, ds)\n\n            # this has to be at the end if we want link creation and\n            # dataset creation to remain independent for odd cases\n            # where dataset exists but not the link\n            if not overwrite_data and member_initially_exists:\n                logger.warn(\"Ignoring existing dataset: \" + h5_name)\n\n        elif isinstance(obj, SpecH5Group):\n            if h5_name not in h5f:\n                logger.debug(\"Creating group: \" + h5_name)\n                grp = h5f.create_group(h5_name)\n            else:\n                grp = h5f[h5_name]\n\n            # link:\n            # /1.1/measurement/mca_0/info  --> /1.1/instrument/mca_0/\n            if re.match(r\".*/([0-9]+\\.[0-9]+)/instrument/mca_([0-9]+)/?$\",\n                        h5_name):\n                link_name = h5_name.replace(\"instrument\", \"measurement\")\n                link_name += \"/info\"\n                create_link(link_name, grp)\n\n    sfh5.visititems(append_spec_member_to_h5)\n\n    # Close file if it was opened in this function\n    if not isinstance(h5file, h5py.File):\n        h5f.close()",
  "def convert(specfile, h5file, mode=\"w-\",\n            create_dataset_args=None):\n    \"\"\"Convert a SpecFile into an HDF5 file, write scans into the root (``/``)\n    group.\n\n    :param specfile: Path of input SpecFile or :class:`SpecH5` instance\n    :param h5file: Path of output HDF5 file or HDF5 file handle\n    :param mode: Can be ``\"w\"`` (write, existing file is\n        lost), ``\"w-\"`` (write, fail if exists). This is ignored\n        if ``h5file`` is a file handle.\n    :param create_dataset_args: Dictionary of args you want to pass to\n        ``h5f.create_dataset``. This allows you to specify filters and\n        compression parameters. Don't specify ``name`` and ``data``.\n\n    This is a convenience shortcut to call::\n\n        write_spec_to_h5(specfile, h5file, h5path='/',\n                         mode=\"w-\", link_type=\"hard\")\n    \"\"\"\n    if mode not in [\"w\", \"w-\"]:\n        raise IOError(\"File mode must be 'w' or 'w-'. Use write_spec_to_h5\" +\n                      \" to append Spec data to an existing HDF5 file.\")\n    write_spec_to_h5(specfile, h5file, h5path='/',\n                     mode=mode,\n                     create_dataset_args=create_dataset_args)",
  "def create_link(link_name, target):\n        \"\"\"Create link\n\n        If member with name ``link_name`` already exists, delete it first or\n        ignore link depending on global param ``overwrite_data``.\n\n        :param link_name: Link path\n        :param target: Handle for target group or dataset\n        \"\"\"\n        if link_name not in h5f:\n            logger.debug(\"Creating link \" + link_name + \" -> \" + target.name)\n        elif overwrite_data:\n            logger.warn(\"Overwriting \" + link_name + \" with link to\" +\n                        target.name)\n            del h5f[link_name]\n        else:\n            logger.warn(link_name + \" already exist. Can't create link to \" +\n                        target.name)\n            return None\n\n        if link_type == \"hard\":\n            h5f[link_name] = target\n        elif link_type == \"soft\":\n            h5f[link_name] = h5py.SoftLink(target.name)\n        else:\n            raise ValueError(\"link_type  must be 'hard' or 'soft'\")",
  "def append_spec_member_to_h5(spec_h5_name, obj):\n        h5_name = h5path + spec_h5_name.lstrip(\"/\")\n\n        if isinstance(obj, SpecH5LinkToGroup) or\\\n                isinstance(obj, SpecH5LinkToDataset):\n            # links are created at the same time as their targets\n            logger.debug(\"Ignoring link: \" + h5_name)\n            pass\n\n        elif isinstance(obj, SpecH5Dataset):\n            logger.debug(\"Saving dataset: \" + h5_name)\n\n            member_initially_exists = h5_name in h5f\n\n            if overwrite_data and member_initially_exists:\n                logger.warn(\"Overwriting dataset: \" + h5_name)\n                del h5f[h5_name]\n\n            if overwrite_data or not member_initially_exists:\n                # fancy arguments don't apply to scalars (shape==())\n                if obj.shape == ():\n                    ds = h5f.create_dataset(h5_name, data=obj)\n                else:\n                    ds = h5f.create_dataset(h5_name, data=obj,\n                                            **create_dataset_args)\n            else:\n                ds = h5f[h5_name]\n\n            # link:\n            #  /1.1/measurement/mca_0/data  --> /1.1/instrument/mca_0/data\n            if re.match(r\".*/([0-9]+\\.[0-9]+)/instrument/mca_([0-9]+)/?data$\",\n                        h5_name):\n                link_name = h5_name.replace(\"instrument\", \"measurement\")\n                create_link(link_name, ds)\n\n            # this has to be at the end if we want link creation and\n            # dataset creation to remain independent for odd cases\n            # where dataset exists but not the link\n            if not overwrite_data and member_initially_exists:\n                logger.warn(\"Ignoring existing dataset: \" + h5_name)\n\n        elif isinstance(obj, SpecH5Group):\n            if h5_name not in h5f:\n                logger.debug(\"Creating group: \" + h5_name)\n                grp = h5f.create_group(h5_name)\n            else:\n                grp = h5f[h5_name]\n\n            # link:\n            # /1.1/measurement/mca_0/info  --> /1.1/instrument/mca_0/\n            if re.match(r\".*/([0-9]+\\.[0-9]+)/instrument/mca_([0-9]+)/?$\",\n                        h5_name):\n                link_name = h5_name.replace(\"instrument\", \"measurement\")\n                link_name += \"/info\"\n                create_link(link_name, grp)",
  "def _prepare_hdf5_dataset(array_like):\n    \"\"\"Cast a python object into a numpy array in a HDF5 friendly format.\n\n    :param array_like: Input dataset in a type that can be digested by\n        ``numpy.array()`` (`str`, `list`, `numpy.ndarray`\u2026)\n    :return: ``numpy.ndarray`` ready to be written as an HDF5 dataset\n    \"\"\"\n    # simple strings\n    if isinstance(array_like, string_types):\n        array_like = numpy.string_(array_like)\n\n    # Ensure our data is a numpy.ndarray\n    if not isinstance(array_like, (numpy.ndarray, numpy.string_)):\n        array = numpy.array(array_like)\n    else:\n        array = array_like\n\n    # handle list of strings or numpy array of strings\n    if not isinstance(array, numpy.string_):\n        data_kind = array.dtype.kind\n        # unicode: convert to byte strings\n        # (http://docs.h5py.org/en/latest/strings.html)\n        if data_kind.lower() in [\"s\", \"u\"]:\n            array = numpy.asarray(array, dtype=numpy.string_)\n\n    return array",
  "def dicttoh5(treedict, h5file, h5path='/',\n             mode=\"a\", overwrite_data=False,\n             create_dataset_args=None):\n    \"\"\"Write a nested dictionary to a HDF5 file, using keys as member names.\n\n    If a dictionary value is a sub-dictionary, a group is created. If it is\n    any other data type, it is cast into a numpy array and written as a\n    :mod:`h5py` dataset. Dictionary keys must be strings and cannot contain\n    the ``/`` character.\n\n    .. note::\n\n        This function requires `h5py <http://www.h5py.org/>`_ to be installed.\n\n    :param treedict: Nested dictionary/tree structure with strings as keys\n         and array-like objects as leafs. The ``\"/\"`` character is not allowed\n         in keys.\n    :param h5file: HDF5 file name or handle. If a file name is provided, the\n        function opens the file in the specified mode and closes it again\n        before completing.\n    :param h5path: Target path in HDF5 file in which scan groups are created.\n        Default is root (``\"/\"``)\n    :param mode: Can be ``\"r+\"`` (read/write, file must exist),\n        ``\"w\"`` (write, existing file is lost), ``\"w-\"`` (write, fail if\n        exists) or ``\"a\"`` (read/write if exists, create otherwise).\n        This parameter is ignored if ``h5file`` is a file handle.\n    :param overwrite_data: If ``True``, existing groups and datasets can be\n        overwritten, if ``False`` they are skipped. This parameter is only\n        relevant if ``h5file_mode`` is ``\"r+\"`` or ``\"a\"``.\n    :param create_dataset_args: Dictionary of args you want to pass to\n        ``h5f.create_dataset``. This allows you to specify filters and\n        compression parameters. Don't specify ``name`` and ``data``.\n\n    Example::\n\n        from silx.io.dicttoh5 import dictdump\n\n        city_area = {\n            \"Europe\": {\n                \"France\": {\n                    \"Is\u00e8re\": {\n                        \"Grenoble\": \"18.44 km2\"\n                    },\n                    \"Nord\": {\n                        \"Tourcoing\": \"15.19 km2\"\n                    },\n                },\n            },\n        }\n\n        create_ds_args = {'compression': \"gzip\",\n                          'shuffle': True,\n                          'fletcher32': True}\n\n        dicttoh5(city_area, \"cities.h5\", h5path=\"/area\",\n                 create_dataset_args=create_ds_args)\n    \"\"\"\n    if h5py_missing:\n        raise h5py_import_error\n\n    if not isinstance(h5file, h5py.File):\n        h5f = h5py.File(h5file, mode)\n    else:\n        h5f = h5file\n\n    if not h5path.endswith(\"/\"):\n        h5path += \"/\"\n\n    for key in treedict:\n\n        if isinstance(treedict[key], dict) and len(treedict[key]):\n            # non-empty group: recurse\n            dicttoh5(treedict[key], h5f, h5path + key,\n                     overwrite_data=overwrite_data,\n                     create_dataset_args=create_dataset_args)\n\n        elif treedict[key] is None or (isinstance(treedict[key], dict)\n             and not len(treedict[key])):\n            # Create empty group\n            h5f.create_group(h5path + key)\n\n        else:\n            ds = _prepare_hdf5_dataset(treedict[key])\n            # can't apply filters on scalars (datasets with shape == () )\n            if ds.shape == () or create_dataset_args is None:\n                h5f.create_dataset(h5path + key,\n                                   data=ds)\n            else:\n                h5f.create_dataset(h5path + key,\n                                   data=ds,\n                                   **create_dataset_args)\n\n    if isinstance(h5file, string_types):\n        h5f.close()",
  "def h5todict(h5file, path=\"/\"):\n    \"\"\"Read HDF5 file and return a nested dictionary with the complete file\n    structure and all data.\n\n    .. note:: This function requires `h5py <http://www.h5py.org/>`_ to be\n        installed.\n\n    .. note:: If you write a dictionary to a HDF5\u00a0file with \n        :func:`dicttoh5` and then read it back with :func:`h5todict`, data\n        types are not preserved. All values are cast to numpy arrays before\n        being written to file, and they are read back as numpy arrays (or\n        scalars). In some cases, you may find that a list of heterogeneous\n        data types is converted to a numpy array of strings.\n\n    :param h5file: File name or :class:`h5py.File` object\n    :return: dict\n    \"\"\"\n    if h5py_missing:\n        raise h5py_import_error\n\n    if not isinstance(h5file, h5py.File):\n        h5f = h5py.File(h5file, \"r\")\n    else:\n        h5f = h5file\n\n    ddict = {}\n    for key in h5f[path]:\n\n        if isinstance(h5f[path + \"/\" + key], h5py.Group):\n            ddict[key] = h5todict(h5f, path + \"/\" + key)\n        else:\n            # Convert HDF5\u00a0dataset to numpy array\n            ddict[key] = h5f[path + \"/\" + key][...]\n    return ddict",
  "def dicttojson(dict, jsonfile, indent=None, mode=\"w\"):\n    \"\"\"Serialize ``dict`` as a JSON formatted stream to ``jsonfile``.\n\n    :param dict: Dictionary (or any object compatible with ``json.dump``).\n    :param jsonfile: JSON file name or file-like object.\n        If a file name is provided, the function opens the file in the\n        specified mode and closes it again.\n    :param indent: If indent is a non-negative integer, then JSON array\n        elements and object members will be pretty-printed with that indent\n        level. An indent level of ``0`` will only insert newlines.\n        ``None`` (the default) selects the most compact representation.\n    :param mode: File opening mode (``w``, ``a``, ``w+``\u2026)\n    \"\"\"\n    if not hasattr(jsonfile, \"write\"):\n        jsonf = open(jsonfile, mode)\n    else:\n        jsonf = jsonfile\n\n    json.dump(dict, jsonf, indent=indent)\n\n    if not hasattr(jsonfile, \"write\"):\n        jsonf.close()",
  "def dicttoini(ddict, inifile, mode=\"a\"):\n    \"\"\"Output dict as configuration file (similar to Microsoft Windows INI).\n\n    :param dict: Dictionary of configuration parameters\n    :param inifile: INI file name or file-like object.\n        If a file name is provided, the function opens the file in the\n        specified mode and closes it again.\n    :param mode: File opening mode (``w``, ``a``, ``w+``\u2026)\n    \"\"\"\n    if not hasattr(inifile, \"write\"):\n        inif = open(inifile, mode)\n    else:\n        inif = inifile\n\n    ConfigDict(initdict=ddict).write(inif)\n\n    if not hasattr(inifile, \"write\"):\n        inif.close()",
  "def dump(ddict, ffile, fmat=\"json\"):\n    \"\"\"Dump dictionary to a file\n\n    :param ddict: Dictionary with string keys\n    :param ffile: File name or file-like object with a ``write`` method\n    :param fmat: Output format: ``\"json\"``, ``\"hdf5\"`` or ``\"ini\"``.\n        Dumping to a HDF5 file requires `h5py <http://www.h5py.org/>`_ to be\n        installed.\n    \"\"\"\n    if fmat.lower() == \"json\":\n        dicttojson(ddict, ffile)\n    elif fmat.lower() in [\"hdf5\", \"h5\"]:\n        if h5py_missing:\n            logger.error(\"Cannot dump to HDF5 format, missing h5py library\")\n            raise h5py_import_error\n        dicttoh5(ddict, ffile)\n    elif fmat.lower() in [\"ini\", \"cfg\"]:\n        dicttoini(ddict, ffile)\n    else:\n        raise IOError(\"Unknown format \" + fmat)",
  "def load(ffile, fmat=\"json\"):\n    \"\"\"Load dictionary from a file\n\n    :param ffile: File name or file-like object with a ``read`` method\n    :param fmat: Input format: ``json``, ``hdf5`` or ``ini``\n        Loading from a HDF5 file requires `h5py <http://www.h5py.org/>`_ to be\n        installed.\n    :return: Dictionary\n    \"\"\"\n    if not hasattr(ffile, \"read\"):\n        f = open(ffile, \"r\")\n        fname = ffile\n    else:\n        f = ffile\n        fname = ffile.name\n\n    if fmat.lower() == \"json\":\n        return json.load(f)\n    if fmat.lower() in [\"hdf5\", \"h5\"]:\n        if h5py_missing:\n            logger.error(\"Cannot load from HDF5 format, missing h5py library\")\n            raise h5py_import_error\n        return h5todict(fname)\n    if fmat.lower() in [\"ini\", \"cfg\"]:\n        return ConfigDict().read(fname)\n    raise IOError(\"Unknown format \" + fmat)",
  "class TestCaseQt(unittest.TestCase):\n    \"\"\"Base class to write test for Qt stuff.\n\n    It creates a QApplication before running the tests.\n    WARNING: The QApplication is shared by all tests, which might have side\n    effects.\n\n    After each test, this class is checking for wigdets remaining alive.\n    To allow some widgets to remain alive at the end of a test, set the\n    allowedLeakingWidgets attribute to the number of widgets that can remain\n    alive at the end of the test.\n    \"\"\"\n\n    DEFAULT_TIMEOUT_WAIT = 100\n    \"\"\"Default timeout for qWait\"\"\"\n\n    TIMEOUT_WAIT = 0\n    \"\"\"Extra timeout in millisecond to add to qSleep, qWait and\n    qWaitForWindowExposed.\n\n    Intended purpose is for debugging, to add extra time to waits in order to\n    allow to view the tested widgets.\n    \"\"\"\n\n    QTest = QTest\n    \"\"\"The Qt QTest class from the used Qt binding.\"\"\"\n\n    def setUp(self):\n        \"\"\"Get the list of existing widgets.\"\"\"\n        self.allowedLeakingWidgets = 0\n        self.__previousWidgets = self.qapp.allWidgets()\n\n    def tearDown(self):\n        \"\"\"Test fixture checking that no more widgets exists.\"\"\"\n        gc.collect()\n\n        widgets = [widget for widget in self.qapp.allWidgets()\n                   if widget not in self.__previousWidgets]\n        del self.__previousWidgets\n\n        allowedLeakingWidgets = self.allowedLeakingWidgets\n        self.allowedLeakingWidgets = 0\n\n        if widgets and len(widgets) <= allowedLeakingWidgets:\n            _logger.info(\n                '%s: %d remaining widgets after test' % (self.id(),\n                                                         len(widgets)))\n\n        if len(widgets) > allowedLeakingWidgets:\n            raise RuntimeError(\n                \"Test ended with widgets alive: %s\" % str(widgets))\n\n    @property\n    def qapp(self):\n        \"\"\"The QApplication currently running.\"\"\"\n        return qt.QApplication.instance()\n\n    # Proxy to QTest\n\n    Press = QTest.Press\n    \"\"\"Key press action code\"\"\"\n\n    Release = QTest.Release\n    \"\"\"Key release action code\"\"\"\n\n    Click = QTest.Click\n    \"\"\"Key click action code\"\"\"\n\n    @staticmethod\n    def keyClick(widget, key, modifier=qt.Qt.NoModifier, delay=-1):\n        \"\"\"Simulate clicking a key.\n\n        See QTest.keyClick for details.\n        \"\"\"\n        QTest.keyClick(widget, key, modifier, delay)\n\n    @staticmethod\n    def keyClicks(widget, sequence, modifier=qt.Qt.NoModifier, delay=-1):\n        \"\"\"Simulate clicking a sequence of keys.\n\n        See QTest.keyClick for details.\n        \"\"\"\n        QTest.keyClicks(widget, sequence, modifier, delay)\n\n    @staticmethod\n    def keyEvent(action, widget, key, modifier=qt.Qt.NoModifier, delay=-1):\n        \"\"\"Sends a Qt key event.\n\n        See QTest.keyEvent for details.\n        \"\"\"\n        QTest.keyEvent(action, widget, key, modifier, delay)\n\n    @staticmethod\n    def keyPress(widget, key, modifier=qt.Qt.NoModifier, delay=-1):\n        \"\"\"Sends a Qt key press event.\n\n        See QTest.keyPress for details.\n        \"\"\"\n        QTest.keyPress(widget, key, modifier, delay)\n\n    @staticmethod\n    def keyRelease(widget, key, modifier=qt.Qt.NoModifier, delay=-1):\n        \"\"\"Sends a Qt key release event.\n\n        See QTest.keyRelease for details.\n        \"\"\"\n        QTest.keyRelease(widget, key, modifier, delay)\n\n    @staticmethod\n    def mouseClick(widget, button, modifier=None, pos=None, delay=-1):\n        \"\"\"Simulate clicking a mouse button.\n\n        See QTest.mouseClick for details.\n        \"\"\"\n        if modifier is None:\n            modifier=qt.Qt.KeyboardModifiers()\n        pos = qt.QPoint(pos[0], pos[1]) if pos is not None else qt.QPoint()\n        QTest.mouseClick(widget, button, modifier, pos, delay)\n\n    @staticmethod\n    def mouseDClick(widget, button, modifier=None, pos=None, delay=-1):\n        \"\"\"Simulate double clicking a mouse button.\n\n        See QTest.mouseDClick for details.\n        \"\"\"\n        if modifier is None:\n            modifier=qt.Qt.KeyboardModifiers()\n        pos = qt.QPoint(pos[0], pos[1]) if pos is not None else qt.QPoint()\n        QTest.mouseDClick(widget, button, modifier, pos, delay)\n\n    @staticmethod\n    def mouseMove(widget, pos=None, delay=-1):\n        \"\"\"Simulate moving the mouse.\n\n        See QTest.mouseMove for details.\n        \"\"\"\n        pos = qt.QPoint(pos[0], pos[1]) if pos is not None else qt.QPoint()\n        QTest.mouseMove(widget, pos, delay)\n\n    @staticmethod\n    def mousePress(widget, button, modifier=None, pos=None, delay=-1):\n        \"\"\"Simulate pressing a mouse button.\n\n        See QTest.mousePress for details.\n        \"\"\"\n        if modifier is None:\n            modifier=qt.Qt.KeyboardModifiers()\n        pos = qt.QPoint(pos[0], pos[1]) if pos is not None else qt.QPoint()\n        QTest.mousePress(widget, button, modifier, pos, delay)\n\n    @staticmethod\n    def mouseRelease(widget, button, modifier=None, pos=None, delay=-1):\n        \"\"\"Simulate releasing a mouse button.\n\n        See QTest.mouseRelease for details.\n        \"\"\"\n        if modifier is None:\n            modifier=qt.Qt.KeyboardModifiers()\n        pos = qt.QPoint(pos[0], pos[1]) if pos is not None else qt.QPoint()\n        QTest.mouseRelease(widget, button, modifier, pos, delay)\n\n    def qSleep(self, ms):\n        \"\"\"Sleep for ms milliseconds, blocking the execution of the test.\n\n        See QTest.qSleep for details.\n        \"\"\"\n        QTest.qSleep(ms + self.TIMEOUT_WAIT)\n\n    def qWait(self, ms=None):\n        \"\"\"Waits for ms milliseconds, events will be processed.\n\n        See QTest.qWait for details.\n        \"\"\"\n        if ms is None:\n            ms = self.DEFAULT_TIMEOUT_WAIT\n\n        if qt.BINDING == 'PySide':\n            # PySide has no qWait, provide a replacement\n            timeout = int(ms)\n            endTimeMS = int(time.time() * 1000) + timeout\n            while timeout > 0:\n                self.qapp.processEvents(qt.QEventLoop.AllEvents,\n                                        maxtime=timeout)\n                timeout = endTimeMS - int(time.time() * 1000)\n        else:\n            QTest.qWait(ms + self.TIMEOUT_WAIT)\n\n    def qWaitForWindowExposed(self, window, timeout=None):\n        \"\"\"Waits until the window is shown in the screen.\n\n        See QTest.qWaitForWindowExposed for details.\n        \"\"\"\n        if timeout is None:\n            result = qWaitForWindowExposed(window)\n        else:\n            result = qWaitForWindowExposed(window, timeout)\n\n        if self.TIMEOUT_WAIT:\n            QTest.qWait(self.TIMEOUT_WAIT)\n\n        return result",
  "def qWaitForWindowExposed(window, timeout=None):\n        \"\"\"Mimic QTest.qWaitForWindowExposed for Qt4.\"\"\"\n        QTest.qWaitForWindowShown(window)\n        return True",
  "def setUp(self):\n        \"\"\"Get the list of existing widgets.\"\"\"\n        self.allowedLeakingWidgets = 0\n        self.__previousWidgets = self.qapp.allWidgets()",
  "def tearDown(self):\n        \"\"\"Test fixture checking that no more widgets exists.\"\"\"\n        gc.collect()\n\n        widgets = [widget for widget in self.qapp.allWidgets()\n                   if widget not in self.__previousWidgets]\n        del self.__previousWidgets\n\n        allowedLeakingWidgets = self.allowedLeakingWidgets\n        self.allowedLeakingWidgets = 0\n\n        if widgets and len(widgets) <= allowedLeakingWidgets:\n            _logger.info(\n                '%s: %d remaining widgets after test' % (self.id(),\n                                                         len(widgets)))\n\n        if len(widgets) > allowedLeakingWidgets:\n            raise RuntimeError(\n                \"Test ended with widgets alive: %s\" % str(widgets))",
  "def qapp(self):\n        \"\"\"The QApplication currently running.\"\"\"\n        return qt.QApplication.instance()",
  "def keyClick(widget, key, modifier=qt.Qt.NoModifier, delay=-1):\n        \"\"\"Simulate clicking a key.\n\n        See QTest.keyClick for details.\n        \"\"\"\n        QTest.keyClick(widget, key, modifier, delay)",
  "def keyClicks(widget, sequence, modifier=qt.Qt.NoModifier, delay=-1):\n        \"\"\"Simulate clicking a sequence of keys.\n\n        See QTest.keyClick for details.\n        \"\"\"\n        QTest.keyClicks(widget, sequence, modifier, delay)",
  "def keyEvent(action, widget, key, modifier=qt.Qt.NoModifier, delay=-1):\n        \"\"\"Sends a Qt key event.\n\n        See QTest.keyEvent for details.\n        \"\"\"\n        QTest.keyEvent(action, widget, key, modifier, delay)",
  "def keyPress(widget, key, modifier=qt.Qt.NoModifier, delay=-1):\n        \"\"\"Sends a Qt key press event.\n\n        See QTest.keyPress for details.\n        \"\"\"\n        QTest.keyPress(widget, key, modifier, delay)",
  "def keyRelease(widget, key, modifier=qt.Qt.NoModifier, delay=-1):\n        \"\"\"Sends a Qt key release event.\n\n        See QTest.keyRelease for details.\n        \"\"\"\n        QTest.keyRelease(widget, key, modifier, delay)",
  "def mouseClick(widget, button, modifier=None, pos=None, delay=-1):\n        \"\"\"Simulate clicking a mouse button.\n\n        See QTest.mouseClick for details.\n        \"\"\"\n        if modifier is None:\n            modifier=qt.Qt.KeyboardModifiers()\n        pos = qt.QPoint(pos[0], pos[1]) if pos is not None else qt.QPoint()\n        QTest.mouseClick(widget, button, modifier, pos, delay)",
  "def mouseDClick(widget, button, modifier=None, pos=None, delay=-1):\n        \"\"\"Simulate double clicking a mouse button.\n\n        See QTest.mouseDClick for details.\n        \"\"\"\n        if modifier is None:\n            modifier=qt.Qt.KeyboardModifiers()\n        pos = qt.QPoint(pos[0], pos[1]) if pos is not None else qt.QPoint()\n        QTest.mouseDClick(widget, button, modifier, pos, delay)",
  "def mouseMove(widget, pos=None, delay=-1):\n        \"\"\"Simulate moving the mouse.\n\n        See QTest.mouseMove for details.\n        \"\"\"\n        pos = qt.QPoint(pos[0], pos[1]) if pos is not None else qt.QPoint()\n        QTest.mouseMove(widget, pos, delay)",
  "def mousePress(widget, button, modifier=None, pos=None, delay=-1):\n        \"\"\"Simulate pressing a mouse button.\n\n        See QTest.mousePress for details.\n        \"\"\"\n        if modifier is None:\n            modifier=qt.Qt.KeyboardModifiers()\n        pos = qt.QPoint(pos[0], pos[1]) if pos is not None else qt.QPoint()\n        QTest.mousePress(widget, button, modifier, pos, delay)",
  "def mouseRelease(widget, button, modifier=None, pos=None, delay=-1):\n        \"\"\"Simulate releasing a mouse button.\n\n        See QTest.mouseRelease for details.\n        \"\"\"\n        if modifier is None:\n            modifier=qt.Qt.KeyboardModifiers()\n        pos = qt.QPoint(pos[0], pos[1]) if pos is not None else qt.QPoint()\n        QTest.mouseRelease(widget, button, modifier, pos, delay)",
  "def qSleep(self, ms):\n        \"\"\"Sleep for ms milliseconds, blocking the execution of the test.\n\n        See QTest.qSleep for details.\n        \"\"\"\n        QTest.qSleep(ms + self.TIMEOUT_WAIT)",
  "def qWait(self, ms=None):\n        \"\"\"Waits for ms milliseconds, events will be processed.\n\n        See QTest.qWait for details.\n        \"\"\"\n        if ms is None:\n            ms = self.DEFAULT_TIMEOUT_WAIT\n\n        if qt.BINDING == 'PySide':\n            # PySide has no qWait, provide a replacement\n            timeout = int(ms)\n            endTimeMS = int(time.time() * 1000) + timeout\n            while timeout > 0:\n                self.qapp.processEvents(qt.QEventLoop.AllEvents,\n                                        maxtime=timeout)\n                timeout = endTimeMS - int(time.time() * 1000)\n        else:\n            QTest.qWait(ms + self.TIMEOUT_WAIT)",
  "def qWaitForWindowExposed(self, window, timeout=None):\n        \"\"\"Waits until the window is shown in the screen.\n\n        See QTest.qWaitForWindowExposed for details.\n        \"\"\"\n        if timeout is None:\n            result = qWaitForWindowExposed(window)\n        else:\n            result = qWaitForWindowExposed(window, timeout)\n\n        if self.TIMEOUT_WAIT:\n            QTest.qWait(self.TIMEOUT_WAIT)\n\n        return result",
  "def configuration(parent_package='', top_path=None):\n    config = Configuration('gui', parent_package, top_path)\n    config.add_subpackage('plot')\n    config.add_subpackage('test')\n\n    return config",
  "def getQIcon(name):\n    \"\"\"Create a QIcon from its name.\n\n    :param str name: Name of the icon, in one of the defined icons\n                     in this module.\n    :return: Corresponding QIcon\n    :raises: ValueError when name is not known\n    \"\"\"\n    try:\n        filename = resource_filename('gui/icons/%s.png' % name)\n    except ValueError:\n        raise ValueError('Not an icon name: %s' % name)\n\n    return qt.QIcon(filename)",
  "def getQPixmap(name):\n    \"\"\"Create a QPixmap from its name.\n\n    :param str name: Name of the icon, in one of the defined icons\n                     in this module.\n    :return: Corresponding QPixmap\n    :raises: ValueError when name is not known\n    \"\"\"\n    try:\n        filename = resource_filename('icons/%s.png')\n    except ValueError:\n        raise ValueError('Not an icon name: %s' % name)\n\n    return qt.QPixmap(filename)",
  "class State(object):\n    \"\"\"Base class for the states of a state machine.\n\n    This class is meant to be subclassed.\n    \"\"\"\n\n    def __init__(self, machine):\n        \"\"\"State instances should be created by the :class:`StateMachine`.\n\n        They are not intended to be used outside this context.\n\n        :param machine: The state machine instance this state belongs to.\n        :type machine: StateMachine\n        \"\"\"\n        self._machineRef = weakref.ref(machine)  # Prevent cyclic reference\n\n    @property\n    def machine(self):\n        \"\"\"The state machine this state belongs to.\n\n        Useful to access data or methods that are shared across states.\n        \"\"\"\n        machine = self._machineRef()\n        if machine is not None:\n            return machine\n        else:\n            raise RuntimeError(\"Associated StateMachine is not valid\")\n\n    def goto(self, state, *args, **kwargs):\n        \"\"\"Performs a transition to a new state.\n\n        Extra arguments are passed to the :meth:`enter` method of the\n        new state.\n\n        :param str state: The name of the state to go to.\n        \"\"\"\n        self.machine._goto(state, *args, **kwargs)\n\n    def enter(self, *args, **kwargs):\n        \"\"\"Called when the state machine enters this state.\n\n        Arguments are those provided to the :meth:`goto` method that\n        triggered the transition to this state.\n        \"\"\"\n        pass\n\n    def leave(self):\n        \"\"\"Called when the state machine leaves this state\n        (i.e., when :meth:`goto` is called).\n        \"\"\"\n        pass",
  "class StateMachine(object):\n    \"\"\"State machine controller.\n\n    This is the entry point of a state machine.\n    It is in charge of dispatching received event and handling the\n    current active state.\n    \"\"\"\n\n    def __init__(self, states, initState, *args, **kwargs):\n        \"\"\"Create a state machine controller with an initial state.\n\n        Extra arguments are passed to the enter method of the initState.\n\n        :param states: All states of the state machine\n        :type states: dict of: {str name: State subclass}\n        :param str initState: Key of the initial state in states\n        \"\"\"\n        self.states = states\n\n        self.state = self.states[initState](self)\n        self.state.enter(*args, **kwargs)\n\n    def _goto(self, state, *args, **kwargs):\n        self.state.leave()\n        self.state = self.states[state](self)\n        self.state.enter(*args, **kwargs)\n\n    def handleEvent(self, eventName, *args, **kwargs):\n        \"\"\"Process an event with the state machine.\n\n        This method looks up for an event handler in the current state\n        and then in the :class:`StateMachine` instance.\n        Handler are looked up as 'onEventName' method.\n        If a handler is found, it is called with the provided extra\n        arguments, and this method returns the return value of the\n        handler.\n        If no handler is found, this method returns None.\n\n        :param str eventName: Name of the event to handle\n        :returns: The return value of the handler or None\n        \"\"\"\n        handlerName = 'on' + eventName[0].upper() + eventName[1:]\n        try:\n            handler = getattr(self.state, handlerName)\n        except AttributeError:\n            try:\n                handler = getattr(self, handlerName)\n            except AttributeError:\n                handler = None\n        if handler is not None:\n            return handler(*args, **kwargs)",
  "class ClickOrDrag(StateMachine):\n    \"\"\"State machine for left and right click and left drag interaction.\n\n    It is intended to be used through subclassing by overriding\n    :meth:`click`, :meth:`beginDrag`, :meth:`drag` and :meth:`endDrag`.\n    \"\"\"\n\n    DRAG_THRESHOLD_SQUARE_DIST = 5 ** 2\n\n    class Idle(State):\n        def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('clickOrDrag', x, y)\n                return True\n            elif btn == RIGHT_BTN:\n                self.goto('rightClick', x, y)\n                return True\n\n    class RightClick(State):\n        def onMove(self, x, y):\n            self.goto('idle')\n\n        def onRelease(self, x, y, btn):\n            if btn == RIGHT_BTN:\n                self.machine.click(x, y, btn)\n                self.goto('idle')\n\n    class ClickOrDrag(State):\n        def enter(self, x, y):\n            self.initPos = x, y\n\n        def onMove(self, x, y):\n            dx = (x - self.initPos[0]) ** 2\n            dy = (y - self.initPos[1]) ** 2\n            if (dx ** 2 + dy ** 2) >= self.machine.DRAG_THRESHOLD_SQUARE_DIST:\n                self.goto('drag', self.initPos, (x, y))\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.click(x, y, btn)\n                self.goto('idle')\n\n    class Drag(State):\n        def enter(self, initPos, curPos):\n            self.initPos = initPos\n            self.machine.beginDrag(*initPos)\n            self.machine.drag(*curPos)\n\n        def onMove(self, x, y):\n            self.machine.drag(x, y)\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.endDrag(self.initPos, (x, y))\n                self.goto('idle')\n\n    def __init__(self):\n        states = {\n            'idle': ClickOrDrag.Idle,\n            'rightClick': ClickOrDrag.RightClick,\n            'clickOrDrag': ClickOrDrag.ClickOrDrag,\n            'drag': ClickOrDrag.Drag\n        }\n        super(ClickOrDrag, self).__init__(states, 'idle')\n\n    def click(self, x, y, btn):\n        \"\"\"Called upon a left or right button click.\n\n        To override in a subclass.\n        \"\"\"\n        pass\n\n    def beginDrag(self, x, y):\n        \"\"\"Called at the beginning of a drag gesture with left button\n        pressed.\n\n        To override in a subclass.\n        \"\"\"\n        pass\n\n    def drag(self, x, y):\n        \"\"\"Called on mouse moved during a drag gesture.\n\n        To override in a subclass.\n        \"\"\"\n        pass\n\n    def endDrag(self, x, y):\n        \"\"\"Called at the end of a drag gesture when the left button is\n        released.\n\n        To override in a subclass.\n        \"\"\"\n        pass",
  "def __init__(self, machine):\n        \"\"\"State instances should be created by the :class:`StateMachine`.\n\n        They are not intended to be used outside this context.\n\n        :param machine: The state machine instance this state belongs to.\n        :type machine: StateMachine\n        \"\"\"\n        self._machineRef = weakref.ref(machine)",
  "def machine(self):\n        \"\"\"The state machine this state belongs to.\n\n        Useful to access data or methods that are shared across states.\n        \"\"\"\n        machine = self._machineRef()\n        if machine is not None:\n            return machine\n        else:\n            raise RuntimeError(\"Associated StateMachine is not valid\")",
  "def goto(self, state, *args, **kwargs):\n        \"\"\"Performs a transition to a new state.\n\n        Extra arguments are passed to the :meth:`enter` method of the\n        new state.\n\n        :param str state: The name of the state to go to.\n        \"\"\"\n        self.machine._goto(state, *args, **kwargs)",
  "def enter(self, *args, **kwargs):\n        \"\"\"Called when the state machine enters this state.\n\n        Arguments are those provided to the :meth:`goto` method that\n        triggered the transition to this state.\n        \"\"\"\n        pass",
  "def leave(self):\n        \"\"\"Called when the state machine leaves this state\n        (i.e., when :meth:`goto` is called).\n        \"\"\"\n        pass",
  "def __init__(self, states, initState, *args, **kwargs):\n        \"\"\"Create a state machine controller with an initial state.\n\n        Extra arguments are passed to the enter method of the initState.\n\n        :param states: All states of the state machine\n        :type states: dict of: {str name: State subclass}\n        :param str initState: Key of the initial state in states\n        \"\"\"\n        self.states = states\n\n        self.state = self.states[initState](self)\n        self.state.enter(*args, **kwargs)",
  "def _goto(self, state, *args, **kwargs):\n        self.state.leave()\n        self.state = self.states[state](self)\n        self.state.enter(*args, **kwargs)",
  "def handleEvent(self, eventName, *args, **kwargs):\n        \"\"\"Process an event with the state machine.\n\n        This method looks up for an event handler in the current state\n        and then in the :class:`StateMachine` instance.\n        Handler are looked up as 'onEventName' method.\n        If a handler is found, it is called with the provided extra\n        arguments, and this method returns the return value of the\n        handler.\n        If no handler is found, this method returns None.\n\n        :param str eventName: Name of the event to handle\n        :returns: The return value of the handler or None\n        \"\"\"\n        handlerName = 'on' + eventName[0].upper() + eventName[1:]\n        try:\n            handler = getattr(self.state, handlerName)\n        except AttributeError:\n            try:\n                handler = getattr(self, handlerName)\n            except AttributeError:\n                handler = None\n        if handler is not None:\n            return handler(*args, **kwargs)",
  "class Idle(State):\n        def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('clickOrDrag', x, y)\n                return True\n            elif btn == RIGHT_BTN:\n                self.goto('rightClick', x, y)\n                return True",
  "class RightClick(State):\n        def onMove(self, x, y):\n            self.goto('idle')\n\n        def onRelease(self, x, y, btn):\n            if btn == RIGHT_BTN:\n                self.machine.click(x, y, btn)\n                self.goto('idle')",
  "class ClickOrDrag(State):\n        def enter(self, x, y):\n            self.initPos = x, y\n\n        def onMove(self, x, y):\n            dx = (x - self.initPos[0]) ** 2\n            dy = (y - self.initPos[1]) ** 2\n            if (dx ** 2 + dy ** 2) >= self.machine.DRAG_THRESHOLD_SQUARE_DIST:\n                self.goto('drag', self.initPos, (x, y))\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.click(x, y, btn)\n                self.goto('idle')",
  "class Drag(State):\n        def enter(self, initPos, curPos):\n            self.initPos = initPos\n            self.machine.beginDrag(*initPos)\n            self.machine.drag(*curPos)\n\n        def onMove(self, x, y):\n            self.machine.drag(x, y)\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.endDrag(self.initPos, (x, y))\n                self.goto('idle')",
  "def __init__(self):\n        states = {\n            'idle': ClickOrDrag.Idle,\n            'rightClick': ClickOrDrag.RightClick,\n            'clickOrDrag': ClickOrDrag.ClickOrDrag,\n            'drag': ClickOrDrag.Drag\n        }\n        super(ClickOrDrag, self).__init__(states, 'idle')",
  "def click(self, x, y, btn):\n        \"\"\"Called upon a left or right button click.\n\n        To override in a subclass.\n        \"\"\"\n        pass",
  "def beginDrag(self, x, y):\n        \"\"\"Called at the beginning of a drag gesture with left button\n        pressed.\n\n        To override in a subclass.\n        \"\"\"\n        pass",
  "def drag(self, x, y):\n        \"\"\"Called on mouse moved during a drag gesture.\n\n        To override in a subclass.\n        \"\"\"\n        pass",
  "def endDrag(self, x, y):\n        \"\"\"Called at the end of a drag gesture when the left button is\n        released.\n\n        To override in a subclass.\n        \"\"\"\n        pass",
  "def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('clickOrDrag', x, y)\n                return True\n            elif btn == RIGHT_BTN:\n                self.goto('rightClick', x, y)\n                return True",
  "def onMove(self, x, y):\n            self.goto('idle')",
  "def onRelease(self, x, y, btn):\n            if btn == RIGHT_BTN:\n                self.machine.click(x, y, btn)\n                self.goto('idle')",
  "def enter(self, x, y):\n            self.initPos = x, y",
  "def onMove(self, x, y):\n            dx = (x - self.initPos[0]) ** 2\n            dy = (y - self.initPos[1]) ** 2\n            if (dx ** 2 + dy ** 2) >= self.machine.DRAG_THRESHOLD_SQUARE_DIST:\n                self.goto('drag', self.initPos, (x, y))",
  "def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.click(x, y, btn)\n                self.goto('idle')",
  "def enter(self, initPos, curPos):\n            self.initPos = initPos\n            self.machine.beginDrag(*initPos)\n            self.machine.drag(*curPos)",
  "def onMove(self, x, y):\n            self.machine.drag(x, y)",
  "def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.endDrag(self.initPos, (x, y))\n                self.goto('idle')",
  "class Plot(object):\n    \"\"\"This class implements the plot API initially provided in PyMca.\n\n    Supported backends:\n\n    - 'matplotlib' and 'mpl': Matplotlib with Qt.\n    - 'none': No backend, to run headless for testing purpose.\n\n    :param parent: The parent widget of the plot (Default: None)\n    :param backend: The backend to use. A str in:\n                    'matplotlib', 'mpl', 'none'\n                    or a :class:`BackendBase.BackendBase` class\n    :param bool autoreplot: Toggle autoreplot mode (Default: True).\n    \"\"\"\n\n    defaultBackend = 'matplotlib'\n    \"\"\"Class attribute setting the default backend for all instances.\"\"\"\n\n    colorList = _COLORLIST\n    colorDict = _COLORDICT\n\n    def __init__(self, parent=None, backend=None, autoreplot=True):\n        self._autoreplot = bool(autoreplot)\n        self._dirty = False\n\n        if backend is None:\n            backend = self.defaultBackend\n\n        if hasattr(backend, \"__call__\"):\n            self._backend = backend(self, parent)\n\n        elif hasattr(backend, \"lower\"):\n            lowerCaseString = backend.lower()\n            if lowerCaseString in (\"matplotlib\", \"mpl\"):\n                from .BackendMatplotlib import BackendMatplotlibQt as \\\n                    backendClass\n            elif lowerCaseString == 'none':\n                from .BackendBase import BackendBase as backendClass\n            else:\n                raise ValueError(\"Backend not supported %s\" % backend)\n            self._backend = backendClass(self, parent)\n\n        else:\n            raise ValueError(\"Backend not supported %s\" % str(backend))\n\n        super(Plot, self).__init__()\n\n        self.setCallback()  # set _callback\n\n        # Items handling\n        self._curves = OrderedDict()\n        self._hiddenCurves = set()\n\n        self._images = OrderedDict()\n        self._markers = OrderedDict()\n        self._items = OrderedDict()\n\n        # line types\n        self._styleList = ['-', '--', '-.', ':']\n\n        self._colorIndex = 0\n        self._styleIndex = 0\n\n        self._activeCurveHandling = True\n        self._activeCurve = None\n        self._activeCurveColor = \"#000000\"\n        self._activeImage = None\n\n        # default properties\n        self._cursorConfiguration = None\n\n        self._logY = False\n        self._logX = False\n        self._xAutoScale = True\n        self._yAutoScale = True\n        self._grid = None\n\n        self.setGraphTitle()\n        self.setGraphXLabel()\n        self.setGraphYLabel()\n\n        self.setDefaultColormap()  # Init default colormap\n\n        self.setDefaultPlotPoints(False)\n        self.setDefaultPlotLines(True)\n\n        self._eventHandler = PlotInteraction.PlotInteraction(self)\n        self._eventHandler.setInteractiveMode('zoom', color=(0., 0., 0., 1.))\n\n        self._pressedButtons = []  # Currently pressed mouse buttons\n\n        self._defaultDataMargins = (0., 0., 0., 0.)\n\n    def _getDirtyPlot(self):\n        \"\"\"Return the plot dirty flag.\n\n        If False, the plot has not changed since last replot.\n        If True, the full plot need to be redrawn.\n        If 'overlay', only the overlay has changed since last replot.\n\n        It can be accessed by backend to check the dirty state.\n\n        :return: False, True, 'overlay'\n        \"\"\"\n        return self._dirty\n\n    def _setDirtyPlot(self, overlayOnly=False):\n        \"\"\"Mark the plot as needing redraw\n\n        :param bool overlayOnly: True to redraw only the overlay,\n                                 False to redraw everything\n        \"\"\"\n        wasDirty = self._dirty\n\n        if not self._dirty and overlayOnly:\n            self._dirty = 'overlay'\n        else:\n            self._dirty = True\n\n        if self._autoreplot and not wasDirty:\n            self._backend.postRedisplay()\n\n    # Add\n\n    # add * input arguments management:\n    # If an arg is set, then use it.\n    # Else:\n    #     If a curve with the same legend exists, then use its arg value\n    #     Else, use a default value.\n    # Store used value.\n    # This value is used when curve is updated either internally or by user.\n\n    def addCurve(self, x, y, legend=None, info=None,\n                 replace=False, replot=None,\n                 color=None, symbol=None,\n                 linewidth=None, linestyle=None,\n                 xlabel=None, ylabel=None, yaxis=None,\n                 xerror=None, yerror=None, z=None, selectable=None,\n                 fill=None, resetzoom=True, **kw):\n        \"\"\"Add a 1D curve given by x an y to the graph.\n\n        Curves are uniquely identified by their legend.\n        To add multiple curves, call :meth:`addCurve` multiple times with\n        different legend argument.\n        To replace/update an existing curve, call :meth:`addCurve` with the\n        existing curve legend.\n\n        When curve parameters are not provided, if a curve with the\n        same legend is displayed in the plot, its parameters are used.\n\n        :param numpy.ndarray x: The data corresponding to the x coordinates\n        :param numpy.ndarray y: The data corresponding to the y coordinates\n        :param str legend: The legend to be associated to the curve (or None)\n        :param info: User-defined information associated to the curve\n        :param bool replace: True (the default) to delete already existing\n                             curves\n        :param color: color(s) to be used\n        :type color: str (\"#RRGGBB\") or (npoints, 4) unsigned byte array or\n                     one of the predefined color names defined in Colors.py\n        :param str symbol: Symbol to be drawn at each (x, y) position::\n\n            - 'o' circle\n            - '.' point\n            - ',' pixel\n            - '+' cross\n            - 'x' x-cross\n            - 'd' diamond\n            - 's' square\n            - None (the default) to use default symbol\n\n        :param float linewidth: The width of the curve in pixels (Default: 1).\n        :param str linestyle: Type of line::\n\n            - ' '  no line\n            - '-'  solid line\n            - '--' dashed line\n            - '-.' dash-dot line\n            - ':'  dotted line\n            - None (the default) to use default line style\n\n        :param str xlabel: Label to show on the X axis when the curve is active\n        :param str ylabel: Label to show on the Y axis when the curve is active\n        :param str yaxis: The Y axis this curve is attached to.\n                          Either 'left' (the default) or 'right'\n        :param xerror: Values with the uncertainties on the x values\n        :type xerror: A float, or a numpy.ndarray of float32.\n                      If it is an array, it can either be a 1D array of\n                      same length as the data or a 2D array with 2 rows\n                      of same length as the data: row 0 for positive errors,\n                      row 1 for negative errors.\n        :param yerror: Values with the uncertainties on the y values\n        :type yerror: A float, or a numpy.ndarray of float32. See xerror.\n        :param int z: Layer on which to draw the curve (default: 1)\n                      This allows to control the overlay.\n        :param bool selectable: Indicate if the curve can be selected.\n                                (Default: True)\n        :param bool fill: True to fill the curve, False otherwise (default).\n        :param bool resetzoom: True (the default) to reset the zoom.\n        :returns: The key string identify this curve\n        \"\"\"\n        # Take care of input parameters: check/conversion, default value\n\n        if replot is not None:\n            _logger.warning(\n                'addCurve deprecated replot argument, use resetzoom instead')\n            resetzoom = replot and resetzoom\n\n        if kw:\n            _logger.warning('addCurve: deprecated extra arguments')\n\n        legend = \"Unnamed curve 1.1\" if legend is None else str(legend)\n\n        # Check/Convert input arguments\n\n        # Convert to arrays (not forcing type) in order to avoid\n        # problems at unexpected places: missing min or max attributes, problem\n        # when using numpy.nonzero on lists, ...\n        x = numpy.asarray(x)\n        y = numpy.asarray(y)\n\n        # TODO check color\n\n        assert symbol in ('o', '.', ',', '+', 'x', 'd', 's', '', None)\n\n        assert linestyle in ('', ' ', '-', '--', '-.', ':', None)\n\n        if xlabel is not None:\n            xlabel = str(xlabel)\n\n        if ylabel is not None:\n            ylabel = str(ylabel)\n\n        assert yaxis in (None, 'left', 'right')\n\n        # TODO check xerror, yerror\n\n        if xerror is not None:\n            xerror = numpy.asarray(xerror)\n\n        if yerror is not None:\n            yerror = numpy.asarray(yerror)\n\n        if z is not None:\n            z = int(z)\n\n        if selectable is not None:\n            selectable = bool(selectable)\n\n        if fill is not None:\n            fill = bool(fill)\n\n        # Store all params with defaults in a dict to treat them at once\n        params = {\n            'info': info, 'color': color,\n            'symbol': symbol, 'linewidth': linewidth, 'linestyle': linestyle,\n            'xlabel': xlabel, 'ylabel': ylabel, 'yaxis': yaxis,\n            'xerror': xerror, 'yerror': yerror, 'z': z,\n            'selectable': selectable, 'fill': fill\n        }\n\n        # Check if curve is previously active\n        wasActive = self.getActiveCurve(just_legend=True) == legend\n\n        # First, try to get defaults from existing curve with same name\n        previousCurve = self._curves.get(legend, None)\n        if previousCurve is not None:\n            defaults = previousCurve['params']\n\n        else:  # If no existing curve use default values\n            default_color, default_linestyle = self._getColorAndStyle()\n            defaults = {\n                'info': None, 'color': default_color,\n                'symbol': self._defaultPlotPoints,\n                'linewidth': 1,\n                'linestyle': default_linestyle,\n                'xlabel': 'X', 'ylabel': 'Y', 'yaxis': 'left',\n                'xerror': None, 'yerror': None, 'z': 1,\n                'selectable': True, 'fill': False\n            }\n\n        # If a parameter is not given as argument, use its default value\n        for key in defaults:\n            if params[key] is None:\n                params[key] = defaults[key]\n\n        # Add: replace, filter data, add\n\n        # This must be done after getting params from existing curve\n        if replace:\n            self.remove(kind='curve')\n        else:\n            # Remove previous curve from backend\n            # but not from _curves and hiddenCurves to keep its place\n            # This is a subset of self.remove(legend, kind='curve')\n            if legend in self._curves:\n                handle = self._curves[legend]['handle']\n                if handle is not None:\n                    self._backend.remove(handle)\n                    self._curves[legend]['handle'] = None\n                    self._setDirtyPlot()\n\n        # Filter-out values <= 0\n        x, y, color, xerror, yerror = self._logFilterData(\n            x, y, params['color'], params['xerror'], params['yerror'],\n            self.isXAxisLogarithmic(), self.isYAxisLogarithmic())\n\n        if len(x) and not self.isCurveHidden(legend):\n            handle = self._backend.addCurve(x, y, legend,\n                                            color=color,\n                                            symbol=params['symbol'],\n                                            linestyle=params['linestyle'],\n                                            linewidth=params['linewidth'],\n                                            yaxis=params['yaxis'],\n                                            xerror=xerror,\n                                            yerror=yerror,\n                                            z=params['z'],\n                                            selectable=params['selectable'],\n                                            fill=params['fill'])\n            self._setDirtyPlot()\n        else:\n            handle = None  # The curve has no points or is hidden\n\n        self._curves[legend] = {\n            'handle': handle, 'x': x, 'y': y, 'params': params\n        }\n\n        if len(self._curves) == 1 or wasActive:\n            self.setActiveCurve(legend)\n\n        if resetzoom:\n            # We ask for a zoom reset in order to handle the plot scaling\n            # if the user does not want that, autoscale of the different\n            # axes has to be set to off.\n            self.resetZoom()\n\n        self.notify(\n            'contentChanged', action='add', kind='curve', legend=legend)\n\n        return legend\n\n    def addImage(self, data, legend=None, info=None,\n                 replace=True, replot=None,\n                 xScale=None, yScale=None, z=None,\n                 selectable=False, draggable=False,\n                 colormap=None, pixmap=None,\n                 xlabel=None, ylabel=None,\n                 origin=None, scale=None,\n                 resetzoom=True, **kw):\n        \"\"\"Add a 2D dataset or an image to the plot.\n\n        It displays either an array of data using a colormap or a RGB(A) image.\n\n        Images are uniquely identified by their legend.\n        To add multiple images, call :meth:`addImage` multiple times with\n        different legend argument.\n        To replace/update an existing image, call :meth:`addImage` with the\n        existing image legend.\n\n        When image parameters are not provided, if an image with the\n        same legend is displayed in the plot, its parameters are used.\n\n        :param numpy.ndarray data: (nrows, ncolumns) data or\n                                   (nrows, ncolumns, RGBA) ubyte array\n        :param str legend: The legend to be associated to the image (or None)\n        :param info: User-defined information associated to the image\n        :param bool replace: True (default) to delete already existing images\n        :param int z: Layer on which to draw the image (default: 0)\n                      This allows to control the overlay.\n        :param bool selectable: Indicate if the image can be selected.\n                                (default: False)\n        :param bool draggable: Indicate if the image can be moved.\n                               (default: False)\n        :param dict colormap: Description of the colormap to use (or None)\n                              This is ignored if data is a RGB(A) image.\n                              See :mod:`Plot` for the documentation\n                              of the colormap dict.\n        :param pixmap: Pixmap representation of the data (if any)\n        :type pixmap: (nrows, ncolumns, RGBA) ubyte array or None (default)\n        :param str xlabel: X axis label to show when this curve is active.\n        :param str ylabel: Y axis label to show when this curve is active.\n        :param origin: (origin X, origin Y) of the data.\n                       Default: (0., 0.)\n        :type origin: 2-tuple of float\n        :param scale: (scale X, scale Y) of the data.\n                       Default: (1., 1.)\n        :type scale: 2-tuple of float\n        :param bool resetzoom: True (the default) to reset the zoom.\n        :returns: The key string identify this image\n        \"\"\"\n        # Take care of input parameters: check/conversion, default value\n\n        if xScale is not None or yScale is not None:\n            _logger.warning(\n                'addImage deprecated xScale and yScale arguments,'\n                'use origin, scale arguments instead.')\n            if origin is None and scale is None:\n                origin = xScale[0], yScale[0]\n                scale = xScale[1], yScale[1]\n            else:\n                _logger.warning(\n                    'addCurve: xScale, yScale and origin, scale arguments'\n                    ' are conflicting. xScale and yScale are ignored.'\n                    ' Use only origin, scale arguments.')\n\n        if replot is not None:\n            _logger.warning(\n                'addImage deprecated replot argument, use resetzoom instead')\n            resetzoom = replot and resetzoom\n\n        if kw:\n            _logger.warning('addImage: deprecated extra arguments')\n\n        legend = \"Unnamed Image 1.1\" if legend is None else str(legend)\n\n        # Check/Convert input arguments\n        data = numpy.asarray(data)\n\n        if origin is not None:\n            origin = float(origin[0]), float(origin[1])\n\n        if scale is not None:\n            scale = float(scale[0]), float(scale[1])\n\n        if z is not None:\n            z = int(z)\n\n        if selectable is not None:\n            selectable = bool(selectable)\n\n        if draggable is not None:\n            draggable = bool(draggable)\n\n        if pixmap is not None:\n            pixmap = numpy.asarray(pixmap)\n\n        if xlabel is not None:\n            xlabel = str(xlabel)\n\n        if ylabel is not None:\n            ylabel = str(ylabel)\n\n        # Store all params with defaults in a dict to treat them at once\n        params = {\n            'info': info, 'origin': origin, 'scale': scale, 'z': z,\n            'selectable': selectable, 'draggable': draggable,\n            'colormap': colormap,\n            'xlabel': xlabel, 'ylabel': ylabel\n        }\n\n        # First, try to get defaults from existing curve with same name\n        previousImage = self._images.get(legend, None)\n        if previousImage is not None:\n            defaults = previousImage['params']\n\n        else:  # If no existing curve use default values\n            defaults = {\n                'info': None, 'origin': (0., 0.), 'scale': (1., 1.), 'z': 0,\n                'selectable': False, 'draggable': False,\n                'colormap': self.getDefaultColormap(),\n                'xlabel': 'Column', 'ylabel': 'Row'\n            }\n\n        # If a parameter is not given as argument, use its default value\n        for key in defaults:\n            if params[key] is None:\n                params[key] = defaults[key]\n\n        # Add: replace, filter data, add\n\n        if replace:\n            self.remove(kind='image')\n        else:\n            # Remove previous image from backend\n            # but not from _images to keep its place\n            # This is a subset of self.remove(legend, kind='image')\n            if legend in self._images:\n                 handle = self._images[legend]['handle']\n                 if handle is not None:\n                     self._backend.remove(handle)\n                     self._images[legend]['handle'] = None\n                     self._setDirtyPlot()\n\n        if self.isXAxisLogarithmic() or self.isYAxisLogarithmic():\n            _logger.info('Hide image while axes has log scale.')\n\n        if (data is not None and not self.isXAxisLogarithmic() and\n                not self.isYAxisLogarithmic()):\n            if pixmap is not None:\n                dataToSend = pixmap\n            else:\n                dataToSend = data\n\n            handle = self._backend.addImage(dataToSend, legend=legend,\n                                            origin=params['origin'],\n                                            scale=params['scale'],\n                                            z=params['z'],\n                                            selectable=params['selectable'],\n                                            draggable=params['draggable'],\n                                            colormap=params['colormap'])\n            self._setDirtyPlot()\n        else:\n            handle = None  # data is None or log scale\n\n        self._images[legend] = {\n            'handle': handle,\n            'data': data,\n            'pixmap': pixmap,\n            'params': params\n        }\n\n        if len(self._images) == 1:\n            self.setActiveImage(legend)\n\n        if resetzoom:\n            # We ask for a zoom reset in order to handle the plot scaling\n            # if the user does not want that, autoscale of the different\n            # axes has to be set to off.\n            self.resetZoom()\n\n        self.notify(\n            'contentChanged', action='add', kind='image', legend=legend)\n\n        return legend\n\n    def addItem(self, xdata, ydata, legend=None, info=None,\n                replace=False,\n                shape=\"polygon\", color='black', fill=True,\n                overlay=False, **kw):\n        \"\"\"Add an item (i.e. a shape) to the plot.\n\n        Items are uniquely identified by their legend.\n        To add multiple items, call :meth:`addItem` multiple times with\n        different legend argument.\n        To replace/update an existing item, call :meth:`addImage` with the\n        existing item legend.\n\n        :param numpy.ndarray xdata: The X coords of the points of the shape\n        :param numpy.ndarray ydata: The Y coords of the points of the shape\n        :param str legend: The legend to be associated to the item\n        :param info: User-defined information associated to the image\n        :param bool replace: True (default) to delete already existing images\n        :param str shape: Type of item to be drawn in\n                          hline, polygon (the default), rectangle, vline\n        :param str color: Color of the item, e.g., 'blue', 'b', '#FF0000'\n                          (Default: 'black')\n        :param bool fill: True (the default) to fill the shape\n        :param bool overlay: True if item is an overlay (Default: False).\n                             This allows for rendering optimization if this\n                             item is changed often.\n        :returns: The key string identify this item\n        \"\"\"\n        # expected to receive the same parameters as the signal\n\n        if kw:\n            _logger.warning('addItem deprecated parameters: %s', str(kw))\n\n        legend = \"Unnamed Item 1.1\" if legend is None else str(legend)\n\n        if replace:\n            self.remove(kind='item')\n        else:\n            self.remove(legend, kind='item')\n\n        handle = self._backend.addItem(xdata, ydata, legend=legend,\n                                       shape=shape, color=color,\n                                       fill=fill, overlay=overlay)\n        self._setDirtyPlot(overlayOnly=overlay)\n\n        self._items[legend] = {'handle': handle, 'overlay': overlay}\n\n        self.notify('contentChanged', action='add', kind='item', legend=legend)\n\n        return legend\n\n    def addXMarker(self, x, legend=None,\n                   text=None,\n                   color=None,\n                   selectable=False,\n                   draggable=False,\n                   constraint=None,\n                   **kw):\n        \"\"\"Add a vertical line marker to the plot.\n\n        Markers are uniquely identified by their legend.\n        As opposed to curves, images and items, two calls to\n        :meth:`addXMarker` without legend argument adds two markers with\n        different identifying legends.\n\n        :param float x: Position of the marker on the X axis in data\n                        coordinates\n        :param str legend: Legend associated to the marker to identify it\n        :param str text: Text to display on the marker.\n        :param str color: Color of the marker, e.g., 'blue', 'b', '#FF0000'\n                          (Default: 'black')\n        :param bool selectable: Indicate if the marker can be selected.\n                                (default: False)\n        :param bool draggable: Indicate if the marker can be moved.\n                               (default: False)\n        :param constraint: A function filtering marker displacement by\n                           dragging operations or None for no filter.\n                           This function is called each time a marker is\n                           moved.\n                           This parameter is only used if draggable is True.\n        :type constraint: None or a callable that takes the coordinates of\n                          the current cursor position in the plot as input\n                          and that returns the filtered coordinates.\n        :return: The key string identify this marker\n        \"\"\"\n        if kw:\n            _logger.warning(\n                'addXMarker deprecated extra parameters: %s', str(kw))\n\n        return self._addMarker(x=x, y=None, legend=legend,\n                               text=text, color=color,\n                               selectable=selectable, draggable=draggable,\n                               symbol=None, constraint=constraint)\n\n    def addYMarker(self, y,\n                   legend=None,\n                   text=None,\n                   color=None,\n                   selectable=False,\n                   draggable=False,\n                   constraint=None,\n                   **kw):\n        \"\"\"Add a horizontal line marker to the plot.\n\n        Markers are uniquely identified by their legend.\n        As opposed to curves, images and items, two calls to\n        :meth:`addYMarker` without legend argument adds two markers with\n        different identifying legends.\n\n        :param float y: Position of the marker on the Y axis in data\n                        coordinates\n        :param str legend: Legend associated to the marker to identify it\n        :param str text: Text to display next to the marker.\n        :param str color: Color of the marker, e.g., 'blue', 'b', '#FF0000'\n                          (Default: 'black')\n        :param bool selectable: Indicate if the marker can be selected.\n                                (default: False)\n        :param bool draggable: Indicate if the marker can be moved.\n                               (default: False)\n        :param constraint: A function filtering marker displacement by\n                           dragging operations or None for no filter.\n                           This function is called each time a marker is\n                           moved.\n                           This parameter is only used if draggable is True.\n        :type constraint: None or a callable that takes the coordinates of\n                          the current cursor position in the plot as input\n                          and that returns the filtered coordinates.\n        :return: The key string identify this marker\n        \"\"\"\n        if kw:\n            _logger.warning(\n                'addYMarker deprecated extra parameters: %s', str(kw))\n\n        return self._addMarker(x=None, y=y, legend=legend,\n                               text=text, color=color,\n                               selectable=selectable, draggable=draggable,\n                               symbol=None, constraint=constraint)\n\n    def addMarker(self, x, y, legend=None,\n                  text=None,\n                  color=None,\n                  selectable=False,\n                  draggable=False,\n                  symbol='+',\n                  constraint=None,\n                  **kw):\n        \"\"\"Add a point marker to the plot.\n\n        Markers are uniquely identified by their legend.\n        As opposed to curves, images and items, two calls to\n        :meth:`addMarker` without legend argument adds two markers with\n        different identifying legends.\n\n        :param float x: Position of the marker on the X axis in data\n                        coordinates\n        :param float y: Position of the marker on the Y axis in data\n                        coordinates\n        :param str legend: Legend associated to the marker to identify it\n        :param str text: Text to display next to the marker\n        :param str color: Color of the marker, e.g., 'blue', 'b', '#FF0000'\n                          (Default: 'black')\n        :param bool selectable: Indicate if the marker can be selected.\n                                (default: False)\n        :param bool draggable: Indicate if the marker can be moved.\n                               (default: False)\n        :param str symbol: Symbol representing the marker in::\n\n            - 'o' circle\n            - '.' point\n            - ',' pixel\n            - '+' cross (the default)\n            - 'x' x-cross\n            - 'd' diamond\n            - 's' square\n\n        :param constraint: A function filtering marker displacement by\n                           dragging operations or None for no filter.\n                           This function is called each time a marker is\n                           moved.\n                           This parameter is only used if draggable is True.\n        :type constraint: None or a callable that takes the coordinates of\n                          the current cursor position in the plot as input\n                          and that returns the filtered coordinates.\n        :return: The key string identify this marker\n        \"\"\"\n        if kw:\n            _logger.warning(\n                'addMarker deprecated extra parameters: %s', str(kw))\n\n        if x is None:\n            xmin, xmax = self.getGraphXLimits()\n            x = 0.5 * (xmax + xmin)\n\n        if y is None:\n            ymin, ymax = self.getGraphYLimits()\n            y = 0.5 * (ymax + ymin)\n\n        return self._addMarker(x=x, y=y, legend=legend,\n                               text=text, color=color,\n                               selectable=selectable, draggable=draggable,\n                               symbol=symbol, constraint=constraint)\n\n    def _addMarker(self, x, y, legend,\n                   text, color,\n                   selectable, draggable,\n                   symbol, constraint):\n        \"\"\"Common method for adding point, vline and hline marker.\n\n        See :meth:`addMarker` for argument documentation.\n        \"\"\"\n        if legend is None:\n            i = 0\n            while legend in self._markers:\n                legend = \"Unnamed Marker %d\" % i\n                i += 1\n\n        if color is None:\n            color = self.colorDict['black']\n        elif color in self.colorDict:\n            color = self.colorDict[color]\n\n        if constraint is not None and not callable(constraint):\n            # Then it must be a string\n            if hasattr(constraint, 'lower'):\n                if constraint.lower().startswith('h'):\n                    constraint = lambda xData, yData: (xData, y)\n                elif constraint.lower().startswith('v'):\n                    constraint = lambda xData, yData: (x, yData)\n                else:\n                    raise ValueError(\n                        \"Unsupported constraint name: %s\" % constraint)\n            else:\n                raise ValueError(\"Unsupported constraint\")\n\n        # Apply constraint to provided position\n        if draggable and constraint is not None:\n            x, y = constraint(x, y)\n\n        if legend in self._markers:\n            self.remove(legend, kind='marker')\n\n        handle = self._backend.addMarker(\n            x=x, y=y, legend=legend, text=text, color=color,\n            selectable=selectable, draggable=draggable,\n            symbol=symbol, constraint=constraint,\n            overlay=draggable)\n\n        self._markers[legend] = {'handle': handle, 'params': {\n            'x': x, 'y': y,\n            'text': text, 'color': color,\n            'selectable': selectable, 'draggable': draggable,\n            'symbol': symbol, 'constraint': constraint}\n        }\n\n        self._setDirtyPlot(overlayOnly=draggable)\n\n        self.notify(\n            'contentChanged', action='add', kind='marker', legend=legend)\n\n        return legend\n\n    # Hide\n\n    def isCurveHidden(self, legend):\n        \"\"\"Returns True if the curve associated to legend is hidden, else False\n\n        :param str legend: The legend key identifying the curve\n        :return: True if the associated curve is hidden, False otherwise\n        \"\"\"\n        return legend in self._hiddenCurves\n\n    def hideCurve(self, legend, flag=True, replot=None):\n        \"\"\"Show/Hide the curve associated to legend.\n\n        Even when hidden, the curve is kept in the list of curves.\n\n        :param str legend: The legend associated to the curve to be hidden\n        :param bool flag: True (default) to hide the curve, False to show it\n        \"\"\"\n        if replot is not None:\n            _logger.warning('hideCurve deprecated replot parameter')\n\n        if legend not in self._curves:\n            _logger.warning('Curve not in plot: %s', legend)\n            return\n\n        if flag:\n            handle = self._curves[legend]['handle']\n            if handle is not None:\n                self._backend.remove(handle)\n                self._curves[legend]['handle'] = None\n\n            self._hiddenCurves.add(legend)\n        else:\n            self._hiddenCurves.discard(legend)\n            curve = self._curves[legend]\n            self.addCurve(curve['x'], curve['y'], legend, resetzoom=False,\n                          **curve['params'])\n\n        self._setDirtyPlot()\n\n    # Remove\n\n    ITEM_KINDS = 'curve', 'image', 'item', 'marker'\n\n    def remove(self, legend=None, kind=ITEM_KINDS):\n        \"\"\"Remove one or all element(s) of the given legend and kind.\n\n        Examples:\n\n        - remove() clears the plot\n        - remove(kind='curve') removes all curves from the plot\n        - remove('myCurve', kind='curve') removes the curve with\n          legend 'myCurve' from the plot.\n        - remove('myImage, kind='image') removes the image with\n          legend 'myImage' from the plot.\n        - remove('myImage') removes elements (for instance curve, image,\n          item and marker) with legend 'myImage'.\n\n        :param str legend: The legend associated to the element to remove,\n                           or None to remove\n        :param kind: The kind of elements to remove from the plot.\n                     In: 'all', 'curve', 'image', 'item', 'marker'.\n                     By default, it removes all kind of elements.\n        :type kind: str or tuple of str to specify multiple kinds.\n        \"\"\"\n        if kind is 'all':  # Replace all by tuple of all kinds\n            kind = self.ITEM_KINDS\n\n        if kind in self.ITEM_KINDS:  # Kind is a str, make it a tuple\n            kind = (kind,)\n\n        if legend is None:  # This is a clear\n            # Clear each given kind\n            for aKind in kind:\n                if aKind == 'curve':\n                    # Copy as _curves gets changed\n                    for legend in list(self._curves):\n                        self.remove(legend, kind='curve')\n                    self._curves = OrderedDict()\n                    self._hiddenCurves = set()\n                    self._colorIndex = 0\n                    self._styleIndex = 0\n\n                elif aKind == 'image':\n                    # Copy as _images gets changed\n                    for legend in list(self._images):\n                        self.remove(legend, kind='image')\n                    self._images = OrderedDict()\n\n                elif aKind == 'item':\n                    # Copy as _items gets changed\n                    for legend in list(self._items):\n                        self.remove(legend, kind='item')\n                    self._items = OrderedDict()\n\n                elif aKind == 'marker':\n                    # Copy as _markers gets changed\n                    for legend in list(self._markers):\n                        self.remove(legend, kind='marker')\n                    self._markers = OrderedDict()\n                else:\n                    _logger.warning('remove: Unhandled item kind %s', aKind)\n\n        else:  # This is removing a single element\n            # Remove each given kind\n            for aKind in kind:\n                if aKind == 'curve':\n                    self._hiddenCurves.discard(legend)\n\n                    if legend in self._curves:\n                        handle = self._curves[legend]['handle']\n                        if handle is not None:\n                            self._backend.remove(handle)\n                            self._setDirtyPlot()\n                        del self._curves[legend]\n\n                        if not self._curves:\n                            self._colorIndex = 0\n                            self._styleIndex = 0\n\n                        self.notify('contentChanged', action='remove',\n                                    kind='curve', legend=legend)\n\n                elif aKind == 'image':\n                    if legend in self._images:\n                         handle = self._images[legend]['handle']\n                         if handle is not None:\n                             self._backend.remove(handle)\n                             self._setDirtyPlot()\n                         del self._images[legend]\n\n                         self.notify('contentChanged', action='remove',\n                                     kind='image', legend=legend)\n\n                elif aKind == 'item':\n                    item = self._items.pop(legend, None)\n                    if item is not None:\n                        if item['handle'] is not None:\n                            self._backend.remove(item['handle'])\n                            self._setDirtyPlot(overlayOnly=item['overlay'])\n\n                        self.notify('contentChanged', action='remove',\n                                    kind='item', legend=legend)\n\n                elif aKind == 'marker':\n                    marker = self._markers.pop(legend, None)\n                    if marker is not None:\n                        if marker['handle'] is not None:\n                            self._backend.remove(marker['handle'])\n                            self._setDirtyPlot(\n                                overlayOnly=marker['params']['draggable'])\n\n                        self.notify('contentChanged', action='remove',\n                                    kind='marker', legend=legend)\n\n                else:\n                    _logger.warning('remove: Unhandled item kind %s', aKind)\n\n    def removeCurve(self, legend):\n        \"\"\"Remove the curve associated to legend from the graph.\n\n        :param str legend: The legend associated to the curve to be deleted\n        \"\"\"\n        if legend is None:\n            return\n        self.remove(legend, kind='curve')\n\n    def removeImage(self, legend):\n        \"\"\"Remove the image associated to legend from the graph.\n\n        :param str legend: The legend associated to the image to be deleted\n        \"\"\"\n        if legend is None:\n            return\n        self.remove(legend, kind='image')\n\n    def removeItem(self, legend):\n        \"\"\"Remove the item associated to legend from the graph.\n\n        :param str legend: The legend associated to the item to be deleted\n        \"\"\"\n        if legend is None:\n            return\n        self.remove(legend, kind='item')\n\n    def removeMarker(self, legend):\n        \"\"\"Remove the marker associated to legend from the graph.\n\n        :param str legend: The legend associated to the marker to be deleted\n        \"\"\"\n        if legend is None:\n            return\n        self.remove(legend, kind='marker')\n\n    # Clear\n\n    def clear(self):\n        \"\"\"Remove everything from the plot.\"\"\"\n        self.remove()\n\n    def clearCurves(self):\n        \"\"\"Remove all the curves from the plot.\"\"\"\n        self.remove(kind='curve')\n\n    def clearImages(self):\n        \"\"\"Remove all the images from the plot.\"\"\"\n        self.remove(kind='image')\n\n    def clearItems(self):\n        \"\"\"Remove all the items from the plot. \"\"\"\n        self.remove(kind='item')\n\n    def clearMarkers(self):\n        \"\"\"Remove all the markers from the plot.\"\"\"\n        self.remove(kind='marker')\n\n    # Interaction\n\n    def getGraphCursor(self):\n        \"\"\"Returns the state of the crosshair cursor.\n\n        See :meth:`setGraphCursor`.\n\n        :return: None if the crosshair cursor is not active,\n                 else a tuple (color, linewidth, linestyle).\n        \"\"\"\n        return self._cursorConfiguration\n\n    def setGraphCursor(self, flag=False, color='black',\n                       linewidth=1, linestyle='-'):\n        \"\"\"Toggle the display of a crosshair cursor and set its attributes.\n\n        :param bool flag: Toggle the display of a crosshair cursor.\n                          The crosshair cursor is hidden by default.\n        :param color: The color to use for the crosshair.\n        :type color: A string (either a predefined color name in Colors.py\n                    or \"#RRGGBB\")) or a 4 columns unsigned byte array\n                    (Default: black).\n        :param int linewidth: The width of the lines of the crosshair\n                    (Default: 1).\n        :param str linestyle: Type of line::\n\n                - ' ' no line\n                - '-' solid line (the default)\n                - '--' dashed line\n                - '-.' dash-dot line\n                - ':' dotted line\n        \"\"\"\n        if flag:\n            self._cursorConfiguration = color, linewidth, linestyle\n        else:\n            self._cursorConfiguration = None\n\n        self._backend.setGraphCursor(flag=flag, color=color,\n                                     linewidth=linewidth, linestyle=linestyle)\n        self._setDirtyPlot()\n        self.notify('setGraphCursor',\n                    state=self._cursorConfiguration is not None)\n\n    def pan(self, direction, factor=0.1):\n        \"\"\"Pan the graph in the given direction by the given factor.\n\n        Warning: Pan of right Y axis not implemented!\n\n        :param str direction: One of 'up', 'down', 'left', 'right'.\n        :param float factor: Proportion of the range used to pan the graph.\n                             Must be strictly positive.\n        \"\"\"\n        assert direction in ('up', 'down', 'left', 'right')\n        assert factor > 0.\n\n        if direction in ('left', 'right'):\n            xFactor = factor if direction == 'right' else - factor\n            xMin, xMax = self.getGraphXLimits()\n\n            xMin, xMax = _utils.applyPan(xMin, xMax, xFactor,\n                                         self.isXAxisLogarithmic())\n            self.setGraphXLimits(xMin, xMax)\n\n        else:  # direction in ('up', 'down')\n            sign = -1. if self.isYAxisInverted() else 1.\n            yFactor = sign * (factor if direction == 'up' else -factor)\n            yMin, yMax = self.getGraphYLimits()\n            yIsLog = self.isYAxisLogarithmic()\n\n            yMin, yMax = _utils.applyPan(yMin, yMax, yFactor, yIsLog)\n            self.setGraphYLimits(yMin, yMax, axis='left')\n\n            y2Min, y2Max = self.getGraphYLimits(axis='right')\n\n            y2Min, y2Max = _utils.applyPan(y2Min, y2Max, yFactor, yIsLog)\n            self.setGraphYLimits(y2Min, y2Max, axis='right')\n\n    # Active Curve/Image\n\n    def isActiveCurveHandling(self):\n        \"\"\"Returns True if active curve selection is enabled.\"\"\"\n        return self._activeCurveHandling\n\n    def setActiveCurveHandling(self, flag=True):\n        \"\"\"Enable/Disable active curve selection.\n\n        :param bool flag: True (the default) to enable active curve selection.\n        \"\"\"\n        if not flag:\n            self.setActiveCurve(None)  # Reset active curve\n\n        self._activeCurveHandling = bool(flag)\n\n    def getActiveCurveColor(self):\n        \"\"\"Get the color used to display the currently active curve.\n\n        See :meth:`setActiveCurveColor`.\n        \"\"\"\n        return self._activeCurveColor\n\n    def setActiveCurveColor(self, color=\"#000000\"):\n        \"\"\"Set the color to use to display the currently active curve.\n\n        :param str color: Color of the active curve,\n                          e.g., 'blue', 'b', '#FF0000' (Default: 'black')\n        \"\"\"\n        if color is None:\n            color = \"black\"\n        if color in self.colorDict:\n            color = self.colorDict[color]\n        self._activeCurveColor = color\n\n    def getActiveCurve(self, just_legend=False):\n        \"\"\"Return the currently active curve.\n\n        It returns None in case of not having an active curve.\n        Default output has the form: [x, y, legend, info, params]\n        where params is a dictionary containing curve parameters.\n\n        Warning: Returned values MUST not be modified.\n        Make a copy if you need to modify them.\n\n        :param bool just_legend: True to get the legend of the curve,\n                                 False (the default) to get the curve data\n                                 and info.\n        :return: legend of the active curve or [x, y, legend, info, params]\n        :rtype: str or list\n        \"\"\"\n        if not self.isActiveCurveHandling():\n            return None\n\n        if self._activeCurve not in self._curves:\n            self._activeCurve = None\n\n        if self._activeCurve is None:\n            return None\n\n        if just_legend:\n            return self._activeCurve\n        else:\n            curve = self._curves[self._activeCurve]\n            return (curve['x'], curve['y'], self._activeCurve,\n                    curve['params']['info'] or {}, curve['params'])\n\n    def setActiveCurve(self, legend, replot=None):\n        \"\"\"Make the curve associated to legend the active curve.\n\n        :param str legend: The legend associated to the curve\n                           or None to have no active curve.\n        \"\"\"\n        if replot is not None:\n            _logger.warning('setActiveCurve deprecated replot parameter')\n\n        if not self.isActiveCurveHandling():\n            return\n\n        xLabel = self._xLabel\n        yLabel = self._yLabel\n\n        oldActiveCurveLegend = self.getActiveCurve(just_legend=True)\n        if oldActiveCurveLegend:  # Reset previous active curve\n            handle = self._curves[oldActiveCurveLegend]['handle']\n            if handle is not None:\n                self._backend.setActiveCurve(handle, False)\n\n        if legend is None:\n            self._activeCurve = None\n        else:\n            legend = str(legend)\n            if legend not in self._curves:\n                _logger.warning(\"This curve does not exist: %s\", legend)\n                self._activeCurve = None\n            else:\n                self._activeCurve = legend\n\n                handle = self._curves[self._activeCurve]['handle']\n                if handle is not None:\n                    self._backend.setActiveCurve(handle, True,\n                                                 self.getActiveCurveColor())\n\n                xLabel = self._curves[self._activeCurve]['params']['xlabel']\n                yLabel = self._curves[self._activeCurve]['params']['ylabel']\n                # TODO y2 axis case\n\n        # Store current labels and update plot\n        self._currentXLabel = xLabel\n        self._backend.setGraphXLabel(xLabel)\n        self._currentYLabel = yLabel\n        self._backend.setGraphYLabel(yLabel, axis='left')  # TODO y2 axis\n\n        self._setDirtyPlot()\n\n        if oldActiveCurveLegend != self._activeCurve:\n            self.notify('activeCurveChanged',\n                        previous=oldActiveCurveLegend,\n                        legend=self._activeCurve)\n\n        return self._activeCurve\n\n    def getActiveImage(self, just_legend=False):\n        \"\"\"Returns the currently active image.\n\n        It returns None in case of not having an active image.\n\n        Default output has the form: [data, legend, info, pixmap, params]\n        where params is a dictionnary containing image parameters.\n\n        Warning: Returned values MUST not be modified.\n        Make a copy if you need to modify them.\n\n        :param bool just_legend: True to get the legend of the image,\n                                 False (the default) to get the image data\n                                 and info.\n        :return: legend of active image or [data, legend, info, pixmap, params]\n        :rtype: str or list\n        \"\"\"\n        if self._activeImage not in self._images:\n            self._activeImage = None\n\n        if just_legend:\n            return self._activeImage\n\n        if self._activeImage is None:\n            return None\n        else:\n            image = self._images[self._activeImage]\n            return (image['data'], self._activeImage,\n                    image['params']['info'] or {}, image['pixmap'],\n                    image['params'])\n\n    def setActiveImage(self, legend, replot=None):\n        \"\"\"Make the image associated to legend the active image.\n\n        :param str legend: The legend associated to the image\n                           or None to have no active image.\n        \"\"\"\n        if replot is not None:\n            _logger.warning('setActiveImage deprecated replot parameter')\n\n        if legend is None:\n            self._activeImage = None\n        else:\n            legend = str(legend)\n            if legend not in self._images:\n                _logger.warning(\n                    \"setActiveImage: This image does not exist: %s\", legend)\n                self._activeImage = None\n            else:\n                self._activeImage = legend\n\n        return self._activeImage\n\n    # Getters\n\n    def getAllCurves(self, just_legend=False, withhidden=False):\n        \"\"\"Returns all curves legend or info and data.\n\n        It returns an empty list in case of not having any curve.\n\n        If just_legend is False, it returns a list of the form:\n            [[xvalues0, yvalues0, legend0, info0, params0],\n             [xvalues1, yvalues1, legend1, info1, params1],\n             [...],\n             [xvaluesn, yvaluesn, legendn, infon, paramsn]]\n        If just_legend is True, it returns a list of the form:\n            [legend0, legend1, ..., legendn]\n\n        Warning: Returned values MUST not be modified.\n        Make a copy if you need to modify them.\n\n        :param bool just_legend: True to get the legend of the curves,\n                                 False (the default) to get the curves' data\n                                 and info.\n        :param bool withhidden: False (default) to skip hidden curves.\n        :return: list of legends or list of [x, y, legend, info, params]\n        :rtype: list of str or list of list\n        \"\"\"\n        output = []\n        for key in self._curves:\n            if not withhidden and self.isCurveHidden(key):\n                continue\n            if just_legend:\n                output.append(key)\n            else:\n                curve = self._curves[key]\n                output.append((curve['x'], curve['y'], key,\n                               curve['params']['info'] or {}, curve['params']))\n        return output\n\n    def getCurve(self, legend):\n        \"\"\"Return the data and info of a specific curve.\n\n        It returns None in case of not having the curve.\n\n        Warning: Returned values MUST not be modified.\n        Make a copy if you need to modify them.\n\n        :param str legend: legend associated to the curve\n        :return: None or list [x, y, legend, parameters]\n        \"\"\"\n        if legend in self._curves:\n            curve = self._curves[legend]\n            return (curve['x'], curve['y'], legend,\n                    curve['params']['info'] or {}, curve['params'])\n        else:\n            return None\n\n    def getImage(self, legend):\n        \"\"\"Return the data and info of a specific image.\n\n        It returns None in case of not having an active curve.\n\n        Warning: Returned values MUST not be modified.\n        Make a copy if you need to modify them.\n\n        :param str legend: legend associated to the curve\n        :return: None or list [image, legend, info, pixmap, params]\n        \"\"\"\n        if legend in self._images:\n            image = self._images[legend]\n            return (image['data'], legend, image['params']['info'] or {},\n                    image['pixmap'], image['params'])\n        else:\n            return None\n\n    # Limits\n\n    def _notifyLimitsChanged(self):\n        \"\"\"Send an event when plot area limits are changed.\"\"\"\n        xRange = self.getGraphXLimits()\n        yRange = self.getGraphYLimits(axis='left')\n        y2Range = self.getGraphYLimits(axis='right')\n        event = PlotEvents.prepareLimitsChangedSignal(\n            id(self.getWidgetHandle()), xRange, yRange, y2Range)\n        self.notify(**event)\n\n    def getGraphXLimits(self):\n        \"\"\"Get the graph X (bottom) limits.\n\n        :return: Minimum and maximum values of the X axis\n        \"\"\"\n        return self._backend.getGraphXLimits()\n\n    def setGraphXLimits(self, xmin, xmax, replot=None):\n        \"\"\"Set the graph X (bottom) limits.\n\n        :param float xmin: minimum bottom axis value\n        :param float xmax: maximum bottom axis value\n        \"\"\"\n        if replot is not None:\n            _logger.warning('setGraphXLimits deprecated replot parameter')\n\n        self._backend.setGraphXLimits(xmin, xmax)\n        self._setDirtyPlot()\n\n        self._notifyLimitsChanged()\n\n    def getGraphYLimits(self, axis='left'):\n        \"\"\"Get the graph Y limits.\n\n        :param str axis: The axis for which to get the limits:\n                         Either 'left' or 'right'\n        :return: Minimum and maximum values of the X axis\n        \"\"\"\n        assert axis in ('left', 'right')\n        return self._backend.getGraphYLimits(axis)\n\n    def setGraphYLimits(self, ymin, ymax, axis='left', replot=None):\n        \"\"\"Set the graph Y limits.\n\n        :param float xmin: minimum bottom axis value\n        :param float xmax: maximum bottom axis value\n        :param str axis: The axis for which to get the limits:\n                         Either 'left' or 'right'\n        \"\"\"\n        if replot is not None:\n            _logger.warning('setGraphYLimits deprecated replot parameter')\n\n        assert axis in ('left', 'right')\n        self._backend.setGraphYLimits(ymin, ymax, axis)\n        self._setDirtyPlot()\n\n        self._notifyLimitsChanged()\n\n    def setLimits(self, xmin, xmax, ymin, ymax, y2min=None, y2max=None):\n        \"\"\"Set the limits of the X and Y axes at once.\n\n        If y2min or y2max is None, the right Y axis limits are not updated.\n\n        :param float xmin: minimum bottom axis value\n        :param float xmax: maximum bottom axis value\n        :param float ymin: minimum left axis value\n        :param float ymax: maximum left axis value\n        :param float y2min: minimum right axis value or None (the default)\n        :param float y2max: maximum right axis value or None (the default)\n        \"\"\"\n        if xmax < xmin:\n            xmin, xmax = xmax, xmin\n        if ymax < ymin:\n            ymin, ymax = ymax, ymin\n\n        if y2min is None or y2max is None:\n            # if one limit is None, both are ignored\n            y2min, y2max = None, None\n        elif y2max < y2min:\n                y2min, y2max = y2max, y2min\n\n        self._backend.setLimits(xmin, xmax, ymin, ymax, y2min, y2max)\n        self._setDirtyPlot()\n        self._notifyLimitsChanged()\n\n    # Title and labels\n\n    def getGraphTitle(self):\n        \"\"\"Return the plot main title as a str.\"\"\"\n        return self._graphTitle\n\n    def setGraphTitle(self, title=\"\"):\n        \"\"\"Set the plot main title.\n\n        :param str title: Main title of the plot (default: '')\n        \"\"\"\n        self._graphTitle = str(title)\n        self._backend.setGraphTitle(title)\n        self._setDirtyPlot()\n\n    def getGraphXLabel(self):\n        \"\"\"Return the current X axis label as a str.\"\"\"\n        return self._currentXLabel\n\n    def setGraphXLabel(self, label=\"X\"):\n        \"\"\"Set the plot X axis label.\n\n        The provided label can be temporarily replaced by the X label of the\n        active curve if any.\n\n        :param str label: The X axis label (default: 'X')\n        \"\"\"\n        self._xLabel = label\n        # Current label can differ from input one with active curve handling\n        self._currentXLabel = label\n        self._backend.setGraphXLabel(label)\n        self._setDirtyPlot()\n\n    def getGraphYLabel(self):\n        \"\"\"Return the current Y axis label as a str.\"\"\"\n        return self._currentYLabel\n\n    def setGraphYLabel(self, label=\"Y\"):\n        \"\"\"Set the plot Y axis label.\n\n        The provided label can be temporarily replaced by the Y label of the\n        active curve if any.\n\n        :param str label: The Y axis label (default: 'Y')\n        \"\"\"\n        self._yLabel = label\n        # Current label can differ from input one with active curve handling\n        self._currentYLabel = label\n        self._backend.setGraphYLabel(label, axis='left')\n        self._setDirtyPlot()\n\n    # Axes\n\n    def setYAxisInverted(self, flag=True):\n        \"\"\"Set the Y axis orientation.\n\n        :param bool flag: True for Y axis going from top to bottom,\n                          False for Y axis going from bottom to top\n        \"\"\"\n        flag = bool(flag)\n        self._backend.setYAxisInverted(flag)\n        self._setDirtyPlot()\n        self.notify('setYAxisInverted', state=flag)\n\n    def isYAxisInverted(self):\n        \"\"\"Return True if Y axis goes from top to bottom, False otherwise.\"\"\"\n        return self._backend.isYAxisInverted()\n\n    def isXAxisLogarithmic(self):\n        \"\"\"Return True if X axis scale is logarithmic, False if linear.\"\"\"\n        return self._logX\n\n    def setXAxisLogarithmic(self, flag):\n        \"\"\"Set the bottom X axis scale (either linear or logarithmic).\n\n        :param bool flag: True to use a logarithmic scale, False for linear.\n        \"\"\"\n        if bool(flag) == self._logX:\n            return\n        self._logX = bool(flag)\n\n        if self._logX:  # Switch to log scale\n            for image in self._images.values():\n                if image['handle'] is not None:\n                    self._backend.remove(image['handle'])\n                    image['handle'] = None\n\n            for curve in self._curves.values():\n                handle = curve['handle']\n                if handle is not None:\n                    self._backend.remove(handle)\n                    curve['handle'] = None\n\n            # matplotlib 1.5 crashes if the log set is made before\n            # the call to self._update()\n            # TODO: Decide what is better for other backends\n            if (hasattr(self._backend, \"matplotlibVersion\") and\n                    self._backend.matplotlibVersion >= \"1.5\"):\n                self._update()\n                self._backend.setXAxisLogarithmic(self._logX)\n            else:\n                self._backend.setXAxisLogarithmic(self._logX)\n                self._update()\n        else:\n                self._backend.setXAxisLogarithmic(self._logX)\n                self._update()\n\n        self._setDirtyPlot()\n        self.resetZoom()\n        self.notify('setXAxisLogarithmic', state=self._logX)\n\n    def isYAxisLogarithmic(self):\n        \"\"\"Return True if Y axis scale is logarithmic, False if linear.\"\"\"\n        return self._logY\n\n    def setYAxisLogarithmic(self, flag):\n        \"\"\"Set the Y axes scale (either linear or logarithmic).\n\n        :param bool flag: True to use a logarithmic scale, False for linear.\n        \"\"\"\n        if bool(flag) == self._logY:\n            return\n        self._logY = bool(flag)\n\n        if self._logY:  # Switch to log scale\n            for image in self._images.values():\n                if image['handle'] is not None:\n                    self._backend.remove(image['handle'])\n                    image['handle'] = None\n\n            for curve in self._curves.values():\n                handle = curve['handle']\n                if handle is not None:\n                    self._backend.remove(handle)\n                    curve['handle'] = None\n\n            # matplotlib 1.5 crashes if the log set is made before\n            # the call to self._update()\n            # TODO: Decide what is better for other backends\n            if (hasattr(self._backend, \"matplotlibVersion\") and\n                    self._backend.matplotlibVersion >= \"1.5\"):\n                self._update()\n                self._backend.setYAxisLogarithmic(self._logY)\n            else:\n                self._backend.setYAxisLogarithmic(self._logY)\n                self._update()\n        else:\n                self._backend.setYAxisLogarithmic(self._logY)\n                self._update()\n\n        self._setDirtyPlot()\n        self.resetZoom()\n        self.notify('setYAxisLogarithmic', state=self._logY)\n\n    def isXAxisAutoScale(self):\n        \"\"\"Return True if X axis is automatically adjusting its limits.\"\"\"\n        return self._xAutoScale\n\n    def setXAxisAutoScale(self, flag=True):\n        \"\"\"Set the X axis limits adjusting behavior of :meth:`resetZoom`.\n\n        :param bool flag: True to resize limits automatically,\n                          False to disable it.\n        \"\"\"\n        self._xAutoScale = bool(flag)\n        self.notify('setXAxisAutoScale', state=self._xAutoScale)\n\n    def isYAxisAutoScale(self):\n        \"\"\"Return True if Y axes are automatically adjusting its limits.\"\"\"\n        return self._yAutoScale\n\n    def setYAxisAutoScale(self, flag=True):\n        \"\"\"Set the Y axis limits adjusting behavior of :meth:`resetZoom`.\n\n        :param bool flag: True to resize limits automatically,\n                          False to disable it.\n        \"\"\"\n        self._yAutoScale = bool(flag)\n        self.notify('setYAxisAutoScale', state=self._yAutoScale)\n\n    def isKeepDataAspectRatio(self):\n        \"\"\"Returns whether the plot is keeping data aspect ratio or not.\"\"\"\n        return self._backend.isKeepDataAspectRatio()\n\n    def setKeepDataAspectRatio(self, flag=True):\n        \"\"\"Set whether the plot keeps data aspect ratio or not.\n\n        :param bool flag: True to respect data aspect ratio\n        \"\"\"\n        flag = bool(flag)\n        self._backend.setKeepDataAspectRatio(flag=flag)\n        self._setDirtyPlot()\n        self.resetZoom()\n        self.notify('setKeepDataAspectRatio', state=flag)\n\n    def getGraphGrid(self):\n        \"\"\"Return the current grid mode, either None, 'major' or 'both'.\n\n        See :meth:`setGraphGrid`.\n        \"\"\"\n        return self._grid\n\n    def setGraphGrid(self, which=True):\n        \"\"\"Set the type of grid to display.\n\n        :param which: None or False to disable the grid,\n                      'major' or True for grid on major ticks (the default),\n                      'both' for grid on both major and minor ticks.\n        :type which: str of bool\n        \"\"\"\n        assert which in (None, True, False, 'both', 'major')\n        if not which:\n            which = None\n        elif which is True:\n            which = 'major'\n        self._grid = which\n        self._backend.setGraphGrid(which)\n        self._setDirtyPlot()\n        self.notify('setGraphGrid', which=str(which))\n\n    # Defaults\n\n    def isDefaultPlotPoints(self):\n        \"\"\"Return True if default Curve symbol is 'o', False for no symbol.\"\"\"\n        return self._defaultPlotPoints == 'o'\n\n    def setDefaultPlotPoints(self, flag):\n        \"\"\"Set the default symbol of all curves.\n\n        When called, this reset the symbol of all existing curves.\n\n        :param bool flag: True to use 'o' as the default curve symbol,\n                          False to use no symbol.\n        \"\"\"\n        self._defaultPlotPoints = 'o' if flag else ''\n\n        # Reset symbol of all curves\n        for curve in self._curves.values():\n            curve['params']['symbol'] = self._defaultPlotPoints\n\n        if self._curves:\n            self._update()\n            self._setDirtyPlot()\n\n    def isDefaultPlotLines(self):\n        \"\"\"Return True for line as default line style, False for no line.\"\"\"\n        return self._plotLines\n\n    def setDefaultPlotLines(self, flag):\n        \"\"\"Toggle the use of lines as the default curve line style.\n\n        :param bool flag: True to use a line as the default line style,\n                          False to use no line as the default line style.\n        \"\"\"\n        self._plotLines = bool(flag)\n\n        # Reset linestyle of all curves\n        for curve in self._curves.values():\n            curve['params']['linestyle'] = '-' if self._plotLines else ' '\n\n        if self._curves:\n            self._update()\n            self._setDirtyPlot()\n\n    def getDefaultColormap(self):\n        \"\"\"Return the default colormap used by :meth:`addImage` as a dict.\n\n        See :mod:`Plot` for the documentation of the colormap dict.\n        \"\"\"\n        return self._defaultColormap.copy()\n\n    def setDefaultColormap(self, colormap=None):\n        \"\"\"Set the default colormap used by :meth:`addImage`.\n\n        :param dict colormap: The description of the default colormap, or\n                            None to set the colormap to a linear autoscale\n                            gray colormap.\n                            See :mod:`Plot` for the documentation\n                            of the colormap dict.\n        \"\"\"\n        if colormap is None:\n            colormap = {'name': 'gray', 'normalization': 'linear',\n                        'autoscale': True, 'vmin': 0.0, 'vmax': 1.0,\n                        'colors': 256}\n        self._defaultColormap = colormap.copy()\n\n    def getSupportedColormaps(self):\n        \"\"\"Get the supported colormap names as a tuple of str.\n\n        The list should at least contain and start by:\n        ('gray', 'reversed gray', 'temperature', 'red', 'green', 'blue')\n        \"\"\"\n        return self._backend.getSupportedColormaps()\n\n    def _getColorAndStyle(self):\n        color = self.colorList[self._colorIndex]\n        style = self._styleList[self._styleIndex]\n\n        # Loop over color and then styles\n        self._colorIndex += 1\n        if self._colorIndex >= len(self.colorList):\n            self._colorIndex = 0\n            self._styleIndex = (self._styleIndex + 1) % len(self._styleList)\n\n        # If color is the one of active curve, take the next one\n        if color == self.getActiveCurveColor():\n            color, style = self._getColorAndStyle()\n\n        if not self._plotLines:\n            style = ' '\n\n        return color, style\n\n    # Misc.\n\n    def getWidgetHandle(self):\n        \"\"\"Return the widget the plot is displayed in.\n\n        This widget is owned by the backend.\n        \"\"\"\n        return self._backend.getWidgetHandle()\n\n    def notify(self, event, **kwargs):\n        \"\"\"Send an event to the listeners.\n\n        Event are passed to the registered callback as a dict with an 'event'\n        key for backward compatibility with PyMca.\n\n        :param str event: The type of event\n        :param kwargs: The information of the event.\n        \"\"\"\n        eventDict = kwargs.copy()\n        eventDict['event'] = event\n        self._callback(eventDict)\n\n    def setCallback(self, callbackFunction=None):\n        \"\"\"Attach a listener to the backend.\n\n        Limitation: Only one listener at a time.\n\n        :param callbackFunction: function accepting a dictionnary as input\n                                 to handle the graph events\n                                 If None (default), use a default listener.\n        \"\"\"\n        # TODO allow multiple listeners, keep a weakref on it\n        # allow register listener by event type\n        if callbackFunction is None:\n            callbackFunction = self.graphCallback\n        self._callback = callbackFunction\n\n    def graphCallback(self, ddict=None):\n        \"\"\"This callback is going to receive all the events from the plot.\n\n        Those events will consist on a dictionnary and among the dictionnary\n        keys the key 'event' is mandatory to describe the type of event.\n        This default implementation only handles setting the active curve.\n        \"\"\"\n\n        if ddict is None:\n            ddict = {}\n        _logger.debug(\"Received dict keys = %s\", str(ddict.keys()))\n        _logger.debug(str(ddict))\n        if ddict['event'] in [\"legendClicked\", \"curveClicked\"]:\n            if ddict['button'] == \"left\":\n                self.setActiveCurve(ddict['label'])\n\n    def saveGraph(self, filename, fileFormat=None, dpi=None, **kw):\n        \"\"\"Save a snapshot of the plot.\n\n        Supported file formats: \"png\", \"svg\", \"pdf\", \"ps\", \"eps\",\n        \"tif\", \"tiff\", \"jpeg\", \"jpg\".\n\n        :param filename: Destination\n        :type filename: str, StringIO or BytesIO\n        :param str fileFormat:  String specifying the format\n        :return: False if cannot save the plot, True otherwise\n        \"\"\"\n        if kw:\n            _logger.warning('Extra parameters ignored: %s', str(kw))\n\n        if fileFormat is None:\n            if not hasattr(filename, 'lower'):\n                _logger.warning(\n                    'saveGraph cancelled, cannot define file format.')\n                return False\n            else:\n                fileFormat = (filename.split(\".\")[-1]).lower()\n\n        supportedFormats = (\"png\", \"svg\", \"pdf\", \"ps\", \"eps\",\n                            \"tif\", \"tiff\", \"jpeg\", \"jpg\")\n\n        if fileFormat not in supportedFormats:\n            _logger.warning('Unsupported format %s', fileFormat)\n            return False\n        else:\n            self._backend.saveGraph(filename,\n                                    fileFormat=fileFormat,\n                                    dpi=dpi)\n            return True\n\n    def getDataMargins(self):\n        \"\"\"Get the default data margin ratios, see :meth:`setDataMargins`.\n\n        :return: The margin ratios for each side (xMin, xMax, yMin, yMax).\n        :rtype: A 4-tuple of floats.\n        \"\"\"\n        return self._defaultDataMargins\n\n    def setDataMargins(self, xMinMargin=0., xMaxMargin=0.,\n                       yMinMargin=0., yMaxMargin=0.):\n        \"\"\"Set the default data margins to use in :meth:`resetZoom`.\n\n        Set the default ratios of margins (as floats) to add around the data\n        inside the plot area for each side.\n        \"\"\"\n        self._defaultDataMargins = (xMinMargin, xMaxMargin,\n                                    yMinMargin, yMaxMargin)\n\n    def getAutoReplot(self):\n        \"\"\"Return True if replot is automatically handled, False otherwise.\n\n        See :meth`setAutoReplot`.\n        \"\"\"\n        return self._autoreplot\n\n    def setAutoReplot(self, autoreplot=True):\n        \"\"\"Set automatic replot mode.\n\n        When enabled, the plot is redrawn automatically when changed.\n        When disabled, the plot is not redrawn when its content change.\n        Instead, it :meth:`replot` must be called.\n\n        :param bool autoreplot: True to enable it (default),\n                                False to disable it.\n        \"\"\"\n        self._autoreplot = bool(autoreplot)\n\n        # If the plot is dirty before enabling autoreplot,\n        # then _backend.postRedisplay will never be called from _setDirtyPlot\n        if self._autoreplot and self._getDirtyPlot():\n            self._backend.postRedisplay()\n\n    def replot(self):\n        \"\"\"Redraw the plot immediately.\"\"\"\n        self._backend.replot()\n        self._dirty = False  # reset dirty flag\n\n    def resetZoom(self, dataMargins=None):\n        \"\"\"Reset the plot limits to the bounds of the data and redraw the plot.\n\n        It automatically scale limits of axes that are in autoscale mode\n        (See :meth:`setXAxisAutoScale`, :meth:`setYAxisAutoScale`).\n        It keeps current limits on axes that are not in autoscale mode.\n\n        Extra margins can be added around the data inside the plot area.\n        Margins are given as one ratio of the data range per limit of the\n        data (xMin, xMax, yMin and yMax limits).\n        For log scale, extra margins are applied in log10 of the data.\n\n        :param dataMargins: Ratios of margins to add around the data inside\n                            the plot area for each side (Default: no margins).\n        :type dataMargins: A 4-tuple of float as (xMin, xMax, yMin, yMax).\n        \"\"\"\n        if dataMargins is None:\n            dataMargins = self._defaultDataMargins\n\n        xlim = self.getGraphXLimits()\n        ylim = self.getGraphYLimits(axis='left')\n        y2lim = self.getGraphYLimits(axis='right')\n\n        self._backend.resetZoom(dataMargins)\n        self._setDirtyPlot()\n\n        if (xlim != self.getGraphXLimits() or\n                ylim != self.getGraphYLimits(axis='left') or\n                y2lim != self.getGraphYLimits(axis='right')):\n            self._notifyLimitsChanged()\n\n    # Internal\n\n    @staticmethod\n    def _logFilterData(x, y, color, xerror, yerror, xLog, yLog):\n        \"\"\"Filter out values with x or y <= 0 on log axes\n\n        All arrays are expected to have the same length.\n\n        :param x: The x coords.\n        :param y: The y coords.\n        :param color: The addCurve color arg (might not be an array).\n        :param xerror: The addCuve xerror arg (might not be an array).\n        :param yerror: The addCuve yerror arg (might not be an array).\n        :param bool xLog: True to filter arrays according to X coords.\n        :param bool yLog: True to filter arrays according to Y coords.\n        :return: The filter arrays or unchanged object if\n        :rtype: (x, y, color, xerror, yerror)\n        \"\"\"\n        if xLog and yLog:\n            idx = numpy.nonzero((x > 0) & (y > 0))[0]\n        elif yLog:\n            idx = numpy.nonzero(y > 0)[0]\n        elif xLog:\n            idx = numpy.nonzero(x > 0)[0]\n        else:\n            return x, y, color, xerror, yerror\n\n        x = numpy.take(x, idx)\n        y = numpy.take(y, idx)\n\n        if isinstance(color, numpy.ndarray) and len(color) == len(x):\n            # Nx(3 or 4) array (do not change RGBA color defined as an array)\n            color = numpy.take(color, idx, axis=0)\n\n        if isinstance(xerror, numpy.ndarray):\n            if len(xerror) == len(x):\n                # N or Nx1 array\n                xerror = numpy.take(xerror, idx, axis=0)\n            elif len(xerror) == 2 and len(xerror.shape) == 2:\n                # 2xN array (+/- error)\n                xerror = xerror[:, idx]\n\n        if isinstance(yerror, numpy.ndarray):\n            if len(yerror) == len(y):\n                # N or Nx1 array\n                yerror = numpy.take(yerror, idx, axis=0)\n            elif len(yerror) == 2 and len(yerror.shape) == 2:\n                # 2xN array (+/- error)\n                yerror = yerror[:, idx]\n\n        return x, y, color, xerror, yerror\n\n    def _update(self):\n        _logger.debug(\"_update called\")\n\n        # curves\n        activeCurve = self.getActiveCurve(just_legend=True)\n        curves = list(self._curves)\n        for legend in curves:\n            curve = self._curves[legend]\n            self.addCurve(curve['x'], curve['y'], legend, resetzoom=False,\n                          **curve['params'])\n\n        if len(curves):\n            if activeCurve not in curves:\n                activeCurve = curves[0]\n        else:\n            activeCurve = None\n        self.setActiveCurve(activeCurve)\n\n        # images\n        if not self.isXAxisLogarithmic() and not self.isYAxisLogarithmic():\n            for legend in list(self._images):  # Copy has images is changed\n                image = self._images[legend]\n                self.addImage(image['data'], legend,\n                              replace=False, rezetZoom=False,\n                              pixmap=image['pixmap'], **image['params'])\n\n    # Coord conversion\n\n    def dataToPixel(self, x=None, y=None, axis=\"left\"):\n        \"\"\"Convert a position in data coordinates to a position in pixels.\n\n        :param float x: The X coordinate in data space. If None (default)\n                        the middle position of the displayed data is used.\n        :param float y: The Y coordinate in data space. If None (default)\n                        the middle position of the displayed data is used.\n        :param str axis: The Y axis to use for the conversion\n                         ('left' or 'right').\n        :returns: The corresponding position in pixels or\n                  None if the data position is not in the displayed area.\n        :rtype: A tuple of 2 floats: (xPixel, yPixel) or None.\n        \"\"\"\n        assert axis in (\"left\", \"right\")\n\n        xmin, xmax = self.getGraphXLimits()\n        ymin, ymax = self.getGraphYLimits(axis=axis)\n\n        if x is None:\n            x = 0.5 * (xmax - xmin)\n        if y is None:\n            y = 0.5 * (ymax - ymin)\n\n        if x > xmax or x < xmin:\n            return None\n\n        if y > ymax or y < ymin:\n            return None\n\n        return self._backend.dataToPixel(x, y, axis=axis)\n\n    def pixelToData(self, x, y, axis=\"left\", check=False):\n        \"\"\"Convert a position in pixels to a position in data coordinates.\n\n        :param float x: The X coordinate in pixels. If None (default)\n                            the center of the widget is used.\n        :param float y: The Y coordinate in pixels. If None (default)\n                            the center of the widget is used.\n        :param str axis: The Y axis to use for the conversion\n                         ('left' or 'right').\n        :param bool check: Toggle checking if pixel is in plot area.\n                           If False, this method never returns None.\n        :returns: The corresponding position in data space or\n                  None if the pixel position is not in the plot area.\n        :rtype: A tuple of 2 floats: (xData, yData) or None.\n        \"\"\"\n        assert axis in (\"left\", \"right\")\n        return self._backend.pixelToData(x, y, axis=axis, check=check)\n\n    def getPlotBoundsInPixels(self):\n        \"\"\"Plot area bounds in widget coordinates in pixels.\n\n        :return: bounds as a 4-tuple of int: (left, top, width, height)\n        \"\"\"\n        return self._backend.getPlotBoundsInPixels()\n\n    # Interaction support\n\n    def setGraphCursorShape(self, cursor=None):\n        \"\"\"Set the cursor shape.\n\n        :param str cursor: Name of the cursor shape\n        \"\"\"\n        self._backend.setGraphCursorShape(cursor)\n\n    def _pickMarker(self, x, y, test=None):\n        \"\"\"Pick a marker at the given position.\n\n        To use for interaction implementation.\n\n        :param float x: X position in pixels.\n        :param float y: Y position in pixels.\n        :param test: A callable to call for each picked marker to filter\n                     picked markers. If None (default), do not filter markers.\n        \"\"\"\n        if test is None:\n            test = lambda marker: True\n\n        markers = self._backend.pickItems(x, y)\n        markers = [item for item in markers if item['kind'] == 'marker']\n\n        for item in reversed(markers):\n            legend = item['legend']\n            params = self._getMarker(legend)\n            if params is not None and test(params):\n                params['legend'] = legend\n                return params\n        return None\n\n    def _moveMarker(self, legend, x, y):\n        \"\"\"Move a marker to a position.\n\n        To use for interaction implementation.\n\n        :param str legend: The legend associated to the marker.\n        :param float x: The new X position of the marker in data coordinates.\n        :param float y: The new Y position of the marker in data coordinates.\n        \"\"\"\n        params = self._getMarker(legend)\n        if params is not None:\n            if params['x'] is not None:\n                params['x'] = x\n            if params['y'] is not None:\n                params['y'] = y\n            self._addMarker(**params)\n\n    def _getMarker(self, legend):\n        \"\"\"Get the parameters of a marker\n\n        :param str legend: The legend of the marker to retrieve\n        :return: A copy of the parameters the marker has been created with\n        :rtype: dict or None if marker does not exist\n        \"\"\"\n        marker = self._markers.get(legend, None)\n        if marker is None:\n            return None\n        else:\n            # Return a shallow copy\n            params = marker['params'].copy()\n            params['legend'] = legend\n            return params\n\n    def _pickImageOrCurve(self, x, y, test=None):\n        \"\"\"Pick an image or a curve at the given position.\n\n        To use for interaction implementation.\n\n        :param float x: X position in pixels.\n        :param float y: Y position in pixels.\n        :param test: A callable to call for each picked item to filter\n                     picked items. If None (default), do not filter items.\n        \"\"\"\n        if test is None:\n            test = lambda item: True\n\n        items = self._backend.pickItems(x, y)\n        items = [item for item in items if item['kind'] in ['curve', 'image']]\n\n        for item in reversed(items):\n            kind, legend = item['kind'], item['legend']\n            if kind == 'curve':\n                curve = self._curves.get(legend, None)\n                if curve is not None:\n                    params = curve['params'].copy()  # shallow copy\n                    if test(params):\n                        params['legend'] = legend\n                        return kind, params, item['xdata'], item['ydata']\n\n            elif kind == 'image':\n                image = self._images.get(legend, None)\n                if image is not None:\n                    params = image['params'].copy()  # shallow copy\n                    if test(params):\n                        params['legend'] = legend\n                        return kind, params, None\n\n            else:\n                _logger.warning('Unsupported kind: %s', kind)\n\n        return None\n\n    def _moveImage(self, legend, dx, dy):\n        \"\"\"Move an image to a position.\n\n        To use for interaction implementation.\n\n        :param str legend: The legend associated to the image.\n        :param float dx: The X offset to apply to the image in data coords.\n        :param float dy: The Y offset to apply to the image in data coords.\n        \"\"\"\n        # TODO: poor implementation, better to do move image in backend...\n        image = self._images[legend]\n        params = image['params'].copy()\n        params['origin'] = params['origin'][0] + dx, params['origin'][1] + dy\n        self.addImage(image['data'], legend,\n                      replace=False, resetzoom=False,\n                      pixmap=image['pixmap'], **params)\n\n    # User event handling #\n\n    def _isPositionInPlotArea(self, x, y):\n        \"\"\"Project position in pixel to the closest point in the plot area\n\n        :param float x: X coordinate in widget coordinate (in pixel)\n        :param float y: Y coordinate in widget coordinate (in pixel)\n        :return: (x, y) in widget coord (in pixel) in the plot area\n        \"\"\"\n        left, top, width, height = self.getPlotBoundsInPixels()\n        xPlot = _utils.clamp(x, left, left + width)\n        yPlot = _utils.clamp(y, top, top + height)\n        return xPlot, yPlot\n\n    def onMousePress(self, xPixel, yPixel, btn):\n        \"\"\"Handle mouse press event.\n\n        :param float xPixel: X mouse position in pixels\n        :param float yPixel: Y mouse position in pixels\n        :param str btn: Mouse button in 'left', 'middle', 'right'\n        \"\"\"\n        if self._isPositionInPlotArea(xPixel, yPixel) == (xPixel, yPixel):\n            self._pressedButtons.append(btn)\n            self._eventHandler.handleEvent('press', xPixel, yPixel, btn)\n\n    def onMouseMove(self, xPixel, yPixel):\n        \"\"\"Handle mouse move event.\n\n        :param float xPixel: X mouse position in pixels\n        :param float yPixel: Y mouse position in pixels\n        \"\"\"\n        inXPixel, inYPixel = self._isPositionInPlotArea(xPixel, yPixel)\n        isCursorInPlot = inXPixel == xPixel and inYPixel == yPixel\n\n        if isCursorInPlot:\n            # Signal mouse move event\n            dataPos = self.pixelToData(inXPixel, inYPixel)\n            assert dataPos is not None\n\n            btn = self._pressedButtons[-1] if self._pressedButtons else None\n            event = PlotEvents.prepareMouseSignal(\n                'mouseMoved', btn, dataPos[0], dataPos[1], xPixel, yPixel)\n            self.notify(**event)\n\n        # Either button was pressed in the plot or cursor is in the plot\n        if isCursorInPlot or self._pressedButtons:\n            self._eventHandler.handleEvent('move', inXPixel, inYPixel)\n\n    def onMouseRelease(self, xPixel, yPixel, btn):\n        \"\"\"Handle mouse release event.\n\n        :param float xPixel: X mouse position in pixels\n        :param float yPixel: Y mouse position in pixels\n        :param str btn: Mouse button in 'left', 'middle', 'right'\n        \"\"\"\n        try:\n            self._pressedButtons.remove(btn)\n        except ValueError:\n            pass\n        else:\n            xPixel, yPixel = self._isPositionInPlotArea(xPixel, yPixel)\n            self._eventHandler.handleEvent('release', xPixel, yPixel, btn)\n\n    def onMouseWheel(self, xPixel, yPixel, angleInDegrees):\n        \"\"\"Handle mouse wheel event.\n\n        :param float xPixel: X mouse position in pixels\n        :param float yPixel: Y mouse position in pixels\n        :param float angleInDegrees: Angle corresponding to wheel motion.\n                                     Positive for movement away from the user,\n                                     negative for movement toward the user.\n        \"\"\"\n        if self._isPositionInPlotArea(xPixel, yPixel) == (xPixel, yPixel):\n            self._eventHandler.handleEvent(\n                'wheel', xPixel, yPixel, angleInDegrees)\n\n    # Interaction modes #\n\n    def getInteractiveMode(self):\n        \"\"\"Returns the current interactive mode as a dict.\n\n        The returned dict contains at least the key 'mode'.\n        Mode can be: 'draw', 'pan', 'select', 'zoom'.\n        It can also contains extra keys (e.g., 'color') specific to a mode\n        as provided to :meth:`setInteractiveMode`.\n        \"\"\"\n        return self._eventHandler.getInteractiveMode()\n\n    def setInteractiveMode(self, mode, color='black',\n                           shape='polygon', label=None,\n                           zoomOnWheel=True):\n        \"\"\"Switch the interactive mode.\n\n        :param str mode: The name of the interactive mode.\n                         In 'draw', 'pan', 'select', 'zoom'.\n        :param color: Only for 'draw' and 'zoom' modes.\n                      Color to use for drawing selection area. Default black.\n        :type color: Color description: The name as a str or\n                     a tuple of 4 floats.\n        :param str shape: Only for 'draw' mode. The kind of shape to draw.\n                          In 'polygon', 'rectangle', 'line', 'vline', 'hline'.\n                          Default is 'polygon'.\n        :param str label: Only for 'draw' mode, sent in drawing events.\n        :param bool zoomOnWheel: Toggle zoom on wheel support\n        \"\"\"\n        self._eventHandler.setInteractiveMode(mode, color, shape, label)\n        self._eventHandler.zoomOnWheel = zoomOnWheel\n\n    # Deprecated #\n\n    def isDrawModeEnabled(self):\n        \"\"\"Deprecated, use :meth:`getInteractiveMode` instead.\n\n        Return True if the current interactive state is drawing.\"\"\"\n        _logger.warning(\n            'isDrawModeEnabled deprecated, use getInteractiveMode instead')\n        return self.getInteractiveMode()['mode'] == 'draw'\n\n    def setDrawModeEnabled(self, flag=True, shape='polygon', label=None,\n                           color=None, **kwargs):\n        \"\"\"Deprecated, use :meth:`setInteractiveMode` instead.\n\n        Set the drawing mode if flag is True and its parameters.\n\n        If flag is False, only item selection is enabled.\n\n        Warning: Zoom and drawing are not compatible and cannot be enabled\n        simultanelously.\n\n        :param bool flag: True to enable drawing and disable zoom and select.\n        :param str shape: Type of item to be drawn in:\n                          hline, vline, rectangle, polygon (default)\n        :param str label: Associated text for identifying draw signals\n        :param color: The color to use to draw the selection area\n        :type color: string (\"#RRGGBB\") or 4 column unsigned byte array or\n                     one of the predefined color names defined in Colors.py\n        \"\"\"\n        _logger.warning(\n            'setDrawModeEnabled deprecated, use setInteractiveMode instead')\n\n        if kwargs:\n            _logger.warning('setDrawModeEnabled ignores additional parameters')\n\n        if color is None:\n            color = 'black'\n\n        if flag:\n            self.setInteractiveMode('draw', shape=shape,\n                                    label=label, color=color)\n        elif self.getInteractiveMode()['mode'] == 'draw':\n            self.setInteractiveMode('select')\n\n    def getDrawMode(self):\n        \"\"\"Deprecated, use :meth:`getInteractiveMode` instead.\n\n        Return the draw mode parameters as a dict of None.\n\n        It returns None if the interactive moed is not a drawing mode,\n        otherwise, it returns a dict containing the drawing mode parameters\n        as provided to :meth:`setDrawModeEnabled`.\n        \"\"\"\n        _logger.warning(\n            'getDrawMode deprecated, use getInteractiveMode instead')\n        mode = self.getInteractiveMode()\n        return mode if mode['mode'] == 'draw' else None\n\n    def isZoomModeEnabled(self):\n        \"\"\"Deprecated, use :meth:`getInteractiveMode` instead.\n\n        Return True if the current interactive state is zooming.\"\"\"\n        _logger.warning(\n            'isZoomModeEnabled deprecated, use getInteractiveMode instead')\n        return self.getInteractiveMode()['mode'] == 'zoom'\n\n    def setZoomModeEnabled(self, flag=True, color=None):\n        \"\"\"Deprecated, use :meth:`setInteractiveMode` instead.\n\n        Set the zoom mode if flag is True, else item selection is enabled.\n\n        Warning: Zoom and drawing are not compatible and cannot be enabled\n        simultanelously\n\n        :param bool flag: If True, enable zoom and select mode.\n        :param color: The color to use to draw the selection area.\n                      (Default: 'black')\n        :param color: The color to use to draw the selection area\n        :type color: string (\"#RRGGBB\") or 4 column unsigned byte array or\n                     one of the predefined color names defined in Colors.py\n        \"\"\"\n        _logger.warning(\n            'setZoomModeEnabled deprecated, use setInteractiveMode instead')\n        if color is None:\n            color = 'black'\n\n        if flag:\n            self.setInteractiveMode('zoom', color=color)\n        elif self.getInteractiveMode()['mode'] == 'zoom':\n            self.setInteractiveMode('select')\n\n    def insertMarker(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`addMarker` instead.\"\"\"\n        _logger.warning(\n                'insertMarker deprecated, use addMarker instead.')\n        return self.addMarker(*args, **kwargs)\n\n    def insertXMarker(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`addXMarker` instead.\"\"\"\n        _logger.warning(\n                'insertXMarker deprecated, use addXMarker instead.')\n        return self.addXMarker(*args, **kwargs)\n\n    def insertYMarker(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`addYMarker` instead.\"\"\"\n        _logger.warning(\n                'insertYMarker deprecated, use addYMarker instead.')\n        return self.addYMarker(*args, **kwargs)\n\n    def isActiveCurveHandlingEnabled(self):\n        \"\"\"Deprecated, use :meth:`isActiveCurveHandling` instead.\"\"\"\n        _logger.warning(\n            'isActiveCurveHandlingEnabled deprecated, '\n            'use isActiveCurveHandling instead.')\n        return self.isActiveCurveHandling()\n\n    def enableActiveCurveHandling(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`setActiveCurveHandling` instead.\"\"\"\n        _logger.warning(\n            'enableActiveCurveHandling deprecated, '\n            'use setActiveCurveHandling instead.')\n        return self.setActiveCurveHandling(*args, **kwargs)\n\n    def invertYAxis(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`setYAxisInverted` instead.\"\"\"\n        _logger.warning('invertYAxis deprecated, '\n                        'use setYAxisInverted instead.')\n        return self.setYAxisInverted(*args, **kwargs)\n\n    def showGrid(self, flag=True):\n        \"\"\"Deprecated, use :meth:`setGraphGrid` instead.\"\"\"\n        _logger.warning(\"showGrid deprecated, use setGraphGrid instead\")\n        if flag in (0, False):\n            flag = None\n        elif flag in (1, True):\n            flag = 'major'\n        else:\n            flag = 'both'\n        return self.setGraphGrid(flag)\n\n    def keepDataAspectRatio(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`setKeepDataAspectRatio`.\"\"\"\n        _logger.warning('keepDataAspectRatio deprecated,'\n                        'use setKeepDataAspectRatio instead')\n        return self.setKeepDataAspectRatio(*args, **kwargs)",
  "def __init__(self, parent=None, backend=None, autoreplot=True):\n        self._autoreplot = bool(autoreplot)\n        self._dirty = False\n\n        if backend is None:\n            backend = self.defaultBackend\n\n        if hasattr(backend, \"__call__\"):\n            self._backend = backend(self, parent)\n\n        elif hasattr(backend, \"lower\"):\n            lowerCaseString = backend.lower()\n            if lowerCaseString in (\"matplotlib\", \"mpl\"):\n                from .BackendMatplotlib import BackendMatplotlibQt as \\\n                    backendClass\n            elif lowerCaseString == 'none':\n                from .BackendBase import BackendBase as backendClass\n            else:\n                raise ValueError(\"Backend not supported %s\" % backend)\n            self._backend = backendClass(self, parent)\n\n        else:\n            raise ValueError(\"Backend not supported %s\" % str(backend))\n\n        super(Plot, self).__init__()\n\n        self.setCallback()  # set _callback\n\n        # Items handling\n        self._curves = OrderedDict()\n        self._hiddenCurves = set()\n\n        self._images = OrderedDict()\n        self._markers = OrderedDict()\n        self._items = OrderedDict()\n\n        # line types\n        self._styleList = ['-', '--', '-.', ':']\n\n        self._colorIndex = 0\n        self._styleIndex = 0\n\n        self._activeCurveHandling = True\n        self._activeCurve = None\n        self._activeCurveColor = \"#000000\"\n        self._activeImage = None\n\n        # default properties\n        self._cursorConfiguration = None\n\n        self._logY = False\n        self._logX = False\n        self._xAutoScale = True\n        self._yAutoScale = True\n        self._grid = None\n\n        self.setGraphTitle()\n        self.setGraphXLabel()\n        self.setGraphYLabel()\n\n        self.setDefaultColormap()  # Init default colormap\n\n        self.setDefaultPlotPoints(False)\n        self.setDefaultPlotLines(True)\n\n        self._eventHandler = PlotInteraction.PlotInteraction(self)\n        self._eventHandler.setInteractiveMode('zoom', color=(0., 0., 0., 1.))\n\n        self._pressedButtons = []  # Currently pressed mouse buttons\n\n        self._defaultDataMargins = (0., 0., 0., 0.)",
  "def _getDirtyPlot(self):\n        \"\"\"Return the plot dirty flag.\n\n        If False, the plot has not changed since last replot.\n        If True, the full plot need to be redrawn.\n        If 'overlay', only the overlay has changed since last replot.\n\n        It can be accessed by backend to check the dirty state.\n\n        :return: False, True, 'overlay'\n        \"\"\"\n        return self._dirty",
  "def _setDirtyPlot(self, overlayOnly=False):\n        \"\"\"Mark the plot as needing redraw\n\n        :param bool overlayOnly: True to redraw only the overlay,\n                                 False to redraw everything\n        \"\"\"\n        wasDirty = self._dirty\n\n        if not self._dirty and overlayOnly:\n            self._dirty = 'overlay'\n        else:\n            self._dirty = True\n\n        if self._autoreplot and not wasDirty:\n            self._backend.postRedisplay()",
  "def addCurve(self, x, y, legend=None, info=None,\n                 replace=False, replot=None,\n                 color=None, symbol=None,\n                 linewidth=None, linestyle=None,\n                 xlabel=None, ylabel=None, yaxis=None,\n                 xerror=None, yerror=None, z=None, selectable=None,\n                 fill=None, resetzoom=True, **kw):\n        \"\"\"Add a 1D curve given by x an y to the graph.\n\n        Curves are uniquely identified by their legend.\n        To add multiple curves, call :meth:`addCurve` multiple times with\n        different legend argument.\n        To replace/update an existing curve, call :meth:`addCurve` with the\n        existing curve legend.\n\n        When curve parameters are not provided, if a curve with the\n        same legend is displayed in the plot, its parameters are used.\n\n        :param numpy.ndarray x: The data corresponding to the x coordinates\n        :param numpy.ndarray y: The data corresponding to the y coordinates\n        :param str legend: The legend to be associated to the curve (or None)\n        :param info: User-defined information associated to the curve\n        :param bool replace: True (the default) to delete already existing\n                             curves\n        :param color: color(s) to be used\n        :type color: str (\"#RRGGBB\") or (npoints, 4) unsigned byte array or\n                     one of the predefined color names defined in Colors.py\n        :param str symbol: Symbol to be drawn at each (x, y) position::\n\n            - 'o' circle\n            - '.' point\n            - ',' pixel\n            - '+' cross\n            - 'x' x-cross\n            - 'd' diamond\n            - 's' square\n            - None (the default) to use default symbol\n\n        :param float linewidth: The width of the curve in pixels (Default: 1).\n        :param str linestyle: Type of line::\n\n            - ' '  no line\n            - '-'  solid line\n            - '--' dashed line\n            - '-.' dash-dot line\n            - ':'  dotted line\n            - None (the default) to use default line style\n\n        :param str xlabel: Label to show on the X axis when the curve is active\n        :param str ylabel: Label to show on the Y axis when the curve is active\n        :param str yaxis: The Y axis this curve is attached to.\n                          Either 'left' (the default) or 'right'\n        :param xerror: Values with the uncertainties on the x values\n        :type xerror: A float, or a numpy.ndarray of float32.\n                      If it is an array, it can either be a 1D array of\n                      same length as the data or a 2D array with 2 rows\n                      of same length as the data: row 0 for positive errors,\n                      row 1 for negative errors.\n        :param yerror: Values with the uncertainties on the y values\n        :type yerror: A float, or a numpy.ndarray of float32. See xerror.\n        :param int z: Layer on which to draw the curve (default: 1)\n                      This allows to control the overlay.\n        :param bool selectable: Indicate if the curve can be selected.\n                                (Default: True)\n        :param bool fill: True to fill the curve, False otherwise (default).\n        :param bool resetzoom: True (the default) to reset the zoom.\n        :returns: The key string identify this curve\n        \"\"\"\n        # Take care of input parameters: check/conversion, default value\n\n        if replot is not None:\n            _logger.warning(\n                'addCurve deprecated replot argument, use resetzoom instead')\n            resetzoom = replot and resetzoom\n\n        if kw:\n            _logger.warning('addCurve: deprecated extra arguments')\n\n        legend = \"Unnamed curve 1.1\" if legend is None else str(legend)\n\n        # Check/Convert input arguments\n\n        # Convert to arrays (not forcing type) in order to avoid\n        # problems at unexpected places: missing min or max attributes, problem\n        # when using numpy.nonzero on lists, ...\n        x = numpy.asarray(x)\n        y = numpy.asarray(y)\n\n        # TODO check color\n\n        assert symbol in ('o', '.', ',', '+', 'x', 'd', 's', '', None)\n\n        assert linestyle in ('', ' ', '-', '--', '-.', ':', None)\n\n        if xlabel is not None:\n            xlabel = str(xlabel)\n\n        if ylabel is not None:\n            ylabel = str(ylabel)\n\n        assert yaxis in (None, 'left', 'right')\n\n        # TODO check xerror, yerror\n\n        if xerror is not None:\n            xerror = numpy.asarray(xerror)\n\n        if yerror is not None:\n            yerror = numpy.asarray(yerror)\n\n        if z is not None:\n            z = int(z)\n\n        if selectable is not None:\n            selectable = bool(selectable)\n\n        if fill is not None:\n            fill = bool(fill)\n\n        # Store all params with defaults in a dict to treat them at once\n        params = {\n            'info': info, 'color': color,\n            'symbol': symbol, 'linewidth': linewidth, 'linestyle': linestyle,\n            'xlabel': xlabel, 'ylabel': ylabel, 'yaxis': yaxis,\n            'xerror': xerror, 'yerror': yerror, 'z': z,\n            'selectable': selectable, 'fill': fill\n        }\n\n        # Check if curve is previously active\n        wasActive = self.getActiveCurve(just_legend=True) == legend\n\n        # First, try to get defaults from existing curve with same name\n        previousCurve = self._curves.get(legend, None)\n        if previousCurve is not None:\n            defaults = previousCurve['params']\n\n        else:  # If no existing curve use default values\n            default_color, default_linestyle = self._getColorAndStyle()\n            defaults = {\n                'info': None, 'color': default_color,\n                'symbol': self._defaultPlotPoints,\n                'linewidth': 1,\n                'linestyle': default_linestyle,\n                'xlabel': 'X', 'ylabel': 'Y', 'yaxis': 'left',\n                'xerror': None, 'yerror': None, 'z': 1,\n                'selectable': True, 'fill': False\n            }\n\n        # If a parameter is not given as argument, use its default value\n        for key in defaults:\n            if params[key] is None:\n                params[key] = defaults[key]\n\n        # Add: replace, filter data, add\n\n        # This must be done after getting params from existing curve\n        if replace:\n            self.remove(kind='curve')\n        else:\n            # Remove previous curve from backend\n            # but not from _curves and hiddenCurves to keep its place\n            # This is a subset of self.remove(legend, kind='curve')\n            if legend in self._curves:\n                handle = self._curves[legend]['handle']\n                if handle is not None:\n                    self._backend.remove(handle)\n                    self._curves[legend]['handle'] = None\n                    self._setDirtyPlot()\n\n        # Filter-out values <= 0\n        x, y, color, xerror, yerror = self._logFilterData(\n            x, y, params['color'], params['xerror'], params['yerror'],\n            self.isXAxisLogarithmic(), self.isYAxisLogarithmic())\n\n        if len(x) and not self.isCurveHidden(legend):\n            handle = self._backend.addCurve(x, y, legend,\n                                            color=color,\n                                            symbol=params['symbol'],\n                                            linestyle=params['linestyle'],\n                                            linewidth=params['linewidth'],\n                                            yaxis=params['yaxis'],\n                                            xerror=xerror,\n                                            yerror=yerror,\n                                            z=params['z'],\n                                            selectable=params['selectable'],\n                                            fill=params['fill'])\n            self._setDirtyPlot()\n        else:\n            handle = None  # The curve has no points or is hidden\n\n        self._curves[legend] = {\n            'handle': handle, 'x': x, 'y': y, 'params': params\n        }\n\n        if len(self._curves) == 1 or wasActive:\n            self.setActiveCurve(legend)\n\n        if resetzoom:\n            # We ask for a zoom reset in order to handle the plot scaling\n            # if the user does not want that, autoscale of the different\n            # axes has to be set to off.\n            self.resetZoom()\n\n        self.notify(\n            'contentChanged', action='add', kind='curve', legend=legend)\n\n        return legend",
  "def addImage(self, data, legend=None, info=None,\n                 replace=True, replot=None,\n                 xScale=None, yScale=None, z=None,\n                 selectable=False, draggable=False,\n                 colormap=None, pixmap=None,\n                 xlabel=None, ylabel=None,\n                 origin=None, scale=None,\n                 resetzoom=True, **kw):\n        \"\"\"Add a 2D dataset or an image to the plot.\n\n        It displays either an array of data using a colormap or a RGB(A) image.\n\n        Images are uniquely identified by their legend.\n        To add multiple images, call :meth:`addImage` multiple times with\n        different legend argument.\n        To replace/update an existing image, call :meth:`addImage` with the\n        existing image legend.\n\n        When image parameters are not provided, if an image with the\n        same legend is displayed in the plot, its parameters are used.\n\n        :param numpy.ndarray data: (nrows, ncolumns) data or\n                                   (nrows, ncolumns, RGBA) ubyte array\n        :param str legend: The legend to be associated to the image (or None)\n        :param info: User-defined information associated to the image\n        :param bool replace: True (default) to delete already existing images\n        :param int z: Layer on which to draw the image (default: 0)\n                      This allows to control the overlay.\n        :param bool selectable: Indicate if the image can be selected.\n                                (default: False)\n        :param bool draggable: Indicate if the image can be moved.\n                               (default: False)\n        :param dict colormap: Description of the colormap to use (or None)\n                              This is ignored if data is a RGB(A) image.\n                              See :mod:`Plot` for the documentation\n                              of the colormap dict.\n        :param pixmap: Pixmap representation of the data (if any)\n        :type pixmap: (nrows, ncolumns, RGBA) ubyte array or None (default)\n        :param str xlabel: X axis label to show when this curve is active.\n        :param str ylabel: Y axis label to show when this curve is active.\n        :param origin: (origin X, origin Y) of the data.\n                       Default: (0., 0.)\n        :type origin: 2-tuple of float\n        :param scale: (scale X, scale Y) of the data.\n                       Default: (1., 1.)\n        :type scale: 2-tuple of float\n        :param bool resetzoom: True (the default) to reset the zoom.\n        :returns: The key string identify this image\n        \"\"\"\n        # Take care of input parameters: check/conversion, default value\n\n        if xScale is not None or yScale is not None:\n            _logger.warning(\n                'addImage deprecated xScale and yScale arguments,'\n                'use origin, scale arguments instead.')\n            if origin is None and scale is None:\n                origin = xScale[0], yScale[0]\n                scale = xScale[1], yScale[1]\n            else:\n                _logger.warning(\n                    'addCurve: xScale, yScale and origin, scale arguments'\n                    ' are conflicting. xScale and yScale are ignored.'\n                    ' Use only origin, scale arguments.')\n\n        if replot is not None:\n            _logger.warning(\n                'addImage deprecated replot argument, use resetzoom instead')\n            resetzoom = replot and resetzoom\n\n        if kw:\n            _logger.warning('addImage: deprecated extra arguments')\n\n        legend = \"Unnamed Image 1.1\" if legend is None else str(legend)\n\n        # Check/Convert input arguments\n        data = numpy.asarray(data)\n\n        if origin is not None:\n            origin = float(origin[0]), float(origin[1])\n\n        if scale is not None:\n            scale = float(scale[0]), float(scale[1])\n\n        if z is not None:\n            z = int(z)\n\n        if selectable is not None:\n            selectable = bool(selectable)\n\n        if draggable is not None:\n            draggable = bool(draggable)\n\n        if pixmap is not None:\n            pixmap = numpy.asarray(pixmap)\n\n        if xlabel is not None:\n            xlabel = str(xlabel)\n\n        if ylabel is not None:\n            ylabel = str(ylabel)\n\n        # Store all params with defaults in a dict to treat them at once\n        params = {\n            'info': info, 'origin': origin, 'scale': scale, 'z': z,\n            'selectable': selectable, 'draggable': draggable,\n            'colormap': colormap,\n            'xlabel': xlabel, 'ylabel': ylabel\n        }\n\n        # First, try to get defaults from existing curve with same name\n        previousImage = self._images.get(legend, None)\n        if previousImage is not None:\n            defaults = previousImage['params']\n\n        else:  # If no existing curve use default values\n            defaults = {\n                'info': None, 'origin': (0., 0.), 'scale': (1., 1.), 'z': 0,\n                'selectable': False, 'draggable': False,\n                'colormap': self.getDefaultColormap(),\n                'xlabel': 'Column', 'ylabel': 'Row'\n            }\n\n        # If a parameter is not given as argument, use its default value\n        for key in defaults:\n            if params[key] is None:\n                params[key] = defaults[key]\n\n        # Add: replace, filter data, add\n\n        if replace:\n            self.remove(kind='image')\n        else:\n            # Remove previous image from backend\n            # but not from _images to keep its place\n            # This is a subset of self.remove(legend, kind='image')\n            if legend in self._images:\n                 handle = self._images[legend]['handle']\n                 if handle is not None:\n                     self._backend.remove(handle)\n                     self._images[legend]['handle'] = None\n                     self._setDirtyPlot()\n\n        if self.isXAxisLogarithmic() or self.isYAxisLogarithmic():\n            _logger.info('Hide image while axes has log scale.')\n\n        if (data is not None and not self.isXAxisLogarithmic() and\n                not self.isYAxisLogarithmic()):\n            if pixmap is not None:\n                dataToSend = pixmap\n            else:\n                dataToSend = data\n\n            handle = self._backend.addImage(dataToSend, legend=legend,\n                                            origin=params['origin'],\n                                            scale=params['scale'],\n                                            z=params['z'],\n                                            selectable=params['selectable'],\n                                            draggable=params['draggable'],\n                                            colormap=params['colormap'])\n            self._setDirtyPlot()\n        else:\n            handle = None  # data is None or log scale\n\n        self._images[legend] = {\n            'handle': handle,\n            'data': data,\n            'pixmap': pixmap,\n            'params': params\n        }\n\n        if len(self._images) == 1:\n            self.setActiveImage(legend)\n\n        if resetzoom:\n            # We ask for a zoom reset in order to handle the plot scaling\n            # if the user does not want that, autoscale of the different\n            # axes has to be set to off.\n            self.resetZoom()\n\n        self.notify(\n            'contentChanged', action='add', kind='image', legend=legend)\n\n        return legend",
  "def addItem(self, xdata, ydata, legend=None, info=None,\n                replace=False,\n                shape=\"polygon\", color='black', fill=True,\n                overlay=False, **kw):\n        \"\"\"Add an item (i.e. a shape) to the plot.\n\n        Items are uniquely identified by their legend.\n        To add multiple items, call :meth:`addItem` multiple times with\n        different legend argument.\n        To replace/update an existing item, call :meth:`addImage` with the\n        existing item legend.\n\n        :param numpy.ndarray xdata: The X coords of the points of the shape\n        :param numpy.ndarray ydata: The Y coords of the points of the shape\n        :param str legend: The legend to be associated to the item\n        :param info: User-defined information associated to the image\n        :param bool replace: True (default) to delete already existing images\n        :param str shape: Type of item to be drawn in\n                          hline, polygon (the default), rectangle, vline\n        :param str color: Color of the item, e.g., 'blue', 'b', '#FF0000'\n                          (Default: 'black')\n        :param bool fill: True (the default) to fill the shape\n        :param bool overlay: True if item is an overlay (Default: False).\n                             This allows for rendering optimization if this\n                             item is changed often.\n        :returns: The key string identify this item\n        \"\"\"\n        # expected to receive the same parameters as the signal\n\n        if kw:\n            _logger.warning('addItem deprecated parameters: %s', str(kw))\n\n        legend = \"Unnamed Item 1.1\" if legend is None else str(legend)\n\n        if replace:\n            self.remove(kind='item')\n        else:\n            self.remove(legend, kind='item')\n\n        handle = self._backend.addItem(xdata, ydata, legend=legend,\n                                       shape=shape, color=color,\n                                       fill=fill, overlay=overlay)\n        self._setDirtyPlot(overlayOnly=overlay)\n\n        self._items[legend] = {'handle': handle, 'overlay': overlay}\n\n        self.notify('contentChanged', action='add', kind='item', legend=legend)\n\n        return legend",
  "def addXMarker(self, x, legend=None,\n                   text=None,\n                   color=None,\n                   selectable=False,\n                   draggable=False,\n                   constraint=None,\n                   **kw):\n        \"\"\"Add a vertical line marker to the plot.\n\n        Markers are uniquely identified by their legend.\n        As opposed to curves, images and items, two calls to\n        :meth:`addXMarker` without legend argument adds two markers with\n        different identifying legends.\n\n        :param float x: Position of the marker on the X axis in data\n                        coordinates\n        :param str legend: Legend associated to the marker to identify it\n        :param str text: Text to display on the marker.\n        :param str color: Color of the marker, e.g., 'blue', 'b', '#FF0000'\n                          (Default: 'black')\n        :param bool selectable: Indicate if the marker can be selected.\n                                (default: False)\n        :param bool draggable: Indicate if the marker can be moved.\n                               (default: False)\n        :param constraint: A function filtering marker displacement by\n                           dragging operations or None for no filter.\n                           This function is called each time a marker is\n                           moved.\n                           This parameter is only used if draggable is True.\n        :type constraint: None or a callable that takes the coordinates of\n                          the current cursor position in the plot as input\n                          and that returns the filtered coordinates.\n        :return: The key string identify this marker\n        \"\"\"\n        if kw:\n            _logger.warning(\n                'addXMarker deprecated extra parameters: %s', str(kw))\n\n        return self._addMarker(x=x, y=None, legend=legend,\n                               text=text, color=color,\n                               selectable=selectable, draggable=draggable,\n                               symbol=None, constraint=constraint)",
  "def addYMarker(self, y,\n                   legend=None,\n                   text=None,\n                   color=None,\n                   selectable=False,\n                   draggable=False,\n                   constraint=None,\n                   **kw):\n        \"\"\"Add a horizontal line marker to the plot.\n\n        Markers are uniquely identified by their legend.\n        As opposed to curves, images and items, two calls to\n        :meth:`addYMarker` without legend argument adds two markers with\n        different identifying legends.\n\n        :param float y: Position of the marker on the Y axis in data\n                        coordinates\n        :param str legend: Legend associated to the marker to identify it\n        :param str text: Text to display next to the marker.\n        :param str color: Color of the marker, e.g., 'blue', 'b', '#FF0000'\n                          (Default: 'black')\n        :param bool selectable: Indicate if the marker can be selected.\n                                (default: False)\n        :param bool draggable: Indicate if the marker can be moved.\n                               (default: False)\n        :param constraint: A function filtering marker displacement by\n                           dragging operations or None for no filter.\n                           This function is called each time a marker is\n                           moved.\n                           This parameter is only used if draggable is True.\n        :type constraint: None or a callable that takes the coordinates of\n                          the current cursor position in the plot as input\n                          and that returns the filtered coordinates.\n        :return: The key string identify this marker\n        \"\"\"\n        if kw:\n            _logger.warning(\n                'addYMarker deprecated extra parameters: %s', str(kw))\n\n        return self._addMarker(x=None, y=y, legend=legend,\n                               text=text, color=color,\n                               selectable=selectable, draggable=draggable,\n                               symbol=None, constraint=constraint)",
  "def addMarker(self, x, y, legend=None,\n                  text=None,\n                  color=None,\n                  selectable=False,\n                  draggable=False,\n                  symbol='+',\n                  constraint=None,\n                  **kw):\n        \"\"\"Add a point marker to the plot.\n\n        Markers are uniquely identified by their legend.\n        As opposed to curves, images and items, two calls to\n        :meth:`addMarker` without legend argument adds two markers with\n        different identifying legends.\n\n        :param float x: Position of the marker on the X axis in data\n                        coordinates\n        :param float y: Position of the marker on the Y axis in data\n                        coordinates\n        :param str legend: Legend associated to the marker to identify it\n        :param str text: Text to display next to the marker\n        :param str color: Color of the marker, e.g., 'blue', 'b', '#FF0000'\n                          (Default: 'black')\n        :param bool selectable: Indicate if the marker can be selected.\n                                (default: False)\n        :param bool draggable: Indicate if the marker can be moved.\n                               (default: False)\n        :param str symbol: Symbol representing the marker in::\n\n            - 'o' circle\n            - '.' point\n            - ',' pixel\n            - '+' cross (the default)\n            - 'x' x-cross\n            - 'd' diamond\n            - 's' square\n\n        :param constraint: A function filtering marker displacement by\n                           dragging operations or None for no filter.\n                           This function is called each time a marker is\n                           moved.\n                           This parameter is only used if draggable is True.\n        :type constraint: None or a callable that takes the coordinates of\n                          the current cursor position in the plot as input\n                          and that returns the filtered coordinates.\n        :return: The key string identify this marker\n        \"\"\"\n        if kw:\n            _logger.warning(\n                'addMarker deprecated extra parameters: %s', str(kw))\n\n        if x is None:\n            xmin, xmax = self.getGraphXLimits()\n            x = 0.5 * (xmax + xmin)\n\n        if y is None:\n            ymin, ymax = self.getGraphYLimits()\n            y = 0.5 * (ymax + ymin)\n\n        return self._addMarker(x=x, y=y, legend=legend,\n                               text=text, color=color,\n                               selectable=selectable, draggable=draggable,\n                               symbol=symbol, constraint=constraint)",
  "def _addMarker(self, x, y, legend,\n                   text, color,\n                   selectable, draggable,\n                   symbol, constraint):\n        \"\"\"Common method for adding point, vline and hline marker.\n\n        See :meth:`addMarker` for argument documentation.\n        \"\"\"\n        if legend is None:\n            i = 0\n            while legend in self._markers:\n                legend = \"Unnamed Marker %d\" % i\n                i += 1\n\n        if color is None:\n            color = self.colorDict['black']\n        elif color in self.colorDict:\n            color = self.colorDict[color]\n\n        if constraint is not None and not callable(constraint):\n            # Then it must be a string\n            if hasattr(constraint, 'lower'):\n                if constraint.lower().startswith('h'):\n                    constraint = lambda xData, yData: (xData, y)\n                elif constraint.lower().startswith('v'):\n                    constraint = lambda xData, yData: (x, yData)\n                else:\n                    raise ValueError(\n                        \"Unsupported constraint name: %s\" % constraint)\n            else:\n                raise ValueError(\"Unsupported constraint\")\n\n        # Apply constraint to provided position\n        if draggable and constraint is not None:\n            x, y = constraint(x, y)\n\n        if legend in self._markers:\n            self.remove(legend, kind='marker')\n\n        handle = self._backend.addMarker(\n            x=x, y=y, legend=legend, text=text, color=color,\n            selectable=selectable, draggable=draggable,\n            symbol=symbol, constraint=constraint,\n            overlay=draggable)\n\n        self._markers[legend] = {'handle': handle, 'params': {\n            'x': x, 'y': y,\n            'text': text, 'color': color,\n            'selectable': selectable, 'draggable': draggable,\n            'symbol': symbol, 'constraint': constraint}\n        }\n\n        self._setDirtyPlot(overlayOnly=draggable)\n\n        self.notify(\n            'contentChanged', action='add', kind='marker', legend=legend)\n\n        return legend",
  "def isCurveHidden(self, legend):\n        \"\"\"Returns True if the curve associated to legend is hidden, else False\n\n        :param str legend: The legend key identifying the curve\n        :return: True if the associated curve is hidden, False otherwise\n        \"\"\"\n        return legend in self._hiddenCurves",
  "def hideCurve(self, legend, flag=True, replot=None):\n        \"\"\"Show/Hide the curve associated to legend.\n\n        Even when hidden, the curve is kept in the list of curves.\n\n        :param str legend: The legend associated to the curve to be hidden\n        :param bool flag: True (default) to hide the curve, False to show it\n        \"\"\"\n        if replot is not None:\n            _logger.warning('hideCurve deprecated replot parameter')\n\n        if legend not in self._curves:\n            _logger.warning('Curve not in plot: %s', legend)\n            return\n\n        if flag:\n            handle = self._curves[legend]['handle']\n            if handle is not None:\n                self._backend.remove(handle)\n                self._curves[legend]['handle'] = None\n\n            self._hiddenCurves.add(legend)\n        else:\n            self._hiddenCurves.discard(legend)\n            curve = self._curves[legend]\n            self.addCurve(curve['x'], curve['y'], legend, resetzoom=False,\n                          **curve['params'])\n\n        self._setDirtyPlot()",
  "def remove(self, legend=None, kind=ITEM_KINDS):\n        \"\"\"Remove one or all element(s) of the given legend and kind.\n\n        Examples:\n\n        - remove() clears the plot\n        - remove(kind='curve') removes all curves from the plot\n        - remove('myCurve', kind='curve') removes the curve with\n          legend 'myCurve' from the plot.\n        - remove('myImage, kind='image') removes the image with\n          legend 'myImage' from the plot.\n        - remove('myImage') removes elements (for instance curve, image,\n          item and marker) with legend 'myImage'.\n\n        :param str legend: The legend associated to the element to remove,\n                           or None to remove\n        :param kind: The kind of elements to remove from the plot.\n                     In: 'all', 'curve', 'image', 'item', 'marker'.\n                     By default, it removes all kind of elements.\n        :type kind: str or tuple of str to specify multiple kinds.\n        \"\"\"\n        if kind is 'all':  # Replace all by tuple of all kinds\n            kind = self.ITEM_KINDS\n\n        if kind in self.ITEM_KINDS:  # Kind is a str, make it a tuple\n            kind = (kind,)\n\n        if legend is None:  # This is a clear\n            # Clear each given kind\n            for aKind in kind:\n                if aKind == 'curve':\n                    # Copy as _curves gets changed\n                    for legend in list(self._curves):\n                        self.remove(legend, kind='curve')\n                    self._curves = OrderedDict()\n                    self._hiddenCurves = set()\n                    self._colorIndex = 0\n                    self._styleIndex = 0\n\n                elif aKind == 'image':\n                    # Copy as _images gets changed\n                    for legend in list(self._images):\n                        self.remove(legend, kind='image')\n                    self._images = OrderedDict()\n\n                elif aKind == 'item':\n                    # Copy as _items gets changed\n                    for legend in list(self._items):\n                        self.remove(legend, kind='item')\n                    self._items = OrderedDict()\n\n                elif aKind == 'marker':\n                    # Copy as _markers gets changed\n                    for legend in list(self._markers):\n                        self.remove(legend, kind='marker')\n                    self._markers = OrderedDict()\n                else:\n                    _logger.warning('remove: Unhandled item kind %s', aKind)\n\n        else:  # This is removing a single element\n            # Remove each given kind\n            for aKind in kind:\n                if aKind == 'curve':\n                    self._hiddenCurves.discard(legend)\n\n                    if legend in self._curves:\n                        handle = self._curves[legend]['handle']\n                        if handle is not None:\n                            self._backend.remove(handle)\n                            self._setDirtyPlot()\n                        del self._curves[legend]\n\n                        if not self._curves:\n                            self._colorIndex = 0\n                            self._styleIndex = 0\n\n                        self.notify('contentChanged', action='remove',\n                                    kind='curve', legend=legend)\n\n                elif aKind == 'image':\n                    if legend in self._images:\n                         handle = self._images[legend]['handle']\n                         if handle is not None:\n                             self._backend.remove(handle)\n                             self._setDirtyPlot()\n                         del self._images[legend]\n\n                         self.notify('contentChanged', action='remove',\n                                     kind='image', legend=legend)\n\n                elif aKind == 'item':\n                    item = self._items.pop(legend, None)\n                    if item is not None:\n                        if item['handle'] is not None:\n                            self._backend.remove(item['handle'])\n                            self._setDirtyPlot(overlayOnly=item['overlay'])\n\n                        self.notify('contentChanged', action='remove',\n                                    kind='item', legend=legend)\n\n                elif aKind == 'marker':\n                    marker = self._markers.pop(legend, None)\n                    if marker is not None:\n                        if marker['handle'] is not None:\n                            self._backend.remove(marker['handle'])\n                            self._setDirtyPlot(\n                                overlayOnly=marker['params']['draggable'])\n\n                        self.notify('contentChanged', action='remove',\n                                    kind='marker', legend=legend)\n\n                else:\n                    _logger.warning('remove: Unhandled item kind %s', aKind)",
  "def removeCurve(self, legend):\n        \"\"\"Remove the curve associated to legend from the graph.\n\n        :param str legend: The legend associated to the curve to be deleted\n        \"\"\"\n        if legend is None:\n            return\n        self.remove(legend, kind='curve')",
  "def removeImage(self, legend):\n        \"\"\"Remove the image associated to legend from the graph.\n\n        :param str legend: The legend associated to the image to be deleted\n        \"\"\"\n        if legend is None:\n            return\n        self.remove(legend, kind='image')",
  "def removeItem(self, legend):\n        \"\"\"Remove the item associated to legend from the graph.\n\n        :param str legend: The legend associated to the item to be deleted\n        \"\"\"\n        if legend is None:\n            return\n        self.remove(legend, kind='item')",
  "def removeMarker(self, legend):\n        \"\"\"Remove the marker associated to legend from the graph.\n\n        :param str legend: The legend associated to the marker to be deleted\n        \"\"\"\n        if legend is None:\n            return\n        self.remove(legend, kind='marker')",
  "def clear(self):\n        \"\"\"Remove everything from the plot.\"\"\"\n        self.remove()",
  "def clearCurves(self):\n        \"\"\"Remove all the curves from the plot.\"\"\"\n        self.remove(kind='curve')",
  "def clearImages(self):\n        \"\"\"Remove all the images from the plot.\"\"\"\n        self.remove(kind='image')",
  "def clearItems(self):\n        \"\"\"Remove all the items from the plot. \"\"\"\n        self.remove(kind='item')",
  "def clearMarkers(self):\n        \"\"\"Remove all the markers from the plot.\"\"\"\n        self.remove(kind='marker')",
  "def getGraphCursor(self):\n        \"\"\"Returns the state of the crosshair cursor.\n\n        See :meth:`setGraphCursor`.\n\n        :return: None if the crosshair cursor is not active,\n                 else a tuple (color, linewidth, linestyle).\n        \"\"\"\n        return self._cursorConfiguration",
  "def setGraphCursor(self, flag=False, color='black',\n                       linewidth=1, linestyle='-'):\n        \"\"\"Toggle the display of a crosshair cursor and set its attributes.\n\n        :param bool flag: Toggle the display of a crosshair cursor.\n                          The crosshair cursor is hidden by default.\n        :param color: The color to use for the crosshair.\n        :type color: A string (either a predefined color name in Colors.py\n                    or \"#RRGGBB\")) or a 4 columns unsigned byte array\n                    (Default: black).\n        :param int linewidth: The width of the lines of the crosshair\n                    (Default: 1).\n        :param str linestyle: Type of line::\n\n                - ' ' no line\n                - '-' solid line (the default)\n                - '--' dashed line\n                - '-.' dash-dot line\n                - ':' dotted line\n        \"\"\"\n        if flag:\n            self._cursorConfiguration = color, linewidth, linestyle\n        else:\n            self._cursorConfiguration = None\n\n        self._backend.setGraphCursor(flag=flag, color=color,\n                                     linewidth=linewidth, linestyle=linestyle)\n        self._setDirtyPlot()\n        self.notify('setGraphCursor',\n                    state=self._cursorConfiguration is not None)",
  "def pan(self, direction, factor=0.1):\n        \"\"\"Pan the graph in the given direction by the given factor.\n\n        Warning: Pan of right Y axis not implemented!\n\n        :param str direction: One of 'up', 'down', 'left', 'right'.\n        :param float factor: Proportion of the range used to pan the graph.\n                             Must be strictly positive.\n        \"\"\"\n        assert direction in ('up', 'down', 'left', 'right')\n        assert factor > 0.\n\n        if direction in ('left', 'right'):\n            xFactor = factor if direction == 'right' else - factor\n            xMin, xMax = self.getGraphXLimits()\n\n            xMin, xMax = _utils.applyPan(xMin, xMax, xFactor,\n                                         self.isXAxisLogarithmic())\n            self.setGraphXLimits(xMin, xMax)\n\n        else:  # direction in ('up', 'down')\n            sign = -1. if self.isYAxisInverted() else 1.\n            yFactor = sign * (factor if direction == 'up' else -factor)\n            yMin, yMax = self.getGraphYLimits()\n            yIsLog = self.isYAxisLogarithmic()\n\n            yMin, yMax = _utils.applyPan(yMin, yMax, yFactor, yIsLog)\n            self.setGraphYLimits(yMin, yMax, axis='left')\n\n            y2Min, y2Max = self.getGraphYLimits(axis='right')\n\n            y2Min, y2Max = _utils.applyPan(y2Min, y2Max, yFactor, yIsLog)\n            self.setGraphYLimits(y2Min, y2Max, axis='right')",
  "def isActiveCurveHandling(self):\n        \"\"\"Returns True if active curve selection is enabled.\"\"\"\n        return self._activeCurveHandling",
  "def setActiveCurveHandling(self, flag=True):\n        \"\"\"Enable/Disable active curve selection.\n\n        :param bool flag: True (the default) to enable active curve selection.\n        \"\"\"\n        if not flag:\n            self.setActiveCurve(None)  # Reset active curve\n\n        self._activeCurveHandling = bool(flag)",
  "def getActiveCurveColor(self):\n        \"\"\"Get the color used to display the currently active curve.\n\n        See :meth:`setActiveCurveColor`.\n        \"\"\"\n        return self._activeCurveColor",
  "def setActiveCurveColor(self, color=\"#000000\"):\n        \"\"\"Set the color to use to display the currently active curve.\n\n        :param str color: Color of the active curve,\n                          e.g., 'blue', 'b', '#FF0000' (Default: 'black')\n        \"\"\"\n        if color is None:\n            color = \"black\"\n        if color in self.colorDict:\n            color = self.colorDict[color]\n        self._activeCurveColor = color",
  "def getActiveCurve(self, just_legend=False):\n        \"\"\"Return the currently active curve.\n\n        It returns None in case of not having an active curve.\n        Default output has the form: [x, y, legend, info, params]\n        where params is a dictionary containing curve parameters.\n\n        Warning: Returned values MUST not be modified.\n        Make a copy if you need to modify them.\n\n        :param bool just_legend: True to get the legend of the curve,\n                                 False (the default) to get the curve data\n                                 and info.\n        :return: legend of the active curve or [x, y, legend, info, params]\n        :rtype: str or list\n        \"\"\"\n        if not self.isActiveCurveHandling():\n            return None\n\n        if self._activeCurve not in self._curves:\n            self._activeCurve = None\n\n        if self._activeCurve is None:\n            return None\n\n        if just_legend:\n            return self._activeCurve\n        else:\n            curve = self._curves[self._activeCurve]\n            return (curve['x'], curve['y'], self._activeCurve,\n                    curve['params']['info'] or {}, curve['params'])",
  "def setActiveCurve(self, legend, replot=None):\n        \"\"\"Make the curve associated to legend the active curve.\n\n        :param str legend: The legend associated to the curve\n                           or None to have no active curve.\n        \"\"\"\n        if replot is not None:\n            _logger.warning('setActiveCurve deprecated replot parameter')\n\n        if not self.isActiveCurveHandling():\n            return\n\n        xLabel = self._xLabel\n        yLabel = self._yLabel\n\n        oldActiveCurveLegend = self.getActiveCurve(just_legend=True)\n        if oldActiveCurveLegend:  # Reset previous active curve\n            handle = self._curves[oldActiveCurveLegend]['handle']\n            if handle is not None:\n                self._backend.setActiveCurve(handle, False)\n\n        if legend is None:\n            self._activeCurve = None\n        else:\n            legend = str(legend)\n            if legend not in self._curves:\n                _logger.warning(\"This curve does not exist: %s\", legend)\n                self._activeCurve = None\n            else:\n                self._activeCurve = legend\n\n                handle = self._curves[self._activeCurve]['handle']\n                if handle is not None:\n                    self._backend.setActiveCurve(handle, True,\n                                                 self.getActiveCurveColor())\n\n                xLabel = self._curves[self._activeCurve]['params']['xlabel']\n                yLabel = self._curves[self._activeCurve]['params']['ylabel']\n                # TODO y2 axis case\n\n        # Store current labels and update plot\n        self._currentXLabel = xLabel\n        self._backend.setGraphXLabel(xLabel)\n        self._currentYLabel = yLabel\n        self._backend.setGraphYLabel(yLabel, axis='left')  # TODO y2 axis\n\n        self._setDirtyPlot()\n\n        if oldActiveCurveLegend != self._activeCurve:\n            self.notify('activeCurveChanged',\n                        previous=oldActiveCurveLegend,\n                        legend=self._activeCurve)\n\n        return self._activeCurve",
  "def getActiveImage(self, just_legend=False):\n        \"\"\"Returns the currently active image.\n\n        It returns None in case of not having an active image.\n\n        Default output has the form: [data, legend, info, pixmap, params]\n        where params is a dictionnary containing image parameters.\n\n        Warning: Returned values MUST not be modified.\n        Make a copy if you need to modify them.\n\n        :param bool just_legend: True to get the legend of the image,\n                                 False (the default) to get the image data\n                                 and info.\n        :return: legend of active image or [data, legend, info, pixmap, params]\n        :rtype: str or list\n        \"\"\"\n        if self._activeImage not in self._images:\n            self._activeImage = None\n\n        if just_legend:\n            return self._activeImage\n\n        if self._activeImage is None:\n            return None\n        else:\n            image = self._images[self._activeImage]\n            return (image['data'], self._activeImage,\n                    image['params']['info'] or {}, image['pixmap'],\n                    image['params'])",
  "def setActiveImage(self, legend, replot=None):\n        \"\"\"Make the image associated to legend the active image.\n\n        :param str legend: The legend associated to the image\n                           or None to have no active image.\n        \"\"\"\n        if replot is not None:\n            _logger.warning('setActiveImage deprecated replot parameter')\n\n        if legend is None:\n            self._activeImage = None\n        else:\n            legend = str(legend)\n            if legend not in self._images:\n                _logger.warning(\n                    \"setActiveImage: This image does not exist: %s\", legend)\n                self._activeImage = None\n            else:\n                self._activeImage = legend\n\n        return self._activeImage",
  "def getAllCurves(self, just_legend=False, withhidden=False):\n        \"\"\"Returns all curves legend or info and data.\n\n        It returns an empty list in case of not having any curve.\n\n        If just_legend is False, it returns a list of the form:\n            [[xvalues0, yvalues0, legend0, info0, params0],\n             [xvalues1, yvalues1, legend1, info1, params1],\n             [...],\n             [xvaluesn, yvaluesn, legendn, infon, paramsn]]\n        If just_legend is True, it returns a list of the form:\n            [legend0, legend1, ..., legendn]\n\n        Warning: Returned values MUST not be modified.\n        Make a copy if you need to modify them.\n\n        :param bool just_legend: True to get the legend of the curves,\n                                 False (the default) to get the curves' data\n                                 and info.\n        :param bool withhidden: False (default) to skip hidden curves.\n        :return: list of legends or list of [x, y, legend, info, params]\n        :rtype: list of str or list of list\n        \"\"\"\n        output = []\n        for key in self._curves:\n            if not withhidden and self.isCurveHidden(key):\n                continue\n            if just_legend:\n                output.append(key)\n            else:\n                curve = self._curves[key]\n                output.append((curve['x'], curve['y'], key,\n                               curve['params']['info'] or {}, curve['params']))\n        return output",
  "def getCurve(self, legend):\n        \"\"\"Return the data and info of a specific curve.\n\n        It returns None in case of not having the curve.\n\n        Warning: Returned values MUST not be modified.\n        Make a copy if you need to modify them.\n\n        :param str legend: legend associated to the curve\n        :return: None or list [x, y, legend, parameters]\n        \"\"\"\n        if legend in self._curves:\n            curve = self._curves[legend]\n            return (curve['x'], curve['y'], legend,\n                    curve['params']['info'] or {}, curve['params'])\n        else:\n            return None",
  "def getImage(self, legend):\n        \"\"\"Return the data and info of a specific image.\n\n        It returns None in case of not having an active curve.\n\n        Warning: Returned values MUST not be modified.\n        Make a copy if you need to modify them.\n\n        :param str legend: legend associated to the curve\n        :return: None or list [image, legend, info, pixmap, params]\n        \"\"\"\n        if legend in self._images:\n            image = self._images[legend]\n            return (image['data'], legend, image['params']['info'] or {},\n                    image['pixmap'], image['params'])\n        else:\n            return None",
  "def _notifyLimitsChanged(self):\n        \"\"\"Send an event when plot area limits are changed.\"\"\"\n        xRange = self.getGraphXLimits()\n        yRange = self.getGraphYLimits(axis='left')\n        y2Range = self.getGraphYLimits(axis='right')\n        event = PlotEvents.prepareLimitsChangedSignal(\n            id(self.getWidgetHandle()), xRange, yRange, y2Range)\n        self.notify(**event)",
  "def getGraphXLimits(self):\n        \"\"\"Get the graph X (bottom) limits.\n\n        :return: Minimum and maximum values of the X axis\n        \"\"\"\n        return self._backend.getGraphXLimits()",
  "def setGraphXLimits(self, xmin, xmax, replot=None):\n        \"\"\"Set the graph X (bottom) limits.\n\n        :param float xmin: minimum bottom axis value\n        :param float xmax: maximum bottom axis value\n        \"\"\"\n        if replot is not None:\n            _logger.warning('setGraphXLimits deprecated replot parameter')\n\n        self._backend.setGraphXLimits(xmin, xmax)\n        self._setDirtyPlot()\n\n        self._notifyLimitsChanged()",
  "def getGraphYLimits(self, axis='left'):\n        \"\"\"Get the graph Y limits.\n\n        :param str axis: The axis for which to get the limits:\n                         Either 'left' or 'right'\n        :return: Minimum and maximum values of the X axis\n        \"\"\"\n        assert axis in ('left', 'right')\n        return self._backend.getGraphYLimits(axis)",
  "def setGraphYLimits(self, ymin, ymax, axis='left', replot=None):\n        \"\"\"Set the graph Y limits.\n\n        :param float xmin: minimum bottom axis value\n        :param float xmax: maximum bottom axis value\n        :param str axis: The axis for which to get the limits:\n                         Either 'left' or 'right'\n        \"\"\"\n        if replot is not None:\n            _logger.warning('setGraphYLimits deprecated replot parameter')\n\n        assert axis in ('left', 'right')\n        self._backend.setGraphYLimits(ymin, ymax, axis)\n        self._setDirtyPlot()\n\n        self._notifyLimitsChanged()",
  "def setLimits(self, xmin, xmax, ymin, ymax, y2min=None, y2max=None):\n        \"\"\"Set the limits of the X and Y axes at once.\n\n        If y2min or y2max is None, the right Y axis limits are not updated.\n\n        :param float xmin: minimum bottom axis value\n        :param float xmax: maximum bottom axis value\n        :param float ymin: minimum left axis value\n        :param float ymax: maximum left axis value\n        :param float y2min: minimum right axis value or None (the default)\n        :param float y2max: maximum right axis value or None (the default)\n        \"\"\"\n        if xmax < xmin:\n            xmin, xmax = xmax, xmin\n        if ymax < ymin:\n            ymin, ymax = ymax, ymin\n\n        if y2min is None or y2max is None:\n            # if one limit is None, both are ignored\n            y2min, y2max = None, None\n        elif y2max < y2min:\n                y2min, y2max = y2max, y2min\n\n        self._backend.setLimits(xmin, xmax, ymin, ymax, y2min, y2max)\n        self._setDirtyPlot()\n        self._notifyLimitsChanged()",
  "def getGraphTitle(self):\n        \"\"\"Return the plot main title as a str.\"\"\"\n        return self._graphTitle",
  "def setGraphTitle(self, title=\"\"):\n        \"\"\"Set the plot main title.\n\n        :param str title: Main title of the plot (default: '')\n        \"\"\"\n        self._graphTitle = str(title)\n        self._backend.setGraphTitle(title)\n        self._setDirtyPlot()",
  "def getGraphXLabel(self):\n        \"\"\"Return the current X axis label as a str.\"\"\"\n        return self._currentXLabel",
  "def setGraphXLabel(self, label=\"X\"):\n        \"\"\"Set the plot X axis label.\n\n        The provided label can be temporarily replaced by the X label of the\n        active curve if any.\n\n        :param str label: The X axis label (default: 'X')\n        \"\"\"\n        self._xLabel = label\n        # Current label can differ from input one with active curve handling\n        self._currentXLabel = label\n        self._backend.setGraphXLabel(label)\n        self._setDirtyPlot()",
  "def getGraphYLabel(self):\n        \"\"\"Return the current Y axis label as a str.\"\"\"\n        return self._currentYLabel",
  "def setGraphYLabel(self, label=\"Y\"):\n        \"\"\"Set the plot Y axis label.\n\n        The provided label can be temporarily replaced by the Y label of the\n        active curve if any.\n\n        :param str label: The Y axis label (default: 'Y')\n        \"\"\"\n        self._yLabel = label\n        # Current label can differ from input one with active curve handling\n        self._currentYLabel = label\n        self._backend.setGraphYLabel(label, axis='left')\n        self._setDirtyPlot()",
  "def setYAxisInverted(self, flag=True):\n        \"\"\"Set the Y axis orientation.\n\n        :param bool flag: True for Y axis going from top to bottom,\n                          False for Y axis going from bottom to top\n        \"\"\"\n        flag = bool(flag)\n        self._backend.setYAxisInverted(flag)\n        self._setDirtyPlot()\n        self.notify('setYAxisInverted', state=flag)",
  "def isYAxisInverted(self):\n        \"\"\"Return True if Y axis goes from top to bottom, False otherwise.\"\"\"\n        return self._backend.isYAxisInverted()",
  "def isXAxisLogarithmic(self):\n        \"\"\"Return True if X axis scale is logarithmic, False if linear.\"\"\"\n        return self._logX",
  "def setXAxisLogarithmic(self, flag):\n        \"\"\"Set the bottom X axis scale (either linear or logarithmic).\n\n        :param bool flag: True to use a logarithmic scale, False for linear.\n        \"\"\"\n        if bool(flag) == self._logX:\n            return\n        self._logX = bool(flag)\n\n        if self._logX:  # Switch to log scale\n            for image in self._images.values():\n                if image['handle'] is not None:\n                    self._backend.remove(image['handle'])\n                    image['handle'] = None\n\n            for curve in self._curves.values():\n                handle = curve['handle']\n                if handle is not None:\n                    self._backend.remove(handle)\n                    curve['handle'] = None\n\n            # matplotlib 1.5 crashes if the log set is made before\n            # the call to self._update()\n            # TODO: Decide what is better for other backends\n            if (hasattr(self._backend, \"matplotlibVersion\") and\n                    self._backend.matplotlibVersion >= \"1.5\"):\n                self._update()\n                self._backend.setXAxisLogarithmic(self._logX)\n            else:\n                self._backend.setXAxisLogarithmic(self._logX)\n                self._update()\n        else:\n                self._backend.setXAxisLogarithmic(self._logX)\n                self._update()\n\n        self._setDirtyPlot()\n        self.resetZoom()\n        self.notify('setXAxisLogarithmic', state=self._logX)",
  "def isYAxisLogarithmic(self):\n        \"\"\"Return True if Y axis scale is logarithmic, False if linear.\"\"\"\n        return self._logY",
  "def setYAxisLogarithmic(self, flag):\n        \"\"\"Set the Y axes scale (either linear or logarithmic).\n\n        :param bool flag: True to use a logarithmic scale, False for linear.\n        \"\"\"\n        if bool(flag) == self._logY:\n            return\n        self._logY = bool(flag)\n\n        if self._logY:  # Switch to log scale\n            for image in self._images.values():\n                if image['handle'] is not None:\n                    self._backend.remove(image['handle'])\n                    image['handle'] = None\n\n            for curve in self._curves.values():\n                handle = curve['handle']\n                if handle is not None:\n                    self._backend.remove(handle)\n                    curve['handle'] = None\n\n            # matplotlib 1.5 crashes if the log set is made before\n            # the call to self._update()\n            # TODO: Decide what is better for other backends\n            if (hasattr(self._backend, \"matplotlibVersion\") and\n                    self._backend.matplotlibVersion >= \"1.5\"):\n                self._update()\n                self._backend.setYAxisLogarithmic(self._logY)\n            else:\n                self._backend.setYAxisLogarithmic(self._logY)\n                self._update()\n        else:\n                self._backend.setYAxisLogarithmic(self._logY)\n                self._update()\n\n        self._setDirtyPlot()\n        self.resetZoom()\n        self.notify('setYAxisLogarithmic', state=self._logY)",
  "def isXAxisAutoScale(self):\n        \"\"\"Return True if X axis is automatically adjusting its limits.\"\"\"\n        return self._xAutoScale",
  "def setXAxisAutoScale(self, flag=True):\n        \"\"\"Set the X axis limits adjusting behavior of :meth:`resetZoom`.\n\n        :param bool flag: True to resize limits automatically,\n                          False to disable it.\n        \"\"\"\n        self._xAutoScale = bool(flag)\n        self.notify('setXAxisAutoScale', state=self._xAutoScale)",
  "def isYAxisAutoScale(self):\n        \"\"\"Return True if Y axes are automatically adjusting its limits.\"\"\"\n        return self._yAutoScale",
  "def setYAxisAutoScale(self, flag=True):\n        \"\"\"Set the Y axis limits adjusting behavior of :meth:`resetZoom`.\n\n        :param bool flag: True to resize limits automatically,\n                          False to disable it.\n        \"\"\"\n        self._yAutoScale = bool(flag)\n        self.notify('setYAxisAutoScale', state=self._yAutoScale)",
  "def isKeepDataAspectRatio(self):\n        \"\"\"Returns whether the plot is keeping data aspect ratio or not.\"\"\"\n        return self._backend.isKeepDataAspectRatio()",
  "def setKeepDataAspectRatio(self, flag=True):\n        \"\"\"Set whether the plot keeps data aspect ratio or not.\n\n        :param bool flag: True to respect data aspect ratio\n        \"\"\"\n        flag = bool(flag)\n        self._backend.setKeepDataAspectRatio(flag=flag)\n        self._setDirtyPlot()\n        self.resetZoom()\n        self.notify('setKeepDataAspectRatio', state=flag)",
  "def getGraphGrid(self):\n        \"\"\"Return the current grid mode, either None, 'major' or 'both'.\n\n        See :meth:`setGraphGrid`.\n        \"\"\"\n        return self._grid",
  "def setGraphGrid(self, which=True):\n        \"\"\"Set the type of grid to display.\n\n        :param which: None or False to disable the grid,\n                      'major' or True for grid on major ticks (the default),\n                      'both' for grid on both major and minor ticks.\n        :type which: str of bool\n        \"\"\"\n        assert which in (None, True, False, 'both', 'major')\n        if not which:\n            which = None\n        elif which is True:\n            which = 'major'\n        self._grid = which\n        self._backend.setGraphGrid(which)\n        self._setDirtyPlot()\n        self.notify('setGraphGrid', which=str(which))",
  "def isDefaultPlotPoints(self):\n        \"\"\"Return True if default Curve symbol is 'o', False for no symbol.\"\"\"\n        return self._defaultPlotPoints == 'o'",
  "def setDefaultPlotPoints(self, flag):\n        \"\"\"Set the default symbol of all curves.\n\n        When called, this reset the symbol of all existing curves.\n\n        :param bool flag: True to use 'o' as the default curve symbol,\n                          False to use no symbol.\n        \"\"\"\n        self._defaultPlotPoints = 'o' if flag else ''\n\n        # Reset symbol of all curves\n        for curve in self._curves.values():\n            curve['params']['symbol'] = self._defaultPlotPoints\n\n        if self._curves:\n            self._update()\n            self._setDirtyPlot()",
  "def isDefaultPlotLines(self):\n        \"\"\"Return True for line as default line style, False for no line.\"\"\"\n        return self._plotLines",
  "def setDefaultPlotLines(self, flag):\n        \"\"\"Toggle the use of lines as the default curve line style.\n\n        :param bool flag: True to use a line as the default line style,\n                          False to use no line as the default line style.\n        \"\"\"\n        self._plotLines = bool(flag)\n\n        # Reset linestyle of all curves\n        for curve in self._curves.values():\n            curve['params']['linestyle'] = '-' if self._plotLines else ' '\n\n        if self._curves:\n            self._update()\n            self._setDirtyPlot()",
  "def getDefaultColormap(self):\n        \"\"\"Return the default colormap used by :meth:`addImage` as a dict.\n\n        See :mod:`Plot` for the documentation of the colormap dict.\n        \"\"\"\n        return self._defaultColormap.copy()",
  "def setDefaultColormap(self, colormap=None):\n        \"\"\"Set the default colormap used by :meth:`addImage`.\n\n        :param dict colormap: The description of the default colormap, or\n                            None to set the colormap to a linear autoscale\n                            gray colormap.\n                            See :mod:`Plot` for the documentation\n                            of the colormap dict.\n        \"\"\"\n        if colormap is None:\n            colormap = {'name': 'gray', 'normalization': 'linear',\n                        'autoscale': True, 'vmin': 0.0, 'vmax': 1.0,\n                        'colors': 256}\n        self._defaultColormap = colormap.copy()",
  "def getSupportedColormaps(self):\n        \"\"\"Get the supported colormap names as a tuple of str.\n\n        The list should at least contain and start by:\n        ('gray', 'reversed gray', 'temperature', 'red', 'green', 'blue')\n        \"\"\"\n        return self._backend.getSupportedColormaps()",
  "def _getColorAndStyle(self):\n        color = self.colorList[self._colorIndex]\n        style = self._styleList[self._styleIndex]\n\n        # Loop over color and then styles\n        self._colorIndex += 1\n        if self._colorIndex >= len(self.colorList):\n            self._colorIndex = 0\n            self._styleIndex = (self._styleIndex + 1) % len(self._styleList)\n\n        # If color is the one of active curve, take the next one\n        if color == self.getActiveCurveColor():\n            color, style = self._getColorAndStyle()\n\n        if not self._plotLines:\n            style = ' '\n\n        return color, style",
  "def getWidgetHandle(self):\n        \"\"\"Return the widget the plot is displayed in.\n\n        This widget is owned by the backend.\n        \"\"\"\n        return self._backend.getWidgetHandle()",
  "def notify(self, event, **kwargs):\n        \"\"\"Send an event to the listeners.\n\n        Event are passed to the registered callback as a dict with an 'event'\n        key for backward compatibility with PyMca.\n\n        :param str event: The type of event\n        :param kwargs: The information of the event.\n        \"\"\"\n        eventDict = kwargs.copy()\n        eventDict['event'] = event\n        self._callback(eventDict)",
  "def setCallback(self, callbackFunction=None):\n        \"\"\"Attach a listener to the backend.\n\n        Limitation: Only one listener at a time.\n\n        :param callbackFunction: function accepting a dictionnary as input\n                                 to handle the graph events\n                                 If None (default), use a default listener.\n        \"\"\"\n        # TODO allow multiple listeners, keep a weakref on it\n        # allow register listener by event type\n        if callbackFunction is None:\n            callbackFunction = self.graphCallback\n        self._callback = callbackFunction",
  "def graphCallback(self, ddict=None):\n        \"\"\"This callback is going to receive all the events from the plot.\n\n        Those events will consist on a dictionnary and among the dictionnary\n        keys the key 'event' is mandatory to describe the type of event.\n        This default implementation only handles setting the active curve.\n        \"\"\"\n\n        if ddict is None:\n            ddict = {}\n        _logger.debug(\"Received dict keys = %s\", str(ddict.keys()))\n        _logger.debug(str(ddict))\n        if ddict['event'] in [\"legendClicked\", \"curveClicked\"]:\n            if ddict['button'] == \"left\":\n                self.setActiveCurve(ddict['label'])",
  "def saveGraph(self, filename, fileFormat=None, dpi=None, **kw):\n        \"\"\"Save a snapshot of the plot.\n\n        Supported file formats: \"png\", \"svg\", \"pdf\", \"ps\", \"eps\",\n        \"tif\", \"tiff\", \"jpeg\", \"jpg\".\n\n        :param filename: Destination\n        :type filename: str, StringIO or BytesIO\n        :param str fileFormat:  String specifying the format\n        :return: False if cannot save the plot, True otherwise\n        \"\"\"\n        if kw:\n            _logger.warning('Extra parameters ignored: %s', str(kw))\n\n        if fileFormat is None:\n            if not hasattr(filename, 'lower'):\n                _logger.warning(\n                    'saveGraph cancelled, cannot define file format.')\n                return False\n            else:\n                fileFormat = (filename.split(\".\")[-1]).lower()\n\n        supportedFormats = (\"png\", \"svg\", \"pdf\", \"ps\", \"eps\",\n                            \"tif\", \"tiff\", \"jpeg\", \"jpg\")\n\n        if fileFormat not in supportedFormats:\n            _logger.warning('Unsupported format %s', fileFormat)\n            return False\n        else:\n            self._backend.saveGraph(filename,\n                                    fileFormat=fileFormat,\n                                    dpi=dpi)\n            return True",
  "def getDataMargins(self):\n        \"\"\"Get the default data margin ratios, see :meth:`setDataMargins`.\n\n        :return: The margin ratios for each side (xMin, xMax, yMin, yMax).\n        :rtype: A 4-tuple of floats.\n        \"\"\"\n        return self._defaultDataMargins",
  "def setDataMargins(self, xMinMargin=0., xMaxMargin=0.,\n                       yMinMargin=0., yMaxMargin=0.):\n        \"\"\"Set the default data margins to use in :meth:`resetZoom`.\n\n        Set the default ratios of margins (as floats) to add around the data\n        inside the plot area for each side.\n        \"\"\"\n        self._defaultDataMargins = (xMinMargin, xMaxMargin,\n                                    yMinMargin, yMaxMargin)",
  "def getAutoReplot(self):\n        \"\"\"Return True if replot is automatically handled, False otherwise.\n\n        See :meth`setAutoReplot`.\n        \"\"\"\n        return self._autoreplot",
  "def setAutoReplot(self, autoreplot=True):\n        \"\"\"Set automatic replot mode.\n\n        When enabled, the plot is redrawn automatically when changed.\n        When disabled, the plot is not redrawn when its content change.\n        Instead, it :meth:`replot` must be called.\n\n        :param bool autoreplot: True to enable it (default),\n                                False to disable it.\n        \"\"\"\n        self._autoreplot = bool(autoreplot)\n\n        # If the plot is dirty before enabling autoreplot,\n        # then _backend.postRedisplay will never be called from _setDirtyPlot\n        if self._autoreplot and self._getDirtyPlot():\n            self._backend.postRedisplay()",
  "def replot(self):\n        \"\"\"Redraw the plot immediately.\"\"\"\n        self._backend.replot()\n        self._dirty = False",
  "def resetZoom(self, dataMargins=None):\n        \"\"\"Reset the plot limits to the bounds of the data and redraw the plot.\n\n        It automatically scale limits of axes that are in autoscale mode\n        (See :meth:`setXAxisAutoScale`, :meth:`setYAxisAutoScale`).\n        It keeps current limits on axes that are not in autoscale mode.\n\n        Extra margins can be added around the data inside the plot area.\n        Margins are given as one ratio of the data range per limit of the\n        data (xMin, xMax, yMin and yMax limits).\n        For log scale, extra margins are applied in log10 of the data.\n\n        :param dataMargins: Ratios of margins to add around the data inside\n                            the plot area for each side (Default: no margins).\n        :type dataMargins: A 4-tuple of float as (xMin, xMax, yMin, yMax).\n        \"\"\"\n        if dataMargins is None:\n            dataMargins = self._defaultDataMargins\n\n        xlim = self.getGraphXLimits()\n        ylim = self.getGraphYLimits(axis='left')\n        y2lim = self.getGraphYLimits(axis='right')\n\n        self._backend.resetZoom(dataMargins)\n        self._setDirtyPlot()\n\n        if (xlim != self.getGraphXLimits() or\n                ylim != self.getGraphYLimits(axis='left') or\n                y2lim != self.getGraphYLimits(axis='right')):\n            self._notifyLimitsChanged()",
  "def _logFilterData(x, y, color, xerror, yerror, xLog, yLog):\n        \"\"\"Filter out values with x or y <= 0 on log axes\n\n        All arrays are expected to have the same length.\n\n        :param x: The x coords.\n        :param y: The y coords.\n        :param color: The addCurve color arg (might not be an array).\n        :param xerror: The addCuve xerror arg (might not be an array).\n        :param yerror: The addCuve yerror arg (might not be an array).\n        :param bool xLog: True to filter arrays according to X coords.\n        :param bool yLog: True to filter arrays according to Y coords.\n        :return: The filter arrays or unchanged object if\n        :rtype: (x, y, color, xerror, yerror)\n        \"\"\"\n        if xLog and yLog:\n            idx = numpy.nonzero((x > 0) & (y > 0))[0]\n        elif yLog:\n            idx = numpy.nonzero(y > 0)[0]\n        elif xLog:\n            idx = numpy.nonzero(x > 0)[0]\n        else:\n            return x, y, color, xerror, yerror\n\n        x = numpy.take(x, idx)\n        y = numpy.take(y, idx)\n\n        if isinstance(color, numpy.ndarray) and len(color) == len(x):\n            # Nx(3 or 4) array (do not change RGBA color defined as an array)\n            color = numpy.take(color, idx, axis=0)\n\n        if isinstance(xerror, numpy.ndarray):\n            if len(xerror) == len(x):\n                # N or Nx1 array\n                xerror = numpy.take(xerror, idx, axis=0)\n            elif len(xerror) == 2 and len(xerror.shape) == 2:\n                # 2xN array (+/- error)\n                xerror = xerror[:, idx]\n\n        if isinstance(yerror, numpy.ndarray):\n            if len(yerror) == len(y):\n                # N or Nx1 array\n                yerror = numpy.take(yerror, idx, axis=0)\n            elif len(yerror) == 2 and len(yerror.shape) == 2:\n                # 2xN array (+/- error)\n                yerror = yerror[:, idx]\n\n        return x, y, color, xerror, yerror",
  "def _update(self):\n        _logger.debug(\"_update called\")\n\n        # curves\n        activeCurve = self.getActiveCurve(just_legend=True)\n        curves = list(self._curves)\n        for legend in curves:\n            curve = self._curves[legend]\n            self.addCurve(curve['x'], curve['y'], legend, resetzoom=False,\n                          **curve['params'])\n\n        if len(curves):\n            if activeCurve not in curves:\n                activeCurve = curves[0]\n        else:\n            activeCurve = None\n        self.setActiveCurve(activeCurve)\n\n        # images\n        if not self.isXAxisLogarithmic() and not self.isYAxisLogarithmic():\n            for legend in list(self._images):  # Copy has images is changed\n                image = self._images[legend]\n                self.addImage(image['data'], legend,\n                              replace=False, rezetZoom=False,\n                              pixmap=image['pixmap'], **image['params'])",
  "def dataToPixel(self, x=None, y=None, axis=\"left\"):\n        \"\"\"Convert a position in data coordinates to a position in pixels.\n\n        :param float x: The X coordinate in data space. If None (default)\n                        the middle position of the displayed data is used.\n        :param float y: The Y coordinate in data space. If None (default)\n                        the middle position of the displayed data is used.\n        :param str axis: The Y axis to use for the conversion\n                         ('left' or 'right').\n        :returns: The corresponding position in pixels or\n                  None if the data position is not in the displayed area.\n        :rtype: A tuple of 2 floats: (xPixel, yPixel) or None.\n        \"\"\"\n        assert axis in (\"left\", \"right\")\n\n        xmin, xmax = self.getGraphXLimits()\n        ymin, ymax = self.getGraphYLimits(axis=axis)\n\n        if x is None:\n            x = 0.5 * (xmax - xmin)\n        if y is None:\n            y = 0.5 * (ymax - ymin)\n\n        if x > xmax or x < xmin:\n            return None\n\n        if y > ymax or y < ymin:\n            return None\n\n        return self._backend.dataToPixel(x, y, axis=axis)",
  "def pixelToData(self, x, y, axis=\"left\", check=False):\n        \"\"\"Convert a position in pixels to a position in data coordinates.\n\n        :param float x: The X coordinate in pixels. If None (default)\n                            the center of the widget is used.\n        :param float y: The Y coordinate in pixels. If None (default)\n                            the center of the widget is used.\n        :param str axis: The Y axis to use for the conversion\n                         ('left' or 'right').\n        :param bool check: Toggle checking if pixel is in plot area.\n                           If False, this method never returns None.\n        :returns: The corresponding position in data space or\n                  None if the pixel position is not in the plot area.\n        :rtype: A tuple of 2 floats: (xData, yData) or None.\n        \"\"\"\n        assert axis in (\"left\", \"right\")\n        return self._backend.pixelToData(x, y, axis=axis, check=check)",
  "def getPlotBoundsInPixels(self):\n        \"\"\"Plot area bounds in widget coordinates in pixels.\n\n        :return: bounds as a 4-tuple of int: (left, top, width, height)\n        \"\"\"\n        return self._backend.getPlotBoundsInPixels()",
  "def setGraphCursorShape(self, cursor=None):\n        \"\"\"Set the cursor shape.\n\n        :param str cursor: Name of the cursor shape\n        \"\"\"\n        self._backend.setGraphCursorShape(cursor)",
  "def _pickMarker(self, x, y, test=None):\n        \"\"\"Pick a marker at the given position.\n\n        To use for interaction implementation.\n\n        :param float x: X position in pixels.\n        :param float y: Y position in pixels.\n        :param test: A callable to call for each picked marker to filter\n                     picked markers. If None (default), do not filter markers.\n        \"\"\"\n        if test is None:\n            test = lambda marker: True\n\n        markers = self._backend.pickItems(x, y)\n        markers = [item for item in markers if item['kind'] == 'marker']\n\n        for item in reversed(markers):\n            legend = item['legend']\n            params = self._getMarker(legend)\n            if params is not None and test(params):\n                params['legend'] = legend\n                return params\n        return None",
  "def _moveMarker(self, legend, x, y):\n        \"\"\"Move a marker to a position.\n\n        To use for interaction implementation.\n\n        :param str legend: The legend associated to the marker.\n        :param float x: The new X position of the marker in data coordinates.\n        :param float y: The new Y position of the marker in data coordinates.\n        \"\"\"\n        params = self._getMarker(legend)\n        if params is not None:\n            if params['x'] is not None:\n                params['x'] = x\n            if params['y'] is not None:\n                params['y'] = y\n            self._addMarker(**params)",
  "def _getMarker(self, legend):\n        \"\"\"Get the parameters of a marker\n\n        :param str legend: The legend of the marker to retrieve\n        :return: A copy of the parameters the marker has been created with\n        :rtype: dict or None if marker does not exist\n        \"\"\"\n        marker = self._markers.get(legend, None)\n        if marker is None:\n            return None\n        else:\n            # Return a shallow copy\n            params = marker['params'].copy()\n            params['legend'] = legend\n            return params",
  "def _pickImageOrCurve(self, x, y, test=None):\n        \"\"\"Pick an image or a curve at the given position.\n\n        To use for interaction implementation.\n\n        :param float x: X position in pixels.\n        :param float y: Y position in pixels.\n        :param test: A callable to call for each picked item to filter\n                     picked items. If None (default), do not filter items.\n        \"\"\"\n        if test is None:\n            test = lambda item: True\n\n        items = self._backend.pickItems(x, y)\n        items = [item for item in items if item['kind'] in ['curve', 'image']]\n\n        for item in reversed(items):\n            kind, legend = item['kind'], item['legend']\n            if kind == 'curve':\n                curve = self._curves.get(legend, None)\n                if curve is not None:\n                    params = curve['params'].copy()  # shallow copy\n                    if test(params):\n                        params['legend'] = legend\n                        return kind, params, item['xdata'], item['ydata']\n\n            elif kind == 'image':\n                image = self._images.get(legend, None)\n                if image is not None:\n                    params = image['params'].copy()  # shallow copy\n                    if test(params):\n                        params['legend'] = legend\n                        return kind, params, None\n\n            else:\n                _logger.warning('Unsupported kind: %s', kind)\n\n        return None",
  "def _moveImage(self, legend, dx, dy):\n        \"\"\"Move an image to a position.\n\n        To use for interaction implementation.\n\n        :param str legend: The legend associated to the image.\n        :param float dx: The X offset to apply to the image in data coords.\n        :param float dy: The Y offset to apply to the image in data coords.\n        \"\"\"\n        # TODO: poor implementation, better to do move image in backend...\n        image = self._images[legend]\n        params = image['params'].copy()\n        params['origin'] = params['origin'][0] + dx, params['origin'][1] + dy\n        self.addImage(image['data'], legend,\n                      replace=False, resetzoom=False,\n                      pixmap=image['pixmap'], **params)",
  "def _isPositionInPlotArea(self, x, y):\n        \"\"\"Project position in pixel to the closest point in the plot area\n\n        :param float x: X coordinate in widget coordinate (in pixel)\n        :param float y: Y coordinate in widget coordinate (in pixel)\n        :return: (x, y) in widget coord (in pixel) in the plot area\n        \"\"\"\n        left, top, width, height = self.getPlotBoundsInPixels()\n        xPlot = _utils.clamp(x, left, left + width)\n        yPlot = _utils.clamp(y, top, top + height)\n        return xPlot, yPlot",
  "def onMousePress(self, xPixel, yPixel, btn):\n        \"\"\"Handle mouse press event.\n\n        :param float xPixel: X mouse position in pixels\n        :param float yPixel: Y mouse position in pixels\n        :param str btn: Mouse button in 'left', 'middle', 'right'\n        \"\"\"\n        if self._isPositionInPlotArea(xPixel, yPixel) == (xPixel, yPixel):\n            self._pressedButtons.append(btn)\n            self._eventHandler.handleEvent('press', xPixel, yPixel, btn)",
  "def onMouseMove(self, xPixel, yPixel):\n        \"\"\"Handle mouse move event.\n\n        :param float xPixel: X mouse position in pixels\n        :param float yPixel: Y mouse position in pixels\n        \"\"\"\n        inXPixel, inYPixel = self._isPositionInPlotArea(xPixel, yPixel)\n        isCursorInPlot = inXPixel == xPixel and inYPixel == yPixel\n\n        if isCursorInPlot:\n            # Signal mouse move event\n            dataPos = self.pixelToData(inXPixel, inYPixel)\n            assert dataPos is not None\n\n            btn = self._pressedButtons[-1] if self._pressedButtons else None\n            event = PlotEvents.prepareMouseSignal(\n                'mouseMoved', btn, dataPos[0], dataPos[1], xPixel, yPixel)\n            self.notify(**event)\n\n        # Either button was pressed in the plot or cursor is in the plot\n        if isCursorInPlot or self._pressedButtons:\n            self._eventHandler.handleEvent('move', inXPixel, inYPixel)",
  "def onMouseRelease(self, xPixel, yPixel, btn):\n        \"\"\"Handle mouse release event.\n\n        :param float xPixel: X mouse position in pixels\n        :param float yPixel: Y mouse position in pixels\n        :param str btn: Mouse button in 'left', 'middle', 'right'\n        \"\"\"\n        try:\n            self._pressedButtons.remove(btn)\n        except ValueError:\n            pass\n        else:\n            xPixel, yPixel = self._isPositionInPlotArea(xPixel, yPixel)\n            self._eventHandler.handleEvent('release', xPixel, yPixel, btn)",
  "def onMouseWheel(self, xPixel, yPixel, angleInDegrees):\n        \"\"\"Handle mouse wheel event.\n\n        :param float xPixel: X mouse position in pixels\n        :param float yPixel: Y mouse position in pixels\n        :param float angleInDegrees: Angle corresponding to wheel motion.\n                                     Positive for movement away from the user,\n                                     negative for movement toward the user.\n        \"\"\"\n        if self._isPositionInPlotArea(xPixel, yPixel) == (xPixel, yPixel):\n            self._eventHandler.handleEvent(\n                'wheel', xPixel, yPixel, angleInDegrees)",
  "def getInteractiveMode(self):\n        \"\"\"Returns the current interactive mode as a dict.\n\n        The returned dict contains at least the key 'mode'.\n        Mode can be: 'draw', 'pan', 'select', 'zoom'.\n        It can also contains extra keys (e.g., 'color') specific to a mode\n        as provided to :meth:`setInteractiveMode`.\n        \"\"\"\n        return self._eventHandler.getInteractiveMode()",
  "def setInteractiveMode(self, mode, color='black',\n                           shape='polygon', label=None,\n                           zoomOnWheel=True):\n        \"\"\"Switch the interactive mode.\n\n        :param str mode: The name of the interactive mode.\n                         In 'draw', 'pan', 'select', 'zoom'.\n        :param color: Only for 'draw' and 'zoom' modes.\n                      Color to use for drawing selection area. Default black.\n        :type color: Color description: The name as a str or\n                     a tuple of 4 floats.\n        :param str shape: Only for 'draw' mode. The kind of shape to draw.\n                          In 'polygon', 'rectangle', 'line', 'vline', 'hline'.\n                          Default is 'polygon'.\n        :param str label: Only for 'draw' mode, sent in drawing events.\n        :param bool zoomOnWheel: Toggle zoom on wheel support\n        \"\"\"\n        self._eventHandler.setInteractiveMode(mode, color, shape, label)\n        self._eventHandler.zoomOnWheel = zoomOnWheel",
  "def isDrawModeEnabled(self):\n        \"\"\"Deprecated, use :meth:`getInteractiveMode` instead.\n\n        Return True if the current interactive state is drawing.\"\"\"\n        _logger.warning(\n            'isDrawModeEnabled deprecated, use getInteractiveMode instead')\n        return self.getInteractiveMode()['mode'] == 'draw'",
  "def setDrawModeEnabled(self, flag=True, shape='polygon', label=None,\n                           color=None, **kwargs):\n        \"\"\"Deprecated, use :meth:`setInteractiveMode` instead.\n\n        Set the drawing mode if flag is True and its parameters.\n\n        If flag is False, only item selection is enabled.\n\n        Warning: Zoom and drawing are not compatible and cannot be enabled\n        simultanelously.\n\n        :param bool flag: True to enable drawing and disable zoom and select.\n        :param str shape: Type of item to be drawn in:\n                          hline, vline, rectangle, polygon (default)\n        :param str label: Associated text for identifying draw signals\n        :param color: The color to use to draw the selection area\n        :type color: string (\"#RRGGBB\") or 4 column unsigned byte array or\n                     one of the predefined color names defined in Colors.py\n        \"\"\"\n        _logger.warning(\n            'setDrawModeEnabled deprecated, use setInteractiveMode instead')\n\n        if kwargs:\n            _logger.warning('setDrawModeEnabled ignores additional parameters')\n\n        if color is None:\n            color = 'black'\n\n        if flag:\n            self.setInteractiveMode('draw', shape=shape,\n                                    label=label, color=color)\n        elif self.getInteractiveMode()['mode'] == 'draw':\n            self.setInteractiveMode('select')",
  "def getDrawMode(self):\n        \"\"\"Deprecated, use :meth:`getInteractiveMode` instead.\n\n        Return the draw mode parameters as a dict of None.\n\n        It returns None if the interactive moed is not a drawing mode,\n        otherwise, it returns a dict containing the drawing mode parameters\n        as provided to :meth:`setDrawModeEnabled`.\n        \"\"\"\n        _logger.warning(\n            'getDrawMode deprecated, use getInteractiveMode instead')\n        mode = self.getInteractiveMode()\n        return mode if mode['mode'] == 'draw' else None",
  "def isZoomModeEnabled(self):\n        \"\"\"Deprecated, use :meth:`getInteractiveMode` instead.\n\n        Return True if the current interactive state is zooming.\"\"\"\n        _logger.warning(\n            'isZoomModeEnabled deprecated, use getInteractiveMode instead')\n        return self.getInteractiveMode()['mode'] == 'zoom'",
  "def setZoomModeEnabled(self, flag=True, color=None):\n        \"\"\"Deprecated, use :meth:`setInteractiveMode` instead.\n\n        Set the zoom mode if flag is True, else item selection is enabled.\n\n        Warning: Zoom and drawing are not compatible and cannot be enabled\n        simultanelously\n\n        :param bool flag: If True, enable zoom and select mode.\n        :param color: The color to use to draw the selection area.\n                      (Default: 'black')\n        :param color: The color to use to draw the selection area\n        :type color: string (\"#RRGGBB\") or 4 column unsigned byte array or\n                     one of the predefined color names defined in Colors.py\n        \"\"\"\n        _logger.warning(\n            'setZoomModeEnabled deprecated, use setInteractiveMode instead')\n        if color is None:\n            color = 'black'\n\n        if flag:\n            self.setInteractiveMode('zoom', color=color)\n        elif self.getInteractiveMode()['mode'] == 'zoom':\n            self.setInteractiveMode('select')",
  "def insertMarker(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`addMarker` instead.\"\"\"\n        _logger.warning(\n                'insertMarker deprecated, use addMarker instead.')\n        return self.addMarker(*args, **kwargs)",
  "def insertXMarker(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`addXMarker` instead.\"\"\"\n        _logger.warning(\n                'insertXMarker deprecated, use addXMarker instead.')\n        return self.addXMarker(*args, **kwargs)",
  "def insertYMarker(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`addYMarker` instead.\"\"\"\n        _logger.warning(\n                'insertYMarker deprecated, use addYMarker instead.')\n        return self.addYMarker(*args, **kwargs)",
  "def isActiveCurveHandlingEnabled(self):\n        \"\"\"Deprecated, use :meth:`isActiveCurveHandling` instead.\"\"\"\n        _logger.warning(\n            'isActiveCurveHandlingEnabled deprecated, '\n            'use isActiveCurveHandling instead.')\n        return self.isActiveCurveHandling()",
  "def enableActiveCurveHandling(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`setActiveCurveHandling` instead.\"\"\"\n        _logger.warning(\n            'enableActiveCurveHandling deprecated, '\n            'use setActiveCurveHandling instead.')\n        return self.setActiveCurveHandling(*args, **kwargs)",
  "def invertYAxis(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`setYAxisInverted` instead.\"\"\"\n        _logger.warning('invertYAxis deprecated, '\n                        'use setYAxisInverted instead.')\n        return self.setYAxisInverted(*args, **kwargs)",
  "def showGrid(self, flag=True):\n        \"\"\"Deprecated, use :meth:`setGraphGrid` instead.\"\"\"\n        _logger.warning(\"showGrid deprecated, use setGraphGrid instead\")\n        if flag in (0, False):\n            flag = None\n        elif flag in (1, True):\n            flag = 'major'\n        else:\n            flag = 'both'\n        return self.setGraphGrid(flag)",
  "def keepDataAspectRatio(self, *args, **kwargs):\n        \"\"\"Deprecated, use :meth:`setKeepDataAspectRatio`.\"\"\"\n        _logger.warning('keepDataAspectRatio deprecated,'\n                        'use setKeepDataAspectRatio instead')\n        return self.setKeepDataAspectRatio(*args, **kwargs)",
  "class _PlotInteraction(object):\n    \"\"\"Base class for interaction handler.\n\n    It provides a weakref to the plot and methods to set/reset overlay.\n    \"\"\"\n    def __init__(self, plot):\n        \"\"\"Init.\n\n        :param plot: The plot to apply modifications to.\n        \"\"\"\n        self._needReplot = False\n        self._selectionAreas = set()\n        self._plot = weakref.ref(plot)  # Avoid cyclic-ref\n\n    @property\n    def plot(self):\n        plot = self._plot()\n        assert plot is not None\n        return plot\n\n    def setSelectionArea(self, points, fill, color, name=''):\n        \"\"\"Set a polygon selection area overlaid on the plot.\n        Multiple simultaneous areas are supported through the name parameter.\n\n        :param points: The 2D coordinates of the points of the polygon\n        :type points: An iterable of (x, y) coordinates\n        :param str fill: The fill mode: 'hatch', 'solid' or None\n        :param color: RGBA color to use\n        :type color: list or tuple of 4 float in the range [0, 1]\n        :param name: The key associated with this selection area\n        \"\"\"\n        points = numpy.asarray(points)\n\n        # TODO Not very nice, but as is for now\n        legend = '__SELECTION_AREA__' + name\n\n        fill = bool(fill)  # TODO not very nice either\n\n        self.plot.addItem(points[:, 0], points[:, 1], legend=legend,\n                          replace=False,\n                          shape='polygon', color=color, fill=fill,\n                          overlay=True)\n        self._selectionAreas.add(legend)\n\n    def resetSelectionArea(self):\n        \"\"\"Remove all selection areas set by setSelectionArea.\"\"\"\n        for legend in self._selectionAreas:\n            self.plot.remove(legend, kind='item')\n        self._selectionAreas = set()",
  "def _scale1DRange(min_, max_, center, scale, isLog):\n    \"\"\"Scale a 1D range given a scale factor and an center point.\n\n    Keeps the values in a smaller range than float32.\n\n    :param float min_: The current min value of the range.\n    :param float max_: The current max value of the range.\n    :param float center: The center of the zoom (i.e., invariant point).\n    :param float scale: The scale to use for zoom\n    :param bool isLog: Whether using log scale or not.\n    :return: The zoomed range.\n    :rtype: tuple of 2 floats: (min, max)\n    \"\"\"\n    if isLog:\n        # Min and center can be < 0 when\n        # autoscale is off and switch to log scale\n        # max_ < 0 should not happen\n        min_ = numpy.log10(min_) if min_ > 0. else FLOAT32_MINPOS\n        center = numpy.log10(center) if center > 0. else FLOAT32_MINPOS\n        max_ = numpy.log10(max_) if max_ > 0. else FLOAT32_MINPOS\n\n    if min_ == max_:\n        return min_, max_\n\n    offset = (center - min_) / (max_ - min_)\n    range_ = (max_ - min_) / scale\n    newMin = center - offset * range_\n    newMax = center + (1. - offset) * range_\n\n    if isLog:\n        # No overflow as exponent is log10 of a float32\n        newMin = pow(10., newMin)\n        newMax = pow(10., newMax)\n        newMin = numpy.clip(newMin, FLOAT32_MINPOS, FLOAT32_SAFE_MAX)\n        newMax = numpy.clip(newMax, FLOAT32_MINPOS, FLOAT32_SAFE_MAX)\n    else:\n        newMin = numpy.clip(newMin, FLOAT32_SAFE_MIN, FLOAT32_SAFE_MAX)\n        newMax = numpy.clip(newMax, FLOAT32_SAFE_MIN, FLOAT32_SAFE_MAX)\n    return newMin, newMax",
  "def _applyZoomToPlot(plot, cx, cy, scaleF):\n    \"\"\"Zoom in/out plot given a scale and a center point.\n\n    :param plot: The plot on which to apply zoom.\n    :param float cx: X coord in data coordinates of the zoom center.\n    :param float cy: Y coord in data coordinates of the zoom center.\n    :param float scaleF: Scale factor of zoom.\n    \"\"\"\n    dataCenterPos = plot.pixelToData(cx, cy)\n    assert dataCenterPos is not None\n\n    xMin, xMax = plot.getGraphXLimits()\n    xMin, xMax = _scale1DRange(xMin, xMax, dataCenterPos[0], scaleF,\n                               plot.isXAxisLogarithmic())\n\n    yMin, yMax = plot.getGraphYLimits()\n    yMin, yMax = _scale1DRange(yMin, yMax, dataCenterPos[1], scaleF,\n                               plot.isYAxisLogarithmic())\n\n    dataPos = plot.pixelToData(cx, cy, axis=\"right\")\n    assert dataPos is not None\n    y2Center = dataPos[1]\n    y2Min, y2Max = plot.getGraphYLimits(axis=\"right\")\n    y2Min, y2Max = _scale1DRange(y2Min, y2Max, y2Center, scaleF,\n                                 plot.isYAxisLogarithmic())\n\n    plot.setLimits(xMin, xMax, yMin, yMax, y2Min, y2Max)",
  "class _ZoomOnWheel(ClickOrDrag, _PlotInteraction):\n    \"\"\":class:`ClickOrDrag` state machine with zooming on mouse wheel.\n\n    Base class for :class:`Pan` and :class:`Zoom`\n    \"\"\"\n    class ZoomIdle(ClickOrDrag.Idle):\n        def onWheel(self, x, y, angle):\n            scaleF = 1.1 if angle > 0 else 1./1.1\n            _applyZoomToPlot(self.machine.plot, x, y, scaleF)\n\n    def __init__(self, plot):\n        \"\"\"Init.\n\n        :param plot: The plot to apply modifications to.\n        \"\"\"\n        _PlotInteraction.__init__(self, plot)\n\n        states = {\n            'idle': _ZoomOnWheel.ZoomIdle,\n            'rightClick': ClickOrDrag.RightClick,\n            'clickOrDrag': ClickOrDrag.ClickOrDrag,\n            'drag': ClickOrDrag.Drag\n        }\n        StateMachine.__init__(self, states, 'idle')",
  "class Pan(_ZoomOnWheel):\n    \"\"\"Pan plot content and zoom on wheel state machine.\"\"\"\n\n    def _pixelToData(self, x, y):\n        xData, yData = self.plot.pixelToData(x, y)\n        _, y2Data = self.plot.pixelToData(x, y, axis='right')\n        return xData, yData, y2Data\n\n    def beginDrag(self, x, y):\n        self._previousDataPos = self._pixelToData(x, y)\n\n    def drag(self, x, y):\n        xData, yData, y2Data = self._pixelToData(x, y)\n        lastX, lastY, lastY2 = self._previousDataPos\n\n        xMin, xMax = self.plot.getGraphXLimits()\n        yMin, yMax = self.plot.getGraphYLimits(axis='left')\n        y2Min, y2Max = self.plot.getGraphYLimits(axis='right')\n\n        if self.plot.isXAxisLogarithmic():\n            try:\n                dx = math.log10(xData) - math.log10(lastX)\n                newXMin = pow(10., (math.log10(xMin) - dx))\n                newXMax = pow(10., (math.log10(xMax) - dx))\n            except (ValueError, OverflowError):\n                newXMin, newXMax = xMin, xMax\n\n            # Makes sure both values stays in positive float32 range\n            if newXMin < FLOAT32_MINPOS or newXMax > FLOAT32_SAFE_MAX:\n                newXMin, newXMax = xMin, xMax\n        else:\n            dx = xData - lastX\n            newXMin, newXMax = xMin - dx, xMax - dx\n\n            # Makes sure both values stays in float32 range\n            if newXMin < FLOAT32_SAFE_MIN or newXMax > FLOAT32_SAFE_MAX:\n                newXMin, newXMax = xMin, xMax\n\n        if self.plot.isYAxisLogarithmic():\n            try:\n                dy = math.log10(yData) - math.log10(lastY)\n                newYMin = pow(10., math.log10(yMin) - dy)\n                newYMax = pow(10., math.log10(yMax) - dy)\n\n                dy2 = math.log10(y2Data) - math.log10(lastY2)\n                newY2Min = pow(10., math.log10(y2Min) - dy2)\n                newY2Max = pow(10., math.log10(y2Max) - dy2)\n            except (ValueError, OverflowError):\n                newYMin, newYMax = yMin, yMax\n                newY2Min, newY2Max = y2Min, y2Max\n\n            # Makes sure y and y2 stays in positive float32 range\n            if (newYMin < FLOAT32_MINPOS or newYMax > FLOAT32_SAFE_MAX or\n                    newY2Min < FLOAT32_MINPOS or newY2Max > FLOAT32_SAFE_MAX):\n                newYMin, newYMax = yMin, yMax\n                newY2Min, newY2Max = y2Min, y2Max\n        else:\n            dy = yData - lastY\n            dy2 = y2Data - lastY2\n            newYMin, newYMax = yMin - dy, yMax - dy\n            newY2Min, newY2Max = y2Min - dy2, y2Max - dy2\n\n            # Makes sure y and y2 stays in float32 range\n            if (newYMin < FLOAT32_SAFE_MIN or\n                    newYMax > FLOAT32_SAFE_MAX or\n                    newY2Min < FLOAT32_SAFE_MIN or\n                    newY2Max > FLOAT32_SAFE_MAX):\n                newYMin, newYMax = yMin, yMax\n                newY2Min, newY2Max = y2Min, y2Max\n\n        self.plot.setLimits(newXMin, newXMax,\n                            newYMin, newYMax,\n                            newY2Min, newY2Max)\n\n        self._previousDataPos = self._pixelToData(x, y)\n\n    def endDrag(self, startPos, endPos):\n        del self._previousDataPos\n\n    def cancel(self):\n        pass",
  "class Zoom(_ZoomOnWheel):\n    \"\"\"Zoom-in/out state machine.\n\n    Zoom-in on selected area, zoom-out on right click,\n    and zoom on mouse wheel.\n    \"\"\"\n    _DOUBLE_CLICK_TIMEOUT = 0.4\n\n    def __init__(self, plot, color):\n        self.color = color\n        self.zoomStack = []\n        self._lastClick = 0., None\n\n        super(Zoom, self).__init__(plot)\n\n    def _areaWithAspectRatio(self, x0, y0, x1, y1):\n        plotLeft, plotTop, plotW, plotH = self.plot.getPlotBoundsInPixels()\n\n        areaX0, areaY0, areaX1, areaY1 = x0, y0, x1, y1\n\n        if plotH != 0.:\n            plotRatio = plotW / float(plotH)\n            width, height = math.fabs(x1 - x0), math.fabs(y1 - y0)\n\n            if height != 0. and width != 0.:\n                if width / height > plotRatio:\n                    areaHeight = width / plotRatio\n                    areaX0, areaX1 = x0, x1\n                    center = 0.5 * (y0 + y1)\n                    areaY0 = center - numpy.sign(y1 - y0) * 0.5 * areaHeight\n                    areaY1 = center + numpy.sign(y1 - y0) * 0.5 * areaHeight\n                else:\n                    areaWidth = height * plotRatio\n                    areaY0, areaY1 = y0, y1\n                    center = 0.5 * (x0 + x1)\n                    areaX0 = center - numpy.sign(x1 - x0) * 0.5 * areaWidth\n                    areaX1 = center + numpy.sign(x1 - x0) * 0.5 * areaWidth\n\n        return areaX0, areaY0, areaX1, areaY1\n\n    def click(self, x, y, btn):\n        if btn == LEFT_BTN:\n            lastClickTime, lastClickPos = self._lastClick\n\n            # Signal mouse double clicked event first\n            if (time.time() - lastClickTime) <= self._DOUBLE_CLICK_TIMEOUT:\n                # Use position of first click\n                eventDict = prepareMouseSignal('mouseDoubleClicked', 'left',\n                                               *lastClickPos)\n                self.plot.notify(**eventDict)\n\n                self._lastClick = 0., None\n            else:\n                # Signal mouse clicked event\n                dataPos = self.plot.pixelToData(x, y)\n                assert dataPos is not None\n                eventDict = prepareMouseSignal('mouseClicked', 'left',\n                                               dataPos[0], dataPos[1],\n                                               x, y)\n                self.plot.notify(**eventDict)\n\n                self._lastClick = time.time(), (dataPos[0], dataPos[1], x, y)\n\n            # Zoom-in centered on mouse cursor\n            # xMin, xMax = self.plot.getGraphXLimits()\n            # yMin, yMax = self.plot.getGraphYLimits()\n            # y2Min, y2Max = self.plot.getGraphYLimits(axis=\"right\")\n            # self.zoomStack.append((xMin, xMax, yMin, yMax, y2Min, y2Max))\n            # self._zoom(x, y, 2)\n        elif btn == RIGHT_BTN:\n            try:\n                xMin, xMax, yMin, yMax, y2Min, y2Max = self.zoomStack.pop()\n            except IndexError:\n                # Signal mouse clicked event\n                dataPos = self.plot.pixelToData(x, y)\n                assert dataPos is not None\n                eventDict = prepareMouseSignal('mouseClicked', 'right',\n                                               dataPos[0], dataPos[1],\n                                               x, y)\n                self.plot.notify(**eventDict)\n            else:\n                self.plot.setLimits(xMin, xMax, yMin, yMax, y2Min, y2Max)\n\n    def beginDrag(self, x, y):\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n        self.x0, self.y0 = x, y\n\n    def drag(self, x1, y1):\n        dataPos = self.plot.pixelToData(x1, y1)\n        assert dataPos is not None\n\n        if self.plot.isKeepDataAspectRatio():\n            area = self._areaWithAspectRatio(self.x0, self.y0, x1, y1)\n            areaX0, areaY0, areaX1, areaY1 = area\n            areaPoints = ((areaX0, areaY0),\n                          (areaX1, areaY0),\n                          (areaX1, areaY1),\n                          (areaX0, areaY1))\n            areaPoints = numpy.array([self.plot.pixelToData(\n                x, y, check=False) for (x, y) in areaPoints])\n\n            if self.color != 'video inverted':\n                areaColor = list(self.color)\n                areaColor[3] *= 0.25\n            else:\n                areaColor = [1., 1., 1., 1.]\n\n            self.setSelectionArea(areaPoints,\n                                  fill=None,\n                                  color=areaColor,\n                                  name=\"zoomedArea\")\n\n        corners = ((self.x0, self.y0),\n                   (self.x0, y1),\n                   (x1, y1),\n                   (x1, self.y0))\n        corners = numpy.array([self.plot.pixelToData(x, y, check=False)\n                               for (x, y) in corners])\n\n        self.setSelectionArea(corners, fill=None, color=self.color)\n\n    def endDrag(self, startPos, endPos):\n        x0, y0 = startPos\n        x1, y1 = endPos\n\n        if x0 != x1 or y0 != y1:  # Avoid empty zoom area\n            # Store current zoom state in stack\n            xMin, xMax = self.plot.getGraphXLimits()\n            yMin, yMax = self.plot.getGraphYLimits()\n            y2Min, y2Max = self.plot.getGraphYLimits(axis=\"right\")\n            self.zoomStack.append((xMin, xMax, yMin, yMax, y2Min, y2Max))\n\n            if self.plot.isKeepDataAspectRatio():\n                x0, y0, x1, y1 = self._areaWithAspectRatio(x0, y0, x1, y1)\n\n            # Convert to data space and set limits\n            x0, y0 = self.plot.pixelToData(x0, y0, check=False)\n\n            dataPos = self.plot.pixelToData(\n                startPos[0], startPos[1], axis=\"right\", check=False)\n            y2_0 = dataPos[1]\n\n            x1, y1 = self.plot.pixelToData(x1, y1, check=False)\n\n            dataPos = self.plot.pixelToData(\n                endPos[0], endPos[1], axis=\"right\", check=False)\n            y2_1 = dataPos[1]\n\n            xMin, xMax = min(x0, x1), max(x0, x1)\n            yMin, yMax = min(y0, y1), max(y0, y1)\n            y2Min, y2Max = min(y2_0, y2_1), max(y2_0, y2_1)\n\n            self.plot.setLimits(xMin, xMax, yMin, yMax, y2Min, y2Max)\n\n        self.resetSelectionArea()\n\n    def cancel(self):\n        if isinstance(self.state, self.states['drag']):\n            self.resetSelectionArea()",
  "class Select(StateMachine, _PlotInteraction):\n    \"\"\"Base class for drawing selection areas.\"\"\"\n\n    def __init__(self, plot, parameters, states, state):\n        \"\"\"Init a state machine.\n\n        :param plot: The plot to apply changes to.\n        :param dict parameters: A dict of parameters such as color.\n        :param dict states: The states of the state machine.\n        :param str state: The name of the initial state.\n        \"\"\"\n        _PlotInteraction.__init__(self, plot)\n        self.parameters = parameters\n        StateMachine.__init__(self, states, state)\n\n    def onWheel(self, x, y, angle):\n        scaleF = 1.1 if angle > 0 else 1./1.1\n        _applyZoomToPlot(self.plot, x, y, scaleF)\n\n    @property\n    def color(self):\n        return self.parameters.get('color', None)",
  "class SelectPolygon(Select):\n    \"\"\"Drawing selection polygon area state machine.\"\"\"\n    class Idle(State):\n        def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('select', x, y)\n                return True\n\n    class Select(State):\n        def enter(self, x, y):\n            dataPos = self.machine.plot.pixelToData(x, y)\n            assert dataPos is not None\n            self.points = [dataPos, dataPos]\n\n        def updateSelectionArea(self):\n            self.machine.setSelectionArea(self.points,\n                                          fill='hatch',\n                                          color=self.machine.color)\n            eventDict = prepareDrawingSignal('drawingProgress',\n                                             'polygon',\n                                             self.points,\n                                             self.machine.parameters)\n            self.machine.plot.notify(**eventDict)\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                dataPos = self.machine.plot.pixelToData(x, y)\n                assert dataPos is not None\n                self.points[-1] = dataPos\n                self.updateSelectionArea()\n                if self.points[-2] != self.points[-1]:\n                    self.points.append(dataPos)\n                return True\n\n        def onMove(self, x, y):\n            dataPos = self.machine.plot.pixelToData(x, y)\n            assert dataPos is not None\n            self.points[-1] = dataPos\n            self.updateSelectionArea()\n\n        def onPress(self, x, y, btn):\n            if btn == RIGHT_BTN:\n                self.machine.resetSelectionArea()\n\n                dataPos = self.machine.plot.pixelToData(x, y)\n                assert dataPos is not None\n                self.points[-1] = dataPos\n                if self.points[-2] == self.points[-1]:\n                    self.points.pop()\n                self.points.append(self.points[0])\n\n                eventDict = prepareDrawingSignal('drawingFinished',\n                                                 'polygon',\n                                                 self.points,\n                                                 self.machine.parameters)\n                self.machine.plot.notify(**eventDict)\n                self.goto('idle')\n\n    def __init__(self, plot, parameters):\n        states = {\n            'idle': SelectPolygon.Idle,\n            'select': SelectPolygon.Select\n        }\n        super(SelectPolygon, self).__init__(plot, parameters,\n                                            states, 'idle')\n\n    def cancel(self):\n        if isinstance(self.state, self.states['select']):\n            self.resetSelectionArea()",
  "class Select2Points(Select):\n    \"\"\"Base class for drawing selection based on 2 input points.\"\"\"\n    class Idle(State):\n        def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('start', x, y)\n                return True\n\n    class Start(State):\n        def enter(self, x, y):\n            self.machine.beginSelect(x, y)\n\n        def onMove(self, x, y):\n            self.goto('select', x, y)\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('select', x, y)\n                return True\n\n    class Select(State):\n        def enter(self, x, y):\n            self.onMove(x, y)\n\n        def onMove(self, x, y):\n            self.machine.select(x, y)\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.endSelect(x, y)\n                self.goto('idle')\n\n    def __init__(self, plot, parameters):\n        states = {\n            'idle': Select2Points.Idle,\n            'start': Select2Points.Start,\n            'select': Select2Points.Select\n        }\n        super(Select2Points, self).__init__(plot, parameters,\n                                            states, 'idle')\n\n    def beginSelect(self, x, y):\n        pass\n\n    def select(self, x, y):\n        pass\n\n    def endSelect(self, x, y):\n        pass\n\n    def cancelSelect(self):\n        pass\n\n    def cancel(self):\n        if isinstance(self.state, self.states['select']):\n            self.cancelSelect()",
  "class SelectRectangle(Select2Points):\n    \"\"\"Drawing rectangle selection area state machine.\"\"\"\n    def beginSelect(self, x, y):\n        self.startPt = self.plot.pixelToData(x, y)\n        assert self.startPt is not None\n\n    def select(self, x, y):\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n\n        self.setSelectionArea((self.startPt,\n                              (self.startPt[0], dataPos[1]),\n                              dataPos,\n                              (dataPos[0], self.startPt[1])),\n                              fill='hatch',\n                              color=self.color)\n\n        eventDict = prepareDrawingSignal('drawingProgress',\n                                         'rectangle',\n                                         (self.startPt, dataPos),\n                                         self.parameters)\n        self.plot.notify(**eventDict)\n\n    def endSelect(self, x, y):\n        self.resetSelectionArea()\n\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n\n        eventDict = prepareDrawingSignal('drawingFinished',\n                                         'rectangle',\n                                         (self.startPt, dataPos),\n                                         self.parameters)\n        self.plot.notify(**eventDict)\n\n    def cancelSelect(self):\n        self.resetSelectionArea()",
  "class SelectLine(Select2Points):\n    \"\"\"Drawing line selection area state machine.\"\"\"\n    def beginSelect(self, x, y):\n        self.startPt = self.plot.pixelToData(x, y)\n        assert self.startPt is not None\n\n    def select(self, x, y):\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n\n        self.setSelectionArea((self.startPt, dataPos),\n                              fill='hatch',\n                              color=self.color)\n\n        eventDict = prepareDrawingSignal('drawingProgress',\n                                         'line',\n                                         (self.startPt, dataPos),\n                                         self.parameters)\n        self.plot.notify(**eventDict)\n\n    def endSelect(self, x, y):\n        self.resetSelectionArea()\n\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n\n        eventDict = prepareDrawingSignal('drawingFinished',\n                                         'line',\n                                         (self.startPt, dataPos),\n                                         self.parameters)\n        self.plot.notify(**eventDict)\n\n    def cancelSelect(self):\n        self.resetSelectionArea()",
  "class Select1Point(Select):\n    \"\"\"Base class for drawing selection area based on one input point.\"\"\"\n    class Idle(State):\n        def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('select', x, y)\n                return True\n\n    class Select(State):\n        def enter(self, x, y):\n            self.onMove(x, y)\n\n        def onMove(self, x, y):\n            self.machine.select(x, y)\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.endSelect(x, y)\n                self.goto('idle')\n\n        def onWheel(self, x, y, angle):\n            self.machine.onWheel(x, y, angle)  # Call select default wheel\n            self.machine.select(x, y)\n\n    def __init__(self, plot, parameters):\n        states = {\n            'idle': Select1Point.Idle,\n            'select': Select1Point.Select\n        }\n        super(Select1Point, self).__init__(plot, parameters, states, 'idle')\n\n    def select(self, x, y):\n        pass\n\n    def endSelect(self, x, y):\n        pass\n\n    def cancelSelect(self):\n        pass\n\n    def cancel(self):\n        if isinstance(self.state, self.states['select']):\n            self.cancelSelect()",
  "class SelectHLine(Select1Point):\n    \"\"\"Drawing a horizontal line selection area state machine.\"\"\"\n    def _hLine(self, y):\n        \"\"\"Return points in data coords of the segment visible in the plot.\n\n        Supports non-orthogonal axes.\n        \"\"\"\n        left, top, width, height = self.plot.getPlotBoundsInPixels()\n\n        dataPos1 = self.plot.pixelToData(left, y, check=False)\n        dataPos2 = self.plot.pixelToData(left + width, y, check=False)\n        return dataPos1, dataPos2\n\n    def select(self, x, y):\n        points = self._hLine(y)\n        self.setSelectionArea(points, fill='hatch', color=self.color)\n\n        eventDict = prepareDrawingSignal('drawingProgress',\n                                         'hline',\n                                         points,\n                                         self.parameters)\n        self.plot.notify(**eventDict)\n\n    def endSelect(self, x, y):\n        self.resetSelectionArea()\n\n        eventDict = prepareDrawingSignal('drawingFinished',\n                                         'hline',\n                                         self._hLine(y),\n                                         self.parameters)\n        self.plot.notify(**eventDict)\n\n    def cancelSelect(self):\n        self.resetSelectionArea()",
  "class SelectVLine(Select1Point):\n    \"\"\"Drawing a vertical line selection area state machine.\"\"\"\n    def _vLine(self, x):\n        \"\"\"Return points in data coords of the segment visible in the plot.\n\n        Supports non-orthogonal axes.\n        \"\"\"\n        left, top, width, height = self.plot.getPlotBoundsInPixels()\n\n        dataPos1 = self.plot.pixelToData(x, top, check=False)\n        dataPos2 = self.plot.pixelToData(x, top + height, check=False)\n        return dataPos1, dataPos2\n\n    def select(self, x, y):\n        points = self._vLine(x)\n        self.setSelectionArea(points, fill='hatch', color=self.color)\n\n        eventDict = prepareDrawingSignal('drawingProgress',\n                                         'vline',\n                                         points,\n                                         self.parameters)\n        self.plot.notify(**eventDict)\n\n    def endSelect(self, x, y):\n        self.resetSelectionArea()\n\n        eventDict = prepareDrawingSignal('drawingFinished',\n                                         'vline',\n                                         self._vLine(x),\n                                         self.parameters)\n        self.plot.notify(**eventDict)\n\n    def cancelSelect(self):\n        self.resetSelectionArea()",
  "class ItemsInteraction(ClickOrDrag, _PlotInteraction):\n    class Idle(ClickOrDrag.Idle):\n        def __init__(self, *args, **kw):\n            super(ItemsInteraction.Idle, self).__init__(*args, **kw)\n            self._hoverMarker = None\n\n        def onWheel(self, x, y, angle):\n            scaleF = 1.1 if angle > 0 else 1./1.1\n            _applyZoomToPlot(self.machine.plot, x, y, scaleF)\n\n        def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                marker = self.machine.plot._pickMarker(\n                    x, y,\n                    lambda marker: marker['selectable'] or marker['draggable'])\n                if marker is not None:\n                    self.goto('clickOrDrag', x, y)\n                    return True\n\n                else:\n                    picked = self.machine.plot._pickImageOrCurve(\n                        x,\n                        y,\n                        lambda item: (item['selectable'] or\n                                      item.get('draggable', False)))\n                    if picked is not None:\n                        self.goto('clickOrDrag', x, y)\n                        return True\n\n            return False\n\n        def onMove(self, x, y):\n            marker = self.machine.plot._pickMarker(x, y)\n            if marker is not None:\n                dataPos = self.machine.plot.pixelToData(x, y)\n                assert dataPos is not None\n                eventDict = prepareHoverSignal(\n                    marker['legend'], 'marker',\n                    dataPos, (x, y),\n                    marker['draggable'],\n                    marker['selectable'])\n                self.machine.plot.notify(**eventDict)\n\n            if marker != self._hoverMarker:\n                self._hoverMarker = marker\n\n                if marker is None:\n                    self.machine.plot.setGraphCursorShape()\n\n                elif marker['draggable']:\n                    if marker['x'] is None:\n                        self.machine.plot.setGraphCursorShape(CURSOR_SIZE_VER)\n                    elif marker['y'] is None:\n                        self.machine.plot.setGraphCursorShape(CURSOR_SIZE_HOR)\n                    else:\n                        self.machine.plot.setGraphCursorShape(CURSOR_SIZE_ALL)\n\n                elif marker['selectable']:\n                    self.machine.plot.setGraphCursorShape(CURSOR_POINTING)\n\n            return True\n\n    def __init__(self, plot):\n        _PlotInteraction.__init__(self, plot)\n\n        states = {\n            'idle': ItemsInteraction.Idle,\n            'clickOrDrag': ClickOrDrag.ClickOrDrag,\n            'drag': ClickOrDrag.Drag\n        }\n        StateMachine.__init__(self, states, 'idle')\n\n    def click(self, x, y, btn):\n        # Signal mouse clicked event\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n        eventDict = prepareMouseSignal('mouseClicked', btn,\n                                       dataPos[0], dataPos[1],\n                                       x, y)\n        self.plot.notify(**eventDict)\n\n        if btn == LEFT_BTN:\n            marker = self.plot._pickMarker(\n                x, y, lambda marker: marker['selectable'])\n            if marker is not None:\n                xData, yData = marker['x'], marker['y']\n                if xData is None:\n                    xData = [0, 1]\n                if yData is None:\n                    yData = [0, 1]\n\n                eventDict = prepareMarkerSignal('markerClicked',\n                                                'left',\n                                                marker['legend'],\n                                                'marker',\n                                                marker['draggable'],\n                                                marker['selectable'],\n                                                (xData, yData),\n                                                (x, y), None)\n                self.plot.notify(**eventDict)\n\n            else:\n                picked = self.plot._pickImageOrCurve(\n                    x, y, lambda item: item['selectable'])\n\n                if picked is None:\n                    pass\n                elif picked[0] == 'curve':\n                    curve = picked[1]\n\n                    dataPos = self.plot.pixelToData(x, y)\n                    assert dataPos is not None\n\n                    eventDict = prepareCurveSignal('left',\n                                                   curve['legend'],\n                                                   'curve',\n                                                   picked[2], picked[3],\n                                                   dataPos[0], dataPos[1],\n                                                   x, y)\n                    self.plot.notify(**eventDict)\n\n                elif picked[0] == 'image':\n                    image = picked[1]\n\n                    dataPos = self.plot.pixelToData(x, y)\n                    assert dataPos is not None\n\n                    # Get corresponding coordinate in image\n                    column = int((dataPos[0] - image['origin'][0]) /\n                                 float(image['scale'][0]))\n                    row = int((dataPos[1] - image['origin'][1]) /\n                              float(image['scale'][1]))\n\n                    eventDict = prepareImageSignal('left',\n                                                   image['legend'],\n                                                   'image',\n                                                   column, row,\n                                                   dataPos[0], dataPos[1],\n                                                   x, y)\n                    self.plot.notify(**eventDict)\n\n    def _signalMarkerMovingEvent(self, eventType, marker, x, y):\n        assert marker is not None\n\n        xData, yData = marker['x'], marker['y']\n        if xData is None:\n            xData = [0, 1]\n        if yData is None:\n            yData = [0, 1]\n\n        posDataCursor = self.plot.pixelToData(x, y)\n        assert posDataCursor is not None\n\n        eventDict = prepareMarkerSignal(eventType,\n                                        'left',\n                                        marker['legend'],\n                                        'marker',\n                                        marker['draggable'],\n                                        marker['selectable'],\n                                        (xData, yData),\n                                        (x, y),\n                                        posDataCursor)\n        self.plot.notify(**eventDict)\n\n    def beginDrag(self, x, y):\n        self._lastPos = self.plot.pixelToData(x, y)\n        assert self._lastPos is not None\n\n        self.imageLegend = None\n        self.markerLegend = None\n        marker = self.plot._pickMarker(\n            x, y, lambda marker: marker['draggable'])\n\n        if marker is not None:\n            self.markerLegend = marker['legend']\n            self._signalMarkerMovingEvent('markerMoving', marker, x, y)\n        else:\n            picked = self.plot._pickImageOrCurve(\n                x,\n                y,\n                lambda item: item.get('draggable', False))\n            if picked is None:\n                self.imageLegend = None\n                self.plot.setGraphCursorShape()\n            else:\n                assert picked[0] == 'image'  # For now only drag images\n                self.imageLegend = picked[1]['legend']\n\n    def drag(self, x, y):\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n        xData, yData = dataPos\n\n        if self.markerLegend is not None:\n            marker = self.plot._getMarker(self.markerLegend)\n            if marker['constraint'] is not None:\n                xData, yData = marker['constraint'](xData, yData)\n\n            self.plot._moveMarker(self.markerLegend, xData, yData)\n\n            self._signalMarkerMovingEvent(\n                'markerMoving', self.plot._getMarker(self.markerLegend), x, y)\n\n        if self.imageLegend is not None:\n            dx, dy = xData - self._lastPos[0], yData - self._lastPos[1]\n            self.plot._moveImage(self.imageLegend, dx, dy)\n\n        self._lastPos = xData, yData\n\n    def endDrag(self, startPos, endPos):\n        if self.markerLegend is not None:\n            marker = self.plot._getMarker(self.markerLegend)\n            posData = [marker['x'], marker['y']]\n            if posData[0] is None:\n                posData[0] = [0, 1]\n            if posData[1] is None:\n                posData[1] = [0, 1]\n\n            eventDict = prepareMarkerSignal(\n                'markerMoved',\n                'left',\n                marker['legend'],\n                'marker',\n                marker['draggable'],\n                marker['selectable'],\n                posData)\n            self.plot.notify(**eventDict)\n\n        self.plot.setGraphCursorShape()\n\n        del self.markerLegend\n        del self.imageLegend\n        del self._lastPos\n\n    def cancel(self):\n        self.plot.setGraphCursorShape()",
  "class FocusManager(StateMachine):\n    \"\"\"Manages focus across multiple event handlers\n\n    On press an event handler can acquire focus.\n    By default it looses focus when all buttons are released.\n    \"\"\"\n    class Idle(State):\n        def onPress(self, x, y, btn):\n            for eventHandler in self.machine.eventHandlers:\n                requestFocus = eventHandler.handleEvent('press', x, y, btn)\n                if requestFocus:\n                    self.goto('focus', eventHandler, btn)\n                    break\n\n        def _processEvent(self, *args):\n            for eventHandler in self.machine.eventHandlers:\n                consumeEvent = eventHandler.handleEvent(*args)\n                if consumeEvent:\n                    break\n\n        def onMove(self, x, y):\n            self._processEvent('move', x, y)\n\n        def onRelease(self, x, y, btn):\n            self._processEvent('release', x, y, btn)\n\n        def onWheel(self, x, y, angle):\n            self._processEvent('wheel', x, y, angle)\n\n    class Focus(State):\n        def enter(self, eventHandler, btn):\n            self.eventHandler = eventHandler\n            self.focusBtns = set((btn,))\n\n        def onPress(self, x, y, btn):\n            self.focusBtns.add(btn)\n            self.eventHandler.handleEvent('press', x, y, btn)\n\n        def onMove(self, x, y):\n            self.eventHandler.handleEvent('move', x, y)\n\n        def onRelease(self, x, y, btn):\n            self.focusBtns.discard(btn)\n            requestFocus = self.eventHandler.handleEvent('release', x, y, btn)\n            if len(self.focusBtns) == 0 and not requestFocus:\n                self.goto('idle')\n\n        def onWheel(self, x, y, angleInDegrees):\n            self.eventHandler.handleEvent('wheel', x, y, angleInDegrees)\n\n    def __init__(self, eventHandlers=()):\n        self.eventHandlers = list(eventHandlers)\n\n        states = {\n            'idle': FocusManager.Idle,\n            'focus': FocusManager.Focus\n        }\n        super(FocusManager, self).__init__(states, 'idle')\n\n    def cancel(self):\n        for handler in self.eventHandlers:\n            handler.cancel()",
  "class ZoomAndSelect(FocusManager):\n    \"\"\"Combine Zoom and ItemInteraction state machine.\"\"\"\n    def __init__(self, plot, color):\n        eventHandlers = ItemsInteraction(plot), Zoom(plot, color)\n        super(ZoomAndSelect, self).__init__(eventHandlers)\n\n    @property\n    def color(self):\n        return self.eventHandlers[1].color",
  "class PlotInteraction(object):\n    \"\"\"Proxy to currently use state machine for interaction.\n\n    This allows to switch interactive mode.\n\n    :param plot: The :class:`Plot` to apply interaction to\n    \"\"\"\n\n    _DRAW_MODES = {\n        'polygon': SelectPolygon,\n        'rectangle': SelectRectangle,\n        'line': SelectLine,\n        'vline': SelectVLine,\n        'hline': SelectHLine,\n    }\n\n    def __init__(self, plot):\n        self._plot = weakref.ref(plot)  # Avoid cyclic-ref\n\n        self.zoomOnWheel = True\n        \"\"\"True to enable zoom on wheel, False otherwise.\"\"\"\n\n        # Default event handler\n        self._eventHandler = ItemsInteraction(plot)\n\n    def getInteractiveMode(self):\n        \"\"\"Returns the current interactive mode as a dict.\n\n        The returned dict contains at least the key 'mode'.\n        Mode can be: 'draw', 'pan', 'select', 'zoom'.\n        It can also contains extra keys (e.g., 'color') specific to a mode\n        as provided to :meth:`setInteractiveMode`.\n        \"\"\"\n        if isinstance(self._eventHandler, ZoomAndSelect):\n            return {'mode': 'zoom', 'color': self._eventHandler.color}\n\n        elif isinstance(self._eventHandler, Select):\n            result = self._eventHandler.parameters.copy()\n            result['mode'] = 'draw'\n            return result\n\n        elif isinstance(self._eventHandler, Pan):\n            return {'mode': 'pan'}\n\n        else:\n            return {'mode': 'select'}\n\n    def setInteractiveMode(self, mode, color='black',\n                           shape='polygon', label=None):\n        \"\"\"Switch the interactive mode.\n\n        :param str mode: The name of the interactive mode.\n                         In 'draw', 'pan', 'select', 'zoom'.\n        :param color: Only for 'draw' and 'zoom' modes.\n                      Color to use for drawing selection area. Default black.\n        :type color: Color description: The name as a str or\n                     a tuple of 4 floats.\n        :param str shape: Only for 'draw' mode. The kind of shape to draw.\n                          In 'polygon', 'rectangle', 'line', 'vline', 'hline'.\n                          Default is 'polygon'.\n        :param str label: Only for 'draw' mode.\n        \"\"\"\n        assert mode in ('draw', 'pan', 'select', 'zoom')\n\n        plot = self._plot()\n        assert plot is not None\n\n        if mode == 'draw':\n            assert shape in self._DRAW_MODES\n            eventHandlerClass = self._DRAW_MODES[shape]\n            parameters = {\n                'shape': shape,\n                'label': label,\n                'color': Colors.rgba(color)\n            }\n\n            self._eventHandler.cancel()\n            self._eventHandler = eventHandlerClass(plot, parameters)\n\n        elif mode == 'pan':\n            # Ignores color, shape and label\n            self._eventHandler.cancel()\n            self._eventHandler = Pan(plot)\n\n        elif mode == 'zoom':\n            # Ignores shape and label\n            if color != 'video inverted':\n                color = Colors.rgba(color)\n            self._eventHandler.cancel()\n            self._eventHandler = ZoomAndSelect(plot, color)\n\n        else:  # Default mode: interaction with plot objects\n            # Ignores color, shape and label\n            self._eventHandler.cancel()\n            self._eventHandler = ItemsInteraction(plot)\n\n    def handleEvent(self, event, *args, **kwargs):\n        \"\"\"Forward event to current interactive mode state machine.\"\"\"\n        if not self.zoomOnWheel and event == 'wheel':\n            return  # Discard wheel events\n        self._eventHandler.handleEvent(event, *args, **kwargs)",
  "def __init__(self, plot):\n        \"\"\"Init.\n\n        :param plot: The plot to apply modifications to.\n        \"\"\"\n        self._needReplot = False\n        self._selectionAreas = set()\n        self._plot = weakref.ref(plot)",
  "def plot(self):\n        plot = self._plot()\n        assert plot is not None\n        return plot",
  "def setSelectionArea(self, points, fill, color, name=''):\n        \"\"\"Set a polygon selection area overlaid on the plot.\n        Multiple simultaneous areas are supported through the name parameter.\n\n        :param points: The 2D coordinates of the points of the polygon\n        :type points: An iterable of (x, y) coordinates\n        :param str fill: The fill mode: 'hatch', 'solid' or None\n        :param color: RGBA color to use\n        :type color: list or tuple of 4 float in the range [0, 1]\n        :param name: The key associated with this selection area\n        \"\"\"\n        points = numpy.asarray(points)\n\n        # TODO Not very nice, but as is for now\n        legend = '__SELECTION_AREA__' + name\n\n        fill = bool(fill)  # TODO not very nice either\n\n        self.plot.addItem(points[:, 0], points[:, 1], legend=legend,\n                          replace=False,\n                          shape='polygon', color=color, fill=fill,\n                          overlay=True)\n        self._selectionAreas.add(legend)",
  "def resetSelectionArea(self):\n        \"\"\"Remove all selection areas set by setSelectionArea.\"\"\"\n        for legend in self._selectionAreas:\n            self.plot.remove(legend, kind='item')\n        self._selectionAreas = set()",
  "class ZoomIdle(ClickOrDrag.Idle):\n        def onWheel(self, x, y, angle):\n            scaleF = 1.1 if angle > 0 else 1./1.1\n            _applyZoomToPlot(self.machine.plot, x, y, scaleF)",
  "def __init__(self, plot):\n        \"\"\"Init.\n\n        :param plot: The plot to apply modifications to.\n        \"\"\"\n        _PlotInteraction.__init__(self, plot)\n\n        states = {\n            'idle': _ZoomOnWheel.ZoomIdle,\n            'rightClick': ClickOrDrag.RightClick,\n            'clickOrDrag': ClickOrDrag.ClickOrDrag,\n            'drag': ClickOrDrag.Drag\n        }\n        StateMachine.__init__(self, states, 'idle')",
  "def _pixelToData(self, x, y):\n        xData, yData = self.plot.pixelToData(x, y)\n        _, y2Data = self.plot.pixelToData(x, y, axis='right')\n        return xData, yData, y2Data",
  "def beginDrag(self, x, y):\n        self._previousDataPos = self._pixelToData(x, y)",
  "def drag(self, x, y):\n        xData, yData, y2Data = self._pixelToData(x, y)\n        lastX, lastY, lastY2 = self._previousDataPos\n\n        xMin, xMax = self.plot.getGraphXLimits()\n        yMin, yMax = self.plot.getGraphYLimits(axis='left')\n        y2Min, y2Max = self.plot.getGraphYLimits(axis='right')\n\n        if self.plot.isXAxisLogarithmic():\n            try:\n                dx = math.log10(xData) - math.log10(lastX)\n                newXMin = pow(10., (math.log10(xMin) - dx))\n                newXMax = pow(10., (math.log10(xMax) - dx))\n            except (ValueError, OverflowError):\n                newXMin, newXMax = xMin, xMax\n\n            # Makes sure both values stays in positive float32 range\n            if newXMin < FLOAT32_MINPOS or newXMax > FLOAT32_SAFE_MAX:\n                newXMin, newXMax = xMin, xMax\n        else:\n            dx = xData - lastX\n            newXMin, newXMax = xMin - dx, xMax - dx\n\n            # Makes sure both values stays in float32 range\n            if newXMin < FLOAT32_SAFE_MIN or newXMax > FLOAT32_SAFE_MAX:\n                newXMin, newXMax = xMin, xMax\n\n        if self.plot.isYAxisLogarithmic():\n            try:\n                dy = math.log10(yData) - math.log10(lastY)\n                newYMin = pow(10., math.log10(yMin) - dy)\n                newYMax = pow(10., math.log10(yMax) - dy)\n\n                dy2 = math.log10(y2Data) - math.log10(lastY2)\n                newY2Min = pow(10., math.log10(y2Min) - dy2)\n                newY2Max = pow(10., math.log10(y2Max) - dy2)\n            except (ValueError, OverflowError):\n                newYMin, newYMax = yMin, yMax\n                newY2Min, newY2Max = y2Min, y2Max\n\n            # Makes sure y and y2 stays in positive float32 range\n            if (newYMin < FLOAT32_MINPOS or newYMax > FLOAT32_SAFE_MAX or\n                    newY2Min < FLOAT32_MINPOS or newY2Max > FLOAT32_SAFE_MAX):\n                newYMin, newYMax = yMin, yMax\n                newY2Min, newY2Max = y2Min, y2Max\n        else:\n            dy = yData - lastY\n            dy2 = y2Data - lastY2\n            newYMin, newYMax = yMin - dy, yMax - dy\n            newY2Min, newY2Max = y2Min - dy2, y2Max - dy2\n\n            # Makes sure y and y2 stays in float32 range\n            if (newYMin < FLOAT32_SAFE_MIN or\n                    newYMax > FLOAT32_SAFE_MAX or\n                    newY2Min < FLOAT32_SAFE_MIN or\n                    newY2Max > FLOAT32_SAFE_MAX):\n                newYMin, newYMax = yMin, yMax\n                newY2Min, newY2Max = y2Min, y2Max\n\n        self.plot.setLimits(newXMin, newXMax,\n                            newYMin, newYMax,\n                            newY2Min, newY2Max)\n\n        self._previousDataPos = self._pixelToData(x, y)",
  "def endDrag(self, startPos, endPos):\n        del self._previousDataPos",
  "def cancel(self):\n        pass",
  "def __init__(self, plot, color):\n        self.color = color\n        self.zoomStack = []\n        self._lastClick = 0., None\n\n        super(Zoom, self).__init__(plot)",
  "def _areaWithAspectRatio(self, x0, y0, x1, y1):\n        plotLeft, plotTop, plotW, plotH = self.plot.getPlotBoundsInPixels()\n\n        areaX0, areaY0, areaX1, areaY1 = x0, y0, x1, y1\n\n        if plotH != 0.:\n            plotRatio = plotW / float(plotH)\n            width, height = math.fabs(x1 - x0), math.fabs(y1 - y0)\n\n            if height != 0. and width != 0.:\n                if width / height > plotRatio:\n                    areaHeight = width / plotRatio\n                    areaX0, areaX1 = x0, x1\n                    center = 0.5 * (y0 + y1)\n                    areaY0 = center - numpy.sign(y1 - y0) * 0.5 * areaHeight\n                    areaY1 = center + numpy.sign(y1 - y0) * 0.5 * areaHeight\n                else:\n                    areaWidth = height * plotRatio\n                    areaY0, areaY1 = y0, y1\n                    center = 0.5 * (x0 + x1)\n                    areaX0 = center - numpy.sign(x1 - x0) * 0.5 * areaWidth\n                    areaX1 = center + numpy.sign(x1 - x0) * 0.5 * areaWidth\n\n        return areaX0, areaY0, areaX1, areaY1",
  "def click(self, x, y, btn):\n        if btn == LEFT_BTN:\n            lastClickTime, lastClickPos = self._lastClick\n\n            # Signal mouse double clicked event first\n            if (time.time() - lastClickTime) <= self._DOUBLE_CLICK_TIMEOUT:\n                # Use position of first click\n                eventDict = prepareMouseSignal('mouseDoubleClicked', 'left',\n                                               *lastClickPos)\n                self.plot.notify(**eventDict)\n\n                self._lastClick = 0., None\n            else:\n                # Signal mouse clicked event\n                dataPos = self.plot.pixelToData(x, y)\n                assert dataPos is not None\n                eventDict = prepareMouseSignal('mouseClicked', 'left',\n                                               dataPos[0], dataPos[1],\n                                               x, y)\n                self.plot.notify(**eventDict)\n\n                self._lastClick = time.time(), (dataPos[0], dataPos[1], x, y)\n\n            # Zoom-in centered on mouse cursor\n            # xMin, xMax = self.plot.getGraphXLimits()\n            # yMin, yMax = self.plot.getGraphYLimits()\n            # y2Min, y2Max = self.plot.getGraphYLimits(axis=\"right\")\n            # self.zoomStack.append((xMin, xMax, yMin, yMax, y2Min, y2Max))\n            # self._zoom(x, y, 2)\n        elif btn == RIGHT_BTN:\n            try:\n                xMin, xMax, yMin, yMax, y2Min, y2Max = self.zoomStack.pop()\n            except IndexError:\n                # Signal mouse clicked event\n                dataPos = self.plot.pixelToData(x, y)\n                assert dataPos is not None\n                eventDict = prepareMouseSignal('mouseClicked', 'right',\n                                               dataPos[0], dataPos[1],\n                                               x, y)\n                self.plot.notify(**eventDict)\n            else:\n                self.plot.setLimits(xMin, xMax, yMin, yMax, y2Min, y2Max)",
  "def beginDrag(self, x, y):\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n        self.x0, self.y0 = x, y",
  "def drag(self, x1, y1):\n        dataPos = self.plot.pixelToData(x1, y1)\n        assert dataPos is not None\n\n        if self.plot.isKeepDataAspectRatio():\n            area = self._areaWithAspectRatio(self.x0, self.y0, x1, y1)\n            areaX0, areaY0, areaX1, areaY1 = area\n            areaPoints = ((areaX0, areaY0),\n                          (areaX1, areaY0),\n                          (areaX1, areaY1),\n                          (areaX0, areaY1))\n            areaPoints = numpy.array([self.plot.pixelToData(\n                x, y, check=False) for (x, y) in areaPoints])\n\n            if self.color != 'video inverted':\n                areaColor = list(self.color)\n                areaColor[3] *= 0.25\n            else:\n                areaColor = [1., 1., 1., 1.]\n\n            self.setSelectionArea(areaPoints,\n                                  fill=None,\n                                  color=areaColor,\n                                  name=\"zoomedArea\")\n\n        corners = ((self.x0, self.y0),\n                   (self.x0, y1),\n                   (x1, y1),\n                   (x1, self.y0))\n        corners = numpy.array([self.plot.pixelToData(x, y, check=False)\n                               for (x, y) in corners])\n\n        self.setSelectionArea(corners, fill=None, color=self.color)",
  "def endDrag(self, startPos, endPos):\n        x0, y0 = startPos\n        x1, y1 = endPos\n\n        if x0 != x1 or y0 != y1:  # Avoid empty zoom area\n            # Store current zoom state in stack\n            xMin, xMax = self.plot.getGraphXLimits()\n            yMin, yMax = self.plot.getGraphYLimits()\n            y2Min, y2Max = self.plot.getGraphYLimits(axis=\"right\")\n            self.zoomStack.append((xMin, xMax, yMin, yMax, y2Min, y2Max))\n\n            if self.plot.isKeepDataAspectRatio():\n                x0, y0, x1, y1 = self._areaWithAspectRatio(x0, y0, x1, y1)\n\n            # Convert to data space and set limits\n            x0, y0 = self.plot.pixelToData(x0, y0, check=False)\n\n            dataPos = self.plot.pixelToData(\n                startPos[0], startPos[1], axis=\"right\", check=False)\n            y2_0 = dataPos[1]\n\n            x1, y1 = self.plot.pixelToData(x1, y1, check=False)\n\n            dataPos = self.plot.pixelToData(\n                endPos[0], endPos[1], axis=\"right\", check=False)\n            y2_1 = dataPos[1]\n\n            xMin, xMax = min(x0, x1), max(x0, x1)\n            yMin, yMax = min(y0, y1), max(y0, y1)\n            y2Min, y2Max = min(y2_0, y2_1), max(y2_0, y2_1)\n\n            self.plot.setLimits(xMin, xMax, yMin, yMax, y2Min, y2Max)\n\n        self.resetSelectionArea()",
  "def cancel(self):\n        if isinstance(self.state, self.states['drag']):\n            self.resetSelectionArea()",
  "def __init__(self, plot, parameters, states, state):\n        \"\"\"Init a state machine.\n\n        :param plot: The plot to apply changes to.\n        :param dict parameters: A dict of parameters such as color.\n        :param dict states: The states of the state machine.\n        :param str state: The name of the initial state.\n        \"\"\"\n        _PlotInteraction.__init__(self, plot)\n        self.parameters = parameters\n        StateMachine.__init__(self, states, state)",
  "def onWheel(self, x, y, angle):\n        scaleF = 1.1 if angle > 0 else 1./1.1\n        _applyZoomToPlot(self.plot, x, y, scaleF)",
  "def color(self):\n        return self.parameters.get('color', None)",
  "class Idle(State):\n        def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('select', x, y)\n                return True",
  "class Select(State):\n        def enter(self, x, y):\n            dataPos = self.machine.plot.pixelToData(x, y)\n            assert dataPos is not None\n            self.points = [dataPos, dataPos]\n\n        def updateSelectionArea(self):\n            self.machine.setSelectionArea(self.points,\n                                          fill='hatch',\n                                          color=self.machine.color)\n            eventDict = prepareDrawingSignal('drawingProgress',\n                                             'polygon',\n                                             self.points,\n                                             self.machine.parameters)\n            self.machine.plot.notify(**eventDict)\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                dataPos = self.machine.plot.pixelToData(x, y)\n                assert dataPos is not None\n                self.points[-1] = dataPos\n                self.updateSelectionArea()\n                if self.points[-2] != self.points[-1]:\n                    self.points.append(dataPos)\n                return True\n\n        def onMove(self, x, y):\n            dataPos = self.machine.plot.pixelToData(x, y)\n            assert dataPos is not None\n            self.points[-1] = dataPos\n            self.updateSelectionArea()\n\n        def onPress(self, x, y, btn):\n            if btn == RIGHT_BTN:\n                self.machine.resetSelectionArea()\n\n                dataPos = self.machine.plot.pixelToData(x, y)\n                assert dataPos is not None\n                self.points[-1] = dataPos\n                if self.points[-2] == self.points[-1]:\n                    self.points.pop()\n                self.points.append(self.points[0])\n\n                eventDict = prepareDrawingSignal('drawingFinished',\n                                                 'polygon',\n                                                 self.points,\n                                                 self.machine.parameters)\n                self.machine.plot.notify(**eventDict)\n                self.goto('idle')",
  "def __init__(self, plot, parameters):\n        states = {\n            'idle': SelectPolygon.Idle,\n            'select': SelectPolygon.Select\n        }\n        super(SelectPolygon, self).__init__(plot, parameters,\n                                            states, 'idle')",
  "def cancel(self):\n        if isinstance(self.state, self.states['select']):\n            self.resetSelectionArea()",
  "class Idle(State):\n        def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('start', x, y)\n                return True",
  "class Start(State):\n        def enter(self, x, y):\n            self.machine.beginSelect(x, y)\n\n        def onMove(self, x, y):\n            self.goto('select', x, y)\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('select', x, y)\n                return True",
  "class Select(State):\n        def enter(self, x, y):\n            self.onMove(x, y)\n\n        def onMove(self, x, y):\n            self.machine.select(x, y)\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.endSelect(x, y)\n                self.goto('idle')",
  "def __init__(self, plot, parameters):\n        states = {\n            'idle': Select2Points.Idle,\n            'start': Select2Points.Start,\n            'select': Select2Points.Select\n        }\n        super(Select2Points, self).__init__(plot, parameters,\n                                            states, 'idle')",
  "def beginSelect(self, x, y):\n        pass",
  "def select(self, x, y):\n        pass",
  "def endSelect(self, x, y):\n        pass",
  "def cancelSelect(self):\n        pass",
  "def cancel(self):\n        if isinstance(self.state, self.states['select']):\n            self.cancelSelect()",
  "def beginSelect(self, x, y):\n        self.startPt = self.plot.pixelToData(x, y)\n        assert self.startPt is not None",
  "def select(self, x, y):\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n\n        self.setSelectionArea((self.startPt,\n                              (self.startPt[0], dataPos[1]),\n                              dataPos,\n                              (dataPos[0], self.startPt[1])),\n                              fill='hatch',\n                              color=self.color)\n\n        eventDict = prepareDrawingSignal('drawingProgress',\n                                         'rectangle',\n                                         (self.startPt, dataPos),\n                                         self.parameters)\n        self.plot.notify(**eventDict)",
  "def endSelect(self, x, y):\n        self.resetSelectionArea()\n\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n\n        eventDict = prepareDrawingSignal('drawingFinished',\n                                         'rectangle',\n                                         (self.startPt, dataPos),\n                                         self.parameters)\n        self.plot.notify(**eventDict)",
  "def cancelSelect(self):\n        self.resetSelectionArea()",
  "def beginSelect(self, x, y):\n        self.startPt = self.plot.pixelToData(x, y)\n        assert self.startPt is not None",
  "def select(self, x, y):\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n\n        self.setSelectionArea((self.startPt, dataPos),\n                              fill='hatch',\n                              color=self.color)\n\n        eventDict = prepareDrawingSignal('drawingProgress',\n                                         'line',\n                                         (self.startPt, dataPos),\n                                         self.parameters)\n        self.plot.notify(**eventDict)",
  "def endSelect(self, x, y):\n        self.resetSelectionArea()\n\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n\n        eventDict = prepareDrawingSignal('drawingFinished',\n                                         'line',\n                                         (self.startPt, dataPos),\n                                         self.parameters)\n        self.plot.notify(**eventDict)",
  "def cancelSelect(self):\n        self.resetSelectionArea()",
  "class Idle(State):\n        def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('select', x, y)\n                return True",
  "class Select(State):\n        def enter(self, x, y):\n            self.onMove(x, y)\n\n        def onMove(self, x, y):\n            self.machine.select(x, y)\n\n        def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.endSelect(x, y)\n                self.goto('idle')\n\n        def onWheel(self, x, y, angle):\n            self.machine.onWheel(x, y, angle)  # Call select default wheel\n            self.machine.select(x, y)",
  "def __init__(self, plot, parameters):\n        states = {\n            'idle': Select1Point.Idle,\n            'select': Select1Point.Select\n        }\n        super(Select1Point, self).__init__(plot, parameters, states, 'idle')",
  "def select(self, x, y):\n        pass",
  "def endSelect(self, x, y):\n        pass",
  "def cancelSelect(self):\n        pass",
  "def cancel(self):\n        if isinstance(self.state, self.states['select']):\n            self.cancelSelect()",
  "def _hLine(self, y):\n        \"\"\"Return points in data coords of the segment visible in the plot.\n\n        Supports non-orthogonal axes.\n        \"\"\"\n        left, top, width, height = self.plot.getPlotBoundsInPixels()\n\n        dataPos1 = self.plot.pixelToData(left, y, check=False)\n        dataPos2 = self.plot.pixelToData(left + width, y, check=False)\n        return dataPos1, dataPos2",
  "def select(self, x, y):\n        points = self._hLine(y)\n        self.setSelectionArea(points, fill='hatch', color=self.color)\n\n        eventDict = prepareDrawingSignal('drawingProgress',\n                                         'hline',\n                                         points,\n                                         self.parameters)\n        self.plot.notify(**eventDict)",
  "def endSelect(self, x, y):\n        self.resetSelectionArea()\n\n        eventDict = prepareDrawingSignal('drawingFinished',\n                                         'hline',\n                                         self._hLine(y),\n                                         self.parameters)\n        self.plot.notify(**eventDict)",
  "def cancelSelect(self):\n        self.resetSelectionArea()",
  "def _vLine(self, x):\n        \"\"\"Return points in data coords of the segment visible in the plot.\n\n        Supports non-orthogonal axes.\n        \"\"\"\n        left, top, width, height = self.plot.getPlotBoundsInPixels()\n\n        dataPos1 = self.plot.pixelToData(x, top, check=False)\n        dataPos2 = self.plot.pixelToData(x, top + height, check=False)\n        return dataPos1, dataPos2",
  "def select(self, x, y):\n        points = self._vLine(x)\n        self.setSelectionArea(points, fill='hatch', color=self.color)\n\n        eventDict = prepareDrawingSignal('drawingProgress',\n                                         'vline',\n                                         points,\n                                         self.parameters)\n        self.plot.notify(**eventDict)",
  "def endSelect(self, x, y):\n        self.resetSelectionArea()\n\n        eventDict = prepareDrawingSignal('drawingFinished',\n                                         'vline',\n                                         self._vLine(x),\n                                         self.parameters)\n        self.plot.notify(**eventDict)",
  "def cancelSelect(self):\n        self.resetSelectionArea()",
  "class Idle(ClickOrDrag.Idle):\n        def __init__(self, *args, **kw):\n            super(ItemsInteraction.Idle, self).__init__(*args, **kw)\n            self._hoverMarker = None\n\n        def onWheel(self, x, y, angle):\n            scaleF = 1.1 if angle > 0 else 1./1.1\n            _applyZoomToPlot(self.machine.plot, x, y, scaleF)\n\n        def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                marker = self.machine.plot._pickMarker(\n                    x, y,\n                    lambda marker: marker['selectable'] or marker['draggable'])\n                if marker is not None:\n                    self.goto('clickOrDrag', x, y)\n                    return True\n\n                else:\n                    picked = self.machine.plot._pickImageOrCurve(\n                        x,\n                        y,\n                        lambda item: (item['selectable'] or\n                                      item.get('draggable', False)))\n                    if picked is not None:\n                        self.goto('clickOrDrag', x, y)\n                        return True\n\n            return False\n\n        def onMove(self, x, y):\n            marker = self.machine.plot._pickMarker(x, y)\n            if marker is not None:\n                dataPos = self.machine.plot.pixelToData(x, y)\n                assert dataPos is not None\n                eventDict = prepareHoverSignal(\n                    marker['legend'], 'marker',\n                    dataPos, (x, y),\n                    marker['draggable'],\n                    marker['selectable'])\n                self.machine.plot.notify(**eventDict)\n\n            if marker != self._hoverMarker:\n                self._hoverMarker = marker\n\n                if marker is None:\n                    self.machine.plot.setGraphCursorShape()\n\n                elif marker['draggable']:\n                    if marker['x'] is None:\n                        self.machine.plot.setGraphCursorShape(CURSOR_SIZE_VER)\n                    elif marker['y'] is None:\n                        self.machine.plot.setGraphCursorShape(CURSOR_SIZE_HOR)\n                    else:\n                        self.machine.plot.setGraphCursorShape(CURSOR_SIZE_ALL)\n\n                elif marker['selectable']:\n                    self.machine.plot.setGraphCursorShape(CURSOR_POINTING)\n\n            return True",
  "def __init__(self, plot):\n        _PlotInteraction.__init__(self, plot)\n\n        states = {\n            'idle': ItemsInteraction.Idle,\n            'clickOrDrag': ClickOrDrag.ClickOrDrag,\n            'drag': ClickOrDrag.Drag\n        }\n        StateMachine.__init__(self, states, 'idle')",
  "def click(self, x, y, btn):\n        # Signal mouse clicked event\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n        eventDict = prepareMouseSignal('mouseClicked', btn,\n                                       dataPos[0], dataPos[1],\n                                       x, y)\n        self.plot.notify(**eventDict)\n\n        if btn == LEFT_BTN:\n            marker = self.plot._pickMarker(\n                x, y, lambda marker: marker['selectable'])\n            if marker is not None:\n                xData, yData = marker['x'], marker['y']\n                if xData is None:\n                    xData = [0, 1]\n                if yData is None:\n                    yData = [0, 1]\n\n                eventDict = prepareMarkerSignal('markerClicked',\n                                                'left',\n                                                marker['legend'],\n                                                'marker',\n                                                marker['draggable'],\n                                                marker['selectable'],\n                                                (xData, yData),\n                                                (x, y), None)\n                self.plot.notify(**eventDict)\n\n            else:\n                picked = self.plot._pickImageOrCurve(\n                    x, y, lambda item: item['selectable'])\n\n                if picked is None:\n                    pass\n                elif picked[0] == 'curve':\n                    curve = picked[1]\n\n                    dataPos = self.plot.pixelToData(x, y)\n                    assert dataPos is not None\n\n                    eventDict = prepareCurveSignal('left',\n                                                   curve['legend'],\n                                                   'curve',\n                                                   picked[2], picked[3],\n                                                   dataPos[0], dataPos[1],\n                                                   x, y)\n                    self.plot.notify(**eventDict)\n\n                elif picked[0] == 'image':\n                    image = picked[1]\n\n                    dataPos = self.plot.pixelToData(x, y)\n                    assert dataPos is not None\n\n                    # Get corresponding coordinate in image\n                    column = int((dataPos[0] - image['origin'][0]) /\n                                 float(image['scale'][0]))\n                    row = int((dataPos[1] - image['origin'][1]) /\n                              float(image['scale'][1]))\n\n                    eventDict = prepareImageSignal('left',\n                                                   image['legend'],\n                                                   'image',\n                                                   column, row,\n                                                   dataPos[0], dataPos[1],\n                                                   x, y)\n                    self.plot.notify(**eventDict)",
  "def _signalMarkerMovingEvent(self, eventType, marker, x, y):\n        assert marker is not None\n\n        xData, yData = marker['x'], marker['y']\n        if xData is None:\n            xData = [0, 1]\n        if yData is None:\n            yData = [0, 1]\n\n        posDataCursor = self.plot.pixelToData(x, y)\n        assert posDataCursor is not None\n\n        eventDict = prepareMarkerSignal(eventType,\n                                        'left',\n                                        marker['legend'],\n                                        'marker',\n                                        marker['draggable'],\n                                        marker['selectable'],\n                                        (xData, yData),\n                                        (x, y),\n                                        posDataCursor)\n        self.plot.notify(**eventDict)",
  "def beginDrag(self, x, y):\n        self._lastPos = self.plot.pixelToData(x, y)\n        assert self._lastPos is not None\n\n        self.imageLegend = None\n        self.markerLegend = None\n        marker = self.plot._pickMarker(\n            x, y, lambda marker: marker['draggable'])\n\n        if marker is not None:\n            self.markerLegend = marker['legend']\n            self._signalMarkerMovingEvent('markerMoving', marker, x, y)\n        else:\n            picked = self.plot._pickImageOrCurve(\n                x,\n                y,\n                lambda item: item.get('draggable', False))\n            if picked is None:\n                self.imageLegend = None\n                self.plot.setGraphCursorShape()\n            else:\n                assert picked[0] == 'image'  # For now only drag images\n                self.imageLegend = picked[1]['legend']",
  "def drag(self, x, y):\n        dataPos = self.plot.pixelToData(x, y)\n        assert dataPos is not None\n        xData, yData = dataPos\n\n        if self.markerLegend is not None:\n            marker = self.plot._getMarker(self.markerLegend)\n            if marker['constraint'] is not None:\n                xData, yData = marker['constraint'](xData, yData)\n\n            self.plot._moveMarker(self.markerLegend, xData, yData)\n\n            self._signalMarkerMovingEvent(\n                'markerMoving', self.plot._getMarker(self.markerLegend), x, y)\n\n        if self.imageLegend is not None:\n            dx, dy = xData - self._lastPos[0], yData - self._lastPos[1]\n            self.plot._moveImage(self.imageLegend, dx, dy)\n\n        self._lastPos = xData, yData",
  "def endDrag(self, startPos, endPos):\n        if self.markerLegend is not None:\n            marker = self.plot._getMarker(self.markerLegend)\n            posData = [marker['x'], marker['y']]\n            if posData[0] is None:\n                posData[0] = [0, 1]\n            if posData[1] is None:\n                posData[1] = [0, 1]\n\n            eventDict = prepareMarkerSignal(\n                'markerMoved',\n                'left',\n                marker['legend'],\n                'marker',\n                marker['draggable'],\n                marker['selectable'],\n                posData)\n            self.plot.notify(**eventDict)\n\n        self.plot.setGraphCursorShape()\n\n        del self.markerLegend\n        del self.imageLegend\n        del self._lastPos",
  "def cancel(self):\n        self.plot.setGraphCursorShape()",
  "class Idle(State):\n        def onPress(self, x, y, btn):\n            for eventHandler in self.machine.eventHandlers:\n                requestFocus = eventHandler.handleEvent('press', x, y, btn)\n                if requestFocus:\n                    self.goto('focus', eventHandler, btn)\n                    break\n\n        def _processEvent(self, *args):\n            for eventHandler in self.machine.eventHandlers:\n                consumeEvent = eventHandler.handleEvent(*args)\n                if consumeEvent:\n                    break\n\n        def onMove(self, x, y):\n            self._processEvent('move', x, y)\n\n        def onRelease(self, x, y, btn):\n            self._processEvent('release', x, y, btn)\n\n        def onWheel(self, x, y, angle):\n            self._processEvent('wheel', x, y, angle)",
  "class Focus(State):\n        def enter(self, eventHandler, btn):\n            self.eventHandler = eventHandler\n            self.focusBtns = set((btn,))\n\n        def onPress(self, x, y, btn):\n            self.focusBtns.add(btn)\n            self.eventHandler.handleEvent('press', x, y, btn)\n\n        def onMove(self, x, y):\n            self.eventHandler.handleEvent('move', x, y)\n\n        def onRelease(self, x, y, btn):\n            self.focusBtns.discard(btn)\n            requestFocus = self.eventHandler.handleEvent('release', x, y, btn)\n            if len(self.focusBtns) == 0 and not requestFocus:\n                self.goto('idle')\n\n        def onWheel(self, x, y, angleInDegrees):\n            self.eventHandler.handleEvent('wheel', x, y, angleInDegrees)",
  "def __init__(self, eventHandlers=()):\n        self.eventHandlers = list(eventHandlers)\n\n        states = {\n            'idle': FocusManager.Idle,\n            'focus': FocusManager.Focus\n        }\n        super(FocusManager, self).__init__(states, 'idle')",
  "def cancel(self):\n        for handler in self.eventHandlers:\n            handler.cancel()",
  "def __init__(self, plot, color):\n        eventHandlers = ItemsInteraction(plot), Zoom(plot, color)\n        super(ZoomAndSelect, self).__init__(eventHandlers)",
  "def color(self):\n        return self.eventHandlers[1].color",
  "def __init__(self, plot):\n        self._plot = weakref.ref(plot)  # Avoid cyclic-ref\n\n        self.zoomOnWheel = True\n        \"\"\"True to enable zoom on wheel, False otherwise.\"\"\"\n\n        # Default event handler\n        self._eventHandler = ItemsInteraction(plot)",
  "def getInteractiveMode(self):\n        \"\"\"Returns the current interactive mode as a dict.\n\n        The returned dict contains at least the key 'mode'.\n        Mode can be: 'draw', 'pan', 'select', 'zoom'.\n        It can also contains extra keys (e.g., 'color') specific to a mode\n        as provided to :meth:`setInteractiveMode`.\n        \"\"\"\n        if isinstance(self._eventHandler, ZoomAndSelect):\n            return {'mode': 'zoom', 'color': self._eventHandler.color}\n\n        elif isinstance(self._eventHandler, Select):\n            result = self._eventHandler.parameters.copy()\n            result['mode'] = 'draw'\n            return result\n\n        elif isinstance(self._eventHandler, Pan):\n            return {'mode': 'pan'}\n\n        else:\n            return {'mode': 'select'}",
  "def setInteractiveMode(self, mode, color='black',\n                           shape='polygon', label=None):\n        \"\"\"Switch the interactive mode.\n\n        :param str mode: The name of the interactive mode.\n                         In 'draw', 'pan', 'select', 'zoom'.\n        :param color: Only for 'draw' and 'zoom' modes.\n                      Color to use for drawing selection area. Default black.\n        :type color: Color description: The name as a str or\n                     a tuple of 4 floats.\n        :param str shape: Only for 'draw' mode. The kind of shape to draw.\n                          In 'polygon', 'rectangle', 'line', 'vline', 'hline'.\n                          Default is 'polygon'.\n        :param str label: Only for 'draw' mode.\n        \"\"\"\n        assert mode in ('draw', 'pan', 'select', 'zoom')\n\n        plot = self._plot()\n        assert plot is not None\n\n        if mode == 'draw':\n            assert shape in self._DRAW_MODES\n            eventHandlerClass = self._DRAW_MODES[shape]\n            parameters = {\n                'shape': shape,\n                'label': label,\n                'color': Colors.rgba(color)\n            }\n\n            self._eventHandler.cancel()\n            self._eventHandler = eventHandlerClass(plot, parameters)\n\n        elif mode == 'pan':\n            # Ignores color, shape and label\n            self._eventHandler.cancel()\n            self._eventHandler = Pan(plot)\n\n        elif mode == 'zoom':\n            # Ignores shape and label\n            if color != 'video inverted':\n                color = Colors.rgba(color)\n            self._eventHandler.cancel()\n            self._eventHandler = ZoomAndSelect(plot, color)\n\n        else:  # Default mode: interaction with plot objects\n            # Ignores color, shape and label\n            self._eventHandler.cancel()\n            self._eventHandler = ItemsInteraction(plot)",
  "def handleEvent(self, event, *args, **kwargs):\n        \"\"\"Forward event to current interactive mode state machine.\"\"\"\n        if not self.zoomOnWheel and event == 'wheel':\n            return  # Discard wheel events\n        self._eventHandler.handleEvent(event, *args, **kwargs)",
  "def onWheel(self, x, y, angle):\n            scaleF = 1.1 if angle > 0 else 1./1.1\n            _applyZoomToPlot(self.machine.plot, x, y, scaleF)",
  "def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('select', x, y)\n                return True",
  "def enter(self, x, y):\n            dataPos = self.machine.plot.pixelToData(x, y)\n            assert dataPos is not None\n            self.points = [dataPos, dataPos]",
  "def updateSelectionArea(self):\n            self.machine.setSelectionArea(self.points,\n                                          fill='hatch',\n                                          color=self.machine.color)\n            eventDict = prepareDrawingSignal('drawingProgress',\n                                             'polygon',\n                                             self.points,\n                                             self.machine.parameters)\n            self.machine.plot.notify(**eventDict)",
  "def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                dataPos = self.machine.plot.pixelToData(x, y)\n                assert dataPos is not None\n                self.points[-1] = dataPos\n                self.updateSelectionArea()\n                if self.points[-2] != self.points[-1]:\n                    self.points.append(dataPos)\n                return True",
  "def onMove(self, x, y):\n            dataPos = self.machine.plot.pixelToData(x, y)\n            assert dataPos is not None\n            self.points[-1] = dataPos\n            self.updateSelectionArea()",
  "def onPress(self, x, y, btn):\n            if btn == RIGHT_BTN:\n                self.machine.resetSelectionArea()\n\n                dataPos = self.machine.plot.pixelToData(x, y)\n                assert dataPos is not None\n                self.points[-1] = dataPos\n                if self.points[-2] == self.points[-1]:\n                    self.points.pop()\n                self.points.append(self.points[0])\n\n                eventDict = prepareDrawingSignal('drawingFinished',\n                                                 'polygon',\n                                                 self.points,\n                                                 self.machine.parameters)\n                self.machine.plot.notify(**eventDict)\n                self.goto('idle')",
  "def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('start', x, y)\n                return True",
  "def enter(self, x, y):\n            self.machine.beginSelect(x, y)",
  "def onMove(self, x, y):\n            self.goto('select', x, y)",
  "def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('select', x, y)\n                return True",
  "def enter(self, x, y):\n            self.onMove(x, y)",
  "def onMove(self, x, y):\n            self.machine.select(x, y)",
  "def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.endSelect(x, y)\n                self.goto('idle')",
  "def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.goto('select', x, y)\n                return True",
  "def enter(self, x, y):\n            self.onMove(x, y)",
  "def onMove(self, x, y):\n            self.machine.select(x, y)",
  "def onRelease(self, x, y, btn):\n            if btn == LEFT_BTN:\n                self.machine.endSelect(x, y)\n                self.goto('idle')",
  "def onWheel(self, x, y, angle):\n            self.machine.onWheel(x, y, angle)  # Call select default wheel\n            self.machine.select(x, y)",
  "def __init__(self, *args, **kw):\n            super(ItemsInteraction.Idle, self).__init__(*args, **kw)\n            self._hoverMarker = None",
  "def onWheel(self, x, y, angle):\n            scaleF = 1.1 if angle > 0 else 1./1.1\n            _applyZoomToPlot(self.machine.plot, x, y, scaleF)",
  "def onPress(self, x, y, btn):\n            if btn == LEFT_BTN:\n                marker = self.machine.plot._pickMarker(\n                    x, y,\n                    lambda marker: marker['selectable'] or marker['draggable'])\n                if marker is not None:\n                    self.goto('clickOrDrag', x, y)\n                    return True\n\n                else:\n                    picked = self.machine.plot._pickImageOrCurve(\n                        x,\n                        y,\n                        lambda item: (item['selectable'] or\n                                      item.get('draggable', False)))\n                    if picked is not None:\n                        self.goto('clickOrDrag', x, y)\n                        return True\n\n            return False",
  "def onMove(self, x, y):\n            marker = self.machine.plot._pickMarker(x, y)\n            if marker is not None:\n                dataPos = self.machine.plot.pixelToData(x, y)\n                assert dataPos is not None\n                eventDict = prepareHoverSignal(\n                    marker['legend'], 'marker',\n                    dataPos, (x, y),\n                    marker['draggable'],\n                    marker['selectable'])\n                self.machine.plot.notify(**eventDict)\n\n            if marker != self._hoverMarker:\n                self._hoverMarker = marker\n\n                if marker is None:\n                    self.machine.plot.setGraphCursorShape()\n\n                elif marker['draggable']:\n                    if marker['x'] is None:\n                        self.machine.plot.setGraphCursorShape(CURSOR_SIZE_VER)\n                    elif marker['y'] is None:\n                        self.machine.plot.setGraphCursorShape(CURSOR_SIZE_HOR)\n                    else:\n                        self.machine.plot.setGraphCursorShape(CURSOR_SIZE_ALL)\n\n                elif marker['selectable']:\n                    self.machine.plot.setGraphCursorShape(CURSOR_POINTING)\n\n            return True",
  "def onPress(self, x, y, btn):\n            for eventHandler in self.machine.eventHandlers:\n                requestFocus = eventHandler.handleEvent('press', x, y, btn)\n                if requestFocus:\n                    self.goto('focus', eventHandler, btn)\n                    break",
  "def _processEvent(self, *args):\n            for eventHandler in self.machine.eventHandlers:\n                consumeEvent = eventHandler.handleEvent(*args)\n                if consumeEvent:\n                    break",
  "def onMove(self, x, y):\n            self._processEvent('move', x, y)",
  "def onRelease(self, x, y, btn):\n            self._processEvent('release', x, y, btn)",
  "def onWheel(self, x, y, angle):\n            self._processEvent('wheel', x, y, angle)",
  "def enter(self, eventHandler, btn):\n            self.eventHandler = eventHandler\n            self.focusBtns = set((btn,))",
  "def onPress(self, x, y, btn):\n            self.focusBtns.add(btn)\n            self.eventHandler.handleEvent('press', x, y, btn)",
  "def onMove(self, x, y):\n            self.eventHandler.handleEvent('move', x, y)",
  "def onRelease(self, x, y, btn):\n            self.focusBtns.discard(btn)\n            requestFocus = self.eventHandler.handleEvent('release', x, y, btn)\n            if len(self.focusBtns) == 0 and not requestFocus:\n                self.goto('idle')",
  "def onWheel(self, x, y, angleInDegrees):\n            self.eventHandler.handleEvent('wheel', x, y, angleInDegrees)",
  "def prepareDrawingSignal(event, type_, points, parameters=None):\n    \"\"\"See Plot documentation for content of events\"\"\"\n    assert event in ('drawingProgress', 'drawingFinished')\n\n    if parameters is None:\n        parameters = {}\n\n    eventDict = {}\n    eventDict['event'] = event\n    eventDict['type'] = type_\n    points = np.array(points, dtype=np.float32)\n    points.shape = -1, 2\n    eventDict['points'] = points\n    eventDict['xdata'] = points[:, 0]\n    eventDict['ydata'] = points[:, 1]\n    if type_ in ('rectangle',):\n        eventDict['x'] = eventDict['xdata'].min()\n        eventDict['y'] = eventDict['ydata'].min()\n        eventDict['width'] = eventDict['xdata'].max() - eventDict['x']\n        eventDict['height'] = eventDict['ydata'].max() - eventDict['y']\n    eventDict['parameters'] = parameters.copy()\n    return eventDict",
  "def prepareMouseSignal(eventType, button, xData, yData, xPixel, yPixel):\n    \"\"\"See Plot documentation for content of events\"\"\"\n    assert eventType in ('mouseMoved', 'mouseClicked', 'mouseDoubleClicked')\n    assert button in (None, 'left', 'right')\n\n    return {'event': eventType,\n            'x': xData,\n            'y': yData,\n            'xpixel': xPixel,\n            'ypixel': yPixel,\n            'button': button}",
  "def prepareHoverSignal(label, type_, posData, posPixel, draggable, selectable):\n    \"\"\"See Plot documentation for content of events\"\"\"\n    return {'event': 'hover',\n            'label': label,\n            'type': type_,\n            'x': posData[0],\n            'y': posData[1],\n            'xpixel': posPixel[0],\n            'ypixel': posPixel[1],\n            'draggable': draggable,\n            'selectable': selectable}",
  "def prepareMarkerSignal(eventType, button, label, type_,\n                        draggable, selectable,\n                        posDataMarker,\n                        posPixelCursor=None, posDataCursor=None):\n    \"\"\"See Plot documentation for content of events\"\"\"\n    if eventType == 'markerClicked':\n        assert posPixelCursor is not None\n        assert posDataCursor is None\n\n        posDataCursor = list(posDataMarker)\n        if hasattr(posDataCursor[0], \"__len__\"):\n            posDataCursor[0] = posDataCursor[0][-1]\n        if hasattr(posDataCursor[1], \"__len__\"):\n            posDataCursor[1] = posDataCursor[1][-1]\n\n    elif eventType == 'markerMoving':\n        assert posPixelCursor is not None\n        assert posDataCursor is not None\n\n    elif eventType == 'markerMoved':\n        assert posPixelCursor is None\n        assert posDataCursor is None\n\n        posDataCursor = posDataMarker\n    else:\n        raise NotImplementedError(\"Unknown event type {0}\".format(eventType))\n\n    eventDict = {'event': eventType,\n                 'button': button,\n                 'label': label,\n                 'type': type_,\n                 'x': posDataCursor[0],\n                 'y': posDataCursor[1],\n                 'xdata': posDataMarker[0],\n                 'ydata': posDataMarker[1],\n                 'draggable': draggable,\n                 'selectable': selectable}\n\n    if eventType in ('markerMoving', 'markerClicked'):\n        eventDict['xpixel'] = posPixelCursor[0]\n        eventDict['ypixel'] = posPixelCursor[1]\n\n    return eventDict",
  "def prepareImageSignal(button, label, type_, col, row,\n                       x, y, xPixel, yPixel):\n    \"\"\"See Plot documentation for content of events\"\"\"\n    return {'event': 'imageClicked',\n            'button': button,\n            'label': label,\n            'type': type_,\n            'col': col,\n            'row': row,\n            'x': x,\n            'y': y,\n            'xpixel': xPixel,\n            'ypixel': yPixel}",
  "def prepareCurveSignal(button, label, type_, xData, yData,\n                       x, y, xPixel, yPixel):\n    \"\"\"See Plot documentation for content of events\"\"\"\n    return {'event': 'curveClicked',\n            'button': button,\n            'label': label,\n            'type': type_,\n            'xdata': xData,\n            'ydata': yData,\n            'x': x,\n            'y': y,\n            'xpixel': xPixel,\n            'ypixel': yPixel}",
  "def prepareLimitsChangedSignal(sourceObj, xRange, yRange, y2Range):\n    \"\"\"See Plot documentation for content of events\"\"\"\n    return {'event': 'limitsChanged',\n            'source': id(sourceObj),\n            'xdata': xRange,\n            'ydata': yRange,\n            'y2data': y2Range}",
  "class PlotWindow(PlotWidget):\n    \"\"\"Qt Widget providing a 1D/2D plot area and additional tools.\n\n    This widget includes the following QAction as attributes:\n\n    - resetZoomAction: Reset zoom\n    - xAxisAutoScaleAction: Toggle X axis autoscale\n    - yAxisAutoScaleAction: Toggle Y axis autoscale\n    - xAxisLogarithmicAction: Toggle X axis log scale\n    - yAxisLogarithmicAction: Toggle Y axis log scale\n    - gridAction: Toggle plot grid\n    - curveStyleAction: Change curve line and markers style\n    - colormapAction: Open a colormap dialog to change active image\n      and default colormap.\n    - keepDataAspectRatioAction: Toggle keep aspect ratio\n    - yAxisInvertedAction: Toggle Y Axis direction\n    - copyAction: Copy plot snapshot to clipboard\n    - saveAction: Save plot\n    - printAction: Print plot\n\n    Initialiser parameters:\n\n    :param parent: The parent of this widget or None.\n    :param backend: The backend to use for the plot.\n                    The default is to use matplotlib.\n    :type backend: str or :class:`BackendBase.BackendBase`\n    :param bool resetzoom: Toggle visibility of reset zoom action.\n    :param bool autoScale: Toggle visibility of axes autoscale actions.\n    :param bool logScale: Toggle visibility of axes log scale actions.\n    :param bool grid: Toggle visibility of grid mode action.\n    :param bool curveStyle: Toggle visibility of curve style action.\n    :param bool colormap: Toggle visibility of colormap action.\n    :param bool aspectRatio: Toggle visibility of aspect ration action.\n    :param bool yInverted: Toggle visibility of Y axis direction action.\n    :param bool copy: Toggle visibility of copy action.\n    :param bool save: Toggle visibility of save action.\n    :param bool print_: Toggle visibility of print action.\n    :param bool control: True to display an Options button with a sub-menu\n                         to show legends, toggle crosshair and pan with arrows.\n                         (Default: False)\n    :param position: True to display widget with (x, y) mouse position\n                     (Default: False).\n                     It also supports a list of (name, function(x, y)->value)\n                     to customize the displayed values.\n                     See :class:`silx.gui.plot.PlotTools.PositionInfo`.\n    :param bool autoreplot: Toggle autoreplot mode (Default: True).\n    \"\"\"\n\n    def __init__(self, parent=None, backend=None,\n                 resetzoom=True, autoScale=True, logScale=True, grid=True,\n                 curveStyle=True, colormap=True,\n                 aspectRatio=True, yInverted=True,\n                 copy=True, save=True, print_=True,\n                 control=False, position=False,\n                 autoreplot=True):\n        super(PlotWindow, self).__init__(\n            parent=parent, backend=backend, autoreplot=autoreplot)\n\n        # Init actions\n        self.group = qt.QActionGroup(self)\n        self.group.setExclusive(False)\n\n        self.resetZoomAction = self.group.addAction(ResetZoomAction(self))\n        self.resetZoomAction.setVisible(resetzoom)\n\n        self.xAxisAutoScaleAction = self.group.addAction(\n            XAxisAutoScaleAction(self))\n        self.xAxisAutoScaleAction.setVisible(autoScale)\n\n        self.yAxisAutoScaleAction = self.group.addAction(\n            YAxisAutoScaleAction(self))\n        self.yAxisAutoScaleAction.setVisible(autoScale)\n\n        self.xAxisLogarithmicAction = self.group.addAction(\n            XAxisLogarithmicAction(self))\n        self.xAxisLogarithmicAction.setVisible(logScale)\n\n        self.yAxisLogarithmicAction = self.group.addAction(\n            YAxisLogarithmicAction(self))\n        self.yAxisLogarithmicAction.setVisible(logScale)\n\n        self.gridAction = self.group.addAction(\n            GridAction(self, gridMode='both'))\n        self.gridAction.setVisible(grid)\n\n        self.curveStyleAction = self.group.addAction(CurveStyleAction(self))\n        self.curveStyleAction.setVisible(curveStyle)\n\n        self.colormapAction = self.group.addAction(ColormapAction(self))\n        self.colormapAction.setVisible(colormap)\n\n        self.keepDataAspectRatioAction = self.group.addAction(\n            KeepAspectRatioAction(self))\n        self.keepDataAspectRatioAction.setVisible(aspectRatio)\n\n        self.yAxisInvertedAction = self.group.addAction(\n            YAxisInvertedAction(self))\n        self.yAxisInvertedAction.setVisible(yInverted)\n\n        self._separator = qt.QAction('separator', self)\n        self._separator.setSeparator(True)\n        self.group.addAction(self._separator)\n\n        self.copyAction = self.group.addAction(CopyAction(self))\n        self.copyAction.setVisible(copy)\n\n        self.saveAction = self.group.addAction(SaveAction(self))\n        self.saveAction.setVisible(save)\n\n        self.printAction = self.group.addAction(PrintAction(self))\n        self.printAction.setVisible(print_)\n\n        if control or position:\n            toolBar = qt.QToolBar(self)\n            self.addToolBar(qt.Qt.BottomToolBarArea, toolBar)\n\n            if control:\n                self.controlButton = qt.QPushButton(\"Options\")\n                self.controlButton.setAutoDefault(False)\n                self.controlButton.clicked.connect(self._controlButtonClicked)\n\n                toolBar.addWidget(self.controlButton)\n\n            if position:  # Add PositionInfo widget to the bottom of the plot\n                if isinstance(position, collections.Iterable):\n                    converters = position  # Use position as a set of converters\n                else:\n                    converters = None\n                self.positionWidget = PositionInfo(self, converters=converters)\n                self.positionWidget.autoSnapToActiveCurve = True\n\n                toolBar.addWidget(self.positionWidget)\n\n        self._toolBar = self.toolBar(parent=self)\n        self.addToolBar(self._toolBar)\n        self._menu = self.menu()\n        self.menuBar().addMenu(self._menu)\n\n    @property\n    def legendsDockWidget(self):\n        \"\"\"DockWidget with Legend panel (lazy-loaded).\"\"\"\n        if not hasattr(self, '_legendsDockWidget'):\n            self._legendsDockWidget = LegendsDockWidget(self)\n            self._legendsDockWidget.hide()\n        return self._legendsDockWidget\n\n    @property\n    def crosshairAction(self):\n        \"\"\"Action toggling crosshair cursor mode (lazy-loaded).\"\"\"\n        if not hasattr(self, '_crosshairAction'):\n            self._crosshairAction = CrosshairAction(self, color='red')\n        return self._crosshairAction\n\n    @property\n    def panWithArrowKeysAction(self):\n        \"\"\"Action toggling pan with arrow keys (lazy-loaded).\"\"\"\n        if not hasattr(self, '_panWithArrowKeysAction'):\n            self._panWithArrowKeysAction = PanWithArrowKeysAction(self)\n        return self._panWithArrowKeysAction\n\n    def toolBar(self, title='Plot', parent=None):\n        \"\"\"Return a QToolBar from the QAction of the PlotWindow.\n\n        :param str title: The title of the QMenu\n        :param parent: See :class:`QToolBar`\n        \"\"\"\n        toolbar = qt.QToolBar(title, parent)\n        for action in self.group.actions():\n            toolbar.addAction(action)\n        return toolbar\n\n    def menu(self, title='Plot', parent=None):\n        \"\"\"Return a QMenu from the QAction of the PlotWindow.\n\n        :param str title: The title of the QMenu\n        :param parent: See :class:`QMenu`\n        \"\"\"\n        menu = qt.QMenu(title, parent)\n        for action in self.group.actions():\n            menu.addAction(action)\n        return menu\n\n    def _controlButtonClicked(self):\n        \"\"\"Display Options button sub-menu.\"\"\"\n        controlMenu = qt.QMenu()\n        controlMenu.addAction(self.legendsDockWidget.toggleViewAction())\n        controlMenu.addAction(self.crosshairAction)\n        controlMenu.addAction(self.panWithArrowKeysAction)\n        controlMenu.exec_(self.cursor().pos())",
  "def __init__(self, parent=None, backend=None,\n                 resetzoom=True, autoScale=True, logScale=True, grid=True,\n                 curveStyle=True, colormap=True,\n                 aspectRatio=True, yInverted=True,\n                 copy=True, save=True, print_=True,\n                 control=False, position=False,\n                 autoreplot=True):\n        super(PlotWindow, self).__init__(\n            parent=parent, backend=backend, autoreplot=autoreplot)\n\n        # Init actions\n        self.group = qt.QActionGroup(self)\n        self.group.setExclusive(False)\n\n        self.resetZoomAction = self.group.addAction(ResetZoomAction(self))\n        self.resetZoomAction.setVisible(resetzoom)\n\n        self.xAxisAutoScaleAction = self.group.addAction(\n            XAxisAutoScaleAction(self))\n        self.xAxisAutoScaleAction.setVisible(autoScale)\n\n        self.yAxisAutoScaleAction = self.group.addAction(\n            YAxisAutoScaleAction(self))\n        self.yAxisAutoScaleAction.setVisible(autoScale)\n\n        self.xAxisLogarithmicAction = self.group.addAction(\n            XAxisLogarithmicAction(self))\n        self.xAxisLogarithmicAction.setVisible(logScale)\n\n        self.yAxisLogarithmicAction = self.group.addAction(\n            YAxisLogarithmicAction(self))\n        self.yAxisLogarithmicAction.setVisible(logScale)\n\n        self.gridAction = self.group.addAction(\n            GridAction(self, gridMode='both'))\n        self.gridAction.setVisible(grid)\n\n        self.curveStyleAction = self.group.addAction(CurveStyleAction(self))\n        self.curveStyleAction.setVisible(curveStyle)\n\n        self.colormapAction = self.group.addAction(ColormapAction(self))\n        self.colormapAction.setVisible(colormap)\n\n        self.keepDataAspectRatioAction = self.group.addAction(\n            KeepAspectRatioAction(self))\n        self.keepDataAspectRatioAction.setVisible(aspectRatio)\n\n        self.yAxisInvertedAction = self.group.addAction(\n            YAxisInvertedAction(self))\n        self.yAxisInvertedAction.setVisible(yInverted)\n\n        self._separator = qt.QAction('separator', self)\n        self._separator.setSeparator(True)\n        self.group.addAction(self._separator)\n\n        self.copyAction = self.group.addAction(CopyAction(self))\n        self.copyAction.setVisible(copy)\n\n        self.saveAction = self.group.addAction(SaveAction(self))\n        self.saveAction.setVisible(save)\n\n        self.printAction = self.group.addAction(PrintAction(self))\n        self.printAction.setVisible(print_)\n\n        if control or position:\n            toolBar = qt.QToolBar(self)\n            self.addToolBar(qt.Qt.BottomToolBarArea, toolBar)\n\n            if control:\n                self.controlButton = qt.QPushButton(\"Options\")\n                self.controlButton.setAutoDefault(False)\n                self.controlButton.clicked.connect(self._controlButtonClicked)\n\n                toolBar.addWidget(self.controlButton)\n\n            if position:  # Add PositionInfo widget to the bottom of the plot\n                if isinstance(position, collections.Iterable):\n                    converters = position  # Use position as a set of converters\n                else:\n                    converters = None\n                self.positionWidget = PositionInfo(self, converters=converters)\n                self.positionWidget.autoSnapToActiveCurve = True\n\n                toolBar.addWidget(self.positionWidget)\n\n        self._toolBar = self.toolBar(parent=self)\n        self.addToolBar(self._toolBar)\n        self._menu = self.menu()\n        self.menuBar().addMenu(self._menu)",
  "def legendsDockWidget(self):\n        \"\"\"DockWidget with Legend panel (lazy-loaded).\"\"\"\n        if not hasattr(self, '_legendsDockWidget'):\n            self._legendsDockWidget = LegendsDockWidget(self)\n            self._legendsDockWidget.hide()\n        return self._legendsDockWidget",
  "def crosshairAction(self):\n        \"\"\"Action toggling crosshair cursor mode (lazy-loaded).\"\"\"\n        if not hasattr(self, '_crosshairAction'):\n            self._crosshairAction = CrosshairAction(self, color='red')\n        return self._crosshairAction",
  "def panWithArrowKeysAction(self):\n        \"\"\"Action toggling pan with arrow keys (lazy-loaded).\"\"\"\n        if not hasattr(self, '_panWithArrowKeysAction'):\n            self._panWithArrowKeysAction = PanWithArrowKeysAction(self)\n        return self._panWithArrowKeysAction",
  "def toolBar(self, title='Plot', parent=None):\n        \"\"\"Return a QToolBar from the QAction of the PlotWindow.\n\n        :param str title: The title of the QMenu\n        :param parent: See :class:`QToolBar`\n        \"\"\"\n        toolbar = qt.QToolBar(title, parent)\n        for action in self.group.actions():\n            toolbar.addAction(action)\n        return toolbar",
  "def menu(self, title='Plot', parent=None):\n        \"\"\"Return a QMenu from the QAction of the PlotWindow.\n\n        :param str title: The title of the QMenu\n        :param parent: See :class:`QMenu`\n        \"\"\"\n        menu = qt.QMenu(title, parent)\n        for action in self.group.actions():\n            menu.addAction(action)\n        return menu",
  "def _controlButtonClicked(self):\n        \"\"\"Display Options button sub-menu.\"\"\"\n        controlMenu = qt.QMenu()\n        controlMenu.addAction(self.legendsDockWidget.toggleViewAction())\n        controlMenu.addAction(self.crosshairAction)\n        controlMenu.addAction(self.panWithArrowKeysAction)\n        controlMenu.exec_(self.cursor().pos())",
  "class LegendIcon(qt.QWidget):\n    \"\"\"Object displaying a curve linestyle and symbol.\"\"\"\n\n    def __init__(self, parent=None):\n        super(LegendIcon, self).__init__(parent)\n\n        # Visibilities\n        self.showLine = True\n        self.showSymbol = True\n\n        # Line attributes\n        self.lineStyle = qt.Qt.NoPen\n        self.lineWidth = 1.\n        self.lineColor = qt.Qt.green\n\n        self.symbol = ''\n        # Symbol attributes\n        self.symbolStyle = qt.Qt.SolidPattern\n        self.symbolColor = qt.Qt.green\n        self.symbolOutlineBrush = qt.QBrush(qt.Qt.white)\n\n        # Control widget size: sizeHint \"is the only acceptable\n        # alternative, so the widget can never grow or shrink\"\n        # (c.f. Qt Doc, enum QSizePolicy::Policy)\n        self.setSizePolicy(qt.QSizePolicy.Fixed,\n                           qt.QSizePolicy.Fixed)\n\n    def sizeHint(self):\n        return qt.QSize(50, 15)\n\n    # Modify Symbol\n    def setSymbol(self, symbol):\n        symbol = str(symbol)\n        if symbol not in NoSymbols:\n            if symbol not in Symbols:\n                raise ValueError(\"Unknown symbol: <%s>\" % symbol)\n        self.symbol = symbol\n        # self.update() after set...?\n        # Does not seem necessary\n\n    def setSymbolColor(self, color):\n        \"\"\"\n        :param color: determines the symbol color\n        :type style: qt.QColor\n        \"\"\"\n        self.symbolColor = qt.QColor(color)\n\n    # Modify Line\n\n    def setLineColor(self, color):\n        self.lineColor = qt.QColor(color)\n\n    def setLineWidth(self, width):\n        self.lineWidth = float(width)\n\n    def setLineStyle(self, style):\n        \"\"\"Set the linestyle.\n\n        Possible line styles:\n\n        - '', ' ', 'None': No line\n        - '-': solid\n        - '--': dashed\n        - ':': dotted\n        - '-.': dash and dot\n\n        :param str style: The linestyle to use\n        \"\"\"\n        if style not in LineStyles:\n            raise ValueError('Unknown style: %s', style)\n        self.lineStyle = LineStyles[style]\n\n    # Paint\n\n    def paintEvent(self, event):\n        \"\"\"\n        :param event: event\n        :type event: QPaintEvent\n        \"\"\"\n        painter = qt.QPainter(self)\n        self.paint(painter, event.rect(), self.palette())\n\n    def paint(self, painter, rect, palette):\n        painter.save()\n        painter.setRenderHint(qt.QPainter.Antialiasing)\n        # Scale painter to the icon height\n        # current -> width = 2.5, height = 1.0\n        scale = float(self.height())\n        ratio = float(self.width()) / scale\n        painter.scale(scale,\n                      scale)\n        symbolOffset = qt.QPointF(.5*(ratio-1.), 0.)\n        # Determine and scale offset\n        offset = qt.QPointF(float(rect.left())/scale, float(rect.top())/scale)\n        # Draw BG rectangle (for debugging)\n        # bottomRight = qt.QPointF(\n        #    float(rect.right())/scale,\n        #    float(rect.bottom())/scale)\n        # painter.fillRect(qt.QRectF(offset, bottomRight),\n        #                 qt.QBrush(qt.Qt.green))\n        llist = []\n        if self.showLine:\n            linePath = qt.QPainterPath()\n            linePath.moveTo(0., 0.5)\n            linePath.lineTo(ratio, 0.5)\n            # linePath.lineTo(2.5, 0.5)\n            linePen = qt.QPen(\n                qt.QBrush(self.lineColor),\n                (self.lineWidth / self.height()),\n                self.lineStyle,\n                qt.Qt.FlatCap\n            )\n            llist.append((linePath,\n                          linePen,\n                          qt.QBrush(self.lineColor)))\n        if (self.showSymbol and len(self.symbol) and\n                self.symbol not in NoSymbols):\n            # PITFALL ahead: Let this be a warning to others\n            # symbolPath = Symbols[self.symbol]\n            # Copy before translate! Dict is a mutable type\n            symbolPath = qt.QPainterPath(Symbols[self.symbol])\n            symbolPath.translate(symbolOffset)\n            symbolBrush = qt.QBrush(\n                self.symbolColor,\n                self.symbolStyle\n            )\n            symbolPen = qt.QPen(\n                self.symbolOutlineBrush,  # Brush\n                1./self.height(),         # Width\n                qt.Qt.SolidLine           # Style\n            )\n            llist.append((symbolPath,\n                          symbolPen,\n                          symbolBrush))\n        # Draw\n        for path, pen, brush in llist:\n            path.translate(offset)\n            painter.setPen(pen)\n            painter.setBrush(brush)\n            painter.drawPath(path)\n        painter.restore()",
  "class LegendModel(qt.QAbstractListModel):\n    \"\"\"Data model of curve legends.\n\n    It holds the information of the curve:\n\n    - color\n    - line width\n    - line style\n    - visibility of the lines\n    - symbol\n    - visibility of the symbols\n    \"\"\"\n    iconColorRole = qt.Qt.UserRole + 0\n    iconLineWidthRole = qt.Qt.UserRole + 1\n    iconLineStyleRole = qt.Qt.UserRole + 2\n    showLineRole = qt.Qt.UserRole + 3\n    iconSymbolRole = qt.Qt.UserRole + 4\n    showSymbolRole = qt.Qt.UserRole + 5\n\n    def __init__(self, legendList=None, parent=None):\n        super(LegendModel, self).__init__(parent)\n        if legendList is None:\n            legendList = []\n        self.legendList = []\n        self.insertLegendList(0, legendList)\n\n    def __getitem__(self, idx):\n        if idx >= len(self.legendList):\n            raise IndexError('list index out of range')\n        return self.legendList[idx]\n\n    def rowCount(self, modelIndex=None):\n        return len(self.legendList)\n\n    def flags(self, index):\n        return (qt.Qt.ItemIsEditable |\n                qt.Qt.ItemIsEnabled |\n                qt.Qt.ItemIsSelectable)\n\n    def data(self, modelIndex, role):\n        if modelIndex.isValid:\n            idx = modelIndex.row()\n        else:\n            return None\n        if idx >= len(self.legendList):\n            raise IndexError('list index out of range')\n\n        item = self.legendList[idx]\n        if role == qt.Qt.DisplayRole:\n            # Data to be rendered in the form of text\n            legend = str(item[0])\n            return legend\n        elif role == qt.Qt.SizeHintRole:\n            # size = qt.QSize(200,50)\n            _logger.warning('LegendModel -- size hint role not implemented')\n            return qt.QSize()\n        elif role == qt.Qt.TextAlignmentRole:\n            alignment = qt.Qt.AlignVCenter | qt.Qt.AlignLeft\n            return alignment\n        elif role == qt.Qt.BackgroundRole:\n            # Background color, must be QBrush\n            if idx % 2:\n                brush = qt.QBrush(qt.QColor(240, 240, 240))\n            else:\n                brush = qt.QBrush(qt.Qt.white)\n            return brush\n        elif role == qt.Qt.ForegroundRole:\n            # ForegroundRole color, must be QBrush\n            brush = qt.QBrush(qt.Qt.blue)\n            return brush\n        elif role == qt.Qt.CheckStateRole:\n            return bool(item[2])  # item[2] == True\n        elif role == qt.Qt.ToolTipRole or role == qt.Qt.StatusTipRole:\n            return ''\n        elif role == self.iconColorRole:\n            return item[1]['color']\n        elif role == self.iconLineWidthRole:\n            return item[1]['linewidth']\n        elif role == self.iconLineStyleRole:\n            return item[1]['linestyle']\n        elif role == self.iconSymbolRole:\n            return item[1]['symbol']\n        elif role == self.showLineRole:\n            return item[3]\n        elif role == self.showSymbolRole:\n            return item[4]\n        else:\n            _logger.info('Unkown role requested: %s', str(role))\n            return None\n\n    def setData(self, modelIndex, value, role):\n        if modelIndex.isValid:\n            idx = modelIndex.row()\n        else:\n            return None\n        if idx >= len(self.legendList):\n            # raise IndexError('list index out of range')\n            _logger.warning(\n                'setData -- List index out of range, idx: %d', idx)\n            return None\n\n        item = self.legendList[idx]\n        try:\n            if role == qt.Qt.DisplayRole:\n                # Set legend\n                item[0] = str(value)\n            elif role == self.iconColorRole:\n                item[1]['color'] = qt.QColor(value)\n            elif role == self.iconLineWidthRole:\n                item[1]['linewidth'] = int(value)\n            elif role == self.iconLineStyleRole:\n                item[1]['linestyle'] = str(value)\n            elif role == self.iconSymbolRole:\n                item[1]['symbol'] = str(value)\n            elif role == qt.Qt.CheckStateRole:\n                item[2] = value\n            elif role == self.showLineRole:\n                item[3] = value\n            elif role == self.showSymbolRole:\n                item[4] = value\n        except ValueError:\n            _logger.warning('Conversion failed:\\n\\tvalue: %s\\n\\trole: %s',\n                            str(value), str(role))\n        # Can that be right? Read docs again..\n        self.dataChanged.emit(modelIndex, modelIndex)\n        return True\n\n    def insertLegendList(self, row, llist):\n        \"\"\"\n        :param int row: Determines after which row the items are inserted\n        :param list llist: Carries the new legend information\n        \"\"\"\n        modelIndex = self.createIndex(row, 0)\n        count = len(llist)\n        super(LegendModel, self).beginInsertRows(modelIndex,\n                                                 row,\n                                                 row+count)\n        head = self.legendList[0:row]\n        tail = self.legendList[row:]\n        new = []\n        for (legend, icon) in llist:\n            linestyle = icon.get('linestyle', None)\n            if linestyle in NoLineStyle:\n                # Curve had no line, give it one and hide it\n                # So when toggle line, it will display a solid line\n                showLine = False\n                icon['linestyle'] = '-'\n            else:\n                showLine = True\n\n            symbol = icon.get('symbol', None)\n            if symbol in NoSymbols:\n                # Curve had no symbol, give it one and hide it\n                # So when toggle symbol, it will display 'o'\n                showSymbol = False\n                icon['symbol'] = 'o'\n            else:\n                showSymbol = True\n\n            selected = icon.get('selected', True)\n            item = [legend,\n                    icon,\n                    selected,\n                    showLine,\n                    showSymbol]\n            new.append(item)\n        self.legendList = head + new + tail\n        super(LegendModel, self).endInsertRows()\n        return True\n\n    def insertRows(self, row, count, modelIndex=qt.QModelIndex()):\n        raise NotImplementedError('Use LegendModel.insertLegendList instead')\n\n    def removeRow(self, row):\n        return self.removeRows(row, 1)\n\n    def removeRows(self, row, count, modelIndex=qt.QModelIndex()):\n        length = len(self.legendList)\n        if length == 0:\n            # Nothing to do..\n            return True\n        if row < 0 or row >= length:\n            raise IndexError('Index out of range -- ' +\n                             'idx: %d, len: %d' % (row, length))\n        if count == 0:\n            return False\n        super(LegendModel, self).beginRemoveRows(modelIndex,\n                                                 row,\n                                                 row+count)\n        del(self.legendList[row:row+count])\n        super(LegendModel, self).endRemoveRows()\n        return True\n\n    def setEditor(self, event, editor):\n        \"\"\"\n        :param str event: String that identifies the editor\n        :param editor: Widget used to change data in the underlying model\n        :type editor: QWidget\n        \"\"\"\n        if event not in self.eventList:\n            raise ValueError('setEditor -- Event must be in %s' %\n                             str(self.eventList))\n        self.editorDict[event] = editor",
  "class LegendListItemWidget(qt.QItemDelegate):\n    \"\"\"Object displaying a single item (i.e., a row) in the list.\"\"\"\n\n    # Notice: LegendListItem does NOT inherit\n    # from QObject, it cannot emit signals!\n\n    def __init__(self, parent=None, itemType=0):\n        super(LegendListItemWidget, self).__init__(parent)\n\n        # Dictionary to render checkboxes\n        self.cbDict = {}\n        self.labelDict = {}\n        self.iconDict = {}\n\n        # Keep checkbox and legend to get sizeHint\n        self.checkbox = qt.QCheckBox()\n        self.legend = qt.QLabel()\n        self.icon = LegendIcon()\n\n        # Context Menu and Editors\n        self.contextMenu = None\n\n    def paint(self, painter, option, modelIndex):\n        \"\"\"\n        Here be docs..\n\n        :param QPainter painter:\n        :param QStyleOptionViewItem option:\n        :param QModelIndex modelIndex:\n        \"\"\"\n        painter.save()\n        # Rect geometry\n        width = option.rect.width()\n        height = option.rect.height()\n        left = option.rect.left()\n        top = option.rect.top()\n        rect = qt.QRect(qt.QPoint(left, top),\n                        qt.QSize(width, height))\n        rect = option.rect\n\n        # Calculate the icon rectangle\n        iconSize = self.icon.sizeHint()\n        # Calculate icon position\n        x = rect.left() + 2\n        y = rect.top() + int(.5 * (rect.height() - iconSize.height()))\n        iconRect = qt.QRect(qt.QPoint(x, y), iconSize)\n\n        # Calculate label rectangle\n        legendSize = qt.QSize(rect.width() - iconSize.width() - 30,\n                              rect.height())\n        # Calculate label position\n        x = rect.left() + iconRect.width()\n        y = rect.top()\n        labelRect = qt.QRect(qt.QPoint(x, y), legendSize)\n        labelRect.translate(qt.QPoint(10, 0))\n\n        # Calculate the checkbox rectangle\n        x = rect.right() - 30\n        y = rect.top()\n        chBoxRect = qt.QRect(qt.QPoint(x, y), rect.bottomRight())\n\n        # Remember the rectangles\n        idx = modelIndex.row()\n        self.cbDict[idx] = chBoxRect\n        self.iconDict[idx] = iconRect\n        self.labelDict[idx] = labelRect\n\n        # Draw background first!\n        if option.state & qt.QStyle.State_MouseOver:\n            backgroundBrush = option.palette.highlight()\n        else:\n            backgroundBrush = modelIndex.data(qt.Qt.BackgroundRole)\n        painter.fillRect(rect, backgroundBrush)\n\n        # Draw label\n        legendText = modelIndex.data(qt.Qt.DisplayRole)\n        textBrush = modelIndex.data(qt.Qt.ForegroundRole)\n        textAlign = modelIndex.data(qt.Qt.TextAlignmentRole)\n        painter.setBrush(textBrush)\n        painter.setFont(self.legend.font())\n        painter.drawText(labelRect, textAlign, legendText)\n\n        # Draw icon\n        iconColor = modelIndex.data(LegendModel.iconColorRole)\n        iconLineWidth = modelIndex.data(LegendModel.iconLineWidthRole)\n        iconLineStyle = modelIndex.data(LegendModel.iconLineStyleRole)\n        iconSymbol = modelIndex.data(LegendModel.iconSymbolRole)\n        icon = LegendIcon()\n        icon.resize(iconRect.size())\n        icon.move(iconRect.topRight())\n        icon.showSymbol = modelIndex.data(LegendModel.showSymbolRole)\n        icon.showLine = modelIndex.data(LegendModel.showLineRole)\n        icon.setSymbolColor(iconColor)\n        icon.setLineColor(iconColor)\n        icon.setLineWidth(iconLineWidth)\n        icon.setLineStyle(iconLineStyle)\n        icon.setSymbol(iconSymbol)\n        icon.symbolOutlineBrush = backgroundBrush\n        icon.paint(painter, iconRect, option.palette)\n\n        # Draw the checkbox\n        if modelIndex.data(qt.Qt.CheckStateRole):\n            checkState = qt.Qt.Checked\n        else:\n            checkState = qt.Qt.Unchecked\n\n        self.drawCheck(\n            painter, qt.QStyleOptionViewItem(), chBoxRect, checkState)\n\n        painter.restore()\n\n    def editorEvent(self, event, model, option, modelIndex):\n        # From the docs:\n        # Mouse events are sent to editorEvent()\n        # even if they don't start editing of the item.\n        if event.button() == qt.Qt.RightButton and self.contextMenu:\n            self.contextMenu.exec_(event.globalPos(), modelIndex)\n            return True\n        elif event.button() == qt.Qt.LeftButton:\n            # Check if checkbox was clicked\n            idx = modelIndex.row()\n            cbRect = self.cbDict[idx]\n            if cbRect.contains(event.pos()):\n                # Toggle checkbox\n                model.setData(modelIndex,\n                              not modelIndex.data(qt.Qt.CheckStateRole),\n                              qt.Qt.CheckStateRole)\n            event.ignore()\n            return True\n        else:\n            return super(LegendListItemWidget, self).editorEvent(\n                event, model, option, modelIndex)\n\n    def createEditor(self, parent, option, idx):\n        _logger.info('### Editor request ###')\n\n    def sizeHint(self, option, idx):\n        # return qt.QSize(68,24)\n        iconSize = self.icon.sizeHint()\n        legendSize = self.legend.sizeHint()\n        checkboxSize = self.checkbox.sizeHint()\n        height = max([iconSize.height(),\n                      legendSize.height(),\n                      checkboxSize.height()]) + 4\n        width = iconSize.width() + legendSize.width() + checkboxSize.width()\n        return qt.QSize(width, height)",
  "class LegendListView(qt.QListView):\n    \"\"\"Widget displaying a list of curve legends, line style and symbol.\"\"\"\n\n    sigLegendSignal = qt.Signal(object)\n    \"\"\"Signal emitting a dict when an action is triggered by the user.\"\"\"\n\n    __mouseClickedEvent = 'mouseClicked'\n    __checkBoxClickedEvent = 'checkBoxClicked'\n    __legendClickedEvent = 'legendClicked'\n\n    def __init__(self, parent=None, model=None, contextMenu=None):\n        super(LegendListView, self).__init__(parent)\n        self.__lastButton = None\n        self.__lastClickPos = None\n        self.__lastModelIdx = None\n        # Set default delegate\n        self.setItemDelegate(LegendListItemWidget())\n        # Set default editors\n        # self.setSizePolicy(qt.QSizePolicy.MinimumExpanding,\n        #                    qt.QSizePolicy.MinimumExpanding)\n        # Set edit triggers by hand using self.edit(QModelIndex)\n        # in mousePressEvent (better to control than signals)\n        self.setEditTriggers(qt.QAbstractItemView.NoEditTriggers)\n\n        # Control layout\n        # self.setBatchSize(2)\n        # self.setLayoutMode(qt.QListView.Batched)\n        # self.setFlow(qt.QListView.LeftToRight)\n\n        # Control selection\n        self.setSelectionMode(qt.QAbstractItemView.NoSelection)\n\n        if model is None:\n            model = LegendModel()\n        self.setModel(model)\n        self.setContextMenu(contextMenu)\n\n    def setLegendList(self, legendList, row=None):\n        self.clear()\n        if row is None:\n            row = 0\n        model = self.model()\n        model.insertLegendList(row, legendList)\n        _logger.debug('LegendListView.setLegendList(legendList) finished')\n\n    def clear(self):\n        model = self.model()\n        model.removeRows(0, model.rowCount())\n        _logger.debug('LegendListView.clear() finished')\n\n    def setContextMenu(self, contextMenu=None):\n        delegate = self.itemDelegate()\n        if isinstance(delegate, LegendListItemWidget) and self.model():\n            if contextMenu is None:\n                delegate.contextMenu = LegendListContextMenu(self.model())\n                delegate.contextMenu.sigContextMenu.connect(\n                    self._contextMenuSlot)\n            else:\n                delegate.contextMenu = contextMenu\n\n    def __getitem__(self, idx):\n        model = self.model()\n        try:\n            item = model[idx]\n        except ValueError:\n            item = None\n        return item\n\n    def _contextMenuSlot(self, ddict):\n        self.sigLegendSignal.emit(ddict)\n\n    def mousePressEvent(self, event):\n        self.__lastButton = event.button()\n        self.__lastPosition = event.pos()\n        super(LegendListView, self).mousePressEvent(event)\n        # call _handleMouseClick after editing was handled\n        # If right click (context menu) is aborted, no\n        # signal is emitted..\n        self._handleMouseClick(self.indexAt(self.__lastPosition))\n\n    def mouseDoubleClickEvent(self, event):\n        self.__lastButton = event.button()\n        self.__lastPosition = event.pos()\n        super(LegendListView, self).mouseDoubleClickEvent(event)\n        # call _handleMouseClick after editing was handled\n        # If right click (context menu) is aborted, no\n        # signal is emitted..\n        self._handleMouseClick(self.indexAt(self.__lastPosition))\n\n    def mouseMoveEvent(self, event):\n        # LegendListView.mouseMoveEvent is overwritten\n        # to suppress unwanted behavior in the delegate.\n        pass\n\n    def mouseReleaseEvent(self, event):\n        # LegendListView.mouseReleaseEvent is overwritten\n        # to subpress unwanted behavior in the delegate.\n        pass\n\n    def _handleMouseClick(self, modelIndex):\n        \"\"\"\n        Distinguish between mouse click on Legend\n        and mouse click on CheckBox by setting the\n        currentCheckState attribute in LegendListItem.\n\n        Emits signal sigLegendSignal(ddict)\n\n        :param QModelIndex modelIndex: index of the clicked item\n        \"\"\"\n        _logger.debug('self._handleMouseClick called')\n        if self.__lastButton not in [qt.Qt.LeftButton,\n                                     qt.Qt.RightButton]:\n            return\n        if not modelIndex.isValid():\n            _logger.debug('_handleMouseClick -- Invalid QModelIndex')\n            return\n        # model = self.model()\n        idx = modelIndex.row()\n\n        delegate = self.itemDelegate()\n        cbClicked = False\n        if isinstance(delegate, LegendListItemWidget):\n            for cbRect in delegate.cbDict.values():\n                if cbRect.contains(self.__lastPosition):\n                    cbClicked = True\n                    break\n\n        # TODO: Check for doubleclicks on legend/icon and spawn editors\n\n        ddict = {\n            'legend': str(modelIndex.data(qt.Qt.DisplayRole)),\n            'icon': {\n                'linewidth': str(modelIndex.data(\n                    LegendModel.iconLineWidthRole)),\n                'linestyle': str(modelIndex.data(\n                    LegendModel.iconLineStyleRole)),\n                'symbol': str(modelIndex.data(LegendModel.iconSymbolRole))\n            },\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data())\n        }\n        if self.__lastButton == qt.Qt.RightButton:\n            _logger.debug('Right clicked')\n            ddict['button'] = \"right\"\n            ddict['event'] = self.__mouseClickedEvent\n        elif cbClicked:\n            _logger.debug('CheckBox clicked')\n            ddict['button'] = \"left\"\n            ddict['event'] = self.__checkBoxClickedEvent\n        else:\n            _logger.debug('Legend clicked')\n            ddict['button'] = \"left\"\n            ddict['event'] = self.__legendClickedEvent\n        _logger.debug('  idx: %d\\n  ddict: %s', idx, str(ddict))\n        self.sigLegendSignal.emit(ddict)",
  "class LegendListContextMenu(qt.QMenu):\n    \"\"\"Contextual menu associated to items in a :class:`LegendListView`.\"\"\"\n\n    sigContextMenu = qt.Signal(object)\n    \"\"\"Signal emitting a dict upon contextual menu actions.\"\"\"\n\n    def __init__(self, model):\n        super(LegendListContextMenu, self).__init__(parent=None)\n        self.model = model\n\n        self.addAction('Set Active', self.setActiveAction)\n        self.addAction('Map to left', self.mapToLeftAction)\n        self.addAction('Map to right', self.mapToRightAction)\n\n        self._pointsAction = self.addAction(\n            'Points', self.togglePointsAction)\n        self._pointsAction.setCheckable(True)\n\n        self._linesAction = self.addAction('Lines', self.toggleLinesAction)\n        self._linesAction.setCheckable(True)\n\n        self.addAction('Remove curve', self.removeItemAction)\n        self.addAction('Rename curve', self.renameItemAction)\n\n    def exec_(self, pos, idx):\n        self.__currentIdx = idx\n\n        # Set checkable action state\n        modelIndex = self.currentIdx()\n        self._pointsAction.setChecked(\n            modelIndex.data(LegendModel.showSymbolRole))\n        self._linesAction.setChecked(\n            modelIndex.data(LegendModel.showLineRole))\n\n        super(LegendListContextMenu, self).popup(pos)\n\n    def currentIdx(self):\n        return self.__currentIdx\n\n    def mapToLeftAction(self):\n        _logger.debug('LegendListContextMenu.mapToLeftAction called')\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n            'event': \"mapToLeft\"\n        }\n        self.sigContextMenu.emit(ddict)\n\n    def mapToRightAction(self):\n        _logger.debug('LegendListContextMenu.mapToRightAction called')\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n            'event': \"mapToRight\"\n        }\n        self.sigContextMenu.emit(ddict)\n\n    def removeItemAction(self):\n        _logger.debug('LegendListContextMenu.removeCurveAction called')\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n            'event': \"removeCurve\"\n        }\n        self.model.removeRow(modelIndex.row())\n        self.sigContextMenu.emit(ddict)\n\n    def renameItemAction(self):\n        _logger.debug('LegendListContextMenu.renameCurveAction called')\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n            'event': \"renameCurve\"\n        }\n        self.sigContextMenu.emit(ddict)\n\n    def toggleLinesAction(self):\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n        }\n        linestyle = modelIndex.data(LegendModel.iconLineStyleRole)\n        visible = not modelIndex.data(LegendModel.showLineRole)\n        _logger.debug('toggleLinesAction -- lines visible: %s', str(visible))\n        ddict['event'] = \"toggleLine\"\n        ddict['line'] = visible\n        ddict['linestyle'] = linestyle if visible else ''\n        self.model.setData(modelIndex, visible, LegendModel.showLineRole)\n        self.sigContextMenu.emit(ddict)\n\n    def togglePointsAction(self):\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n        }\n        flag = modelIndex.data(LegendModel.showSymbolRole)\n        symbol = modelIndex.data(LegendModel.iconSymbolRole)\n        visible = not flag or symbol in NoSymbols\n        _logger.debug(\n            'togglePointsAction -- Symbols visible: %s', str(visible))\n\n        ddict['event'] = \"togglePoints\"\n        ddict['points'] = visible\n        ddict['symbol'] = symbol if visible else ''\n        self.model.setData(modelIndex, visible, LegendModel.showSymbolRole)\n        self.sigContextMenu.emit(ddict)\n\n    def setActiveAction(self):\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        _logger.debug('setActiveAction -- active curve: %s', legend)\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n            'event': \"setActiveCurve\",\n        }\n        self.sigContextMenu.emit(ddict)",
  "class RenameCurveDialog(qt.QDialog):\n    \"\"\"Dialog box to input the name of a curve.\"\"\"\n\n    def __init__(self, parent=None, current=\"\", curves=[]):\n        super(RenameCurveDialog, self).__init__(parent)\n        self.setWindowTitle(\"Rename Curve %s\" % current)\n        self.curves = curves\n        layout = qt.QVBoxLayout(self)\n        self.lineEdit = qt.QLineEdit(self)\n        self.lineEdit.setText(current)\n        self.hbox = qt.QWidget(self)\n        self.hboxLayout = qt.QHBoxLayout(self.hbox)\n        self.hboxLayout.addStretch(1)\n        self.okButton = qt.QPushButton(self.hbox)\n        self.okButton.setText('OK')\n        self.hboxLayout.addWidget(self.okButton)\n        self.cancelButton = qt.QPushButton(self.hbox)\n        self.cancelButton.setText('Cancel')\n        self.hboxLayout.addWidget(self.cancelButton)\n        self.hboxLayout.addStretch(1)\n        layout.addWidget(self.lineEdit)\n        layout.addWidget(self.hbox)\n        self.okButton.clicked.connect(self.preAccept)\n        self.cancelButton.clicked.connect(self.reject)\n\n    def preAccept(self):\n        text = str(self.lineEdit.text())\n        addedText = \"\"\n        if len(text):\n            if text not in self.curves:\n                self.accept()\n                return\n            else:\n                addedText = \"Curve already exists.\"\n        text = \"Invalid Curve Name\"\n        msg = qt.QMessageBox(self)\n        msg.setIcon(qt.QMessageBox.Critical)\n        msg.setWindowTitle(text)\n        text += \"\\n%s\" % addedText\n        msg.setText(text)\n        msg.exec_()\n\n    def getText(self):\n        return str(self.lineEdit.text())",
  "class LegendsDockWidget(qt.QDockWidget):\n    \"\"\"QDockWidget with a :class:`LegendSelector` connected to a PlotWindow.\n\n    It makes the link between the LegendListView widget and the PlotWindow.\n\n    :param plot: :class:`.PlotWindow` instance on which to operate\n    :param parent: See :class:`QDockWidget`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        assert plot is not None\n        self._plotRef = weakref.ref(plot)\n\n        super(LegendsDockWidget, self).__init__(\"Legends\", self.plot)\n\n        self._legendWidget = LegendListView()\n\n        self.layout().setContentsMargins(0, 0, 0, 0)\n        self.setWidget(self._legendWidget)\n\n        width = self.plot.centralWidget().width()\n        height = self.plot.centralWidget().height()\n        if width > (1.25 * height):\n            area = qt.Qt.RightDockWidgetArea\n        else:\n            area = qt.Qt.BottomDockWidgetArea\n        self.plot.addDockWidget(area, self)\n\n        self.visibilityChanged.connect(\n            self._visibilityChangedHandler)\n\n        self._legendWidget.sigLegendSignal.connect(self._legendSignalHandler)\n\n    @property\n    def plot(self):\n        \"\"\"The :class:`.PlotWindow` this widget is attached to.\"\"\"\n        return self._plotRef()\n\n    def renameCurve(self, oldLegend, newLegend):\n        \"\"\"Change the name of a curve using remove and addCurve\n\n        :param str oldLegend: The legend of the curve to be change\n        :param str newLegend: The new legend of the curve\n        \"\"\"\n        x, y, legend, info, params = self.plot.getCurve(oldLegend)[0:5]\n        self.plot.remove(oldLegend, kind='curve')\n        self.plot.addCurve(x, y, legend=newLegend, resetzoom=False, **params)\n\n    def _legendSignalHandler(self, ddict):\n        \"\"\"Handles events from the LegendListView signal\"\"\"\n        _logger.debug(\"Legend signal ddict = \", ddict)\n\n        if ddict['event'] == \"legendClicked\":\n            if ddict['button'] == \"left\":\n                self.plot.setActiveCurve(ddict['legend'])\n\n        elif ddict['event'] == \"removeCurve\":\n            self.plot.removeCurve(ddict['legend'])\n\n        elif ddict['event'] == \"renameCurve\":\n            curveList = self.plot.getAllCurves(just_legend=True)\n            oldLegend = ddict['legend']\n            dialog = RenameCurveDialog(self.plot, oldLegend, curveList)\n            ret = dialog.exec_()\n            if ret:\n                newLegend = dialog.getText()\n                self.renameCurve(oldLegend, newLegend)\n\n        elif ddict['event'] == \"setActiveCurve\":\n            self.plot.setActiveCurve(ddict['legend'])\n\n        elif ddict['event'] == \"checkBoxClicked\":\n            self.plot.hideCurve(ddict['legend'], not ddict['selected'])\n\n        elif ddict['event'] in [\"mapToRight\", \"mapToLeft\"]:\n            legend = ddict['legend']\n            x, y, legend, info, params = self.plot.getCurve(legend)[0:5]\n            params = params.copy()\n            if ddict['event'] == \"mapToRight\":\n                params['yaxis'] = \"right\"\n            else:\n                params['yaxis'] = \"left\"\n            self.plot.addCurve(x, y, legend=legend, **params)\n\n        elif ddict['event'] == \"togglePoints\":\n            legend = ddict['legend']\n            x, y, legend, info, params = self.plot.getCurve(legend)[0:5]\n            params = params.copy()\n            params['symbol'] = ddict['symbol'] if ddict['points'] else ''\n            self.plot.addCurve(x, y, legend=legend, resetzoom=False, **params)\n\n        elif ddict['event'] == \"toggleLine\":\n            legend = ddict['legend']\n            x, y, legend, info, params = self.plot.getCurve(legend)[0:5]\n            params = params.copy()\n            params['linestyle'] = ddict['linestyle'] if ddict['line'] else ''\n            self.plot.addCurve(x, y, legend=legend, resetzoom=False, **params)\n\n        else:\n            _logger.debug(\"unhandled event %s\", str(ddict['event']))\n\n    def updateLegends(self, *args):\n        \"\"\"Sync the LegendSelector widget displayed info with the plot.\n        \"\"\"\n        legendList = []\n        curves = self.plot.getAllCurves(withhidden=True)\n        for x, y, legend, info, params in curves:\n            # Use active color if curve is active\n            if legend == self.plot.getActiveCurve(just_legend=True):\n                print('got an active curve')\n                color = self.plot.getActiveCurveColor()\n            else:\n                color = params['color']\n\n            curveInfo = {\n                'color': qt.QColor(color),\n                'linewidth': params['linewidth'],\n                'linestyle': params['linestyle'],\n                'symbol': params['symbol'],\n                'selected': not self.plot.isCurveHidden(legend)}\n            legendList.append((legend, curveInfo))\n\n        self._legendWidget.setLegendList(legendList)\n\n    def _visibilityChangedHandler(self, visible):\n        if visible:\n            self.updateLegends()\n            self.plot.sigContentChanged.connect(self.updateLegends)\n            self.plot.sigActiveCurveChanged.connect(self.updateLegends)\n        else:\n            self.plot.sigContentChanged.disconnect(self.updateLegends)\n            self.plot.sigActiveCurveChanged.disconnect(self.updateLegends)",
  "def __init__(self, parent=None):\n        super(LegendIcon, self).__init__(parent)\n\n        # Visibilities\n        self.showLine = True\n        self.showSymbol = True\n\n        # Line attributes\n        self.lineStyle = qt.Qt.NoPen\n        self.lineWidth = 1.\n        self.lineColor = qt.Qt.green\n\n        self.symbol = ''\n        # Symbol attributes\n        self.symbolStyle = qt.Qt.SolidPattern\n        self.symbolColor = qt.Qt.green\n        self.symbolOutlineBrush = qt.QBrush(qt.Qt.white)\n\n        # Control widget size: sizeHint \"is the only acceptable\n        # alternative, so the widget can never grow or shrink\"\n        # (c.f. Qt Doc, enum QSizePolicy::Policy)\n        self.setSizePolicy(qt.QSizePolicy.Fixed,\n                           qt.QSizePolicy.Fixed)",
  "def sizeHint(self):\n        return qt.QSize(50, 15)",
  "def setSymbol(self, symbol):\n        symbol = str(symbol)\n        if symbol not in NoSymbols:\n            if symbol not in Symbols:\n                raise ValueError(\"Unknown symbol: <%s>\" % symbol)\n        self.symbol = symbol",
  "def setSymbolColor(self, color):\n        \"\"\"\n        :param color: determines the symbol color\n        :type style: qt.QColor\n        \"\"\"\n        self.symbolColor = qt.QColor(color)",
  "def setLineColor(self, color):\n        self.lineColor = qt.QColor(color)",
  "def setLineWidth(self, width):\n        self.lineWidth = float(width)",
  "def setLineStyle(self, style):\n        \"\"\"Set the linestyle.\n\n        Possible line styles:\n\n        - '', ' ', 'None': No line\n        - '-': solid\n        - '--': dashed\n        - ':': dotted\n        - '-.': dash and dot\n\n        :param str style: The linestyle to use\n        \"\"\"\n        if style not in LineStyles:\n            raise ValueError('Unknown style: %s', style)\n        self.lineStyle = LineStyles[style]",
  "def paintEvent(self, event):\n        \"\"\"\n        :param event: event\n        :type event: QPaintEvent\n        \"\"\"\n        painter = qt.QPainter(self)\n        self.paint(painter, event.rect(), self.palette())",
  "def paint(self, painter, rect, palette):\n        painter.save()\n        painter.setRenderHint(qt.QPainter.Antialiasing)\n        # Scale painter to the icon height\n        # current -> width = 2.5, height = 1.0\n        scale = float(self.height())\n        ratio = float(self.width()) / scale\n        painter.scale(scale,\n                      scale)\n        symbolOffset = qt.QPointF(.5*(ratio-1.), 0.)\n        # Determine and scale offset\n        offset = qt.QPointF(float(rect.left())/scale, float(rect.top())/scale)\n        # Draw BG rectangle (for debugging)\n        # bottomRight = qt.QPointF(\n        #    float(rect.right())/scale,\n        #    float(rect.bottom())/scale)\n        # painter.fillRect(qt.QRectF(offset, bottomRight),\n        #                 qt.QBrush(qt.Qt.green))\n        llist = []\n        if self.showLine:\n            linePath = qt.QPainterPath()\n            linePath.moveTo(0., 0.5)\n            linePath.lineTo(ratio, 0.5)\n            # linePath.lineTo(2.5, 0.5)\n            linePen = qt.QPen(\n                qt.QBrush(self.lineColor),\n                (self.lineWidth / self.height()),\n                self.lineStyle,\n                qt.Qt.FlatCap\n            )\n            llist.append((linePath,\n                          linePen,\n                          qt.QBrush(self.lineColor)))\n        if (self.showSymbol and len(self.symbol) and\n                self.symbol not in NoSymbols):\n            # PITFALL ahead: Let this be a warning to others\n            # symbolPath = Symbols[self.symbol]\n            # Copy before translate! Dict is a mutable type\n            symbolPath = qt.QPainterPath(Symbols[self.symbol])\n            symbolPath.translate(symbolOffset)\n            symbolBrush = qt.QBrush(\n                self.symbolColor,\n                self.symbolStyle\n            )\n            symbolPen = qt.QPen(\n                self.symbolOutlineBrush,  # Brush\n                1./self.height(),         # Width\n                qt.Qt.SolidLine           # Style\n            )\n            llist.append((symbolPath,\n                          symbolPen,\n                          symbolBrush))\n        # Draw\n        for path, pen, brush in llist:\n            path.translate(offset)\n            painter.setPen(pen)\n            painter.setBrush(brush)\n            painter.drawPath(path)\n        painter.restore()",
  "def __init__(self, legendList=None, parent=None):\n        super(LegendModel, self).__init__(parent)\n        if legendList is None:\n            legendList = []\n        self.legendList = []\n        self.insertLegendList(0, legendList)",
  "def __getitem__(self, idx):\n        if idx >= len(self.legendList):\n            raise IndexError('list index out of range')\n        return self.legendList[idx]",
  "def rowCount(self, modelIndex=None):\n        return len(self.legendList)",
  "def flags(self, index):\n        return (qt.Qt.ItemIsEditable |\n                qt.Qt.ItemIsEnabled |\n                qt.Qt.ItemIsSelectable)",
  "def data(self, modelIndex, role):\n        if modelIndex.isValid:\n            idx = modelIndex.row()\n        else:\n            return None\n        if idx >= len(self.legendList):\n            raise IndexError('list index out of range')\n\n        item = self.legendList[idx]\n        if role == qt.Qt.DisplayRole:\n            # Data to be rendered in the form of text\n            legend = str(item[0])\n            return legend\n        elif role == qt.Qt.SizeHintRole:\n            # size = qt.QSize(200,50)\n            _logger.warning('LegendModel -- size hint role not implemented')\n            return qt.QSize()\n        elif role == qt.Qt.TextAlignmentRole:\n            alignment = qt.Qt.AlignVCenter | qt.Qt.AlignLeft\n            return alignment\n        elif role == qt.Qt.BackgroundRole:\n            # Background color, must be QBrush\n            if idx % 2:\n                brush = qt.QBrush(qt.QColor(240, 240, 240))\n            else:\n                brush = qt.QBrush(qt.Qt.white)\n            return brush\n        elif role == qt.Qt.ForegroundRole:\n            # ForegroundRole color, must be QBrush\n            brush = qt.QBrush(qt.Qt.blue)\n            return brush\n        elif role == qt.Qt.CheckStateRole:\n            return bool(item[2])  # item[2] == True\n        elif role == qt.Qt.ToolTipRole or role == qt.Qt.StatusTipRole:\n            return ''\n        elif role == self.iconColorRole:\n            return item[1]['color']\n        elif role == self.iconLineWidthRole:\n            return item[1]['linewidth']\n        elif role == self.iconLineStyleRole:\n            return item[1]['linestyle']\n        elif role == self.iconSymbolRole:\n            return item[1]['symbol']\n        elif role == self.showLineRole:\n            return item[3]\n        elif role == self.showSymbolRole:\n            return item[4]\n        else:\n            _logger.info('Unkown role requested: %s', str(role))\n            return None",
  "def setData(self, modelIndex, value, role):\n        if modelIndex.isValid:\n            idx = modelIndex.row()\n        else:\n            return None\n        if idx >= len(self.legendList):\n            # raise IndexError('list index out of range')\n            _logger.warning(\n                'setData -- List index out of range, idx: %d', idx)\n            return None\n\n        item = self.legendList[idx]\n        try:\n            if role == qt.Qt.DisplayRole:\n                # Set legend\n                item[0] = str(value)\n            elif role == self.iconColorRole:\n                item[1]['color'] = qt.QColor(value)\n            elif role == self.iconLineWidthRole:\n                item[1]['linewidth'] = int(value)\n            elif role == self.iconLineStyleRole:\n                item[1]['linestyle'] = str(value)\n            elif role == self.iconSymbolRole:\n                item[1]['symbol'] = str(value)\n            elif role == qt.Qt.CheckStateRole:\n                item[2] = value\n            elif role == self.showLineRole:\n                item[3] = value\n            elif role == self.showSymbolRole:\n                item[4] = value\n        except ValueError:\n            _logger.warning('Conversion failed:\\n\\tvalue: %s\\n\\trole: %s',\n                            str(value), str(role))\n        # Can that be right? Read docs again..\n        self.dataChanged.emit(modelIndex, modelIndex)\n        return True",
  "def insertLegendList(self, row, llist):\n        \"\"\"\n        :param int row: Determines after which row the items are inserted\n        :param list llist: Carries the new legend information\n        \"\"\"\n        modelIndex = self.createIndex(row, 0)\n        count = len(llist)\n        super(LegendModel, self).beginInsertRows(modelIndex,\n                                                 row,\n                                                 row+count)\n        head = self.legendList[0:row]\n        tail = self.legendList[row:]\n        new = []\n        for (legend, icon) in llist:\n            linestyle = icon.get('linestyle', None)\n            if linestyle in NoLineStyle:\n                # Curve had no line, give it one and hide it\n                # So when toggle line, it will display a solid line\n                showLine = False\n                icon['linestyle'] = '-'\n            else:\n                showLine = True\n\n            symbol = icon.get('symbol', None)\n            if symbol in NoSymbols:\n                # Curve had no symbol, give it one and hide it\n                # So when toggle symbol, it will display 'o'\n                showSymbol = False\n                icon['symbol'] = 'o'\n            else:\n                showSymbol = True\n\n            selected = icon.get('selected', True)\n            item = [legend,\n                    icon,\n                    selected,\n                    showLine,\n                    showSymbol]\n            new.append(item)\n        self.legendList = head + new + tail\n        super(LegendModel, self).endInsertRows()\n        return True",
  "def insertRows(self, row, count, modelIndex=qt.QModelIndex()):\n        raise NotImplementedError('Use LegendModel.insertLegendList instead')",
  "def removeRow(self, row):\n        return self.removeRows(row, 1)",
  "def removeRows(self, row, count, modelIndex=qt.QModelIndex()):\n        length = len(self.legendList)\n        if length == 0:\n            # Nothing to do..\n            return True\n        if row < 0 or row >= length:\n            raise IndexError('Index out of range -- ' +\n                             'idx: %d, len: %d' % (row, length))\n        if count == 0:\n            return False\n        super(LegendModel, self).beginRemoveRows(modelIndex,\n                                                 row,\n                                                 row+count)\n        del(self.legendList[row:row+count])\n        super(LegendModel, self).endRemoveRows()\n        return True",
  "def setEditor(self, event, editor):\n        \"\"\"\n        :param str event: String that identifies the editor\n        :param editor: Widget used to change data in the underlying model\n        :type editor: QWidget\n        \"\"\"\n        if event not in self.eventList:\n            raise ValueError('setEditor -- Event must be in %s' %\n                             str(self.eventList))\n        self.editorDict[event] = editor",
  "def __init__(self, parent=None, itemType=0):\n        super(LegendListItemWidget, self).__init__(parent)\n\n        # Dictionary to render checkboxes\n        self.cbDict = {}\n        self.labelDict = {}\n        self.iconDict = {}\n\n        # Keep checkbox and legend to get sizeHint\n        self.checkbox = qt.QCheckBox()\n        self.legend = qt.QLabel()\n        self.icon = LegendIcon()\n\n        # Context Menu and Editors\n        self.contextMenu = None",
  "def paint(self, painter, option, modelIndex):\n        \"\"\"\n        Here be docs..\n\n        :param QPainter painter:\n        :param QStyleOptionViewItem option:\n        :param QModelIndex modelIndex:\n        \"\"\"\n        painter.save()\n        # Rect geometry\n        width = option.rect.width()\n        height = option.rect.height()\n        left = option.rect.left()\n        top = option.rect.top()\n        rect = qt.QRect(qt.QPoint(left, top),\n                        qt.QSize(width, height))\n        rect = option.rect\n\n        # Calculate the icon rectangle\n        iconSize = self.icon.sizeHint()\n        # Calculate icon position\n        x = rect.left() + 2\n        y = rect.top() + int(.5 * (rect.height() - iconSize.height()))\n        iconRect = qt.QRect(qt.QPoint(x, y), iconSize)\n\n        # Calculate label rectangle\n        legendSize = qt.QSize(rect.width() - iconSize.width() - 30,\n                              rect.height())\n        # Calculate label position\n        x = rect.left() + iconRect.width()\n        y = rect.top()\n        labelRect = qt.QRect(qt.QPoint(x, y), legendSize)\n        labelRect.translate(qt.QPoint(10, 0))\n\n        # Calculate the checkbox rectangle\n        x = rect.right() - 30\n        y = rect.top()\n        chBoxRect = qt.QRect(qt.QPoint(x, y), rect.bottomRight())\n\n        # Remember the rectangles\n        idx = modelIndex.row()\n        self.cbDict[idx] = chBoxRect\n        self.iconDict[idx] = iconRect\n        self.labelDict[idx] = labelRect\n\n        # Draw background first!\n        if option.state & qt.QStyle.State_MouseOver:\n            backgroundBrush = option.palette.highlight()\n        else:\n            backgroundBrush = modelIndex.data(qt.Qt.BackgroundRole)\n        painter.fillRect(rect, backgroundBrush)\n\n        # Draw label\n        legendText = modelIndex.data(qt.Qt.DisplayRole)\n        textBrush = modelIndex.data(qt.Qt.ForegroundRole)\n        textAlign = modelIndex.data(qt.Qt.TextAlignmentRole)\n        painter.setBrush(textBrush)\n        painter.setFont(self.legend.font())\n        painter.drawText(labelRect, textAlign, legendText)\n\n        # Draw icon\n        iconColor = modelIndex.data(LegendModel.iconColorRole)\n        iconLineWidth = modelIndex.data(LegendModel.iconLineWidthRole)\n        iconLineStyle = modelIndex.data(LegendModel.iconLineStyleRole)\n        iconSymbol = modelIndex.data(LegendModel.iconSymbolRole)\n        icon = LegendIcon()\n        icon.resize(iconRect.size())\n        icon.move(iconRect.topRight())\n        icon.showSymbol = modelIndex.data(LegendModel.showSymbolRole)\n        icon.showLine = modelIndex.data(LegendModel.showLineRole)\n        icon.setSymbolColor(iconColor)\n        icon.setLineColor(iconColor)\n        icon.setLineWidth(iconLineWidth)\n        icon.setLineStyle(iconLineStyle)\n        icon.setSymbol(iconSymbol)\n        icon.symbolOutlineBrush = backgroundBrush\n        icon.paint(painter, iconRect, option.palette)\n\n        # Draw the checkbox\n        if modelIndex.data(qt.Qt.CheckStateRole):\n            checkState = qt.Qt.Checked\n        else:\n            checkState = qt.Qt.Unchecked\n\n        self.drawCheck(\n            painter, qt.QStyleOptionViewItem(), chBoxRect, checkState)\n\n        painter.restore()",
  "def editorEvent(self, event, model, option, modelIndex):\n        # From the docs:\n        # Mouse events are sent to editorEvent()\n        # even if they don't start editing of the item.\n        if event.button() == qt.Qt.RightButton and self.contextMenu:\n            self.contextMenu.exec_(event.globalPos(), modelIndex)\n            return True\n        elif event.button() == qt.Qt.LeftButton:\n            # Check if checkbox was clicked\n            idx = modelIndex.row()\n            cbRect = self.cbDict[idx]\n            if cbRect.contains(event.pos()):\n                # Toggle checkbox\n                model.setData(modelIndex,\n                              not modelIndex.data(qt.Qt.CheckStateRole),\n                              qt.Qt.CheckStateRole)\n            event.ignore()\n            return True\n        else:\n            return super(LegendListItemWidget, self).editorEvent(\n                event, model, option, modelIndex)",
  "def createEditor(self, parent, option, idx):\n        _logger.info('### Editor request ###')",
  "def sizeHint(self, option, idx):\n        # return qt.QSize(68,24)\n        iconSize = self.icon.sizeHint()\n        legendSize = self.legend.sizeHint()\n        checkboxSize = self.checkbox.sizeHint()\n        height = max([iconSize.height(),\n                      legendSize.height(),\n                      checkboxSize.height()]) + 4\n        width = iconSize.width() + legendSize.width() + checkboxSize.width()\n        return qt.QSize(width, height)",
  "def __init__(self, parent=None, model=None, contextMenu=None):\n        super(LegendListView, self).__init__(parent)\n        self.__lastButton = None\n        self.__lastClickPos = None\n        self.__lastModelIdx = None\n        # Set default delegate\n        self.setItemDelegate(LegendListItemWidget())\n        # Set default editors\n        # self.setSizePolicy(qt.QSizePolicy.MinimumExpanding,\n        #                    qt.QSizePolicy.MinimumExpanding)\n        # Set edit triggers by hand using self.edit(QModelIndex)\n        # in mousePressEvent (better to control than signals)\n        self.setEditTriggers(qt.QAbstractItemView.NoEditTriggers)\n\n        # Control layout\n        # self.setBatchSize(2)\n        # self.setLayoutMode(qt.QListView.Batched)\n        # self.setFlow(qt.QListView.LeftToRight)\n\n        # Control selection\n        self.setSelectionMode(qt.QAbstractItemView.NoSelection)\n\n        if model is None:\n            model = LegendModel()\n        self.setModel(model)\n        self.setContextMenu(contextMenu)",
  "def setLegendList(self, legendList, row=None):\n        self.clear()\n        if row is None:\n            row = 0\n        model = self.model()\n        model.insertLegendList(row, legendList)\n        _logger.debug('LegendListView.setLegendList(legendList) finished')",
  "def clear(self):\n        model = self.model()\n        model.removeRows(0, model.rowCount())\n        _logger.debug('LegendListView.clear() finished')",
  "def setContextMenu(self, contextMenu=None):\n        delegate = self.itemDelegate()\n        if isinstance(delegate, LegendListItemWidget) and self.model():\n            if contextMenu is None:\n                delegate.contextMenu = LegendListContextMenu(self.model())\n                delegate.contextMenu.sigContextMenu.connect(\n                    self._contextMenuSlot)\n            else:\n                delegate.contextMenu = contextMenu",
  "def __getitem__(self, idx):\n        model = self.model()\n        try:\n            item = model[idx]\n        except ValueError:\n            item = None\n        return item",
  "def _contextMenuSlot(self, ddict):\n        self.sigLegendSignal.emit(ddict)",
  "def mousePressEvent(self, event):\n        self.__lastButton = event.button()\n        self.__lastPosition = event.pos()\n        super(LegendListView, self).mousePressEvent(event)\n        # call _handleMouseClick after editing was handled\n        # If right click (context menu) is aborted, no\n        # signal is emitted..\n        self._handleMouseClick(self.indexAt(self.__lastPosition))",
  "def mouseDoubleClickEvent(self, event):\n        self.__lastButton = event.button()\n        self.__lastPosition = event.pos()\n        super(LegendListView, self).mouseDoubleClickEvent(event)\n        # call _handleMouseClick after editing was handled\n        # If right click (context menu) is aborted, no\n        # signal is emitted..\n        self._handleMouseClick(self.indexAt(self.__lastPosition))",
  "def mouseMoveEvent(self, event):\n        # LegendListView.mouseMoveEvent is overwritten\n        # to suppress unwanted behavior in the delegate.\n        pass",
  "def mouseReleaseEvent(self, event):\n        # LegendListView.mouseReleaseEvent is overwritten\n        # to subpress unwanted behavior in the delegate.\n        pass",
  "def _handleMouseClick(self, modelIndex):\n        \"\"\"\n        Distinguish between mouse click on Legend\n        and mouse click on CheckBox by setting the\n        currentCheckState attribute in LegendListItem.\n\n        Emits signal sigLegendSignal(ddict)\n\n        :param QModelIndex modelIndex: index of the clicked item\n        \"\"\"\n        _logger.debug('self._handleMouseClick called')\n        if self.__lastButton not in [qt.Qt.LeftButton,\n                                     qt.Qt.RightButton]:\n            return\n        if not modelIndex.isValid():\n            _logger.debug('_handleMouseClick -- Invalid QModelIndex')\n            return\n        # model = self.model()\n        idx = modelIndex.row()\n\n        delegate = self.itemDelegate()\n        cbClicked = False\n        if isinstance(delegate, LegendListItemWidget):\n            for cbRect in delegate.cbDict.values():\n                if cbRect.contains(self.__lastPosition):\n                    cbClicked = True\n                    break\n\n        # TODO: Check for doubleclicks on legend/icon and spawn editors\n\n        ddict = {\n            'legend': str(modelIndex.data(qt.Qt.DisplayRole)),\n            'icon': {\n                'linewidth': str(modelIndex.data(\n                    LegendModel.iconLineWidthRole)),\n                'linestyle': str(modelIndex.data(\n                    LegendModel.iconLineStyleRole)),\n                'symbol': str(modelIndex.data(LegendModel.iconSymbolRole))\n            },\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data())\n        }\n        if self.__lastButton == qt.Qt.RightButton:\n            _logger.debug('Right clicked')\n            ddict['button'] = \"right\"\n            ddict['event'] = self.__mouseClickedEvent\n        elif cbClicked:\n            _logger.debug('CheckBox clicked')\n            ddict['button'] = \"left\"\n            ddict['event'] = self.__checkBoxClickedEvent\n        else:\n            _logger.debug('Legend clicked')\n            ddict['button'] = \"left\"\n            ddict['event'] = self.__legendClickedEvent\n        _logger.debug('  idx: %d\\n  ddict: %s', idx, str(ddict))\n        self.sigLegendSignal.emit(ddict)",
  "def __init__(self, model):\n        super(LegendListContextMenu, self).__init__(parent=None)\n        self.model = model\n\n        self.addAction('Set Active', self.setActiveAction)\n        self.addAction('Map to left', self.mapToLeftAction)\n        self.addAction('Map to right', self.mapToRightAction)\n\n        self._pointsAction = self.addAction(\n            'Points', self.togglePointsAction)\n        self._pointsAction.setCheckable(True)\n\n        self._linesAction = self.addAction('Lines', self.toggleLinesAction)\n        self._linesAction.setCheckable(True)\n\n        self.addAction('Remove curve', self.removeItemAction)\n        self.addAction('Rename curve', self.renameItemAction)",
  "def exec_(self, pos, idx):\n        self.__currentIdx = idx\n\n        # Set checkable action state\n        modelIndex = self.currentIdx()\n        self._pointsAction.setChecked(\n            modelIndex.data(LegendModel.showSymbolRole))\n        self._linesAction.setChecked(\n            modelIndex.data(LegendModel.showLineRole))\n\n        super(LegendListContextMenu, self).popup(pos)",
  "def currentIdx(self):\n        return self.__currentIdx",
  "def mapToLeftAction(self):\n        _logger.debug('LegendListContextMenu.mapToLeftAction called')\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n            'event': \"mapToLeft\"\n        }\n        self.sigContextMenu.emit(ddict)",
  "def mapToRightAction(self):\n        _logger.debug('LegendListContextMenu.mapToRightAction called')\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n            'event': \"mapToRight\"\n        }\n        self.sigContextMenu.emit(ddict)",
  "def removeItemAction(self):\n        _logger.debug('LegendListContextMenu.removeCurveAction called')\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n            'event': \"removeCurve\"\n        }\n        self.model.removeRow(modelIndex.row())\n        self.sigContextMenu.emit(ddict)",
  "def renameItemAction(self):\n        _logger.debug('LegendListContextMenu.renameCurveAction called')\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n            'event': \"renameCurve\"\n        }\n        self.sigContextMenu.emit(ddict)",
  "def toggleLinesAction(self):\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n        }\n        linestyle = modelIndex.data(LegendModel.iconLineStyleRole)\n        visible = not modelIndex.data(LegendModel.showLineRole)\n        _logger.debug('toggleLinesAction -- lines visible: %s', str(visible))\n        ddict['event'] = \"toggleLine\"\n        ddict['line'] = visible\n        ddict['linestyle'] = linestyle if visible else ''\n        self.model.setData(modelIndex, visible, LegendModel.showLineRole)\n        self.sigContextMenu.emit(ddict)",
  "def togglePointsAction(self):\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n        }\n        flag = modelIndex.data(LegendModel.showSymbolRole)\n        symbol = modelIndex.data(LegendModel.iconSymbolRole)\n        visible = not flag or symbol in NoSymbols\n        _logger.debug(\n            'togglePointsAction -- Symbols visible: %s', str(visible))\n\n        ddict['event'] = \"togglePoints\"\n        ddict['points'] = visible\n        ddict['symbol'] = symbol if visible else ''\n        self.model.setData(modelIndex, visible, LegendModel.showSymbolRole)\n        self.sigContextMenu.emit(ddict)",
  "def setActiveAction(self):\n        modelIndex = self.currentIdx()\n        legend = str(modelIndex.data(qt.Qt.DisplayRole))\n        _logger.debug('setActiveAction -- active curve: %s', legend)\n        ddict = {\n            'legend': legend,\n            'label': legend,\n            'selected': modelIndex.data(qt.Qt.CheckStateRole),\n            'type': str(modelIndex.data()),\n            'event': \"setActiveCurve\",\n        }\n        self.sigContextMenu.emit(ddict)",
  "def __init__(self, parent=None, current=\"\", curves=[]):\n        super(RenameCurveDialog, self).__init__(parent)\n        self.setWindowTitle(\"Rename Curve %s\" % current)\n        self.curves = curves\n        layout = qt.QVBoxLayout(self)\n        self.lineEdit = qt.QLineEdit(self)\n        self.lineEdit.setText(current)\n        self.hbox = qt.QWidget(self)\n        self.hboxLayout = qt.QHBoxLayout(self.hbox)\n        self.hboxLayout.addStretch(1)\n        self.okButton = qt.QPushButton(self.hbox)\n        self.okButton.setText('OK')\n        self.hboxLayout.addWidget(self.okButton)\n        self.cancelButton = qt.QPushButton(self.hbox)\n        self.cancelButton.setText('Cancel')\n        self.hboxLayout.addWidget(self.cancelButton)\n        self.hboxLayout.addStretch(1)\n        layout.addWidget(self.lineEdit)\n        layout.addWidget(self.hbox)\n        self.okButton.clicked.connect(self.preAccept)\n        self.cancelButton.clicked.connect(self.reject)",
  "def preAccept(self):\n        text = str(self.lineEdit.text())\n        addedText = \"\"\n        if len(text):\n            if text not in self.curves:\n                self.accept()\n                return\n            else:\n                addedText = \"Curve already exists.\"\n        text = \"Invalid Curve Name\"\n        msg = qt.QMessageBox(self)\n        msg.setIcon(qt.QMessageBox.Critical)\n        msg.setWindowTitle(text)\n        text += \"\\n%s\" % addedText\n        msg.setText(text)\n        msg.exec_()",
  "def getText(self):\n        return str(self.lineEdit.text())",
  "def __init__(self, plot, parent=None):\n        assert plot is not None\n        self._plotRef = weakref.ref(plot)\n\n        super(LegendsDockWidget, self).__init__(\"Legends\", self.plot)\n\n        self._legendWidget = LegendListView()\n\n        self.layout().setContentsMargins(0, 0, 0, 0)\n        self.setWidget(self._legendWidget)\n\n        width = self.plot.centralWidget().width()\n        height = self.plot.centralWidget().height()\n        if width > (1.25 * height):\n            area = qt.Qt.RightDockWidgetArea\n        else:\n            area = qt.Qt.BottomDockWidgetArea\n        self.plot.addDockWidget(area, self)\n\n        self.visibilityChanged.connect(\n            self._visibilityChangedHandler)\n\n        self._legendWidget.sigLegendSignal.connect(self._legendSignalHandler)",
  "def plot(self):\n        \"\"\"The :class:`.PlotWindow` this widget is attached to.\"\"\"\n        return self._plotRef()",
  "def renameCurve(self, oldLegend, newLegend):\n        \"\"\"Change the name of a curve using remove and addCurve\n\n        :param str oldLegend: The legend of the curve to be change\n        :param str newLegend: The new legend of the curve\n        \"\"\"\n        x, y, legend, info, params = self.plot.getCurve(oldLegend)[0:5]\n        self.plot.remove(oldLegend, kind='curve')\n        self.plot.addCurve(x, y, legend=newLegend, resetzoom=False, **params)",
  "def _legendSignalHandler(self, ddict):\n        \"\"\"Handles events from the LegendListView signal\"\"\"\n        _logger.debug(\"Legend signal ddict = \", ddict)\n\n        if ddict['event'] == \"legendClicked\":\n            if ddict['button'] == \"left\":\n                self.plot.setActiveCurve(ddict['legend'])\n\n        elif ddict['event'] == \"removeCurve\":\n            self.plot.removeCurve(ddict['legend'])\n\n        elif ddict['event'] == \"renameCurve\":\n            curveList = self.plot.getAllCurves(just_legend=True)\n            oldLegend = ddict['legend']\n            dialog = RenameCurveDialog(self.plot, oldLegend, curveList)\n            ret = dialog.exec_()\n            if ret:\n                newLegend = dialog.getText()\n                self.renameCurve(oldLegend, newLegend)\n\n        elif ddict['event'] == \"setActiveCurve\":\n            self.plot.setActiveCurve(ddict['legend'])\n\n        elif ddict['event'] == \"checkBoxClicked\":\n            self.plot.hideCurve(ddict['legend'], not ddict['selected'])\n\n        elif ddict['event'] in [\"mapToRight\", \"mapToLeft\"]:\n            legend = ddict['legend']\n            x, y, legend, info, params = self.plot.getCurve(legend)[0:5]\n            params = params.copy()\n            if ddict['event'] == \"mapToRight\":\n                params['yaxis'] = \"right\"\n            else:\n                params['yaxis'] = \"left\"\n            self.plot.addCurve(x, y, legend=legend, **params)\n\n        elif ddict['event'] == \"togglePoints\":\n            legend = ddict['legend']\n            x, y, legend, info, params = self.plot.getCurve(legend)[0:5]\n            params = params.copy()\n            params['symbol'] = ddict['symbol'] if ddict['points'] else ''\n            self.plot.addCurve(x, y, legend=legend, resetzoom=False, **params)\n\n        elif ddict['event'] == \"toggleLine\":\n            legend = ddict['legend']\n            x, y, legend, info, params = self.plot.getCurve(legend)[0:5]\n            params = params.copy()\n            params['linestyle'] = ddict['linestyle'] if ddict['line'] else ''\n            self.plot.addCurve(x, y, legend=legend, resetzoom=False, **params)\n\n        else:\n            _logger.debug(\"unhandled event %s\", str(ddict['event']))",
  "def updateLegends(self, *args):\n        \"\"\"Sync the LegendSelector widget displayed info with the plot.\n        \"\"\"\n        legendList = []\n        curves = self.plot.getAllCurves(withhidden=True)\n        for x, y, legend, info, params in curves:\n            # Use active color if curve is active\n            if legend == self.plot.getActiveCurve(just_legend=True):\n                print('got an active curve')\n                color = self.plot.getActiveCurveColor()\n            else:\n                color = params['color']\n\n            curveInfo = {\n                'color': qt.QColor(color),\n                'linewidth': params['linewidth'],\n                'linestyle': params['linestyle'],\n                'symbol': params['symbol'],\n                'selected': not self.plot.isCurveHidden(legend)}\n            legendList.append((legend, curveInfo))\n\n        self._legendWidget.setLegendList(legendList)",
  "def _visibilityChangedHandler(self, visible):\n        if visible:\n            self.updateLegends()\n            self.plot.sigContentChanged.connect(self.updateLegends)\n            self.plot.sigActiveCurveChanged.connect(self.updateLegends)\n        else:\n            self.plot.sigContentChanged.disconnect(self.updateLegends)\n            self.plot.sigActiveCurveChanged.disconnect(self.updateLegends)",
  "class _PlotAction(qt.QAction):\n    \"\"\"Base class for QAction that operates on a PlotWidget.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate.\n    :param icon: QIcon or str name of icon to use\n    :param str text: The name of this action to be used for menu label\n    :param str tooltip: The text of the tooltip\n    :param triggered: The callback to connect to the action's triggered\n                      signal or None for no callback.\n    :param bool checkable: True for checkable action, False otherwise (default)\n    :param parent: See :class:`QAction`.\n    \"\"\"\n\n    def __init__(self, plot, icon, text, tooltip=None,\n                 triggered=None, checkable=False, parent=None):\n        assert plot is not None\n        self._plotRef = weakref.ref(plot)\n\n        if not isinstance(icon, qt.QIcon):\n            # Try with icon as a string and load corresponding icon\n            icon = icons.getQIcon(icon)\n\n        super(_PlotAction, self).__init__(icon, text, None)\n\n        if tooltip is not None:\n            self.setToolTip(tooltip)\n\n        self.setCheckable(checkable)\n\n        if triggered is not None:\n            self.triggered[bool].connect(triggered)\n\n    @property\n    def plot(self):\n        \"\"\"The :class:`.PlotWidget` this action group is controlling.\"\"\"\n        return self._plotRef()",
  "class ResetZoomAction(_PlotAction):\n    \"\"\"QAction controlling reset zoom on a :class:`.PlotWidget`.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        super(ResetZoomAction, self).__init__(\n            plot,  icon='zoom-original', text='Reset Zoom',\n            tooltip='Auto-Scale the Graph',\n            triggered=self._actionTriggered,\n            checkable=False, parent=parent)\n\n    def _actionTriggered(self, checked=False):\n        self.plot.resetZoom()",
  "class XAxisAutoScaleAction(_PlotAction):\n    \"\"\"QAction controlling X axis autoscale on a :class:`.PlotWidget`.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        super(XAxisAutoScaleAction, self).__init__(\n            plot, icon='plot-xauto', text='X Autoscale',\n            tooltip='Enable X Axis Autoscale when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.isXAxisAutoScale())\n        plot.sigSetXAxisAutoScale.connect(self.setChecked)\n\n    def _actionTriggered(self, checked=False):\n        self.plot.setXAxisAutoScale(checked)",
  "class YAxisAutoScaleAction(_PlotAction):\n    \"\"\"QAction controlling Y axis autoscale on a :class:`.PlotWidget`.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        super(YAxisAutoScaleAction, self).__init__(\n            plot, icon='plot-yauto', text='Y Autoscale',\n            tooltip='Enable Y Axis Autoscale when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.isXAxisAutoScale())\n        plot.sigSetYAxisAutoScale.connect(self.setChecked)\n\n    def _actionTriggered(self, checked=False):\n        self.plot.setYAxisAutoScale(checked)",
  "class XAxisLogarithmicAction(_PlotAction):\n    \"\"\"QAction controlling X axis log scale on a :class:`.PlotWidget`.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        super(XAxisLogarithmicAction, self).__init__(\n            plot, icon='plot-xlog', text='X Log. scale',\n            tooltip='Logarithmic X Axis when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.isXAxisLogarithmic())\n        plot.sigSetXAxisLogarithmic.connect(self.setChecked)\n\n    def _actionTriggered(self, checked=False):\n        self.plot.setXAxisLogarithmic(checked)",
  "class YAxisLogarithmicAction(_PlotAction):\n    \"\"\"QAction controlling Y axis log scale on a :class:`.PlotWidget`.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        super(YAxisLogarithmicAction, self).__init__(\n            plot, icon='plot-ylog', text='Y Log. scale',\n            tooltip='Logarithmic Y Axis when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.isYAxisLogarithmic())\n        plot.sigSetYAxisLogarithmic.connect(self.setChecked)\n\n    def _actionTriggered(self, checked=False):\n        self.plot.setYAxisLogarithmic(checked)",
  "class GridAction(_PlotAction):\n    \"\"\"QAction controlling grid mode on a :class:`.PlotWidget`.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param str gridMode: The grid mode to use in 'both', 'major'.\n                         See :meth:`.PlotWidget.setGraphGrid`\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, gridMode='both', parent=None):\n        assert gridMode in ('both', 'major')\n        self._gridMode = gridMode\n\n        super(GridAction, self).__init__(\n            plot, icon='plot-grid', text='Grid',\n            tooltip='Toggle grid (On/Off)',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.getGraphGrid() is not None)\n        plot.sigSetGraphGrid.connect(self._gridChanged)\n\n    def _gridChanged(self, which):\n        \"\"\"Slot listening for PlotWidget grid mode change.\"\"\"\n        self.setChecked(which != 'None')\n\n    def _actionTriggered(self, checked=False):\n        self.plot.setGraphGrid(self._gridMode if checked else None)",
  "class CurveStyleAction(_PlotAction):\n    \"\"\"QAction controlling curve style on a :class:`.PlotWidget`.\n\n    It changes the default line and markers style which updates all\n    curves on the plot.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        super(CurveStyleAction, self).__init__(\n            plot, icon='plot-toggle-points', text='Curve style',\n            tooltip='Change curve line and markers style',\n            triggered=self._actionTriggered,\n            checkable=False, parent=parent)\n\n    def _actionTriggered(self, checked=False):\n        currentState = (self.plot.isDefaultPlotLines(),\n                        self.plot.isDefaultPlotPoints())\n\n        # line only, line and symbol, symbol only\n        states = (True, False), (True, True), (False, True)\n        newState = states[(states.index(currentState) + 1) % 3]\n\n        self.plot.setDefaultPlotLines(newState[0])\n        self.plot.setDefaultPlotPoints(newState[1])",
  "class ColormapAction(_PlotAction):\n    \"\"\"QAction opening a ColormapDialog to update the colormap.\n\n    Both the active image colormap and the default colormap are updated.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n    def __init__(self, plot, parent=None):\n        self._dialog = None  # To store an instance of ColormapDialog\n        super(ColormapAction, self).__init__(\n            plot, icon='colormap', text='Colormap',\n            tooltip=\"Change colormap\",\n            triggered=self._actionTriggered,\n            checkable=False, parent=parent)\n\n    def _actionTriggered(self, checked=False):\n        \"\"\"Create a cmap dialog and update active image and default cmap.\"\"\"\n        # Create the dialog if not already existing\n        if self._dialog is None:\n            self._dialog = ColormapDialog()\n\n        image = self.plot.getActiveImage()\n        if image is None:\n            # No active image, set dialog from default info\n            colormap = self.plot.getDefaultColormap()\n\n            self._dialog.setHistogram()  # Reset histogram and range if any\n\n        else:\n            # Set dialog from active image\n            colormap = image[4]['colormap']\n\n            data = image[0]\n\n            goodData = data[numpy.isfinite(data)]\n            if goodData.size > 0:\n                dataMin = goodData.min()\n                dataMax = goodData.max()\n            else:\n                qt.QMessageBox.warning(\n                    self, \"No Data\",\n                    \"Image data does not contain any real value\")\n                dataMin, dataMax = 1., 10.\n\n            self._dialog.setHistogram()  # Reset histogram if any\n            self._dialog.setDataRange(dataMin, dataMax)\n            # The histogram should be done in a worker thread\n            # hist, bin_edges = numpy.histogram(goodData, bins=256)\n            # self._dialog.setHistogram(hist, bin_edges)\n\n        self._dialog.setColormap(**colormap)\n\n        # Run the dialog listening to colormap change\n        self._dialog.sigColormapChanged.connect(self._colormapChanged)\n        result = self._dialog.exec_()\n        self._dialog.sigColormapChanged.disconnect(self._colormapChanged)\n\n        if not result:  # Restore the previous colormap\n            self._colormapChanged(colormap)\n\n    def _colormapChanged(self, colormap):\n        # Update default colormap\n        self.plot.setDefaultColormap(colormap)\n\n        # Update active image\n        image = self.plot.getActiveImage()\n        if image is not None:\n            # Update image: This do not preserve pixmap\n            params = image[4].copy()\n            params['colormap'] = colormap\n            self.plot.addImage(image[0],\n                               legend=image[1],\n                               replace=False,\n                               resetzoom=False,\n                               **params)",
  "class KeepAspectRatioAction(_PlotAction):\n    \"\"\"QAction controlling aspect ratio on a :class:`.PlotWidget`.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        # Uses two images for checked/unchecked states\n        self._states = {\n            False: (icons.getQIcon('shape-circle-solid'),\n                    \"Keep data aspect ratio\"),\n            True: (icons.getQIcon('shape-ellipse-solid'),\n                   \"Do no keep data aspect ratio\")\n        }\n\n        icon, tooltip = self._states[plot.isKeepDataAspectRatio()]\n        super(KeepAspectRatioAction, self).__init__(\n            plot,\n            icon=icon,\n            text='Toggle keep aspect ratio',\n            tooltip=tooltip,\n            triggered=self._actionTriggered,\n            checkable=False,\n            parent=parent)\n        plot.sigSetKeepDataAspectRatio.connect(\n            self._keepDataAspectRatioChanged)\n\n    def _keepDataAspectRatioChanged(self, aspectRatio):\n        \"\"\"Handle Plot set keep aspect ratio signal\"\"\"\n        icon, tooltip = self._states[aspectRatio]\n        self.setIcon(icon)\n        self.setToolTip(tooltip)\n\n    def _actionTriggered(self, checked=False):\n        # This will trigger _keepDataAspectRatioChanged\n        self.plot.setKeepDataAspectRatio(not self.plot.isKeepDataAspectRatio())",
  "class YAxisInvertedAction(_PlotAction):\n    \"\"\"QAction controlling Y orientation on a :class:`.PlotWidget`.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        # Uses two images for checked/unchecked states\n        self._states = {\n            False: (icons.getQIcon('plot-ydown'),\n                    \"Orient Y axis downward\"),\n            True: (icons.getQIcon('plot-yup'),\n                   \"Orient Y axis upward\"),\n        }\n\n        icon, tooltip = self._states[plot.isYAxisInverted()]\n        super(YAxisInvertedAction, self).__init__(\n            plot,\n            icon=icon,\n            text='Invert Y Axis',\n            tooltip=tooltip,\n            triggered=self._actionTriggered,\n            checkable=False,\n            parent=parent)\n        plot.sigSetYAxisInverted.connect(self._yAxisInvertedChanged)\n\n    def _yAxisInvertedChanged(self, inverted):\n        \"\"\"Handle Plot set y axis inverted signal\"\"\"\n        icon, tooltip = self._states[inverted]\n        self.setIcon(icon)\n        self.setToolTip(tooltip)\n\n    def _actionTriggered(self, checked=False):\n        # This will trigger _yAxisInvertedChanged\n        self.plot.setYAxisInverted(not self.plot.isYAxisInverted())",
  "class SaveAction(_PlotAction):\n    \"\"\"QAction for saving Plot content.\n\n    It opens a Save as... dialog.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate.\n    :param parent: See :class:`QAction`.\n    \"\"\"\n    # TODO find a way to make the filter list selectable and extensible\n\n    SNAPSHOT_FILTERS = ('Plot Snapshot PNG *.png', 'Plot Snapshot JPEG *.jpg')\n\n    # Dict of curve filters with CSV-like format\n    # Using ordered dict to guarantee filters order\n    # Note: '%.18e' is numpy.savetxt default format\n    CURVE_FILTERS_TXT = OrderedDict((\n        ('Curve as Raw ASCII *.txt',\n         {'fmt': '%.18e', 'delimiter': ' ', 'header': False}),\n        ('Curve as \";\"-separated CSV *.csv',\n         {'fmt': '%.18e', 'delimiter': ';', 'header': True}),\n        ('Curve as \",\"-separated CSV *.csv',\n         {'fmt': '%.18e', 'delimiter': ',', 'header': True}),\n        ('Curve as tab-separated CSV *.csv',\n         {'fmt': '%.18e', 'delimiter': '\\t', 'header': True}),\n        ('Curve as OMNIC CSV *.csv',\n         {'fmt': '%.7E', 'delimiter': ',', 'header': False}),\n        ('Curve as SpecFile *.dat',\n         {'fmt': '%.7g', 'delimiter': '', 'header': False})\n    ))\n\n    CURVE_FILTER_NPY = 'Curve as NumPy binary file *.npy'\n\n    CURVE_FILTERS = list(CURVE_FILTERS_TXT.keys()) + [CURVE_FILTER_NPY]\n\n    ALL_CURVES_FILTERS = (\"All curves as SpecFile *.dat\", )\n\n    IMAGE_FILTER_EDF = 'Image as EDF *.edf'\n    IMAGE_FILTER_TIFF = 'Image as TIFF *.tif'\n    IMAGE_FILTER_NUMPY = 'Image as NumPy binary file *.npy'\n    IMAGE_FILTERS = (IMAGE_FILTER_EDF, IMAGE_FILTER_TIFF, IMAGE_FILTER_NUMPY)\n\n    def __init__(self, plot, parent=None):\n        super(SaveAction, self).__init__(\n            plot, icon='document-save', text='Save as...',\n            tooltip='Save Curve/Image/Plot Snapshot Dialog',\n            triggered=self._actionTriggered,\n            checkable=False, parent=parent)\n        self.setShortcut(qt.QKeySequence.Save)\n\n    def _errorMessage(self, informativeText=''):\n        \"\"\"Display an error message.\"\"\"\n        # TODO issue with QMessageBox size fixed and too small\n        msg = qt.QMessageBox(self.plot)\n        msg.setIcon(qt.QMessageBox.Critical)\n        msg.setInformativeText(informativeText + ' ' + str(sys.exc_info()[1]))\n        msg.setDetailedText(traceback.format_exc())\n        msg.exec_()\n\n    def _saveSnapshot(self, filename, nameFilter):\n        \"\"\"Save a snapshot of the :class:`PlotWindow` widget.\n\n        :param str filename: The name of the file to write\n        :param str nameFilter: The selected name filter\n        :return: False if format is not supported or save failed,\n                 True otherwise.\n        \"\"\"\n        pixmap = qt.QPixmap.grabWidget(self.plot.centralWidget())\n        if not pixmap.save(filename):\n            self._errorMessage()\n            return False\n        return True\n\n    def _saveCurve(self, filename, nameFilter):\n        \"\"\"Save a curve from the plot.\n\n        :param str filename: The name of the file to write\n        :param str nameFilter: The selected name filter\n        :return: False if format is not supported or save failed,\n                 True otherwise.\n        \"\"\"\n        if nameFilter not in self.CURVE_FILTERS:\n            return False\n\n        # Check if a curve is to be saved\n        curve = self.plot.getActiveCurve()\n        # before calling _saveCurve, if there is no selected curve, we\n        # make sure there is only one curve on the graph\n        if curve is None:\n            curves = self.plot.getAllCurves()\n            if not curves:\n                self._errorMessage(\"No curve to be saved\")\n                return False\n            curve = curves[0]\n\n        if nameFilter in self.CURVE_FILTERS_TXT:\n            filter_ = self.CURVE_FILTERS_TXT[nameFilter]\n            fmt=filter_['fmt']\n            csvdelim=filter_['delimiter']\n            autoheader=filter_['header']\n        else:\n            # .npy\n            fmt, csvdelim, autoheader = (\"\", \"\", False)\n\n        try:\n            save1D(filename, curve[0], curve[1],\n                   curve[4]['xlabel'], [curve[4]['ylabel']],\n                   fmt=fmt, csvdelim=csvdelim,\n                   autoheader=autoheader)\n        except IOError:\n            self._errorMessage('Save failed\\n')\n            return False\n\n        return True\n\n    def _saveCurves(self, filename, nameFilter):\n        \"\"\"Save all curves from the plot.\n\n        :param str filename: The name of the file to write\n        :param str nameFilter: The selected name filter\n        :return: False if format is not supported or save failed,\n                 True otherwise.\n        \"\"\"\n        if nameFilter not in self.ALL_CURVES_FILTERS:\n            return False\n\n        curves = self.plot.getAllCurves()\n        if not curves:\n            self._errorMessage(\"No curves to be saved\")\n            return False\n\n        curve = curves[0]\n        scanno = 1\n        try:\n            specfile = savespec(filename, curve[0], curve[1],\n                                curve[4]['xlabel'], curve[4]['ylabel'],\n                                fmt=\"%.7g\", scan_number=1, mode=\"w\",\n                                write_file_header=True,\n                                close_file = False)\n        except IOError:\n            self._errorMessage('Save failed\\n')\n            return False\n\n        for curve in curves[1:]:\n            try:\n                scanno += 1\n                specfile = savespec(specfile, curve[0], curve[1],\n                                    curve[4]['xlabel'], curve[4]['ylabel'],\n                                    fmt=\"%.7g\", scan_number=scanno, mode=\"w\",\n                                    write_file_header=False,\n                                    close_file = False)\n            except IOError:\n                self._errorMessage('Save failed\\n')\n                return False\n        specfile.close()\n\n        return True\n\n    def _saveImage(self, filename, nameFilter):\n        \"\"\"Save an image from the plot.\n\n        :param str filename: The name of the file to write\n        :param str nameFilter: The selected name filter\n        :return: False if format is not supported or save failed,\n                 True otherwise.\n        \"\"\"\n        if nameFilter not in self.IMAGE_FILTERS:\n            return False\n\n        image = self.plot.getActiveImage()\n        if image is None:\n            qt.QMessageBox.warning(\n                self.plot, \"No Data\", \"No image to be saved\")\n            return False\n\n        data = image[0]\n\n        # TODO Use silx.io for writing files\n        if nameFilter == self.IMAGE_FILTER_EDF:\n            edfFile = EdfFile(filename, access=\"w+\")\n            edfFile.WriteImage({}, data, Append=0)\n\n        elif nameFilter == self.IMAGE_FILTER_TIFF:\n            tiffFile = TiffIO(filename, mode='w')\n            tiffFile.writeImage(data, software='silx')\n\n        elif nameFilter == self.IMAGE_FILTER_NUMPY:\n            try:\n                numpy.save(filename, data)\n            except IOError:\n                self._errorMessage('Save failed\\n')\n                return False\n            return True\n\n        return False\n\n    def _actionTriggered(self, checked=False):\n        \"\"\"Handle save action.\"\"\"\n        # Set-up filters\n        filters = []\n\n        # Add image filters if there is an active image\n        if self.plot.getActiveImage() is not None:\n            filters.extend(self.IMAGE_FILTERS)\n\n        # Add curve filters if there is a curve to save\n        if (self.plot.getActiveCurve() is not None or\n                len(self.plot.getAllCurves()) == 1):\n            filters.extend(self.CURVE_FILTERS)\n        if len(self.plot.getAllCurves()) > 1:\n            filters.extend(self.ALL_CURVES_FILTERS)\n\n        filters.extend(self.SNAPSHOT_FILTERS)\n\n        # Create and run File dialog\n        dialog = qt.QFileDialog(self.plot)\n        dialog.setWindowTitle(\"Output File Selection\")\n        dialog.setModal(1)\n        dialog.setNameFilters(filters)\n\n        dialog.setFileMode(dialog.AnyFile)\n        dialog.setAcceptMode(dialog.AcceptSave)\n\n        if not dialog.exec_():\n            return False\n\n        nameFilter = dialog.selectedNameFilter()\n        filename = dialog.selectedFiles()[0]\n        dialog.close()\n\n        # Forces the filename extension to match the chosen filter\n        extension = nameFilter.split()[-1][1:]\n        if (len(filename) <= len(extension) or\n                filename[-len(extension):].lower() != extension.lower()):\n            filename += extension\n\n        # Handle save\n        if nameFilter in self.SNAPSHOT_FILTERS:\n            return self._saveSnapshot(filename, nameFilter)\n        elif nameFilter in self.CURVE_FILTERS:\n            return self._saveCurve(filename, nameFilter)\n        elif nameFilter in self.ALL_CURVES_FILTERS:\n            return self._saveCurves(filename, nameFilter)\n        elif nameFilter in self.IMAGE_FILTERS:\n            return self._saveImage(filename, nameFilter)\n        else:\n            _logger.warning('Unsupported file filter: %s', nameFilter)\n            return False",
  "def _plotAsPNG(plot):\n    \"\"\"Save a :class:`Plot` as PNG and return the payload.\n\n    :param plot: The :class:`Plot` to save\n    \"\"\"\n    pngFile = BytesIO()\n    plot.saveGraph(pngFile, fileFormat='png')\n    pngFile.flush()\n    pngFile.seek(0)\n    data = pngFile.read()\n    pngFile.close()\n    return data",
  "class PrintAction(_PlotAction):\n    \"\"\"QAction for printing the plot.\n\n    It opens a Print dialog.\n\n    Current implementation print a bitmap of the plot area and not vector\n    graphics, so printing quality is not great.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate.\n    :param parent: See :class:`QAction`.\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        super(PrintAction, self).__init__(\n            plot, icon='document-print', text='Print...',\n            tooltip='Open Print Dialog',\n            triggered=self.printPlot,\n            checkable=False, parent=parent)\n        self.setShortcut(qt.QKeySequence.Print)\n\n    def printPlotAsWidget(self):\n        \"\"\"Open the print dialog and print the plot.\n\n        Use :meth:`QWidget.render` to print the plot\n\n        :return: True if successful\n        \"\"\"\n        printer = qt.QPrinter()\n        dialog = qt.QPrintDialog(printer, self.plot)\n        dialog.setWindowTitle('Print Plot')\n        if not dialog.exec_():\n            return False\n\n        # Print a snapshot of the plot widget at the top of the page\n        widget = self.plot.centralWidget()\n\n        painter = qt.QPainter()\n        if not painter.begin(printer):\n            return False\n\n        pageRect = printer.pageRect()\n        xScale = pageRect.width() / widget.width()\n        yScale = pageRect.height() / widget.height()\n        scale = min(xScale, yScale)\n\n        painter.translate(pageRect.width() / 2., 0.)\n        painter.scale(scale, scale)\n        painter.translate(-widget.width() / 2., 0.)\n        widget.render(painter)\n        painter.end()\n\n        return True\n\n    def printPlot(self):\n        \"\"\"Open the print dialog and print the plot.\n\n        Use :meth:`Plot.saveGraph` to print the plot.\n\n        :return: True if successful\n        \"\"\"\n        # Init printer and start printer dialog\n        printer = qt.QPrinter()\n        dialog = qt.QPrintDialog(printer, self.plot)\n        dialog.setWindowTitle('Print Plot')\n        if not dialog.exec_():\n            return False\n\n        # Save Plot as PNG and make a pixmap from it with default dpi\n        pngData = _plotAsPNG(self.plot)\n\n        pixmap = qt.QPixmap()\n        pixmap.loadFromData(pngData, 'png')\n\n        xScale = printer.pageRect().width() / pixmap.width()\n        yScale = printer.pageRect().height() / pixmap.height()\n        scale = min(xScale, yScale)\n\n        # Draw pixmap with painter\n        painter = qt.QPainter()\n        if not painter.begin(printer):\n            return False\n\n        painter.drawPixmap(0, 0,\n                           pixmap.width() * scale,\n                           pixmap.height() * scale,\n                           pixmap)\n        painter.end()\n\n        return True",
  "class CopyAction(_PlotAction):\n    \"\"\"QAction to copy :class:`.PlotWidget` content to clipboard.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        super(CopyAction, self).__init__(\n            plot, icon='edit-copy', text='Copy plot',\n            tooltip='Copy a snapshot of the plot the clipboard',\n            triggered=self.copyPlot,\n            checkable=False, parent=parent)\n        self.setShortcut(qt.QKeySequence.Copy)\n\n    def copyPlot(self):\n        \"\"\"Copy plot content to the clipboard as a bitmap.\"\"\"\n        # Save Plot as PNG and make a QImage from it with default dpi\n        pngData = _plotAsPNG(self.plot)\n        image = qt.QImage.fromData(pngData, 'png')\n        qt.QApplication.clipboard().setImage(image)",
  "class CrosshairAction(_PlotAction):\n    \"\"\"QAction toggling crosshair cursor on a :class:`.PlotWidget`.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param str color: Color to use to draw the crosshair\n    :param int linewidth: Width of the crosshair cursor\n    :param str linestyle: Style of line. See :meth:`.Plot.setGraphCursor`\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, color='black', linewidth=1, linestyle='-',\n                 parent=None):\n        self.color = color\n        \"\"\"Color used to draw the crosshair (str).\"\"\"\n\n        self.linewidth = linewidth\n        \"\"\"Width of the crosshair cursor (int).\"\"\"\n\n        self.linestyle = linestyle\n        \"\"\"Style of line of the cursor (str).\"\"\"\n\n        super(CrosshairAction, self).__init__(\n            plot, icon='crosshair', text='Crosshair Cursor',\n            tooltip='Enable crosshair cursor when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.getGraphCursor() is not None)\n        plot.sigSetGraphCursor.connect(self.setChecked)\n\n    def _actionTriggered(self, checked=False):\n        self.plot.setGraphCursor(checked,\n            color=self.color,\n            linestyle=self.linestyle,\n            linewidth=self.linewidth)",
  "class PanWithArrowKeysAction(_PlotAction):\n    \"\"\"QAction toggling pan with arrow keys on a :class:`.PlotWidget`.\n\n    :param plot: :class:`.PlotWidget` instance on which to operate\n    :param parent: See :class:`QAction`\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n\n        super(PanWithArrowKeysAction, self).__init__(\n            plot, icon='arrow_keys', text='Pan with arrow keys',\n            tooltip='Enable pan with arrow keys when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.isPanWithArrowKeys())\n        plot.sigSetPanWithArrowKeys.connect(self.setChecked)\n\n    def _actionTriggered(self, checked=False):\n        self.plot.setPanWithArrowKeys(checked)",
  "def __init__(self, plot, icon, text, tooltip=None,\n                 triggered=None, checkable=False, parent=None):\n        assert plot is not None\n        self._plotRef = weakref.ref(plot)\n\n        if not isinstance(icon, qt.QIcon):\n            # Try with icon as a string and load corresponding icon\n            icon = icons.getQIcon(icon)\n\n        super(_PlotAction, self).__init__(icon, text, None)\n\n        if tooltip is not None:\n            self.setToolTip(tooltip)\n\n        self.setCheckable(checkable)\n\n        if triggered is not None:\n            self.triggered[bool].connect(triggered)",
  "def plot(self):\n        \"\"\"The :class:`.PlotWidget` this action group is controlling.\"\"\"\n        return self._plotRef()",
  "def __init__(self, plot, parent=None):\n        super(ResetZoomAction, self).__init__(\n            plot,  icon='zoom-original', text='Reset Zoom',\n            tooltip='Auto-Scale the Graph',\n            triggered=self._actionTriggered,\n            checkable=False, parent=parent)",
  "def _actionTriggered(self, checked=False):\n        self.plot.resetZoom()",
  "def __init__(self, plot, parent=None):\n        super(XAxisAutoScaleAction, self).__init__(\n            plot, icon='plot-xauto', text='X Autoscale',\n            tooltip='Enable X Axis Autoscale when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.isXAxisAutoScale())\n        plot.sigSetXAxisAutoScale.connect(self.setChecked)",
  "def _actionTriggered(self, checked=False):\n        self.plot.setXAxisAutoScale(checked)",
  "def __init__(self, plot, parent=None):\n        super(YAxisAutoScaleAction, self).__init__(\n            plot, icon='plot-yauto', text='Y Autoscale',\n            tooltip='Enable Y Axis Autoscale when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.isXAxisAutoScale())\n        plot.sigSetYAxisAutoScale.connect(self.setChecked)",
  "def _actionTriggered(self, checked=False):\n        self.plot.setYAxisAutoScale(checked)",
  "def __init__(self, plot, parent=None):\n        super(XAxisLogarithmicAction, self).__init__(\n            plot, icon='plot-xlog', text='X Log. scale',\n            tooltip='Logarithmic X Axis when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.isXAxisLogarithmic())\n        plot.sigSetXAxisLogarithmic.connect(self.setChecked)",
  "def _actionTriggered(self, checked=False):\n        self.plot.setXAxisLogarithmic(checked)",
  "def __init__(self, plot, parent=None):\n        super(YAxisLogarithmicAction, self).__init__(\n            plot, icon='plot-ylog', text='Y Log. scale',\n            tooltip='Logarithmic Y Axis when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.isYAxisLogarithmic())\n        plot.sigSetYAxisLogarithmic.connect(self.setChecked)",
  "def _actionTriggered(self, checked=False):\n        self.plot.setYAxisLogarithmic(checked)",
  "def __init__(self, plot, gridMode='both', parent=None):\n        assert gridMode in ('both', 'major')\n        self._gridMode = gridMode\n\n        super(GridAction, self).__init__(\n            plot, icon='plot-grid', text='Grid',\n            tooltip='Toggle grid (On/Off)',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.getGraphGrid() is not None)\n        plot.sigSetGraphGrid.connect(self._gridChanged)",
  "def _gridChanged(self, which):\n        \"\"\"Slot listening for PlotWidget grid mode change.\"\"\"\n        self.setChecked(which != 'None')",
  "def _actionTriggered(self, checked=False):\n        self.plot.setGraphGrid(self._gridMode if checked else None)",
  "def __init__(self, plot, parent=None):\n        super(CurveStyleAction, self).__init__(\n            plot, icon='plot-toggle-points', text='Curve style',\n            tooltip='Change curve line and markers style',\n            triggered=self._actionTriggered,\n            checkable=False, parent=parent)",
  "def _actionTriggered(self, checked=False):\n        currentState = (self.plot.isDefaultPlotLines(),\n                        self.plot.isDefaultPlotPoints())\n\n        # line only, line and symbol, symbol only\n        states = (True, False), (True, True), (False, True)\n        newState = states[(states.index(currentState) + 1) % 3]\n\n        self.plot.setDefaultPlotLines(newState[0])\n        self.plot.setDefaultPlotPoints(newState[1])",
  "def __init__(self, plot, parent=None):\n        self._dialog = None  # To store an instance of ColormapDialog\n        super(ColormapAction, self).__init__(\n            plot, icon='colormap', text='Colormap',\n            tooltip=\"Change colormap\",\n            triggered=self._actionTriggered,\n            checkable=False, parent=parent)",
  "def _actionTriggered(self, checked=False):\n        \"\"\"Create a cmap dialog and update active image and default cmap.\"\"\"\n        # Create the dialog if not already existing\n        if self._dialog is None:\n            self._dialog = ColormapDialog()\n\n        image = self.plot.getActiveImage()\n        if image is None:\n            # No active image, set dialog from default info\n            colormap = self.plot.getDefaultColormap()\n\n            self._dialog.setHistogram()  # Reset histogram and range if any\n\n        else:\n            # Set dialog from active image\n            colormap = image[4]['colormap']\n\n            data = image[0]\n\n            goodData = data[numpy.isfinite(data)]\n            if goodData.size > 0:\n                dataMin = goodData.min()\n                dataMax = goodData.max()\n            else:\n                qt.QMessageBox.warning(\n                    self, \"No Data\",\n                    \"Image data does not contain any real value\")\n                dataMin, dataMax = 1., 10.\n\n            self._dialog.setHistogram()  # Reset histogram if any\n            self._dialog.setDataRange(dataMin, dataMax)\n            # The histogram should be done in a worker thread\n            # hist, bin_edges = numpy.histogram(goodData, bins=256)\n            # self._dialog.setHistogram(hist, bin_edges)\n\n        self._dialog.setColormap(**colormap)\n\n        # Run the dialog listening to colormap change\n        self._dialog.sigColormapChanged.connect(self._colormapChanged)\n        result = self._dialog.exec_()\n        self._dialog.sigColormapChanged.disconnect(self._colormapChanged)\n\n        if not result:  # Restore the previous colormap\n            self._colormapChanged(colormap)",
  "def _colormapChanged(self, colormap):\n        # Update default colormap\n        self.plot.setDefaultColormap(colormap)\n\n        # Update active image\n        image = self.plot.getActiveImage()\n        if image is not None:\n            # Update image: This do not preserve pixmap\n            params = image[4].copy()\n            params['colormap'] = colormap\n            self.plot.addImage(image[0],\n                               legend=image[1],\n                               replace=False,\n                               resetzoom=False,\n                               **params)",
  "def __init__(self, plot, parent=None):\n        # Uses two images for checked/unchecked states\n        self._states = {\n            False: (icons.getQIcon('shape-circle-solid'),\n                    \"Keep data aspect ratio\"),\n            True: (icons.getQIcon('shape-ellipse-solid'),\n                   \"Do no keep data aspect ratio\")\n        }\n\n        icon, tooltip = self._states[plot.isKeepDataAspectRatio()]\n        super(KeepAspectRatioAction, self).__init__(\n            plot,\n            icon=icon,\n            text='Toggle keep aspect ratio',\n            tooltip=tooltip,\n            triggered=self._actionTriggered,\n            checkable=False,\n            parent=parent)\n        plot.sigSetKeepDataAspectRatio.connect(\n            self._keepDataAspectRatioChanged)",
  "def _keepDataAspectRatioChanged(self, aspectRatio):\n        \"\"\"Handle Plot set keep aspect ratio signal\"\"\"\n        icon, tooltip = self._states[aspectRatio]\n        self.setIcon(icon)\n        self.setToolTip(tooltip)",
  "def _actionTriggered(self, checked=False):\n        # This will trigger _keepDataAspectRatioChanged\n        self.plot.setKeepDataAspectRatio(not self.plot.isKeepDataAspectRatio())",
  "def __init__(self, plot, parent=None):\n        # Uses two images for checked/unchecked states\n        self._states = {\n            False: (icons.getQIcon('plot-ydown'),\n                    \"Orient Y axis downward\"),\n            True: (icons.getQIcon('plot-yup'),\n                   \"Orient Y axis upward\"),\n        }\n\n        icon, tooltip = self._states[plot.isYAxisInverted()]\n        super(YAxisInvertedAction, self).__init__(\n            plot,\n            icon=icon,\n            text='Invert Y Axis',\n            tooltip=tooltip,\n            triggered=self._actionTriggered,\n            checkable=False,\n            parent=parent)\n        plot.sigSetYAxisInverted.connect(self._yAxisInvertedChanged)",
  "def _yAxisInvertedChanged(self, inverted):\n        \"\"\"Handle Plot set y axis inverted signal\"\"\"\n        icon, tooltip = self._states[inverted]\n        self.setIcon(icon)\n        self.setToolTip(tooltip)",
  "def _actionTriggered(self, checked=False):\n        # This will trigger _yAxisInvertedChanged\n        self.plot.setYAxisInverted(not self.plot.isYAxisInverted())",
  "def __init__(self, plot, parent=None):\n        super(SaveAction, self).__init__(\n            plot, icon='document-save', text='Save as...',\n            tooltip='Save Curve/Image/Plot Snapshot Dialog',\n            triggered=self._actionTriggered,\n            checkable=False, parent=parent)\n        self.setShortcut(qt.QKeySequence.Save)",
  "def _errorMessage(self, informativeText=''):\n        \"\"\"Display an error message.\"\"\"\n        # TODO issue with QMessageBox size fixed and too small\n        msg = qt.QMessageBox(self.plot)\n        msg.setIcon(qt.QMessageBox.Critical)\n        msg.setInformativeText(informativeText + ' ' + str(sys.exc_info()[1]))\n        msg.setDetailedText(traceback.format_exc())\n        msg.exec_()",
  "def _saveSnapshot(self, filename, nameFilter):\n        \"\"\"Save a snapshot of the :class:`PlotWindow` widget.\n\n        :param str filename: The name of the file to write\n        :param str nameFilter: The selected name filter\n        :return: False if format is not supported or save failed,\n                 True otherwise.\n        \"\"\"\n        pixmap = qt.QPixmap.grabWidget(self.plot.centralWidget())\n        if not pixmap.save(filename):\n            self._errorMessage()\n            return False\n        return True",
  "def _saveCurve(self, filename, nameFilter):\n        \"\"\"Save a curve from the plot.\n\n        :param str filename: The name of the file to write\n        :param str nameFilter: The selected name filter\n        :return: False if format is not supported or save failed,\n                 True otherwise.\n        \"\"\"\n        if nameFilter not in self.CURVE_FILTERS:\n            return False\n\n        # Check if a curve is to be saved\n        curve = self.plot.getActiveCurve()\n        # before calling _saveCurve, if there is no selected curve, we\n        # make sure there is only one curve on the graph\n        if curve is None:\n            curves = self.plot.getAllCurves()\n            if not curves:\n                self._errorMessage(\"No curve to be saved\")\n                return False\n            curve = curves[0]\n\n        if nameFilter in self.CURVE_FILTERS_TXT:\n            filter_ = self.CURVE_FILTERS_TXT[nameFilter]\n            fmt=filter_['fmt']\n            csvdelim=filter_['delimiter']\n            autoheader=filter_['header']\n        else:\n            # .npy\n            fmt, csvdelim, autoheader = (\"\", \"\", False)\n\n        try:\n            save1D(filename, curve[0], curve[1],\n                   curve[4]['xlabel'], [curve[4]['ylabel']],\n                   fmt=fmt, csvdelim=csvdelim,\n                   autoheader=autoheader)\n        except IOError:\n            self._errorMessage('Save failed\\n')\n            return False\n\n        return True",
  "def _saveCurves(self, filename, nameFilter):\n        \"\"\"Save all curves from the plot.\n\n        :param str filename: The name of the file to write\n        :param str nameFilter: The selected name filter\n        :return: False if format is not supported or save failed,\n                 True otherwise.\n        \"\"\"\n        if nameFilter not in self.ALL_CURVES_FILTERS:\n            return False\n\n        curves = self.plot.getAllCurves()\n        if not curves:\n            self._errorMessage(\"No curves to be saved\")\n            return False\n\n        curve = curves[0]\n        scanno = 1\n        try:\n            specfile = savespec(filename, curve[0], curve[1],\n                                curve[4]['xlabel'], curve[4]['ylabel'],\n                                fmt=\"%.7g\", scan_number=1, mode=\"w\",\n                                write_file_header=True,\n                                close_file = False)\n        except IOError:\n            self._errorMessage('Save failed\\n')\n            return False\n\n        for curve in curves[1:]:\n            try:\n                scanno += 1\n                specfile = savespec(specfile, curve[0], curve[1],\n                                    curve[4]['xlabel'], curve[4]['ylabel'],\n                                    fmt=\"%.7g\", scan_number=scanno, mode=\"w\",\n                                    write_file_header=False,\n                                    close_file = False)\n            except IOError:\n                self._errorMessage('Save failed\\n')\n                return False\n        specfile.close()\n\n        return True",
  "def _saveImage(self, filename, nameFilter):\n        \"\"\"Save an image from the plot.\n\n        :param str filename: The name of the file to write\n        :param str nameFilter: The selected name filter\n        :return: False if format is not supported or save failed,\n                 True otherwise.\n        \"\"\"\n        if nameFilter not in self.IMAGE_FILTERS:\n            return False\n\n        image = self.plot.getActiveImage()\n        if image is None:\n            qt.QMessageBox.warning(\n                self.plot, \"No Data\", \"No image to be saved\")\n            return False\n\n        data = image[0]\n\n        # TODO Use silx.io for writing files\n        if nameFilter == self.IMAGE_FILTER_EDF:\n            edfFile = EdfFile(filename, access=\"w+\")\n            edfFile.WriteImage({}, data, Append=0)\n\n        elif nameFilter == self.IMAGE_FILTER_TIFF:\n            tiffFile = TiffIO(filename, mode='w')\n            tiffFile.writeImage(data, software='silx')\n\n        elif nameFilter == self.IMAGE_FILTER_NUMPY:\n            try:\n                numpy.save(filename, data)\n            except IOError:\n                self._errorMessage('Save failed\\n')\n                return False\n            return True\n\n        return False",
  "def _actionTriggered(self, checked=False):\n        \"\"\"Handle save action.\"\"\"\n        # Set-up filters\n        filters = []\n\n        # Add image filters if there is an active image\n        if self.plot.getActiveImage() is not None:\n            filters.extend(self.IMAGE_FILTERS)\n\n        # Add curve filters if there is a curve to save\n        if (self.plot.getActiveCurve() is not None or\n                len(self.plot.getAllCurves()) == 1):\n            filters.extend(self.CURVE_FILTERS)\n        if len(self.plot.getAllCurves()) > 1:\n            filters.extend(self.ALL_CURVES_FILTERS)\n\n        filters.extend(self.SNAPSHOT_FILTERS)\n\n        # Create and run File dialog\n        dialog = qt.QFileDialog(self.plot)\n        dialog.setWindowTitle(\"Output File Selection\")\n        dialog.setModal(1)\n        dialog.setNameFilters(filters)\n\n        dialog.setFileMode(dialog.AnyFile)\n        dialog.setAcceptMode(dialog.AcceptSave)\n\n        if not dialog.exec_():\n            return False\n\n        nameFilter = dialog.selectedNameFilter()\n        filename = dialog.selectedFiles()[0]\n        dialog.close()\n\n        # Forces the filename extension to match the chosen filter\n        extension = nameFilter.split()[-1][1:]\n        if (len(filename) <= len(extension) or\n                filename[-len(extension):].lower() != extension.lower()):\n            filename += extension\n\n        # Handle save\n        if nameFilter in self.SNAPSHOT_FILTERS:\n            return self._saveSnapshot(filename, nameFilter)\n        elif nameFilter in self.CURVE_FILTERS:\n            return self._saveCurve(filename, nameFilter)\n        elif nameFilter in self.ALL_CURVES_FILTERS:\n            return self._saveCurves(filename, nameFilter)\n        elif nameFilter in self.IMAGE_FILTERS:\n            return self._saveImage(filename, nameFilter)\n        else:\n            _logger.warning('Unsupported file filter: %s', nameFilter)\n            return False",
  "def __init__(self, plot, parent=None):\n        super(PrintAction, self).__init__(\n            plot, icon='document-print', text='Print...',\n            tooltip='Open Print Dialog',\n            triggered=self.printPlot,\n            checkable=False, parent=parent)\n        self.setShortcut(qt.QKeySequence.Print)",
  "def printPlotAsWidget(self):\n        \"\"\"Open the print dialog and print the plot.\n\n        Use :meth:`QWidget.render` to print the plot\n\n        :return: True if successful\n        \"\"\"\n        printer = qt.QPrinter()\n        dialog = qt.QPrintDialog(printer, self.plot)\n        dialog.setWindowTitle('Print Plot')\n        if not dialog.exec_():\n            return False\n\n        # Print a snapshot of the plot widget at the top of the page\n        widget = self.plot.centralWidget()\n\n        painter = qt.QPainter()\n        if not painter.begin(printer):\n            return False\n\n        pageRect = printer.pageRect()\n        xScale = pageRect.width() / widget.width()\n        yScale = pageRect.height() / widget.height()\n        scale = min(xScale, yScale)\n\n        painter.translate(pageRect.width() / 2., 0.)\n        painter.scale(scale, scale)\n        painter.translate(-widget.width() / 2., 0.)\n        widget.render(painter)\n        painter.end()\n\n        return True",
  "def printPlot(self):\n        \"\"\"Open the print dialog and print the plot.\n\n        Use :meth:`Plot.saveGraph` to print the plot.\n\n        :return: True if successful\n        \"\"\"\n        # Init printer and start printer dialog\n        printer = qt.QPrinter()\n        dialog = qt.QPrintDialog(printer, self.plot)\n        dialog.setWindowTitle('Print Plot')\n        if not dialog.exec_():\n            return False\n\n        # Save Plot as PNG and make a pixmap from it with default dpi\n        pngData = _plotAsPNG(self.plot)\n\n        pixmap = qt.QPixmap()\n        pixmap.loadFromData(pngData, 'png')\n\n        xScale = printer.pageRect().width() / pixmap.width()\n        yScale = printer.pageRect().height() / pixmap.height()\n        scale = min(xScale, yScale)\n\n        # Draw pixmap with painter\n        painter = qt.QPainter()\n        if not painter.begin(printer):\n            return False\n\n        painter.drawPixmap(0, 0,\n                           pixmap.width() * scale,\n                           pixmap.height() * scale,\n                           pixmap)\n        painter.end()\n\n        return True",
  "def __init__(self, plot, parent=None):\n        super(CopyAction, self).__init__(\n            plot, icon='edit-copy', text='Copy plot',\n            tooltip='Copy a snapshot of the plot the clipboard',\n            triggered=self.copyPlot,\n            checkable=False, parent=parent)\n        self.setShortcut(qt.QKeySequence.Copy)",
  "def copyPlot(self):\n        \"\"\"Copy plot content to the clipboard as a bitmap.\"\"\"\n        # Save Plot as PNG and make a QImage from it with default dpi\n        pngData = _plotAsPNG(self.plot)\n        image = qt.QImage.fromData(pngData, 'png')\n        qt.QApplication.clipboard().setImage(image)",
  "def __init__(self, plot, color='black', linewidth=1, linestyle='-',\n                 parent=None):\n        self.color = color\n        \"\"\"Color used to draw the crosshair (str).\"\"\"\n\n        self.linewidth = linewidth\n        \"\"\"Width of the crosshair cursor (int).\"\"\"\n\n        self.linestyle = linestyle\n        \"\"\"Style of line of the cursor (str).\"\"\"\n\n        super(CrosshairAction, self).__init__(\n            plot, icon='crosshair', text='Crosshair Cursor',\n            tooltip='Enable crosshair cursor when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.getGraphCursor() is not None)\n        plot.sigSetGraphCursor.connect(self.setChecked)",
  "def _actionTriggered(self, checked=False):\n        self.plot.setGraphCursor(checked,\n            color=self.color,\n            linestyle=self.linestyle,\n            linewidth=self.linewidth)",
  "def __init__(self, plot, parent=None):\n\n        super(PanWithArrowKeysAction, self).__init__(\n            plot, icon='arrow_keys', text='Pan with arrow keys',\n            tooltip='Enable pan with arrow keys when checked',\n            triggered=self._actionTriggered,\n            checkable=True, parent=parent)\n        self.setChecked(plot.isPanWithArrowKeys())\n        plot.sigSetPanWithArrowKeys.connect(self.setChecked)",
  "def _actionTriggered(self, checked=False):\n        self.plot.setPanWithArrowKeys(checked)",
  "class PlotWidget(qt.QMainWindow, Plot.Plot):\n    \"\"\"Qt Widget providing a 1D/2D plot.\n\n    This widget is a QMainWindow.\n    It provides Qt signals for the Plot and add supports for panning\n    with arrow keys.\n\n    :param parent: The parent of this widget or None.\n    :param backend: The backend to use for the plot.\n                    The default is to use matplotlib.\n    :type backend: str or :class:`BackendBase.BackendBase`\n    :param bool autoreplot: Toggle autoreplot mode (Default: True).\n    \"\"\"\n\n    sigPlotSignal = qt.Signal(object)\n    \"\"\"Signal for all events of the plot.\n\n    The signal information is provided as a dict.\n    See :class:`Plot` for documentation of the content of the dict.\n    \"\"\"\n\n    sigSetYAxisInverted = qt.Signal(bool)\n    \"\"\"Signal emitted when Y axis orientation has changed\"\"\"\n\n    sigSetXAxisLogarithmic = qt.Signal(bool)\n    \"\"\"Signal emitted when X axis scale has changed\"\"\"\n\n    sigSetYAxisLogarithmic = qt.Signal(bool)\n    \"\"\"Signal emitted when Y axis scale has changed\"\"\"\n\n    sigSetXAxisAutoScale = qt.Signal(bool)\n    \"\"\"Signal emitted when X axis autoscale has changed\"\"\"\n\n    sigSetYAxisAutoScale = qt.Signal(bool)\n    \"\"\"Signal emitted when Y axis autoscale has changed\"\"\"\n\n    sigSetKeepDataAspectRatio = qt.Signal(bool)\n    \"\"\"Signal emitted when plot keep aspect ratio has changed\"\"\"\n\n    sigSetGraphGrid = qt.Signal(str)\n    \"\"\"Signal emitted when plot grid has changed\"\"\"\n\n    sigSetGraphCursor = qt.Signal(bool)\n    \"\"\"Signal emitted when plot crosshair cursor has changed\"\"\"\n\n    sigSetPanWithArrowKeys = qt.Signal(bool)\n    \"\"\"Signal emitted when pan with arrow keys has changed\"\"\"\n\n    sigContentChanged = qt.Signal(str, str, str)\n    \"\"\"Signal emitted when the content of the plot is changed.\n\n    It provides 3 informations:\n\n    - action: The change of the plot: 'add' or 'remove'\n    - kind: The kind of primitive changed: 'curve', 'image', 'item' or 'marker'\n    - legend: The legend of the primitive changed.\n    \"\"\"\n\n    sigActiveCurveChanged = qt.Signal(object, object)\n    \"\"\"Signal emitted when the active curve has changed.\n\n    It provides 2 informations:\n\n    - previous: The legend of the previous active curve or None\n    - legend: The legend of the new active curve or None if no curve is active\n    \"\"\"\n\n    def __init__(self, parent=None, backend=None,\n                 legends=False, callback=None, autoreplot=True, **kw):\n\n        if kw:\n            _logger.warning(\n                'deprecated: __init__ extra arguments: %s', str(kw))\n        if legends:\n            _logger.warning('deprecated: __init__ legend argument')\n        if callback:\n            _logger.warning('deprecated: __init__ callback argument')\n\n        self._panWithArrowKeys = False\n\n        qt.QMainWindow.__init__(self, parent)\n        if parent is not None:\n            # behave as a widget\n            self.setWindowFlags(qt.Qt.Widget)\n\n        Plot.Plot.__init__(\n            self, parent, backend=backend, autoreplot=autoreplot)\n\n        widget = self.getWidgetHandle()\n        if widget is not None:\n            self.setCentralWidget(widget)\n        else:\n            _logger.warning(\"Plot backend does not support widget\")\n\n    def notify(self, event, **kwargs):\n        \"\"\"Override :meth:`Plot.notify` to send Qt signals.\"\"\"\n        eventDict = kwargs.copy()\n        eventDict['event'] = event\n        self.sigPlotSignal.emit(eventDict)\n\n        if event == 'setYAxisInverted':\n            self.sigSetYAxisInverted.emit(kwargs['state'])\n        elif event == 'setXAxisLogarithmic':\n            self.sigSetXAxisLogarithmic.emit(kwargs['state'])\n        elif event == 'setYAxisLogarithmic':\n            self.sigSetYAxisLogarithmic.emit(kwargs['state'])\n        elif event == 'setXAxisAutoScale':\n            self.sigSetXAxisAutoScale.emit(kwargs['state'])\n        elif event == 'setYAxisAutoScale':\n            self.sigSetYAxisAutoScale.emit(kwargs['state'])\n        elif event == 'setKeepDataAspectRatio':\n            self.sigSetKeepDataAspectRatio.emit(kwargs['state'])\n        elif event == 'setGraphGrid':\n            self.sigSetGraphGrid.emit(kwargs['which'])\n        elif event == 'setGraphCursor':\n            self.sigSetGraphCursor.emit(kwargs['state'])\n        elif event == 'contentChanged':\n            self.sigContentChanged.emit(\n                kwargs['action'], kwargs['kind'], kwargs['legend'])\n        elif event == 'activeCurveChanged':\n            self.sigActiveCurveChanged.emit(\n                kwargs['previous'], kwargs['legend'])\n        Plot.Plot.notify(self, event, **kwargs)\n\n    # Panning with arrow keys\n\n    def isPanWithArrowKeys(self):\n        \"\"\"Returns whether or not panning the graph with arrow keys is enable.\n\n        See :meth:`setPanWithArrowKeys`.\n        \"\"\"\n        return self._panWithArrowKeys\n\n    def setPanWithArrowKeys(self, pan=False):\n        \"\"\"Enable/Disable panning the graph with arrow keys.\n\n        This grabs the keyboard.\n\n        :param bool pan: True to enable panning, False to disable.\n        \"\"\"\n        pan = bool(pan)\n        panHasChanged = self._panWithArrowKeys != pan\n\n        self._panWithArrowKeys = pan\n        if not self._panWithArrowKeys:\n            self.setFocusPolicy(qt.Qt.NoFocus)\n        else:\n            self.setFocusPolicy(qt.Qt.StrongFocus)\n            self.setFocus(qt.Qt.OtherFocusReason)\n\n        if panHasChanged:\n            self.sigSetPanWithArrowKeys.emit(pan)\n\n    # Dict to convert Qt arrow key code to direction str.\n    _ARROWS_TO_PAN_DIRECTION = {\n        qt.Qt.Key_Left: 'left',\n        qt.Qt.Key_Right: 'right',\n        qt.Qt.Key_Up: 'up',\n        qt.Qt.Key_Down: 'down'\n    }\n\n    def keyPressEvent(self, event):\n        \"\"\"Key event handler handling panning on arrow keys.\n\n        Overrides base class implementation.\n        \"\"\"\n        key = event.key()\n        if self._panWithArrowKeys and key in self._ARROWS_TO_PAN_DIRECTION:\n            self.pan(self._ARROWS_TO_PAN_DIRECTION[key], factor=0.1)\n\n            # Send a mouse move event to the plot widget to take into account\n            # that even if mouse didn't move on the screen, it moved relative\n            # to the plotted data.\n            qapp = qt.QApplication.instance()\n            event = qt.QMouseEvent(\n                qt.QEvent.MouseMove,\n                self.centralWidget().mapFromGlobal(qt.QCursor.pos()),\n                qt.Qt.NoButton,\n                qapp.mouseButtons(),\n                qapp.keyboardModifiers())\n            qapp.sendEvent(self.centralWidget(), event)\n\n        else:\n            # Only call base class implementation when key is not handled.\n            # See QWidget.keyPressEvent for details.\n            super(PlotWidget, self).keyPressEvent(event)",
  "def __init__(self, parent=None, backend=None,\n                 legends=False, callback=None, autoreplot=True, **kw):\n\n        if kw:\n            _logger.warning(\n                'deprecated: __init__ extra arguments: %s', str(kw))\n        if legends:\n            _logger.warning('deprecated: __init__ legend argument')\n        if callback:\n            _logger.warning('deprecated: __init__ callback argument')\n\n        self._panWithArrowKeys = False\n\n        qt.QMainWindow.__init__(self, parent)\n        if parent is not None:\n            # behave as a widget\n            self.setWindowFlags(qt.Qt.Widget)\n\n        Plot.Plot.__init__(\n            self, parent, backend=backend, autoreplot=autoreplot)\n\n        widget = self.getWidgetHandle()\n        if widget is not None:\n            self.setCentralWidget(widget)\n        else:\n            _logger.warning(\"Plot backend does not support widget\")",
  "def notify(self, event, **kwargs):\n        \"\"\"Override :meth:`Plot.notify` to send Qt signals.\"\"\"\n        eventDict = kwargs.copy()\n        eventDict['event'] = event\n        self.sigPlotSignal.emit(eventDict)\n\n        if event == 'setYAxisInverted':\n            self.sigSetYAxisInverted.emit(kwargs['state'])\n        elif event == 'setXAxisLogarithmic':\n            self.sigSetXAxisLogarithmic.emit(kwargs['state'])\n        elif event == 'setYAxisLogarithmic':\n            self.sigSetYAxisLogarithmic.emit(kwargs['state'])\n        elif event == 'setXAxisAutoScale':\n            self.sigSetXAxisAutoScale.emit(kwargs['state'])\n        elif event == 'setYAxisAutoScale':\n            self.sigSetYAxisAutoScale.emit(kwargs['state'])\n        elif event == 'setKeepDataAspectRatio':\n            self.sigSetKeepDataAspectRatio.emit(kwargs['state'])\n        elif event == 'setGraphGrid':\n            self.sigSetGraphGrid.emit(kwargs['which'])\n        elif event == 'setGraphCursor':\n            self.sigSetGraphCursor.emit(kwargs['state'])\n        elif event == 'contentChanged':\n            self.sigContentChanged.emit(\n                kwargs['action'], kwargs['kind'], kwargs['legend'])\n        elif event == 'activeCurveChanged':\n            self.sigActiveCurveChanged.emit(\n                kwargs['previous'], kwargs['legend'])\n        Plot.Plot.notify(self, event, **kwargs)",
  "def isPanWithArrowKeys(self):\n        \"\"\"Returns whether or not panning the graph with arrow keys is enable.\n\n        See :meth:`setPanWithArrowKeys`.\n        \"\"\"\n        return self._panWithArrowKeys",
  "def setPanWithArrowKeys(self, pan=False):\n        \"\"\"Enable/Disable panning the graph with arrow keys.\n\n        This grabs the keyboard.\n\n        :param bool pan: True to enable panning, False to disable.\n        \"\"\"\n        pan = bool(pan)\n        panHasChanged = self._panWithArrowKeys != pan\n\n        self._panWithArrowKeys = pan\n        if not self._panWithArrowKeys:\n            self.setFocusPolicy(qt.Qt.NoFocus)\n        else:\n            self.setFocusPolicy(qt.Qt.StrongFocus)\n            self.setFocus(qt.Qt.OtherFocusReason)\n\n        if panHasChanged:\n            self.sigSetPanWithArrowKeys.emit(pan)",
  "def keyPressEvent(self, event):\n        \"\"\"Key event handler handling panning on arrow keys.\n\n        Overrides base class implementation.\n        \"\"\"\n        key = event.key()\n        if self._panWithArrowKeys and key in self._ARROWS_TO_PAN_DIRECTION:\n            self.pan(self._ARROWS_TO_PAN_DIRECTION[key], factor=0.1)\n\n            # Send a mouse move event to the plot widget to take into account\n            # that even if mouse didn't move on the screen, it moved relative\n            # to the plotted data.\n            qapp = qt.QApplication.instance()\n            event = qt.QMouseEvent(\n                qt.QEvent.MouseMove,\n                self.centralWidget().mapFromGlobal(qt.QCursor.pos()),\n                qt.Qt.NoButton,\n                qapp.mouseButtons(),\n                qapp.keyboardModifiers())\n            qapp.sendEvent(self.centralWidget(), event)\n\n        else:\n            # Only call base class implementation when key is not handled.\n            # See QWidget.keyPressEvent for details.\n            super(PlotWidget, self).keyPressEvent(event)",
  "def addMarginsToLimits(margins, isXLog, isYLog,\n                       xMin, xMax, yMin, yMax, y2Min=None, y2Max=None):\n    \"\"\"Returns updated limits by extending them with margins.\n\n    :param margins: The ratio of the margins to add or None for no margins.\n    :type margins: A 4-tuple of floats as\n                   (xMinMargin, xMaxMargin, yMinMargin, yMaxMargin)\n\n    :return: The updated limits\n    :rtype: tuple of 4 or 6 floats: Either (xMin, xMax, yMin, yMax) or\n            (xMin, xMax, yMin, yMax, y2Min, y2Max) if y2Min and y2Max\n            are provided.\n    \"\"\"\n    if margins is not None:\n        xMinMargin, xMaxMargin, yMinMargin, yMaxMargin = margins\n\n        if not isXLog:\n            xRange = xMax - xMin\n            xMin -= xMinMargin * xRange\n            xMax += xMaxMargin * xRange\n\n        elif xMin > 0. and xMax > 0.:  # Log scale\n            # Do not apply margins if limits < 0\n            xMinLog, xMaxLog = numpy.log10(xMin), numpy.log10(xMax)\n            xRangeLog = xMaxLog - xMinLog\n            xMin = pow(10., xMinLog - xMinMargin * xRangeLog)\n            xMax = pow(10., xMaxLog + xMaxMargin * xRangeLog)\n\n        if not isYLog:\n            yRange = yMax - yMin\n            yMin -= yMinMargin * yRange\n            yMax += yMaxMargin * yRange\n        elif yMin > 0. and yMax > 0.:  # Log scale\n            # Do not apply margins if limits < 0\n            yMinLog, yMaxLog = numpy.log10(yMin), numpy.log10(yMax)\n            yRangeLog = yMaxLog - yMinLog\n            yMin = pow(10., yMinLog - yMinMargin * yRangeLog)\n            yMax = pow(10., yMaxLog + yMaxMargin * yRangeLog)\n\n        if y2Min is not None and y2Max is not None:\n            if not isYLog:\n                yRange = y2Max - y2Min\n                y2Min -= yMinMargin * yRange\n                y2Max += yMaxMargin * yRange\n            elif y2Min > 0. and y2Max > 0.:  # Log scale\n                # Do not apply margins if limits < 0\n                yMinLog, yMaxLog = numpy.log10(y2Min), numpy.log10(y2Max)\n                yRangeLog = yMaxLog - yMinLog\n                y2Min = pow(10., yMinLog - yMinMargin * yRangeLog)\n                y2Max = pow(10., yMaxLog + yMaxMargin * yRangeLog)\n\n    if y2Min is None or y2Max is None:\n        return xMin, xMax, yMin, yMax\n    else:\n        return xMin, xMax, yMin, yMax, y2Min, y2Max",
  "def applyPan(min_, max_, panFactor, isLog10):\n    \"\"\"Returns a new range with applied panning.\n\n    Moves the range according to panFactor.\n    If isLog10 is True, converts to log10 before moving.\n\n    :param float min_: Min value of the data range to pan.\n    :param float max_: Max value of the data range to pan.\n                       Must be >= min_.\n    :param float panFactor: Signed proportion of the range to use for pan.\n    :param bool isLog10: True if log10 scale, False if linear scale.\n    :return: New min and max value with pan applied.\n    :rtype: 2-tuple of float.\n    \"\"\"\n    if isLog10 and min_ > 0.:\n        # Negative range and log scale can happen with matplotlib\n        logMin, logMax = math.log10(min_), math.log10(max_)\n        logOffset = panFactor * (logMax - logMin)\n        newMin = pow(10., logMin + logOffset)\n        newMax = pow(10., logMax + logOffset)\n\n        # Takes care of out-of-range values\n        if newMin > 0. and newMax < float('inf'):\n            min_, max_ = newMin, newMax\n\n    else:\n        offset = panFactor * (max_ - min_)\n        newMin, newMax = min_ + offset, max_ + offset\n\n        # Takes care of out-of-range values\n        if newMin > - float('inf') and newMax < float('inf'):\n            min_, max_ = newMin, newMax\n    return min_, max_",
  "def clamp(value, min_=0., max_=1.):\n    \"\"\"Clip a value to a range [min, max].\n\n    :param value: The value to clip\n    :param min_: The min_ edge of the range\n    :param max_: The max_ edge of the range\n    :return: The clipped value\n    \"\"\"\n    if value < min_:\n        return min_\n    elif value > max_:\n        return max_\n    else:\n        return value",
  "class _FloatEdit(qt.QLineEdit):\n    \"\"\"Field to edit a float value.\n\n    :param float value: The value to set the QLineEdit to.\n    :param parent: See :class:`QLineEdit`\n    \"\"\"\n    def __init__(self, value=None, parent=None):\n        qt.QLineEdit.__init__(self, parent)\n        self.setValidator(qt.QDoubleValidator())\n        self.setAlignment(qt.Qt.AlignRight)\n        if value is not None:\n            self.setValue(value)\n\n    def value(self):\n        \"\"\"Return the QLineEdit current value as a float.\"\"\"\n        return float(self.text())\n\n    def setValue(self, value):\n        \"\"\"Set the current value of the LineEdit\n\n        :param float value: The value to set the QLineEdit to.\n        \"\"\"\n        self.setText('%g' % value)",
  "class ColormapDialog(qt.QDialog):\n    \"\"\"A QDialog widget to set the colormap.\n\n    :param str title: The QDialog title\n    :param parent: See :class:`QDialog`\n    \"\"\"\n\n    sigColormapChanged = qt.Signal(dict)\n    \"\"\"Signal triggered when the colormap is changed.\n\n    It provides a dict describing the colormap to the slot.\n    This dict can be used with :class:`Plot`.\n    \"\"\"\n\n    def __init__(self, title=\"Colormap Dialog\", parent=None):\n        qt.QDialog.__init__(self, parent)\n        self.setWindowTitle(title)\n\n        self._histogramData = None\n        self._dataRange = None\n        self._minMaxWasEdited = False\n\n        self._colormapList = ('gray', 'reversed gray', 'temperature',\n                              'red', 'green', 'blue')\n\n        # Make the GUI\n        vLayout = qt.QVBoxLayout(self)\n\n        formWidget = qt.QWidget()\n        vLayout.addWidget(formWidget)\n        formLayout = qt.QFormLayout(formWidget)\n        formLayout.setContentsMargins(10, 10, 10, 10)\n        formLayout.setSpacing(0)\n\n        # Colormap row\n        self._comboBoxColormap = qt.QComboBox()\n        for cmap in self._colormapList:\n            # Capitalize first letters\n            cmap = ' '.join(w[0].upper() + w[1:] for w in cmap.split())\n            self._comboBoxColormap.addItem(cmap)\n        self._comboBoxColormap.activated[int].connect(self._notify)\n        formLayout.addRow('Colormap:', self._comboBoxColormap)\n\n        # Normalization row\n        self._normButtonLinear = qt.QRadioButton('Linear')\n        self._normButtonLinear.setChecked(True)\n        self._normButtonLog = qt.QRadioButton('Log')\n\n        normButtonGroup = qt.QButtonGroup(self)\n        normButtonGroup.setExclusive(True)\n        normButtonGroup.addButton(self._normButtonLinear)\n        normButtonGroup.addButton(self._normButtonLog)\n        normButtonGroup.buttonClicked[int].connect(self._notify)\n\n        normLayout = qt.QHBoxLayout()\n        normLayout.setContentsMargins(0, 0, 0, 0)\n        normLayout.setSpacing(10)\n        normLayout.addWidget(self._normButtonLinear)\n        normLayout.addWidget(self._normButtonLog)\n\n        formLayout.addRow('Normalization:', normLayout)\n\n        # Range row\n        self._rangeAutoscaleButton = qt.QCheckBox('Autoscale')\n        self._rangeAutoscaleButton.setChecked(True)\n        self._rangeAutoscaleButton.toggled.connect(self._autoscaleToggled)\n        self._rangeAutoscaleButton.clicked.connect(self._notify)\n        formLayout.addRow('Range:', self._rangeAutoscaleButton)\n\n        # Min row\n        self._minValue = _FloatEdit(1.)\n        self._minValue.setEnabled(False)\n        self._minValue.textEdited.connect(self._minMaxTextEdited)\n        self._minValue.editingFinished.connect(self._minEditingFinished)\n        formLayout.addRow('\\tMin:', self._minValue)\n\n        # Max row\n        self._maxValue = _FloatEdit(10.)\n        self._maxValue.setEnabled(False)\n        self._maxValue.textEdited.connect(self._minMaxTextEdited)\n        self._maxValue.editingFinished.connect(self._maxEditingFinished)\n        formLayout.addRow('\\tMax:', self._maxValue)\n\n        # Add plot for histogram\n        self._plotInit()\n        vLayout.addWidget(self._plot)\n\n        # Close button\n        buttonsWidget = qt.QWidget()\n        vLayout.addWidget(buttonsWidget)\n\n        buttonsLayout = qt.QHBoxLayout(buttonsWidget)\n\n        okButton = qt.QPushButton('OK')\n        okButton.clicked.connect(self.accept)\n        buttonsLayout.addWidget(okButton)\n\n        cancelButton = qt.QPushButton('Cancel')\n        cancelButton.clicked.connect(self.reject)\n        buttonsLayout.addWidget(cancelButton)\n\n        # colormap window can not be resized\n        self.setFixedSize(vLayout.minimumSize())\n\n        # Set the colormap to default values\n        self.setColormap(name='gray', normalization='linear',\n                         autoscale=True, vmin=1., vmax=10.)\n\n    def _plotInit(self):\n        \"\"\"Init the plot to display the range and the values\"\"\"\n        self._plot = PlotWidget()\n        self._plot.setDataMargins(yMinMargin=0.125, yMaxMargin=0.125)\n        self._plot.setGraphXLabel(\"Data Values\")\n        self._plot.setGraphYLabel(\"\")\n        self._plot.setInteractiveMode('select', zoomOnWheel=False)\n        self._plot.setActiveCurveHandling(False)\n        self._plot.setMinimumSize(qt.QSize(250, 200))\n        self._plot.sigPlotSignal.connect(self._plotSlot)\n        self._plot.hide()\n\n        self._plotUpdate()\n\n    def _plotUpdate(self, updateMarkers=True):\n        \"\"\"Update the plot content\n\n        :param bool updateMarkers: True to update markers, False otherwith\n        \"\"\"\n        dataRange = self.getDataRange()\n\n        if dataRange is None:\n            if self._plot.isVisibleTo(self):\n                self._plot.setVisible(False)\n                self.setFixedSize(self.layout().minimumSize())\n            return\n\n        if not self._plot.isVisibleTo(self):\n            self._plot.setVisible(True)\n            self.setFixedSize(self.layout().minimumSize())\n\n        dataMin, dataMax = dataRange\n        marge = (abs(dataMax) + abs(dataMin)) / 6.0\n        minmd = dataMin - marge\n        maxpd = dataMax + marge\n\n        start, end = self._minValue.value(), self._maxValue.value()\n\n        if start <= end:\n            x = [minmd, start, end, maxpd]\n            y = [0, 0, 1, 1]\n\n        else:\n            x = [minmd, end, start, maxpd]\n            y = [1, 1, 0, 0]\n\n        # Display the colormap on the side\n        # colormap = {'name': self.getColormap()['name'],\n        #             'normalization': self.getColormap()['normalization'],\n        #             'autoscale': True, 'vmin': 1., 'vmax': 256.}\n        # self._plot.addImage((1 + numpy.arange(256)).reshape(256, -1),\n        #                     xScale=(minmd - marge, marge),\n        #                     yScale=(1., 2./256.),\n        #                     legend='colormap',\n        #                     colormap=colormap)\n\n        self._plot.addCurve(x, y,\n                            legend=\"ConstrainedCurve\",\n                            color='black',\n                            symbol='o',\n                            linestyle='-',\n                            resetzoom=False)\n\n        draggable = not self._rangeAutoscaleButton.isChecked()\n\n        if updateMarkers:\n            self._plot.addXMarker(\n                self._minValue.value(),\n                legend='Min',\n                text='Min',\n                draggable=draggable,\n                color='blue',\n                constraint=self._plotMinMarkerConstraint)\n\n            self._plot.addXMarker(\n                self._maxValue.value(),\n                legend='Max',\n                text='Max',\n                draggable=draggable,\n                color='blue',\n                constraint=self._plotMaxMarkerConstraint)\n\n        self._plot.resetZoom()\n\n    def _plotMinMarkerConstraint(self, x, y):\n        \"\"\"Constraint of the min marker\"\"\"\n        return min(x, self._maxValue.value()), y\n\n    def _plotMaxMarkerConstraint(self, x, y):\n        \"\"\"Constraint of the max marker\"\"\"\n        return max(x, self._minValue.value()), y\n\n    def _plotSlot(self, event):\n        \"\"\"Handle events from the plot\"\"\"\n        if event['event'] in ('markerMoving', 'markerMoved'):\n            value = float(str(event['xdata']))\n            if event['label'] == 'Min':\n                self._minValue.setValue(value)\n            elif event['label'] == 'Max':\n                self._maxValue.setValue(value)\n\n            # This will recreate the markers while interacting...\n            # It might break if marker interaction is changed\n            if event['event'] == 'markerMoved':\n                self._notify()\n            else:\n                self._plotUpdate(updateMarkers=False)\n\n    def getHistogram(self):\n        \"\"\"Returns the counts and bin edges of the displayed histogram.\n\n        :return: (hist, bin_edges)\n        :rtype: 2-tuple of numpy arrays\"\"\"\n        if self._histogramData is None:\n            return None\n        else:\n            bins, counts = self._histogramData\n            return numpy.array(bins, copy=True), numpy.array(counts, copy=True)\n\n    def setHistogram(self, hist=None, bin_edges=None):\n        \"\"\"Set the histogram to display.\n\n        This update the data range with the bounds of the bins.\n        See :meth:`setDataRange`.\n\n        :param hist: array-like of counts or None to hide histogram\n        :param bin_edges: array-like of bins edges or None to hide histogram\n        \"\"\"\n        if hist is None or bin_edges is None:\n            self._histogramData = None\n            self._plot.remove(legend='Histogram', kind='curve')\n            self.setDataRange()  # Remove data range\n\n        else:\n            hist = numpy.array(hist, copy=True)\n            bin_edges = numpy.array(bin_edges, copy=True)\n            self._histogramData = hist, bin_edges\n\n            # For now, draw the histogram as a curve\n            # using bin centers and normalised counts\n            bins_center = 0.5 * (bin_edges[:-1] + bin_edges[1:])\n            norm_hist = hist / max(hist)\n            self._plot.addCurve(bins_center, norm_hist,\n                                legend=\"Histogram\",\n                                color='gray',\n                                symbol='',\n                                linestyle='-',\n                                fill=True)\n\n            # Update the data range\n            self.setDataRange(bin_edges[0], bin_edges[-1])\n\n    def getDataRange(self):\n        \"\"\"Returns the data range used for the histogram area.\n\n        :return: (dataMin, dataMax) or None if no data range is set\n        :rtype: 2-tuple of float\n        \"\"\"\n        return self._dataRange\n\n    def setDataRange(self, min_=None, max_=None):\n        \"\"\"Set the range of data to use for the range of the histogram area.\n\n        :param float min_: The min of the data or None to disable range.\n        :param float max_: The max of the data or None to disable range.\n        \"\"\"\n        if min_ is None or max_ is None:\n            self._dataRange = None\n            self._plotUpdate()\n\n        else:\n            min_, max_ = float(min_), float(max_)\n            assert min_ <= max_\n            self._dataRange = min_, max_\n            if self._rangeAutoscaleButton.isChecked():\n                self._minValue.setValue(min_)\n                self._maxValue.setValue(max_)\n                self._notify()\n            else:\n                self._plotUpdate()\n\n    def getColormap(self):\n        \"\"\"Return the colormap description as a dict.\n\n        See :class:`Plot` for documentation on the colormap dict.\n        \"\"\"\n        isNormLinear = self._normButtonLinear.isChecked()\n        colormap = {\n            'name': str(self._comboBoxColormap.currentText()).lower(),\n            'normalization': 'linear' if isNormLinear else 'log',\n            'autoscale': self._rangeAutoscaleButton.isChecked(),\n            'vmin': self._minValue.value(),\n            'vmax': self._maxValue.value(),\n            'colors': 256}\n        return colormap\n\n    def setColormap(self, name=None, normalization=None,\n                    autoscale=None, vmin=None, vmax=None, colors=None):\n        \"\"\"Set the colormap description\n\n        If some arguments are not provided, the current values are used.\n\n        :param str name: The name of the colormap\n        :param str normalization: 'linear' or 'log'\n        :param bool autoscale: Toggle colormap range autoscale\n        :param float vmin: The min value, ignored if autoscale is True\n        :param float vmax: The max value, ignored if autoscale is True\n        \"\"\"\n        if name is not None:\n            assert name in self._colormapList\n            index = self._colormapList.index(name)\n            self._comboBoxColormap.setCurrentIndex(index)\n\n        if normalization is not None:\n            assert normalization in ('linear', 'log')\n            self._normButtonLinear.setChecked(normalization == 'linear')\n            self._normButtonLog.setChecked(normalization == 'log')\n\n        if autoscale is not None:\n            self._rangeAutoscaleButton.setChecked(autoscale)\n\n        if vmin is not None:\n            self._minValue.setValue(vmin)\n\n        if vmax is not None:\n            self._maxValue.setValue(vmax)\n\n        # Do it once for all the changes\n        self._notify()\n\n    def _notify(self, *args, **kwargs):\n        \"\"\"Emit the signal for colormap change\"\"\"\n        self._plotUpdate()\n        self.sigColormapChanged.emit(self.getColormap())\n\n    def _autoscaleToggled(self, checked):\n        \"\"\"Handle autoscale changes by enabling/disabling min/max fields\"\"\"\n        self._minValue.setEnabled(not checked)\n        self._maxValue.setEnabled(not checked)\n        if checked:\n            dataRange = self.getDataRange()\n            if dataRange is not None:\n                self._minValue.setValue(dataRange[0])\n                self._maxValue.setValue(dataRange[1])\n\n    def _minMaxTextEdited(self, text):\n        \"\"\"Handle _minValue and _maxValue textEdited signal\"\"\"\n        self._minMaxWasEdited = True\n\n    def _minEditingFinished(self):\n        \"\"\"Handle _minValue editingFinished signal\n\n        Together with :meth:`_minMaxTextEdited`, this avoids to notify\n        colormap change when the min and max value where not edited.\n        \"\"\"\n        if self._minMaxWasEdited:\n            self._minMaxWasEdited = False\n\n            # Fix start value\n            if self._minValue.value() > self._maxValue.value():\n                self._minValue.setValue(self._maxValue.value())\n            self._notify()\n\n    def _maxEditingFinished(self):\n        \"\"\"Handle _maxValue editingFinished signal\n\n        Together with :meth:`_minMaxTextEdited`, this avoids to notify\n        colormap change when the min and max value where not edited.\n        \"\"\"\n        if self._minMaxWasEdited:\n            self._minMaxWasEdited = False\n\n            # Fix end value\n            if self._minValue.value() > self._maxValue.value():\n                self._maxValue.setValue(self._minValue.value())\n            self._notify()\n\n    def keyPressEvent(self, event):\n        \"\"\"Override key handling.\n\n        It disables leaving the dialog when editing a text field.\n        \"\"\"\n        if event.key() == qt.Qt.Key_Enter and (self._minValue.hasFocus() or\n            self._maxValue.hasFocus()):\n            # Bypass QDialog keyPressEvent\n            # To avoid leaving the dialog when pressing enter on a text field\n            super(qt.QDialog, self).keyPressEvent(event)\n        else:\n            # Use QDialog keyPressEvent\n            super(ColormapDialog, self).keyPressEvent(event)",
  "def __init__(self, value=None, parent=None):\n        qt.QLineEdit.__init__(self, parent)\n        self.setValidator(qt.QDoubleValidator())\n        self.setAlignment(qt.Qt.AlignRight)\n        if value is not None:\n            self.setValue(value)",
  "def value(self):\n        \"\"\"Return the QLineEdit current value as a float.\"\"\"\n        return float(self.text())",
  "def setValue(self, value):\n        \"\"\"Set the current value of the LineEdit\n\n        :param float value: The value to set the QLineEdit to.\n        \"\"\"\n        self.setText('%g' % value)",
  "def __init__(self, title=\"Colormap Dialog\", parent=None):\n        qt.QDialog.__init__(self, parent)\n        self.setWindowTitle(title)\n\n        self._histogramData = None\n        self._dataRange = None\n        self._minMaxWasEdited = False\n\n        self._colormapList = ('gray', 'reversed gray', 'temperature',\n                              'red', 'green', 'blue')\n\n        # Make the GUI\n        vLayout = qt.QVBoxLayout(self)\n\n        formWidget = qt.QWidget()\n        vLayout.addWidget(formWidget)\n        formLayout = qt.QFormLayout(formWidget)\n        formLayout.setContentsMargins(10, 10, 10, 10)\n        formLayout.setSpacing(0)\n\n        # Colormap row\n        self._comboBoxColormap = qt.QComboBox()\n        for cmap in self._colormapList:\n            # Capitalize first letters\n            cmap = ' '.join(w[0].upper() + w[1:] for w in cmap.split())\n            self._comboBoxColormap.addItem(cmap)\n        self._comboBoxColormap.activated[int].connect(self._notify)\n        formLayout.addRow('Colormap:', self._comboBoxColormap)\n\n        # Normalization row\n        self._normButtonLinear = qt.QRadioButton('Linear')\n        self._normButtonLinear.setChecked(True)\n        self._normButtonLog = qt.QRadioButton('Log')\n\n        normButtonGroup = qt.QButtonGroup(self)\n        normButtonGroup.setExclusive(True)\n        normButtonGroup.addButton(self._normButtonLinear)\n        normButtonGroup.addButton(self._normButtonLog)\n        normButtonGroup.buttonClicked[int].connect(self._notify)\n\n        normLayout = qt.QHBoxLayout()\n        normLayout.setContentsMargins(0, 0, 0, 0)\n        normLayout.setSpacing(10)\n        normLayout.addWidget(self._normButtonLinear)\n        normLayout.addWidget(self._normButtonLog)\n\n        formLayout.addRow('Normalization:', normLayout)\n\n        # Range row\n        self._rangeAutoscaleButton = qt.QCheckBox('Autoscale')\n        self._rangeAutoscaleButton.setChecked(True)\n        self._rangeAutoscaleButton.toggled.connect(self._autoscaleToggled)\n        self._rangeAutoscaleButton.clicked.connect(self._notify)\n        formLayout.addRow('Range:', self._rangeAutoscaleButton)\n\n        # Min row\n        self._minValue = _FloatEdit(1.)\n        self._minValue.setEnabled(False)\n        self._minValue.textEdited.connect(self._minMaxTextEdited)\n        self._minValue.editingFinished.connect(self._minEditingFinished)\n        formLayout.addRow('\\tMin:', self._minValue)\n\n        # Max row\n        self._maxValue = _FloatEdit(10.)\n        self._maxValue.setEnabled(False)\n        self._maxValue.textEdited.connect(self._minMaxTextEdited)\n        self._maxValue.editingFinished.connect(self._maxEditingFinished)\n        formLayout.addRow('\\tMax:', self._maxValue)\n\n        # Add plot for histogram\n        self._plotInit()\n        vLayout.addWidget(self._plot)\n\n        # Close button\n        buttonsWidget = qt.QWidget()\n        vLayout.addWidget(buttonsWidget)\n\n        buttonsLayout = qt.QHBoxLayout(buttonsWidget)\n\n        okButton = qt.QPushButton('OK')\n        okButton.clicked.connect(self.accept)\n        buttonsLayout.addWidget(okButton)\n\n        cancelButton = qt.QPushButton('Cancel')\n        cancelButton.clicked.connect(self.reject)\n        buttonsLayout.addWidget(cancelButton)\n\n        # colormap window can not be resized\n        self.setFixedSize(vLayout.minimumSize())\n\n        # Set the colormap to default values\n        self.setColormap(name='gray', normalization='linear',\n                         autoscale=True, vmin=1., vmax=10.)",
  "def _plotInit(self):\n        \"\"\"Init the plot to display the range and the values\"\"\"\n        self._plot = PlotWidget()\n        self._plot.setDataMargins(yMinMargin=0.125, yMaxMargin=0.125)\n        self._plot.setGraphXLabel(\"Data Values\")\n        self._plot.setGraphYLabel(\"\")\n        self._plot.setInteractiveMode('select', zoomOnWheel=False)\n        self._plot.setActiveCurveHandling(False)\n        self._plot.setMinimumSize(qt.QSize(250, 200))\n        self._plot.sigPlotSignal.connect(self._plotSlot)\n        self._plot.hide()\n\n        self._plotUpdate()",
  "def _plotUpdate(self, updateMarkers=True):\n        \"\"\"Update the plot content\n\n        :param bool updateMarkers: True to update markers, False otherwith\n        \"\"\"\n        dataRange = self.getDataRange()\n\n        if dataRange is None:\n            if self._plot.isVisibleTo(self):\n                self._plot.setVisible(False)\n                self.setFixedSize(self.layout().minimumSize())\n            return\n\n        if not self._plot.isVisibleTo(self):\n            self._plot.setVisible(True)\n            self.setFixedSize(self.layout().minimumSize())\n\n        dataMin, dataMax = dataRange\n        marge = (abs(dataMax) + abs(dataMin)) / 6.0\n        minmd = dataMin - marge\n        maxpd = dataMax + marge\n\n        start, end = self._minValue.value(), self._maxValue.value()\n\n        if start <= end:\n            x = [minmd, start, end, maxpd]\n            y = [0, 0, 1, 1]\n\n        else:\n            x = [minmd, end, start, maxpd]\n            y = [1, 1, 0, 0]\n\n        # Display the colormap on the side\n        # colormap = {'name': self.getColormap()['name'],\n        #             'normalization': self.getColormap()['normalization'],\n        #             'autoscale': True, 'vmin': 1., 'vmax': 256.}\n        # self._plot.addImage((1 + numpy.arange(256)).reshape(256, -1),\n        #                     xScale=(minmd - marge, marge),\n        #                     yScale=(1., 2./256.),\n        #                     legend='colormap',\n        #                     colormap=colormap)\n\n        self._plot.addCurve(x, y,\n                            legend=\"ConstrainedCurve\",\n                            color='black',\n                            symbol='o',\n                            linestyle='-',\n                            resetzoom=False)\n\n        draggable = not self._rangeAutoscaleButton.isChecked()\n\n        if updateMarkers:\n            self._plot.addXMarker(\n                self._minValue.value(),\n                legend='Min',\n                text='Min',\n                draggable=draggable,\n                color='blue',\n                constraint=self._plotMinMarkerConstraint)\n\n            self._plot.addXMarker(\n                self._maxValue.value(),\n                legend='Max',\n                text='Max',\n                draggable=draggable,\n                color='blue',\n                constraint=self._plotMaxMarkerConstraint)\n\n        self._plot.resetZoom()",
  "def _plotMinMarkerConstraint(self, x, y):\n        \"\"\"Constraint of the min marker\"\"\"\n        return min(x, self._maxValue.value()), y",
  "def _plotMaxMarkerConstraint(self, x, y):\n        \"\"\"Constraint of the max marker\"\"\"\n        return max(x, self._minValue.value()), y",
  "def _plotSlot(self, event):\n        \"\"\"Handle events from the plot\"\"\"\n        if event['event'] in ('markerMoving', 'markerMoved'):\n            value = float(str(event['xdata']))\n            if event['label'] == 'Min':\n                self._minValue.setValue(value)\n            elif event['label'] == 'Max':\n                self._maxValue.setValue(value)\n\n            # This will recreate the markers while interacting...\n            # It might break if marker interaction is changed\n            if event['event'] == 'markerMoved':\n                self._notify()\n            else:\n                self._plotUpdate(updateMarkers=False)",
  "def getHistogram(self):\n        \"\"\"Returns the counts and bin edges of the displayed histogram.\n\n        :return: (hist, bin_edges)\n        :rtype: 2-tuple of numpy arrays\"\"\"\n        if self._histogramData is None:\n            return None\n        else:\n            bins, counts = self._histogramData\n            return numpy.array(bins, copy=True), numpy.array(counts, copy=True)",
  "def setHistogram(self, hist=None, bin_edges=None):\n        \"\"\"Set the histogram to display.\n\n        This update the data range with the bounds of the bins.\n        See :meth:`setDataRange`.\n\n        :param hist: array-like of counts or None to hide histogram\n        :param bin_edges: array-like of bins edges or None to hide histogram\n        \"\"\"\n        if hist is None or bin_edges is None:\n            self._histogramData = None\n            self._plot.remove(legend='Histogram', kind='curve')\n            self.setDataRange()  # Remove data range\n\n        else:\n            hist = numpy.array(hist, copy=True)\n            bin_edges = numpy.array(bin_edges, copy=True)\n            self._histogramData = hist, bin_edges\n\n            # For now, draw the histogram as a curve\n            # using bin centers and normalised counts\n            bins_center = 0.5 * (bin_edges[:-1] + bin_edges[1:])\n            norm_hist = hist / max(hist)\n            self._plot.addCurve(bins_center, norm_hist,\n                                legend=\"Histogram\",\n                                color='gray',\n                                symbol='',\n                                linestyle='-',\n                                fill=True)\n\n            # Update the data range\n            self.setDataRange(bin_edges[0], bin_edges[-1])",
  "def getDataRange(self):\n        \"\"\"Returns the data range used for the histogram area.\n\n        :return: (dataMin, dataMax) or None if no data range is set\n        :rtype: 2-tuple of float\n        \"\"\"\n        return self._dataRange",
  "def setDataRange(self, min_=None, max_=None):\n        \"\"\"Set the range of data to use for the range of the histogram area.\n\n        :param float min_: The min of the data or None to disable range.\n        :param float max_: The max of the data or None to disable range.\n        \"\"\"\n        if min_ is None or max_ is None:\n            self._dataRange = None\n            self._plotUpdate()\n\n        else:\n            min_, max_ = float(min_), float(max_)\n            assert min_ <= max_\n            self._dataRange = min_, max_\n            if self._rangeAutoscaleButton.isChecked():\n                self._minValue.setValue(min_)\n                self._maxValue.setValue(max_)\n                self._notify()\n            else:\n                self._plotUpdate()",
  "def getColormap(self):\n        \"\"\"Return the colormap description as a dict.\n\n        See :class:`Plot` for documentation on the colormap dict.\n        \"\"\"\n        isNormLinear = self._normButtonLinear.isChecked()\n        colormap = {\n            'name': str(self._comboBoxColormap.currentText()).lower(),\n            'normalization': 'linear' if isNormLinear else 'log',\n            'autoscale': self._rangeAutoscaleButton.isChecked(),\n            'vmin': self._minValue.value(),\n            'vmax': self._maxValue.value(),\n            'colors': 256}\n        return colormap",
  "def setColormap(self, name=None, normalization=None,\n                    autoscale=None, vmin=None, vmax=None, colors=None):\n        \"\"\"Set the colormap description\n\n        If some arguments are not provided, the current values are used.\n\n        :param str name: The name of the colormap\n        :param str normalization: 'linear' or 'log'\n        :param bool autoscale: Toggle colormap range autoscale\n        :param float vmin: The min value, ignored if autoscale is True\n        :param float vmax: The max value, ignored if autoscale is True\n        \"\"\"\n        if name is not None:\n            assert name in self._colormapList\n            index = self._colormapList.index(name)\n            self._comboBoxColormap.setCurrentIndex(index)\n\n        if normalization is not None:\n            assert normalization in ('linear', 'log')\n            self._normButtonLinear.setChecked(normalization == 'linear')\n            self._normButtonLog.setChecked(normalization == 'log')\n\n        if autoscale is not None:\n            self._rangeAutoscaleButton.setChecked(autoscale)\n\n        if vmin is not None:\n            self._minValue.setValue(vmin)\n\n        if vmax is not None:\n            self._maxValue.setValue(vmax)\n\n        # Do it once for all the changes\n        self._notify()",
  "def _notify(self, *args, **kwargs):\n        \"\"\"Emit the signal for colormap change\"\"\"\n        self._plotUpdate()\n        self.sigColormapChanged.emit(self.getColormap())",
  "def _autoscaleToggled(self, checked):\n        \"\"\"Handle autoscale changes by enabling/disabling min/max fields\"\"\"\n        self._minValue.setEnabled(not checked)\n        self._maxValue.setEnabled(not checked)\n        if checked:\n            dataRange = self.getDataRange()\n            if dataRange is not None:\n                self._minValue.setValue(dataRange[0])\n                self._maxValue.setValue(dataRange[1])",
  "def _minMaxTextEdited(self, text):\n        \"\"\"Handle _minValue and _maxValue textEdited signal\"\"\"\n        self._minMaxWasEdited = True",
  "def _minEditingFinished(self):\n        \"\"\"Handle _minValue editingFinished signal\n\n        Together with :meth:`_minMaxTextEdited`, this avoids to notify\n        colormap change when the min and max value where not edited.\n        \"\"\"\n        if self._minMaxWasEdited:\n            self._minMaxWasEdited = False\n\n            # Fix start value\n            if self._minValue.value() > self._maxValue.value():\n                self._minValue.setValue(self._maxValue.value())\n            self._notify()",
  "def _maxEditingFinished(self):\n        \"\"\"Handle _maxValue editingFinished signal\n\n        Together with :meth:`_minMaxTextEdited`, this avoids to notify\n        colormap change when the min and max value where not edited.\n        \"\"\"\n        if self._minMaxWasEdited:\n            self._minMaxWasEdited = False\n\n            # Fix end value\n            if self._minValue.value() > self._maxValue.value():\n                self._maxValue.setValue(self._minValue.value())\n            self._notify()",
  "def keyPressEvent(self, event):\n        \"\"\"Override key handling.\n\n        It disables leaving the dialog when editing a text field.\n        \"\"\"\n        if event.key() == qt.Qt.Key_Enter and (self._minValue.hasFocus() or\n            self._maxValue.hasFocus()):\n            # Bypass QDialog keyPressEvent\n            # To avoid leaving the dialog when pressing enter on a text field\n            super(qt.QDialog, self).keyPressEvent(event)\n        else:\n            # Use QDialog keyPressEvent\n            super(ColormapDialog, self).keyPressEvent(event)",
  "def configuration(parent_package='', top_path=None):\n    config = Configuration('plot', parent_package, top_path)\n    config.add_subpackage('test')\n\n    return config",
  "class BackendBase(object):\n    \"\"\"Class defining the API a backend of the Plot should provide.\"\"\"\n\n    def __init__(self, plot, parent=None):\n        \"\"\"Init.\n\n        :param Plot plot: The Plot this backend is attached to\n        :param parent: The parent widget of the plot widget.\n        \"\"\"\n        self.__xLimits = 1., 100.\n        self.__yLimits = {'left': (1., 100.), 'right': (1., 100.)}\n        self.__yAxisInverted = False\n        self.__keepDataAspectRatio = False\n        # Store a weakref to get access to the plot state.\n        self._setPlot(plot)\n\n    @property\n    def _plot(self):\n        \"\"\"The plot this backend is attached to.\"\"\"\n        if self._plotRef is None:\n            raise RuntimeError('This backend is not attached to a Plot')\n\n        plot = self._plotRef()\n        if plot is None:\n            raise RuntimeError('This backend is no more attached to a Plot')\n        return plot\n\n    def _setPlot(self, plot):\n        \"\"\"Allow to set plot after init.\n\n        Use with caution, basically **immediately** after init.\n        \"\"\"\n        self._plotRef = weakref.ref(plot)\n\n    # Add methods\n\n    def addCurve(self, x, y, legend,\n                 color, symbol, linewidth, linestyle,\n                 yaxis,\n                 xerror, yerror, z, selectable,\n                 fill):\n        \"\"\"Add a 1D curve given by x an y to the graph.\n\n        :param numpy.ndarray x: The data corresponding to the x axis\n        :param numpy.ndarray y: The data corresponding to the y axis\n        :param str legend: The legend to be associated to the curve\n        :param color: color(s) to be used\n        :type color: string (\"#RRGGBB\") or (npoints, 4) unsigned byte array or\n                     one of the predefined color names defined in Colors.py\n        :param str symbol: Symbol to be drawn at each (x, y) position::\n\n            - ' ' or '' no symbol\n            - 'o' circle\n            - '.' point\n            - ',' pixel\n            - '+' cross\n            - 'x' x-cross\n            - 'd' diamond\n            - 's' square\n\n        :param float linewidth: The width of the curve in pixels\n\n            - ' ' or ''  no line\n            - '-'  solid line\n            - '--' dashed line\n            - '-.' dash-dot line\n            - ':'  dotted line\n\n        :param str yaxis: The Y axis this curve belongs to in: 'left', 'right'\n        :param xerror: Values with the uncertainties on the x values\n        :type xerror: numpy.ndarray or None\n        :param yerror: Values with the uncertainties on the y values\n        :type yerror: numpy.ndarray or None\n        :param int z: Layer on which to draw the cuve\n        :param bool selectable: indicate if the curve can be selected\n        :returns: The handle used by the backend to univocally access the curve\n        \"\"\"\n        return legend\n\n    def addImage(self, data, legend,\n                 origin, scale, z,\n                 selectable, draggable,\n                 colormap):\n        \"\"\"Add an image to the plot.\n\n        :param numpy.ndarray data: (nrows, ncolumns) data or\n                     (nrows, ncolumns, RGBA) ubyte array\n        :param str legend: The legend to be associated to the image\n        :param origin: (origin X, origin Y) of the data.\n                       Default: (0., 0.)\n        :type origin: 2-tuple of float\n        :param scale: (scale X, scale Y) of the data.\n                       Default: (1., 1.)\n        :type scale: 2-tuple of float\n        :param int z: Layer on which to draw the image\n        :param bool selectable: indicate if the image can be selected\n        :param bool draggable: indicate if the image can be moved\n        :param colormap: Dictionary describing the colormap to use.\n                         Ignored if data is RGB(A).\n        :type colormap: dict or None\n        :returns: The handle used by the backend to univocally access the image\n        \"\"\"\n        return legend\n\n    def addItem(self, x, y, legend, shape, color, fill, overlay):\n        \"\"\"Add an item (i.e. a shape) to the plot.\n\n        :param numpy.ndarray x: The X coords of the points of the shape\n        :param numpy.ndarray y: The Y coords of the points of the shape\n        :param str legend: The legend to be associated to the item\n        :param str shape: Type of item to be drawn in\n                          hline, polygon, rectangle, vline\n        :param bool fill: True to fill the shape\n        :param bool overlay: True if item is an overlay, False otherwise\n        :returns: The handle used by the backend to univocally access the item\n        \"\"\"\n        return legend\n\n    def addMarker(self, x, y, legend, text, color,\n                  selectable, draggable,\n                  symbol, constraint, overlay):\n        \"\"\"Add a point, vertical line or horizontal line marker to the plot.\n\n        :param float x: Horizontal position of the marker in graph coordinates.\n                        If None, the marker is a horizontal line.\n        :param float y: Vertical position of the marker in graph coordinates.\n                        If None, the marker is a vertical line.\n        :param str legend: Legend associated to the marker\n        :param str text: Text associated to the marker (or None for no text)\n        :param str color: Color to be used for instance 'blue', 'b', '#FF0000'\n        :param bool selectable: indicate if the marker can be selected\n        :param bool draggable: indicate if the marker can be moved\n        :param str symbol: Symbol representing the marker.\n            Only relevant for point markers where X and Y are not None.\n            Value in:\n\n            - 'o' circle\n            - '.' point\n            - ',' pixel\n            - '+' cross\n            - 'x' x-cross\n            - 'd' diamond\n            - 's' square\n\n        :param constraint: A function filtering marker displacement by\n                           dragging operations or None for no filter.\n                           This function is called each time a marker is\n                           moved.\n                           This parameter is only used if draggable is True.\n        :type constraint: None or a callable that takes the coordinates of\n                          the current cursor position in the plot as input\n                          and that returns the filtered coordinates.\n        :param bool overlay: True if marker is an overlay (Default: False).\n                             This allows for rendering optimization if this\n                             marker is changed often.\n        :return: Handle used by the backend to univocally access the marker\n        \"\"\"\n        return legend\n\n    # Remove methods\n\n    def remove(self, item):\n        \"\"\"Remove an existing item from the plot.\n\n        :param item: A backend specific item handle returned by a add* method\n        \"\"\"\n        pass\n\n    # Interaction methods\n\n    def setGraphCursorShape(self, cursor):\n        \"\"\"Set the cursor shape.\n\n        To override in interactive backends.\n\n        :param str cursor: Name of the cursor shape or None\n        \"\"\"\n        pass\n\n    def setGraphCursor(self, flag, color, linewidth, linestyle):\n        \"\"\"Toggle the display of a crosshair cursor and set its attributes.\n\n        To override in interactive backends.\n\n        :param bool flag: Toggle the display of a crosshair cursor.\n        :param color: The color to use for the crosshair.\n        :type color: A string (either a predefined color name in Colors.py\n                    or \"#RRGGBB\")) or a 4 columns unsigned byte array.\n        :param int linewidth: The width of the lines of the crosshair.\n        :param linestyle: Type of line::\n\n                - ' ' no line\n                - '-' solid line\n                - '--' dashed line\n                - '-.' dash-dot line\n                - ':' dotted line\n\n        :type linestyle: None or one of the predefined styles.\n        \"\"\"\n        pass\n\n    def pickItems(self, x, y):\n        \"\"\"Get a list of items at a pixel position.\n\n\n        :param float x: The x pixel coord where to pick.\n        :param float y: The y pixel coord where to pick.\n        :return: All picked items from back to front.\n                 One dict per item,\n                 with 'kind' key in 'curve', 'marker', 'image';\n                 'legend' key, the item legend.\n                 and for curves, 'xdata' and 'ydata' keys storing picked\n                 position on the curve.\n        :rtype: list of dict\n        \"\"\"\n        return []\n\n    # Active curve\n\n    def setActiveCurve(self, curve, active, color=None):\n        \"\"\"Set/Reset the color of a curve to show that it is active.\n\n        :param curve: The curve handle\n        :param bool active: True to set curve to color, False to reset curve\n                            to its initial color.\n        :param str color: The color to use.\n        \"\"\"\n        pass\n\n    # Misc.\n\n    def getWidgetHandle(self):\n        \"\"\"Return the widget this backend is drawing to.\"\"\"\n        return None\n\n    def postRedisplay(self):\n        \"\"\"Trigger a :meth:`Plot.replot`.\n\n        Default implementation triggers a synchronous replot if plot is dirty.\n        This method should be overridden by the embedding widget in order to\n        provide an asynchronous call to replot in order to optimize the number\n        replot operations.\n        \"\"\"\n        if self._plot._getDirtyPlot():\n            self._plot.replot()\n\n    def replot(self):\n        \"\"\"Redraw the plot.\"\"\"\n        pass\n\n    def saveGraph(self, fileName, fileFormat, dpi):\n        \"\"\"Save the graph to a file (or a StringIO)\n\n        :param fileName: Destination\n        :type fileName: String or StringIO or BytesIO\n        :param str fileFormat: String specifying the format\n        :param int dpi: The resolution to use or None.\n        \"\"\"\n        pass\n\n    # Graph labels\n\n    def setGraphTitle(self, title):\n        \"\"\"Set the main title of the plot.\n\n        :param str title: Title associated to the plot\n        \"\"\"\n        pass\n\n    def setGraphXLabel(self, label):\n        \"\"\"Set the X axis label.\n\n        :param str label: label associated to the plot bottom X axis\n        \"\"\"\n        pass\n\n    def setGraphYLabel(self, label, axis):\n        \"\"\"Set the left Y axis label.\n\n        :param str label: label associated to the plot left Y axis\n        :param str axis: The axis for which to get the limits: left or right\n        \"\"\"\n        pass\n\n    # Graph limits\n\n    def resetZoom(self, dataMargins):\n        \"\"\"Reset the displayed area of the plot.\n\n        Autoscale any axis that is in autoscale mode.\n        Keep current limits on axes not in autoscale mode\n\n        Extra margins can be added around the data inside the plot area.\n        Margins are given as one ratio of the data range per limit of the\n        data (xMin, xMax, yMin and yMax limits).\n        For log scale, extra margins are applied in log10 of the data.\n\n        :param dataMargins: Ratios of margins to add around the data inside\n                            the plot area for each side\n        :type dataMargins: A 4-tuple of float as (xMin, xMax, yMin, yMax).\n        \"\"\"\n        pass\n\n    def setLimits(self, xmin, xmax, ymin, ymax, y2min=None, y2max=None):\n        \"\"\"Set the limits of the X and Y axes at once.\n\n        :param float xmin: minimum bottom axis value\n        :param float xmax: maximum bottom axis value\n        :param float ymin: minimum left axis value\n        :param float ymax: maximum left axis value\n        :param float y2min: minimum right axis value\n        :param float y2max: maximum right axis value\n        \"\"\"\n        self.__xLimits = xmin, xmax\n        self.__yLimits['left'] = ymin, ymax\n        if y2min is not None and y2max is not None:\n            self.__yLimits['right'] = y2min, y2max\n\n    def getGraphXLimits(self):\n        \"\"\"Get the graph X (bottom) limits.\n\n        :return:  Minimum and maximum values of the X axis\n        \"\"\"\n        return self.__xLimits\n\n    def setGraphXLimits(self, xmin, xmax):\n        \"\"\"Set the limits of X axis.\n\n        :param float xmin: minimum bottom axis value\n        :param float xmax: maximum bottom axis value\n        \"\"\"\n        self.__xLimits = xmin, xmax\n\n    def getGraphYLimits(self, axis):\n        \"\"\"Get the graph Y (left) limits.\n\n        :param str axis: The axis for which to get the limits: left or right\n        :return: Minimum and maximum values of the Y axis\n        \"\"\"\n        return self.__yLimits[axis]\n\n    def setGraphYLimits(self, ymin, ymax, axis):\n        \"\"\"Set the limits of the Y axis.\n\n        :param float ymin: minimum left axis value\n        :param float ymax: maximum left axis value\n        :param str axis: The axis for which to get the limits: left or right\n        \"\"\"\n        self.__yLimits[axis] = ymin, ymax\n\n    # Graph axes\n\n    def setXAxisLogarithmic(self, flag):\n        \"\"\"Set the X axis scale between linear and log.\n\n        :param bool flag: If True, the bottom axis will use a log scale\n        \"\"\"\n        pass\n\n    def setYAxisLogarithmic(self, flag):\n        \"\"\"Set the Y axis scale between linear and log.\n\n        :param bool flag: If True, the left axis will use a log scale\n        \"\"\"\n        pass\n\n    def setYAxisInverted(self, flag):\n        \"\"\"Invert the Y axis.\n\n        :param bool flag: If True, put the vertical axis origin on the top\n        \"\"\"\n        self.__yAxisInverted = bool(flag)\n\n    def isYAxisInverted(self):\n        \"\"\"Return True if left Y axis is inverted, False otherwise.\"\"\"\n        return self.__yAxisInverted\n\n    def isKeepDataAspectRatio(self):\n        \"\"\"Returns whether the plot is keeping data aspect ratio or not.\"\"\"\n        return self.__keepDataAspectRatio\n\n    def setKeepDataAspectRatio(self, flag):\n        \"\"\"Set whether to keep data aspect ratio or not.\n\n        :param flag:  True to respect data aspect ratio\n        :type flag: Boolean, default True\n        \"\"\"\n        self.__keepDataAspectRatio = bool(flag)\n\n    def setGraphGrid(self, which):\n        \"\"\"Set grid.\n\n        :param which: None to disable grid, 'major' for major grid,\n                     'both' for major and minor grid\n        \"\"\"\n        pass\n\n    # colormap\n\n    def getSupportedColormaps(self):\n        \"\"\"Get a list of strings with the supported colormap names.\n\n        The list should at least contain and start by:\n        ['gray', 'reversed gray', 'temperature', 'red', 'green', 'blue']\n        \"\"\"\n        return ('gray', 'reversed gray', 'temperature', 'red', 'green', 'blue')\n\n    # Data <-> Pixel coordinates conversion\n\n    def dataToPixel(self, x, y, axis):\n        \"\"\"Convert a position in data space to a position in pixels\n        in the widget.\n\n        :param float x: The X coordinate in data space.\n        :param float y: The Y coordinate in data space.\n        :param str axis: The Y axis to use for the conversion\n                         ('left' or 'right').\n        :returns: The corresponding position in pixels or\n                  None if the data position is not in the displayed area.\n        :rtype: A tuple of 2 floats: (xPixel, yPixel) or None.\n        \"\"\"\n        raise NotImplementedError()\n\n    def pixelToData(self, x, y, axis):\n        \"\"\"Convert a position in pixels in the widget to a position in\n        the data space.\n\n        :param float x: The X coordinate in pixels.\n        :param float y: The Y coordinate in pixels.\n        :param str axis: The Y axis to use for the conversion\n                         ('left' or 'right').\n        :returns: The corresponding position in data space or\n                  None if the pixel position is not in the plot area.\n        :rtype: A tuple of 2 floats: (xData, yData) or None.\n        \"\"\"\n        raise NotImplementedError()\n\n    def getPlotBoundsInPixels(self):\n        \"\"\"Plot area bounds in widget coordinates in pixels.\n\n        :return: bounds as a 4-tuple of int: (left, top, width, height)\n        \"\"\"\n        raise NotImplementedError()",
  "def __init__(self, plot, parent=None):\n        \"\"\"Init.\n\n        :param Plot plot: The Plot this backend is attached to\n        :param parent: The parent widget of the plot widget.\n        \"\"\"\n        self.__xLimits = 1., 100.\n        self.__yLimits = {'left': (1., 100.), 'right': (1., 100.)}\n        self.__yAxisInverted = False\n        self.__keepDataAspectRatio = False\n        # Store a weakref to get access to the plot state.\n        self._setPlot(plot)",
  "def _plot(self):\n        \"\"\"The plot this backend is attached to.\"\"\"\n        if self._plotRef is None:\n            raise RuntimeError('This backend is not attached to a Plot')\n\n        plot = self._plotRef()\n        if plot is None:\n            raise RuntimeError('This backend is no more attached to a Plot')\n        return plot",
  "def _setPlot(self, plot):\n        \"\"\"Allow to set plot after init.\n\n        Use with caution, basically **immediately** after init.\n        \"\"\"\n        self._plotRef = weakref.ref(plot)",
  "def addCurve(self, x, y, legend,\n                 color, symbol, linewidth, linestyle,\n                 yaxis,\n                 xerror, yerror, z, selectable,\n                 fill):\n        \"\"\"Add a 1D curve given by x an y to the graph.\n\n        :param numpy.ndarray x: The data corresponding to the x axis\n        :param numpy.ndarray y: The data corresponding to the y axis\n        :param str legend: The legend to be associated to the curve\n        :param color: color(s) to be used\n        :type color: string (\"#RRGGBB\") or (npoints, 4) unsigned byte array or\n                     one of the predefined color names defined in Colors.py\n        :param str symbol: Symbol to be drawn at each (x, y) position::\n\n            - ' ' or '' no symbol\n            - 'o' circle\n            - '.' point\n            - ',' pixel\n            - '+' cross\n            - 'x' x-cross\n            - 'd' diamond\n            - 's' square\n\n        :param float linewidth: The width of the curve in pixels\n\n            - ' ' or ''  no line\n            - '-'  solid line\n            - '--' dashed line\n            - '-.' dash-dot line\n            - ':'  dotted line\n\n        :param str yaxis: The Y axis this curve belongs to in: 'left', 'right'\n        :param xerror: Values with the uncertainties on the x values\n        :type xerror: numpy.ndarray or None\n        :param yerror: Values with the uncertainties on the y values\n        :type yerror: numpy.ndarray or None\n        :param int z: Layer on which to draw the cuve\n        :param bool selectable: indicate if the curve can be selected\n        :returns: The handle used by the backend to univocally access the curve\n        \"\"\"\n        return legend",
  "def addImage(self, data, legend,\n                 origin, scale, z,\n                 selectable, draggable,\n                 colormap):\n        \"\"\"Add an image to the plot.\n\n        :param numpy.ndarray data: (nrows, ncolumns) data or\n                     (nrows, ncolumns, RGBA) ubyte array\n        :param str legend: The legend to be associated to the image\n        :param origin: (origin X, origin Y) of the data.\n                       Default: (0., 0.)\n        :type origin: 2-tuple of float\n        :param scale: (scale X, scale Y) of the data.\n                       Default: (1., 1.)\n        :type scale: 2-tuple of float\n        :param int z: Layer on which to draw the image\n        :param bool selectable: indicate if the image can be selected\n        :param bool draggable: indicate if the image can be moved\n        :param colormap: Dictionary describing the colormap to use.\n                         Ignored if data is RGB(A).\n        :type colormap: dict or None\n        :returns: The handle used by the backend to univocally access the image\n        \"\"\"\n        return legend",
  "def addItem(self, x, y, legend, shape, color, fill, overlay):\n        \"\"\"Add an item (i.e. a shape) to the plot.\n\n        :param numpy.ndarray x: The X coords of the points of the shape\n        :param numpy.ndarray y: The Y coords of the points of the shape\n        :param str legend: The legend to be associated to the item\n        :param str shape: Type of item to be drawn in\n                          hline, polygon, rectangle, vline\n        :param bool fill: True to fill the shape\n        :param bool overlay: True if item is an overlay, False otherwise\n        :returns: The handle used by the backend to univocally access the item\n        \"\"\"\n        return legend",
  "def addMarker(self, x, y, legend, text, color,\n                  selectable, draggable,\n                  symbol, constraint, overlay):\n        \"\"\"Add a point, vertical line or horizontal line marker to the plot.\n\n        :param float x: Horizontal position of the marker in graph coordinates.\n                        If None, the marker is a horizontal line.\n        :param float y: Vertical position of the marker in graph coordinates.\n                        If None, the marker is a vertical line.\n        :param str legend: Legend associated to the marker\n        :param str text: Text associated to the marker (or None for no text)\n        :param str color: Color to be used for instance 'blue', 'b', '#FF0000'\n        :param bool selectable: indicate if the marker can be selected\n        :param bool draggable: indicate if the marker can be moved\n        :param str symbol: Symbol representing the marker.\n            Only relevant for point markers where X and Y are not None.\n            Value in:\n\n            - 'o' circle\n            - '.' point\n            - ',' pixel\n            - '+' cross\n            - 'x' x-cross\n            - 'd' diamond\n            - 's' square\n\n        :param constraint: A function filtering marker displacement by\n                           dragging operations or None for no filter.\n                           This function is called each time a marker is\n                           moved.\n                           This parameter is only used if draggable is True.\n        :type constraint: None or a callable that takes the coordinates of\n                          the current cursor position in the plot as input\n                          and that returns the filtered coordinates.\n        :param bool overlay: True if marker is an overlay (Default: False).\n                             This allows for rendering optimization if this\n                             marker is changed often.\n        :return: Handle used by the backend to univocally access the marker\n        \"\"\"\n        return legend",
  "def remove(self, item):\n        \"\"\"Remove an existing item from the plot.\n\n        :param item: A backend specific item handle returned by a add* method\n        \"\"\"\n        pass",
  "def setGraphCursorShape(self, cursor):\n        \"\"\"Set the cursor shape.\n\n        To override in interactive backends.\n\n        :param str cursor: Name of the cursor shape or None\n        \"\"\"\n        pass",
  "def setGraphCursor(self, flag, color, linewidth, linestyle):\n        \"\"\"Toggle the display of a crosshair cursor and set its attributes.\n\n        To override in interactive backends.\n\n        :param bool flag: Toggle the display of a crosshair cursor.\n        :param color: The color to use for the crosshair.\n        :type color: A string (either a predefined color name in Colors.py\n                    or \"#RRGGBB\")) or a 4 columns unsigned byte array.\n        :param int linewidth: The width of the lines of the crosshair.\n        :param linestyle: Type of line::\n\n                - ' ' no line\n                - '-' solid line\n                - '--' dashed line\n                - '-.' dash-dot line\n                - ':' dotted line\n\n        :type linestyle: None or one of the predefined styles.\n        \"\"\"\n        pass",
  "def pickItems(self, x, y):\n        \"\"\"Get a list of items at a pixel position.\n\n\n        :param float x: The x pixel coord where to pick.\n        :param float y: The y pixel coord where to pick.\n        :return: All picked items from back to front.\n                 One dict per item,\n                 with 'kind' key in 'curve', 'marker', 'image';\n                 'legend' key, the item legend.\n                 and for curves, 'xdata' and 'ydata' keys storing picked\n                 position on the curve.\n        :rtype: list of dict\n        \"\"\"\n        return []",
  "def setActiveCurve(self, curve, active, color=None):\n        \"\"\"Set/Reset the color of a curve to show that it is active.\n\n        :param curve: The curve handle\n        :param bool active: True to set curve to color, False to reset curve\n                            to its initial color.\n        :param str color: The color to use.\n        \"\"\"\n        pass",
  "def getWidgetHandle(self):\n        \"\"\"Return the widget this backend is drawing to.\"\"\"\n        return None",
  "def postRedisplay(self):\n        \"\"\"Trigger a :meth:`Plot.replot`.\n\n        Default implementation triggers a synchronous replot if plot is dirty.\n        This method should be overridden by the embedding widget in order to\n        provide an asynchronous call to replot in order to optimize the number\n        replot operations.\n        \"\"\"\n        if self._plot._getDirtyPlot():\n            self._plot.replot()",
  "def replot(self):\n        \"\"\"Redraw the plot.\"\"\"\n        pass",
  "def saveGraph(self, fileName, fileFormat, dpi):\n        \"\"\"Save the graph to a file (or a StringIO)\n\n        :param fileName: Destination\n        :type fileName: String or StringIO or BytesIO\n        :param str fileFormat: String specifying the format\n        :param int dpi: The resolution to use or None.\n        \"\"\"\n        pass",
  "def setGraphTitle(self, title):\n        \"\"\"Set the main title of the plot.\n\n        :param str title: Title associated to the plot\n        \"\"\"\n        pass",
  "def setGraphXLabel(self, label):\n        \"\"\"Set the X axis label.\n\n        :param str label: label associated to the plot bottom X axis\n        \"\"\"\n        pass",
  "def setGraphYLabel(self, label, axis):\n        \"\"\"Set the left Y axis label.\n\n        :param str label: label associated to the plot left Y axis\n        :param str axis: The axis for which to get the limits: left or right\n        \"\"\"\n        pass",
  "def resetZoom(self, dataMargins):\n        \"\"\"Reset the displayed area of the plot.\n\n        Autoscale any axis that is in autoscale mode.\n        Keep current limits on axes not in autoscale mode\n\n        Extra margins can be added around the data inside the plot area.\n        Margins are given as one ratio of the data range per limit of the\n        data (xMin, xMax, yMin and yMax limits).\n        For log scale, extra margins are applied in log10 of the data.\n\n        :param dataMargins: Ratios of margins to add around the data inside\n                            the plot area for each side\n        :type dataMargins: A 4-tuple of float as (xMin, xMax, yMin, yMax).\n        \"\"\"\n        pass",
  "def setLimits(self, xmin, xmax, ymin, ymax, y2min=None, y2max=None):\n        \"\"\"Set the limits of the X and Y axes at once.\n\n        :param float xmin: minimum bottom axis value\n        :param float xmax: maximum bottom axis value\n        :param float ymin: minimum left axis value\n        :param float ymax: maximum left axis value\n        :param float y2min: minimum right axis value\n        :param float y2max: maximum right axis value\n        \"\"\"\n        self.__xLimits = xmin, xmax\n        self.__yLimits['left'] = ymin, ymax\n        if y2min is not None and y2max is not None:\n            self.__yLimits['right'] = y2min, y2max",
  "def getGraphXLimits(self):\n        \"\"\"Get the graph X (bottom) limits.\n\n        :return:  Minimum and maximum values of the X axis\n        \"\"\"\n        return self.__xLimits",
  "def setGraphXLimits(self, xmin, xmax):\n        \"\"\"Set the limits of X axis.\n\n        :param float xmin: minimum bottom axis value\n        :param float xmax: maximum bottom axis value\n        \"\"\"\n        self.__xLimits = xmin, xmax",
  "def getGraphYLimits(self, axis):\n        \"\"\"Get the graph Y (left) limits.\n\n        :param str axis: The axis for which to get the limits: left or right\n        :return: Minimum and maximum values of the Y axis\n        \"\"\"\n        return self.__yLimits[axis]",
  "def setGraphYLimits(self, ymin, ymax, axis):\n        \"\"\"Set the limits of the Y axis.\n\n        :param float ymin: minimum left axis value\n        :param float ymax: maximum left axis value\n        :param str axis: The axis for which to get the limits: left or right\n        \"\"\"\n        self.__yLimits[axis] = ymin, ymax",
  "def setXAxisLogarithmic(self, flag):\n        \"\"\"Set the X axis scale between linear and log.\n\n        :param bool flag: If True, the bottom axis will use a log scale\n        \"\"\"\n        pass",
  "def setYAxisLogarithmic(self, flag):\n        \"\"\"Set the Y axis scale between linear and log.\n\n        :param bool flag: If True, the left axis will use a log scale\n        \"\"\"\n        pass",
  "def setYAxisInverted(self, flag):\n        \"\"\"Invert the Y axis.\n\n        :param bool flag: If True, put the vertical axis origin on the top\n        \"\"\"\n        self.__yAxisInverted = bool(flag)",
  "def isYAxisInverted(self):\n        \"\"\"Return True if left Y axis is inverted, False otherwise.\"\"\"\n        return self.__yAxisInverted",
  "def isKeepDataAspectRatio(self):\n        \"\"\"Returns whether the plot is keeping data aspect ratio or not.\"\"\"\n        return self.__keepDataAspectRatio",
  "def setKeepDataAspectRatio(self, flag):\n        \"\"\"Set whether to keep data aspect ratio or not.\n\n        :param flag:  True to respect data aspect ratio\n        :type flag: Boolean, default True\n        \"\"\"\n        self.__keepDataAspectRatio = bool(flag)",
  "def setGraphGrid(self, which):\n        \"\"\"Set grid.\n\n        :param which: None to disable grid, 'major' for major grid,\n                     'both' for major and minor grid\n        \"\"\"\n        pass",
  "def getSupportedColormaps(self):\n        \"\"\"Get a list of strings with the supported colormap names.\n\n        The list should at least contain and start by:\n        ['gray', 'reversed gray', 'temperature', 'red', 'green', 'blue']\n        \"\"\"\n        return ('gray', 'reversed gray', 'temperature', 'red', 'green', 'blue')",
  "def dataToPixel(self, x, y, axis):\n        \"\"\"Convert a position in data space to a position in pixels\n        in the widget.\n\n        :param float x: The X coordinate in data space.\n        :param float y: The Y coordinate in data space.\n        :param str axis: The Y axis to use for the conversion\n                         ('left' or 'right').\n        :returns: The corresponding position in pixels or\n                  None if the data position is not in the displayed area.\n        :rtype: A tuple of 2 floats: (xPixel, yPixel) or None.\n        \"\"\"\n        raise NotImplementedError()",
  "def pixelToData(self, x, y, axis):\n        \"\"\"Convert a position in pixels in the widget to a position in\n        the data space.\n\n        :param float x: The X coordinate in pixels.\n        :param float y: The Y coordinate in pixels.\n        :param str axis: The Y axis to use for the conversion\n                         ('left' or 'right').\n        :returns: The corresponding position in data space or\n                  None if the pixel position is not in the plot area.\n        :rtype: A tuple of 2 floats: (xData, yData) or None.\n        \"\"\"\n        raise NotImplementedError()",
  "def getPlotBoundsInPixels(self):\n        \"\"\"Plot area bounds in widget coordinates in pixels.\n\n        :return: bounds as a 4-tuple of int: (left, top, width, height)\n        \"\"\"\n        raise NotImplementedError()",
  "def rgba(color, colorDict=None):\n    \"\"\"Convert color code '#RRGGBB' and '#RRGGBBAA' to (R, G, B, A)\n\n    :param str code: The color code to conver\n    :param dict colorDict: A dictionary of color name conversion to color code\n    :returns: RGBA colors as floats in [0., 1.]\n    :rtype: tuple\n    \"\"\"\n    if colorDict is None:\n        colorDict = COLORDICT\n    if len(color) == 4:\n        r, g, b, a = color\n        if type(color[3]) in [type(1), numpy.uint8, numpy.int8]:\n            return r / 255., g / 255., b / 255., a / 255.\n        if type(color[3]) in [type(1.), numpy.float32, numpy.float64]:\n            assert r >= 0. and r <= 1.\n            assert g >= 0. and g <= 1.\n            assert b >= 0. and b <= 1.\n            assert a >= 0. and a <= 1.\n            return r, g, b, a\n\n    # We assume color is a string\n    if not color.startswith('#'):\n        color = colorDict[color]\n\n    assert len(color) in (7, 9) and color[0] == '#'\n    r = int(color[1:3], 16) / 255.\n    g = int(color[3:5], 16) / 255.\n    b = int(color[5:7], 16) / 255.\n    a = int(color[7:9], 16) / 255. if len(color) == 9 else 1.\n    return r, g, b, a",
  "class BackendMatplotlib(BackendBase.BackendBase):\n    \"\"\"Base class for Matplotlib backend without a FigureCanvas.\n\n    For interactive on screen plot, see :class:`BackendMatplotlibQt`.\n\n    See :class:`BackendBase.BackendBase` for public API documentation.\n    \"\"\"\n\n    def __init__(self, plot, parent=None):\n        super(BackendMatplotlib, self).__init__(plot, parent)\n\n        self.fig = Figure()\n        self.fig.set_facecolor(\"w\")\n\n        self.ax = self.fig.add_axes([.15, .15, .75, .75], label=\"left\")\n        self.ax2 = self.ax.twinx()\n        self.ax2.set_label(\"right\")\n\n        # critical for picking!!!!\n        self.ax2.set_zorder(0)\n        self.ax2.set_autoscaley_on(True)\n        self.ax.set_zorder(1)\n        # this works but the figure color is left\n        self.ax.set_axis_bgcolor('none')\n        self.fig.sca(self.ax)\n\n        self._overlays = set()\n        self._background = None\n\n        self._colormaps = {}\n\n        self._graphCursor = tuple()\n        self.matplotlibVersion = matplotlib.__version__\n\n        self.setGraphXLimits(0., 100.)\n        self.setGraphYLimits(0., 100., axis='left')\n        self.setGraphYLimits(0., 100., axis='right')\n\n        self._enableAxis('right', False)\n\n    # Add methods\n\n    def addCurve(self, x, y, legend,\n                 color, symbol, linewidth, linestyle,\n                 yaxis,\n                 xerror, yerror, z, selectable,\n                 fill):\n        for parameter in (x, y, legend, color, symbol, linewidth, linestyle,\n                          yaxis, z, selectable, fill):\n            assert parameter is not None\n        assert yaxis in ('left', 'right')\n\n        if (len(color) == 4 and\n                type(color[3]) in [type(1), numpy.uint8, numpy.int8]):\n            color = numpy.array(color, dtype=numpy.float)/255.\n\n        if yaxis == \"right\":\n            axes = self.ax2\n            self._enableAxis(\"right\", True)\n        else:\n            axes = self.ax\n\n        picker = 3 if selectable else None\n\n        artists = []  # All the artists composing the curve\n\n        # First add errorbars if any so they are behind the curve\n        if xerror is not None or yerror is not None:\n            if hasattr(color, 'dtype') and len(color) == len(x):\n                errorbarColor = 'k'\n            else:\n                errorbarColor = color\n\n            errorbars = axes.errorbar(x, y, label=legend,\n                                      xerr=xerror, yerr=yerror,\n                                      linestyle=' ', color=errorbarColor)\n            artists += list(errorbars.get_children())\n\n        if hasattr(color, 'dtype') and len(color) == len(x):\n            # scatter plot\n            if color.dtype not in [numpy.float32, numpy.float]:\n                actualColor = color / 255.\n            else:\n                actualColor = color\n\n            if linestyle not in [\"\", \" \", None]:\n                # scatter plot with an actual line ...\n                # we need to assign a color ...\n                curveList = axes.plot(x, y, label=legend,\n                                      linestyle=linestyle,\n                                      color=actualColor[0],\n                                      linewidth=linewidth,\n                                      picker=picker,\n                                      marker=None)\n                artists += list(curveList)\n\n            scatter = axes.scatter(x, y,\n                                   label=legend,\n                                   color=actualColor,\n                                   marker=symbol,\n                                   picker=picker)\n            artists.append(scatter)\n\n            if fill:\n                artists.append(axes.fill_between(\n                    x, 1.0e-8, y, facecolor=actualColor[0], linestyle=''))\n\n        else:  # Curve\n            curveList = axes.plot(x, y,\n                                  label=legend,\n                                  linestyle=linestyle,\n                                  color=color,\n                                  linewidth=linewidth,\n                                  marker=symbol,\n                                  picker=picker)\n            artists += list(curveList)\n\n            if fill:\n                artists.append(\n                    axes.fill_between(x, 1.0e-8, y,\n                                      facecolor=color, linewidth=0))\n\n        # This complies with _getDataLimits\n        artists[-1]._plot_info = {\n            'axes': yaxis,\n            # this is needed for scatter plots because I do not know\n            # how to recover the data yet, it can speed up limits too\n            'xmin': numpy.nanmin(x),\n            'xmax': numpy.nanmax(x),\n            'ymin': numpy.nanmin(y),\n            'ymax': numpy.nanmax(y),\n        }\n\n        artists[-1].axes = axes\n\n        for artist in artists:\n            artist.set_zorder(z)\n\n        return Container(artists)\n\n    def addImage(self, data, legend,\n                 origin, scale, z,\n                 selectable, draggable,\n                 colormap):\n        # Non-uniform image\n        # http://wiki.scipy.org/Cookbook/Histograms\n        # Non-linear axes\n        # http://stackoverflow.com/questions/11488800/non-linear-axes-for-imshow-in-matplotlib\n        for parameter in (data, legend, origin, scale, z,\n                          selectable, draggable):\n            assert parameter is not None\n\n        h, w = data.shape[0:2]\n        xmin = origin[0]\n        xmax = xmin + scale[0] * w\n        ymin = origin[1]\n        ymax = ymin + scale[1] * h\n        extent = (xmin, xmax, ymax, ymin)\n\n        picker = (selectable or draggable)\n\n        # the normalization can be a source of time waste\n        # Two possibilities, we receive data or a ready to show image\n        if len(data.shape) == 3:\n            if data.shape[-1] == 4:\n                # force alpha? data[:,:,3] = 255\n                pass\n\n            # RGBA image\n            # TODO: Possibility to mirror the image\n            # in case of pixmaps just setting\n            # extend = (xmin, xmax, ymax, ymin)\n            # instead of (xmin, xmax, ymin, ymax)\n            extent = (xmin, xmax, ymin, ymax)\n            if tuple(origin) != (0., 0.) or tuple(scale) != (1., 1.):\n                # for the time being not properly handled\n                imageClass = AxesImage\n            elif (data.shape[0] * data.shape[1]) > 5.0e5:\n                imageClass = ModestImage\n            else:\n                imageClass = AxesImage\n            image = imageClass(self.ax,\n                               label=\"__IMAGE__\"+legend,\n                               interpolation='nearest',\n                               picker=picker,\n                               zorder=z)\n            if image.origin == 'upper':\n                image.set_extent((xmin, xmax, ymax, ymin))\n            else:\n                image.set_extent((xmin, xmax, ymin, ymax))\n            image.set_data(data)\n\n        else:\n            assert colormap is not None\n            cmap = self.__getColormap(colormap['name'])\n            if colormap['normalization'].startswith('log'):\n                vmin, vmax = None, None\n                if not colormap['autoscale']:\n                    if colormap['vmin'] > 0.:\n                        vmin = colormap['vmin']\n                    if colormap['vmax'] > 0.:\n                        vmax = colormap['vmax']\n\n                    if vmin is None or vmax is None:\n                        _logger.warning('Log colormap with negative bounds, ' +\n                                        'changing bounds to positive ones.')\n                    elif vmin > vmax:\n                        _logger.warning('Colormap bounds are inverted.')\n                        vmin, vmax = vmax, vmin\n\n                # Set unset/negative bounds to positive bounds\n                if vmin is None or vmax is None:\n                    posData = data[data > 0]\n                    if vmax is None:\n                        # 1. as an ultimate fallback\n                        vmax = posData.max() if posData.size > 0 else 1.\n                    if vmin is None:\n                        vmin = posData.min() if posData.size > 0 else vmax\n                    if vmin > vmax:\n                        vmin = vmax\n\n                norm = LogNorm(vmin, vmax)\n\n            else:  # Linear normalization\n                if colormap['autoscale']:\n                    vmin = data.min()\n                    vmax = data.max()\n                else:\n                    vmin = colormap['vmin']\n                    vmax = colormap['vmax']\n                    if vmin > vmax:\n                        _logger.warning('Colormap bounds are inverted.')\n                        vmin, vmax = vmax, vmin\n\n                norm = Normalize(vmin, vmax)\n\n            # try as data\n            if tuple(origin) != (0., 0.) or tuple(scale) != (1., 1.):\n                # for the time being not properly handled\n                imageClass = AxesImage\n            elif (data.shape[0] * data.shape[1]) > 5.0e5:\n                imageClass = ModestImage\n            else:\n                imageClass = AxesImage\n            image = imageClass(self.ax,\n                               label=\"__IMAGE__\" + legend,\n                               interpolation='nearest',\n                               cmap=cmap,\n                               extent=extent,\n                               picker=picker,\n                               zorder=z,\n                               norm=norm)\n\n            if image.origin == 'upper':\n                image.set_extent((xmin, xmax, ymax, ymin))\n            else:\n                image.set_extent((xmin, xmax, ymin, ymax))\n\n            image.set_data(data)\n\n        self.ax.add_artist(image)\n\n        return image\n\n    def addItem(self, x, y, legend, shape, color, fill, overlay):\n        xView = numpy.array(x, copy=False)\n        yView = numpy.array(y, copy=False)\n\n        if shape == \"line\":\n            item = self.ax.plot(x, y, label=legend, color=color,\n                                linestyle='-', marker=None)[0]\n\n        elif shape == \"hline\":\n            if hasattr(y, \"__len__\"):\n                y = y[-1]\n            item = self.ax.axhline(y, label=legend, color=color)\n\n        elif shape == \"vline\":\n            if hasattr(x, \"__len__\"):\n                x = x[-1]\n            item = self.ax.axvline(x, label=legend, color=color)\n\n        elif shape == 'rectangle':\n            xMin = numpy.nanmin(xView)\n            xMax = numpy.nanmax(xView)\n            yMin = numpy.nanmin(yView)\n            yMax = numpy.nanmax(yView)\n            w = xMax - xMin\n            h = yMax - yMin\n            item = Rectangle(xy=(xMin, yMin),\n                             width=w,\n                             height=h,\n                             fill=False,\n                             color=color)\n            if fill:\n                item.set_hatch('.')\n\n            self.ax.add_patch(item)\n\n        elif shape == 'polygon':\n            xView.shape = 1, -1\n            yView.shape = 1, -1\n            item = Polygon(numpy.vstack((xView, yView)).T,\n                           closed=True,\n                           fill=False,\n                           label=legend,\n                           color=color)\n            if fill:\n                item.set_hatch('/')\n\n            self.ax.add_patch(item)\n\n        else:\n            raise NotImplementedError(\"Unsupported item shape %s\" % shape)\n\n        if overlay:\n            item.set_animated(True)\n            self._overlays.add(item)\n\n        return item\n\n    def addMarker(self, x, y, legend, text, color,\n                  selectable, draggable,\n                  symbol, constraint, overlay):\n        legend = \"__MARKER__\" + legend\n\n        # TODO issues with text placement when changing limits..\n        if x is not None and y is not None:\n            line = self.ax.plot(x, y, label=legend,\n                                linestyle=\" \",\n                                color=color,\n                                marker=symbol,\n                                markersize=10.)[-1]\n\n            if text is not None:\n                xtmp, ytmp = self.ax.transData.transform_point((x, y))\n                inv = self.ax.transData.inverted()\n                xtmp, ytmp = inv.transform_point((xtmp, ytmp + 15))\n                text = \" \" + text\n                line._infoText = self.ax.text(x, ytmp, text,\n                                              color=color,\n                                              horizontalalignment='left',\n                                              verticalalignment='top')\n\n        elif x is not None:\n            line = self.ax.axvline(x, label=legend, color=color)\n            if text is not None:\n                text = \" \" + text\n                ymin, ymax = self.getGraphYLimits(axis='left')\n                delta = abs(ymax - ymin)\n                if ymin > ymax:\n                    ymax = ymin\n                ymax -= 0.005 * delta\n                line._infoText = self.ax.text(x, ymax, text,\n                                              color=color,\n                                              horizontalalignment='left',\n                                              verticalalignment='top')\n\n        elif y is not None:\n            line = self.ax.axhline(y, label=legend, color=color)\n\n            if text is not None:\n                text = \" \" + text\n                xmin, xmax = self.getGraphXLimits()\n                delta = abs(xmax - xmin)\n                if xmin > xmax:\n                    xmax = xmin\n                xmax -= 0.005 * delta\n                line._infoText = self.ax.text(xmax, y, text,\n                                              color=color,\n                                              horizontalalignment='right',\n                                              verticalalignment='top')\n\n        else:\n            raise RuntimeError('A marker must at least have one coordinate')\n\n        if selectable or draggable:\n            line.set_picker(5)\n\n        if overlay:\n            line.set_animated(True)\n            self._overlays.add(line)\n\n        return line\n\n    # Remove methods\n\n    def remove(self, item):\n        # Warning: It also needs to remove extra stuff if added as for markers\n        if hasattr(item, \"_infoText\"):  # For markers text\n            item._infoText.remove()\n            item._infoText = None\n        self._overlays.discard(item)\n        item.remove()\n\n    # Interaction methods\n\n    def setGraphCursor(self, flag, color, linewidth, linestyle):\n        if flag:\n            lineh = self.ax.axhline(\n                self.ax.get_ybound()[0], visible=False, color=color,\n                linewidth=linewidth, linestyle=linestyle)\n            lineh.set_animated(True)\n\n            linev = self.ax.axvline(\n                self.ax.get_xbound()[0], visible=False, color=color,\n                linewidth=linewidth, linestyle=linestyle)\n            linev.set_animated(True)\n\n            self._graphCursor = lineh, linev\n        else:\n            if self._graphCursor is not None:\n                lineh, linev = self._graphCursor\n                lineh.remove()\n                linev.remove()\n                self._graphCursor = tuple()\n\n    # Active curve\n\n    def setActiveCurve(self, curve, active, color=None):\n        # Store Line2D and PathCollection\n        for artist in curve.get_children():\n            if active:\n                if isinstance(artist, (Line2D, LineCollection)):\n                    artist._initialColor = artist.get_color()\n                    artist.set_color(color)\n                elif isinstance(artist, PathCollection):\n                    artist._initialColor = artist.get_facecolors()\n                    artist.set_facecolors(color)\n                    artist.set_edgecolors(color)\n                else:\n                    _logger.warning(\n                        'setActiveCurve ignoring artist %s', str(artist))\n            else:\n                if hasattr(artist, '_initialColor'):\n                    if isinstance(artist, (Line2D, LineCollection)):\n                        artist.set_color(artist._initialColor)\n                    elif isinstance(artist, PathCollection):\n                        artist.set_facecolors(artist._initialColor)\n                        artist.set_edgecolors(artist._initialColor)\n                    else:\n                        _logger.info(\n                            'setActiveCurve ignoring artist %s', str(artist))\n                    del artist._initialColor\n\n    # Misc.\n\n    def getWidgetHandle(self):\n        return self.fig.canvas\n\n    def _enableAxis(self, axis, flag=True):\n        \"\"\"Show/hide Y axis\n\n        :param str axis: Axis name: 'left' or 'right'\n        :param bool flag: Default, True\n        \"\"\"\n        assert axis in ('right', 'left')\n        axes = self.ax2 if axis == 'right' else self.ax\n        axes.get_yaxis().set_visible(flag)\n\n    def replot(self):\n        \"\"\"Do not perform rendering.\n\n        Override in subclass to actually draw something.\n        \"\"\"\n        # TODO images, markers? scatter plot? move in remove?\n        # Right Y axis only support curve for now\n        # Hide right Y axis if no line is present\n        if not self.ax2.lines:\n            self._enableAxis('right', False)\n\n    def saveGraph(self, fileName, fileFormat, dpi):\n        # fileName can be also a StringIO or file instance\n        if dpi is not None:\n            self.fig.savefig(fileName, format=fileFormat, dpi=dpi)\n        else:\n            self.fig.savefig(fileName, format=fileFormat)\n        self._plot._setDirtyPlot()\n\n    # Graph labels\n\n    def setGraphTitle(self, title):\n        self.ax.set_title(title)\n\n    def setGraphXLabel(self, label):\n        self.ax.set_xlabel(label)\n\n    def setGraphYLabel(self, label, axis):\n        axes = self.ax if axis == 'left' else self.ax2\n        axes.set_ylabel(label)\n\n    # Graph limits\n\n    def resetZoom(self, dataMargins):\n        xAuto = self._plot.isXAxisAutoScale()\n        yAuto = self._plot.isYAxisAutoScale()\n\n        if not xAuto and not yAuto:\n            _logger.debug(\"Nothing to autoscale\")\n        else:  # Some axes to autoscale\n            xLimits = self.getGraphXLimits()\n            yLimits = self.getGraphYLimits(axis='left')\n            y2Limits = self.getGraphYLimits(axis='right')\n\n            xmin, xmax, ymin, ymax = self._getDataLimits('left')\n            if hasattr(self.ax2, \"get_visible\"):\n                if self.ax2.get_visible():\n                    xmin2, xmax2, ymin2, ymax2 = self._getDataLimits('right')\n                else:\n                    xmin2, xmax2, ymin2, ymax2 = None, None, None, None\n            else:\n                xmin2, xmax2, ymin2, ymax2 = self._getDataLimits('right')\n\n            if (xmin2 is not None) and ((xmin2 != 0) or (xmax2 != 1)):\n                xmin = min(xmin, xmin2)\n                xmax = max(xmax, xmax2)\n\n            # Add margins around data inside the plot area\n            newLimits = _utils.addMarginsToLimits(\n                dataMargins,\n                self.ax.get_xscale() == 'log',\n                self.ax.get_yscale() == 'log',\n                xmin, xmax, ymin, ymax, ymin2, ymax2)\n\n            self.setLimits(*newLimits)\n\n            if not xAuto and yAuto:\n                self.setGraphXLimits(*xLimits)\n            elif xAuto and not yAuto:\n                self.setGraphYLimits(yLimits[0], yLimits[1], axis='left')\n                self.setGraphYLimits(y2Limits[0], y2Limits[1], axis='right')\n\n    def _getDataLimits(self, axesLabel='left'):\n        \"\"\"Returns the bounds of the data.\n\n        :param str axesLabel: The Y axis to consider in 'left', 'right'\n        :return: The data bounds\n        :rtype: 4-tuple of float (xmin, xmax, ymin, ymax)\n        \"\"\"\n        if axesLabel == 'right':\n            axes = self.ax2\n        else:\n            axes = self.ax\n        _logger.debug(\"CALCULATING limits %s\", axes.get_label())\n        xmin = None\n\n        for line2d in axes.lines:\n            label = line2d.get_label()\n            if label.startswith(\"__MARKER__\"):\n                # it is a marker\n                continue\n            lineXMin = None\n            if hasattr(line2d, \"_plot_info\"):\n                if line2d._plot_info[\"axes\"] != axesLabel:\n                    continue\n                if \"xmin\" in line2d._plot_info:\n                    lineXMin = line2d._plot_info[\"xmin\"]\n                    lineXMax = line2d._plot_info[\"xmax\"]\n                    lineYMin = line2d._plot_info[\"ymin\"]\n                    lineYMax = line2d._plot_info[\"ymax\"]\n            if lineXMin is None:\n                x = line2d.get_xdata()\n                y = line2d.get_ydata()\n                if not len(x) or not len(y):\n                    continue\n                lineXMin = numpy.nanmin(x)\n                lineXMax = numpy.nanmax(x)\n                lineYMin = numpy.nanmin(y)\n                lineYMax = numpy.nanmax(y)\n            if xmin is None:\n                xmin = lineXMin\n                xmax = lineXMax\n                ymin = lineYMin\n                ymax = lineYMax\n                continue\n            xmin = min(xmin, lineXMin)\n            xmax = max(xmax, lineXMax)\n            ymin = min(ymin, lineYMin)\n            ymax = max(ymax, lineYMax)\n\n        for line2d in axes.collections:\n            label = line2d.get_label()\n            if label.startswith(\"__MARKER__\"):\n                # it is a marker\n                continue\n            lineXMin = None\n            if hasattr(line2d, \"_plot_info\"):\n                if line2d._plot_info[\"axes\"] != axesLabel:\n                    continue\n                if \"xmin\" in line2d._plot_info:\n                    lineXMin = line2d._plot_info[\"xmin\"]\n                    lineXMax = line2d._plot_info[\"xmax\"]\n                    lineYMin = line2d._plot_info[\"ymin\"]\n                    lineYMax = line2d._plot_info[\"ymax\"]\n            if lineXMin is None:\n                _logger.debug(\"CANNOT CALCULATE LIMITS\")\n                continue\n            if xmin is None:\n                xmin = lineXMin\n                xmax = lineXMax\n                ymin = lineYMin\n                ymax = lineYMax\n                continue\n            xmin = min(xmin, lineXMin)\n            xmax = max(xmax, lineXMax)\n            ymin = min(ymin, lineYMin)\n            ymax = max(ymax, lineYMax)\n\n        for artist in axes.images:\n            x0, x1, y0, y1 = artist.get_extent()\n            if (xmin is None):\n                xmin = x0\n                xmax = x1\n                ymin = min(y0, y1)\n                ymax = max(y0, y1)\n            xmin = min(xmin, x0)\n            xmax = max(xmax, x1)\n            ymin = min(ymin, y0)\n            ymax = max(ymax, y1)\n\n        for artist in axes.artists:\n            label = artist.get_label()\n            if label.startswith(\"__IMAGE__\"):\n                if hasattr(artist, 'get_image_extent'):\n                    x0, x1, y0, y1 = artist.get_image_extent()\n                else:\n                    x0, x1, y0, y1 = artist.get_extent()\n                if (xmin is None):\n                    xmin = x0\n                    xmax = x1\n                    ymin = min(y0, y1)\n                    ymax = max(y0, y1)\n                ymin = min(ymin, y0, y1)\n                ymax = max(ymax, y1, y0)\n                xmin = min(xmin, x0)\n                xmax = max(xmax, x1)\n\n        if xmin is None:\n            _logger.debug('Did not found any limits, set to default')\n            xmin = 1\n            xmax = 100\n            ymin = 1\n            ymax = 100\n            if axesLabel == 'right':\n                _logger.debug('Returning None')\n                return None, None, None, None\n\n        xSize = float(xmax - xmin)\n        ySize = float(ymax - ymin)\n        A = self.ax.get_aspect()\n        if A != 'auto':\n            figW, figH = self.fig.get_size_inches()\n            figAspect = figH / figW\n\n            dataRatio = (ySize / xSize) * A\n\n            y_expander = dataRatio - figAspect\n            # If y_expander > 0, the dy/dx viewLim ratio needs to increase\n            if abs(y_expander) < 0.005:\n                # good enough\n                pass\n            else:\n                # this works for any data ratio\n                if y_expander < 0:\n                    deltaY = xSize * (figAspect / A) - ySize\n                    yc = 0.5 * (ymin + ymax)\n                    ymin = yc - (ySize + deltaY) * 0.5\n                    ymax = yc + (ySize + deltaY) * 0.5\n                else:\n                    deltaX = ySize * (A / figAspect) - xSize\n                    xc = 0.5 * (xmin + xmax)\n                    xmin = xc - (xSize + deltaX) * 0.5\n                    xmax = xc + (xSize + deltaX) * 0.5\n        _logger.debug(\n            \"CALCULATED LIMITS = %f %f %f %f\", xmin, xmax, ymin, ymax)\n        return xmin, xmax, ymin, ymax\n\n    def setLimits(self, xmin, xmax, ymin, ymax, y2min=None, y2max=None):\n        self.setGraphXLimits(xmin, xmax)\n        self.setGraphYLimits(ymin, ymax, axis='left')\n\n        if y2min is not None and y2max is not None:\n            self.setGraphYLimits(ymin, ymax, axis='right')\n\n    def getGraphXLimits(self):\n        vmin, vmax = self.ax.get_xlim()\n        if vmin > vmax:\n            return vmax, vmin\n        else:\n            return vmin, vmax\n\n    def setGraphXLimits(self, xmin, xmax):\n        if xmax < xmin:\n            xmin, xmax = xmax, xmin\n        self.ax.set_xlim(xmin, xmax)\n\n    def getGraphYLimits(self, axis):\n        assert axis in ('left', 'right')\n        ax = self.ax2 if axis == 'right' else self.ax\n\n        if not ax.get_visible():\n            return None\n\n        vmin, vmax = ax.get_ylim()\n        if vmin > vmax:\n            return vmax, vmin\n        else:\n            return vmin, vmax\n\n    def setGraphYLimits(self, ymin, ymax, axis):\n        ax = self.ax2 if axis == 'right' else self.ax\n        if ymax < ymin:\n            ymin, ymax = ymax, ymin\n        if ax.yaxis_inverted():\n            ax.set_ylim(ymax, ymin)\n        else:\n            ax.set_ylim(ymin, ymax)\n\n    # Graph axes\n\n    def setXAxisLogarithmic(self, flag):\n        self.ax2.set_xscale('log' if flag else 'linear')\n        self.ax.set_xscale('log' if flag else 'linear')\n\n    def setYAxisLogarithmic(self, flag):\n        self.ax2.set_yscale('log' if flag else 'linear')\n        self.ax.set_yscale('log' if flag else 'linear')\n\n    def setYAxisInverted(self, flag):\n        if self.ax.yaxis_inverted() != bool(flag):\n            self.ax.invert_yaxis()\n\n    def isYAxisInverted(self):\n        return self.ax.yaxis_inverted()\n\n    def isKeepDataAspectRatio(self):\n        return self.ax.get_aspect() in (1.0, 'equal')\n\n    def setKeepDataAspectRatio(self, flag):\n        self.ax.set_aspect(1.0 if flag else 'auto')\n\n    def setGraphGrid(self, which):\n        self.ax.grid(False, which='both')  # Disable all grid first\n        if which is not None:\n            self.ax.grid(True, which=which)\n\n    # colormap\n\n    def getSupportedColormaps(self):\n        default = super(BackendMatplotlib, self).getSupportedColormaps()\n        maps = [m for m in cm.datad]\n        maps.sort()\n        return default + maps\n\n    def __getColormap(self, name):\n        if not self._colormaps:  # Lazy initialization of own colormaps\n            cdict = {'red': ((0.0, 0.0, 0.0),\n                             (1.0, 1.0, 1.0)),\n                     'green': ((0.0, 0.0, 0.0),\n                               (1.0, 0.0, 0.0)),\n                     'blue': ((0.0, 0.0, 0.0),\n                              (1.0, 0.0, 0.0))}\n            self._colormaps['red'] = LinearSegmentedColormap(\n                'red', cdict, 256)\n\n            cdict = {'red': ((0.0, 0.0, 0.0),\n                             (1.0, 0.0, 0.0)),\n                     'green': ((0.0, 0.0, 0.0),\n                               (1.0, 1.0, 1.0)),\n                     'blue': ((0.0, 0.0, 0.0),\n                              (1.0, 0.0, 0.0))}\n            self._colormaps['green'] = LinearSegmentedColormap(\n                'green', cdict, 256)\n\n            cdict = {'red': ((0.0, 0.0, 0.0),\n                             (1.0, 0.0, 0.0)),\n                     'green': ((0.0, 0.0, 0.0),\n                               (1.0, 0.0, 0.0)),\n                     'blue': ((0.0, 0.0, 0.0),\n                              (1.0, 1.0, 1.0))}\n            self._colormaps['blue'] = LinearSegmentedColormap(\n                'blue', cdict, 256)\n\n            # Temperature as defined in spslut\n            cdict = {'red': ((0.0, 0.0, 0.0),\n                             (0.5, 0.0, 0.0),\n                             (0.75, 1.0, 1.0),\n                             (1.0, 1.0, 1.0)),\n                     'green': ((0.0, 0.0, 0.0),\n                               (0.25, 1.0, 1.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0, 0.0, 0.0)),\n                     'blue': ((0.0, 1.0, 1.0),\n                              (0.25, 1.0, 1.0),\n                              (0.5, 0.0, 0.0),\n                              (1.0, 0.0, 0.0))}\n            # but limited to 256 colors for a faster display (of the colorbar)\n            self._colormaps['temperature'] = LinearSegmentedColormap(\n                'temperature', cdict, 256)\n\n            # reversed gray\n            cdict = {'red':     ((0.0, 1.0, 1.0),\n                                 (1.0, 0.0, 0.0)),\n                     'green':   ((0.0, 1.0, 1.0),\n                                 (1.0, 0.0, 0.0)),\n                     'blue':    ((0.0, 1.0, 1.0),\n                                 (1.0, 0.0, 0.0))}\n\n            self._colormaps['reversed gray'] = LinearSegmentedColormap(\n                'yerg', cdict, 256)\n\n        if name in self._colormaps:\n            return self._colormaps[name]\n        else:\n            # matplotlib built-in\n            return cm.get_cmap(name)\n\n    # Data <-> Pixel coordinates conversion\n\n    def dataToPixel(self, x, y, axis):\n        ax = self.ax2 if \"axis\" == \"right\" else self.ax\n\n        pixels = ax.transData.transform_point((x, y))\n        xPixel, yPixel = pixels.T\n        return xPixel, yPixel\n\n    def pixelToData(self, x, y, axis, check):\n        ax = self.ax2 if \"axis\" == \"right\" else self.ax\n\n        inv = ax.transData.inverted()\n        x, y = inv.transform_point((x, y))\n\n        xmin, xmax = self.getGraphXLimits()\n        ymin, ymax = self.getGraphYLimits(axis=axis)\n\n        if check and (x > xmax or x < xmin or y > ymax or y < ymin):\n            return None  # (x, y) is out of plot area\n\n        return x, y\n\n    def getPlotBoundsInPixels(self):\n        bbox = self.ax.get_window_extent().transformed(\n            self.fig.dpi_scale_trans.inverted())\n        dpi = self.fig.dpi\n        # Warning this is not returning int...\n        return (bbox.bounds[0] * dpi, bbox.bounds[1] * dpi,\n                bbox.bounds[2] * dpi, bbox.bounds[3] * dpi)",
  "class BackendMatplotlibQt(FigureCanvasQTAgg, BackendMatplotlib):\n    \"\"\"QWidget matplotlib backend using a QtAgg canvas.\n\n    It adds fast overlay drawing and mouse event management.\n    \"\"\"\n\n    _sigPostRedisplay = qt.Signal()\n    \"\"\"Signal handling automatic asynchronous replot\"\"\"\n\n    def __init__(self, plot, parent=None):\n        self._insideResizeEventMethod = False\n\n        BackendMatplotlib.__init__(self, plot, parent)\n        FigureCanvasQTAgg.__init__(self, self.fig)\n        self.setParent(parent)\n\n        FigureCanvasQTAgg.setSizePolicy(\n            self, qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding)\n        FigureCanvasQTAgg.updateGeometry(self)\n\n        # Make postRedisplay asynchronous using Qt signal\n        self._sigPostRedisplay.connect(\n            super(BackendMatplotlibQt, self).postRedisplay,\n            qt.Qt.QueuedConnection)\n\n        self.mpl_connect('button_press_event', self._onMousePress)\n        self.mpl_connect('button_release_event', self._onMouseRelease)\n        self.mpl_connect('motion_notify_event', self._onMouseMove)\n        self.mpl_connect('scroll_event', self._onMouseWheel)\n\n    def postRedisplay(self):\n        self._sigPostRedisplay.emit()\n\n    # Mouse event forwarding\n\n    _MPL_TO_PLOT_BUTTONS = {1: 'left', 2: 'middle', 3: 'right'}\n\n    def _onMousePress(self, event):\n        self._plot.onMousePress(\n            event.x, event.y, self._MPL_TO_PLOT_BUTTONS[event.button])\n\n    def _onMouseMove(self, event):\n        if self._graphCursor:\n            lineh, linev = self._graphCursor\n            if event.inaxes != self.ax and lineh.get_visible():\n                lineh.set_visible(False)\n                linev.set_visible(False)\n                self._plot._setDirtyPlot(overlayOnly=True)\n            else:\n                linev.set_visible(True)\n                linev.set_xdata((event.xdata, event.xdata))\n                lineh.set_visible(True)\n                lineh.set_ydata((event.ydata, event.ydata))\n                self._plot._setDirtyPlot(overlayOnly=True)\n            # onMouseMove must trigger replot if dirty flag is raised\n\n        self._plot.onMouseMove(event.x, event.y)\n\n    def _onMouseRelease(self, event):\n        self._plot.onMouseRelease(\n            event.x, event.y, self._MPL_TO_PLOT_BUTTONS[event.button])\n\n    def _onMouseWheel(self, event):\n        self._plot.onMouseWheel(event.x, event.y, event.step)\n\n    # picking\n\n    def _onPick(self, event):\n        # TODO not very nice and fragile, find a better way?\n        # Make a selection according to kind\n        label = event.artist.get_label()\n        if label.startswith('__MARKER__'):\n            self._picked.append({'kind': 'marker', 'legend': label[10:]})\n\n        elif label.startswith('__IMAGE__'):\n            self._picked.append({'kind': 'image', 'legend': label[9:]})\n\n        else:  # it's a curve, item have no picker for now\n            if isinstance(event.artist, PathCollection):\n                data = event.artist.get_offsets()[event.ind, :]\n                xdata, ydata = data[:, 0], data[:, 1]\n            elif isinstance(event.artist, Line2D):\n                xdata = event.artist.get_xdata()[event.ind]\n                ydata = event.artist.get_ydata()[event.ind]\n            else:\n                _logger.info('Unsupported artist, ignored')\n                return\n\n            self._picked.append({'kind': 'curve', 'legend': label,\n                                 'xdata': xdata, 'ydata': ydata})\n\n    def pickItems(self, x, y):\n        self._picked = []\n\n        # Weird way to do an explicit picking: Simulate a button press event\n        mouseEvent = MouseEvent('button_press_event', self, x, y)\n        cid = self.mpl_connect('pick_event', self._onPick)\n        self.fig.pick(mouseEvent)\n        self.mpl_disconnect(cid)\n        picked = self._picked\n        del self._picked\n\n        return picked\n\n    # replot control\n\n    def resizeEvent(self, event):\n        self._insideResizeEventMethod = True\n        # Need to dirty the whole plot on resize.\n        self._plot._setDirtyPlot()\n        FigureCanvasQTAgg.resizeEvent(self, event)\n        self._insideResizeEventMethod = False\n\n    def draw(self):\n        \"\"\"Override canvas draw method to support faster draw of overlays.\"\"\"\n        if self._plot._getDirtyPlot():  # Need a full redraw\n            FigureCanvasQTAgg.draw(self)\n            self._background = None  # Any saved background is dirty\n\n        if (self._overlays or self._graphCursor or\n                self._plot._getDirtyPlot() == 'overlay'):\n            # There are overlays or crosshair, or they is just no more overlays\n\n            # Specific case: called from resizeEvent:\n            # avoid store/restore background, just draw the overlay\n            if not self._insideResizeEventMethod:\n                if self._background is None:  # First store the background\n                    self._background = self.copy_from_bbox(self.fig.bbox)\n\n                self.restore_region(self._background)\n\n            # This assume that items are only on left/bottom Axes\n            for item in self._overlays:\n                self.ax.draw_artist(item)\n\n            for item in self._graphCursor:\n                self.ax.draw_artist(item)\n\n            self.blit(self.fig.bbox)\n\n    def replot(self):\n        BackendMatplotlib.replot(self)\n        self.draw()\n\n    # cursor\n\n    _QT_CURSORS = {\n        None: qt.Qt.ArrowCursor,\n        BackendBase.CURSOR_DEFAULT: qt.Qt.ArrowCursor,\n        BackendBase.CURSOR_POINTING: qt.Qt.PointingHandCursor,\n        BackendBase.CURSOR_SIZE_HOR: qt.Qt.SizeHorCursor,\n        BackendBase.CURSOR_SIZE_VER: qt.Qt.SizeVerCursor,\n        BackendBase.CURSOR_SIZE_ALL: qt.Qt.SizeAllCursor,\n    }\n\n    def setGraphCursorShape(self, cursor):\n        cursor = self._QT_CURSORS[cursor]\n\n        FigureCanvasQTAgg.setCursor(self, qt.QCursor(cursor))",
  "def __init__(self, plot, parent=None):\n        super(BackendMatplotlib, self).__init__(plot, parent)\n\n        self.fig = Figure()\n        self.fig.set_facecolor(\"w\")\n\n        self.ax = self.fig.add_axes([.15, .15, .75, .75], label=\"left\")\n        self.ax2 = self.ax.twinx()\n        self.ax2.set_label(\"right\")\n\n        # critical for picking!!!!\n        self.ax2.set_zorder(0)\n        self.ax2.set_autoscaley_on(True)\n        self.ax.set_zorder(1)\n        # this works but the figure color is left\n        self.ax.set_axis_bgcolor('none')\n        self.fig.sca(self.ax)\n\n        self._overlays = set()\n        self._background = None\n\n        self._colormaps = {}\n\n        self._graphCursor = tuple()\n        self.matplotlibVersion = matplotlib.__version__\n\n        self.setGraphXLimits(0., 100.)\n        self.setGraphYLimits(0., 100., axis='left')\n        self.setGraphYLimits(0., 100., axis='right')\n\n        self._enableAxis('right', False)",
  "def addCurve(self, x, y, legend,\n                 color, symbol, linewidth, linestyle,\n                 yaxis,\n                 xerror, yerror, z, selectable,\n                 fill):\n        for parameter in (x, y, legend, color, symbol, linewidth, linestyle,\n                          yaxis, z, selectable, fill):\n            assert parameter is not None\n        assert yaxis in ('left', 'right')\n\n        if (len(color) == 4 and\n                type(color[3]) in [type(1), numpy.uint8, numpy.int8]):\n            color = numpy.array(color, dtype=numpy.float)/255.\n\n        if yaxis == \"right\":\n            axes = self.ax2\n            self._enableAxis(\"right\", True)\n        else:\n            axes = self.ax\n\n        picker = 3 if selectable else None\n\n        artists = []  # All the artists composing the curve\n\n        # First add errorbars if any so they are behind the curve\n        if xerror is not None or yerror is not None:\n            if hasattr(color, 'dtype') and len(color) == len(x):\n                errorbarColor = 'k'\n            else:\n                errorbarColor = color\n\n            errorbars = axes.errorbar(x, y, label=legend,\n                                      xerr=xerror, yerr=yerror,\n                                      linestyle=' ', color=errorbarColor)\n            artists += list(errorbars.get_children())\n\n        if hasattr(color, 'dtype') and len(color) == len(x):\n            # scatter plot\n            if color.dtype not in [numpy.float32, numpy.float]:\n                actualColor = color / 255.\n            else:\n                actualColor = color\n\n            if linestyle not in [\"\", \" \", None]:\n                # scatter plot with an actual line ...\n                # we need to assign a color ...\n                curveList = axes.plot(x, y, label=legend,\n                                      linestyle=linestyle,\n                                      color=actualColor[0],\n                                      linewidth=linewidth,\n                                      picker=picker,\n                                      marker=None)\n                artists += list(curveList)\n\n            scatter = axes.scatter(x, y,\n                                   label=legend,\n                                   color=actualColor,\n                                   marker=symbol,\n                                   picker=picker)\n            artists.append(scatter)\n\n            if fill:\n                artists.append(axes.fill_between(\n                    x, 1.0e-8, y, facecolor=actualColor[0], linestyle=''))\n\n        else:  # Curve\n            curveList = axes.plot(x, y,\n                                  label=legend,\n                                  linestyle=linestyle,\n                                  color=color,\n                                  linewidth=linewidth,\n                                  marker=symbol,\n                                  picker=picker)\n            artists += list(curveList)\n\n            if fill:\n                artists.append(\n                    axes.fill_between(x, 1.0e-8, y,\n                                      facecolor=color, linewidth=0))\n\n        # This complies with _getDataLimits\n        artists[-1]._plot_info = {\n            'axes': yaxis,\n            # this is needed for scatter plots because I do not know\n            # how to recover the data yet, it can speed up limits too\n            'xmin': numpy.nanmin(x),\n            'xmax': numpy.nanmax(x),\n            'ymin': numpy.nanmin(y),\n            'ymax': numpy.nanmax(y),\n        }\n\n        artists[-1].axes = axes\n\n        for artist in artists:\n            artist.set_zorder(z)\n\n        return Container(artists)",
  "def addImage(self, data, legend,\n                 origin, scale, z,\n                 selectable, draggable,\n                 colormap):\n        # Non-uniform image\n        # http://wiki.scipy.org/Cookbook/Histograms\n        # Non-linear axes\n        # http://stackoverflow.com/questions/11488800/non-linear-axes-for-imshow-in-matplotlib\n        for parameter in (data, legend, origin, scale, z,\n                          selectable, draggable):\n            assert parameter is not None\n\n        h, w = data.shape[0:2]\n        xmin = origin[0]\n        xmax = xmin + scale[0] * w\n        ymin = origin[1]\n        ymax = ymin + scale[1] * h\n        extent = (xmin, xmax, ymax, ymin)\n\n        picker = (selectable or draggable)\n\n        # the normalization can be a source of time waste\n        # Two possibilities, we receive data or a ready to show image\n        if len(data.shape) == 3:\n            if data.shape[-1] == 4:\n                # force alpha? data[:,:,3] = 255\n                pass\n\n            # RGBA image\n            # TODO: Possibility to mirror the image\n            # in case of pixmaps just setting\n            # extend = (xmin, xmax, ymax, ymin)\n            # instead of (xmin, xmax, ymin, ymax)\n            extent = (xmin, xmax, ymin, ymax)\n            if tuple(origin) != (0., 0.) or tuple(scale) != (1., 1.):\n                # for the time being not properly handled\n                imageClass = AxesImage\n            elif (data.shape[0] * data.shape[1]) > 5.0e5:\n                imageClass = ModestImage\n            else:\n                imageClass = AxesImage\n            image = imageClass(self.ax,\n                               label=\"__IMAGE__\"+legend,\n                               interpolation='nearest',\n                               picker=picker,\n                               zorder=z)\n            if image.origin == 'upper':\n                image.set_extent((xmin, xmax, ymax, ymin))\n            else:\n                image.set_extent((xmin, xmax, ymin, ymax))\n            image.set_data(data)\n\n        else:\n            assert colormap is not None\n            cmap = self.__getColormap(colormap['name'])\n            if colormap['normalization'].startswith('log'):\n                vmin, vmax = None, None\n                if not colormap['autoscale']:\n                    if colormap['vmin'] > 0.:\n                        vmin = colormap['vmin']\n                    if colormap['vmax'] > 0.:\n                        vmax = colormap['vmax']\n\n                    if vmin is None or vmax is None:\n                        _logger.warning('Log colormap with negative bounds, ' +\n                                        'changing bounds to positive ones.')\n                    elif vmin > vmax:\n                        _logger.warning('Colormap bounds are inverted.')\n                        vmin, vmax = vmax, vmin\n\n                # Set unset/negative bounds to positive bounds\n                if vmin is None or vmax is None:\n                    posData = data[data > 0]\n                    if vmax is None:\n                        # 1. as an ultimate fallback\n                        vmax = posData.max() if posData.size > 0 else 1.\n                    if vmin is None:\n                        vmin = posData.min() if posData.size > 0 else vmax\n                    if vmin > vmax:\n                        vmin = vmax\n\n                norm = LogNorm(vmin, vmax)\n\n            else:  # Linear normalization\n                if colormap['autoscale']:\n                    vmin = data.min()\n                    vmax = data.max()\n                else:\n                    vmin = colormap['vmin']\n                    vmax = colormap['vmax']\n                    if vmin > vmax:\n                        _logger.warning('Colormap bounds are inverted.')\n                        vmin, vmax = vmax, vmin\n\n                norm = Normalize(vmin, vmax)\n\n            # try as data\n            if tuple(origin) != (0., 0.) or tuple(scale) != (1., 1.):\n                # for the time being not properly handled\n                imageClass = AxesImage\n            elif (data.shape[0] * data.shape[1]) > 5.0e5:\n                imageClass = ModestImage\n            else:\n                imageClass = AxesImage\n            image = imageClass(self.ax,\n                               label=\"__IMAGE__\" + legend,\n                               interpolation='nearest',\n                               cmap=cmap,\n                               extent=extent,\n                               picker=picker,\n                               zorder=z,\n                               norm=norm)\n\n            if image.origin == 'upper':\n                image.set_extent((xmin, xmax, ymax, ymin))\n            else:\n                image.set_extent((xmin, xmax, ymin, ymax))\n\n            image.set_data(data)\n\n        self.ax.add_artist(image)\n\n        return image",
  "def addItem(self, x, y, legend, shape, color, fill, overlay):\n        xView = numpy.array(x, copy=False)\n        yView = numpy.array(y, copy=False)\n\n        if shape == \"line\":\n            item = self.ax.plot(x, y, label=legend, color=color,\n                                linestyle='-', marker=None)[0]\n\n        elif shape == \"hline\":\n            if hasattr(y, \"__len__\"):\n                y = y[-1]\n            item = self.ax.axhline(y, label=legend, color=color)\n\n        elif shape == \"vline\":\n            if hasattr(x, \"__len__\"):\n                x = x[-1]\n            item = self.ax.axvline(x, label=legend, color=color)\n\n        elif shape == 'rectangle':\n            xMin = numpy.nanmin(xView)\n            xMax = numpy.nanmax(xView)\n            yMin = numpy.nanmin(yView)\n            yMax = numpy.nanmax(yView)\n            w = xMax - xMin\n            h = yMax - yMin\n            item = Rectangle(xy=(xMin, yMin),\n                             width=w,\n                             height=h,\n                             fill=False,\n                             color=color)\n            if fill:\n                item.set_hatch('.')\n\n            self.ax.add_patch(item)\n\n        elif shape == 'polygon':\n            xView.shape = 1, -1\n            yView.shape = 1, -1\n            item = Polygon(numpy.vstack((xView, yView)).T,\n                           closed=True,\n                           fill=False,\n                           label=legend,\n                           color=color)\n            if fill:\n                item.set_hatch('/')\n\n            self.ax.add_patch(item)\n\n        else:\n            raise NotImplementedError(\"Unsupported item shape %s\" % shape)\n\n        if overlay:\n            item.set_animated(True)\n            self._overlays.add(item)\n\n        return item",
  "def addMarker(self, x, y, legend, text, color,\n                  selectable, draggable,\n                  symbol, constraint, overlay):\n        legend = \"__MARKER__\" + legend\n\n        # TODO issues with text placement when changing limits..\n        if x is not None and y is not None:\n            line = self.ax.plot(x, y, label=legend,\n                                linestyle=\" \",\n                                color=color,\n                                marker=symbol,\n                                markersize=10.)[-1]\n\n            if text is not None:\n                xtmp, ytmp = self.ax.transData.transform_point((x, y))\n                inv = self.ax.transData.inverted()\n                xtmp, ytmp = inv.transform_point((xtmp, ytmp + 15))\n                text = \" \" + text\n                line._infoText = self.ax.text(x, ytmp, text,\n                                              color=color,\n                                              horizontalalignment='left',\n                                              verticalalignment='top')\n\n        elif x is not None:\n            line = self.ax.axvline(x, label=legend, color=color)\n            if text is not None:\n                text = \" \" + text\n                ymin, ymax = self.getGraphYLimits(axis='left')\n                delta = abs(ymax - ymin)\n                if ymin > ymax:\n                    ymax = ymin\n                ymax -= 0.005 * delta\n                line._infoText = self.ax.text(x, ymax, text,\n                                              color=color,\n                                              horizontalalignment='left',\n                                              verticalalignment='top')\n\n        elif y is not None:\n            line = self.ax.axhline(y, label=legend, color=color)\n\n            if text is not None:\n                text = \" \" + text\n                xmin, xmax = self.getGraphXLimits()\n                delta = abs(xmax - xmin)\n                if xmin > xmax:\n                    xmax = xmin\n                xmax -= 0.005 * delta\n                line._infoText = self.ax.text(xmax, y, text,\n                                              color=color,\n                                              horizontalalignment='right',\n                                              verticalalignment='top')\n\n        else:\n            raise RuntimeError('A marker must at least have one coordinate')\n\n        if selectable or draggable:\n            line.set_picker(5)\n\n        if overlay:\n            line.set_animated(True)\n            self._overlays.add(line)\n\n        return line",
  "def remove(self, item):\n        # Warning: It also needs to remove extra stuff if added as for markers\n        if hasattr(item, \"_infoText\"):  # For markers text\n            item._infoText.remove()\n            item._infoText = None\n        self._overlays.discard(item)\n        item.remove()",
  "def setGraphCursor(self, flag, color, linewidth, linestyle):\n        if flag:\n            lineh = self.ax.axhline(\n                self.ax.get_ybound()[0], visible=False, color=color,\n                linewidth=linewidth, linestyle=linestyle)\n            lineh.set_animated(True)\n\n            linev = self.ax.axvline(\n                self.ax.get_xbound()[0], visible=False, color=color,\n                linewidth=linewidth, linestyle=linestyle)\n            linev.set_animated(True)\n\n            self._graphCursor = lineh, linev\n        else:\n            if self._graphCursor is not None:\n                lineh, linev = self._graphCursor\n                lineh.remove()\n                linev.remove()\n                self._graphCursor = tuple()",
  "def setActiveCurve(self, curve, active, color=None):\n        # Store Line2D and PathCollection\n        for artist in curve.get_children():\n            if active:\n                if isinstance(artist, (Line2D, LineCollection)):\n                    artist._initialColor = artist.get_color()\n                    artist.set_color(color)\n                elif isinstance(artist, PathCollection):\n                    artist._initialColor = artist.get_facecolors()\n                    artist.set_facecolors(color)\n                    artist.set_edgecolors(color)\n                else:\n                    _logger.warning(\n                        'setActiveCurve ignoring artist %s', str(artist))\n            else:\n                if hasattr(artist, '_initialColor'):\n                    if isinstance(artist, (Line2D, LineCollection)):\n                        artist.set_color(artist._initialColor)\n                    elif isinstance(artist, PathCollection):\n                        artist.set_facecolors(artist._initialColor)\n                        artist.set_edgecolors(artist._initialColor)\n                    else:\n                        _logger.info(\n                            'setActiveCurve ignoring artist %s', str(artist))\n                    del artist._initialColor",
  "def getWidgetHandle(self):\n        return self.fig.canvas",
  "def _enableAxis(self, axis, flag=True):\n        \"\"\"Show/hide Y axis\n\n        :param str axis: Axis name: 'left' or 'right'\n        :param bool flag: Default, True\n        \"\"\"\n        assert axis in ('right', 'left')\n        axes = self.ax2 if axis == 'right' else self.ax\n        axes.get_yaxis().set_visible(flag)",
  "def replot(self):\n        \"\"\"Do not perform rendering.\n\n        Override in subclass to actually draw something.\n        \"\"\"\n        # TODO images, markers? scatter plot? move in remove?\n        # Right Y axis only support curve for now\n        # Hide right Y axis if no line is present\n        if not self.ax2.lines:\n            self._enableAxis('right', False)",
  "def saveGraph(self, fileName, fileFormat, dpi):\n        # fileName can be also a StringIO or file instance\n        if dpi is not None:\n            self.fig.savefig(fileName, format=fileFormat, dpi=dpi)\n        else:\n            self.fig.savefig(fileName, format=fileFormat)\n        self._plot._setDirtyPlot()",
  "def setGraphTitle(self, title):\n        self.ax.set_title(title)",
  "def setGraphXLabel(self, label):\n        self.ax.set_xlabel(label)",
  "def setGraphYLabel(self, label, axis):\n        axes = self.ax if axis == 'left' else self.ax2\n        axes.set_ylabel(label)",
  "def resetZoom(self, dataMargins):\n        xAuto = self._plot.isXAxisAutoScale()\n        yAuto = self._plot.isYAxisAutoScale()\n\n        if not xAuto and not yAuto:\n            _logger.debug(\"Nothing to autoscale\")\n        else:  # Some axes to autoscale\n            xLimits = self.getGraphXLimits()\n            yLimits = self.getGraphYLimits(axis='left')\n            y2Limits = self.getGraphYLimits(axis='right')\n\n            xmin, xmax, ymin, ymax = self._getDataLimits('left')\n            if hasattr(self.ax2, \"get_visible\"):\n                if self.ax2.get_visible():\n                    xmin2, xmax2, ymin2, ymax2 = self._getDataLimits('right')\n                else:\n                    xmin2, xmax2, ymin2, ymax2 = None, None, None, None\n            else:\n                xmin2, xmax2, ymin2, ymax2 = self._getDataLimits('right')\n\n            if (xmin2 is not None) and ((xmin2 != 0) or (xmax2 != 1)):\n                xmin = min(xmin, xmin2)\n                xmax = max(xmax, xmax2)\n\n            # Add margins around data inside the plot area\n            newLimits = _utils.addMarginsToLimits(\n                dataMargins,\n                self.ax.get_xscale() == 'log',\n                self.ax.get_yscale() == 'log',\n                xmin, xmax, ymin, ymax, ymin2, ymax2)\n\n            self.setLimits(*newLimits)\n\n            if not xAuto and yAuto:\n                self.setGraphXLimits(*xLimits)\n            elif xAuto and not yAuto:\n                self.setGraphYLimits(yLimits[0], yLimits[1], axis='left')\n                self.setGraphYLimits(y2Limits[0], y2Limits[1], axis='right')",
  "def _getDataLimits(self, axesLabel='left'):\n        \"\"\"Returns the bounds of the data.\n\n        :param str axesLabel: The Y axis to consider in 'left', 'right'\n        :return: The data bounds\n        :rtype: 4-tuple of float (xmin, xmax, ymin, ymax)\n        \"\"\"\n        if axesLabel == 'right':\n            axes = self.ax2\n        else:\n            axes = self.ax\n        _logger.debug(\"CALCULATING limits %s\", axes.get_label())\n        xmin = None\n\n        for line2d in axes.lines:\n            label = line2d.get_label()\n            if label.startswith(\"__MARKER__\"):\n                # it is a marker\n                continue\n            lineXMin = None\n            if hasattr(line2d, \"_plot_info\"):\n                if line2d._plot_info[\"axes\"] != axesLabel:\n                    continue\n                if \"xmin\" in line2d._plot_info:\n                    lineXMin = line2d._plot_info[\"xmin\"]\n                    lineXMax = line2d._plot_info[\"xmax\"]\n                    lineYMin = line2d._plot_info[\"ymin\"]\n                    lineYMax = line2d._plot_info[\"ymax\"]\n            if lineXMin is None:\n                x = line2d.get_xdata()\n                y = line2d.get_ydata()\n                if not len(x) or not len(y):\n                    continue\n                lineXMin = numpy.nanmin(x)\n                lineXMax = numpy.nanmax(x)\n                lineYMin = numpy.nanmin(y)\n                lineYMax = numpy.nanmax(y)\n            if xmin is None:\n                xmin = lineXMin\n                xmax = lineXMax\n                ymin = lineYMin\n                ymax = lineYMax\n                continue\n            xmin = min(xmin, lineXMin)\n            xmax = max(xmax, lineXMax)\n            ymin = min(ymin, lineYMin)\n            ymax = max(ymax, lineYMax)\n\n        for line2d in axes.collections:\n            label = line2d.get_label()\n            if label.startswith(\"__MARKER__\"):\n                # it is a marker\n                continue\n            lineXMin = None\n            if hasattr(line2d, \"_plot_info\"):\n                if line2d._plot_info[\"axes\"] != axesLabel:\n                    continue\n                if \"xmin\" in line2d._plot_info:\n                    lineXMin = line2d._plot_info[\"xmin\"]\n                    lineXMax = line2d._plot_info[\"xmax\"]\n                    lineYMin = line2d._plot_info[\"ymin\"]\n                    lineYMax = line2d._plot_info[\"ymax\"]\n            if lineXMin is None:\n                _logger.debug(\"CANNOT CALCULATE LIMITS\")\n                continue\n            if xmin is None:\n                xmin = lineXMin\n                xmax = lineXMax\n                ymin = lineYMin\n                ymax = lineYMax\n                continue\n            xmin = min(xmin, lineXMin)\n            xmax = max(xmax, lineXMax)\n            ymin = min(ymin, lineYMin)\n            ymax = max(ymax, lineYMax)\n\n        for artist in axes.images:\n            x0, x1, y0, y1 = artist.get_extent()\n            if (xmin is None):\n                xmin = x0\n                xmax = x1\n                ymin = min(y0, y1)\n                ymax = max(y0, y1)\n            xmin = min(xmin, x0)\n            xmax = max(xmax, x1)\n            ymin = min(ymin, y0)\n            ymax = max(ymax, y1)\n\n        for artist in axes.artists:\n            label = artist.get_label()\n            if label.startswith(\"__IMAGE__\"):\n                if hasattr(artist, 'get_image_extent'):\n                    x0, x1, y0, y1 = artist.get_image_extent()\n                else:\n                    x0, x1, y0, y1 = artist.get_extent()\n                if (xmin is None):\n                    xmin = x0\n                    xmax = x1\n                    ymin = min(y0, y1)\n                    ymax = max(y0, y1)\n                ymin = min(ymin, y0, y1)\n                ymax = max(ymax, y1, y0)\n                xmin = min(xmin, x0)\n                xmax = max(xmax, x1)\n\n        if xmin is None:\n            _logger.debug('Did not found any limits, set to default')\n            xmin = 1\n            xmax = 100\n            ymin = 1\n            ymax = 100\n            if axesLabel == 'right':\n                _logger.debug('Returning None')\n                return None, None, None, None\n\n        xSize = float(xmax - xmin)\n        ySize = float(ymax - ymin)\n        A = self.ax.get_aspect()\n        if A != 'auto':\n            figW, figH = self.fig.get_size_inches()\n            figAspect = figH / figW\n\n            dataRatio = (ySize / xSize) * A\n\n            y_expander = dataRatio - figAspect\n            # If y_expander > 0, the dy/dx viewLim ratio needs to increase\n            if abs(y_expander) < 0.005:\n                # good enough\n                pass\n            else:\n                # this works for any data ratio\n                if y_expander < 0:\n                    deltaY = xSize * (figAspect / A) - ySize\n                    yc = 0.5 * (ymin + ymax)\n                    ymin = yc - (ySize + deltaY) * 0.5\n                    ymax = yc + (ySize + deltaY) * 0.5\n                else:\n                    deltaX = ySize * (A / figAspect) - xSize\n                    xc = 0.5 * (xmin + xmax)\n                    xmin = xc - (xSize + deltaX) * 0.5\n                    xmax = xc + (xSize + deltaX) * 0.5\n        _logger.debug(\n            \"CALCULATED LIMITS = %f %f %f %f\", xmin, xmax, ymin, ymax)\n        return xmin, xmax, ymin, ymax",
  "def setLimits(self, xmin, xmax, ymin, ymax, y2min=None, y2max=None):\n        self.setGraphXLimits(xmin, xmax)\n        self.setGraphYLimits(ymin, ymax, axis='left')\n\n        if y2min is not None and y2max is not None:\n            self.setGraphYLimits(ymin, ymax, axis='right')",
  "def getGraphXLimits(self):\n        vmin, vmax = self.ax.get_xlim()\n        if vmin > vmax:\n            return vmax, vmin\n        else:\n            return vmin, vmax",
  "def setGraphXLimits(self, xmin, xmax):\n        if xmax < xmin:\n            xmin, xmax = xmax, xmin\n        self.ax.set_xlim(xmin, xmax)",
  "def getGraphYLimits(self, axis):\n        assert axis in ('left', 'right')\n        ax = self.ax2 if axis == 'right' else self.ax\n\n        if not ax.get_visible():\n            return None\n\n        vmin, vmax = ax.get_ylim()\n        if vmin > vmax:\n            return vmax, vmin\n        else:\n            return vmin, vmax",
  "def setGraphYLimits(self, ymin, ymax, axis):\n        ax = self.ax2 if axis == 'right' else self.ax\n        if ymax < ymin:\n            ymin, ymax = ymax, ymin\n        if ax.yaxis_inverted():\n            ax.set_ylim(ymax, ymin)\n        else:\n            ax.set_ylim(ymin, ymax)",
  "def setXAxisLogarithmic(self, flag):\n        self.ax2.set_xscale('log' if flag else 'linear')\n        self.ax.set_xscale('log' if flag else 'linear')",
  "def setYAxisLogarithmic(self, flag):\n        self.ax2.set_yscale('log' if flag else 'linear')\n        self.ax.set_yscale('log' if flag else 'linear')",
  "def setYAxisInverted(self, flag):\n        if self.ax.yaxis_inverted() != bool(flag):\n            self.ax.invert_yaxis()",
  "def isYAxisInverted(self):\n        return self.ax.yaxis_inverted()",
  "def isKeepDataAspectRatio(self):\n        return self.ax.get_aspect() in (1.0, 'equal')",
  "def setKeepDataAspectRatio(self, flag):\n        self.ax.set_aspect(1.0 if flag else 'auto')",
  "def setGraphGrid(self, which):\n        self.ax.grid(False, which='both')  # Disable all grid first\n        if which is not None:\n            self.ax.grid(True, which=which)",
  "def getSupportedColormaps(self):\n        default = super(BackendMatplotlib, self).getSupportedColormaps()\n        maps = [m for m in cm.datad]\n        maps.sort()\n        return default + maps",
  "def __getColormap(self, name):\n        if not self._colormaps:  # Lazy initialization of own colormaps\n            cdict = {'red': ((0.0, 0.0, 0.0),\n                             (1.0, 1.0, 1.0)),\n                     'green': ((0.0, 0.0, 0.0),\n                               (1.0, 0.0, 0.0)),\n                     'blue': ((0.0, 0.0, 0.0),\n                              (1.0, 0.0, 0.0))}\n            self._colormaps['red'] = LinearSegmentedColormap(\n                'red', cdict, 256)\n\n            cdict = {'red': ((0.0, 0.0, 0.0),\n                             (1.0, 0.0, 0.0)),\n                     'green': ((0.0, 0.0, 0.0),\n                               (1.0, 1.0, 1.0)),\n                     'blue': ((0.0, 0.0, 0.0),\n                              (1.0, 0.0, 0.0))}\n            self._colormaps['green'] = LinearSegmentedColormap(\n                'green', cdict, 256)\n\n            cdict = {'red': ((0.0, 0.0, 0.0),\n                             (1.0, 0.0, 0.0)),\n                     'green': ((0.0, 0.0, 0.0),\n                               (1.0, 0.0, 0.0)),\n                     'blue': ((0.0, 0.0, 0.0),\n                              (1.0, 1.0, 1.0))}\n            self._colormaps['blue'] = LinearSegmentedColormap(\n                'blue', cdict, 256)\n\n            # Temperature as defined in spslut\n            cdict = {'red': ((0.0, 0.0, 0.0),\n                             (0.5, 0.0, 0.0),\n                             (0.75, 1.0, 1.0),\n                             (1.0, 1.0, 1.0)),\n                     'green': ((0.0, 0.0, 0.0),\n                               (0.25, 1.0, 1.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0, 0.0, 0.0)),\n                     'blue': ((0.0, 1.0, 1.0),\n                              (0.25, 1.0, 1.0),\n                              (0.5, 0.0, 0.0),\n                              (1.0, 0.0, 0.0))}\n            # but limited to 256 colors for a faster display (of the colorbar)\n            self._colormaps['temperature'] = LinearSegmentedColormap(\n                'temperature', cdict, 256)\n\n            # reversed gray\n            cdict = {'red':     ((0.0, 1.0, 1.0),\n                                 (1.0, 0.0, 0.0)),\n                     'green':   ((0.0, 1.0, 1.0),\n                                 (1.0, 0.0, 0.0)),\n                     'blue':    ((0.0, 1.0, 1.0),\n                                 (1.0, 0.0, 0.0))}\n\n            self._colormaps['reversed gray'] = LinearSegmentedColormap(\n                'yerg', cdict, 256)\n\n        if name in self._colormaps:\n            return self._colormaps[name]\n        else:\n            # matplotlib built-in\n            return cm.get_cmap(name)",
  "def dataToPixel(self, x, y, axis):\n        ax = self.ax2 if \"axis\" == \"right\" else self.ax\n\n        pixels = ax.transData.transform_point((x, y))\n        xPixel, yPixel = pixels.T\n        return xPixel, yPixel",
  "def pixelToData(self, x, y, axis, check):\n        ax = self.ax2 if \"axis\" == \"right\" else self.ax\n\n        inv = ax.transData.inverted()\n        x, y = inv.transform_point((x, y))\n\n        xmin, xmax = self.getGraphXLimits()\n        ymin, ymax = self.getGraphYLimits(axis=axis)\n\n        if check and (x > xmax or x < xmin or y > ymax or y < ymin):\n            return None  # (x, y) is out of plot area\n\n        return x, y",
  "def getPlotBoundsInPixels(self):\n        bbox = self.ax.get_window_extent().transformed(\n            self.fig.dpi_scale_trans.inverted())\n        dpi = self.fig.dpi\n        # Warning this is not returning int...\n        return (bbox.bounds[0] * dpi, bbox.bounds[1] * dpi,\n                bbox.bounds[2] * dpi, bbox.bounds[3] * dpi)",
  "def __init__(self, plot, parent=None):\n        self._insideResizeEventMethod = False\n\n        BackendMatplotlib.__init__(self, plot, parent)\n        FigureCanvasQTAgg.__init__(self, self.fig)\n        self.setParent(parent)\n\n        FigureCanvasQTAgg.setSizePolicy(\n            self, qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding)\n        FigureCanvasQTAgg.updateGeometry(self)\n\n        # Make postRedisplay asynchronous using Qt signal\n        self._sigPostRedisplay.connect(\n            super(BackendMatplotlibQt, self).postRedisplay,\n            qt.Qt.QueuedConnection)\n\n        self.mpl_connect('button_press_event', self._onMousePress)\n        self.mpl_connect('button_release_event', self._onMouseRelease)\n        self.mpl_connect('motion_notify_event', self._onMouseMove)\n        self.mpl_connect('scroll_event', self._onMouseWheel)",
  "def postRedisplay(self):\n        self._sigPostRedisplay.emit()",
  "def _onMousePress(self, event):\n        self._plot.onMousePress(\n            event.x, event.y, self._MPL_TO_PLOT_BUTTONS[event.button])",
  "def _onMouseMove(self, event):\n        if self._graphCursor:\n            lineh, linev = self._graphCursor\n            if event.inaxes != self.ax and lineh.get_visible():\n                lineh.set_visible(False)\n                linev.set_visible(False)\n                self._plot._setDirtyPlot(overlayOnly=True)\n            else:\n                linev.set_visible(True)\n                linev.set_xdata((event.xdata, event.xdata))\n                lineh.set_visible(True)\n                lineh.set_ydata((event.ydata, event.ydata))\n                self._plot._setDirtyPlot(overlayOnly=True)\n            # onMouseMove must trigger replot if dirty flag is raised\n\n        self._plot.onMouseMove(event.x, event.y)",
  "def _onMouseRelease(self, event):\n        self._plot.onMouseRelease(\n            event.x, event.y, self._MPL_TO_PLOT_BUTTONS[event.button])",
  "def _onMouseWheel(self, event):\n        self._plot.onMouseWheel(event.x, event.y, event.step)",
  "def _onPick(self, event):\n        # TODO not very nice and fragile, find a better way?\n        # Make a selection according to kind\n        label = event.artist.get_label()\n        if label.startswith('__MARKER__'):\n            self._picked.append({'kind': 'marker', 'legend': label[10:]})\n\n        elif label.startswith('__IMAGE__'):\n            self._picked.append({'kind': 'image', 'legend': label[9:]})\n\n        else:  # it's a curve, item have no picker for now\n            if isinstance(event.artist, PathCollection):\n                data = event.artist.get_offsets()[event.ind, :]\n                xdata, ydata = data[:, 0], data[:, 1]\n            elif isinstance(event.artist, Line2D):\n                xdata = event.artist.get_xdata()[event.ind]\n                ydata = event.artist.get_ydata()[event.ind]\n            else:\n                _logger.info('Unsupported artist, ignored')\n                return\n\n            self._picked.append({'kind': 'curve', 'legend': label,\n                                 'xdata': xdata, 'ydata': ydata})",
  "def pickItems(self, x, y):\n        self._picked = []\n\n        # Weird way to do an explicit picking: Simulate a button press event\n        mouseEvent = MouseEvent('button_press_event', self, x, y)\n        cid = self.mpl_connect('pick_event', self._onPick)\n        self.fig.pick(mouseEvent)\n        self.mpl_disconnect(cid)\n        picked = self._picked\n        del self._picked\n\n        return picked",
  "def resizeEvent(self, event):\n        self._insideResizeEventMethod = True\n        # Need to dirty the whole plot on resize.\n        self._plot._setDirtyPlot()\n        FigureCanvasQTAgg.resizeEvent(self, event)\n        self._insideResizeEventMethod = False",
  "def draw(self):\n        \"\"\"Override canvas draw method to support faster draw of overlays.\"\"\"\n        if self._plot._getDirtyPlot():  # Need a full redraw\n            FigureCanvasQTAgg.draw(self)\n            self._background = None  # Any saved background is dirty\n\n        if (self._overlays or self._graphCursor or\n                self._plot._getDirtyPlot() == 'overlay'):\n            # There are overlays or crosshair, or they is just no more overlays\n\n            # Specific case: called from resizeEvent:\n            # avoid store/restore background, just draw the overlay\n            if not self._insideResizeEventMethod:\n                if self._background is None:  # First store the background\n                    self._background = self.copy_from_bbox(self.fig.bbox)\n\n                self.restore_region(self._background)\n\n            # This assume that items are only on left/bottom Axes\n            for item in self._overlays:\n                self.ax.draw_artist(item)\n\n            for item in self._graphCursor:\n                self.ax.draw_artist(item)\n\n            self.blit(self.fig.bbox)",
  "def replot(self):\n        BackendMatplotlib.replot(self)\n        self.draw()",
  "def setGraphCursorShape(self, cursor):\n        cursor = self._QT_CURSORS[cursor]\n\n        FigureCanvasQTAgg.setCursor(self, qt.QCursor(cursor))",
  "class PositionInfo(qt.QWidget):\n    \"\"\"QWidget displaying coords converted from data coords of the mouse.\n\n    Provide this widget with a list of couple:\n\n    - A name to display before the data\n    - A function that takes (x, y) as arguments and returns something that\n      gets converted to a string.\n      If the result is a float it is converted with '%.7g' format.\n\n    To run the following sample code, a QApplication must be initialized.\n    First, create a PlotWindow and add a QToolBar where to place the\n    PositionInfo widget.\n\n    >>> from silx.gui.plot import PlotWindow\n    >>> from silx.gui import qt\n\n    >>> plot = PlotWindow()  # Create a PlotWindow to add the widget to\n    >>> toolBar = qt.QToolBar()  # Create a toolbar to place the widget in\n    >>> plot.addToolBar(qt.Qt.BottomToolBarArea, toolBar)  # Add it to plot\n\n    Then, create the PositionInfo widget and add it to the toolbar.\n    The PositionInfo widget is created with a list of converters, here\n    to display polar coordinates of the mouse position.\n\n    >>> import math\n    >>> from silx.gui.plot.PlotTools import PositionInfo\n\n    >>> position = PositionInfo(plot, converters=[\n    ...     ('Radius', lambda x, y: math.sqrt(x*x + y*y)),\n    ...     ('Angle', lambda x, y: math.degrees(math.atan2(y, x)))])\n\n    >>> toolBar.addWidget(position)  # Add the widget to the toolbar\n    <...>\n\n    >>> plot.show()  # To display the PlotWindow with the position widget\n\n    :param plot: The PlotWidget this widget is displaying data coords from.\n    :param converters: List of name to display and conversion function from\n                       (x, y) in data coords to displayed value.\n                       If None, the default, it displays X and Y.\n    :type converters: Iterable of 2-tuple (str, function)\n    :param parent: Parent widget\n    \"\"\"\n\n    def __init__(self, plot, converters=None, parent=None):\n        self._plotRef = weakref.ref(plot)\n\n        super(PositionInfo, self).__init__(parent)\n\n        if converters is None:\n            converters = (('X', lambda x, y: x), ('Y', lambda x, y: y))\n\n        self.autoSnapToActiveCurve = False\n        \"\"\"Toggle snapping use position to active curve.\n\n        - True to snap used coordinates to the active curve if the active curve\n        is displayed with symbols and mouse is close enough.\n        If the mouse is not close to a point of the curve, values are\n        displayed in red.\n        - False (the default) to always use mouse coordinates.\n        \"\"\"\n\n        self._fields = []  # To store (QLineEdit, name, function (x, y)->v)\n\n        # Create a new layout with new widgets\n        layout = qt.QHBoxLayout()\n        layout.setContentsMargins(0, 0, 0, 0)\n        # layout.setSpacing(0)\n\n        # Create all LineEdit and store them with the corresponding converter\n        for name, func in converters:\n            layout.addWidget(qt.QLabel('<b>' + name + ':</b>'))\n\n            lineEdit = qt.QLineEdit()\n            lineEdit.setText('------')\n            lineEdit.setReadOnly(1)\n            lineEdit.setFixedWidth(\n                lineEdit.fontMetrics().width('##############'))\n            layout.addWidget(lineEdit)\n            self._fields.append((lineEdit, name, func))\n\n        layout.addStretch(1)\n        self.setLayout(layout)\n\n        # Connect to Plot events\n        plot.sigPlotSignal.connect(self._plotEvent)\n\n    @property\n    def plot(self):\n        \"\"\"The :class:`.PlotWindow` this widget is attached to.\"\"\"\n        return self._plotRef()\n\n    def getConverters(self):\n        \"\"\"Return the list of converters as 2-tuple (name, function).\"\"\"\n        return [(name, func) for lineEdit, name, func in self._fields]\n\n    def _plotEvent(self, event):\n        \"\"\"Handle events from the Plot.\n\n        :param dict event: Plot event\n        \"\"\"\n        if event['event'] == 'mouseMoved':\n            x, y = event['x'], event['y']  # Position in data\n            styleSheet = \"color: rgb(0, 0, 0);\"  # Default style\n\n            if self.autoSnapToActiveCurve and self.plot.getGraphCursor():\n                # Check if near active curve with symbols.\n\n                styleSheet = \"color: rgb(255, 0, 0);\"  # Style far from curve\n\n                activeCurve = self.plot.getActiveCurve()\n                if activeCurve:\n                    xData, yData, legend, info, params = activeCurve[0:5]\n                    if params['symbol']:  # Only handled if symbols on curve\n                        closestIndex = numpy.argmin(\n                            pow(xData - x, 2) + pow(yData - y, 2))\n\n                        xClosest = xData[closestIndex]\n                        yClosest = yData[closestIndex]\n\n                        closestInPixels = self.plot.dataToPixel(\n                            xClosest, yClosest, axis=params['yaxis'])\n                        if closestInPixels is not None:\n                            xClosest, yClosest = closestInPixels\n                            xPixel, yPixel = event['xpixel'], event['ypixel']\n\n                            if (abs(xClosest - xPixel) < 5 and\n                                    abs(yClosest - yPixel) < 5):\n                                # Update lineEdit style sheet\n                                styleSheet = \"color: rgb(0, 0, 0);\"\n\n                                # if close enough, wrap to data point coords\n                                x, y = xClosest, yClosest\n\n            for lineEdit, name, func in self._fields:\n                lineEdit.setStyleSheet(styleSheet)\n\n                try:\n                    value = func(x, y)\n                except:\n                    lineEdit.setText('Error')\n                    _logger.error(\n                        \"Error while converting coordinates (%f, %f)\"\n                        \"with converter '%s'\" % (x, y, name))\n                    _logger.error(traceback.format_exc())\n                else:\n                    if isinstance(value, numbers.Real):\n                        value = '%.7g' % value  # Use this for floats and int\n                    else:\n                        value = str(value)  # Fallback for other types\n                    lineEdit.setText(value)",
  "def __init__(self, plot, converters=None, parent=None):\n        self._plotRef = weakref.ref(plot)\n\n        super(PositionInfo, self).__init__(parent)\n\n        if converters is None:\n            converters = (('X', lambda x, y: x), ('Y', lambda x, y: y))\n\n        self.autoSnapToActiveCurve = False\n        \"\"\"Toggle snapping use position to active curve.\n\n        - True to snap used coordinates to the active curve if the active curve\n        is displayed with symbols and mouse is close enough.\n        If the mouse is not close to a point of the curve, values are\n        displayed in red.\n        - False (the default) to always use mouse coordinates.\n        \"\"\"\n\n        self._fields = []  # To store (QLineEdit, name, function (x, y)->v)\n\n        # Create a new layout with new widgets\n        layout = qt.QHBoxLayout()\n        layout.setContentsMargins(0, 0, 0, 0)\n        # layout.setSpacing(0)\n\n        # Create all LineEdit and store them with the corresponding converter\n        for name, func in converters:\n            layout.addWidget(qt.QLabel('<b>' + name + ':</b>'))\n\n            lineEdit = qt.QLineEdit()\n            lineEdit.setText('------')\n            lineEdit.setReadOnly(1)\n            lineEdit.setFixedWidth(\n                lineEdit.fontMetrics().width('##############'))\n            layout.addWidget(lineEdit)\n            self._fields.append((lineEdit, name, func))\n\n        layout.addStretch(1)\n        self.setLayout(layout)\n\n        # Connect to Plot events\n        plot.sigPlotSignal.connect(self._plotEvent)",
  "def plot(self):\n        \"\"\"The :class:`.PlotWindow` this widget is attached to.\"\"\"\n        return self._plotRef()",
  "def getConverters(self):\n        \"\"\"Return the list of converters as 2-tuple (name, function).\"\"\"\n        return [(name, func) for lineEdit, name, func in self._fields]",
  "def _plotEvent(self, event):\n        \"\"\"Handle events from the Plot.\n\n        :param dict event: Plot event\n        \"\"\"\n        if event['event'] == 'mouseMoved':\n            x, y = event['x'], event['y']  # Position in data\n            styleSheet = \"color: rgb(0, 0, 0);\"  # Default style\n\n            if self.autoSnapToActiveCurve and self.plot.getGraphCursor():\n                # Check if near active curve with symbols.\n\n                styleSheet = \"color: rgb(255, 0, 0);\"  # Style far from curve\n\n                activeCurve = self.plot.getActiveCurve()\n                if activeCurve:\n                    xData, yData, legend, info, params = activeCurve[0:5]\n                    if params['symbol']:  # Only handled if symbols on curve\n                        closestIndex = numpy.argmin(\n                            pow(xData - x, 2) + pow(yData - y, 2))\n\n                        xClosest = xData[closestIndex]\n                        yClosest = yData[closestIndex]\n\n                        closestInPixels = self.plot.dataToPixel(\n                            xClosest, yClosest, axis=params['yaxis'])\n                        if closestInPixels is not None:\n                            xClosest, yClosest = closestInPixels\n                            xPixel, yPixel = event['xpixel'], event['ypixel']\n\n                            if (abs(xClosest - xPixel) < 5 and\n                                    abs(yClosest - yPixel) < 5):\n                                # Update lineEdit style sheet\n                                styleSheet = \"color: rgb(0, 0, 0);\"\n\n                                # if close enough, wrap to data point coords\n                                x, y = xClosest, yClosest\n\n            for lineEdit, name, func in self._fields:\n                lineEdit.setStyleSheet(styleSheet)\n\n                try:\n                    value = func(x, y)\n                except:\n                    lineEdit.setText('Error')\n                    _logger.error(\n                        \"Error while converting coordinates (%f, %f)\"\n                        \"with converter '%s'\" % (x, y, name))\n                    _logger.error(traceback.format_exc())\n                else:\n                    if isinstance(value, numbers.Real):\n                        value = '%.7g' % value  # Use this for floats and int\n                    else:\n                        value = str(value)  # Fallback for other types\n                    lineEdit.setText(value)",
  "class ModestImage(AxesImage):\n    \"\"\"Computationally modest image class.\n\nCustomization of https://github.com/ChrisBeaumont/ModestImage to allow\nextent support.\n\nModestImage is an extension of the Matplotlib AxesImage class\nbetter suited for the interactive display of larger images. Before\ndrawing, ModestImage resamples the data array based on the screen\nresolution and view window. This has very little affect on the\nappearance of the image, but can substantially cut down on\ncomputation since calculations of unresolved or clipped pixels\nare skipped.\n\nThe interface of ModestImage is the same as AxesImage. However, it\ndoes not currently support setting the 'extent' property. There\nmay also be weird coordinate warping operations for images that\nI'm not aware of. Don't expect those to work either.\n\"\"\"\n    def __init__(self, *args, **kwargs):\n        self._full_res = None\n        self._sx, self._sy = None, None\n        self._bounds = (None, None, None, None)\n        self._origExtent = None\n        super(ModestImage, self).__init__(*args, **kwargs)\n        if 'extent' in kwargs and kwargs['extent'] is not None:\n            self.set_extent(kwargs['extent'])\n\n    def set_extent(self, extent):\n        super(ModestImage, self).set_extent(extent)\n        if self._origExtent is None:\n            self._origExtent = self.get_extent()\n\n    def get_image_extent(self):\n        \"\"\"Returns the extent of the whole image.\n\n        get_extent returns the extent of the drawn area and not of the full\n        image.\n\n        :return: Bounds of the image (x0, x1, y0, y1).\n        :rtype: Tuple of 4 floats.\n        \"\"\"\n        if self._origExtent is not None:\n            return self._origExtent\n        else:\n            return self.get_extent()\n\n    def set_data(self, A):\n        \"\"\"\n        Set the image array\n\n        ACCEPTS: numpy/PIL Image A\n        \"\"\"\n\n        self._full_res = A\n        self._A = A\n\n        if (self._A.dtype != numpy.uint8 and\n                not numpy.can_cast(self._A.dtype, numpy.float)):\n            raise TypeError(\"Image data can not convert to float\")\n\n        if (self._A.ndim not in (2, 3) or\n                (self._A.ndim == 3 and self._A.shape[-1] not in (3, 4))):\n            raise TypeError(\"Invalid dimensions for image data\")\n\n        self._imcache = None\n        self._rgbacache = None\n        self._oldxslice = None\n        self._oldyslice = None\n        self._sx, self._sy = None, None\n\n    def get_array(self):\n        \"\"\"Override to return the full-resolution array\"\"\"\n        return self._full_res\n\n    def _scale_to_res(self):\n        \"\"\" Change self._A and _extent to render an image whose\nresolution is matched to the eventual rendering.\"\"\"\n        # extent has to be set BEFORE set_data\n        if self._origExtent is None:\n            if self.origin == \"upper\":\n                self._origExtent = (0, self._full_res.shape[1],\n                                    self._full_res.shape[0], 0)\n            else:\n                self._origExtent = (0, self._full_res.shape[1],\n                                    0, self._full_res.shape[0])\n\n        if self.origin == \"upper\":\n            origXMin, origXMax, origYMax, origYMin = self._origExtent[0:4]\n        else:\n            origXMin, origXMax, origYMin, origYMax = self._origExtent[0:4]\n        ax = self.axes\n        ext = ax.transAxes.transform([1, 1]) - ax.transAxes.transform([0, 0])\n        xlim, ylim = ax.get_xlim(), ax.get_ylim()\n        xlim = max(xlim[0], origXMin), min(xlim[1], origXMax)\n        if ylim[0] > ylim[1]:\n            ylim = max(ylim[1], origYMin), min(ylim[0], origYMax)\n        else:\n            ylim = max(ylim[0], origYMin), min(ylim[1], origYMax)\n        # print(\"THOSE LIMITS ARE TO BE COMPARED WITH THE EXTENT\")\n        # print(\"IN ORDER TO KNOW WHAT IT IS LIMITING THE DISPLAY\")\n        # print(\"IF THE AXES OR THE EXTENT\")\n        dx, dy = xlim[1] - xlim[0], ylim[1] - ylim[0]\n\n        y0 = max(0, ylim[0] - 5)\n        y1 = min(self._full_res.shape[0], ylim[1] + 5)\n        x0 = max(0, xlim[0] - 5)\n        x1 = min(self._full_res.shape[1], xlim[1] + 5)\n        y0, y1, x0, x1 = [int(a) for a in [y0, y1, x0, x1]]\n\n        sy = int(max(1, min((y1 - y0) / 5., numpy.ceil(dy / ext[1]))))\n        sx = int(max(1, min((x1 - x0) / 5., numpy.ceil(dx / ext[0]))))\n\n        # have we already calculated what we need?\n        if (self._sx is not None) and (self._sy is not None):\n            if (sx >= self._sx and sy >= self._sy and\n                    x0 >= self._bounds[0] and x1 <= self._bounds[1] and\n                    y0 >= self._bounds[2] and y1 <= self._bounds[3]):\n                return\n\n        self._A = self._full_res[y0:y1:sy, x0:x1:sx]\n        self._A = cbook.safe_masked_invalid(self._A)\n        x1 = x0 + self._A.shape[1] * sx\n        y1 = y0 + self._A.shape[0] * sy\n\n        if self.origin == \"upper\":\n            self.set_extent([x0, x1, y1, y0])\n        else:\n            self.set_extent([x0, x1, y0, y1])\n        self._sx = sx\n        self._sy = sy\n        self._bounds = (x0, x1, y0, y1)\n        self.changed()\n\n    def draw(self, renderer, *args, **kwargs):\n        self._scale_to_res()\n        super(ModestImage, self).draw(renderer, *args, **kwargs)",
  "def __init__(self, *args, **kwargs):\n        self._full_res = None\n        self._sx, self._sy = None, None\n        self._bounds = (None, None, None, None)\n        self._origExtent = None\n        super(ModestImage, self).__init__(*args, **kwargs)\n        if 'extent' in kwargs and kwargs['extent'] is not None:\n            self.set_extent(kwargs['extent'])",
  "def set_extent(self, extent):\n        super(ModestImage, self).set_extent(extent)\n        if self._origExtent is None:\n            self._origExtent = self.get_extent()",
  "def get_image_extent(self):\n        \"\"\"Returns the extent of the whole image.\n\n        get_extent returns the extent of the drawn area and not of the full\n        image.\n\n        :return: Bounds of the image (x0, x1, y0, y1).\n        :rtype: Tuple of 4 floats.\n        \"\"\"\n        if self._origExtent is not None:\n            return self._origExtent\n        else:\n            return self.get_extent()",
  "def set_data(self, A):\n        \"\"\"\n        Set the image array\n\n        ACCEPTS: numpy/PIL Image A\n        \"\"\"\n\n        self._full_res = A\n        self._A = A\n\n        if (self._A.dtype != numpy.uint8 and\n                not numpy.can_cast(self._A.dtype, numpy.float)):\n            raise TypeError(\"Image data can not convert to float\")\n\n        if (self._A.ndim not in (2, 3) or\n                (self._A.ndim == 3 and self._A.shape[-1] not in (3, 4))):\n            raise TypeError(\"Invalid dimensions for image data\")\n\n        self._imcache = None\n        self._rgbacache = None\n        self._oldxslice = None\n        self._oldyslice = None\n        self._sx, self._sy = None, None",
  "def get_array(self):\n        \"\"\"Override to return the full-resolution array\"\"\"\n        return self._full_res",
  "def _scale_to_res(self):\n        \"\"\" Change self._A and _extent to render an image whose\nresolution is matched to the eventual rendering.\"\"\"\n        # extent has to be set BEFORE set_data\n        if self._origExtent is None:\n            if self.origin == \"upper\":\n                self._origExtent = (0, self._full_res.shape[1],\n                                    self._full_res.shape[0], 0)\n            else:\n                self._origExtent = (0, self._full_res.shape[1],\n                                    0, self._full_res.shape[0])\n\n        if self.origin == \"upper\":\n            origXMin, origXMax, origYMax, origYMin = self._origExtent[0:4]\n        else:\n            origXMin, origXMax, origYMin, origYMax = self._origExtent[0:4]\n        ax = self.axes\n        ext = ax.transAxes.transform([1, 1]) - ax.transAxes.transform([0, 0])\n        xlim, ylim = ax.get_xlim(), ax.get_ylim()\n        xlim = max(xlim[0], origXMin), min(xlim[1], origXMax)\n        if ylim[0] > ylim[1]:\n            ylim = max(ylim[1], origYMin), min(ylim[0], origYMax)\n        else:\n            ylim = max(ylim[0], origYMin), min(ylim[1], origYMax)\n        # print(\"THOSE LIMITS ARE TO BE COMPARED WITH THE EXTENT\")\n        # print(\"IN ORDER TO KNOW WHAT IT IS LIMITING THE DISPLAY\")\n        # print(\"IF THE AXES OR THE EXTENT\")\n        dx, dy = xlim[1] - xlim[0], ylim[1] - ylim[0]\n\n        y0 = max(0, ylim[0] - 5)\n        y1 = min(self._full_res.shape[0], ylim[1] + 5)\n        x0 = max(0, xlim[0] - 5)\n        x1 = min(self._full_res.shape[1], xlim[1] + 5)\n        y0, y1, x0, x1 = [int(a) for a in [y0, y1, x0, x1]]\n\n        sy = int(max(1, min((y1 - y0) / 5., numpy.ceil(dy / ext[1]))))\n        sx = int(max(1, min((x1 - x0) / 5., numpy.ceil(dx / ext[0]))))\n\n        # have we already calculated what we need?\n        if (self._sx is not None) and (self._sy is not None):\n            if (sx >= self._sx and sy >= self._sy and\n                    x0 >= self._bounds[0] and x1 <= self._bounds[1] and\n                    y0 >= self._bounds[2] and y1 <= self._bounds[3]):\n                return\n\n        self._A = self._full_res[y0:y1:sy, x0:x1:sx]\n        self._A = cbook.safe_masked_invalid(self._A)\n        x1 = x0 + self._A.shape[1] * sx\n        y1 = y0 + self._A.shape[0] * sy\n\n        if self.origin == \"upper\":\n            self.set_extent([x0, x1, y1, y0])\n        else:\n            self.set_extent([x0, x1, y0, y1])\n        self._sx = sx\n        self._sy = sy\n        self._bounds = (x0, x1, y0, y1)\n        self.changed()",
  "def draw(self, renderer, *args, **kwargs):\n        self._scale_to_res()\n        super(ModestImage, self).draw(renderer, *args, **kwargs)",
  "class PlotWindowPlugin(QtDesigner.QPyDesignerCustomWidgetPlugin):\n\n    def __init__(self, parent=None):\n        super(PlotWindowPlugin, self).__init__(parent)\n        self.initialized = False\n\n    def initialize(self, core):\n        if self.initialized:\n            return\n\n        self.initialized = True\n\n    def isInitialized(self):\n        return self.initialized\n\n    def createWidget(self, parent):\n        return PlotWindow(parent, autoreplot=False)\n\n    def name(self):\n        return \"PlotWindow\"\n\n    def group(self):\n        return \"silx\"\n\n    def icon(self):\n        return qt.QIcon(qt.QPixmap(_logo_pixmap))\n\n    def toolTip(self):\n        return \"\"\n\n    def whatsThis(self):\n        return \"\"\n\n    def isContainer(self):\n        return False\n\n    def includeFile(self):\n        return \"silx.gui.plot.PlotWindow\"",
  "def __init__(self, parent=None):\n        super(PlotWindowPlugin, self).__init__(parent)\n        self.initialized = False",
  "def initialize(self, core):\n        if self.initialized:\n            return\n\n        self.initialized = True",
  "def isInitialized(self):\n        return self.initialized",
  "def createWidget(self, parent):\n        return PlotWindow(parent, autoreplot=False)",
  "def name(self):\n        return \"PlotWindow\"",
  "def group(self):\n        return \"silx\"",
  "def icon(self):\n        return qt.QIcon(qt.QPixmap(_logo_pixmap))",
  "def toolTip(self):\n        return \"\"",
  "def whatsThis(self):\n        return \"\"",
  "def isContainer(self):\n        return False",
  "def includeFile(self):\n        return \"silx.gui.plot.PlotWindow\"",
  "class PlotWidgetPlugin(QtDesigner.QPyDesignerCustomWidgetPlugin):\n\n    def __init__(self, parent=None):\n        super(PlotWidgetPlugin, self).__init__(parent)\n        self.initialized = False\n\n    def initialize(self, core):\n        if self.initialized:\n            return\n\n        self.initialized = True\n\n    def isInitialized(self):\n        return self.initialized\n\n    def createWidget(self, parent):\n        return PlotWidget(parent, autoreplot=False)\n\n    def name(self):\n        return \"PlotWidget\"\n\n    def group(self):\n        return \"silx\"\n\n    def icon(self):\n        return qt.QIcon(qt.QPixmap(_logo_pixmap))\n\n    def toolTip(self):\n        return \"\"\n\n    def whatsThis(self):\n        return \"\"\n\n    def isContainer(self):\n        return False\n\n    def includeFile(self):\n        return \"silx.gui.plot.PlotWidget\"",
  "def __init__(self, parent=None):\n        super(PlotWidgetPlugin, self).__init__(parent)\n        self.initialized = False",
  "def initialize(self, core):\n        if self.initialized:\n            return\n\n        self.initialized = True",
  "def isInitialized(self):\n        return self.initialized",
  "def createWidget(self, parent):\n        return PlotWidget(parent, autoreplot=False)",
  "def name(self):\n        return \"PlotWidget\"",
  "def group(self):\n        return \"silx\"",
  "def icon(self):\n        return qt.QIcon(qt.QPixmap(_logo_pixmap))",
  "def toolTip(self):\n        return \"\"",
  "def whatsThis(self):\n        return \"\"",
  "def isContainer(self):\n        return False",
  "def includeFile(self):\n        return \"silx.gui.plot.PlotWidget\""
]