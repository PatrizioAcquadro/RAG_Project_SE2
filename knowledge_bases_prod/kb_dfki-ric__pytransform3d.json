[
  "class Open3DScraper(object):\n    def __repr__(self):\n        return \"Open3DScraper\"\n\n    def __call__(self, block, block_vars, gallery_conf, **kwargs):\n        \"\"\"Scrape Open3D images.\n\n        Parameters\n        ----------\n        block : tuple\n            A tuple containing the (label, content, line_number) of the block.\n        block_vars : dict\n            Dict of block variables.\n        gallery_conf : dict\n            Contains the configuration of Sphinx-Gallery\n        **kwargs : dict\n            Additional keyword arguments to pass to\n            :meth:`~matplotlib.figure.Figure.savefig`, e.g. ``format='svg'``.\n            The ``format`` kwarg in particular is used to set the file extension\n            of the output file (currently only 'png', 'jpg', and 'svg' are\n            supported).\n\n        Returns\n        -------\n        rst : str\n            The ReSTructuredText that will be rendered to HTML containing\n            the images.\n        \"\"\"\n        path_current_example = os.path.dirname(block_vars['src_file'])\n        jpgs = sorted(glob.glob(os.path.join(\n            path_current_example, \"__open3d_rendered_image.jpg\")))\n\n        image_names = list()\n        image_path_iterator = block_vars[\"image_path_iterator\"]\n        for jpg in jpgs:\n            this_image_path = image_path_iterator.next()\n            image_names.append(this_image_path)\n            shutil.move(jpg, this_image_path)\n        return figure_rst(image_names, gallery_conf[\"src_dir\"])",
  "def __repr__(self):\n        return \"Open3DScraper\"",
  "def __call__(self, block, block_vars, gallery_conf, **kwargs):\n        \"\"\"Scrape Open3D images.\n\n        Parameters\n        ----------\n        block : tuple\n            A tuple containing the (label, content, line_number) of the block.\n        block_vars : dict\n            Dict of block variables.\n        gallery_conf : dict\n            Contains the configuration of Sphinx-Gallery\n        **kwargs : dict\n            Additional keyword arguments to pass to\n            :meth:`~matplotlib.figure.Figure.savefig`, e.g. ``format='svg'``.\n            The ``format`` kwarg in particular is used to set the file extension\n            of the output file (currently only 'png', 'jpg', and 'svg' are\n            supported).\n\n        Returns\n        -------\n        rst : str\n            The ReSTructuredText that will be rendered to HTML containing\n            the images.\n        \"\"\"\n        path_current_example = os.path.dirname(block_vars['src_file'])\n        jpgs = sorted(glob.glob(os.path.join(\n            path_current_example, \"__open3d_rendered_image.jpg\")))\n\n        image_names = list()\n        image_path_iterator = block_vars[\"image_path_iterator\"]\n        for jpg in jpgs:\n            this_image_path = image_path_iterator.next()\n            image_names.append(this_image_path)\n            shutil.move(jpg, this_image_path)\n        return figure_rst(image_names, gallery_conf[\"src_dir\"])",
  "def unit_sphere_surface_grid(n_steps):\n    \"\"\"Create grid on the surface of a unit sphere in 3D.\n\n    Parameters\n    ----------\n    n_steps : int\n        Number of discrete steps in each dimension of the surface.\n\n    Returns\n    -------\n    x : array, shape (n_steps, n_steps)\n        x-coordinates of grid points.\n\n    y : array, shape (n_steps, n_steps)\n        y-coordinates of grid points.\n\n    z : array, shape (n_steps, n_steps)\n        z-coordinates of grid points.\n    \"\"\"\n    phi, theta = np.mgrid[0.0:np.pi:n_steps * 1j,\n                          0.0:2.0 * np.pi:n_steps * 1j]\n    sin_phi = np.sin(phi)\n\n    x = sin_phi * np.cos(theta)\n    y = sin_phi * np.sin(theta)\n    z = np.cos(phi)\n\n    return x, y, z",
  "def transform_surface(surface2origin, x, y, z):\n    \"\"\"Transform surface grid.\n\n    Parameters\n    ----------\n    surface2origin : array-like, shape (4, 4)\n        Pose: transformation that will be applied to the surface grid.\n\n    x : array, shape (n_steps, n_steps)\n        x-coordinates of grid points.\n\n    y : array, shape (n_steps, n_steps)\n        y-coordinates of grid points.\n\n    z : array, shape (n_steps, n_steps)\n        z-coordinates of grid points.\n\n    Returns\n    -------\n    x : array, shape (n_steps, n_steps)\n        x-coordinates of transformed grid points.\n\n    y : array, shape (n_steps, n_steps)\n        y-coordinates of transformed grid points.\n\n    z : array, shape (n_steps, n_steps)\n        z-coordinates of transformed grid points.\n    \"\"\"\n    surface2origin = check_transform(surface2origin)\n    x = np.asarray(x)\n    y = np.asarray(y)\n    z = np.asarray(z)\n\n    shape = x.shape\n\n    P = np.column_stack((x.reshape(-1), y.reshape(-1), z.reshape(-1)))\n    P = P.dot(surface2origin[:3, :3].T) + surface2origin[np.newaxis, :3, 3]\n\n    x = P[:, 0].reshape(*shape)\n    y = P[:, 1].reshape(*shape)\n    z = P[:, 2].reshape(*shape)\n    return x, y, z",
  "def invert_transforms(A2Bs):\n    \"\"\"Invert transforms.\n\n    Parameters\n    ----------\n    A2Bs : array-like, shape (..., 4, 4)\n        Transforms from frames A to frames B\n\n    Returns\n    -------\n    B2As : array, shape (..., 4, 4)\n        Transforms from frames B to frames A\n    \"\"\"\n    A2Bs = np.asarray(A2Bs)\n    instances_shape = A2Bs.shape[:-2]\n    B2As = np.empty_like(A2Bs)\n    # ( R t )^-1   ( R^T -R^T*t )\n    # ( 0 1 )    = ( 0    1     )\n    B2As[..., :3, :3] = A2Bs[..., :3, :3].transpose(\n        list(range(A2Bs.ndim - 2)) + [A2Bs.ndim - 1, A2Bs.ndim - 2])\n    B2As[..., :3, 3] = np.einsum(\n        \"nij,nj->ni\",\n        -B2As[..., :3, :3].reshape(-1, 3, 3),\n        A2Bs[..., :3, 3].reshape(-1, 3)).reshape(\n        *(list(instances_shape) + [3]))\n    B2As[..., 3, :3] = 0.0\n    B2As[..., 3, 3] = 1.0\n    return B2As",
  "def concat_one_to_many(A2B, B2Cs):\n    \"\"\"Concatenate transformation A2B with multiple transformations B2C.\n\n    We use the extrinsic convention, which means that B2Cs are left-multiplied\n    to A2B.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    B2Cs : array-like, shape (n_transforms, 4, 4)\n        Transforms from frame B to frame C\n\n    Returns\n    -------\n    A2Cs : array, shape (n_transforms, 4, 4)\n        Transforms from frame A to frame C\n    \"\"\"\n    return np.einsum(\"nij,jk->nik\", B2Cs, A2B)",
  "def concat_many_to_one(A2Bs, B2C):\n    \"\"\"Concatenate multiple transformations A2B with transformation B2C.\n\n    We use the extrinsic convention, which means that B2C is left-multiplied\n    to A2Bs.\n\n    Parameters\n    ----------\n    A2Bs : array-like, shape (4, 4)\n        Transforms from frame A to frame B\n\n    B2C : array-like, shape (n_transforms, 4, 4)\n        Transform from frame B to frame C\n\n    Returns\n    -------\n    A2Cs : array, shape (n_transforms, 4, 4)\n        Transforms from frame A to frame C\n    \"\"\"\n    return np.einsum(\"ij,njk->nik\", B2C, A2Bs)",
  "def transforms_from_pqs(P, normalize_quaternions=True):\n    \"\"\"Get sequence of homogeneous matrices from positions and quaternions.\n\n    Parameters\n    ----------\n    P : array-like, shape (..., 7)\n        Poses represented by positions and quaternions in the\n        order (x, y, z, qw, qx, qy, qz)\n\n    normalize_quaternions : bool, optional (default: True)\n        Normalize quaternions before conversion\n\n    Returns\n    -------\n    A2Bs : array, shape (..., 4, 4)\n        Poses represented by homogeneous matrices\n    \"\"\"\n    P = np.asarray(P)\n    instances_shape = P.shape[:-1]\n    A2Bs = np.empty(instances_shape + (4, 4))\n    A2Bs[..., :3, 3] = P[..., :3]\n    A2Bs[..., 3, :3] = 0.0\n    A2Bs[..., 3, 3] = 1.0\n\n    matrices_from_quaternions(\n        P[..., 3:], normalize_quaternions, out=A2Bs[..., :3, :3])\n\n    return A2Bs",
  "def pqs_from_transforms(A2Bs):\n    \"\"\"Get sequence of positions and quaternions from homogeneous matrices.\n\n    Parameters\n    ----------\n    A2Bs : array-like, shape (..., 4, 4)\n        Poses represented by homogeneous matrices\n\n    Returns\n    -------\n    P : array, shape (n_steps, 7)\n        Poses represented by positions and quaternions in the\n        order (x, y, z, qw, qx, qy, qz) for each step\n    \"\"\"\n    A2Bs = np.asarray(A2Bs)\n    instances_shape = A2Bs.shape[:-2]\n    P = np.empty(instances_shape + (7,))\n    P[..., :3] = A2Bs[..., :3, 3]\n    quaternions_from_matrices(A2Bs[..., :3, :3], out=P[..., 3:])\n    return P",
  "def exponential_coordinates_from_transforms(A2Bs):\n    \"\"\"Compute exponential coordinates from transformations.\n\n    Parameters\n    ----------\n    A2Bs : array-like, shape (..., 4, 4)\n        Poses represented by homogeneous matrices\n\n    Returns\n    -------\n    Sthetas : array, shape (..., 6)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where S is the screw axis, the first 3 components are related to\n        rotation and the last 3 components are related to translation.\n        Theta is the rotation angle and h * theta the translation.\n    \"\"\"\n    A2Bs = np.asarray(A2Bs)\n\n    instances_shape = A2Bs.shape[:-2]\n\n    Rs = A2Bs[..., :3, :3]\n    ps = A2Bs[..., :3, 3]\n\n    traces = np.einsum(\"nii\", Rs.reshape(-1, 3, 3))\n    if instances_shape:\n        traces = traces.reshape(*instances_shape)\n    else:\n        # this works because indX will be a single boolean and\n        # out[True, n] = value will assign value to out[n], while\n        # out[False, n] = value will not assign value to out[n]\n        traces = traces[0]\n\n    Sthetas = np.empty(instances_shape + (6,))\n\n    omega_thetas = axis_angles_from_matrices(Rs, traces=traces)\n    Sthetas[..., :3] = omega_thetas[..., :3]\n    thetas = omega_thetas[..., 3]\n\n    # from sympy import *\n    # o0, o1, o2, px, py, pz, t = symbols(\"o0 o1 o2 p0 p1 p2 theta\")\n    # w = Matrix([[0, -o2, o1], [o2, 0, -o0], [-o1, o0, 0]])\n    # p = Matrix([[px], [py], [pz]])\n    # v = (eye(3) / t - 0.5 * w + (1 / t - 0.5 / tan(t / 2.0)) * w * w) * p\n\n    # Result:\n    # p0*(-o1**2*(-0.5/tan(0.5*t) + 1/t)\n    #     - o2**2*(-0.5/tan(0.5*t) + 1/t) + 1/t)\n    #     + p1*(o0*o1*(-0.5/tan(0.5*t) + 1/t) + 0.5*o2)\n    #     + p2*(o0*o2*(-0.5/tan(0.5*t) + 1/t) - 0.5*o1)\n    # p0*(o0*o1*(-0.5/tan(0.5*t) + 1/t) - 0.5*o2)\n    #     + p1*(-o0**2*(-0.5/tan(0.5*t) + 1/t)\n    #           - o2**2*(-0.5/tan(0.5*t) + 1/t) + 1/t)\n    #     + p2*(0.5*o0 + o1*o2*(-0.5/tan(0.5*t) + 1/t))\n    # p0*(o0*o2*(-0.5/tan(0.5*t) + 1/t) + 0.5*o1)\n    #     + p1*(-0.5*o0 + o1*o2*(-0.5/tan(0.5*t) + 1/t))\n    #     + p2*(-o0**2*(-0.5/tan(0.5*t) + 1/t)\n    #           - o1**2*(-0.5/tan(0.5*t) + 1/t) + 1/t)\n\n    thetas = np.maximum(thetas, np.finfo(float).tiny)\n    ti = 1.0 / thetas\n    tan_term = -0.5 / np.tan(thetas / 2.0) + ti\n    o0 = omega_thetas[..., 0]\n    o1 = omega_thetas[..., 1]\n    o2 = omega_thetas[..., 2]\n    p0 = ps[..., 0]\n    p1 = ps[..., 1]\n    p2 = ps[..., 2]\n    o00 = o0 * o0\n    o01 = o0 * o1\n    o02 = o0 * o2\n    o11 = o1 * o1\n    o12 = o1 * o2\n    o22 = o2 * o2\n    Sthetas[..., 3] = (p0 * ((-o11 - o22) * tan_term + ti)\n                       + p1 * (o01 * tan_term + 0.5 * o2)\n                       + p2 * (o02 * tan_term - 0.5 * o1)\n                       )\n    Sthetas[..., 4] = (p0 * (o01 * tan_term - 0.5 * o2)\n                       + p1 * ((-o00 - o22) * tan_term + ti)\n                       + p2 * (0.5 * o0 + o12 * tan_term)\n                       )\n    Sthetas[..., 5] = (p0 * (o02 * tan_term + 0.5 * o1)\n                       + p1 * (-0.5 * o0 + o12 * tan_term)\n                       + p2 * ((-o00 - o11) * tan_term + ti)\n                       )\n\n    Sthetas *= thetas[..., np.newaxis]\n\n    ind_only_translation = traces >= 3.0 - np.finfo(float).eps\n    Sthetas[ind_only_translation, :3] = 0.0\n    Sthetas[ind_only_translation, 3:] = ps[ind_only_translation]\n\n    return Sthetas",
  "def transforms_from_exponential_coordinates(Sthetas):\n    \"\"\"Compute transformations from exponential coordinates.\n\n    Parameters\n    ----------\n    Sthetas : array-like, shape (..., 6)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where S is the screw axis, the first 3 components are related to\n        rotation and the last 3 components are related to translation.\n        Theta is the rotation angle and h * theta the translation.\n\n    Returns\n    -------\n    A2Bs : array, shape (..., 4, 4)\n        Poses represented by homogeneous matrices\n    \"\"\"\n    Sthetas = np.asarray(Sthetas)\n    if Sthetas.ndim == 1:\n        return transform_from_exponential_coordinates(Sthetas)\n\n    instances_shape = Sthetas.shape[:-1]\n\n    t = np.linalg.norm(Sthetas[..., :3], axis=-1)\n\n    A2Bs = np.empty(instances_shape + (4, 4))\n    A2Bs[..., 3, :] = (0, 0, 0, 1)\n\n    ind_only_translation = t == 0.0\n\n    if not np.all(ind_only_translation):\n        t[ind_only_translation] = 1.0\n        screw_axes = Sthetas / t[..., np.newaxis]\n\n        matrices_from_compact_axis_angles(\n            axes=screw_axes[..., :3], angles=t, out=A2Bs[..., :3, :3])\n\n        # from sympy import *\n        # o0, o1, o2, vx, vy, vz, t = symbols(\"o0 o1 o2 v_x v_y v_z t\")\n        # w = Matrix([[0, -o2, o1], [o2, 0, -o0], [-o1, o0, 0]])\n        # v = Matrix([[vx], [vy], [vz]])\n        # p = (eye(3) * t + (1 - cos(t)) * w + (t - sin(t)) * w * w) * v\n        #\n        # Result:\n        # -v_x*(o1**2*(t - sin(t)) + o2**2*(t - sin(t)) - t)\n        #     + v_y*(o0*o1*(t - sin(t)) + o2*(cos(t) - 1))\n        #     + v_z*(o0*o2*(t - sin(t)) - o1*(cos(t) - 1))\n        # v_x*(o0*o1*(t - sin(t)) - o2*(cos(t) - 1))\n        #     - v_y*(o0**2*(t - sin(t)) + o2**2*(t - sin(t)) - t)\n        #     + v_z*(o0*(cos(t) - 1) + o1*o2*(t - sin(t)))\n        # v_x*(o0*o2*(t - sin(t)) + o1*(cos(t) - 1))\n        #     - v_y*(o0*(cos(t) - 1) - o1*o2*(t - sin(t)))\n        #     - v_z*(o0**2*(t - sin(t)) + o1**2*(t - sin(t)) - t)\n\n        tms = t - np.sin(t)\n        cm1 = np.cos(t) - 1.0\n        o0 = screw_axes[..., 0]\n        o1 = screw_axes[..., 1]\n        o2 = screw_axes[..., 2]\n        v0 = screw_axes[..., 3]\n        v1 = screw_axes[..., 4]\n        v2 = screw_axes[..., 5]\n        o01tms = o0 * o1 * tms\n        o12tms = o1 * o2 * tms\n        o02tms = o0 * o2 * tms\n        o0cm1 = o0 * cm1\n        o1cm1 = o1 * cm1\n        o2cm1 = o2 * cm1\n        o00tms = o0 * o0 * tms\n        o11tms = o1 * o1 * tms\n        o22tms = o2 * o2 * tms\n        v0 = v0.reshape(*instances_shape)\n        v1 = v1.reshape(*instances_shape)\n        v2 = v2.reshape(*instances_shape)\n        A2Bs[..., 0, 3] = (-v0 * (o11tms + o22tms - t)\n                           + v1 * (o01tms + o2cm1)\n                           + v2 * (o02tms - o1cm1))\n        A2Bs[..., 1, 3] = (v0 * (o01tms - o2cm1)\n                           - v1 * (o00tms + o22tms - t)\n                           + v2 * (o0cm1 + o12tms))\n        A2Bs[..., 2, 3] = (v0 * (o02tms + o1cm1)\n                           - v1 * (o0cm1 - o12tms)\n                           - v2 * (o00tms + o11tms - t))\n\n    A2Bs[ind_only_translation, :3, :3] = np.eye(3)\n    A2Bs[ind_only_translation, :3, 3] = Sthetas[ind_only_translation, 3:]\n\n    return A2Bs",
  "def dual_quaternions_from_pqs(pqs):\n    \"\"\"Get dual quaternions from positions and quaternions.\n\n    Parameters\n    ----------\n    pqs : array-like, shape (..., 7)\n        Poses represented by positions and quaternions in the\n        order (x, y, z, qw, qx, qy, qz)\n\n    Returns\n    -------\n    dqs : array, shape (..., 8)\n        Dual quaternions to represent transforms:\n        (pw, px, py, pz, qw, qx, qy, qz)\n    \"\"\"\n    pqs = np.asarray(pqs)\n    instances_shape = pqs.shape[:-1]\n    out = np.empty(list(instances_shape) + [8])\n\n    # orientation quaternion\n    out[..., :4] = pqs[..., 3:]\n\n    # use memory temporarily to store position\n    out[..., 4] = 0\n    out[..., 5:] = pqs[..., :3]\n\n    out[..., 4:] = 0.5 * batch_concatenate_quaternions(\n        out[..., 4:], out[..., :4])\n    return out",
  "def dual_quaternions_from_transforms(A2Bs):\n    \"\"\"Get dual quaternions from transformations.\n\n    Parameters\n    ----------\n    A2Bs : array-like, shape (..., 4, 4)\n        Poses represented by homogeneous matrices\n\n    Returns\n    -------\n    dqs : array, shape (..., 8)\n        Dual quaternions to represent transforms:\n        (pw, px, py, pz, qw, qx, qy, qz)\n    \"\"\"\n    A2Bs = np.asarray(A2Bs)\n    instances_shape = A2Bs.shape[:-2]\n    out = np.empty(list(instances_shape) + [8])\n\n    # orientation quaternion\n    out[..., :4] = quaternions_from_matrices(A2Bs[..., :3, :3])\n\n    # use memory temporarily to store position\n    out[..., 4] = 0\n    out[..., 5:] = A2Bs[..., :3, 3]\n\n    out[..., 4:] = 0.5 * batch_concatenate_quaternions(\n        out[..., 4:], out[..., :4])\n    return out",
  "def pqs_from_dual_quaternions(dqs):\n    \"\"\"Get positions and quaternions from dual quaternions.\n\n    Parameters\n    ----------\n    dqs : array-like, shape (..., 8)\n        Dual quaternions to represent transforms:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Returns\n    -------\n    pqs : array, shape (..., 7)\n        Poses represented by positions and quaternions in the\n        order (x, y, z, qw, qx, qy, qz)\n    \"\"\"\n    dqs = np.asarray(dqs)\n    instances_shape = dqs.shape[:-1]\n    out = np.empty(list(instances_shape) + [7])\n    out[..., 3:] = dqs[..., :4]\n    out[..., :3] = 2 * batch_concatenate_quaternions(\n        dqs[..., 4:], batch_q_conj(out[..., 3:]))[..., 1:]\n    return out",
  "def transforms_from_dual_quaternions(dqs):\n    \"\"\"Get transformations from dual quaternions.\n\n    Parameters\n    ----------\n    dqs : array-like, shape (..., 8)\n        Dual quaternions to represent transforms:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Returns\n    -------\n    A2Bs : array, shape (..., 4, 4)\n        Poses represented by homogeneous matrices\n    \"\"\"\n    dqs = np.asarray(dqs)\n    instances_shape = dqs.shape[:-1]\n    out = np.empty(list(instances_shape) + [4, 4])\n    out[..., :3, :3] = matrices_from_quaternions(dqs[..., :4])\n    out[..., :3, 3] = 2 * batch_concatenate_quaternions(\n        dqs[..., 4:], batch_q_conj(dqs[..., :4]))[..., 1:]\n    out[..., 3, :3] = 0.0\n    out[..., 3, 3] = 1.0\n    return out",
  "def batch_dq_conj(dqs):\n    \"\"\"Conjugate of dual quaternions.\n\n    There are three different conjugates for dual quaternions. The one that we\n    use here converts (pw, px, py, pz, qw, qx, qy, qz) to\n    (pw, -px, -py, -pz, -qw, qx, qy, qz). It is a combination of the quaternion\n    conjugate and the dual number conjugate.\n\n    Parameters\n    ----------\n    dqs : array-like, shape (..., 8)\n        Dual quaternions to represent transforms:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Returns\n    -------\n    dq_conjugates : array-like, shape (..., 8)\n        Conjugates of dual quaternions: (pw, -px, -py, -pz, -qw, qx, qy, qz)\n    \"\"\"\n    out = np.empty_like(dqs)\n    out[..., 0] = dqs[..., 0]\n    out[..., 1:5] = -dqs[..., 1:5]\n    out[..., 5:] = dqs[..., 5:]\n    return out",
  "def batch_concatenate_dual_quaternions(dqs1, dqs2):\n    \"\"\"Concatenate dual quaternions.\n\n    Suppose we want to apply two extrinsic transforms given by dual\n    quaternions dq1 and dq2 to a vector v. We can either apply dq2 to v and\n    then dq1 to the result or we can concatenate dq1 and dq2 and apply the\n    result to v.\n\n    Parameters\n    ----------\n    dqs1 : array-like, shape (..., 8)\n        Dual quaternions to represent transforms:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    dqs2 : array-like, shape (..., 8)\n        Dual quaternions to represent transforms:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Returns\n    -------\n    dqs3 : array, shape (8,)\n        Products of the two batches of dual quaternions:\n        (pw, px, py, pz, qw, qx, qy, qz)\n    \"\"\"\n    dqs1 = np.asarray(dqs1)\n    dqs2 = np.asarray(dqs2)\n\n    out = np.empty_like(dqs1)\n    out[..., :4] = batch_concatenate_quaternions(\n        dqs1[..., :4], dqs2[..., :4])\n    out[..., 4:] = (\n        batch_concatenate_quaternions(dqs1[..., :4], dqs2[..., 4:]) +\n        batch_concatenate_quaternions(dqs1[..., 4:], dqs2[..., :4]))\n    return out",
  "def batch_dq_prod_vector(dqs, V):\n    \"\"\"Apply transforms represented by a dual quaternions to vectors.\n\n    Parameters\n    ----------\n    dqs : array-like, shape (..., 8)\n        Unit dual quaternions\n\n    V : array-like, shape (..., 3)\n        3d vectors\n\n    Returns\n    -------\n    W : array, shape (3,)\n        3d vectors\n    \"\"\"\n    dqs = np.asarray(dqs)\n\n    v_dqs = np.empty_like(dqs)\n    v_dqs[..., 0] = 1.0\n    v_dqs[..., 1:5] = 0.0\n    v_dqs[..., 5:] = V\n    v_dq_transformed = batch_concatenate_dual_quaternions(\n        batch_concatenate_dual_quaternions(dqs, v_dqs),\n        batch_dq_conj(dqs))\n    return v_dq_transformed[5:]",
  "def plot_trajectory(\n        ax=None, P=None, normalize_quaternions=True, show_direction=True,\n        n_frames=10, s=1.0, ax_s=1, **kwargs):  # pragma: no cover\n    \"\"\"Plot pose trajectory.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    P : array-like, shape (n_steps, 7), optional (default: None)\n        Sequence of poses represented by positions and quaternions in the\n        order (x, y, z, w, vx, vy, vz) for each step\n\n    normalize_quaternions : bool, optional (default: True)\n        Normalize quaternions before plotting\n\n    show_direction : bool, optional (default: True)\n        Plot an arrow to indicate the direction of the trajectory\n\n    n_frames : int, optional (default: 10)\n        Number of frames that should be plotted to indicate the rotation\n\n    s : float, optional (default: 1)\n        Scaling of the frames that will be drawn\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    kwargs : dict, optional (default: {})\n        Additional arguments for the plotting functions, e.g. alpha\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n\n    Raises\n    ------\n    ValueError\n        If trajectory does not contain any elements.\n    \"\"\"\n    if P is None or len(P) == 0:\n        raise ValueError(\"Trajectory does not contain any elements.\")\n\n    if ax is None:\n        from .plot_utils import make_3d_axis\n        ax = make_3d_axis(ax_s)\n\n    A2Bs = transforms_from_pqs(P, normalize_quaternions)\n    from .plot_utils import Trajectory\n    trajectory = Trajectory(A2Bs, show_direction, n_frames, s, **kwargs)\n    trajectory.add_trajectory(ax)\n\n    return ax",
  "def mirror_screw_axis_direction(Sthetas):\n    \"\"\"Switch to the other representation of the same transformation.\n\n    We take the negative of the screw axis, invert the rotation angle\n    and adapt the screw pitch accordingly. For this operation we have\n    to convert exponential coordinates to screw parameters first.\n\n    Parameters\n    ----------\n    Sthetas : array-like, shape (n_steps, 6)\n        Exponential coordinates of transformation:\n        (omega_x, omega_y, omega_z, v_x, v_y, v_z)\n\n    Returns\n    -------\n    Sthetas : array-like, shape (n_steps, 6)\n        Exponential coordinates of transformation:\n        (omega_x, omega_y, omega_z, v_x, v_y, v_z)\n    \"\"\"\n    Sthetas_new = np.empty((len(Sthetas), 6))\n    for i, Stheta in enumerate(Sthetas):\n        S, theta = screw_axis_from_exponential_coordinates(Stheta)\n        q, s, h = screw_parameters_from_screw_axis(S)\n        s_new = -s\n        theta_new = 2.0 * np.pi - theta\n        h_new = -h * theta / theta_new\n        Stheta_new = screw_axis_from_screw_parameters(\n            q, s_new, h_new) * theta_new\n        Sthetas_new[i] = Stheta_new\n    return Sthetas_new",
  "def _block_signals(qobject):\n        \"\"\"Block signals of a QObject in this context.\"\"\"\n        signals_blocked = qobject.blockSignals(True)\n        try:\n            yield qobject\n        finally:\n            qobject.blockSignals(signals_blocked)",
  "def _internal_repr(A2B):\n        \"\"\"Compute internal representation of transform.\"\"\"\n        p = A2B[:3, 3]\n        R = A2B[:3, :3]\n        e = intrinsic_euler_xyz_from_active_matrix(R)\n        return np.hstack((p, e))",
  "class PositionEulerEditor(QWidget):\n        \"\"\"Frame editor that represents orientation by Euler angles (XY'Z'').\n\n        Parameters\n        ----------\n        base_frame : string\n            Name of the base frame\n\n        xlim : tuple\n            Lower and upper limit for the x position. Defines the range of the\n            plot and the range of the slider.\n\n        ylim : tuple\n            Lower and upper limit for the y position. Defines the range of the\n            plot and the range of the slider.\n\n        zlim : tuple\n            Lower and upper limit for the z position. Defines the range of the\n            plot and the range of the slider.\n\n        parent : QWidget, optional (default: None)\n            Parent widget.\n        \"\"\"\n        frameChanged = QtCore.pyqtSignal()\n\n        def __init__(self, base_frame, xlim, ylim, zlim, parent=None):\n            super(PositionEulerEditor, self).__init__(parent)\n\n            self.dim_labels = [\"x\", \"y\", \"z\", \"X\", \"Y'\", \"Z''\"]\n            self.limits = [xlim, ylim, zlim,\n                           (-3.141, 3.141), (-1.570, 1.570), (-3.141, 3.141)]\n            self.n_slider_steps = [int(100 * (upper - lower)) + 1\n                                   for lower, upper in self.limits]\n            self.setLayout(self._create(base_frame))\n            self.A2B = None\n\n        def _create(self, base_frame):\n            self.sliders = []\n            self.spinboxes = []\n            for i in range(len(self.dim_labels)):\n                self.sliders.append(QSlider(QtCore.Qt.Horizontal))\n                self.sliders[i].setRange(0, self.n_slider_steps[i])\n                self.sliders[i].valueChanged.connect(\n                    partial(self._on_slide, i))\n                spinbox = QDoubleSpinBox()\n                spinbox.setRange(*self.limits[i])\n                spinbox.setDecimals(3)\n                spinbox.setSingleStep(0.001)\n                self.spinboxes.append(spinbox)\n                self.spinboxes[i].valueChanged.connect(\n                    partial(self._on_pos_edited, i))\n            slider_group = QGridLayout()\n            slider_group.addWidget(QLabel(\"Position\"),\n                                   0, 0, 1, 3, QtCore.Qt.AlignCenter)\n            slider_group.addWidget(QLabel(\"Orientation (Euler angles)\"),\n                                   0, 3, 1, 3, QtCore.Qt.AlignCenter)\n            for i, slider in enumerate(self.sliders):\n                slider_group.addWidget(QLabel(self.dim_labels[i]), 1, i)\n                slider_group.addWidget(slider, 2, i)\n                slider_group.addWidget(self.spinboxes[i], 3, i)\n            slider_groupbox = QGroupBox(\"Transformation in frame '%s'\"\n                                        % base_frame)\n            slider_groupbox.setLayout(slider_group)\n            layout = QHBoxLayout()\n            layout.addWidget(slider_groupbox)\n            layout.addStretch(1)\n            return layout\n\n        def set_frame(self, A2B):\n            \"\"\"Set pose of frame.\n\n            Parameters\n            ----------\n            A2B : array\n                Transformation matrix\n            \"\"\"\n            self.A2B = A2B\n            pose = _internal_repr(self.A2B)\n\n            for i in range(6):\n                pos = self._pos_to_slider_pos(i, pose[i])\n                with _block_signals(self.sliders[i]) as slider:\n                    slider.setValue(pos)\n                with _block_signals(self.spinboxes[i]) as spinbox:\n                    spinbox.setValue(pose[i])\n\n        def _on_pos_edited(self, dim, pos):\n            \"\"\"Slot: value in spinbox changed.\"\"\"\n            pose = _internal_repr(self.A2B)\n            pose[dim] = pos\n            self.A2B = transform_from(active_matrix_from_intrinsic_euler_xyz(\n                pose[3:]), pose[:3])\n\n            for i in range(6):\n                pos = self._pos_to_slider_pos(i, pose[i])\n                with _block_signals(self.sliders[i]) as slider:\n                    slider.setValue(pos)\n\n            self.frameChanged.emit()\n\n        def _on_slide(self, dim, step):\n            \"\"\"Slot: slider position changed.\"\"\"\n            pose = _internal_repr(self.A2B)\n            v = self._slider_pos_to_pos(dim, step)\n            pose[dim] = v\n            self.A2B = transform_from(active_matrix_from_intrinsic_euler_xyz(\n                pose[3:]), pose[:3])\n\n            self.spinboxes[dim].setValue(v)\n\n            self.frameChanged.emit()\n\n        def _pos_to_slider_pos(self, dim, pos):\n            \"\"\"Compute slider position from value.\"\"\"\n            m = self.limits[dim][0]\n            r = self.limits[dim][1] - m\n            slider_pos = int((pos - m) / r * self.n_slider_steps[dim])\n            slider_pos = np.clip(slider_pos, 0, self.n_slider_steps[dim])\n            return slider_pos\n\n        def _slider_pos_to_pos(self, dim, slider_pos):\n            \"\"\"Create value from slider position.\"\"\"\n            m = self.limits[dim][0]\n            r = self.limits[dim][1] - m\n            return m + r * float(slider_pos) / float(self.n_slider_steps[dim])",
  "class TransformEditor(QMainWindow):\n        \"\"\"GUI to edit transformations.\n\n        .. warning::\n\n            Note that this module requires PyQt4.\n\n        Parameters\n        ----------\n        transform_manager : TransformManager\n            All nodes that are reachable from the base frame will be editable\n\n        frame : string\n            Name of the base frame\n\n        xlim : tuple, optional (-1, 1)\n            Lower and upper limit for the x position. Defines the range of the\n            plot and the range of the slider.\n\n        ylim : tuple, optional (-1, 1)\n            Lower and upper limit for the y position. Defines the range of the\n            plot and the range of the slider.\n\n        zlim : tuple, optional (-1, 1)\n            Lower and upper limit for the z position. Defines the range of the\n            plot and the range of the slider.\n\n        s : float, optional (default: 1)\n            Scaling of the axis and angle that will be drawn\n\n        figsize : tuple of integers, optional (default: (10, 10))\n            Width, height in inches.\n\n        dpi : integer, optional (default: 100)\n            Resolution of the figure.\n\n        parent : QWidget, optional (default: None)\n            Parent widget.\n\n        Attributes\n        ----------\n        transform_manager : TransformManager\n            Result, all frames are expressed in the base frame\n        \"\"\"\n        def __init__(self, transform_manager, base_frame, xlim=(-1.0, 1.0),\n                     ylim=(-1.0, 1.0), zlim=(-1.0, 1.0), s=1.0,\n                     figsize=(10, 10), dpi=100, window_size=(500, 600),\n                     parent=None):\n            self.app = QApplication(sys.argv)\n\n            super(TransformEditor, self).__init__(parent)\n            self.transform_manager = self._init_transform_manager(\n                transform_manager, base_frame)\n            self.base_frame = base_frame\n            self.xlim = xlim\n            self.ylim = ylim\n            self.zlim = zlim\n            self.s = s\n            self.figsize = figsize\n            self.dpi = dpi\n            self.window_size = window_size\n\n            self.setWindowTitle(\"Transformation Editor\")\n            self.canvas = None\n            self.fig = None\n            self.axis = None\n\n            self._create_main_frame()\n            self._on_node_changed(0)\n\n        def _init_transform_manager(self, transform_manager, frame):\n            \"\"\"Transform all nodes into the reference frame.\"\"\"\n            tm = TransformManager()\n            if frame not in transform_manager.nodes:\n                raise KeyError(\"Unknown frame '%s'\" % frame)\n\n            for node in transform_manager.nodes:\n                try:\n                    node2frame = transform_manager.get_transform(node, frame)\n                    tm.add_transform(node, frame, node2frame)\n                except KeyError:\n                    pass  # Frame is not connected to the reference frame\n\n            return tm\n\n        def _create_main_frame(self):\n            \"\"\"Create main frame and layout.\"\"\"\n            self.main_frame = QWidget()\n\n            self.frame_editor = PositionEulerEditor(\n                self.base_frame, self.xlim, self.ylim, self.zlim)\n            self.frame_editor.frameChanged.connect(self._on_update)\n\n            self.frame_selection = self._create_frame_selector()\n\n            plot = self._create_plot()\n\n            vbox = QVBoxLayout()\n            vbox.addWidget(self.frame_editor)\n            vbox.addWidget(self.frame_selection)\n            vbox.addWidget(plot)\n\n            main_layout = QHBoxLayout()\n            main_layout.addLayout(vbox)\n\n            self.main_frame.setLayout(main_layout)\n            self.setCentralWidget(self.main_frame)\n            self.setGeometry(0, 0, *self.window_size)\n\n        def _create_frame_selector(self):\n            frame_selection = QComboBox()\n            for node in self.transform_manager.nodes:\n                if node != self.base_frame:\n                    frame_selection.addItem(node)\n            frame_selection.activated.connect(self._on_node_changed)\n            return frame_selection\n\n        def _create_plot(self):\n            plot = QWidget()\n            canvas_group = QGridLayout()\n            self.fig = Figure(self.figsize, dpi=self.dpi)\n            self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1)\n            self.canvas = FigureCanvasQTAgg(self.fig)\n            self.canvas.setParent(self.main_frame)\n            canvas_group.addWidget(self.canvas, 1, 0)\n            mpl_toolbar = NavigationToolbar2QT(self.canvas, self.main_frame)\n            canvas_group.addWidget(mpl_toolbar, 2, 0)\n            plot.setLayout(canvas_group)\n            return plot\n\n        def _on_node_changed(self, node_idx):\n            \"\"\"Slot: manipulatable node changed.\"\"\"\n            self.node = self.frame_selection.itemText(node_idx)\n            A2B = self.transform_manager.get_transform(\n                self.node, self.base_frame)\n            self.frame_editor.set_frame(A2B)\n            self._plot()\n\n        def _on_update(self):\n            \"\"\"Slot: transformation changed.\"\"\"\n            self.transform_manager.add_transform(\n                self.node, self.base_frame, self.frame_editor.A2B)\n            self._plot()\n\n        def _plot(self):\n            \"\"\"Draw plot.\"\"\"\n            if self.axis is None:\n                elev, azim = 30, 60\n            else:\n                elev, azim = self.axis.elev, self.axis.azim\n                self.fig.delaxes(self.axis)\n\n            self.axis = self.fig.add_subplot(111, projection=\"3d\")\n            self.axis.view_init(elev, azim)\n\n            self.axis.set_xlim(self.xlim)\n            self.axis.set_ylim(self.ylim)\n            self.axis.set_zlim(self.zlim)\n\n            p = self.transform_manager.get_transform(\n                self.node, self.base_frame)[:3, 3]\n            self.axis.scatter(p[0], p[1], p[2], s=100)\n            self.transform_manager.plot_frames_in(\n                self.base_frame, ax=self.axis, s=self.s)\n\n            self.canvas.draw()\n\n        def show(self):\n            \"\"\"Start GUI.\"\"\"\n            super(TransformEditor, self).show()\n            self.app.exec_()",
  "def __init__(self, base_frame, xlim, ylim, zlim, parent=None):\n            super(PositionEulerEditor, self).__init__(parent)\n\n            self.dim_labels = [\"x\", \"y\", \"z\", \"X\", \"Y'\", \"Z''\"]\n            self.limits = [xlim, ylim, zlim,\n                           (-3.141, 3.141), (-1.570, 1.570), (-3.141, 3.141)]\n            self.n_slider_steps = [int(100 * (upper - lower)) + 1\n                                   for lower, upper in self.limits]\n            self.setLayout(self._create(base_frame))\n            self.A2B = None",
  "def _create(self, base_frame):\n            self.sliders = []\n            self.spinboxes = []\n            for i in range(len(self.dim_labels)):\n                self.sliders.append(QSlider(QtCore.Qt.Horizontal))\n                self.sliders[i].setRange(0, self.n_slider_steps[i])\n                self.sliders[i].valueChanged.connect(\n                    partial(self._on_slide, i))\n                spinbox = QDoubleSpinBox()\n                spinbox.setRange(*self.limits[i])\n                spinbox.setDecimals(3)\n                spinbox.setSingleStep(0.001)\n                self.spinboxes.append(spinbox)\n                self.spinboxes[i].valueChanged.connect(\n                    partial(self._on_pos_edited, i))\n            slider_group = QGridLayout()\n            slider_group.addWidget(QLabel(\"Position\"),\n                                   0, 0, 1, 3, QtCore.Qt.AlignCenter)\n            slider_group.addWidget(QLabel(\"Orientation (Euler angles)\"),\n                                   0, 3, 1, 3, QtCore.Qt.AlignCenter)\n            for i, slider in enumerate(self.sliders):\n                slider_group.addWidget(QLabel(self.dim_labels[i]), 1, i)\n                slider_group.addWidget(slider, 2, i)\n                slider_group.addWidget(self.spinboxes[i], 3, i)\n            slider_groupbox = QGroupBox(\"Transformation in frame '%s'\"\n                                        % base_frame)\n            slider_groupbox.setLayout(slider_group)\n            layout = QHBoxLayout()\n            layout.addWidget(slider_groupbox)\n            layout.addStretch(1)\n            return layout",
  "def set_frame(self, A2B):\n            \"\"\"Set pose of frame.\n\n            Parameters\n            ----------\n            A2B : array\n                Transformation matrix\n            \"\"\"\n            self.A2B = A2B\n            pose = _internal_repr(self.A2B)\n\n            for i in range(6):\n                pos = self._pos_to_slider_pos(i, pose[i])\n                with _block_signals(self.sliders[i]) as slider:\n                    slider.setValue(pos)\n                with _block_signals(self.spinboxes[i]) as spinbox:\n                    spinbox.setValue(pose[i])",
  "def _on_pos_edited(self, dim, pos):\n            \"\"\"Slot: value in spinbox changed.\"\"\"\n            pose = _internal_repr(self.A2B)\n            pose[dim] = pos\n            self.A2B = transform_from(active_matrix_from_intrinsic_euler_xyz(\n                pose[3:]), pose[:3])\n\n            for i in range(6):\n                pos = self._pos_to_slider_pos(i, pose[i])\n                with _block_signals(self.sliders[i]) as slider:\n                    slider.setValue(pos)\n\n            self.frameChanged.emit()",
  "def _on_slide(self, dim, step):\n            \"\"\"Slot: slider position changed.\"\"\"\n            pose = _internal_repr(self.A2B)\n            v = self._slider_pos_to_pos(dim, step)\n            pose[dim] = v\n            self.A2B = transform_from(active_matrix_from_intrinsic_euler_xyz(\n                pose[3:]), pose[:3])\n\n            self.spinboxes[dim].setValue(v)\n\n            self.frameChanged.emit()",
  "def _pos_to_slider_pos(self, dim, pos):\n            \"\"\"Compute slider position from value.\"\"\"\n            m = self.limits[dim][0]\n            r = self.limits[dim][1] - m\n            slider_pos = int((pos - m) / r * self.n_slider_steps[dim])\n            slider_pos = np.clip(slider_pos, 0, self.n_slider_steps[dim])\n            return slider_pos",
  "def _slider_pos_to_pos(self, dim, slider_pos):\n            \"\"\"Create value from slider position.\"\"\"\n            m = self.limits[dim][0]\n            r = self.limits[dim][1] - m\n            return m + r * float(slider_pos) / float(self.n_slider_steps[dim])",
  "def __init__(self, transform_manager, base_frame, xlim=(-1.0, 1.0),\n                     ylim=(-1.0, 1.0), zlim=(-1.0, 1.0), s=1.0,\n                     figsize=(10, 10), dpi=100, window_size=(500, 600),\n                     parent=None):\n            self.app = QApplication(sys.argv)\n\n            super(TransformEditor, self).__init__(parent)\n            self.transform_manager = self._init_transform_manager(\n                transform_manager, base_frame)\n            self.base_frame = base_frame\n            self.xlim = xlim\n            self.ylim = ylim\n            self.zlim = zlim\n            self.s = s\n            self.figsize = figsize\n            self.dpi = dpi\n            self.window_size = window_size\n\n            self.setWindowTitle(\"Transformation Editor\")\n            self.canvas = None\n            self.fig = None\n            self.axis = None\n\n            self._create_main_frame()\n            self._on_node_changed(0)",
  "def _init_transform_manager(self, transform_manager, frame):\n            \"\"\"Transform all nodes into the reference frame.\"\"\"\n            tm = TransformManager()\n            if frame not in transform_manager.nodes:\n                raise KeyError(\"Unknown frame '%s'\" % frame)\n\n            for node in transform_manager.nodes:\n                try:\n                    node2frame = transform_manager.get_transform(node, frame)\n                    tm.add_transform(node, frame, node2frame)\n                except KeyError:\n                    pass  # Frame is not connected to the reference frame\n\n            return tm",
  "def _create_main_frame(self):\n            \"\"\"Create main frame and layout.\"\"\"\n            self.main_frame = QWidget()\n\n            self.frame_editor = PositionEulerEditor(\n                self.base_frame, self.xlim, self.ylim, self.zlim)\n            self.frame_editor.frameChanged.connect(self._on_update)\n\n            self.frame_selection = self._create_frame_selector()\n\n            plot = self._create_plot()\n\n            vbox = QVBoxLayout()\n            vbox.addWidget(self.frame_editor)\n            vbox.addWidget(self.frame_selection)\n            vbox.addWidget(plot)\n\n            main_layout = QHBoxLayout()\n            main_layout.addLayout(vbox)\n\n            self.main_frame.setLayout(main_layout)\n            self.setCentralWidget(self.main_frame)\n            self.setGeometry(0, 0, *self.window_size)",
  "def _create_frame_selector(self):\n            frame_selection = QComboBox()\n            for node in self.transform_manager.nodes:\n                if node != self.base_frame:\n                    frame_selection.addItem(node)\n            frame_selection.activated.connect(self._on_node_changed)\n            return frame_selection",
  "def _create_plot(self):\n            plot = QWidget()\n            canvas_group = QGridLayout()\n            self.fig = Figure(self.figsize, dpi=self.dpi)\n            self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1)\n            self.canvas = FigureCanvasQTAgg(self.fig)\n            self.canvas.setParent(self.main_frame)\n            canvas_group.addWidget(self.canvas, 1, 0)\n            mpl_toolbar = NavigationToolbar2QT(self.canvas, self.main_frame)\n            canvas_group.addWidget(mpl_toolbar, 2, 0)\n            plot.setLayout(canvas_group)\n            return plot",
  "def _on_node_changed(self, node_idx):\n            \"\"\"Slot: manipulatable node changed.\"\"\"\n            self.node = self.frame_selection.itemText(node_idx)\n            A2B = self.transform_manager.get_transform(\n                self.node, self.base_frame)\n            self.frame_editor.set_frame(A2B)\n            self._plot()",
  "def _on_update(self):\n            \"\"\"Slot: transformation changed.\"\"\"\n            self.transform_manager.add_transform(\n                self.node, self.base_frame, self.frame_editor.A2B)\n            self._plot()",
  "def _plot(self):\n            \"\"\"Draw plot.\"\"\"\n            if self.axis is None:\n                elev, azim = 30, 60\n            else:\n                elev, azim = self.axis.elev, self.axis.azim\n                self.fig.delaxes(self.axis)\n\n            self.axis = self.fig.add_subplot(111, projection=\"3d\")\n            self.axis.view_init(elev, azim)\n\n            self.axis.set_xlim(self.xlim)\n            self.axis.set_ylim(self.ylim)\n            self.axis.set_zlim(self.zlim)\n\n            p = self.transform_manager.get_transform(\n                self.node, self.base_frame)[:3, 3]\n            self.axis.scatter(p[0], p[1], p[2], s=100)\n            self.transform_manager.plot_frames_in(\n                self.base_frame, ax=self.axis, s=self.s)\n\n            self.canvas.draw()",
  "def show(self):\n            \"\"\"Start GUI.\"\"\"\n            super(TransformEditor, self).show()\n            self.app.exec_()",
  "class UrdfTransformManager(TransformManager):\n    \"\"\"Transformation manager that can load URDF files.\n\n    URDF is the `Unified Robot Description Format <http://wiki.ros.org/urdf>`_.\n    URDF allows to define joints between links that can be rotated about one\n    axis. This transformation manager allows to set the joint angles after\n    joints have been added or loaded from an URDF.\n\n    .. warning::\n\n        Note that this module requires the Python package lxml.\n\n    .. note::\n\n        Joint angles must be given in radians.\n\n    Parameters\n    ----------\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    check : bool, optional (default: True)\n        Check if transformation matrices are valid and requested nodes exist,\n        which might significantly slow down some operations.\n    \"\"\"\n    def __init__(self, strict_check=True, check=True):\n        super(UrdfTransformManager, self).__init__(strict_check, check)\n        self._joints = {}\n        self.collision_objects = []\n        self.visuals = []\n\n    def add_joint(self, joint_name, from_frame, to_frame, child2parent, axis,\n                  limits=(float(\"-inf\"), float(\"inf\")), joint_type=\"revolute\"):\n        \"\"\"Add joint.\n\n        Parameters\n        ----------\n        joint_name : str\n            Name of the joint\n\n        from_frame : Hashable\n            Child link of the joint\n\n        to_frame : Hashable\n            Parent link of the joint\n\n        child2parent : array-like, shape (4, 4)\n            Transformation from child to parent\n\n        axis : array-like, shape (3,)\n            Rotation axis of the joint (defined in the child frame)\n\n        limits : pair of float, optional (default: (-inf, inf))\n            Lower and upper joint angle limit\n\n        joint_type : str, optional (default: 'revolute')\n            Joint type: revolute, prismatic, or fixed (continuous is the same\n            as revolute)\n        \"\"\"\n        self.add_transform(from_frame, to_frame, child2parent)\n        self._joints[joint_name] = (\n            from_frame, to_frame, child2parent, norm_vector(axis), limits,\n            joint_type)\n\n    def set_joint(self, joint_name, value):\n        \"\"\"Set joint position.\n\n        Note that joint values are clipped to their limits.\n\n        Parameters\n        ----------\n        joint_name : str\n            Name of the joint\n\n        value : float\n            Joint angle in radians in case of revolute joints or position\n            in case of prismatic joint.\n\n        Raises\n        ------\n        KeyError\n            If joint_name is unknown\n        \"\"\"\n        if joint_name not in self._joints:\n            raise KeyError(\"Joint '%s' is not known\" % joint_name)\n        from_frame, to_frame, child2parent, axis, limits, joint_type = \\\n            self._joints[joint_name]\n        # this is way faster than np.clip:\n        value = min(max(value, limits[0]), limits[1])\n        if joint_type == \"revolute\":\n            joint_rotation = matrix_from_axis_angle(\n                np.hstack((axis, (value,))))\n            joint2A = transform_from(\n                joint_rotation, np.zeros(3), strict_check=self.strict_check)\n        elif joint_type == \"prismatic\":\n            joint_offset = value * axis\n            joint2A = transform_from(\n                np.eye(3), joint_offset, strict_check=self.strict_check)\n        else:\n            assert joint_type == \"fixed\"\n            warnings.warn(\"Trying to set a fixed joint\")\n            return\n        self.add_transform(from_frame, to_frame, concat(\n            joint2A, child2parent, strict_check=self.strict_check,\n            check=self.check))\n\n    def get_joint_limits(self, joint_name):\n        \"\"\"Get limits of a joint.\n\n        Parameters\n        ----------\n        joint_name : str\n            Name of the joint\n\n        Returns\n        -------\n        limits : pair of float\n            Lower and upper joint angle limit\n\n        Raises\n        ------\n        KeyError\n            If joint_name is unknown\n        \"\"\"\n        if joint_name not in self._joints:\n            raise KeyError(\"Joint '%s' is not known\" % joint_name)\n        return self._joints[joint_name][4]\n\n    def load_urdf(self, urdf_xml, mesh_path=None, package_dir=None):\n        \"\"\"Load URDF file into transformation manager.\n\n        Parameters\n        ----------\n        urdf_xml : str\n            Robot definition in URDF\n\n        mesh_path : str, optional (default: None)\n            Path in which we search for meshes that are defined in the URDF.\n            Meshes will be ignored if it is set to None and no 'package_dir'\n            is given.\n\n        package_dir : str, optional (default: None)\n            Some URDFs start file names with 'package://' to refer to the ROS\n            package in which these files (textures, meshes) are located. This\n            variable defines to which path this prefix will be resolved.\n        \"\"\"\n        robot_name, links, joints = parse_urdf(\n            urdf_xml, mesh_path, package_dir, self.strict_check)\n        initialize_urdf_transform_manager(self, robot_name, links, joints)\n\n    def plot_visuals(self, frame, ax=None, ax_s=1, wireframe=False,\n                     convex_hull_of_mesh=True, alpha=0.3):  # pragma: no cover\n        \"\"\"Plot all visuals in a given reference frame.\n\n        Visuals can be boxes, spheres, cylinders, or meshes. Note that visuals\n        that cannot be connected to the reference frame are omitted.\n\n        Parameters\n        ----------\n        frame : Hashable\n            Reference frame\n\n        ax : Matplotlib 3d axis, optional (default: None)\n            If the axis is None, a new 3d axis will be created\n\n        ax_s : float, optional (default: 1)\n            Scaling of the new matplotlib 3d axis\n\n        wireframe : bool, optional (default: False)\n            Plot wireframe (surface otherwise)\n\n        convex_hull_of_mesh : bool, optional (default: True)\n            Displays convex hull of meshes instead of the original mesh. This\n            makes plotting a lot faster with complex meshes.\n\n        alpha : float, optional (default: 0.3)\n            Alpha value of the surface / wireframe that will be plotted\n\n        Returns\n        -------\n        ax : Matplotlib 3d axis\n            New or old axis\n        \"\"\"\n        return self._plot_objects(\n            self.visuals, frame, ax, ax_s, wireframe, convex_hull_of_mesh,\n            alpha)\n\n    def plot_collision_objects(\n            self, frame, ax=None, ax_s=1, wireframe=True,\n            convex_hull_of_mesh=True, alpha=1.0):  # pragma: no cover\n        \"\"\"Plot all collision objects in a given reference frame.\n\n        Collision objects can be boxes, spheres, cylinders, or meshes. Note\n        that collision objects that cannot be connected to the reference frame\n        are omitted.\n\n        Parameters\n        ----------\n        frame : Hashable\n            Reference frame\n\n        ax : Matplotlib 3d axis, optional (default: None)\n            If the axis is None, a new 3d axis will be created\n\n        ax_s : float, optional (default: 1)\n            Scaling of the new matplotlib 3d axis\n\n        wireframe : bool, optional (default: True)\n            Plot wireframe (surface otherwise)\n\n        convex_hull_of_mesh : bool, optional (default: True)\n            Displays convex hull of meshes instead of the original mesh. This\n            makes plotting a lot faster with complex meshes.\n\n        alpha : float, optional (default: 1)\n            Alpha value of the surface / wireframe that will be plotted\n\n        Returns\n        -------\n        ax : Matplotlib 3d axis\n            New or old axis\n        \"\"\"\n        return self._plot_objects(\n            self.collision_objects, frame, ax, ax_s, wireframe,\n            convex_hull_of_mesh, alpha)\n\n    def _plot_objects(self, objects, frame, ax=None, ax_s=1, wireframe=True,\n                      convex_hull_of_mesh=True, alpha=1.0):  # pragma: no cover\n        \"\"\"Plot all objects in a given reference frame.\n\n        Objects can be boxes, spheres, cylinders, or meshes. Note that objects\n        that cannot be connected to the reference frame are omitted.\n\n        Parameters\n        ----------\n        objects : list\n            Objects that will be plotted\n\n        frame : Hashable\n            Reference frame\n\n        ax : Matplotlib 3d axis, optional (default: None)\n            If the axis is None, a new 3d axis will be created\n\n        ax_s : float, optional (default: 1)\n            Scaling of the new matplotlib 3d axis\n\n        wireframe : bool, optional (default: True)\n            Plot wireframe (surface otherwise)\n\n        convex_hull_of_mesh : bool, optional (default: True)\n            Displays convex hull of meshes instead of the original mesh. This\n            makes plotting a lot faster with complex meshes.\n\n        alpha : float, optional (default: 1)\n            Alpha value of the surface / wireframe that will be plotted\n\n        Returns\n        -------\n        ax : Matplotlib 3d axis\n            New or old axis\n        \"\"\"\n        if ax is None:\n            from .plot_utils import make_3d_axis\n            ax = make_3d_axis(ax_s)\n        for obj in objects:\n            ax = obj.plot(\n                self, frame, ax, wireframe=wireframe,\n                convex_hull=convex_hull_of_mesh, alpha=alpha)\n        return ax",
  "def parse_urdf(urdf_xml, mesh_path=None, package_dir=None, strict_check=True):\n    \"\"\"Parse information from URDF file.\n\n    Parameters\n    ----------\n    urdf_xml : str\n        Robot definition in URDF\n\n    mesh_path : str, optional (default: None)\n        Path in which we search for meshes that are defined in the URDF.\n        Meshes will be ignored if it is set to None and no 'package_dir'\n        is given.\n\n    package_dir : str, optional (default: None)\n        Some URDFs start file names with 'package://' to refer to the ROS\n        package in which these files (textures, meshes) are located. This\n        variable defines to which path this prefix will be resolved.\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    Returns\n    -------\n    robot_name : str\n        Name of the robot\n\n    links : list of Link\n        Links of the robot\n\n    joints : list of Joint\n        Joints of the robot\n\n    Raises\n    ------\n    UrdfException\n        If URDF is not valid\n    \"\"\"\n    # lxml does not allow whitespaces in the beginning\n    urdf_xml = urdf_xml.strip()\n    # lxml complains about unicode strings that start with unicode encoding\n    # declaration. Hence, we have to convert them to bytes first.\n    urdf_xml = bytes(urdf_xml.encode(\"utf-8\"))\n    try:\n        root = etree.XML(urdf_xml, parser=etree.XMLParser(recover=True))\n    except etree.XMLSyntaxError:\n        raise UrdfException(\"Invalid XML.\")\n\n    # URDF XML schema:\n    # https://github.com/ros/urdfdom/blob/master/xsd/urdf.xsd\n\n    if root.tag != \"robot\":\n        raise UrdfException(\"Robot tag is missing.\")\n\n    tree = etree.ElementTree(root)\n\n    if \"name\" not in root.attrib:\n        raise UrdfException(\"Attribute 'name' is missing in robot tag.\")\n\n    robot_name = root.attrib[\"name\"]\n\n    materials = dict([_parse_material(material)\n                      for material in tree.findall(\"material\")])\n\n    links = [_parse_link(link, materials, mesh_path, package_dir, strict_check)\n             for link in tree.findall(\"link\")]\n\n    link_names = [link.name for link in links]\n    joints = [_parse_joint(joint, link_names, strict_check)\n              for joint in tree.findall(\"joint\")]\n\n    return robot_name, links, joints",
  "def initialize_urdf_transform_manager(tm, robot_name, links, joints):\n    \"\"\"Initializes transform manager from previously parsed URDF data.\n\n    Parameters\n    ----------\n    tm : UrdfTransformManager\n        Transform manager\n\n    robot_name : str\n        Name of the robot\n\n    links : list of Link\n        Links of the robot\n\n    joints : list of Joint\n        Joints of the robot\n    \"\"\"\n    tm.add_transform(links[0].name, robot_name, np.eye(4))\n    _add_links(tm, links)\n    _add_joints(tm, joints)",
  "def _parse_material(material):\n    \"\"\"Parse material.\"\"\"\n    if \"name\" not in material.attrib:\n        raise UrdfException(\"Material name is missing.\")\n    colors = material.findall(\"color\")\n    if len(colors) not in [0, 1]:\n        raise UrdfException(\"More than one color is not allowed.\")\n    if len(colors) == 1:\n        color = _parse_color(colors[0])\n    else:\n        color = None\n    # TODO texture is currently ignored\n    return material.attrib[\"name\"], color",
  "def _parse_color(color):\n    \"\"\"Parse color.\"\"\"\n    if \"rgba\" not in color.attrib:\n        raise UrdfException(\"Attribute 'rgba' of color tag is missing.\")\n    return np.fromstring(color.attrib[\"rgba\"], sep=\" \")",
  "def _parse_link(link, materials, mesh_path, package_dir, strict_check):\n    \"\"\"Create link.\"\"\"\n    if \"name\" not in link.attrib:\n        raise UrdfException(\"Link name is missing.\")\n\n    result = Link()\n    result.name = link.attrib[\"name\"]\n\n    visuals, visual_transforms = _parse_link_children(\n        link, \"visual\", materials, mesh_path, package_dir, strict_check)\n    result.visuals = visuals\n    result.transforms.extend(visual_transforms)\n\n    collision_objects, collision_object_transforms = _parse_link_children(\n        link, \"collision\", dict(), mesh_path, package_dir, strict_check)\n    result.collision_objects = collision_objects\n    result.transforms.extend(collision_object_transforms)\n\n    inertial = link.find(\"inertial\")\n    if inertial is not None:\n        result.inertial_frame[:, :] = _parse_origin(inertial, strict_check)\n        result.mass = _parse_mass(inertial)\n        result.inertia[:, :] = _parse_inertia(inertial)\n        result.transforms.append(\n            (\"inertial_frame:%s\" % result.name, result.name,\n             result.inertial_frame))\n\n    return result",
  "def _parse_link_children(link, child_type, materials, mesh_path, package_dir,\n                         strict_check):\n    \"\"\"Parse collision objects or visuals.\"\"\"\n    children = link.findall(child_type)\n    shape_objects = []\n    transforms = []\n    for i, child in enumerate(children):\n        if \"name\" in child.attrib:\n            name = \"%s:%s/%s\" % (child_type, link.attrib[\"name\"],\n                                 child.attrib[\"name\"])\n        else:\n            name = \"%s:%s/%s\" % (child_type, link.attrib[\"name\"], i)\n\n        color = None\n        if child_type == \"visual\":\n            material = child.find(\"material\")\n            if material is not None:\n                material_name, color = _parse_material(material)\n                if color is None and material_name in materials:\n                    color = materials[material_name]\n\n        child2link = _parse_origin(child, strict_check)\n        transforms.append((name, link.attrib[\"name\"], child2link))\n\n        shape_objects.extend(_parse_geometry(\n            child, name, color, mesh_path, package_dir))\n    return shape_objects, transforms",
  "def _parse_geometry(child, name, color, mesh_path, package_dir):\n    \"\"\"Parse geometric primitives (box, cylinder, sphere) or meshes.\"\"\"\n    geometry = child.find(\"geometry\")\n    if geometry is None:\n        raise UrdfException(\"Missing geometry tag in link '%s'\" % name)\n    result = []\n    for shape_type in [\"box\", \"cylinder\", \"sphere\", \"mesh\"]:\n        shapes = geometry.findall(shape_type)\n        Cls = shape_classes[shape_type]\n        for shape in shapes:\n            shape_object = Cls(\n                name, mesh_path=mesh_path, package_dir=package_dir,\n                color=color)\n            shape_object.parse(shape)\n            result.append(shape_object)\n    return result",
  "def _parse_origin(entry, strict_check):\n    \"\"\"Parse transformation.\"\"\"\n    origin = entry.find(\"origin\")\n    translation = np.zeros(3)\n    rotation = np.eye(3)\n    if origin is not None:\n        if \"xyz\" in origin.attrib:\n            translation = np.fromstring(origin.attrib[\"xyz\"], sep=\" \")\n        if \"rpy\" in origin.attrib:\n            roll_pitch_yaw = np.fromstring(origin.attrib[\"rpy\"], sep=\" \")\n            # URDF and KDL use the active convention for rotation matrices.\n            # For more details on how the URDF parser handles the\n            # conversion from Euler angles, see this blog post:\n            # https://orbitalstation.wordpress.com/tag/quaternion/\n            rotation = active_matrix_from_extrinsic_roll_pitch_yaw(\n                roll_pitch_yaw)\n    return transform_from(\n        rotation, translation, strict_check=strict_check)",
  "def _parse_mass(inertial):\n    \"\"\"Parse link mass.\"\"\"\n    mass = inertial.find(\"mass\")\n    if mass is not None and \"value\" in mass.attrib:\n        result = float(mass.attrib[\"value\"])\n    else:\n        result = 0.0\n    return result",
  "def _parse_inertia(inertial):\n    \"\"\"Parse inertia matrix.\"\"\"\n    inertia = inertial.find(\"inertia\")\n\n    result = np.zeros((3, 3))\n    if inertia is None:\n        return result\n\n    if \"ixx\" in inertia.attrib:\n        result[0, 0] = float(inertia.attrib[\"ixx\"])\n    if \"ixy\" in inertia.attrib:\n        ixy = float(inertia.attrib[\"ixy\"])\n        result[0, 1] = ixy\n        result[1, 0] = ixy\n    if \"ixz\" in inertia.attrib:\n        ixz = float(inertia.attrib[\"ixz\"])\n        result[0, 2] = ixz\n        result[2, 0] = ixz\n    if \"iyy\" in inertia.attrib:\n        result[1, 1] = float(inertia.attrib[\"iyy\"])\n    if \"iyz\" in inertia.attrib:\n        iyz = float(inertia.attrib[\"iyz\"])\n        result[1, 2] = iyz\n        result[2, 1] = iyz\n    if \"izz\" in inertia.attrib:\n        result[2, 2] = float(inertia.attrib[\"izz\"])\n    return result",
  "def _parse_joint(joint, link_names, strict_check):\n    \"\"\"Create joint object.\"\"\"\n    j = Joint()\n\n    if \"name\" not in joint.attrib:\n        raise UrdfException(\"Joint name is missing.\")\n    j.joint_name = joint.attrib[\"name\"]\n\n    if \"type\" not in joint.attrib:\n        raise UrdfException(\"Joint type is missing in joint '%s'.\"\n                            % j.joint_name)\n\n    parent = joint.find(\"parent\")\n    if parent is None:\n        raise UrdfException(\"No parent specified in joint '%s'\"\n                            % j.joint_name)\n    if \"link\" not in parent.attrib:\n        raise UrdfException(\"No parent link name given in joint '%s'.\"\n                            % j.joint_name)\n    j.parent = parent.attrib[\"link\"]\n    if j.parent not in link_names:\n        raise UrdfException(\"Parent link '%s' of joint '%s' is not \"\n                            \"defined.\" % (j.parent, j.joint_name))\n\n    child = joint.find(\"child\")\n    if child is None:\n        raise UrdfException(\"No child specified in joint '%s'\"\n                            % j.joint_name)\n    if \"link\" not in child.attrib:\n        raise UrdfException(\"No child link name given in joint '%s'.\"\n                            % j.joint_name)\n    j.child = child.attrib[\"link\"]\n    if j.child not in link_names:\n        raise UrdfException(\"Child link '%s' of joint '%s' is not \"\n                            \"defined.\" % (j.child, j.joint_name))\n\n    j.joint_type = joint.attrib[\"type\"]\n\n    if j.joint_type in [\"planar\", \"floating\"]:\n        raise UrdfException(\"Unsupported joint type '%s'\" % j.joint_type)\n    if j.joint_type not in [\"revolute\", \"continuous\", \"prismatic\",\n                            \"fixed\"]:\n        raise UrdfException(\"Joint type '%s' is not allowed in a URDF \"\n                            \"document.\" % j.joint_type)\n\n    j.child2parent = _parse_origin(joint, strict_check)\n\n    j.joint_axis = np.array([1, 0, 0])\n    if j.joint_type in [\"revolute\", \"continuous\", \"prismatic\"]:\n        axis = joint.find(\"axis\")\n        if axis is not None and \"xyz\" in axis.attrib:\n            j.joint_axis = np.fromstring(axis.attrib[\"xyz\"], sep=\" \")\n\n    j.limits = _parse_limits(joint)\n    return j",
  "def _parse_limits(joint):\n    \"\"\"Parse joint limits.\"\"\"\n    limit = joint.find(\"limit\")\n    lower, upper = float(\"-inf\"), float(\"inf\")\n    if limit is not None:\n        if \"lower\" in limit.attrib:\n            lower = float(limit.attrib[\"lower\"])\n        if \"upper\" in limit.attrib:\n            upper = float(limit.attrib[\"upper\"])\n    return lower, upper",
  "def _add_links(tm, links):\n    \"\"\"Add previously parsed links.\n\n    Parameters\n    ----------\n    tm : UrdfTransformManager\n        Transform manager\n\n    links : list of Link\n        Joint information from URDF\n    \"\"\"\n    for link in links:\n        tm.visuals.extend(link.visuals)\n        tm.collision_objects.extend(link.collision_objects)\n\n        for from_frame, to_frame, transform in link.transforms:\n            tm.add_transform(from_frame, to_frame, transform)",
  "def _add_joints(tm, joints):\n    \"\"\"Add previously parsed joints.\n\n    Parameters\n    ----------\n    tm : UrdfTransformManager\n        Transform manager\n\n    joints : list of Joint\n        Joint information from URDF\n    \"\"\"\n    for joint in joints:\n        if joint.joint_type in [\"revolute\", \"continuous\"]:\n            tm.add_joint(\n                joint.joint_name, joint.child, joint.parent,\n                joint.child2parent, joint.joint_axis, joint.limits,\n                \"revolute\")\n        elif joint.joint_type == \"prismatic\":\n            tm.add_joint(\n                joint.joint_name, joint.child, joint.parent,\n                joint.child2parent, joint.joint_axis, joint.limits,\n                \"prismatic\")\n        else:\n            assert joint.joint_type == \"fixed\"\n            tm.add_joint(\n                joint.joint_name, joint.child, joint.parent,\n                joint.child2parent, joint.joint_axis, (0.0, 0.0),\n                \"fixed\")",
  "class Link(object):\n    \"\"\"Link from URDF file.\n\n    This class is only required temporarily while we parse the URDF.\n\n    Attributes\n    ----------\n    name : str\n        Link name\n\n    visuals : list of Geometry\n        Visual geometries\n\n    collision_objects : list of Geometry\n        Geometries for collision calculation\n\n    transforms : list\n        Transformations given as tuples: name of frame A, name of frame B,\n        transform A2B\n\n    inertial_frame : array, shape (4, 4)\n        Pose of inertial frame with respect to the link\n\n    mass : float\n        Mass of the link\n\n    inertia : array, shape (3, 3)\n        Inertia matrix\n    \"\"\"\n    def __init__(self):\n        self.name = None\n        self.visuals = []\n        self.collision_objects = []\n        self.transforms = []\n        self.inertial_frame = np.eye(4)\n        self.mass = 0.0\n        self.inertia = np.zeros((3, 3))",
  "class Joint(object):\n    \"\"\"Joint from URDF file.\n\n    This class is only required temporarily while we parse the URDF.\n\n    Attributes\n    ----------\n    child : str\n        Name of the child\n\n    parent : str\n        Name of the parent frame\n\n    child2parent : array-like, shape (4, 4)\n        Transformation from child to parent\n\n    joint_name : str\n        Name of the joint that defines the transformation\n\n    joint_axis : array-like, shape (3,)\n        Rotation axis of the joint (defined in the child frame)\n\n    joint_type : str\n        Either 'fixed' or 'revolute'\n\n    limits : pair of float\n        Lower and upper joint angle limit\n    \"\"\"\n    def __init__(self):\n        self.child = None\n        self.parent = None\n        self.child2parent = np.eye(4)\n        self.joint_name = None\n        self.joint_axis = None\n        self.joint_type = \"fixed\"\n        self.limits = float(\"-inf\"), float(\"inf\")",
  "class Geometry(object):\n    \"\"\"Geometrical object.\"\"\"\n    def __init__(self, frame, mesh_path, package_dir, color):\n        self.frame = frame\n        self.mesh_path = mesh_path\n        self.package_dir = package_dir\n        self.color = color\n\n    def parse(self, xml):\n        \"\"\"Parse parameters of geometry.\"\"\"\n\n    def plot(self, tm, frame, ax=None, alpha=0.3, wireframe=True,\n             convex_hull=True):\n        \"\"\"Plot geometry.\"\"\"",
  "class Box(Geometry):\n    \"\"\"Geometrical object: box.\"\"\"\n    def __init__(self, frame, mesh_path, package_dir, color):\n        super(Box, self).__init__(frame, mesh_path, package_dir, color)\n        self.size = np.zeros(3)\n\n    def parse(self, xml):\n        \"\"\"Parse box size.\"\"\"\n        if \"size\" in xml.attrib:\n            self.size[:] = np.fromstring(xml.attrib[\"size\"], sep=\" \")\n\n    def plot(self, tm, frame, ax=None, alpha=0.3, wireframe=True,\n             convex_hull=True):  # pragma: no cover\n        \"\"\"Plot box.\"\"\"\n        A2B = tm.get_transform(self.frame, frame)\n        color = self.color if self.color is not None else \"k\"\n        from .plot_utils import plot_box\n        return plot_box(\n            ax, self.size, A2B, wireframe=wireframe, alpha=alpha, color=color)",
  "class Sphere(Geometry):\n    \"\"\"Geometrical object: sphere.\"\"\"\n    def __init__(self, frame, mesh_path, package_dir, color):\n        super(Sphere, self).__init__(frame, mesh_path, package_dir, color)\n        self.radius = 0.0\n\n    def parse(self, xml):\n        \"\"\"Parse sphere radius.\"\"\"\n        if \"radius\" not in xml.attrib:\n            raise UrdfException(\"Sphere has no radius.\")\n        self.radius = float(xml.attrib[\"radius\"])\n\n    def plot(self, tm, frame, ax=None, alpha=0.3, wireframe=True,\n             convex_hull=True):  # pragma: no cover\n        \"\"\"Plot sphere.\"\"\"\n        center = tm.get_transform(self.frame, frame)[:3, 3]\n        color = self.color if self.color is not None else \"k\"\n        from .plot_utils import plot_sphere\n        return plot_sphere(\n            ax, self.radius, center, wireframe=wireframe, alpha=alpha,\n            color=color)",
  "class Cylinder(Geometry):\n    \"\"\"Geometrical object: cylinder.\"\"\"\n    def __init__(self, frame, mesh_path, package_dir, color):\n        super(Cylinder, self).__init__(frame, mesh_path, package_dir, color)\n        self.radius = 0.0\n        self.length = 0.0\n\n    def parse(self, xml):\n        \"\"\"Parse cylinder radius and length.\"\"\"\n        if \"radius\" not in xml.attrib:\n            raise UrdfException(\"Cylinder has no radius.\")\n        self.radius = float(xml.attrib[\"radius\"])\n        if \"length\" not in xml.attrib:\n            raise UrdfException(\"Cylinder has no length.\")\n        self.length = float(xml.attrib[\"length\"])\n\n    def plot(self, tm, frame, ax=None, alpha=0.3, wireframe=True,\n             convex_hull=True):  # pragma: no cover\n        \"\"\"Plot cylinder.\"\"\"\n        A2B = tm.get_transform(self.frame, frame)\n        color = self.color if self.color is not None else \"k\"\n        from .plot_utils import plot_cylinder\n        return plot_cylinder(\n            ax, self.length, self.radius, 0.0, A2B, wireframe=wireframe,\n            alpha=alpha, color=color)",
  "class Mesh(Geometry):\n    \"\"\"Geometrical object: mesh.\"\"\"\n    def __init__(self, frame, mesh_path, package_dir, color):\n        super(Mesh, self).__init__(frame, mesh_path, package_dir, color)\n        self.filename = None\n        self.scale = np.ones(3)\n\n    def parse(self, xml):\n        \"\"\"Parse mesh filename and scale.\"\"\"\n        if self.mesh_path is None and self.package_dir is None:\n            self.filename = None\n        else:\n            if \"filename\" not in xml.attrib:\n                raise UrdfException(\"Mesh has no filename.\")\n            if self.mesh_path is not None:\n                self.filename = os.path.join(\n                    self.mesh_path, xml.attrib[\"filename\"])\n            else:\n                assert self.package_dir is not None\n                self.filename = xml.attrib[\"filename\"].replace(\n                    \"package://\", self.package_dir)\n            if \"scale\" in xml.attrib:\n                self.scale = np.fromstring(xml.attrib[\"scale\"], sep=\" \")\n\n    def plot(self, tm, frame, ax=None, alpha=0.3, wireframe=True,\n             convex_hull=True):  # pragma: no cover\n        \"\"\"Plot mesh.\"\"\"\n        from .plot_utils import plot_mesh\n        A2B = tm.get_transform(self.frame, frame)\n        color = self.color if self.color is not None else \"k\"\n        return plot_mesh(\n            ax, self.filename, A2B, self.scale, wireframe=wireframe,\n            convex_hull=convex_hull, alpha=alpha, color=color)",
  "class UrdfException(Exception):\n    \"\"\"Exception while parsing URDF files.\"\"\"",
  "def __init__(self, strict_check=True, check=True):\n        super(UrdfTransformManager, self).__init__(strict_check, check)\n        self._joints = {}\n        self.collision_objects = []\n        self.visuals = []",
  "def add_joint(self, joint_name, from_frame, to_frame, child2parent, axis,\n                  limits=(float(\"-inf\"), float(\"inf\")), joint_type=\"revolute\"):\n        \"\"\"Add joint.\n\n        Parameters\n        ----------\n        joint_name : str\n            Name of the joint\n\n        from_frame : Hashable\n            Child link of the joint\n\n        to_frame : Hashable\n            Parent link of the joint\n\n        child2parent : array-like, shape (4, 4)\n            Transformation from child to parent\n\n        axis : array-like, shape (3,)\n            Rotation axis of the joint (defined in the child frame)\n\n        limits : pair of float, optional (default: (-inf, inf))\n            Lower and upper joint angle limit\n\n        joint_type : str, optional (default: 'revolute')\n            Joint type: revolute, prismatic, or fixed (continuous is the same\n            as revolute)\n        \"\"\"\n        self.add_transform(from_frame, to_frame, child2parent)\n        self._joints[joint_name] = (\n            from_frame, to_frame, child2parent, norm_vector(axis), limits,\n            joint_type)",
  "def set_joint(self, joint_name, value):\n        \"\"\"Set joint position.\n\n        Note that joint values are clipped to their limits.\n\n        Parameters\n        ----------\n        joint_name : str\n            Name of the joint\n\n        value : float\n            Joint angle in radians in case of revolute joints or position\n            in case of prismatic joint.\n\n        Raises\n        ------\n        KeyError\n            If joint_name is unknown\n        \"\"\"\n        if joint_name not in self._joints:\n            raise KeyError(\"Joint '%s' is not known\" % joint_name)\n        from_frame, to_frame, child2parent, axis, limits, joint_type = \\\n            self._joints[joint_name]\n        # this is way faster than np.clip:\n        value = min(max(value, limits[0]), limits[1])\n        if joint_type == \"revolute\":\n            joint_rotation = matrix_from_axis_angle(\n                np.hstack((axis, (value,))))\n            joint2A = transform_from(\n                joint_rotation, np.zeros(3), strict_check=self.strict_check)\n        elif joint_type == \"prismatic\":\n            joint_offset = value * axis\n            joint2A = transform_from(\n                np.eye(3), joint_offset, strict_check=self.strict_check)\n        else:\n            assert joint_type == \"fixed\"\n            warnings.warn(\"Trying to set a fixed joint\")\n            return\n        self.add_transform(from_frame, to_frame, concat(\n            joint2A, child2parent, strict_check=self.strict_check,\n            check=self.check))",
  "def get_joint_limits(self, joint_name):\n        \"\"\"Get limits of a joint.\n\n        Parameters\n        ----------\n        joint_name : str\n            Name of the joint\n\n        Returns\n        -------\n        limits : pair of float\n            Lower and upper joint angle limit\n\n        Raises\n        ------\n        KeyError\n            If joint_name is unknown\n        \"\"\"\n        if joint_name not in self._joints:\n            raise KeyError(\"Joint '%s' is not known\" % joint_name)\n        return self._joints[joint_name][4]",
  "def load_urdf(self, urdf_xml, mesh_path=None, package_dir=None):\n        \"\"\"Load URDF file into transformation manager.\n\n        Parameters\n        ----------\n        urdf_xml : str\n            Robot definition in URDF\n\n        mesh_path : str, optional (default: None)\n            Path in which we search for meshes that are defined in the URDF.\n            Meshes will be ignored if it is set to None and no 'package_dir'\n            is given.\n\n        package_dir : str, optional (default: None)\n            Some URDFs start file names with 'package://' to refer to the ROS\n            package in which these files (textures, meshes) are located. This\n            variable defines to which path this prefix will be resolved.\n        \"\"\"\n        robot_name, links, joints = parse_urdf(\n            urdf_xml, mesh_path, package_dir, self.strict_check)\n        initialize_urdf_transform_manager(self, robot_name, links, joints)",
  "def plot_visuals(self, frame, ax=None, ax_s=1, wireframe=False,\n                     convex_hull_of_mesh=True, alpha=0.3):  # pragma: no cover\n        \"\"\"Plot all visuals in a given reference frame.\n\n        Visuals can be boxes, spheres, cylinders, or meshes. Note that visuals\n        that cannot be connected to the reference frame are omitted.\n\n        Parameters\n        ----------\n        frame : Hashable\n            Reference frame\n\n        ax : Matplotlib 3d axis, optional (default: None)\n            If the axis is None, a new 3d axis will be created\n\n        ax_s : float, optional (default: 1)\n            Scaling of the new matplotlib 3d axis\n\n        wireframe : bool, optional (default: False)\n            Plot wireframe (surface otherwise)\n\n        convex_hull_of_mesh : bool, optional (default: True)\n            Displays convex hull of meshes instead of the original mesh. This\n            makes plotting a lot faster with complex meshes.\n\n        alpha : float, optional (default: 0.3)\n            Alpha value of the surface / wireframe that will be plotted\n\n        Returns\n        -------\n        ax : Matplotlib 3d axis\n            New or old axis\n        \"\"\"\n        return self._plot_objects(\n            self.visuals, frame, ax, ax_s, wireframe, convex_hull_of_mesh,\n            alpha)",
  "def plot_collision_objects(\n            self, frame, ax=None, ax_s=1, wireframe=True,\n            convex_hull_of_mesh=True, alpha=1.0):  # pragma: no cover\n        \"\"\"Plot all collision objects in a given reference frame.\n\n        Collision objects can be boxes, spheres, cylinders, or meshes. Note\n        that collision objects that cannot be connected to the reference frame\n        are omitted.\n\n        Parameters\n        ----------\n        frame : Hashable\n            Reference frame\n\n        ax : Matplotlib 3d axis, optional (default: None)\n            If the axis is None, a new 3d axis will be created\n\n        ax_s : float, optional (default: 1)\n            Scaling of the new matplotlib 3d axis\n\n        wireframe : bool, optional (default: True)\n            Plot wireframe (surface otherwise)\n\n        convex_hull_of_mesh : bool, optional (default: True)\n            Displays convex hull of meshes instead of the original mesh. This\n            makes plotting a lot faster with complex meshes.\n\n        alpha : float, optional (default: 1)\n            Alpha value of the surface / wireframe that will be plotted\n\n        Returns\n        -------\n        ax : Matplotlib 3d axis\n            New or old axis\n        \"\"\"\n        return self._plot_objects(\n            self.collision_objects, frame, ax, ax_s, wireframe,\n            convex_hull_of_mesh, alpha)",
  "def _plot_objects(self, objects, frame, ax=None, ax_s=1, wireframe=True,\n                      convex_hull_of_mesh=True, alpha=1.0):  # pragma: no cover\n        \"\"\"Plot all objects in a given reference frame.\n\n        Objects can be boxes, spheres, cylinders, or meshes. Note that objects\n        that cannot be connected to the reference frame are omitted.\n\n        Parameters\n        ----------\n        objects : list\n            Objects that will be plotted\n\n        frame : Hashable\n            Reference frame\n\n        ax : Matplotlib 3d axis, optional (default: None)\n            If the axis is None, a new 3d axis will be created\n\n        ax_s : float, optional (default: 1)\n            Scaling of the new matplotlib 3d axis\n\n        wireframe : bool, optional (default: True)\n            Plot wireframe (surface otherwise)\n\n        convex_hull_of_mesh : bool, optional (default: True)\n            Displays convex hull of meshes instead of the original mesh. This\n            makes plotting a lot faster with complex meshes.\n\n        alpha : float, optional (default: 1)\n            Alpha value of the surface / wireframe that will be plotted\n\n        Returns\n        -------\n        ax : Matplotlib 3d axis\n            New or old axis\n        \"\"\"\n        if ax is None:\n            from .plot_utils import make_3d_axis\n            ax = make_3d_axis(ax_s)\n        for obj in objects:\n            ax = obj.plot(\n                self, frame, ax, wireframe=wireframe,\n                convex_hull=convex_hull_of_mesh, alpha=alpha)\n        return ax",
  "def __init__(self):\n        self.name = None\n        self.visuals = []\n        self.collision_objects = []\n        self.transforms = []\n        self.inertial_frame = np.eye(4)\n        self.mass = 0.0\n        self.inertia = np.zeros((3, 3))",
  "def __init__(self):\n        self.child = None\n        self.parent = None\n        self.child2parent = np.eye(4)\n        self.joint_name = None\n        self.joint_axis = None\n        self.joint_type = \"fixed\"\n        self.limits = float(\"-inf\"), float(\"inf\")",
  "def __init__(self, frame, mesh_path, package_dir, color):\n        self.frame = frame\n        self.mesh_path = mesh_path\n        self.package_dir = package_dir\n        self.color = color",
  "def parse(self, xml):\n        \"\"\"Parse parameters of geometry.\"\"\"",
  "def plot(self, tm, frame, ax=None, alpha=0.3, wireframe=True,\n             convex_hull=True):\n        \"\"\"Plot geometry.\"\"\"",
  "def __init__(self, frame, mesh_path, package_dir, color):\n        super(Box, self).__init__(frame, mesh_path, package_dir, color)\n        self.size = np.zeros(3)",
  "def parse(self, xml):\n        \"\"\"Parse box size.\"\"\"\n        if \"size\" in xml.attrib:\n            self.size[:] = np.fromstring(xml.attrib[\"size\"], sep=\" \")",
  "def plot(self, tm, frame, ax=None, alpha=0.3, wireframe=True,\n             convex_hull=True):  # pragma: no cover\n        \"\"\"Plot box.\"\"\"\n        A2B = tm.get_transform(self.frame, frame)\n        color = self.color if self.color is not None else \"k\"\n        from .plot_utils import plot_box\n        return plot_box(\n            ax, self.size, A2B, wireframe=wireframe, alpha=alpha, color=color)",
  "def __init__(self, frame, mesh_path, package_dir, color):\n        super(Sphere, self).__init__(frame, mesh_path, package_dir, color)\n        self.radius = 0.0",
  "def parse(self, xml):\n        \"\"\"Parse sphere radius.\"\"\"\n        if \"radius\" not in xml.attrib:\n            raise UrdfException(\"Sphere has no radius.\")\n        self.radius = float(xml.attrib[\"radius\"])",
  "def plot(self, tm, frame, ax=None, alpha=0.3, wireframe=True,\n             convex_hull=True):  # pragma: no cover\n        \"\"\"Plot sphere.\"\"\"\n        center = tm.get_transform(self.frame, frame)[:3, 3]\n        color = self.color if self.color is not None else \"k\"\n        from .plot_utils import plot_sphere\n        return plot_sphere(\n            ax, self.radius, center, wireframe=wireframe, alpha=alpha,\n            color=color)",
  "def __init__(self, frame, mesh_path, package_dir, color):\n        super(Cylinder, self).__init__(frame, mesh_path, package_dir, color)\n        self.radius = 0.0\n        self.length = 0.0",
  "def parse(self, xml):\n        \"\"\"Parse cylinder radius and length.\"\"\"\n        if \"radius\" not in xml.attrib:\n            raise UrdfException(\"Cylinder has no radius.\")\n        self.radius = float(xml.attrib[\"radius\"])\n        if \"length\" not in xml.attrib:\n            raise UrdfException(\"Cylinder has no length.\")\n        self.length = float(xml.attrib[\"length\"])",
  "def plot(self, tm, frame, ax=None, alpha=0.3, wireframe=True,\n             convex_hull=True):  # pragma: no cover\n        \"\"\"Plot cylinder.\"\"\"\n        A2B = tm.get_transform(self.frame, frame)\n        color = self.color if self.color is not None else \"k\"\n        from .plot_utils import plot_cylinder\n        return plot_cylinder(\n            ax, self.length, self.radius, 0.0, A2B, wireframe=wireframe,\n            alpha=alpha, color=color)",
  "def __init__(self, frame, mesh_path, package_dir, color):\n        super(Mesh, self).__init__(frame, mesh_path, package_dir, color)\n        self.filename = None\n        self.scale = np.ones(3)",
  "def parse(self, xml):\n        \"\"\"Parse mesh filename and scale.\"\"\"\n        if self.mesh_path is None and self.package_dir is None:\n            self.filename = None\n        else:\n            if \"filename\" not in xml.attrib:\n                raise UrdfException(\"Mesh has no filename.\")\n            if self.mesh_path is not None:\n                self.filename = os.path.join(\n                    self.mesh_path, xml.attrib[\"filename\"])\n            else:\n                assert self.package_dir is not None\n                self.filename = xml.attrib[\"filename\"].replace(\n                    \"package://\", self.package_dir)\n            if \"scale\" in xml.attrib:\n                self.scale = np.fromstring(xml.attrib[\"scale\"], sep=\" \")",
  "def plot(self, tm, frame, ax=None, alpha=0.3, wireframe=True,\n             convex_hull=True):  # pragma: no cover\n        \"\"\"Plot mesh.\"\"\"\n        from .plot_utils import plot_mesh\n        A2B = tm.get_transform(self.frame, frame)\n        color = self.color if self.color is not None else \"k\"\n        return plot_mesh(\n            ax, self.filename, A2B, self.scale, wireframe=wireframe,\n            convex_hull=convex_hull, alpha=alpha, color=color)",
  "def estimate_gaussian_transform_from_samples(samples):\n    \"\"\"Estimate Gaussian distribution over transformations from samples.\n\n    Uses iterative approximation of mean described by Eade (2017) and computes\n    covariance in exponential coordinate space (using an unbiased estimator).\n\n    Parameters\n    ----------\n    samples : array-like, shape (n_samples, 4, 4)\n        Sampled transformations represented by homogeneous matrices.\n\n    Returns\n    -------\n    mean : array, shape (4, 4)\n        Mean as homogeneous transformation matrix.\n\n    cov : array, shape (6, 6)\n        Covariance of distribution in exponential coordinate space.\n\n    References\n    ----------\n    Eade: Lie Groups for 2D and 3D Transformations (2017),\n    https://ethaneade.com/lie.pdf\n    \"\"\"\n    assert len(samples) > 0\n    mean = samples[0]\n    for _ in range(20):\n        mean_inv = invert_transform(mean)\n        mean_diffs = exponential_coordinates_from_transforms(\n            concat_many_to_one(samples, mean_inv))\n        avg_mean_diff = np.mean(mean_diffs, axis=0)\n        mean = np.dot(\n            transform_from_exponential_coordinates(avg_mean_diff), mean)\n\n    cov = np.cov(mean_diffs, rowvar=False, bias=True)\n    return mean, cov",
  "def invert_uncertain_transform(mean, cov):\n    r\"\"\"Invert uncertain transform.\n\n    For the mean :math:`\\boldsymbol{T}_{BA}`, the inverse is simply\n    :math:`\\boldsymbol{T}_{BA}^{-1} = \\boldsymbol{T}_{AB}`.\n\n    For the covariance, we need the adjoint of the inverse transformation\n    :math:`\\left[Ad_{\\boldsymbol{T}_{BA}^{-1}}\\right]`:\n\n    .. math::\n\n        \\boldsymbol{\\Sigma}_{\\boldsymbol{T}_{AB}}\n        =\n        \\left[Ad_{\\boldsymbol{T}_{BA}^{-1}}\\right]\n        \\boldsymbol{\\Sigma}_{\\boldsymbol{T}_{BA}}\n        \\left[Ad_{\\boldsymbol{T}_{BA}^{-1}}\\right]^T\n\n    Parameters\n    ----------\n    mean : array-like, shape (4, 4)\n        Mean of transform from frame A to frame B.\n\n    cov : array, shape (6, 6)\n        Covariance of transform from frame A to frame B in exponential\n        coordinate space.\n\n    Returns\n    -------\n    mean_inv : array, shape (4, 4)\n        Mean of transform from frame B to frame A.\n\n    cov_inv : array, shape (6, 6)\n        Covariance of transform from frame B to frame A in exponential\n        coordinate space.\n\n    References\n    ----------\n    Mangelson, Ghaffari, Vasudevan, Eustice: Characterizing the Uncertainty of\n    Jointly Distributed Poses in the Lie Algebra,\n    https://arxiv.org/pdf/1906.07795.pdf\n    \"\"\"\n    mean_inv = invert_transform(mean)\n    ad_inv = adjoint_from_transform(mean_inv)\n    cov_inv = np.dot(ad_inv, np.dot(cov, ad_inv.T))\n    return mean_inv, cov_inv",
  "def concat_globally_uncertain_transforms(mean_A2B, cov_A2B, mean_B2C, cov_B2C):\n    r\"\"\"Concatenate two independent globally uncertain transformations.\n\n    We assume that the two distributions are independent.\n\n    Each of the two transformations is globally uncertain (not in the local /\n    body frame), that is, samples are generated through\n\n    .. math::\n\n        \\boldsymbol{T} = Exp(\\boldsymbol{\\xi}) \\overline{\\boldsymbol{T}},\n\n    where :math:`\\boldsymbol{T} \\in SE(3)` is a sampled transformation matrix,\n    :math:`\\overline{\\boldsymbol{T}} \\in SE(3)` is the mean transformation,\n    and :math:`\\boldsymbol{\\xi} \\in \\mathbb{R}^6` are exponential coordinates\n    of transformations and are distributed according to a Gaussian\n    distribution with zero mean and covariance :math:`\\boldsymbol{\\Sigma} \\in\n    \\mathbb{R}^{6 \\times 6}`, that is, :math:`\\boldsymbol{\\xi} \\sim\n    \\mathcal{N}(\\boldsymbol{0}, \\boldsymbol{\\Sigma})`.\n\n    The concatenation order is the same as in\n    :func:`~pytransform3d.transformations.concat`, that is, the transformation\n    B2C is left-multiplied to A2B. Note that the order of arguments is\n    different from\n    :func:`~pytransform3d.uncertainty.concat_locally_uncertain_transforms`.\n\n    Hence, the full model is\n\n    .. math::\n\n        Exp(_C\\boldsymbol{\\xi'}) \\overline{\\boldsymbol{T}}_{CA} =\n        Exp(_C\\boldsymbol{\\xi}) \\overline{\\boldsymbol{T}}_{CB}\n        Exp(_B\\boldsymbol{\\xi}) \\overline{\\boldsymbol{T}}_{BA},\n\n    where :math:`_B\\boldsymbol{\\xi} \\sim \\mathcal{N}(\\boldsymbol{0},\n    \\boldsymbol{\\Sigma}_{BA})`, :math:`_C\\boldsymbol{\\xi} \\sim\n    \\mathcal{N}(\\boldsymbol{0}, \\boldsymbol{\\Sigma}_{CB})`, and\n    :math:`_C\\boldsymbol{\\xi'} \\sim \\mathcal{N}(\\boldsymbol{0},\n    \\boldsymbol{\\Sigma}_{CA})`.\n\n    This version of Barfoot and Furgale approximates the covariance up to\n    4th-order terms. Note that it is still an approximation of the covariance\n    after concatenation of the two transforms.\n\n    Parameters\n    ----------\n    mean_A2B : array, shape (4, 4)\n        Mean of transform from A to B.\n\n    cov_A2B : array, shape (6, 6)\n        Covariance of transform from A to B. Models uncertainty in frame B.\n\n    mean_B2C : array, shape (4, 4)\n        Mean of transform from B to C.\n\n    cov_B2C : array, shape (6, 6)\n        Covariance of transform from B to C. Models uncertainty in frame C.\n\n    Returns\n    -------\n    mean_A2C : array, shape (4, 4)\n        Mean of new pose.\n\n    cov_A2C : array, shape (6, 6)\n        Covariance of new pose. Models uncertainty in frame C.\n\n    References\n    ----------\n    Barfoot, Furgale: Associating Uncertainty With Three-Dimensional Poses for\n    Use in Estimation Problems,\n    http://ncfrn.mcgill.ca/members/pubs/barfoot_tro14.pdf\n    \"\"\"\n    mean_A2C = concat(mean_A2B, mean_B2C)\n\n    ad_B2C = adjoint_from_transform(mean_B2C)\n    cov_A2B_in_C = np.dot(ad_B2C, np.dot(cov_A2B, ad_B2C.T))\n    second_order_terms = cov_B2C + cov_A2B_in_C\n\n    cov_A2C = second_order_terms + _compound_cov_fourth_order_terms(\n        cov_B2C, cov_A2B_in_C)\n\n    return mean_A2C, cov_A2C",
  "def _compound_cov_fourth_order_terms(cov1, cov2_prime):\n    cov1 = _swap_cov(cov1)\n    cov2_prime = _swap_cov(cov2_prime)\n\n    cov1_11 = cov1[:3, :3]\n    cov1_22 = cov1[3:, 3:]\n    cov1_12 = cov1[:3, 3:]\n\n    cov2_11 = cov2_prime[:3, :3]\n    cov2_22 = cov2_prime[3:, 3:]\n    cov2_12 = cov2_prime[:3, 3:]\n\n    A1 = np.block([\n        [_covop1(cov1_22), _covop1(cov1_12 + cov1_12.T)],\n        [np.zeros((3, 3)), _covop1(cov1_22)]\n    ])\n    A2 = np.block([\n        [_covop1(cov2_22), _covop1(cov2_12 + cov2_12.T)],\n        [np.zeros((3, 3)), _covop1(cov2_22)]\n    ])\n    B_11 = (_covop2(cov1_22, cov2_11) + _covop2(cov1_12.T, cov2_12)\n            + _covop2(cov1_12, cov2_12.T) + _covop2(cov1_11, cov2_22))\n    B_12 = _covop2(cov1_22, cov2_12.T) + _covop2(cov1_12.T, cov2_22)\n    B_22 = _covop2(cov1_22, cov2_22)\n    B = np.block([\n        [B_11, B_12],\n        [B_12.T, B_22]\n    ])\n\n    return _swap_cov(\n        (np.dot(A1, cov2_prime) + np.dot(cov2_prime, A1.T)\n         + np.dot(A2, cov1) + np.dot(cov1, A2.T)) / 12.0\n        + B / 4.0\n    )",
  "def _swap_cov(cov):\n    return np.block([\n        [cov[3:, 3:], cov[3:, :3]],\n        [cov[:3, 3:], cov[:3, :3]]\n    ])",
  "def _covop1(A):\n    return -np.trace(A) * np.eye(len(A)) + A",
  "def _covop2(A, B):\n    return np.dot(_covop1(A), _covop1(B)) + _covop1(np.dot(B, A))",
  "def concat_locally_uncertain_transforms(mean_A2B, mean_B2C, cov_A, cov_B):\n    r\"\"\"Concatenate two independent locally uncertain transformations.\n\n    We assume that the two distributions are independent.\n\n    Each of the two transformations is locally uncertain (not in the global /\n    world frame), that is, samples are generated through\n\n    .. math::\n\n        \\boldsymbol{T} = \\overline{\\boldsymbol{T}} Exp(\\boldsymbol{\\xi}),\n\n    where :math:`\\boldsymbol{T} \\in SE(3)` is a sampled transformation matrix,\n    :math:`\\overline{\\boldsymbol{T}} \\in SE(3)` is the mean transformation,\n    and :math:`\\boldsymbol{\\xi} \\in \\mathbb{R}^6` are exponential coordinates\n    of transformations and are distributed according to a Gaussian\n    distribution with zero mean and covariance :math:`\\boldsymbol{\\Sigma} \\in\n    \\mathbb{R}^{6 \\times 6}`, that is, :math:`\\boldsymbol{\\xi} \\sim\n    \\mathcal{N}(\\boldsymbol{0}, \\boldsymbol{\\Sigma})`.\n\n    The concatenation order is the same as in\n    :func:`~pytransform3d.transformations.concat`, that is, the transformation\n    B2C is left-multiplied to A2B. Note that the order of arguments is\n    different from\n    :func:`~pytransform3d.uncertainty.concat_globally_uncertain_transforms`.\n\n    Hence, the full model is\n\n    .. math::\n\n        \\overline{\\boldsymbol{T}}_{CA} Exp(_A\\boldsymbol{\\xi'}) =\n        \\overline{\\boldsymbol{T}}_{CB} Exp(_B\\boldsymbol{\\xi})\n        \\overline{\\boldsymbol{T}}_{BA} Exp(_A\\boldsymbol{\\xi}),\n\n    where :math:`_B\\boldsymbol{\\xi} \\sim \\mathcal{N}(\\boldsymbol{0},\n    \\boldsymbol{\\Sigma}_B)`, :math:`_A\\boldsymbol{\\xi} \\sim\n    \\mathcal{N}(\\boldsymbol{0}, \\boldsymbol{\\Sigma}_A)`, and\n    :math:`_A\\boldsymbol{\\xi'} \\sim \\mathcal{N}(\\boldsymbol{0},\n    \\boldsymbol{\\Sigma}_{A,total})`.\n\n    This version of Meyer et al. approximates the covariance up to 2nd-order\n    terms.\n\n    Parameters\n    ----------\n    mean_A2B : array, shape (4, 4)\n        Mean of transform from A to B: :math:`\\overline{\\boldsymbol{T}}_{BA}`.\n\n    mean_B2C : array, shape (4, 4)\n        Mean of transform from B to C: :math:`\\overline{\\boldsymbol{T}}_{CB}`.\n\n    cov_A : array, shape (6, 6)\n        Covariance of noise in frame A: :math:`\\boldsymbol{\\Sigma}_A`. Noise\n        samples are right-multiplied with the mean transform A2B.\n\n    cov_B : array, shape (6, 6)\n        Covariance of noise in frame B: :math:`\\boldsymbol{\\Sigma}_B`. Noise\n        samples are right-multiplied with the mean transform B2C.\n\n    Returns\n    -------\n    mean_A2C : array, shape (4, 4)\n        Mean of new pose.\n\n    cov_A_total : array, shape (6, 6)\n        Covariance of accumulated noise in frame A.\n\n    References\n    ----------\n    Meyer, Strobl, Triebel: The Probabilistic Robot Kinematics Model and its\n    Application to Sensor Fusion,\n    https://elib.dlr.de/191928/1/202212_ELIB_PAPER_VERSION_with_copyright.pdf\n    \"\"\"\n    mean_A2C = concat(mean_A2B, mean_B2C)\n\n    ad_B2A = adjoint_from_transform(invert_transform(mean_A2B))\n    cov_B_in_A = np.dot(ad_B2A, np.dot(cov_B, ad_B2A.T))\n    cov_A_total = cov_B_in_A + cov_A\n\n    return mean_A2C, cov_A_total",
  "def pose_fusion(means, covs):\n    \"\"\"Fuse Gaussian distributions of multiple poses.\n\n    Parameters\n    ----------\n    means : array-like, shape (n_poses, 4, 4)\n        Homogeneous transformation matrices.\n\n    covs : array-like, shape (n_poses, 6, 6)\n        Covariances of pose distributions in exponential coordinate space.\n\n    Returns\n    -------\n    mean : array, shape (4, 4)\n        Fused pose mean.\n\n    cov : array, shape (6, 6)\n        Fused pose covariance.\n\n    V : float\n        Error of optimization objective.\n\n    References\n    ----------\n    Barfoot, Furgale: Associating Uncertainty With Three-Dimensional Poses for\n    Use in Estimation Problems,\n    http://ncfrn.mcgill.ca/members/pubs/barfoot_tro14.pdf\n    \"\"\"\n    n_poses = len(means)\n    covs_inv = [np.linalg.inv(cov) for cov in covs]\n\n    mean = np.eye(4)\n    LHS = np.empty((6, 6))\n    RHS = np.empty(6)\n    for _ in range(20):\n        LHS[:, :] = 0.0\n        RHS[:] = 0.0\n        for k in range(n_poses):\n            x_ik = exponential_coordinates_from_transform(\n                np.dot(mean, invert_transform(means[k])))\n            J_inv = left_jacobian_SE3_inv(x_ik)\n            J_invT_S = np.dot(J_inv.T, covs_inv[k])\n            LHS += np.dot(J_invT_S, J_inv)\n            RHS += np.dot(J_invT_S, x_ik)\n        x_i = np.linalg.solve(-LHS, RHS)\n        mean = np.dot(transform_from_exponential_coordinates(x_i), mean)\n\n    cov = np.linalg.inv(LHS)\n\n    V = 0.0\n    for k in range(n_poses):\n        x_ik = exponential_coordinates_from_transform(\n            np.dot(mean, invert_transform(means[k])))\n        V += 0.5 * np.dot(x_ik, np.dot(covs_inv[k], x_ik))\n    return mean, cov, V",
  "def to_ellipsoid(mean, cov):\n    \"\"\"Compute error ellipsoid.\n\n    An error ellipsoid indicates the equiprobable surface. The resulting\n    ellipsoid includes one standard deviation of the data along each main\n    axis, which covers approximately 68.27% of the data. Multiplying the\n    radii with factors > 1 will increase the coverage. The usual factors\n    for Gaussian distributions apply:\n\n    * 1 - 68.27%\n    * 1.65 - 90%\n    * 1.96 - 95%\n    * 2 - 95.45%\n    * 2.58 - 99%\n    * 3 - 99.73%\n\n    Parameters\n    ----------\n    mean : array-like, shape (3,)\n        Mean of distribution.\n\n    cov : array-like, shape (3, 3)\n        Covariance of distribution.\n\n    Returns\n    -------\n    ellipsoid2origin : array, shape (4, 4)\n        Ellipsoid frame in world frame. Note that there are multiple solutions\n        possible for the orientation because an ellipsoid is symmetric.\n        A body-fixed rotation around a main axis by 180 degree results in the\n        same ellipsoid.\n\n    radii : array, shape (3,)\n        Radii of ellipsoid, coinciding with standard deviations along the\n        three axes of the ellipsoid. These are sorted in ascending order.\n    \"\"\"\n    from scipy import linalg\n    radii, R = linalg.eigh(cov)\n    if np.linalg.det(R) < 0:  # undo reflection (exploit symmetry)\n        R *= -1\n    ellipsoid2origin = transform_from(R=R, p=mean)\n    return ellipsoid2origin, np.sqrt(np.abs(radii))",
  "def to_projected_ellipsoid(mean, cov, factor=1.96, n_steps=20):\n    \"\"\"Compute projected error ellipsoid.\n\n    An error ellipsoid shows equiprobable points. This is a projection of a\n    Gaussian distribution in exponential coordinate space to 3D.\n\n    Parameters\n    ----------\n    mean : array-like, shape (4, 4)\n        Mean of pose distribution.\n\n    cov : array-like, shape (6, 6)\n        Covariance of pose distribution in exponential coordinate space.\n\n    factor : float, optional (default: 1.96)\n        Multiple of the standard deviations that should be plotted.\n\n    n_steps : int, optional (default: 20)\n        Number of discrete steps plotted in each dimension.\n\n    Returns\n    -------\n    x : array, shape (n_steps, n_steps)\n        Coordinates on x-axis of grid on projected ellipsoid.\n\n    y : array, shape (n_steps, n_steps)\n        Coordinates on y-axis of grid on projected ellipsoid.\n\n    z : array, shape (n_steps, n_steps)\n        Coordinates on z-axis of grid on projected ellipsoid.\n    \"\"\"\n    from scipy import linalg\n    vals, vecs = linalg.eigh(cov)\n    order = vals.argsort()[::-1]\n    vals, vecs = vals[order], vecs[:, order]\n\n    radii = factor * np.sqrt(vals[:3])\n\n    # Grid on ellipsoid in exponential coordinate space\n    radius_x, radius_y, radius_z = radii\n    x, y, z = unit_sphere_surface_grid(n_steps)\n    x *= radius_x\n    y *= radius_y\n    z *= radius_z\n    P = np.column_stack((x.reshape(-1), y.reshape(-1), z.reshape(-1)))\n    P = np.dot(P, vecs[:, :3].T)\n\n    # Grid in Cartesian space\n    T_diff = transforms_from_exponential_coordinates(P)\n    # same as T_diff[m, :3, :3].T.dot(T_diff[m, :3, 3]) for each m\n    P = np.einsum(\"ikj,ik->ij\", T_diff[:, :3, :3], T_diff[:, :3, 3])\n    P = (np.dot(P, mean[:3, :3].T) + mean[np.newaxis, :3, 3]).T\n\n    shape = x.shape\n    x = P[0].reshape(*shape)\n    y = P[1].reshape(*shape)\n    z = P[2].reshape(*shape)\n\n    return x, y, z",
  "def plot_projected_ellipsoid(\n        ax, mean, cov, factor=1.96, wireframe=True, n_steps=20, color=None,\n        alpha=1.0):  # pragma: no cover\n    \"\"\"Plots projected equiprobable ellipsoid in 3D.\n\n    An error ellipsoid shows equiprobable points. This is a projection of a\n    Gaussian distribution in exponential coordinate space to 3D.\n\n    Parameters\n    ----------\n    ax : axis\n        Matplotlib axis.\n\n    mean : array-like, shape (4, 4)\n        Mean pose.\n\n    cov : array-like, shape (6, 6)\n        Covariance in exponential coordinate space.\n\n    factor : float, optional (default: 1.96)\n        Multiple of the standard deviations that should be plotted.\n\n    wireframe : bool, optional (default: True)\n        Plot wireframe of ellipsoid and surface otherwise.\n\n    n_steps : int, optional (default: 20)\n        Number of discrete steps plotted in each dimension.\n\n    color : str, optional (default: None)\n        Color in which the equiprobably lines should be plotted.\n\n    alpha : float, optional (default: 1.0)\n        Alpha value for lines.\n\n    Returns\n    -------\n    ax : axis\n        Matplotlib axis.\n    \"\"\"\n    x, y, z = to_projected_ellipsoid(mean, cov, factor, n_steps)\n\n    if wireframe:\n        ax.plot_wireframe(\n            x, y, z, rstride=2, cstride=2, color=color, alpha=alpha)\n    else:\n        ax.plot_surface(x, y, z, color=color, alpha=alpha, linewidth=0)\n\n    return ax",
  "def norm_vectors(V, out=None):\n    \"\"\"Normalize vectors.\n\n    Parameters\n    ----------\n    V : array-like, shape (..., n)\n        nd vectors\n\n    out : array, shape (..., n), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    V_unit : array, shape (..., n)\n        nd unit vectors with norm 1 or zero vectors\n    \"\"\"\n    V = np.asarray(V)\n    norms = np.linalg.norm(V, axis=-1)\n    if out is None:\n        out = np.empty_like(V)\n    # Avoid division by zero with np.maximum(..., smallest positive float).\n    # The norm is zero only when the vector is zero so this case does not\n    # require further processing.\n    out[...] = V / np.maximum(norms[..., np.newaxis], np.finfo(float).tiny)\n    return out",
  "def angles_between_vectors(A, B):\n    \"\"\"Compute angle between two vectors.\n\n    Parameters\n    ----------\n    A : array-like, shape (..., n)\n        nd vectors\n\n    B : array-like, shape (..., n)\n        nd vectors\n\n    Returns\n    -------\n    angles : array, shape (...)\n        Angles between pairs of vectors from A and B\n    \"\"\"\n    A = np.asarray(A)\n    B = np.asarray(B)\n    n_dims = A.shape[-1]\n    A_norms = np.linalg.norm(A, axis=-1)\n    B_norms = np.linalg.norm(B, axis=-1)\n    AdotB = np.einsum(\n        \"ni,ni->n\", A.reshape(-1, n_dims), B.reshape(-1, n_dims)\n    ).reshape(A.shape[:-1])\n    return np.arccos(np.clip(AdotB / (A_norms * B_norms), -1.0, 1.0))",
  "def active_matrices_from_angles(basis, angles, out=None):\n    \"\"\"Compute active rotation matrices from rotation about basis vectors.\n\n    Parameters\n    ----------\n    basis : int from [0, 1, 2]\n        The rotation axis (0: x, 1: y, 2: z)\n\n    angles : array-like, shape (...)\n        Rotation angles\n\n    out : array, shape (..., 3, 3), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    Rs : array, shape (..., 3, 3)\n        Rotation matrices\n    \"\"\"\n    angles = np.asarray(angles)\n    c = np.cos(angles)\n    s = np.sin(angles)\n\n    R_shape = angles.shape + (3, 3)\n    if out is None:\n        out = np.empty(R_shape)\n\n    out[..., basis, :] = 0.0\n    out[..., :, basis] = 0.0\n    out[..., basis, basis] = 1.0\n    basisp1 = (basis + 1) % 3\n    basisp2 = (basis + 2) % 3\n    out[..., basisp1, basisp1] = c\n    out[..., basisp2, basisp2] = c\n    out[..., basisp1, basisp2] = -s\n    out[..., basisp2, basisp1] = s\n\n    return out",
  "def active_matrices_from_intrinsic_euler_angles(\n        basis1, basis2, basis3, e, out=None):\n    \"\"\"Compute active rotation matrices from intrinsic Euler angles.\n\n    Parameters\n    ----------\n    basis1 : int\n        Basis vector of first rotation. 0 corresponds to x axis, 1 to y axis,\n        and 2 to z axis.\n\n    basis2 : int\n        Basis vector of second rotation. 0 corresponds to x axis, 1 to y axis,\n        and 2 to z axis.\n\n    basis3 : int\n        Basis vector of third rotation. 0 corresponds to x axis, 1 to y axis,\n        and 2 to z axis.\n\n    e : array-like, shape (..., 3)\n        Euler angles\n\n    out : array, shape (..., 3, 3), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    Rs : array, shape (..., 3, 3)\n        Rotation matrices\n    \"\"\"\n    e = np.asarray(e)\n    R_shape = e.shape + (3,)\n    R_alpha = active_matrices_from_angles(basis1, e[..., 0].flat)\n    R_beta = active_matrices_from_angles(basis2, e[..., 1].flat)\n    R_gamma = active_matrices_from_angles(basis3, e[..., 2].flat)\n\n    if out is None:\n        out = np.empty(R_shape)\n\n    out[:] = np.einsum(\n        \"nij,njk->nik\", np.einsum(\"nij,njk->nik\", R_alpha, R_beta),\n        R_gamma).reshape(R_shape)\n\n    return out",
  "def active_matrices_from_extrinsic_euler_angles(\n        basis1, basis2, basis3, e, out=None):\n    \"\"\"Compute active rotation matrices from extrinsic Euler angles.\n\n    Parameters\n    ----------\n    basis1 : int\n        Basis vector of first rotation. 0 corresponds to x axis, 1 to y axis,\n        and 2 to z axis.\n\n    basis2 : int\n        Basis vector of second rotation. 0 corresponds to x axis, 1 to y axis,\n        and 2 to z axis.\n\n    basis3 : int\n        Basis vector of third rotation. 0 corresponds to x axis, 1 to y axis,\n        and 2 to z axis.\n\n    e : array-like, shape (..., 3)\n        Euler angles\n\n    out : array, shape (..., 3, 3), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    Rs : array, shape (..., 3, 3)\n        Rotation matrices\n    \"\"\"\n    e = np.asarray(e)\n    R_shape = e.shape + (3,)\n    R_alpha = active_matrices_from_angles(basis1, e[..., 0].flat)\n    R_beta = active_matrices_from_angles(basis2, e[..., 1].flat)\n    R_gamma = active_matrices_from_angles(basis3, e[..., 2].flat)\n\n    if out is None:\n        out = np.empty(R_shape)\n\n    out[:] = np.einsum(\n        \"nij,njk->nik\", np.einsum(\"nij,njk->nik\", R_gamma, R_beta),\n        R_alpha).reshape(R_shape)\n\n    return out",
  "def matrices_from_compact_axis_angles(\n        A=None, axes=None, angles=None, out=None):\n    \"\"\"Compute rotation matrices from compact axis-angle representations.\n\n    This is called exponential map or Rodrigues' formula.\n\n    This typically results in an active rotation matrix.\n\n    Parameters\n    ----------\n    A : array-like, shape (..., 3)\n        Axes of rotation and rotation angles in compact representation:\n        angle * (x, y, z)\n\n    axes : array, shape (..., 3)\n        If the unit axes of rotation have been precomputed, you can pass them\n        here.\n\n    angles : array, shape (...)\n        If the angles have been precomputed, you can pass them here.\n\n    out : array, shape (..., 3, 3), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    Rs : array, shape (..., 3, 3)\n        Rotation matrices\n    \"\"\"\n    if angles is None:\n        thetas = np.linalg.norm(A, axis=-1)\n    else:\n        thetas = np.asarray(angles)\n\n    if axes is None:\n        omega_unit = norm_vectors(A)\n    else:\n        omega_unit = axes\n\n    c = np.cos(thetas)\n    s = np.sin(thetas)\n    ci = 1.0 - c\n    ux = omega_unit[..., 0]\n    uy = omega_unit[..., 1]\n    uz = omega_unit[..., 2]\n\n    uxs = ux * s\n    uys = uy * s\n    uzs = uz * s\n    ciux = ci * ux\n    ciuy = ci * uy\n    ciuxuy = ciux * uy\n    ciuxuz = ciux * uz\n    ciuyuz = ciuy * uz\n\n    if out is None:\n        out = np.empty(A.shape[:-1] + (3, 3))\n\n    out[..., 0, 0] = ciux * ux + c\n    out[..., 0, 1] = ciuxuy - uzs\n    out[..., 0, 2] = ciuxuz + uys\n    out[..., 1, 0] = ciuxuy + uzs\n    out[..., 1, 1] = ciuy * uy + c\n    out[..., 1, 2] = ciuyuz - uxs\n    out[..., 2, 0] = ciuxuz - uys\n    out[..., 2, 1] = ciuyuz + uxs\n    out[..., 2, 2] = ci * uz * uz + c\n\n    return out",
  "def axis_angles_from_matrices(Rs, traces=None, out=None):\n    \"\"\"Compute compact axis-angle representations from rotation matrices.\n\n    This is called logarithmic map.\n\n    Parameters\n    ----------\n    Rs : array-like, shape (..., 3, 3)\n        Rotation matrices\n\n    traces : array, shape (..., 3)\n        If the traces of rotation matrices been precomputed, you can pass them\n        here.\n\n    out : array, shape (..., 4), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    A : array, shape (..., 4)\n        Axes of rotation and rotation angles: (x, y, z, angle)\n    \"\"\"\n    Rs = np.asarray(Rs)\n\n    instances_shape = Rs.shape[:-2]\n\n    if traces is None:\n        traces = np.einsum(\"nii\", Rs.reshape(-1, 3, 3))\n        if instances_shape:\n            traces = traces.reshape(*instances_shape)\n        else:\n            # this works because indX will be a single boolean and\n            # out[True, n] = value will assign value to out[n], while\n            # out[False, n] = value will not assign value to out[n]\n            traces = traces[0]\n\n    angles = np.arccos(np.clip((traces - 1.0) / 2.0, -1.0, 1.0))\n\n    if out is None:\n        out = np.empty(instances_shape + (4,))\n\n    out[..., 0] = Rs[..., 2, 1] - Rs[..., 1, 2]\n    out[..., 1] = Rs[..., 0, 2] - Rs[..., 2, 0]\n    out[..., 2] = Rs[..., 1, 0] - Rs[..., 0, 1]\n\n    # The threshold is a result from this discussion:\n    # https://github.com/dfki-ric/pytransform3d/issues/43\n    # The standard formula becomes numerically unstable, however,\n    # Rodrigues' formula reduces to R = I + 2 (ee^T - I), with the\n    # rotation axis e, that is, ee^T = 0.5 * (R + I) and we can find the\n    # squared values of the rotation axis on the diagonal of this matrix.\n    # We can still use the original formula to reconstruct the signs of\n    # the rotation axis correctly.\n    angle_close_to_pi = np.abs(angles - np.pi) < 1e-4\n    angle_not_zero = np.abs(angles) != 0.0\n\n    Rs_diag = np.einsum(\"nii->ni\", Rs.reshape(-1, 3, 3))\n    if instances_shape:\n        Rs_diag = Rs_diag.reshape(*(instances_shape + (3,)))\n    else:\n        Rs_diag = Rs_diag[0]\n    out[angle_close_to_pi, :3] = (\n        np.sqrt(0.5 * (Rs_diag[angle_close_to_pi] + 1.0))\n        * np.sign(out[angle_close_to_pi, :3]))\n    out[angle_not_zero, :3] /= np.linalg.norm(\n        out[angle_not_zero, :3], axis=-1)[..., np.newaxis]\n\n    out[..., 3] = angles\n\n    return out",
  "def cross_product_matrices(V):\n    \"\"\"Generate the cross-product matrices of vectors.\n\n    The cross-product matrix :math:`\\\\boldsymbol{V}` satisfies the equation\n\n    .. math::\n\n        \\\\boldsymbol{V} \\\\boldsymbol{w} = \\\\boldsymbol{v} \\\\times\n        \\\\boldsymbol{w}\n\n    It is a skew-symmetric (antisymmetric) matrix, i.e.\n    :math:`-\\\\boldsymbol{V} = \\\\boldsymbol{V}^T`.\n\n    Parameters\n    ----------\n    V : array-like, shape (..., 3)\n        3d vectors\n\n    Returns\n    -------\n    V_cross_product_matrices : array, shape (..., 3, 3)\n        Cross-product matrices of V\n    \"\"\"\n    V = np.asarray(V)\n\n    instances_shape = V.shape[:-1]\n    V_matrices = np.empty(instances_shape + (3, 3))\n\n    V_matrices[..., 0, 0] = 0.0\n    V_matrices[..., 0, 1] = -V[..., 2]\n    V_matrices[..., 0, 2] = V[..., 1]\n    V_matrices[..., 1, 0] = V[..., 2]\n    V_matrices[..., 1, 1] = 0.0\n    V_matrices[..., 1, 2] = -V[..., 0]\n    V_matrices[..., 2, 0] = -V[..., 1]\n    V_matrices[..., 2, 1] = V[..., 0]\n    V_matrices[..., 2, 2] = 0.0\n\n    return V_matrices",
  "def matrices_from_quaternions(Q, normalize_quaternions=True, out=None):\n    \"\"\"Compute rotation matrices from quaternions.\n\n    Parameters\n    ----------\n    Q : array-like, shape (..., 4)\n        Unit quaternions to represent rotations: (w, x, y, z)\n\n    normalize_quaternions : bool, optional (default: True)\n        Normalize quaternions before conversion\n\n    out : array, shape (..., 3, 3), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    Rs : array, shape (..., 3, 3)\n        Rotation matrices\n    \"\"\"\n    Q = np.asarray(Q)\n\n    if normalize_quaternions:\n        Q = norm_vectors(Q)\n\n    w = Q[..., 0]\n    x = Q[..., 1]\n    y = Q[..., 2]\n    z = Q[..., 3]\n\n    x2 = 2.0 * x * x\n    y2 = 2.0 * y * y\n    z2 = 2.0 * z * z\n    xy = 2.0 * x * y\n    xz = 2.0 * x * z\n    yz = 2.0 * y * z\n    xw = 2.0 * x * w\n    yw = 2.0 * y * w\n    zw = 2.0 * z * w\n\n    if out is None:\n        out = np.empty(w.shape + (3, 3))\n\n    out[..., 0, 0] = 1.0 - y2 - z2\n    out[..., 0, 1] = xy - zw\n    out[..., 0, 2] = xz + yw\n    out[..., 1, 0] = xy + zw\n    out[..., 1, 1] = 1.0 - x2 - z2\n    out[..., 1, 2] = yz - xw\n    out[..., 2, 0] = xz - yw\n    out[..., 2, 1] = yz + xw\n    out[..., 2, 2] = 1.0 - x2 - y2\n\n    return out",
  "def quaternions_from_matrices(Rs, out=None):\n    \"\"\"Compute quaternions from rotation matrices.\n\n    Parameters\n    ----------\n    Rs : array-like, shape (..., 3, 3)\n        Rotation matrices\n\n    out : array, shape (..., 4), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    Q : array, shape (..., 4)\n        Unit quaternions to represent rotations: (w, x, y, z)\n    \"\"\"\n    Rs = np.asarray(Rs)\n    instances_shape = Rs.shape[:-2]\n\n    if out is None:\n        out = np.empty(instances_shape + (4,))\n\n    traces = np.einsum(\"nii\", Rs.reshape(-1, 3, 3))\n    if instances_shape:\n        traces = traces.reshape(*instances_shape)\n    else:\n        # this works because indX will be a single boolean and\n        # out[True, n] = value will assign value to out[n], while\n        # out[False, n] = value will not assign value to out[n]\n        traces = traces[0]\n    ind1 = traces > 0.0\n    s = 2.0 * np.sqrt(1.0 + traces[ind1])\n    out[ind1, 0] = 0.25 * s\n    out[ind1, 1] = (Rs[ind1, 2, 1] - Rs[ind1, 1, 2]) / s\n    out[ind1, 2] = (Rs[ind1, 0, 2] - Rs[ind1, 2, 0]) / s\n    out[ind1, 3] = (Rs[ind1, 1, 0] - Rs[ind1, 0, 1]) / s\n\n    ind2 = np.logical_and(\n        np.logical_not(ind1),\n        np.logical_and(Rs[..., 0, 0] > Rs[..., 1, 1],\n                       Rs[..., 0, 0] > Rs[..., 2, 2]))\n    s = 2.0 * np.sqrt(1.0 + Rs[ind2, 0, 0] - Rs[ind2, 1, 1] - Rs[ind2, 2, 2])\n    out[ind2, 0] = (Rs[ind2, 2, 1] - Rs[ind2, 1, 2]) / s\n    out[ind2, 1] = 0.25 * s\n    out[ind2, 2] = (Rs[ind2, 1, 0] + Rs[ind2, 0, 1]) / s\n    out[ind2, 3] = (Rs[ind2, 0, 2] + Rs[ind2, 2, 0]) / s\n\n    ind3 = np.logical_and(\n        np.logical_not(ind1), Rs[..., 1, 1] > Rs[..., 2, 2])\n    s = 2.0 * np.sqrt(1.0 + Rs[ind3, 1, 1] - Rs[ind3, 0, 0] - Rs[ind3, 2, 2])\n    out[ind3, 0] = (Rs[ind3, 0, 2] - Rs[ind3, 2, 0]) / s\n    out[ind3, 1] = (Rs[ind3, 1, 0] + Rs[ind3, 0, 1]) / s\n    out[ind3, 2] = 0.25 * s\n    out[ind3, 3] = (Rs[ind3, 2, 1] + Rs[ind3, 1, 2]) / s\n\n    ind4 = np.logical_and(\n        np.logical_and(np.logical_not(ind1),\n                       np.logical_not(ind2)),\n        np.logical_not(ind3))\n    s = 2.0 * np.sqrt(1.0 + Rs[ind4, 2, 2] - Rs[ind4, 0, 0] - Rs[ind4, 1, 1])\n    out[ind4, 0] = (Rs[ind4, 1, 0] - Rs[ind4, 0, 1]) / s\n    out[ind4, 1] = (Rs[ind4, 0, 2] + Rs[ind4, 2, 0]) / s\n    out[ind4, 2] = (Rs[ind4, 2, 1] + Rs[ind4, 1, 2]) / s\n    out[ind4, 3] = 0.25 * s\n\n    return out",
  "def quaternion_slerp_batch(start, end, t, shortest_path=False):\n    \"\"\"Spherical linear interpolation for a batch of steps.\n\n    Parameters\n    ----------\n    start : array-like, shape (4,)\n        Start unit quaternion to represent rotation: (w, x, y, z)\n\n    end : array-like, shape (4,)\n        End unit quaternion to represent rotation: (w, x, y, z)\n\n    t : array-like, shape (n_steps,)\n        Steps between start and goal, must be in interval [0, 1]\n\n    shortest_path : bool, optional (default: False)\n        Resolve sign ambiguity before interpolation to find the shortest path.\n        The end quaternion will be picked to be close to the start quaternion.\n\n    Returns\n    -------\n    Q : array, shape (n_steps, 4)\n        Interpolated unit quaternions\n    \"\"\"\n    t = np.asarray(t)\n    if shortest_path:\n        end = pick_closest_quaternion(end, start)\n    angle = angle_between_vectors(start, end)\n    w1, w2 = slerp_weights(angle, t)\n    return (w1[:, np.newaxis] * start[np.newaxis]\n            + w2[:, np.newaxis] * end[np.newaxis])",
  "def batch_concatenate_quaternions(Q1, Q2, out=None):\n    \"\"\"Concatenate two batches of quaternions.\n\n    We use Hamilton's quaternion multiplication.\n\n    Suppose we want to apply two extrinsic rotations given by quaternions\n    q1 and q2 to a vector v. We can either apply q2 to v and then q1 to\n    the result or we can concatenate q1 and q2 and apply the result to v.\n\n    Parameters\n    ----------\n    Q1 : array-like, shape (..., 4)\n        First batch of quaternions\n\n    Q2 : array-like, shape (..., 4)\n        Second batch of quaternions\n\n    out : array, shape (..., 4), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    Q12 : array, shape (..., 4)\n        Batch of quaternions that represents the concatenated rotations\n\n    Raises\n    ------\n    ValueError\n        If the input dimensions are incorrect\n    \"\"\"\n    Q1 = np.asarray(Q1)\n    Q2 = np.asarray(Q2)\n\n    if Q1.ndim != Q2.ndim:\n        raise ValueError(\"Number of dimensions must be the same. \"\n                         \"Got %d for Q1 and %d for Q2.\" % (Q1.ndim, Q2.ndim))\n    for d in range(Q1.ndim - 1):\n        if Q1.shape[d] != Q2.shape[d]:\n            raise ValueError(\n                \"Size of dimension %d does not match: %d != %d\"\n                % (d + 1, Q1.shape[d], Q2.shape[d]))\n    if Q1.shape[-1] != 4:\n        raise ValueError(\n            \"Last dimension of first argument does not match. A quaternion \"\n            \"must have 4 entries, got %d\" % Q1.shape[-1])\n    if Q2.shape[-1] != 4:\n        raise ValueError(\n            \"Last dimension of second argument does not match. A quaternion \"\n            \"must have 4 entries, got %d\" % Q2.shape[-1])\n\n    if out is None:\n        out = np.empty_like(Q1)\n\n    vector_inner_products = np.sum(Q1[..., 1:] * Q2[..., 1:], axis=-1)\n    out[..., 0] = Q1[..., 0] * Q2[..., 0] - vector_inner_products\n    out[..., 1:] = (Q1[..., 0, np.newaxis] * Q2[..., 1:] +\n                    Q2[..., 0, np.newaxis] * Q1[..., 1:] +\n                    np.cross(Q1[..., 1:], Q2[..., 1:]))\n    return out",
  "def batch_q_conj(Q):\n    \"\"\"Conjugate of quaternions.\n\n    The conjugate of a unit quaternion inverts the rotation represented by\n    this unit quaternion. The conjugate of a quaternion q is often denoted\n    as q*.\n\n    Parameters\n    ----------\n    Q : array-like, shape (..., 4)\n        Unit quaternions to represent rotations: (w, x, y, z)\n\n    Returns\n    -------\n    Q_c : array, shape (..., 4,)\n        Conjugates (w, -x, -y, -z)\n    \"\"\"\n    Q = np.asarray(Q)\n    out = np.empty_like(Q)\n    out[..., 0] = Q[..., 0]\n    out[..., 1:] = -Q[..., 1:]\n    return out",
  "def batch_quaternion_wxyz_from_xyzw(Q_xyzw, out=None):\n    \"\"\"Converts from x, y, z, w to w, x, y, z convention.\n\n    Parameters\n    ----------\n    Q_xyzw : array-like, shape (..., 4)\n        Quaternions with scalar part after vector part\n\n    out : array, shape (..., 4), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    Q_wxyz : array-like, shape (..., 4)\n        Quaternions with scalar part before vector part\n    \"\"\"\n    Q_xyzw = np.asarray(Q_xyzw)\n    if out is None:\n        out = np.empty_like(Q_xyzw)\n    out[..., 0] = Q_xyzw[..., 3]\n    out[..., 1] = Q_xyzw[..., 0]\n    out[..., 2] = Q_xyzw[..., 1]\n    out[..., 3] = Q_xyzw[..., 2]\n    return out",
  "def batch_quaternion_xyzw_from_wxyz(Q_wxyz, out=None):\n    \"\"\"Converts from w, x, y, z to x, y, z, w convention.\n\n    Parameters\n    ----------\n    Q_wxyz : array-like, shape (..., 4)\n        Quaternions with scalar part before vector part\n\n    out : array, shape (..., 4), optional (default: new array)\n        Output array to which we write the result\n\n    Returns\n    -------\n    Q_xyzw : array-like, shape (..., 4)\n        Quaternions with scalar part after vector part\n    \"\"\"\n    Q_wxyz = np.asarray(Q_wxyz)\n    if out is None:\n        out = np.empty_like(Q_wxyz)\n    out[..., 0] = Q_wxyz[..., 1]\n    out[..., 1] = Q_wxyz[..., 2]\n    out[..., 2] = Q_wxyz[..., 3]\n    out[..., 3] = Q_wxyz[..., 0]\n    return out",
  "def smooth_quaternion_trajectory(Q, start_component_positive=\"x\"):\n    \"\"\"Smooth quaternion trajectory.\n\n    Quaternion q and -q represent the same rotation but cannot be\n    interpolated well. This function guarantees that two successive\n    quaternions q1 and q2 are closer than q1 and -q2.\n\n    Parameters\n    ----------\n    Q : array-like, shape (n_steps, 4)\n        Unit quaternions to represent rotations: (w, x, y, z)\n\n    start_component_positive : str, optional (default: 'x')\n        Start trajectory with quaternion that has this component positive.\n        Allowed values: 'w' (scalar), 'x', 'y', and 'z'.\n\n    Returns\n    -------\n    Q : array, shape (n_steps, 4)\n        Unit quaternions to represent rotations: (w, x, y, z)\n\n    Raises\n    ------\n    ValueError\n        If Q has length 0.\n    \"\"\"\n    Q = np.copy(Q)\n\n    if len(Q) == 0:\n        raise ValueError(\"At least one quaternion is expected.\")\n\n    if Q[0, \"wxyz\".index(start_component_positive)] < 0.0:\n        Q[0] *= -1.0\n\n    q1q2_dists = np.linalg.norm(Q[:-1] - Q[1:], axis=1)\n    q1mq2_dists = np.linalg.norm(Q[:-1] + Q[1:], axis=1)\n    before_jump_indices = np.where(q1q2_dists > q1mq2_dists)[0]\n\n    # workaround for interpolation artifacts:\n    before_smooth_jump_indices = np.isclose(q1q2_dists, q1mq2_dists)\n    before_smooth_jump_indices = np.where(\n        np.logical_and(before_smooth_jump_indices[:-1],\n                       before_smooth_jump_indices[1:]))[0]\n    before_jump_indices = np.unique(\n        np.hstack((before_jump_indices, before_smooth_jump_indices))).tolist()\n    before_jump_indices.append(len(Q) - 1)\n\n    slices_to_correct = np.array(\n        list(zip(before_jump_indices[:-1], before_jump_indices[1:])))[::2]\n    for i, j in slices_to_correct:\n        Q[i + 1:j + 1] *= -1.0\n    return Q",
  "def load_mesh(filename):\n    \"\"\"Load mesh from file.\n\n    This feature relies on optional dependencies. It can use trimesh or\n    Open3D to load meshes. If both are not available, it will fail.\n    Furthermore, some mesh formats require additional dependencies. For\n    example, loading collada files ('.dae' file ending) requires pycollada\n    and trimesh.\n\n    Parameters\n    ----------\n    filename : str\n        File in which the mesh is stored.\n\n    Returns\n    -------\n    mesh : MeshBase\n        Mesh instance.\n    \"\"\"\n    mesh = _Trimesh(filename)\n    loader_available = mesh.load()\n\n    if not loader_available:  # pragma: no cover\n        mesh = _Open3DMesh(filename)\n        loader_available = mesh.load()\n\n    if not loader_available:  # pragma: no cover\n        raise ImportError(\n            \"Could not load mesh from '%s'. Please install one of the \"\n            \"optional dependencies 'trimesh' or 'open3d'.\" % filename)\n\n    return mesh",
  "class MeshBase(abc.ABC):\n    \"\"\"Abstract base class of meshes.\n\n    Parameters\n    ----------\n    filename : str\n        File in which the mesh is stored.\n    \"\"\"\n    def __init__(self, filename):\n        self.filename = filename\n\n    @abc.abstractmethod\n    def load(self):\n        \"\"\"Load mesh from file.\n\n        Returns\n        -------\n        loader_available : bool\n            Is the mesh loader available?\n        \"\"\"\n\n    @abc.abstractmethod\n    def convex_hull(self):\n        \"\"\"Compute convex hull of mesh.\"\"\"\n\n    @abc.abstractmethod\n    def get_open3d_mesh(self):\n        \"\"\"Return Open3D mesh.\n\n        Returns\n        -------\n        mesh : open3d.geometry.TriangleMesh\n            Open3D mesh.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def vertices(self):\n        \"\"\"Vertices.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def triangles(self):\n        \"\"\"Triangles.\"\"\"",
  "class _Trimesh(MeshBase):\n    def __init__(self, filename):\n        super(_Trimesh, self).__init__(filename)\n        self.mesh = None\n\n    def load(self):\n        try:\n            import trimesh\n        except ImportError:\n            return False\n        obj = trimesh.load(self.filename)\n        if isinstance(obj, trimesh.Scene):  # pragma: no cover\n            # Special case in which we load a collada file that contains\n            # multiple meshes. We might lose textures. This is excluded\n            # from testing as it would add another dependency.\n            obj = obj.dump().sum()\n        self.mesh = obj\n        return True\n\n    def convex_hull(self):\n        self.mesh = self.mesh.convex_hull\n\n    def get_open3d_mesh(self):  # pragma: no cover\n        import open3d\n        return open3d.geometry.TriangleMesh(\n            open3d.utility.Vector3dVector(self.vertices),\n            open3d.utility.Vector3iVector(self.triangles))\n\n    @property\n    def vertices(self):\n        return self.mesh.vertices\n\n    @property\n    def triangles(self):\n        return self.mesh.faces",
  "class _Open3DMesh(MeshBase):  # pragma: no cover\n    def __init__(self, filename):\n        super(_Open3DMesh, self).__init__(filename)\n        self.mesh = None\n\n    def load(self):\n        try:\n            import open3d\n        except ImportError:\n            return False\n        self.mesh = open3d.io.read_triangle_mesh(self.filename)\n        return True\n\n    def convex_hull(self):\n        assert self.mesh is not None\n        self.mesh = self.mesh.compute_convex_hull()[0]\n\n    def get_open3d_mesh(self):\n        return self.mesh\n\n    @property\n    def vertices(self):\n        return np.asarray(self.mesh.vertices)\n\n    @property\n    def triangles(self):\n        return np.asarray(self.mesh.triangles)",
  "def __init__(self, filename):\n        self.filename = filename",
  "def load(self):\n        \"\"\"Load mesh from file.\n\n        Returns\n        -------\n        loader_available : bool\n            Is the mesh loader available?\n        \"\"\"",
  "def convex_hull(self):\n        \"\"\"Compute convex hull of mesh.\"\"\"",
  "def get_open3d_mesh(self):\n        \"\"\"Return Open3D mesh.\n\n        Returns\n        -------\n        mesh : open3d.geometry.TriangleMesh\n            Open3D mesh.\n        \"\"\"",
  "def vertices(self):\n        \"\"\"Vertices.\"\"\"",
  "def triangles(self):\n        \"\"\"Triangles.\"\"\"",
  "def __init__(self, filename):\n        super(_Trimesh, self).__init__(filename)\n        self.mesh = None",
  "def load(self):\n        try:\n            import trimesh\n        except ImportError:\n            return False\n        obj = trimesh.load(self.filename)\n        if isinstance(obj, trimesh.Scene):  # pragma: no cover\n            # Special case in which we load a collada file that contains\n            # multiple meshes. We might lose textures. This is excluded\n            # from testing as it would add another dependency.\n            obj = obj.dump().sum()\n        self.mesh = obj\n        return True",
  "def convex_hull(self):\n        self.mesh = self.mesh.convex_hull",
  "def get_open3d_mesh(self):  # pragma: no cover\n        import open3d\n        return open3d.geometry.TriangleMesh(\n            open3d.utility.Vector3dVector(self.vertices),\n            open3d.utility.Vector3iVector(self.triangles))",
  "def vertices(self):\n        return self.mesh.vertices",
  "def triangles(self):\n        return self.mesh.faces",
  "def __init__(self, filename):\n        super(_Open3DMesh, self).__init__(filename)\n        self.mesh = None",
  "def load(self):\n        try:\n            import open3d\n        except ImportError:\n            return False\n        self.mesh = open3d.io.read_triangle_mesh(self.filename)\n        return True",
  "def convex_hull(self):\n        assert self.mesh is not None\n        self.mesh = self.mesh.compute_convex_hull()[0]",
  "def get_open3d_mesh(self):\n        return self.mesh",
  "def vertices(self):\n        return np.asarray(self.mesh.vertices)",
  "def triangles(self):\n        return np.asarray(self.mesh.triangles)",
  "def cartesian_from_cylindrical(p):\n    \"\"\"Convert cylindrical coordinates to Cartesian coordinates.\n\n    Parameters\n    ----------\n    p : array-like, shape (..., 3)\n        Cylindrical coordinates: axial / radial distance (rho), azimuth\n        (phi), and axial coordinate / height (z)\n\n    Returns\n    -------\n    q : array, shape (..., 3)\n        Cartesian coordinates (x, y, z)\n    \"\"\"\n    p = np.asarray(p, dtype=float)\n    q = np.empty_like(p)\n    q[..., 0] = p[..., 0] * np.cos(p[..., 1])\n    q[..., 1] = p[..., 0] * np.sin(p[..., 1])\n    q[..., 2] = p[..., 2]\n    return q",
  "def cartesian_from_spherical(p):\n    \"\"\"Convert spherical coordinates to Cartesian coordinates.\n\n    Parameters\n    ----------\n    p : array-like, shape (..., 3)\n        Spherical coordinates: radial distance (rho), inclination /\n        elevation (theta), and azimuth (phi)\n\n    Returns\n    -------\n    q : array, shape (..., 3)\n        Cartesian coordinates (x, y, z)\n    \"\"\"\n    p = np.asarray(p, dtype=float)\n    q = np.empty_like(p)\n    r_sin_theta = p[..., 0] * np.sin(p[..., 1])\n    q[..., 0] = np.cos(p[..., 2]) * r_sin_theta\n    q[..., 1] = np.sin(p[..., 2]) * r_sin_theta\n    q[..., 2] = p[..., 0] * np.cos(p[..., 1])\n    return q",
  "def cylindrical_from_cartesian(p):\n    \"\"\"Convert Cartesian coordinates to cylindrical coordinates.\n\n    Parameters\n    ----------\n    p : array-like, shape (..., 3)\n        Cartesian coordinates (x, y, z)\n\n    Returns\n    -------\n    q : array, shape (..., 3)\n        Cylindrical coordinates: axial / radial distance (rho >= 0), azimuth\n        (-pi >= phi >= pi), and axial coordinate / height (z)\n    \"\"\"\n    p = np.asarray(p, dtype=float)\n    q = np.empty_like(p)\n    q[..., 0] = np.linalg.norm(p[..., :2], axis=-1)\n    q[..., 1] = np.arctan2(p[..., 1], p[..., 0])\n    q[..., 2] = p[..., 2]\n    return q",
  "def cylindrical_from_spherical(p):\n    \"\"\"Convert spherical coordinates to cylindrical coordinates.\n\n    Parameters\n    ----------\n    p : array-like, shape (..., 3)\n        Spherical coordinates: radial distance (rho), inclination /\n        elevation (theta), and azimuth (phi)\n\n    Returns\n    -------\n    q : array, shape (..., 3)\n        Cylindrical coordinates: axial / radial distance (rho), azimuth\n        (phi), and axial coordinate / height (z)\n    \"\"\"\n    p = np.asarray(p, dtype=float)\n    q = np.empty_like(p)\n    q[..., 0] = p[..., 0] * np.sin(p[..., 1])\n    q[..., 1] = p[..., 2]\n    q[..., 2] = p[..., 0] * np.cos(p[..., 1])\n    return q",
  "def spherical_from_cartesian(p):\n    \"\"\"Convert Cartesian coordinates to spherical coordinates.\n\n    Parameters\n    ----------\n    p : array-like, shape (..., 3)\n        Cartesian coordinates (x, y, z)\n\n    Returns\n    -------\n    q : array, shape (..., 3)\n        Spherical coordinates: radial distance (rho >= 0), inclination /\n        elevation (0 <= theta <= pi), and azimuth (-pi <= phi <= pi)\n    \"\"\"\n    p = np.asarray(p, dtype=float)\n    q = np.empty_like(p)\n    q[..., 0] = np.linalg.norm(p, axis=-1)\n    q[..., 1] = np.arctan2(np.linalg.norm(p[..., :2], axis=-1), p[..., 2])\n    q[..., 2] = np.arctan2(p[..., 1], p[..., 0])\n    return q",
  "def spherical_from_cylindrical(p):\n    \"\"\"Convert cylindrical coordinates to spherical coordinates.\n\n    Parameters\n    ----------\n    p : array-like, shape (..., 3)\n        Cylindrical coordinates: axial / radial distance (rho), azimuth\n        (phi), and axial coordinate / height (z)\n\n    Returns\n    -------\n    q : array, shape (..., 3)\n        Spherical coordinates: radial distance (rho), inclination /\n        elevation (theta), and azimuth (phi)\n    \"\"\"\n    p = np.asarray(p, dtype=float)\n    q = np.empty_like(p)\n    q[..., 0] = np.linalg.norm(p[..., (0, 2)], axis=-1)\n    q[..., 1] = np.arctan2(p[..., 0], p[..., 2])\n    q[..., 2] = p[..., 1]\n    return q",
  "def make_world_grid(n_lines=11, n_points_per_line=51, xlim=(-0.5, 0.5),\n                    ylim=(-0.5, 0.5)):\n    \"\"\"Generate grid in world coordinate frame.\n\n    The grid will have the form\n\n    .. code::\n\n        +----+----+----+----+----+\n        |    |    |    |    |    |\n        +----+----+----+----+----+\n        |    |    |    |    |    |\n        +----+----+----+----+----+\n        |    |    |    |    |    |\n        +----+----+----+----+----+\n        |    |    |    |    |    |\n        +----+----+----+----+----+\n        |    |    |    |    |    |\n        +----+----+----+----+----+\n\n    on the x-y plane with z=0 for all points.\n\n    Parameters\n    ----------\n    n_lines : int, optional (default: 11)\n        Number of lines\n\n    n_points_per_line : int, optional (default: 51)\n        Number of points per line\n\n    xlim : tuple, optional (default: (-0.5, 0.5))\n        Range on x-axis\n\n    ylim : tuple, optional (default: (-0.5, 0.5))\n        Range on y-axis\n\n    Returns\n    -------\n    world_grid : array-like, shape (2 * n_lines * n_points_per_line, 4)\n        Grid as homogenous coordinate vectors\n    \"\"\"\n    world_grid_x = np.vstack([make_world_line([xlim[0], y], [xlim[1], y],\n                                              n_points_per_line)\n                              for y in np.linspace(ylim[0], ylim[1], n_lines)])\n    world_grid_y = np.vstack([make_world_line([x, ylim[0]], [x, ylim[1]],\n                                              n_points_per_line)\n                              for x in np.linspace(xlim[0], xlim[1], n_lines)])\n    return np.vstack((world_grid_x, world_grid_y))",
  "def make_world_line(p1, p2, n_points):\n    \"\"\"Generate line in world coordinate frame.\n\n    Parameters\n    ----------\n    p1 : array-like, shape (2 or 3,)\n        Start point of the line\n\n    p2 : array-like, shape (2 or 3,)\n        End point of the line\n\n    n_points : int\n        Number of points\n\n    Returns\n    -------\n    line : array-like, shape (n_points, 4)\n        Samples from line in world frame\n    \"\"\"\n    if len(p1) == 2:\n        p1 = [p1[0], p1[1], 0]\n    if len(p2) == 2:\n        p2 = [p2[0], p2[1], 0]\n    return np.array([np.linspace(p1[0], p2[0], n_points),\n                     np.linspace(p1[1], p2[1], n_points),\n                     np.linspace(p1[2], p2[2], n_points),\n                     np.ones(n_points)]).T",
  "def cam2sensor(P_cam, focal_length, kappa=0.0):\n    \"\"\"Project points from 3D camera coordinate system to sensor plane.\n\n    Parameters\n    ----------\n    P_cam : array-like, shape (n_points, 3 or 4)\n        Points in camera coordinates\n\n    focal_length : float\n        Focal length of the camera\n\n    kappa : float, optional (default: 0)\n        Camera distortion parameter\n\n    Returns\n    -------\n    P_sensor : array-like, shape (n_points, 2)\n        Points on the sensor plane. The result for points that are behind the\n        camera will be a vector of nans.\n\n    Raises\n    ------\n    ValueError\n        If input is not valid\n    \"\"\"\n    n_points, n_dims = P_cam.shape\n    if n_dims not in (3, 4):\n        raise ValueError(\"Expected 3- or 4-dimensional points, got %d \"\n                         \"dimensions\" % n_dims)\n    if focal_length <= 0.0:\n        raise ValueError(\"Focal length must be greater than 0.\")\n\n    P_sensor = np.empty((n_points, 2))\n    ahead = P_cam[:, 2] > 0.0\n    P_sensor[ahead] = P_cam[ahead][:, :2] / P_cam[ahead][:, 2, np.newaxis]\n    behind = np.logical_not(ahead)\n\n    for n in range(P_sensor.shape[0]):\n        P_sensor[n] *= 1.0 / (1.0 + kappa * np.linalg.norm(P_sensor[n]) ** 2)\n    P_sensor *= focal_length\n    P_sensor[behind] = np.nan\n    return P_sensor",
  "def sensor2img(P_sensor, sensor_size, image_size, image_center=None):\n    \"\"\"Project points from 2D sensor plane to image coordinate system.\n\n    Parameters\n    ----------\n    P_sensor : array-like, shape (n_points, 2)\n        Points on camera sensor\n\n    sensor_size : array-like, shape (2,)\n        Size of the sensor array\n\n    image_size : array-like, shape (2,)\n        Size of the camera image: (width, height)\n\n    image_center : array-like, shape (2,), optional (default: image_size / 2)\n        Center of the image\n\n    Returns\n    -------\n    P_img : array-like, shape (n_points, 2)\n        Points on image\n    \"\"\"\n    P_img = np.asarray(image_size) * P_sensor / np.asarray(sensor_size)\n    if image_center is None:\n        image_center = np.asarray(image_size) / 2\n    P_img += np.asarray(image_center)\n    return P_img",
  "def world2image(P_world, cam2world, sensor_size, image_size, focal_length,\n                image_center=None, kappa=0.0):\n    \"\"\"Project points from 3D world coordinate system to 2D image.\n\n    Parameters\n    ----------\n    P_world : array-like, shape (n_points, 4)\n        Points in world coordinates\n\n    cam2world : array-like, shape (4, 4), optional (default: I)\n        Camera in world frame\n\n    sensor_size : array-like, shape (2,)\n        Size of the sensor array\n\n    image_size : array-like, shape (2,)\n        Size of the camera image: (width, height)\n\n    focal_length : float\n        Focal length of the camera\n\n    image_center : array-like, shape (2,), optional (default: image_size / 2)\n        Center of the image\n\n    kappa : float, optional (default: 0)\n        Camera distortion parameter\n\n    Returns\n    -------\n    P_img : array-like, shape (n_points, 2)\n        Points on image\n    \"\"\"\n    world2cam = invert_transform(cam2world)\n    P_cam = transform(world2cam, P_world)\n    P_sensor = cam2sensor(P_cam, focal_length, kappa)\n    P_img = sensor2img(P_sensor, sensor_size, image_size, image_center)\n    return P_img",
  "def plot_camera(ax=None, M=None, cam2world=None, virtual_image_distance=1.0,\n                sensor_size=(1920, 1080), ax_s=1, strict_check=True,\n                **kwargs):  # pragma: no cover\n    \"\"\"Plot camera in world coordinates.\n\n    This function is inspired by Blender's camera visualization. It will\n    show the camera center, a virtual image plane, and the top of the virtual\n    image plane.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created.\n\n    M : array-like, shape (3, 3)\n        Intrinsic camera matrix that contains the focal lengths on the diagonal\n        and the center of the the image in the last column. It does not matter\n        whether values are given in meters or pixels as long as the unit is the\n        same as for the sensor size.\n\n    cam2world : array-like, shape (4, 4), optional (default: I)\n        Transformation matrix of camera in world frame. We assume that the\n        position is given in meters.\n\n    virtual_image_distance : float, optional (default: 1)\n        Distance from pinhole to virtual image plane that will be displayed.\n        We assume that this distance is given in meters. The unit has to be\n        consistent with the unit of the position in cam2world.\n\n    sensor_size : array-like, shape (2,), optional (default: [1920, 1080])\n        Size of the image sensor: (width, height). It does not matter whether\n        values are given in meters or pixels as long as the unit is the same as\n        for the sensor size.\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis.\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    kwargs : dict, optional (default: {})\n        Additional arguments for the plotting functions, e.g. alpha.\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n\n    Raises\n    ------\n    ValueError\n        If input is not valid\n    \"\"\"\n    if ax is None:\n        from .plot_utils import make_3d_axis\n        ax = make_3d_axis(ax_s)\n\n    if M is None:\n        raise ValueError(\"No intrinsic camera matrix given.\")\n\n    if cam2world is None:\n        cam2world = np.eye(4)\n\n    cam2world = check_transform(cam2world, strict_check=strict_check)\n\n    camera_center_in_world = cam2world[:3, 3]\n    focal_length = np.mean(np.diag(M[:2, :2]))\n    sensor_corners_in_cam = np.array([\n        [0, 0, focal_length],\n        [0, sensor_size[1], focal_length],\n        [sensor_size[0], sensor_size[1], focal_length],\n        [sensor_size[0], 0, focal_length],\n    ])\n    sensor_corners_in_cam[:, 0] -= M[0, 2]\n    sensor_corners_in_cam[:, 1] -= M[1, 2]\n    sensor_corners_in_world = transform(\n        cam2world, vectors_to_points(sensor_corners_in_cam), strict_check=strict_check)[:, :3]\n    virtual_image_corners = (\n        virtual_image_distance / focal_length *\n        (sensor_corners_in_world - camera_center_in_world[np.newaxis]) +\n        camera_center_in_world[np.newaxis])\n\n    if \"c\" in kwargs:\n        color = kwargs.pop(\"c\")\n    elif \"color\" in kwargs:\n        color = kwargs.pop(\"color\")\n    else:\n        color = \"k\"\n\n    _make_camera_frame(\n        ax, virtual_image_corners, camera_center_in_world, color, **kwargs)\n    _make_camera_top(ax, virtual_image_corners, color, **kwargs)\n    ax.scatter(camera_center_in_world[0], camera_center_in_world[1],\n               camera_center_in_world[2], color=color, **kwargs)\n\n    return ax",
  "def _make_camera_frame(\n        ax, virtual_image_corners, camera_center_in_world, color,\n        **kwargs):  # pragma: no cover\n    \"\"\"Plot camera frame.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis\n        Axis\n\n    virtual_image_corners : array, shape (4, 3)\n        Virtual image corners in world coordinates.\n\n    camera_center_in_world : array, shape (3,)\n        Camera center in world coordinates.\n\n    color : str\n        Line color.\n\n    kwargs : dict, optional (default: {})\n        Additional arguments for the plotting functions, e.g. alpha.\n    \"\"\"\n    camera_frame = np.vstack((\n        virtual_image_corners[0],\n        camera_center_in_world,\n        virtual_image_corners[0],\n        virtual_image_corners[1],\n        camera_center_in_world,\n        virtual_image_corners[1],\n        virtual_image_corners[2],\n        camera_center_in_world,\n        virtual_image_corners[2],\n        virtual_image_corners[3],\n        camera_center_in_world,\n        virtual_image_corners[3],\n        virtual_image_corners[0],\n    ))\n    ax.plot(camera_frame[:, 0], camera_frame[:, 1], camera_frame[:, 2],\n            color=color, **kwargs)",
  "def _make_camera_top(\n        ax, virtual_image_corners, color, **kwargs):  # pragma: no cover\n    \"\"\"Plot top indicator of camera.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis\n        Axis\n\n    virtual_image_corners : array, shape (4, 3)\n        Virtual image corners in world coordinates.\n\n    color : str\n        Line color.\n\n    kwargs : dict, optional (default: {})\n        Additional arguments for the plotting functions, e.g. alpha.\n    \"\"\"\n    up = virtual_image_corners[0] - virtual_image_corners[1]\n    camera_top = np.array([\n        virtual_image_corners[0] + 0.1 * up,\n        0.5 * (virtual_image_corners[0] + virtual_image_corners[3]) + 0.5 * up,\n        virtual_image_corners[3] + 0.1 * up,\n        virtual_image_corners[0] + 0.1 * up\n    ])\n    ax.plot(camera_top[:, 0], camera_top[:, 1], camera_top[:, 2],\n            color=color, **kwargs)",
  "def transform_from(R, p, strict_check=True):\n    r\"\"\"Make transformation from rotation matrix and translation.\n\n    .. math::\n\n        \\boldsymbol{T}_{BA} = \\left(\n        \\begin{array}{cc}\n        \\boldsymbol{R} & \\boldsymbol{p}\\\\\n        \\boldsymbol{0} & 1\n        \\end{array}\n        \\right) \\in SE(3)\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    p : array-like, shape (3,)\n        Translation\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    Returns\n    -------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n    \"\"\"\n    A2B = rotate_transform(\n        np.eye(4), R, strict_check=strict_check, check=False)\n    A2B = translate_transform(\n        A2B, p, strict_check=strict_check, check=False)\n    return A2B",
  "def translate_transform(A2B, p, strict_check=True, check=True):\n    \"\"\"Sets the translation of a transform.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    p : array-like, shape (3,)\n        Translation\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    check : bool, optional (default: True)\n        Check if transformation matrix is valid\n\n    Returns\n    -------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n    \"\"\"\n    if check:\n        A2B = check_transform(A2B, strict_check=strict_check)\n    out = A2B.copy()\n    out[:3, -1] = p\n    return out",
  "def rotate_transform(A2B, R, strict_check=True, check=True):\n    \"\"\"Sets the rotation of a transform.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    check : bool, optional (default: True)\n        Check if transformation matrix is valid\n\n    Returns\n    -------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n    \"\"\"\n    if check:\n        A2B = check_transform(A2B, strict_check=strict_check)\n    out = A2B.copy()\n    out[:3, :3] = R\n    return out",
  "def pq_from_transform(A2B, strict_check=True):\n    \"\"\"Compute position and quaternion from transformation matrix.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transformation matrix from frame A to frame B\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    Returns\n    -------\n    pq : array-like, shape (7,)\n        Position and orientation quaternion: (x, y, z, qw, qx, qy, qz)\n    \"\"\"\n    A2B = check_transform(A2B, strict_check=strict_check)\n    return np.hstack((A2B[:3, 3], quaternion_from_matrix(A2B[:3, :3])))",
  "def transform_from_pq(pq):\n    \"\"\"Compute transformation matrix from position and quaternion.\n\n    Parameters\n    ----------\n    pq : array-like, shape (7,)\n        Position and orientation quaternion: (x, y, z, qw, qx, qy, qz)\n\n    Returns\n    -------\n    A2B : array-like, shape (4, 4)\n        Transformation matrix from frame A to frame B\n    \"\"\"\n    pq = check_pq(pq)\n    return transform_from(matrix_from_quaternion(pq[3:]), pq[:3])",
  "def screw_parameters_from_screw_axis(screw_axis):\n    \"\"\"Compute screw parameters from screw axis.\n\n    Note that there is not just one solution since q can be any point on the\n    screw axis. We select q so that it is orthogonal to s_axis.\n\n    Parameters\n    ----------\n    screw_axis : array-like, shape (6,)\n        Screw axis described by 6 values\n        (omega_1, omega_2, omega_3, v_1, v_2, v_3),\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation.\n\n    Returns\n    -------\n    q : array, shape (3,)\n        Vector to a point on the screw axis that is orthogonal to s_axis\n\n    s_axis : array, shape (3,)\n        Unit direction vector of the screw axis\n\n    h : float\n        Pitch of the screw. The pitch is the ratio of translation and rotation\n        of the screw axis. Infinite pitch indicates pure translation.\n    \"\"\"\n    screw_axis = check_screw_axis(screw_axis)\n\n    omega = screw_axis[:3]\n    v = screw_axis[3:]\n\n    omega_norm = np.linalg.norm(omega)\n    if abs(omega_norm) < np.finfo(float).eps:  # pure translation\n        q = np.zeros(3)\n        s_axis = v\n        h = np.inf\n    else:\n        s_axis = omega\n        h = omega.dot(v)\n        moment = v - h * s_axis\n        q = np.cross(s_axis, moment)\n    return q, s_axis, h",
  "def screw_axis_from_screw_parameters(q, s_axis, h):\n    \"\"\"Compute screw axis representation from screw parameters.\n\n    Parameters\n    ----------\n    q : array-like, shape (3,)\n        Vector to a point on the screw axis\n\n    s_axis : array-like, shape (3,)\n        Direction vector of the screw axis\n\n    h : float\n        Pitch of the screw. The pitch is the ratio of translation and rotation\n        of the screw axis. Infinite pitch indicates pure translation.\n\n    Returns\n    -------\n    screw_axis : array, shape (6,)\n        Screw axis described by 6 values\n        (omega_1, omega_2, omega_3, v_1, v_2, v_3),\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation.\n    \"\"\"\n    q, s_axis, h = check_screw_parameters(q, s_axis, h)\n\n    if np.isinf(h):  # pure translation\n        return np.r_[0.0, 0.0, 0.0, s_axis]\n    return np.r_[s_axis, np.cross(q, s_axis) + h * s_axis]",
  "def screw_axis_from_exponential_coordinates(Stheta):\n    \"\"\"Compute screw axis and theta from exponential coordinates.\n\n    Parameters\n    ----------\n    Stheta : array-like, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation. Theta is the rotation angle\n        and h * theta the translation. Theta should be >= 0. Negative rotations\n        will be represented by a negative screw axis instead. This is relevant\n        if you want to recover theta from exponential coordinates.\n\n    Returns\n    -------\n    screw_axis : array, shape (6,)\n        Screw axis described by 6 values\n        (omega_1, omega_2, omega_3, v_1, v_2, v_3),\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation.\n\n    theta : float\n        Parameter of the transformation: theta is the angle of rotation\n        and h * theta the translation.\n    \"\"\"\n    Stheta = check_exponential_coordinates(Stheta)\n\n    omega_theta = Stheta[:3]\n    v_theta = Stheta[3:]\n    theta = np.linalg.norm(omega_theta)\n    if theta < np.finfo(float).eps:\n        theta = np.linalg.norm(v_theta)\n    if theta < np.finfo(float).eps:\n        return np.zeros(6), 0.0\n    return Stheta / theta, theta",
  "def screw_axis_from_screw_matrix(screw_matrix):\n    \"\"\"Compute screw axis from screw matrix.\n\n    Parameters\n    ----------\n    screw_matrix : array-like, shape (4, 4)\n        A screw matrix consists of a cross-product matrix that represents an\n        axis of rotation, a translation, and a row of zeros.\n\n    Returns\n    -------\n    screw_axis : array, shape (6,)\n        Screw axis described by 6 values\n        (omega_1, omega_2, omega_3, v_1, v_2, v_3),\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation.\n    \"\"\"\n    screw_matrix = check_screw_matrix(screw_matrix)\n\n    screw_axis = np.empty(6)\n    screw_axis[0] = screw_matrix[2, 1]\n    screw_axis[1] = screw_matrix[0, 2]\n    screw_axis[2] = screw_matrix[1, 0]\n    screw_axis[3:] = screw_matrix[:3, 3]\n    return screw_axis",
  "def exponential_coordinates_from_screw_axis(screw_axis, theta):\n    \"\"\"Compute exponential coordinates from screw axis and theta.\n\n    Parameters\n    ----------\n    screw_axis : array-like, shape (6,)\n        Screw axis described by 6 values\n        (omega_1, omega_2, omega_3, v_1, v_2, v_3),\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation.\n\n    theta : float\n        Parameter of the transformation: theta is the angle of rotation\n        and h * theta the translation.\n\n    Returns\n    -------\n    Stheta : array, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation. Theta is the rotation angle\n        and h * theta the translation. Theta should be >= 0. Negative rotations\n        will be represented by a negative screw axis instead. This is relevant\n        if you want to recover theta from exponential coordinates.\n    \"\"\"\n    screw_axis = check_screw_axis(screw_axis)\n    return screw_axis * theta",
  "def exponential_coordinates_from_transform_log(transform_log, check=True):\n    r\"\"\"Compute exponential coordinates from logarithm of transformation.\n\n    Extracts the vector :math:`\\mathcal{S} \\theta =\n    (\\hat{\\boldsymbol{\\omega}}, \\boldsymbol{v}) \\theta \\in \\mathbb{R}^6` from\n    the matrix\n\n    .. math::\n\n        \\left(\n        \\begin{array}{cccc}\n        0 & -\\omega_3 & \\omega_2 & v_1\\\\\n        \\omega_3 & 0 & -\\omega_1 & v_2\\\\\n        -\\omega_2 & \\omega_1 & 0 & v_3\\\\\n        0 & 0 & 0 & 0\n        \\end{array}\n        \\right)\n        \\theta = \\left[ \\mathcal{S} \\right] \\theta \\in so(3).\n\n    Parameters\n    ----------\n    transform_log : array-like, shape (4, 4)\n        Matrix logarithm of transformation matrix: [S] * theta.\n\n    check : bool, optional (default: True)\n        Check if logarithm of transformation is valid\n\n    Returns\n    -------\n    Stheta : array, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where S is the screw axis, the first 3 components are related to\n        rotation and the last 3 components are related to translation.\n        Theta is the rotation angle and h * theta the translation.\n    \"\"\"\n    if check:\n        transform_log = check_transform_log(transform_log)\n\n    Stheta = np.empty(6)\n    Stheta[0] = transform_log[2, 1]\n    Stheta[1] = transform_log[0, 2]\n    Stheta[2] = transform_log[1, 0]\n    Stheta[3:] = transform_log[:3, 3]\n    return Stheta",
  "def exponential_coordinates_from_transform(A2B, strict_check=True, check=True):\n    r\"\"\"Compute exponential coordinates from transformation matrix.\n\n    Logarithmic map.\n\n    .. math::\n\n        Log: \\boldsymbol{T} \\in SE(3)\n        \\rightarrow \\mathcal{S} \\theta \\in \\mathbb{R}^6\n\n    .. math::\n\n        Log(\\boldsymbol{T}) =\n        Log\\left(\n        \\begin{array}{cc}\n        \\boldsymbol{R} & \\boldsymbol{p}\\\\\n        \\boldsymbol{0} & 1\n        \\end{array}\n        \\right)\n        =\n        \\left(\n        \\begin{array}{c}\n        Log(\\boldsymbol{R})\\\\\n        \\boldsymbol{J}^{-1}(\\theta) \\boldsymbol{p}\n        \\end{array}\n        \\right)\n        =\n        \\left(\n        \\begin{array}{c}\n        \\hat{\\boldsymbol{\\omega}}\\\\\n        \\boldsymbol{v}\n        \\end{array}\n        \\right)\n        \\theta\n        =\n        \\mathcal{S}\\theta,\n\n    where :math:`\\boldsymbol{J}^{-1}(\\theta)` is the inverse left Jacobian of\n    :math:`SO(3)` (see :func:`~pytransform3d.rotations.left_jacobian_SO3_inv`).\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transformation matrix from frame A to frame B\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    check : bool, optional (default: True)\n        Check if transformation matrix is valid\n\n    Returns\n    -------\n    Stheta : array, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where S is the screw axis, the first 3 components are related to\n        rotation and the last 3 components are related to translation.\n        Theta is the rotation angle and h * theta the translation.\n    \"\"\"\n    if check:\n        A2B = check_transform(A2B, strict_check=strict_check)\n\n    R = A2B[:3, :3]\n    p = A2B[:3, 3]\n\n    if np.linalg.norm(np.eye(3) - R) < np.finfo(float).eps:\n        return np.r_[0.0, 0.0, 0.0, p]\n\n    omega_theta = compact_axis_angle_from_matrix(R, check=check)\n    theta = np.linalg.norm(omega_theta)\n\n    if theta == 0:\n        return np.r_[0.0, 0.0, 0.0, p]\n\n    v_theta = np.dot(left_jacobian_SO3_inv(omega_theta), p)\n\n    return np.hstack((omega_theta, v_theta))",
  "def screw_matrix_from_screw_axis(screw_axis):\n    \"\"\"Compute screw matrix from screw axis.\n\n    Parameters\n    ----------\n    screw_axis : array-like, shape (6,)\n        Screw axis described by 6 values\n        (omega_1, omega_2, omega_3, v_1, v_2, v_3),\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation.\n\n    Returns\n    -------\n    screw_matrix : array, shape (4, 4)\n        A screw matrix consists of a cross-product matrix that represents an\n        axis of rotation, a translation, and a row of zeros.\n    \"\"\"\n    screw_axis = check_screw_axis(screw_axis)\n\n    omega = screw_axis[:3]\n    v = screw_axis[3:]\n    screw_matrix = np.zeros((4, 4))\n    screw_matrix[:3, :3] = cross_product_matrix(omega)\n    screw_matrix[:3, 3] = v\n    return screw_matrix",
  "def screw_matrix_from_transform_log(transform_log):\n    \"\"\"Compute screw matrix from logarithm of transformation.\n\n    Parameters\n    ----------\n    transform_log : array-like, shape (4, 4)\n        Matrix logarithm of transformation matrix: [S] * theta.\n\n    Returns\n    -------\n    screw_matrix : array, shape (4, 4)\n        A screw matrix consists of a cross-product matrix that represents an\n        axis of rotation, a translation, and a row of zeros.\n    \"\"\"\n    transform_log = check_transform_log(transform_log)\n\n    omega = np.array([\n        transform_log[2, 1], transform_log[0, 2], transform_log[1, 0]])\n    theta = np.linalg.norm(omega)\n    if abs(theta) < np.finfo(float).eps:\n        theta = np.linalg.norm(transform_log[:3, 3])\n    if abs(theta) < np.finfo(float).eps:\n        return np.zeros((4, 4)), 0.0\n    return transform_log / theta, theta",
  "def transform_log_from_exponential_coordinates(Stheta):\n    r\"\"\"Compute matrix logarithm of transformation from exponential coordinates.\n\n    Builds the matrix\n\n    .. math::\n\n        \\left(\n        \\begin{array}{cccc}\n        0 & -\\omega_3 & \\omega_2 & v_1\\\\\n        \\omega_3 & 0 & -\\omega_1 & v_2\\\\\n        -\\omega_2 & \\omega_1 & 0 & v_3\\\\\n        0 & 0 & 0 & 0\n        \\end{array}\n        \\right) \\theta\n        = \\left[ \\mathcal{S} \\right] \\theta \\in so(3)\n\n    from the vector :math:`\\mathcal{S} \\theta = (\\hat{\\boldsymbol{\\omega}},\n    \\boldsymbol{v}) \\theta \\in \\mathbb{R}^6`.\n\n    Parameters\n    ----------\n    Stheta : array-like, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where S is the screw axis, the first 3 components are related to\n        rotation and the last 3 components are related to translation.\n        Theta is the rotation angle and h * theta the translation.\n\n    Returns\n    -------\n    transform_log : array, shape (4, 4)\n        Matrix logarithm of transformation matrix: [S] * theta.\n    \"\"\"\n    check_exponential_coordinates(Stheta)\n\n    omega = Stheta[:3]\n    v = Stheta[3:]\n    transform_log = np.zeros((4, 4))\n    transform_log[:3, :3] = cross_product_matrix(omega)\n    transform_log[:3, 3] = v\n    return transform_log",
  "def transform_log_from_screw_matrix(screw_matrix, theta):\n    \"\"\"Compute matrix logarithm of transformation from screw matrix and theta.\n\n    Parameters\n    ----------\n    screw_matrix : array-like, shape (4, 4)\n        A screw matrix consists of a cross-product matrix that represents an\n        axis of rotation, a translation, and a row of zeros.\n\n    theta : float\n        Parameter of the transformation: theta is the angle of rotation\n        and h * theta the translation.\n\n    Returns\n    -------\n    transform_log : array, shape (4, 4)\n        Matrix logarithm of transformation matrix: [S] * theta.\n    \"\"\"\n    screw_matrix = check_screw_matrix(screw_matrix)\n    return screw_matrix * theta",
  "def transform_log_from_transform(A2B, strict_check=True):\n    r\"\"\"Compute matrix logarithm of transformation from transformation.\n\n    Logarithmic map.\n\n    .. math::\n\n        \\log: \\boldsymbol{T} \\in SE(3)\n        \\rightarrow \\left[ \\mathcal{S} \\right] \\theta \\in se(3)\n\n    .. math::\n\n        \\log(\\boldsymbol{T}) =\n        \\log\\left(\n        \\begin{array}{cc}\n        \\boldsymbol{R} & \\boldsymbol{p}\\\\\n        \\boldsymbol{0} & 1\n        \\end{array}\n        \\right)\n        =\n        \\left(\n        \\begin{array}{cc}\n        \\log\\boldsymbol{R} & \\boldsymbol{J}^{-1}(\\theta) \\boldsymbol{p}\\\\\n        \\boldsymbol{0} & 0\n        \\end{array}\n        \\right)\n        =\n        \\left(\n        \\begin{array}{cc}\n        \\hat{\\boldsymbol{\\omega}} \\theta\n        & \\boldsymbol{v} \\theta\\\\\n        \\boldsymbol{0} & 0\n        \\end{array}\n        \\right)\n        =\n        \\left[\\mathcal{S}\\right]\\theta,\n\n    where :math:`\\boldsymbol{J}^{-1}(\\theta)` is the inverse left Jacobian of\n    :math:`SO(3)` (see :func:`~pytransform3d.rotations.left_jacobian_SO3_inv`).\n\n    Parameters\n    ----------\n    A2B : array, shape (4, 4)\n        Transform from frame A to frame B\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    Returns\n    -------\n    transform_log : array, shape (4, 4)\n        Matrix logarithm of transformation matrix: [S] * theta.\n    \"\"\"\n    A2B = check_transform(A2B, strict_check=strict_check)\n\n    R = A2B[:3, :3]\n    p = A2B[:3, 3]\n\n    transform_log = np.zeros((4, 4))\n\n    if np.linalg.norm(np.eye(3) - R) < np.finfo(float).eps:\n        transform_log[:3, 3] = p\n        return transform_log\n\n    omega_theta = compact_axis_angle_from_matrix(R)\n    theta = np.linalg.norm(omega_theta)\n\n    if theta == 0:\n        return transform_log\n\n    J_inv = left_jacobian_SO3_inv(omega_theta)\n    v_theta = np.dot(J_inv, p)\n\n    transform_log[:3, :3] = cross_product_matrix(omega_theta)\n    transform_log[:3, 3] = v_theta\n\n    return transform_log",
  "def transform_from_exponential_coordinates(Stheta, check=True):\n    r\"\"\"Compute transformation matrix from exponential coordinates.\n\n    Exponential map.\n\n    .. math::\n\n        Exp: \\mathcal{S} \\theta \\in \\mathbb{R}^6\n        \\rightarrow \\boldsymbol{T} \\in SE(3)\n\n    .. math::\n\n        Exp(\\mathcal{S}\\theta) =\n        Exp\\left(\\left(\\begin{array}{c}\n        \\hat{\\boldsymbol{\\omega}}\\\\\n        \\boldsymbol{v}\n        \\end{array}\\right)\\theta\\right)\n        =\n        \\exp(\\left[\\mathcal{S}\\right] \\theta)\n        =\n        \\left(\\begin{array}{cc}\n        Exp(\\hat{\\boldsymbol{\\omega}} \\theta) &\n        \\boldsymbol{J}(\\theta)\\boldsymbol{v}\\theta\\\\\n        \\boldsymbol{0} & 1\n        \\end{array}\\right),\n\n    where :math:`\\boldsymbol{J}(\\theta)` is the left Jacobian of :math:`SO(3)`\n    (see :func:`~pytransform3d.rotations.left_jacobian_SO3`).\n\n    Parameters\n    ----------\n    Stheta : array-like, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where S is the screw axis, the first 3 components are related to\n        rotation and the last 3 components are related to translation.\n        Theta is the rotation angle and h * theta the translation.\n\n    check : bool, optional (default: True)\n        Check if exponential coordinates are valid\n\n    Returns\n    -------\n    A2B : array, shape (4, 4)\n        Transformation matrix from frame A to frame B\n    \"\"\"\n    if check:\n        Stheta = check_exponential_coordinates(Stheta)\n\n    omega_theta = Stheta[:3]\n    theta = np.linalg.norm(omega_theta)\n\n    if theta == 0.0:  # only translation\n        return translate_transform(np.eye(4), Stheta[3:], check=check)\n\n    omega_theta = Stheta[:3]\n    v_theta = Stheta[3:]\n\n    A2B = np.eye(4)\n    A2B[:3, :3] = matrix_from_compact_axis_angle(omega_theta)\n    J = left_jacobian_SO3(omega_theta)\n    A2B[:3, 3] = np.dot(J, v_theta)\n    return A2B",
  "def transform_from_transform_log(transform_log):\n    r\"\"\"Compute transformation from matrix logarithm of transformation.\n\n    Exponential map.\n\n    .. math::\n\n        \\exp: \\left[ \\mathcal{S} \\right] \\theta \\in se(3)\n        \\rightarrow \\boldsymbol{T} \\in SE(3)\n\n    .. math::\n\n        \\exp([\\mathcal{S}]\\theta) =\n        \\exp\\left(\\left(\\begin{array}{cc}\n        \\left[\\hat{\\boldsymbol{\\omega}}\\right] & \\boldsymbol{v}\\\\\n        \\boldsymbol{0} & 0\n        \\end{array}\\right)\\theta\\right) =\n        \\left(\\begin{array}{cc}\n        Exp(\\hat{\\boldsymbol{\\omega}} \\theta) &\n        \\boldsymbol{J}(\\theta)\\boldsymbol{v}\\theta\\\\\n        \\boldsymbol{0} & 1\n        \\end{array}\\right),\n\n    where :math:`\\boldsymbol{J}(\\theta)` is the left Jacobian of :math:`SO(3)`\n    (see :func:`~pytransform3d.rotations.left_jacobian_SO3`).\n\n    Parameters\n    ----------\n    transform_log : array-like, shape (4, 4)\n        Matrix logarithm of transformation matrix: [S] * theta.\n\n    Returns\n    -------\n    A2B : array, shape (4, 4)\n        Transform from frame A to frame B\n    \"\"\"\n    transform_log = check_transform_log(transform_log)\n\n    omega_theta = np.array([\n        transform_log[2, 1], transform_log[0, 2], transform_log[1, 0]])\n    v_theta = transform_log[:3, 3]\n    theta = np.linalg.norm(omega_theta)\n\n    if theta == 0.0:  # only translation\n        return translate_transform(np.eye(4), v_theta)\n\n    A2B = np.eye(4)\n    A2B[:3, :3] = matrix_from_compact_axis_angle(omega_theta)\n    J = left_jacobian_SO3(omega_theta)\n    A2B[:3, 3] = np.dot(J, v_theta)\n    return A2B",
  "def dual_quaternion_from_transform(A2B):\n    \"\"\"Compute dual quaternion from transformation matrix.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    Returns\n    -------\n    dq : array, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n    \"\"\"\n    A2B = check_transform(A2B)\n    real = quaternion_from_matrix(A2B[:3, :3])\n    dual = 0.5 * concatenate_quaternions(\n        np.r_[0, A2B[:3, 3]], real)\n    return np.hstack((real, dual))",
  "def dual_quaternion_from_pq(pq):\n    \"\"\"Compute dual quaternion from position and quaternion.\n\n    Parameters\n    ----------\n    pq : array-like, shape (7,)\n        Position and orientation quaternion: (x, y, z, qw, qx, qy, qz)\n\n    Returns\n    -------\n    dq : array, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n    \"\"\"\n    pq = check_pq(pq)\n    real = pq[3:]\n    dual = 0.5 * concatenate_quaternions(\n        np.r_[0, pq[:3]], real)\n    return np.hstack((real, dual))",
  "def dual_quaternion_from_screw_parameters(q, s_axis, h, theta):\n    \"\"\"Compute dual quaternion from screw parameters.\n\n    Parameters\n    ----------\n    q : array-like, shape (3,)\n        Vector to a point on the screw axis\n\n    s_axis : array-like, shape (3,)\n        Direction vector of the screw axis\n\n    h : float\n        Pitch of the screw. The pitch is the ratio of translation and rotation\n        of the screw axis. Infinite pitch indicates pure translation.\n\n    theta : float\n        Parameter of the transformation: theta is the angle of rotation\n        and h * theta the translation.\n\n    Returns\n    -------\n    dq : array, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n    \"\"\"\n    q, s_axis, h = check_screw_parameters(q, s_axis, h)\n\n    if np.isinf(h):  # pure translation\n        d = theta\n        theta = 0\n    else:\n        d = h * theta\n    moment = np.cross(q, s_axis)\n\n    half_distance = 0.5 * d\n    sin_half_angle = np.sin(0.5 * theta)\n    cos_half_angle = np.cos(0.5 * theta)\n\n    real_w = cos_half_angle\n    real_vec = sin_half_angle * s_axis\n    dual_w = -half_distance * sin_half_angle\n    dual_vec = (sin_half_angle * moment +\n                half_distance * cos_half_angle * s_axis)\n\n    return np.r_[real_w, real_vec, dual_w, dual_vec]",
  "def transform_from_dual_quaternion(dq):\n    \"\"\"Compute transformation matrix from dual quaternion.\n\n    Parameters\n    ----------\n    dq : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Returns\n    -------\n    A2B : array, shape (4, 4)\n        Transform from frame A to frame B\n    \"\"\"\n    dq = check_dual_quaternion(dq)\n    real = dq[:4]\n    dual = dq[4:]\n    R = matrix_from_quaternion(real)\n    p = 2 * concatenate_quaternions(dual, q_conj(real))[1:]\n    return transform_from(R=R, p=p)",
  "def pq_from_dual_quaternion(dq):\n    \"\"\"Compute position and quaternion from dual quaternion.\n\n    Parameters\n    ----------\n    dq : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Returns\n    -------\n    pq : array, shape (7,)\n        Position and orientation quaternion: (x, y, z, qw, qx, qy, qz)\n    \"\"\"\n    dq = check_dual_quaternion(dq)\n    real = dq[:4]\n    dual = dq[4:]\n    p = 2 * concatenate_quaternions(dual, q_conj(real))[1:]\n    return np.hstack((p, real))",
  "def screw_parameters_from_dual_quaternion(dq):\n    \"\"\"Compute screw parameters from dual quaternion.\n\n    Parameters\n    ----------\n    dq : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Returns\n    -------\n    q : array, shape (3,)\n        Vector to a point on the screw axis\n\n    s_axis : array, shape (3,)\n        Direction vector of the screw axis\n\n    h : float\n        Pitch of the screw. The pitch is the ratio of translation and rotation\n        of the screw axis. Infinite pitch indicates pure translation.\n\n    theta : float\n        Parameter of the transformation: theta is the angle of rotation\n        and h * theta the translation.\n    \"\"\"\n    dq = check_dual_quaternion(dq, unit=True)\n\n    real = dq[:4]\n    dual = dq[4:]\n\n    a = axis_angle_from_quaternion(real)\n    s_axis = a[:3]\n    theta = a[3]\n\n    translation = 2 * concatenate_quaternions(dual, q_conj(real))[1:]\n    if abs(theta) < np.finfo(float).eps:\n        # pure translation\n        d = np.linalg.norm(translation)\n        if d < np.finfo(float).eps:\n            s_axis = np.array([1, 0, 0])\n        else:\n            s_axis = translation / d\n        q = np.zeros(3)\n        theta = d\n        h = np.inf\n        return q, s_axis, h, theta\n\n    distance = np.dot(translation, s_axis)\n    moment = 0.5 * (np.cross(translation, s_axis) +\n                    (translation - distance * s_axis)\n                    / np.tan(0.5 * theta))\n    dual = np.cross(s_axis, moment)\n    h = distance / theta\n    return dual, s_axis, h, theta",
  "def adjoint_from_transform(A2B, strict_check=True, check=True):\n    r\"\"\"Compute adjoint representation of a transformation matrix.\n\n    The adjoint representation of a transformation\n    :math:`\\left[Ad_{\\boldsymbol{T}_{BA}}\\right] \\in \\mathbb{R}^{6 \\times 6}`\n    from frame A to frame B translates a twist from frame A to frame B\n    through the adjoint map\n\n    .. math::\n\n        \\mathcal{V}_{B}\n        = \\left[Ad_{\\boldsymbol{T}_{BA}}\\right] \\mathcal{V}_A\n\n    The corresponding transformation matrix operation is\n\n    .. math::\n\n        \\left[\\mathcal{V}_{B}\\right]\n        = \\boldsymbol{T}_{BA} \\left[\\mathcal{V}_A\\right]\n        \\boldsymbol{T}_{BA}^{-1}\n\n    We can also use the adjoint representation to transform a wrench from frame\n    A to frame B:\n\n    .. math::\n\n        \\mathcal{F}_B\n        = \\left[ Ad_{\\boldsymbol{T}_{AB}} \\right]^T \\mathcal{F}_A\n\n    Note that not only the adjoint is transposed but also the transformation is\n    inverted.\n\n    Adjoint representations have the following properties:\n\n    .. math::\n\n        \\left[Ad_{\\boldsymbol{T}_1 \\boldsymbol{T}_2}\\right]\n        = \\left[Ad_{\\boldsymbol{T}_1}\\right]\n        \\left[Ad_{\\boldsymbol{T}_2}\\right]\n\n    .. math::\n\n        \\left[Ad_{\\boldsymbol{T}}\\right]^{-1} =\n        \\left[Ad_{\\boldsymbol{T}^{-1}}\\right]\n\n    For a transformation matrix\n\n    .. math::\n\n        \\boldsymbol T =\n        \\left( \\begin{array}{cc}\n            \\boldsymbol R & \\boldsymbol t\\\\\n            \\boldsymbol 0 & 1\\\\\n        \\end{array} \\right)\n\n    the adjoint is defined as\n\n    .. math::\n\n        \\left[Ad_{\\boldsymbol{T}}\\right]\n        =\n        \\left( \\begin{array}{cc}\n            \\boldsymbol R & \\boldsymbol 0\\\\\n            \\left[\\boldsymbol{t}\\right]_{\\times}\\boldsymbol R & \\boldsymbol R\\\\\n        \\end{array} \\right),\n\n    where :math:`\\left[\\boldsymbol{t}\\right]_{\\times}` is the cross-product\n    matrix (see :func:`~pytransform3d.rotations.cross_product_matrix`) of the\n    translation component.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    check : bool, optional (default: True)\n        Check if transformation matrix is valid\n\n    Returns\n    -------\n    adj_A2B : array, shape (6, 6)\n        Adjoint representation of transformation matrix\n    \"\"\"\n    if check:\n        A2B = check_transform(A2B, strict_check)\n\n    R = A2B[:3, :3]\n    p = A2B[:3, 3]\n\n    adj_A2B = np.zeros((6, 6))\n    adj_A2B[:3, :3] = R\n    adj_A2B[3:, :3] = np.dot(cross_product_matrix(p), R)\n    adj_A2B[3:, 3:] = R\n    return adj_A2B",
  "def norm_exponential_coordinates(Stheta):\n    \"\"\"Normalize exponential coordinates of transformation.\n\n    Parameters\n    ----------\n    Stheta : array-like, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation. Theta is the rotation angle\n        and h * theta the translation. Theta should be >= 0. Negative rotations\n        will be represented by a negative screw axis instead. This is relevant\n        if you want to recover theta from exponential coordinates.\n\n    Returns\n    -------\n    Stheta : array, shape (6,)\n        Normalized exponential coordinates of transformation with theta in\n        [0, pi]. Note that in the case of pure translation no normalization\n        is required because the representation is unique. In the case of\n        rotation by pi, there is an ambiguity that will be resolved so that\n        the screw pitch is positive.\n    \"\"\"\n    theta = np.linalg.norm(Stheta[:3])\n    if theta == 0.0:\n        return Stheta\n\n    screw_axis = Stheta / theta\n    q, s_axis, h = screw_parameters_from_screw_axis(screw_axis)\n    if abs(theta - np.pi) < eps and h < 0:\n        h *= -1.0\n        s_axis *= -1.0\n    theta_normed = norm_angle(theta)\n    h_normalized = h * theta / theta_normed\n    screw_axis = screw_axis_from_screw_parameters(q, s_axis, h_normalized)\n\n    return screw_axis * theta_normed",
  "def left_jacobian_SE3(Stheta):\n    r\"\"\"Left Jacobian of SE(3).\n\n    .. math::\n\n        \\boldsymbol{\\mathcal{J}}\n        =\n        \\left(\n        \\begin{array}{cc}\n        \\boldsymbol{J} & \\boldsymbol{0}\\\\\n        \\boldsymbol{Q} & \\boldsymbol{J}\n        \\end{array}\n        \\right),\n\n    where :math:`\\boldsymbol{J}` is the left Jacobian of SO(3) and\n    :math:`\\boldsymbol{Q}` is given by Barfoot and Furgale (see reference\n    below).\n\n    Parameters\n    ----------\n    Stheta : array-like, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where S is the screw axis, the first 3 components are related to\n        rotation and the last 3 components are related to translation.\n        Theta is the rotation angle and h * theta the translation.\n\n    Returns\n    -------\n    J : array, shape (6, 6)\n        Jacobian of SE(3).\n\n    References\n    ----------\n    Barfoot, Furgale: Associating Uncertainty With Three-Dimensional Poses for\n    Use in Estimation Problems,\n    http://ncfrn.mcgill.ca/members/pubs/barfoot_tro14.pdf\n    \"\"\"\n    Stheta = check_exponential_coordinates(Stheta)\n\n    _, theta = screw_axis_from_exponential_coordinates(Stheta)\n    if theta < np.finfo(float).eps:\n        return left_jacobian_SE3_series(Stheta, 10)\n\n    phi = Stheta[:3]\n    J = left_jacobian_SO3(phi)\n    return np.block([\n        [J, np.zeros((3, 3))],\n        [_Q(Stheta), J]\n    ])",
  "def left_jacobian_SE3_series(Stheta, n_terms):\n    \"\"\"Left Jacobian of SE(3) at theta from Taylor series.\n\n    Parameters\n    ----------\n    Stheta : array-like, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where S is the screw axis, the first 3 components are related to\n        rotation and the last 3 components are related to translation.\n        Theta is the rotation angle and h * theta the translation.\n\n    n_terms : int\n        Number of terms to include in the series.\n\n    Returns\n    -------\n    J : array, shape (3, 3)\n        Left Jacobian of SE(3).\n    \"\"\"\n    Stheta = check_exponential_coordinates(Stheta)\n    J = np.eye(6)\n    pxn = np.eye(6)\n    px = _curlyhat(Stheta)\n    for n in range(n_terms):\n        pxn = np.dot(pxn, px) / (n + 2)\n        J += pxn\n    return J",
  "def left_jacobian_SE3_inv(Stheta):\n    r\"\"\"Left inverse Jacobian of SE(3).\n\n    .. math::\n\n        \\boldsymbol{\\mathcal{J}}^{-1}\n        =\n        \\left(\n        \\begin{array}{cc}\n        \\boldsymbol{J}^{-1} & \\boldsymbol{0}\\\\\n        -\\boldsymbol{J}^{-1}\\boldsymbol{Q}\\boldsymbol{J}^{-1} &\n        \\boldsymbol{J}^{-1}\n        \\end{array}\n        \\right),\n\n    where :math:`\\boldsymbol{J}` is the left Jacobian of SO(3) and\n    :math:`\\boldsymbol{Q}` is given by Barfoot and Furgale (see reference\n    below).\n\n    Parameters\n    ----------\n    Stheta : array-like, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where S is the screw axis, the first 3 components are related to\n        rotation and the last 3 components are related to translation.\n        Theta is the rotation angle and h * theta the translation.\n\n    Returns\n    -------\n    J_inv : array, shape (6, 6)\n        Inverse Jacobian of SE(3).\n    \"\"\"\n    Stheta = check_exponential_coordinates(Stheta)\n\n    _, theta = screw_axis_from_exponential_coordinates(Stheta)\n    if theta < np.finfo(float).eps:\n        return left_jacobian_SE3_inv_series(Stheta, 10)\n\n    phi = Stheta[:3]\n    J_inv = left_jacobian_SO3_inv(phi)\n    return np.block([\n        [J_inv, np.zeros((3, 3))],\n        [-np.dot(J_inv, np.dot(_Q(Stheta), J_inv)), J_inv]\n    ])",
  "def _Q(Stheta):\n    rho = Stheta[3:]\n    phi = Stheta[:3]\n    ph = np.linalg.norm(phi)\n\n    px = cross_product_matrix(phi)\n    rx = cross_product_matrix(rho)\n\n    ph2 = ph * ph\n    ph3 = ph2 * ph\n    ph4 = ph3 * ph\n    ph5 = ph4 * ph\n\n    cph = math.cos(ph)\n    sph = math.sin(ph)\n\n    t1 = 0.5 * rx\n    t2 = (ph - sph) / ph3 * (np.dot(px, rx) + np.dot(rx, px)\n                             + np.dot(px, np.dot(rx, px)))\n    m3 = (1.0 - 0.5 * ph * ph - cph) / ph4\n    t3 = -m3 * (np.dot(px, np.dot(px, rx)) + np.dot(rx, np.dot(px, px))\n                - 3 * np.dot(px, np.dot(rx, px)))\n    m4 = 0.5 * (m3 - 3.0 * (ph - sph - ph3 / 6.0) / ph5)\n    t4 = -m4 * (np.dot(px, np.dot(rx, np.dot(px, px)))\n                + np.dot(px, np.dot(px, np.dot(rx, px))))\n\n    Q = t1 + t2 + t3 + t4\n\n    return Q",
  "def left_jacobian_SE3_inv_series(Stheta, n_terms):\n    \"\"\"Left inverse Jacobian of SE(3) at theta from Taylor series.\n\n    Parameters\n    ----------\n    Stheta : array-like, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where S is the screw axis, the first 3 components are related to\n        rotation and the last 3 components are related to translation.\n        Theta is the rotation angle and h * theta the translation.\n\n    n_terms : int\n        Number of terms to include in the series.\n\n    Returns\n    -------\n    J_inv : array, shape (3, 3)\n        Inverse left Jacobian of SE(3).\n    \"\"\"\n    from scipy.special import bernoulli\n\n    Stheta = check_exponential_coordinates(Stheta)\n    J_inv = np.eye(6)\n    pxn = np.eye(6)\n    px = _curlyhat(Stheta)\n    b = bernoulli(n_terms + 1)\n    for n in range(n_terms):\n        pxn = np.dot(pxn, px / (n + 1))\n        J_inv += b[n + 1] * pxn\n    return J_inv",
  "def _curlyhat(Stheta):\n    omega_matrix = cross_product_matrix(Stheta[:3])\n    return np.block([\n        [omega_matrix, np.zeros((3, 3))],\n        [cross_product_matrix(Stheta[3:]), omega_matrix]\n    ])",
  "def plot_transform(ax=None, A2B=None, s=1.0, ax_s=1, name=None,\n                   strict_check=True, **kwargs):\n    \"\"\"Plot transform.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    A2B : array-like, shape (4, 4), optional (default: I)\n        Transform from frame A to frame B\n\n    s : float, optional (default: 1)\n        Scaling of the axis and angle that will be drawn\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    name : string, optional (default: None)\n        Name of the frame, will be used for annotation\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    kwargs : dict, optional (default: {})\n        Additional arguments for the plotting functions, e.g. alpha\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    from ..plot_utils import make_3d_axis, Frame\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    if A2B is None:\n        A2B = np.eye(4)\n    A2B = check_transform(A2B, strict_check=strict_check)\n\n    frame = Frame(A2B, name, s, **kwargs)\n    frame.add_frame(ax)\n\n    return ax",
  "def plot_screw(ax=None, q=np.zeros(3), s_axis=np.array([1.0, 0.0, 0.0]), h=1.0,\n               theta=1.0, A2B=None, s=1.0, ax_s=1, alpha=1.0, **kwargs):\n    \"\"\"Plot transformation about and along screw axis.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    q : array-like, shape (3,), optional (default: [0, 0, 0])\n        Vector to a point on the screw axis\n\n    s_axis : array-like, shape (3,), optional (default: [1, 0, 0])\n        Direction vector of the screw axis\n\n    h : float, optional (default: 1)\n        Pitch of the screw. The pitch is the ratio of translation and rotation\n        of the screw axis. Infinite pitch indicates pure translation.\n\n    theta : float, optional (default: 1)\n        Rotation angle. h * theta is the translation.\n\n    A2B : array-like, shape (4, 4), optional (default: I)\n        Origin of the screw\n\n    s : float, optional (default: 1)\n        Scaling of the axis and angle that will be drawn\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    alpha : float, optional (default: 1)\n        Alpha channel of plotted lines\n\n    kwargs : dict, optional (default: {})\n        Additional arguments for the plotting functions, e.g. color\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    from ..plot_utils import make_3d_axis, Arrow3D\n    from ..rotations import (vector_projection, angle_between_vectors,\n                             perpendicular_to_vectors, slerp_weights)\n\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    if A2B is None:\n        A2B = np.eye(4)\n\n    q, s_axis, h = check_screw_parameters(q, s_axis, h)\n\n    origin_projected_on_screw_axis = q + vector_projection(-q, s_axis)\n\n    pure_translation = np.isinf(h)\n\n    if not pure_translation:\n        screw_axis_to_old_frame = -origin_projected_on_screw_axis\n        screw_axis_to_rotated_frame = perpendicular_to_vectors(\n            s_axis, screw_axis_to_old_frame)\n        screw_axis_to_translated_frame = h * s_axis\n\n        arc = np.empty((100, 3))\n        angle = angle_between_vectors(\n            screw_axis_to_old_frame, screw_axis_to_rotated_frame)\n        for i, t in enumerate(zip(np.linspace(0, 2 * theta / np.pi, len(arc)),\n                                  np.linspace(0.0, 1.0, len(arc)))):\n            t1, t2 = t\n            w1, w2 = slerp_weights(angle, t1)\n            arc[i] = (origin_projected_on_screw_axis\n                      + w1 * screw_axis_to_old_frame\n                      + w2 * screw_axis_to_rotated_frame\n                      + screw_axis_to_translated_frame * t2 * theta)\n\n    q = transform(A2B, vector_to_point(q))[:3]\n    s_axis = transform(A2B, vector_to_direction(s_axis))[:3]\n    if not pure_translation:\n        arc = transform(A2B, vectors_to_points(arc))[:, :3]\n        origin_projected_on_screw_axis = transform(\n            A2B, vector_to_point(origin_projected_on_screw_axis))[:3]\n\n    # Screw axis\n    ax.scatter(q[0], q[1], q[2], color=\"r\")\n    if pure_translation:\n        s_axis *= theta\n        ax.scatter(q[0] + s_axis[0], q[1] + s_axis[1], q[2] + s_axis[2],\n                   color=\"r\")\n    ax.plot(\n        [q[0] - s * s_axis[0], q[0] + (1 + s) * s_axis[0]],\n        [q[1] - s * s_axis[1], q[1] + (1 + s) * s_axis[1]],\n        [q[2] - s * s_axis[2], q[2] + (1 + s) * s_axis[2]],\n        \"--\", c=\"k\", alpha=alpha)\n    axis_arrow = Arrow3D(\n        [q[0], q[0] + s_axis[0]],\n        [q[1], q[1] + s_axis[1]],\n        [q[2], q[2] + s_axis[2]],\n        mutation_scale=20, lw=3, arrowstyle=\"-|>\", color=\"k\", alpha=alpha)\n    ax.add_artist(axis_arrow)\n\n    if not pure_translation:\n        # Transformation\n        ax.plot(arc[:, 0], arc[:, 1], arc[:, 2], color=\"k\", lw=3,\n                alpha=alpha, **kwargs)\n        arrow_coords = np.vstack((arc[-1], arc[-1] + (arc[-1] - arc[-2]))).T\n        angle_arrow = Arrow3D(\n            arrow_coords[0], arrow_coords[1], arrow_coords[2],\n            mutation_scale=20, lw=3, arrowstyle=\"-|>\", color=\"k\", alpha=alpha)\n        ax.add_artist(angle_arrow)\n\n        for i in [0, -1]:\n            arc_bound = np.vstack((origin_projected_on_screw_axis, arc[i])).T\n            ax.plot(arc_bound[0], arc_bound[1], arc_bound[2], \"--\", c=\"k\",\n                    alpha=alpha)\n\n    return ax",
  "def random_transform(\n        rng=np.random.default_rng(0), mean=np.eye(4), cov=np.eye(6)):\n    r\"\"\"Generate random transform.\n\n    Generate :math:`\\Delta \\boldsymbol{T}_{B_{i+1}{B_i}}\n    \\boldsymbol{T}_{{B_i}A}`, with :math:`\\Delta \\boldsymbol{T}_{B_{i+1}{B_i}}\n    = Exp(S \\theta)` and :math:`\\mathcal{S}\\theta \\sim\n    \\mathcal{N}(\\boldsymbol{0}_6, \\boldsymbol{\\Sigma}_{6 \\times 6})`.\n    The mean :math:`\\boldsymbol{T}_{{B_i}A}` and the covariance\n    :math:`\\boldsymbol{\\Sigma}_{6 \\times 6}` are parameters of the function.\n\n    Note that uncertainty is defined in the global frame B, not in the\n    body frame A.\n\n    Parameters\n    ----------\n    rng : np.random.Generator, optional (default: random seed 0)\n        Random number generator\n\n    mean : array-like, shape (4, 4), optional (default: I)\n        Mean transform as homogeneous transformation matrix.\n\n    cov : array-like, shape (6, 6), optional (default: I)\n        Covariance of noise in exponential coordinate space.\n\n    Returns\n    -------\n    A2B : array-like, shape (4, 4)\n        Random transform from frame A to frame B\n    \"\"\"\n    mean = check_transform(mean)\n    Stheta = random_exponential_coordinates(rng=rng, cov=cov)\n    delta = transform_from_exponential_coordinates(Stheta)\n    return np.dot(delta, mean)",
  "def random_screw_axis(rng=np.random.default_rng(0)):\n    r\"\"\"Generate random screw axis.\n\n    Each component of v will be sampled from a standard normal distribution\n    :math:`\\mathcal{N}(\\mu=0, \\sigma=1)`. Components of :math:`\\omega` will\n    be sampled from a standard normal distribution and normalized.\n\n    Parameters\n    ----------\n    rng : np.random.Generator, optional (default: random seed 0)\n        Random number generator\n\n    Returns\n    -------\n    screw_axis : array, shape (6,)\n        Screw axis described by 6 values\n        (omega_1, omega_2, omega_3, v_1, v_2, v_3),\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation.\n    \"\"\"\n    omega = norm_vector(rng.standard_normal(size=3))\n    v = rng.standard_normal(size=3)\n    return np.hstack((omega, v))",
  "def random_exponential_coordinates(\n        rng=np.random.default_rng(0), cov=np.eye(6)):\n    r\"\"\"Generate random exponential coordinates.\n\n    Each component of Stheta will be sampled from a standard normal\n    distribution :math:`\\mathcal{N}(\\boldsymbol{0}_6,\n    \\boldsymbol{\\Sigma}_{6 \\times 6})`.\n\n    Parameters\n    ----------\n    rng : np.random.Generator, optional (default: random seed 0)\n        Random number generator\n\n    cov : array-like, shape (6, 6), optional (default: I)\n        Covariance of normal distribution.\n\n    Returns\n    -------\n    Stheta : array, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation. Theta is the rotation angle\n        and h * theta the translation. Theta should be >= 0. Negative rotations\n        will be represented by a negative screw axis instead. This is relevant\n        if you want to recover theta from exponential coordinates.\n    \"\"\"\n    return rng.multivariate_normal(mean=np.zeros(6), cov=cov)",
  "def dq_conj(dq):\n    \"\"\"Conjugate of dual quaternion.\n\n    There are three different conjugates for dual quaternions. The one that we\n    use here converts (pw, px, py, pz, qw, qx, qy, qz) to\n    (pw, -px, -py, -pz, -qw, qx, qy, qz). It is a combination of the quaternion\n    conjugate and the dual number conjugate.\n\n    Parameters\n    ----------\n    dq : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Returns\n    -------\n    dq_conjugate : array-like, shape (8,)\n        Conjugate of dual quaternion: (pw, -px, -py, -pz, -qw, qx, qy, qz)\n    \"\"\"\n    dq = check_dual_quaternion(dq)\n    return np.r_[dq[0], -dq[1:5], dq[5:]]",
  "def dq_q_conj(dq):\n    \"\"\"Quaternion conjugate of dual quaternion.\n\n    There are three different conjugates for dual quaternions. The one that we\n    use here converts (pw, px, py, pz, qw, qx, qy, qz) to\n    (pw, -px, -py, -pz, qw, -qx, -qy, -qz). It is the quaternion conjugate\n    applied to each of the two quaternions.\n\n    For unit dual quaternions that represent transformations, this function\n    is equivalent to the inverse of the corresponding transformation matrix.\n\n    Parameters\n    ----------\n    dq : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Returns\n    -------\n    dq_q_conjugate : array-like, shape (8,)\n        Conjugate of dual quaternion: (pw, -px, -py, -pz, qw, -qx, -qy, -qz)\n    \"\"\"\n    dq = check_dual_quaternion(dq)\n    return np.r_[dq[0], -dq[1:4], dq[4], -dq[5:]]",
  "def concatenate_dual_quaternions(dq1, dq2):\n    \"\"\"Concatenate dual quaternions.\n\n    Suppose we want to apply two extrinsic transforms given by dual\n    quaternions dq1 and dq2 to a vector v. We can either apply dq2 to v and\n    then dq1 to the result or we can concatenate dq1 and dq2 and apply the\n    result to v.\n\n    .. warning::\n\n        Note that the order of arguments is different than the order in\n        :func:`concat`.\n\n    Parameters\n    ----------\n    dq1 : array-like, shape (8,)\n        Dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    dq2 : array-like, shape (8,)\n        Dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Returns\n    -------\n    dq3 : array, shape (8,)\n        Product of the two dual quaternions:\n        (pw, px, py, pz, qw, qx, qy, qz)\n    \"\"\"\n    dq1 = check_dual_quaternion(dq1)\n    dq2 = check_dual_quaternion(dq2)\n    real = concatenate_quaternions(dq1[:4], dq2[:4])\n    dual = (concatenate_quaternions(dq1[:4], dq2[4:]) +\n            concatenate_quaternions(dq1[4:], dq2[:4]))\n    return np.hstack((real, dual))",
  "def dq_prod_vector(dq, v):\n    \"\"\"Apply transform represented by a dual quaternion to a vector.\n\n    Parameters\n    ----------\n    dq : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    v : array-like, shape (3,)\n        3d vector\n\n    Returns\n    -------\n    w : array, shape (3,)\n        3d vector\n    \"\"\"\n    dq = check_dual_quaternion(dq)\n    v_dq = np.r_[1, 0, 0, 0, 0, v]\n    v_dq_transformed = concatenate_dual_quaternions(\n        concatenate_dual_quaternions(dq, v_dq),\n        dq_conj(dq))\n    return v_dq_transformed[5:]",
  "def dual_quaternion_sclerp(start, end, t):\n    \"\"\"Screw linear interpolation (ScLERP) for dual quaternions.\n\n    Although linear interpolation of dual quaternions is possible, this does\n    not result in constant velocities. If you want to generate interpolations\n    with constant velocity, you have to use ScLERP.\n\n    Parameters\n    ----------\n    start : array-like, shape (8,)\n        Unit dual quaternion to represent start pose:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    end : array-like, shape (8,)\n        Unit dual quaternion to represent end pose:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    t : float in [0, 1]\n        Position between start and goal\n\n    Returns\n    -------\n    a : array, shape (8,)\n        Interpolated unit dual quaternion: (pw, px, py, pz, qw, qx, qy, qz)\n\n    References\n    ----------\n    Kavan, Collins, O'Sullivan, Zara: Dual Quaternions for Rigid Transformation\n    Blending (2006), Technical report, Trinity College Dublin,\n    https://users.cs.utah.edu/~ladislav/kavan06dual/kavan06dual.pdf\n    \"\"\"\n    start = check_dual_quaternion(start)\n    end = check_dual_quaternion(end)\n    diff = concatenate_dual_quaternions(dq_q_conj(start), end)\n    return concatenate_dual_quaternions(start, dual_quaternion_power(diff, t))",
  "def dual_quaternion_power(dq, t):\n    r\"\"\"Compute power of unit dual quaternion with respect to scalar.\n\n    .. math::\n\n        (p + \\epsilon q)^t\n\n    Parameters\n    ----------\n    dq : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    t : float\n        Exponent\n\n    Returns\n    -------\n    dq_t : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz) ** t\n    \"\"\"\n    dq = check_dual_quaternion(dq)\n    q, s_axis, h, theta = screw_parameters_from_dual_quaternion(dq)\n    return dual_quaternion_from_screw_parameters(q, s_axis, h, theta * t)",
  "def invert_transform(A2B, strict_check=True, check=True):\n    \"\"\"Invert transform.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    check : bool, optional (default: True)\n        Check if transformation matrix is valid\n\n    Returns\n    -------\n    B2A : array, shape (4, 4)\n        Transform from frame B to frame A\n    \"\"\"\n    if check:\n        A2B = check_transform(A2B, strict_check=strict_check)\n    # NOTE there is a faster version, but it is not faster than matrix\n    # inversion with numpy:\n    # ( R t )^-1   ( R^T -R^T*t )\n    # ( 0 1 )    = ( 0    1     )\n    return np.linalg.inv(A2B)",
  "def vector_to_point(v):\n    \"\"\"Convert 3D vector to position.\n\n    A point (x, y, z) given by the components of a vector will be represented\n    by [x, y, z, 1] in homogeneous coordinates to which we can apply a\n    transformation.\n\n    Parameters\n    ----------\n    v : array-like, shape (3,)\n        3D vector that contains x, y, and z\n\n    Returns\n    -------\n    p : array-like, shape (4,)\n        Point vector with 1 as last element\n    \"\"\"\n    return np.hstack((v, 1))",
  "def vectors_to_points(V):\n    \"\"\"Convert 3D vectors to positions.\n\n    A point (x, y, z) given by the components of a vector will be represented\n    by [x, y, z, 1] in homogeneous coordinates to which we can apply a\n    transformation.\n\n    Parameters\n    ----------\n    V : array-like, shape (n_points, 3)\n        Each row is a 3D vector that contains x, y, and z\n\n    Returns\n    -------\n    P : array-like, shape (n_points, 4)\n        Each row is a point vector with 1 as last element\n    \"\"\"\n    return np.hstack((V, np.ones((len(V), 1))))",
  "def vector_to_direction(v):\n    \"\"\"Convert 3D vector to direction.\n\n    A direction (x, y, z) given by the components of a vector will be\n    represented by [x, y, z, 0] in homogeneous coordinates to which we can\n    apply a transformation.\n\n    Parameters\n    ----------\n    v : array-like, shape (3,)\n        3D vector that contains x, y, and z\n\n    Returns\n    -------\n    p : array-like, shape (4,)\n        Direction vector with 0 as last element\n    \"\"\"\n    return np.hstack((v, 0))",
  "def vectors_to_directions(V):\n    \"\"\"Convert 3D vectors to directions.\n\n    A direction (x, y, z) given by the components of a vector will be\n    represented by [x, y, z, 0] in homogeneous coordinates to which we can\n    apply a transformation.\n\n    Parameters\n    ----------\n    V : array-like, shape (n_directions, 3)\n        Each row is a 3D vector that contains x, y, and z\n\n    Returns\n    -------\n    P : array-like, shape (n_directions, 4)\n        Each row is a direction vector with 0 as last element\n    \"\"\"\n    return np.hstack((V, np.zeros((len(V), 1))))",
  "def concat(A2B, B2C, strict_check=True, check=True):\n    r\"\"\"Concatenate transformations.\n\n    We use the extrinsic convention, which means that B2C is left-multiplied\n    to A2B. In mathematical notation:\n\n    .. math::\n\n        \\boldsymbol{T}_{CB} \\boldsymbol{T}_{BA} = \\boldsymbol{T}_{CA}.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    B2C : array-like, shape (4, 4)\n        Transform from frame B to frame C\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    check : bool, optional (default: True)\n        Check if transformation matrices are valid\n\n    Returns\n    -------\n    A2C : array-like, shape (4, 4)\n        Transform from frame A to frame C\n    \"\"\"\n    if check:\n        A2B = check_transform(A2B, strict_check=strict_check)\n        B2C = check_transform(B2C, strict_check=strict_check)\n    return B2C.dot(A2B)",
  "def transform(A2B, PA, strict_check=True):\n    \"\"\"Transform point or list of points or directions.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    PA : array-like, shape (4,) or (n_points, 4)\n        Point or points in frame A\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    Returns\n    -------\n    PB : array-like, shape (4,) or (n_points, 4)\n        Point or points in frame B\n\n    Raises\n    ------\n    ValueError\n        If dimensions are incorrect\n    \"\"\"\n    A2B = check_transform(A2B, strict_check=strict_check)\n    PA = np.asarray(PA)\n\n    if PA.ndim == 1:\n        return np.dot(A2B, PA)\n\n    if PA.ndim == 2:\n        return np.dot(PA, A2B.T)\n\n    raise ValueError(\"Cannot transform array with more than 2 dimensions\")",
  "def scale_transform(A2B, s_xr=1.0, s_yr=1.0, s_zr=1.0, s_r=1.0,\n                    s_xt=1.0, s_yt=1.0, s_zt=1.0, s_t=1.0, s_d=1.0,\n                    strict_check=True):\n    \"\"\"Scale a transform from A to reference frame B.\n\n    See algorithm 10 from \"Analytic Approaches for Design and Operation of\n    Haptic Human-Machine Interfaces\" (Bertold Bongardt).\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    s_xr : float, optional (default: 1)\n        Scaling of x-component of the rotation axis\n\n    s_yr : float, optional (default: 1)\n        Scaling of y-component of the rotation axis\n\n    s_zr : float, optional (default: 1)\n        Scaling of z-component of the rotation axis\n\n    s_r : float, optional (default: 1)\n        Scaling of the rotation\n\n    s_xt : float, optional (default: 1)\n        Scaling of z-component of the translation\n\n    s_yt : float, optional (default: 1)\n        Scaling of z-component of the translation\n\n    s_zt : float, optional (default: 1)\n        Scaling of z-component of the translation\n\n    s_t : float, optional (default: 1)\n        Scaling of the translation\n\n    s_d : float, optional (default: 1)\n        Scaling of the whole transform (displacement)\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    Returns\n    -------\n    A2B_scaled\n        Scaled transform from frame A to frame B (actually this is a transform\n        from A to another frame C)\n    \"\"\"\n    A2B = check_transform(A2B, strict_check=strict_check)\n    A2B_scaled = np.eye(4)\n\n    R = A2B[:3, :3]\n    t = A2B[:3, 3]\n\n    S_t = np.array([s_xt, s_yt, s_zt])\n    A2B_scaled[:3, 3] = s_d * s_t * S_t * t\n\n    a = axis_angle_from_matrix(R)\n    a_new = np.empty(4)\n    a_new[3] = s_d * s_r * a[3]\n    S_r = np.array([s_xr, s_yr, s_zr])\n    a_new[:3] = norm_vector(S_r * a[:3])\n    A2B_scaled[:3, :3] = matrix_from_axis_angle(a_new)\n\n    return A2B_scaled",
  "def check_transform(A2B, strict_check=True):\n    \"\"\"Input validation of transform.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    Returns\n    -------\n    A2B : array, shape (4, 4)\n        Validated transform from frame A to frame B\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    A2B = np.asarray(A2B, dtype=np.float64)\n    if A2B.ndim != 2 or A2B.shape[0] != 4 or A2B.shape[1] != 4:\n        raise ValueError(\"Expected homogeneous transformation matrix with \"\n                         \"shape (4, 4), got array-like object with shape %s\"\n                         % (A2B.shape,))\n    check_matrix(A2B[:3, :3], strict_check=strict_check)\n    if not np.allclose(A2B[3], np.array([0.0, 0.0, 0.0, 1.0])):\n        error_msg = (\"Excpected homogeneous transformation matrix with \"\n                     \"[0, 0, 0, 1] at the bottom, got %r\" % A2B)\n        if strict_check:\n            raise ValueError(error_msg)\n        warnings.warn(error_msg)\n    return A2B",
  "def check_pq(pq):\n    \"\"\"Input validation for position and orientation quaternion.\n\n    Parameters\n    ----------\n    pq : array-like, shape (7,)\n        Position and orientation quaternion: (x, y, z, qw, qx, qy, qz)\n\n    Returns\n    -------\n    pq : array, shape (7,)\n        Validated position and orientation quaternion:\n         (x, y, z, qw, qx, qy, qz)\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    pq = np.asarray(pq, dtype=np.float64)\n    if pq.ndim != 1 or pq.shape[0] != 7:\n        raise ValueError(\"Expected position and orientation quaternion in a \"\n                         \"1D array, got array-like object with shape %s\"\n                         % (pq.shape,))\n    return pq",
  "def check_screw_parameters(q, s_axis, h):\n    r\"\"\"Input validation of screw parameters.\n\n    The parameters :math:`(\\boldsymbol{q}, \\hat{\\boldsymbol{s}}, h)`\n    describe a screw.\n\n    Parameters\n    ----------\n    q : array-like, shape (3,)\n        Vector to a point on the screw axis\n\n    s_axis : array-like, shape (3,)\n        Direction vector of the screw axis\n\n    h : float\n        Pitch of the screw. The pitch is the ratio of translation and rotation\n        of the screw axis. Infinite pitch indicates pure translation.\n\n    Returns\n    -------\n    q : array, shape (3,)\n        Vector to a point on the screw axis. Will be set to zero vector when\n        pitch is infinite (pure translation).\n\n    s_axis : array, shape (3,)\n        Unit direction vector of the screw axis\n\n    h : float\n        Pitch of the screw. The pitch is the ratio of translation and rotation\n        of the screw axis. Infinite pitch indicates pure translation.\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    s_axis = np.asarray(s_axis, dtype=np.float64)\n    if s_axis.ndim != 1 or s_axis.shape[0] != 3:\n        raise ValueError(\"Expected 3D vector with shape (3,), got array-like \"\n                         \"object with shape %s\" % (s_axis.shape,))\n    if np.linalg.norm(s_axis) == 0.0:\n        raise ValueError(\"s_axis must not have norm 0\")\n\n    q = np.asarray(q, dtype=np.float64)\n    if q.ndim != 1 or q.shape[0] != 3:\n        raise ValueError(\"Expected 3D vector with shape (3,), got array-like \"\n                         \"object with shape %s\" % (q.shape,))\n    if np.isinf(h):  # pure translation\n        q = np.zeros(3)\n\n    return q, norm_vector(s_axis), h",
  "def check_screw_axis(screw_axis):\n    r\"\"\"Input validation of screw axis.\n\n    A screw axis\n\n    .. math::\n\n        \\mathcal{S}\n        = \\left[\\begin{array}{c}\\boldsymbol{\\omega}\\\\\n          \\boldsymbol{v}\\end{array}\\right] \\in \\mathbb{R}^6\n\n    consists of a part that describes rotation and a part that describes\n    translation.\n\n    Parameters\n    ----------\n    screw_axis : array-like, shape (6,)\n        Screw axis described by 6 values\n        (omega_1, omega_2, omega_3, v_1, v_2, v_3),\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation.\n\n    Returns\n    -------\n    screw_axis : array, shape (6,)\n        Screw axis described by 6 values\n        (omega_1, omega_2, omega_3, v_1, v_2, v_3),\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation.\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    screw_axis = np.asarray(screw_axis, dtype=np.float64)\n    if screw_axis.ndim != 1 or screw_axis.shape[0] != 6:\n        raise ValueError(\"Expected 3D vector with shape (6,), got array-like \"\n                         \"object with shape %s\" % (screw_axis.shape,))\n\n    omega_norm = np.linalg.norm(screw_axis[:3])\n    if (abs(omega_norm - 1.0) > 10.0 * np.finfo(float).eps\n            and abs(omega_norm) > 10.0 * np.finfo(float).eps):\n        raise ValueError(\n            \"Norm of rotation axis must either be 0 or 1, but it is %g.\"\n            % omega_norm)\n    if abs(omega_norm) < np.finfo(float).eps:\n        v_norm = np.linalg.norm(screw_axis[3:])\n        if abs(v_norm - 1.0) > np.finfo(float).eps:\n            raise ValueError(\n                \"If the norm of the rotation axis is 0, then the direction \"\n                \"vector must have norm 1, but it is %g.\" % v_norm)\n\n    return screw_axis",
  "def check_exponential_coordinates(Stheta):\n    \"\"\"Input validation for exponential coordinates of transformation.\n\n    Exponential coordinates of a transformation :math:`\\\\mathcal{S}\\\\theta\n    \\\\in \\\\mathbb{R}^6` are the product of a screw axis and a scalar\n    :math:`\\\\theta`.\n\n    Parameters\n    ----------\n    Stheta : array-like, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation. Theta is the rotation angle\n        and h * theta the translation. Theta should be >= 0. Negative rotations\n        will be represented by a negative screw axis instead. This is relevant\n        if you want to recover theta from exponential coordinates.\n\n    Returns\n    -------\n    Stheta : array, shape (6,)\n        Exponential coordinates of transformation:\n        S * theta = (omega_1, omega_2, omega_3, v_1, v_2, v_3) * theta,\n        where the first 3 components are related to rotation and the last 3\n        components are related to translation. Theta is the rotation angle\n        and h * theta the translation. Theta should be >= 0. Negative rotations\n        will be represented by a negative screw axis instead. This is relevant\n        if you want to recover theta from exponential coordinates.\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    Stheta = np.asarray(Stheta, dtype=np.float64)\n    if Stheta.ndim != 1 or Stheta.shape[0] != 6:\n        raise ValueError(\"Expected array-like with shape (6,), got array-like \"\n                         \"object with shape %s\" % (Stheta.shape,))\n    return Stheta",
  "def check_screw_matrix(screw_matrix, tolerance=1e-6, strict_check=True):\n    \"\"\"Input validation for screw matrix.\n\n    A screw matrix consists of the cross-product matrix of a rotation\n    axis and a translation.\n\n    .. math::\n\n        \\\\left[\\\\mathcal S\\\\right]\n        =\n        \\\\left( \\\\begin{array}{cc}\n            \\\\left[\\\\boldsymbol{\\\\omega}\\\\right] & \\\\boldsymbol v\\\\\\\\\n            \\\\boldsymbol 0 & 0\\\\\\\\\n        \\\\end{array} \\\\right)\n        =\n        \\\\left(\n        \\\\begin{matrix}\n        0 & -\\\\omega_3 & \\\\omega_2 & v_1\\\\\\\\\n        \\\\omega_3 & 0 & -\\\\omega_1 & v_2\\\\\\\\\n        -\\\\omega_2 & \\\\omega_1 & 0 & v_3\\\\\\\\\n        0 & 0 & 0 & 0\\\\\\\\\n        \\\\end{matrix}\n        \\\\right)\n        \\\\in se(3) \\\\subset \\\\mathbb{R}^{4 \\\\times 4}\n\n    Parameters\n    ----------\n    screw_matrix : array-like, shape (4, 4)\n        A screw matrix consists of a cross-product matrix that represents an\n        axis of rotation, a translation, and a row of zeros.\n\n    tolerance : float, optional (default: 1e-6)\n        Tolerance threshold for checks.\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if [omega].T is not numerically close enough to\n        -[omega]. Otherwise we print a warning.\n\n    Returns\n    -------\n    screw_matrix : array, shape (4, 4)\n        A screw matrix consists of a cross-product matrix that represents an\n        axis of rotation, a translation, and a row of zeros.\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    screw_matrix = np.asarray(screw_matrix, dtype=np.float64)\n    if (screw_matrix.ndim != 2 or screw_matrix.shape[0] != 4\n            or screw_matrix.shape[1] != 4):\n        raise ValueError(\n            \"Expected array-like with shape (4, 4), got array-like \"\n            \"object with shape %s\" % (screw_matrix.shape,))\n    if any(screw_matrix[3] != 0.0):\n        raise ValueError(\"Last row of screw matrix must only contains zeros.\")\n\n    check_skew_symmetric_matrix(screw_matrix[:3, :3], tolerance, strict_check)\n\n    omega_norm = np.linalg.norm(\n        [screw_matrix[2, 1], screw_matrix[0, 2], screw_matrix[1, 0]])\n\n    if (abs(omega_norm - 1.0) > np.finfo(float).eps\n            and abs(omega_norm) > np.finfo(float).eps):\n        raise ValueError(\n            \"Norm of rotation axis must either be 0 or 1, but it is %g.\"\n            % omega_norm)\n    if abs(omega_norm) < np.finfo(float).eps:\n        v_norm = np.linalg.norm(screw_matrix[:3, 3])\n        if (abs(v_norm - 1.0) > np.finfo(float).eps\n                and abs(v_norm) > np.finfo(float).eps):\n            raise ValueError(\n                \"If the norm of the rotation axis is 0, then the direction \"\n                \"vector must have norm 1 or 0, but it is %g.\" % v_norm)\n\n    return screw_matrix",
  "def check_transform_log(transform_log, tolerance=1e-6, strict_check=True):\n    \"\"\"Input validation for logarithm of transformation.\n\n    The logarithm of a transformation :math:`\\\\left[\\\\mathcal{S}\\\\right]\\\\theta\n    \\\\in se(3) \\\\subset \\\\mathbb{R}^{4 \\\\times 4}` are the product of a screw\n    matrix and a scalar :math:`\\\\theta`.\n\n    Parameters\n    ----------\n    transform_log : array-like, shape (4, 4)\n        Matrix logarithm of transformation matrix: [S] * theta.\n\n    tolerance : float, optional (default: 1e-6)\n        Tolerance threshold for checks.\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if [omega].T is not numerically close enough to\n        -[omega]. Otherwise we print a warning.\n\n    Returns\n    -------\n    transform_log : array, shape (4, 4)\n        Matrix logarithm of transformation matrix: [S] * theta.\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    transform_log = np.asarray(transform_log, dtype=np.float64)\n    if (transform_log.ndim != 2 or transform_log.shape[0] != 4\n            or transform_log.shape[1] != 4):\n        raise ValueError(\n            \"Expected array-like with shape (4, 4), got array-like \"\n            \"object with shape %s\" % (transform_log.shape,))\n    if any(transform_log[3] != 0.0):\n        raise ValueError(\n            \"Last row of logarithm of transformation must only \"\n            \"contains zeros.\")\n\n    check_skew_symmetric_matrix(transform_log[:3, :3], tolerance, strict_check)\n\n    return transform_log",
  "def check_dual_quaternion(dq, unit=True):\n    \"\"\"Input validation of dual quaternion representation.\n\n    See http://web.cs.iastate.edu/~cs577/handouts/dual-quaternion.pdf\n\n    A dual quaternion is defined as\n\n    .. math::\n\n        \\\\boldsymbol{\\\\sigma} = \\\\boldsymbol{p} + \\\\epsilon \\\\boldsymbol{q},\n\n    where :math:`\\\\boldsymbol{p}` and :math:`\\\\boldsymbol{q}` are both\n    quaternions and :math:`\\\\epsilon` is the dual unit with\n    :math:`\\\\epsilon^2 = 0`. The first quaternion is also called the real part\n    and the second quaternion is called the dual part.\n\n    Parameters\n    ----------\n    dq : array-like, shape (8,)\n        Dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    unit : bool, optional (default: True)\n        Normalize the dual quaternion so that it is a unit dual quaternion.\n        A unit dual quaternion has the properties\n        :math:`p_w^2 + p_x^2 + p_y^2 + p_z^2 = 1` and\n        :math:`p_w q_w + p_x q_x + p_y q_y + p_z q_z = 0`.\n\n    Returns\n    -------\n    dq : array, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    dq = np.asarray(dq, dtype=np.float64)\n    if dq.ndim != 1 or dq.shape[0] != 8:\n        raise ValueError(\"Expected dual quaternion with shape (8,), got \"\n                         \"array-like object with shape %s\" % (dq.shape,))\n    if unit:\n        # Norm of a dual quaternion only depends on the real part because\n        # the dual part vanishes with epsilon ** 2 = 0.\n        real_norm = np.linalg.norm(dq[:4])\n        if real_norm == 0.0:\n            return np.r_[1, 0, 0, 0, dq[4:]]\n        return dq / real_norm\n    return dq",
  "def assert_transform(A2B, *args, **kwargs):\n    \"\"\"Raise an assertion if the transform is not a homogeneous matrix.\n\n    See numpy.testing.assert_array_almost_equal for a more detailed\n    documentation of the other parameters.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    args : tuple\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n\n    kwargs : dict\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n    \"\"\"\n    assert_rotation_matrix(A2B[:3, :3], *args, **kwargs)\n    assert_array_almost_equal(A2B[3], np.array([0.0, 0.0, 0.0, 1.0]),\n                              *args, **kwargs)",
  "def assert_unit_dual_quaternion(dq, *args, **kwargs):\n    \"\"\"Raise an assertion if the dual quaternion does not have unit norm.\n\n    See numpy.testing.assert_array_almost_equal for a more detailed\n    documentation of the other parameters.\n\n    Parameters\n    ----------\n    dq : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    args : tuple\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n\n    kwargs : dict\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n    \"\"\"\n    real = dq[:4]\n    dual = dq[4:]\n\n    real_norm = np.linalg.norm(real)\n    assert_array_almost_equal(real_norm, 1.0, *args, **kwargs)\n\n    real_dual_dot = np.dot(real, dual)\n    assert_array_almost_equal(real_dual_dot, 0.0, *args, **kwargs)\n\n    # The two previous checks are consequences of the unit norm requirement.\n    # The norm of a dual quaternion is defined as the product of a dual\n    # quaternion and its quaternion conjugate.\n    dq_conj = dq_q_conj(dq)\n    dq_prod_dq_conj = concatenate_dual_quaternions(dq, dq_conj)\n    assert_array_almost_equal(dq_prod_dq_conj, [1, 0, 0, 0, 0, 0, 0, 0],\n                              *args, **kwargs)",
  "def assert_unit_dual_quaternion_equal(dq1, dq2, *args, **kwargs):\n    \"\"\"Raise an assertion if unit dual quaternions are not approximately equal.\n\n    Note that unit dual quaternions are equal either if dq1 == dq2 or if\n    dq1 == -dq2. See numpy.testing.assert_array_almost_equal for a more\n    detailed documentation of the other parameters.\n\n    Parameters\n    ----------\n    dq1 : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    dq2 : array-like, shape (8,)\n        Unit dual quaternion to represent transform:\n        (pw, px, py, pz, qw, qx, qy, qz)\n\n    args : tuple\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n\n    kwargs : dict\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n    \"\"\"\n    try:\n        assert_array_almost_equal(dq1, dq2, *args, **kwargs)\n    except AssertionError:\n        assert_array_almost_equal(dq1, -dq2, *args, **kwargs)",
  "def assert_screw_parameters_equal(\n        q1, s_axis1, h1, theta1, q2, s_axis2, h2, theta2, *args, **kwargs):\n    \"\"\"Raise an assertion if two sets of screw parameters are not similar.\n\n    Note that the screw axis can be inverted. In this case theta and h have\n    to be adapted.\n\n    Parameters\n    ----------\n    q1 : array, shape (3,)\n        Vector to a point on the screw axis that is orthogonal to s_axis\n\n    s_axis1 : array, shape (3,)\n        Unit direction vector of the screw axis\n\n    h1 : float\n        Pitch of the screw. The pitch is the ratio of translation and rotation\n        of the screw axis. Infinite pitch indicates pure translation.\n\n    theta1 : float\n        Parameter of the transformation: theta is the angle of rotation\n        and h * theta the translation.\n\n    q2 : array, shape (3,)\n        Vector to a point on the screw axis that is orthogonal to s_axis\n\n    s_axis2 : array, shape (3,)\n        Unit direction vector of the screw axis\n\n    h2 : float\n        Pitch of the screw. The pitch is the ratio of translation and rotation\n        of the screw axis. Infinite pitch indicates pure translation.\n\n    theta2 : float\n        Parameter of the transformation: theta is the angle of rotation\n        and h * theta the translation.\n\n    args : tuple\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n\n    kwargs : dict\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n    \"\"\"\n    # normalize thetas\n    theta1_new = norm_angle(theta1)\n    h1 *= theta1 / theta1_new\n    theta1 = theta1_new\n\n    theta2_new = norm_angle(theta2)\n    h2 *= theta2 / theta2_new\n    theta2 = theta2_new\n\n    # q1 and q2 can be any points on the screw axis, that is, they must be a\n    # linear combination of each other and the screw axis (which one does not\n    # matter since they should be identical or mirrored)\n    q1_to_q2 = q2 - q1\n    factors = q1_to_q2 / s_axis2\n    assert abs(factors[0] - factors[1]) < eps\n    assert abs(factors[1] - factors[2]) < eps\n    try:\n        assert_array_almost_equal(s_axis1, s_axis2, *args, **kwargs)\n        assert abs(h1 - h2) < eps\n        assert abs(theta1 - theta2) < eps\n    except AssertionError:  # possibly mirrored screw axis\n        s_axis1_new = -s_axis1\n        # make sure that we keep the direction of rotation\n        theta1_new = 2.0 * np.pi - theta1\n        # adjust pitch: switch sign and update rotation component\n        h1 = -h1 / theta1_new * theta1\n        theta1 = theta1_new\n\n        # we have to normalize the angle again\n        theta1_new = norm_angle(theta1)\n        h1 *= theta1 / theta1_new\n        theta1 = theta1_new\n\n        assert_array_almost_equal(s_axis1_new, s_axis2, *args, **kwargs)\n        assert abs(h1 - h2) < eps\n        assert abs(theta1 - theta2) < eps",
  "class Frame(artist.Artist):\n    \"\"\"A Matplotlib artist that displays a frame represented by its basis.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    label : str, optional (default: None)\n        Name of the frame\n\n    s : float, optional (default: 1)\n        Length of basis vectors\n\n    draw_label_indicator : bool, optional (default: True)\n        Controls whether the line from the frame origin to frame label is\n        drawn.\n\n    Other arguments except 'c' and 'color' are passed on to Line3D.\n    \"\"\"\n    def __init__(self, A2B, label=None, s=1.0, **kwargs):\n        super(Frame, self).__init__()\n\n        if \"c\" in kwargs:\n            kwargs.pop(\"c\")\n        if \"color\" in kwargs:\n            kwargs.pop(\"color\")\n\n        self.draw_label_indicator = kwargs.pop(\"draw_label_indicator\", True)\n\n        self.s = s\n\n        self.x_axis = Line3D([], [], [], color=\"r\", **kwargs)\n        self.y_axis = Line3D([], [], [], color=\"g\", **kwargs)\n        self.z_axis = Line3D([], [], [], color=\"b\", **kwargs)\n\n        self.draw_label = label is not None\n        self.label = label\n\n        if self.draw_label:\n            if self.draw_label_indicator:\n                self.label_indicator = Line3D([], [], [], color=\"k\", **kwargs)\n            self.label_text = Text3D(0, 0, 0, text=\"\", zdir=\"x\")\n\n        self.set_data(A2B, label)\n\n    def set_data(self, A2B, label=None):\n        \"\"\"Set the transformation data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        label : str, optional (default: None)\n            Name of the frame\n        \"\"\"\n        R = A2B[:3, :3]\n        p = A2B[:3, 3]\n\n        for d, b in enumerate([self.x_axis, self.y_axis, self.z_axis]):\n            b.set_data(np.array([p[0], p[0] + self.s * R[0, d]]),\n                       np.array([p[1], p[1] + self.s * R[1, d]]))\n            b.set_3d_properties(np.array([p[2], p[2] + self.s * R[2, d]]))\n\n        if self.draw_label:\n            if label is None:\n                label = self.label\n            label_pos = p + 0.5 * self.s * (R[:, 0] + R[:, 1] + R[:, 2])\n\n            if self.draw_label_indicator:\n                self.label_indicator.set_data(\n                    np.array([p[0], label_pos[0]]),\n                    np.array([p[1], label_pos[1]]))\n                self.label_indicator.set_3d_properties(\n                    np.array([p[2], label_pos[2]]))\n\n            self.label_text.set_text(label)\n            self.label_text.set_position([label_pos[0], label_pos[1]])\n            self.label_text.set_3d_properties(label_pos[2], zdir=\"x\")\n\n    @artist.allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        \"\"\"Draw the artist.\"\"\"\n        for b in [self.x_axis, self.y_axis, self.z_axis]:\n            b.draw(renderer, *args, **kwargs)\n        if self.draw_label:\n            if self.draw_label_indicator:\n                self.label_indicator.draw(renderer, *args, **kwargs)\n            self.label_text.draw(renderer, *args, **kwargs)\n        super(Frame, self).draw(renderer, *args, **kwargs)\n\n    def add_frame(self, axis):\n        \"\"\"Add the frame to a 3D axis.\"\"\"\n        for b in [self.x_axis, self.y_axis, self.z_axis]:\n            axis.add_line(b)\n        if self.draw_label:\n            if self.draw_label_indicator:\n                axis.add_line(self.label_indicator)\n            axis._add_text(self.label_text)",
  "class LabeledFrame(Frame):\n    \"\"\"Displays a frame represented by its basis with axis labels.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    label : str, optional (default: None)\n        Name of the frame\n\n    s : float, optional (default: 1)\n        Length of basis vectors\n\n    draw_label_indicator : bool, optional (default: True)\n        Controls whether the line from the frame origin to frame label is\n        drawn.\n\n    Other arguments except 'c' and 'color' are passed on to Line3D.\n    \"\"\"\n    def __init__(self, A2B, label=None, s=1.0, **kwargs):\n        self.x_label = Text3D(0, 0, 0, text=\"\", zdir=\"x\")\n        self.y_label = Text3D(0, 0, 0, text=\"\", zdir=\"x\")\n        self.z_label = Text3D(0, 0, 0, text=\"\", zdir=\"x\")\n        super(LabeledFrame, self).__init__(\n            A2B, label=label, s=s, **kwargs)\n\n    def set_data(self, A2B, label=None):\n        \"\"\"Set the transformation data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        label : str, optional (default: None)\n            Name of the frame\n        \"\"\"\n        super(LabeledFrame, self).set_data(A2B, label)\n\n        R = A2B[:3, :3]\n        p = A2B[:3, 3]\n        x_label_location = p + 1.1 * self.s * R[:, 0]\n        y_label_location = p + 1.1 * self.s * R[:, 1]\n        z_label_location = p + 1.1 * self.s * R[:, 2]\n\n        self.x_label.set_text(\"x\")\n        self.x_label.set_position(x_label_location[:2])\n        self.x_label.set_3d_properties(x_label_location[2], zdir=\"x\")\n\n        self.y_label.set_text(\"y\")\n        self.y_label.set_position(y_label_location[:2])\n        self.y_label.set_3d_properties(y_label_location[2], zdir=\"x\")\n\n        self.z_label.set_text(\"z\")\n        self.z_label.set_position(z_label_location[:2])\n        self.z_label.set_3d_properties(z_label_location[2], zdir=\"x\")\n\n    @artist.allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        \"\"\"Draw the artist.\"\"\"\n        self.x_label.draw(renderer, *args, **kwargs)\n        self.y_label.draw(renderer, *args, **kwargs)\n        self.z_label.draw(renderer, *args, **kwargs)\n        super(LabeledFrame, self).draw(renderer, *args, **kwargs)\n\n    def add_frame(self, axis):\n        \"\"\"Add the frame to a 3D axis.\"\"\"\n        super(LabeledFrame, self).add_frame(axis)\n        axis._add_text(self.x_label)\n        axis._add_text(self.y_label)\n        axis._add_text(self.z_label)",
  "class Trajectory(artist.Artist):\n    \"\"\"A Matplotlib artist that displays a trajectory.\n\n    Parameters\n    ----------\n    H : array-like, shape (n_steps, 4, 4)\n        Sequence of poses represented by homogeneous matrices\n\n    show_direction : bool, optional (default: True)\n        Plot an arrow to indicate the direction of the trajectory\n\n    n_frames : int, optional (default: 10)\n        Number of frames that should be plotted to indicate the rotation\n\n    s : float, optional (default: 1)\n        Scaling of the frames that will be drawn\n\n    Other arguments are passed onto Line3D.\n    \"\"\"\n    def __init__(self, H, show_direction=True, n_frames=10, s=1.0, **kwargs):\n        super(Trajectory, self).__init__()\n\n        self.show_direction = show_direction\n\n        self.trajectory = Line3D([], [], [], **kwargs)\n        self.key_frames = [Frame(np.eye(4), s=s, **kwargs)\n                           for _ in range(n_frames)]\n\n        if self.show_direction:\n            self.direction_arrow = Arrow3D(\n                [0, 0], [0, 0], [0, 0],\n                mutation_scale=20, lw=1, arrowstyle=\"-|>\", color=\"k\")\n\n        self.set_data(H)\n\n    def set_data(self, H):\n        \"\"\"Set the trajectory data.\n\n        Parameters\n        ----------\n        H : array-like, shape (n_steps, 4, 4)\n            Sequence of poses represented by homogeneous matrices\n        \"\"\"\n        positions = H[:, :3, 3]\n        self.trajectory.set_data(positions[:, 0], positions[:, 1])\n        self.trajectory.set_3d_properties(positions[:, 2])\n\n        key_frames_indices = np.linspace(\n            0, len(H) - 1, len(self.key_frames), dtype=np.int64)\n        for i, key_frame_idx in enumerate(key_frames_indices):\n            self.key_frames[i].set_data(H[key_frame_idx])\n\n        if self.show_direction:\n            start = 0.8 * positions[0] + 0.2 * positions[-1]\n            end = 0.2 * positions[0] + 0.8 * positions[-1]\n            self.direction_arrow.set_data(\n                [start[0], end[0]], [start[1], end[1]], [start[2], end[2]])\n\n    @artist.allow_rasterization\n    def draw(self, renderer, *args, **kwargs):\n        \"\"\"Draw the artist.\"\"\"\n        self.trajectory.draw(renderer, *args, **kwargs)\n        for key_frame in self.key_frames:\n            key_frame.draw(renderer, *args, **kwargs)\n        if self.show_direction:\n            self.direction_arrow.draw(renderer)\n        super(Trajectory, self).draw(renderer, *args, **kwargs)\n\n    def add_trajectory(self, axis):\n        \"\"\"Add the trajectory to a 3D axis.\"\"\"\n        axis.add_line(self.trajectory)\n        for key_frame in self.key_frames:\n            key_frame.add_frame(axis)\n        if self.show_direction:\n            axis.add_artist(self.direction_arrow)",
  "class Arrow3D(FancyArrowPatch):\n    \"\"\"A Matplotlib patch that represents an arrow in 3D.\n\n    Source: http://stackoverflow.com/a/11156353/915743\n    \"\"\"\n    def __init__(self, xs, ys, zs, *args, **kwargs):\n        super(Arrow3D, self).__init__((0, 0), (0, 0), *args, **kwargs)\n        self._verts3d = xs, ys, zs\n\n    def set_data(self, xs, ys, zs):\n        \"\"\"Set the arrow data.\n\n        Parameters\n        ----------\n        xs : iterable\n            List of x positions\n\n        ys : iterable\n            List of y positions\n\n        zs : iterable\n            List of z positions\n        \"\"\"\n        self._verts3d = xs, ys, zs\n\n    def draw(self, renderer):\n        \"\"\"Draw the patch.\"\"\"\n        xs3d, ys3d, zs3d = self._verts3d\n        try:\n            M = self.axes.M\n        except AttributeError:\n            # deprecated since matplotlib 3.4, will be removed in 3.6\n            M = renderer.M\n        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, M)\n        self.set_positions((xs[0], ys[0]), (xs[1], ys[1]))\n        super(Arrow3D, self).draw(renderer)\n\n    def do_3d_projection(self, renderer=None):\n        # This supports both matplotlib 3.4 and 3.5\n        return 0",
  "def __init__(self, A2B, label=None, s=1.0, **kwargs):\n        super(Frame, self).__init__()\n\n        if \"c\" in kwargs:\n            kwargs.pop(\"c\")\n        if \"color\" in kwargs:\n            kwargs.pop(\"color\")\n\n        self.draw_label_indicator = kwargs.pop(\"draw_label_indicator\", True)\n\n        self.s = s\n\n        self.x_axis = Line3D([], [], [], color=\"r\", **kwargs)\n        self.y_axis = Line3D([], [], [], color=\"g\", **kwargs)\n        self.z_axis = Line3D([], [], [], color=\"b\", **kwargs)\n\n        self.draw_label = label is not None\n        self.label = label\n\n        if self.draw_label:\n            if self.draw_label_indicator:\n                self.label_indicator = Line3D([], [], [], color=\"k\", **kwargs)\n            self.label_text = Text3D(0, 0, 0, text=\"\", zdir=\"x\")\n\n        self.set_data(A2B, label)",
  "def set_data(self, A2B, label=None):\n        \"\"\"Set the transformation data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        label : str, optional (default: None)\n            Name of the frame\n        \"\"\"\n        R = A2B[:3, :3]\n        p = A2B[:3, 3]\n\n        for d, b in enumerate([self.x_axis, self.y_axis, self.z_axis]):\n            b.set_data(np.array([p[0], p[0] + self.s * R[0, d]]),\n                       np.array([p[1], p[1] + self.s * R[1, d]]))\n            b.set_3d_properties(np.array([p[2], p[2] + self.s * R[2, d]]))\n\n        if self.draw_label:\n            if label is None:\n                label = self.label\n            label_pos = p + 0.5 * self.s * (R[:, 0] + R[:, 1] + R[:, 2])\n\n            if self.draw_label_indicator:\n                self.label_indicator.set_data(\n                    np.array([p[0], label_pos[0]]),\n                    np.array([p[1], label_pos[1]]))\n                self.label_indicator.set_3d_properties(\n                    np.array([p[2], label_pos[2]]))\n\n            self.label_text.set_text(label)\n            self.label_text.set_position([label_pos[0], label_pos[1]])\n            self.label_text.set_3d_properties(label_pos[2], zdir=\"x\")",
  "def draw(self, renderer, *args, **kwargs):\n        \"\"\"Draw the artist.\"\"\"\n        for b in [self.x_axis, self.y_axis, self.z_axis]:\n            b.draw(renderer, *args, **kwargs)\n        if self.draw_label:\n            if self.draw_label_indicator:\n                self.label_indicator.draw(renderer, *args, **kwargs)\n            self.label_text.draw(renderer, *args, **kwargs)\n        super(Frame, self).draw(renderer, *args, **kwargs)",
  "def add_frame(self, axis):\n        \"\"\"Add the frame to a 3D axis.\"\"\"\n        for b in [self.x_axis, self.y_axis, self.z_axis]:\n            axis.add_line(b)\n        if self.draw_label:\n            if self.draw_label_indicator:\n                axis.add_line(self.label_indicator)\n            axis._add_text(self.label_text)",
  "def __init__(self, A2B, label=None, s=1.0, **kwargs):\n        self.x_label = Text3D(0, 0, 0, text=\"\", zdir=\"x\")\n        self.y_label = Text3D(0, 0, 0, text=\"\", zdir=\"x\")\n        self.z_label = Text3D(0, 0, 0, text=\"\", zdir=\"x\")\n        super(LabeledFrame, self).__init__(\n            A2B, label=label, s=s, **kwargs)",
  "def set_data(self, A2B, label=None):\n        \"\"\"Set the transformation data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        label : str, optional (default: None)\n            Name of the frame\n        \"\"\"\n        super(LabeledFrame, self).set_data(A2B, label)\n\n        R = A2B[:3, :3]\n        p = A2B[:3, 3]\n        x_label_location = p + 1.1 * self.s * R[:, 0]\n        y_label_location = p + 1.1 * self.s * R[:, 1]\n        z_label_location = p + 1.1 * self.s * R[:, 2]\n\n        self.x_label.set_text(\"x\")\n        self.x_label.set_position(x_label_location[:2])\n        self.x_label.set_3d_properties(x_label_location[2], zdir=\"x\")\n\n        self.y_label.set_text(\"y\")\n        self.y_label.set_position(y_label_location[:2])\n        self.y_label.set_3d_properties(y_label_location[2], zdir=\"x\")\n\n        self.z_label.set_text(\"z\")\n        self.z_label.set_position(z_label_location[:2])\n        self.z_label.set_3d_properties(z_label_location[2], zdir=\"x\")",
  "def draw(self, renderer, *args, **kwargs):\n        \"\"\"Draw the artist.\"\"\"\n        self.x_label.draw(renderer, *args, **kwargs)\n        self.y_label.draw(renderer, *args, **kwargs)\n        self.z_label.draw(renderer, *args, **kwargs)\n        super(LabeledFrame, self).draw(renderer, *args, **kwargs)",
  "def add_frame(self, axis):\n        \"\"\"Add the frame to a 3D axis.\"\"\"\n        super(LabeledFrame, self).add_frame(axis)\n        axis._add_text(self.x_label)\n        axis._add_text(self.y_label)\n        axis._add_text(self.z_label)",
  "def __init__(self, H, show_direction=True, n_frames=10, s=1.0, **kwargs):\n        super(Trajectory, self).__init__()\n\n        self.show_direction = show_direction\n\n        self.trajectory = Line3D([], [], [], **kwargs)\n        self.key_frames = [Frame(np.eye(4), s=s, **kwargs)\n                           for _ in range(n_frames)]\n\n        if self.show_direction:\n            self.direction_arrow = Arrow3D(\n                [0, 0], [0, 0], [0, 0],\n                mutation_scale=20, lw=1, arrowstyle=\"-|>\", color=\"k\")\n\n        self.set_data(H)",
  "def set_data(self, H):\n        \"\"\"Set the trajectory data.\n\n        Parameters\n        ----------\n        H : array-like, shape (n_steps, 4, 4)\n            Sequence of poses represented by homogeneous matrices\n        \"\"\"\n        positions = H[:, :3, 3]\n        self.trajectory.set_data(positions[:, 0], positions[:, 1])\n        self.trajectory.set_3d_properties(positions[:, 2])\n\n        key_frames_indices = np.linspace(\n            0, len(H) - 1, len(self.key_frames), dtype=np.int64)\n        for i, key_frame_idx in enumerate(key_frames_indices):\n            self.key_frames[i].set_data(H[key_frame_idx])\n\n        if self.show_direction:\n            start = 0.8 * positions[0] + 0.2 * positions[-1]\n            end = 0.2 * positions[0] + 0.8 * positions[-1]\n            self.direction_arrow.set_data(\n                [start[0], end[0]], [start[1], end[1]], [start[2], end[2]])",
  "def draw(self, renderer, *args, **kwargs):\n        \"\"\"Draw the artist.\"\"\"\n        self.trajectory.draw(renderer, *args, **kwargs)\n        for key_frame in self.key_frames:\n            key_frame.draw(renderer, *args, **kwargs)\n        if self.show_direction:\n            self.direction_arrow.draw(renderer)\n        super(Trajectory, self).draw(renderer, *args, **kwargs)",
  "def add_trajectory(self, axis):\n        \"\"\"Add the trajectory to a 3D axis.\"\"\"\n        axis.add_line(self.trajectory)\n        for key_frame in self.key_frames:\n            key_frame.add_frame(axis)\n        if self.show_direction:\n            axis.add_artist(self.direction_arrow)",
  "def __init__(self, xs, ys, zs, *args, **kwargs):\n        super(Arrow3D, self).__init__((0, 0), (0, 0), *args, **kwargs)\n        self._verts3d = xs, ys, zs",
  "def set_data(self, xs, ys, zs):\n        \"\"\"Set the arrow data.\n\n        Parameters\n        ----------\n        xs : iterable\n            List of x positions\n\n        ys : iterable\n            List of y positions\n\n        zs : iterable\n            List of z positions\n        \"\"\"\n        self._verts3d = xs, ys, zs",
  "def draw(self, renderer):\n        \"\"\"Draw the patch.\"\"\"\n        xs3d, ys3d, zs3d = self._verts3d\n        try:\n            M = self.axes.M\n        except AttributeError:\n            # deprecated since matplotlib 3.4, will be removed in 3.6\n            M = renderer.M\n        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, M)\n        self.set_positions((xs[0], ys[0]), (xs[1], ys[1]))\n        super(Arrow3D, self).draw(renderer)",
  "def do_3d_projection(self, renderer=None):\n        # This supports both matplotlib 3.4 and 3.5\n        return 0",
  "def make_3d_axis(ax_s, pos=111, unit=None, n_ticks=5):\n    \"\"\"Generate new 3D axis.\n\n    Parameters\n    ----------\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    pos : int, optional (default: 111)\n        Position indicator (nrows, ncols, plot_number)\n\n    unit : str, optional (default: None)\n        Unit of axes. For example, 'm', 'cm', 'km', ...\n        The unit will be shown in the axis label, for example,\n        as 'X [m]'.\n\n    n_ticks : int, optional (default: 5)\n        Number of ticks on each axis\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New axis\n    \"\"\"\n    try:\n        ax = plt.subplot(pos, projection=\"3d\", aspect=\"equal\")\n    except NotImplementedError:\n        # HACK: workaround for bug in new matplotlib versions (ca. 3.02):\n        # \"It is not currently possible to manually set the aspect\"\n        ax = plt.subplot(pos, projection=\"3d\")\n\n    if unit is None:\n        xlabel = \"X\"\n        ylabel = \"Y\"\n        zlabel = \"Z\"\n    else:\n        xlabel = \"X [%s]\" % unit\n        ylabel = \"Y [%s]\" % unit\n        zlabel = \"Z [%s]\" % unit\n\n    plt.setp(\n        ax, xlim=(-ax_s, ax_s), ylim=(-ax_s, ax_s), zlim=(-ax_s, ax_s),\n        xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)\n\n    ax.xaxis.set_major_locator(MaxNLocator(n_ticks))\n    ax.yaxis.set_major_locator(MaxNLocator(n_ticks))\n    ax.zaxis.set_major_locator(MaxNLocator(n_ticks))\n\n    try:\n        ax.xaxis.pane.set_color(\"white\")\n        ax.yaxis.pane.set_color(\"white\")\n        ax.zaxis.pane.set_color(\"white\")\n    except AttributeError:  # pragma: no cover\n        # fallback for older versions of matplotlib, deprecated since v3.1\n        ax.w_xaxis.pane.set_color(\"white\")\n        ax.w_yaxis.pane.set_color(\"white\")\n        ax.w_zaxis.pane.set_color(\"white\")\n\n    return ax",
  "def remove_frame(ax, left=0.0, bottom=0.0, right=1.0, top=1.0):\n    \"\"\"Remove axis and scale bbox.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis\n        Axis from which we remove the frame\n\n    left : float, optional (default: 0)\n        Position of left border (between 0 and 1)\n\n    bottom : float, optional (default: 0)\n        Position of bottom border (between 0 and 1)\n\n    right : float, optional (default: 1)\n        Position of right border (between 0 and 1)\n\n    top : float, optional (default: 1)\n        Position of top border (between 0 and 1)\n    \"\"\"\n    ax.axis(\"off\")\n    plt.subplots_adjust(left=left, bottom=bottom, right=right, top=top)",
  "def plot_box(ax=None, size=np.ones(3), A2B=np.eye(4), ax_s=1, wireframe=True,\n             color=\"k\", alpha=1.0):\n    \"\"\"Plot box.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    size : array-like, shape (3,), optional (default: [1, 1, 1])\n        Size of the box per dimension\n\n    A2B : array-like, shape (4, 4)\n        Center of the box\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    wireframe : bool, optional (default: True)\n        Plot wireframe of box and surface otherwise\n\n    color : str, optional (default: black)\n        Color in which the box should be plotted\n\n    alpha : float, optional (default: 1)\n        Alpha value of the mesh that will be plotted\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    corners = np.array([\n        [0, 0, 0],\n        [0, 0, 1],\n        [0, 1, 0],\n        [0, 1, 1],\n        [1, 0, 0],\n        [1, 0, 1],\n        [1, 1, 0],\n        [1, 1, 1]\n    ])\n    corners = (corners - 0.5) * size\n    corners = transform(\n        A2B, np.hstack((corners, np.ones((len(corners), 1)))))[:, :3]\n\n    if wireframe:\n        for i, j in [(0, 1), (0, 2), (1, 3), (2, 3),\n                     (4, 5), (4, 6), (5, 7), (6, 7),\n                     (0, 4), (1, 5), (2, 6), (3, 7)]:\n            ax.plot([corners[i, 0], corners[j, 0]],\n                    [corners[i, 1], corners[j, 1]],\n                    [corners[i, 2], corners[j, 2]],\n                    c=color, alpha=alpha)\n    else:\n        p3c = Poly3DCollection(np.array([\n            [corners[0], corners[1], corners[2]],\n            [corners[1], corners[2], corners[3]],\n\n            [corners[4], corners[5], corners[6]],\n            [corners[5], corners[6], corners[7]],\n\n            [corners[0], corners[1], corners[4]],\n            [corners[1], corners[4], corners[5]],\n\n            [corners[2], corners[6], corners[7]],\n            [corners[2], corners[3], corners[7]],\n\n            [corners[0], corners[4], corners[6]],\n            [corners[0], corners[2], corners[6]],\n\n            [corners[1], corners[5], corners[7]],\n            [corners[1], corners[3], corners[7]],\n        ]))\n        p3c.set_alpha(alpha)\n        p3c.set_facecolor(color)\n        ax.add_collection3d(p3c)\n\n    return ax",
  "def plot_sphere(ax=None, radius=1.0, p=np.zeros(3), ax_s=1, wireframe=True,\n                n_steps=20, alpha=1.0, color=\"k\"):\n    \"\"\"Plot sphere.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    radius : float, optional (default: 1)\n        Radius of the sphere\n\n    p : array-like, shape (3,), optional (default: [0, 0, 0])\n        Center of the sphere\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    wireframe : bool, optional (default: True)\n        Plot wireframe of sphere and surface otherwise\n\n    n_steps : int, optional (default: 20)\n        Number of discrete steps plotted in each dimension\n\n    alpha : float, optional (default: 1)\n        Alpha value of the sphere that will be plotted\n\n    color : str, optional (default: black)\n        Color in which the sphere should be plotted\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    x, y, z = unit_sphere_surface_grid(n_steps)\n    x = p[0] + radius * x\n    y = p[1] + radius * y\n    z = p[2] + radius * z\n\n    if wireframe:\n        ax.plot_wireframe(\n            x, y, z, rstride=2, cstride=2, color=color, alpha=alpha)\n    else:\n        ax.plot_surface(x, y, z, color=color, alpha=alpha, linewidth=0)\n\n    return ax",
  "def plot_spheres(ax=None, radius=np.ones(1), p=np.zeros((1, 3)), ax_s=1,\n                 wireframe=True, n_steps=20, alpha=np.ones(1),\n                 color=np.zeros((1, 3))):\n    \"\"\"Plot multiple spheres.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    radius : array-like, shape (n_spheres,), optional (default: 1)\n        Radius of the sphere(s)\n\n    p : array-like, shape (n_spheres, 3), optional (default: [0, 0, 0])\n        Center of the sphere(s)\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    wireframe : bool, optional (default: True)\n        Plot wireframe of sphere(s) and surface otherwise\n\n    n_steps : int, optional (default: 20)\n        Number of discrete steps plotted in each dimension\n\n    alpha : array-like, shape (n_spheres,), optional (default: 1)\n        Alpha value of the sphere(s) that will be plotted\n\n    color : array-like, shape (n_spheres, 3), optional (default: black)\n        Color in which the sphere(s) should be plotted\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    radius = np.asarray(radius)\n    p = np.asarray(p)\n\n    phi, theta = np.mgrid[0.0:np.pi:n_steps * 1j, 0.0:2.0 * np.pi:n_steps * 1j]\n    sin_phi = np.sin(phi)\n    verts = (radius[..., np.newaxis, np.newaxis, np.newaxis]\n             * np.array([sin_phi * np.cos(theta), sin_phi * np.sin(theta),\n                         np.cos(phi)])[np.newaxis, ...]\n             + p[..., np.newaxis, np.newaxis])\n    colors = np.resize(color, (len(verts), 3))\n    alphas = np.resize(alpha, len(verts))\n\n    for verts_i, color_i, alpha_i in zip(verts, colors, alphas):\n        if wireframe:\n            ax.plot_wireframe(\n                *verts_i, rstride=2, cstride=2, color=color_i, alpha=alpha_i)\n        else:\n            ax.plot_surface(*verts_i, color=color_i, alpha=alpha_i,\n                            linewidth=0)\n\n    return ax",
  "def plot_cylinder(ax=None, length=1.0, radius=1.0, thickness=0.0,\n                  A2B=np.eye(4), ax_s=1, wireframe=True, n_steps=100,\n                  alpha=1.0, color=\"k\"):\n    \"\"\"Plot cylinder.\n\n    A cylinder is the volume covered by a disk moving along a line segment.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    length : float, optional (default: 1)\n        Length of the cylinder\n\n    radius : float, optional (default: 1)\n        Radius of the cylinder\n\n    thickness : float, optional (default: 0)\n        Thickness of a cylindrical shell. It will be subtracted from the\n        outer radius to obtain the inner radius. The difference must be\n        greater than 0.\n\n    A2B : array-like, shape (4, 4)\n        Center of the cylinder\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    wireframe : bool, optional (default: True)\n        Plot wireframe of cylinder and surface otherwise\n\n    n_steps : int, optional (default: 100)\n        Number of discrete steps plotted in each dimension\n\n    alpha : float, optional (default: 1)\n        Alpha value of the cylinder that will be plotted\n\n    color : str, optional (default: black)\n        Color in which the cylinder should be plotted\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n\n    Raises\n    ------\n    ValueError\n        If thickness is <= 0\n    \"\"\"\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    inner_radius = radius - thickness\n    if inner_radius <= 0.0:\n        raise ValueError(\"Thickness of cylindrical shell results in \"\n                         \"invalid inner radius: %g\" % inner_radius)\n\n    axis_start = A2B.dot(np.array([0, 0, -0.5 * length, 1]))[:3]\n    axis_end = A2B.dot(np.array([0, 0, 0.5 * length, 1]))[:3]\n    axis = axis_end - axis_start\n    axis /= length\n\n    not_axis = np.array([1, 0, 0])\n    if np.allclose(axis, not_axis) or np.allclose(-axis, not_axis):\n        not_axis = np.array([0, 1, 0])\n\n    n1 = np.cross(axis, not_axis)\n    n1 /= np.linalg.norm(n1)\n    n2 = np.cross(axis, n1)\n\n    if wireframe:\n        t = np.linspace(0, length, n_steps)\n    else:\n        t = np.array([0, length])\n    theta = np.linspace(0, 2 * np.pi, n_steps)\n    t, theta = np.meshgrid(t, theta)\n\n    if thickness > 0.0:\n        X_outer, Y_outer, Z_outer = [\n            axis_start[i] + axis[i] * t\n            + radius * np.sin(theta) * n1[i]\n            + radius * np.cos(theta) * n2[i] for i in [0, 1, 2]]\n        X_inner, Y_inner, Z_inner = [\n            axis_end[i] - axis[i] * t\n            + inner_radius * np.sin(theta) * n1[i]\n            + inner_radius * np.cos(theta) * n2[i] for i in [0, 1, 2]]\n        X = np.hstack((X_outer, X_inner))\n        Y = np.hstack((Y_outer, Y_inner))\n        Z = np.hstack((Z_outer, Z_inner))\n    else:\n        X, Y, Z = [axis_start[i] + axis[i] * t\n                   + radius * np.sin(theta) * n1[i]\n                   + radius * np.cos(theta) * n2[i] for i in [0, 1, 2]]\n\n    if wireframe:\n        ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10, alpha=alpha,\n                          color=color)\n    else:\n        ax.plot_surface(X, Y, Z, color=color, alpha=alpha, linewidth=0)\n\n    return ax",
  "def plot_mesh(ax=None, filename=None, A2B=np.eye(4),\n              s=np.array([1.0, 1.0, 1.0]), ax_s=1, wireframe=False,\n              convex_hull=False, alpha=1.0, color=\"k\"):\n    \"\"\"Plot mesh.\n\n    Note that this function requires the additional library to load meshes\n    such as trimesh or open3d.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    filename : str, optional (default: None)\n        Path to mesh file.\n\n    A2B : array-like, shape (4, 4)\n        Pose of the mesh\n\n    s : array-like, shape (3,), optional (default: [1, 1, 1])\n        Scaling of the mesh that will be drawn\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    wireframe : bool, optional (default: True)\n        Plot wireframe of mesh and surface otherwise\n\n    convex_hull : bool, optional (default: False)\n        Show convex hull instead of the original mesh. This can be much\n        faster.\n\n    alpha : float, optional (default: 1)\n        Alpha value of the mesh that will be plotted\n\n    color : str, optional (default: black)\n        Color in which the mesh should be plotted\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    if filename is None:\n        warnings.warn(\n            \"No filename given for mesh. When you use the \"\n            \"UrdfTransformManager, make sure to set the mesh path or \"\n            \"package directory.\")\n        return ax\n\n    mesh = load_mesh(filename)\n    if convex_hull:\n        mesh.convex_hull()\n\n    vertices = mesh.vertices * s\n    vertices = np.hstack((vertices, np.ones((len(vertices), 1))))\n    vertices = transform(A2B, vertices)[:, :3]\n    vectors = np.array([vertices[[i, j, k]] for i, j, k in mesh.triangles])\n    if wireframe:\n        surface = Line3DCollection(vectors)\n        surface.set_color(color)\n    else:\n        surface = Poly3DCollection(vectors)\n        surface.set_facecolor(color)\n    surface.set_alpha(alpha)\n    ax.add_collection3d(surface)\n    return ax",
  "def plot_ellipsoid(ax=None, radii=np.ones(3), A2B=np.eye(4), ax_s=1,\n                   wireframe=True, n_steps=20, alpha=1.0, color=\"k\"):\n    \"\"\"Plot ellipsoid.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    radii : array-like, shape (3,)\n        Radii along the x-axis, y-axis, and z-axis of the ellipsoid.\n\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    wireframe : bool, optional (default: True)\n        Plot wireframe of ellipsoid and surface otherwise\n\n    n_steps : int, optional (default: 20)\n        Number of discrete steps plotted in each dimension\n\n    alpha : float, optional (default: 1)\n        Alpha value of the ellipsoid that will be plotted\n\n    color : str, optional (default: black)\n        Color in which the ellipsoid should be plotted\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    radius_x, radius_y, radius_z = radii\n\n    x, y, z = unit_sphere_surface_grid(n_steps)\n    x *= radius_x\n    y *= radius_y\n    z *= radius_z\n\n    x, y, z = transform_surface(A2B, x, y, z)\n\n    if wireframe:\n        ax.plot_wireframe(\n            x, y, z, rstride=2, cstride=2, color=color, alpha=alpha)\n    else:\n        ax.plot_surface(x, y, z, color=color, alpha=alpha, linewidth=0)\n\n    return ax",
  "def plot_capsule(ax=None, A2B=np.eye(4), height=1.0, radius=1.0,\n                 ax_s=1, wireframe=True, n_steps=20, alpha=1.0, color=\"k\"):\n    \"\"\"Plot capsule.\n\n    A capsule is the volume covered by a sphere moving along a line segment.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    A2B : array-like, shape (4, 4)\n        Frame of the capsule, located at the center of the line segment.\n\n    height : float, optional (default: 1)\n        Height of the capsule along its z-axis.\n\n    radius : float, optional (default: 1)\n        Radius of the capsule.\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    wireframe : bool, optional (default: True)\n        Plot wireframe of capsule and surface otherwise\n\n    n_steps : int, optional (default: 20)\n        Number of discrete steps plotted in each dimension\n\n    alpha : float, optional (default: 1)\n        Alpha value of the mesh that will be plotted\n\n    color : str, optional (default: black)\n        Color in which the capsule should be plotted\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    x, y, z = unit_sphere_surface_grid(n_steps)\n    x *= radius\n    y *= radius\n    z *= radius\n    z[len(z) // 2:] -= 0.5 * height\n    z[:len(z) // 2] += 0.5 * height\n\n    x, y, z = transform_surface(A2B, x, y, z)\n\n    if wireframe:\n        ax.plot_wireframe(\n            x, y, z, rstride=2, cstride=2, color=color, alpha=alpha)\n    else:\n        ax.plot_surface(x, y, z, color=color, alpha=alpha, linewidth=0)\n\n    return ax",
  "def plot_cone(ax=None, height=1.0, radius=1.0, A2B=np.eye(4), ax_s=1,\n              wireframe=True, n_steps=20, alpha=1.0, color=\"k\"):\n    \"\"\"Plot cone.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    height : float, optional (default: 1)\n        Height of the cone\n\n    radius : float, optional (default: 1)\n        Radius of the cone\n\n    A2B : array-like, shape (4, 4)\n        Center of the cone\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    wireframe : bool, optional (default: True)\n        Plot wireframe of cone and surface otherwise\n\n    n_steps : int, optional (default: 100)\n        Number of discrete steps plotted in each dimension\n\n    alpha : float, optional (default: 1)\n        Alpha value of the cone that will be plotted\n\n    color : str, optional (default: black)\n        Color in which the cone should be plotted\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    axis_start = A2B.dot(np.array([0, 0, 0, 1]))[:3]\n    axis_end = A2B.dot(np.array([0, 0, height, 1]))[:3]\n    axis = axis_end - axis_start\n    axis /= height\n\n    not_axis = np.array([1, 0, 0])\n    if np.allclose(axis, not_axis) or np.allclose(-axis, not_axis):\n        not_axis = np.array([0, 1, 0])\n\n    n1 = np.cross(axis, not_axis)\n    n1 /= np.linalg.norm(n1)\n    n2 = np.cross(axis, n1)\n\n    if wireframe:\n        t = np.linspace(0, height, n_steps)\n        radii = np.linspace(radius, 0, n_steps)\n    else:\n        t = np.array([0, height])\n        radii = np.array([radius, 0])\n    theta = np.linspace(0, 2 * np.pi, n_steps)\n    t, theta = np.meshgrid(t, theta)\n\n    X, Y, Z = [axis_start[i] + axis[i] * t\n               + radii * np.sin(theta) * n1[i]\n               + radii * np.cos(theta) * n2[i] for i in [0, 1, 2]]\n\n    if wireframe:\n        ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10, alpha=alpha,\n                          color=color)\n    else:\n        ax.plot_surface(X, Y, Z, color=color, alpha=alpha, linewidth=0)\n\n    return ax",
  "def plot_vector(ax=None, start=np.zeros(3), direction=np.array([1, 0, 0]),\n                s=1.0, arrowstyle=\"simple\", ax_s=1, **kwargs):\n    \"\"\"Plot Vector.\n\n    Draws an arrow from start to start + s * direction.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    start : array-like, shape (3,), optional (default: [0, 0, 0])\n        Start of the vector\n\n    direction : array-like, shape (3,), optional (default: [1, 0, 0])\n        Direction of the vector\n\n    s : float, optional (default: 1)\n        Scaling of the vector that will be drawn\n\n    arrowstyle : str, or ArrowStyle, optional (default: 'simple')\n        See matplotlib's documentation of arrowstyle in\n        matplotlib.patches.FancyArrowPatch for more options\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    kwargs : dict, optional (default: {})\n        Additional arguments for the plotting functions, e.g. alpha\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    axis_arrow = Arrow3D(\n        [start[0], start[0] + s * direction[0]],\n        [start[1], start[1] + s * direction[1]],\n        [start[2], start[2] + s * direction[2]],\n        mutation_scale=20, arrowstyle=arrowstyle, **kwargs)\n    ax.add_artist(axis_arrow)\n\n    return ax",
  "def plot_length_variable(ax=None, start=np.zeros(3), end=np.ones(3), name=\"l\",\n                         above=False, ax_s=1, color=\"k\", **kwargs):\n    \"\"\"Plot length with text at its center.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    start : array-like, shape (3,), optional (default: [0, 0, 0])\n        Start point\n\n    end : array-like, shape (3,), optional (default: [1, 1, 1])\n        End point\n\n    name : str, optional (default: 'l')\n        Text in the middle\n\n    above : bool, optional (default: False)\n        Plot name above line\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    color : str, optional (default: black)\n        Color in which the cylinder should be plotted\n\n    kwargs : dict, optional (default: {})\n        Additional arguments for the text, e.g. fontsize\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    direction = end - start\n    length = np.linalg.norm(direction)\n\n    if above:\n        ax.plot([start[0], end[0]], [start[1], end[1]],\n                [start[2], end[2]], color=color)\n    else:\n        mid1 = start + 0.4 * direction\n        mid2 = start + 0.6 * direction\n        ax.plot([start[0], mid1[0]], [start[1], mid1[1]],\n                [start[2], mid1[2]], color=color)\n        ax.plot([end[0], mid2[0]], [end[1], mid2[1]],\n                [end[2], mid2[2]], color=color)\n\n    if np.linalg.norm(direction / length - unitz) < np.finfo(float).eps:\n        axis = unitx\n    else:\n        axis = unitz\n\n    mark = (norm_vector(perpendicular_to_vectors(direction, axis))\n            * 0.03 * length)\n    mark_start1 = start + mark\n    mark_start2 = start - mark\n    mark_end1 = end + mark\n    mark_end2 = end - mark\n    ax.plot([mark_start1[0], mark_start2[0]],\n            [mark_start1[1], mark_start2[1]],\n            [mark_start1[2], mark_start2[2]],\n            color=color)\n    ax.plot([mark_end1[0], mark_end2[0]],\n            [mark_end1[1], mark_end2[1]],\n            [mark_end1[2], mark_end2[2]],\n            color=color)\n    text_location = start + 0.45 * direction\n    if above:\n        text_location[2] += 0.3 * length\n    ax.text(text_location[0], text_location[1], text_location[2], name,\n            zdir=\"x\", **kwargs)\n\n    return ax",
  "class Artist:\n    \"\"\"Abstract base class for objects that can be rendered.\"\"\"\n\n    def add_artist(self, figure):\n        \"\"\"Add artist to figure.\n\n        Parameters\n        ----------\n        figure : Figure\n            Figure to which the artist will be added.\n        \"\"\"\n        for g in self.geometries:\n            figure.add_geometry(g)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return []",
  "class Line3D(Artist):\n    \"\"\"A line.\n\n    Parameters\n    ----------\n    P : array-like, shape (n_points, 3)\n        Points of which the line consists.\n\n    c : array-like, shape (n_points - 1, 3) or (3,), optional (default: black)\n        Color can be given as individual colors per line segment or as one\n        color for each segment. A color is represented by 3 values between\n        0 and 1 indicate representing red, green, and blue respectively.\n    \"\"\"\n    def __init__(self, P, c=(0, 0, 0)):\n        self.line_set = o3d.geometry.LineSet()\n        self.set_data(P, c)\n\n    def set_data(self, P, c=None):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        P : array-like, shape (n_points, 3)\n            Points of which the line consists.\n\n        c : array-like, shape (n_points - 1, 3) or (3,), optional (default: black)\n            Color can be given as individual colors per line segment or\n            as one color for each segment. A color is represented by 3\n            values between 0 and 1 indicate representing red, green, and\n            blue respectively.\n        \"\"\"\n        self.line_set.points = o3d.utility.Vector3dVector(P)\n        self.line_set.lines = o3d.utility.Vector2iVector(np.hstack((\n            np.arange(len(P) - 1)[:, np.newaxis],\n            np.arange(1, len(P))[:, np.newaxis])))\n\n        if c is not None:\n            try:\n                if len(c[0]) == 3:\n                    self.line_set.colors = o3d.utility.Vector3dVector(c)\n            except TypeError:  # one color for all segments\n                self.line_set.colors = o3d.utility.Vector3dVector(\n                    [c for _ in range(len(P) - 1)])\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.line_set]",
  "class PointCollection3D(Artist):\n    \"\"\"Collection of points.\n\n    Parameters\n    ----------\n    P : array, shape (n_points, 3)\n        Points\n\n    s : float, optional (default: 0.05)\n        Scaling of the spheres that will be drawn.\n\n    c : array-like, shape (3,) or (n_points, 3), optional (default: black)\n        A color is represented by 3 values between 0 and 1 indicate\n        representing red, green, and blue respectively.\n    \"\"\"\n    def __init__(self, P, s=0.05, c=None):\n        self._points = []\n        self._P = np.zeros_like(P)\n\n        if c is not None:\n            c = np.asarray(c)\n            if c.ndim == 1:\n                c = np.tile(c, (len(P), 1))\n\n        for i in range(len(P)):\n            point = o3d.geometry.TriangleMesh.create_sphere(\n                radius=s, resolution=10)\n            if c is not None:\n                n_vertices = len(point.vertices)\n                colors = np.zeros((n_vertices, 3))\n                colors[:] = c[i]\n                point.vertex_colors = o3d.utility.Vector3dVector(colors)\n            point.compute_vertex_normals()\n            self._points.append(point)\n\n        self.set_data(P)\n\n    def set_data(self, P):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        P : array, shape (n_points, 3)\n            Points\n        \"\"\"\n        P = np.copy(P)\n        for i, point, p, previous_p in zip(\n                range(len(self._P)), self._points, P, self._P):\n            if any(np.isnan(p)):\n                P[i] = previous_p\n            else:\n                point.translate(p - previous_p)\n\n        self._P = P\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return self._points",
  "class Vector3D(Artist):\n    \"\"\"A vector.\n\n    Parameters\n    ----------\n    start : array-like, shape (3,), optional (default: [0, 0, 0])\n        Start of the vector\n\n    direction : array-like, shape (3,), optional (default: [1, 0, 0])\n        Direction of the vector\n\n    c : array-like, shape (3,), optional (default: black)\n        A color is represented by 3 values between 0 and 1 indicate\n        representing red, green, and blue respectively.\n    \"\"\"\n    def __init__(self, start=np.zeros(3), direction=np.array([1, 0, 0]),\n                 c=(0, 0, 0)):\n        self.vector = o3d.geometry.TriangleMesh.create_arrow(\n            cylinder_radius=0.035, cone_radius=0.07,\n            cylinder_height=0.8, cone_height=0.2)\n        self.set_data(start, direction, c)\n\n    def set_data(self, start, direction, c=None):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        start : array-like, shape (3,)\n            Start of the vector\n\n        direction : array-like, shape (3,)\n            Direction of the vector\n\n        c : array-like, shape (3,), optional (default: black)\n            A color is represented by 3 values between 0 and 1 indicate\n            representing red, green, and blue respectively.\n        \"\"\"\n        length = np.linalg.norm(direction)\n        z = direction / length\n        x, y = pr.plane_basis_from_normal(z)\n        R = np.column_stack((x, y, z))\n        A2B = pt.transform_from(R, start)\n\n        new_vector = o3d.geometry.TriangleMesh.create_arrow(\n            cylinder_radius=0.035 * length, cone_radius=0.07 * length,\n            cylinder_height=0.8 * length, cone_height=0.2 * length)\n        self.vector.vertices = new_vector.vertices\n        self.vector.triangles = new_vector.triangles\n        self.vector.transform(A2B)\n        if c is not None:\n            self.vector.paint_uniform_color(c)\n        self.vector.compute_vertex_normals()\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.vector]",
  "class Frame(Artist):\n    \"\"\"Coordinate frame.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Transform from frame A to frame B\n\n    label : str, optional (default: None)\n        Name of the frame\n\n    s : float, optional (default: 1)\n        Length of basis vectors\n    \"\"\"\n    def __init__(self, A2B, label=None, s=1.0):\n        self.A2B = None\n        self.label = None\n        self.s = s\n\n        self.frame = o3d.geometry.TriangleMesh.create_coordinate_frame(\n            size=self.s)\n\n        self.set_data(A2B, label)\n\n    def set_data(self, A2B, label=None):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        label : str, optional (default: None)\n            Name of the frame\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n        self.label = label\n        if label is not None:\n            warnings.warn(\n                \"This viewer does not support text. Frame label \"\n                \"will be ignored.\")\n\n        self.frame.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.frame.transform(self.A2B)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.frame]",
  "class Trajectory(Artist):\n    \"\"\"Trajectory of poses.\n\n    Parameters\n    ----------\n    H : array-like, shape (n_steps, 4, 4)\n        Sequence of poses represented by homogeneous matrices\n\n    n_frames : int, optional (default: 10)\n        Number of frames that should be plotted to indicate the rotation\n\n    s : float, optional (default: 1)\n        Scaling of the frames that will be drawn\n\n    c : array-like, shape (3,), optional (default: black)\n        A color is represented by 3 values between 0 and 1 indicate\n        representing red, green, and blue respectively.\n    \"\"\"\n    def __init__(self, H, n_frames=10, s=1.0, c=(0, 0, 0)):\n        self.H = H\n        self.n_frames = n_frames\n        self.s = s\n        self.c = c\n\n        self.key_frames = []\n        self.line = Line3D(H[:, :3, 3], c)\n\n        self.key_frames_indices = np.linspace(\n            0, len(self.H) - 1, self.n_frames, dtype=np.int64)\n        for key_frame_idx in self.key_frames_indices:\n            self.key_frames.append(Frame(self.H[key_frame_idx], s=self.s))\n\n        self.set_data(H)\n\n    def set_data(self, H):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        H : array-like, shape (n_steps, 4, 4)\n            Sequence of poses represented by homogeneous matrices\n        \"\"\"\n        self.line.set_data(H[:, :3, 3])\n        for i, key_frame_idx in enumerate(self.key_frames_indices):\n            self.key_frames[i].set_data(H[key_frame_idx])\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return self.line.geometries + list(\n            chain(*[kf.geometries for kf in self.key_frames]))",
  "class Sphere(Artist):\n    \"\"\"Sphere.\n\n    Parameters\n    ----------\n    radius : float, optional (default: 1)\n        Radius of the sphere\n\n    A2B : array-like, shape (4, 4)\n        Center of the sphere\n\n    resolution : int, optional (default: 20)\n        The resolution of the sphere. The longitudes will be split into\n        resolution segments (i.e. there are resolution + 1 latitude lines\n        including the north and south pole). The latitudes will be split\n        into 2 * resolution segments (i.e. there are 2 * resolution\n        longitude lines.)\n\n    c : array-like, shape (3,), optional (default: None)\n        Color\n    \"\"\"\n    def __init__(self, radius=1.0, A2B=np.eye(4), resolution=20, c=None):\n        self.sphere = o3d.geometry.TriangleMesh.create_sphere(\n            radius, resolution)\n        if c is not None:\n            n_vertices = len(self.sphere.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.sphere.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.sphere.compute_vertex_normals()\n        self.A2B = None\n        self.set_data(A2B)\n\n    def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the sphere.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.sphere.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.sphere.transform(self.A2B)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.sphere]",
  "class Box(Artist):\n    \"\"\"Box.\n\n    Parameters\n    ----------\n    size : array-like, shape (3,), optional (default: [1, 1, 1])\n        Size of the box per dimension\n\n    A2B : array-like, shape (4, 4), optional (default: I)\n        Center of the box\n\n    c : array-like, shape (3,), optional (default: None)\n        Color\n    \"\"\"\n    def __init__(self, size=np.ones(3), A2B=np.eye(4), c=None):\n        self.half_size = np.asarray(size) / 2.0\n        width, height, depth = size\n        self.box = o3d.geometry.TriangleMesh.create_box(\n            width, height, depth)\n        if c is not None:\n            n_vertices = len(self.box.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.box.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.box.compute_vertex_normals()\n        self.A2B = None\n        self.set_data(A2B)\n\n    def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the box.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            self.box.transform(\n                pt.transform_from(R=np.eye(3), p=-self.half_size))\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.box.transform(pt.invert_transform(previous_A2B, check=False))\n        self.box.transform(self.A2B)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.box]",
  "class Cylinder(Artist):\n    \"\"\"Cylinder.\n\n    A cylinder is the volume covered by a disk moving along a line segment.\n\n    Parameters\n    ----------\n    length : float, optional (default: 1)\n        Length of the cylinder.\n\n    radius : float, optional (default: 1)\n        Radius of the cylinder.\n\n    A2B : array-like, shape (4, 4)\n        Pose of the cylinder. The position corresponds to the center of the\n        line segment and the z-axis to the direction of the line segment.\n\n    resolution : int, optional (default: 20)\n        The circles will be split into resolution segments.\n\n    split : int, optional (default: 4)\n        The height will be split into split segments\n\n    c : array-like, shape (3,), optional (default: None)\n        Color\n    \"\"\"\n    def __init__(self, length=2.0, radius=1.0, A2B=np.eye(4), resolution=20,\n                 split=4, c=None):\n        self.cylinder = o3d.geometry.TriangleMesh.create_cylinder(\n            radius=radius, height=length, resolution=resolution,\n            split=split)\n        if c is not None:\n            n_vertices = len(self.cylinder.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.cylinder.vertex_colors = \\\n                o3d.utility.Vector3dVector(colors)\n        self.cylinder.compute_vertex_normals()\n        self.A2B = None\n        self.set_data(A2B)\n\n    def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the cylinder.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.cylinder.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.cylinder.transform(self.A2B)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.cylinder]",
  "class Mesh(Artist):\n    \"\"\"Mesh.\n\n    Parameters\n    ----------\n    filename : str\n        Path to mesh file\n\n    A2B : array-like, shape (4, 4)\n        Center of the mesh\n\n    s : array-like, shape (3,), optional (default: [1, 1, 1])\n        Scaling of the mesh that will be drawn\n\n    c : array-like, shape (n_vertices, 3) or (3,), optional (default: None)\n        Color(s)\n\n    convex_hull : bool, optional (default: False)\n        Compute convex hull of mesh.\n    \"\"\"\n    def __init__(self, filename, A2B=np.eye(4), s=np.ones(3), c=None,\n                 convex_hull=False):\n        mesh = load_mesh(filename)\n        if convex_hull:\n            mesh.convex_hull()\n\n        self.mesh = mesh.get_open3d_mesh()\n        self.mesh.vertices = o3d.utility.Vector3dVector(\n            np.asarray(self.mesh.vertices) * s)\n        self.mesh.compute_vertex_normals()\n        if c is not None:\n            n_vertices = len(self.mesh.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.mesh.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.A2B = None\n        self.set_data(A2B)\n\n    def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the mesh.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.mesh.transform(pt.invert_transform(previous_A2B, check=False))\n        self.mesh.transform(self.A2B)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.mesh]",
  "class Ellipsoid(Artist):\n    \"\"\"Ellipsoid.\n\n    Parameters\n    ----------\n    radii : array-like, shape (3,)\n        Radii along the x-axis, y-axis, and z-axis of the ellipsoid.\n\n    A2B : array-like, shape (4, 4)\n        Pose of the ellipsoid.\n\n    resolution : int, optional (default: 20)\n        The resolution of the ellipsoid. The longitudes will be split into\n        resolution segments (i.e. there are resolution + 1 latitude lines\n        including the north and south pole). The latitudes will be split\n        into 2 * resolution segments (i.e. there are 2 * resolution\n        longitude lines.)\n\n    c : array-like, shape (3,), optional (default: None)\n        Color\n    \"\"\"\n    def __init__(self, radii, A2B=np.eye(4), resolution=20, c=None):\n        self.ellipsoid = o3d.geometry.TriangleMesh.create_sphere(\n            1.0, resolution)\n        vertices = np.asarray(self.ellipsoid.vertices)\n        vertices *= np.asarray(radii)[np.newaxis]\n        self.ellipsoid.vertices = o3d.utility.Vector3dVector(vertices)\n        self.ellipsoid.compute_vertex_normals()\n        if c is not None:\n            n_vertices = len(self.ellipsoid.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.ellipsoid.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.A2B = None\n        self.set_data(A2B)\n\n    def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the ellipsoid.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.ellipsoid.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.ellipsoid.transform(self.A2B)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.ellipsoid]",
  "class Capsule(Artist):\n    \"\"\"Capsule.\n\n    A capsule is the volume covered by a sphere moving along a line segment.\n\n    Parameters\n    ----------\n    height : float, optional (default: 1)\n        Height of the capsule along its z-axis.\n\n    radius : float, optional (default: 1)\n        Radius of the capsule.\n\n    A2B : array-like, shape (4, 4)\n        Pose of the capsule. The position corresponds to the center of the line\n        segment and the z-axis to the direction of the line segment.\n\n    resolution : int, optional (default: 20)\n        The resolution of the half spheres. The longitudes will be split into\n        resolution segments (i.e. there are resolution + 1 latitude lines\n        including the north and south pole). The latitudes will be split\n        into 2 * resolution segments (i.e. there are 2 * resolution\n        longitude lines.)\n\n    c : array-like, shape (3,), optional (default: None)\n        Color\n    \"\"\"\n    def __init__(self, height=1, radius=1, A2B=np.eye(4), resolution=20,\n                 c=None):\n        self.capsule = o3d.geometry.TriangleMesh.create_sphere(\n            radius, resolution)\n        vertices = np.asarray(self.capsule.vertices)\n        vertices[vertices[:, 2] < 0, 2] -= 0.5 * height\n        vertices[vertices[:, 2] > 0, 2] += 0.5 * height\n        self.capsule.vertices = o3d.utility.Vector3dVector(vertices)\n        self.capsule.compute_vertex_normals()\n        if c is not None:\n            n_vertices = len(self.capsule.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.capsule.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.A2B = None\n        self.set_data(A2B)\n\n    def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Start of the capsule's line segment.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.capsule.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.capsule.transform(self.A2B)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.capsule]",
  "class Cone(Artist):\n    \"\"\"Cone.\n\n    Parameters\n    ----------\n    height : float, optional (default: 1)\n        Height of the cone along its z-axis.\n\n    radius : float, optional (default: 1)\n        Radius of the cone.\n\n    A2B : array-like, shape (4, 4)\n        Pose of the cone, which is the center of its circle.\n\n    resolution : int, optional (default: 20)\n        The circle will be split into resolution segments.\n\n    c : array-like, shape (3,), optional (default: None)\n        Color\n    \"\"\"\n    def __init__(self, height=1, radius=1, A2B=np.eye(4), resolution=20,\n                 c=None):\n        self.cone = o3d.geometry.TriangleMesh.create_cone(\n            radius, height, resolution)\n        self.cone.compute_vertex_normals()\n        if c is not None:\n            n_vertices = len(self.cone.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.cone.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.A2B = None\n        self.set_data(A2B)\n\n    def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the cone's circle.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.cone.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.cone.transform(self.A2B)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.cone]",
  "class Plane(Artist):\n    \"\"\"Plane.\n\n    The plane will be defined either by a normal and a point in the plane or\n    by the Hesse normal form, which only needs a normal and the distance to\n    the origin from which we can compute the point in the plane as d * normal.\n\n    A plane will be visualized by a square.\n\n    Parameters\n    ----------\n    normal : array-like, shape (3,), optional (default: [0, 0, 1])\n        Plane normal.\n\n    d : float, optional (default: None)\n        Distance to origin in Hesse normal form.\n\n    point_in_plane : array-like, shape (3,), optional (default: None)\n        Point in plane.\n\n    s : float, optional (default: 1)\n        Scaling of the plane that will be drawn.\n\n    c : array-like, shape (3,), optional (default: None)\n        Color.\n    \"\"\"\n    def __init__(self, normal=np.array([0.0, 0.0, 1.0]), d=None,\n                 point_in_plane=None, s=1.0, c=None):\n        self.triangles = np.array([\n            [0, 1, 2],\n            [1, 3, 2],\n            [2, 1, 0],\n            [2, 3, 1],\n        ])\n        vertices = np.zeros((4, 3))\n        self.plane = o3d.geometry.TriangleMesh(\n            o3d.utility.Vector3dVector(vertices),\n            o3d.utility.Vector3iVector(self.triangles))\n\n        self.set_data(normal, d, point_in_plane, s, c)\n\n    def set_data(self, normal, d=None, point_in_plane=None, s=None,\n                 c=None):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        normal : array-like, shape (3,)\n            Plane normal.\n\n        d : float, optional (default: None)\n            Distance to origin in Hesse normal form.\n\n        point_in_plane : array-like, shape (3,), optional (default: None)\n            Point in plane.\n\n        s : float, optional (default: 1)\n            Scaling of the plane that will be drawn.\n\n        c : array-like, shape (3,), optional (default: None)\n            Color.\n\n        Raises\n        ------\n        ValueError\n            If neither 'd' nor 'point_in_plane' is defined.\n        \"\"\"\n        normal = np.asarray(normal)\n        if point_in_plane is None:\n            if d is None:\n                raise ValueError(\n                    \"Either 'd' or 'point_in_plane' has to be defined!\")\n            point_in_plane = d * normal\n        else:\n            point_in_plane = np.asarray(point_in_plane)\n\n        x_axis, y_axis = pr.plane_basis_from_normal(normal)\n        vertices = np.array([\n            point_in_plane + s * x_axis + s * y_axis,\n            point_in_plane - s * x_axis + s * y_axis,\n            point_in_plane + s * x_axis - s * y_axis,\n            point_in_plane - s * x_axis - s * y_axis,\n        ])\n        self.plane.vertices = o3d.utility.Vector3dVector(vertices)\n        self.plane.compute_vertex_normals()\n        if c is not None:\n            self.plane.paint_uniform_color(c)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.plane]",
  "class Camera(Artist):\n    \"\"\"Camera.\n\n    Parameters\n    ----------\n    M : array-like, shape (3, 3)\n        Intrinsic camera matrix that contains the focal lengths on the diagonal\n        and the center of the the image in the last column. It does not matter\n        whether values are given in meters or pixels as long as the unit is the\n        same as for the sensor size.\n\n    cam2world : array-like, shape (4, 4), optional (default: I)\n        Transformation matrix of camera in world frame. We assume that the\n        position is given in meters.\n\n    virtual_image_distance : float, optional (default: 1)\n        Distance from pinhole to virtual image plane that will be displayed.\n        We assume that this distance is given in meters. The unit has to be\n        consistent with the unit of the position in cam2world.\n\n    sensor_size : array-like, shape (2,), optional (default: [1920, 1080])\n        Size of the image sensor: (width, height). It does not matter whether\n        values are given in meters or pixels as long as the unit is the same as\n        for the sensor size.\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n    \"\"\"\n    def __init__(self, M, cam2world=None, virtual_image_distance=1,\n                 sensor_size=(1920, 1080), strict_check=True):\n        self.M = None\n        self.cam2world = None\n        self.virtual_image_distance = None\n        self.sensor_size = None\n        self.strict_check = strict_check\n\n        self.line_set = o3d.geometry.LineSet()\n\n        if cam2world is None:\n            cam2world = np.eye(4)\n\n        self.set_data(M, cam2world, virtual_image_distance, sensor_size)\n\n    def set_data(self, M=None, cam2world=None, virtual_image_distance=None,\n                 sensor_size=None):\n        \"\"\"Update camera parameters.\n\n        Parameters\n        ----------\n        M : array-like, shape (3, 3), optional (default: old value)\n            Intrinsic camera matrix that contains the focal lengths on the\n            diagonal and the center of the the image in the last column. It\n            does not matter whether values are given in meters or pixels as\n            long as the unit is the same as for the sensor size.\n\n        cam2world : array-like, shape (4, 4), optional (default: old value)\n            Transformation matrix of camera in world frame. We assume that\n            the position is given in meters.\n\n        virtual_image_distance : float, optional (default: old value)\n            Distance from pinhole to virtual image plane that will be\n            displayed. We assume that this distance is given in meters.\n            The unit has to be consistent with the unit of the position\n            in cam2world.\n\n        sensor_size : array-like, shape (2,), optional (default: old value)\n            Size of the image sensor: (width, height). It does not matter\n            whether values are given in meters or pixels as long as the\n            unit is the same as for the sensor size.\n        \"\"\"\n        if M is not None:\n            self.M = M\n        if cam2world is not None:\n            self.cam2world = pt.check_transform(\n                cam2world, strict_check=self.strict_check)\n        if virtual_image_distance is not None:\n            self.virtual_image_distance = virtual_image_distance\n        if sensor_size is not None:\n            self.sensor_size = sensor_size\n\n        camera_center_in_world = cam2world[:3, 3]\n        focal_length = np.mean(np.diag(M[:2, :2]))\n        sensor_corners_in_cam = np.array([\n            [0, 0, focal_length],\n            [0, sensor_size[1], focal_length],\n            [sensor_size[0], sensor_size[1], focal_length],\n            [sensor_size[0], 0, focal_length],\n        ])\n        sensor_corners_in_cam[:, 0] -= M[0, 2]\n        sensor_corners_in_cam[:, 1] -= M[1, 2]\n        sensor_corners_in_world = pt.transform(\n            cam2world, pt.vectors_to_points(sensor_corners_in_cam))[:, :3]\n        virtual_image_corners = (\n            virtual_image_distance / focal_length *\n            (sensor_corners_in_world - camera_center_in_world[np.newaxis]) +\n            camera_center_in_world[np.newaxis])\n\n        up = virtual_image_corners[0] - virtual_image_corners[1]\n        camera_line_points = np.vstack((\n            camera_center_in_world[:3],\n            virtual_image_corners[0],\n            virtual_image_corners[1],\n            virtual_image_corners[2],\n            virtual_image_corners[3],\n            virtual_image_corners[0] + 0.1 * up,\n            0.5 * (virtual_image_corners[0] +\n                   virtual_image_corners[3]) + 0.5 * up,\n            virtual_image_corners[3] + 0.1 * up\n        ))\n\n        self.line_set.points = o3d.utility.Vector3dVector(\n            camera_line_points)\n        self.line_set.lines = o3d.utility.Vector2iVector(\n            np.array([[0, 1], [0, 2], [0, 3], [0, 4],\n                      [1, 2], [2, 3], [3, 4], [4, 1],\n                      [5, 6], [6, 7], [7, 5]]))\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.line_set]",
  "class Graph(Artist):\n    \"\"\"Graph of connected frames.\n\n    Parameters\n    ----------\n    tm : TransformManager\n        Representation of the graph\n\n    frame : str\n        Name of the base frame in which the graph will be displayed\n\n    show_frames : bool, optional (default: False)\n        Show coordinate frames\n\n    show_connections : bool, optional (default: False)\n        Draw lines between frames of the graph\n\n    show_visuals : bool, optional (default: False)\n        Show visuals that are stored in the graph\n\n    show_collision_objects : bool, optional (default: False)\n        Show collision objects that are stored in the graph\n\n    show_name : bool, optional (default: False)\n        Show names of frames\n\n    whitelist : list, optional (default: all)\n        List of frames that should be displayed\n\n    convex_hull_of_collision_objects : bool, optional (default: False)\n        Show convex hull of collision objects.\n\n    s : float, optional (default: 1)\n        Scaling of the frames that will be drawn\n    \"\"\"\n    def __init__(self, tm, frame, show_frames=False, show_connections=False,\n                 show_visuals=False, show_collision_objects=False,\n                 show_name=False, whitelist=None,\n                 convex_hull_of_collision_objects=False, s=1.0):\n        self.tm = tm\n        self.frame = frame\n        self.show_frames = show_frames\n        self.show_connections = show_connections\n        self.show_visuals = show_visuals\n        self.show_collision_objects = show_collision_objects\n        self.whitelist = whitelist\n        self.convex_hull_of_collision_objects = \\\n            convex_hull_of_collision_objects\n        self.s = s\n\n        if self.frame not in self.tm.nodes:\n            raise KeyError(\"Unknown frame '%s'\" % self.frame)\n\n        self.nodes = list(sorted(self.tm._whitelisted_nodes(whitelist)))\n\n        self.frames = {}\n        if self.show_frames:\n            for node in self.nodes:\n                try:\n                    node2frame = self.tm.get_transform(node, frame)\n                    name = node if show_name else None\n                    self.frames[node] = Frame(node2frame, name, self.s)\n                except KeyError:\n                    pass  # Frame is not connected to the reference frame\n\n        self.connections = {}\n        if self.show_connections:\n            for frame_names in self.tm.transforms.keys():\n                from_frame, to_frame = frame_names\n                if (from_frame in self.tm.nodes and\n                        to_frame in self.tm.nodes):\n                    try:\n                        self.tm.get_transform(from_frame, self.frame)\n                        self.tm.get_transform(to_frame, self.frame)\n                        self.connections[frame_names] = \\\n                            o3d.geometry.LineSet()\n                    except KeyError:\n                        pass  # Frame is not connected to reference frame\n\n        self.visuals = {}\n        if show_visuals and hasattr(self.tm, \"visuals\"):\n            self.visuals.update(_objects_to_artists(self.tm.visuals))\n        self.collision_objects = {}\n        if show_collision_objects and hasattr(\n                self.tm, \"collision_objects\"):\n            self.collision_objects.update(\n                _objects_to_artists(self.tm.collision_objects,\n                                    convex_hull_of_collision_objects))\n\n        self.set_data()\n\n    def set_data(self):\n        \"\"\"Indicate that data has been updated.\"\"\"\n        if self.show_frames:\n            for node in self.nodes:\n                try:\n                    node2frame = self.tm.get_transform(node, self.frame)\n                    self.frames[node].set_data(node2frame)\n                except KeyError:\n                    pass  # Frame is not connected to the reference frame\n\n        if self.show_connections:\n            for frame_names in self.connections:\n                from_frame, to_frame = frame_names\n                try:\n                    from2ref = self.tm.get_transform(\n                        from_frame, self.frame)\n                    to2ref = self.tm.get_transform(to_frame, self.frame)\n\n                    points = np.vstack((from2ref[:3, 3], to2ref[:3, 3]))\n                    self.connections[frame_names].points = \\\n                        o3d.utility.Vector3dVector(points)\n                    self.connections[frame_names].lines = \\\n                        o3d.utility.Vector2iVector(np.array([[0, 1]]))\n                except KeyError:\n                    pass  # Frame is not connected to the reference frame\n\n        for frame, obj in self.visuals.items():\n            A2B = self.tm.get_transform(frame, self.frame)\n            obj.set_data(A2B)\n\n        for frame, obj in self.collision_objects.items():\n            A2B = self.tm.get_transform(frame, self.frame)\n            obj.set_data(A2B)\n\n    @property\n    def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        geometries = []\n        if self.show_frames:\n            for f in self.frames.values():\n                geometries += f.geometries\n        if self.show_connections:\n            geometries += list(self.connections.values())\n        for obj in self.visuals.values():\n            geometries += obj.geometries\n        for obj in self.collision_objects.values():\n            geometries += obj.geometries\n        return geometries",
  "def _objects_to_artists(objects, convex_hull=False):\n    \"\"\"Convert geometries from URDF to artists.\n\n    Parameters\n    ----------\n    objects : list of Geometry\n        Objects parsed from URDF.\n\n    convex_hull : bool, optional (default: False)\n        Compute convex hull for each object.\n\n    Returns\n    -------\n    artists : dict\n        Mapping from frame names to artists.\n    \"\"\"\n    artists = {}\n    for obj in objects:\n        if obj.color is None:\n            color = None\n        else:\n            # we loose the alpha channel as it is not supported by Open3D\n            color = (obj.color[0], obj.color[1], obj.color[2])\n        try:\n            if isinstance(obj, urdf.Sphere):\n                artist = Sphere(radius=obj.radius, c=color)\n            elif isinstance(obj, urdf.Box):\n                artist = Box(obj.size, c=color)\n            elif isinstance(obj, urdf.Cylinder):\n                artist = Cylinder(obj.length, obj.radius, c=color)\n            else:\n                assert isinstance(obj, urdf.Mesh)\n                artist = Mesh(obj.filename, s=obj.scale, c=color,\n                              convex_hull=convex_hull)\n            artists[obj.frame] = artist\n        except RuntimeError as e:\n            warnings.warn(str(e))\n    return artists",
  "def add_artist(self, figure):\n        \"\"\"Add artist to figure.\n\n        Parameters\n        ----------\n        figure : Figure\n            Figure to which the artist will be added.\n        \"\"\"\n        for g in self.geometries:\n            figure.add_geometry(g)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return []",
  "def __init__(self, P, c=(0, 0, 0)):\n        self.line_set = o3d.geometry.LineSet()\n        self.set_data(P, c)",
  "def set_data(self, P, c=None):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        P : array-like, shape (n_points, 3)\n            Points of which the line consists.\n\n        c : array-like, shape (n_points - 1, 3) or (3,), optional (default: black)\n            Color can be given as individual colors per line segment or\n            as one color for each segment. A color is represented by 3\n            values between 0 and 1 indicate representing red, green, and\n            blue respectively.\n        \"\"\"\n        self.line_set.points = o3d.utility.Vector3dVector(P)\n        self.line_set.lines = o3d.utility.Vector2iVector(np.hstack((\n            np.arange(len(P) - 1)[:, np.newaxis],\n            np.arange(1, len(P))[:, np.newaxis])))\n\n        if c is not None:\n            try:\n                if len(c[0]) == 3:\n                    self.line_set.colors = o3d.utility.Vector3dVector(c)\n            except TypeError:  # one color for all segments\n                self.line_set.colors = o3d.utility.Vector3dVector(\n                    [c for _ in range(len(P) - 1)])",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.line_set]",
  "def __init__(self, P, s=0.05, c=None):\n        self._points = []\n        self._P = np.zeros_like(P)\n\n        if c is not None:\n            c = np.asarray(c)\n            if c.ndim == 1:\n                c = np.tile(c, (len(P), 1))\n\n        for i in range(len(P)):\n            point = o3d.geometry.TriangleMesh.create_sphere(\n                radius=s, resolution=10)\n            if c is not None:\n                n_vertices = len(point.vertices)\n                colors = np.zeros((n_vertices, 3))\n                colors[:] = c[i]\n                point.vertex_colors = o3d.utility.Vector3dVector(colors)\n            point.compute_vertex_normals()\n            self._points.append(point)\n\n        self.set_data(P)",
  "def set_data(self, P):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        P : array, shape (n_points, 3)\n            Points\n        \"\"\"\n        P = np.copy(P)\n        for i, point, p, previous_p in zip(\n                range(len(self._P)), self._points, P, self._P):\n            if any(np.isnan(p)):\n                P[i] = previous_p\n            else:\n                point.translate(p - previous_p)\n\n        self._P = P",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return self._points",
  "def __init__(self, start=np.zeros(3), direction=np.array([1, 0, 0]),\n                 c=(0, 0, 0)):\n        self.vector = o3d.geometry.TriangleMesh.create_arrow(\n            cylinder_radius=0.035, cone_radius=0.07,\n            cylinder_height=0.8, cone_height=0.2)\n        self.set_data(start, direction, c)",
  "def set_data(self, start, direction, c=None):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        start : array-like, shape (3,)\n            Start of the vector\n\n        direction : array-like, shape (3,)\n            Direction of the vector\n\n        c : array-like, shape (3,), optional (default: black)\n            A color is represented by 3 values between 0 and 1 indicate\n            representing red, green, and blue respectively.\n        \"\"\"\n        length = np.linalg.norm(direction)\n        z = direction / length\n        x, y = pr.plane_basis_from_normal(z)\n        R = np.column_stack((x, y, z))\n        A2B = pt.transform_from(R, start)\n\n        new_vector = o3d.geometry.TriangleMesh.create_arrow(\n            cylinder_radius=0.035 * length, cone_radius=0.07 * length,\n            cylinder_height=0.8 * length, cone_height=0.2 * length)\n        self.vector.vertices = new_vector.vertices\n        self.vector.triangles = new_vector.triangles\n        self.vector.transform(A2B)\n        if c is not None:\n            self.vector.paint_uniform_color(c)\n        self.vector.compute_vertex_normals()",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.vector]",
  "def __init__(self, A2B, label=None, s=1.0):\n        self.A2B = None\n        self.label = None\n        self.s = s\n\n        self.frame = o3d.geometry.TriangleMesh.create_coordinate_frame(\n            size=self.s)\n\n        self.set_data(A2B, label)",
  "def set_data(self, A2B, label=None):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        label : str, optional (default: None)\n            Name of the frame\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n        self.label = label\n        if label is not None:\n            warnings.warn(\n                \"This viewer does not support text. Frame label \"\n                \"will be ignored.\")\n\n        self.frame.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.frame.transform(self.A2B)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.frame]",
  "def __init__(self, H, n_frames=10, s=1.0, c=(0, 0, 0)):\n        self.H = H\n        self.n_frames = n_frames\n        self.s = s\n        self.c = c\n\n        self.key_frames = []\n        self.line = Line3D(H[:, :3, 3], c)\n\n        self.key_frames_indices = np.linspace(\n            0, len(self.H) - 1, self.n_frames, dtype=np.int64)\n        for key_frame_idx in self.key_frames_indices:\n            self.key_frames.append(Frame(self.H[key_frame_idx], s=self.s))\n\n        self.set_data(H)",
  "def set_data(self, H):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        H : array-like, shape (n_steps, 4, 4)\n            Sequence of poses represented by homogeneous matrices\n        \"\"\"\n        self.line.set_data(H[:, :3, 3])\n        for i, key_frame_idx in enumerate(self.key_frames_indices):\n            self.key_frames[i].set_data(H[key_frame_idx])",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return self.line.geometries + list(\n            chain(*[kf.geometries for kf in self.key_frames]))",
  "def __init__(self, radius=1.0, A2B=np.eye(4), resolution=20, c=None):\n        self.sphere = o3d.geometry.TriangleMesh.create_sphere(\n            radius, resolution)\n        if c is not None:\n            n_vertices = len(self.sphere.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.sphere.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.sphere.compute_vertex_normals()\n        self.A2B = None\n        self.set_data(A2B)",
  "def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the sphere.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.sphere.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.sphere.transform(self.A2B)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.sphere]",
  "def __init__(self, size=np.ones(3), A2B=np.eye(4), c=None):\n        self.half_size = np.asarray(size) / 2.0\n        width, height, depth = size\n        self.box = o3d.geometry.TriangleMesh.create_box(\n            width, height, depth)\n        if c is not None:\n            n_vertices = len(self.box.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.box.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.box.compute_vertex_normals()\n        self.A2B = None\n        self.set_data(A2B)",
  "def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the box.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            self.box.transform(\n                pt.transform_from(R=np.eye(3), p=-self.half_size))\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.box.transform(pt.invert_transform(previous_A2B, check=False))\n        self.box.transform(self.A2B)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.box]",
  "def __init__(self, length=2.0, radius=1.0, A2B=np.eye(4), resolution=20,\n                 split=4, c=None):\n        self.cylinder = o3d.geometry.TriangleMesh.create_cylinder(\n            radius=radius, height=length, resolution=resolution,\n            split=split)\n        if c is not None:\n            n_vertices = len(self.cylinder.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.cylinder.vertex_colors = \\\n                o3d.utility.Vector3dVector(colors)\n        self.cylinder.compute_vertex_normals()\n        self.A2B = None\n        self.set_data(A2B)",
  "def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the cylinder.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.cylinder.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.cylinder.transform(self.A2B)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.cylinder]",
  "def __init__(self, filename, A2B=np.eye(4), s=np.ones(3), c=None,\n                 convex_hull=False):\n        mesh = load_mesh(filename)\n        if convex_hull:\n            mesh.convex_hull()\n\n        self.mesh = mesh.get_open3d_mesh()\n        self.mesh.vertices = o3d.utility.Vector3dVector(\n            np.asarray(self.mesh.vertices) * s)\n        self.mesh.compute_vertex_normals()\n        if c is not None:\n            n_vertices = len(self.mesh.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.mesh.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.A2B = None\n        self.set_data(A2B)",
  "def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the mesh.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.mesh.transform(pt.invert_transform(previous_A2B, check=False))\n        self.mesh.transform(self.A2B)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.mesh]",
  "def __init__(self, radii, A2B=np.eye(4), resolution=20, c=None):\n        self.ellipsoid = o3d.geometry.TriangleMesh.create_sphere(\n            1.0, resolution)\n        vertices = np.asarray(self.ellipsoid.vertices)\n        vertices *= np.asarray(radii)[np.newaxis]\n        self.ellipsoid.vertices = o3d.utility.Vector3dVector(vertices)\n        self.ellipsoid.compute_vertex_normals()\n        if c is not None:\n            n_vertices = len(self.ellipsoid.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.ellipsoid.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.A2B = None\n        self.set_data(A2B)",
  "def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the ellipsoid.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.ellipsoid.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.ellipsoid.transform(self.A2B)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.ellipsoid]",
  "def __init__(self, height=1, radius=1, A2B=np.eye(4), resolution=20,\n                 c=None):\n        self.capsule = o3d.geometry.TriangleMesh.create_sphere(\n            radius, resolution)\n        vertices = np.asarray(self.capsule.vertices)\n        vertices[vertices[:, 2] < 0, 2] -= 0.5 * height\n        vertices[vertices[:, 2] > 0, 2] += 0.5 * height\n        self.capsule.vertices = o3d.utility.Vector3dVector(vertices)\n        self.capsule.compute_vertex_normals()\n        if c is not None:\n            n_vertices = len(self.capsule.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.capsule.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.A2B = None\n        self.set_data(A2B)",
  "def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Start of the capsule's line segment.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.capsule.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.capsule.transform(self.A2B)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.capsule]",
  "def __init__(self, height=1, radius=1, A2B=np.eye(4), resolution=20,\n                 c=None):\n        self.cone = o3d.geometry.TriangleMesh.create_cone(\n            radius, height, resolution)\n        self.cone.compute_vertex_normals()\n        if c is not None:\n            n_vertices = len(self.cone.vertices)\n            colors = np.zeros((n_vertices, 3))\n            colors[:] = c\n            self.cone.vertex_colors = o3d.utility.Vector3dVector(colors)\n        self.A2B = None\n        self.set_data(A2B)",
  "def set_data(self, A2B):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Center of the cone's circle.\n        \"\"\"\n        previous_A2B = self.A2B\n        if previous_A2B is None:\n            previous_A2B = np.eye(4)\n        self.A2B = A2B\n\n        self.cone.transform(\n            pt.invert_transform(previous_A2B, check=False))\n        self.cone.transform(self.A2B)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.cone]",
  "def __init__(self, normal=np.array([0.0, 0.0, 1.0]), d=None,\n                 point_in_plane=None, s=1.0, c=None):\n        self.triangles = np.array([\n            [0, 1, 2],\n            [1, 3, 2],\n            [2, 1, 0],\n            [2, 3, 1],\n        ])\n        vertices = np.zeros((4, 3))\n        self.plane = o3d.geometry.TriangleMesh(\n            o3d.utility.Vector3dVector(vertices),\n            o3d.utility.Vector3iVector(self.triangles))\n\n        self.set_data(normal, d, point_in_plane, s, c)",
  "def set_data(self, normal, d=None, point_in_plane=None, s=None,\n                 c=None):\n        \"\"\"Update data.\n\n        Parameters\n        ----------\n        normal : array-like, shape (3,)\n            Plane normal.\n\n        d : float, optional (default: None)\n            Distance to origin in Hesse normal form.\n\n        point_in_plane : array-like, shape (3,), optional (default: None)\n            Point in plane.\n\n        s : float, optional (default: 1)\n            Scaling of the plane that will be drawn.\n\n        c : array-like, shape (3,), optional (default: None)\n            Color.\n\n        Raises\n        ------\n        ValueError\n            If neither 'd' nor 'point_in_plane' is defined.\n        \"\"\"\n        normal = np.asarray(normal)\n        if point_in_plane is None:\n            if d is None:\n                raise ValueError(\n                    \"Either 'd' or 'point_in_plane' has to be defined!\")\n            point_in_plane = d * normal\n        else:\n            point_in_plane = np.asarray(point_in_plane)\n\n        x_axis, y_axis = pr.plane_basis_from_normal(normal)\n        vertices = np.array([\n            point_in_plane + s * x_axis + s * y_axis,\n            point_in_plane - s * x_axis + s * y_axis,\n            point_in_plane + s * x_axis - s * y_axis,\n            point_in_plane - s * x_axis - s * y_axis,\n        ])\n        self.plane.vertices = o3d.utility.Vector3dVector(vertices)\n        self.plane.compute_vertex_normals()\n        if c is not None:\n            self.plane.paint_uniform_color(c)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.plane]",
  "def __init__(self, M, cam2world=None, virtual_image_distance=1,\n                 sensor_size=(1920, 1080), strict_check=True):\n        self.M = None\n        self.cam2world = None\n        self.virtual_image_distance = None\n        self.sensor_size = None\n        self.strict_check = strict_check\n\n        self.line_set = o3d.geometry.LineSet()\n\n        if cam2world is None:\n            cam2world = np.eye(4)\n\n        self.set_data(M, cam2world, virtual_image_distance, sensor_size)",
  "def set_data(self, M=None, cam2world=None, virtual_image_distance=None,\n                 sensor_size=None):\n        \"\"\"Update camera parameters.\n\n        Parameters\n        ----------\n        M : array-like, shape (3, 3), optional (default: old value)\n            Intrinsic camera matrix that contains the focal lengths on the\n            diagonal and the center of the the image in the last column. It\n            does not matter whether values are given in meters or pixels as\n            long as the unit is the same as for the sensor size.\n\n        cam2world : array-like, shape (4, 4), optional (default: old value)\n            Transformation matrix of camera in world frame. We assume that\n            the position is given in meters.\n\n        virtual_image_distance : float, optional (default: old value)\n            Distance from pinhole to virtual image plane that will be\n            displayed. We assume that this distance is given in meters.\n            The unit has to be consistent with the unit of the position\n            in cam2world.\n\n        sensor_size : array-like, shape (2,), optional (default: old value)\n            Size of the image sensor: (width, height). It does not matter\n            whether values are given in meters or pixels as long as the\n            unit is the same as for the sensor size.\n        \"\"\"\n        if M is not None:\n            self.M = M\n        if cam2world is not None:\n            self.cam2world = pt.check_transform(\n                cam2world, strict_check=self.strict_check)\n        if virtual_image_distance is not None:\n            self.virtual_image_distance = virtual_image_distance\n        if sensor_size is not None:\n            self.sensor_size = sensor_size\n\n        camera_center_in_world = cam2world[:3, 3]\n        focal_length = np.mean(np.diag(M[:2, :2]))\n        sensor_corners_in_cam = np.array([\n            [0, 0, focal_length],\n            [0, sensor_size[1], focal_length],\n            [sensor_size[0], sensor_size[1], focal_length],\n            [sensor_size[0], 0, focal_length],\n        ])\n        sensor_corners_in_cam[:, 0] -= M[0, 2]\n        sensor_corners_in_cam[:, 1] -= M[1, 2]\n        sensor_corners_in_world = pt.transform(\n            cam2world, pt.vectors_to_points(sensor_corners_in_cam))[:, :3]\n        virtual_image_corners = (\n            virtual_image_distance / focal_length *\n            (sensor_corners_in_world - camera_center_in_world[np.newaxis]) +\n            camera_center_in_world[np.newaxis])\n\n        up = virtual_image_corners[0] - virtual_image_corners[1]\n        camera_line_points = np.vstack((\n            camera_center_in_world[:3],\n            virtual_image_corners[0],\n            virtual_image_corners[1],\n            virtual_image_corners[2],\n            virtual_image_corners[3],\n            virtual_image_corners[0] + 0.1 * up,\n            0.5 * (virtual_image_corners[0] +\n                   virtual_image_corners[3]) + 0.5 * up,\n            virtual_image_corners[3] + 0.1 * up\n        ))\n\n        self.line_set.points = o3d.utility.Vector3dVector(\n            camera_line_points)\n        self.line_set.lines = o3d.utility.Vector2iVector(\n            np.array([[0, 1], [0, 2], [0, 3], [0, 4],\n                      [1, 2], [2, 3], [3, 4], [4, 1],\n                      [5, 6], [6, 7], [7, 5]]))",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        return [self.line_set]",
  "def __init__(self, tm, frame, show_frames=False, show_connections=False,\n                 show_visuals=False, show_collision_objects=False,\n                 show_name=False, whitelist=None,\n                 convex_hull_of_collision_objects=False, s=1.0):\n        self.tm = tm\n        self.frame = frame\n        self.show_frames = show_frames\n        self.show_connections = show_connections\n        self.show_visuals = show_visuals\n        self.show_collision_objects = show_collision_objects\n        self.whitelist = whitelist\n        self.convex_hull_of_collision_objects = \\\n            convex_hull_of_collision_objects\n        self.s = s\n\n        if self.frame not in self.tm.nodes:\n            raise KeyError(\"Unknown frame '%s'\" % self.frame)\n\n        self.nodes = list(sorted(self.tm._whitelisted_nodes(whitelist)))\n\n        self.frames = {}\n        if self.show_frames:\n            for node in self.nodes:\n                try:\n                    node2frame = self.tm.get_transform(node, frame)\n                    name = node if show_name else None\n                    self.frames[node] = Frame(node2frame, name, self.s)\n                except KeyError:\n                    pass  # Frame is not connected to the reference frame\n\n        self.connections = {}\n        if self.show_connections:\n            for frame_names in self.tm.transforms.keys():\n                from_frame, to_frame = frame_names\n                if (from_frame in self.tm.nodes and\n                        to_frame in self.tm.nodes):\n                    try:\n                        self.tm.get_transform(from_frame, self.frame)\n                        self.tm.get_transform(to_frame, self.frame)\n                        self.connections[frame_names] = \\\n                            o3d.geometry.LineSet()\n                    except KeyError:\n                        pass  # Frame is not connected to reference frame\n\n        self.visuals = {}\n        if show_visuals and hasattr(self.tm, \"visuals\"):\n            self.visuals.update(_objects_to_artists(self.tm.visuals))\n        self.collision_objects = {}\n        if show_collision_objects and hasattr(\n                self.tm, \"collision_objects\"):\n            self.collision_objects.update(\n                _objects_to_artists(self.tm.collision_objects,\n                                    convex_hull_of_collision_objects))\n\n        self.set_data()",
  "def set_data(self):\n        \"\"\"Indicate that data has been updated.\"\"\"\n        if self.show_frames:\n            for node in self.nodes:\n                try:\n                    node2frame = self.tm.get_transform(node, self.frame)\n                    self.frames[node].set_data(node2frame)\n                except KeyError:\n                    pass  # Frame is not connected to the reference frame\n\n        if self.show_connections:\n            for frame_names in self.connections:\n                from_frame, to_frame = frame_names\n                try:\n                    from2ref = self.tm.get_transform(\n                        from_frame, self.frame)\n                    to2ref = self.tm.get_transform(to_frame, self.frame)\n\n                    points = np.vstack((from2ref[:3, 3], to2ref[:3, 3]))\n                    self.connections[frame_names].points = \\\n                        o3d.utility.Vector3dVector(points)\n                    self.connections[frame_names].lines = \\\n                        o3d.utility.Vector2iVector(np.array([[0, 1]]))\n                except KeyError:\n                    pass  # Frame is not connected to the reference frame\n\n        for frame, obj in self.visuals.items():\n            A2B = self.tm.get_transform(frame, self.frame)\n            obj.set_data(A2B)\n\n        for frame, obj in self.collision_objects.items():\n            A2B = self.tm.get_transform(frame, self.frame)\n            obj.set_data(A2B)",
  "def geometries(self):\n        \"\"\"Expose geometries.\n\n        Returns\n        -------\n        geometries : list\n            List of geometries that can be added to the visualizer.\n        \"\"\"\n        geometries = []\n        if self.show_frames:\n            for f in self.frames.values():\n                geometries += f.geometries\n        if self.show_connections:\n            geometries += list(self.connections.values())\n        for obj in self.visuals.values():\n            geometries += obj.geometries\n        for obj in self.collision_objects.values():\n            geometries += obj.geometries\n        return geometries",
  "class Figure:\n    \"\"\"The top level container for all the plot elements.\n\n    You can close the visualizer with the keys `escape` or `q`.\n\n    Parameters\n    ----------\n    window_name : str, optional (default: Open3D)\n        Window title name.\n\n    width : int, optional (default: 1920)\n        Width of the window.\n\n    height : int, optional (default: 1080)\n        Height of the window.\n\n    with_key_callbacks : bool, optional (default: False)\n        Creates a visualizer that allows to register callbacks\n        for keys.\n    \"\"\"\n    def __init__(self, window_name=\"Open3D\", width=1920, height=1080,\n                 with_key_callbacks=False):\n        if with_key_callbacks:\n            self.visualizer = o3d.visualization.VisualizerWithKeyCallback()\n        else:\n            self.visualizer = o3d.visualization.Visualizer()\n        self.visualizer.create_window(\n            window_name=window_name, width=width, height=height)\n\n    def add_geometry(self, geometry):\n        \"\"\"Add geometry to visualizer.\n\n        Parameters\n        ----------\n        geometry : Geometry\n            Open3D geometry.\n        \"\"\"\n        self.visualizer.add_geometry(geometry)\n\n    def _remove_geometry(self, geometry):\n        \"\"\"Remove geometry to visualizer.\n\n        .. warning::\n\n            This function is not public because the interface of the\n            underlying visualizer might change in the future causing the\n            signature of this function to change as well.\n\n        Parameters\n        ----------\n        geometry : Geometry\n            Open3D geometry.\n        \"\"\"\n        self.visualizer.remove_geometry(geometry)\n\n    def update_geometry(self, geometry):\n        \"\"\"Indicate that geometry has been updated.\n\n        Parameters\n        ----------\n        geometry : Geometry\n            Open3D geometry.\n        \"\"\"\n        self.visualizer.update_geometry(geometry)\n\n    def remove_artist(self, artist):\n        \"\"\"Remove artist from visualizer.\n\n        Parameters\n        ----------\n        artist : Artist\n            Artist that should be removed from this figure.\n        \"\"\"\n        for g in artist.geometries:\n            self._remove_geometry(g)\n\n    def set_line_width(self, line_width):\n        \"\"\"Set render option line width.\n\n        Note: this feature does not work in Open3D's visualizer at the\n        moment.\n\n        Parameters\n        ----------\n        line_width : float\n            Line width.\n        \"\"\"\n        self.visualizer.get_render_option().line_width = line_width\n        self.visualizer.update_renderer()\n\n    def set_zoom(self, zoom):\n        \"\"\"Set zoom.\n\n        Parameters\n        ----------\n        zoom : float\n            Zoom of the visualizer.\n        \"\"\"\n        self.visualizer.get_view_control().set_zoom(zoom)\n\n    def animate(self, callback, n_frames, loop=False, fargs=()):\n        \"\"\"Make animation with callback.\n\n        Parameters\n        ----------\n        callback : callable\n            Callback that will be called in a loop to update geometries.\n            The first input of the function will be the current frame\n            index from [0, `n_frames`). Further arguments can be given as\n            `fargs`. The function should return one artist object or a\n            list of artists that have been updated.\n\n        n_frames : int\n            Total number of frames.\n\n        loop : bool, optional (default: False)\n            Run callback in an infinite loop.\n\n        fargs : list, optional (default: [])\n            Arguments that will be passed to the callback.\n\n        Raises\n        ------\n        RuntimeError\n            When callback does not return any artists\n        \"\"\"\n        initialized = False\n        window_open = True\n        while window_open and (loop or not initialized):\n            for i in range(n_frames):\n                drawn_artists = callback(i, *fargs)\n\n                if drawn_artists is None:\n                    raise RuntimeError(\n                        \"The animation function must return a \"\n                        \"sequence of Artist objects.\")\n                try:\n                    drawn_artists = [a for a in drawn_artists]\n                except TypeError:\n                    drawn_artists = [drawn_artists]\n\n                for a in drawn_artists:\n                    for geometry in a.geometries:\n                        self.update_geometry(geometry)\n\n                window_open = self.visualizer.poll_events()\n                if not window_open:\n                    break\n                self.visualizer.update_renderer()\n            initialized = True\n\n    def view_init(self, azim=-60, elev=30):\n        \"\"\"Set the elevation and azimuth of the axes.\n\n        Parameters\n        ----------\n        azim : float, optional (default: -60)\n            Azimuth angle in the x,y plane in degrees.\n\n        elev : float, optional (default: 30)\n            Elevation angle in the z plane.\n        \"\"\"\n        vc = self.visualizer.get_view_control()\n        pcp = vc.convert_to_pinhole_camera_parameters()\n        distance = np.linalg.norm(pcp.extrinsic[:3, 3])\n        R_azim_elev_0_world2camera = np.array([\n            [0, 1, 0],\n            [0, 0, -1],\n            [-1, 0, 0]])\n        R_azim_elev_0_camera2world = R_azim_elev_0_world2camera.T\n        # azimuth and elevation are defined in world frame\n        R_azim = pr.active_matrix_from_angle(2, np.deg2rad(azim))\n        R_elev = pr.active_matrix_from_angle(1, np.deg2rad(-elev))\n        R_elev_azim_camera2world = R_azim.dot(R_elev).dot(\n            R_azim_elev_0_camera2world)\n        pcp.extrinsic = pt.transform_from(  # world2camera\n            R=R_elev_azim_camera2world.T,\n            p=[0, 0, distance])\n        vc.convert_from_pinhole_camera_parameters(pcp)\n\n    def plot(self, P, c=(0, 0, 0)):\n        \"\"\"Plot line.\n\n        Parameters\n        ----------\n        P : array-like, shape (n_points, 3)\n            Points of which the line consists.\n\n        c : array-like, shape (n_points - 1, 3) or (3,), optional (default: black)\n            Color can be given as individual colors per line segment or\n            as one color for each segment. A color is represented by 3\n            values between 0 and 1 indicate representing red, green, and\n            blue respectively.\n\n        Returns\n        -------\n        line : Line3D\n            New line.\n        \"\"\"\n        line3d = Line3D(P, c)\n        line3d.add_artist(self)\n        return line3d\n\n    def scatter(self, P, s=0.05, c=None):\n        \"\"\"Plot collection of points.\n\n        Parameters\n        ----------\n        P : array, shape (n_points, 3)\n            Points\n\n        s : float, optional (default: 0.05)\n            Scaling of the spheres that will be drawn.\n\n        c : array-like, shape (3,) or (n_points, 3), optional (default: black)\n            A color is represented by 3 values between 0 and 1 indicate\n            representing red, green, and blue respectively.\n\n        Returns\n        -------\n        point_collection : PointCollection3D\n            New point collection.\n        \"\"\"\n        point_collection = PointCollection3D(P, s, c)\n        point_collection.add_artist(self)\n        return point_collection\n\n    def plot_vector(self, start=np.zeros(3), direction=np.array([1, 0, 0]),\n                    c=(0, 0, 0)):\n        \"\"\"Plot vector.\n\n        Parameters\n        ----------\n        start : array-like, shape (3,), optional (default: [0, 0, 0])\n            Start of the vector\n\n        direction : array-like, shape (3,), optional (default: [1, 0, 0])\n            Direction of the vector\n\n        c : array-like, shape (3,), optional (default: black)\n            A color is represented by 3 values between 0 and 1 indicate\n            representing red, green, and blue respectively.\n\n        Returns\n        -------\n        vector : Vector3D\n            New vector.\n        \"\"\"\n        vector3d = Vector3D(start, direction, c)\n        vector3d.add_artist(self)\n        return vector3d\n\n    def plot_basis(self, R=None, p=np.zeros(3), s=1.0, strict_check=True):\n        \"\"\"Plot basis.\n\n        Parameters\n        ----------\n        R : array-like, shape (3, 3), optional (default: I)\n            Rotation matrix, each column contains a basis vector\n\n        p : array-like, shape (3,), optional (default: [0, 0, 0])\n            Offset from the origin\n\n        s : float, optional (default: 1)\n            Scaling of the frame that will be drawn\n\n        strict_check : bool, optional (default: True)\n            Raise a ValueError if the rotation matrix is not numerically\n            close enough to a real rotation matrix. Otherwise we print a\n            warning.\n\n        Returns\n        -------\n        Frame : frame\n            New frame.\n        \"\"\"\n        if R is None:\n            R = np.eye(3)\n        R = pr.check_matrix(R, strict_check=strict_check)\n\n        frame = Frame(pt.transform_from(R=R, p=p), s=s)\n        frame.add_artist(self)\n\n        return frame\n\n    def plot_transform(self, A2B=None, s=1.0, name=None, strict_check=True):\n        \"\"\"Plot coordinate frame.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        s : float, optional (default: 1)\n            Length of basis vectors\n\n        name : str, optional (default: None)\n            Name of the frame\n\n        strict_check : bool, optional (default: True)\n            Raise a ValueError if the transformation matrix is not\n            numerically close enough to a real transformation matrix.\n            Otherwise we print a warning.\n\n        Returns\n        -------\n        Frame : frame\n            New frame.\n        \"\"\"\n        if A2B is None:\n            A2B = np.eye(4)\n        A2B = pt.check_transform(A2B, strict_check=strict_check)\n\n        frame = Frame(A2B, name, s)\n        frame.add_artist(self)\n\n        return frame\n\n    def plot_trajectory(self, P, n_frames=10, s=1.0, c=(0, 0, 0)):\n        \"\"\"Trajectory of poses.\n\n        Parameters\n        ----------\n        P : array-like, shape (n_steps, 7), optional (default: None)\n            Sequence of poses represented by positions and quaternions in\n            the order (x, y, z, w, vx, vy, vz) for each step\n\n        n_frames : int, optional (default: 10)\n            Number of frames that should be plotted to indicate the\n            rotation\n\n        s : float, optional (default: 1)\n            Scaling of the frames that will be drawn\n\n        c : array-like, shape (3,), optional (default: black)\n            A color is represented by 3 values between 0 and 1 indicate\n            representing red, green, and blue respectively.\n\n        Returns\n        -------\n        trajectory : Trajectory\n            New trajectory.\n        \"\"\"\n        H = ptr.matrices_from_pos_quat(P)\n        trajectory = Trajectory(H, n_frames, s, c)\n        trajectory.add_artist(self)\n        return trajectory\n\n    def plot_sphere(self, radius=1.0, A2B=np.eye(4), resolution=20, c=None):\n        \"\"\"Plot sphere.\n\n        Parameters\n        ----------\n        radius : float, optional (default: 1)\n            Radius of the sphere\n\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        resolution : int, optional (default: 20)\n            The resolution of the sphere. The longitudes will be split into\n            resolution segments (i.e. there are resolution + 1 latitude\n            lines including the north and south pole). The latitudes will\n            be split into 2 * resolution segments (i.e. there are\n            2 * resolution longitude lines.)\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        sphere : Sphere\n            New sphere.\n        \"\"\"\n        sphere = Sphere(radius, A2B, resolution, c)\n        sphere.add_artist(self)\n        return sphere\n\n    def plot_box(self, size=np.ones(3), A2B=np.eye(4), c=None):\n        \"\"\"Plot box.\n\n        Parameters\n        ----------\n        size : array-like, shape (3,), optional (default: [1, 1, 1])\n            Size of the box per dimension\n\n        A2B : array-like, shape (4, 4), optional (default: I)\n            Center of the box\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        box : Box\n            New box.\n        \"\"\"\n        box = Box(size, A2B, c)\n        box.add_artist(self)\n        return box\n\n    def plot_cylinder(self, length=2.0, radius=1.0, A2B=np.eye(4),\n                      resolution=20, split=4, c=None):\n        \"\"\"Plot cylinder.\n\n        Parameters\n        ----------\n        length : float, optional (default: 1)\n            Length of the cylinder.\n\n        radius : float, optional (default: 1)\n            Radius of the cylinder.\n\n        A2B : array-like, shape (4, 4)\n            Pose of the cylinder. The position corresponds to the center of the\n            line segment and the z-axis to the direction of the line segment.\n\n        resolution : int, optional (default: 20)\n            The circle will be split into resolution segments\n\n        split : int, optional (default: 4)\n            The height will be split into split segments\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        cylinder : Cylinder\n            New cylinder.\n        \"\"\"\n        cylinder = Cylinder(length, radius, A2B, resolution, split, c)\n        cylinder.add_artist(self)\n        return cylinder\n\n    def plot_mesh(self, filename, A2B=np.eye(4), s=np.ones(3), c=None):\n        \"\"\"Plot mesh.\n\n        Parameters\n        ----------\n        filename : str\n            Path to mesh file\n\n        A2B : array-like, shape (4, 4)\n            Center of the mesh\n\n        s : array-like, shape (3,), optional (default: [1, 1, 1])\n            Scaling of the mesh that will be drawn\n\n        c : array-like, shape (n_vertices, 3) or (3,), optional (default: None)\n            Color(s)\n\n        Returns\n        -------\n        mesh : Mesh\n            New mesh.\n        \"\"\"\n        mesh = Mesh(filename, A2B, s, c)\n        mesh.add_artist(self)\n        return mesh\n\n    def plot_ellipsoid(self, radii=np.ones(3), A2B=np.eye(4), resolution=20,\n                       c=None):\n        \"\"\"Plot ellipsoid.\n\n        Parameters\n        ----------\n        radii : array-like, shape (3,)\n            Radii along the x-axis, y-axis, and z-axis of the ellipsoid.\n\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        resolution : int, optional (default: 20)\n            The resolution of the ellipsoid. The longitudes will be split into\n            resolution segments (i.e. there are resolution + 1 latitude\n            lines including the north and south pole). The latitudes will\n            be split into 2 * resolution segments (i.e. there are\n            2 * resolution longitude lines.)\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        ellipsoid : Ellipsoid\n            New ellipsoid.\n        \"\"\"\n        ellipsoid = Ellipsoid(radii, A2B, resolution, c)\n        ellipsoid.add_artist(self)\n        return ellipsoid\n\n    def plot_capsule(self, height=1, radius=1, A2B=np.eye(4), resolution=20,\n                     c=None):\n        \"\"\"Plot capsule.\n\n        A capsule is the volume covered by a sphere moving along a line\n        segment.\n\n        Parameters\n        ----------\n        height : float, optional (default: 1)\n            Height of the capsule along its z-axis.\n\n        radius : float, optional (default: 1)\n            Radius of the capsule.\n\n        A2B : array-like, shape (4, 4)\n            Pose of the capsule. The position corresponds to the center of the\n            line segment and the z-axis to the direction of the line segment.\n\n        resolution : int, optional (default: 20)\n            The resolution of the capsule. The longitudes will be split into\n            resolution segments (i.e. there are resolution + 1 latitude lines\n            including the north and south pole). The latitudes will be split\n            into 2 * resolution segments (i.e. there are 2 * resolution\n            longitude lines.)\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        capsule : Capsule\n            New capsule.\n        \"\"\"\n        capsule = Capsule(height, radius, A2B, resolution, c)\n        capsule.add_artist(self)\n        return capsule\n\n    def plot_cone(self, height=1, radius=1, A2B=np.eye(4), resolution=20,\n                  c=None):\n        \"\"\"Plot cone.\n\n        Parameters\n        ----------\n        height : float, optional (default: 1)\n            Height of the cone along its z-axis.\n\n        radius : float, optional (default: 1)\n            Radius of the cone.\n\n        A2B : array-like, shape (4, 4)\n            Pose of the cone.\n\n        resolution : int, optional (default: 20)\n            The circle will be split into resolution segments.\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        cone : Cone\n            New cone.\n        \"\"\"\n        cone = Cone(height, radius, A2B, resolution, c)\n        cone.add_artist(self)\n        return cone\n\n    def plot_plane(self, normal=np.array([0.0, 0.0, 1.0]), d=None,\n                   point_in_plane=None, s=1.0, c=None):\n        \"\"\"Plot plane.\n\n        Parameters\n        ----------\n        normal : array-like, shape (3,), optional (default: [0, 0, 1])\n            Plane normal.\n\n        d : float, optional (default: None)\n            Distance to origin in Hesse normal form.\n\n        point_in_plane : array-like, shape (3,), optional (default: None)\n            Point in plane.\n\n        s : float, optional (default: 1)\n            Scaling of the plane that will be drawn.\n\n        c : array-like, shape (3,), optional (default: None)\n            Color.\n\n        Returns\n        -------\n        plane : Plane\n            New plane.\n        \"\"\"\n        plane = Plane(normal, d, point_in_plane, s, c)\n        plane.add_artist(self)\n        return plane\n\n    def plot_graph(\n            self, tm, frame, show_frames=False, show_connections=False,\n            show_visuals=False, show_collision_objects=False,\n            show_name=False, whitelist=None,\n            convex_hull_of_collision_objects=False, s=1.0):\n        \"\"\"Plot graph of connected frames.\n\n        Parameters\n        ----------\n        tm : TransformManager\n            Representation of the graph\n\n        frame : str\n            Name of the base frame in which the graph will be displayed\n\n        show_frames : bool, optional (default: False)\n            Show coordinate frames\n\n        show_connections : bool, optional (default: False)\n            Draw lines between frames of the graph\n\n        show_visuals : bool, optional (default: False)\n            Show visuals that are stored in the graph\n\n        show_collision_objects : bool, optional (default: False)\n            Show collision objects that are stored in the graph\n\n        show_name : bool, optional (default: False)\n            Show names of frames\n\n        whitelist : list, optional (default: all)\n            List of frames that should be displayed\n\n        convex_hull_of_collision_objects : bool, optional (default: False)\n            Show convex hull of collision objects.\n\n        s : float, optional (default: 1)\n            Scaling of the frames that will be drawn\n\n        Returns\n        -------\n        graph : Graph\n            New graph.\n        \"\"\"\n        graph = Graph(tm, frame, show_frames, show_connections,\n                      show_visuals, show_collision_objects, show_name,\n                      whitelist, convex_hull_of_collision_objects, s)\n        graph.add_artist(self)\n        return graph\n\n    def plot_camera(self, M, cam2world=None, virtual_image_distance=1,\n                    sensor_size=(1920, 1080), strict_check=True):\n        \"\"\"Plot camera in world coordinates.\n\n        This function is inspired by Blender's camera visualization. It will\n        show the camera center, a virtual image plane, and the top of the\n        virtual image plane.\n\n        Parameters\n        ----------\n        M : array-like, shape (3, 3)\n            Intrinsic camera matrix that contains the focal lengths on the\n            diagonal and the center of the the image in the last column. It\n            does not matter whether values are given in meters or pixels as\n            long as the unit is the same as for the sensor size.\n\n        cam2world : array-like, shape (4, 4), optional (default: I)\n            Transformation matrix of camera in world frame. We assume that the\n            position is given in meters.\n\n        virtual_image_distance : float, optional (default: 1)\n            Distance from pinhole to virtual image plane that will be\n            displayed. We assume that this distance is given in meters. The\n            unit has to be consistent with the unit of the position in\n            cam2world.\n\n        sensor_size : array-like, shape (2,), optional (default: [1920, 1080])\n            Size of the image sensor: (width, height). It does not matter\n            whether values are given in meters or pixels as long as the unit is\n            the same as for the sensor size.\n\n        strict_check : bool, optional (default: True)\n            Raise a ValueError if the transformation matrix is not numerically\n            close enough to a real transformation matrix. Otherwise we print a\n            warning.\n\n        Returns\n        -------\n        camera : Camera\n            New camera.\n        \"\"\"\n        camera = Camera(M, cam2world, virtual_image_distance, sensor_size,\n                        strict_check)\n        camera.add_artist(self)\n        return camera\n\n    def save_image(self, filename):\n        \"\"\"Save rendered image to file.\n\n        Parameters\n        ----------\n        filename : str\n            Path to file in which the rendered image should be stored\n        \"\"\"\n        self.visualizer.capture_screen_image(filename, True)\n\n    def show(self):\n        \"\"\"Display the figure window.\"\"\"\n        self.visualizer.run()\n        self.visualizer.destroy_window()",
  "def figure(window_name=\"Open3D\", width=1920, height=1080,\n           with_key_callbacks=False):\n    \"\"\"Create a new figure.\n\n    Parameters\n    ----------\n    window_name : str, optional (default: Open3D)\n        Window title name.\n\n    width : int, optional (default: 1920)\n        Width of the window.\n\n    height : int, optional (default: 1080)\n        Height of the window.\n\n    with_key_callbacks : bool, optional (default: False)\n        Creates a visualizer that allows to register callbacks\n        for keys.\n\n    Returns\n    -------\n    figure : Figure\n        New figure.\n    \"\"\"\n    return Figure(window_name, width, height, with_key_callbacks)",
  "def __init__(self, window_name=\"Open3D\", width=1920, height=1080,\n                 with_key_callbacks=False):\n        if with_key_callbacks:\n            self.visualizer = o3d.visualization.VisualizerWithKeyCallback()\n        else:\n            self.visualizer = o3d.visualization.Visualizer()\n        self.visualizer.create_window(\n            window_name=window_name, width=width, height=height)",
  "def add_geometry(self, geometry):\n        \"\"\"Add geometry to visualizer.\n\n        Parameters\n        ----------\n        geometry : Geometry\n            Open3D geometry.\n        \"\"\"\n        self.visualizer.add_geometry(geometry)",
  "def _remove_geometry(self, geometry):\n        \"\"\"Remove geometry to visualizer.\n\n        .. warning::\n\n            This function is not public because the interface of the\n            underlying visualizer might change in the future causing the\n            signature of this function to change as well.\n\n        Parameters\n        ----------\n        geometry : Geometry\n            Open3D geometry.\n        \"\"\"\n        self.visualizer.remove_geometry(geometry)",
  "def update_geometry(self, geometry):\n        \"\"\"Indicate that geometry has been updated.\n\n        Parameters\n        ----------\n        geometry : Geometry\n            Open3D geometry.\n        \"\"\"\n        self.visualizer.update_geometry(geometry)",
  "def remove_artist(self, artist):\n        \"\"\"Remove artist from visualizer.\n\n        Parameters\n        ----------\n        artist : Artist\n            Artist that should be removed from this figure.\n        \"\"\"\n        for g in artist.geometries:\n            self._remove_geometry(g)",
  "def set_line_width(self, line_width):\n        \"\"\"Set render option line width.\n\n        Note: this feature does not work in Open3D's visualizer at the\n        moment.\n\n        Parameters\n        ----------\n        line_width : float\n            Line width.\n        \"\"\"\n        self.visualizer.get_render_option().line_width = line_width\n        self.visualizer.update_renderer()",
  "def set_zoom(self, zoom):\n        \"\"\"Set zoom.\n\n        Parameters\n        ----------\n        zoom : float\n            Zoom of the visualizer.\n        \"\"\"\n        self.visualizer.get_view_control().set_zoom(zoom)",
  "def animate(self, callback, n_frames, loop=False, fargs=()):\n        \"\"\"Make animation with callback.\n\n        Parameters\n        ----------\n        callback : callable\n            Callback that will be called in a loop to update geometries.\n            The first input of the function will be the current frame\n            index from [0, `n_frames`). Further arguments can be given as\n            `fargs`. The function should return one artist object or a\n            list of artists that have been updated.\n\n        n_frames : int\n            Total number of frames.\n\n        loop : bool, optional (default: False)\n            Run callback in an infinite loop.\n\n        fargs : list, optional (default: [])\n            Arguments that will be passed to the callback.\n\n        Raises\n        ------\n        RuntimeError\n            When callback does not return any artists\n        \"\"\"\n        initialized = False\n        window_open = True\n        while window_open and (loop or not initialized):\n            for i in range(n_frames):\n                drawn_artists = callback(i, *fargs)\n\n                if drawn_artists is None:\n                    raise RuntimeError(\n                        \"The animation function must return a \"\n                        \"sequence of Artist objects.\")\n                try:\n                    drawn_artists = [a for a in drawn_artists]\n                except TypeError:\n                    drawn_artists = [drawn_artists]\n\n                for a in drawn_artists:\n                    for geometry in a.geometries:\n                        self.update_geometry(geometry)\n\n                window_open = self.visualizer.poll_events()\n                if not window_open:\n                    break\n                self.visualizer.update_renderer()\n            initialized = True",
  "def view_init(self, azim=-60, elev=30):\n        \"\"\"Set the elevation and azimuth of the axes.\n\n        Parameters\n        ----------\n        azim : float, optional (default: -60)\n            Azimuth angle in the x,y plane in degrees.\n\n        elev : float, optional (default: 30)\n            Elevation angle in the z plane.\n        \"\"\"\n        vc = self.visualizer.get_view_control()\n        pcp = vc.convert_to_pinhole_camera_parameters()\n        distance = np.linalg.norm(pcp.extrinsic[:3, 3])\n        R_azim_elev_0_world2camera = np.array([\n            [0, 1, 0],\n            [0, 0, -1],\n            [-1, 0, 0]])\n        R_azim_elev_0_camera2world = R_azim_elev_0_world2camera.T\n        # azimuth and elevation are defined in world frame\n        R_azim = pr.active_matrix_from_angle(2, np.deg2rad(azim))\n        R_elev = pr.active_matrix_from_angle(1, np.deg2rad(-elev))\n        R_elev_azim_camera2world = R_azim.dot(R_elev).dot(\n            R_azim_elev_0_camera2world)\n        pcp.extrinsic = pt.transform_from(  # world2camera\n            R=R_elev_azim_camera2world.T,\n            p=[0, 0, distance])\n        vc.convert_from_pinhole_camera_parameters(pcp)",
  "def plot(self, P, c=(0, 0, 0)):\n        \"\"\"Plot line.\n\n        Parameters\n        ----------\n        P : array-like, shape (n_points, 3)\n            Points of which the line consists.\n\n        c : array-like, shape (n_points - 1, 3) or (3,), optional (default: black)\n            Color can be given as individual colors per line segment or\n            as one color for each segment. A color is represented by 3\n            values between 0 and 1 indicate representing red, green, and\n            blue respectively.\n\n        Returns\n        -------\n        line : Line3D\n            New line.\n        \"\"\"\n        line3d = Line3D(P, c)\n        line3d.add_artist(self)\n        return line3d",
  "def scatter(self, P, s=0.05, c=None):\n        \"\"\"Plot collection of points.\n\n        Parameters\n        ----------\n        P : array, shape (n_points, 3)\n            Points\n\n        s : float, optional (default: 0.05)\n            Scaling of the spheres that will be drawn.\n\n        c : array-like, shape (3,) or (n_points, 3), optional (default: black)\n            A color is represented by 3 values between 0 and 1 indicate\n            representing red, green, and blue respectively.\n\n        Returns\n        -------\n        point_collection : PointCollection3D\n            New point collection.\n        \"\"\"\n        point_collection = PointCollection3D(P, s, c)\n        point_collection.add_artist(self)\n        return point_collection",
  "def plot_vector(self, start=np.zeros(3), direction=np.array([1, 0, 0]),\n                    c=(0, 0, 0)):\n        \"\"\"Plot vector.\n\n        Parameters\n        ----------\n        start : array-like, shape (3,), optional (default: [0, 0, 0])\n            Start of the vector\n\n        direction : array-like, shape (3,), optional (default: [1, 0, 0])\n            Direction of the vector\n\n        c : array-like, shape (3,), optional (default: black)\n            A color is represented by 3 values between 0 and 1 indicate\n            representing red, green, and blue respectively.\n\n        Returns\n        -------\n        vector : Vector3D\n            New vector.\n        \"\"\"\n        vector3d = Vector3D(start, direction, c)\n        vector3d.add_artist(self)\n        return vector3d",
  "def plot_basis(self, R=None, p=np.zeros(3), s=1.0, strict_check=True):\n        \"\"\"Plot basis.\n\n        Parameters\n        ----------\n        R : array-like, shape (3, 3), optional (default: I)\n            Rotation matrix, each column contains a basis vector\n\n        p : array-like, shape (3,), optional (default: [0, 0, 0])\n            Offset from the origin\n\n        s : float, optional (default: 1)\n            Scaling of the frame that will be drawn\n\n        strict_check : bool, optional (default: True)\n            Raise a ValueError if the rotation matrix is not numerically\n            close enough to a real rotation matrix. Otherwise we print a\n            warning.\n\n        Returns\n        -------\n        Frame : frame\n            New frame.\n        \"\"\"\n        if R is None:\n            R = np.eye(3)\n        R = pr.check_matrix(R, strict_check=strict_check)\n\n        frame = Frame(pt.transform_from(R=R, p=p), s=s)\n        frame.add_artist(self)\n\n        return frame",
  "def plot_transform(self, A2B=None, s=1.0, name=None, strict_check=True):\n        \"\"\"Plot coordinate frame.\n\n        Parameters\n        ----------\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        s : float, optional (default: 1)\n            Length of basis vectors\n\n        name : str, optional (default: None)\n            Name of the frame\n\n        strict_check : bool, optional (default: True)\n            Raise a ValueError if the transformation matrix is not\n            numerically close enough to a real transformation matrix.\n            Otherwise we print a warning.\n\n        Returns\n        -------\n        Frame : frame\n            New frame.\n        \"\"\"\n        if A2B is None:\n            A2B = np.eye(4)\n        A2B = pt.check_transform(A2B, strict_check=strict_check)\n\n        frame = Frame(A2B, name, s)\n        frame.add_artist(self)\n\n        return frame",
  "def plot_trajectory(self, P, n_frames=10, s=1.0, c=(0, 0, 0)):\n        \"\"\"Trajectory of poses.\n\n        Parameters\n        ----------\n        P : array-like, shape (n_steps, 7), optional (default: None)\n            Sequence of poses represented by positions and quaternions in\n            the order (x, y, z, w, vx, vy, vz) for each step\n\n        n_frames : int, optional (default: 10)\n            Number of frames that should be plotted to indicate the\n            rotation\n\n        s : float, optional (default: 1)\n            Scaling of the frames that will be drawn\n\n        c : array-like, shape (3,), optional (default: black)\n            A color is represented by 3 values between 0 and 1 indicate\n            representing red, green, and blue respectively.\n\n        Returns\n        -------\n        trajectory : Trajectory\n            New trajectory.\n        \"\"\"\n        H = ptr.matrices_from_pos_quat(P)\n        trajectory = Trajectory(H, n_frames, s, c)\n        trajectory.add_artist(self)\n        return trajectory",
  "def plot_sphere(self, radius=1.0, A2B=np.eye(4), resolution=20, c=None):\n        \"\"\"Plot sphere.\n\n        Parameters\n        ----------\n        radius : float, optional (default: 1)\n            Radius of the sphere\n\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        resolution : int, optional (default: 20)\n            The resolution of the sphere. The longitudes will be split into\n            resolution segments (i.e. there are resolution + 1 latitude\n            lines including the north and south pole). The latitudes will\n            be split into 2 * resolution segments (i.e. there are\n            2 * resolution longitude lines.)\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        sphere : Sphere\n            New sphere.\n        \"\"\"\n        sphere = Sphere(radius, A2B, resolution, c)\n        sphere.add_artist(self)\n        return sphere",
  "def plot_box(self, size=np.ones(3), A2B=np.eye(4), c=None):\n        \"\"\"Plot box.\n\n        Parameters\n        ----------\n        size : array-like, shape (3,), optional (default: [1, 1, 1])\n            Size of the box per dimension\n\n        A2B : array-like, shape (4, 4), optional (default: I)\n            Center of the box\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        box : Box\n            New box.\n        \"\"\"\n        box = Box(size, A2B, c)\n        box.add_artist(self)\n        return box",
  "def plot_cylinder(self, length=2.0, radius=1.0, A2B=np.eye(4),\n                      resolution=20, split=4, c=None):\n        \"\"\"Plot cylinder.\n\n        Parameters\n        ----------\n        length : float, optional (default: 1)\n            Length of the cylinder.\n\n        radius : float, optional (default: 1)\n            Radius of the cylinder.\n\n        A2B : array-like, shape (4, 4)\n            Pose of the cylinder. The position corresponds to the center of the\n            line segment and the z-axis to the direction of the line segment.\n\n        resolution : int, optional (default: 20)\n            The circle will be split into resolution segments\n\n        split : int, optional (default: 4)\n            The height will be split into split segments\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        cylinder : Cylinder\n            New cylinder.\n        \"\"\"\n        cylinder = Cylinder(length, radius, A2B, resolution, split, c)\n        cylinder.add_artist(self)\n        return cylinder",
  "def plot_mesh(self, filename, A2B=np.eye(4), s=np.ones(3), c=None):\n        \"\"\"Plot mesh.\n\n        Parameters\n        ----------\n        filename : str\n            Path to mesh file\n\n        A2B : array-like, shape (4, 4)\n            Center of the mesh\n\n        s : array-like, shape (3,), optional (default: [1, 1, 1])\n            Scaling of the mesh that will be drawn\n\n        c : array-like, shape (n_vertices, 3) or (3,), optional (default: None)\n            Color(s)\n\n        Returns\n        -------\n        mesh : Mesh\n            New mesh.\n        \"\"\"\n        mesh = Mesh(filename, A2B, s, c)\n        mesh.add_artist(self)\n        return mesh",
  "def plot_ellipsoid(self, radii=np.ones(3), A2B=np.eye(4), resolution=20,\n                       c=None):\n        \"\"\"Plot ellipsoid.\n\n        Parameters\n        ----------\n        radii : array-like, shape (3,)\n            Radii along the x-axis, y-axis, and z-axis of the ellipsoid.\n\n        A2B : array-like, shape (4, 4)\n            Transform from frame A to frame B\n\n        resolution : int, optional (default: 20)\n            The resolution of the ellipsoid. The longitudes will be split into\n            resolution segments (i.e. there are resolution + 1 latitude\n            lines including the north and south pole). The latitudes will\n            be split into 2 * resolution segments (i.e. there are\n            2 * resolution longitude lines.)\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        ellipsoid : Ellipsoid\n            New ellipsoid.\n        \"\"\"\n        ellipsoid = Ellipsoid(radii, A2B, resolution, c)\n        ellipsoid.add_artist(self)\n        return ellipsoid",
  "def plot_capsule(self, height=1, radius=1, A2B=np.eye(4), resolution=20,\n                     c=None):\n        \"\"\"Plot capsule.\n\n        A capsule is the volume covered by a sphere moving along a line\n        segment.\n\n        Parameters\n        ----------\n        height : float, optional (default: 1)\n            Height of the capsule along its z-axis.\n\n        radius : float, optional (default: 1)\n            Radius of the capsule.\n\n        A2B : array-like, shape (4, 4)\n            Pose of the capsule. The position corresponds to the center of the\n            line segment and the z-axis to the direction of the line segment.\n\n        resolution : int, optional (default: 20)\n            The resolution of the capsule. The longitudes will be split into\n            resolution segments (i.e. there are resolution + 1 latitude lines\n            including the north and south pole). The latitudes will be split\n            into 2 * resolution segments (i.e. there are 2 * resolution\n            longitude lines.)\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        capsule : Capsule\n            New capsule.\n        \"\"\"\n        capsule = Capsule(height, radius, A2B, resolution, c)\n        capsule.add_artist(self)\n        return capsule",
  "def plot_cone(self, height=1, radius=1, A2B=np.eye(4), resolution=20,\n                  c=None):\n        \"\"\"Plot cone.\n\n        Parameters\n        ----------\n        height : float, optional (default: 1)\n            Height of the cone along its z-axis.\n\n        radius : float, optional (default: 1)\n            Radius of the cone.\n\n        A2B : array-like, shape (4, 4)\n            Pose of the cone.\n\n        resolution : int, optional (default: 20)\n            The circle will be split into resolution segments.\n\n        c : array-like, shape (3,), optional (default: None)\n            Color\n\n        Returns\n        -------\n        cone : Cone\n            New cone.\n        \"\"\"\n        cone = Cone(height, radius, A2B, resolution, c)\n        cone.add_artist(self)\n        return cone",
  "def plot_plane(self, normal=np.array([0.0, 0.0, 1.0]), d=None,\n                   point_in_plane=None, s=1.0, c=None):\n        \"\"\"Plot plane.\n\n        Parameters\n        ----------\n        normal : array-like, shape (3,), optional (default: [0, 0, 1])\n            Plane normal.\n\n        d : float, optional (default: None)\n            Distance to origin in Hesse normal form.\n\n        point_in_plane : array-like, shape (3,), optional (default: None)\n            Point in plane.\n\n        s : float, optional (default: 1)\n            Scaling of the plane that will be drawn.\n\n        c : array-like, shape (3,), optional (default: None)\n            Color.\n\n        Returns\n        -------\n        plane : Plane\n            New plane.\n        \"\"\"\n        plane = Plane(normal, d, point_in_plane, s, c)\n        plane.add_artist(self)\n        return plane",
  "def plot_graph(\n            self, tm, frame, show_frames=False, show_connections=False,\n            show_visuals=False, show_collision_objects=False,\n            show_name=False, whitelist=None,\n            convex_hull_of_collision_objects=False, s=1.0):\n        \"\"\"Plot graph of connected frames.\n\n        Parameters\n        ----------\n        tm : TransformManager\n            Representation of the graph\n\n        frame : str\n            Name of the base frame in which the graph will be displayed\n\n        show_frames : bool, optional (default: False)\n            Show coordinate frames\n\n        show_connections : bool, optional (default: False)\n            Draw lines between frames of the graph\n\n        show_visuals : bool, optional (default: False)\n            Show visuals that are stored in the graph\n\n        show_collision_objects : bool, optional (default: False)\n            Show collision objects that are stored in the graph\n\n        show_name : bool, optional (default: False)\n            Show names of frames\n\n        whitelist : list, optional (default: all)\n            List of frames that should be displayed\n\n        convex_hull_of_collision_objects : bool, optional (default: False)\n            Show convex hull of collision objects.\n\n        s : float, optional (default: 1)\n            Scaling of the frames that will be drawn\n\n        Returns\n        -------\n        graph : Graph\n            New graph.\n        \"\"\"\n        graph = Graph(tm, frame, show_frames, show_connections,\n                      show_visuals, show_collision_objects, show_name,\n                      whitelist, convex_hull_of_collision_objects, s)\n        graph.add_artist(self)\n        return graph",
  "def plot_camera(self, M, cam2world=None, virtual_image_distance=1,\n                    sensor_size=(1920, 1080), strict_check=True):\n        \"\"\"Plot camera in world coordinates.\n\n        This function is inspired by Blender's camera visualization. It will\n        show the camera center, a virtual image plane, and the top of the\n        virtual image plane.\n\n        Parameters\n        ----------\n        M : array-like, shape (3, 3)\n            Intrinsic camera matrix that contains the focal lengths on the\n            diagonal and the center of the the image in the last column. It\n            does not matter whether values are given in meters or pixels as\n            long as the unit is the same as for the sensor size.\n\n        cam2world : array-like, shape (4, 4), optional (default: I)\n            Transformation matrix of camera in world frame. We assume that the\n            position is given in meters.\n\n        virtual_image_distance : float, optional (default: 1)\n            Distance from pinhole to virtual image plane that will be\n            displayed. We assume that this distance is given in meters. The\n            unit has to be consistent with the unit of the position in\n            cam2world.\n\n        sensor_size : array-like, shape (2,), optional (default: [1920, 1080])\n            Size of the image sensor: (width, height). It does not matter\n            whether values are given in meters or pixels as long as the unit is\n            the same as for the sensor size.\n\n        strict_check : bool, optional (default: True)\n            Raise a ValueError if the transformation matrix is not numerically\n            close enough to a real transformation matrix. Otherwise we print a\n            warning.\n\n        Returns\n        -------\n        camera : Camera\n            New camera.\n        \"\"\"\n        camera = Camera(M, cam2world, virtual_image_distance, sensor_size,\n                        strict_check)\n        camera.add_artist(self)\n        return camera",
  "def save_image(self, filename):\n        \"\"\"Save rendered image to file.\n\n        Parameters\n        ----------\n        filename : str\n            Path to file in which the rendered image should be stored\n        \"\"\"\n        self.visualizer.capture_screen_image(filename, True)",
  "def show(self):\n        \"\"\"Display the figure window.\"\"\"\n        self.visualizer.run()\n        self.visualizer.destroy_window()",
  "class TransformManager(TransformGraphBase):\n    \"\"\"Manage transformations between frames.\n\n    This is a simplified version of `ROS tf <http://wiki.ros.org/tf>`_ that\n    ignores the temporal aspect. A user can register transformations. The\n    shortest path between all frames will be computed internally which enables\n    us to provide transforms for any connected frames.\n\n    Suppose we know the transformations A2B, D2C, and B2C. The transform\n    manager can compute any transformation between the frames A, B, C and D.\n    For example, you can request the transformation that represents frame D in\n    frame A. The transformation manager will automatically concatenate the\n    transformations D2C, C2B, and B2A, where C2B and B2A are obtained by\n    inverting B2C and A2B respectively.\n\n    .. warning::\n\n        It is possible to introduce inconsistencies in the transformation\n        manager. Adding A2B and B2A with inconsistent values will result in\n        an invalid state because inconsistencies will not be checked. It seems\n        to be trivial in this simple case but can be computationally complex\n        for large graphs. You can check the consistency explicitly with\n        :func:`TransformManager.check_consistency`.\n\n    The TransformManager does not directly support serialization because\n    we don't want to decide for a specific format. However, it allows\n    conversion to a dict with only primitive types that is serializable,\n    for instance, as JSON. If a more compact format is required, binary\n    formats like msgpack can be used. Use :func:`TransformManager.to_dict`\n    and :func:`TransformManager.from_dict` for this purpose.\n\n    Parameters\n    ----------\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    check : bool, optional (default: True)\n        Check if transformation matrices are valid and requested nodes exist,\n        which might significantly slow down some operations.\n    \"\"\"\n    def __init__(self, strict_check=True, check=True):\n        super(TransformManager, self).__init__(strict_check, check)\n        self._transforms = {}\n\n    @property\n    def transforms(self):\n        \"\"\"Rigid transformations between nodes.\"\"\"\n        return self._transforms\n\n    def _check_transform(self, A2B):\n        \"\"\"Check validity of rigid transformation.\"\"\"\n        return check_transform(A2B, strict_check=self.strict_check)\n\n    def _transform_available(self, key):\n        return key in self._transforms\n\n    def _set_transform(self, key, A2B):\n        self._transforms[key] = A2B\n\n    def _get_transform(self, key):\n        return self._transforms[key]\n\n    def _del_transform(self, key):\n        del self._transforms[key]\n\n    def plot_frames_in(self, frame, ax=None, s=1.0, ax_s=1, show_name=True,\n                       whitelist=None, **kwargs):  # pragma: no cover\n        \"\"\"Plot all frames in a given reference frame.\n\n        Note that frames that cannot be connected to the reference frame are\n        omitted.\n\n        Parameters\n        ----------\n        frame : Hashable\n            Reference frame\n\n        ax : Matplotlib 3d axis, optional (default: None)\n            If the axis is None, a new 3d axis will be created\n\n        s : float, optional (default: 1)\n            Scaling of the frame that will be drawn\n\n        ax_s : float, optional (default: 1)\n            Scaling of the new matplotlib 3d axis\n\n        show_name : bool, optional (default: True)\n            Print node names\n\n        whitelist : list, optional (default: None)\n            Frames that must be plotted\n\n        kwargs : dict, optional (default: {})\n            Additional arguments for the plotting functions, e.g. alpha\n\n        Returns\n        -------\n        ax : Matplotlib 3d axis\n            New or old axis\n\n        Raises\n        ------\n        KeyError\n            If the frame is unknown\n        \"\"\"\n        if frame not in self.nodes:\n            raise KeyError(\"Unknown frame '%s'\" % frame)\n\n        nodes = self._whitelisted_nodes(whitelist)\n\n        for node in nodes:\n            try:\n                node2frame = self.get_transform(node, frame)\n                name = node if show_name else None\n                ax = plot_transform(\n                    ax, node2frame, s, ax_s, name,\n                    strict_check=self.strict_check, **kwargs)\n            except KeyError:\n                pass  # Frame is not connected to the reference frame\n        return ax\n\n    def plot_connections_in(self, frame, ax=None, ax_s=1, whitelist=None,\n                            **kwargs):  # pragma: no cover\n        \"\"\"Plot direct frame connections in a given reference frame.\n\n        A line between each pair of frames for which a direct transformation\n        is known will be plotted. Direct means that either A2B or B2A has been\n        added to the transformation manager.\n\n        Note that frames that cannot be connected to the reference frame are\n        omitted.\n\n        Parameters\n        ----------\n        frame : Hashable\n            Reference frame\n\n        ax : Matplotlib 3d axis, optional (default: None)\n            If the axis is None, a new 3d axis will be created\n\n        ax_s : float, optional (default: 1)\n            Scaling of the new matplotlib 3d axis\n\n        whitelist : list, optional (default: None)\n            Both frames of a connection must be in the whitelist to plot the\n            connection\n\n        kwargs : dict, optional (default: {})\n            Additional arguments for the plotting functions, e.g. alpha\n\n        Returns\n        -------\n        ax : Matplotlib 3d axis\n            New or old axis\n\n        Raises\n        ------\n        KeyError\n            If the frame is unknown\n        \"\"\"\n        if frame not in self.nodes:\n            raise KeyError(\"Unknown frame '%s'\" % frame)\n\n        if ax is None:\n            from ..plot_utils import make_3d_axis\n            ax = make_3d_axis(ax_s)\n\n        nodes = self._whitelisted_nodes(whitelist)\n\n        if \"c\" not in kwargs and \"color\" not in kwargs:\n            kwargs[\"color\"] = \"black\"\n\n        for frame_names in self._transforms:\n            from_frame, to_frame = frame_names\n            if from_frame in nodes and to_frame in nodes:\n                try:\n                    from2ref = self.get_transform(from_frame, frame)\n                    to2ref = self.get_transform(to_frame, frame)\n                    ax.plot(\n                        (from2ref[0, 3], to2ref[0, 3]),\n                        (from2ref[1, 3], to2ref[1, 3]),\n                        (from2ref[2, 3], to2ref[2, 3]),\n                        **kwargs\n                    )\n                except KeyError:\n                    pass  # Frame is not connected to the reference frame\n\n        return ax\n\n    def _whitelisted_nodes(self, whitelist):\n        \"\"\"Get whitelisted nodes.\n\n        Parameters\n        ----------\n        whitelist : list or None\n            Whitelist of frames\n\n        Returns\n        -------\n        nodes : set\n            Existing whitelisted nodes\n\n        Raises\n        ------\n        KeyError\n            Will be raised if an unknown node is in the whitelist.\n        \"\"\"\n        nodes = set(self.nodes)\n        if whitelist is not None:\n            whitelist = set(whitelist)\n            nodes = nodes.intersection(whitelist)\n            nonwhitlisted_nodes = whitelist.difference(nodes)\n            if nonwhitlisted_nodes:\n                raise KeyError(\"Whitelist contains unknown nodes: '%s'\"\n                               % nonwhitlisted_nodes)\n        return nodes\n\n    def write_png(self, filename, prog=None):  # pragma: no cover\n        \"\"\"Create PNG from dot graph of the transformations.\n\n        .. warning::\n\n            Note that this method requires the Python package pydot and an\n            existing installation of graphviz on your system.\n\n        Parameters\n        ----------\n        filename : str\n            Name of the output file. Should end with '.png'.\n\n        prog : str, optional (default: dot)\n            Name of GraphViz executable that can be found in the `$PATH` or\n            absolute path to GraphViz executable. Possible options are, for\n            example, 'dot', 'twopi', 'neato', 'circo', 'fdp', 'sfdp'.\n\n        Raises\n        ------\n        ImportError\n            If pydot is not available\n        \"\"\"\n        if not PYDOT_AVAILABLE:\n            raise ImportError(\"pydot must be installed to use this feature.\")\n\n        graph = pydot.Dot(graph_type=\"graph\")\n        frame_color = \"#dd3322\"\n        connection_color = \"#d0d0ff\"\n\n        for frame in self.nodes:\n            node = pydot.Node(\n                _dot_display_name(str(frame)), style=\"filled\",\n                fillcolor=frame_color, shape=\"egg\")\n            graph.add_node(node)\n        for frames, A2B in self._transforms.items():\n            frame_a, frame_b = frames\n            connection_name = \"%s to %s\\n%s\" % (\n                _dot_display_name(str(frame_a)),\n                _dot_display_name(str(frame_b)), str(np.round(A2B, 3)))\n            node = pydot.Node(\n                connection_name, style=\"filled\", fillcolor=connection_color,\n                shape=\"note\")\n            graph.add_node(node)\n            a_name = _dot_display_name(str(frame_a))\n            a_edge = pydot.Edge(connection_name, a_name, penwidth=3)\n            graph.add_edge(a_edge)\n            b_name = _dot_display_name(str(frame_b))\n            b_edge = pydot.Edge(connection_name, b_name, penwidth=3)\n            graph.add_edge(b_edge)\n\n        graph.write_png(filename, prog=prog)\n\n    def to_dict(self):\n        \"\"\"Convert the transform manager to a dict that is serializable.\n\n        Returns\n        -------\n        tm_dict : dict\n            Serializable dict.\n        \"\"\"\n        return {\n            \"class\": self.__class__.__name__,\n            \"strict_check\": self.strict_check,\n            \"check\": self.check,\n            \"transforms\": [(k, v.ravel().tolist())\n                           for k, v in self._transforms.items()],\n            \"nodes\": self.nodes,\n            \"i\": self.i,\n            \"j\": self.j,\n            \"transform_to_ij_index\": list(self.transform_to_ij_index.items()),\n            \"connections\": {\n                \"data\": self.connections.data.tolist(),\n                \"indices\": self.connections.indices.tolist(),\n                \"indptr\": self.connections.indptr.tolist()\n            },\n            \"dist\": self.dist.tolist(),\n            \"predecessors\": self.predecessors.tolist()\n        }\n\n    @staticmethod\n    def from_dict(tm_dict):\n        \"\"\"Create transform manager from dict.\n\n        Parameters\n        ----------\n        tm_dict : dict\n            Serializable dict.\n\n        Returns\n        -------\n        tm : TransformManager\n            Deserialized transform manager.\n        \"\"\"\n        strict_check = tm_dict.get(\"strict_check\")\n        check = tm_dict.get(\"check\")\n        tm = TransformManager(strict_check=strict_check, check=check)\n        tm.set_transform_manager_state(tm_dict)\n        return tm\n\n    def set_transform_manager_state(self, tm_dict):\n        \"\"\"Set state of transform manager from dict.\n\n        Parameters\n        ----------\n        tm_dict : dict\n            Serializable dict.\n        \"\"\"\n        transforms = tm_dict.get(\"transforms\")\n        self._transforms = {tuple(k): np.array(v).reshape(4, 4)\n                            for k, v in transforms}\n        self.nodes = tm_dict.get(\"nodes\")\n        self.i = tm_dict.get(\"i\")\n        self.j = tm_dict.get(\"j\")\n        self.transform_to_ij_index = {\n            (tuple(k), v) for k, v in tm_dict.get(\"transform_to_ij_index\")}\n        connections = tm_dict.get(\"connections\")\n        self.connections = sp.csr_matrix((\n            connections[\"data\"], connections[\"indices\"],\n            connections[\"indptr\"]))\n        n_nodes = len(self.nodes)\n        dist = np.array(tm_dict.get(\"dist\"))\n        self.dist = dist.reshape(n_nodes, n_nodes)\n        predecessors = np.array(tm_dict.get(\"predecessors\"), dtype=np.int32)\n        self.predecessors = predecessors.reshape(n_nodes, n_nodes)",
  "def _dot_display_name(name):  # pragma: no cover\n    return name.replace(\"/\", \"\")",
  "def __init__(self, strict_check=True, check=True):\n        super(TransformManager, self).__init__(strict_check, check)\n        self._transforms = {}",
  "def transforms(self):\n        \"\"\"Rigid transformations between nodes.\"\"\"\n        return self._transforms",
  "def _check_transform(self, A2B):\n        \"\"\"Check validity of rigid transformation.\"\"\"\n        return check_transform(A2B, strict_check=self.strict_check)",
  "def _transform_available(self, key):\n        return key in self._transforms",
  "def _set_transform(self, key, A2B):\n        self._transforms[key] = A2B",
  "def _get_transform(self, key):\n        return self._transforms[key]",
  "def _del_transform(self, key):\n        del self._transforms[key]",
  "def plot_frames_in(self, frame, ax=None, s=1.0, ax_s=1, show_name=True,\n                       whitelist=None, **kwargs):  # pragma: no cover\n        \"\"\"Plot all frames in a given reference frame.\n\n        Note that frames that cannot be connected to the reference frame are\n        omitted.\n\n        Parameters\n        ----------\n        frame : Hashable\n            Reference frame\n\n        ax : Matplotlib 3d axis, optional (default: None)\n            If the axis is None, a new 3d axis will be created\n\n        s : float, optional (default: 1)\n            Scaling of the frame that will be drawn\n\n        ax_s : float, optional (default: 1)\n            Scaling of the new matplotlib 3d axis\n\n        show_name : bool, optional (default: True)\n            Print node names\n\n        whitelist : list, optional (default: None)\n            Frames that must be plotted\n\n        kwargs : dict, optional (default: {})\n            Additional arguments for the plotting functions, e.g. alpha\n\n        Returns\n        -------\n        ax : Matplotlib 3d axis\n            New or old axis\n\n        Raises\n        ------\n        KeyError\n            If the frame is unknown\n        \"\"\"\n        if frame not in self.nodes:\n            raise KeyError(\"Unknown frame '%s'\" % frame)\n\n        nodes = self._whitelisted_nodes(whitelist)\n\n        for node in nodes:\n            try:\n                node2frame = self.get_transform(node, frame)\n                name = node if show_name else None\n                ax = plot_transform(\n                    ax, node2frame, s, ax_s, name,\n                    strict_check=self.strict_check, **kwargs)\n            except KeyError:\n                pass  # Frame is not connected to the reference frame\n        return ax",
  "def plot_connections_in(self, frame, ax=None, ax_s=1, whitelist=None,\n                            **kwargs):  # pragma: no cover\n        \"\"\"Plot direct frame connections in a given reference frame.\n\n        A line between each pair of frames for which a direct transformation\n        is known will be plotted. Direct means that either A2B or B2A has been\n        added to the transformation manager.\n\n        Note that frames that cannot be connected to the reference frame are\n        omitted.\n\n        Parameters\n        ----------\n        frame : Hashable\n            Reference frame\n\n        ax : Matplotlib 3d axis, optional (default: None)\n            If the axis is None, a new 3d axis will be created\n\n        ax_s : float, optional (default: 1)\n            Scaling of the new matplotlib 3d axis\n\n        whitelist : list, optional (default: None)\n            Both frames of a connection must be in the whitelist to plot the\n            connection\n\n        kwargs : dict, optional (default: {})\n            Additional arguments for the plotting functions, e.g. alpha\n\n        Returns\n        -------\n        ax : Matplotlib 3d axis\n            New or old axis\n\n        Raises\n        ------\n        KeyError\n            If the frame is unknown\n        \"\"\"\n        if frame not in self.nodes:\n            raise KeyError(\"Unknown frame '%s'\" % frame)\n\n        if ax is None:\n            from ..plot_utils import make_3d_axis\n            ax = make_3d_axis(ax_s)\n\n        nodes = self._whitelisted_nodes(whitelist)\n\n        if \"c\" not in kwargs and \"color\" not in kwargs:\n            kwargs[\"color\"] = \"black\"\n\n        for frame_names in self._transforms:\n            from_frame, to_frame = frame_names\n            if from_frame in nodes and to_frame in nodes:\n                try:\n                    from2ref = self.get_transform(from_frame, frame)\n                    to2ref = self.get_transform(to_frame, frame)\n                    ax.plot(\n                        (from2ref[0, 3], to2ref[0, 3]),\n                        (from2ref[1, 3], to2ref[1, 3]),\n                        (from2ref[2, 3], to2ref[2, 3]),\n                        **kwargs\n                    )\n                except KeyError:\n                    pass  # Frame is not connected to the reference frame\n\n        return ax",
  "def _whitelisted_nodes(self, whitelist):\n        \"\"\"Get whitelisted nodes.\n\n        Parameters\n        ----------\n        whitelist : list or None\n            Whitelist of frames\n\n        Returns\n        -------\n        nodes : set\n            Existing whitelisted nodes\n\n        Raises\n        ------\n        KeyError\n            Will be raised if an unknown node is in the whitelist.\n        \"\"\"\n        nodes = set(self.nodes)\n        if whitelist is not None:\n            whitelist = set(whitelist)\n            nodes = nodes.intersection(whitelist)\n            nonwhitlisted_nodes = whitelist.difference(nodes)\n            if nonwhitlisted_nodes:\n                raise KeyError(\"Whitelist contains unknown nodes: '%s'\"\n                               % nonwhitlisted_nodes)\n        return nodes",
  "def write_png(self, filename, prog=None):  # pragma: no cover\n        \"\"\"Create PNG from dot graph of the transformations.\n\n        .. warning::\n\n            Note that this method requires the Python package pydot and an\n            existing installation of graphviz on your system.\n\n        Parameters\n        ----------\n        filename : str\n            Name of the output file. Should end with '.png'.\n\n        prog : str, optional (default: dot)\n            Name of GraphViz executable that can be found in the `$PATH` or\n            absolute path to GraphViz executable. Possible options are, for\n            example, 'dot', 'twopi', 'neato', 'circo', 'fdp', 'sfdp'.\n\n        Raises\n        ------\n        ImportError\n            If pydot is not available\n        \"\"\"\n        if not PYDOT_AVAILABLE:\n            raise ImportError(\"pydot must be installed to use this feature.\")\n\n        graph = pydot.Dot(graph_type=\"graph\")\n        frame_color = \"#dd3322\"\n        connection_color = \"#d0d0ff\"\n\n        for frame in self.nodes:\n            node = pydot.Node(\n                _dot_display_name(str(frame)), style=\"filled\",\n                fillcolor=frame_color, shape=\"egg\")\n            graph.add_node(node)\n        for frames, A2B in self._transforms.items():\n            frame_a, frame_b = frames\n            connection_name = \"%s to %s\\n%s\" % (\n                _dot_display_name(str(frame_a)),\n                _dot_display_name(str(frame_b)), str(np.round(A2B, 3)))\n            node = pydot.Node(\n                connection_name, style=\"filled\", fillcolor=connection_color,\n                shape=\"note\")\n            graph.add_node(node)\n            a_name = _dot_display_name(str(frame_a))\n            a_edge = pydot.Edge(connection_name, a_name, penwidth=3)\n            graph.add_edge(a_edge)\n            b_name = _dot_display_name(str(frame_b))\n            b_edge = pydot.Edge(connection_name, b_name, penwidth=3)\n            graph.add_edge(b_edge)\n\n        graph.write_png(filename, prog=prog)",
  "def to_dict(self):\n        \"\"\"Convert the transform manager to a dict that is serializable.\n\n        Returns\n        -------\n        tm_dict : dict\n            Serializable dict.\n        \"\"\"\n        return {\n            \"class\": self.__class__.__name__,\n            \"strict_check\": self.strict_check,\n            \"check\": self.check,\n            \"transforms\": [(k, v.ravel().tolist())\n                           for k, v in self._transforms.items()],\n            \"nodes\": self.nodes,\n            \"i\": self.i,\n            \"j\": self.j,\n            \"transform_to_ij_index\": list(self.transform_to_ij_index.items()),\n            \"connections\": {\n                \"data\": self.connections.data.tolist(),\n                \"indices\": self.connections.indices.tolist(),\n                \"indptr\": self.connections.indptr.tolist()\n            },\n            \"dist\": self.dist.tolist(),\n            \"predecessors\": self.predecessors.tolist()\n        }",
  "def from_dict(tm_dict):\n        \"\"\"Create transform manager from dict.\n\n        Parameters\n        ----------\n        tm_dict : dict\n            Serializable dict.\n\n        Returns\n        -------\n        tm : TransformManager\n            Deserialized transform manager.\n        \"\"\"\n        strict_check = tm_dict.get(\"strict_check\")\n        check = tm_dict.get(\"check\")\n        tm = TransformManager(strict_check=strict_check, check=check)\n        tm.set_transform_manager_state(tm_dict)\n        return tm",
  "def set_transform_manager_state(self, tm_dict):\n        \"\"\"Set state of transform manager from dict.\n\n        Parameters\n        ----------\n        tm_dict : dict\n            Serializable dict.\n        \"\"\"\n        transforms = tm_dict.get(\"transforms\")\n        self._transforms = {tuple(k): np.array(v).reshape(4, 4)\n                            for k, v in transforms}\n        self.nodes = tm_dict.get(\"nodes\")\n        self.i = tm_dict.get(\"i\")\n        self.j = tm_dict.get(\"j\")\n        self.transform_to_ij_index = {\n            (tuple(k), v) for k, v in tm_dict.get(\"transform_to_ij_index\")}\n        connections = tm_dict.get(\"connections\")\n        self.connections = sp.csr_matrix((\n            connections[\"data\"], connections[\"indices\"],\n            connections[\"indptr\"]))\n        n_nodes = len(self.nodes)\n        dist = np.array(tm_dict.get(\"dist\"))\n        self.dist = dist.reshape(n_nodes, n_nodes)\n        predecessors = np.array(tm_dict.get(\"predecessors\"), dtype=np.int32)\n        self.predecessors = predecessors.reshape(n_nodes, n_nodes)",
  "class TimeVaryingTransform(abc.ABC):\n    \"\"\"Time-varying rigid transformation.\n\n    You have to inherit from this abstract base class to use the\n    TemporalTransformManager. Two implementations of the interface that\n    are already available are :class:`StaticTransform` and\n    :class:`NumpyTimeseriesTransform`.\n    \"\"\"\n\n    @abc.abstractmethod\n    def as_matrix(self, query_time):\n        \"\"\"Get transformation matrix at given time.\n\n        Parameters\n        ----------\n        query_time : float\n            Query time\n\n        Returns\n        -------\n        A2B_t : array, shape (4, 4)\n            Homogeneous transformation matrix at given time.\n        \"\"\"\n\n    @abc.abstractmethod\n    def check_transforms(self):\n        \"\"\"Checks all transformations.\n\n        Returns\n        -------\n        self : TimeVaryingTransform\n            Validated transformations.\n        \"\"\"",
  "class StaticTransform(TimeVaryingTransform):\n    \"\"\"Transformation, which does not change over time.\n\n    Parameters\n    ----------\n    A2B : array-like, shape (4, 4)\n        Homogeneous transformation matrix.\n    \"\"\"\n    def __init__(self, A2B):\n        self._A2B = A2B\n\n    def as_matrix(self, query_time):\n        return self._A2B\n\n    def check_transforms(self):\n        self._A2B = check_transform(self._A2B)\n        return self",
  "class NumpyTimeseriesTransform(TimeVaryingTransform):\n    \"\"\"Transformation sequence, represented in a numpy array.\n\n    The interpolation is computed using screw linear interpolation (ScLERP)\n    method.\n\n    Parameters\n    ----------\n    time: array, shape (n_steps,)\n        Numeric timesteps corresponding to the transformation samples.\n        You can use, for example, unix timestamps, relative time (starting\n        with 0).\n\n    pqs : array, shape (n_steps, 7)\n        Time-sequence of transformations, with each row representing a single\n        sample as position-quarternion (PQ) structure.\n    \"\"\"\n\n    def __init__(self, time, pqs):\n        self.time = np.asarray(time)\n        self._pqs = np.asarray(pqs)\n\n        if len(self._pqs.shape) != 2:\n            raise ValueError(\"Shape of PQ array must be 2-dimensional.\")\n\n        if self.time.size != self._pqs.shape[0]:\n            raise ValueError(\n                \"Number of timesteps does not equal to number of PQ samples\")\n\n        if self._pqs.shape[1] != 7:\n            raise ValueError(\"`pqs` matrix shall have 7 columns.\")\n\n    def as_matrix(self, query_time):\n        pq = self._interpolate_pq_using_sclerp(query_time)\n        return transform_from_pq(pq)\n\n    def check_transforms(self):\n        self._pqs[:, 3:] = norm_vectors(self._pqs[:, 3:])\n        return self\n\n    def _interpolate_pq_using_sclerp(self, query_time):\n        # identify the index of the preceding sample\n        idx_timestep_earlier_wrt_query_time = np.argmax(\n            self.time >= query_time) - 1\n\n        # deal with first timestamp\n        idx_timestep_earlier_wrt_query_time = max(\n            idx_timestep_earlier_wrt_query_time, 0)\n\n        # dual quaternion from preceding sample\n        t_prev = self.time[idx_timestep_earlier_wrt_query_time]\n        pq_prev = self._pqs[idx_timestep_earlier_wrt_query_time, :]\n        dq_prev = dual_quaternion_from_pq(pq_prev)\n\n        # dual quaternion from successive sample\n        t_next = self.time[idx_timestep_earlier_wrt_query_time + 1]\n        pq_next = self._pqs[idx_timestep_earlier_wrt_query_time + 1, :]\n        dq_next = dual_quaternion_from_pq(pq_next)\n\n        # since sclerp works with relative (0-1) positions\n        rel_delta_t = (query_time - t_prev) / (t_next - t_prev)\n        dq_interpolated = dual_quaternion_sclerp(dq_prev, dq_next, rel_delta_t)\n\n        return pq_from_dual_quaternion(dq_interpolated)",
  "class TemporalTransformManager(TransformGraphBase):\n    \"\"\"Manage time-varying transformations.\n\n    Parameters\n    ----------\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    check : bool, optional (default: True)\n        Check if transformation matrices are valid and requested nodes exist,\n        which might significantly slow down some operations.\n    \"\"\"\n    def __init__(self, strict_check=True, check=True):\n        super(TemporalTransformManager, self).__init__(strict_check, check)\n        self._transforms = {}\n        self._current_time = 0.0\n\n    @property\n    def current_time(self):\n        \"\"\"Current time at which we evaluate transformations.\"\"\"\n        return self._current_time\n\n    @current_time.setter\n    def current_time(self, time):\n        \"\"\"Set current time at which we evaluate transformations.\"\"\"\n        self._current_time = time\n\n    @property\n    def transforms(self):\n        \"\"\"Rigid transformations between nodes.\"\"\"\n        return {transform_key: transform.as_matrix(self.current_time) for\n                transform_key, transform in self._transforms.items()}\n\n    def get_transform_at_time(self, from_frame, to_frame, time):\n        \"\"\"Request a transformation at a given time.\n\n        Parameters\n        ----------\n        from_frame : Hashable\n            Name of the frame for which the transformation is requested in the\n            to_frame coordinate system\n\n        to_frame : Hashable\n            Name of the frame in which the transformation is defined\n\n        time : float\n            Time at which we request the transformation.\n\n        Returns\n        -------\n        A2B : array, shape (4, 4)\n            Transformation from 'from_frame' to 'to_frame'\n\n        Raises\n        ------\n        KeyError\n            If one of the frames is unknown or there is no connection between\n            them\n        \"\"\"\n        previous_time = self.current_time\n        self.current_time = time\n\n        A2B = self.get_transform(from_frame, to_frame)\n\n        # revert internal state\n        self.current_time = previous_time\n        return A2B\n\n    def _transform_available(self, key):\n        return key in self._transforms\n\n    def _set_transform(self, key, A2B):\n        self._transforms[key] = A2B\n\n    def _get_transform(self, key):\n        return self._transforms[key].as_matrix(self._current_time)\n\n    def _del_transform(self, key):\n        del self._transforms[key]\n\n    def _check_transform(self, A2B):\n        return A2B.check_transforms()",
  "def as_matrix(self, query_time):\n        \"\"\"Get transformation matrix at given time.\n\n        Parameters\n        ----------\n        query_time : float\n            Query time\n\n        Returns\n        -------\n        A2B_t : array, shape (4, 4)\n            Homogeneous transformation matrix at given time.\n        \"\"\"",
  "def check_transforms(self):\n        \"\"\"Checks all transformations.\n\n        Returns\n        -------\n        self : TimeVaryingTransform\n            Validated transformations.\n        \"\"\"",
  "def __init__(self, A2B):\n        self._A2B = A2B",
  "def as_matrix(self, query_time):\n        return self._A2B",
  "def check_transforms(self):\n        self._A2B = check_transform(self._A2B)\n        return self",
  "def __init__(self, time, pqs):\n        self.time = np.asarray(time)\n        self._pqs = np.asarray(pqs)\n\n        if len(self._pqs.shape) != 2:\n            raise ValueError(\"Shape of PQ array must be 2-dimensional.\")\n\n        if self.time.size != self._pqs.shape[0]:\n            raise ValueError(\n                \"Number of timesteps does not equal to number of PQ samples\")\n\n        if self._pqs.shape[1] != 7:\n            raise ValueError(\"`pqs` matrix shall have 7 columns.\")",
  "def as_matrix(self, query_time):\n        pq = self._interpolate_pq_using_sclerp(query_time)\n        return transform_from_pq(pq)",
  "def check_transforms(self):\n        self._pqs[:, 3:] = norm_vectors(self._pqs[:, 3:])\n        return self",
  "def _interpolate_pq_using_sclerp(self, query_time):\n        # identify the index of the preceding sample\n        idx_timestep_earlier_wrt_query_time = np.argmax(\n            self.time >= query_time) - 1\n\n        # deal with first timestamp\n        idx_timestep_earlier_wrt_query_time = max(\n            idx_timestep_earlier_wrt_query_time, 0)\n\n        # dual quaternion from preceding sample\n        t_prev = self.time[idx_timestep_earlier_wrt_query_time]\n        pq_prev = self._pqs[idx_timestep_earlier_wrt_query_time, :]\n        dq_prev = dual_quaternion_from_pq(pq_prev)\n\n        # dual quaternion from successive sample\n        t_next = self.time[idx_timestep_earlier_wrt_query_time + 1]\n        pq_next = self._pqs[idx_timestep_earlier_wrt_query_time + 1, :]\n        dq_next = dual_quaternion_from_pq(pq_next)\n\n        # since sclerp works with relative (0-1) positions\n        rel_delta_t = (query_time - t_prev) / (t_next - t_prev)\n        dq_interpolated = dual_quaternion_sclerp(dq_prev, dq_next, rel_delta_t)\n\n        return pq_from_dual_quaternion(dq_interpolated)",
  "def __init__(self, strict_check=True, check=True):\n        super(TemporalTransformManager, self).__init__(strict_check, check)\n        self._transforms = {}\n        self._current_time = 0.0",
  "def current_time(self):\n        \"\"\"Current time at which we evaluate transformations.\"\"\"\n        return self._current_time",
  "def current_time(self, time):\n        \"\"\"Set current time at which we evaluate transformations.\"\"\"\n        self._current_time = time",
  "def transforms(self):\n        \"\"\"Rigid transformations between nodes.\"\"\"\n        return {transform_key: transform.as_matrix(self.current_time) for\n                transform_key, transform in self._transforms.items()}",
  "def get_transform_at_time(self, from_frame, to_frame, time):\n        \"\"\"Request a transformation at a given time.\n\n        Parameters\n        ----------\n        from_frame : Hashable\n            Name of the frame for which the transformation is requested in the\n            to_frame coordinate system\n\n        to_frame : Hashable\n            Name of the frame in which the transformation is defined\n\n        time : float\n            Time at which we request the transformation.\n\n        Returns\n        -------\n        A2B : array, shape (4, 4)\n            Transformation from 'from_frame' to 'to_frame'\n\n        Raises\n        ------\n        KeyError\n            If one of the frames is unknown or there is no connection between\n            them\n        \"\"\"\n        previous_time = self.current_time\n        self.current_time = time\n\n        A2B = self.get_transform(from_frame, to_frame)\n\n        # revert internal state\n        self.current_time = previous_time\n        return A2B",
  "def _transform_available(self, key):\n        return key in self._transforms",
  "def _set_transform(self, key, A2B):\n        self._transforms[key] = A2B",
  "def _get_transform(self, key):\n        return self._transforms[key].as_matrix(self._current_time)",
  "def _del_transform(self, key):\n        del self._transforms[key]",
  "def _check_transform(self, A2B):\n        return A2B.check_transforms()",
  "class TransformGraphBase(abc.ABC):\n    \"\"\"Base class for all graphs of rigid transformations.\n\n    Parameters\n    ----------\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the transformation matrix is not numerically\n        close enough to a real transformation matrix. Otherwise we print a\n        warning.\n\n    check : bool, optional (default: True)\n        Check if transformation matrices are valid and requested nodes exist,\n        which might significantly slow down some operations.\n    \"\"\"\n    def __init__(self, strict_check=True, check=True):\n        self.strict_check = strict_check\n        self.check = check\n\n        # Names of nodes\n        self.nodes = []\n\n        # A pair (self.i[n], self.j[n]) represents indices of connected nodes\n        self.i = []\n        self.j = []\n        # We have to store the index n associated to a transformation to be\n        # able to remove the transformation later\n        self.transform_to_ij_index = {}\n        # Connection information as sparse matrix\n        self.connections = sp.csr_matrix((0, 0))\n        # Result of shortest path algorithm:\n        # distance matrix (distance is the number of transformations)\n        self.dist = np.empty(0)\n        self.predecessors = np.empty(0, dtype=np.int32)\n\n        self._cached_shortest_paths = {}\n\n    @property\n    @abc.abstractmethod\n    def transforms(self):\n        \"\"\"Rigid transformations between nodes.\"\"\"\n\n    @abc.abstractmethod\n    def _check_transform(self, A2B):\n        \"\"\"Check validity of rigid transformation.\"\"\"\n\n    def _path_transform(self, path):\n        \"\"\"Convert sequence of node names to rigid transformation.\"\"\"\n        A2B = np.eye(4)\n        for from_f, to_f in zip(path[:-1], path[1:]):\n            A2B = concat(A2B, self.get_transform(from_f, to_f),\n                         strict_check=self.strict_check, check=self.check)\n        return A2B\n\n    @abc.abstractmethod\n    def _transform_available(self, key):\n        \"\"\"Check if transformation key is available.\"\"\"\n\n    @abc.abstractmethod\n    def _set_transform(self, key, A2B):\n        \"\"\"Store transformation under given key.\"\"\"\n\n    @abc.abstractmethod\n    def _get_transform(self, key):\n        \"\"\"Retrieve stored transformation under given key.\"\"\"\n\n    @abc.abstractmethod\n    def _del_transform(self, key):\n        \"\"\"Delete transformation stored under given key.\"\"\"\n\n    def has_frame(self, frame):\n        \"\"\"Check if frame has been registered.\n\n        Parameters\n        ----------\n        frame : Hashable\n            Frame name\n\n        Returns\n        -------\n        has_frame : bool\n            Frame is registered\n        \"\"\"\n        return frame in self.nodes\n\n    def add_transform(self, from_frame, to_frame, A2B):\n        \"\"\"Register a transformation.\n\n        Parameters\n        ----------\n        from_frame : Hashable\n            Name of the frame for which the transformation is added in the\n            to_frame coordinate system\n\n        to_frame : Hashable\n            Name of the frame in which the transformation is defined\n\n        A2B : Any\n            Transformation from 'from_frame' to 'to_frame'\n\n        Returns\n        -------\n        self : TransformManager\n            This object for chaining\n        \"\"\"\n        if self.check:\n            A2B = self._check_transform(A2B)\n\n        if from_frame not in self.nodes:\n            self.nodes.append(from_frame)\n        if to_frame not in self.nodes:\n            self.nodes.append(to_frame)\n\n        transform_key = (from_frame, to_frame)\n\n        recompute_shortest_path = False\n        if not self._transform_available(transform_key):\n            ij_index = len(self.i)\n            self.i.append(self.nodes.index(from_frame))\n            self.j.append(self.nodes.index(to_frame))\n            self.transform_to_ij_index[transform_key] = ij_index\n            recompute_shortest_path = True\n\n        if recompute_shortest_path:\n            self._recompute_shortest_path()\n\n        self._set_transform(transform_key, A2B)\n\n        return self\n\n    def _recompute_shortest_path(self):\n        n_nodes = len(self.nodes)\n        self.connections = sp.csr_matrix(\n            (np.zeros(len(self.i)), (self.i, self.j)),\n            shape=(n_nodes, n_nodes))\n        self.dist, self.predecessors = csgraph.shortest_path(\n            self.connections, unweighted=True, directed=False, method=\"D\",\n            return_predecessors=True)\n        self._cached_shortest_paths.clear()\n\n    def remove_transform(self, from_frame, to_frame):\n        \"\"\"Remove a transformation.\n\n        Nothing happens if there is no such transformation.\n\n        Parameters\n        ----------\n        from_frame : Hashable\n            Name of the frame for which the transformation is added in the\n            to_frame coordinate system\n\n        to_frame : Hashable\n            Name of the frame in which the transformation is defined\n\n        Returns\n        -------\n        self : TransformManager\n            This object for chaining\n        \"\"\"\n        transform_key = (from_frame, to_frame)\n        if self._transform_available(transform_key):\n            self._del_transform(transform_key)\n            ij_index = self.transform_to_ij_index[transform_key]\n            del self.transform_to_ij_index[transform_key]\n            self.transform_to_ij_index = {\n                k: v if v < ij_index else v - 1\n                for k, v in self.transform_to_ij_index.items()}\n            del self.i[ij_index]\n            del self.j[ij_index]\n            self._recompute_shortest_path()\n        return self\n\n    def get_transform(self, from_frame, to_frame):\n        \"\"\"Request a transformation.\n\n        Parameters\n        ----------\n        from_frame : Hashable\n            Name of the frame for which the transformation is requested in the\n            to_frame coordinate system\n\n        to_frame : Hashable\n            Name of the frame in which the transformation is defined\n\n        Returns\n        -------\n        A2B : Any\n            Transformation from 'from_frame' to 'to_frame'\n\n        Raises\n        ------\n        KeyError\n            If one of the frames is unknown or there is no connection between\n            them\n        \"\"\"\n        if self.check:\n            if from_frame not in self.nodes:\n                raise KeyError(\"Unknown frame '%s'\" % from_frame)\n            if to_frame not in self.nodes:\n                raise KeyError(\"Unknown frame '%s'\" % to_frame)\n\n        if self._transform_available((from_frame, to_frame)):\n            return self._get_transform((from_frame, to_frame))\n\n        if self._transform_available((to_frame, from_frame)):\n            return invert_transform(\n                self._get_transform((to_frame, from_frame)),\n                strict_check=self.strict_check,\n                check=self.check\n            )\n\n        i = self.nodes.index(from_frame)\n        j = self.nodes.index(to_frame)\n        if not np.isfinite(self.dist[i, j]):\n            raise KeyError(\"Cannot compute path from frame '%s' to \"\n                           \"frame '%s'.\" % (from_frame, to_frame))\n\n        path = self._shortest_path(i, j)\n        return self._path_transform(path)\n\n    def _shortest_path(self, i, j):\n        \"\"\"Names of nodes along the shortest path between two indices.\"\"\"\n        if (i, j) in self._cached_shortest_paths:\n            return self._cached_shortest_paths[(i, j)]\n\n        path = []\n        k = i\n        while k != -9999:\n            path.append(self.nodes[k])\n            k = self.predecessors[j, k]\n        self._cached_shortest_paths[(i, j)] = path\n        return path\n\n    def connected_components(self):\n        \"\"\"Get number of connected components.\n\n        If the number is larger than 1 there will be frames without\n        connections.\n\n        Returns\n        -------\n        n_connected_components : int\n            Number of connected components.\n        \"\"\"\n        return csgraph.connected_components(\n            self.connections, directed=False, return_labels=False)\n\n    def check_consistency(self):\n        \"\"\"Check consistency of the known transformations.\n\n        The complexity of this is between :math:`O(n^2)` and :math:`O(n^3)`,\n        where :math:`n` is the number of nodes. In graphs where each pair of\n        nodes is directly connected the complexity is :math:`O(n^2)`. In graphs\n        that are actually paths, the complexity is :math:`O(n^3)`.\n\n        Returns\n        -------\n        consistent : bool\n            Is the graph consistent, i.e. is A2B always the same as the inverse\n            of B2A?\n        \"\"\"\n        consistent = True\n        for node1 in self.nodes:\n            for node2 in self.nodes:\n                try:\n                    node1_to_node2 = self.get_transform(node1, node2)\n                    node2_to_node1 = self.get_transform(node2, node1)\n                    node1_to_node2_inv = invert_transform(node2_to_node1)\n                    consistent = consistent and np.allclose(node1_to_node2,\n                                                            node1_to_node2_inv)\n                except KeyError:\n                    pass  # Frames are not connected\n        return consistent",
  "def __init__(self, strict_check=True, check=True):\n        self.strict_check = strict_check\n        self.check = check\n\n        # Names of nodes\n        self.nodes = []\n\n        # A pair (self.i[n], self.j[n]) represents indices of connected nodes\n        self.i = []\n        self.j = []\n        # We have to store the index n associated to a transformation to be\n        # able to remove the transformation later\n        self.transform_to_ij_index = {}\n        # Connection information as sparse matrix\n        self.connections = sp.csr_matrix((0, 0))\n        # Result of shortest path algorithm:\n        # distance matrix (distance is the number of transformations)\n        self.dist = np.empty(0)\n        self.predecessors = np.empty(0, dtype=np.int32)\n\n        self._cached_shortest_paths = {}",
  "def transforms(self):\n        \"\"\"Rigid transformations between nodes.\"\"\"",
  "def _check_transform(self, A2B):\n        \"\"\"Check validity of rigid transformation.\"\"\"",
  "def _path_transform(self, path):\n        \"\"\"Convert sequence of node names to rigid transformation.\"\"\"\n        A2B = np.eye(4)\n        for from_f, to_f in zip(path[:-1], path[1:]):\n            A2B = concat(A2B, self.get_transform(from_f, to_f),\n                         strict_check=self.strict_check, check=self.check)\n        return A2B",
  "def _transform_available(self, key):\n        \"\"\"Check if transformation key is available.\"\"\"",
  "def _set_transform(self, key, A2B):\n        \"\"\"Store transformation under given key.\"\"\"",
  "def _get_transform(self, key):\n        \"\"\"Retrieve stored transformation under given key.\"\"\"",
  "def _del_transform(self, key):\n        \"\"\"Delete transformation stored under given key.\"\"\"",
  "def has_frame(self, frame):\n        \"\"\"Check if frame has been registered.\n\n        Parameters\n        ----------\n        frame : Hashable\n            Frame name\n\n        Returns\n        -------\n        has_frame : bool\n            Frame is registered\n        \"\"\"\n        return frame in self.nodes",
  "def add_transform(self, from_frame, to_frame, A2B):\n        \"\"\"Register a transformation.\n\n        Parameters\n        ----------\n        from_frame : Hashable\n            Name of the frame for which the transformation is added in the\n            to_frame coordinate system\n\n        to_frame : Hashable\n            Name of the frame in which the transformation is defined\n\n        A2B : Any\n            Transformation from 'from_frame' to 'to_frame'\n\n        Returns\n        -------\n        self : TransformManager\n            This object for chaining\n        \"\"\"\n        if self.check:\n            A2B = self._check_transform(A2B)\n\n        if from_frame not in self.nodes:\n            self.nodes.append(from_frame)\n        if to_frame not in self.nodes:\n            self.nodes.append(to_frame)\n\n        transform_key = (from_frame, to_frame)\n\n        recompute_shortest_path = False\n        if not self._transform_available(transform_key):\n            ij_index = len(self.i)\n            self.i.append(self.nodes.index(from_frame))\n            self.j.append(self.nodes.index(to_frame))\n            self.transform_to_ij_index[transform_key] = ij_index\n            recompute_shortest_path = True\n\n        if recompute_shortest_path:\n            self._recompute_shortest_path()\n\n        self._set_transform(transform_key, A2B)\n\n        return self",
  "def _recompute_shortest_path(self):\n        n_nodes = len(self.nodes)\n        self.connections = sp.csr_matrix(\n            (np.zeros(len(self.i)), (self.i, self.j)),\n            shape=(n_nodes, n_nodes))\n        self.dist, self.predecessors = csgraph.shortest_path(\n            self.connections, unweighted=True, directed=False, method=\"D\",\n            return_predecessors=True)\n        self._cached_shortest_paths.clear()",
  "def remove_transform(self, from_frame, to_frame):\n        \"\"\"Remove a transformation.\n\n        Nothing happens if there is no such transformation.\n\n        Parameters\n        ----------\n        from_frame : Hashable\n            Name of the frame for which the transformation is added in the\n            to_frame coordinate system\n\n        to_frame : Hashable\n            Name of the frame in which the transformation is defined\n\n        Returns\n        -------\n        self : TransformManager\n            This object for chaining\n        \"\"\"\n        transform_key = (from_frame, to_frame)\n        if self._transform_available(transform_key):\n            self._del_transform(transform_key)\n            ij_index = self.transform_to_ij_index[transform_key]\n            del self.transform_to_ij_index[transform_key]\n            self.transform_to_ij_index = {\n                k: v if v < ij_index else v - 1\n                for k, v in self.transform_to_ij_index.items()}\n            del self.i[ij_index]\n            del self.j[ij_index]\n            self._recompute_shortest_path()\n        return self",
  "def get_transform(self, from_frame, to_frame):\n        \"\"\"Request a transformation.\n\n        Parameters\n        ----------\n        from_frame : Hashable\n            Name of the frame for which the transformation is requested in the\n            to_frame coordinate system\n\n        to_frame : Hashable\n            Name of the frame in which the transformation is defined\n\n        Returns\n        -------\n        A2B : Any\n            Transformation from 'from_frame' to 'to_frame'\n\n        Raises\n        ------\n        KeyError\n            If one of the frames is unknown or there is no connection between\n            them\n        \"\"\"\n        if self.check:\n            if from_frame not in self.nodes:\n                raise KeyError(\"Unknown frame '%s'\" % from_frame)\n            if to_frame not in self.nodes:\n                raise KeyError(\"Unknown frame '%s'\" % to_frame)\n\n        if self._transform_available((from_frame, to_frame)):\n            return self._get_transform((from_frame, to_frame))\n\n        if self._transform_available((to_frame, from_frame)):\n            return invert_transform(\n                self._get_transform((to_frame, from_frame)),\n                strict_check=self.strict_check,\n                check=self.check\n            )\n\n        i = self.nodes.index(from_frame)\n        j = self.nodes.index(to_frame)\n        if not np.isfinite(self.dist[i, j]):\n            raise KeyError(\"Cannot compute path from frame '%s' to \"\n                           \"frame '%s'.\" % (from_frame, to_frame))\n\n        path = self._shortest_path(i, j)\n        return self._path_transform(path)",
  "def _shortest_path(self, i, j):\n        \"\"\"Names of nodes along the shortest path between two indices.\"\"\"\n        if (i, j) in self._cached_shortest_paths:\n            return self._cached_shortest_paths[(i, j)]\n\n        path = []\n        k = i\n        while k != -9999:\n            path.append(self.nodes[k])\n            k = self.predecessors[j, k]\n        self._cached_shortest_paths[(i, j)] = path\n        return path",
  "def connected_components(self):\n        \"\"\"Get number of connected components.\n\n        If the number is larger than 1 there will be frames without\n        connections.\n\n        Returns\n        -------\n        n_connected_components : int\n            Number of connected components.\n        \"\"\"\n        return csgraph.connected_components(\n            self.connections, directed=False, return_labels=False)",
  "def check_consistency(self):\n        \"\"\"Check consistency of the known transformations.\n\n        The complexity of this is between :math:`O(n^2)` and :math:`O(n^3)`,\n        where :math:`n` is the number of nodes. In graphs where each pair of\n        nodes is directly connected the complexity is :math:`O(n^2)`. In graphs\n        that are actually paths, the complexity is :math:`O(n^3)`.\n\n        Returns\n        -------\n        consistent : bool\n            Is the graph consistent, i.e. is A2B always the same as the inverse\n            of B2A?\n        \"\"\"\n        consistent = True\n        for node1 in self.nodes:\n            for node2 in self.nodes:\n                try:\n                    node1_to_node2 = self.get_transform(node1, node2)\n                    node2_to_node1 = self.get_transform(node2, node1)\n                    node1_to_node2_inv = invert_transform(node2_to_node1)\n                    consistent = consistent and np.allclose(node1_to_node2,\n                                                            node1_to_node2_inv)\n                except KeyError:\n                    pass  # Frames are not connected\n        return consistent",
  "def cross_product_matrix(v):\n    r\"\"\"Generate the cross-product matrix of a vector.\n\n    The cross-product matrix :math:`\\boldsymbol{V}` satisfies the equation\n\n    .. math::\n\n        \\boldsymbol{V} \\boldsymbol{w} = \\boldsymbol{v} \\times\n        \\boldsymbol{w}.\n\n    It is a skew-symmetric (antisymmetric) matrix, i.e.,\n    :math:`-\\boldsymbol{V} = \\boldsymbol{V}^T`. Its elements are\n\n    .. math::\n\n        \\left[\\boldsymbol{v}\\right]\n        =\n        \\left[\\begin{array}{c}\n        v_1\\\\ v_2\\\\ v_3\n        \\end{array}\\right]\n        =\n        \\boldsymbol{V}\n        =\n        \\left(\\begin{array}{ccc}\n        0 & -v_3 & v_2\\\\\n        v_3 & 0 & -v_1\\\\\n        -v_2 & v_1 & 0\n        \\end{array}\\right).\n\n    Parameters\n    ----------\n    v : array-like, shape (3,)\n        3d vector\n\n    Returns\n    -------\n    V : array-like, shape (3, 3)\n        Cross-product matrix\n    \"\"\"\n    return np.array([[0.0, -v[2], v[1]],\n                     [v[2], 0.0, -v[0]],\n                     [-v[1], v[0], 0.0]])",
  "def matrix_from_two_vectors(a, b):\n    \"\"\"Compute rotation matrix from two vectors.\n\n    We assume that the two given vectors form a plane so that we can compute\n    a third, orthogonal vector with the cross product.\n\n    The x-axis will point in the same direction as a, the y-axis corresponds\n    to the normalized vector rejection of b on a, and the z-axis is the\n    cross product of the other basis vectors.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        First vector, must not be 0\n\n    b : array-like, shape (3,)\n        Second vector, must not be 0 or parallel to a\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n\n    Raises\n    ------\n    ValueError\n        If vectors are parallel or one of them is the zero vector\n    \"\"\"\n    if np.linalg.norm(a) == 0:\n        raise ValueError(\"a must not be the zero vector.\")\n    if np.linalg.norm(b) == 0:\n        raise ValueError(\"b must not be the zero vector.\")\n\n    c = perpendicular_to_vectors(a, b)\n    if np.linalg.norm(c) == 0:\n        raise ValueError(\"a and b must not be parallel.\")\n\n    a = norm_vector(a)\n\n    b_on_a_projection = vector_projection(b, a)\n    b_on_a_rejection = b - b_on_a_projection\n    b = norm_vector(b_on_a_rejection)\n\n    c = norm_vector(c)\n\n    return np.column_stack((a, b, c))",
  "def matrix_from_axis_angle(a):\n    r\"\"\"Compute rotation matrix from axis-angle.\n\n    This is called exponential map or Rodrigues' formula.\n\n    .. math::\n\n        \\boldsymbol{R}(\\hat{\\boldsymbol{\\omega}}, \\theta)\n        =\n        Exp(\\hat{\\boldsymbol{\\omega}} \\theta)\n        =\n        \\cos{\\theta} \\boldsymbol{I}\n        + \\sin{\\theta} \\left[\\hat{\\boldsymbol{\\omega}}\\right]\n        + (1 - \\cos{\\theta})\n        \\hat{\\boldsymbol{\\omega}}\\hat{\\boldsymbol{\\omega}}^T\n        =\n        \\boldsymbol{I}\n        + \\sin{\\theta} \\left[\\hat{\\boldsymbol{\\omega}}\\right]\n        + (1 - \\cos{\\theta}) \\left[\\hat{\\boldsymbol{\\omega}}\\right]^2\n\n    This typically results in an active rotation matrix.\n\n    Parameters\n    ----------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    a = check_axis_angle(a)\n    ux, uy, uz, theta = a\n    c = math.cos(theta)\n    s = math.sin(theta)\n    ci = 1.0 - c\n    R = np.array([[ci * ux * ux + c,\n                   ci * ux * uy - uz * s,\n                   ci * ux * uz + uy * s],\n                  [ci * uy * ux + uz * s,\n                   ci * uy * uy + c,\n                   ci * uy * uz - ux * s],\n                  [ci * uz * ux - uy * s,\n                   ci * uz * uy + ux * s,\n                   ci * uz * uz + c],\n                  ])\n\n    # This is equivalent to\n    # R = (np.eye(3) * np.cos(a[3]) +\n    #      (1.0 - np.cos(a[3])) * a[:3, np.newaxis].dot(a[np.newaxis, :3]) +\n    #      cross_product_matrix(a[:3]) * np.sin(a[3]))\n    # or\n    # w = cross_product_matrix(a[:3])\n    # R = np.eye(3) + np.sin(a[3]) * w + (1.0 - np.cos(a[3])) * w.dot(w)\n\n    return R",
  "def matrix_from_compact_axis_angle(a):\n    r\"\"\"Compute rotation matrix from compact axis-angle.\n\n    This is called exponential map or Rodrigues' formula.\n\n    .. math::\n\n        Exp(\\hat{\\boldsymbol{\\omega}} \\theta)\n        =\n        \\cos{\\theta} \\boldsymbol{I}\n        + \\sin{\\theta} \\left[\\hat{\\boldsymbol{\\omega}}\\right]\n        + (1 - \\cos{\\theta})\n        \\hat{\\boldsymbol{\\omega}}\\hat{\\boldsymbol{\\omega}}^T\n        =\n        \\boldsymbol{I}\n        + \\sin{\\theta} \\left[\\hat{\\boldsymbol{\\omega}}\\right]\n        + (1 - \\cos{\\theta}) \\left[\\hat{\\boldsymbol{\\omega}}\\right]^2\n\n    This typically results in an active rotation matrix.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z)\n\n    Returns\n    -------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    a = axis_angle_from_compact_axis_angle(a)\n    return matrix_from_axis_angle(a)",
  "def matrix_from_quaternion(q):\n    \"\"\"Compute rotation matrix from quaternion.\n\n    This typically results in an active rotation matrix.\n\n    Parameters\n    ----------\n    q : array-like, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    Returns\n    -------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    q = check_quaternion(q)\n    uq = norm_vector(q)\n    w, x, y, z = uq\n    x2 = 2.0 * x * x\n    y2 = 2.0 * y * y\n    z2 = 2.0 * z * z\n    xy = 2.0 * x * y\n    xz = 2.0 * x * z\n    yz = 2.0 * y * z\n    xw = 2.0 * x * w\n    yw = 2.0 * y * w\n    zw = 2.0 * z * w\n\n    R = np.array([[1.0 - y2 - z2, xy - zw, xz + yw],\n                  [xy + zw, 1.0 - x2 - z2, yz - xw],\n                  [xz - yw, yz + xw, 1.0 - x2 - y2]])\n    return R",
  "def passive_matrix_from_angle(basis, angle):\n    \"\"\"Compute passive rotation matrix from rotation about basis vector.\n\n    Parameters\n    ----------\n    basis : int from [0, 1, 2]\n        The rotation axis (0: x, 1: y, 2: z)\n\n    angle : float\n        Rotation angle\n\n    Returns\n    -------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    Raises\n    ------\n    ValueError\n        If basis is invalid\n    \"\"\"\n    c = np.cos(angle)\n    s = np.sin(angle)\n\n    if basis == 0:\n        R = np.array([[1.0, 0.0, 0.0],\n                      [0.0, c, s],\n                      [0.0, -s, c]])\n    elif basis == 1:\n        R = np.array([[c, 0.0, -s],\n                      [0.0, 1.0, 0.0],\n                      [s, 0.0, c]])\n    elif basis == 2:\n        R = np.array([[c, s, 0.0],\n                      [-s, c, 0.0],\n                      [0.0, 0.0, 1.0]])\n    else:\n        raise ValueError(\"Basis must be in [0, 1, 2]\")\n\n    return R",
  "def active_matrix_from_angle(basis, angle):\n    r\"\"\"Compute active rotation matrix from rotation about basis vector.\n\n    With the angle :math:`\\alpha` and :math:`s = \\sin{\\alpha}, c=\\cos{\\alpha}`,\n    we construct rotation matrices about the basis vectors as follows:\n\n    .. math::\n\n        \\boldsymbol{R}_x(\\alpha) =\n        \\left(\n        \\begin{array}{ccc}\n        1 & 0 & 0\\\\\n        0 & c & -s\\\\\n        0 & s & c\n        \\end{array}\n        \\right)\n\n    .. math::\n\n        \\boldsymbol{R}_y(\\alpha) =\n        \\left(\n        \\begin{array}{ccc}\n        c & 0 & s\\\\\n        0 & 1 & 0\\\\\n        -s & 0 & c\n        \\end{array}\n        \\right)\n\n    .. math::\n\n        \\boldsymbol{R}_z(\\alpha) =\n        \\left(\n        \\begin{array}{ccc}\n        c & -s & 0\\\\\n        s & c & 0\\\\\n        0 & 0 & 1\n        \\end{array}\n        \\right)\n\n    Parameters\n    ----------\n    basis : int from [0, 1, 2]\n        The rotation axis (0: x, 1: y, 2: z)\n\n    angle : float\n        Rotation angle\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n\n    Raises\n    ------\n    ValueError\n        If basis is invalid\n    \"\"\"\n    c = np.cos(angle)\n    s = np.sin(angle)\n\n    if basis == 0:\n        R = np.array([[1.0, 0.0, 0.0],\n                      [0.0, c, -s],\n                      [0.0, s, c]])\n    elif basis == 1:\n        R = np.array([[c, 0.0, s],\n                      [0.0, 1.0, 0.0],\n                      [-s, 0.0, c]])\n    elif basis == 2:\n        R = np.array([[c, -s, 0.0],\n                      [s, c, 0.0],\n                      [0.0, 0.0, 1.0]])\n    else:\n        raise ValueError(\"Basis must be in [0, 1, 2]\")\n\n    return R",
  "def active_matrix_from_intrinsic_euler_xzx(e):\n    \"\"\"Compute active rotation matrix from intrinsic xzx Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around x-, z'-, and x''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(0, alpha).dot(\n        active_matrix_from_angle(2, beta)).dot(\n        active_matrix_from_angle(0, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_xzx(e):\n    \"\"\"Compute active rotation matrix from extrinsic xzx Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around x-, z-, and x-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(0, gamma).dot(\n        active_matrix_from_angle(2, beta)).dot(\n        active_matrix_from_angle(0, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_xyx(e):\n    \"\"\"Compute active rotation matrix from intrinsic xyx Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around x-, y'-, and x''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(0, alpha).dot(\n        active_matrix_from_angle(1, beta)).dot(\n        active_matrix_from_angle(0, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_xyx(e):\n    \"\"\"Compute active rotation matrix from extrinsic xyx Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around x-, y-, and x-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(0, gamma).dot(\n        active_matrix_from_angle(1, beta)).dot(\n        active_matrix_from_angle(0, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_yxy(e):\n    \"\"\"Compute active rotation matrix from intrinsic yxy Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around y-, x'-, and y''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(1, alpha).dot(\n        active_matrix_from_angle(0, beta)).dot(\n        active_matrix_from_angle(1, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_yxy(e):\n    \"\"\"Compute active rotation matrix from extrinsic yxy Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around y-, x-, and y-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(1, gamma).dot(\n        active_matrix_from_angle(0, beta)).dot(\n        active_matrix_from_angle(1, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_yzy(e):\n    \"\"\"Compute active rotation matrix from intrinsic yzy Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around y-, z'-, and y''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(1, alpha).dot(\n        active_matrix_from_angle(2, beta)).dot(\n        active_matrix_from_angle(1, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_yzy(e):\n    \"\"\"Compute active rotation matrix from extrinsic yzy Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around y-, z-, and y-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(1, gamma).dot(\n        active_matrix_from_angle(2, beta)).dot(\n        active_matrix_from_angle(1, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_zyz(e):\n    \"\"\"Compute active rotation matrix from intrinsic zyz Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around z-, y'-, and z''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(2, alpha).dot(\n        active_matrix_from_angle(1, beta)).dot(\n        active_matrix_from_angle(2, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_zyz(e):\n    \"\"\"Compute active rotation matrix from extrinsic zyz Euler angles.\n\n    .. warning::\n\n        This function was not implemented correctly in versions 1.3 and 1.4\n        as the order of the angles was reversed, which actually corresponds\n        to intrinsic rotations. This has been fixed in version 1.5.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around z-, y-, and z-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(2, gamma).dot(\n        active_matrix_from_angle(1, beta)).dot(\n        active_matrix_from_angle(2, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_zxz(e):\n    \"\"\"Compute active rotation matrix from intrinsic zxz Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around z-, x'-, and z''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(2, alpha).dot(\n        active_matrix_from_angle(0, beta)).dot(\n        active_matrix_from_angle(2, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_zxz(e):\n    \"\"\"Compute active rotation matrix from extrinsic zxz Euler angles.\n\n    .. warning::\n\n        This function was not implemented correctly in versions 1.3 and 1.4\n        as the order of the angles was reversed, which actually corresponds\n        to intrinsic rotations. This has been fixed in version 1.5.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around z-, x-, and z-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(2, gamma).dot(\n        active_matrix_from_angle(0, beta)).dot(\n        active_matrix_from_angle(2, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_xzy(e):\n    \"\"\"Compute active rotation matrix from intrinsic xzy Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around x-, z'-, and y''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(0, alpha).dot(\n        active_matrix_from_angle(2, beta)).dot(\n        active_matrix_from_angle(1, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_xzy(e):\n    \"\"\"Compute active rotation matrix from extrinsic xzy Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around x-, z-, and y-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(1, gamma).dot(\n        active_matrix_from_angle(2, beta)).dot(\n        active_matrix_from_angle(0, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_xyz(e):\n    \"\"\"Compute active rotation matrix from intrinsic xyz Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around x-, y'-, and z''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(0, alpha).dot(\n        active_matrix_from_angle(1, beta)).dot(\n        active_matrix_from_angle(2, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_xyz(e):\n    \"\"\"Compute active rotation matrix from extrinsic xyz Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around x-, y-, and z-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(2, gamma).dot(\n        active_matrix_from_angle(1, beta)).dot(\n        active_matrix_from_angle(0, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_yxz(e):\n    \"\"\"Compute active rotation matrix from intrinsic yxz Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around y-, x'-, and z''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(1, alpha).dot(\n        active_matrix_from_angle(0, beta)).dot(\n        active_matrix_from_angle(2, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_yxz(e):\n    \"\"\"Compute active rotation matrix from extrinsic yxz Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around y-, x-, and z-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(2, gamma).dot(\n        active_matrix_from_angle(0, beta)).dot(\n        active_matrix_from_angle(1, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_yzx(e):\n    \"\"\"Compute active rotation matrix from intrinsic yzx Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around y-, z'-, and x''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(1, alpha).dot(\n        active_matrix_from_angle(2, beta)).dot(\n        active_matrix_from_angle(0, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_yzx(e):\n    \"\"\"Compute active rotation matrix from extrinsic yzx Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around y-, z-, and x-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(0, gamma).dot(\n        active_matrix_from_angle(2, beta)).dot(\n        active_matrix_from_angle(1, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_zyx(e):\n    \"\"\"Compute active rotation matrix from intrinsic zyx Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around z-, y'-, and x''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(2, alpha).dot(\n        active_matrix_from_angle(1, beta)).dot(\n        active_matrix_from_angle(0, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_zyx(e):\n    \"\"\"Compute active rotation matrix from extrinsic zyx Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around z-, y-, and x-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(0, gamma).dot(\n        active_matrix_from_angle(1, beta)).dot(\n        active_matrix_from_angle(2, alpha))\n    return R",
  "def active_matrix_from_intrinsic_euler_zxy(e):\n    \"\"\"Compute active rotation matrix from intrinsic zxy Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around z-, x'-, and y''-axes (intrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(2, alpha).dot(\n        active_matrix_from_angle(0, beta)).dot(\n        active_matrix_from_angle(1, gamma))\n    return R",
  "def active_matrix_from_extrinsic_euler_zxy(e):\n    \"\"\"Compute active rotation matrix from extrinsic zxy Cardan angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around z-, x-, and y-axes (extrinsic rotations)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    alpha, beta, gamma = e\n    R = active_matrix_from_angle(1, gamma).dot(\n        active_matrix_from_angle(0, beta)).dot(\n        active_matrix_from_angle(2, alpha))\n    return R",
  "def active_matrix_from_extrinsic_roll_pitch_yaw(rpy):\n    \"\"\"Compute active rotation matrix from extrinsic roll, pitch, and yaw.\n\n    Parameters\n    ----------\n    rpy : array-like, shape (3,)\n        Angles for rotation around x- (roll), y- (pitch), and z-axes (yaw),\n        extrinsic rotations\n\n    Returns\n    -------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    return active_matrix_from_extrinsic_euler_xyz(rpy)",
  "def check_axis_index(name, i):\n    \"\"\"Checks axis index.\n\n    Parameters\n    ----------\n    name : str\n        Name of the axis. Required for the error message.\n\n    i : int from [0, 1, 2]\n        Index of the axis (0: x, 1: y, 2: z)\n\n    Raises\n    ------\n    ValueError\n        If basis is invalid\n    \"\"\"\n    if i not in [0, 1, 2]:\n        raise ValueError(\"Axis index %s (%d) must be in [0, 1, 2]\" % (name, i))",
  "def matrix_from_euler(e, i, j, k, extrinsic):\n    \"\"\"General method to compute active rotation matrix from any Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Extracted rotation angles in radians about the axes i, j, k in this\n        order. The first and last angle are normalized to [-pi, pi]. The middle\n        angle is normalized to either [0, pi] (proper Euler angles) or\n        [-pi/2, pi/2] (Cardan / Tait-Bryan angles).\n\n    i : int from [0, 1, 2]\n        The first rotation axis (0: x, 1: y, 2: z)\n\n    j : int from [0, 1, 2]\n        The second rotation axis (0: x, 1: y, 2: z)\n\n    k : int from [0, 1, 2]\n        The third rotation axis (0: x, 1: y, 2: z)\n\n    extrinsic : bool\n        Do we use extrinsic transformations? Intrinsic otherwise.\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Active rotation matrix\n\n    Raises\n    ------\n    ValueError\n        If basis is invalid\n    \"\"\"\n    check_axis_index(\"i\", i)\n    check_axis_index(\"j\", j)\n    check_axis_index(\"k\", k)\n\n    alpha, beta, gamma = e\n    if not extrinsic:\n        i, k = k, i\n        alpha, gamma = gamma, alpha\n    R = active_matrix_from_angle(k, gamma).dot(\n        active_matrix_from_angle(j, beta)).dot(\n        active_matrix_from_angle(i, alpha))\n    return R",
  "def _general_intrinsic_euler_from_active_matrix(\n        R, n1, n2, n3, proper_euler, strict_check=True):\n    \"\"\"General algorithm to extract intrinsic euler angles from a matrix.\n\n    The implementation is based on SciPy's implementation:\n    https://github.com/scipy/scipy/blob/743c283bbe79473a03ca2eddaa537661846d8a19/scipy/spatial/transform/_rotation.pyx\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Active rotation matrix\n\n    n1 : array, shape (3,)\n        First rotation axis (basis vector)\n\n    n2 : array, shape (3,)\n        Second rotation axis (basis vector)\n\n    n3 : array, shape (3,)\n        Third rotation axis (basis vector)\n\n    proper_euler : bool\n        Is this an Euler angle convention or a Cardan / Tait-Bryan convention?\n        Proper Euler angles rotate about the same axis twice, for example,\n        z, y', and z''.\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    euler_angles : array, shape (3,)\n        Extracted intrinsic rotation angles in radians about the axes\n        n1, n2, and n3 in this order. The first and last angle are\n        normalized to [-pi, pi]. The middle angle is normalized to\n        either [0, pi] (proper Euler angles) or [-pi/2, pi/2]\n        (Cardan / Tait-Bryan angles).\n\n    References\n    ----------\n    Shuster, Markley: General Formula for Extracting the Euler Angles,\n    https://arc.aiaa.org/doi/abs/10.2514/1.16622\n    \"\"\"\n    D = check_matrix(R, strict_check=strict_check)\n\n    # Differences to the paper:\n    # - we call the angles alpha, beta, and gamma\n    # - we obtain angles from intrinsic rotations, thus some matrices are\n    #   transposed like in SciPy's implementation\n\n    # Step 2\n    # - Equation 5\n    n1_cross_n2 = np.cross(n1, n2)\n    lmbda = np.arctan2(\n        np.dot(n1_cross_n2, n3),\n        np.dot(n1, n3)\n    )\n    # - Equation 6\n    C = np.vstack((n2, n1_cross_n2, n1))\n\n    # Step 3\n    # - Equation 8\n    CDCT = np.dot(np.dot(C, D), C.T)\n    O = np.dot(CDCT, active_matrix_from_angle(0, lmbda).T)\n\n    # Step 4\n    # Fix numerical issue if O_22 is slightly out of range of arccos\n    O_22 = max(min(O[2, 2], 1.0), -1.0)\n    # - Equation 10a\n    beta = lmbda + np.arccos(O_22)\n\n    safe1 = abs(beta - lmbda) >= np.finfo(float).eps\n    safe2 = abs(beta - lmbda - np.pi) >= np.finfo(float).eps\n    if safe1 and safe2:  # Default case, no gimbal lock\n        # Step 5\n        # - Equation 10b\n        alpha = np.arctan2(O[0, 2], -O[1, 2])\n        # - Equation 10c\n        gamma = np.arctan2(O[2, 0], O[2, 1])\n\n        # Step 7\n        if proper_euler:\n            valid_beta = 0.0 <= beta <= np.pi\n        else:  # Cardan / Tait-Bryan angles\n            valid_beta = -0.5 * np.pi <= beta <= 0.5 * np.pi\n        # - Equation 12\n        if not valid_beta:\n            alpha += np.pi\n            beta = 2.0 * lmbda - beta\n            gamma -= np.pi\n    else:\n        # Step 6 - Handle gimbal locks\n        # a)\n        gamma = 0.0\n        if not safe1:\n            # b)\n            alpha = np.arctan2(O[1, 0] - O[0, 1], O[0, 0] + O[1, 1])\n        else:\n            # c)\n            alpha = np.arctan2(O[1, 0] + O[0, 1], O[0, 0] - O[1, 1])\n    euler_angles = norm_angle([alpha, beta, gamma])\n    return euler_angles",
  "def intrinsic_euler_xzx_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic xzx Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around x-, z'-, and x''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitx, unitz, unitx, True, strict_check)",
  "def extrinsic_euler_xzx_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic xzx Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around x-, z-, and x-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitx, unitz, unitx, True, strict_check)[::-1]",
  "def intrinsic_euler_xyx_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic xyx Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around x-, y'-, and x''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitx, unity, unitx, True, strict_check)",
  "def extrinsic_euler_xyx_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic xyx Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around x-, y-, and x-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitx, unity, unitx, True, strict_check)[::-1]",
  "def intrinsic_euler_yxy_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic yxy Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around y-, x'-, and y''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unity, unitx, unity, True, strict_check)",
  "def extrinsic_euler_yxy_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic yxy Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around y-, x-, and y-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unity, unitx, unity, True, strict_check)[::-1]",
  "def intrinsic_euler_yzy_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic yzy Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around y-, z'-, and y''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unity, unitz, unity, True, strict_check)",
  "def extrinsic_euler_yzy_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic yzy Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around y-, z-, and y-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unity, unitz, unity, True, strict_check)[::-1]",
  "def intrinsic_euler_zyz_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic zyz Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around z-, y'-, and z''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitz, unity, unitz, True, strict_check)",
  "def extrinsic_euler_zyz_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic zyz Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around z-, y-, and z-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitz, unity, unitz, True, strict_check)[::-1]",
  "def intrinsic_euler_zxz_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic zxz Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around z-, x'-, and z''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitz, unitx, unitz, True, strict_check)",
  "def extrinsic_euler_zxz_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic zxz Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around z-, x-, and z-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitz, unitx, unitz, True, strict_check)[::-1]",
  "def intrinsic_euler_xzy_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic xzy Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around x-, z'-, and y''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitx, unitz, unity, False, strict_check)",
  "def extrinsic_euler_xzy_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic xzy Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around x-, z-, and y-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unity, unitz, unitx, False, strict_check)[::-1]",
  "def intrinsic_euler_xyz_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic xyz Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around x-, y'-, and z''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitx, unity, unitz, False, strict_check)",
  "def extrinsic_euler_xyz_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic xyz Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around x-, y-, and z-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitz, unity, unitx, False, strict_check)[::-1]",
  "def intrinsic_euler_yxz_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic yxz Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around y-, x'-, and z''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unity, unitx, unitz, False, strict_check)",
  "def extrinsic_euler_yxz_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic yxz Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around y-, x-, and z-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitz, unitx, unity, False, strict_check)[::-1]",
  "def intrinsic_euler_yzx_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic yzx Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around y-, z'-, and x''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unity, unitz, unitx, False, strict_check)",
  "def extrinsic_euler_yzx_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic yzx Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around y-, z-, and x-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitx, unitz, unity, False, strict_check)[::-1]",
  "def intrinsic_euler_zyx_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic zyx Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around z-, y'-, and x''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitz, unity, unitx, False, strict_check)",
  "def extrinsic_euler_zyx_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic zyx Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around z-, y-, and x-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitx, unity, unitz, False, strict_check)[::-1]",
  "def intrinsic_euler_zxy_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute intrinsic zxy Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around z-, x'-, and y''-axes (intrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unitz, unitx, unity, False, strict_check)",
  "def extrinsic_euler_zxy_from_active_matrix(R, strict_check=True):\n    \"\"\"Compute extrinsic zxy Cardan angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    e : array, shape (3,)\n        Angles for rotation around z-, x-, and y-axes (extrinsic rotations)\n    \"\"\"\n    return _general_intrinsic_euler_from_active_matrix(\n        R, unity, unitx, unitz, False, strict_check)[::-1]",
  "def euler_from_matrix(R, i, j, k, extrinsic, strict_check=True):\n    \"\"\"General method to extract any Euler angles from active rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Active rotation matrix\n\n    i : int from [0, 1, 2]\n        The first rotation axis (0: x, 1: y, 2: z)\n\n    j : int from [0, 1, 2]\n        The second rotation axis (0: x, 1: y, 2: z)\n\n    k : int from [0, 1, 2]\n        The third rotation axis (0: x, 1: y, 2: z)\n\n    extrinsic : bool\n        Do we use extrinsic transformations? Intrinsic otherwise.\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    euler_angles : array, shape (3,)\n        Extracted rotation angles in radians about the axes i, j, k in this\n        order. The first and last angle are normalized to [-pi, pi]. The middle\n        angle is normalized to either [0, pi] (proper Euler angles) or\n        [-pi/2, pi/2] (Cardan / Tait-Bryan angles).\n\n    Raises\n    ------\n    ValueError\n        If basis is invalid\n\n    References\n    ----------\n    Shuster, Markley: General Formula for Extracting the Euler Angles,\n    https://arc.aiaa.org/doi/abs/10.2514/1.16622\n    \"\"\"\n    check_axis_index(\"i\", i)\n    check_axis_index(\"j\", j)\n    check_axis_index(\"k\", k)\n\n    basis_vectors = [unitx, unity, unitz]\n    proper_euler = i == k\n    if extrinsic:\n        i, k = k, i\n    e = _general_intrinsic_euler_from_active_matrix(\n        R, basis_vectors[i], basis_vectors[j], basis_vectors[k], proper_euler,\n        strict_check)\n\n    if extrinsic:\n        e = e[::-1]\n\n    return e",
  "def euler_from_quaternion(q, i, j, k, extrinsic):\n    \"\"\"General method to extract any Euler angles from quaternions.\n\n    Parameters\n    ----------\n    q : array-like, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    i : int from [0, 1, 2]\n        The first rotation axis (0: x, 1: y, 2: z)\n\n    j : int from [0, 1, 2]\n        The second rotation axis (0: x, 1: y, 2: z)\n\n    k : int from [0, 1, 2]\n        The third rotation axis (0: x, 1: y, 2: z)\n\n    extrinsic : bool\n        Do we use extrinsic transformations? Intrinsic otherwise.\n\n    Returns\n    -------\n    euler_angles : array, shape (3,)\n        Extracted rotation angles in radians about the axes i, j, k in this\n        order. The first and last angle are normalized to [-pi, pi]. The middle\n        angle is normalized to either [0, pi] (proper Euler angles) or\n        [-pi/2, pi/2] (Cardan / Tait-Bryan angles).\n\n    Raises\n    ------\n    ValueError\n        If basis is invalid\n\n    References\n    ----------\n    Bernardes, Evandro; Viollet, Stephane: Quaternion to Euler angles\n    conversion: A direct, general and computationally efficient method,\n    https://doi.org/10.1371/journal.pone.0276302\n    \"\"\"\n    q = check_quaternion(q)\n\n    check_axis_index(\"i\", i)\n    check_axis_index(\"j\", j)\n    check_axis_index(\"k\", k)\n\n    i += 1\n    j += 1\n    k += 1\n\n    # The original algorithm assumes extrinsic convention. Hence, we swap\n    # the order of axes for intrinsic rotation.\n    if not extrinsic:\n        i, k = k, i\n\n    # Proper Euler angles rotate about the same axis in the first and last\n    # rotation. If this is not the case, they are called Cardan or Tait-Bryan\n    # angles and have to be handled differently.\n    proper_euler = i == k\n    if proper_euler:\n        k = 6 - i - j\n\n    sign = (i - j) * (j - k) * (k - i) // 2\n    a = q[0]\n    b = q[i]\n    c = q[j]\n    d = q[k] * sign\n\n    if not proper_euler:\n        a, b, c, d = a - c, b + d, c + a, d - b\n\n    # Equation 34 is used instead of Equation 35 as atan2 it is numerically\n    # more accurate than acos.\n    angle_j = 2.0 * math.atan2(math.hypot(c, d),\n                               math.hypot(a, b))\n\n    # Check for singularities\n    if abs(angle_j) <= eps:\n        singularity = 1\n    elif abs(angle_j - math.pi) <= eps:\n        singularity = 2\n    else:\n        singularity = 0\n\n    # Equation 25\n    # (theta_1 + theta_3) / 2\n    half_sum = math.atan2(b, a)\n    # (theta_1 - theta_3) / 2\n    half_diff = math.atan2(d, c)\n\n    if singularity == 0:  # no singularity\n        # Equation 32\n        angle_i = half_sum + half_diff\n        angle_k = half_sum - half_diff\n    elif extrinsic:  # singularity\n        angle_k = 0.0\n        if singularity == 1:\n            angle_i = 2.0 * half_sum\n        else:\n            assert singularity == 2\n            angle_i = 2.0 * half_diff\n    else:  # intrinsic, singularity\n        angle_i = 0.0\n        if singularity == 1:\n            angle_k = 2.0 * half_sum\n        else:\n            assert singularity == 2\n            angle_k = -2.0 * half_diff\n\n    if not proper_euler:\n        # Equation 43\n        angle_j -= math.pi / 2.0\n        # Equation 44\n        angle_i *= sign\n\n    angle_k = norm_angle(angle_k)\n    angle_i = norm_angle(angle_i)\n\n    if extrinsic:\n        return np.array([angle_k, angle_j, angle_i])\n\n    return np.array([angle_i, angle_j, angle_k])",
  "def axis_angle_from_matrix(R, strict_check=True, check=True):\n    \"\"\"Compute axis-angle from rotation matrix.\n\n    This operation is called logarithmic map. Note that there are two possible\n    solutions for the rotation axis when the angle is 180 degrees (pi).\n\n    We usually assume active rotations.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    check : bool, optional (default: True)\n        Check if rotation matrix is valid\n\n    Returns\n    -------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle). The angle is\n        constrained to [0, pi].\n    \"\"\"\n    if check:\n        R = check_matrix(R, strict_check=strict_check)\n    cos_angle = (np.trace(R) - 1.0) / 2.0\n    angle = np.arccos(min(max(-1.0, cos_angle), 1.0))\n\n    if angle == 0.0:  # R == np.eye(3)\n        return np.array([1.0, 0.0, 0.0, 0.0])\n\n    a = np.empty(4)\n\n    # We can usually determine the rotation axis by inverting Rodrigues'\n    # formula. Subtracting opposing off-diagonal elements gives us\n    # 2 * sin(angle) * e,\n    # where e is the normalized rotation axis.\n    axis_unnormalized = np.array(\n        [R[2, 1] - R[1, 2], R[0, 2] - R[2, 0], R[1, 0] - R[0, 1]])\n\n    if abs(angle - np.pi) < 1e-4:  # np.trace(R) close to -1\n        # The threshold 1e-4 is a result from this discussion:\n        # https://github.com/dfki-ric/pytransform3d/issues/43\n        # The standard formula becomes numerically unstable, however,\n        # Rodrigues' formula reduces to R = I + 2 (ee^T - I), with the\n        # rotation axis e, that is, ee^T = 0.5 * (R + I) and we can find the\n        # squared values of the rotation axis on the diagonal of this matrix.\n        # We can still use the original formula to reconstruct the signs of\n        # the rotation axis correctly.\n\n        # In case of floating point inaccuracies:\n        R_diag = np.clip(np.diag(R), -1.0, 1.0)\n\n        eeT_diag = 0.5 * (R_diag + 1.0)\n        signs = np.sign(axis_unnormalized)\n        signs[signs == 0.0] = 1.0\n        a[:3] = np.sqrt(eeT_diag) * signs\n    else:\n        a[:3] = axis_unnormalized\n        # The norm of axis_unnormalized is 2.0 * np.sin(angle), that is, we\n        # could normalize with a[:3] = a[:3] / (2.0 * np.sin(angle)),\n        # but the following is much more precise for angles close to 0 or pi:\n    a[:3] /= np.linalg.norm(a[:3])\n\n    a[3] = angle\n    return a",
  "def axis_angle_from_quaternion(q):\n    \"\"\"Compute axis-angle from quaternion.\n\n    This operation is called logarithmic map.\n\n    We usually assume active rotations.\n\n    Parameters\n    ----------\n    q : array-like, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    Returns\n    -------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle). The angle is\n        constrained to [0, pi) so that the mapping is unique.\n    \"\"\"\n    q = check_quaternion(q)\n    p = q[1:]\n    p_norm = np.linalg.norm(p)\n\n    if p_norm < np.finfo(float).eps:\n        return np.array([1.0, 0.0, 0.0, 0.0])\n\n    axis = p / p_norm\n    w_clamped = max(min(q[0], 1.0), -1.0)\n    angle = (2.0 * np.arccos(w_clamped),)\n    return norm_axis_angle(np.hstack((axis, angle)))",
  "def axis_angle_from_compact_axis_angle(a):\n    \"\"\"Compute axis-angle from compact axis-angle representation.\n\n    We usually assume active rotations.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z).\n\n    Returns\n    -------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle). The angle is\n        constrained to [0, pi].\n    \"\"\"\n    a = check_compact_axis_angle(a)\n    angle = np.linalg.norm(a)\n\n    if angle == 0.0:\n        return np.array([1.0, 0.0, 0.0, 0.0])\n\n    axis = a / angle\n    return np.hstack((axis, (angle,)))",
  "def axis_angle_from_two_directions(a, b):\n    \"\"\"Compute axis-angle representation from two direction vectors.\n\n    The rotation will transform direction vector a to direction vector b.\n    The direction vectors don't have to be normalized as this will be\n    done internally. Note that there is more than one possible solution.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        First direction vector\n\n    b : array-like, shape (3,)\n        Second direction vector\n\n    Returns\n    -------\n    a : array, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle). The angle is\n        constrained to [0, pi].\n    \"\"\"\n    a = norm_vector(a)\n    b = norm_vector(b)\n    cos_angle = a.dot(b)\n    if abs(-1.0 - cos_angle) < eps:\n        # For 180 degree rotations we have an infinite number of solutions,\n        # but we have to pick one axis.\n        axis = perpendicular_to_vector(a)\n    else:\n        axis = np.cross(a, b)\n    aa = np.empty(4)\n    aa[:3] = norm_vector(axis)\n    aa[3] = np.arccos(max(min(cos_angle, 1.0), -1.0))\n    return norm_axis_angle(aa)",
  "def compact_axis_angle(a):\n    r\"\"\"Compute 3-dimensional axis-angle from a 4-dimensional one.\n\n    In a 3-dimensional axis-angle, the 4th dimension (the rotation) is\n    represented by the norm of the rotation axis vector, which means we\n    transform :math:`\\left( \\boldsymbol{\\hat{e}}, \\theta \\right)` to\n    :math:`\\theta \\boldsymbol{\\hat{e}}`.\n\n    We usually assume active rotations.\n\n    Parameters\n    ----------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle).\n\n    Returns\n    -------\n    a : array-like, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z) (compact\n        representation).\n    \"\"\"\n    a = check_axis_angle(a)\n    return a[:3] * a[3]",
  "def compact_axis_angle_from_matrix(R, check=True):\n    \"\"\"Compute compact axis-angle from rotation matrix.\n\n    This operation is called logarithmic map. Note that there are two possible\n    solutions for the rotation axis when the angle is 180 degrees (pi).\n\n    We usually assume active rotations.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    check : bool, optional (default: True)\n        Check if rotation matrix is valid\n\n    Returns\n    -------\n    a : array-like, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z). The angle is\n        constrained to [0, pi].\n    \"\"\"\n    a = axis_angle_from_matrix(R, check=check)\n    return compact_axis_angle(a)",
  "def compact_axis_angle_from_quaternion(q):\n    \"\"\"Compute compact axis-angle from quaternion (logarithmic map).\n\n    We usually assume active rotations.\n\n    Parameters\n    ----------\n    q : array-like, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    Returns\n    -------\n    a : array-like, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z). The angle is\n        constrained to [0, pi].\n    \"\"\"\n    a = axis_angle_from_quaternion(q)\n    return compact_axis_angle(a)",
  "def quaternion_from_matrix(R, strict_check=True):\n    \"\"\"Compute quaternion from rotation matrix.\n\n    We usually assume active rotations.\n\n    .. warning::\n\n        When computing a quaternion from the rotation matrix there is a sign\n        ambiguity: q and -q represent the same rotation.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    q : array-like, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n    \"\"\"\n    R = check_matrix(R, strict_check=strict_check)\n    q = np.empty(4)\n\n    # Source:\n    # http://www.euclideanspace.com/maths/geometry/rotations/conversions\n    trace = np.trace(R)\n    if trace > 0.0:\n        sqrt_trace = np.sqrt(1.0 + trace)\n        q[0] = 0.5 * sqrt_trace\n        q[1] = 0.5 / sqrt_trace * (R[2, 1] - R[1, 2])\n        q[2] = 0.5 / sqrt_trace * (R[0, 2] - R[2, 0])\n        q[3] = 0.5 / sqrt_trace * (R[1, 0] - R[0, 1])\n    else:\n        if R[0, 0] > R[1, 1] and R[0, 0] > R[2, 2]:\n            sqrt_trace = np.sqrt(1.0 + R[0, 0] - R[1, 1] - R[2, 2])\n            q[0] = 0.5 / sqrt_trace * (R[2, 1] - R[1, 2])\n            q[1] = 0.5 * sqrt_trace\n            q[2] = 0.5 / sqrt_trace * (R[1, 0] + R[0, 1])\n            q[3] = 0.5 / sqrt_trace * (R[0, 2] + R[2, 0])\n        elif R[1, 1] > R[2, 2]:\n            sqrt_trace = np.sqrt(1.0 + R[1, 1] - R[0, 0] - R[2, 2])\n            q[0] = 0.5 / sqrt_trace * (R[0, 2] - R[2, 0])\n            q[1] = 0.5 / sqrt_trace * (R[1, 0] + R[0, 1])\n            q[2] = 0.5 * sqrt_trace\n            q[3] = 0.5 / sqrt_trace * (R[2, 1] + R[1, 2])\n        else:\n            sqrt_trace = np.sqrt(1.0 + R[2, 2] - R[0, 0] - R[1, 1])\n            q[0] = 0.5 / sqrt_trace * (R[1, 0] - R[0, 1])\n            q[1] = 0.5 / sqrt_trace * (R[0, 2] + R[2, 0])\n            q[2] = 0.5 / sqrt_trace * (R[2, 1] + R[1, 2])\n            q[3] = 0.5 * sqrt_trace\n    return q",
  "def quaternion_from_angle(basis, angle):\n    \"\"\"Compute quaternion from rotation about basis vector.\n\n    Parameters\n    ----------\n    basis : int from [0, 1, 2]\n        The rotation axis (0: x, 1: y, 2: z)\n\n    angle : float\n        Rotation angle\n\n    Returns\n    -------\n    q : array, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    Raises\n    ------\n    ValueError\n        If basis is invalid\n    \"\"\"\n    half_angle = 0.5 * angle\n    c = math.cos(half_angle)\n    s = math.sin(half_angle)\n\n    if basis == 0:\n        q = np.array([c, s, 0.0, 0.0])\n    elif basis == 1:\n        q = np.array([c, 0.0, s, 0.0])\n    elif basis == 2:\n        q = np.array([c, 0.0, 0.0, s])\n    else:\n        raise ValueError(\"Basis must be in [0, 1, 2]\")\n\n    return q",
  "def quaternion_from_axis_angle(a):\n    \"\"\"Compute quaternion from axis-angle.\n\n    This operation is called exponential map.\n\n    We usually assume active rotations.\n\n    Parameters\n    ----------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle)\n\n    Returns\n    -------\n    q : array, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n    \"\"\"\n    a = check_axis_angle(a)\n    theta = a[3]\n\n    q = np.empty(4)\n    q[0] = np.cos(theta / 2)\n    q[1:] = np.sin(theta / 2) * a[:3]\n    return q",
  "def quaternion_from_compact_axis_angle(a):\n    \"\"\"Compute quaternion from compact axis-angle (exponential map).\n\n    We usually assume active rotations.\n\n    Parameters\n    ----------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: angle * (x, y, z)\n\n    Returns\n    -------\n    q : array, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n    \"\"\"\n    a = axis_angle_from_compact_axis_angle(a)\n    return quaternion_from_axis_angle(a)",
  "def quaternion_xyzw_from_wxyz(q_wxyz):\n    \"\"\"Converts from w, x, y, z to x, y, z, w convention.\n\n    Parameters\n    ----------\n    q_wxyz : array-like, shape (4,)\n        Quaternion with scalar part before vector part\n\n    Returns\n    -------\n    q_xyzw : array, shape (4,)\n        Quaternion with scalar part after vector part\n    \"\"\"\n    q_wxyz = check_quaternion(q_wxyz)\n    return np.array([q_wxyz[1], q_wxyz[2], q_wxyz[3], q_wxyz[0]])",
  "def quaternion_wxyz_from_xyzw(q_xyzw):\n    \"\"\"Converts from x, y, z, w to w, x, y, z convention.\n\n    Parameters\n    ----------\n    q_xyzw : array-like, shape (4,)\n        Quaternion with scalar part after vector part\n\n    Returns\n    -------\n    q_wxyz : array, shape (4,)\n        Quaternion with scalar part before vector part\n    \"\"\"\n    q_xyzw = check_quaternion(q_xyzw)\n    return np.array([q_xyzw[3], q_xyzw[0], q_xyzw[1], q_xyzw[2]])",
  "def quaternion_from_extrinsic_euler_xyz(e):\n    \"\"\"Compute quaternion from extrinsic xyz Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Angles for rotation around x-, y-, and z-axes (extrinsic rotations)\n\n    Returns\n    -------\n    q : array, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n    \"\"\"\n    warnings.warn(\n        \"quaternion_from_extrinsic_euler_xyz is deprecated, use \"\n        \"quaternion_from_euler\", DeprecationWarning)\n    R = active_matrix_from_extrinsic_euler_xyz(e)\n    return quaternion_from_matrix(R)",
  "def quaternion_from_mrp(mrp):\n    \"\"\"Compute quaternion from modified Rodrigues parameters.\n\n    Parameters\n    ----------\n    mrp : array-like, shape (3,)\n        Modified Rodrigues parameters.\n\n    Returns\n    -------\n    q : array, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n    \"\"\"\n    mrp = check_mrp(mrp)\n    dot_product_p1 = np.dot(mrp, mrp) + 1.0\n    q = np.empty(4, dtype=float)\n    q[0] = (2.0 - dot_product_p1) / dot_product_p1\n    q[1:] = 2.0 * mrp / dot_product_p1\n    return q",
  "def mrp_from_quaternion(q):\n    \"\"\"Compute modified Rodrigues parameters from quaternion.\n\n    Parameters\n    ----------\n    q : array-like, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    Returns\n    -------\n    mrp : array, shape (3,)\n        Modified Rodrigues parameters.\n    \"\"\"\n    q = check_quaternion(q)\n    if q[0] < 0.0:\n        q = -q\n    return q[1:] / (1.0 + q[0])",
  "def left_jacobian_SO3(omega):\n    r\"\"\"Left Jacobian of SO(3) at theta (angle of rotation).\n\n    .. math::\n\n        \\boldsymbol{J}(\\theta)\n        =\n        \\frac{\\sin{\\theta}}{\\theta} \\boldsymbol{I}\n        + \\left(\\frac{1 - \\cos{\\theta}}{\\theta}\\right)\n        \\left[\\hat{\\boldsymbol{\\omega}}\\right]\n        + \\left(1 - \\frac{\\sin{\\theta}}{\\theta} \\right)\n        \\hat{\\boldsymbol{\\omega}} \\hat{\\boldsymbol{\\omega}}^T\n\n    Parameters\n    ----------\n    omega : array-like, shape (3,)\n        Compact axis-angle representation.\n\n    Returns\n    -------\n    J : array, shape (3, 3)\n        Left Jacobian of SO(3).\n    \"\"\"\n    omega = np.asarray(omega)\n    theta = np.linalg.norm(omega)\n    if theta < np.finfo(float).eps:\n        return left_jacobian_SO3_series(omega, 10)\n    omega_unit = omega / theta\n    omega_matrix = cross_product_matrix(omega_unit)\n    return (\n        np.eye(3)\n        + (1.0 - math.cos(theta)) / theta * omega_matrix\n        + (1.0 - math.sin(theta) / theta) * np.dot(omega_matrix, omega_matrix)\n    )",
  "def left_jacobian_SO3_series(omega, n_terms):\n    \"\"\"Left Jacobian of SO(3) at theta from Taylor series.\n\n    Parameters\n    ----------\n    omega : array-like, shape (3,)\n        Compact axis-angle representation.\n\n    n_terms : int\n        Number of terms to include in the series.\n\n    Returns\n    -------\n    J : array, shape (3, 3)\n        Left Jacobian of SO(3).\n    \"\"\"\n    omega = np.asarray(omega)\n    J = np.eye(3)\n    pxn = np.eye(3)\n    px = cross_product_matrix(omega)\n    for n in range(n_terms):\n        pxn = np.dot(pxn, px) / (n + 2)\n        J += pxn\n    return J",
  "def left_jacobian_SO3_inv(omega):\n    r\"\"\"Inverse left Jacobian of SO(3) at theta (angle of rotation).\n\n    .. math::\n\n        \\boldsymbol{J}^{-1}(\\theta)\n        =\n        \\frac{\\theta}{2 \\tan{\\frac{\\theta}{2}}} \\boldsymbol{I}\n        - \\frac{\\theta}{2} \\left[\\hat{\\boldsymbol{\\omega}}\\right]\n        + \\left(1 - \\frac{\\theta}{2 \\tan{\\frac{\\theta}{2}}}\\right)\n        \\hat{\\boldsymbol{\\omega}} \\hat{\\boldsymbol{\\omega}}^T\n\n    Parameters\n    ----------\n    omega : array-like, shape (3,)\n        Compact axis-angle representation.\n\n    Returns\n    -------\n    J_inv : array, shape (3, 3)\n        Inverse left Jacobian of SO(3).\n    \"\"\"\n    omega = np.asarray(omega)\n    theta = np.linalg.norm(omega)\n    if theta < np.finfo(float).eps:\n        return left_jacobian_SO3_inv_series(omega, 10)\n    omega_unit = omega / theta\n    omega_matrix = cross_product_matrix(omega_unit)\n    return (\n        np.eye(3)\n        - 0.5 * omega_matrix * theta\n        + (1.0 - 0.5 * theta / np.tan(theta / 2.0)) * np.dot(\n            omega_matrix, omega_matrix)\n    )",
  "def left_jacobian_SO3_inv_series(omega, n_terms):\n    \"\"\"Inverse left Jacobian of SO(3) at theta from Taylor series.\n\n    Parameters\n    ----------\n    omega : array-like, shape (3,)\n        Compact axis-angle representation.\n\n    n_terms : int\n        Number of terms to include in the series.\n\n    Returns\n    -------\n    J_inv : array, shape (3, 3)\n        Inverse left Jacobian of SO(3).\n    \"\"\"\n    from scipy.special import bernoulli\n\n    omega = np.asarray(omega)\n    J_inv = np.eye(3)\n    pxn = np.eye(3)\n    px = cross_product_matrix(omega)\n    b = bernoulli(n_terms + 1)\n    for n in range(n_terms):\n        pxn = np.dot(pxn, px / (n + 1))\n        J_inv += b[n + 1] * pxn\n    return J_inv",
  "def quaternion_integrate(Qd, q0=np.array([1.0, 0.0, 0.0, 0.0]), dt=1.0):\n    \"\"\"Integrate angular velocities to quaternions.\n\n     Angular velocities are given in global frame and will be left-multiplied\n     to the initial or previous orientation respectively.\n\n    Parameters\n    ----------\n    Qd : array-like, shape (n_steps, 3)\n        Angular velocities in a compact axis-angle representation. Each angular\n        velocity represents the rotational offset after one unit of time.\n\n    q0 : array-like, shape (4,), optional (default: [1, 0, 0, 0])\n        Unit quaternion to represent initial orientation: (w, x, y, z)\n\n    dt : float, optional (default: 1)\n        Time interval between steps.\n\n    Returns\n    -------\n    Q : array-like, shape (n_steps, 4)\n        Quaternions to represent rotations: (w, x, y, z)\n    \"\"\"\n    Q = np.empty((len(Qd), 4))\n    Q[0] = q0\n    for t in range(1, len(Qd)):\n        qd = (Qd[t] + Qd[t - 1]) / 2.0\n        Q[t] = concatenate_quaternions(\n            quaternion_from_compact_axis_angle(dt * qd), Q[t - 1])\n    return Q",
  "def quaternion_gradient(Q, dt=1.0):\n    \"\"\"Time-derivatives of a sequence of quaternions.\n\n    Note that this function does not provide the exact same functionality for\n    quaternions as `NumPy's gradient function\n    <https://numpy.org/doc/stable/reference/generated/numpy.gradient.html>`_\n    for positions. Gradients are always computed as central differences except\n    the first and last gradient. We additionally accept a parameter dt that\n    defines the time interval between each quaternion. Note that this means\n    that we expect this to be constant for the whole sequence.\n\n    Parameters\n    ----------\n    Q : array-like, shape (n_steps, 4)\n        Quaternions to represent rotations: (w, x, y, z)\n\n    dt : float, optional (default: 1)\n        Time interval between steps. If you have non-constant dt, you can pass\n        1 and manually divide angular velocities by their corresponding time\n        interval afterwards.\n\n    Returns\n    -------\n    A : array-like, shape (n_steps, 3)\n        Angular velocities in a compact axis-angle representation. Each angular\n        velocity represents the rotational offset after one unit of time.\n        Angular velocities are given in global frame and will be\n        left-multiplied during integration to the initial or previous\n        orientation respectively.\n    \"\"\"\n    Q = check_quaternions(Q)\n    Qd = np.empty((len(Q), 3))\n    Qd[0] = compact_axis_angle_from_quaternion(\n        concatenate_quaternions(Q[1], q_conj(Q[0]))) / dt\n    for t in range(1, len(Q) - 1):\n        # divided by two because of central differences\n        Qd[t] = compact_axis_angle_from_quaternion(\n            concatenate_quaternions(Q[t + 1], q_conj(Q[t - 1]))) / (2.0 * dt)\n    Qd[-1] = compact_axis_angle_from_quaternion(\n        concatenate_quaternions(Q[-1], q_conj(Q[-2]))) / dt\n    return Qd",
  "def concatenate_quaternions(q1, q2):\n    \"\"\"Concatenate two quaternions.\n\n    We use Hamilton's quaternion multiplication.\n\n    Suppose we want to apply two extrinsic rotations given by quaternions\n    q1 and q2 to a vector v. We can either apply q2 to v and then q1 to\n    the result or we can concatenate q1 and q2 and apply the result to v.\n\n    Parameters\n    ----------\n    q1 : array-like, shape (4,)\n        First quaternion\n\n    q2 : array-like, shape (4,)\n        Second quaternion\n\n    Returns\n    -------\n    q12 : array-like, shape (4,)\n        Quaternion that represents the concatenated rotation q1 * q2\n    \"\"\"\n    q1 = check_quaternion(q1, unit=False)\n    q2 = check_quaternion(q2, unit=False)\n    q12 = np.empty(4)\n    q12[0] = q1[0] * q2[0] - np.dot(q1[1:], q2[1:])\n    q12[1:] = q1[0] * q2[1:] + q2[0] * q1[1:] + np.cross(q1[1:], q2[1:])\n    return q12",
  "def q_prod_vector(q, v):\n    \"\"\"Apply rotation represented by a quaternion to a vector.\n\n    We use Hamilton's quaternion multiplication.\n\n    Parameters\n    ----------\n    q : array-like, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    v : array-like, shape (3,)\n        3d vector\n\n    Returns\n    -------\n    w : array-like, shape (3,)\n        3d vector\n    \"\"\"\n    q = check_quaternion(q)\n    t = 2 * np.cross(q[1:], v)\n    return v + q[0] * t + np.cross(q[1:], t)",
  "def q_conj(q):\n    \"\"\"Conjugate of quaternion.\n\n    The conjugate of a unit quaternion inverts the rotation represented by\n    this unit quaternion. The conjugate of a quaternion q is often denoted\n    as q*.\n\n    Parameters\n    ----------\n    q : array-like, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    Returns\n    -------\n    q_c : array-like, shape (4,)\n        Conjugate (w, -x, -y, -z)\n    \"\"\"\n    q = check_quaternion(q)\n    return np.array([q[0], -q[1], -q[2], -q[3]])",
  "def quaternion_dist(q1, q2):\n    r\"\"\"Compute distance between two quaternions.\n\n    We use the angular metric of :math:`S^3`, which is defined as\n\n    .. math::\n\n        d(q_1, q_2) = \\min(|| \\log(q_1 * \\overline{q_2})||,\n                            2 \\pi - || \\log(q_1 * \\overline{q_2})||)\n\n    Parameters\n    ----------\n    q1 : array-like, shape (4,)\n        First quaternion\n\n    q2 : array-like, shape (4,)\n        Second quaternion\n\n    Returns\n    -------\n    dist : float\n        Distance between q1 and q2\n    \"\"\"\n    q1 = check_quaternion(q1)\n    q2 = check_quaternion(q2)\n    q12c = concatenate_quaternions(q1, q_conj(q2))\n    angle = axis_angle_from_quaternion(q12c)[-1]\n    return min(angle, 2.0 * np.pi - angle)",
  "def quaternion_diff(q1, q2):\n    r\"\"\"Compute the rotation in angle-axis format that rotates q2 into q1.\n\n    .. math::\n\n        \\omega = 2 \\log (q_1 * \\overline{q_2})\n\n    Parameters\n    ----------\n    q1 : array-like, shape (4,)\n        First quaternion\n\n    q2 : array-line, shape (4,)\n        Second quaternion\n\n    Returns\n    -------\n    a : array-like, shape (4,)\n        The rotation in angle-axis format that rotates q2 into q1\n    \"\"\"\n    q1 = check_quaternion(q1)\n    q2 = check_quaternion(q2)\n    q1q2c = concatenate_quaternions(q1, q_conj(q2))\n    return axis_angle_from_quaternion(q1q2c)",
  "def quaternion_from_euler(e, i, j, k, extrinsic):\n    \"\"\"General conversion to quaternion from any Euler angles.\n\n    Parameters\n    ----------\n    e : array-like, shape (3,)\n        Rotation angles in radians about the axes i, j, k in this order. The\n        first and last angle are normalized to [-pi, pi]. The middle angle is\n        normalized to either [0, pi] (proper Euler angles) or [-pi/2, pi/2]\n        (Cardan / Tait-Bryan angles).\n\n    i : int from [0, 1, 2]\n        The first rotation axis (0: x, 1: y, 2: z)\n\n    j : int from [0, 1, 2]\n        The second rotation axis (0: x, 1: y, 2: z)\n\n    k : int from [0, 1, 2]\n        The third rotation axis (0: x, 1: y, 2: z)\n\n    extrinsic : bool\n        Do we use extrinsic transformations? Intrinsic otherwise.\n\n    Returns\n    -------\n    q : array, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    Raises\n    ------\n    ValueError\n        If basis is invalid\n    \"\"\"\n    check_axis_index(\"i\", i)\n    check_axis_index(\"j\", j)\n    check_axis_index(\"k\", k)\n\n    q0 = quaternion_from_angle(i, e[0])\n    q1 = quaternion_from_angle(j, e[1])\n    q2 = quaternion_from_angle(k, e[2])\n    if not extrinsic:\n        q0, q2 = q2, q0\n    return concatenate_quaternions(concatenate_quaternions(q2, q1), q0)",
  "def plot_basis(ax=None, R=None, p=np.zeros(3), s=1.0, ax_s=1,\n               strict_check=True, **kwargs):\n    \"\"\"Plot basis of a rotation matrix.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    R : array-like, shape (3, 3), optional (default: I)\n        Rotation matrix, each column contains a basis vector\n\n    p : array-like, shape (3,), optional (default: [0, 0, 0])\n        Offset from the origin\n\n    s : float, optional (default: 1)\n        Scaling of the frame that will be drawn\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    kwargs : dict, optional (default: {})\n        Additional arguments for the plotting functions, e.g. alpha\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    from ..plot_utils import make_3d_axis, Frame\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    if R is None:\n        R = np.eye(3)\n    R = check_matrix(R, strict_check=strict_check)\n\n    A2B = np.eye(4)\n    A2B[:3, :3] = R\n    A2B[:3, 3] = p\n\n    frame = Frame(A2B, s=s, **kwargs)\n    frame.add_frame(ax)\n\n    return ax",
  "def plot_axis_angle(ax=None, a=a_id, p=p0, s=1.0, ax_s=1, **kwargs):\n    \"\"\"Plot rotation axis and angle.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    a : array-like, shape (4,), optional (default: [1, 0, 0, 0])\n        Axis of rotation and rotation angle: (x, y, z, angle)\n\n    p : array-like, shape (3,), optional (default: [0, 0, 0])\n        Offset from the origin\n\n    s : float, optional (default: 1)\n        Scaling of the axis and angle that will be drawn\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    kwargs : dict, optional (default: {})\n        Additional arguments for the plotting functions, e.g. alpha\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    from ..plot_utils import make_3d_axis, Arrow3D\n    a = check_axis_angle(a)\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    ax.add_artist(Arrow3D(\n        [p[0], p[0] + s * a[0]],\n        [p[1], p[1] + s * a[1]],\n        [p[2], p[2] + s * a[2]],\n        mutation_scale=20, lw=3, arrowstyle=\"-|>\", color=\"k\"))\n\n    arc = _arc_axis_angle(a, p, s)\n    ax.plot(arc[:-5, 0], arc[:-5, 1], arc[:-5, 2], color=\"k\", lw=3, **kwargs)\n\n    arrow_coords = np.vstack((arc[-1], arc[-1] + 20 * (arc[-1] - arc[-3]))).T\n    ax.add_artist(Arrow3D(\n        arrow_coords[0], arrow_coords[1], arrow_coords[2],\n        mutation_scale=20, lw=3, arrowstyle=\"-|>\", color=\"k\"))\n\n    for i in [0, -1]:\n        arc_bound = np.vstack((p + 0.5 * s * a[:3], arc[i])).T\n        ax.plot(arc_bound[0], arc_bound[1], arc_bound[2], \"--\", c=\"k\")\n\n    return ax",
  "def _arc_axis_angle(a, p, s):  # pragma: no cover\n    \"\"\"Compute arc defined by a around p with scaling s.\n\n    Parameters\n    ----------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle)\n\n    p : array-like, shape (3,), optional (default: [0, 0, 0])\n        Offset from the origin\n\n    s : float, optional (default: 1)\n        Scaling of the axis and angle that will be drawn\n\n    Returns\n    -------\n    arc : array, shape (100, 3)\n        Coordinates of arc\n    \"\"\"\n    p1 = (unitx if np.abs(a[0]) <= np.finfo(float).eps else\n          perpendicular_to_vectors(unity, a[:3]))\n    p2 = perpendicular_to_vectors(a[:3], p1)\n    angle_p1p2 = angle_between_vectors(p1, p2)\n    arc = np.empty((100, 3))\n    for i, t in enumerate(np.linspace(0, 2 * a[3] / np.pi, len(arc))):\n        w1, w2 = slerp_weights(angle_p1p2, t)\n        arc[i] = p + 0.5 * s * (a[:3] + w1 * p1 + w2 * p2)\n    return arc",
  "def plot_bivector(ax=None, a=None, b=None, ax_s=1):\n    \"\"\"Plot bivector from wedge product of two vectors a and b.\n\n    The two vectors will be displayed in grey together with the parallelogram\n    that they form. Each component of the bivector corresponds to the area of\n    the parallelogram projected on the basis planes. These parallelograms will\n    be shown as well. Furthermore, one black arrow will show the rotation\n    direction of the bivector and one black arrow will represent the normal of\n    the plane that can be extracted by rearranging the elements of the bivector\n    and normalizing the vector.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis, optional (default: None)\n        If the axis is None, a new 3d axis will be created\n\n    a : array-like, shape (3,), optional (default: [1, 0, 0])\n        Vector\n\n    b : array-like, shape (3,), optional (default: [0, 1, 0])\n        Vector\n\n    ax_s : float, optional (default: 1)\n        Scaling of the new matplotlib 3d axis\n\n    Returns\n    -------\n    ax : Matplotlib 3d axis\n        New or old axis\n    \"\"\"\n    from ..plot_utils import make_3d_axis, Arrow3D, plot_vector\n    if ax is None:\n        ax = make_3d_axis(ax_s)\n\n    if a is None:\n        a = np.array([1, 0, 0])\n    if b is None:\n        b = np.array([0, 1, 0])\n\n    B = wedge(a, b)\n    normal = plane_normal_from_bivector(B)\n\n    _plot_projected_parallelograms(ax, a, b)\n\n    arc = _arc_between_vectors(a, b)\n    ax.plot(arc[:-5, 0], arc[:-5, 1], arc[:-5, 2], color=\"k\", lw=2)\n\n    arrow_coords = np.vstack((arc[-6], arc[-6] + 10 * (arc[-1] - arc[-3]))).T\n    angle_arrow = Arrow3D(\n        arrow_coords[0], arrow_coords[1], arrow_coords[2],\n        mutation_scale=20, lw=2, arrowstyle=\"-|>\", color=\"k\")\n    ax.add_artist(angle_arrow)\n\n    plot_vector(ax=ax, start=np.zeros(3), direction=normal, color=\"k\")\n\n    return ax",
  "def _plot_projected_parallelograms(ax, a, b):\n    \"\"\"Plot projected parallelograms.\n\n    We visualize a plane described by two vectors in 3D as a parallelogram.\n    Furthermore, we project the parallelogram to the three basis planes and\n    visualize these projections as parallelograms.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis\n        Axis\n\n    a : array, shape (3,)\n        Vector that defines the first side\n\n    b : array, shape (3,)\n        Vector that defines the second side\n    \"\"\"\n    _plot_parallelogram(ax, a, b, \"#aaaaaa\", 0.5)\n    a_xy = np.array([a[0], a[1], 0])\n    b_xy = np.array([b[0], b[1], 0])\n    _plot_parallelogram(ax, a_xy, b_xy, \"#ffff00\", 0.5)\n    a_xz = np.array([a[0], 0, a[2]])\n    b_xz = np.array([b[0], 0, b[2]])\n    _plot_parallelogram(ax, a_xz, b_xz, \"#ff00ff\", 0.5)\n    a_yz = np.array([0, a[1], a[2]])\n    b_yz = np.array([0, b[1], b[2]])\n    _plot_parallelogram(ax, a_yz, b_yz, \"#00ffff\", 0.5)",
  "def _plot_parallelogram(ax, a, b, color, alpha):\n    \"\"\"Plot parallelogram.\n\n    Parameters\n    ----------\n    ax : Matplotlib 3d axis\n        Axis\n\n    a : array, shape (3,)\n        Vector that defines the first side\n\n    b : array, shape (3,)\n        Vector that defines the second side\n\n    color : str\n        Color\n\n    alpha : float\n        Alpha of surface\n    \"\"\"\n    from ..plot_utils import plot_vector\n    from mpl_toolkits.mplot3d.art3d import Poly3DCollection\n    plot_vector(ax, start=np.zeros(3), direction=a, color=color, alpha=alpha)\n    plot_vector(ax, start=np.zeros(3), direction=b, color=color, alpha=alpha)\n    verts = np.vstack((np.zeros(3), a, b, a + b, b, a))\n    try:  # Matplotlib < 3.5\n        parallelogram = Poly3DCollection(verts)\n    except ValueError:  # Matplotlib >= 3.5\n        parallelogram = Poly3DCollection(verts.reshape(2, 3, 3))\n    parallelogram.set_facecolor(color)\n    parallelogram.set_alpha(alpha)\n    ax.add_collection3d(parallelogram)",
  "def _arc_between_vectors(a, b):  # pragma: no cover\n    \"\"\"Compute arc defined by a around p with scaling s.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        Vector\n\n    b : array-like, shape (3,)\n        Vector\n\n    Returns\n    -------\n    arc : array, shape (100, 3)\n        Coordinates of arc\n    \"\"\"\n    angle = angle_between_vectors(a, b)\n    arc = np.empty((100, 3))\n    for i, t in enumerate(np.linspace(0, angle, len(arc))):\n        w1, w2 = slerp_weights(angle, t)\n        arc[i] = 0.5 * (w1 * a + w2 * b)\n    return arc",
  "def norm_vector(v):\n    \"\"\"Normalize vector.\n\n    Parameters\n    ----------\n    v : array-like, shape (n,)\n        nd vector\n\n    Returns\n    -------\n    u : array, shape (n,)\n        nd unit vector with norm 1 or the zero vector\n    \"\"\"\n    norm = np.linalg.norm(v)\n    if norm == 0.0:\n        return v\n\n    return np.asarray(v) / norm",
  "def norm_matrix(R):\n    \"\"\"Orthonormalize rotation matrix.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix with small numerical errors\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Normalized rotation matrix\n    \"\"\"\n    R = np.asarray(R)\n    c2 = R[:, 1]\n    c3 = norm_vector(R[:, 2])\n    c1 = norm_vector(np.cross(c2, c3))\n    c2 = norm_vector(np.cross(c3, c1))\n    return np.column_stack((c1, c2, c3))",
  "def norm_angle(a):\n    \"\"\"Normalize angle to (-pi, pi].\n\n    It is worth noting that using `numpy.ceil` to normalize angles will lose\n    more digits of precision as angles going larger but can keep more digits\n    of precision when angles are around zero. In common use cases, for example,\n    -10.0*pi to 10.0*pi, it performs well.\n\n    For more discussions on numerical precision:\n    https://github.com/dfki-ric/pytransform3d/pull/263\n\n    Parameters\n    ----------\n    a : float or array-like, shape (n,)\n        Angle(s) in radians\n\n    Returns\n    -------\n    a_norm : float or array-like, shape (n,)\n        Normalized angle(s) in radians\n    \"\"\"\n    a = np.asarray(a, dtype=np.float64)\n    return (a - (np.ceil((a + np.pi) / two_pi) - 1.0) * two_pi)",
  "def norm_axis_angle(a):\n    \"\"\"Normalize axis-angle representation.\n\n    Parameters\n    ----------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle)\n\n    Returns\n    -------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle). The length\n        of the axis vector is 1 and the angle is in [0, pi). No rotation\n        is represented by [1, 0, 0, 0].\n    \"\"\"\n    angle = a[3]\n    norm = np.linalg.norm(a[:3])\n    if angle == 0.0 or norm == 0.0:\n        return np.array([1.0, 0.0, 0.0, 0.0])\n\n    res = np.empty(4)\n    res[:3] = a[:3] / norm\n\n    angle = norm_angle(angle)\n    if angle < 0.0:\n        angle *= -1.0\n        res[:3] *= -1.0\n\n    res[3] = angle\n\n    return res",
  "def norm_compact_axis_angle(a):\n    \"\"\"Normalize compact axis-angle representation.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z)\n\n    Returns\n    -------\n    a : array-like, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z).\n        The angle is in [0, pi). No rotation is represented by [0, 0, 0].\n    \"\"\"\n    angle = np.linalg.norm(a)\n    if angle == 0.0:\n        return np.zeros(3)\n    axis = a / angle\n    return axis * norm_angle(angle)",
  "def perpendicular_to_vectors(a, b):\n    \"\"\"Compute perpendicular vector to two other vectors.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        3d vector\n\n    b : array-like, shape (3,)\n        3d vector\n\n    Returns\n    -------\n    c : array-like, shape (3,)\n        3d vector that is orthogonal to a and b\n    \"\"\"\n    return np.cross(a, b)",
  "def perpendicular_to_vector(a):\n    \"\"\"Compute perpendicular vector to one other vector.\n\n    There is an infinite number of solutions to this problem. Thus, we\n    restrict the solutions to [1, 0, z] and return [0, 0, 1] if the\n    z component of a is 0.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        3d vector\n\n    Returns\n    -------\n    b : array-like, shape (3,)\n        A 3d vector that is orthogonal to a. It does not necessarily have\n        unit length.\n    \"\"\"\n    if abs(a[2]) < eps:\n        return np.copy(unitz)\n    # Now that we solved the problem for [x, y, 0], we can solve it for all\n    # other vectors by restricting solutions to [1, 0, z] and find z.\n    # The dot product of orthogonal vectors is 0, thus\n    # a[0] * 1 + a[1] * 0 + a[2] * z == 0 or -a[0] / a[2] = z\n    return np.array([1.0, 0.0, -a[0] / a[2]])",
  "def angle_between_vectors(a, b, fast=False):\n    \"\"\"Compute angle between two vectors.\n\n    Parameters\n    ----------\n    a : array-like, shape (n,)\n        nd vector\n\n    b : array-like, shape (n,)\n        nd vector\n\n    fast : bool, optional (default: False)\n        Use fast implementation instead of numerically stable solution\n\n    Returns\n    -------\n    angle : float\n        Angle between a and b\n    \"\"\"\n    if len(a) != 3 or fast:\n        return np.arccos(\n            np.clip(np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b)),\n                    -1.0, 1.0))\n    return np.arctan2(np.linalg.norm(np.cross(a, b)), np.dot(a, b))",
  "def vector_projection(a, b):\n    \"\"\"Orthogonal projection of vector a on vector b.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        Vector a that will be projected on vector b\n\n    b : array-like, shape (3,)\n        Vector b on which vector a will be projected\n\n    Returns\n    -------\n    a_on_b : array, shape (3,)\n        Vector a\n    \"\"\"\n    b_norm_squared = np.dot(b, b)\n    if b_norm_squared == 0.0:\n        return np.zeros(3)\n    return np.dot(a, b) * b / b_norm_squared",
  "def plane_basis_from_normal(plane_normal):\n    \"\"\"Compute two basis vectors of a plane from the plane's normal vector.\n\n    Note that there are infinitely many solutions because any rotation of the\n    basis vectors about the normal is also a solution. This function\n    deterministically picks one of the solutions.\n\n    The two basis vectors of the plane together with the normal form an\n    orthonormal basis in 3D space and could be used as columns to form a\n    rotation matrix.\n\n    Parameters\n    ----------\n    plane_normal : array-like, shape (3,)\n        Plane normal of unit length.\n\n    Returns\n    -------\n    x_axis : array, shape (3,)\n        x-axis of the plane.\n\n    y_axis : array, shape (3,)\n        y-axis of the plane.\n    \"\"\"\n    if abs(plane_normal[0]) >= abs(plane_normal[1]):\n        # x or z is the largest magnitude component, swap them\n        length = math.sqrt(\n            plane_normal[0] * plane_normal[0]\n            + plane_normal[2] * plane_normal[2])\n        x_axis = np.array([-plane_normal[2] / length, 0.0,\n                           plane_normal[0] / length])\n        y_axis = np.array([\n            plane_normal[1] * x_axis[2],\n            plane_normal[2] * x_axis[0] - plane_normal[0] * x_axis[2],\n            -plane_normal[1] * x_axis[0]])\n    else:\n        # y or z is the largest magnitude component, swap them\n        length = math.sqrt(plane_normal[1] * plane_normal[1]\n                           + plane_normal[2] * plane_normal[2])\n        x_axis = np.array([0.0, plane_normal[2] / length,\n                           -plane_normal[1] / length])\n        y_axis = np.array([\n            plane_normal[1] * x_axis[2] - plane_normal[2] * x_axis[1],\n            -plane_normal[0] * x_axis[2], plane_normal[0] * x_axis[1]])\n    return x_axis, y_axis",
  "def random_vector(rng=np.random.default_rng(0), n=3):\n    r\"\"\"Generate an nd vector with normally distributed components.\n\n    Each component will be sampled from :math:`\\mathcal{N}(\\mu=0, \\sigma=1)`.\n\n    Parameters\n    ----------\n    rng : np.random.Generator, optional (default: random seed 0)\n        Random number generator\n\n    n : int, optional (default: 3)\n        Number of vector components\n\n    Returns\n    -------\n    v : array, shape (n,)\n        Random vector\n    \"\"\"\n    return rng.standard_normal(size=n)",
  "def random_axis_angle(rng=np.random.default_rng(0)):\n    r\"\"\"Generate random axis-angle.\n\n    The angle will be sampled uniformly from the interval :math:`[0, \\pi)`\n    and each component of the rotation axis will be sampled from\n    :math:`\\mathcal{N}(\\mu=0, \\sigma=1)` and than the axis will be normalized\n    to length 1.\n\n    Parameters\n    ----------\n    rng : np.random.Generator, optional (default: random seed 0)\n        Random number generator\n\n    Returns\n    -------\n    a : array, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle)\n    \"\"\"\n    angle = np.pi * rng.random()\n    a = np.array([0, 0, 0, angle])\n    a[:3] = norm_vector(rng.standard_normal(size=3))\n    return a",
  "def random_compact_axis_angle(rng=np.random.default_rng(0)):\n    r\"\"\"Generate random compact axis-angle.\n\n    The angle will be sampled uniformly from the interval :math:`[0, \\pi)`\n    and each component of the rotation axis will be sampled from\n    :math:`\\mathcal{N}(\\mu=0, \\sigma=1)` and then the axis will be normalized\n    to length 1.\n\n    Parameters\n    ----------\n    rng : np.random.Generator, optional (default: random seed 0)\n        Random number generator\n\n    Returns\n    -------\n    a : array, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z)\n    \"\"\"\n    a = random_axis_angle(rng)\n    return a[:3] * a[3]",
  "def random_quaternion(rng=np.random.default_rng(0)):\n    \"\"\"Generate random quaternion.\n\n    Parameters\n    ----------\n    rng : np.random.Generator, optional (default: random seed 0)\n        Random number generator\n\n    Returns\n    -------\n    q : array, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n    \"\"\"\n    return norm_vector(rng.standard_normal(size=4))",
  "def check_skew_symmetric_matrix(V, tolerance=1e-6, strict_check=True):\n    \"\"\"Input validation of a skew-symmetric matrix.\n\n    Check whether the transpose of the matrix is its negative:\n\n    .. math::\n\n        V^T = -V\n\n    Parameters\n    ----------\n    V : array-like, shape (3, 3)\n        Cross-product matrix\n\n    tolerance : float, optional (default: 1e-6)\n        Tolerance threshold for checks.\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if V.T is not numerically close enough to -V.\n        Otherwise we print a warning.\n\n    Returns\n    -------\n    V : array, shape (3, 3)\n        Validated cross-product matrix\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    V = np.asarray(V, dtype=np.float64)\n    if V.ndim != 2 or V.shape[0] != 3 or V.shape[1] != 3:\n        raise ValueError(\"Expected skew-symmetric matrix with shape (3, 3), \"\n                         \"got array-like object with shape %s\" % (V.shape,))\n    if not np.allclose(V.T, -V, atol=tolerance):\n        error_msg = (\"Expected skew-symmetric matrix, but it failed the test \"\n                     \"V.T = %r\\n-V = %r\" % (V.T, -V))\n        if strict_check:\n            raise ValueError(error_msg)\n        warnings.warn(error_msg)\n    return V",
  "def check_matrix(R, tolerance=1e-6, strict_check=True):\n    r\"\"\"Input validation of a rotation matrix.\n\n    We check whether R multiplied by its inverse is approximately the identity\n    matrix\n\n    .. math::\n\n        \\boldsymbol{R}\\boldsymbol{R}^T = \\boldsymbol{I}\n\n    and whether the determinant is positive\n\n    .. math::\n\n        det(\\boldsymbol{R}) > 0\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    tolerance : float, optional (default: 1e-6)\n        Tolerance threshold for checks. Default tolerance is the same as in\n        assert_rotation_matrix(R).\n\n    strict_check : bool, optional (default: True)\n        Raise a ValueError if the rotation matrix is not numerically close\n        enough to a real rotation matrix. Otherwise we print a warning.\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Validated rotation matrix\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    R = np.asarray(R, dtype=np.float64)\n    if R.ndim != 2 or R.shape[0] != 3 or R.shape[1] != 3:\n        raise ValueError(\"Expected rotation matrix with shape (3, 3), got \"\n                         \"array-like object with shape %s\" % (R.shape,))\n    RRT = np.dot(R, R.T)\n    if not np.allclose(RRT, np.eye(3), atol=tolerance):\n        error_msg = (\"Expected rotation matrix, but it failed the test \"\n                     \"for inversion by transposition. np.dot(R, R.T) \"\n                     \"gives %r\" % RRT)\n        if strict_check:\n            raise ValueError(error_msg)\n        warnings.warn(error_msg)\n    R_det = np.linalg.det(R)\n    if R_det < 0.0:\n        error_msg = (\"Expected rotation matrix, but it failed the test \"\n                     \"for the determinant, which should be 1 but is %g; \"\n                     \"that is, it probably represents a rotoreflection\"\n                     % R_det)\n        if strict_check:\n            raise ValueError(error_msg)\n        warnings.warn(error_msg)\n    return R",
  "def check_axis_angle(a):\n    \"\"\"Input validation of axis-angle representation.\n\n    Parameters\n    ----------\n    a : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle)\n\n    Returns\n    -------\n    a : array, shape (4,)\n        Validated axis of rotation and rotation angle: (x, y, z, angle)\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    a = np.asarray(a, dtype=np.float64)\n    if a.ndim != 1 or a.shape[0] != 4:\n        raise ValueError(\"Expected axis and angle in array with shape (4,), \"\n                         \"got array-like object with shape %s\" % (a.shape,))\n    return norm_axis_angle(a)",
  "def check_compact_axis_angle(a):\n    \"\"\"Input validation of compact axis-angle representation.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z)\n\n    Returns\n    -------\n    a : array, shape (3,)\n        Validated axis of rotation and rotation angle: angle * (x, y, z)\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    a = np.asarray(a, dtype=np.float64)\n    if a.ndim != 1 or a.shape[0] != 3:\n        raise ValueError(\"Expected axis and angle in array with shape (3,), \"\n                         \"got array-like object with shape %s\" % (a.shape,))\n    return norm_compact_axis_angle(a)",
  "def check_quaternion(q, unit=True):\n    \"\"\"Input validation of quaternion representation.\n\n    Parameters\n    ----------\n    q : array-like, shape (4,)\n        Quaternion to represent rotation: (w, x, y, z)\n\n    unit : bool, optional (default: True)\n        Normalize the quaternion so that it is a unit quaternion\n\n    Returns\n    -------\n    q : array-like, shape (4,)\n        Validated quaternion to represent rotation: (w, x, y, z)\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    q = np.asarray(q, dtype=np.float64)\n    if q.ndim != 1 or q.shape[0] != 4:\n        raise ValueError(\"Expected quaternion with shape (4,), got \"\n                         \"array-like object with shape %s\" % (q.shape,))\n    if unit:\n        return norm_vector(q)\n    return q",
  "def check_quaternions(Q, unit=True):\n    \"\"\"Input validation of quaternion representation.\n\n    Parameters\n    ----------\n    Q : array-like, shape (n_steps, 4)\n        Quaternions to represent rotations: (w, x, y, z)\n\n    unit : bool, optional (default: True)\n        Normalize the quaternions so that they are unit quaternions\n\n    Returns\n    -------\n    Q : array-like, shape (n_steps, 4)\n        Validated quaternions to represent rotations: (w, x, y, z)\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    Q_checked = np.asarray(Q, dtype=np.float64)\n    if Q_checked.ndim != 2 or Q_checked.shape[1] != 4:\n        raise ValueError(\n            \"Expected quaternion array with shape (n_steps, 4), got \"\n            \"array-like object with shape %s\" % (Q_checked.shape,))\n    if unit:\n        for i in range(len(Q)):\n            Q_checked[i] = norm_vector(Q_checked[i])\n    return Q_checked",
  "def check_rotor(rotor):\n    \"\"\"Input validation of rotor.\n\n    Parameters\n    ----------\n    rotor : array-like, shape (4,)\n        Rotor: (a, b_yz, b_zx, b_xy)\n\n    Returns\n    -------\n    rotor : array, shape (4,)\n        Validated rotor (with unit norm): (a, b_yz, b_zx, b_xy)\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    rotor = np.asarray(rotor, dtype=np.float64)\n    if rotor.ndim != 1 or rotor.shape[0] != 4:\n        raise ValueError(\"Expected rotor with shape (4,), got \"\n                         \"array-like object with shape %s\" % (rotor.shape,))\n    return norm_vector(rotor)",
  "def check_mrp(mrp):\n    \"\"\"Input validation of modified Rodrigues parameters.\n\n    Parameters\n    ----------\n    mrp : array-like, shape (3,)\n        Modified Rodrigues parameters.\n\n    Returns\n    -------\n    mrp : array, shape (3,)\n        Validated modified Rodrigues parameters.\n\n    Raises\n    ------\n    ValueError\n        If input is invalid\n    \"\"\"\n    mrp = np.asarray(mrp)\n    if mrp.ndim != 1 or mrp.shape[0] != 3:\n        raise ValueError(\n            \"Expected modified Rodrigues parameters with shape (3,), got \"\n            \"array-like object with shape %s\" % (mrp.shape,))\n    return mrp",
  "def assert_axis_angle_equal(a1, a2, *args, **kwargs):\n    \"\"\"Raise an assertion if two axis-angle are not approximately equal.\n\n    Usually we assume that the rotation axis is normalized to length 1 and\n    the angle is within [0, pi). However, this function ignores these\n    constraints and will normalize the representations before comparison.\n    See numpy.testing.assert_array_almost_equal for a more detailed\n    documentation of the other parameters.\n\n    Parameters\n    ----------\n    a1 : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle)\n\n    a2 : array-like, shape (4,)\n        Axis of rotation and rotation angle: (x, y, z, angle)\n\n    args : tuple\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n\n    kwargs : dict\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n    \"\"\"\n    # required despite normalization in case of 180 degree rotation\n    if np.any(np.sign(a1) != np.sign(a2)):\n        a1 = -a1\n    a1 = norm_axis_angle(a1)\n    a2 = norm_axis_angle(a2)\n    assert_array_almost_equal(a1, a2, *args, **kwargs)",
  "def assert_compact_axis_angle_equal(a1, a2, *args, **kwargs):\n    \"\"\"Raise an assertion if two axis-angle are not approximately equal.\n\n    Usually we assume that the angle is within [0, pi). However, this function\n    ignores this constraint and will normalize the representations before\n    comparison. See numpy.testing.assert_array_almost_equal for a more detailed\n    documentation of the other parameters.\n\n    Parameters\n    ----------\n    a1 : array-like, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z)\n\n    a2 : array-like, shape (3,)\n        Axis of rotation and rotation angle: angle * (x, y, z)\n\n    args : tuple\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n\n    kwargs : dict\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n    \"\"\"\n    angle1 = np.linalg.norm(a1)\n    angle2 = np.linalg.norm(a2)\n    # required despite normalization in case of 180 degree rotation\n    if (abs(angle1) == np.pi and abs(angle2) == np.pi and\n            any(np.sign(a1) != np.sign(a2))):\n        a1 = -a1\n    a1 = norm_compact_axis_angle(a1)\n    a2 = norm_compact_axis_angle(a2)\n    assert_array_almost_equal(a1, a2, *args, **kwargs)",
  "def assert_quaternion_equal(q1, q2, *args, **kwargs):\n    \"\"\"Raise an assertion if two quaternions are not approximately equal.\n\n    Note that quaternions are equal either if q1 == q2 or if q1 == -q2. See\n    numpy.testing.assert_array_almost_equal for a more detailed documentation\n    of the other parameters.\n\n    Parameters\n    ----------\n    q1 : array-like, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    q2 : array-like, shape (4,)\n        Unit quaternion to represent rotation: (w, x, y, z)\n\n    args : tuple\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n\n    kwargs : dict\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n    \"\"\"\n    try:\n        assert_array_almost_equal(q1, q2, *args, **kwargs)\n    except AssertionError:\n        assert_array_almost_equal(q1, -q2, *args, **kwargs)",
  "def assert_rotation_matrix(R, *args, **kwargs):\n    \"\"\"Raise an assertion if a matrix is not a rotation matrix.\n\n    The two properties :math:`\\\\boldsymbol{I} = \\\\boldsymbol{R R}^T` and\n    :math:`det(R) = 1` will be checked. See\n    numpy.testing.assert_array_almost_equal for a more detailed documentation\n    of the other parameters.\n\n    Parameters\n    ----------\n    R : array-like, shape (3, 3)\n        Rotation matrix\n\n    args : tuple\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n\n    kwargs : dict\n        Positional arguments that will be passed to\n        `assert_array_almost_equal`\n    \"\"\"\n    assert_array_almost_equal(np.dot(R, R.T), np.eye(3), *args, **kwargs)\n    assert_array_almost_equal(np.linalg.det(R), 1.0, *args, **kwargs)",
  "def axis_angle_slerp(start, end, t):\n    \"\"\"Spherical linear interpolation.\n\n    Parameters\n    ----------\n    start : array-like, shape (4,)\n        Start axis of rotation and rotation angle: (x, y, z, angle)\n\n    end : array-like, shape (4,)\n        Goal axis of rotation and rotation angle: (x, y, z, angle)\n\n    t : float in [0, 1]\n        Position between start and end\n\n    Returns\n    -------\n    a : array, shape (4,)\n        Interpolated axis of rotation and rotation angle: (x, y, z, angle)\n    \"\"\"\n    start = check_axis_angle(start)\n    end = check_axis_angle(end)\n    angle = angle_between_vectors(start[:3], end[:3])\n    w1, w2 = slerp_weights(angle, t)\n    w1 = np.array([w1, w1, w1, (1.0 - t)])\n    w2 = np.array([w2, w2, w2, t])\n    return w1 * start + w2 * end",
  "def quaternion_slerp(start, end, t, shortest_path=False):\n    \"\"\"Spherical linear interpolation.\n\n    Parameters\n    ----------\n    start : array-like, shape (4,)\n        Start unit quaternion to represent rotation: (w, x, y, z)\n\n    end : array-like, shape (4,)\n        End unit quaternion to represent rotation: (w, x, y, z)\n\n    t : float in [0, 1]\n        Position between start and end\n\n    shortest_path : bool, optional (default: False)\n        Resolve sign ambiguity before interpolation to find the shortest path.\n        The end quaternion will be picked to be close to the start quaternion.\n\n    Returns\n    -------\n    q : array, shape (4,)\n        Interpolated unit quaternion to represent rotation: (w, x, y, z)\n    \"\"\"\n    start = check_quaternion(start)\n    end = check_quaternion(end)\n    if shortest_path:\n        end = _pick_closest_quaternion(end, start)\n    angle = angle_between_vectors(start, end)\n    w1, w2 = slerp_weights(angle, t)\n    return w1 * start + w2 * end",
  "def pick_closest_quaternion(quaternion, target_quaternion):\n    \"\"\"Resolve quaternion ambiguity and pick the closest one to the target.\n\n    .. warning::\n        There are always two quaternions that represent the exact same\n        orientation: q and -q.\n\n    Parameters\n    ----------\n    quaternion : array-like, shape (4,)\n        Quaternion (w, x, y, z) of which we are unsure whether we want to\n        select quaternion or -quaternion.\n\n    target_quaternion : array-like, shape (4,)\n        Target quaternion (w, x, y, z) to which we want to be close.\n\n    Returns\n    -------\n    closest_quaternion : array, shape (4,)\n        Quaternion that is closest (Euclidean norm) to the target quaternion.\n    \"\"\"\n    quaternion = check_quaternion(quaternion)\n    target_quaternion = check_quaternion(target_quaternion)\n    return _pick_closest_quaternion(quaternion, target_quaternion)",
  "def _pick_closest_quaternion(quaternion, target_quaternion):\n    \"\"\"Resolve quaternion ambiguity and pick the closest one to the target.\n\n    This is an internal function that does not validate the inputs.\n\n    Parameters\n    ----------\n    quaternion : array, shape (4,)\n        Quaternion (w, x, y, z) of which we are unsure whether we want to\n        select quaternion or -quaternion.\n\n    target_quaternion : array, shape (4,)\n        Target quaternion (w, x, y, z) to which we want to be close.\n\n    Returns\n    -------\n    closest_quaternion : array, shape (4,)\n        Quaternion that is closest (Euclidean norm) to the target quaternion.\n    \"\"\"\n    if (np.linalg.norm(-quaternion - target_quaternion) <\n            np.linalg.norm(quaternion - target_quaternion)):\n        return -quaternion\n    return quaternion",
  "def rotor_slerp(start, end, t, shortest_path=False):\n    \"\"\"Spherical linear interpolation.\n\n    Parameters\n    ----------\n    start : array-like, shape (4,)\n        Rotor: (a, b_yz, b_zx, b_xy)\n\n    end : array-like, shape (4,)\n        Rotor: (a, b_yz, b_zx, b_xy)\n\n    t : float in [0, 1]\n        Position between start and end\n\n    shortest_path : bool, optional (default: False)\n        Resolve sign ambiguity before interpolation to find the shortest path.\n        The end rotor will be picked to be close to the start rotor.\n\n    Returns\n    -------\n    rotor : array, shape (4,)\n        Interpolated rotor: (a, b_yz, b_zx, b_xy)\n    \"\"\"\n    start = check_rotor(start)\n    end = check_rotor(end)\n    return quaternion_slerp(start, end, t, shortest_path)",
  "def slerp_weights(angle, t):\n    \"\"\"Compute weights of start and end for spherical linear interpolation.\n\n    Parameters\n    ----------\n    angle : float\n        Rotation angle.\n\n    t : float or array, shape (n_steps,)\n        Position between start and end\n\n    Returns\n    -------\n    w1 : float or array, shape (n_steps,)\n        Weights for quaternion 1\n\n    w2 : float or array, shape (n_steps,)\n        Weights for quaternion 2\n    \"\"\"\n    if angle == 0.0:\n        return np.ones_like(t), np.zeros_like(t)\n    return (np.sin((1.0 - t) * angle) / np.sin(angle),\n            np.sin(t * angle) / np.sin(angle))",
  "def wedge(a, b):\n    r\"\"\"Outer product of two vectors (also exterior or wedge product).\n\n    .. math::\n\n        B = a \\wedge b\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        Vector: (x, y, z)\n\n    b : array-like, shape (3,)\n        Vector: (x, y, z)\n\n    Returns\n    -------\n    B : array, shape (3,)\n        Bivector that defines the plane that a and b form together:\n        (b_yz, b_zx, b_xy)\n    \"\"\"\n    return np.cross(a, b)",
  "def plane_normal_from_bivector(B):\n    \"\"\"Convert bivector to normal vector of a plane.\n\n    Parameters\n    ----------\n    B : array-like, shape (3,)\n        Bivector that defines a plane: (b_yz, b_zx, b_xy)\n\n    Returns\n    -------\n    n : array, shape (3,)\n        Unit normal of the corresponding plane: (x, y, z)\n    \"\"\"\n    return norm_vector(B)",
  "def geometric_product(a, b):\n    r\"\"\"Geometric product of two vectors.\n\n    The geometric product consists of the symmetric inner / dot product and the\n    antisymmetric outer product of two vectors.\n\n    .. math::\n\n        ab = a \\cdot b + a \\wedge b\n\n    The inner product contains the cosine and the outer product contains the\n    sine of the angle of rotation from a to b.\n\n    Parameters\n    ----------\n    a : array-like, shape (3,)\n        Vector: (x, y, z)\n\n    b : array-like, shape (3,)\n        Vector: (x, y, z)\n\n    Returns\n    -------\n    ab : array, shape (4,)\n        A multivector (a, b_yz, b_zx, b_xy) composed of scalar and bivector\n        (b_yz, b_zx, b_xy) that form the geometric product of vectors a and b.\n    \"\"\"\n    return np.hstack(((np.dot(a, b),), wedge(a, b)))",
  "def rotor_reverse(rotor):\n    \"\"\"Invert rotor.\n\n    Parameters\n    ----------\n    rotor : array-like, shape (4,)\n        Rotor: (a, b_yz, b_zx, b_xy)\n\n    Returns\n    -------\n    reverse_rotor : array, shape (4,)\n        Reverse of the rotor: (a, b_yz, b_zx, b_xy)\n    \"\"\"\n    rotor = check_rotor(rotor)\n    return np.hstack(((rotor[0],), -rotor[1:]))",
  "def concatenate_rotors(rotor1, rotor2):\n    \"\"\"Concatenate rotors.\n\n    Suppose we want to apply two extrinsic rotations given by rotors\n    R1 and R2 to a vector v. We can either apply R2 to v and then R1 to\n    the result or we can concatenate R1 and R2 and apply the result to v.\n\n    Parameters\n    ----------\n    rotor1 : array-like, shape (4,)\n        Rotor: (a, b_yz, b_zx, b_xy)\n\n    rotor2 : array-like, shape (4,)\n        Rotor: (a, b_yz, b_zx, b_xy)\n\n    Returns\n    -------\n    rotor : array, shape (4,)\n        rotor1 applied to rotor2: (a, b_yz, b_zx, b_xy)\n    \"\"\"\n    rotor1 = check_rotor(rotor1)\n    rotor2 = check_rotor(rotor2)\n    return concatenate_quaternions(rotor1, rotor2)",
  "def rotor_apply(rotor, v):\n    r\"\"\"Compute rotation matrix from rotor.\n\n    .. math::\n\n        v' = R v R^*\n\n    Parameters\n    ----------\n    rotor : array-like, shape (4,)\n        Rotor: (a, b_yz, b_zx, b_xy)\n\n    v : array-like, shape (3,)\n        Vector: (x, y, z)\n\n    Returns\n    -------\n    v : array, shape (3,)\n        Rotated vector\n    \"\"\"\n    rotor = check_rotor(rotor)\n    return q_prod_vector(rotor, v)",
  "def matrix_from_rotor(rotor):\n    \"\"\"Compute rotation matrix from rotor.\n\n    Parameters\n    ----------\n    rotor : array-like, shape (4,)\n        Rotor: (a, b_yz, b_zx, b_xy)\n\n    Returns\n    -------\n    R : array, shape (3, 3)\n        Rotation matrix\n    \"\"\"\n    rotor = check_rotor(rotor)\n    return np.column_stack((\n        rotor_apply(rotor, unitx), rotor_apply(rotor, unity),\n        rotor_apply(rotor, unitz)))",
  "def rotor_from_two_directions(v_from, v_to):\n    \"\"\"Construct the rotor that rotates one vector to another.\n\n    Parameters\n    ----------\n    v_from : array-like, shape (3,)\n        Unit vector (will be normalized internally)\n\n    v_to : array-like, shape (3,)\n        Unit vector (will be normalized internally)\n\n    Returns\n    -------\n    rotor : array, shape (4,)\n        Rotor: (a, b_yz, b_zx, b_xy)\n    \"\"\"\n    v_from = norm_vector(v_from)\n    v_to = norm_vector(v_to)\n    cos_angle_p1 = 1.0 + np.dot(v_from, v_to)\n    if cos_angle_p1 < eps:\n        # There is an infinite number of solutions for the plane of rotation.\n        # This solution works with our convention, since the rotation axis is\n        # the same as the plane bivector.\n        plane = perpendicular_to_vector(v_from)\n    else:\n        plane = wedge(v_from, v_to)\n    multivector = np.hstack(((cos_angle_p1,), plane))\n    return norm_vector(multivector)",
  "def rotor_from_plane_angle(B, angle):\n    r\"\"\"Compute rotor from plane bivector and angle.\n\n    Parameters\n    ----------\n    B : array-like, shape (3,)\n        Unit bivector (b_yz, b_zx, b_xy) that represents the plane of rotation\n        (will be normalized internally)\n\n    angle : float\n        Rotation angle\n\n    Returns\n    -------\n    rotor : array, shape (4,)\n        Rotor: (a, b_yz, b_zx, b_xy)\n    \"\"\"\n    a = np.cos(angle / 2.0)\n    sina = np.sin(angle / 2.0)\n    B = norm_vector(B)\n    return np.hstack(((a,), sina * B))"
]