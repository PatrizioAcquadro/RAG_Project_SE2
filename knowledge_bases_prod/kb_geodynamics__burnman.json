[
  "def test_set_state(runs=10000):\n        g = burnman.minerals.SLB_2011.garnet()\n        g.set_composition([0.1, 0.2, 0.4, 0.2, 0.1])\n        x = 0.0\n        for x in range(0, runs):\n            g.set_state(10.0e9 + x, 1500.0)\n            x += g.activities\n        print(x)",
  "def test_grueneisen():\n        for aa in range(0, 500):\n            a = burnman.eos.SLB3()\n            m = minerals.SLB_2011.fayalite()\n            x = 0\n            for i in range(0, 10000):\n                x += a.grueneisen_parameter(1e9, 1e4, 1.1, m.params)\n        return x",
  "def calc_velocities(a, b, c):\n        amount_perovskite = a\n        pv = minerals.SLB_2011.mg_fe_perovskite([b, 1.0 - b, 0.0])\n        fp = minerals.SLB_2011.ferropericlase([c, 1.0 - c])\n        rock = burnman.Composite([pv, fp], [amount_perovskite, 1.0 - amount_perovskite])\n\n        mat_rho, mat_vp, mat_vs = rock.evaluate(\n            [\"density\", \"v_phi\", \"v_s\"], seis_p, temperature\n        )\n        return mat_vp, mat_vs, mat_rho",
  "def error(a, b, c):\n        mat_vp, mat_vs, mat_rho = calc_velocities(a, b, c)\n\n        vs_err = burnman.utils.math.l2(depths, mat_vs, seis_vs) / 1e9\n        vp_err = burnman.utils.math.l2(depths, mat_vp, seis_vp) / 1e9\n        den_err = burnman.utils.math.l2(depths, mat_rho, seis_rho) / 1e9\n\n        return vs_err + vp_err + den_err",
  "def run():\n        n = 5\n        m = 1e10\n        for a in np.linspace(0.0, 1.0, n):\n            for b in np.linspace(0.0, 1.0, n):\n                for c in np.linspace(0.0, 1.0, n):\n                    m = min(m, error(a, b, c))\n        print(m)\n        return m",
  "def create_list(name, mineral):\n        ownname = mineral.to_string().replace(\"'\", \"\").replace(\"burnman.minerals.\", \"\")\n        if name != ownname:\n            name = name + \" (\" + ownname + \")\"\n        row = [name]\n        for param in params:\n            row.append(str(p.params[param] if param in p.params else \"\"))\n        return row",
  "def invariant(m1, m2, m3, P=5.0e9, T=2000.0):\n    composition = m1.formula\n    assemblage = burnman.Composite([m1, m2, m3])\n    assemblage.set_state(P, T)\n    equality_constraints = [\n        (\"phase_fraction\", (m1, 0.0)),\n        (\"phase_fraction\", (m2, 0.0)),\n    ]\n    sol, prm = equilibrate(\n        composition, assemblage, equality_constraints, store_iterates=False\n    )\n    return sol.x[0:2]",
  "def univariant(m1, m2, condition_constraints, P=5.0e9, T=2000.0):\n    composition = m1.formula\n    assemblage = burnman.Composite([m1, m2])\n    assemblage.set_state(P, T)\n    equality_constraints = [condition_constraints, (\"phase_fraction\", (m1, 0.0))]\n    sols, prm = equilibrate(\n        composition, assemblage, equality_constraints, store_iterates=False\n    )\n\n    pressures = np.array([s.x[0] for s in sols])\n    temperatures = np.array([s.x[1] for s in sols])\n    return pressures, temperatures",
  "def eqm_P_xMgB(A, B):\n    def eqm(arg, T, xMgA):\n        P = arg[0]\n        xMgB = arg[1]\n\n        A.set_composition([xMgA, 1.0 - xMgA])\n        A.set_state(P, T)\n\n        B.set_composition([xMgB, 1.0 - xMgB])\n        B.set_state(P, T)\n\n        diff_mu_Mg2SiO4 = A.partial_gibbs[0] - B.partial_gibbs[0]\n        diff_mu_Fe2SiO4 = A.partial_gibbs[1] - B.partial_gibbs[1]\n        return [diff_mu_Mg2SiO4, diff_mu_Fe2SiO4]\n\n    return eqm",
  "def eqm_P_xMgABC(A, B, C):\n    def eqm(arg, T):\n        P = arg[0]\n        xMgA = arg[1]\n        xMgB = arg[2]\n        xMgC = arg[3]\n\n        A.set_composition([xMgA, 1.0 - xMgA])\n        A.set_state(P, T)\n\n        B.set_composition([xMgB, 1.0 - xMgB])\n        B.set_state(P, T)\n\n        C.set_composition([xMgC, 1.0 - xMgC])\n        C.set_state(P, T)\n\n        diff_mu_Mg2SiO4_0 = A.partial_gibbs[0] - B.partial_gibbs[0]\n        diff_mu_Fe2SiO4_0 = A.partial_gibbs[1] - B.partial_gibbs[1]\n        diff_mu_Mg2SiO4_1 = A.partial_gibbs[0] - C.partial_gibbs[0]\n        diff_mu_Fe2SiO4_1 = A.partial_gibbs[1] - C.partial_gibbs[1]\n\n        return [\n            diff_mu_Mg2SiO4_0,\n            diff_mu_Fe2SiO4_0,\n            diff_mu_Mg2SiO4_1,\n            diff_mu_Fe2SiO4_1,\n        ]\n\n    return eqm",
  "def eqm(arg, T, xMgA):\n        P = arg[0]\n        xMgB = arg[1]\n\n        A.set_composition([xMgA, 1.0 - xMgA])\n        A.set_state(P, T)\n\n        B.set_composition([xMgB, 1.0 - xMgB])\n        B.set_state(P, T)\n\n        diff_mu_Mg2SiO4 = A.partial_gibbs[0] - B.partial_gibbs[0]\n        diff_mu_Fe2SiO4 = A.partial_gibbs[1] - B.partial_gibbs[1]\n        return [diff_mu_Mg2SiO4, diff_mu_Fe2SiO4]",
  "def eqm(arg, T):\n        P = arg[0]\n        xMgA = arg[1]\n        xMgB = arg[2]\n        xMgC = arg[3]\n\n        A.set_composition([xMgA, 1.0 - xMgA])\n        A.set_state(P, T)\n\n        B.set_composition([xMgB, 1.0 - xMgB])\n        B.set_state(P, T)\n\n        C.set_composition([xMgC, 1.0 - xMgC])\n        C.set_state(P, T)\n\n        diff_mu_Mg2SiO4_0 = A.partial_gibbs[0] - B.partial_gibbs[0]\n        diff_mu_Fe2SiO4_0 = A.partial_gibbs[1] - B.partial_gibbs[1]\n        diff_mu_Mg2SiO4_1 = A.partial_gibbs[0] - C.partial_gibbs[0]\n        diff_mu_Fe2SiO4_1 = A.partial_gibbs[1] - C.partial_gibbs[1]\n\n        return [\n            diff_mu_Mg2SiO4_0,\n            diff_mu_Fe2SiO4_0,\n            diff_mu_Mg2SiO4_1,\n            diff_mu_Fe2SiO4_1,\n        ]",
  "class Re(burnman.Mineral):\n    def __init__(self):\n        formula = \"Re1.0\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Re\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 36.53,\n            \"V_0\": 8.862e-06,\n            \"Cp\": [23.7, 0.005448, 68.0, 0.0],\n            \"a_0\": 1.9e-05,\n            \"K_0\": 3.6e11,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -1.1e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        burnman.Mineral.__init__(self)",
  "class ReO2(burnman.Mineral):\n    def __init__(self):\n        formula = \"Re1.0O2.0\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"ReO2\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -445140.0,\n            \"S_0\": 47.82,\n            \"V_0\": 1.8779e-05,\n            \"Cp\": [76.89, 0.00993, -1207130.0, -208.0],\n            \"a_0\": 4.4e-05,\n            \"K_0\": 1.8e11,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.25e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        burnman.Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Re1.0\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Re\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 36.53,\n            \"V_0\": 8.862e-06,\n            \"Cp\": [23.7, 0.005448, 68.0, 0.0],\n            \"a_0\": 1.9e-05,\n            \"K_0\": 3.6e11,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -1.1e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        burnman.Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Re1.0O2.0\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"ReO2\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -445140.0,\n            \"S_0\": 47.82,\n            \"V_0\": 1.8779e-05,\n            \"Cp\": [76.89, 0.00993, -1207130.0, -208.0],\n            \"a_0\": 4.4e-05,\n            \"K_0\": 1.8e11,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.25e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        burnman.Mineral.__init__(self)",
  "def check_birch_murnaghan():\n    \"\"\"\n    Recreates Stixrude and Lithgow-Bertelloni (2005) Figure 1,\n    bulk and shear modulus without thermal corrections\n    \"\"\"\n    plt.close()\n\n    # make a test mineral\n    test_mineral = burnman.Mineral()\n    test_mineral.params = {\n        \"name\": \"test\",\n        \"V_0\": 6.844e-6,\n        \"K_0\": 259.0e9,\n        \"Kprime_0\": 4.0,\n        \"G_0\": 175.0e9,\n        \"Gprime_0\": 1.7,\n        \"molar_mass\": 0.0,\n    }\n    test_mineral.set_method(\"bm3\")\n\n    pressure = np.linspace(0.0, 140.0e9, 100)\n    volume = np.empty_like(pressure)\n    bulk_modulus = np.empty_like(pressure)\n    shear_modulus = np.empty_like(pressure)\n\n    # calculate its static properties\n    for i in range(len(pressure)):\n        volume[i] = bm.volume(pressure[i], test_mineral.params)\n        bulk_modulus[i] = bm.bulk_modulus(volume[i], test_mineral.params)\n        shear_modulus[i] = bm.shear_modulus_third_order(\n            volume[i], test_mineral.params\n        )  # third order is used for the plot we are comparing against\n\n    # compare with figure 1\n    plt.plot(\n        pressure / 1.0e9, bulk_modulus / 1.0e9, pressure / 1.0e9, shear_modulus / 1.0e9\n    )\n    fig1 = mpimg.imread(\"../../burnman/data/input_figures/slb_fig1.png\")\n    plt.imshow(fig1, extent=[0, 140, 0, 800], aspect=\"auto\")\n    plt.plot(\n        pressure / 1.0e9,\n        bulk_modulus / 1.0e9,\n        \"g+\",\n        pressure / 1.0e9,\n        shear_modulus / 1.0e9,\n        \"g+\",\n    )\n    plt.ylim(0, 800)\n    plt.xlim(0, 140)\n    plt.xlabel(\"Pressure (GPa)\")\n    plt.ylabel(\"Modulus (GPa)\")\n    plt.title(\"Comparing with Figure 1 of Stixrude and Lithgow-Bertelloni (2005)\")\n\n    plt.show()",
  "def check_birch_murnaghan_4th():\n    \"\"\"\n    Recreates the formulation of the 4th order Birch-Murnaghan EOS as in\n    Ahmad and Alkammash, 2012; Figure 1.\n    \"\"\"\n    plt.close()\n\n    # make a test mineral\n    test_mineral = burnman.Mineral()\n    test_mineral.params = {\n        \"name\": \"test\",\n        \"V_0\": 10.0e-6,\n        \"K_0\": 72.7e9,\n        \"Kprime_0\": 4.14,\n        \"Kprime_prime_0\": -0.0484e-9,\n    }\n\n    test_mineral.set_method(\"bm4\")\n\n    pressure = np.linspace(0.0, 90.0e9, 20)\n    volume = np.empty_like(pressure)\n\n    # calculate its static properties\n    for i in range(len(pressure)):\n        volume[i] = bm4.volume_fourth_order(\n            pressure[i], test_mineral.params\n        ) / test_mineral.params.get(\"V_0\")\n\n    # compare with figure 1\n    plt.plot(pressure / 1.0e9, volume)\n    fig1 = mpimg.imread(\"../../burnman/data/input_figures/Ahmad.png\")\n    plt.imshow(fig1, extent=[0.0, 90.0, 0.65, 1.0], aspect=\"auto\")\n    plt.plot(pressure / 1.0e9, volume, marker=\"o\", color=\"r\", linestyle=\"\", label=\"BM4\")\n    plt.legend(loc=\"lower left\")\n    plt.xlim(0.0, 90.0)\n    plt.ylim(0.65, 1.0)\n    plt.xlabel(\"Volume/V0\")\n    plt.ylabel(\"Pressure (GPa)\")\n    plt.title(\"Comparing with Figure 1 of Ahmad et al., (2012)\")\n\n    plt.show()",
  "def check_vinet():\n    \"\"\"\n    Recreates Dewaele et al., 2006, Figure 1, fitting a Vinet EOS to Fe data\n    \"\"\"\n    plt.close()\n\n    # make a test mineral\n    test_mineral = burnman.Mineral()\n    test_mineral.params = {\n        \"name\": \"test\",\n        \"V_0\": 6.75e-6,\n        \"K_0\": 163.4e9,\n        \"Kprime_0\": 5.38,\n    }\n\n    test_mineral.set_method(\"vinet\")\n\n    pressure = np.linspace(17.7e9, 300.0e9, 20)\n    volume = np.empty_like(pressure)\n\n    # calculate its static properties\n    for i in range(len(pressure)):\n        volume[i] = vinet.volume(pressure[i], test_mineral.params)\n\n    # compare with figure 1\n    plt.plot(pressure / 1.0e9, volume / 6.02e-7)\n    fig1 = mpimg.imread(\"../../burnman/data/input_figures/Dewaele.png\")\n    plt.imshow(fig1, extent=[0.0, 300.0, 6.8, 11.8], aspect=\"auto\")\n    plt.plot(\n        pressure / 1.0e9,\n        volume / 6.02e-7,\n        marker=\"o\",\n        color=\"r\",\n        linestyle=\"\",\n        label=\"Vinet Fit\",\n    )\n    plt.legend(loc=\"lower left\")\n    plt.xlim(0.0, 300.0)\n    plt.ylim(6.8, 11.8)\n    plt.ylabel(\"Volume (Angstroms^3/atom\")\n    plt.xlabel(\"Pressure (GPa)\")\n    plt.title(\"Comparing with Figure 1 of Dewaele et al., (2006)\")\n\n    plt.show()",
  "def check_mgd_shim_duffy_kenichi():\n    \"\"\"\n    Attemmpts to recreate Shim Duffy Kenichi (2002)\n    \"\"\"\n    plt.close()\n    # Create gold material from Table 1\n    gold = burnman.Mineral()\n    gold.params = {\n        \"name\": \"gold\",\n        \"V_0\": 10.22e-6,\n        \"K_0\": 167.0e9,\n        \"Kprime_0\": 5.0,\n        \"G_0\": 0.0e9,\n        \"Gprime_0\": 0.0,\n        \"molar_mass\": 0.196966,\n        \"n\": 1.0,\n        \"Debye_0\": 170.0,\n        \"grueneisen_0\": 2.97,  # this does better with gr = 2.93.  Why?\n        \"q_0\": 1.0,\n    }\n    gold.set_method(\"mgd3\")\n\n    # Total pressures, pulled from Table 2\n    ref_pressures = [\n        np.array(\n            [\n                0.0,\n                3.55,\n                7.55,\n                12.06,\n                17.16,\n                22.91,\n                29.42,\n                36.77,\n                45.11,\n                54.56,\n                65.29,\n                77.50,\n                91.42,\n                107.32,\n                125.51,\n                146.38,\n                170.38,\n                198.07,\n            ]\n        )\n    ]\n    ref_pressures.append(\n        np.array(\n            [\n                4.99,\n                8.53,\n                12.53,\n                17.04,\n                22.13,\n                27.88,\n                34.38,\n                41.73,\n                50.06,\n                59.50,\n                70.22,\n                82.43,\n                96.33,\n                112.22,\n                130.40,\n                151.25,\n                175.24,\n                202.90,\n            ]\n        )\n    )\n    ref_pressures.append(\n        np.array(\n            [\n                12.14,\n                15.69,\n                19.68,\n                24.19,\n                29.28,\n                35.03,\n                41.53,\n                48.88,\n                57.20,\n                66.64,\n                77.37,\n                89.57,\n                103.47,\n                119.35,\n                137.53,\n                158.38,\n                182.36,\n                210.02,\n            ]\n        )\n    )\n    ref_pressures.append(\n        np.array(\n            [\n                19.30,\n                22.84,\n                26.84,\n                31.35,\n                36.44,\n                42.19,\n                48.68,\n                56.03,\n                64.35,\n                73.80,\n                84.52,\n                96.72,\n                110.62,\n                126.50,\n                144.68,\n                165.53,\n                189.51,\n                217.17,\n            ]\n        )\n    )\n\n    eos = mgd.MGD3()\n\n    pressures = np.empty_like(ref_pressures)\n    ref_dv = np.linspace(0.0, 0.34, len(pressures[0]))\n    ref_volumes = (1 - ref_dv) * gold.params[\"V_0\"]\n    T = np.array([300.0, 1000.0, 2000.0, 3000.0])\n    for t in range(len(pressures)):\n        for i in range(len(pressures[t])):\n            pressures[t][i] = eos.pressure(T[t], ref_volumes[i], gold.params)\n        plt.plot(ref_dv, (pressures[t] / 1.0e9 - ref_pressures[t]))\n    plt.ylim(-1, 1)\n    plt.ylabel(\"Difference in pressure (GPa)\")\n    plt.xlabel(\"1-dV/V\")\n    plt.title(\"Comparing with Shim, Duffy, and Kenichi (2002)\")\n    plt.show()",
  "def check_mgd_fei_mao_shu_hu():\n    \"\"\"\n    Benchmark agains Fei Mao Shu Hu (1991)\n    \"\"\"\n    mgfeo = burnman.Mineral()\n    mgfeo.params = {\n        \"name\": \"MgFeO\",\n        \"V_0\": 11.657e-6,\n        \"K_0\": 157.0e9,\n        \"Kprime_0\": 4.0,\n        \"G_0\": 0.0e9,\n        \"Gprime_0\": 0.0,\n        \"molar_mass\": 0.196966,\n        \"n\": 2.0,\n        \"Debye_0\": 500.0,\n        \"grueneisen_0\": 1.50,\n        \"q_0\": 1.1,\n    }\n    mgfeo.set_method(\"mgd3\")\n\n    # pulled from table 1\n    temperatures = np.array(\n        [\n            300,\n            300,\n            483,\n            483,\n            483,\n            590,\n            593,\n            593,\n            593,\n            700,\n            600,\n            500,\n            650,\n            600,\n            600,\n            650,\n            700,\n            737,\n            727,\n            673,\n            600,\n            543,\n            565,\n            585,\n            600,\n            628,\n            654,\n            745,\n            768,\n            747,\n            726,\n            700,\n            676,\n        ]\n    )\n    volumes = np.array(\n        [\n            77.418,\n            72.327,\n            74.427,\n            73.655,\n            72.595,\n            74.1,\n            73.834,\n            73.101,\n            70.845,\n            73.024,\n            72.630,\n            68.644,\n            72.969,\n            72.324,\n            71.857,\n            72.128,\n            73.283,\n            73.337,\n            72.963,\n            71.969,\n            69.894,\n            67.430,\n            67.607,\n            67.737,\n            68.204,\n            68.518,\n            68.955,\n            70.777,\n            72.921,\n            72.476,\n            72.152,\n            71.858,\n            71.473,\n        ]\n    )\n    # change from cubic angstroms per unit cell to cubic meters per mol of\n    # molecules.\n    volumes = volumes / 1.0e30 * 6.022141e23 / 4.0\n    ref_pressures = np.array(\n        [\n            0.0,\n            12.23,\n            7.77,\n            9.69,\n            12.54,\n            9.21,\n            9.90,\n            11.83,\n            18.35,\n            12.68,\n            13.15,\n            25.16,\n            12.53,\n            14.01,\n            15.34,\n            14.86,\n            11.99,\n            12.08,\n            13.03,\n            15.46,\n            21.44,\n            29.98,\n            29.41,\n            29.05,\n            27.36,\n            26.38,\n            24.97,\n            19.49,\n            13.39,\n            14.48,\n            15.27,\n            15.95,\n            16.94,\n        ]\n    )\n    ref_pressures = ref_pressures\n    pressures = np.empty_like(volumes)\n\n    eos = mgd.MGD3()\n\n    for i in range(len(temperatures)):\n        pressures[i] = eos.pressure(temperatures[i], volumes[i], mgfeo.params)\n\n    plt.scatter(temperatures, (pressures / 1.0e9 - ref_pressures))\n    plt.ylim(-1, 1)\n    plt.title(\"Comparing with Fei, Mao, Shu, and Hu (1991)\")\n    plt.xlabel(\"Temperature (K) at various volumes\")\n    plt.ylabel(\"Difference in total pressure (GPa)\")\n    plt.show()",
  "def check_slb_fig3():\n    \"\"\"\n    Benchmark grueneisen parameter against figure 3 of Stixrude and Lithgow-Bertelloni (2005b)\n    \"\"\"\n    perovskite = burnman.Mineral()\n    perovskite.params = {\n        \"name\": \"perovksite\",\n        \"V_0\": molar_volume_from_unit_cell_volume(168.27, 4.0),\n        \"grueneisen_0\": 1.63,\n        \"q_0\": 1.7,\n    }\n\n    volume = np.linspace(0.6, 1.0, 100)\n    grueneisen_slb = np.empty_like(volume)\n    grueneisen_mgd = np.empty_like(volume)\n    q_slb = np.empty_like(volume)\n    q_mgd = np.empty_like(volume)\n\n    slb_eos = slb.SLB2()\n    mgd_eos = mgd.MGD2()\n\n    # calculate its thermal properties\n    for i in range(len(volume)):\n        # call with dummy pressure and temperatures, they do not change it\n        grueneisen_slb[i] = slb_eos.grueneisen_parameter(\n            0.0, 0.0, volume[i] * perovskite.params[\"V_0\"], perovskite.params\n        )\n        grueneisen_mgd[i] = mgd_eos.grueneisen_parameter(\n            0.0, 0.0, volume[i] * perovskite.params[\"V_0\"], perovskite.params\n        )\n        q_slb[i] = slb_eos.volume_dependent_q(1.0 / volume[i], perovskite.params)\n        q_mgd[i] = perovskite.params[\"q_0\"]\n\n    # compare with figure 7\n    fig1 = mpimg.imread(\"../../burnman/data/input_figures/slb_fig3.png\")\n    plt.imshow(fig1, extent=[0.6, 1.0, 0.35, 2.0], aspect=\"auto\")\n    plt.plot(volume, grueneisen_slb, \"g+\", volume, grueneisen_mgd, \"b+\")\n    plt.plot(volume, q_slb, \"g+\", volume, q_mgd, \"b+\")\n    plt.xlim(0.6, 1.0)\n    plt.ylim(0.35, 2.0)\n    plt.ylabel(\"Grueneisen parameter\")\n    plt.xlabel(\"Relative Volume V/V0\")\n    plt.title(\"Comparing with Figure 3 of Stixrude and Lithgow-Bertelloni (2005)\")\n    plt.show()",
  "def check_slb_fig7_txt():\n    \"\"\"\n    Calculates all values for forsterite and benchmarks with values from Stixrude and Lithgow-Bertelloni (personal communication)\n    \"\"\"\n    forsterite = burnman.Mineral()\n    forsterite.params = {\n        \"name\": \"forsterite\",\n        \"V_0\": 43.603e-6,\n        \"K_0\": 127.955e9,\n        \"Kprime_0\": 4.232,\n        \"G_0\": 81.6e9,\n        \"Gprime_0\": 1.4,\n        \"molar_mass\": 0.140695,\n        \"n\": 7.0,\n        \"Debye_0\": 809.183,\n        \"grueneisen_0\": 0.993,\n        \"q_0\": 2.093,\n        \"F_0\": -1.1406e5,\n        \"eta_s_0\": 2.364,\n    }\n    forsterite.set_method(\"slb3\")\n\n    data = np.loadtxt(\"../../burnman/data/input_minphys/slb_fig7.txt\", skiprows=2)\n\n    temperature = np.array(data[:, 2])\n    pressure = np.array(data[:, 0])\n    rho = np.array(data[:, 3])\n    rho_comp = np.empty_like(rho)\n    Kt = np.array(data[:, 4])\n    Kt_comp = np.empty_like(Kt)\n    Ks = np.array(data[:, 5])\n    Ks_comp = np.empty_like(Ks)\n    G = np.array(data[:, 6])\n    G_comp = np.empty_like(G)\n    VB = np.array(data[:, 7])\n    VB_comp = np.empty_like(VB)\n    VS = np.array(data[:, 8])\n    VS_comp = np.empty_like(VS)\n    VP = np.array(data[:, 9])\n    VP_comp = np.empty_like(VP)\n    vol = np.array(data[:, 10])\n    vol_comp = np.empty_like(vol)\n    alpha = np.array(data[:, 11])\n    alpha_comp = np.empty_like(alpha)\n    Cp = np.array(data[:, 12])\n    Cp_comp = np.empty_like(Cp)\n    gr = np.array(data[:, 13])\n    gr_comp = np.empty_like(gr)\n    gibbs = np.array(data[:, 14])\n    gibbs_comp = np.empty_like(gibbs)\n    entropy = np.array(data[:, 15])\n    entropy_comp = np.empty_like(gibbs)\n    enthalpy = np.array(data[:, 16])\n    enthalpy_comp = np.empty_like(gibbs)\n\n    for i in range(len(temperature)):\n        forsterite.set_state(pressure[i], temperature[i])\n        rho_comp[i] = 100.0 * (forsterite.density / 1000.0 - rho[i]) / rho[i]\n        Kt_comp[i] = (\n            100.0 * (forsterite.isothermal_bulk_modulus / 1.0e9 - Kt[i]) / Kt[i]\n        )\n        Ks_comp[i] = 100.0 * (forsterite.adiabatic_bulk_modulus / 1.0e9 - Ks[i]) / Ks[i]\n        G_comp[i] = 100.0 * (forsterite.shear_modulus / 1.0e9 - G[i]) / G[i]\n        VB_comp[i] = 100.0 * (forsterite.v_phi / 1000.0 - VB[i]) / VB[i]\n        VS_comp[i] = 100.0 * (forsterite.v_s / 1000.0 - VS[i]) / VS[i]\n        VP_comp[i] = 100.0 * (forsterite.v_p / 1000.0 - VP[i]) / VP[i]\n        vol_comp[i] = 100.0 * (forsterite.molar_volume * 1.0e6 - vol[i]) / vol[i]\n        alpha_comp[i] = (\n            100.0 * (forsterite.thermal_expansivity / 1.0e-5 - alpha[i]) / (alpha[-1])\n        )\n        Cp_comp[i] = (\n            100.0\n            * (\n                forsterite.molar_heat_capacity_p\n                / forsterite.params[\"molar_mass\"]\n                / 1000.0\n                - Cp[i]\n            )\n            / (Cp[-1])\n        )\n        gr_comp[i] = (forsterite.grueneisen_parameter - gr[i]) / gr[i]\n        gibbs_comp[i] = 100.0 * (forsterite.molar_gibbs / 1.0e6 - gibbs[i]) / gibbs[i]\n        entropy_comp[i] = (\n            100.0\n            * (forsterite.molar_entropy - entropy[i])\n            / (entropy[i] if entropy[i] != 0.0 else 1.0)\n        )\n        enthalpy_comp[i] = (\n            100.0\n            * (forsterite.molar_enthalpy / 1.0e6 - enthalpy[i])\n            / (enthalpy[i] if enthalpy[i] != 0.0 else 1.0)\n        )\n\n    plt.plot(temperature, rho_comp, label=r\"$\\rho$\")\n    plt.plot(temperature, Kt_comp, label=r\"$K_S$\")\n    plt.plot(temperature, Ks_comp, label=r\"$K_T$\")\n    plt.plot(temperature, G_comp, label=r\"$G$\")\n    plt.plot(temperature, VS_comp, label=r\"$V_S$\")\n    plt.plot(temperature, VP_comp, label=r\"$V_P$\")\n    plt.plot(temperature, VB_comp, label=r\"$V_\\phi$\")\n    plt.plot(temperature, vol_comp, label=r\"$V$\")\n    plt.plot(temperature, alpha_comp, label=r\"$\\alpha$\")\n    plt.plot(temperature, Cp_comp, label=r\"$c_P$\")\n    plt.plot(temperature, gr_comp, label=r\"$\\gamma$\")\n    plt.plot(temperature, gibbs_comp, label=r\"Gibbs\")\n    plt.plot(temperature, enthalpy_comp, label=r\"Enthalpy\")\n    plt.plot(temperature, entropy_comp, label=r\"Entropy\")\n\n    plt.xlim([0, 2750])\n    plt.ylim([-0.001, 0.001])\n    plt.xticks([0, 800, 1600, 2200])\n    plt.xlabel(\"Temperature (K)\")\n    plt.ylabel(\"Percent Difference from HeFESTo\")\n    plt.legend(loc=\"center right\")\n    #    plt.savefig(\"output_figures/benchmark1.pdf\")\n    plt.show()",
  "def check_slb_fig7():\n    \"\"\"\n    Calculates all values for forsterite and benchmarks with figure 7 from Stixrude and Lithgow-Bertelloni (2005)\n    \"\"\"\n    forsterite = burnman.Mineral()\n    forsterite.params = {\n        \"name\": \"forsterite\",\n        \"V_0\": 43.60e-6,\n        \"K_0\": 128.0e9,\n        \"Kprime_0\": 4.2,\n        \"G_0\": 82.0e9,\n        \"Gprime_0\": 1.4,\n        \"n\": 7.0,\n        \"molar_mass\": 0.140695,\n        \"Debye_0\": 809.0,\n        \"grueneisen_0\": 0.99,\n        \"q_0\": 2.1,\n        \"eta_s_0\": 2.4,\n    }\n    forsterite.set_method(\"slb3\")\n\n    temperature = np.linspace(0.0, 2000.0, 200)\n    volume = np.empty_like(temperature)\n    bulk_modulus = np.empty_like(temperature)\n    shear_modulus = np.empty_like(temperature)\n    heat_capacity = np.empty_like(temperature)\n\n    pressure = 1.0e5\n    forsterite.set_state(pressure, 300.0)\n    Ks_0 = forsterite.adiabatic_bulk_modulus\n\n    # calculate its thermal properties\n    for i in range(len(temperature)):\n        forsterite.set_state(pressure, temperature[i])\n        volume[i] = forsterite.molar_volume / forsterite.params[\"V_0\"]\n        bulk_modulus[i] = forsterite.adiabatic_bulk_modulus / Ks_0\n        shear_modulus[i] = forsterite.shear_modulus / forsterite.params[\"G_0\"]\n        heat_capacity[i] = forsterite.molar_heat_capacity_p / forsterite.params[\"n\"]\n\n    # compare with figure 7\n    fig1 = mpimg.imread(\"../../burnman/data/input_figures/slb_fig7_vol.png\")\n    plt.imshow(fig1, extent=[0, 2200, 0.99, 1.08], aspect=\"auto\")\n    plt.plot(temperature, volume, \"g+\")\n    plt.ylim(0.99, 1.08)\n    plt.xlim(0, 2200)\n    plt.xlabel(\"Temperature (K)\")\n    plt.ylabel(\"Relative Volume V/V0\")\n    plt.title(\"Comparing with Figure 7 of Stixrude and Lithgow-Bertelloni (2005)\")\n    plt.show()\n\n    fig1 = mpimg.imread(\"../../burnman/data/input_figures/slb_fig7_Cp.png\")\n    plt.imshow(fig1, extent=[0, 2200, 0.0, 70.0], aspect=\"auto\")\n    plt.plot(temperature, heat_capacity, \"g+\")\n    plt.ylim(0, 70)\n    plt.xlim(0, 2200)\n    plt.xlabel(\"Temperature (K)\")\n    plt.ylabel(\"Heat Capacity Cp\")\n    plt.title(\n        \"Comparing with adiabatic_bulk_modulus7 of Stixrude and Lithgow-Bertelloni (2005)\"\n    )\n    plt.show()\n\n    fig1 = mpimg.imread(\"../../burnman/data/input_figures/slb_fig7_K.png\")\n    plt.imshow(fig1, extent=[0, 2200, 0.6, 1.02], aspect=\"auto\")\n    plt.plot(temperature, bulk_modulus, \"g+\")\n    plt.ylim(0.6, 1.02)\n    plt.xlim(0, 2200)\n    plt.xlabel(\"Temperature (K)\")\n    plt.ylabel(\"Relative Bulk Modulus K/K0\")\n    plt.title(\"Comparing with Figure 7 of Stixrude and Lithgow-Bertelloni (2005)\")\n    plt.show()\n\n    fig1 = mpimg.imread(\"../../burnman/data/input_figures/slb_fig7_G.png\")\n    plt.imshow(fig1, extent=[0, 2200, 0.6, 1.02], aspect=\"auto\")\n    plt.plot(temperature, shear_modulus, \"g+\")\n    plt.ylim(0.6, 1.02)\n    plt.xlim(0, 2200)\n    plt.xlabel(\"Temperature (K)\")\n    plt.ylabel(\"Relative Shear Modulus G/G0\")\n    plt.title(\"Comparing with Figure 7 of Stixrude and Lithgow-Bertelloni (2005)\")\n    plt.show()",
  "def check_averaging():\n    \"\"\"\n    Reproduce Figure 1a from Watt et. al. 1976 to check the Voigt, Reuss,\n    Voigt-Reuss-Hill, and Hashin-Shtrikman bounds for an elastic composite\n    \"\"\"\n    voigt = burnman.averaging_schemes.Voigt()\n    reuss = burnman.averaging_schemes.Reuss()\n    voigt_reuss_hill = burnman.averaging_schemes.VoigtReussHill()\n    hashin_shtrikman_upper = burnman.averaging_schemes.HashinShtrikmanUpper()\n    hashin_shtrikman_lower = burnman.averaging_schemes.HashinShtrikmanLower()\n\n    # create arrays for sampling in volume fraction\n    volumes = np.linspace(0.0, 1.0, 100)\n    v_bulk_modulus = np.empty_like(volumes)\n    v_shear_modulus = np.empty_like(volumes)\n    r_bulk_modulus = np.empty_like(volumes)\n    r_shear_modulus = np.empty_like(volumes)\n    vrh_bulk_modulus = np.empty_like(volumes)\n    vrh_shear_modulus = np.empty_like(volumes)\n    hsu_bulk_modulus = np.empty_like(volumes)\n    hsu_shear_modulus = np.empty_like(volumes)\n    hsl_bulk_modulus = np.empty_like(volumes)\n    hsl_shear_modulus = np.empty_like(volumes)\n\n    # MgO bulk and shear moduli taken from Landolt-Boernstein\n    # - Group III Condensed Matter Volume 41B, 1999, pp 1-3\n    K2 = 152.0  # Bulk modulus, GPa\n    G2 = 155.0  # Shear modulus, GPa\n\n    # AgCl bulk and shear moduli (estimated from plot)\n    G1 = G2 * 0.07\n    K1 = K2 * 0.27\n\n    for i in range(len(volumes)):\n        v_bulk_modulus[i] = voigt.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n        v_shear_modulus[i] = voigt.average_shear_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n\n        r_bulk_modulus[i] = reuss.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n        r_shear_modulus[i] = reuss.average_shear_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n\n        vrh_bulk_modulus[i] = voigt_reuss_hill.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n        vrh_shear_modulus[i] = voigt_reuss_hill.average_shear_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n\n        hsu_bulk_modulus[i] = hashin_shtrikman_upper.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n        hsu_shear_modulus[i] = hashin_shtrikman_upper.average_shear_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n\n        hsl_bulk_modulus[i] = hashin_shtrikman_lower.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n        hsl_shear_modulus[i] = hashin_shtrikman_lower.average_shear_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n\n    fig = mpimg.imread(\"../../burnman/data/input_figures/watt_1976_a1.png\")\n    plt.imshow(fig, extent=[0, 1.0, 0.25, 1.0], aspect=\"auto\")\n    plt.plot(volumes, v_bulk_modulus / K2, \"g-\")\n    plt.plot(volumes, r_bulk_modulus / K2, \"g-\")\n    plt.plot(volumes, vrh_bulk_modulus / K2, \"g-\")\n    plt.plot(volumes, hsu_bulk_modulus / K2, \"g-\")\n    plt.plot(volumes, hsl_bulk_modulus / K2, \"g-\")\n    plt.ylim(0.25, 1.00)\n    plt.xlim(0, 1.0)\n    plt.xlabel(\"Volume fraction\")\n    plt.ylabel(\"Averaged bulk modulus\")\n    plt.title(\"Comparing with Figure 1 of Watt et al 1976\")\n    plt.show()\n\n    fig = mpimg.imread(\"../../burnman/data/input_figures/watt_1976_a2.png\")\n    plt.imshow(fig, extent=[0, 1.0, 0.0, 1.0], aspect=\"auto\")\n    plt.plot(volumes, v_shear_modulus / G2, \"g-\")\n    plt.plot(volumes, r_shear_modulus / G2, \"g-\")\n    plt.plot(volumes, vrh_shear_modulus / G2, \"g-\")\n    plt.plot(volumes, hsu_shear_modulus / G2, \"g-\")\n    plt.plot(volumes, hsl_shear_modulus / G2, \"g-\")\n    plt.ylim(0.0, 1.00)\n    plt.xlim(0, 1.0)\n    plt.xlabel(\"Volume fraction\")\n    plt.ylabel(\"Averaged shear modulus\")\n    plt.title(\"Comparing with Figure 1 of Watt et al 1976\")\n    plt.show()\n\n    # also check against some numerical values given in Berryman (1995) for\n    # porous glass\n    K = 46.3\n    G = 30.5\n    # the value for porosity=0.46 in the table appears to be a typo.  Remove\n    # it here\n    porosity = np.array(\n        [0.0, 0.05, 0.11, 0.13, 0.25, 0.33, 0.36, 0.39, 0.44, 0.50, 0.70]\n    )\n    berryman_bulk_modulus = np.array(\n        [46.3, 41.6, 36.6, 35.1, 27.0, 22.5, 21.0, 19.6, 17.3, 14.8, 7.7]\n    )  # 15.5 probably a typo?\n    hsu_bulk_modulus_vals = np.empty_like(porosity)\n    for i in range(len(porosity)):\n        hsu_bulk_modulus_vals[i] = hashin_shtrikman_upper.average_bulk_moduli(\n            [porosity[i], 1.0 - porosity[i]], [0.0, K], [0.0, G]\n        )\n    for i in range(len(volumes)):\n        hsu_bulk_modulus[i] = hashin_shtrikman_upper.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [0.0, K], [0.0, G]\n        )\n    fig = mpimg.imread(\"../../burnman/data/input_figures/berryman_fig4.png\")\n    plt.imshow(fig, extent=[0, 1.0, 0.0, 50.0], aspect=\"auto\")\n    plt.plot(volumes, hsu_bulk_modulus, \"g-\")\n    plt.scatter(porosity, hsu_bulk_modulus_vals, c=\"r\")\n    plt.scatter(porosity, berryman_bulk_modulus, c=\"y\")\n    plt.ylim(0.0, 50.0)\n    plt.xlim(0, 1.0)\n    plt.xlabel(\"Porosity\")\n    plt.ylabel(\"Averaged bulk modulus\")\n    plt.title(\"Comparing with Figure 4 of Berryman (1995)\")\n    plt.show()",
  "def check_averaging_2():\n    \"\"\"\n    Reproduce Figure 1 from Hashin and Shtrikman (1963) to check the\n    Hashin-Shtrikman bounds for an elastic composite\n    \"\"\"\n\n    hashin_shtrikman_upper = burnman.averaging_schemes.HashinShtrikmanUpper()\n    hashin_shtrikman_lower = burnman.averaging_schemes.HashinShtrikmanLower()\n\n    # create arrays for sampling in volume fraction\n    volumes = np.linspace(0.0, 1.0, 100)\n    hsu_bulk_modulus = np.empty_like(volumes)\n    hsu_shear_modulus = np.empty_like(volumes)\n    hsl_bulk_modulus = np.empty_like(volumes)\n    hsl_shear_modulus = np.empty_like(volumes)\n\n    # These values are from Hashin and Shtrikman (1963)\n    K1 = 25.0\n    K2 = 60.7\n    G1 = 11.5\n    G2 = 41.8\n\n    for i in range(len(volumes)):\n        hsu_bulk_modulus[i] = hashin_shtrikman_upper.average_bulk_moduli(\n            [1.0 - volumes[i], volumes[i]], [K1, K2], [G1, G2]\n        )\n        hsu_shear_modulus[i] = hashin_shtrikman_upper.average_shear_moduli(\n            [1.0 - volumes[i], volumes[i]], [K1, K2], [G1, G2]\n        )\n\n        hsl_bulk_modulus[i] = hashin_shtrikman_lower.average_bulk_moduli(\n            [1.0 - volumes[i], volumes[i]], [K1, K2], [G1, G2]\n        )\n        hsl_shear_modulus[i] = hashin_shtrikman_lower.average_shear_moduli(\n            [1.0 - volumes[i], volumes[i]], [K1, K2], [G1, G2]\n        )\n\n    fig = mpimg.imread(\n        \"../../burnman/data/input_figures/Hashin_Shtrikman_1963_fig1_K.png\"\n    )\n    plt.imshow(fig, extent=[0, 1.0, 1.1, K2 + 0.3], aspect=\"auto\")\n    plt.plot(volumes, hsu_bulk_modulus, \"g-\")\n    plt.plot(volumes, hsl_bulk_modulus, \"g-\")\n    plt.ylim(K1, K2)\n    plt.xlim(0, 1.0)\n    plt.xlabel(\"Volume fraction\")\n    plt.ylabel(\"Averaged bulk modulus\")\n    plt.title(\"Comparing with Figure 1 of Hashin and Shtrikman (1963)\")\n    plt.show()\n\n    fig = mpimg.imread(\n        \"../../burnman/data/input_figures/Hashin_Shtrikman_1963_fig2_G.png\"\n    )\n    plt.imshow(fig, extent=[0, 1.0, 0.3, G2], aspect=\"auto\")\n    plt.plot(volumes, hsu_shear_modulus, \"g-\")\n    plt.plot(volumes, hsl_shear_modulus, \"g-\")\n    plt.ylim(G1, G2)\n    plt.xlim(0, 1.0)\n    plt.xlabel(\"Volume fraction\")\n    plt.ylabel(\"Averaged shear modulus\")\n    plt.title(\"Comparing with Figure 2 of Hashin and Shtrikman (1963)\")\n    plt.show()",
  "def check_averaging_3():\n    \"\"\"\n    Reproduce Figure 3 from Avseth et al. (2010) to check the Voigt, Reuss,\n    Voigt-Reuss-Hill, and Hashin-Shtrikman bounds for an elastic composite\n    \"\"\"\n    voigt = burnman.averaging_schemes.Voigt()\n    reuss = burnman.averaging_schemes.Reuss()\n    voigt_reuss_hill = burnman.averaging_schemes.VoigtReussHill()\n    hashin_shtrikman_upper = burnman.averaging_schemes.HashinShtrikmanUpper()\n    hashin_shtrikman_lower = burnman.averaging_schemes.HashinShtrikmanLower()\n\n    # create arrays for sampling in volume fraction\n    volumes = np.linspace(0.0, 1.0, 100)\n    v_bulk_modulus = np.empty_like(volumes)\n    v_shear_modulus = np.empty_like(volumes)\n    r_bulk_modulus = np.empty_like(volumes)\n    r_shear_modulus = np.empty_like(volumes)\n    vrh_bulk_modulus = np.empty_like(volumes)\n    vrh_shear_modulus = np.empty_like(volumes)\n    hsu_bulk_modulus = np.empty_like(volumes)\n    hsu_shear_modulus = np.empty_like(volumes)\n    hsl_bulk_modulus = np.empty_like(volumes)\n    hsl_shear_modulus = np.empty_like(volumes)\n    hs_av_bulk_modulus = np.empty_like(volumes)\n    hs_av_shear_modulus = np.empty_like(volumes)\n\n    # Quartz bulk and shear moduli\n    K2 = 37.0\n    G2 = 45.0\n\n    # Fluid bulk and shear moduli\n    G1 = 0.00001\n    K1 = 2.35\n\n    for i in range(len(volumes)):\n        v_bulk_modulus[i] = voigt.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n        v_shear_modulus[i] = voigt.average_shear_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n\n        r_bulk_modulus[i] = reuss.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n        r_shear_modulus[i] = reuss.average_shear_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n\n        vrh_bulk_modulus[i] = voigt_reuss_hill.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n        vrh_shear_modulus[i] = voigt_reuss_hill.average_shear_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n\n        hsu_bulk_modulus[i] = hashin_shtrikman_upper.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n        hsu_shear_modulus[i] = hashin_shtrikman_upper.average_shear_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n\n        hsl_bulk_modulus[i] = hashin_shtrikman_lower.average_bulk_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n        hsl_shear_modulus[i] = hashin_shtrikman_lower.average_shear_moduli(\n            [volumes[i], 1.0 - volumes[i]], [K1, K2], [G1, G2]\n        )\n\n        hs_av_bulk_modulus[i] = 0.5 * hsl_bulk_modulus[i] + 0.5 * hsu_bulk_modulus[i]\n        hs_av_shear_modulus[i] = 0.5 * hsl_shear_modulus[i] + 0.5 * hsu_shear_modulus[i]\n\n    fig = mpimg.imread(\"../../burnman/data/input_figures/Avseth_et_al_2010_fig3_K.png\")\n    plt.imshow(fig, extent=[0, 1.0, 0.0, 40.0], aspect=\"auto\")\n    plt.plot(volumes, v_bulk_modulus, \"g-\")\n    plt.plot(volumes, r_bulk_modulus, \"g-\")\n    plt.plot(volumes, vrh_bulk_modulus, \"g-\")\n    plt.plot(volumes, hsu_bulk_modulus, \"g-\")\n    plt.plot(volumes, hsl_bulk_modulus, \"g-\")\n    plt.plot(volumes, hs_av_bulk_modulus, \"g-\")\n    plt.ylim(0.0, 40.00)\n    plt.xlim(0.0, 1.0)\n    plt.xlabel(\"Volume fraction\")\n    plt.ylabel(\"Averaged bulk modulus\")\n    plt.title(\"Comparing with Figure 3 of Avseth et al., 2010\")\n    plt.show()",
  "def p(v1, v2):\n    return (v2 - v1) / v1",
  "def isentrope(T, P, Sref, mineral):\n    mineral.set_state(P, T[0])\n    return Sref - mineral.S",
  "def temperature(T, P, rho, mineral):\n    mineral.set_state(P, T[0])\n    return mineral.density - rho",
  "def old_thermal(T, debye_T, n):\n    if T == 0:\n        return 0\n    return 3.0 * n * constants.gas_constant * T * debye.debye_fn(debye_T / T)",
  "def old_heat(T, debye_T, n):\n    if T == 0:\n        return 0\n    deb = scipy.integrate.quad(\n        lambda x: (pow(x, 4.0) * np.exp(x) / pow((np.exp(x) - 1.0), 2.0)),\n        0.0,\n        debye_T / T,\n    )\n    return 9.0 * n * constants.gas_constant * deb[0] / pow(debye_T / T, 3.0)",
  "class o_d_spinel(burnman.SolidSolution):\n    def __init__(self):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [minerals.HP_2011_ds62.sp(), \"[Mg][Al]2O4\"],\n                [minerals.HP_2011_ds62.sp(), \"[Al][Mg1/2Al1/2]2O4\"],\n            ],\n            energy_interaction=[[0.0]],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "class orthopyroxene_red(burnman.SolidSolution):\n    def __init__(self):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [minerals.SLB_2011.enstatite(), \"Mg[Mg][Si]SiO6\"],\n                [minerals.SLB_2011.mg_tschermaks(), \"Mg[Al][Al]SiO6\"],\n            ],\n            energy_interaction=[[0.0]],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "class orthopyroxene_blue(burnman.SolidSolution):\n    def __init__(self):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [minerals.SLB_2011.enstatite(), \"Mg[Mg]Si2O6\"],\n                [minerals.SLB_2011.mg_tschermaks(), \"Mg[Al]AlSiO6\"],\n            ],\n            energy_interaction=[[0.0]],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "class orthopyroxene_long_dashed(burnman.SolidSolution):\n    def __init__(self):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [minerals.SLB_2011.enstatite(), \"Mg[Mg]Si2O6\"],\n                [minerals.SLB_2011.mg_tschermaks(), \"[Mg1/2Al1/2]2AlSiO6\"],\n            ],\n            energy_interaction=[[10.0e3]],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "class orthopyroxene_short_dashed(burnman.SolidSolution):\n    def __init__(self):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [minerals.SLB_2011.enstatite(), \"Mg[Mg][Si]2O6\"],\n                [minerals.SLB_2011.mg_tschermaks(), \"Mg[Al][Al1/2Si1/2]2O6\"],\n            ],\n            energy_interaction=[[0.0]],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "class clinopyroxene(burnman.SolidSolution):\n    def __init__(self):\n        self.name = \"clinopyroxene\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [minerals.SLB_2011.diopside(), \"[Ca][Mg][Si]2O6\"],\n                [minerals.SLB_2011.ca_tschermaks(), \"[Ca][Al][Si1/2Al1/2]2O6\"],\n            ],\n            energy_interaction=[[26.0e3]],\n            alphas=[1.0, 3.5],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "def __init__(self):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [minerals.HP_2011_ds62.sp(), \"[Mg][Al]2O4\"],\n                [minerals.HP_2011_ds62.sp(), \"[Al][Mg1/2Al1/2]2O4\"],\n            ],\n            energy_interaction=[[0.0]],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "def __init__(self):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [minerals.SLB_2011.enstatite(), \"Mg[Mg][Si]SiO6\"],\n                [minerals.SLB_2011.mg_tschermaks(), \"Mg[Al][Al]SiO6\"],\n            ],\n            energy_interaction=[[0.0]],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "def __init__(self):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [minerals.SLB_2011.enstatite(), \"Mg[Mg]Si2O6\"],\n                [minerals.SLB_2011.mg_tschermaks(), \"Mg[Al]AlSiO6\"],\n            ],\n            energy_interaction=[[0.0]],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "def __init__(self):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [minerals.SLB_2011.enstatite(), \"Mg[Mg]Si2O6\"],\n                [minerals.SLB_2011.mg_tschermaks(), \"[Mg1/2Al1/2]2AlSiO6\"],\n            ],\n            energy_interaction=[[10.0e3]],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "def __init__(self):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [minerals.SLB_2011.enstatite(), \"Mg[Mg][Si]2O6\"],\n                [minerals.SLB_2011.mg_tschermaks(), \"Mg[Al][Al1/2Si1/2]2O6\"],\n            ],\n            energy_interaction=[[0.0]],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "def __init__(self):\n        self.name = \"clinopyroxene\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [minerals.SLB_2011.diopside(), \"[Ca][Mg][Si]2O6\"],\n                [minerals.SLB_2011.ca_tschermaks(), \"[Ca][Al][Si1/2Al1/2]2O6\"],\n            ],\n            energy_interaction=[[26.0e3]],\n            alphas=[1.0, 3.5],\n        )\n\n        burnman.SolidSolution.__init__(self)",
  "def file_to_composition_list(fname, unit_type, normalize):\n    \"\"\"\n    Takes an input file with a specific format and returns a list of\n    compositions (and associated comments) contained in that file.\n\n    :param fname: Path to ascii file containing composition data.\n        Lines beginning with a hash are not read.\n        The first read-line of the datafile contains a list of tab or\n        space-separated components (e.g. FeO or SiO2), followed by the\n        word Comment.\n        Following lines are lists of floats with the amounts of each component.\n        After the component amounts, the user can write anything they like\n        in the Comment section.\n    :type fname: str\n    :param unit_type: 'mass', 'weight' or 'molar'\n        Specify whether the compositions in the file are given as\n        mass (weight) or molar amounts.\n    :type unit_type: str\n    :param normalize: If False, absolute numbers of moles/grams of component are stored,\n        otherwise the component amounts of returned compositions will\n        sum to one (until Composition.renormalize() is used).\n    :type normalize : bool\n\n    \"\"\"\n    lines = list(\n        filter(\n            None, [line.rstrip(\"\\n\").split() for line in open(fname) if line[0] != \"#\"]\n        )\n    )\n    n_components = lines[0].index(\"Comment\")\n    components = lines[0][:n_components]\n    comments = [line[n_components:] for line in lines[1:]]\n    compositions = np.array(\n        [map(float, ln) for ln in list(zip(*(list(zip(*lines[1:]))[:n_components])))]\n    )\n    return [\n        Composition(OrderedCounter(dict(zip(components, c))), unit_type, normalize)\n        for c in compositions\n    ], comments",
  "class Composition(object):\n    \"\"\"\n    Class for a composition object, which can be used\n    to store, modify and renormalize compositions,\n    and also convert between mass, molar\n    and atomic amounts. Weight is provided as an alias\n    for mass, as we assume that only Earthlings\n    will use this software.\n\n    This class is available as ``burnman.Composition``.\n    \"\"\"\n\n    def __init__(self, composition_dictionary, unit_type=\"mass\", normalize=False):\n        \"\"\"\n        Create a composition using a dictionary and unit type.\n\n        :param composition_dictionary: Dictionary of components\n            (given as a string) and their amounts.\n        :type composition_dictionary: dictionary\n        :param unit_type: 'mass', 'weight' or 'molar' (optional, 'mass' as default)\n            Specify whether the input composition is given as mass or\n            molar amounts.\n        :type unit_type: str\n        :param normalize: If False, absolute numbers of kilograms/moles of component are\n            stored, otherwise the component amounts of returned compositions\n            will sum to one (until Composition.renormalize() is used).\n        :type normalize: bool\n        \"\"\"\n\n        self._cached = {}\n\n        n_total = float(sum(composition_dictionary.values()))\n\n        # Create the input dictionary, normalize if requested\n        input_dictionary = OrderedCounter(deepcopy(composition_dictionary))\n        if normalize:\n            for k in composition_dictionary.keys():\n                input_dictionary[k] = composition_dictionary[k] / n_total\n\n        # Break component formulae into atomic dictionaries\n        self.component_formulae = {\n            c: dictionarize_formula(c) for c in composition_dictionary.keys()\n        }\n\n        # Create lists of elemental compositions of components\n        self.element_list = OrderedCounter()\n        for component in self.component_formulae.values():\n            self.element_list += OrderedCounter(\n                {element: n_atoms for (element, n_atoms) in component.items()}\n            )\n        self.element_list = list(self.element_list.keys())\n\n        if unit_type == \"mass\" or unit_type == \"weight\":\n            self.mass_composition = input_dictionary\n        elif unit_type == \"molar\":\n            self.mass_composition = self._mole_to_mass_composition(input_dictionary)\n        else:\n            raise Exception(\n                \"Unit type not yet implemented. \"\n                \"Should be either mass, weight or molar.\"\n            )\n\n    def renormalize(self, unit_type, normalization_component, normalization_amount):\n        \"\"\"\n        Change the total amount of material in the composition\n        to satisfy a given normalization condition\n        (mass, weight, molar, or atomic)\n\n        :param unit_type: 'mass', 'weight', 'molar' or 'atomic'\n            Unit type with which to normalize the composition\n        :type unit_type: str\n        :param normalization_component: Component/element on which to renormalize.\n            String must either be one of the components/elements\n            already in the composition, or have the value 'total'.\n        :type normalization_component: str\n        :param normalization_amount: Amount of component in the\n            renormalised composition.\n        :type normalization_amount: float\n        \"\"\"\n\n        if unit_type not in [\"mass\", \"weight\", \"molar\", \"atomic\"]:\n            raise Exception(\n                \"unit_type not yet implemented.\"\n                \"Should be either mass, weight, molar or atomic.\"\n            )\n\n        c = self.composition(unit_type)\n\n        if normalization_component == \"total\":\n            f = normalization_amount / float(sum(c.values()))\n        else:\n            f = normalization_amount / c[normalization_component]\n\n        new_mass_composition = OrderedCounter()\n        for k in self.mass_composition.keys():\n            new_mass_composition[k] = self.mass_composition[k] * f\n\n        self.mass_composition = new_mass_composition\n\n    def add_components(self, composition_dictionary, unit_type):\n        \"\"\"\n        Add (or remove) components from the composition.\n        The components are added to the current state of the\n        (mass, weight or molar) composition; if the composition has\n        been renormalised, then this should be taken into account.\n\n        :param composition_dictionary: Components to add, and their amounts.\n        :type composition_dictionary: dictionary\n        :param unit_type: 'mass', 'weight' or 'molar'.\n            Unit type of the components to be added.\n        :type unit_type: str\n        \"\"\"\n        if unit_type == \"mass\" or unit_type == \"weight\":\n            composition = self.mass_composition\n        elif unit_type == \"molar\":\n            composition = self.molar_composition\n        else:\n            raise Exception(\n                \"Unit type not recognised. \" \"Should be either mass, weight or molar.\"\n            )\n\n        composition += OrderedCounter(composition_dictionary)\n\n        # Reinitialize composition object\n        self.__init__(composition, unit_type)\n\n    def change_component_set(self, new_component_list):\n        \"\"\"\n        Change the set of basis components without\n        changing the bulk composition.\n\n        Will raise an exception if the new component set is\n        invalid for the given composition.\n\n        :param new_component_list: New set of basis components.\n        :type new_component_list: list of strings\n        \"\"\"\n        composition = np.array(\n            [self.atomic_composition[element] for element in self.element_list]\n        )\n        component_matrix = np.zeros((len(new_component_list), len(self.element_list)))\n\n        for i, component in enumerate(new_component_list):\n            formula = dictionarize_formula(component)\n            for element, n_atoms in formula.items():\n                component_matrix[i][self.element_list.index(element)] = n_atoms\n\n        sol = nnls(component_matrix.T, composition)\n        if sol[1] < 1.0e-12:\n            component_amounts = sol[0]\n        else:\n            raise Exception(\n                \"Failed to change component set. \"\n                \"Could not find a non-negative \"\n                \"least squares solution. \"\n                \"Can the bulk composition be described \"\n                \"with this set of components?\"\n            )\n\n        composition = OrderedCounter(dict(zip(new_component_list, component_amounts)))\n\n        # Reinitialize the object\n        self.__init__(composition, \"molar\")\n\n    def _mole_to_mass_composition(self, molar_comp):\n        \"\"\"\n        Hidden function to returns the mass composition as a counter [kg]\n        \"\"\"\n        cf = self.component_formulae\n        mass_composition = OrderedCounter(\n            {c: molar_comp[c] * formula_mass(cf[c]) for c in molar_comp.keys()}\n        )\n\n        return mass_composition\n\n    @property\n    def weight_composition(self):\n        \"\"\"\n        An alias for mass composition [kg].\n        \"\"\"\n        return self.mass_composition\n\n    @property\n    def molar_composition(self):\n        \"\"\"\n        Returns the molar composition as a counter [moles]\n        \"\"\"\n        mass_comp = self.mass_composition\n        cf = self.component_formulae\n\n        return OrderedCounter(\n            {c: mass_comp[c] / formula_mass(cf[c]) for c in mass_comp.keys()}\n        )\n\n    @property\n    def atomic_composition(self):\n        \"\"\"\n        Returns the atomic composition as a counter [moles]\n        \"\"\"\n\n        return self._moles_to_atoms(self.molar_composition)\n\n    def composition(self, unit_type):\n        \"\"\"\n        Helper function to return the composition in the\n        desired type.\n\n        :param unit_type: One of 'mass', 'weight', 'molar' and 'atomic'.\n        :type unit_type: str\n\n        :returns: Mass (weight), molar or atomic composition.\n        :rtype: OrderedCounter\n        \"\"\"\n        return getattr(self, f\"{unit_type}_composition\")\n\n    def _moles_to_atoms(self, molar_comp_dictionary):\n        \"\"\"\n        Hidden function that converts a molar component\n        dictionary into an atomic (elemental) dictionary\n        \"\"\"\n        component_matrix = np.zeros(\n            (len(self.component_formulae), len(self.element_list))\n        )\n        cf = self.component_formulae\n        molar_composition_vector = np.zeros(len(cf))\n        for i, (component, formula) in enumerate(cf.items()):\n            molar_composition_vector[i] = molar_comp_dictionary[component]\n\n            for element, n_atoms in formula.items():\n                component_matrix[i][self.element_list.index(element)] = n_atoms\n\n        atom_compositions = np.dot(molar_composition_vector, component_matrix)\n        return OrderedCounter(dict(zip(self.element_list, atom_compositions)))\n\n    def print(\n        self,\n        unit_type,\n        significant_figures=1,\n        normalization_component=\"total\",\n        normalization_amount=None,\n    ):\n        \"\"\"\n        Pretty-print function for the composition\n        This does not renormalize the Composition object itself,\n        only the printed values.\n\n        :param unit_type: 'mass', 'weight', 'molar' or 'atomic'\n            Unit type in which to print the composition.\n        :type unit_type: str\n        :param significant_figures: Number of significant figures\n            for each amount.\n        :type significant_figures: int\n        :param normalization_component: Component/element on which to renormalize.\n            String must either be one of the components/elements\n            already in composite, or have the value 'total'.\n            (default = 'total')\n        :type normalization_component: str\n        :param normalization_amount: Amount of component in the\n            renormalised composition. If not explicitly set,\n            no renormalization will be applied.\n        :type normalization_amount: float\n        \"\"\"\n\n        if unit_type not in [\"mass\", \"weight\", \"molar\", \"atomic\"]:\n            raise Exception(\n                \"unit_type not yet implemented.\"\n                \"Should be either mass, weight, molar or atomic.\"\n            )\n\n        c = self.composition(unit_type)\n        print(f\"{unit_type.capitalize()} composition\")\n\n        if normalization_amount is None:\n            f = 1\n        elif normalization_component == \"total\":\n            f = normalization_amount / float(sum(c.values()))\n        else:\n            f = normalization_amount / c[normalization_component]\n\n        for key, value in sorted(c.items()):\n            print(f\"{key}: {value*f:0.{significant_figures}f}\")",
  "def __init__(self, composition_dictionary, unit_type=\"mass\", normalize=False):\n        \"\"\"\n        Create a composition using a dictionary and unit type.\n\n        :param composition_dictionary: Dictionary of components\n            (given as a string) and their amounts.\n        :type composition_dictionary: dictionary\n        :param unit_type: 'mass', 'weight' or 'molar' (optional, 'mass' as default)\n            Specify whether the input composition is given as mass or\n            molar amounts.\n        :type unit_type: str\n        :param normalize: If False, absolute numbers of kilograms/moles of component are\n            stored, otherwise the component amounts of returned compositions\n            will sum to one (until Composition.renormalize() is used).\n        :type normalize: bool\n        \"\"\"\n\n        self._cached = {}\n\n        n_total = float(sum(composition_dictionary.values()))\n\n        # Create the input dictionary, normalize if requested\n        input_dictionary = OrderedCounter(deepcopy(composition_dictionary))\n        if normalize:\n            for k in composition_dictionary.keys():\n                input_dictionary[k] = composition_dictionary[k] / n_total\n\n        # Break component formulae into atomic dictionaries\n        self.component_formulae = {\n            c: dictionarize_formula(c) for c in composition_dictionary.keys()\n        }\n\n        # Create lists of elemental compositions of components\n        self.element_list = OrderedCounter()\n        for component in self.component_formulae.values():\n            self.element_list += OrderedCounter(\n                {element: n_atoms for (element, n_atoms) in component.items()}\n            )\n        self.element_list = list(self.element_list.keys())\n\n        if unit_type == \"mass\" or unit_type == \"weight\":\n            self.mass_composition = input_dictionary\n        elif unit_type == \"molar\":\n            self.mass_composition = self._mole_to_mass_composition(input_dictionary)\n        else:\n            raise Exception(\n                \"Unit type not yet implemented. \"\n                \"Should be either mass, weight or molar.\"\n            )",
  "def renormalize(self, unit_type, normalization_component, normalization_amount):\n        \"\"\"\n        Change the total amount of material in the composition\n        to satisfy a given normalization condition\n        (mass, weight, molar, or atomic)\n\n        :param unit_type: 'mass', 'weight', 'molar' or 'atomic'\n            Unit type with which to normalize the composition\n        :type unit_type: str\n        :param normalization_component: Component/element on which to renormalize.\n            String must either be one of the components/elements\n            already in the composition, or have the value 'total'.\n        :type normalization_component: str\n        :param normalization_amount: Amount of component in the\n            renormalised composition.\n        :type normalization_amount: float\n        \"\"\"\n\n        if unit_type not in [\"mass\", \"weight\", \"molar\", \"atomic\"]:\n            raise Exception(\n                \"unit_type not yet implemented.\"\n                \"Should be either mass, weight, molar or atomic.\"\n            )\n\n        c = self.composition(unit_type)\n\n        if normalization_component == \"total\":\n            f = normalization_amount / float(sum(c.values()))\n        else:\n            f = normalization_amount / c[normalization_component]\n\n        new_mass_composition = OrderedCounter()\n        for k in self.mass_composition.keys():\n            new_mass_composition[k] = self.mass_composition[k] * f\n\n        self.mass_composition = new_mass_composition",
  "def add_components(self, composition_dictionary, unit_type):\n        \"\"\"\n        Add (or remove) components from the composition.\n        The components are added to the current state of the\n        (mass, weight or molar) composition; if the composition has\n        been renormalised, then this should be taken into account.\n\n        :param composition_dictionary: Components to add, and their amounts.\n        :type composition_dictionary: dictionary\n        :param unit_type: 'mass', 'weight' or 'molar'.\n            Unit type of the components to be added.\n        :type unit_type: str\n        \"\"\"\n        if unit_type == \"mass\" or unit_type == \"weight\":\n            composition = self.mass_composition\n        elif unit_type == \"molar\":\n            composition = self.molar_composition\n        else:\n            raise Exception(\n                \"Unit type not recognised. \" \"Should be either mass, weight or molar.\"\n            )\n\n        composition += OrderedCounter(composition_dictionary)\n\n        # Reinitialize composition object\n        self.__init__(composition, unit_type)",
  "def change_component_set(self, new_component_list):\n        \"\"\"\n        Change the set of basis components without\n        changing the bulk composition.\n\n        Will raise an exception if the new component set is\n        invalid for the given composition.\n\n        :param new_component_list: New set of basis components.\n        :type new_component_list: list of strings\n        \"\"\"\n        composition = np.array(\n            [self.atomic_composition[element] for element in self.element_list]\n        )\n        component_matrix = np.zeros((len(new_component_list), len(self.element_list)))\n\n        for i, component in enumerate(new_component_list):\n            formula = dictionarize_formula(component)\n            for element, n_atoms in formula.items():\n                component_matrix[i][self.element_list.index(element)] = n_atoms\n\n        sol = nnls(component_matrix.T, composition)\n        if sol[1] < 1.0e-12:\n            component_amounts = sol[0]\n        else:\n            raise Exception(\n                \"Failed to change component set. \"\n                \"Could not find a non-negative \"\n                \"least squares solution. \"\n                \"Can the bulk composition be described \"\n                \"with this set of components?\"\n            )\n\n        composition = OrderedCounter(dict(zip(new_component_list, component_amounts)))\n\n        # Reinitialize the object\n        self.__init__(composition, \"molar\")",
  "def _mole_to_mass_composition(self, molar_comp):\n        \"\"\"\n        Hidden function to returns the mass composition as a counter [kg]\n        \"\"\"\n        cf = self.component_formulae\n        mass_composition = OrderedCounter(\n            {c: molar_comp[c] * formula_mass(cf[c]) for c in molar_comp.keys()}\n        )\n\n        return mass_composition",
  "def weight_composition(self):\n        \"\"\"\n        An alias for mass composition [kg].\n        \"\"\"\n        return self.mass_composition",
  "def molar_composition(self):\n        \"\"\"\n        Returns the molar composition as a counter [moles]\n        \"\"\"\n        mass_comp = self.mass_composition\n        cf = self.component_formulae\n\n        return OrderedCounter(\n            {c: mass_comp[c] / formula_mass(cf[c]) for c in mass_comp.keys()}\n        )",
  "def atomic_composition(self):\n        \"\"\"\n        Returns the atomic composition as a counter [moles]\n        \"\"\"\n\n        return self._moles_to_atoms(self.molar_composition)",
  "def composition(self, unit_type):\n        \"\"\"\n        Helper function to return the composition in the\n        desired type.\n\n        :param unit_type: One of 'mass', 'weight', 'molar' and 'atomic'.\n        :type unit_type: str\n\n        :returns: Mass (weight), molar or atomic composition.\n        :rtype: OrderedCounter\n        \"\"\"\n        return getattr(self, f\"{unit_type}_composition\")",
  "def _moles_to_atoms(self, molar_comp_dictionary):\n        \"\"\"\n        Hidden function that converts a molar component\n        dictionary into an atomic (elemental) dictionary\n        \"\"\"\n        component_matrix = np.zeros(\n            (len(self.component_formulae), len(self.element_list))\n        )\n        cf = self.component_formulae\n        molar_composition_vector = np.zeros(len(cf))\n        for i, (component, formula) in enumerate(cf.items()):\n            molar_composition_vector[i] = molar_comp_dictionary[component]\n\n            for element, n_atoms in formula.items():\n                component_matrix[i][self.element_list.index(element)] = n_atoms\n\n        atom_compositions = np.dot(molar_composition_vector, component_matrix)\n        return OrderedCounter(dict(zip(self.element_list, atom_compositions)))",
  "def print(\n        self,\n        unit_type,\n        significant_figures=1,\n        normalization_component=\"total\",\n        normalization_amount=None,\n    ):\n        \"\"\"\n        Pretty-print function for the composition\n        This does not renormalize the Composition object itself,\n        only the printed values.\n\n        :param unit_type: 'mass', 'weight', 'molar' or 'atomic'\n            Unit type in which to print the composition.\n        :type unit_type: str\n        :param significant_figures: Number of significant figures\n            for each amount.\n        :type significant_figures: int\n        :param normalization_component: Component/element on which to renormalize.\n            String must either be one of the components/elements\n            already in composite, or have the value 'total'.\n            (default = 'total')\n        :type normalization_component: str\n        :param normalization_amount: Amount of component in the\n            renormalised composition. If not explicitly set,\n            no renormalization will be applied.\n        :type normalization_amount: float\n        \"\"\"\n\n        if unit_type not in [\"mass\", \"weight\", \"molar\", \"atomic\"]:\n            raise Exception(\n                \"unit_type not yet implemented.\"\n                \"Should be either mass, weight, molar or atomic.\"\n            )\n\n        c = self.composition(unit_type)\n        print(f\"{unit_type.capitalize()} composition\")\n\n        if normalization_amount is None:\n            f = 1\n        elif normalization_component == \"total\":\n            f = normalization_amount / float(sum(c.values()))\n        else:\n            f = normalization_amount / c[normalization_component]\n\n        for key, value in sorted(c.items()):\n            print(f\"{key}: {value*f:0.{significant_figures}f}\")",
  "def _ideal_activities_fct(\n    molar_fractions,\n    endmember_noccupancies,\n    n_endmembers,\n    n_occupancies,\n    site_multiplicities,\n    endmember_configurational_entropies,\n):\n    site_noccupancies = np.dot(molar_fractions, endmember_noccupancies)\n    site_multiplicities = np.einsum(\"i, ij\", molar_fractions, site_multiplicities)\n    site_occupancies = site_noccupancies * inverseish(site_multiplicities)\n\n    a = np.power(site_occupancies, endmember_noccupancies).prod(-1)\n    normalisation_constants = np.exp(\n        endmember_configurational_entropies / constants.gas_constant\n    )\n    return normalisation_constants * a",
  "def _non_ideal_hessian_fct(phi, molar_fractions, n_endmembers, alpha, W):\n    q = np.eye(n_endmembers) - phi * np.ones((n_endmembers, n_endmembers))\n    sum_pa = np.dot(molar_fractions, alpha)\n    hess = np.einsum(\"m, i, ij, jk, mk->im\", -alpha / sum_pa, -alpha, q, W, q)\n    hess += hess.T\n    return hess",
  "def _non_ideal_interactions_fct(phi, molar_fractions, n_endmembers, alpha, W):\n    # -sum(sum(qi.qj.Wij*)\n    # equation (2) of Holland and Powell 2003\n    q = np.eye(n_endmembers) - phi * np.ones((n_endmembers, n_endmembers))\n    # The following are equivalent to\n    # np.einsum('i, ij, jk, ik->i', -self.alphas, q, self.Wx, q)\n    Wint = -alpha * (q.dot(W) * q).sum(-1)\n    return Wint",
  "def _non_ideal_hessian_subreg(p, n_endmembers, Wijk):\n    Id = np.identity(n_endmembers)\n    IIp = np.einsum(\"il, jm, k->ijklm\", Id, Id, p)\n    Ipp = np.einsum(\"il, j, k->ijkl\", Id, p, p)\n    ppp = np.einsum(\"i, j, k->ijk\", p, p, p)\n\n    A = (\n        IIp\n        + np.transpose(IIp, axes=[0, 2, 1, 3, 4])\n        + np.transpose(IIp, axes=[1, 0, 2, 3, 4])\n        + np.transpose(IIp, axes=[1, 2, 0, 3, 4])\n        + np.transpose(IIp, axes=[2, 1, 0, 3, 4])\n        + np.transpose(IIp, axes=[2, 0, 1, 3, 4])\n    )\n    B = 2.0 * (\n        Ipp\n        + np.transpose(Ipp, axes=[1, 0, 2, 3])\n        + np.transpose(Ipp, axes=[2, 1, 0, 3])\n    )\n\n    Asum = (\n        A - B[:, :, :, :, None] - B[:, :, :, None, :] + 6.0 * ppp[:, :, :, None, None]\n    )\n    hess = np.einsum(\"ijklm, ijk->lm\", Asum, Wijk)\n    return hess",
  "def _non_ideal_interactions_subreg(p, n_endmembers, Wijk):\n    Aijkl = np.einsum(\"li, j, k->ijkl\", np.identity(n_endmembers), p, p)\n    ppp = np.einsum(\"i, j, k->ijk\", p, p, p)\n\n    Asum = (\n        Aijkl\n        + np.transpose(Aijkl, axes=[1, 0, 2, 3])\n        + np.transpose(Aijkl, axes=[1, 2, 0, 3])\n        - 2 * ppp[:, :, :, None]\n    )\n\n    Wint = np.einsum(\"ijk, ijkl->l\", Wijk, Asum)\n    return Wint",
  "def logish(x, eps=1.0e-5):\n    \"\"\"\n    2nd order series expansion of log(x) about eps:\n    log(eps) - sum_k=1^infty (f_eps)^k / k\n    Prevents infinities at x=0\n    \"\"\"\n    f_eps = 1.0 - x / eps\n    mask = x > eps\n    ln = np.where(x <= eps, np.log(eps) - f_eps - f_eps * f_eps / 2.0, 0.0)\n    ln[mask] = np.log(x[mask])\n    return ln",
  "def inverseish(x, eps=1.0e-5):\n    \"\"\"\n    1st order series expansion of 1/x about eps: 2/eps - x/eps/eps\n    Prevents infinities at x=0\n    \"\"\"\n    mask = x > eps\n    oneoverx = np.where(x <= eps, 2.0 / eps - x / eps / eps, 0.0)\n    oneoverx[mask] = 1.0 / x[mask]\n    return oneoverx",
  "class SolutionModel(object):\n\n    \"\"\"\n    This is the base class for a solution model,  intended for use\n    in defining solutions and performing thermodynamic calculations\n    on them.  All minerals of type :class:`burnman.Solution` use\n    a solution model for defining how the endmembers in the solution\n    interact.\n\n    A user wanting a new solution model should define the functions included\n    in the base class. All of the functions in the base class return zero,\n    so if the user-defined solution model does not implement them,\n    they essentially have no effect, and the Gibbs free energy and molar\n    volume of a solution will be equal to the weighted arithmetic\n    averages of the different endmember values.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Does nothing.\n        \"\"\"\n        pass\n\n    def excess_gibbs_free_energy(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess Gibbs free energy of the solution.\n        The base class implementation assumes that the excess gibbs\n        free energy is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess Gibbs energy.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            np.array(molar_fractions),\n            self.excess_partial_gibbs_free_energies(\n                pressure, temperature, molar_fractions\n            ),\n        )\n\n    def excess_volume(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess volume of the solution.\n        The base class implementation assumes that the excess volume is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess volume of the solution.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            molar_fractions,\n            self.excess_partial_volumes(pressure, temperature, molar_fractions),\n        )\n\n    def excess_entropy(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess entropy of the solution.\n        The base class implementation assumes that the excess entropy is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess entropy of the solution.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            molar_fractions,\n            self.excess_partial_entropies(pressure, temperature, molar_fractions),\n        )\n\n    def excess_enthalpy(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess enthalpy of the solution.\n        The base class implementation assumes that the excess enthalpy is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess enthalpy of the solution.\n        :rtype: float\n        \"\"\"\n        return self.excess_gibbs_free_energy(\n            pressure, temperature, molar_fractions\n        ) + temperature * self.excess_entropy(pressure, temperature, molar_fractions)\n\n    def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess Gibbs free energy for each endmember\n        of the solution.\n        The base class implementation assumes that the excess gibbs\n        free energy is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess partial Gibbs free energy of each endmember.\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(molar_fractions)\n\n    def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess entropy for each endmember of the solution.\n        The base class implementation assumes that the excess entropy\n        is zero (true for mechanical solutions).\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess partial entropy of each endmember.\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(molar_fractions)\n\n    def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess volume for each endmember of the solution.\n        The base class implementation assumes that the excess volume\n        is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess partial volume of each endmember.\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(np.array(molar_fractions))\n\n    def Cp_excess(self):\n        \"\"\"\n        Returns the excess heat capacity of the solution model\n        at its current state\n        \"\"\"\n        return 0.0\n\n    def alphaV_excess(self):\n        \"\"\"\n        Returns the excess alpha*V of the solution model\n        at its current state\n        \"\"\"\n        return 0.0\n\n    def VoverKT_excess(self):\n        \"\"\"\n        Returns the excess V/K_T of the solution model\n        at its current state\n        \"\"\"\n        return 0.0",
  "class MechanicalSolution(SolutionModel):\n\n    \"\"\"\n    An extremely simple class representing a mechanical solution model.\n    A mechanical solution experiences no interaction between endmembers.\n    Therefore, unlike ideal solutions there is no entropy of mixing;\n    the total gibbs free energy of the solution is equal to the\n    dot product of the molar gibbs free energies and molar fractions\n    of the constituent materials.\n    \"\"\"\n\n    def __init__(self, endmembers):\n        self.endmembers = endmembers\n        self.n_endmembers = len(endmembers)\n        self.formulas = [e[1] for e in endmembers]\n\n    def excess_gibbs_free_energy(self, pressure, temperature, molar_fractions):\n        return 0.0\n\n    def excess_volume(self, pressure, temperature, molar_fractions):\n        return 0.0\n\n    def excess_entropy(self, pressure, temperature, molar_fractions):\n        return 0.0\n\n    def excess_enthalpy(self, pressure, temperature, molar_fractions):\n        return 0.0\n\n    def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        return np.zeros_like(molar_fractions)\n\n    def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        return np.zeros_like(molar_fractions)\n\n    def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        return np.zeros_like(molar_fractions)\n\n    def activity_coefficients(self, pressure, temperature, molar_fractions):\n        return np.ones_like(molar_fractions)\n\n    def activities(self, pressure, temperature, molar_fractions):\n        return np.ones_like(molar_fractions)",
  "class IdealSolution(SolutionModel):\n\n    \"\"\"\n    A class representing an ideal solution model.\n    Calculates the excess gibbs free energy and entropy due to configurational\n    entropy. Excess internal energy and volume are equal to zero.\n\n    The multiplicity of each type of site in the structure is allowed to\n    change linearly as a function of endmember proportions. This class\n    is therefore equivalent to the entropic part of\n    a Temkin-type model :cite:`Temkin1945`.\n    \"\"\"\n\n    def __init__(self, endmembers):\n        self.endmembers = endmembers\n        self.n_endmembers = len(endmembers)\n        self.formulas = [e[1] for e in endmembers]\n\n        # Process solution chemistry\n        process_solution_chemistry(self)\n\n        self._calculate_endmember_configurational_entropies()\n\n    def _calculate_endmember_configurational_entropies(self):\n        S_conf = -(\n            constants.gas_constant\n            * (self.endmember_noccupancies * logish(self.endmember_occupancies)).sum(-1)\n        )\n        self.endmember_configurational_entropies = S_conf\n\n    def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        return self._ideal_excess_partial_gibbs(temperature, molar_fractions)\n\n    def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        return self._ideal_excess_partial_entropies(temperature, molar_fractions)\n\n    def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        return np.zeros((self.n_endmembers))\n\n    def gibbs_hessian(self, pressure, temperature, molar_fractions):\n        hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)\n        return -temperature * hess_S\n\n    def entropy_hessian(self, pressure, temperature, molar_fractions):\n        hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)\n        return hess_S\n\n    def volume_hessian(self, pressure, temperature, molar_fractions):\n        return np.zeros((len(molar_fractions), len(molar_fractions)))\n\n    def _configurational_entropy(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n        site_occupancies = site_noccupancies * inverseish(site_multiplicities)\n        conf_entropy = -(\n            constants.gas_constant\n            * (site_noccupancies * logish(site_occupancies)).sum(-1)\n        )\n        return conf_entropy\n\n    def _ideal_excess_partial_gibbs(self, temperature, molar_fractions):\n        return -(\n            temperature\n            * self._ideal_excess_partial_entropies(temperature, molar_fractions)\n        )\n\n    def _ideal_excess_partial_entropies(self, temperature, molar_fractions):\n        return -(constants.gas_constant * self._log_ideal_activities(molar_fractions))\n\n    def _ideal_entropy_hessian(self, temperature, molar_fractions):\n        hessian = -(\n            constants.gas_constant\n            * self._log_ideal_activity_derivatives(molar_fractions)\n        )\n        return hessian\n\n    def _log_ideal_activities(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n\n        lna = np.einsum(\n            \"ij, j->i\",\n            self.endmember_noccupancies,\n            logish(site_noccupancies) - logish(site_multiplicities),\n        )\n        normalisation_constants = (\n            self.endmember_configurational_entropies / constants.gas_constant\n        )\n        return lna + normalisation_constants\n\n    def _log_ideal_activity_derivatives(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n\n        dlnadp = np.einsum(\n            \"pj, qj, j->pq\",\n            self.endmember_noccupancies,\n            self.endmember_noccupancies,\n            inverseish(site_noccupancies),\n        ) - np.einsum(\n            \"pj, qj, j->pq\",\n            self.endmember_noccupancies,\n            self.site_multiplicities,\n            inverseish(site_multiplicities),\n        )\n\n        return dlnadp\n\n    def _ideal_activities(self, molar_fractions):\n        return _ideal_activities_fct(\n            molar_fractions,\n            self.endmember_noccupancies,\n            self.n_endmembers,\n            self.n_occupancies,\n            self.site_multiplicities,\n            self.endmember_configurational_entropies,\n        )\n\n    def activity_coefficients(self, pressure, temperature, molar_fractions):\n        return np.ones_like(molar_fractions)\n\n    def activities(self, pressure, temperature, molar_fractions):\n        return self._ideal_activities(molar_fractions)",
  "class AsymmetricRegularSolution(IdealSolution):\n\n    \"\"\"\n    Solution model implementing the asymmetric regular solution model\n    formulation as described in :cite:`HP2003`.\n\n    The excess nonconfigurational Gibbs energy is given by the\n    expression:\n\n    .. math::\n        \\\\mathcal{G}_{\\\\textrm{excess}} = \\\\alpha^T p (\\\\phi^T W \\\\phi)\n\n    :math:`\\\\alpha` is a vector of van Laar parameters governing asymmetry\n    in the excess properties.\n\n    .. math::\n        \\\\phi_i = \\\\frac{\\\\alpha_i p_i}{\\\\sum_{k=1}^{n} \\\\alpha_k p_k},\n        W_{ij} = \\\\frac{2 w_{ij}}{\\\\alpha_i + \\\\alpha_j} \\\\textrm{for i<j}\n    \"\"\"\n\n    def __init__(\n        self,\n        endmembers,\n        alphas,\n        energy_interaction,\n        volume_interaction=None,\n        entropy_interaction=None,\n    ):\n        self.n_endmembers = len(endmembers)\n\n        # Create array of van Laar parameters\n        self.alphas = np.array(alphas)\n\n        # Create 2D arrays of interaction parameters\n        self.We = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n        self.We[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n            [i for row in energy_interaction for i in row]\n        )\n\n        if entropy_interaction is not None:\n            self.Ws = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n            self.Ws[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n                [i for row in entropy_interaction for i in row]\n            )\n        else:\n            self.Ws = np.zeros((self.n_endmembers, self.n_endmembers))\n\n        if volume_interaction is not None:\n            self.Wv = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n            self.Wv[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n                [i for row in volume_interaction for i in row]\n            )\n        else:\n            self.Wv = np.zeros((self.n_endmembers, self.n_endmembers))\n\n        # initialize ideal solution model\n        IdealSolution.__init__(self, endmembers)\n\n    def _phi(self, molar_fractions):\n        phi = self.alphas * molar_fractions\n        phi = np.divide(phi, np.sum(phi))\n        return phi\n\n    def _non_ideal_interactions(self, W, molar_fractions):\n        # -sum(sum(qi.qj.Wij*)\n        # equation (2) of Holland and Powell 2003\n        phi = self._phi(molar_fractions)\n        return _non_ideal_interactions_fct(\n            phi, np.array(molar_fractions), self.n_endmembers, self.alphas, W\n        )\n\n    def _non_ideal_excess_partial_gibbs(self, pressure, temperature, molar_fractions):\n        Eint = self._non_ideal_interactions(self.We, molar_fractions)\n        Sint = self._non_ideal_interactions(self.Ws, molar_fractions)\n        Vint = self._non_ideal_interactions(self.Wv, molar_fractions)\n        return Eint - temperature * Sint + pressure * Vint\n\n    def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(\n            self, temperature, molar_fractions\n        )\n        non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_gibbs + non_ideal_gibbs\n\n    def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        ideal_entropies = IdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_interactions(self.Ws, molar_fractions)\n        return ideal_entropies + non_ideal_entropies\n\n    def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        return self._non_ideal_interactions(self.Wv, molar_fractions)\n\n    def gibbs_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        phi = self._phi(molar_fractions)\n        nonideal_gibbs_hessian = _non_ideal_hessian_fct(\n            phi,\n            molar_fractions,\n            self.n_endmembers,\n            self.alphas,\n            self.We - temperature * self.Ws + pressure * self.Wv,\n        )\n\n        return nonideal_gibbs_hessian - temperature * ideal_entropy_hessian\n\n    def entropy_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        phi = self._phi(molar_fractions)\n        nonideal_entropy_hessian = _non_ideal_hessian_fct(\n            phi, molar_fractions, self.n_endmembers, self.alphas, self.Ws\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian\n\n    def volume_hessian(self, pressure, temperature, molar_fractions):\n        phi = self._phi(molar_fractions)\n        return _non_ideal_hessian_fct(\n            phi, molar_fractions, self.n_endmembers, self.alphas, self.Wv\n        )\n\n    def activity_coefficients(self, pressure, temperature, molar_fractions):\n        if temperature > 1.0e-10:\n            return np.exp(\n                self._non_ideal_excess_partial_gibbs(\n                    pressure, temperature, molar_fractions\n                )\n                / (constants.gas_constant * temperature)\n            )\n        else:\n            raise Exception(\"Activity coefficients not defined at 0 K.\")\n\n    def activities(self, pressure, temperature, molar_fractions):\n        return IdealSolution.activities(\n            self, pressure, temperature, molar_fractions\n        ) * self.activity_coefficients(pressure, temperature, molar_fractions)",
  "class SymmetricRegularSolution(AsymmetricRegularSolution):\n\n    \"\"\"\n    Solution model implementing the symmetric regular solution model.\n    This is a special case of the\n    :class:`burnman.solutionmodel.AsymmetricRegularSolution` class.\n    \"\"\"\n\n    def __init__(\n        self,\n        endmembers,\n        energy_interaction,\n        volume_interaction=None,\n        entropy_interaction=None,\n    ):\n        alphas = np.ones(len(endmembers))\n        AsymmetricRegularSolution.__init__(\n            self,\n            endmembers,\n            alphas,\n            energy_interaction,\n            volume_interaction,\n            entropy_interaction,\n        )",
  "class SubregularSolution(IdealSolution):\n\n    \"\"\"\n    Solution model implementing the subregular solution model formulation\n    as described in :cite:`HW1989`. The excess nonconfigurational\n    Gibbs energy is given by the expression:\n\n    .. math::\n        \\\\mathcal{G}_{\\\\textrm{excess}} = \\\\sum_i \\\\sum_{j > i} (p_i p_j^2\n        W_{ij} + p_j p_i^2 W_{ji} + \\\\sum_{k > j > i} p_i p_j p_k W_{ijk})\n\n    Interaction parameters are inserted into a 3D interaction matrix during\n    initialization to make use of numpy vector algebra.\n\n    :param endmembers: A list of all the independent endmembers in the solution.\n        The first item of each list gives the Mineral object corresponding\n        to the endmember. The second item gives the site-species formula.\n    :type endmembers: list of lists\n    :param energy_interaction: The binary endmember interaction energies.\n        Each interaction[i, j-i-1, 0] corresponds to W(i,j), while\n        interaction[i, j-i-1, 1] corresponds to W(j,i).\n    :type energy_interaction: list of list of lists\n    :param volume_interaction: The binary endmember interaction volumes.\n        Each interaction[i, j-i-1, 0] corresponds to W(i,j), while\n        interaction[i, j-i-1, 1] corresponds to W(j,i).\n    :type volume_interaction: list of list of lists\n    :param entropy_interaction: The binary endmember interaction entropies.\n        Each interaction[i, j-i-1, 0] corresponds to W(i,j), while\n        interaction[i, j-i-1, 1] corresponds to W(j,i).\n    :type entropy_interaction: list of list of lists\n    :param energy_ternary_terms: The ternary interaction energies.\n        Each list should contain four entries:\n        the indices i, j, k and the value of the interaction.\n    :type energy_ternary_terms: list of lists\n    :param volume_ternary_terms: The ternary interaction volumes.\n        Each list should contain four entries:\n        the indices i, j, k and the value of the interaction.\n    :type volume_ternary_terms: list of lists\n    :param entropy_ternary_terms: The ternary interaction entropies.\n        Each list should contain four entries:\n        the indices i, j, k and the value of the interaction.\n    :type entropy_ternary_terms: list of lists\n    \"\"\"\n\n    def __init__(\n        self,\n        endmembers,\n        energy_interaction,\n        volume_interaction=None,\n        entropy_interaction=None,\n        energy_ternary_terms=None,\n        volume_ternary_terms=None,\n        entropy_ternary_terms=None,\n    ):\n        \"\"\"\n        Initialization function for the SubregularSolution class.\n        \"\"\"\n\n        self.n_endmembers = len(endmembers)\n\n        # Create 3D arrays of interaction parameters\n        self.Wijke = np.zeros(\n            shape=(self.n_endmembers, self.n_endmembers, self.n_endmembers)\n        )\n        self.Wijks = np.zeros_like(self.Wijke)\n        self.Wijkv = np.zeros_like(self.Wijke)\n\n        # setup excess enthalpy interaction matrix\n        for i in range(self.n_endmembers):\n            for j in range(i + 1, self.n_endmembers):\n                w0 = energy_interaction[i][j - i - 1][0] / 2.0\n                w1 = energy_interaction[i][j - i - 1][1] / 2.0\n                self.Wijke[:, i, j] += w0\n                self.Wijke[:, j, i] += w1\n\n                self.Wijke[i, j, j] += w0\n                self.Wijke[j, i, i] += w1\n\n                self.Wijke[i, j, i] -= w0\n                self.Wijke[j, i, j] -= w1\n\n        if energy_ternary_terms is not None:\n            for i, j, k, v in energy_ternary_terms:\n                self.Wijke[i, j, k] += v\n\n        if entropy_interaction is not None:\n            for i in range(self.n_endmembers):\n                for j in range(i + 1, self.n_endmembers):\n                    w0 = entropy_interaction[i][j - i - 1][0] / 2.0\n                    w1 = entropy_interaction[i][j - i - 1][1] / 2.0\n                    self.Wijks[:, i, j] += w0\n                    self.Wijks[:, j, i] += w1\n\n                    self.Wijks[i, j, j] += w0\n                    self.Wijks[j, i, i] += w1\n\n                    self.Wijks[i, j, i] -= w0\n                    self.Wijks[j, i, j] -= w1\n\n        if entropy_ternary_terms is not None:\n            for i, j, k, v in entropy_ternary_terms:\n                self.Wijks[i, j, k] += v\n\n        if volume_interaction is not None:\n            for i in range(self.n_endmembers):\n                for j in range(i + 1, self.n_endmembers):\n                    w0 = volume_interaction[i][j - i - 1][0] / 2.0\n                    w1 = volume_interaction[i][j - i - 1][1] / 2.0\n                    self.Wijkv[:, i, j] += w0\n                    self.Wijkv[:, j, i] += w1\n\n                    self.Wijkv[i, j, j] += w0\n                    self.Wijkv[j, i, i] += w1\n\n                    self.Wijkv[i, j, i] -= w0\n                    self.Wijkv[j, i, j] -= w1\n\n        if volume_ternary_terms is not None:\n            for i, j, k, v in volume_ternary_terms:\n                self.Wijkv[i, j, k] += v\n\n        # initialize ideal solution model\n        IdealSolution.__init__(self, endmembers)\n\n    def _non_ideal_function(self, Wijk, molar_fractions):\n        n = len(molar_fractions)\n        return _non_ideal_interactions_subreg(molar_fractions, n, Wijk)\n\n    def _non_ideal_interactions(self, molar_fractions):\n        # equation (6') of Helffrich and Wood, 1989\n        Eint = self._non_ideal_function(self.Wijke, molar_fractions)\n        Sint = self._non_ideal_function(self.Wijks, molar_fractions)\n        Vint = self._non_ideal_function(self.Wijkv, molar_fractions)\n        return Eint, Sint, Vint\n\n    def _non_ideal_excess_partial_gibbs(self, pressure, temperature, molar_fractions):\n        Eint, Sint, Vint = self._non_ideal_interactions(molar_fractions)\n        return Eint - temperature * Sint + pressure * Vint\n\n    def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(\n            self, temperature, molar_fractions\n        )\n        non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_gibbs + non_ideal_gibbs\n\n    def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        ideal_entropies = IdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_function(self.Wijks, molar_fractions)\n        return ideal_entropies + non_ideal_entropies\n\n    def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        non_ideal_volumes = self._non_ideal_function(self.Wijkv, molar_fractions)\n        return non_ideal_volumes\n\n    def gibbs_hessian(self, pressure, temperature, molar_fractions):\n        n = len(molar_fractions)\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_gibbs_hessian = _non_ideal_hessian_subreg(\n            molar_fractions,\n            n,\n            self.Wijke - temperature * self.Wijks + pressure * self.Wijkv,\n        )\n\n        return nonideal_gibbs_hessian - temperature * ideal_entropy_hessian\n\n    def entropy_hessian(self, pressure, temperature, molar_fractions):\n        n = len(molar_fractions)\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_entropy_hessian = _non_ideal_hessian_subreg(\n            molar_fractions, n, self.Wijks\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian\n\n    def volume_hessian(self, pressure, temperature, molar_fractions):\n        n = len(molar_fractions)\n        return _non_ideal_hessian_subreg(molar_fractions, n, self.Wijkv)\n\n    def activity_coefficients(self, pressure, temperature, molar_fractions):\n        if temperature > 1.0e-10:\n            return np.exp(\n                self._non_ideal_excess_partial_gibbs(\n                    pressure, temperature, molar_fractions\n                )\n                / (constants.gas_constant * temperature)\n            )\n        else:\n            raise Exception(\"Activity coefficients not defined at 0 K.\")\n\n    def activities(self, pressure, temperature, molar_fractions):\n        return IdealSolution.activities(\n            self, pressure, temperature, molar_fractions\n        ) * self.activity_coefficients(pressure, temperature, molar_fractions)",
  "class FunctionSolution(IdealSolution):\n    \"\"\"\n    Solution model implementing a generalized solution model.\n    The extensive excess nonconfigurational Gibbs energy is\n    provided as a function by the user.\n\n    Derivatives are calculated using the autograd module,\n    and so the user-defined excess Gibbs energy function\n    should be defined using autograd-friendly expressions.\n\n    :param endmembers: A list of all the independent endmembers in the solution.\n        The first item of each list gives the Mineral object corresponding\n        to the endmember. The second item gives the site-species formula.\n    :type endmembers: list of lists\n\n    :param excess_gibbs_function: The nonconfigurational Gibbs energy function\n        with arguments pressure, temperature and molar_amounts, in that order.\n        Note that the function must be extensive; if the molar amounts\n        are doubled, the Gibbs energy must also double.\n    :type excess_gibbs_function: function\n    \"\"\"\n\n    def __init__(self, endmembers, excess_gibbs_function):\n        \"\"\"\n        Initialization function for the GeneralSolution class.\n        \"\"\"\n\n        # initialize ideal solution model\n        IdealSolution.__init__(self, endmembers)\n\n        self.n_endmembers = len(endmembers)\n        self._excess_gibbs_function = excess_gibbs_function\n\n        self._non_ideal_excess_partial_gibbs = ag.jacobian(\n            excess_gibbs_function, argnum=2\n        )\n\n        def partial_entropies(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return -ag.jacobian(self._non_ideal_excess_partial_gibbs, argnum=1)(\n                    pressure, temperature, molar_amounts\n                )\n\n        self._non_ideal_excess_partial_entropies = partial_entropies\n\n        def partial_volumes(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(self._non_ideal_excess_partial_gibbs, argnum=0)(\n                    pressure, temperature, molar_amounts\n                )\n\n        self.excess_partial_volumes = partial_volumes\n\n        self._non_ideal_gibbs_hessian = ag.jacobian(\n            self._non_ideal_excess_partial_gibbs, argnum=2\n        )\n\n        def entropy_hess(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_entropies, argnum=2)(\n                    pressure, temperature, molar_amounts\n                )\n\n        self._non_ideal_entropy_hessian = entropy_hess\n\n        def volume_hess(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_volumes, argnum=2)(\n                    pressure, temperature, molar_amounts\n                )\n\n        self.volume_hessian = volume_hess\n\n    def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(\n            self, temperature, molar_fractions\n        )\n        non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_gibbs + non_ideal_gibbs\n\n    def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        ideal_entropies = IdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_excess_partial_entropies(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_entropies + non_ideal_entropies\n\n    def gibbs_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_gibbs_hessian = self._non_ideal_gibbs_hessian(\n            pressure, temperature, molar_fractions\n        )\n\n        return nonideal_gibbs_hessian - temperature * ideal_entropy_hessian\n\n    def entropy_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_entropy_hessian = self._non_ideal_entropy_hessian(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian\n\n    def activity_coefficients(self, pressure, temperature, molar_fractions):\n        if temperature > 1.0e-10:\n            return np.exp(\n                self._non_ideal_excess_partial_gibbs(\n                    pressure, temperature, molar_fractions\n                )\n                / (constants.gas_constant * temperature)\n            )\n        else:\n            raise Exception(\"Activity coefficients not defined at 0 K.\")\n\n    def activities(self, pressure, temperature, molar_fractions):\n        return IdealSolution.activities(\n            self, pressure, temperature, molar_fractions\n        ) * self.activity_coefficients(pressure, temperature, molar_fractions)",
  "class PolynomialSolution(IdealSolution):\n    \"\"\"\n    Solution model implementing a general polynomial solution model.\n\n    :param endmembers: A list of all the independent endmembers in the solution.\n        The first item of each list gives the Mineral object corresponding\n        to the endmember. The second item gives the site-species formula.\n    :type endmembers: list of lists\n    :param ESV_interactions: A list containing lists where the first three elements are\n        energy, entropy and volume interactions and the rest of the elements\n        are indices of the transformed endmembers to which those\n        interactions correspond.\n        For example, [2., 0., 0., 0, 1, 1] would correspond to an interaction\n        of 2*p'[0]*p'[1]*p'[1].\n    :type ESV_interactions: list of lists\n    :param interaction_endmembers: A list of minerals involved in the interaction terms.\n    :type interaction_endmembers: list of :class:`burnman.Mineral` objects\n    :param endmember_coefficients_and_interactions: list of lists\n        A list containing lists where the first n elements are\n        coefficients for each of the interaction_endmembers and the\n        rest of the elements are indices of the transformed\n        endmembers to which those interactions correspond.\n        For example, [1., 0., -1., 0, 1, 1] would correspond to an interaction\n        of (mbr[0].gibbs - mbr[2].gibbs)*p'[0]*p'[1]*p'[1].\n    :type endmember_coefficients_and_interactions: list of lists\n    :param transformation_matrix: The interactions for a given solution may\n        be most compactly expressed not as a polynomial function of the\n        proportions of the endmembers, but a polynomial function of a\n        linearly transformed set. This parameter is a square numpy array A,\n        where p'i = A_ij p_j\n    :type transformation_matrix: 2D numpy array\n    \"\"\"\n\n    def __init__(\n        self,\n        endmembers,\n        ESV_interactions=None,\n        interaction_endmembers=[],\n        endmember_coefficients_and_interactions=None,\n        transformation_matrix=None,\n    ):\n        # initialize ideal solution model\n        IdealSolution.__init__(self, endmembers)\n\n        self.n_endmembers = len(endmembers)\n        self.endmembers = endmembers\n\n        self.W_ESV = None\n        if ESV_interactions is not None:\n            self.W_ESV = self.make_interaction_arrays(ESV_interactions)\n\n        self.n_interaction_endmembers = len(interaction_endmembers)\n        self.interaction_endmembers = interaction_endmembers\n\n        self.W_mbr = None\n        if self.n_interaction_endmembers > 0:\n            self.W_mbr = self.make_endmember_interaction_arrays(\n                endmember_coefficients_and_interactions\n            )\n\n        self.transformation_matrix = transformation_matrix\n        self.reset()\n\n    def reset(self):\n        \"\"\"\n        Resets all cached material properties.\n        It is typically not required for the user to call this function.\n        \"\"\"\n        self._cached = {}\n\n    def set_composition(self, molar_fractions):\n        \"\"\"\n        Resets all cached material properties.\n        It is typically not required for the user to call this function.\n        \"\"\"\n        self.reset()\n        self.molar_fractions = molar_fractions\n\n    def set_state(self, pressure, temperature):\n        \"\"\"\n        Sets the states for the interaction endmembers.\n        It is typically not required for the user to call this function.\n        \"\"\"\n        for mbr in self.interaction_endmembers:\n            mbr.set_state(pressure, temperature)\n\n    def make_interaction_arrays(self, Ws):\n        n_Ws = len(Ws)\n        for i, W in enumerate(Ws):\n            if not all(W[i] <= W[i + 1] for i in range(3, len(W) - 1)):\n                raise Exception(\n                    f\"Interaction parameter {i+1}/{n_Ws} must be \"\n                    \"upper triangular (i<=j<=k<=...<=z)\"\n                )\n            if not W[3] < W[-1]:\n                raise Exception(\n                    f\"Interaction parameter {i+1}/{n_Ws} must not lie on the \"\n                    \"first diagonal (i=j=k=...=z)\"\n                )\n\n        W_arrays = []\n\n        dims = sorted(list(set([len(W) - 3 for W in Ws])))\n        for dim in dims:\n            coords = [\n                [0, *W[3:]] for W in Ws if len(W) == dim + 3 and np.abs(W[0]) > 1.0e-10\n            ]\n            coords.extend(\n                [\n                    [1, *W[3:]]\n                    for W in Ws\n                    if len(W) == dim + 3 and np.abs(W[1]) > 1.0e-10\n                ]\n            )\n            coords.extend(\n                [\n                    [2, *W[3:]]\n                    for W in Ws\n                    if len(W) == dim + 3 and np.abs(W[2]) > 1.0e-10\n                ]\n            )\n            coords = list(zip(*coords))\n\n            data = [W[0] for W in Ws if len(W) == dim + 3 and np.abs(W[0]) > 1.0e-10]\n            data.extend(\n                [W[1] for W in Ws if len(W) == dim + 3 and np.abs(W[1]) > 1.0e-10]\n            )\n            data.extend(\n                [W[2] for W in Ws if len(W) == dim + 3 and np.abs(W[2]) > 1.0e-10]\n            )\n\n            shape = [3]  # First dimension is for E, S, V\n            shape.extend([self.n_endmembers for i in range(dim)])\n\n            shape = tuple(shape)\n            s = sparse.COO(coords, data, shape=shape).todense()\n            W_arrays.append((dim, s))\n        return W_arrays\n\n    def make_endmember_interaction_arrays(self, Ws):\n        n_Ws = len(Ws)\n        n_int = self.n_interaction_endmembers\n        for i, W in enumerate(Ws):\n            if not all(W[i] <= W[i + 1] for i in range(n_int, len(W) - 1)):\n                raise Exception(\n                    f\"Interaction parameter {i+1}/{n_Ws} must be \"\n                    \"upper triangular (i<=j<=k<=...<=z)\"\n                )\n            if not W[n_int] < W[-1]:\n                raise Exception(\n                    f\"Interaction parameter {i+1}/{n_Ws} must not lie on the \"\n                    \"first diagonal (i=j=k=...=z)\"\n                )\n\n        W_arrays = []\n\n        dims = sorted(list(set([len(W) - n_int for W in Ws])))\n        for dim in dims:\n            coords = []\n            data = []\n            for i in range(n_int):\n                coords.extend(\n                    [\n                        [i, *W[n_int:]]\n                        for W in Ws\n                        if len(W) == dim + n_int and np.abs(W[i]) > 1.0e-10\n                    ]\n                )\n                data.extend(\n                    [\n                        W[i]\n                        for W in Ws\n                        if len(W) == dim + n_int and np.abs(W[i]) > 1.0e-10\n                    ]\n                )\n\n            coords = list(zip(*coords))\n\n            shape = [n_int]  # First dimension is for the excess_endmembers\n            shape.extend([self.n_endmembers for i in range(dim)])\n\n            shape = tuple(shape)\n            s = sparse.COO(coords, data, shape=shape).todense()\n            W_arrays.append((dim, s))\n        return W_arrays\n\n    def transform_scalar_list(self, x, A):\n        if A is not None:\n            return A.dot(x)\n        else:\n            return x\n\n    def transform_gradient_list(self, W, A):\n        if A is not None:\n            return np.einsum(\"ij, jk->ik\", W, A)\n        else:\n            return W\n\n    def transform_hessian_list(self, W, A):\n        if A is not None:\n            return np.einsum(\"ki, mij, lj->mkl\", A, W, A)\n        else:\n            return W\n\n    def W_dots_x(self, dim, W_array, x):\n        if dim == 0:\n            return W_array\n        else:\n            ESVdim = [W_array]\n            ESVdim.extend([x for i in range(dim)])\n            strng = string.ascii_lowercase[: W_array.ndim]\n            strng2 = \", \".join(strng[-dim:])\n            strng += f\", {strng2}\"\n            return np.einsum(strng, *ESVdim)\n\n    def rolled_array(self, W, istart):\n        W_array_rolled = deepcopy(W)\n        dim = len(W.shape) - 1\n\n        W_roll = deepcopy(W)\n        for i in range(dim - istart):\n            W_roll = np.moveaxis(W_roll, istart, -1)\n            W_array_rolled += W_roll\n        return W_array_rolled\n\n    def get_scalar_list(self, x, W_arrays, A):\n        xp = self.transform_scalar_list(x, A)\n        xp_total = np.sum(xp)\n        ESV = np.zeros(W_arrays[0][-1].shape[0])\n        for dim, W_array in W_arrays:\n            ESV += self.W_dots_x(dim, W_array, xp) / np.power(xp_total, dim - 1.0)\n        return ESV\n\n    def get_gradient_list(self, x, W_arrays, A):\n        xp = self.transform_scalar_list(x, A)\n        xp_total = np.sum(xp)\n\n        dESVdx = np.zeros(W_arrays[0][-1].shape[:2])\n\n        for dim, W_array in W_arrays:\n            dESVdx += (\n                -(dim - 1)\n                / np.power(xp_total, dim)\n                * self.W_dots_x(dim, W_array, xp)[:, np.newaxis]\n            )\n\n            W_array_rolled = self.rolled_array(W_array, 1)\n            dESVdx += self.W_dots_x(dim - 1, W_array_rolled, xp) / np.power(\n                xp_total, dim - 1.0\n            )\n        return self.transform_gradient_list(dESVdx, A)\n\n    def get_hessian_list(self, x, W_arrays, A):\n        xp = self.transform_scalar_list(x, A)\n        xp_total = np.sum(xp)\n\n        d2ESVdx2 = np.zeros(W_arrays[0][-1].shape[:3])\n\n        for dim, W_array in W_arrays:\n            d2ESVdx2 += (\n                (dim - 1)\n                * dim\n                / np.power(xp_total, dim + 1)\n                * self.W_dots_x(dim, W_array, xp)[:, np.newaxis, np.newaxis]\n            )\n\n            W_array_rolled = self.rolled_array(W_array, 1)\n\n            f = self.W_dots_x(dim - 1, W_array_rolled, xp)\n            h = f[:, np.newaxis, :] + f[:, :, np.newaxis]\n\n            d2ESVdx2 += -(dim - 1) / np.power(xp_total, dim) * h\n\n            W_array_rolled_2 = self.rolled_array(W_array_rolled, 2)\n            g = self.W_dots_x(dim - 2, W_array_rolled_2, xp)\n\n            d2ESVdx2 += g / np.power(xp_total, dim - 1.0)\n\n        return self.transform_hessian_list(d2ESVdx2, A)\n\n    @material_property\n    def ESV_scalar_list(self):\n        if self.W_ESV is None:\n            return np.zeros((3))\n        else:\n            return self.get_scalar_list(\n                self.molar_fractions, self.W_ESV, self.transformation_matrix\n            )\n\n    @material_property\n    def ESV_gradient_list(self):\n        if self.W_ESV is None:\n            return np.zeros((3, self.n_endmembers))\n        else:\n            return self.get_gradient_list(\n                self.molar_fractions, self.W_ESV, self.transformation_matrix\n            )\n\n    @material_property\n    def ESV_hessian_list(self):\n        if self.W_ESV is None:\n            return np.zeros((3, self.n_endmembers, self.n_endmembers))\n        else:\n            return self.get_hessian_list(\n                self.molar_fractions, self.W_ESV, self.transformation_matrix\n            )\n\n    @material_property\n    def mbr_scalar_list(self):\n        if self.W_mbr is None:\n            return np.zeros((0))\n        else:\n            return self.get_scalar_list(\n                self.molar_fractions, self.W_mbr, self.transformation_matrix\n            )\n\n    @material_property\n    def mbr_gradient_list(self):\n        if self.W_mbr is None:\n            return np.zeros((0, self.n_endmembers))\n        else:\n            return self.get_gradient_list(\n                self.molar_fractions, self.W_mbr, self.transformation_matrix\n            )\n\n    @material_property\n    def mbr_hessian_list(self):\n        if self.W_mbr is None:\n            return np.zeros((0, self.n_endmembers, self.n_endmembers))\n        else:\n            return self.get_hessian_list(\n                self.molar_fractions, self.W_mbr, self.transformation_matrix\n            )\n\n    def _non_ideal_excess_partial_gibbs(self, pressure, temperature, molar_fractions):\n        dEdx, dSdx, dVdx = self.ESV_gradient_list\n        mbr_gradients = self.mbr_gradient_list\n        mbr_gibbs = np.array([mbr.gibbs for mbr in self.interaction_endmembers])\n        gibbs = dEdx - temperature * dSdx + pressure * dVdx\n        gibbs += np.einsum(\"i, ij->j\", mbr_gibbs, mbr_gradients)\n        return gibbs\n\n    def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(\n            self, temperature, molar_fractions\n        )\n        non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_gibbs + non_ideal_gibbs\n\n    def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        ideal_entropies = IdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n\n        dSdx = self.ESV_gradient_list[1]\n        mbr_gradients = self.mbr_gradient_list\n        mbr_entropies = np.array([mbr.S for mbr in self.interaction_endmembers])\n\n        non_ideal_entropies = dSdx + np.einsum(\"i, ij->j\", mbr_entropies, mbr_gradients)\n        return ideal_entropies + non_ideal_entropies\n\n    def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        dVdx = self.ESV_gradient_list[2]\n        mbr_gradients = self.mbr_gradient_list\n        mbr_volumes = np.array([mbr.V for mbr in self.interaction_endmembers])\n\n        return dVdx + np.einsum(\"i, ij->j\", mbr_volumes, mbr_gradients)\n\n    def gibbs_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n\n        d2Edx2, d2Sdx2, d2Vdx2 = self.ESV_hessian_list\n        mbr_hessian = self.mbr_hessian_list\n        mbr_gibbs = np.array([mbr.gibbs for mbr in self.interaction_endmembers])\n\n        d2Gdx2 = d2Edx2 - temperature * d2Sdx2 + pressure * d2Vdx2\n        d2Gdx2 += np.einsum(\"i, ijk->jk\", mbr_gibbs, mbr_hessian)\n\n        return d2Gdx2 - temperature * ideal_entropy_hessian\n\n    def entropy_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n\n        d2Sdx2 = self.ESV_hessian_list[1]\n        mbr_hessian = self.mbr_hessian_list\n        mbr_entropies = np.array([mbr.S for mbr in self.interaction_endmembers])\n\n        d2Sdx2 += np.einsum(\"i, ijk->jk\", mbr_entropies, mbr_hessian)\n\n        return d2Sdx2 + ideal_entropy_hessian\n\n    def volume_hessian(self, pressure, temperature, molar_fractions):\n        d2Vdx2 = self.ESV_hessian_list[2]\n        mbr_hessian = self.mbr_hessian_list\n        mbr_volumes = np.array([mbr.V for mbr in self.interaction_endmembers])\n\n        d2Vdx2 += np.einsum(\"i, ijk->jk\", mbr_volumes, mbr_hessian)\n\n        return d2Vdx2\n\n    def Cp_excess(self):\n        mbr_scalar = self.mbr_scalar_list\n        mbr_Cp = np.array(\n            [mbr.molar_heat_capacity_p for mbr in self.interaction_endmembers]\n        )\n        return np.einsum(\"i, i\", mbr_scalar, mbr_Cp)\n\n    def alphaV_excess(self):\n        mbr_scalar = self.mbr_scalar_list\n        mbr_d2gibbsdpdt = np.array(\n            [mbr.alpha * mbr.V for mbr in self.interaction_endmembers]\n        )\n        return np.einsum(\"i, i\", mbr_scalar, mbr_d2gibbsdpdt)\n\n    def VoverKT_excess(self):\n        mbr_scalar = self.mbr_scalar_list\n        mbr_d2gibbsdpdp = np.array(\n            [mbr.V / mbr.K_T for mbr in self.interaction_endmembers]\n        )\n        return np.einsum(\"i, i\", mbr_scalar, mbr_d2gibbsdpdp)\n\n    def activity_coefficients(self, pressure, temperature, molar_fractions):\n        if temperature > 1.0e-10:\n            return np.exp(\n                self._non_ideal_excess_partial_gibbs(\n                    pressure, temperature, molar_fractions\n                )\n                / (constants.gas_constant * temperature)\n            )\n        else:\n            raise Exception(\"Activity coefficients not defined at 0 K.\")\n\n    def activities(self, pressure, temperature, molar_fractions):\n        return IdealSolution.activities(\n            self, pressure, temperature, molar_fractions\n        ) * self.activity_coefficients(pressure, temperature, molar_fractions)",
  "def __init__(self):\n        \"\"\"\n        Does nothing.\n        \"\"\"\n        pass",
  "def excess_gibbs_free_energy(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess Gibbs free energy of the solution.\n        The base class implementation assumes that the excess gibbs\n        free energy is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess Gibbs energy.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            np.array(molar_fractions),\n            self.excess_partial_gibbs_free_energies(\n                pressure, temperature, molar_fractions\n            ),\n        )",
  "def excess_volume(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess volume of the solution.\n        The base class implementation assumes that the excess volume is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess volume of the solution.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            molar_fractions,\n            self.excess_partial_volumes(pressure, temperature, molar_fractions),\n        )",
  "def excess_entropy(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess entropy of the solution.\n        The base class implementation assumes that the excess entropy is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess entropy of the solution.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            molar_fractions,\n            self.excess_partial_entropies(pressure, temperature, molar_fractions),\n        )",
  "def excess_enthalpy(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess enthalpy of the solution.\n        The base class implementation assumes that the excess enthalpy is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess enthalpy of the solution.\n        :rtype: float\n        \"\"\"\n        return self.excess_gibbs_free_energy(\n            pressure, temperature, molar_fractions\n        ) + temperature * self.excess_entropy(pressure, temperature, molar_fractions)",
  "def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess Gibbs free energy for each endmember\n        of the solution.\n        The base class implementation assumes that the excess gibbs\n        free energy is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess partial Gibbs free energy of each endmember.\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(molar_fractions)",
  "def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess entropy for each endmember of the solution.\n        The base class implementation assumes that the excess entropy\n        is zero (true for mechanical solutions).\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess partial entropy of each endmember.\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(molar_fractions)",
  "def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess volume for each endmember of the solution.\n        The base class implementation assumes that the excess volume\n        is zero.\n\n        :param pressure: Pressure at which to evaluate the solution model [Pa].\n        :type pressure: float\n        :param temperature: Temperature at which to evaluate the solution model [K].\n        :type temperature: float\n        :param molar_fractions: List of molar fractions of the\n            different independent endmembers in the solution model.\n        :type molar_fractions: list of floats\n\n        :returns: The excess partial volume of each endmember.\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(np.array(molar_fractions))",
  "def Cp_excess(self):\n        \"\"\"\n        Returns the excess heat capacity of the solution model\n        at its current state\n        \"\"\"\n        return 0.0",
  "def alphaV_excess(self):\n        \"\"\"\n        Returns the excess alpha*V of the solution model\n        at its current state\n        \"\"\"\n        return 0.0",
  "def VoverKT_excess(self):\n        \"\"\"\n        Returns the excess V/K_T of the solution model\n        at its current state\n        \"\"\"\n        return 0.0",
  "def __init__(self, endmembers):\n        self.endmembers = endmembers\n        self.n_endmembers = len(endmembers)\n        self.formulas = [e[1] for e in endmembers]",
  "def excess_gibbs_free_energy(self, pressure, temperature, molar_fractions):\n        return 0.0",
  "def excess_volume(self, pressure, temperature, molar_fractions):\n        return 0.0",
  "def excess_entropy(self, pressure, temperature, molar_fractions):\n        return 0.0",
  "def excess_enthalpy(self, pressure, temperature, molar_fractions):\n        return 0.0",
  "def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        return np.zeros_like(molar_fractions)",
  "def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        return np.zeros_like(molar_fractions)",
  "def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        return np.zeros_like(molar_fractions)",
  "def activity_coefficients(self, pressure, temperature, molar_fractions):\n        return np.ones_like(molar_fractions)",
  "def activities(self, pressure, temperature, molar_fractions):\n        return np.ones_like(molar_fractions)",
  "def __init__(self, endmembers):\n        self.endmembers = endmembers\n        self.n_endmembers = len(endmembers)\n        self.formulas = [e[1] for e in endmembers]\n\n        # Process solution chemistry\n        process_solution_chemistry(self)\n\n        self._calculate_endmember_configurational_entropies()",
  "def _calculate_endmember_configurational_entropies(self):\n        S_conf = -(\n            constants.gas_constant\n            * (self.endmember_noccupancies * logish(self.endmember_occupancies)).sum(-1)\n        )\n        self.endmember_configurational_entropies = S_conf",
  "def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        return self._ideal_excess_partial_gibbs(temperature, molar_fractions)",
  "def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        return self._ideal_excess_partial_entropies(temperature, molar_fractions)",
  "def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        return np.zeros((self.n_endmembers))",
  "def gibbs_hessian(self, pressure, temperature, molar_fractions):\n        hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)\n        return -temperature * hess_S",
  "def entropy_hessian(self, pressure, temperature, molar_fractions):\n        hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)\n        return hess_S",
  "def volume_hessian(self, pressure, temperature, molar_fractions):\n        return np.zeros((len(molar_fractions), len(molar_fractions)))",
  "def _configurational_entropy(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n        site_occupancies = site_noccupancies * inverseish(site_multiplicities)\n        conf_entropy = -(\n            constants.gas_constant\n            * (site_noccupancies * logish(site_occupancies)).sum(-1)\n        )\n        return conf_entropy",
  "def _ideal_excess_partial_gibbs(self, temperature, molar_fractions):\n        return -(\n            temperature\n            * self._ideal_excess_partial_entropies(temperature, molar_fractions)\n        )",
  "def _ideal_excess_partial_entropies(self, temperature, molar_fractions):\n        return -(constants.gas_constant * self._log_ideal_activities(molar_fractions))",
  "def _ideal_entropy_hessian(self, temperature, molar_fractions):\n        hessian = -(\n            constants.gas_constant\n            * self._log_ideal_activity_derivatives(molar_fractions)\n        )\n        return hessian",
  "def _log_ideal_activities(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n\n        lna = np.einsum(\n            \"ij, j->i\",\n            self.endmember_noccupancies,\n            logish(site_noccupancies) - logish(site_multiplicities),\n        )\n        normalisation_constants = (\n            self.endmember_configurational_entropies / constants.gas_constant\n        )\n        return lna + normalisation_constants",
  "def _log_ideal_activity_derivatives(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n\n        dlnadp = np.einsum(\n            \"pj, qj, j->pq\",\n            self.endmember_noccupancies,\n            self.endmember_noccupancies,\n            inverseish(site_noccupancies),\n        ) - np.einsum(\n            \"pj, qj, j->pq\",\n            self.endmember_noccupancies,\n            self.site_multiplicities,\n            inverseish(site_multiplicities),\n        )\n\n        return dlnadp",
  "def _ideal_activities(self, molar_fractions):\n        return _ideal_activities_fct(\n            molar_fractions,\n            self.endmember_noccupancies,\n            self.n_endmembers,\n            self.n_occupancies,\n            self.site_multiplicities,\n            self.endmember_configurational_entropies,\n        )",
  "def activity_coefficients(self, pressure, temperature, molar_fractions):\n        return np.ones_like(molar_fractions)",
  "def activities(self, pressure, temperature, molar_fractions):\n        return self._ideal_activities(molar_fractions)",
  "def __init__(\n        self,\n        endmembers,\n        alphas,\n        energy_interaction,\n        volume_interaction=None,\n        entropy_interaction=None,\n    ):\n        self.n_endmembers = len(endmembers)\n\n        # Create array of van Laar parameters\n        self.alphas = np.array(alphas)\n\n        # Create 2D arrays of interaction parameters\n        self.We = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n        self.We[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n            [i for row in energy_interaction for i in row]\n        )\n\n        if entropy_interaction is not None:\n            self.Ws = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n            self.Ws[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n                [i for row in entropy_interaction for i in row]\n            )\n        else:\n            self.Ws = np.zeros((self.n_endmembers, self.n_endmembers))\n\n        if volume_interaction is not None:\n            self.Wv = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n            self.Wv[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n                [i for row in volume_interaction for i in row]\n            )\n        else:\n            self.Wv = np.zeros((self.n_endmembers, self.n_endmembers))\n\n        # initialize ideal solution model\n        IdealSolution.__init__(self, endmembers)",
  "def _phi(self, molar_fractions):\n        phi = self.alphas * molar_fractions\n        phi = np.divide(phi, np.sum(phi))\n        return phi",
  "def _non_ideal_interactions(self, W, molar_fractions):\n        # -sum(sum(qi.qj.Wij*)\n        # equation (2) of Holland and Powell 2003\n        phi = self._phi(molar_fractions)\n        return _non_ideal_interactions_fct(\n            phi, np.array(molar_fractions), self.n_endmembers, self.alphas, W\n        )",
  "def _non_ideal_excess_partial_gibbs(self, pressure, temperature, molar_fractions):\n        Eint = self._non_ideal_interactions(self.We, molar_fractions)\n        Sint = self._non_ideal_interactions(self.Ws, molar_fractions)\n        Vint = self._non_ideal_interactions(self.Wv, molar_fractions)\n        return Eint - temperature * Sint + pressure * Vint",
  "def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(\n            self, temperature, molar_fractions\n        )\n        non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_gibbs + non_ideal_gibbs",
  "def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        ideal_entropies = IdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_interactions(self.Ws, molar_fractions)\n        return ideal_entropies + non_ideal_entropies",
  "def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        return self._non_ideal_interactions(self.Wv, molar_fractions)",
  "def gibbs_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        phi = self._phi(molar_fractions)\n        nonideal_gibbs_hessian = _non_ideal_hessian_fct(\n            phi,\n            molar_fractions,\n            self.n_endmembers,\n            self.alphas,\n            self.We - temperature * self.Ws + pressure * self.Wv,\n        )\n\n        return nonideal_gibbs_hessian - temperature * ideal_entropy_hessian",
  "def entropy_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        phi = self._phi(molar_fractions)\n        nonideal_entropy_hessian = _non_ideal_hessian_fct(\n            phi, molar_fractions, self.n_endmembers, self.alphas, self.Ws\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian",
  "def volume_hessian(self, pressure, temperature, molar_fractions):\n        phi = self._phi(molar_fractions)\n        return _non_ideal_hessian_fct(\n            phi, molar_fractions, self.n_endmembers, self.alphas, self.Wv\n        )",
  "def activity_coefficients(self, pressure, temperature, molar_fractions):\n        if temperature > 1.0e-10:\n            return np.exp(\n                self._non_ideal_excess_partial_gibbs(\n                    pressure, temperature, molar_fractions\n                )\n                / (constants.gas_constant * temperature)\n            )\n        else:\n            raise Exception(\"Activity coefficients not defined at 0 K.\")",
  "def activities(self, pressure, temperature, molar_fractions):\n        return IdealSolution.activities(\n            self, pressure, temperature, molar_fractions\n        ) * self.activity_coefficients(pressure, temperature, molar_fractions)",
  "def __init__(\n        self,\n        endmembers,\n        energy_interaction,\n        volume_interaction=None,\n        entropy_interaction=None,\n    ):\n        alphas = np.ones(len(endmembers))\n        AsymmetricRegularSolution.__init__(\n            self,\n            endmembers,\n            alphas,\n            energy_interaction,\n            volume_interaction,\n            entropy_interaction,\n        )",
  "def __init__(\n        self,\n        endmembers,\n        energy_interaction,\n        volume_interaction=None,\n        entropy_interaction=None,\n        energy_ternary_terms=None,\n        volume_ternary_terms=None,\n        entropy_ternary_terms=None,\n    ):\n        \"\"\"\n        Initialization function for the SubregularSolution class.\n        \"\"\"\n\n        self.n_endmembers = len(endmembers)\n\n        # Create 3D arrays of interaction parameters\n        self.Wijke = np.zeros(\n            shape=(self.n_endmembers, self.n_endmembers, self.n_endmembers)\n        )\n        self.Wijks = np.zeros_like(self.Wijke)\n        self.Wijkv = np.zeros_like(self.Wijke)\n\n        # setup excess enthalpy interaction matrix\n        for i in range(self.n_endmembers):\n            for j in range(i + 1, self.n_endmembers):\n                w0 = energy_interaction[i][j - i - 1][0] / 2.0\n                w1 = energy_interaction[i][j - i - 1][1] / 2.0\n                self.Wijke[:, i, j] += w0\n                self.Wijke[:, j, i] += w1\n\n                self.Wijke[i, j, j] += w0\n                self.Wijke[j, i, i] += w1\n\n                self.Wijke[i, j, i] -= w0\n                self.Wijke[j, i, j] -= w1\n\n        if energy_ternary_terms is not None:\n            for i, j, k, v in energy_ternary_terms:\n                self.Wijke[i, j, k] += v\n\n        if entropy_interaction is not None:\n            for i in range(self.n_endmembers):\n                for j in range(i + 1, self.n_endmembers):\n                    w0 = entropy_interaction[i][j - i - 1][0] / 2.0\n                    w1 = entropy_interaction[i][j - i - 1][1] / 2.0\n                    self.Wijks[:, i, j] += w0\n                    self.Wijks[:, j, i] += w1\n\n                    self.Wijks[i, j, j] += w0\n                    self.Wijks[j, i, i] += w1\n\n                    self.Wijks[i, j, i] -= w0\n                    self.Wijks[j, i, j] -= w1\n\n        if entropy_ternary_terms is not None:\n            for i, j, k, v in entropy_ternary_terms:\n                self.Wijks[i, j, k] += v\n\n        if volume_interaction is not None:\n            for i in range(self.n_endmembers):\n                for j in range(i + 1, self.n_endmembers):\n                    w0 = volume_interaction[i][j - i - 1][0] / 2.0\n                    w1 = volume_interaction[i][j - i - 1][1] / 2.0\n                    self.Wijkv[:, i, j] += w0\n                    self.Wijkv[:, j, i] += w1\n\n                    self.Wijkv[i, j, j] += w0\n                    self.Wijkv[j, i, i] += w1\n\n                    self.Wijkv[i, j, i] -= w0\n                    self.Wijkv[j, i, j] -= w1\n\n        if volume_ternary_terms is not None:\n            for i, j, k, v in volume_ternary_terms:\n                self.Wijkv[i, j, k] += v\n\n        # initialize ideal solution model\n        IdealSolution.__init__(self, endmembers)",
  "def _non_ideal_function(self, Wijk, molar_fractions):\n        n = len(molar_fractions)\n        return _non_ideal_interactions_subreg(molar_fractions, n, Wijk)",
  "def _non_ideal_interactions(self, molar_fractions):\n        # equation (6') of Helffrich and Wood, 1989\n        Eint = self._non_ideal_function(self.Wijke, molar_fractions)\n        Sint = self._non_ideal_function(self.Wijks, molar_fractions)\n        Vint = self._non_ideal_function(self.Wijkv, molar_fractions)\n        return Eint, Sint, Vint",
  "def _non_ideal_excess_partial_gibbs(self, pressure, temperature, molar_fractions):\n        Eint, Sint, Vint = self._non_ideal_interactions(molar_fractions)\n        return Eint - temperature * Sint + pressure * Vint",
  "def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(\n            self, temperature, molar_fractions\n        )\n        non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_gibbs + non_ideal_gibbs",
  "def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        ideal_entropies = IdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_function(self.Wijks, molar_fractions)\n        return ideal_entropies + non_ideal_entropies",
  "def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        non_ideal_volumes = self._non_ideal_function(self.Wijkv, molar_fractions)\n        return non_ideal_volumes",
  "def gibbs_hessian(self, pressure, temperature, molar_fractions):\n        n = len(molar_fractions)\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_gibbs_hessian = _non_ideal_hessian_subreg(\n            molar_fractions,\n            n,\n            self.Wijke - temperature * self.Wijks + pressure * self.Wijkv,\n        )\n\n        return nonideal_gibbs_hessian - temperature * ideal_entropy_hessian",
  "def entropy_hessian(self, pressure, temperature, molar_fractions):\n        n = len(molar_fractions)\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_entropy_hessian = _non_ideal_hessian_subreg(\n            molar_fractions, n, self.Wijks\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian",
  "def volume_hessian(self, pressure, temperature, molar_fractions):\n        n = len(molar_fractions)\n        return _non_ideal_hessian_subreg(molar_fractions, n, self.Wijkv)",
  "def activity_coefficients(self, pressure, temperature, molar_fractions):\n        if temperature > 1.0e-10:\n            return np.exp(\n                self._non_ideal_excess_partial_gibbs(\n                    pressure, temperature, molar_fractions\n                )\n                / (constants.gas_constant * temperature)\n            )\n        else:\n            raise Exception(\"Activity coefficients not defined at 0 K.\")",
  "def activities(self, pressure, temperature, molar_fractions):\n        return IdealSolution.activities(\n            self, pressure, temperature, molar_fractions\n        ) * self.activity_coefficients(pressure, temperature, molar_fractions)",
  "def __init__(self, endmembers, excess_gibbs_function):\n        \"\"\"\n        Initialization function for the GeneralSolution class.\n        \"\"\"\n\n        # initialize ideal solution model\n        IdealSolution.__init__(self, endmembers)\n\n        self.n_endmembers = len(endmembers)\n        self._excess_gibbs_function = excess_gibbs_function\n\n        self._non_ideal_excess_partial_gibbs = ag.jacobian(\n            excess_gibbs_function, argnum=2\n        )\n\n        def partial_entropies(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return -ag.jacobian(self._non_ideal_excess_partial_gibbs, argnum=1)(\n                    pressure, temperature, molar_amounts\n                )\n\n        self._non_ideal_excess_partial_entropies = partial_entropies\n\n        def partial_volumes(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(self._non_ideal_excess_partial_gibbs, argnum=0)(\n                    pressure, temperature, molar_amounts\n                )\n\n        self.excess_partial_volumes = partial_volumes\n\n        self._non_ideal_gibbs_hessian = ag.jacobian(\n            self._non_ideal_excess_partial_gibbs, argnum=2\n        )\n\n        def entropy_hess(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_entropies, argnum=2)(\n                    pressure, temperature, molar_amounts\n                )\n\n        self._non_ideal_entropy_hessian = entropy_hess\n\n        def volume_hess(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_volumes, argnum=2)(\n                    pressure, temperature, molar_amounts\n                )\n\n        self.volume_hessian = volume_hess",
  "def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(\n            self, temperature, molar_fractions\n        )\n        non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_gibbs + non_ideal_gibbs",
  "def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        ideal_entropies = IdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_excess_partial_entropies(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_entropies + non_ideal_entropies",
  "def gibbs_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_gibbs_hessian = self._non_ideal_gibbs_hessian(\n            pressure, temperature, molar_fractions\n        )\n\n        return nonideal_gibbs_hessian - temperature * ideal_entropy_hessian",
  "def entropy_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_entropy_hessian = self._non_ideal_entropy_hessian(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian",
  "def activity_coefficients(self, pressure, temperature, molar_fractions):\n        if temperature > 1.0e-10:\n            return np.exp(\n                self._non_ideal_excess_partial_gibbs(\n                    pressure, temperature, molar_fractions\n                )\n                / (constants.gas_constant * temperature)\n            )\n        else:\n            raise Exception(\"Activity coefficients not defined at 0 K.\")",
  "def activities(self, pressure, temperature, molar_fractions):\n        return IdealSolution.activities(\n            self, pressure, temperature, molar_fractions\n        ) * self.activity_coefficients(pressure, temperature, molar_fractions)",
  "def __init__(\n        self,\n        endmembers,\n        ESV_interactions=None,\n        interaction_endmembers=[],\n        endmember_coefficients_and_interactions=None,\n        transformation_matrix=None,\n    ):\n        # initialize ideal solution model\n        IdealSolution.__init__(self, endmembers)\n\n        self.n_endmembers = len(endmembers)\n        self.endmembers = endmembers\n\n        self.W_ESV = None\n        if ESV_interactions is not None:\n            self.W_ESV = self.make_interaction_arrays(ESV_interactions)\n\n        self.n_interaction_endmembers = len(interaction_endmembers)\n        self.interaction_endmembers = interaction_endmembers\n\n        self.W_mbr = None\n        if self.n_interaction_endmembers > 0:\n            self.W_mbr = self.make_endmember_interaction_arrays(\n                endmember_coefficients_and_interactions\n            )\n\n        self.transformation_matrix = transformation_matrix\n        self.reset()",
  "def reset(self):\n        \"\"\"\n        Resets all cached material properties.\n        It is typically not required for the user to call this function.\n        \"\"\"\n        self._cached = {}",
  "def set_composition(self, molar_fractions):\n        \"\"\"\n        Resets all cached material properties.\n        It is typically not required for the user to call this function.\n        \"\"\"\n        self.reset()\n        self.molar_fractions = molar_fractions",
  "def set_state(self, pressure, temperature):\n        \"\"\"\n        Sets the states for the interaction endmembers.\n        It is typically not required for the user to call this function.\n        \"\"\"\n        for mbr in self.interaction_endmembers:\n            mbr.set_state(pressure, temperature)",
  "def make_interaction_arrays(self, Ws):\n        n_Ws = len(Ws)\n        for i, W in enumerate(Ws):\n            if not all(W[i] <= W[i + 1] for i in range(3, len(W) - 1)):\n                raise Exception(\n                    f\"Interaction parameter {i+1}/{n_Ws} must be \"\n                    \"upper triangular (i<=j<=k<=...<=z)\"\n                )\n            if not W[3] < W[-1]:\n                raise Exception(\n                    f\"Interaction parameter {i+1}/{n_Ws} must not lie on the \"\n                    \"first diagonal (i=j=k=...=z)\"\n                )\n\n        W_arrays = []\n\n        dims = sorted(list(set([len(W) - 3 for W in Ws])))\n        for dim in dims:\n            coords = [\n                [0, *W[3:]] for W in Ws if len(W) == dim + 3 and np.abs(W[0]) > 1.0e-10\n            ]\n            coords.extend(\n                [\n                    [1, *W[3:]]\n                    for W in Ws\n                    if len(W) == dim + 3 and np.abs(W[1]) > 1.0e-10\n                ]\n            )\n            coords.extend(\n                [\n                    [2, *W[3:]]\n                    for W in Ws\n                    if len(W) == dim + 3 and np.abs(W[2]) > 1.0e-10\n                ]\n            )\n            coords = list(zip(*coords))\n\n            data = [W[0] for W in Ws if len(W) == dim + 3 and np.abs(W[0]) > 1.0e-10]\n            data.extend(\n                [W[1] for W in Ws if len(W) == dim + 3 and np.abs(W[1]) > 1.0e-10]\n            )\n            data.extend(\n                [W[2] for W in Ws if len(W) == dim + 3 and np.abs(W[2]) > 1.0e-10]\n            )\n\n            shape = [3]  # First dimension is for E, S, V\n            shape.extend([self.n_endmembers for i in range(dim)])\n\n            shape = tuple(shape)\n            s = sparse.COO(coords, data, shape=shape).todense()\n            W_arrays.append((dim, s))\n        return W_arrays",
  "def make_endmember_interaction_arrays(self, Ws):\n        n_Ws = len(Ws)\n        n_int = self.n_interaction_endmembers\n        for i, W in enumerate(Ws):\n            if not all(W[i] <= W[i + 1] for i in range(n_int, len(W) - 1)):\n                raise Exception(\n                    f\"Interaction parameter {i+1}/{n_Ws} must be \"\n                    \"upper triangular (i<=j<=k<=...<=z)\"\n                )\n            if not W[n_int] < W[-1]:\n                raise Exception(\n                    f\"Interaction parameter {i+1}/{n_Ws} must not lie on the \"\n                    \"first diagonal (i=j=k=...=z)\"\n                )\n\n        W_arrays = []\n\n        dims = sorted(list(set([len(W) - n_int for W in Ws])))\n        for dim in dims:\n            coords = []\n            data = []\n            for i in range(n_int):\n                coords.extend(\n                    [\n                        [i, *W[n_int:]]\n                        for W in Ws\n                        if len(W) == dim + n_int and np.abs(W[i]) > 1.0e-10\n                    ]\n                )\n                data.extend(\n                    [\n                        W[i]\n                        for W in Ws\n                        if len(W) == dim + n_int and np.abs(W[i]) > 1.0e-10\n                    ]\n                )\n\n            coords = list(zip(*coords))\n\n            shape = [n_int]  # First dimension is for the excess_endmembers\n            shape.extend([self.n_endmembers for i in range(dim)])\n\n            shape = tuple(shape)\n            s = sparse.COO(coords, data, shape=shape).todense()\n            W_arrays.append((dim, s))\n        return W_arrays",
  "def transform_scalar_list(self, x, A):\n        if A is not None:\n            return A.dot(x)\n        else:\n            return x",
  "def transform_gradient_list(self, W, A):\n        if A is not None:\n            return np.einsum(\"ij, jk->ik\", W, A)\n        else:\n            return W",
  "def transform_hessian_list(self, W, A):\n        if A is not None:\n            return np.einsum(\"ki, mij, lj->mkl\", A, W, A)\n        else:\n            return W",
  "def W_dots_x(self, dim, W_array, x):\n        if dim == 0:\n            return W_array\n        else:\n            ESVdim = [W_array]\n            ESVdim.extend([x for i in range(dim)])\n            strng = string.ascii_lowercase[: W_array.ndim]\n            strng2 = \", \".join(strng[-dim:])\n            strng += f\", {strng2}\"\n            return np.einsum(strng, *ESVdim)",
  "def rolled_array(self, W, istart):\n        W_array_rolled = deepcopy(W)\n        dim = len(W.shape) - 1\n\n        W_roll = deepcopy(W)\n        for i in range(dim - istart):\n            W_roll = np.moveaxis(W_roll, istart, -1)\n            W_array_rolled += W_roll\n        return W_array_rolled",
  "def get_scalar_list(self, x, W_arrays, A):\n        xp = self.transform_scalar_list(x, A)\n        xp_total = np.sum(xp)\n        ESV = np.zeros(W_arrays[0][-1].shape[0])\n        for dim, W_array in W_arrays:\n            ESV += self.W_dots_x(dim, W_array, xp) / np.power(xp_total, dim - 1.0)\n        return ESV",
  "def get_gradient_list(self, x, W_arrays, A):\n        xp = self.transform_scalar_list(x, A)\n        xp_total = np.sum(xp)\n\n        dESVdx = np.zeros(W_arrays[0][-1].shape[:2])\n\n        for dim, W_array in W_arrays:\n            dESVdx += (\n                -(dim - 1)\n                / np.power(xp_total, dim)\n                * self.W_dots_x(dim, W_array, xp)[:, np.newaxis]\n            )\n\n            W_array_rolled = self.rolled_array(W_array, 1)\n            dESVdx += self.W_dots_x(dim - 1, W_array_rolled, xp) / np.power(\n                xp_total, dim - 1.0\n            )\n        return self.transform_gradient_list(dESVdx, A)",
  "def get_hessian_list(self, x, W_arrays, A):\n        xp = self.transform_scalar_list(x, A)\n        xp_total = np.sum(xp)\n\n        d2ESVdx2 = np.zeros(W_arrays[0][-1].shape[:3])\n\n        for dim, W_array in W_arrays:\n            d2ESVdx2 += (\n                (dim - 1)\n                * dim\n                / np.power(xp_total, dim + 1)\n                * self.W_dots_x(dim, W_array, xp)[:, np.newaxis, np.newaxis]\n            )\n\n            W_array_rolled = self.rolled_array(W_array, 1)\n\n            f = self.W_dots_x(dim - 1, W_array_rolled, xp)\n            h = f[:, np.newaxis, :] + f[:, :, np.newaxis]\n\n            d2ESVdx2 += -(dim - 1) / np.power(xp_total, dim) * h\n\n            W_array_rolled_2 = self.rolled_array(W_array_rolled, 2)\n            g = self.W_dots_x(dim - 2, W_array_rolled_2, xp)\n\n            d2ESVdx2 += g / np.power(xp_total, dim - 1.0)\n\n        return self.transform_hessian_list(d2ESVdx2, A)",
  "def ESV_scalar_list(self):\n        if self.W_ESV is None:\n            return np.zeros((3))\n        else:\n            return self.get_scalar_list(\n                self.molar_fractions, self.W_ESV, self.transformation_matrix\n            )",
  "def ESV_gradient_list(self):\n        if self.W_ESV is None:\n            return np.zeros((3, self.n_endmembers))\n        else:\n            return self.get_gradient_list(\n                self.molar_fractions, self.W_ESV, self.transformation_matrix\n            )",
  "def ESV_hessian_list(self):\n        if self.W_ESV is None:\n            return np.zeros((3, self.n_endmembers, self.n_endmembers))\n        else:\n            return self.get_hessian_list(\n                self.molar_fractions, self.W_ESV, self.transformation_matrix\n            )",
  "def mbr_scalar_list(self):\n        if self.W_mbr is None:\n            return np.zeros((0))\n        else:\n            return self.get_scalar_list(\n                self.molar_fractions, self.W_mbr, self.transformation_matrix\n            )",
  "def mbr_gradient_list(self):\n        if self.W_mbr is None:\n            return np.zeros((0, self.n_endmembers))\n        else:\n            return self.get_gradient_list(\n                self.molar_fractions, self.W_mbr, self.transformation_matrix\n            )",
  "def mbr_hessian_list(self):\n        if self.W_mbr is None:\n            return np.zeros((0, self.n_endmembers, self.n_endmembers))\n        else:\n            return self.get_hessian_list(\n                self.molar_fractions, self.W_mbr, self.transformation_matrix\n            )",
  "def _non_ideal_excess_partial_gibbs(self, pressure, temperature, molar_fractions):\n        dEdx, dSdx, dVdx = self.ESV_gradient_list\n        mbr_gradients = self.mbr_gradient_list\n        mbr_gibbs = np.array([mbr.gibbs for mbr in self.interaction_endmembers])\n        gibbs = dEdx - temperature * dSdx + pressure * dVdx\n        gibbs += np.einsum(\"i, ij->j\", mbr_gibbs, mbr_gradients)\n        return gibbs",
  "def excess_partial_gibbs_free_energies(\n        self, pressure, temperature, molar_fractions\n    ):\n        ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(\n            self, temperature, molar_fractions\n        )\n        non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(\n            pressure, temperature, molar_fractions\n        )\n        return ideal_gibbs + non_ideal_gibbs",
  "def excess_partial_entropies(self, pressure, temperature, molar_fractions):\n        ideal_entropies = IdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n\n        dSdx = self.ESV_gradient_list[1]\n        mbr_gradients = self.mbr_gradient_list\n        mbr_entropies = np.array([mbr.S for mbr in self.interaction_endmembers])\n\n        non_ideal_entropies = dSdx + np.einsum(\"i, ij->j\", mbr_entropies, mbr_gradients)\n        return ideal_entropies + non_ideal_entropies",
  "def excess_partial_volumes(self, pressure, temperature, molar_fractions):\n        dVdx = self.ESV_gradient_list[2]\n        mbr_gradients = self.mbr_gradient_list\n        mbr_volumes = np.array([mbr.V for mbr in self.interaction_endmembers])\n\n        return dVdx + np.einsum(\"i, ij->j\", mbr_volumes, mbr_gradients)",
  "def gibbs_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n\n        d2Edx2, d2Sdx2, d2Vdx2 = self.ESV_hessian_list\n        mbr_hessian = self.mbr_hessian_list\n        mbr_gibbs = np.array([mbr.gibbs for mbr in self.interaction_endmembers])\n\n        d2Gdx2 = d2Edx2 - temperature * d2Sdx2 + pressure * d2Vdx2\n        d2Gdx2 += np.einsum(\"i, ijk->jk\", mbr_gibbs, mbr_hessian)\n\n        return d2Gdx2 - temperature * ideal_entropy_hessian",
  "def entropy_hessian(self, pressure, temperature, molar_fractions):\n        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n\n        d2Sdx2 = self.ESV_hessian_list[1]\n        mbr_hessian = self.mbr_hessian_list\n        mbr_entropies = np.array([mbr.S for mbr in self.interaction_endmembers])\n\n        d2Sdx2 += np.einsum(\"i, ijk->jk\", mbr_entropies, mbr_hessian)\n\n        return d2Sdx2 + ideal_entropy_hessian",
  "def volume_hessian(self, pressure, temperature, molar_fractions):\n        d2Vdx2 = self.ESV_hessian_list[2]\n        mbr_hessian = self.mbr_hessian_list\n        mbr_volumes = np.array([mbr.V for mbr in self.interaction_endmembers])\n\n        d2Vdx2 += np.einsum(\"i, ijk->jk\", mbr_volumes, mbr_hessian)\n\n        return d2Vdx2",
  "def Cp_excess(self):\n        mbr_scalar = self.mbr_scalar_list\n        mbr_Cp = np.array(\n            [mbr.molar_heat_capacity_p for mbr in self.interaction_endmembers]\n        )\n        return np.einsum(\"i, i\", mbr_scalar, mbr_Cp)",
  "def alphaV_excess(self):\n        mbr_scalar = self.mbr_scalar_list\n        mbr_d2gibbsdpdt = np.array(\n            [mbr.alpha * mbr.V for mbr in self.interaction_endmembers]\n        )\n        return np.einsum(\"i, i\", mbr_scalar, mbr_d2gibbsdpdt)",
  "def VoverKT_excess(self):\n        mbr_scalar = self.mbr_scalar_list\n        mbr_d2gibbsdpdp = np.array(\n            [mbr.V / mbr.K_T for mbr in self.interaction_endmembers]\n        )\n        return np.einsum(\"i, i\", mbr_scalar, mbr_d2gibbsdpdp)",
  "def activity_coefficients(self, pressure, temperature, molar_fractions):\n        if temperature > 1.0e-10:\n            return np.exp(\n                self._non_ideal_excess_partial_gibbs(\n                    pressure, temperature, molar_fractions\n                )\n                / (constants.gas_constant * temperature)\n            )\n        else:\n            raise Exception(\"Activity coefficients not defined at 0 K.\")",
  "def activities(self, pressure, temperature, molar_fractions):\n        return IdealSolution.activities(\n            self, pressure, temperature, molar_fractions\n        ) * self.activity_coefficients(pressure, temperature, molar_fractions)",
  "def partial_entropies(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return -ag.jacobian(self._non_ideal_excess_partial_gibbs, argnum=1)(\n                    pressure, temperature, molar_amounts\n                )",
  "def partial_volumes(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(self._non_ideal_excess_partial_gibbs, argnum=0)(\n                    pressure, temperature, molar_amounts\n                )",
  "def entropy_hess(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_entropies, argnum=2)(\n                    pressure, temperature, molar_amounts\n                )",
  "def volume_hess(pressure, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_volumes, argnum=2)(\n                    pressure, temperature, molar_amounts\n                )",
  "class AnisotropicMaterial(Material):\n    \"\"\"\n    A base class for anisotropic elastic materials. The base class\n    is initialised with a density and a full isentropic stiffness tensor\n    in Voigt notation. It can then be interrogated to find the values of\n    different properties, such as bounds on seismic velocities.\n    There are also several functions which can be called to calculate\n    properties along directions oriented with respect to the isentropic\n    elastic tensor.\n\n    See :cite:`Mainprice2011`\n    and https://docs.materialsproject.org/methodology/elasticity/\n    for mathematical descriptions of each function.\n    \"\"\"\n\n    def __init__(self, rho, cijs):\n        self._isentropic_stiffness_tensor = cijs\n        self._rho = rho\n\n        assert cijs.shape == (6, 6), \"cijs must be in Voigt notation (6x6)\"\n        assert np.allclose(cijs.T, cijs), \"stiffness_tensor must be symmetric\"\n\n        Material.__init__(self)\n\n    @material_property\n    def isentropic_stiffness_tensor(self):\n        return self._isentropic_stiffness_tensor\n\n    @material_property\n    def full_isentropic_stiffness_tensor(self):\n        return voigt_notation_to_stiffness_tensor(self.isentropic_stiffness_tensor)\n\n    @material_property\n    def isentropic_compliance_tensor(self):\n        return np.linalg.inv(self.isentropic_stiffness_tensor)\n\n    @material_property\n    def full_isentropic_compliance_tensor(self):\n        return voigt_notation_to_compliance_tensor(self.isentropic_compliance_tensor)\n\n    @material_property\n    def density(self):\n        return self._rho\n\n    @material_property\n    def isentropic_bulk_modulus_voigt(self):\n        \"\"\"\n        :returns: The Voigt bound on the isentropic bulk modulus [Pa].\n        :rtype: float\n        \"\"\"\n        K = (\n            np.sum(\n                [\n                    [self.isentropic_stiffness_tensor[i][k] for k in range(3)]\n                    for i in range(3)\n                ]\n            )\n            / 9.0\n        )\n        return K\n\n    @material_property\n    def isentropic_bulk_modulus_reuss(self):\n        \"\"\"\n        :returns: The Reuss bound on the isentropic bulk modulus [Pa].\n        :rtype: float\n        \"\"\"\n        beta = np.sum(\n            [\n                [self.isentropic_compliance_tensor[i][k] for k in range(3)]\n                for i in range(3)\n            ]\n        )\n        return 1.0 / beta\n\n    @material_property\n    def isentropic_bulk_modulus_vrh(self):\n        \"\"\"\n        :returns: The Voigt-Reuss-Hill average of the isentropic bulk modulus [Pa].\n        :rtype: float\n        \"\"\"\n        return 0.5 * (\n            self.isentropic_bulk_modulus_voigt + self.isentropic_bulk_modulus_reuss\n        )\n\n    @material_property\n    def isentropic_shear_modulus_voigt(self):\n        \"\"\"\n        :returns: The Voigt bound on the isentropic shear modulus [Pa].\n        :rtype: float\n        \"\"\"\n        G = (\n            np.sum([self.isentropic_stiffness_tensor[i][i] for i in [0, 1, 2]])\n            + np.sum([self.isentropic_stiffness_tensor[i][i] for i in [3, 4, 5]]) * 3.0\n            - (\n                self.isentropic_stiffness_tensor[0][1]\n                + self.isentropic_stiffness_tensor[1][2]\n                + self.isentropic_stiffness_tensor[2][0]\n            )\n        ) / 15.0\n        return G\n\n    @material_property\n    def isentropic_shear_modulus_reuss(self):\n        \"\"\"\n        :returns: The Reuss bound on the isentropic shear modulus [Pa].\n        :rtype: float\n        \"\"\"\n        beta = (\n            np.sum([self.isentropic_compliance_tensor[i][i] for i in [0, 1, 2]]) * 4.0\n            + np.sum([self.isentropic_compliance_tensor[i][i] for i in [3, 4, 5]]) * 3.0\n            - (\n                self.isentropic_compliance_tensor[0][1]\n                + self.isentropic_compliance_tensor[1][2]\n                + self.isentropic_compliance_tensor[2][0]\n            )\n            * 4.0\n        ) / 15.0\n        return 1.0 / beta\n\n    @material_property\n    def isentropic_shear_modulus_vrh(self):\n        \"\"\"\n        :returns: The Voigt-Reuss-Hill average of the isentropic shear modulus [Pa].\n        :rtype: float\n        \"\"\"\n        return 0.5 * (\n            self.isentropic_shear_modulus_voigt + self.isentropic_shear_modulus_reuss\n        )\n\n    @material_property\n    def isentropic_universal_elastic_anisotropy(self):\n        \"\"\"\n        :returns: The universal elastic anisotropy [unitless]\n        :rtype: float\n        \"\"\"\n        return (\n            5.0\n            * (\n                self.isentropic_shear_modulus_voigt\n                / self.isentropic_shear_modulus_reuss\n            )\n            + (self.isentropic_bulk_modulus_voigt / self.isentropic_bulk_modulus_reuss)\n            - 6.0\n        )\n\n    @material_property\n    def isentropic_isotropic_poisson_ratio(self):\n        \"\"\"\n        :returns: The isotropic Poisson ratio (mu) [unitless].\n            A metric of the laterial response to loading.\n        :rtype: float\n        \"\"\"\n        return (\n            3.0 * self.isentropic_bulk_modulus_vrh\n            - 2.0 * self.isentropic_shear_modulus_vrh\n        ) / (\n            6.0 * self.isentropic_bulk_modulus_vrh\n            + 2.0 * self.isentropic_shear_modulus_vrh\n        )\n\n    def christoffel_tensor(self, propagation_direction):\n        \"\"\"\n        :returns: The Christoffel tensor from an elastic stiffness\n            tensor and a propagation direction for a seismic wave\n            relative to the stiffness tensor:\n            T_ik = C_ijkl n_j n_l.\n        :rtype: float\n        \"\"\"\n        propagation_direction = unit_normalize(propagation_direction)\n        Tik = np.tensordot(\n            np.tensordot(\n                self.full_isentropic_stiffness_tensor,\n                propagation_direction,\n                axes=([1], [0]),\n            ),\n            propagation_direction,\n            axes=([2], [0]),\n        )\n        return Tik\n\n    def isentropic_linear_compressibility(self, direction):\n        \"\"\"\n        :returns: The linear isentropic compressibility in a given direction\n        relative to the stiffness tensor [1/Pa].\n        :rtype: float\n        \"\"\"\n        direction = unit_normalize(direction)\n        Sijkk = np.einsum(\"ijkk\", self.full_isentropic_compliance_tensor)\n        beta = Sijkk.dot(direction).dot(direction)\n        return beta\n\n    def isentropic_youngs_modulus(self, direction):\n        \"\"\"\n        :returns: The isentropic Youngs modulus in a given direction\n        relative to the stiffness tensor [Pa].\n        :rtype: float\n        \"\"\"\n        direction = unit_normalize(direction)\n        Sijkl = self.full_isentropic_compliance_tensor\n        S = Sijkl.dot(direction).dot(direction).dot(direction).dot(direction)\n        return 1.0 / S\n\n    def isentropic_shear_modulus(self, plane_normal, shear_direction):\n        \"\"\"\n        :returns: The isentropic shear modulus on a plane in a given\n        shear direction relative to the stiffness tensor [Pa].\n        :rtype: float\n        \"\"\"\n        plane_normal = unit_normalize(plane_normal)\n        shear_direction = unit_normalize(shear_direction)\n\n        assert (\n            np.abs(plane_normal.dot(shear_direction)) < np.finfo(float).eps\n        ), \"plane_normal and shear_direction must be orthogonal\"\n        Sijkl = self.full_isentropic_compliance_tensor\n        G = (\n            Sijkl.dot(shear_direction)\n            .dot(plane_normal)\n            .dot(shear_direction)\n            .dot(plane_normal)\n        )\n        return 0.25 / G\n\n    def isentropic_poissons_ratio(self, axial_direction, lateral_direction):\n        \"\"\"\n        :returns: The isentropic poisson ratio given loading and response\n        directions relative to the stiffness tensor [unitless].\n        :rtype: float\n        \"\"\"\n\n        axial_direction = unit_normalize(axial_direction)\n        lateral_direction = unit_normalize(lateral_direction)\n        assert (\n            np.abs(axial_direction.dot(lateral_direction)) < np.finfo(float).eps\n        ), \"axial_direction and lateral_direction must be orthogonal\"\n\n        Sijkl = self.full_isentropic_compliance_tensor\n        x = axial_direction\n        y = lateral_direction\n        nu = -(Sijkl.dot(y).dot(y).dot(x).dot(x) / Sijkl.dot(x).dot(x).dot(x).dot(x))\n        return nu\n\n    def wave_velocities(self, propagation_direction):\n        \"\"\"\n        :returns: The compressional wave velocity, and two\n        shear wave velocities in a given propagation direction [m/s].\n        :rtype: list, containing the wave speeds and directions\n            of particle motion relative to the stiffness tensor\n        \"\"\"\n        propagation_direction = unit_normalize(propagation_direction)\n\n        Tik = self.christoffel_tensor(propagation_direction)\n\n        eigenvalues, eigenvectors = np.linalg.eig(Tik)\n\n        idx = eigenvalues.argsort()[::-1]\n        eigenvalues = np.real(eigenvalues[idx])\n        eigenvectors = eigenvectors[:, idx]\n        velocities = np.sqrt(eigenvalues / self.density)\n\n        return velocities, eigenvectors",
  "class IsotropicMaterial(AnisotropicMaterial):\n    \"\"\"\n    A class derived from the AnisotropicMaterial base class\n    Initialization takes two input parameters; rho and\n    [C12, C44] (i.e. lambda and mu, the Lame parameters)\n    \"\"\"\n\n    def __init__(self, rho, cijs):\n        assert len(cijs) == 2\n        cijs = list(cijs)\n        cijs.insert(0, cijs[0] + 2.0 * cijs[1])  # C11 = C12 + 2C44\n        index_lists = [\n            [(0, 0), (1, 1), (2, 2)],  # C11\n            [(0, 1), (0, 2), (1, 2)],  # C12\n            [(3, 3), (4, 4), (5, 5)],\n        ]  # C44\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "class CubicMaterial(AnisotropicMaterial):\n    \"\"\"\n    A class derived from the AnisotropicMaterial base class\n    Initialization takes two input parameters; rho and\n    [C11, C12, C44]\n    \"\"\"\n\n    def __init__(self, rho, cijs):\n        assert len(cijs) == 3\n        index_lists = [\n            [(0, 0), (1, 1), (2, 2)],  # C11\n            [(0, 1), (0, 2), (1, 2)],  # C12\n            [(3, 3), (4, 4), (5, 5)],\n        ]  # C44\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "class HexagonalMaterial(AnisotropicMaterial):\n    \"\"\"\n    A class derived from the AnisotropicMaterial base class\n    Initialization takes two input parameters; rho and\n    [C11, C12, C13, C33, C44]\n    \"\"\"\n\n    def __init__(self, rho, cijs):\n        assert len(cijs) == 5\n        cijs = list(cijs)\n        cijs.append((cijs[0] - cijs[1]) / 2.0)  # C66 = (C11-C12)/2.\n\n        index_lists = [\n            [(0, 0), (1, 1)],  # C11\n            [(0, 1)],  # C12\n            [(0, 2), (1, 2)],  # C13\n            [(2, 2)],  # C33\n            [(3, 3), (4, 4)],  # C44\n            [(5, 5)],\n        ]  # C66\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "class TetragonalMaterial(AnisotropicMaterial):\n    \"\"\"\n    A class derived from the AnisotropicMaterial base class\n    Initialization takes two input parameters; rho and\n    [C11, C12, C13, C33, C44, C66] or\n    [C11, C12, C13, C16, C33, C44, C66]\n    \"\"\"\n\n    def __init__(self, rho, cijs):\n        if len(cijs) == 6:\n            # Tetragonal I / Laue class 4/mmm\n            index_lists = [\n                [(0, 0), (1, 1)],  # C11\n                [(0, 1)],  # C12\n                [(0, 2), (1, 2)],  # C13\n                [(2, 2)],  # C33\n                [(3, 3), (4, 4)],  # C44\n                [(5, 5)],\n            ]  # C66\n        elif len(cijs) == 7:\n            # Tetragonal II / Laue class 4/m\n            cijs = list(cijs)\n            cijs.insert(4, -cijs[3])  # C26 = -C16\n            index_lists = [\n                [(0, 0), (1, 1)],  # C11\n                [(0, 1)],  # C12\n                [(0, 2), (1, 2)],  # C13\n                [(0, 5)],  # C16\n                [(1, 5)],  # C26\n                [(2, 2)],  # C33\n                [(3, 3), (4, 4)],  # C44\n                [(5, 5)],\n            ]  # C66\n        else:\n            raise Exception(\n                \"Tetragonal materials should have \" \"either 6 or 7 independent Cijs\"\n            )\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "class RhombohedralMaterial(AnisotropicMaterial):\n    \"\"\"\n    A class derived from the AnisotropicMaterial base class\n    Initialization takes two input parameters; rho and\n    [C11, C12, C13, C14, C33, C44, C66] or\n    [C11, C12, C13, C14, C15, C33, C44, C66]\n    \"\"\"\n\n    def __init__(self, rho, cijs):\n        cijs = list(cijs)\n        if len(cijs) == 7:\n            # Rhombohedral I / Laue class \\bar{3}m\n            cijs.insert(4, -cijs[3])  # C24 = -C14\n            index_lists = [\n                [(0, 0), (1, 1)],  # C11\n                [(0, 1)],  # C12\n                [(0, 2), (1, 2)],  # C13\n                [(0, 3), (4, 5)],  # C14\n                [(1, 3)],  # C24\n                [(2, 2)],  # C33\n                [(3, 3), (4, 4)],  # C44\n                [(5, 5)],\n            ]  # C66\n\n        elif len(cijs) == 8:\n            # Rhombohedral II / Laue class \\bar{3}\n            cijs.insert(4, -cijs[3])  # C24 = -C14\n            cijs.insert(6, -cijs[5])  # C25 = -C15\n            index_lists = [\n                [(0, 0), (1, 1)],  # C11\n                [(0, 1)],  # C12\n                [(0, 2), (1, 2)],  # C13\n                [(0, 3), (4, 5)],  # C14\n                [(1, 3)],  # C24\n                [(0, 4)],  # C15\n                [(1, 4), (3, 5)],  # C25\n                [(2, 2)],  # C33\n                [(3, 3), (4, 4)],  # C44\n                [(5, 5)],\n            ]  # C66\n\n        else:\n            raise Exception(\n                \"Rhombohedral materials should have \" \"either 7 or 8 independent Cijs\"\n            )\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "class OrthorhombicMaterial(AnisotropicMaterial):\n    \"\"\"\n    A class derived from the AnisotropicMaterial base class\n    Initialization takes two input parameters; rho and\n    [C11, C12, C13, C22, C23, C33, C44, C55, C66]\n    \"\"\"\n\n    def __init__(self, rho, cijs):\n        assert len(cijs) == 9\n        index_lists = [\n            [(0, 0)],  # C11\n            [(0, 1)],  # C12\n            [(0, 2)],  # C13\n            [(1, 1)],  # C22\n            [(1, 2)],  # C23\n            [(2, 2)],  # C33\n            [(3, 3)],  # C44\n            [(4, 4)],  # C55\n            [(5, 5)],\n        ]  # C66\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "class MonoclinicMaterial(AnisotropicMaterial):\n    \"\"\"\n    A class derived from the AnisotropicMaterial base class\n    Initialization takes two input parameters; rho and\n    [C11, C12, C13, C15, C22, C23, C25, C33, C35, C44, C46, C55, C66]\n    \"\"\"\n\n    def __init__(self, rho, cijs):\n        assert len(cijs) == 13\n        index_lists = [\n            [(0, 0)],  # C11\n            [(0, 1)],  # C12\n            [(0, 2)],  # C13\n            [(0, 4)],  # C15\n            [(1, 1)],  # C22\n            [(1, 2)],  # C23\n            [(1, 4)],  # C25\n            [(2, 2)],  # C33\n            [(2, 4)],  # C35\n            [(3, 3)],  # C44\n            [(3, 5)],  # C46\n            [(4, 4)],  # C55\n            [(5, 5)],\n        ]  # C66\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "class TriclinicMaterial(AnisotropicMaterial):\n    \"\"\"\n    A class derived from the AnisotropicMaterial base class\n    Initialization takes two input parameters; rho and\n    [Cij, where 1<=i<=6 and i<=j<=6]\n    \"\"\"\n\n    def __init__(self, rho, cijs):\n        assert len(cijs) == 21\n        index_lists = [[(i, j)] for i in range(6) for j in range(i, 6)]\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "def __init__(self, rho, cijs):\n        self._isentropic_stiffness_tensor = cijs\n        self._rho = rho\n\n        assert cijs.shape == (6, 6), \"cijs must be in Voigt notation (6x6)\"\n        assert np.allclose(cijs.T, cijs), \"stiffness_tensor must be symmetric\"\n\n        Material.__init__(self)",
  "def isentropic_stiffness_tensor(self):\n        return self._isentropic_stiffness_tensor",
  "def full_isentropic_stiffness_tensor(self):\n        return voigt_notation_to_stiffness_tensor(self.isentropic_stiffness_tensor)",
  "def isentropic_compliance_tensor(self):\n        return np.linalg.inv(self.isentropic_stiffness_tensor)",
  "def full_isentropic_compliance_tensor(self):\n        return voigt_notation_to_compliance_tensor(self.isentropic_compliance_tensor)",
  "def density(self):\n        return self._rho",
  "def isentropic_bulk_modulus_voigt(self):\n        \"\"\"\n        :returns: The Voigt bound on the isentropic bulk modulus [Pa].\n        :rtype: float\n        \"\"\"\n        K = (\n            np.sum(\n                [\n                    [self.isentropic_stiffness_tensor[i][k] for k in range(3)]\n                    for i in range(3)\n                ]\n            )\n            / 9.0\n        )\n        return K",
  "def isentropic_bulk_modulus_reuss(self):\n        \"\"\"\n        :returns: The Reuss bound on the isentropic bulk modulus [Pa].\n        :rtype: float\n        \"\"\"\n        beta = np.sum(\n            [\n                [self.isentropic_compliance_tensor[i][k] for k in range(3)]\n                for i in range(3)\n            ]\n        )\n        return 1.0 / beta",
  "def isentropic_bulk_modulus_vrh(self):\n        \"\"\"\n        :returns: The Voigt-Reuss-Hill average of the isentropic bulk modulus [Pa].\n        :rtype: float\n        \"\"\"\n        return 0.5 * (\n            self.isentropic_bulk_modulus_voigt + self.isentropic_bulk_modulus_reuss\n        )",
  "def isentropic_shear_modulus_voigt(self):\n        \"\"\"\n        :returns: The Voigt bound on the isentropic shear modulus [Pa].\n        :rtype: float\n        \"\"\"\n        G = (\n            np.sum([self.isentropic_stiffness_tensor[i][i] for i in [0, 1, 2]])\n            + np.sum([self.isentropic_stiffness_tensor[i][i] for i in [3, 4, 5]]) * 3.0\n            - (\n                self.isentropic_stiffness_tensor[0][1]\n                + self.isentropic_stiffness_tensor[1][2]\n                + self.isentropic_stiffness_tensor[2][0]\n            )\n        ) / 15.0\n        return G",
  "def isentropic_shear_modulus_reuss(self):\n        \"\"\"\n        :returns: The Reuss bound on the isentropic shear modulus [Pa].\n        :rtype: float\n        \"\"\"\n        beta = (\n            np.sum([self.isentropic_compliance_tensor[i][i] for i in [0, 1, 2]]) * 4.0\n            + np.sum([self.isentropic_compliance_tensor[i][i] for i in [3, 4, 5]]) * 3.0\n            - (\n                self.isentropic_compliance_tensor[0][1]\n                + self.isentropic_compliance_tensor[1][2]\n                + self.isentropic_compliance_tensor[2][0]\n            )\n            * 4.0\n        ) / 15.0\n        return 1.0 / beta",
  "def isentropic_shear_modulus_vrh(self):\n        \"\"\"\n        :returns: The Voigt-Reuss-Hill average of the isentropic shear modulus [Pa].\n        :rtype: float\n        \"\"\"\n        return 0.5 * (\n            self.isentropic_shear_modulus_voigt + self.isentropic_shear_modulus_reuss\n        )",
  "def isentropic_universal_elastic_anisotropy(self):\n        \"\"\"\n        :returns: The universal elastic anisotropy [unitless]\n        :rtype: float\n        \"\"\"\n        return (\n            5.0\n            * (\n                self.isentropic_shear_modulus_voigt\n                / self.isentropic_shear_modulus_reuss\n            )\n            + (self.isentropic_bulk_modulus_voigt / self.isentropic_bulk_modulus_reuss)\n            - 6.0\n        )",
  "def isentropic_isotropic_poisson_ratio(self):\n        \"\"\"\n        :returns: The isotropic Poisson ratio (mu) [unitless].\n            A metric of the laterial response to loading.\n        :rtype: float\n        \"\"\"\n        return (\n            3.0 * self.isentropic_bulk_modulus_vrh\n            - 2.0 * self.isentropic_shear_modulus_vrh\n        ) / (\n            6.0 * self.isentropic_bulk_modulus_vrh\n            + 2.0 * self.isentropic_shear_modulus_vrh\n        )",
  "def christoffel_tensor(self, propagation_direction):\n        \"\"\"\n        :returns: The Christoffel tensor from an elastic stiffness\n            tensor and a propagation direction for a seismic wave\n            relative to the stiffness tensor:\n            T_ik = C_ijkl n_j n_l.\n        :rtype: float\n        \"\"\"\n        propagation_direction = unit_normalize(propagation_direction)\n        Tik = np.tensordot(\n            np.tensordot(\n                self.full_isentropic_stiffness_tensor,\n                propagation_direction,\n                axes=([1], [0]),\n            ),\n            propagation_direction,\n            axes=([2], [0]),\n        )\n        return Tik",
  "def isentropic_linear_compressibility(self, direction):\n        \"\"\"\n        :returns: The linear isentropic compressibility in a given direction\n        relative to the stiffness tensor [1/Pa].\n        :rtype: float\n        \"\"\"\n        direction = unit_normalize(direction)\n        Sijkk = np.einsum(\"ijkk\", self.full_isentropic_compliance_tensor)\n        beta = Sijkk.dot(direction).dot(direction)\n        return beta",
  "def isentropic_youngs_modulus(self, direction):\n        \"\"\"\n        :returns: The isentropic Youngs modulus in a given direction\n        relative to the stiffness tensor [Pa].\n        :rtype: float\n        \"\"\"\n        direction = unit_normalize(direction)\n        Sijkl = self.full_isentropic_compliance_tensor\n        S = Sijkl.dot(direction).dot(direction).dot(direction).dot(direction)\n        return 1.0 / S",
  "def isentropic_shear_modulus(self, plane_normal, shear_direction):\n        \"\"\"\n        :returns: The isentropic shear modulus on a plane in a given\n        shear direction relative to the stiffness tensor [Pa].\n        :rtype: float\n        \"\"\"\n        plane_normal = unit_normalize(plane_normal)\n        shear_direction = unit_normalize(shear_direction)\n\n        assert (\n            np.abs(plane_normal.dot(shear_direction)) < np.finfo(float).eps\n        ), \"plane_normal and shear_direction must be orthogonal\"\n        Sijkl = self.full_isentropic_compliance_tensor\n        G = (\n            Sijkl.dot(shear_direction)\n            .dot(plane_normal)\n            .dot(shear_direction)\n            .dot(plane_normal)\n        )\n        return 0.25 / G",
  "def isentropic_poissons_ratio(self, axial_direction, lateral_direction):\n        \"\"\"\n        :returns: The isentropic poisson ratio given loading and response\n        directions relative to the stiffness tensor [unitless].\n        :rtype: float\n        \"\"\"\n\n        axial_direction = unit_normalize(axial_direction)\n        lateral_direction = unit_normalize(lateral_direction)\n        assert (\n            np.abs(axial_direction.dot(lateral_direction)) < np.finfo(float).eps\n        ), \"axial_direction and lateral_direction must be orthogonal\"\n\n        Sijkl = self.full_isentropic_compliance_tensor\n        x = axial_direction\n        y = lateral_direction\n        nu = -(Sijkl.dot(y).dot(y).dot(x).dot(x) / Sijkl.dot(x).dot(x).dot(x).dot(x))\n        return nu",
  "def wave_velocities(self, propagation_direction):\n        \"\"\"\n        :returns: The compressional wave velocity, and two\n        shear wave velocities in a given propagation direction [m/s].\n        :rtype: list, containing the wave speeds and directions\n            of particle motion relative to the stiffness tensor\n        \"\"\"\n        propagation_direction = unit_normalize(propagation_direction)\n\n        Tik = self.christoffel_tensor(propagation_direction)\n\n        eigenvalues, eigenvectors = np.linalg.eig(Tik)\n\n        idx = eigenvalues.argsort()[::-1]\n        eigenvalues = np.real(eigenvalues[idx])\n        eigenvectors = eigenvectors[:, idx]\n        velocities = np.sqrt(eigenvalues / self.density)\n\n        return velocities, eigenvectors",
  "def __init__(self, rho, cijs):\n        assert len(cijs) == 2\n        cijs = list(cijs)\n        cijs.insert(0, cijs[0] + 2.0 * cijs[1])  # C11 = C12 + 2C44\n        index_lists = [\n            [(0, 0), (1, 1), (2, 2)],  # C11\n            [(0, 1), (0, 2), (1, 2)],  # C12\n            [(3, 3), (4, 4), (5, 5)],\n        ]  # C44\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "def __init__(self, rho, cijs):\n        assert len(cijs) == 3\n        index_lists = [\n            [(0, 0), (1, 1), (2, 2)],  # C11\n            [(0, 1), (0, 2), (1, 2)],  # C12\n            [(3, 3), (4, 4), (5, 5)],\n        ]  # C44\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "def __init__(self, rho, cijs):\n        assert len(cijs) == 5\n        cijs = list(cijs)\n        cijs.append((cijs[0] - cijs[1]) / 2.0)  # C66 = (C11-C12)/2.\n\n        index_lists = [\n            [(0, 0), (1, 1)],  # C11\n            [(0, 1)],  # C12\n            [(0, 2), (1, 2)],  # C13\n            [(2, 2)],  # C33\n            [(3, 3), (4, 4)],  # C44\n            [(5, 5)],\n        ]  # C66\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "def __init__(self, rho, cijs):\n        if len(cijs) == 6:\n            # Tetragonal I / Laue class 4/mmm\n            index_lists = [\n                [(0, 0), (1, 1)],  # C11\n                [(0, 1)],  # C12\n                [(0, 2), (1, 2)],  # C13\n                [(2, 2)],  # C33\n                [(3, 3), (4, 4)],  # C44\n                [(5, 5)],\n            ]  # C66\n        elif len(cijs) == 7:\n            # Tetragonal II / Laue class 4/m\n            cijs = list(cijs)\n            cijs.insert(4, -cijs[3])  # C26 = -C16\n            index_lists = [\n                [(0, 0), (1, 1)],  # C11\n                [(0, 1)],  # C12\n                [(0, 2), (1, 2)],  # C13\n                [(0, 5)],  # C16\n                [(1, 5)],  # C26\n                [(2, 2)],  # C33\n                [(3, 3), (4, 4)],  # C44\n                [(5, 5)],\n            ]  # C66\n        else:\n            raise Exception(\n                \"Tetragonal materials should have \" \"either 6 or 7 independent Cijs\"\n            )\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "def __init__(self, rho, cijs):\n        cijs = list(cijs)\n        if len(cijs) == 7:\n            # Rhombohedral I / Laue class \\bar{3}m\n            cijs.insert(4, -cijs[3])  # C24 = -C14\n            index_lists = [\n                [(0, 0), (1, 1)],  # C11\n                [(0, 1)],  # C12\n                [(0, 2), (1, 2)],  # C13\n                [(0, 3), (4, 5)],  # C14\n                [(1, 3)],  # C24\n                [(2, 2)],  # C33\n                [(3, 3), (4, 4)],  # C44\n                [(5, 5)],\n            ]  # C66\n\n        elif len(cijs) == 8:\n            # Rhombohedral II / Laue class \\bar{3}\n            cijs.insert(4, -cijs[3])  # C24 = -C14\n            cijs.insert(6, -cijs[5])  # C25 = -C15\n            index_lists = [\n                [(0, 0), (1, 1)],  # C11\n                [(0, 1)],  # C12\n                [(0, 2), (1, 2)],  # C13\n                [(0, 3), (4, 5)],  # C14\n                [(1, 3)],  # C24\n                [(0, 4)],  # C15\n                [(1, 4), (3, 5)],  # C25\n                [(2, 2)],  # C33\n                [(3, 3), (4, 4)],  # C44\n                [(5, 5)],\n            ]  # C66\n\n        else:\n            raise Exception(\n                \"Rhombohedral materials should have \" \"either 7 or 8 independent Cijs\"\n            )\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "def __init__(self, rho, cijs):\n        assert len(cijs) == 9\n        index_lists = [\n            [(0, 0)],  # C11\n            [(0, 1)],  # C12\n            [(0, 2)],  # C13\n            [(1, 1)],  # C22\n            [(1, 2)],  # C23\n            [(2, 2)],  # C33\n            [(3, 3)],  # C44\n            [(4, 4)],  # C55\n            [(5, 5)],\n        ]  # C66\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "def __init__(self, rho, cijs):\n        assert len(cijs) == 13\n        index_lists = [\n            [(0, 0)],  # C11\n            [(0, 1)],  # C12\n            [(0, 2)],  # C13\n            [(0, 4)],  # C15\n            [(1, 1)],  # C22\n            [(1, 2)],  # C23\n            [(1, 4)],  # C25\n            [(2, 2)],  # C33\n            [(2, 4)],  # C35\n            [(3, 3)],  # C44\n            [(3, 5)],  # C46\n            [(4, 4)],  # C55\n            [(5, 5)],\n        ]  # C66\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "def __init__(self, rho, cijs):\n        assert len(cijs) == 21\n        index_lists = [[(i, j)] for i in range(6) for j in range(i, 6)]\n\n        AnisotropicMaterial.__init__(\n            self, rho, voigt_array_from_cijs(cijs, index_lists)\n        )",
  "class AnisotropicMineral(Mineral, AnisotropicMaterial):\n    \"\"\"\n    A class implementing the anisotropic mineral equation of state described\n    in :cite:`Myhill2022`.\n    This class is derived from both Mineral and AnisotropicMaterial,\n    and inherits most of the methods from these classes.\n\n    Instantiation of an AnisotropicMineral takes three required arguments;\n    a reference Mineral (i.e. a standard isotropic mineral which provides\n    volume as a function of pressure and temperature), cell_parameters,\n    which give the lengths of the molar cell vectors and the angles between\n    them (see :func:`~burnman.utils.unitcell.cell_parameters_to_vectors`),\n    and an anisotropic parameters object, which should be either a\n    4D array of anisotropic parameters or a dictionary of parameters which\n    describe the anisotropic behaviour of the mineral.\n    For a description of the physical meaning of the parameters in the\n    4D array, please refer to the code\n    or to the original paper.\n\n    If the user chooses to define their parameters as a dictionary,\n    they must also provide a function to the psi_function argument\n    that describes how to compute the tensors Psi, dPsidf and dPsidPth\n    (in Voigt form). The function arguments should be f, Pth and params,\n    in that order. The output variables Psi, dPsidf and dPsidth\n    must be returned in that order in a tuple. The user should\n    also explicitly state whether the material is orthotropic or not\n    by supplying a boolean to the orthotropic argument.\n\n    States of the mineral can only be queried after setting the\n    pressure and temperature using set_state().\n\n    This class is available as ``burnman.AnisotropicMineral``.\n\n    All the material parameters are expected to be in plain SI units.  This\n    means that the elastic moduli should be in Pascals and NOT Gigapascals.\n    Additionally, the cell parameters should be in m/(mol formula unit)\n    and not in unit cell lengths. To convert unit cell lengths given in\n    Angstrom to molar cell parameters you should multiply by 10^(-10) *\n    (N_a / Z)^1/3, where N_a is Avogadro's number\n    and Z is the number of formula units per unit cell.\n    You can look up Z in many places, including www.mindat.org.\n\n    Finally, it is assumed that the unit cell of the anisotropic material\n    is aligned in a particular way relative to the coordinate axes\n    (the anisotropic_parameters are defined relative to the coordinate axes).\n    The crystallographic a-axis is assumed to be parallel to the first\n    spatial coordinate axis, and the crystallographic b-axis is assumed to\n    be perpendicular to the third spatial coordinate axis.\n    \"\"\"\n\n    def __init__(\n        self,\n        isotropic_mineral,\n        cell_parameters,\n        anisotropic_parameters,\n        psi_function=None,\n        orthotropic=None,\n    ):\n        if psi_function is None:\n            self.check_standard_parameters(anisotropic_parameters)\n            self.anisotropic_params = {\"c\": anisotropic_parameters}\n            self.psi_function = self.standard_psi_function\n        else:\n            if not isinstance(orthotropic, bool):\n                raise Exception(\n                    \"If the Psi function is provided, \"\n                    \"you must specify whether your material is \"\n                    \"orthotropic as a boolean.\"\n                )\n            self.orthotropic = orthotropic\n            self.anisotropic_params = anisotropic_parameters\n            self.psi_function = psi_function\n\n        self.cell_vectors_0 = cell_parameters_to_vectors(cell_parameters)\n\n        if (\n            np.abs(np.linalg.det(self.cell_vectors_0) - isotropic_mineral.params[\"V_0\"])\n            > np.finfo(float).eps\n        ):\n            factor = np.cbrt(\n                isotropic_mineral.params[\"V_0\"] / np.linalg.det(self.cell_vectors_0)\n            )\n            raise Exception(\n                \"The standard state unit vectors are inconsistent \"\n                \"with the volume. Suggest multiplying each \"\n                f\"by {factor}.\"\n            )\n\n        # Note, Psi_0 may be asymmetric, in which case the Voigt contraction\n        # cannot be applied\n        self.Psi_0 = np.einsum(\"ij, kl\", logm(self.cell_vectors_0), np.eye(3) / 3.0)\n\n        self.isotropic_mineral = isotropic_mineral\n        if \"name\" in isotropic_mineral.params:\n            self.name = isotropic_mineral.params[\"name\"]\n\n        Mineral.__init__(\n            self, isotropic_mineral.params, isotropic_mineral.property_modifiers\n        )\n\n    def standard_psi_function(self, f, Pth, params):\n        # Compute Psi, dPsidPth, dPsidf, needed by most anisotropic properties\n        c = params[\"c\"]\n        ns = np.arange(c.shape[-1])\n        x = c[:, :, 0, :] + c[:, :, 1, :] * f\n        dPsidf = c[:, :, 1, :]\n\n        for i in list(range(2, c.shape[2])):\n            # non-intuitively, the += operator doesn't simply add in-place,\n            # so here we overwrite the arrays with new ones\n            x = x + c[:, :, i, :] * np.power(f, float(i)) / float(i)\n            dPsidf = dPsidf + c[:, :, i, :] * np.power(f, float(i) - 1.0)\n\n        Psi = np.einsum(\"ikn, n->ik\", x, np.power(Pth, ns))\n\n        dPsidPth = np.einsum(\n            \"ikn, n->ik\", x[:, :, 1:], ns[1:] * np.power(Pth, ns[1:] - 1)\n        )\n\n        dPsidf = np.einsum(\"ikn, n->ik\", dPsidf, np.power(Pth, ns))\n        return (Psi, dPsidf, dPsidPth)\n\n    @copy_documentation(Material.set_state)\n    def set_state(self, pressure, temperature):\n        # 1) Compute dPthdf|T\n        # relatively large dP needed for accurate estimate of dPthdf\n\n        self.isotropic_mineral.set_state(pressure, temperature)\n        V2 = self.isotropic_mineral.V\n        KT2 = self.isotropic_mineral.K_T\n        self.isotropic_mineral.set_state_with_volume(V2, self.params[\"T_0\"])\n        P1 = self.isotropic_mineral.pressure\n        KT1 = self.isotropic_mineral.K_T\n        self.dPthdf = KT1 - KT2\n        self.Pth = pressure - P1\n\n        self.isotropic_mineral.set_state(pressure, temperature)\n        Mineral.set_state(self, pressure, temperature)\n\n        # 2) Compute other properties needed for anisotropic equation of state\n        V = self.V\n        V_0 = self.params[\"V_0\"]\n        Vrel = V / V_0\n        f = np.log(Vrel)\n        self._Vrel = Vrel\n        self._f = f\n\n        out = self.psi_function(f, self.Pth, self.anisotropic_params)\n        Psi_Voigt, self.dPsidf_Voigt, self.dPsidPth_Voigt = out\n        self.Psi = voigt_notation_to_compliance_tensor(Psi_Voigt) + self.Psi_0\n\n        # Convert to (f, T) variables\n        self.dPsidP_Voigt = -self.isothermal_compressibility_reuss * (\n            self.dPsidf_Voigt + self.dPsidPth_Voigt * self.dPthdf\n        )\n        self.dPsidT_Voigt = self.alpha * (\n            self.dPsidf_Voigt\n            + self.dPsidPth_Voigt * (self.dPthdf + self.isothermal_bulk_modulus_reuss)\n        )\n\n    @material_property\n    def deformation_gradient_tensor(self):\n        \"\"\"\n        :returns: The deformation gradient tensor describing the deformation of the\n            mineral from its undeformed state\n            (i.e. the state at the reference pressure and temperature).\n        :rtype: numpy.array (2D)\n        \"\"\"\n        F = expm(np.einsum(\"ijkl, kl\", self.Psi, np.eye(3)))\n        return F\n\n    @material_property\n    def unrotated_cell_vectors(self):\n        \"\"\"\n        :returns: The vectors of the cell [m] constructed from one mole\n            of formula units after deformation of the mineral from its\n            undeformed state (i.e. the state at the reference\n            pressure and temperature). See the documentation for the function\n            :func:`~burnman.utils.unitcell.cell_parameters_to_vectors`\n            for the assumed relationships between the cell vectors and\n            spatial coordinate axes.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return self.deformation_gradient_tensor\n\n    @material_property\n    def deformed_coordinate_frame(self):\n        \"\"\"\n        :returns: The orientations of the three spatial coordinate axes\n            after deformation of the mineral [m]. For orthotropic minerals,\n            this is equal to the identity matrix, as hydrostatic stresses only\n            induce rotations in monoclinic and triclinic crystals.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        if self.orthotropic:\n            return np.eye(3)\n        else:\n            M = self.unrotated_cell_vectors\n            Q = np.empty((3, 3))\n            Q[0] = M[0] / np.linalg.norm(M[0])\n            Q[2] = np.cross(M[0], M[1]) / np.linalg.norm(np.cross(M[0], M[1]))\n            Q[1] = np.cross(Q[2], Q[0])\n            return Q\n\n    @material_property\n    def rotation_matrix(self):\n        \"\"\"\n        :returns: The matrix required to rotate the properties of the deformed\n            mineral into the deformed coordinate frame. For orthotropic\n            minerals, this is equal to the identity matrix.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return self.deformed_coordinate_frame.T\n\n    @material_property\n    def cell_vectors(self):\n        \"\"\"\n        :returns: The vectors of the cell constructed from one mole\n            of formula units [m]. See the documentation for the function\n            :func:`~burnman.utils.unitcell.cell_parameters_to_vectors`\n            for the assumed relationships between the cell vectors and\n            spatial coordinate axes.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        if self.orthotropic:\n            return self.unrotated_cell_vectors\n        else:\n            return np.einsum(\n                \"ij, jk->ik\", self.unrotated_cell_vectors, self.rotation_matrix\n            )\n\n    @material_property\n    def cell_parameters(self):\n        \"\"\"\n        :returns: The molar cell parameters of the mineral, given in standard form:\n            [:math:`a`, :math:`b`, :math:`c`,\n            :math:`\\\\alpha`, :math:`\\\\beta`, :math:`\\\\gamma`],\n            where the first three floats are the lengths of the vectors in [m]\n            defining the cell constructed from one mole of formula units.\n            The last three floats are angles between vectors\n            (given in radians). See the documentation for the function\n            :func:`~burnman.utils.unitcell.cell_parameters_to_vectors`\n            for the assumed relationships between the cell vectors and\n            spatial coordinate axes.\n        :rtype: numpy.array (1D)\n        \"\"\"\n        return cell_vectors_to_parameters(self.cell_vectors)\n\n    @material_property\n    def shear_modulus(self):\n        \"\"\"\n        Anisotropic minerals do not (in general) have a single shear modulus.\n        This function returns a NotImplementedError. Users should instead\n        consider directly querying the elements in the\n        isothermal_stiffness_tensor or isentropic_stiffness_tensor.\n        \"\"\"\n        raise NotImplementedError(\n            \"Anisotropic minerals do not have a shear \"\n            \"modulus property. Query \"\n            \"the isentropic or isothermal stiffness \"\n            \"tensors directory, or use\"\n            \"isentropic_shear_modulus_reuss or \"\n            \"isentropic_shear_modulus_voigt.\"\n        )\n\n    @material_property\n    def isothermal_bulk_modulus(self):\n        \"\"\"\n        Anisotropic minerals do not have a single isothermal bulk modulus.\n        This function returns a NotImplementedError. Users should instead\n        consider either using isothermal_bulk_modulus_reuss,\n        isothermal_bulk_modulus_voigt,\n        or directly querying the elements in the isothermal_stiffness_tensor.\n        \"\"\"\n        raise NotImplementedError(\n            \"isothermal_bulk_modulus is not \"\n            \"sufficiently explicit for an \"\n            \"anisotropic mineral. Did you mean \"\n            \"isothermal_bulk_modulus_reuss?\"\n        )\n\n    @material_property\n    def isentropic_bulk_modulus(self):\n        \"\"\"\n        Anisotropic minerals do not have a single isentropic bulk modulus.\n        This function returns a NotImplementedError. Users should instead\n        consider either using isentropic_bulk_modulus_reuss,\n        isentropic_bulk_modulus_voigt (both derived from AnisotropicMineral),\n        or directly querying the elements in the isentropic_stiffness_tensor.\n        \"\"\"\n        raise NotImplementedError(\n            \"isentropic_bulk_modulus is not \"\n            \"sufficiently explicit for an \"\n            \"anisotropic mineral. Did you mean \"\n            \"isentropic_bulk_modulus_reuss?\"\n        )\n\n    isothermal_bulk_modulus_reuss = Mineral.isothermal_bulk_modulus\n\n    @material_property\n    def isothermal_compressibility(self):\n        \"\"\"\n        Anisotropic minerals do not have a single isentropic compressibility.\n        This function returns a NotImplementedError. Users should instead\n        consider either using isothermal_compressibility_reuss,\n        isothermal_compressibility_voigt (both derived from AnisotropicMineral),\n        or directly querying the elements in the isothermal_compliance_tensor.\n        \"\"\"\n        raise NotImplementedError(\n            \"isothermal_compressibility is not \"\n            \"sufficiently explicit for an \"\n            \"anisotropic mineral. Did you mean \"\n            \"isothermal_compressibility_reuss?\"\n        )\n\n    @material_property\n    def isentropic_compressibility(self):\n        \"\"\"\n        Anisotropic minerals do not have a single isentropic compressibility.\n        This function returns a NotImplementedError. Users should instead\n        consider either using isentropic_compressibility_reuss,\n        isentropic_compressibility_voigt (both derived from AnisotropicMineral),\n        or directly querying the elements in the isentropic_compliance_tensor.\n        \"\"\"\n        raise NotImplementedError(\n            \"isentropic_compressibility is not \"\n            \"sufficiently explicit for an \"\n            \"anisotropic mineral. Did you mean \"\n            \"isentropic_compressibility_reuss?\"\n        )\n\n    @material_property\n    def isothermal_bulk_modulus_voigt(self):\n        \"\"\"\n        :returns: The Voigt bound on the isothermal bulk modulus in [Pa].\n        :rtype: float\n        \"\"\"\n        K = (\n            np.sum(\n                [\n                    [self.isothermal_stiffness_tensor[i][k] for k in range(3)]\n                    for i in range(3)\n                ]\n            )\n            / 9.0\n        )\n        return K\n\n    @material_property\n    def isothermal_compressibility_reuss(self):\n        \"\"\"\n        :returns: The Reuss bound on the isothermal compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus_reuss\n\n    beta_T = isothermal_compressibility_reuss\n\n    @material_property\n    def isothermal_compressibility_voigt(self):\n        \"\"\"\n        :returns: The Voigt bound on the isothermal compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus_voigt\n\n    @material_property\n    def isentropic_compressibility_reuss(self):\n        \"\"\"\n        :returns: The Reuss bound on the isentropic compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        return 1.0 / self.isentropic_bulk_modulus_reuss\n\n    beta_S = isentropic_compressibility_reuss\n\n    @material_property\n    def isentropic_compressibility_voigt(self):\n        \"\"\"\n        :returns: The Voigt bound on the isentropic compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        return 1.0 / self.isentropic_bulk_modulus_voigt\n\n    @material_property\n    def isothermal_compliance_tensor(self):\n        \"\"\"\n        :returns: The isothermal compliance tensor [1/Pa]\n            in Voigt form (:math:`\\\\mathbb{S}_{\\\\text{T} pq}`).\n        :rtype: numpy.array (2D)\n        \"\"\"\n        S_T = -self.dPsidP_Voigt\n        if self.orthotropic:\n            return S_T\n        else:\n            R = self.rotation_matrix\n            S = voigt_notation_to_compliance_tensor(S_T)\n            S_rotated = np.einsum(\"mi, nj, ok, pl, ijkl->mnop\", R, R, R, R, S)\n            return contract_compliances(S_rotated)\n\n    @material_property\n    def thermal_expansivity_tensor(self):\n        \"\"\"\n        :returns: The tensor of thermal expansivities [1/K].\n        :rtype: numpy.array (2D)\n        \"\"\"\n        alpha = np.einsum(\n            \"ijkl, kl\",\n            voigt_notation_to_compliance_tensor(self.dPsidT_Voigt),\n            np.eye(3),\n        )\n\n        if self.orthotropic:\n            return alpha\n        else:\n            R = self.rotation_matrix\n            return np.einsum(\"mi, nj, ij->mn\", R, R, alpha)\n\n    # Derived properties start here\n    @material_property\n    def isothermal_stiffness_tensor(self):\n        \"\"\"\n        :returns: The isothermal stiffness tensor [Pa]\n            in Voigt form (:math:`\\\\mathbb{C}_{\\\\text{T} pq}`).\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return np.linalg.inv(self.isothermal_compliance_tensor)\n\n    @material_property\n    def full_isothermal_compliance_tensor(self):\n        \"\"\"\n        :returns: The isothermal compliance tensor [1/Pa]\n            in standard form (:math:`\\\\mathbb{S}_{\\\\text{T} ijkl}`).\n        :rtype: numpy.array (4D)\n        \"\"\"\n        S_Voigt = self.isothermal_compliance_tensor\n        return voigt_notation_to_compliance_tensor(S_Voigt)\n\n    @material_property\n    def full_isothermal_stiffness_tensor(self):\n        \"\"\"\n        :returns: The isothermal stiffness tensor [Pa]\n            in standard form (:math:`\\\\mathbb{C}_{\\\\text{T} ijkl}`).\n        :rtype: numpy.array (4D)\n        \"\"\"\n        CT = self.isothermal_stiffness_tensor\n        return voigt_notation_to_stiffness_tensor(CT)\n\n    @material_property\n    def full_isentropic_compliance_tensor(self):\n        \"\"\"\n        :returns: The isentropic compliance tensor [1/Pa]\n            in standard form (:math:`\\\\mathbb{S}_{\\\\text{N} ijkl}`).\n        :rtype: numpy.array (4D)\n        \"\"\"\n        return (\n            self.full_isothermal_compliance_tensor\n            - np.einsum(\n                \"ij, kl->ijkl\",\n                self.thermal_expansivity_tensor,\n                self.thermal_expansivity_tensor,\n            )\n            * self.V\n            * self.temperature\n            / self.C_p\n        )\n\n    @material_property\n    def isentropic_compliance_tensor(self):\n        \"\"\"\n        :returns: The isentropic compliance tensor [1/Pa]\n            in Voigt form (:math:`\\\\mathbb{S}_{\\\\text{N} pq}`).\n        :rtype: numpy.array (2D)\n        \"\"\"\n        S_full = self.full_isentropic_compliance_tensor\n        return contract_compliances(S_full)\n\n    @material_property\n    def isentropic_stiffness_tensor(self):\n        \"\"\"\n        :returns: The isentropic stiffness tensor [Pa]\n            in Voigt form (:math:`\\\\mathbb{C}_{\\\\text{N} pq}`).\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return np.linalg.inv(self.isentropic_compliance_tensor)\n\n    @material_property\n    def full_isentropic_stiffness_tensor(self):\n        \"\"\"\n        :returns: The isentropic stiffness tensor [Pa]\n            in standard form (:math:`\\\\mathbb{C}_{\\\\text{N} ijkl}`).\n        :rtype: numpy.array (4D)\n        \"\"\"\n        C_Voigt = self.isentropic_stiffness_tensor\n        return voigt_notation_to_stiffness_tensor(C_Voigt)\n\n    @material_property\n    def grueneisen_tensor(self):\n        \"\"\"\n        :returns: The grueneisen tensor [unitless].\n            This is defined by :cite:`BarronMunn1967` as\n            :math:`\\\\mathbb{C}_{\\\\text{N} ijkl} \\\\alpha_{kl} V/C_{P}`.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return (\n            np.einsum(\n                \"ijkl, kl->ij\",\n                self.full_isentropic_stiffness_tensor,\n                self.thermal_expansivity_tensor,\n            )\n            * self.molar_volume\n            / self.molar_heat_capacity_p\n        )\n\n    @material_property\n    def grueneisen_parameter(self):\n        \"\"\"\n        :returns: The scalar grueneisen parameter [unitless].\n        :rtype: float\n        \"\"\"\n        return (\n            self.thermal_expansivity\n            * self.V\n            / (self.isentropic_compressibility_reuss * self.molar_heat_capacity_p)\n        )\n\n    @material_property\n    def isothermal_compressibility_tensor(self):\n        \"\"\"\n        :returns: The isothermal compressibility tensor [1/Pa].\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return np.einsum(\n            \"ijkl, kl->ij\", self.full_isothermal_compliance_tensor, np.eye(3)\n        )\n\n    @material_property\n    def isentropic_compressibility_tensor(self):\n        \"\"\"\n        :returns: The isentropic compressibility tensor [1/Pa].\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return np.einsum(\n            \"ijkl, kl->ij\", self.full_isentropic_compliance_tensor, np.eye(3)\n        )\n\n    @material_property\n    def thermal_stress_tensor(self):\n        \"\"\"\n        :returns: The change in stress with temperature at constant strain [Pa/K].\n        :rtype: numpy.array (2D)\n        \"\"\"\n        pi = -np.einsum(\n            \"ijkl, kl\",\n            self.full_isothermal_stiffness_tensor,\n            self.thermal_expansivity_tensor,\n        )\n        return pi\n\n    @material_property\n    def molar_isometric_heat_capacity(self):\n        \"\"\"\n        :returns: The molar heat capacity at constant strain [J/K/mol].\n        :rtype: float\n        \"\"\"\n        alpha = self.thermal_expansivity_tensor\n        pi = self.thermal_stress_tensor\n        C_isometric = (\n            self.molar_heat_capacity_p\n            + self.V * self.temperature * np.einsum(\"ij, ij\", alpha, pi)\n        )\n        return C_isometric\n\n    def check_standard_parameters(self, anisotropic_parameters):\n        if not np.all(anisotropic_parameters[:, :, 0, 0] == 0):\n            raise Exception(\n                \"anisotropic_parameters_pqmn should be set to \" \"zero for all m = n = 0\"\n            )\n\n        sum_ijij_block = np.sum(anisotropic_parameters[:3, :3, :, :], axis=(0, 1))\n\n        if np.abs(sum_ijij_block[1, 0] - 1.0) > 1.0e-5:\n            raise Exception(\n                \"The sum of the upper 3x3 pq-block of \"\n                \"anisotropic_parameters_pqmn must equal \"\n                \"1 for m=1, n=0 for consistency with the volume. \"\n                f\"Value is {sum_ijij_block[1, 0]}\"\n            )\n\n        for m in range(2, len(sum_ijij_block)):\n            if np.abs(sum_ijij_block[m, 0]) > 1.0e-10:\n                raise Exception(\n                    \"The sum of the upper 3x3 pq-block of \"\n                    \"anisotropic_parameters_pqmn must equal 0 for\"\n                    f\"m={m}, n=0 for consistency with the volume. \"\n                    f\"Value is {sum_ijij_block[m, 0]}\"\n                )\n\n        for m in range(len(sum_ijij_block)):\n            for n in range(1, len(sum_ijij_block[0])):\n                if np.abs(sum_ijij_block[m, n]) > 1.0e-10:\n                    raise Exception(\n                        \"The sum of the upper 3x3 pq-block of \"\n                        \"anisotropic_parameters_pqmn must equal \"\n                        f\"0 for m={m}, n={n} for \"\n                        \"consistency with the volume. \"\n                        f\"Value is {sum_ijij_block[m, n]}\"\n                    )\n\n        if cond(anisotropic_parameters[:, :, 1, 0]) > 1 / np.finfo(float).eps:\n            raise Exception(\"anisotropic_parameters[:, :, 1, 0] is singular\")\n\n        sum_lower_left_block = np.sum(anisotropic_parameters[3:, :3, :, :], axis=1)\n\n        self.orthotropic = True\n        for i, s in enumerate(sum_lower_left_block):\n            if not np.all(np.abs(s) < 1.0e-10):\n                self.orthotropic = False",
  "def __init__(\n        self,\n        isotropic_mineral,\n        cell_parameters,\n        anisotropic_parameters,\n        psi_function=None,\n        orthotropic=None,\n    ):\n        if psi_function is None:\n            self.check_standard_parameters(anisotropic_parameters)\n            self.anisotropic_params = {\"c\": anisotropic_parameters}\n            self.psi_function = self.standard_psi_function\n        else:\n            if not isinstance(orthotropic, bool):\n                raise Exception(\n                    \"If the Psi function is provided, \"\n                    \"you must specify whether your material is \"\n                    \"orthotropic as a boolean.\"\n                )\n            self.orthotropic = orthotropic\n            self.anisotropic_params = anisotropic_parameters\n            self.psi_function = psi_function\n\n        self.cell_vectors_0 = cell_parameters_to_vectors(cell_parameters)\n\n        if (\n            np.abs(np.linalg.det(self.cell_vectors_0) - isotropic_mineral.params[\"V_0\"])\n            > np.finfo(float).eps\n        ):\n            factor = np.cbrt(\n                isotropic_mineral.params[\"V_0\"] / np.linalg.det(self.cell_vectors_0)\n            )\n            raise Exception(\n                \"The standard state unit vectors are inconsistent \"\n                \"with the volume. Suggest multiplying each \"\n                f\"by {factor}.\"\n            )\n\n        # Note, Psi_0 may be asymmetric, in which case the Voigt contraction\n        # cannot be applied\n        self.Psi_0 = np.einsum(\"ij, kl\", logm(self.cell_vectors_0), np.eye(3) / 3.0)\n\n        self.isotropic_mineral = isotropic_mineral\n        if \"name\" in isotropic_mineral.params:\n            self.name = isotropic_mineral.params[\"name\"]\n\n        Mineral.__init__(\n            self, isotropic_mineral.params, isotropic_mineral.property_modifiers\n        )",
  "def standard_psi_function(self, f, Pth, params):\n        # Compute Psi, dPsidPth, dPsidf, needed by most anisotropic properties\n        c = params[\"c\"]\n        ns = np.arange(c.shape[-1])\n        x = c[:, :, 0, :] + c[:, :, 1, :] * f\n        dPsidf = c[:, :, 1, :]\n\n        for i in list(range(2, c.shape[2])):\n            # non-intuitively, the += operator doesn't simply add in-place,\n            # so here we overwrite the arrays with new ones\n            x = x + c[:, :, i, :] * np.power(f, float(i)) / float(i)\n            dPsidf = dPsidf + c[:, :, i, :] * np.power(f, float(i) - 1.0)\n\n        Psi = np.einsum(\"ikn, n->ik\", x, np.power(Pth, ns))\n\n        dPsidPth = np.einsum(\n            \"ikn, n->ik\", x[:, :, 1:], ns[1:] * np.power(Pth, ns[1:] - 1)\n        )\n\n        dPsidf = np.einsum(\"ikn, n->ik\", dPsidf, np.power(Pth, ns))\n        return (Psi, dPsidf, dPsidPth)",
  "def set_state(self, pressure, temperature):\n        # 1) Compute dPthdf|T\n        # relatively large dP needed for accurate estimate of dPthdf\n\n        self.isotropic_mineral.set_state(pressure, temperature)\n        V2 = self.isotropic_mineral.V\n        KT2 = self.isotropic_mineral.K_T\n        self.isotropic_mineral.set_state_with_volume(V2, self.params[\"T_0\"])\n        P1 = self.isotropic_mineral.pressure\n        KT1 = self.isotropic_mineral.K_T\n        self.dPthdf = KT1 - KT2\n        self.Pth = pressure - P1\n\n        self.isotropic_mineral.set_state(pressure, temperature)\n        Mineral.set_state(self, pressure, temperature)\n\n        # 2) Compute other properties needed for anisotropic equation of state\n        V = self.V\n        V_0 = self.params[\"V_0\"]\n        Vrel = V / V_0\n        f = np.log(Vrel)\n        self._Vrel = Vrel\n        self._f = f\n\n        out = self.psi_function(f, self.Pth, self.anisotropic_params)\n        Psi_Voigt, self.dPsidf_Voigt, self.dPsidPth_Voigt = out\n        self.Psi = voigt_notation_to_compliance_tensor(Psi_Voigt) + self.Psi_0\n\n        # Convert to (f, T) variables\n        self.dPsidP_Voigt = -self.isothermal_compressibility_reuss * (\n            self.dPsidf_Voigt + self.dPsidPth_Voigt * self.dPthdf\n        )\n        self.dPsidT_Voigt = self.alpha * (\n            self.dPsidf_Voigt\n            + self.dPsidPth_Voigt * (self.dPthdf + self.isothermal_bulk_modulus_reuss)\n        )",
  "def deformation_gradient_tensor(self):\n        \"\"\"\n        :returns: The deformation gradient tensor describing the deformation of the\n            mineral from its undeformed state\n            (i.e. the state at the reference pressure and temperature).\n        :rtype: numpy.array (2D)\n        \"\"\"\n        F = expm(np.einsum(\"ijkl, kl\", self.Psi, np.eye(3)))\n        return F",
  "def unrotated_cell_vectors(self):\n        \"\"\"\n        :returns: The vectors of the cell [m] constructed from one mole\n            of formula units after deformation of the mineral from its\n            undeformed state (i.e. the state at the reference\n            pressure and temperature). See the documentation for the function\n            :func:`~burnman.utils.unitcell.cell_parameters_to_vectors`\n            for the assumed relationships between the cell vectors and\n            spatial coordinate axes.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return self.deformation_gradient_tensor",
  "def deformed_coordinate_frame(self):\n        \"\"\"\n        :returns: The orientations of the three spatial coordinate axes\n            after deformation of the mineral [m]. For orthotropic minerals,\n            this is equal to the identity matrix, as hydrostatic stresses only\n            induce rotations in monoclinic and triclinic crystals.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        if self.orthotropic:\n            return np.eye(3)\n        else:\n            M = self.unrotated_cell_vectors\n            Q = np.empty((3, 3))\n            Q[0] = M[0] / np.linalg.norm(M[0])\n            Q[2] = np.cross(M[0], M[1]) / np.linalg.norm(np.cross(M[0], M[1]))\n            Q[1] = np.cross(Q[2], Q[0])\n            return Q",
  "def rotation_matrix(self):\n        \"\"\"\n        :returns: The matrix required to rotate the properties of the deformed\n            mineral into the deformed coordinate frame. For orthotropic\n            minerals, this is equal to the identity matrix.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return self.deformed_coordinate_frame.T",
  "def cell_vectors(self):\n        \"\"\"\n        :returns: The vectors of the cell constructed from one mole\n            of formula units [m]. See the documentation for the function\n            :func:`~burnman.utils.unitcell.cell_parameters_to_vectors`\n            for the assumed relationships between the cell vectors and\n            spatial coordinate axes.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        if self.orthotropic:\n            return self.unrotated_cell_vectors\n        else:\n            return np.einsum(\n                \"ij, jk->ik\", self.unrotated_cell_vectors, self.rotation_matrix\n            )",
  "def cell_parameters(self):\n        \"\"\"\n        :returns: The molar cell parameters of the mineral, given in standard form:\n            [:math:`a`, :math:`b`, :math:`c`,\n            :math:`\\\\alpha`, :math:`\\\\beta`, :math:`\\\\gamma`],\n            where the first three floats are the lengths of the vectors in [m]\n            defining the cell constructed from one mole of formula units.\n            The last three floats are angles between vectors\n            (given in radians). See the documentation for the function\n            :func:`~burnman.utils.unitcell.cell_parameters_to_vectors`\n            for the assumed relationships between the cell vectors and\n            spatial coordinate axes.\n        :rtype: numpy.array (1D)\n        \"\"\"\n        return cell_vectors_to_parameters(self.cell_vectors)",
  "def shear_modulus(self):\n        \"\"\"\n        Anisotropic minerals do not (in general) have a single shear modulus.\n        This function returns a NotImplementedError. Users should instead\n        consider directly querying the elements in the\n        isothermal_stiffness_tensor or isentropic_stiffness_tensor.\n        \"\"\"\n        raise NotImplementedError(\n            \"Anisotropic minerals do not have a shear \"\n            \"modulus property. Query \"\n            \"the isentropic or isothermal stiffness \"\n            \"tensors directory, or use\"\n            \"isentropic_shear_modulus_reuss or \"\n            \"isentropic_shear_modulus_voigt.\"\n        )",
  "def isothermal_bulk_modulus(self):\n        \"\"\"\n        Anisotropic minerals do not have a single isothermal bulk modulus.\n        This function returns a NotImplementedError. Users should instead\n        consider either using isothermal_bulk_modulus_reuss,\n        isothermal_bulk_modulus_voigt,\n        or directly querying the elements in the isothermal_stiffness_tensor.\n        \"\"\"\n        raise NotImplementedError(\n            \"isothermal_bulk_modulus is not \"\n            \"sufficiently explicit for an \"\n            \"anisotropic mineral. Did you mean \"\n            \"isothermal_bulk_modulus_reuss?\"\n        )",
  "def isentropic_bulk_modulus(self):\n        \"\"\"\n        Anisotropic minerals do not have a single isentropic bulk modulus.\n        This function returns a NotImplementedError. Users should instead\n        consider either using isentropic_bulk_modulus_reuss,\n        isentropic_bulk_modulus_voigt (both derived from AnisotropicMineral),\n        or directly querying the elements in the isentropic_stiffness_tensor.\n        \"\"\"\n        raise NotImplementedError(\n            \"isentropic_bulk_modulus is not \"\n            \"sufficiently explicit for an \"\n            \"anisotropic mineral. Did you mean \"\n            \"isentropic_bulk_modulus_reuss?\"\n        )",
  "def isothermal_compressibility(self):\n        \"\"\"\n        Anisotropic minerals do not have a single isentropic compressibility.\n        This function returns a NotImplementedError. Users should instead\n        consider either using isothermal_compressibility_reuss,\n        isothermal_compressibility_voigt (both derived from AnisotropicMineral),\n        or directly querying the elements in the isothermal_compliance_tensor.\n        \"\"\"\n        raise NotImplementedError(\n            \"isothermal_compressibility is not \"\n            \"sufficiently explicit for an \"\n            \"anisotropic mineral. Did you mean \"\n            \"isothermal_compressibility_reuss?\"\n        )",
  "def isentropic_compressibility(self):\n        \"\"\"\n        Anisotropic minerals do not have a single isentropic compressibility.\n        This function returns a NotImplementedError. Users should instead\n        consider either using isentropic_compressibility_reuss,\n        isentropic_compressibility_voigt (both derived from AnisotropicMineral),\n        or directly querying the elements in the isentropic_compliance_tensor.\n        \"\"\"\n        raise NotImplementedError(\n            \"isentropic_compressibility is not \"\n            \"sufficiently explicit for an \"\n            \"anisotropic mineral. Did you mean \"\n            \"isentropic_compressibility_reuss?\"\n        )",
  "def isothermal_bulk_modulus_voigt(self):\n        \"\"\"\n        :returns: The Voigt bound on the isothermal bulk modulus in [Pa].\n        :rtype: float\n        \"\"\"\n        K = (\n            np.sum(\n                [\n                    [self.isothermal_stiffness_tensor[i][k] for k in range(3)]\n                    for i in range(3)\n                ]\n            )\n            / 9.0\n        )\n        return K",
  "def isothermal_compressibility_reuss(self):\n        \"\"\"\n        :returns: The Reuss bound on the isothermal compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus_reuss",
  "def isothermal_compressibility_voigt(self):\n        \"\"\"\n        :returns: The Voigt bound on the isothermal compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus_voigt",
  "def isentropic_compressibility_reuss(self):\n        \"\"\"\n        :returns: The Reuss bound on the isentropic compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        return 1.0 / self.isentropic_bulk_modulus_reuss",
  "def isentropic_compressibility_voigt(self):\n        \"\"\"\n        :returns: The Voigt bound on the isentropic compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        return 1.0 / self.isentropic_bulk_modulus_voigt",
  "def isothermal_compliance_tensor(self):\n        \"\"\"\n        :returns: The isothermal compliance tensor [1/Pa]\n            in Voigt form (:math:`\\\\mathbb{S}_{\\\\text{T} pq}`).\n        :rtype: numpy.array (2D)\n        \"\"\"\n        S_T = -self.dPsidP_Voigt\n        if self.orthotropic:\n            return S_T\n        else:\n            R = self.rotation_matrix\n            S = voigt_notation_to_compliance_tensor(S_T)\n            S_rotated = np.einsum(\"mi, nj, ok, pl, ijkl->mnop\", R, R, R, R, S)\n            return contract_compliances(S_rotated)",
  "def thermal_expansivity_tensor(self):\n        \"\"\"\n        :returns: The tensor of thermal expansivities [1/K].\n        :rtype: numpy.array (2D)\n        \"\"\"\n        alpha = np.einsum(\n            \"ijkl, kl\",\n            voigt_notation_to_compliance_tensor(self.dPsidT_Voigt),\n            np.eye(3),\n        )\n\n        if self.orthotropic:\n            return alpha\n        else:\n            R = self.rotation_matrix\n            return np.einsum(\"mi, nj, ij->mn\", R, R, alpha)",
  "def isothermal_stiffness_tensor(self):\n        \"\"\"\n        :returns: The isothermal stiffness tensor [Pa]\n            in Voigt form (:math:`\\\\mathbb{C}_{\\\\text{T} pq}`).\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return np.linalg.inv(self.isothermal_compliance_tensor)",
  "def full_isothermal_compliance_tensor(self):\n        \"\"\"\n        :returns: The isothermal compliance tensor [1/Pa]\n            in standard form (:math:`\\\\mathbb{S}_{\\\\text{T} ijkl}`).\n        :rtype: numpy.array (4D)\n        \"\"\"\n        S_Voigt = self.isothermal_compliance_tensor\n        return voigt_notation_to_compliance_tensor(S_Voigt)",
  "def full_isothermal_stiffness_tensor(self):\n        \"\"\"\n        :returns: The isothermal stiffness tensor [Pa]\n            in standard form (:math:`\\\\mathbb{C}_{\\\\text{T} ijkl}`).\n        :rtype: numpy.array (4D)\n        \"\"\"\n        CT = self.isothermal_stiffness_tensor\n        return voigt_notation_to_stiffness_tensor(CT)",
  "def full_isentropic_compliance_tensor(self):\n        \"\"\"\n        :returns: The isentropic compliance tensor [1/Pa]\n            in standard form (:math:`\\\\mathbb{S}_{\\\\text{N} ijkl}`).\n        :rtype: numpy.array (4D)\n        \"\"\"\n        return (\n            self.full_isothermal_compliance_tensor\n            - np.einsum(\n                \"ij, kl->ijkl\",\n                self.thermal_expansivity_tensor,\n                self.thermal_expansivity_tensor,\n            )\n            * self.V\n            * self.temperature\n            / self.C_p\n        )",
  "def isentropic_compliance_tensor(self):\n        \"\"\"\n        :returns: The isentropic compliance tensor [1/Pa]\n            in Voigt form (:math:`\\\\mathbb{S}_{\\\\text{N} pq}`).\n        :rtype: numpy.array (2D)\n        \"\"\"\n        S_full = self.full_isentropic_compliance_tensor\n        return contract_compliances(S_full)",
  "def isentropic_stiffness_tensor(self):\n        \"\"\"\n        :returns: The isentropic stiffness tensor [Pa]\n            in Voigt form (:math:`\\\\mathbb{C}_{\\\\text{N} pq}`).\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return np.linalg.inv(self.isentropic_compliance_tensor)",
  "def full_isentropic_stiffness_tensor(self):\n        \"\"\"\n        :returns: The isentropic stiffness tensor [Pa]\n            in standard form (:math:`\\\\mathbb{C}_{\\\\text{N} ijkl}`).\n        :rtype: numpy.array (4D)\n        \"\"\"\n        C_Voigt = self.isentropic_stiffness_tensor\n        return voigt_notation_to_stiffness_tensor(C_Voigt)",
  "def grueneisen_tensor(self):\n        \"\"\"\n        :returns: The grueneisen tensor [unitless].\n            This is defined by :cite:`BarronMunn1967` as\n            :math:`\\\\mathbb{C}_{\\\\text{N} ijkl} \\\\alpha_{kl} V/C_{P}`.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return (\n            np.einsum(\n                \"ijkl, kl->ij\",\n                self.full_isentropic_stiffness_tensor,\n                self.thermal_expansivity_tensor,\n            )\n            * self.molar_volume\n            / self.molar_heat_capacity_p\n        )",
  "def grueneisen_parameter(self):\n        \"\"\"\n        :returns: The scalar grueneisen parameter [unitless].\n        :rtype: float\n        \"\"\"\n        return (\n            self.thermal_expansivity\n            * self.V\n            / (self.isentropic_compressibility_reuss * self.molar_heat_capacity_p)\n        )",
  "def isothermal_compressibility_tensor(self):\n        \"\"\"\n        :returns: The isothermal compressibility tensor [1/Pa].\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return np.einsum(\n            \"ijkl, kl->ij\", self.full_isothermal_compliance_tensor, np.eye(3)\n        )",
  "def isentropic_compressibility_tensor(self):\n        \"\"\"\n        :returns: The isentropic compressibility tensor [1/Pa].\n        :rtype: numpy.array (2D)\n        \"\"\"\n        return np.einsum(\n            \"ijkl, kl->ij\", self.full_isentropic_compliance_tensor, np.eye(3)\n        )",
  "def thermal_stress_tensor(self):\n        \"\"\"\n        :returns: The change in stress with temperature at constant strain [Pa/K].\n        :rtype: numpy.array (2D)\n        \"\"\"\n        pi = -np.einsum(\n            \"ijkl, kl\",\n            self.full_isothermal_stiffness_tensor,\n            self.thermal_expansivity_tensor,\n        )\n        return pi",
  "def molar_isometric_heat_capacity(self):\n        \"\"\"\n        :returns: The molar heat capacity at constant strain [J/K/mol].\n        :rtype: float\n        \"\"\"\n        alpha = self.thermal_expansivity_tensor\n        pi = self.thermal_stress_tensor\n        C_isometric = (\n            self.molar_heat_capacity_p\n            + self.V * self.temperature * np.einsum(\"ij, ij\", alpha, pi)\n        )\n        return C_isometric",
  "def check_standard_parameters(self, anisotropic_parameters):\n        if not np.all(anisotropic_parameters[:, :, 0, 0] == 0):\n            raise Exception(\n                \"anisotropic_parameters_pqmn should be set to \" \"zero for all m = n = 0\"\n            )\n\n        sum_ijij_block = np.sum(anisotropic_parameters[:3, :3, :, :], axis=(0, 1))\n\n        if np.abs(sum_ijij_block[1, 0] - 1.0) > 1.0e-5:\n            raise Exception(\n                \"The sum of the upper 3x3 pq-block of \"\n                \"anisotropic_parameters_pqmn must equal \"\n                \"1 for m=1, n=0 for consistency with the volume. \"\n                f\"Value is {sum_ijij_block[1, 0]}\"\n            )\n\n        for m in range(2, len(sum_ijij_block)):\n            if np.abs(sum_ijij_block[m, 0]) > 1.0e-10:\n                raise Exception(\n                    \"The sum of the upper 3x3 pq-block of \"\n                    \"anisotropic_parameters_pqmn must equal 0 for\"\n                    f\"m={m}, n=0 for consistency with the volume. \"\n                    f\"Value is {sum_ijij_block[m, 0]}\"\n                )\n\n        for m in range(len(sum_ijij_block)):\n            for n in range(1, len(sum_ijij_block[0])):\n                if np.abs(sum_ijij_block[m, n]) > 1.0e-10:\n                    raise Exception(\n                        \"The sum of the upper 3x3 pq-block of \"\n                        \"anisotropic_parameters_pqmn must equal \"\n                        f\"0 for m={m}, n={n} for \"\n                        \"consistency with the volume. \"\n                        f\"Value is {sum_ijij_block[m, n]}\"\n                    )\n\n        if cond(anisotropic_parameters[:, :, 1, 0]) > 1 / np.finfo(float).eps:\n            raise Exception(\"anisotropic_parameters[:, :, 1, 0] is singular\")\n\n        sum_lower_left_block = np.sum(anisotropic_parameters[3:, :3, :, :], axis=1)\n\n        self.orthotropic = True\n        for i, s in enumerate(sum_lower_left_block):\n            if not np.all(np.abs(s) < 1.0e-10):\n                self.orthotropic = False",
  "class Seismic1DModel(object):\n    \"\"\"\n    Base class for all the seismological models.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def evaluate(self, vars_list, depth_list=None):\n        \"\"\"\n        Returns the lists of data for a Seismic1DModel for the depths provided\n\n        :param vars_list: Available variables depend on the seismic model,\n            and can be chosen from 'pressure', 'density', 'gravity',\n            'v_s', 'v_p', 'v_phi', 'G', 'K', 'QG' and 'QK'.\n        :type vars_list: array of str\n        :param depth_list: Array of depths [m] to evaluate seismic model at.\n        :type depth_list: array of floats\n\n        :returns: Array of values shapes as (len(vars_list),len(depth_list)).\n        :rtype: numpy.array\n        \"\"\"\n        if depth_list is None:\n            depth_list = self.internal_depth_list()\n        values = np.empty((len(vars_list), len(depth_list)))\n        for a in range(len(vars_list)):\n            values[a, :] = getattr(self, vars_list[a])(depth_list)\n        return values\n\n    def internal_depth_list(\n        self, mindepth=0.0, maxdepth=1.0e99, discontinuity_interval=1.0\n    ):\n        \"\"\"\n        Returns a sorted list of depths at which this seismic data is specified.\n        This allows you to compare the seismic data without interpolation.\n        The depths can be bounded by the mindepth and maxdepth parameters.\n\n        :param mindepth: Minimum depth value to be returned [m].\n        :type mindepth: float\n        :param maxdepth: Maximum depth value to be returned [m].\n        :type maxdepth: float\n        :param discontinuity_interval: Shift continuities to remove\n            ambigious values for depth [m].\n        :type discontinuity_interval: float\n\n        :returns: Depths [m].\n        :rtype: numpy.array\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")\n\n    def pressure(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Pressure(s) at given depth(s) in [Pa].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")\n\n    def v_p(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: P wave velocity at given depth(s) in [m/s].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")\n\n    def v_s(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: S wave velocity at given depth(s) in [m/s].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")\n\n    def v_phi(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Bulk sound wave velocity at given depth(s) in [m/s].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        v_s = self.v_s(depth)\n        v_p = self.v_p(depth)\n        return np.sqrt(v_p * v_p - 4.0 / 3.0 * v_s * v_s)\n\n    def density(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Density at given depth(s) in [kg/m^3].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")\n\n    def G(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Shear modulus at given depth(s) in [Pa].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        return np.power(self.v_s(depth), 2.0) * self.density(depth)\n\n    def K(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Bulk modulus at given depth(s) in [Pa]\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        return np.power(self.v_phi(depth), 2.0) * self.density(depth)\n\n    def QK(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Quality factor (dimensionless) for bulk modulus at given depth(s).\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")\n\n    def QG(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Quality factor (dimensionless) for shear modulus at given depth(s).\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")\n\n    def depth(self, pressure):\n        \"\"\"\n        :param pressure: Pressure(s) [Pa] at which to evaluate depths.\n        :type pressure: float or numpy.array of floats\n\n        :returns: Depth(s) [m] for given pressure(s).\n        :type depth: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")\n\n    def gravity(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Gravity at given depths in [m/s^2].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")",
  "class SeismicTable(Seismic1DModel):\n    \"\"\"\n    This is a base class that gets a 1D seismic model from a table indexed and\n    sorted by radius. Fill the tables in the constructor after deriving\n    from this class. This class uses :class:`burnman.seismic.Seismic1DModel`\n\n    Note: all tables need to be sorted by increasing depth.\n    self.table_depth needs to be defined. Alternatively, you can also overwrite\n    the _lookup function if you want to access with something else.\n    \"\"\"\n\n    def __init__(self):\n        Seismic1DModel.__init__(self)\n\n        self.table_depth = []\n        self.table_radius = []\n        self.table_pressure = []\n        self.table_gravity = []\n        self.table_density = []\n        self.table_vp = []\n        self.table_vs = []\n        self.table_QG = []\n        self.table_QK = []\n\n        self.earth_radius = 6371.0e3\n\n    def internal_depth_list(\n        self, mindepth=0.0, maxdepth=1.0e10, discontinuity_interval=1.0\n    ):\n        depths = np.array(\n            [\n                self.table_depth[x]\n                for x in range(len(self.table_depth))\n                if self.table_depth[x] >= mindepth and self.table_depth[x] <= maxdepth\n            ]\n        )\n        discontinuities = np.where(depths[1:] - depths[:-1] == 0)[0]\n        # Shift values at discontinities by 1 m to simplify evaluating values\n        # around these.\n        depths[discontinuities] = depths[discontinuities] - discontinuity_interval\n        depths[discontinuities + 1] = (\n            depths[discontinuities + 1] + discontinuity_interval\n        )\n        return depths\n\n    def pressure(self, depth):\n        if len(self.table_pressure) == 0:\n            warnings.warn(\n                \"Pressure is not given in \"\n                + self.__class__.__name__\n                + \" and is now being computed. This will only work when density is defined for the entire planet. Use at your own risk.\"\n            )\n            self._compute_pressure()\n        return self._lookup(depth, self.table_pressure)\n\n    def gravity(self, depth):\n        if len(self.table_gravity) == 0:\n            warnings.warn(\n                \"Gravity is not given in \"\n                + self.__class__.__name__\n                + \" and is now being computed. This will only work when density is defined for the entire planet. Use at your own risk.\"\n            )\n            self._compute_gravity()\n        return self._lookup(depth, self.table_gravity)\n\n    def v_p(self, depth):\n        return self._lookup(depth, self.table_vp)\n\n    def v_s(self, depth):\n        return self._lookup(depth, self.table_vs)\n\n    def QK(self, depth):\n        return self._lookup(depth, self.table_QK)\n\n    def QG(self, depth):\n        return self._lookup(depth, self.table_QG)\n\n    def density(self, depth):\n        if len(self.table_density) == 0:\n            raise ValueError(\"Density has not been defined for this seismic model\")\n        return self._lookup(depth, self.table_density)\n\n    def bullen(self, depth):\n        \"\"\"\n        Returns the Bullen parameter only for significant arrays\n        \"\"\"\n        assert len(depth) > 3\n        v_phi = self.v_phi(depth)\n        density = self.density(depth)\n        phi = v_phi * v_phi\n        kappa = phi * density\n        try:\n            dkappadP = np.gradient(kappa, edge_order=2) / np.gradient(\n                self.pressure(depth), edge_order=2\n            )\n            dphidz = (\n                np.gradient(phi, edge_order=2)\n                / np.gradient(depth, edge_order=2)\n                / self.gravity(depth)\n            )\n        except:\n            dkappadP = np.gradient(kappa) / np.gradient(self.pressure(depth))\n            dphidz = np.gradient(phi) / np.gradient(depth) / self.gravity(depth)\n        bullen = dkappadP - dphidz\n        return bullen\n\n    def depth(self, pressure):\n        if max(pressure) > max(self.table_pressure) or min(pressure) < min(\n            self.table_pressure\n        ):\n            raise ValueError(\"Pressure outside range of SeismicTable\")\n\n        depth = np.interp(pressure, self.table_pressure, self.table_depth)\n        return depth\n\n    def radius(self, pressure):\n        radius = np.interp(\n            pressure,\n            self.table_pressure[::-1],\n            self.earth_radius - self.table_depth[::-1],\n        )\n        return radius\n\n    def _lookup(self, depth, value_table):\n        return np.interp(depth, self.table_depth, value_table)\n\n    def _compute_gravity(self):\n        # Calculate the gravity of the planet, based on a density profile.\n        # There is a check of the surface value is within reason for this\n        # model, otherwise values for PREM are used.\n\n        density = self.table_density[::-1]\n\n        if len(density) > 0:\n            radii = self.table_radius[::-1]\n            g = scipy.integrate.cumtrapz(\n                constants.G * 4.0 * np.pi * density * radii * radii, x=radii, initial=0\n            )\n            g[1:] = g[1:] / radii[1:] / radii[1:]\n\n            self.table_gravity = g[::-1]\n        else:\n            raise ValueError(\n                \"Density profile is an empty list \" \"in this SeismicTable instance.\"\n            )\n\n    def _compute_pressure(self):\n        # Calculate the pressure profile based on density and gravity.\n        # This integrates the equation for hydrostatic equilibrium P = rho g z.\n        radii = self.table_radius\n        density = self.table_density\n        gravity = self.gravity(self.earth_radius - radii)\n\n        # convert radii to depths\n        depth = self.earth_radius - radii\n        pressure = scipy.integrate.cumtrapz(gravity * density, x=depth, initial=0.0)\n\n        self.table_pressure = pressure",
  "class PREM(SeismicTable):\n    \"\"\"\n    Reads PREM (1s) (input_seismic/prem.txt, :cite:`dziewonski1981`).\n    See also :class:`burnman.seismic.SeismicTable`.\n    \"\"\"\n\n    def __init__(self):\n        SeismicTable.__init__(self)\n        table = read_table(\"input_seismic/prem.txt\")\n        table = np.array(table)\n        self.table_depth = table[:, 0]\n        self.table_radius = table[:, 1]\n        self.table_pressure = table[:, 2]\n        self.table_density = table[:, 3]\n        self.table_vp = table[:, 4]\n        self.table_vs = table[:, 5]\n        self.table_QK = table[:, 6]\n        self.table_QG = table[:, 7]",
  "class Slow(SeismicTable):\n    \"\"\"\n    Inserts the mean profiles for slower regions in the lower mantle\n    (Lekic et al. 2012). We stitch together tables\n    'input_seismic/prem_lowermantle.txt',\n    'input_seismic/swave_slow.txt',\n    'input_seismic/pwave_slow.txt').\n    See also :class:`burnman.seismic.SeismicTable`.\n    \"\"\"\n\n    def __init__(self):\n        SeismicTable.__init__(self)\n\n        # data is: depth radius pressure density V_p V_s Q_K Q_G\n        table = read_table(\"input_seismic/prem.txt\")\n        table = np.array(table)\n        table2 = read_table(\"input_seismic/swave_slow.txt\")\n        table2 = np.array(table2)\n        table3 = read_table(\"input_seismic/pwave_slow.txt\")\n        table3 = np.array(table3)\n\n        min_radius = self.earth_radius - max(table2[:, 0])\n        max_radius = self.earth_radius - min(table2[:, 0])\n\n        table = np.array(\n            list(filter(lambda x: (x[1] >= min_radius and x[1] <= max_radius), table))\n        )\n\n        self.table_depth = table[:, 0]\n        self.table_radius = table[:, 1]\n        self.table_pressure = table[:, 2]\n        self.table_density = table[:, 3]\n        self.table_vp = np.interp(\n            self.table_depth, table3[:, 0][::-1], table3[:, 1][::-1]\n        )\n        self.table_vs = np.interp(\n            self.table_depth, table2[:, 0][::-1], table2[:, 1][::-1]\n        )",
  "class Fast(SeismicTable):\n    \"\"\"\n    Inserts the mean profiles for faster regions in the lower mantle\n    (Lekic et al. 2012). We stitch together tables\n    'input_seismic/prem_lowermantle.txt',\n    'input_seismic/swave_fast.txt',\n    'input_seismic/pwave_fast.txt').\n    See also :class:`burnman.seismic.Seismic1DModel`.\n    \"\"\"\n\n    def __init__(self):\n        SeismicTable.__init__(self)\n\n        # data is: radius pressure density V_p V_s Q_K Q_G\n        table = read_table(\"input_seismic/prem.txt\")\n        table = np.array(table)\n        table2 = read_table(\"input_seismic/swave_fast.txt\")\n        table2 = np.array(table2)\n        table3 = read_table(\"input_seismic/pwave_fast.txt\")\n        table3 = np.array(table3)\n\n        min_radius = self.earth_radius - max(table2[:, 0])\n        max_radius = self.earth_radius - min(table2[:, 0])\n\n        table = np.array(\n            list(filter(lambda x: (x[1] >= min_radius and x[1] <= max_radius), table))\n        )\n\n        self.table_depth = table[:, 0]\n        self.table_radius = table[:, 1]\n        self.table_pressure = table[:, 2]\n        self.table_density = table[:, 3]\n        self.table_vp = np.interp(\n            self.table_depth, table3[:, 0][::-1], table3[:, 1][::-1]\n        )\n        self.table_vs = np.interp(\n            self.table_depth, table2[:, 0][::-1], table2[:, 1][::-1]\n        )",
  "class STW105(SeismicTable):\n    \"\"\"\n    Reads STW05 (a.k.a. REF) (1s) (input_seismic/STW105.txt, :cite:`kustowski2008`).\n    See also :class:`burnman.seismic.SeismicTable`.\n    \"\"\"\n\n    def __init__(self):\n        SeismicTable.__init__(self)\n        # radius, pressure, density, v_p, v_s\n        table = read_table(\"input_seismic/STW105.txt\")\n        table = np.array(table)\n        self.table_radius = table[:, 0][::-1]\n        self.table_density = table[:, 1][::-1]\n        self.table_vpv = table[:, 2][::-1]\n        self.table_vsv = table[:, 3][::-1]\n        self.table_QK = table[:, 4][::-1]\n        self.table_QG = table[:, 5][::-1]\n        self.table_vph = table[:, 6][::-1]\n        self.table_vsh = table[:, 7][::-1]\n\n        self.table_depth = self.earth_radius - self.table_radius\n\n        # Voigt averages for Vs and Vp\n        self.table_vs = np.sqrt(\n            (2.0 * self.table_vsv * self.table_vsv + self.table_vsh * self.table_vsh)\n            / 3.0\n        )\n        self.table_vp = np.sqrt(\n            (self.table_vpv * self.table_vpv + 4.0 * self.table_vph * self.table_vph)\n            / 5.0\n        )",
  "class IASP91(SeismicTable):\n    \"\"\"\n    Reads REF/STW05 (input_seismic/STW105.txt, :cite:`kustowski2008`).\n    See also :class:`burnman.seismic.SeismicTable`.\n    \"\"\"\n\n    def __init__(self):\n        SeismicTable.__init__(self)\n        table = read_table(\"input_seismic/iasp91.txt\")  # depth, radius, v_p, v_s\n        table = np.array(table)\n        self.table_depth = table[:, 0]\n        self.table_radius = table[:, 1]\n        self.table_vp = table[:, 2]\n        self.table_vs = table[:, 3]",
  "class AK135(SeismicTable):\n    \"\"\"\n    Reads AK135 (input_seismic/ak135.txt, :cite:`kennett1995`).\n    See also :class:`burnman.seismic.SeismicTable`.\n    \"\"\"\n\n    def __init__(self):\n        SeismicTable.__init__(self)\n        table = read_table(\n            \"input_seismic/ak135.txt\"\n        )  # radius, pressure, density, v_p, v_s\n        table = np.array(table)\n        self.table_depth = table[:, 0]\n        self.table_radius = table[:, 1]\n        self.table_density = table[:, 2]\n        self.table_vp = table[:, 3]\n        self.table_vs = table[:, 4]\n        self.table_QG = table[:, 5]\n        self.table_QK = table[:, 6]",
  "def attenuation_correction(v_p, v_s, v_phi, Qs, Qphi):\n    \"\"\"\n    Applies the attenuation correction following Matas et al. (2007), page 4.\n    This is simplified, and there is also currently no 1D Q model implemented.\n    The correction, however, only slightly reduces the velocities,\n    and can be ignored for our current applications.\n    Arguably, it might not be as relevant when comparing computations\n    to PREM for periods of 1s as is implemented here.\n    Called from :func:`burnman.main.apply_attenuation_correction`\n\n    :param v_p: P wave velocity in [m/s].\n    :type v_p: float\n    :param v_s: S wave velocitiy in [m/s].\n    :type v_s: float\n    :param v_phi: Bulk sound velocity in [m/s].\n    :type v_phi: float\n    :param Qs: Shear quality factor [dimensionless].\n    :type Qs: float\n    :param Qphi: Bulk quality factor [dimensionless].\n    :type Qphi: float\n\n    :returns: Corrected P wave, S wave and bulk sound velocities in [m/s].\n    :rtype: tuple\n    \"\"\"\n    beta = 0.3  # Matas et al. (2007) page 4\n    Qp = 3.0 / 4.0 * pow((v_p / v_s), 2.0) * Qs  # Matas et al. (2007) page 4\n\n    cot = 1.0 / np.tan(beta * np.pi / 2.0)\n    v_p *= 1.0 - 1.0 / 2.0 * cot * 1.0 / Qp  # Matas et al. (2007) page 1\n    v_s *= 1.0 - 1.0 / 2.0 * cot * 1.0 / Qs\n    v_phi *= 1.0 - 1.0 / 2.0 * cot * 1.0 / Qphi\n    return v_p, v_s, v_phi",
  "def __init__(self):\n        pass",
  "def evaluate(self, vars_list, depth_list=None):\n        \"\"\"\n        Returns the lists of data for a Seismic1DModel for the depths provided\n\n        :param vars_list: Available variables depend on the seismic model,\n            and can be chosen from 'pressure', 'density', 'gravity',\n            'v_s', 'v_p', 'v_phi', 'G', 'K', 'QG' and 'QK'.\n        :type vars_list: array of str\n        :param depth_list: Array of depths [m] to evaluate seismic model at.\n        :type depth_list: array of floats\n\n        :returns: Array of values shapes as (len(vars_list),len(depth_list)).\n        :rtype: numpy.array\n        \"\"\"\n        if depth_list is None:\n            depth_list = self.internal_depth_list()\n        values = np.empty((len(vars_list), len(depth_list)))\n        for a in range(len(vars_list)):\n            values[a, :] = getattr(self, vars_list[a])(depth_list)\n        return values",
  "def internal_depth_list(\n        self, mindepth=0.0, maxdepth=1.0e99, discontinuity_interval=1.0\n    ):\n        \"\"\"\n        Returns a sorted list of depths at which this seismic data is specified.\n        This allows you to compare the seismic data without interpolation.\n        The depths can be bounded by the mindepth and maxdepth parameters.\n\n        :param mindepth: Minimum depth value to be returned [m].\n        :type mindepth: float\n        :param maxdepth: Maximum depth value to be returned [m].\n        :type maxdepth: float\n        :param discontinuity_interval: Shift continuities to remove\n            ambigious values for depth [m].\n        :type discontinuity_interval: float\n\n        :returns: Depths [m].\n        :rtype: numpy.array\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")",
  "def pressure(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Pressure(s) at given depth(s) in [Pa].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")",
  "def v_p(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: P wave velocity at given depth(s) in [m/s].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")",
  "def v_s(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: S wave velocity at given depth(s) in [m/s].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")",
  "def v_phi(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Bulk sound wave velocity at given depth(s) in [m/s].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        v_s = self.v_s(depth)\n        v_p = self.v_p(depth)\n        return np.sqrt(v_p * v_p - 4.0 / 3.0 * v_s * v_s)",
  "def density(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Density at given depth(s) in [kg/m^3].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")",
  "def G(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Shear modulus at given depth(s) in [Pa].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        return np.power(self.v_s(depth), 2.0) * self.density(depth)",
  "def K(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Bulk modulus at given depth(s) in [Pa]\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        return np.power(self.v_phi(depth), 2.0) * self.density(depth)",
  "def QK(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Quality factor (dimensionless) for bulk modulus at given depth(s).\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")",
  "def QG(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Quality factor (dimensionless) for shear modulus at given depth(s).\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")",
  "def depth(self, pressure):\n        \"\"\"\n        :param pressure: Pressure(s) [Pa] at which to evaluate depths.\n        :type pressure: float or numpy.array of floats\n\n        :returns: Depth(s) [m] for given pressure(s).\n        :type depth: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")",
  "def gravity(self, depth):\n        \"\"\"\n        :param depth: Depth(s) [m] at which to evaluate seismic model.\n        :type depth: float or numpy.array of floats\n\n        :returns: Gravity at given depths in [m/s^2].\n        :rtype: float or numpy.array of floats\n        \"\"\"\n        raise NotImplementedError(\"abstract method to be implemented in derived class\")",
  "def __init__(self):\n        Seismic1DModel.__init__(self)\n\n        self.table_depth = []\n        self.table_radius = []\n        self.table_pressure = []\n        self.table_gravity = []\n        self.table_density = []\n        self.table_vp = []\n        self.table_vs = []\n        self.table_QG = []\n        self.table_QK = []\n\n        self.earth_radius = 6371.0e3",
  "def internal_depth_list(\n        self, mindepth=0.0, maxdepth=1.0e10, discontinuity_interval=1.0\n    ):\n        depths = np.array(\n            [\n                self.table_depth[x]\n                for x in range(len(self.table_depth))\n                if self.table_depth[x] >= mindepth and self.table_depth[x] <= maxdepth\n            ]\n        )\n        discontinuities = np.where(depths[1:] - depths[:-1] == 0)[0]\n        # Shift values at discontinities by 1 m to simplify evaluating values\n        # around these.\n        depths[discontinuities] = depths[discontinuities] - discontinuity_interval\n        depths[discontinuities + 1] = (\n            depths[discontinuities + 1] + discontinuity_interval\n        )\n        return depths",
  "def pressure(self, depth):\n        if len(self.table_pressure) == 0:\n            warnings.warn(\n                \"Pressure is not given in \"\n                + self.__class__.__name__\n                + \" and is now being computed. This will only work when density is defined for the entire planet. Use at your own risk.\"\n            )\n            self._compute_pressure()\n        return self._lookup(depth, self.table_pressure)",
  "def gravity(self, depth):\n        if len(self.table_gravity) == 0:\n            warnings.warn(\n                \"Gravity is not given in \"\n                + self.__class__.__name__\n                + \" and is now being computed. This will only work when density is defined for the entire planet. Use at your own risk.\"\n            )\n            self._compute_gravity()\n        return self._lookup(depth, self.table_gravity)",
  "def v_p(self, depth):\n        return self._lookup(depth, self.table_vp)",
  "def v_s(self, depth):\n        return self._lookup(depth, self.table_vs)",
  "def QK(self, depth):\n        return self._lookup(depth, self.table_QK)",
  "def QG(self, depth):\n        return self._lookup(depth, self.table_QG)",
  "def density(self, depth):\n        if len(self.table_density) == 0:\n            raise ValueError(\"Density has not been defined for this seismic model\")\n        return self._lookup(depth, self.table_density)",
  "def bullen(self, depth):\n        \"\"\"\n        Returns the Bullen parameter only for significant arrays\n        \"\"\"\n        assert len(depth) > 3\n        v_phi = self.v_phi(depth)\n        density = self.density(depth)\n        phi = v_phi * v_phi\n        kappa = phi * density\n        try:\n            dkappadP = np.gradient(kappa, edge_order=2) / np.gradient(\n                self.pressure(depth), edge_order=2\n            )\n            dphidz = (\n                np.gradient(phi, edge_order=2)\n                / np.gradient(depth, edge_order=2)\n                / self.gravity(depth)\n            )\n        except:\n            dkappadP = np.gradient(kappa) / np.gradient(self.pressure(depth))\n            dphidz = np.gradient(phi) / np.gradient(depth) / self.gravity(depth)\n        bullen = dkappadP - dphidz\n        return bullen",
  "def depth(self, pressure):\n        if max(pressure) > max(self.table_pressure) or min(pressure) < min(\n            self.table_pressure\n        ):\n            raise ValueError(\"Pressure outside range of SeismicTable\")\n\n        depth = np.interp(pressure, self.table_pressure, self.table_depth)\n        return depth",
  "def radius(self, pressure):\n        radius = np.interp(\n            pressure,\n            self.table_pressure[::-1],\n            self.earth_radius - self.table_depth[::-1],\n        )\n        return radius",
  "def _lookup(self, depth, value_table):\n        return np.interp(depth, self.table_depth, value_table)",
  "def _compute_gravity(self):\n        # Calculate the gravity of the planet, based on a density profile.\n        # There is a check of the surface value is within reason for this\n        # model, otherwise values for PREM are used.\n\n        density = self.table_density[::-1]\n\n        if len(density) > 0:\n            radii = self.table_radius[::-1]\n            g = scipy.integrate.cumtrapz(\n                constants.G * 4.0 * np.pi * density * radii * radii, x=radii, initial=0\n            )\n            g[1:] = g[1:] / radii[1:] / radii[1:]\n\n            self.table_gravity = g[::-1]\n        else:\n            raise ValueError(\n                \"Density profile is an empty list \" \"in this SeismicTable instance.\"\n            )",
  "def _compute_pressure(self):\n        # Calculate the pressure profile based on density and gravity.\n        # This integrates the equation for hydrostatic equilibrium P = rho g z.\n        radii = self.table_radius\n        density = self.table_density\n        gravity = self.gravity(self.earth_radius - radii)\n\n        # convert radii to depths\n        depth = self.earth_radius - radii\n        pressure = scipy.integrate.cumtrapz(gravity * density, x=depth, initial=0.0)\n\n        self.table_pressure = pressure",
  "def __init__(self):\n        SeismicTable.__init__(self)\n        table = read_table(\"input_seismic/prem.txt\")\n        table = np.array(table)\n        self.table_depth = table[:, 0]\n        self.table_radius = table[:, 1]\n        self.table_pressure = table[:, 2]\n        self.table_density = table[:, 3]\n        self.table_vp = table[:, 4]\n        self.table_vs = table[:, 5]\n        self.table_QK = table[:, 6]\n        self.table_QG = table[:, 7]",
  "def __init__(self):\n        SeismicTable.__init__(self)\n\n        # data is: depth radius pressure density V_p V_s Q_K Q_G\n        table = read_table(\"input_seismic/prem.txt\")\n        table = np.array(table)\n        table2 = read_table(\"input_seismic/swave_slow.txt\")\n        table2 = np.array(table2)\n        table3 = read_table(\"input_seismic/pwave_slow.txt\")\n        table3 = np.array(table3)\n\n        min_radius = self.earth_radius - max(table2[:, 0])\n        max_radius = self.earth_radius - min(table2[:, 0])\n\n        table = np.array(\n            list(filter(lambda x: (x[1] >= min_radius and x[1] <= max_radius), table))\n        )\n\n        self.table_depth = table[:, 0]\n        self.table_radius = table[:, 1]\n        self.table_pressure = table[:, 2]\n        self.table_density = table[:, 3]\n        self.table_vp = np.interp(\n            self.table_depth, table3[:, 0][::-1], table3[:, 1][::-1]\n        )\n        self.table_vs = np.interp(\n            self.table_depth, table2[:, 0][::-1], table2[:, 1][::-1]\n        )",
  "def __init__(self):\n        SeismicTable.__init__(self)\n\n        # data is: radius pressure density V_p V_s Q_K Q_G\n        table = read_table(\"input_seismic/prem.txt\")\n        table = np.array(table)\n        table2 = read_table(\"input_seismic/swave_fast.txt\")\n        table2 = np.array(table2)\n        table3 = read_table(\"input_seismic/pwave_fast.txt\")\n        table3 = np.array(table3)\n\n        min_radius = self.earth_radius - max(table2[:, 0])\n        max_radius = self.earth_radius - min(table2[:, 0])\n\n        table = np.array(\n            list(filter(lambda x: (x[1] >= min_radius and x[1] <= max_radius), table))\n        )\n\n        self.table_depth = table[:, 0]\n        self.table_radius = table[:, 1]\n        self.table_pressure = table[:, 2]\n        self.table_density = table[:, 3]\n        self.table_vp = np.interp(\n            self.table_depth, table3[:, 0][::-1], table3[:, 1][::-1]\n        )\n        self.table_vs = np.interp(\n            self.table_depth, table2[:, 0][::-1], table2[:, 1][::-1]\n        )",
  "def __init__(self):\n        SeismicTable.__init__(self)\n        # radius, pressure, density, v_p, v_s\n        table = read_table(\"input_seismic/STW105.txt\")\n        table = np.array(table)\n        self.table_radius = table[:, 0][::-1]\n        self.table_density = table[:, 1][::-1]\n        self.table_vpv = table[:, 2][::-1]\n        self.table_vsv = table[:, 3][::-1]\n        self.table_QK = table[:, 4][::-1]\n        self.table_QG = table[:, 5][::-1]\n        self.table_vph = table[:, 6][::-1]\n        self.table_vsh = table[:, 7][::-1]\n\n        self.table_depth = self.earth_radius - self.table_radius\n\n        # Voigt averages for Vs and Vp\n        self.table_vs = np.sqrt(\n            (2.0 * self.table_vsv * self.table_vsv + self.table_vsh * self.table_vsh)\n            / 3.0\n        )\n        self.table_vp = np.sqrt(\n            (self.table_vpv * self.table_vpv + 4.0 * self.table_vph * self.table_vph)\n            / 5.0\n        )",
  "def __init__(self):\n        SeismicTable.__init__(self)\n        table = read_table(\"input_seismic/iasp91.txt\")  # depth, radius, v_p, v_s\n        table = np.array(table)\n        self.table_depth = table[:, 0]\n        self.table_radius = table[:, 1]\n        self.table_vp = table[:, 2]\n        self.table_vs = table[:, 3]",
  "def __init__(self):\n        SeismicTable.__init__(self)\n        table = read_table(\n            \"input_seismic/ak135.txt\"\n        )  # radius, pressure, density, v_p, v_s\n        table = np.array(table)\n        self.table_depth = table[:, 0]\n        self.table_radius = table[:, 1]\n        self.table_density = table[:, 2]\n        self.table_vp = table[:, 3]\n        self.table_vs = table[:, 4]\n        self.table_QG = table[:, 5]\n        self.table_QK = table[:, 6]",
  "class CombinedMineral(Mineral):\n\n    \"\"\"\n    This is the base class for endmembers constructed from a\n    linear combination of other minerals.\n\n    Instances of this class should be initialised with a\n    list of Mineral instances, a second list containing the\n    number of moles of each mineral, and (optionally) a\n    third list containing three floats describing a\n    free energy adjustment which is linear in pressure and temperature\n    (i.e. a constant energy [J/mol], entropy [J/K/mol]\n    and volume adjustment [J/Pa/mol or m^3/mol]).\n\n    For example, a crude approximation to a bridgmanite model might be\n    bdg = CombinedMineral([per, stv], [1.0, 1.0], [-15.e3, 0., 0.])\n\n    This class is available as :class:`burnman.CombinedMineral`.\n    \"\"\"\n\n    def __init__(\n        self,\n        mineral_list,\n        molar_amounts,\n        free_energy_adjustment=[],\n        name=\"User-created endmember\",\n    ):\n        model = MechanicalSolution(endmembers=[[m, \"\"] for m in mineral_list])\n        self.mixture = Solution(solution_model=model, molar_fractions=molar_amounts)\n\n        # Remove elements from the chemical formula if they have\n        # negligible concentrations\n        for key, value in list(self.mixture.formula.items()):\n            if np.abs(value) < 1.0e-10:\n                self.mixture.formula.pop(key)\n\n        self.params = {\n            \"name\": name,\n            \"formula\": self.mixture.formula,\n            \"equation_of_state\": \"combined\",\n            \"molar_mass\": self.mixture.molar_mass,\n            \"n\": sum(self.mixture.formula.values()),\n        }\n\n        if free_energy_adjustment != []:\n            assert len(free_energy_adjustment) == 3\n            dE, dS, dV = free_energy_adjustment\n            self.property_modifiers = [\n                [\"linear\", {\"delta_E\": dE, \"delta_S\": dS, \"delta_V\": dV}]\n            ]\n\n        Mineral.__init__(self)\n\n    def set_state(self, pressure, temperature):\n        self.mixture.set_state(pressure, temperature)\n        Mineral.set_state(self, pressure, temperature)\n\n    @material_property\n    def molar_gibbs(self):\n        \"\"\"\n        Returns Gibbs free energy of the mineral [J]\n        Aliased with self.gibbs\n        \"\"\"\n        return self.mixture.molar_gibbs + self._property_modifiers[\"G\"]\n\n    @material_property\n    def _molar_volume_unmodified(self):\n        return self.mixture.molar_volume\n\n    @material_property\n    def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the mineral [m^3/mol]\n        Aliased with self.V\n        \"\"\"\n        return self.mixture.molar_volume + self._property_modifiers[\"dGdP\"]\n\n    @material_property\n    def molar_entropy(self):\n        \"\"\"\n        Returns entropy of the mineral [J]\n        Aliased with self.S\n        \"\"\"\n        return self.mixture.molar_entropy - self._property_modifiers[\"dGdT\"]\n\n    @material_property\n    def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the mineral [Pa]\n        Aliased with self.K_T\n        \"\"\"\n        K_T_orig = self.mixture.isothermal_bulk_modulus\n\n        return self.molar_volume / (\n            (self._molar_volume_unmodified / K_T_orig)\n            - self._property_modifiers[\"d2GdP2\"]\n        )\n\n    @material_property\n    def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the mineral [Pa]\n        Aliased with self.G\n        \"\"\"\n        return self.mixture.shear_modulus\n\n    @material_property\n    def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient (alpha) of the mineral [1/K]\n        Aliased with self.alpha\n        \"\"\"\n        return (\n            (self.mixture.thermal_expansivity * self._molar_volume_unmodified)\n            + self._property_modifiers[\"d2GdPdT\"]\n        ) / self.molar_volume\n\n    @material_property\n    def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns heat capacity at constant pressure of the mineral [J/K/mol]\n        Aliased with self.C_p\n        \"\"\"\n        return (\n            self.mixture.molar_heat_capacity_p\n            - self.temperature * self._property_modifiers[\"d2GdT2\"]\n        )\n\n    \"\"\"\n    Properties from mineral parameters,\n    Legendre transformations\n    or Maxwell relations\n    \"\"\"\n\n    @material_property\n    def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the mineral [kg/mol]\n        \"\"\"\n        return self.mixture.molar_mass\n\n    @material_property\n    def formula(self):\n        \"\"\"\n        Returns molar chemical formula of the mineral\n        \"\"\"\n        return self.mixture.formula\n\n    @material_property\n    def density(self):\n        \"\"\"\n        Returns density of the mineral [kg/m^3]\n        Aliased with self.rho\n        \"\"\"\n        return self.molar_mass / self.molar_volume\n\n    @material_property\n    def molar_internal_energy(self):\n        \"\"\"\n        Returns molar internal energy of the mineral [J/mol]\n        Aliased with self.energy\n        \"\"\"\n        return (\n            self.molar_gibbs\n            - self.pressure * self.molar_volume\n            + self.temperature * self.molar_entropy\n        )\n\n    @material_property\n    def molar_helmholtz(self):\n        \"\"\"\n        Returns molar Helmholtz free energy of the mineral [J/mol]\n        Aliased with self.helmholtz\n        \"\"\"\n        return self.molar_gibbs - self.pressure * self.molar_volume\n\n    @material_property\n    def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpy of the mineral [J/mol]\n        Aliased with self.H\n        \"\"\"\n        return self.molar_gibbs + self.temperature * self.molar_entropy\n\n    @material_property\n    def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns adiabatic bulk modulus of the mineral [Pa]\n        Aliased with self.K_S\n        \"\"\"\n        if self.temperature < 1.0e-10:\n            return self.isothermal_bulk_modulus\n        else:\n            return (\n                self.isothermal_bulk_modulus\n                * self.molar_heat_capacity_p\n                / self.molar_heat_capacity_v\n            )\n\n    @material_property\n    def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the mineral\n        (or inverse isothermal bulk modulus) [1/Pa]\n        Aliased with self.K_T\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus\n\n    @material_property\n    def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibility of the mineral\n        (or inverse adiabatic bulk modulus) [1/Pa]\n        Aliased with self.K_S\n        \"\"\"\n        return 1.0 / self.adiabatic_bulk_modulus\n\n    @material_property\n    def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the mineral [m/s]\n        Aliased with self.v_p\n        \"\"\"\n        return np.sqrt(\n            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)\n            / self.density\n        )\n\n    @material_property\n    def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the mineral [m/s]\n        Aliased with self.v_phi\n        \"\"\"\n        return np.sqrt(self.adiabatic_bulk_modulus / self.density)\n\n    @material_property\n    def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the mineral [m/s]\n        Aliased with self.v_s\n        \"\"\"\n        return np.sqrt(self.shear_modulus / self.density)\n\n    @material_property\n    def grueneisen_parameter(self):\n        \"\"\"\n        Returns grueneisen parameter of the mineral [unitless]\n        Aliased with self.gr\n        \"\"\"\n        if self.temperature < 1.0e-12:\n            return 0.0\n        else:\n            return (\n                self.thermal_expansivity\n                * self.isothermal_bulk_modulus\n                * self.molar_volume\n                / self.molar_heat_capacity_v\n            )\n\n    @material_property\n    def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volume of the mineral [J/K/mol]\n        Aliased with self.C_v\n        \"\"\"\n        return (\n            self.molar_heat_capacity_p\n            - self.molar_volume\n            * self.temperature\n            * self.thermal_expansivity\n            * self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n        )",
  "def __init__(\n        self,\n        mineral_list,\n        molar_amounts,\n        free_energy_adjustment=[],\n        name=\"User-created endmember\",\n    ):\n        model = MechanicalSolution(endmembers=[[m, \"\"] for m in mineral_list])\n        self.mixture = Solution(solution_model=model, molar_fractions=molar_amounts)\n\n        # Remove elements from the chemical formula if they have\n        # negligible concentrations\n        for key, value in list(self.mixture.formula.items()):\n            if np.abs(value) < 1.0e-10:\n                self.mixture.formula.pop(key)\n\n        self.params = {\n            \"name\": name,\n            \"formula\": self.mixture.formula,\n            \"equation_of_state\": \"combined\",\n            \"molar_mass\": self.mixture.molar_mass,\n            \"n\": sum(self.mixture.formula.values()),\n        }\n\n        if free_energy_adjustment != []:\n            assert len(free_energy_adjustment) == 3\n            dE, dS, dV = free_energy_adjustment\n            self.property_modifiers = [\n                [\"linear\", {\"delta_E\": dE, \"delta_S\": dS, \"delta_V\": dV}]\n            ]\n\n        Mineral.__init__(self)",
  "def set_state(self, pressure, temperature):\n        self.mixture.set_state(pressure, temperature)\n        Mineral.set_state(self, pressure, temperature)",
  "def molar_gibbs(self):\n        \"\"\"\n        Returns Gibbs free energy of the mineral [J]\n        Aliased with self.gibbs\n        \"\"\"\n        return self.mixture.molar_gibbs + self._property_modifiers[\"G\"]",
  "def _molar_volume_unmodified(self):\n        return self.mixture.molar_volume",
  "def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the mineral [m^3/mol]\n        Aliased with self.V\n        \"\"\"\n        return self.mixture.molar_volume + self._property_modifiers[\"dGdP\"]",
  "def molar_entropy(self):\n        \"\"\"\n        Returns entropy of the mineral [J]\n        Aliased with self.S\n        \"\"\"\n        return self.mixture.molar_entropy - self._property_modifiers[\"dGdT\"]",
  "def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the mineral [Pa]\n        Aliased with self.K_T\n        \"\"\"\n        K_T_orig = self.mixture.isothermal_bulk_modulus\n\n        return self.molar_volume / (\n            (self._molar_volume_unmodified / K_T_orig)\n            - self._property_modifiers[\"d2GdP2\"]\n        )",
  "def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the mineral [Pa]\n        Aliased with self.G\n        \"\"\"\n        return self.mixture.shear_modulus",
  "def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient (alpha) of the mineral [1/K]\n        Aliased with self.alpha\n        \"\"\"\n        return (\n            (self.mixture.thermal_expansivity * self._molar_volume_unmodified)\n            + self._property_modifiers[\"d2GdPdT\"]\n        ) / self.molar_volume",
  "def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns heat capacity at constant pressure of the mineral [J/K/mol]\n        Aliased with self.C_p\n        \"\"\"\n        return (\n            self.mixture.molar_heat_capacity_p\n            - self.temperature * self._property_modifiers[\"d2GdT2\"]\n        )",
  "def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the mineral [kg/mol]\n        \"\"\"\n        return self.mixture.molar_mass",
  "def formula(self):\n        \"\"\"\n        Returns molar chemical formula of the mineral\n        \"\"\"\n        return self.mixture.formula",
  "def density(self):\n        \"\"\"\n        Returns density of the mineral [kg/m^3]\n        Aliased with self.rho\n        \"\"\"\n        return self.molar_mass / self.molar_volume",
  "def molar_internal_energy(self):\n        \"\"\"\n        Returns molar internal energy of the mineral [J/mol]\n        Aliased with self.energy\n        \"\"\"\n        return (\n            self.molar_gibbs\n            - self.pressure * self.molar_volume\n            + self.temperature * self.molar_entropy\n        )",
  "def molar_helmholtz(self):\n        \"\"\"\n        Returns molar Helmholtz free energy of the mineral [J/mol]\n        Aliased with self.helmholtz\n        \"\"\"\n        return self.molar_gibbs - self.pressure * self.molar_volume",
  "def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpy of the mineral [J/mol]\n        Aliased with self.H\n        \"\"\"\n        return self.molar_gibbs + self.temperature * self.molar_entropy",
  "def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns adiabatic bulk modulus of the mineral [Pa]\n        Aliased with self.K_S\n        \"\"\"\n        if self.temperature < 1.0e-10:\n            return self.isothermal_bulk_modulus\n        else:\n            return (\n                self.isothermal_bulk_modulus\n                * self.molar_heat_capacity_p\n                / self.molar_heat_capacity_v\n            )",
  "def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the mineral\n        (or inverse isothermal bulk modulus) [1/Pa]\n        Aliased with self.K_T\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus",
  "def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibility of the mineral\n        (or inverse adiabatic bulk modulus) [1/Pa]\n        Aliased with self.K_S\n        \"\"\"\n        return 1.0 / self.adiabatic_bulk_modulus",
  "def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the mineral [m/s]\n        Aliased with self.v_p\n        \"\"\"\n        return np.sqrt(\n            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)\n            / self.density\n        )",
  "def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the mineral [m/s]\n        Aliased with self.v_phi\n        \"\"\"\n        return np.sqrt(self.adiabatic_bulk_modulus / self.density)",
  "def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the mineral [m/s]\n        Aliased with self.v_s\n        \"\"\"\n        return np.sqrt(self.shear_modulus / self.density)",
  "def grueneisen_parameter(self):\n        \"\"\"\n        Returns grueneisen parameter of the mineral [unitless]\n        Aliased with self.gr\n        \"\"\"\n        if self.temperature < 1.0e-12:\n            return 0.0\n        else:\n            return (\n                self.thermal_expansivity\n                * self.isothermal_bulk_modulus\n                * self.molar_volume\n                / self.molar_heat_capacity_v\n            )",
  "def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volume of the mineral [J/K/mol]\n        Aliased with self.C_v\n        \"\"\"\n        return (\n            self.molar_heat_capacity_p\n            - self.molar_volume\n            * self.temperature\n            * self.thermal_expansivity\n            * self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n        )",
  "class Solution(Mineral):\n    \"\"\"\n    This is the base class for all solutions.\n    Site occupancies, endmember activities and the constant\n    and pressure and temperature dependencies of the excess\n    properties can be queried after using set_composition().\n    States of the solution can only be queried after setting\n    the pressure, temperature and composition using set_state().\n\n    This class is available as :class:`burnman.Solution`.\n    It uses an instance of :class:`burnman.SolutionModel` to\n    calculate interaction terms between endmembers.\n\n    All the solution parameters are expected to be in SI units.  This\n    means that the interaction parameters should be in J/mol, with the T\n    and P derivatives in J/K/mol and m^3/mol.\n\n    The parameters are relevant to all solution models. Please\n    see the documentation for individual models for details about\n    other parameters.\n\n    :param name: Name of the solution.\n    :type name: string\n    :param solution_model: The SolutionModel object defining the properties\n        of the solution.\n    :type solution_model: :class:`burnman.SolutionModel`\n    :param molar_fractions: The molar fractions of each endmember in the solution.\n        Can be reset using the set_composition() method.\n    :type molar_fractions: numpy.array\n    \"\"\"\n\n    def __init__(self, name=None, solution_model=None, molar_fractions=None):\n        \"\"\"\n        Set up matrices to speed up calculations for when P, T, X is defined.\n        \"\"\"\n        Mineral.__init__(self)\n\n        # Solution needs a method attribute to call Mineral.set_state().\n        # Note that set_method() below will not change self.method\n        self.method = \"SolutionMethod\"\n\n        if name is not None:\n            self.name = name\n        if solution_model is not None:\n            self.solution_model = solution_model\n\n        # Equation of state\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_method(\n                self.solution_model.endmembers[i][0].params[\"equation_of_state\"]\n            )\n\n        # Molar fractions\n        if molar_fractions is not None:\n            self.set_composition(molar_fractions)\n\n    @cached_property\n    def endmembers(self):\n        return self.solution_model.endmembers\n\n    def set_composition(self, molar_fractions):\n        \"\"\"\n        Set the composition for this solution.\n        Resets cached properties.\n\n        :param molar_fractions: Molar abundance for each endmember, needs to sum to one.\n        :type molar_fractions: list of float\n        \"\"\"\n        assert len(self.solution_model.endmembers) == len(molar_fractions)\n\n        if type(self.solution_model) != MechanicalSolution:\n            assert sum(molar_fractions) > 0.9999\n            assert sum(molar_fractions) < 1.0001\n\n        if type(self.solution_model) == PolynomialSolution:\n            self.solution_model.set_composition(molar_fractions)\n\n        self.reset()\n        self.molar_fractions = np.array(molar_fractions)\n\n    def set_method(self, method):\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_method(method)\n        # note: do not set self.method here!\n        self.reset()\n\n    def set_state(self, pressure, temperature):\n        if type(self.solution_model) == PolynomialSolution:\n            self.solution_model.set_state(pressure, temperature)\n\n        Mineral.set_state(self, pressure, temperature)\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_state(pressure, temperature)\n\n    @material_property\n    def formula(self):\n        \"\"\"\n        Returns molar chemical formula of the solution.\n        :rtype: Counter\n        \"\"\"\n        return sum_formulae(self.endmember_formulae, self.molar_fractions)\n\n    @material_property\n    def site_occupancies(self):\n        \"\"\"\n        :returns: The fractional occupancies of species on each site.\n        :rtype: list of OrderedDicts\n        \"\"\"\n        occs = np.einsum(\n            \"ij, i\", self.solution_model.endmember_occupancies, self.molar_fractions\n        )\n        site_occs = []\n        k = 0\n        for i in range(self.solution_model.n_sites):\n            site_occs.append(OrderedDict())\n            for j in range(len(self.solution_model.sites[i])):\n                site_occs[-1][self.solution_model.sites[i][j]] = occs[k]\n                k += 1\n\n        return site_occs\n\n    def site_formula(self, precision=2):\n        \"\"\"\n        Returns the molar chemical formula of the solution with site occupancies.\n            For example, [Mg0.4Fe0.6]2SiO4.\n\n        :param precision: Precision with which to print the site occupancies\n        :type precision: int\n\n        :returns: Molar chemical formula of the solution with site occupancies\n        :rtype: str\n        \"\"\"\n        split_empty = self.solution_model.empty_formula.split(\"[\")\n        formula = split_empty[0]\n        for i, site_occs in enumerate(self.site_occupancies):\n            formula += \"[\"\n            for species, occ in site_occs.items():\n                formula += f\"{species}{occ:0.{precision}f}\"\n            formula += split_empty[i + 1]\n        return formula\n\n    @material_property\n    def activities(self):\n        \"\"\"\n        Returns a list of endmember activities [unitless].\n        \"\"\"\n        return self.solution_model.activities(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def activity_coefficients(self):\n        \"\"\"\n        Returns a list of endmember activity coefficients\n        (gamma = activity / ideal activity) [unitless].\n        \"\"\"\n        return self.solution_model.activity_coefficients(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def molar_internal_energy(self):\n        \"\"\"\n        Returns molar internal energy of the mineral [J/mol].\n        Aliased with self.energy\n        \"\"\"\n        return self.molar_helmholtz + self.temperature * self.molar_entropy\n\n    @material_property\n    def excess_partial_gibbs(self):\n        \"\"\"\n        Returns excess partial molar gibbs free energy [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_gibbs_free_energies(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def excess_partial_volumes(self):\n        \"\"\"\n        Returns excess partial volumes [m^3].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_volumes(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def excess_partial_entropies(self):\n        \"\"\"\n        Returns excess partial entropies [J/K].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_entropies(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def partial_gibbs(self):\n        \"\"\"\n        Returns endmember partial molar gibbs free energy [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].gibbs\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_partial_gibbs\n        )\n\n    @material_property\n    def partial_volumes(self):\n        \"\"\"\n        Returns endmember partial volumes [m^3].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].molar_volume\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_partial_volumes\n        )\n\n    @material_property\n    def partial_entropies(self):\n        \"\"\"\n        Returns endmember partial entropies [J/K].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].molar_entropy\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_partial_entropies\n        )\n\n    @material_property\n    def excess_gibbs(self):\n        \"\"\"\n        Returns molar excess gibbs free energy [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_gibbs_free_energy(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def gibbs_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the Gibbs free energy [J]. Property specific to solutions.\n        \"\"\"\n        return self.solution_model.gibbs_hessian(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def entropy_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the entropy [J/K]. Property specific to solutions.\n        \"\"\"\n        return self.solution_model.entropy_hessian(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def volume_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the volume [m^3]. Property specific to solutions.\n        \"\"\"\n        return self.solution_model.volume_hessian(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def molar_gibbs(self):\n        \"\"\"\n        Returns molar Gibbs free energy of the solution [J/mol].\n        Aliased with self.gibbs.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].gibbs * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_gibbs\n        )\n\n    @material_property\n    def molar_helmholtz(self):\n        \"\"\"\n        Returns molar Helmholtz free energy of the solution [J/mol].\n        Aliased with self.helmholtz.\n        \"\"\"\n        return self.molar_gibbs - self.pressure * self.molar_volume\n\n    @material_property\n    def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the solution [kg/mol].\n        \"\"\"\n        return sum(\n            [\n                self.solution_model.endmembers[i][0].molar_mass\n                * self.molar_fractions[i]\n                for i in range(self.n_endmembers)\n            ]\n        )\n\n    @material_property\n    def excess_volume(self):\n        \"\"\"\n        Returns excess molar volume of the solution [m^3/mol].\n        Specific property for solutions.\n        \"\"\"\n        return self.solution_model.excess_volume(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the solution [m^3/mol].\n        Aliased with self.V.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].molar_volume\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_volume\n        )\n\n    @material_property\n    def density(self):\n        \"\"\"\n        Returns density of the solution [kg/m^3].\n        Aliased with self.rho.\n        \"\"\"\n        return self.molar_mass / self.molar_volume\n\n    @material_property\n    def excess_entropy(self):\n        \"\"\"\n        Returns excess molar entropy [J/K/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_entropy(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def molar_entropy(self):\n        \"\"\"\n        Returns molar entropy of the solution [J/K/mol].\n        Aliased with self.S.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].S * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_entropy\n        )\n\n    @material_property\n    def excess_enthalpy(self):\n        \"\"\"\n        Returns excess molar enthalpy [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_enthalpy(\n            self.pressure, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpy of the solution [J/mol].\n        Aliased with self.H.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].H * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_enthalpy\n        )\n\n    @material_property\n    def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the solution [Pa].\n        Aliased with self.K_T.\n        \"\"\"\n        return (\n            self.V\n            * 1.0\n            / (\n                sum(\n                    [\n                        self.solution_model.endmembers[i][0].V\n                        / (self.solution_model.endmembers[i][0].K_T)\n                        * self.molar_fractions[i]\n                        for i in range(self.n_endmembers)\n                    ]\n                )\n                + self.solution_model.VoverKT_excess()\n            )\n        )\n\n    @material_property\n    def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns adiabatic bulk modulus of the solution [Pa].\n        Aliased with self.K_S.\n        \"\"\"\n        if self.temperature < 1e-10:\n            return self.isothermal_bulk_modulus\n        else:\n            return (\n                self.isothermal_bulk_modulus\n                * self.molar_heat_capacity_p\n                / self.molar_heat_capacity_v\n            )\n\n    @material_property\n    def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the solution.\n        (or inverse isothermal bulk modulus) [1/Pa].\n        Aliased with self.K_T.\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus\n\n    @material_property\n    def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibility of the solution.\n        (or inverse adiabatic bulk modulus) [1/Pa].\n        Aliased with self.K_S.\n        \"\"\"\n        return 1.0 / self.adiabatic_bulk_modulus\n\n    @material_property\n    def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the solution [Pa].\n        Aliased with self.G.\n        \"\"\"\n        G_list = np.fromiter(\n            (e[0].G for e in self.solution_model.endmembers),\n            dtype=float,\n            count=self.n_endmembers,\n        )\n        return reuss_average_function(self.molar_fractions, G_list)\n\n    @material_property\n    def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the solution [m/s].\n        Aliased with self.v_p.\n        \"\"\"\n        return np.sqrt(\n            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)\n            / self.density\n        )\n\n    @material_property\n    def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the solution [m/s].\n        Aliased with self.v_phi.\n        \"\"\"\n        return np.sqrt(self.adiabatic_bulk_modulus / self.density)\n\n    @material_property\n    def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the solution [m/s].\n        Aliased with self.v_s.\n        \"\"\"\n        return np.sqrt(self.shear_modulus / self.density)\n\n    @material_property\n    def grueneisen_parameter(self):\n        \"\"\"\n        Returns grueneisen parameter of the solution [unitless].\n        Aliased with self.gr.\n        \"\"\"\n        if self.temperature < 1e-10:\n            return float(\"nan\")\n        else:\n            return (\n                self.thermal_expansivity\n                * self.isothermal_bulk_modulus\n                * self.molar_volume\n                / self.molar_heat_capacity_v\n            )\n\n    @material_property\n    def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient (alpha)\n        of the solution [1/K].\n        Aliased with self.alpha.\n        \"\"\"\n        return (1.0 / self.V) * (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].alpha\n                    * self.solution_model.endmembers[i][0].V\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.solution_model.alphaV_excess()\n        )\n\n    @material_property\n    def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volume of the\n        solution [J/K/mol].\n        Aliased with self.C_v.\n        \"\"\"\n        return (\n            self.molar_heat_capacity_p\n            - self.molar_volume\n            * self.temperature\n            * self.thermal_expansivity\n            * self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n        )\n\n    @material_property\n    def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar heat capacity at constant pressure\n        of the solution [J/K/mol].\n        Aliased with self.C_p.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].molar_heat_capacity_p\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.solution_model.Cp_excess()\n        )\n\n    @cached_property\n    def stoichiometric_matrix(self):\n        \"\"\"\n        A sympy Matrix where each element M[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n\n        def f(i, j):\n            e = self.elements[j]\n            if e in self.endmember_formulae[i]:\n                return nsimplify(self.endmember_formulae[i][e])\n            else:\n                return 0\n\n        return Matrix(len(self.endmember_formulae), len(self.elements), f)\n\n    @cached_property\n    def stoichiometric_array(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n        return np.array(self.stoichiometric_matrix)\n\n    @cached_property\n    def reaction_basis(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of moles of endmember[j] involved in reaction[i].\n        \"\"\"\n        reaction_basis = np.array(\n            [v[:] for v in self.stoichiometric_matrix.T.nullspace()]\n        )\n\n        if len(reaction_basis) == 0:\n            reaction_basis = np.empty((0, len(self.endmember_names)))\n\n        return reaction_basis\n\n    @cached_property\n    def n_reactions(self):\n        \"\"\"\n        The number of reactions in reaction_basis.\n        \"\"\"\n        return len(self.reaction_basis[:, 0])\n\n    @cached_property\n    def independent_element_indices(self):\n        \"\"\"\n        A list of an independent set of element indices. If the amounts of\n        these elements are known (element_amounts),\n        the amounts of the other elements can be inferred by\n        -compositional_null_basis[independent_element_indices].dot(element_amounts).\n        \"\"\"\n        return sorted(independent_row_indices(self.stoichiometric_matrix.T))\n\n    @cached_property\n    def dependent_element_indices(self):\n        \"\"\"\n        The element indices not included in the independent list.\n        \"\"\"\n        return [\n            i\n            for i in range(len(self.elements))\n            if i not in self.independent_element_indices\n        ]\n\n    @cached_property\n    def compositional_null_basis(self):\n        \"\"\"\n        An array N such that N.b = 0 for all bulk compositions that can\n        be produced with a linear sum of the endmembers in the solution.\n        \"\"\"\n        null_basis = np.array([v[:] for v in self.stoichiometric_matrix.nullspace()])\n\n        M = null_basis[:, self.dependent_element_indices]\n        assert (M.shape[0] == M.shape[1]) and (M == np.eye(M.shape[0])).all()\n\n        return null_basis\n\n    @cached_property\n    def endmember_formulae(self):\n        \"\"\"\n        A list of formulae for all the endmember in the solution.\n        \"\"\"\n        return [mbr[0].params[\"formula\"] for mbr in self.solution_model.endmembers]\n\n    @cached_property\n    def endmember_names(self):\n        \"\"\"\n        A list of names for all the endmember in the solution.\n        \"\"\"\n        return [mbr[0].name for mbr in self.solution_model.endmembers]\n\n    @cached_property\n    def n_endmembers(self):\n        \"\"\"\n        The number of endmembers in the solution.\n        \"\"\"\n        return len(self.solution_model.endmembers)\n\n    @cached_property\n    def elements(self):\n        \"\"\"\n        A list of the elements which could be contained in the solution,\n        returned in the IUPAC element order.\n        \"\"\"\n        keys = []\n        for f in self.endmember_formulae:\n            keys.extend(f.keys())\n\n        return sort_element_list_to_IUPAC_order(set(keys))",
  "def __init__(self, name=None, solution_model=None, molar_fractions=None):\n        \"\"\"\n        Set up matrices to speed up calculations for when P, T, X is defined.\n        \"\"\"\n        Mineral.__init__(self)\n\n        # Solution needs a method attribute to call Mineral.set_state().\n        # Note that set_method() below will not change self.method\n        self.method = \"SolutionMethod\"\n\n        if name is not None:\n            self.name = name\n        if solution_model is not None:\n            self.solution_model = solution_model\n\n        # Equation of state\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_method(\n                self.solution_model.endmembers[i][0].params[\"equation_of_state\"]\n            )\n\n        # Molar fractions\n        if molar_fractions is not None:\n            self.set_composition(molar_fractions)",
  "def endmembers(self):\n        return self.solution_model.endmembers",
  "def set_composition(self, molar_fractions):\n        \"\"\"\n        Set the composition for this solution.\n        Resets cached properties.\n\n        :param molar_fractions: Molar abundance for each endmember, needs to sum to one.\n        :type molar_fractions: list of float\n        \"\"\"\n        assert len(self.solution_model.endmembers) == len(molar_fractions)\n\n        if type(self.solution_model) != MechanicalSolution:\n            assert sum(molar_fractions) > 0.9999\n            assert sum(molar_fractions) < 1.0001\n\n        if type(self.solution_model) == PolynomialSolution:\n            self.solution_model.set_composition(molar_fractions)\n\n        self.reset()\n        self.molar_fractions = np.array(molar_fractions)",
  "def set_method(self, method):\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_method(method)\n        # note: do not set self.method here!\n        self.reset()",
  "def set_state(self, pressure, temperature):\n        if type(self.solution_model) == PolynomialSolution:\n            self.solution_model.set_state(pressure, temperature)\n\n        Mineral.set_state(self, pressure, temperature)\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_state(pressure, temperature)",
  "def formula(self):\n        \"\"\"\n        Returns molar chemical formula of the solution.\n        :rtype: Counter\n        \"\"\"\n        return sum_formulae(self.endmember_formulae, self.molar_fractions)",
  "def site_occupancies(self):\n        \"\"\"\n        :returns: The fractional occupancies of species on each site.\n        :rtype: list of OrderedDicts\n        \"\"\"\n        occs = np.einsum(\n            \"ij, i\", self.solution_model.endmember_occupancies, self.molar_fractions\n        )\n        site_occs = []\n        k = 0\n        for i in range(self.solution_model.n_sites):\n            site_occs.append(OrderedDict())\n            for j in range(len(self.solution_model.sites[i])):\n                site_occs[-1][self.solution_model.sites[i][j]] = occs[k]\n                k += 1\n\n        return site_occs",
  "def site_formula(self, precision=2):\n        \"\"\"\n        Returns the molar chemical formula of the solution with site occupancies.\n            For example, [Mg0.4Fe0.6]2SiO4.\n\n        :param precision: Precision with which to print the site occupancies\n        :type precision: int\n\n        :returns: Molar chemical formula of the solution with site occupancies\n        :rtype: str\n        \"\"\"\n        split_empty = self.solution_model.empty_formula.split(\"[\")\n        formula = split_empty[0]\n        for i, site_occs in enumerate(self.site_occupancies):\n            formula += \"[\"\n            for species, occ in site_occs.items():\n                formula += f\"{species}{occ:0.{precision}f}\"\n            formula += split_empty[i + 1]\n        return formula",
  "def activities(self):\n        \"\"\"\n        Returns a list of endmember activities [unitless].\n        \"\"\"\n        return self.solution_model.activities(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def activity_coefficients(self):\n        \"\"\"\n        Returns a list of endmember activity coefficients\n        (gamma = activity / ideal activity) [unitless].\n        \"\"\"\n        return self.solution_model.activity_coefficients(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def molar_internal_energy(self):\n        \"\"\"\n        Returns molar internal energy of the mineral [J/mol].\n        Aliased with self.energy\n        \"\"\"\n        return self.molar_helmholtz + self.temperature * self.molar_entropy",
  "def excess_partial_gibbs(self):\n        \"\"\"\n        Returns excess partial molar gibbs free energy [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_gibbs_free_energies(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def excess_partial_volumes(self):\n        \"\"\"\n        Returns excess partial volumes [m^3].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_volumes(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def excess_partial_entropies(self):\n        \"\"\"\n        Returns excess partial entropies [J/K].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_entropies(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def partial_gibbs(self):\n        \"\"\"\n        Returns endmember partial molar gibbs free energy [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].gibbs\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_partial_gibbs\n        )",
  "def partial_volumes(self):\n        \"\"\"\n        Returns endmember partial volumes [m^3].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].molar_volume\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_partial_volumes\n        )",
  "def partial_entropies(self):\n        \"\"\"\n        Returns endmember partial entropies [J/K].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].molar_entropy\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_partial_entropies\n        )",
  "def excess_gibbs(self):\n        \"\"\"\n        Returns molar excess gibbs free energy [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_gibbs_free_energy(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def gibbs_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the Gibbs free energy [J]. Property specific to solutions.\n        \"\"\"\n        return self.solution_model.gibbs_hessian(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def entropy_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the entropy [J/K]. Property specific to solutions.\n        \"\"\"\n        return self.solution_model.entropy_hessian(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def volume_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the volume [m^3]. Property specific to solutions.\n        \"\"\"\n        return self.solution_model.volume_hessian(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def molar_gibbs(self):\n        \"\"\"\n        Returns molar Gibbs free energy of the solution [J/mol].\n        Aliased with self.gibbs.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].gibbs * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_gibbs\n        )",
  "def molar_helmholtz(self):\n        \"\"\"\n        Returns molar Helmholtz free energy of the solution [J/mol].\n        Aliased with self.helmholtz.\n        \"\"\"\n        return self.molar_gibbs - self.pressure * self.molar_volume",
  "def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the solution [kg/mol].\n        \"\"\"\n        return sum(\n            [\n                self.solution_model.endmembers[i][0].molar_mass\n                * self.molar_fractions[i]\n                for i in range(self.n_endmembers)\n            ]\n        )",
  "def excess_volume(self):\n        \"\"\"\n        Returns excess molar volume of the solution [m^3/mol].\n        Specific property for solutions.\n        \"\"\"\n        return self.solution_model.excess_volume(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the solution [m^3/mol].\n        Aliased with self.V.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].molar_volume\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_volume\n        )",
  "def density(self):\n        \"\"\"\n        Returns density of the solution [kg/m^3].\n        Aliased with self.rho.\n        \"\"\"\n        return self.molar_mass / self.molar_volume",
  "def excess_entropy(self):\n        \"\"\"\n        Returns excess molar entropy [J/K/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_entropy(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def molar_entropy(self):\n        \"\"\"\n        Returns molar entropy of the solution [J/K/mol].\n        Aliased with self.S.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].S * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_entropy\n        )",
  "def excess_enthalpy(self):\n        \"\"\"\n        Returns excess molar enthalpy [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_enthalpy(\n            self.pressure, self.temperature, self.molar_fractions\n        )",
  "def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpy of the solution [J/mol].\n        Aliased with self.H.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].H * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_enthalpy\n        )",
  "def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the solution [Pa].\n        Aliased with self.K_T.\n        \"\"\"\n        return (\n            self.V\n            * 1.0\n            / (\n                sum(\n                    [\n                        self.solution_model.endmembers[i][0].V\n                        / (self.solution_model.endmembers[i][0].K_T)\n                        * self.molar_fractions[i]\n                        for i in range(self.n_endmembers)\n                    ]\n                )\n                + self.solution_model.VoverKT_excess()\n            )\n        )",
  "def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns adiabatic bulk modulus of the solution [Pa].\n        Aliased with self.K_S.\n        \"\"\"\n        if self.temperature < 1e-10:\n            return self.isothermal_bulk_modulus\n        else:\n            return (\n                self.isothermal_bulk_modulus\n                * self.molar_heat_capacity_p\n                / self.molar_heat_capacity_v\n            )",
  "def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the solution.\n        (or inverse isothermal bulk modulus) [1/Pa].\n        Aliased with self.K_T.\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus",
  "def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibility of the solution.\n        (or inverse adiabatic bulk modulus) [1/Pa].\n        Aliased with self.K_S.\n        \"\"\"\n        return 1.0 / self.adiabatic_bulk_modulus",
  "def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the solution [Pa].\n        Aliased with self.G.\n        \"\"\"\n        G_list = np.fromiter(\n            (e[0].G for e in self.solution_model.endmembers),\n            dtype=float,\n            count=self.n_endmembers,\n        )\n        return reuss_average_function(self.molar_fractions, G_list)",
  "def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the solution [m/s].\n        Aliased with self.v_p.\n        \"\"\"\n        return np.sqrt(\n            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)\n            / self.density\n        )",
  "def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the solution [m/s].\n        Aliased with self.v_phi.\n        \"\"\"\n        return np.sqrt(self.adiabatic_bulk_modulus / self.density)",
  "def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the solution [m/s].\n        Aliased with self.v_s.\n        \"\"\"\n        return np.sqrt(self.shear_modulus / self.density)",
  "def grueneisen_parameter(self):\n        \"\"\"\n        Returns grueneisen parameter of the solution [unitless].\n        Aliased with self.gr.\n        \"\"\"\n        if self.temperature < 1e-10:\n            return float(\"nan\")\n        else:\n            return (\n                self.thermal_expansivity\n                * self.isothermal_bulk_modulus\n                * self.molar_volume\n                / self.molar_heat_capacity_v\n            )",
  "def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient (alpha)\n        of the solution [1/K].\n        Aliased with self.alpha.\n        \"\"\"\n        return (1.0 / self.V) * (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].alpha\n                    * self.solution_model.endmembers[i][0].V\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.solution_model.alphaV_excess()\n        )",
  "def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volume of the\n        solution [J/K/mol].\n        Aliased with self.C_v.\n        \"\"\"\n        return (\n            self.molar_heat_capacity_p\n            - self.molar_volume\n            * self.temperature\n            * self.thermal_expansivity\n            * self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n        )",
  "def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar heat capacity at constant pressure\n        of the solution [J/K/mol].\n        Aliased with self.C_p.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].molar_heat_capacity_p\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.solution_model.Cp_excess()\n        )",
  "def stoichiometric_matrix(self):\n        \"\"\"\n        A sympy Matrix where each element M[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n\n        def f(i, j):\n            e = self.elements[j]\n            if e in self.endmember_formulae[i]:\n                return nsimplify(self.endmember_formulae[i][e])\n            else:\n                return 0\n\n        return Matrix(len(self.endmember_formulae), len(self.elements), f)",
  "def stoichiometric_array(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n        return np.array(self.stoichiometric_matrix)",
  "def reaction_basis(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of moles of endmember[j] involved in reaction[i].\n        \"\"\"\n        reaction_basis = np.array(\n            [v[:] for v in self.stoichiometric_matrix.T.nullspace()]\n        )\n\n        if len(reaction_basis) == 0:\n            reaction_basis = np.empty((0, len(self.endmember_names)))\n\n        return reaction_basis",
  "def n_reactions(self):\n        \"\"\"\n        The number of reactions in reaction_basis.\n        \"\"\"\n        return len(self.reaction_basis[:, 0])",
  "def independent_element_indices(self):\n        \"\"\"\n        A list of an independent set of element indices. If the amounts of\n        these elements are known (element_amounts),\n        the amounts of the other elements can be inferred by\n        -compositional_null_basis[independent_element_indices].dot(element_amounts).\n        \"\"\"\n        return sorted(independent_row_indices(self.stoichiometric_matrix.T))",
  "def dependent_element_indices(self):\n        \"\"\"\n        The element indices not included in the independent list.\n        \"\"\"\n        return [\n            i\n            for i in range(len(self.elements))\n            if i not in self.independent_element_indices\n        ]",
  "def compositional_null_basis(self):\n        \"\"\"\n        An array N such that N.b = 0 for all bulk compositions that can\n        be produced with a linear sum of the endmembers in the solution.\n        \"\"\"\n        null_basis = np.array([v[:] for v in self.stoichiometric_matrix.nullspace()])\n\n        M = null_basis[:, self.dependent_element_indices]\n        assert (M.shape[0] == M.shape[1]) and (M == np.eye(M.shape[0])).all()\n\n        return null_basis",
  "def endmember_formulae(self):\n        \"\"\"\n        A list of formulae for all the endmember in the solution.\n        \"\"\"\n        return [mbr[0].params[\"formula\"] for mbr in self.solution_model.endmembers]",
  "def endmember_names(self):\n        \"\"\"\n        A list of names for all the endmember in the solution.\n        \"\"\"\n        return [mbr[0].name for mbr in self.solution_model.endmembers]",
  "def n_endmembers(self):\n        \"\"\"\n        The number of endmembers in the solution.\n        \"\"\"\n        return len(self.solution_model.endmembers)",
  "def elements(self):\n        \"\"\"\n        A list of the elements which could be contained in the solution,\n        returned in the IUPAC element order.\n        \"\"\"\n        keys = []\n        for f in self.endmember_formulae:\n            keys.extend(f.keys())\n\n        return sort_element_list_to_IUPAC_order(set(keys))",
  "def f(i, j):\n            e = self.elements[j]\n            if e in self.endmember_formulae[i]:\n                return nsimplify(self.endmember_formulae[i][e])\n            else:\n                return 0",
  "def check_pairs(phases, fractions):\n    if len(fractions) < 1:\n        raise Exception(\"ERROR: we need at least one phase\")\n\n    if len(phases) != len(fractions):\n        raise Exception(\"ERROR: different array lengths for phases and fractions\")\n\n    total = sum(fractions)\n    if abs(total - 1.0) > 1e-10:\n        raise Exception(\"ERROR: list of molar fractions does not add up to one\")\n    for p in phases:\n        if not isinstance(p, Mineral):\n            raise Exception(\n                \"ERROR: object of type \" \"%s\" \" is not of type Mineral\" % (type(p))\n            )",
  "class Composite(Material):\n\n    \"\"\"\n    Base class for a composite material.\n    The static phases can be minerals or materials,\n    meaning composite can be nested arbitrarily.\n\n    The fractions of the phases can be input\n    as either 'molar' or 'mass' during instantiation,\n    and modified (or initialised) after this point by\n    using set_fractions.\n\n    This class is available as ``burnman.Composite``.\n    \"\"\"\n\n    def __init__(\n        self, phases, fractions=None, fraction_type=\"molar\", name=\"Unnamed composite\"\n    ):\n        \"\"\"\n        Create a composite using a list of phases and their fractions (adding to 1.0).\n\n        :param phases: List of phases.\n        :type phases: list of :class:`burnman.Material`\n        :param fractions: molar or mass fraction for each phase.\n        :type fractions: list of floats\n        :param fraction_type: 'molar' or 'mass' (optional, 'molar' as standard)\n            specify whether molar or mass fractions are specified.\n        :type fraction_type: str\n        \"\"\"\n\n        Material.__init__(self)\n\n        assert len(phases) > 0\n        self.phases = phases\n\n        if fractions is not None:\n            self.set_fractions(fractions, fraction_type)\n        else:\n            self.molar_fractions = None\n\n        self.set_averaging_scheme(\"VoigtReussHill\")\n        self.name = name\n        self.equilibrium_tolerance = 1.0e-3  # J/reaction\n        self.print_precision = 4  # number of significant figures used by self.__str__\n\n    def __str__(self):\n        string = \"Composite: {0}\".format(self.name)\n        try:\n            string += \"\\n  P, T: {0:.{sf}g} Pa, {1:.{sf}g} K\".format(\n                self.pressure, self.temperature, sf=self.print_precision\n            )\n        except:\n            pass\n        string += \"\\nPhase and endmember fractions:\"\n        for phase, fraction in zip(*self.unroll()):\n            string += \"\\n  {0}: {1:0.{sf}f}\".format(\n                phase.name, fraction, sf=self.print_precision\n            )\n            if isinstance(phase, Solution):\n                for i in range(phase.n_endmembers):\n                    string += \"\\n    {0}: {1:0.{sf}f}\".format(\n                        phase.endmember_names[i],\n                        phase.molar_fractions[i],\n                        sf=self.print_precision,\n                    )\n        return string\n\n    def set_fractions(self, fractions, fraction_type=\"molar\"):\n        \"\"\"\n        Change the fractions of the phases of this Composite.\n        Resets cached properties\n\n        :param fractions: list or numpy array of floats\n            molar or mass fraction for each phase.\n        :param fraction_type: 'molar' or 'mass'\n            specify whether molar or mass fractions are specified.\n        \"\"\"\n        assert len(self.phases) == len(fractions)\n\n        if isinstance(fractions, list):\n            fractions = np.array(fractions)\n\n        try:\n            total = sum(fractions)\n        except TypeError:\n            raise Exception(\n                \"Since v0.8, burnman.Composite takes an array of Materials, \"\n                \"then an array of fractions\"\n            )\n\n        assert np.all(fractions >= -1e-12)\n\n        self.reset()\n\n        if abs(total - 1.0) > 1e-12:\n            warnings.warn(\n                \"Warning: list of fractions does not add \"\n                f\"up to one but {total:g}. Normalizing.\"\n            )\n            fractions /= total\n\n        if fraction_type == \"molar\":\n            molar_fractions = fractions\n        elif fraction_type == \"mass\":\n            molar_fractions = self._mass_to_molar_fractions(self.phases, fractions)\n        else:\n            raise Exception(\n                \"Fraction type not recognised. \" \"Please use 'molar' or mass\"\n            )\n\n        # Set minimum value of a molar fraction at 0.0 (rather than -1.e-12)\n        self.molar_fractions = molar_fractions.clip(0.0)\n\n    def set_method(self, method):\n        \"\"\"\n        set the same equation of state method for all the phases in the composite\n        \"\"\"\n        for phase in self.phases:\n            phase.set_method(method)\n        # Clear the cache on resetting method\n        self.reset()\n\n    def set_averaging_scheme(self, averaging_scheme):\n        \"\"\"\n        Set the averaging scheme for the moduli in the composite.\n        Default is set to VoigtReussHill, when Composite is initialized.\n        \"\"\"\n\n        if type(averaging_scheme) == str:\n            self.averaging_scheme = getattr(averaging_schemes, averaging_scheme)()\n        else:\n            self.averaging_scheme = averaging_scheme\n        # Clear the cache on resetting averaging scheme\n        self.reset()\n\n    def set_state(self, pressure, temperature):\n        \"\"\"\n        Update the material to the given pressure [Pa] and temperature [K].\n        \"\"\"\n        Material.set_state(self, pressure, temperature)\n        for phase in self.phases:\n            phase.set_state(pressure, temperature)\n\n    def debug_print(self, indent=\"\"):\n        print(\"{0}Composite: {1}\".format(indent, self.name))\n        indent += \"  \"\n        if self.molar_fractions is None:\n            for i, phase in enumerate(self.phases):\n                phase.debug_print(indent + \"  \")\n        else:\n            for i, phase in enumerate(self.phases):\n                print(\"%s%g of\" % (indent, self.molar_fractions[i]))\n                phase.debug_print(indent + \"  \")\n\n    def unroll(self):\n        if self.molar_fractions is None:\n            raise Exception(\"Unroll only works if the composite has defined fractions.\")\n        phases = []\n        fractions = []\n        for i, phase in enumerate(self.phases):\n            p_mineral, p_fraction = phase.unroll()\n            check_pairs(p_mineral, p_fraction)\n            fractions.extend([f * self.molar_fractions[i] for f in p_fraction])\n            phases.extend(p_mineral)\n        return phases, fractions\n\n    def to_string(self):\n        \"\"\"\n        return the name of the composite\n        \"\"\"\n        return \"{0}: {1}\".format(self.__class__.__name__, self.name)\n\n    @material_property\n    def formula(self):\n        \"\"\"\n        Returns molar chemical formula of the composite\n        \"\"\"\n        return sum_formulae([ph.formula for ph in self.phases], self.molar_fractions)\n\n    @material_property\n    def molar_internal_energy(self):\n        \"\"\"\n        Returns molar internal energy of the mineral [J/mol]\n        Aliased with self.energy\n        \"\"\"\n        U = sum(\n            phase.molar_internal_energy * molar_fraction\n            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n        )\n        return U\n\n    @material_property\n    def molar_gibbs(self):\n        \"\"\"\n        Returns molar Gibbs free energy of the composite [J/mol]\n        Aliased with self.gibbs\n        \"\"\"\n        G = sum(\n            phase.molar_gibbs * molar_fraction\n            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n        )\n        return G\n\n    @material_property\n    def molar_helmholtz(self):\n        \"\"\"\n        Returns molar Helmholtz free energy of the mineral [J/mol]\n        Aliased with self.helmholtz\n        \"\"\"\n        F = sum(\n            phase.molar_helmholtz * molar_fraction\n            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n        )\n        return F\n\n    @material_property\n    def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the composite [m^3/mol]\n        Aliased with self.V\n        \"\"\"\n        volumes = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        return np.sum(volumes)\n\n    @material_property\n    def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the composite [kg/mol]\n        \"\"\"\n        return sum(\n            [\n                phase.molar_mass * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n\n    @material_property\n    def density(self):\n        \"\"\"\n        Compute the density of the composite based on the molar volumes and masses\n        Aliased with self.rho\n        \"\"\"\n        densities = np.array([phase.density for phase in self.phases])\n        volumes = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        return self.averaging_scheme.average_density(volumes, densities)\n\n    @material_property\n    def molar_entropy(self):\n        \"\"\"\n        Returns enthalpy of the mineral [J]\n        Aliased with self.S\n        \"\"\"\n        S = sum(\n            phase.molar_entropy * molar_fraction\n            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n        )\n        return S\n\n    @material_property\n    def molar_enthalpy(self):\n        \"\"\"\n        Returns enthalpy of the mineral [J]\n        Aliased with self.H\n        \"\"\"\n        H = sum(\n            phase.molar_enthalpy * molar_fraction\n            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n        )\n        return H\n\n    @material_property\n    def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the composite [Pa]\n        Aliased with self.K_T\n        \"\"\"\n        V_frac = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        K_ph = np.array([phase.isothermal_bulk_modulus for phase in self.phases])\n        G_ph = np.array([phase.shear_modulus for phase in self.phases])\n\n        return self.averaging_scheme.average_bulk_moduli(V_frac, K_ph, G_ph)\n\n    @material_property\n    def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns adiabatic bulk modulus of the mineral [Pa]\n        Aliased with self.K_S\n        \"\"\"\n        V_frac = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        K_ph = np.array([phase.adiabatic_bulk_modulus for phase in self.phases])\n        G_ph = np.array([phase.shear_modulus for phase in self.phases])\n\n        return self.averaging_scheme.average_bulk_moduli(V_frac, K_ph, G_ph)\n\n    @material_property\n    def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the composite\n        (or inverse isothermal bulk modulus) [1/Pa]\n        Aliased with self.beta_T\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus\n\n    @material_property\n    def adiabatic_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the composite\n        (or inverse isothermal bulk modulus) [1/Pa]\n        Aliased with self.beta_S\n        \"\"\"\n        return 1.0 / self.adiabatic_bulk_modulus\n\n    @material_property\n    def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the mineral [Pa]\n        Aliased with self.G\n        \"\"\"\n        V_frac = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        K_ph = np.array([phase.adiabatic_bulk_modulus for phase in self.phases])\n        G_ph = np.array([phase.shear_modulus for phase in self.phases])\n\n        return self.averaging_scheme.average_shear_moduli(V_frac, K_ph, G_ph)\n\n    @material_property\n    def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the composite [m/s]\n        Aliased with self.v_p\n        \"\"\"\n        return np.sqrt(\n            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)\n            / self.density\n        )\n\n    @material_property\n    def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the composite [m/s]\n        Aliased with self.v_phi\n        \"\"\"\n        return np.sqrt(self.adiabatic_bulk_modulus / self.density)\n\n    @material_property\n    def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the composite [m/s]\n        Aliased with self.v_s\n        \"\"\"\n        return np.sqrt(self.shear_modulus / self.density)\n\n    @material_property\n    def grueneisen_parameter(self):\n        \"\"\"\n        Returns grueneisen parameter of the composite [unitless]\n        Aliased with self.gr\n        \"\"\"\n        return (\n            self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n            * self.molar_volume\n            / self.molar_heat_capacity_v\n        )\n\n    @material_property\n    def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient of the composite [1/K]\n        Aliased with self.alpha\n        \"\"\"\n        volumes = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        alphas = np.array([phase.thermal_expansivity for phase in self.phases])\n        return self.averaging_scheme.average_thermal_expansivity(volumes, alphas)\n\n    @material_property\n    def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar_heat capacity at constant volume of the composite [J/K/mol]\n        Aliased with self.C_v\n        \"\"\"\n        c_v = np.array([phase.molar_heat_capacity_v for phase in self.phases])\n        return self.averaging_scheme.average_heat_capacity_v(self.molar_fractions, c_v)\n\n    @material_property\n    def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar heat capacity at constant pressure of the composite [J/K/mol]\n        Aliased with self.C_p\n        \"\"\"\n        c_p = np.array([phase.molar_heat_capacity_p for phase in self.phases])\n        return self.averaging_scheme.average_heat_capacity_p(self.molar_fractions, c_p)\n\n    @material_property\n    def endmember_partial_gibbs(self):\n        \"\"\"\n        Returns the partial Gibbs energies for all\n        the endmember minerals in the Composite\n        \"\"\"\n        partial_gibbs = np.empty(self.n_endmembers)\n        j = 0\n        for i, n_endmembers in enumerate(self.endmembers_per_phase):\n            if n_endmembers == 1:\n                partial_gibbs[j] = self.phases[i].gibbs\n            else:\n                partial_gibbs[j : j + n_endmembers] = self.phases[i].partial_gibbs\n            j += n_endmembers\n        return partial_gibbs\n\n    @material_property\n    def reaction_affinities(self):\n        \"\"\"\n        Returns the affinities corresponding to each reaction in reaction_basis\n        \"\"\"\n        return self.reaction_basis.dot(self.endmember_partial_gibbs)\n\n    @material_property\n    def equilibrated(self):\n        \"\"\"\n        Returns True if the reaction affinities are all zero\n        within a given tolerance given by self.equilibrium_tolerance.\n        \"\"\"\n        return np.all(np.abs(self.reaction_affinities) < self.equilibrium_tolerance)\n\n    def set_components(self, components):\n        \"\"\"\n        Sets the components and components_array attributes of the\n        composite material. The components attribute is a list of dictionaries\n        containing the chemical formulae of the components.\n        The components_array attribute is a 2D numpy array describing the\n        linear transformation between endmember amounts and component amounts.\n\n        The components do not need to be linearly independent, not do they need\n        to form a complete basis set for the composite.\n        However, it must be possible to obtain the composition of each\n        component from a linear sum of the endmember compositions of\n        the composite. For example, if the composite was composed of\n        MgSiO3 and Mg2SiO4, SiO2 would be a valid component, but Si would not.\n        The method raises an exception if any of the chemical potentials are\n        not defined by the assemblage.\n\n        :param components: List of formulae of the components.\n        :type components: list of dictionaries\n        \"\"\"\n        # Convert components into array form\n        b = np.array(\n            [\n                [component[el] if el in component else 0.0 for component in components]\n                for el in self.elements\n            ]\n        )\n\n        # Solve to find a set of endmember proportions that\n        # satisfy each of the component formulae\n        p = np.linalg.lstsq(self.stoichiometric_array.T, b, rcond=None)\n\n        res = np.abs((self.stoichiometric_array.T.dot(p[0]) - b).T)\n        res = np.sum(res, axis=1)\n        # Check that all components can be described by linear sums of\n        # the endmembers\n        if not np.all(res < 1.0e-12):\n            bad_indices = np.argwhere(res > 1.0e-12)\n\n            raise Exception(\n                f\"Components {bad_indices} not defined by \" \"prescribed assemblage\"\n            )\n\n        self.components = components\n        self.component_array = p[0]\n\n    def chemical_potential(self, components=None):\n        \"\"\"\n        Returns the chemical potentials of the currently defined components\n        in the composite. Raises an exception if\n        the assemblage is not equilibrated.\n\n        :param components: List of formulae of the desired components.\n            If not specified, the method uses the components specified\n            by a previous call to set_components.\n        :type components: list of dictionaries\n\n        :returns: The chemical potentials of the desired components in the\n            equilibrium composite.\n        :rtype: numpy.array of floats\n        \"\"\"\n        if not self.equilibrated:\n            raise Exception(\n                \"This composite is not equilibrated, so \"\n                \"it cannot have a defined chemical potential.\"\n            )\n\n        if components is not None:\n            self.set_components(components)\n\n        # Return the chemical potential of each component\n        return np.dot(self.component_array.T, self.endmember_partial_gibbs)\n\n    def _mass_to_molar_fractions(self, phases, mass_fractions):\n        \"\"\"\n        Converts a set of mass fractions for phases into a set of molar fractions.\n\n        :param phases: The list of phases for which fractions should be converted.\n        :type phases: list of :class:`burnman.Material`\n\n        :param mass_fractions: An array of mass fractions of the input phases.\n        :type mass_fractions: numpy.array of floats\n\n        :returns: An array of molar fractions corresponding to the\n            input molar fractions.\n        :rtype: numpy.array of floats\n        \"\"\"\n        molar_masses = np.array([phase.molar_mass for phase in phases])\n        moles = mass_fractions / molar_masses\n        return moles / sum(moles)\n\n    @cached_property\n    def stoichiometric_matrix(self):\n        \"\"\"\n        An sympy Matrix where each element M[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n\n        def f(i, j):\n            e = self.elements[j]\n            if e in self.endmember_formulae[i]:\n                return nsimplify(self.endmember_formulae[i][e])\n            else:\n                return 0\n\n        return Matrix(self.n_endmembers, self.n_elements, f)\n\n    @cached_property\n    def stoichiometric_array(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n        return np.array(self.stoichiometric_matrix).astype(float)\n\n    @cached_property\n    def reaction_basis(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of moles of endmember[j] involved in reaction[i].\n        \"\"\"\n        reaction_basis = np.array(\n            [v[:] for v in self.stoichiometric_matrix.T.nullspace()], dtype=float\n        )\n\n        if len(reaction_basis) == 0:\n            reaction_basis = np.empty((0, self.n_endmembers))\n\n        return reaction_basis\n\n    @cached_property\n    def reaction_basis_as_strings(self):\n        \"\"\"\n        Returns a list of string representations of all the reactions in\n        reaction_basis.\n        \"\"\"\n        return reaction_matrix_as_strings(self.reaction_basis, self.endmember_names)\n\n    @cached_property\n    def n_reactions(self):\n        \"\"\"\n        The number of reactions in reaction_basis.\n        \"\"\"\n        return len(self.reaction_basis[:, 0])\n\n    @cached_property\n    def independent_element_indices(self):\n        \"\"\"\n        A list of an independent set of element indices. If the amounts of\n        these elements are known (element_amounts),\n        the amounts of the other elements can be\n        inferred by\n        -compositional_null_basis[independent_element_indices].dot(element_amounts)\n        \"\"\"\n        return sorted(independent_row_indices(self.stoichiometric_matrix.T))\n\n    @cached_property\n    def dependent_element_indices(self):\n        \"\"\"\n        The element indices not included in the independent list.\n        \"\"\"\n        return [\n            i\n            for i in range(self.n_elements)\n            if i not in self.independent_element_indices\n        ]\n\n    @cached_property\n    def reduced_stoichiometric_array(self):\n        \"\"\"\n        The stoichiometric array including only the independent elements\n        \"\"\"\n        return self.stoichiometric_array[:, self.independent_element_indices]\n\n    @cached_property\n    def compositional_null_basis(self):\n        \"\"\"\n        An array N such that N.b = 0 for all bulk compositions that can\n        be produced with a linear sum of the endmembers in the composite.\n        \"\"\"\n        null_basis = np.array(\n            [v[:] for v in self.stoichiometric_matrix.nullspace()], dtype=float\n        )\n        if null_basis.shape[0] != 0:\n            M = null_basis[:, self.dependent_element_indices]\n            assert (M.shape[0] == M.shape[1]) and (M == np.eye(M.shape[0])).all()\n\n        return null_basis\n\n    @cached_property\n    def endmember_formulae(self):\n        \"\"\"\n        A list of the formulae in the composite.\n        \"\"\"\n        self._set_endmember_properties()\n        return self.__dict__[\"endmember_formulae\"]\n\n    @cached_property\n    def endmember_names(self):\n        \"\"\"\n        A list of the endmember names contained in the composite.\n        Mineral names are returned as given in Mineral.name.\n        Solution endmember names are given in the format\n        `Mineral.name in Solution.name`.\n        \"\"\"\n        self._set_endmember_properties()\n        return self.__dict__[\"endmember_names\"]\n\n    @cached_property\n    def endmembers_per_phase(self):\n        \"\"\"\n        A list of integers corresponding to the number of endmembers\n        stored within each phase.\n        \"\"\"\n        self._set_endmember_properties()\n        return self.__dict__[\"endmembers_per_phase\"]\n\n    @cached_property\n    def elements(self):\n        \"\"\"\n        A list of the elements which could be contained in the composite,\n        returned in the IUPAC element order.\n        \"\"\"\n        self._set_endmember_properties()\n        return self.__dict__[\"elements\"]\n\n    @cached_property\n    def n_endmembers(self):\n        \"\"\"\n        Returns the number of endmembers in the composite.\n        \"\"\"\n        return len(self.endmember_names)\n\n    @cached_property\n    def n_elements(self):\n        \"\"\"\n        Returns the total number of distinct elements\n        which might be in the composite.\n        \"\"\"\n        return len(self.elements)\n\n    def _set_endmember_properties(self):\n        \"\"\"\n        Sets endmember_formulae, endmember_names, endmembers_per_phase and\n        elements as properties of the Composite. This helper function\n        is used to set all properties at the same time while still allowing\n        the properties to be stored and documented as individual\n        cached_properties.\n        \"\"\"\n        endmember_formulae = []\n        endmember_names = []\n        endmembers_per_phase = []\n        for ph_idx, ph in enumerate(self.phases):\n            if isinstance(ph, Solution):\n                endmember_formulae.extend(ph.endmember_formulae)\n                endmember_names.extend(\n                    [name + \" in \" + ph.name for name in ph.endmember_names]\n                )\n                endmembers_per_phase.append(ph.n_endmembers)\n\n            elif isinstance(ph, Mineral):\n                endmember_formulae.append(ph.formula)\n                endmember_names.append(ph.name)\n                endmembers_per_phase.append(1)\n\n            else:\n                raise Exception(\n                    \"Unsupported Material type, can only read\"\n                    \"burnman.Mineral or burnman.Solution\"\n                )\n\n        # Populate the stoichiometric matrix\n        keys = []\n        for f in endmember_formulae:\n            keys.extend(f.keys())\n\n        # Save to dict so that we only need to do this once\n        self.__dict__[\"endmember_formulae\"] = endmember_formulae\n        self.__dict__[\"endmember_names\"] = endmember_names\n        self.__dict__[\"endmembers_per_phase\"] = endmembers_per_phase\n        self.__dict__[\"elements\"] = sort_element_list_to_IUPAC_order(set(keys))",
  "def __init__(\n        self, phases, fractions=None, fraction_type=\"molar\", name=\"Unnamed composite\"\n    ):\n        \"\"\"\n        Create a composite using a list of phases and their fractions (adding to 1.0).\n\n        :param phases: List of phases.\n        :type phases: list of :class:`burnman.Material`\n        :param fractions: molar or mass fraction for each phase.\n        :type fractions: list of floats\n        :param fraction_type: 'molar' or 'mass' (optional, 'molar' as standard)\n            specify whether molar or mass fractions are specified.\n        :type fraction_type: str\n        \"\"\"\n\n        Material.__init__(self)\n\n        assert len(phases) > 0\n        self.phases = phases\n\n        if fractions is not None:\n            self.set_fractions(fractions, fraction_type)\n        else:\n            self.molar_fractions = None\n\n        self.set_averaging_scheme(\"VoigtReussHill\")\n        self.name = name\n        self.equilibrium_tolerance = 1.0e-3  # J/reaction\n        self.print_precision = 4",
  "def __str__(self):\n        string = \"Composite: {0}\".format(self.name)\n        try:\n            string += \"\\n  P, T: {0:.{sf}g} Pa, {1:.{sf}g} K\".format(\n                self.pressure, self.temperature, sf=self.print_precision\n            )\n        except:\n            pass\n        string += \"\\nPhase and endmember fractions:\"\n        for phase, fraction in zip(*self.unroll()):\n            string += \"\\n  {0}: {1:0.{sf}f}\".format(\n                phase.name, fraction, sf=self.print_precision\n            )\n            if isinstance(phase, Solution):\n                for i in range(phase.n_endmembers):\n                    string += \"\\n    {0}: {1:0.{sf}f}\".format(\n                        phase.endmember_names[i],\n                        phase.molar_fractions[i],\n                        sf=self.print_precision,\n                    )\n        return string",
  "def set_fractions(self, fractions, fraction_type=\"molar\"):\n        \"\"\"\n        Change the fractions of the phases of this Composite.\n        Resets cached properties\n\n        :param fractions: list or numpy array of floats\n            molar or mass fraction for each phase.\n        :param fraction_type: 'molar' or 'mass'\n            specify whether molar or mass fractions are specified.\n        \"\"\"\n        assert len(self.phases) == len(fractions)\n\n        if isinstance(fractions, list):\n            fractions = np.array(fractions)\n\n        try:\n            total = sum(fractions)\n        except TypeError:\n            raise Exception(\n                \"Since v0.8, burnman.Composite takes an array of Materials, \"\n                \"then an array of fractions\"\n            )\n\n        assert np.all(fractions >= -1e-12)\n\n        self.reset()\n\n        if abs(total - 1.0) > 1e-12:\n            warnings.warn(\n                \"Warning: list of fractions does not add \"\n                f\"up to one but {total:g}. Normalizing.\"\n            )\n            fractions /= total\n\n        if fraction_type == \"molar\":\n            molar_fractions = fractions\n        elif fraction_type == \"mass\":\n            molar_fractions = self._mass_to_molar_fractions(self.phases, fractions)\n        else:\n            raise Exception(\n                \"Fraction type not recognised. \" \"Please use 'molar' or mass\"\n            )\n\n        # Set minimum value of a molar fraction at 0.0 (rather than -1.e-12)\n        self.molar_fractions = molar_fractions.clip(0.0)",
  "def set_method(self, method):\n        \"\"\"\n        set the same equation of state method for all the phases in the composite\n        \"\"\"\n        for phase in self.phases:\n            phase.set_method(method)\n        # Clear the cache on resetting method\n        self.reset()",
  "def set_averaging_scheme(self, averaging_scheme):\n        \"\"\"\n        Set the averaging scheme for the moduli in the composite.\n        Default is set to VoigtReussHill, when Composite is initialized.\n        \"\"\"\n\n        if type(averaging_scheme) == str:\n            self.averaging_scheme = getattr(averaging_schemes, averaging_scheme)()\n        else:\n            self.averaging_scheme = averaging_scheme\n        # Clear the cache on resetting averaging scheme\n        self.reset()",
  "def set_state(self, pressure, temperature):\n        \"\"\"\n        Update the material to the given pressure [Pa] and temperature [K].\n        \"\"\"\n        Material.set_state(self, pressure, temperature)\n        for phase in self.phases:\n            phase.set_state(pressure, temperature)",
  "def debug_print(self, indent=\"\"):\n        print(\"{0}Composite: {1}\".format(indent, self.name))\n        indent += \"  \"\n        if self.molar_fractions is None:\n            for i, phase in enumerate(self.phases):\n                phase.debug_print(indent + \"  \")\n        else:\n            for i, phase in enumerate(self.phases):\n                print(\"%s%g of\" % (indent, self.molar_fractions[i]))\n                phase.debug_print(indent + \"  \")",
  "def unroll(self):\n        if self.molar_fractions is None:\n            raise Exception(\"Unroll only works if the composite has defined fractions.\")\n        phases = []\n        fractions = []\n        for i, phase in enumerate(self.phases):\n            p_mineral, p_fraction = phase.unroll()\n            check_pairs(p_mineral, p_fraction)\n            fractions.extend([f * self.molar_fractions[i] for f in p_fraction])\n            phases.extend(p_mineral)\n        return phases, fractions",
  "def to_string(self):\n        \"\"\"\n        return the name of the composite\n        \"\"\"\n        return \"{0}: {1}\".format(self.__class__.__name__, self.name)",
  "def formula(self):\n        \"\"\"\n        Returns molar chemical formula of the composite\n        \"\"\"\n        return sum_formulae([ph.formula for ph in self.phases], self.molar_fractions)",
  "def molar_internal_energy(self):\n        \"\"\"\n        Returns molar internal energy of the mineral [J/mol]\n        Aliased with self.energy\n        \"\"\"\n        U = sum(\n            phase.molar_internal_energy * molar_fraction\n            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n        )\n        return U",
  "def molar_gibbs(self):\n        \"\"\"\n        Returns molar Gibbs free energy of the composite [J/mol]\n        Aliased with self.gibbs\n        \"\"\"\n        G = sum(\n            phase.molar_gibbs * molar_fraction\n            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n        )\n        return G",
  "def molar_helmholtz(self):\n        \"\"\"\n        Returns molar Helmholtz free energy of the mineral [J/mol]\n        Aliased with self.helmholtz\n        \"\"\"\n        F = sum(\n            phase.molar_helmholtz * molar_fraction\n            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n        )\n        return F",
  "def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the composite [m^3/mol]\n        Aliased with self.V\n        \"\"\"\n        volumes = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        return np.sum(volumes)",
  "def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the composite [kg/mol]\n        \"\"\"\n        return sum(\n            [\n                phase.molar_mass * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )",
  "def density(self):\n        \"\"\"\n        Compute the density of the composite based on the molar volumes and masses\n        Aliased with self.rho\n        \"\"\"\n        densities = np.array([phase.density for phase in self.phases])\n        volumes = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        return self.averaging_scheme.average_density(volumes, densities)",
  "def molar_entropy(self):\n        \"\"\"\n        Returns enthalpy of the mineral [J]\n        Aliased with self.S\n        \"\"\"\n        S = sum(\n            phase.molar_entropy * molar_fraction\n            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n        )\n        return S",
  "def molar_enthalpy(self):\n        \"\"\"\n        Returns enthalpy of the mineral [J]\n        Aliased with self.H\n        \"\"\"\n        H = sum(\n            phase.molar_enthalpy * molar_fraction\n            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n        )\n        return H",
  "def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the composite [Pa]\n        Aliased with self.K_T\n        \"\"\"\n        V_frac = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        K_ph = np.array([phase.isothermal_bulk_modulus for phase in self.phases])\n        G_ph = np.array([phase.shear_modulus for phase in self.phases])\n\n        return self.averaging_scheme.average_bulk_moduli(V_frac, K_ph, G_ph)",
  "def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns adiabatic bulk modulus of the mineral [Pa]\n        Aliased with self.K_S\n        \"\"\"\n        V_frac = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        K_ph = np.array([phase.adiabatic_bulk_modulus for phase in self.phases])\n        G_ph = np.array([phase.shear_modulus for phase in self.phases])\n\n        return self.averaging_scheme.average_bulk_moduli(V_frac, K_ph, G_ph)",
  "def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the composite\n        (or inverse isothermal bulk modulus) [1/Pa]\n        Aliased with self.beta_T\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus",
  "def adiabatic_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the composite\n        (or inverse isothermal bulk modulus) [1/Pa]\n        Aliased with self.beta_S\n        \"\"\"\n        return 1.0 / self.adiabatic_bulk_modulus",
  "def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the mineral [Pa]\n        Aliased with self.G\n        \"\"\"\n        V_frac = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        K_ph = np.array([phase.adiabatic_bulk_modulus for phase in self.phases])\n        G_ph = np.array([phase.shear_modulus for phase in self.phases])\n\n        return self.averaging_scheme.average_shear_moduli(V_frac, K_ph, G_ph)",
  "def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the composite [m/s]\n        Aliased with self.v_p\n        \"\"\"\n        return np.sqrt(\n            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)\n            / self.density\n        )",
  "def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the composite [m/s]\n        Aliased with self.v_phi\n        \"\"\"\n        return np.sqrt(self.adiabatic_bulk_modulus / self.density)",
  "def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the composite [m/s]\n        Aliased with self.v_s\n        \"\"\"\n        return np.sqrt(self.shear_modulus / self.density)",
  "def grueneisen_parameter(self):\n        \"\"\"\n        Returns grueneisen parameter of the composite [unitless]\n        Aliased with self.gr\n        \"\"\"\n        return (\n            self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n            * self.molar_volume\n            / self.molar_heat_capacity_v\n        )",
  "def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient of the composite [1/K]\n        Aliased with self.alpha\n        \"\"\"\n        volumes = np.array(\n            [\n                phase.molar_volume * molar_fraction\n                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)\n            ]\n        )\n        alphas = np.array([phase.thermal_expansivity for phase in self.phases])\n        return self.averaging_scheme.average_thermal_expansivity(volumes, alphas)",
  "def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar_heat capacity at constant volume of the composite [J/K/mol]\n        Aliased with self.C_v\n        \"\"\"\n        c_v = np.array([phase.molar_heat_capacity_v for phase in self.phases])\n        return self.averaging_scheme.average_heat_capacity_v(self.molar_fractions, c_v)",
  "def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar heat capacity at constant pressure of the composite [J/K/mol]\n        Aliased with self.C_p\n        \"\"\"\n        c_p = np.array([phase.molar_heat_capacity_p for phase in self.phases])\n        return self.averaging_scheme.average_heat_capacity_p(self.molar_fractions, c_p)",
  "def endmember_partial_gibbs(self):\n        \"\"\"\n        Returns the partial Gibbs energies for all\n        the endmember minerals in the Composite\n        \"\"\"\n        partial_gibbs = np.empty(self.n_endmembers)\n        j = 0\n        for i, n_endmembers in enumerate(self.endmembers_per_phase):\n            if n_endmembers == 1:\n                partial_gibbs[j] = self.phases[i].gibbs\n            else:\n                partial_gibbs[j : j + n_endmembers] = self.phases[i].partial_gibbs\n            j += n_endmembers\n        return partial_gibbs",
  "def reaction_affinities(self):\n        \"\"\"\n        Returns the affinities corresponding to each reaction in reaction_basis\n        \"\"\"\n        return self.reaction_basis.dot(self.endmember_partial_gibbs)",
  "def equilibrated(self):\n        \"\"\"\n        Returns True if the reaction affinities are all zero\n        within a given tolerance given by self.equilibrium_tolerance.\n        \"\"\"\n        return np.all(np.abs(self.reaction_affinities) < self.equilibrium_tolerance)",
  "def set_components(self, components):\n        \"\"\"\n        Sets the components and components_array attributes of the\n        composite material. The components attribute is a list of dictionaries\n        containing the chemical formulae of the components.\n        The components_array attribute is a 2D numpy array describing the\n        linear transformation between endmember amounts and component amounts.\n\n        The components do not need to be linearly independent, not do they need\n        to form a complete basis set for the composite.\n        However, it must be possible to obtain the composition of each\n        component from a linear sum of the endmember compositions of\n        the composite. For example, if the composite was composed of\n        MgSiO3 and Mg2SiO4, SiO2 would be a valid component, but Si would not.\n        The method raises an exception if any of the chemical potentials are\n        not defined by the assemblage.\n\n        :param components: List of formulae of the components.\n        :type components: list of dictionaries\n        \"\"\"\n        # Convert components into array form\n        b = np.array(\n            [\n                [component[el] if el in component else 0.0 for component in components]\n                for el in self.elements\n            ]\n        )\n\n        # Solve to find a set of endmember proportions that\n        # satisfy each of the component formulae\n        p = np.linalg.lstsq(self.stoichiometric_array.T, b, rcond=None)\n\n        res = np.abs((self.stoichiometric_array.T.dot(p[0]) - b).T)\n        res = np.sum(res, axis=1)\n        # Check that all components can be described by linear sums of\n        # the endmembers\n        if not np.all(res < 1.0e-12):\n            bad_indices = np.argwhere(res > 1.0e-12)\n\n            raise Exception(\n                f\"Components {bad_indices} not defined by \" \"prescribed assemblage\"\n            )\n\n        self.components = components\n        self.component_array = p[0]",
  "def chemical_potential(self, components=None):\n        \"\"\"\n        Returns the chemical potentials of the currently defined components\n        in the composite. Raises an exception if\n        the assemblage is not equilibrated.\n\n        :param components: List of formulae of the desired components.\n            If not specified, the method uses the components specified\n            by a previous call to set_components.\n        :type components: list of dictionaries\n\n        :returns: The chemical potentials of the desired components in the\n            equilibrium composite.\n        :rtype: numpy.array of floats\n        \"\"\"\n        if not self.equilibrated:\n            raise Exception(\n                \"This composite is not equilibrated, so \"\n                \"it cannot have a defined chemical potential.\"\n            )\n\n        if components is not None:\n            self.set_components(components)\n\n        # Return the chemical potential of each component\n        return np.dot(self.component_array.T, self.endmember_partial_gibbs)",
  "def _mass_to_molar_fractions(self, phases, mass_fractions):\n        \"\"\"\n        Converts a set of mass fractions for phases into a set of molar fractions.\n\n        :param phases: The list of phases for which fractions should be converted.\n        :type phases: list of :class:`burnman.Material`\n\n        :param mass_fractions: An array of mass fractions of the input phases.\n        :type mass_fractions: numpy.array of floats\n\n        :returns: An array of molar fractions corresponding to the\n            input molar fractions.\n        :rtype: numpy.array of floats\n        \"\"\"\n        molar_masses = np.array([phase.molar_mass for phase in phases])\n        moles = mass_fractions / molar_masses\n        return moles / sum(moles)",
  "def stoichiometric_matrix(self):\n        \"\"\"\n        An sympy Matrix where each element M[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n\n        def f(i, j):\n            e = self.elements[j]\n            if e in self.endmember_formulae[i]:\n                return nsimplify(self.endmember_formulae[i][e])\n            else:\n                return 0\n\n        return Matrix(self.n_endmembers, self.n_elements, f)",
  "def stoichiometric_array(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n        return np.array(self.stoichiometric_matrix).astype(float)",
  "def reaction_basis(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of moles of endmember[j] involved in reaction[i].\n        \"\"\"\n        reaction_basis = np.array(\n            [v[:] for v in self.stoichiometric_matrix.T.nullspace()], dtype=float\n        )\n\n        if len(reaction_basis) == 0:\n            reaction_basis = np.empty((0, self.n_endmembers))\n\n        return reaction_basis",
  "def reaction_basis_as_strings(self):\n        \"\"\"\n        Returns a list of string representations of all the reactions in\n        reaction_basis.\n        \"\"\"\n        return reaction_matrix_as_strings(self.reaction_basis, self.endmember_names)",
  "def n_reactions(self):\n        \"\"\"\n        The number of reactions in reaction_basis.\n        \"\"\"\n        return len(self.reaction_basis[:, 0])",
  "def independent_element_indices(self):\n        \"\"\"\n        A list of an independent set of element indices. If the amounts of\n        these elements are known (element_amounts),\n        the amounts of the other elements can be\n        inferred by\n        -compositional_null_basis[independent_element_indices].dot(element_amounts)\n        \"\"\"\n        return sorted(independent_row_indices(self.stoichiometric_matrix.T))",
  "def dependent_element_indices(self):\n        \"\"\"\n        The element indices not included in the independent list.\n        \"\"\"\n        return [\n            i\n            for i in range(self.n_elements)\n            if i not in self.independent_element_indices\n        ]",
  "def reduced_stoichiometric_array(self):\n        \"\"\"\n        The stoichiometric array including only the independent elements\n        \"\"\"\n        return self.stoichiometric_array[:, self.independent_element_indices]",
  "def compositional_null_basis(self):\n        \"\"\"\n        An array N such that N.b = 0 for all bulk compositions that can\n        be produced with a linear sum of the endmembers in the composite.\n        \"\"\"\n        null_basis = np.array(\n            [v[:] for v in self.stoichiometric_matrix.nullspace()], dtype=float\n        )\n        if null_basis.shape[0] != 0:\n            M = null_basis[:, self.dependent_element_indices]\n            assert (M.shape[0] == M.shape[1]) and (M == np.eye(M.shape[0])).all()\n\n        return null_basis",
  "def endmember_formulae(self):\n        \"\"\"\n        A list of the formulae in the composite.\n        \"\"\"\n        self._set_endmember_properties()\n        return self.__dict__[\"endmember_formulae\"]",
  "def endmember_names(self):\n        \"\"\"\n        A list of the endmember names contained in the composite.\n        Mineral names are returned as given in Mineral.name.\n        Solution endmember names are given in the format\n        `Mineral.name in Solution.name`.\n        \"\"\"\n        self._set_endmember_properties()\n        return self.__dict__[\"endmember_names\"]",
  "def endmembers_per_phase(self):\n        \"\"\"\n        A list of integers corresponding to the number of endmembers\n        stored within each phase.\n        \"\"\"\n        self._set_endmember_properties()\n        return self.__dict__[\"endmembers_per_phase\"]",
  "def elements(self):\n        \"\"\"\n        A list of the elements which could be contained in the composite,\n        returned in the IUPAC element order.\n        \"\"\"\n        self._set_endmember_properties()\n        return self.__dict__[\"elements\"]",
  "def n_endmembers(self):\n        \"\"\"\n        Returns the number of endmembers in the composite.\n        \"\"\"\n        return len(self.endmember_names)",
  "def n_elements(self):\n        \"\"\"\n        Returns the total number of distinct elements\n        which might be in the composite.\n        \"\"\"\n        return len(self.elements)",
  "def _set_endmember_properties(self):\n        \"\"\"\n        Sets endmember_formulae, endmember_names, endmembers_per_phase and\n        elements as properties of the Composite. This helper function\n        is used to set all properties at the same time while still allowing\n        the properties to be stored and documented as individual\n        cached_properties.\n        \"\"\"\n        endmember_formulae = []\n        endmember_names = []\n        endmembers_per_phase = []\n        for ph_idx, ph in enumerate(self.phases):\n            if isinstance(ph, Solution):\n                endmember_formulae.extend(ph.endmember_formulae)\n                endmember_names.extend(\n                    [name + \" in \" + ph.name for name in ph.endmember_names]\n                )\n                endmembers_per_phase.append(ph.n_endmembers)\n\n            elif isinstance(ph, Mineral):\n                endmember_formulae.append(ph.formula)\n                endmember_names.append(ph.name)\n                endmembers_per_phase.append(1)\n\n            else:\n                raise Exception(\n                    \"Unsupported Material type, can only read\"\n                    \"burnman.Mineral or burnman.Solution\"\n                )\n\n        # Populate the stoichiometric matrix\n        keys = []\n        for f in endmember_formulae:\n            keys.extend(f.keys())\n\n        # Save to dict so that we only need to do this once\n        self.__dict__[\"endmember_formulae\"] = endmember_formulae\n        self.__dict__[\"endmember_names\"] = endmember_names\n        self.__dict__[\"endmembers_per_phase\"] = endmembers_per_phase\n        self.__dict__[\"elements\"] = sort_element_list_to_IUPAC_order(set(keys))",
  "def f(i, j):\n            e = self.elements[j]\n            if e in self.endmember_formulae[i]:\n                return nsimplify(self.endmember_formulae[i][e])\n            else:\n                return 0",
  "class cached_property(property):\n\n    \"\"\"A decorator that converts a function into a lazy property.  The\n    function wrapped is called the first time to retrieve the result\n    and then that calculated result is used the next time you access\n    the value::\n\n        class Foo(object):\n\n            @cached_property\n            def foo(self):\n                # calculate something important here\n                return 42\n\n    The class has to have a `__dict__` in order for this property to\n    work.\n\n    This decorator is adapted slightly from the one in the werkzeug module:\n    https://tedboy.github.io/flask/_modules/werkzeug/utils.html#cached_property\n    \"\"\"\n\n    def __init__(self, func, name=None, doc=None):\n        self.__name__ = name or func.__name__\n        self.__module__ = func.__module__\n        self.__doc__ = doc or func.__doc__\n        self.func = func\n\n    def __set__(self, obj, value):\n        obj.__dict__[self.__name__] = value\n\n    def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        try:\n            value = obj.__dict__[self.__name__]\n        except KeyError:\n            value = self.func(obj)\n            obj.__dict__[self.__name__] = value\n        return value",
  "def material_property(func):\n    \"\"\"\n    Decorator @material_property to be used for cached properties of materials.\n\n    To be used on function in Material or derived classes that should be exposed\n    as read-only properties that are cached. The function Material.reset() will\n    reset the cached values.\n\n    Internally, the values are stored in a dictionary member called _cached, which\n    is emptied by .reset().\n    \"\"\"\n\n    class mat_obj:\n        def __init__(self, func):\n            self.func = func\n            self.varname = self.func.__name__\n\n        def get(self, obj):\n            if not hasattr(obj, \"_cached\"):\n                raise Exception(\n                    \"The material_property decorator could not find \"\n                    \"class member _cached. \"\n                    \"Did you forget to call Material.__init__(self) in __init___?\"\n                )\n            cache_array = getattr(obj, \"_cached\")\n            if self.varname not in cache_array:\n                cache_array[self.varname] = self.func(obj)\n            return cache_array[self.varname]\n\n    return property(mat_obj(func).get, doc=func.__doc__)",
  "class Material(object):\n\n    \"\"\"\n    Base class for all materials. The main functionality is unroll() which\n    returns a list of objects of type :class:`~burnman.Mineral` and their molar\n    fractions. This class is available as ``burnman.Material``.\n\n    The user needs to call set_method() (once in the beginning) and set_state()\n    before querying the material with unroll() or density().\n    \"\"\"\n\n    def __init__(self):\n        self._pressure = None\n        self._temperature = None\n        if not hasattr(self, \"name\"):\n            # if a derived class decides to set .name before calling this\n            # constructor (I am looking at you, SLB_2011.py!), do not\n            # overwrite the name here.\n            self._name = self.__class__.__name__\n        self._cached = {}\n\n    @property\n    def name(self):\n        \"\"\"Human-readable name of this material.\n\n        By default this will return the name of the class, but it can be set\n        to an arbitrary string. Overriden in Mineral.\n        \"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        self._name = value\n\n    def set_method(self, method):\n        \"\"\"\n        Set the averaging method. See :doc:`averaging` for details.\n\n        .. note:: Needs to be implemented in derived classes.\n        \"\"\"\n        raise NotImplementedError(\"need to implement set_method() in derived class!\")\n\n    def to_string(self):\n        \"\"\"\n        Returns a human-readable name of this material.\n        The default implementation will return the name of the class,\n        which is a reasonable default.\n\n        :returns: A human-readable name of the material.\n        :rtype: str\n        \"\"\"\n        return \"'\" + self.name + \"'\"\n\n    def debug_print(self, indent=\"\"):\n        \"\"\"\n        Print a human-readable representation of this Material.\n        \"\"\"\n        raise NotImplementedError(\n            \"Derived classes need to implement debug_print(). This is '\"\n            + self.__class__.__name__\n            + \"'\"\n        )\n\n    def print_minerals_of_current_state(self):\n        \"\"\"\n        Print a human-readable representation of this Material at the current\n        P, T as a list of minerals.\n        This requires set_state() has been called before.\n        \"\"\"\n        (minerals, fractions) = self.unroll()\n        if len(minerals) == 1:\n            print(minerals[0].to_string())\n        else:\n            print(\"Material %s:\" % self.to_string())\n            for mineral, fraction in zip(minerals, fractions):\n                print(\"  %g of phase %s\" % (fraction, mineral.to_string()))\n\n    def set_state(self, pressure, temperature):\n        \"\"\"\n        Set the material to the given pressure and temperature.\n\n        :param pressure: The desired pressure in [Pa].\n        :type pressure: float\n\n        :param temperature: The desired temperature in [K].\n        :type temperature: float\n        \"\"\"\n        if not hasattr(self, \"_pressure\"):\n            raise Exception(\n                \"Material.set_state() could not find class member _pressure. \"\n                \"Did you forget to call Material.__init__(self) in __init___?\"\n            )\n        self.reset()\n\n        self._pressure = pressure\n        self._temperature = temperature\n\n    def set_state_with_volume(\n        self, volume, temperature, pressure_guesses=[0.0e9, 10.0e9]\n    ):\n        \"\"\"\n        This function acts similarly to set_state, but takes volume and\n        temperature as input to find the pressure. In order to ensure\n        self-consistency, this function does not use any pressure functions\n        from the material classes, but instead finds the pressure using the\n        brentq root-finding method.\n\n        :param volume: The desired molar volume of the mineral [m^3].\n        :type volume: float\n\n        :param temperature: The desired temperature of the mineral [K].\n        :type temperature: float\n\n        :param pressure_guesses: A list of floats denoting the initial\n            low and high guesses for bracketing of the pressure [Pa].\n            These guesses should preferably bound the correct pressure,\n            but do not need to do so. More importantly,\n            they should not lie outside the valid region of\n            the equation of state. Defaults to [5.e9, 10.e9].\n        :type pressure_guesses: list\n        \"\"\"\n\n        def _delta_volume(pressure, volume, temperature):\n            # Try to set the state with this pressure,\n            # but if the pressure is too low most equations of state\n            # fail. In this case, treat the molar_volume as infinite\n            # and brentq will try a larger pressure.\n            try:\n                self.set_state(pressure, temperature)\n                return volume - self.molar_volume\n            except Exception:\n                return -np.inf\n\n        # we need to have a sign change in [a,b] to find a zero.\n        args = (volume, temperature)\n        try:\n            sol = bracket(_delta_volume, pressure_guesses[0], pressure_guesses[1], args)\n        except ValueError:\n            raise Exception(\n                \"Cannot find a pressure, perhaps the volume or starting pressures \"\n                \"are outside the range of validity for the equation of state?\"\n            )\n        pressure = brentq(_delta_volume, sol[0], sol[1], args=args)\n        self.set_state(pressure, temperature)\n\n    def reset(self):\n        \"\"\"\n        Resets all cached material properties.\n\n        It is typically not required for the user to call this function.\n        \"\"\"\n        self._cached = {}\n\n    def copy(self):\n        return deepcopy(self)\n\n    def unroll(self):\n        \"\"\"\n        Unroll this material into a list of :class:`burnman.Mineral` and their molar\n        fractions. All averaging schemes then operate on this list of minerals.\n        Note that the return value of this function may depend on the current\n        state (temperature, pressure).\n\n        .. note:: Needs to be implemented in derived classes.\n\n        :returns: A list of molar fractions which should sum to 1.0,\n            and a list of :class:`burnman.Mineral` objects\n            containing the minerals in the material.\n        :rtype: tuple\n        \"\"\"\n        raise NotImplementedError(\"need to implement unroll() in derived class!\")\n\n    def evaluate(self, vars_list, pressures, temperatures):\n        \"\"\"\n        Returns an array of material properties requested through a list of strings\n        at given pressure and temperature conditions.\n        At the end it resets the set_state to the original values.\n        The user needs to call set_method() before.\n\n        :param vars_list: Variables to be returned for given conditions\n        :type vars_list: list of strings\n\n        :param pressures: ndlist or ndarray of float of pressures in [Pa].\n        :type pressures: :class:`numpy.array`, n-dimensional\n\n        :param temperatures: ndlist or ndarray of float of temperatures in [K].\n        :type temperatures: :class:`numpy.array`, n-dimensional\n\n        :returns: Array returning all variables at given pressure/temperature values.\n            output[i][j] is property vars_list[j] for temperatures[i] and pressures[i].\n        :rtype: :class:`numpy.array`, n-dimensional\n        \"\"\"\n        old_pressure = self.pressure\n        old_temperature = self.temperature\n        pressures = np.array(pressures)\n        temperatures = np.array(temperatures)\n\n        assert pressures.shape == temperatures.shape\n\n        output = np.empty((len(vars_list),) + pressures.shape)\n        for i, p in np.ndenumerate(pressures):\n            self.set_state(p, temperatures[i])\n            for j in range(len(vars_list)):\n                output[(j,) + i] = getattr(self, vars_list[j])\n        if old_pressure is None or old_temperature is None:\n            # do not set_state if old values were None. Just reset to None\n            # manually\n            self._pressure = self._temperature = None\n            self.reset()\n        else:\n            self.set_state(old_pressure, old_temperature)\n\n        return output\n\n    @property\n    def pressure(self):\n        \"\"\"\n        Returns current pressure that was set with :func:`~burnman.Material.set_state`.\n\n        .. note:: Aliased with :func:`~burnman.Material.P`.\n\n        :returns: Pressure in [Pa].\n        :rtype: float\n        \"\"\"\n        return self._pressure\n\n    @property\n    def temperature(self):\n        \"\"\"\n        Returns current temperature that was set with\n        :func:`~burnman.Material.set_state`.\n\n        .. note:: Aliased with :func:`~burnman.Material.T`.\n\n        :returns: Temperature in [K].\n        :rtype: float\n        \"\"\"\n        return self._temperature\n\n    @material_property\n    def molar_internal_energy(self):\n        \"\"\"\n        Returns the molar internal energy of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.energy`.\n\n        :returns: The internal energy in [J/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement molar_internal_energy() in derived class!\"\n        )\n\n    @material_property\n    def molar_gibbs(self):\n        \"\"\"\n        Returns the molar Gibbs free energy of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.gibbs`.\n\n        :returns: Gibbs free energy in [J/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement molar_gibbs() in derived class!\")\n\n    @material_property\n    def molar_helmholtz(self):\n        \"\"\"\n        Returns the molar Helmholtz free energy of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.helmholtz`.\n\n        :returns: Helmholtz free energy in [J/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement molar_helmholtz() in derived class!\"\n        )\n\n    @material_property\n    def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n\n        :returns: Molar mass in [kg/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement molar_mass() in derived class!\")\n\n    @material_property\n    def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.V`.\n\n        :returns: Molar volume in [m^3/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement molar_volume() in derived class!\")\n\n    @material_property\n    def density(self):\n        \"\"\"\n        Returns the density of this material.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.rho`.\n\n        :returns: The density of this material in [kg/m^3].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement density() in derived class!\")\n\n    @material_property\n    def molar_entropy(self):\n        \"\"\"\n        Returns molar entropy of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.S`.\n\n        :returns: Entropy in [J/K/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement molar_entropy() in derived class!\")\n\n    @material_property\n    def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpy of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.H`.\n\n        :returns: Enthalpy in [J/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement molar_enthalpy() in derived class!\"\n        )\n\n    @material_property\n    def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the material.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.K_T`.\n\n        :returns: Isothermal bulk modulus in [Pa].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement isothermal_bulk_moduls() in derived class!\"\n        )\n\n    @material_property\n    def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns the adiabatic bulk modulus of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.K_S`.\n\n        :returns: Adiabatic bulk modulus in [Pa].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement adiabatic_bulk_modulus() in derived class!\"\n        )\n\n    @material_property\n    def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the mineral\n        (or inverse isothermal bulk modulus).\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.beta_T`.\n\n        :returns: Isothermal compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement compressibility() in derived class!\"\n        )\n\n    @material_property\n    def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibility of the mineral\n        (or inverse adiabatic bulk modulus).\n\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.beta_S`.\n\n        :returns: Adiabatic compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement compressibility() in derived class!\"\n        )\n\n    @material_property\n    def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.beta_G`.\n\n        :returns: Shear modulus in [Pa].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement shear_modulus() in derived class!\")\n\n    @material_property\n    def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.v_p`.\n\n        :returns: P wave speed in [m/s].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement p_wave_velocity() in derived class!\"\n        )\n\n    @material_property\n    def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.v_phi`.\n\n        :returns: Bulk sound velocity in [m/s].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement bulk_sound_velocity() in derived class!\"\n        )\n\n    @material_property\n    def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.v_s`.\n\n        :returns: Shear wave speed in [m/s].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement shear_wave_velocity() in derived class!\"\n        )\n\n    @material_property\n    def grueneisen_parameter(self):\n        \"\"\"\n        Returns the grueneisen parameter of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.gr`.\n\n        :returns: Grueneisen parameter [unitless].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement grueneisen_parameter() in derived class!\"\n        )\n\n    @material_property\n    def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.alpha`.\n\n        :returns: Thermal expansivity in [1/K].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement thermal_expansivity() in derived class!\"\n        )\n\n    @material_property\n    def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volume of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.C_v`.\n\n        :returns: Isochoric heat capacity in [J/K/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement molar_heat_capacity_v() in derived class!\"\n        )\n\n    @material_property\n    def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar heat capacity at constant pressure of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.C_p`.\n\n        :returns: Isobaric heat capacity in [J/K/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement molar_heat_capacity_p() in derived class!\"\n        )\n\n    #\n    # Aliased properties\n    @property\n    def P(self):\n        \"\"\"Alias for :func:`~burnman.Material.pressure`\"\"\"\n        return self.pressure\n\n    @property\n    def T(self):\n        \"\"\"Alias for :func:`~burnman.Material.temperature`\"\"\"\n        return self.temperature\n\n    @property\n    def energy(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_internal_energy`\"\"\"\n        return self.molar_internal_energy\n\n    @property\n    def helmholtz(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_helmholtz`\"\"\"\n        return self.molar_helmholtz\n\n    @property\n    def gibbs(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_gibbs`\"\"\"\n        return self.molar_gibbs\n\n    @property\n    def V(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_volume`\"\"\"\n        return self.molar_volume\n\n    @property\n    def rho(self):\n        \"\"\"Alias for :func:`~burnman.Material.density`\"\"\"\n        return self.density\n\n    @property\n    def S(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_entropy`\"\"\"\n        return self.molar_entropy\n\n    @property\n    def H(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_enthalpy`\"\"\"\n        return self.molar_enthalpy\n\n    @property\n    def K_T(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_bulk_modulus`\"\"\"\n        return self.isothermal_bulk_modulus\n\n    @property\n    def K_S(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_bulk_modulus`\"\"\"\n        return self.adiabatic_bulk_modulus\n\n    @property\n    def beta_T(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_compressibility`\"\"\"\n        return self.isothermal_compressibility\n\n    @property\n    def beta_S(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_compressibility`\"\"\"\n        return self.adiabatic_compressibility\n\n    @property\n    def isothermal_bulk_modulus_reuss(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_bulk_modulus`\"\"\"\n        return self.isothermal_bulk_modulus\n\n    @property\n    def adiabatic_bulk_modulus_reuss(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_bulk_modulus`\"\"\"\n        return self.adiabatic_bulk_modulus\n\n    @property\n    def isothermal_compressibility_reuss(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_compressibility`\"\"\"\n        return self.isothermal_compressibility\n\n    @property\n    def adiabatic_compressibility_reuss(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_compressibility`\"\"\"\n        return self.adiabatic_compressibility\n\n    @property\n    def G(self):\n        \"\"\"Alias for :func:`~burnman.Material.shear_modulus`\"\"\"\n        return self.shear_modulus\n\n    @property\n    def v_p(self):\n        \"\"\"Alias for :func:`~burnman.Material.p_wave_velocity`\"\"\"\n        return self.p_wave_velocity\n\n    @property\n    def v_phi(self):\n        \"\"\"Alias for :func:`~burnman.Material.bulk_sound_velocity`\"\"\"\n        return self.bulk_sound_velocity\n\n    @property\n    def v_s(self):\n        \"\"\"Alias for :func:`~burnman.Material.shear_wave_velocity`\"\"\"\n        return self.shear_wave_velocity\n\n    @property\n    def gr(self):\n        \"\"\"Alias for :func:`~burnman.Material.grueneisen_parameter`\"\"\"\n        return self.grueneisen_parameter\n\n    @property\n    def alpha(self):\n        \"\"\"Alias for :func:`~burnman.Material.thermal_expansivity`\"\"\"\n        return self.thermal_expansivity\n\n    @property\n    def C_v(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_v`\"\"\"\n        return self.molar_heat_capacity_v\n\n    @property\n    def C_p(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_p`\"\"\"\n        return self.molar_heat_capacity_p",
  "def __init__(self, func, name=None, doc=None):\n        self.__name__ = name or func.__name__\n        self.__module__ = func.__module__\n        self.__doc__ = doc or func.__doc__\n        self.func = func",
  "def __set__(self, obj, value):\n        obj.__dict__[self.__name__] = value",
  "def __get__(self, obj, type=None):\n        if obj is None:\n            return self\n        try:\n            value = obj.__dict__[self.__name__]\n        except KeyError:\n            value = self.func(obj)\n            obj.__dict__[self.__name__] = value\n        return value",
  "class mat_obj:\n        def __init__(self, func):\n            self.func = func\n            self.varname = self.func.__name__\n\n        def get(self, obj):\n            if not hasattr(obj, \"_cached\"):\n                raise Exception(\n                    \"The material_property decorator could not find \"\n                    \"class member _cached. \"\n                    \"Did you forget to call Material.__init__(self) in __init___?\"\n                )\n            cache_array = getattr(obj, \"_cached\")\n            if self.varname not in cache_array:\n                cache_array[self.varname] = self.func(obj)\n            return cache_array[self.varname]",
  "def __init__(self):\n        self._pressure = None\n        self._temperature = None\n        if not hasattr(self, \"name\"):\n            # if a derived class decides to set .name before calling this\n            # constructor (I am looking at you, SLB_2011.py!), do not\n            # overwrite the name here.\n            self._name = self.__class__.__name__\n        self._cached = {}",
  "def name(self):\n        \"\"\"Human-readable name of this material.\n\n        By default this will return the name of the class, but it can be set\n        to an arbitrary string. Overriden in Mineral.\n        \"\"\"\n        return self._name",
  "def name(self, value):\n        self._name = value",
  "def set_method(self, method):\n        \"\"\"\n        Set the averaging method. See :doc:`averaging` for details.\n\n        .. note:: Needs to be implemented in derived classes.\n        \"\"\"\n        raise NotImplementedError(\"need to implement set_method() in derived class!\")",
  "def to_string(self):\n        \"\"\"\n        Returns a human-readable name of this material.\n        The default implementation will return the name of the class,\n        which is a reasonable default.\n\n        :returns: A human-readable name of the material.\n        :rtype: str\n        \"\"\"\n        return \"'\" + self.name + \"'\"",
  "def debug_print(self, indent=\"\"):\n        \"\"\"\n        Print a human-readable representation of this Material.\n        \"\"\"\n        raise NotImplementedError(\n            \"Derived classes need to implement debug_print(). This is '\"\n            + self.__class__.__name__\n            + \"'\"\n        )",
  "def print_minerals_of_current_state(self):\n        \"\"\"\n        Print a human-readable representation of this Material at the current\n        P, T as a list of minerals.\n        This requires set_state() has been called before.\n        \"\"\"\n        (minerals, fractions) = self.unroll()\n        if len(minerals) == 1:\n            print(minerals[0].to_string())\n        else:\n            print(\"Material %s:\" % self.to_string())\n            for mineral, fraction in zip(minerals, fractions):\n                print(\"  %g of phase %s\" % (fraction, mineral.to_string()))",
  "def set_state(self, pressure, temperature):\n        \"\"\"\n        Set the material to the given pressure and temperature.\n\n        :param pressure: The desired pressure in [Pa].\n        :type pressure: float\n\n        :param temperature: The desired temperature in [K].\n        :type temperature: float\n        \"\"\"\n        if not hasattr(self, \"_pressure\"):\n            raise Exception(\n                \"Material.set_state() could not find class member _pressure. \"\n                \"Did you forget to call Material.__init__(self) in __init___?\"\n            )\n        self.reset()\n\n        self._pressure = pressure\n        self._temperature = temperature",
  "def set_state_with_volume(\n        self, volume, temperature, pressure_guesses=[0.0e9, 10.0e9]\n    ):\n        \"\"\"\n        This function acts similarly to set_state, but takes volume and\n        temperature as input to find the pressure. In order to ensure\n        self-consistency, this function does not use any pressure functions\n        from the material classes, but instead finds the pressure using the\n        brentq root-finding method.\n\n        :param volume: The desired molar volume of the mineral [m^3].\n        :type volume: float\n\n        :param temperature: The desired temperature of the mineral [K].\n        :type temperature: float\n\n        :param pressure_guesses: A list of floats denoting the initial\n            low and high guesses for bracketing of the pressure [Pa].\n            These guesses should preferably bound the correct pressure,\n            but do not need to do so. More importantly,\n            they should not lie outside the valid region of\n            the equation of state. Defaults to [5.e9, 10.e9].\n        :type pressure_guesses: list\n        \"\"\"\n\n        def _delta_volume(pressure, volume, temperature):\n            # Try to set the state with this pressure,\n            # but if the pressure is too low most equations of state\n            # fail. In this case, treat the molar_volume as infinite\n            # and brentq will try a larger pressure.\n            try:\n                self.set_state(pressure, temperature)\n                return volume - self.molar_volume\n            except Exception:\n                return -np.inf\n\n        # we need to have a sign change in [a,b] to find a zero.\n        args = (volume, temperature)\n        try:\n            sol = bracket(_delta_volume, pressure_guesses[0], pressure_guesses[1], args)\n        except ValueError:\n            raise Exception(\n                \"Cannot find a pressure, perhaps the volume or starting pressures \"\n                \"are outside the range of validity for the equation of state?\"\n            )\n        pressure = brentq(_delta_volume, sol[0], sol[1], args=args)\n        self.set_state(pressure, temperature)",
  "def reset(self):\n        \"\"\"\n        Resets all cached material properties.\n\n        It is typically not required for the user to call this function.\n        \"\"\"\n        self._cached = {}",
  "def copy(self):\n        return deepcopy(self)",
  "def unroll(self):\n        \"\"\"\n        Unroll this material into a list of :class:`burnman.Mineral` and their molar\n        fractions. All averaging schemes then operate on this list of minerals.\n        Note that the return value of this function may depend on the current\n        state (temperature, pressure).\n\n        .. note:: Needs to be implemented in derived classes.\n\n        :returns: A list of molar fractions which should sum to 1.0,\n            and a list of :class:`burnman.Mineral` objects\n            containing the minerals in the material.\n        :rtype: tuple\n        \"\"\"\n        raise NotImplementedError(\"need to implement unroll() in derived class!\")",
  "def evaluate(self, vars_list, pressures, temperatures):\n        \"\"\"\n        Returns an array of material properties requested through a list of strings\n        at given pressure and temperature conditions.\n        At the end it resets the set_state to the original values.\n        The user needs to call set_method() before.\n\n        :param vars_list: Variables to be returned for given conditions\n        :type vars_list: list of strings\n\n        :param pressures: ndlist or ndarray of float of pressures in [Pa].\n        :type pressures: :class:`numpy.array`, n-dimensional\n\n        :param temperatures: ndlist or ndarray of float of temperatures in [K].\n        :type temperatures: :class:`numpy.array`, n-dimensional\n\n        :returns: Array returning all variables at given pressure/temperature values.\n            output[i][j] is property vars_list[j] for temperatures[i] and pressures[i].\n        :rtype: :class:`numpy.array`, n-dimensional\n        \"\"\"\n        old_pressure = self.pressure\n        old_temperature = self.temperature\n        pressures = np.array(pressures)\n        temperatures = np.array(temperatures)\n\n        assert pressures.shape == temperatures.shape\n\n        output = np.empty((len(vars_list),) + pressures.shape)\n        for i, p in np.ndenumerate(pressures):\n            self.set_state(p, temperatures[i])\n            for j in range(len(vars_list)):\n                output[(j,) + i] = getattr(self, vars_list[j])\n        if old_pressure is None or old_temperature is None:\n            # do not set_state if old values were None. Just reset to None\n            # manually\n            self._pressure = self._temperature = None\n            self.reset()\n        else:\n            self.set_state(old_pressure, old_temperature)\n\n        return output",
  "def pressure(self):\n        \"\"\"\n        Returns current pressure that was set with :func:`~burnman.Material.set_state`.\n\n        .. note:: Aliased with :func:`~burnman.Material.P`.\n\n        :returns: Pressure in [Pa].\n        :rtype: float\n        \"\"\"\n        return self._pressure",
  "def temperature(self):\n        \"\"\"\n        Returns current temperature that was set with\n        :func:`~burnman.Material.set_state`.\n\n        .. note:: Aliased with :func:`~burnman.Material.T`.\n\n        :returns: Temperature in [K].\n        :rtype: float\n        \"\"\"\n        return self._temperature",
  "def molar_internal_energy(self):\n        \"\"\"\n        Returns the molar internal energy of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.energy`.\n\n        :returns: The internal energy in [J/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement molar_internal_energy() in derived class!\"\n        )",
  "def molar_gibbs(self):\n        \"\"\"\n        Returns the molar Gibbs free energy of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.gibbs`.\n\n        :returns: Gibbs free energy in [J/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement molar_gibbs() in derived class!\")",
  "def molar_helmholtz(self):\n        \"\"\"\n        Returns the molar Helmholtz free energy of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.helmholtz`.\n\n        :returns: Helmholtz free energy in [J/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement molar_helmholtz() in derived class!\"\n        )",
  "def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n\n        :returns: Molar mass in [kg/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement molar_mass() in derived class!\")",
  "def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.V`.\n\n        :returns: Molar volume in [m^3/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement molar_volume() in derived class!\")",
  "def density(self):\n        \"\"\"\n        Returns the density of this material.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.rho`.\n\n        :returns: The density of this material in [kg/m^3].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement density() in derived class!\")",
  "def molar_entropy(self):\n        \"\"\"\n        Returns molar entropy of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.S`.\n\n        :returns: Entropy in [J/K/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement molar_entropy() in derived class!\")",
  "def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpy of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.H`.\n\n        :returns: Enthalpy in [J/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement molar_enthalpy() in derived class!\"\n        )",
  "def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the material.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.K_T`.\n\n        :returns: Isothermal bulk modulus in [Pa].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement isothermal_bulk_moduls() in derived class!\"\n        )",
  "def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns the adiabatic bulk modulus of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.K_S`.\n\n        :returns: Adiabatic bulk modulus in [Pa].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement adiabatic_bulk_modulus() in derived class!\"\n        )",
  "def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the mineral\n        (or inverse isothermal bulk modulus).\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.beta_T`.\n\n        :returns: Isothermal compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement compressibility() in derived class!\"\n        )",
  "def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibility of the mineral\n        (or inverse adiabatic bulk modulus).\n\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.beta_S`.\n\n        :returns: Adiabatic compressibility in [1/Pa].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement compressibility() in derived class!\"\n        )",
  "def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.beta_G`.\n\n        :returns: Shear modulus in [Pa].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"need to implement shear_modulus() in derived class!\")",
  "def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.v_p`.\n\n        :returns: P wave speed in [m/s].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement p_wave_velocity() in derived class!\"\n        )",
  "def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.v_phi`.\n\n        :returns: Bulk sound velocity in [m/s].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement bulk_sound_velocity() in derived class!\"\n        )",
  "def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.v_s`.\n\n        :returns: Shear wave speed in [m/s].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement shear_wave_velocity() in derived class!\"\n        )",
  "def grueneisen_parameter(self):\n        \"\"\"\n        Returns the grueneisen parameter of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.gr`.\n\n        :returns: Grueneisen parameter [unitless].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement grueneisen_parameter() in derived class!\"\n        )",
  "def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.alpha`.\n\n        :returns: Thermal expansivity in [1/K].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement thermal_expansivity() in derived class!\"\n        )",
  "def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volume of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.C_v`.\n\n        :returns: Isochoric heat capacity in [J/K/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement molar_heat_capacity_v() in derived class!\"\n        )",
  "def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar heat capacity at constant pressure of the mineral.\n\n        .. note:: Needs to be implemented in derived classes.\n            Aliased with :func:`~burnman.Material.C_p`.\n\n        :returns: Isobaric heat capacity in [J/K/mol].\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\n            \"need to implement molar_heat_capacity_p() in derived class!\"\n        )",
  "def P(self):\n        \"\"\"Alias for :func:`~burnman.Material.pressure`\"\"\"\n        return self.pressure",
  "def T(self):\n        \"\"\"Alias for :func:`~burnman.Material.temperature`\"\"\"\n        return self.temperature",
  "def energy(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_internal_energy`\"\"\"\n        return self.molar_internal_energy",
  "def helmholtz(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_helmholtz`\"\"\"\n        return self.molar_helmholtz",
  "def gibbs(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_gibbs`\"\"\"\n        return self.molar_gibbs",
  "def V(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_volume`\"\"\"\n        return self.molar_volume",
  "def rho(self):\n        \"\"\"Alias for :func:`~burnman.Material.density`\"\"\"\n        return self.density",
  "def S(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_entropy`\"\"\"\n        return self.molar_entropy",
  "def H(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_enthalpy`\"\"\"\n        return self.molar_enthalpy",
  "def K_T(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_bulk_modulus`\"\"\"\n        return self.isothermal_bulk_modulus",
  "def K_S(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_bulk_modulus`\"\"\"\n        return self.adiabatic_bulk_modulus",
  "def beta_T(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_compressibility`\"\"\"\n        return self.isothermal_compressibility",
  "def beta_S(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_compressibility`\"\"\"\n        return self.adiabatic_compressibility",
  "def isothermal_bulk_modulus_reuss(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_bulk_modulus`\"\"\"\n        return self.isothermal_bulk_modulus",
  "def adiabatic_bulk_modulus_reuss(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_bulk_modulus`\"\"\"\n        return self.adiabatic_bulk_modulus",
  "def isothermal_compressibility_reuss(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_compressibility`\"\"\"\n        return self.isothermal_compressibility",
  "def adiabatic_compressibility_reuss(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_compressibility`\"\"\"\n        return self.adiabatic_compressibility",
  "def G(self):\n        \"\"\"Alias for :func:`~burnman.Material.shear_modulus`\"\"\"\n        return self.shear_modulus",
  "def v_p(self):\n        \"\"\"Alias for :func:`~burnman.Material.p_wave_velocity`\"\"\"\n        return self.p_wave_velocity",
  "def v_phi(self):\n        \"\"\"Alias for :func:`~burnman.Material.bulk_sound_velocity`\"\"\"\n        return self.bulk_sound_velocity",
  "def v_s(self):\n        \"\"\"Alias for :func:`~burnman.Material.shear_wave_velocity`\"\"\"\n        return self.shear_wave_velocity",
  "def gr(self):\n        \"\"\"Alias for :func:`~burnman.Material.grueneisen_parameter`\"\"\"\n        return self.grueneisen_parameter",
  "def alpha(self):\n        \"\"\"Alias for :func:`~burnman.Material.thermal_expansivity`\"\"\"\n        return self.thermal_expansivity",
  "def C_v(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_v`\"\"\"\n        return self.molar_heat_capacity_v",
  "def C_p(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_p`\"\"\"\n        return self.molar_heat_capacity_p",
  "def __init__(self, func):\n            self.func = func\n            self.varname = self.func.__name__",
  "def get(self, obj):\n            if not hasattr(obj, \"_cached\"):\n                raise Exception(\n                    \"The material_property decorator could not find \"\n                    \"class member _cached. \"\n                    \"Did you forget to call Material.__init__(self) in __init___?\"\n                )\n            cache_array = getattr(obj, \"_cached\")\n            if self.varname not in cache_array:\n                cache_array[self.varname] = self.func(obj)\n            return cache_array[self.varname]",
  "def _delta_volume(pressure, volume, temperature):\n            # Try to set the state with this pressure,\n            # but if the pressure is too low most equations of state\n            # fail. In this case, treat the molar_volume as infinite\n            # and brentq will try a larger pressure.\n            try:\n                self.set_state(pressure, temperature)\n                return volume - self.molar_volume\n            except Exception:\n                return -np.inf",
  "class HelperRockSwitcher(Material):\n    \"\"\"\n    A Helper that represents a Material that switches between different rocks\n    based on a user specified select_rock() function based on current temperature\n    and pressure. This class can be used in several ways:\n    1. By creating an instance and setting select_rock to a lambda that returns a rock\n    2. By deriving from this class and implementing select_rock.\n    \"\"\"\n\n    def __init__(self):\n        self.current_rock = None\n        Material.__init__(self)\n\n    def select_rock(self):\n        raise NotImplementedError(\"Need to implement select_rock() in derived class!\")\n\n    def set_method(self, method):\n        raise NotImplementedError(\"Need to implement select_rock() in derived class!\")\n\n    def debug_print(self, indent=\"\"):\n        print(\"%sHelperRockSwitcher\" % (indent))\n\n    def set_state(self, pressure, temperature):\n        Material.set_state(self, pressure, temperature)\n\n        self.current_rock = self.select_rock()\n        self.current_rock.set_state(pressure, temperature)\n\n    def unroll(self):\n        return self.current_rock.unroll()\n\n    @material_property\n    def molar_internal_energy(self):\n        return self.current_rock.molar_internal_energy\n\n    @material_property\n    def molar_gibbs(self):\n        return self.current_rock.molar_gibbs\n\n    @material_property\n    def molar_helmholtz(self):\n        return self.current_rock.molar_helmholtz\n\n    @material_property\n    def molar_mass(self):\n        return self.current_rock.molar_mass\n\n    @material_property\n    def molar_volume(self):\n        return self.current_rock.molar_volume\n\n    @material_property\n    def density(self):\n        return self.current_rock.density\n\n    @material_property\n    def molar_entropy(self):\n        return self.current_rock.molar_entropy\n\n    @material_property\n    def molar_enthalpy(self):\n        return self.current_rock.molar_enthalpy\n\n    @material_property\n    def isothermal_bulk_modulus(self):\n        return self.current_rock.isothermal_bulk_modulus\n\n    @material_property\n    def adiabatic_bulk_modulus(self):\n        return self.current_rock.adiabatic_bulk_modulus\n\n    @material_property\n    def isothermal_compressibility(self):\n        return self.current_rock.isothermal_compressibility\n\n    @material_property\n    def adiabatic_compressibility(self):\n        return self.current_rock.adiabatic_compressibility\n\n    @material_property\n    def shear_modulus(self):\n        return self.current_rock.shear_modulus\n\n    @material_property\n    def p_wave_velocity(self):\n        return self.current_rock.p_wave_velocity\n\n    @material_property\n    def bulk_sound_velocity(self):\n        return self.current_rock.bulk_sound_velocity\n\n    @material_property\n    def shear_wave_velocity(self):\n        return self.current_rock.shear_wave_velocity\n\n    @material_property\n    def grueneisen_parameter(self):\n        return self.current_rock.grueneisen_parameter\n\n    @material_property\n    def thermal_expansivity(self):\n        return self.current_rock.thermal_expansivity\n\n    @material_property\n    def molar_heat_capacity_v(self):\n        return self.current_rock.molar_heat_capacity_v\n\n    @material_property\n    def molar_heat_capacity_p(self):\n        return self.current_rock.molar_heat_capacity_p",
  "class HelperLowHighPressureRockTransition(HelperRockSwitcher):\n    \"\"\"\n    A Helper that represents a Material that switches between two given rocks based\n    on a given transition pressure.\n    \"\"\"\n\n    def __init__(self, transition_pressure, low_pressure_rock, high_pressure_rock):\n        self.transition_pressure = transition_pressure\n        self.rocks = [low_pressure_rock, high_pressure_rock]\n        HelperRockSwitcher.__init__(self)\n        self._name = (\n            \"HelperLowHighPressureRockTransition(\"\n            + str(self.transition_pressure)\n            + \" GPa, \"\n            + self.rocks[0].name\n            + \", \"\n            + self.rocks[1].name\n            + \")\"\n        )\n\n    def select_rock(self):\n        if self._pressure < self.transition_pressure:\n            return self.rocks[0]\n        else:\n            return self.rocks[1]\n\n    def set_method(self, method):\n        for r in self.rocks:\n            r.set_method(method)\n\n    def debug_print(self, indent=\"\"):\n        print(\n            \"%sHelperLowHighPressureRockTransition (%f GPa):\"\n            % (indent, self.transition_pressure)\n        )\n        indent += \"  \"\n        for r in self.rocks:\n            r.debug_print(indent)",
  "class HelperSpinTransition(Composite):\n\n    \"\"\"\n    Helper class that makes a mineral that switches between two materials\n    (for low and high spin) based on some transition pressure [Pa]\n    \"\"\"\n\n    def __init__(self, transition_pressure, ls_mat, hs_mat):\n        \"\"\"\n        Takes a transition pressure, and two minerals.  Use the\n        thermoelastic parameters for ls_mat below the transition\n        pressure, and the thermoelastic parameters for hs_mat\n        above the transition pressure\n        \"\"\"\n        Material.__init__(self)\n        self.transition_pressure = transition_pressure\n        self.ls_mat = ls_mat\n        self.hs_mat = hs_mat\n        Composite.__init__(self, [ls_mat, hs_mat])\n\n    def debug_print(self, indent=\"\"):\n        print(\"%sHelperSpinTransition:\" % indent)\n        self.ls_mat.debug_print(indent + \"  \")\n        self.hs_mat.debug_print(indent + \"  \")\n\n    def set_state(self, pressure, temperature):\n        if pressure >= self.transition_pressure:\n            Composite.set_fractions(self, [1.0, 0.0])\n        else:\n            Composite.set_fractions(self, [0.0, 1.0])\n\n        Composite.set_state(self, pressure, temperature)",
  "def __init__(self):\n        self.current_rock = None\n        Material.__init__(self)",
  "def select_rock(self):\n        raise NotImplementedError(\"Need to implement select_rock() in derived class!\")",
  "def set_method(self, method):\n        raise NotImplementedError(\"Need to implement select_rock() in derived class!\")",
  "def debug_print(self, indent=\"\"):\n        print(\"%sHelperRockSwitcher\" % (indent))",
  "def set_state(self, pressure, temperature):\n        Material.set_state(self, pressure, temperature)\n\n        self.current_rock = self.select_rock()\n        self.current_rock.set_state(pressure, temperature)",
  "def unroll(self):\n        return self.current_rock.unroll()",
  "def molar_internal_energy(self):\n        return self.current_rock.molar_internal_energy",
  "def molar_gibbs(self):\n        return self.current_rock.molar_gibbs",
  "def molar_helmholtz(self):\n        return self.current_rock.molar_helmholtz",
  "def molar_mass(self):\n        return self.current_rock.molar_mass",
  "def molar_volume(self):\n        return self.current_rock.molar_volume",
  "def density(self):\n        return self.current_rock.density",
  "def molar_entropy(self):\n        return self.current_rock.molar_entropy",
  "def molar_enthalpy(self):\n        return self.current_rock.molar_enthalpy",
  "def isothermal_bulk_modulus(self):\n        return self.current_rock.isothermal_bulk_modulus",
  "def adiabatic_bulk_modulus(self):\n        return self.current_rock.adiabatic_bulk_modulus",
  "def isothermal_compressibility(self):\n        return self.current_rock.isothermal_compressibility",
  "def adiabatic_compressibility(self):\n        return self.current_rock.adiabatic_compressibility",
  "def shear_modulus(self):\n        return self.current_rock.shear_modulus",
  "def p_wave_velocity(self):\n        return self.current_rock.p_wave_velocity",
  "def bulk_sound_velocity(self):\n        return self.current_rock.bulk_sound_velocity",
  "def shear_wave_velocity(self):\n        return self.current_rock.shear_wave_velocity",
  "def grueneisen_parameter(self):\n        return self.current_rock.grueneisen_parameter",
  "def thermal_expansivity(self):\n        return self.current_rock.thermal_expansivity",
  "def molar_heat_capacity_v(self):\n        return self.current_rock.molar_heat_capacity_v",
  "def molar_heat_capacity_p(self):\n        return self.current_rock.molar_heat_capacity_p",
  "def __init__(self, transition_pressure, low_pressure_rock, high_pressure_rock):\n        self.transition_pressure = transition_pressure\n        self.rocks = [low_pressure_rock, high_pressure_rock]\n        HelperRockSwitcher.__init__(self)\n        self._name = (\n            \"HelperLowHighPressureRockTransition(\"\n            + str(self.transition_pressure)\n            + \" GPa, \"\n            + self.rocks[0].name\n            + \", \"\n            + self.rocks[1].name\n            + \")\"\n        )",
  "def select_rock(self):\n        if self._pressure < self.transition_pressure:\n            return self.rocks[0]\n        else:\n            return self.rocks[1]",
  "def set_method(self, method):\n        for r in self.rocks:\n            r.set_method(method)",
  "def debug_print(self, indent=\"\"):\n        print(\n            \"%sHelperLowHighPressureRockTransition (%f GPa):\"\n            % (indent, self.transition_pressure)\n        )\n        indent += \"  \"\n        for r in self.rocks:\n            r.debug_print(indent)",
  "def __init__(self, transition_pressure, ls_mat, hs_mat):\n        \"\"\"\n        Takes a transition pressure, and two minerals.  Use the\n        thermoelastic parameters for ls_mat below the transition\n        pressure, and the thermoelastic parameters for hs_mat\n        above the transition pressure\n        \"\"\"\n        Material.__init__(self)\n        self.transition_pressure = transition_pressure\n        self.ls_mat = ls_mat\n        self.hs_mat = hs_mat\n        Composite.__init__(self, [ls_mat, hs_mat])",
  "def debug_print(self, indent=\"\"):\n        print(\"%sHelperSpinTransition:\" % indent)\n        self.ls_mat.debug_print(indent + \"  \")\n        self.hs_mat.debug_print(indent + \"  \")",
  "def set_state(self, pressure, temperature):\n        if pressure >= self.transition_pressure:\n            Composite.set_fractions(self, [1.0, 0.0])\n        else:\n            Composite.set_fractions(self, [0.0, 1.0])\n\n        Composite.set_state(self, pressure, temperature)",
  "class Planet(object):\n    \"\"\"\n    A class to build (self-consistent) Planets made out of Layers\n    (:class:`burnman.Layer`). By default the planet is set to be self-consistent\n    (with zero pressure at the surface and zero gravity at the center),\n    but this can be overwritte using the set_pressure_mode().\n    Pressure_modes defined in the individual layers will be ignored.\n    If temperature modes are already set for each of the layers, when the\n    planet is initialized, the planet will be built immediately.\n    \"\"\"\n\n    def __init__(\n        self, name, layers, n_max_iterations=50, max_delta=1.0e-5, verbose=False\n    ):\n        \"\"\"\n        :param name: Name of planet.\n        :type name: str\n        :param layers: Layers to build the planet out of\n            (layers are sorted within the planet).\n        :type layers: list of :class:`burnman.Layer`\n        :param n_max_iterations: Maximum number of iterations to reach\n            self-consistent planet.\n        :type n_max_iterations: int\n        :param max_delta: Relative update to the center pressure of the planet between\n            iterations to stop iterations.\n        :type max_delta: float\n        \"\"\"\n        # sort layers\n        self.layers = sorted(layers, key=lambda x: x.inner_radius)\n        # assert layers attach to one another\n        if len(self.layers) > 1:\n            for i in range(1, len(self.layers)):\n                assert self.layers[i].inner_radius == self.layers[i - 1].outer_radius\n\n        self.name = name\n\n        self.radii = self.evaluate([\"radii\"])\n        self.n_slices = len(self.radii)\n        self.radius_planet = max(self.radii)\n        self.volume = 4.0 / 3.0 * np.pi * np.power(self.radius_planet, 3.0)\n\n        for layer in self.layers:\n            layer.n_start = np.where(self.radii == layer.inner_radius)[0][-1]\n            layer.n_end = np.where(self.radii == layer.outer_radius)[0][0] + 1\n        self._cached = {}\n        self.verbose = verbose\n        self.set_pressure_mode(n_max_iterations=n_max_iterations, max_delta=max_delta)\n\n    def __iter__(self):\n        \"\"\"\n        Planet object will iterate over Layers.\n        \"\"\"\n        return list(self.layers).__iter__()\n\n    def __str__(self):\n        \"\"\"\n        Prints details of the planet\n        \"\"\"\n        writing = \"{0} consists of {1} layers:\\n\".format(self.name, len(self.layers))\n        for layer in self:\n            writing = writing + layer.__str__()\n        return writing\n\n    def reset(self):\n        \"\"\"\n        Resets all cached material properties.\n        It is typically not required for the user to call this function.\n        \"\"\"\n        self._cached = {}\n\n    def get_layer(self, name):\n        \"\"\"\n        Returns a layer with a given name\n\n        :param name: Given name of a layer\n        :type name: str\n\n        :returns: Layer with the given name.\n        :rtype: :class:`burnman.Layer`\n        \"\"\"\n        for layer in self.layers:\n            if layer.name == name:\n                return layer\n        raise LookupError()\n\n    def get_layer_by_radius(self, radius):\n        \"\"\"\n        Returns a layer in which this radius lies\n\n        :param radius: Radius at which to evaluate the layer.\n        :type radius: float\n\n        :returns: Layer in which the radius lies.\n        :rtype: :class:`burnman.Layer`\n        \"\"\"\n        for layer in self.layers:\n            if layer.outer_radius >= radius:\n                return layer\n        raise LookupError()\n\n    def evaluate(self, properties, radlist=None):\n        \"\"\"\n        Function that is generally used to evaluate properties\n        of the different layers and stitch them together.\n        If asking for different radii than the internal radlist,\n        pressure and temperature values are interpolated and the\n        layer material evaluated at those pressures and\n        temperatures.\n\n        :param properties: List of properties to evaluate\n        :type properties: list of strings\n        :param radlist: Radii to evaluate properties at. If left empty,\n            internal radius lists are used.\n        :type radlist: array of floats\n\n        :returns: 1D or 2D array of requested properties\n            (1D if only one property was requested)\n        :rtype: numpy.array\n        \"\"\"\n        if radlist is None:\n            values = np.empty(\n                [len(properties), np.sum([len(layer.radii) for layer in self.layers])]\n            )\n            for i, prop in enumerate(properties):\n                if prop == \"depth\":\n                    values[i] = np.array(\n                        [\n                            self.radius_planet - r\n                            for layer in self.layers\n                            for r in layer.radii\n                        ]\n                    )\n                else:\n                    j = 0\n                    for layer in self.layers:\n                        vals = getattr(layer, prop)\n                        values[i, j : j + len(vals)] = vals\n                        j += len(vals)\n        else:\n            values = np.empty([len(properties), len(radlist)])\n            l_idx = [\n                i\n                for i, layer in enumerate(self.layers)\n                for r in radlist\n                if r >= layer.inner_radius and r <= layer.outer_radius\n            ]\n\n            for j, r in enumerate(radlist):\n                values[:, j] = (\n                    self.layers[l_idx[j]]\n                    .evaluate(properties, [r], self.radius_planet)\n                    .T[0]\n                )\n\n        if values.shape[0] == 1:\n            values = values[0]\n        return values\n\n    def set_pressure_mode(\n        self,\n        pressure_mode=\"self-consistent\",\n        pressures=None,\n        pressure_top=0.0,\n        gravity_bottom=0.0,\n        n_max_iterations=50,\n        max_delta=1.0e-5,\n    ):\n        \"\"\"\n        Sets the pressure mode of the planet by user-defined values are in a\n        self-consistent fashion.\n        pressure_mode is 'user-defined' or 'self-consistent'.\n        The default for the planet is self-consistent, with zero pressure at\n        the surface and zero pressure at the center.\n\n        :param pressure_mode: This can be set to 'user-defined' or 'self-consistent'.\n        :type pressure_mode: str\n        :param pressures: Pressures (Pa) to set layer to ('user-defined').\n            This should be the same length as defined radius array for the layer.\n        :type pressures: array of floats\n        :param pressure_top: Pressure (Pa) at the top of the layer.\n        :type pressure_top: float\n        :param gravity_bottom: Gravity (m/s^2) at the bottom the layer\n        :type gravity_bottom: float\n        :param n_max_iterations: Maximum number of iterations to reach\n            self-consistent pressures.\n        :type n_max_iterations: int\n        \"\"\"\n        self.reset()\n        assert pressure_mode == \"user-defined\" or pressure_mode == \"self-consistent\"\n\n        self.pressure_mode = pressure_mode\n        self.gravity_bottom = gravity_bottom\n\n        if pressure_mode == \"user-defined\":\n            assert len(pressures) == len(self.radii)\n            self._pressures = pressures\n            warnings.warn(\n                \"User-defined pressures mean that the planet is \"\n                \"unlikely to be self-consistent\"\n            )\n\n        if pressure_mode == \"self-consistent\":\n            self.pressure_top = pressure_top\n            self.n_max_iterations = n_max_iterations\n            self.max_delta = max_delta\n\n    def make(self):\n        \"\"\"\n        This routine needs to be called before evaluating any properties.\n        If pressures and temperatures are self-consistent, they\n        are computed across the planet here. Also initializes an array of materials\n        in each Layer to compute properties from.\n        \"\"\"\n\n        self.reset()\n        for layer in self.layers:\n            assert layer.temperature_mode is not None\n\n        if self.pressure_mode == \"user-defined\":\n            self._temperatures = self._evaluate_temperature(self._pressures)\n\n        if self.pressure_mode == \"self-consistent\":\n            new_press = (\n                self.pressure_top + (-self.radii + max(self.radii)) * 1.0e3\n            )  # initial pressure curve guess\n            temperatures = self._evaluate_temperature(new_press)\n\n            # Make it self-consistent!!!\n            i = 0\n            while i < self.n_max_iterations:\n                i += 1\n                ref_press = new_press\n                new_grav, new_press = self._evaluate_eos(\n                    new_press, temperatures, self.gravity_bottom, self.pressure_top\n                )\n                temperatures = self._evaluate_temperature(new_press)\n                rel_err = abs((max(ref_press) - max(new_press)) / max(new_press))\n                if self.verbose:\n                    print(\n                        f\"Iteration {i:0d} maximum relative pressure error: \"\n                        f\"{rel_err:.1e}\"\n                    )\n\n                if rel_err < self.max_delta:\n                    break\n\n            self.pressures = new_press\n            self.temperatures = temperatures\n            self._gravity = new_grav\n\n        for layer in self.layers:\n            layer.sublayers = []\n            layer.pressures = self.pressures[layer.n_start : layer.n_end]\n            layer.temperatures = self.temperatures[layer.n_start : layer.n_end]\n            layer.gravity_bottom = self._gravity[layer.n_start - 1]\n            layer.pressure_mode = \"set-in-planet\"\n            for i in range(len(layer.radii)):\n                layer.sublayers.append(layer.material.copy())\n                layer.sublayers[i].set_state(layer.pressures[i], layer.temperatures[i])\n\n    def _evaluate_eos(self, pressures, temperatures, gravity_bottom, pressure_top):\n        \"\"\"\n        Used to update the pressure profile in set_state()\n        \"\"\"\n        density = self._evaluate_density(pressures, temperatures)\n        grav = self._compute_gravity(density, gravity_bottom)\n        press = self._compute_pressure(density, grav, pressure_top)\n        return grav, press\n\n    def _evaluate_density(self, pressures, temperatures):\n        \"\"\"\n        Used to update the density profile in _evaluate_eos()\n        \"\"\"\n        density = []\n        for layer in self.layers:\n            density.append(\n                layer.material.evaluate(\n                    [\"density\"],\n                    pressures[layer.n_start : layer.n_end],\n                    temperatures[layer.n_start : layer.n_end],\n                )\n            )\n        return np.squeeze(np.hstack(density))\n\n    def _evaluate_temperature(self, pressures):\n        \"\"\"\n        Returns the temperatures of different layers for given pressures.\n        Used by set_state()\n        \"\"\"\n        temps = []\n        temperature_top = None\n        for layer in self.layers[::-1]:\n            if temperature_top is None or layer.temperature_top is not None:\n                temperature_top = layer.temperature_top\n            temps.extend(\n                layer._evaluate_temperature(\n                    (pressures[layer.n_start : layer.n_end]), temperature_top\n                )[::-1]\n            )\n            temperature_top = temps[-1]\n        return np.hstack(np.squeeze(temps))[::-1]\n\n    def _compute_gravity(self, density, gravity_bottom):\n        \"\"\"\n        Calculate the gravity of the planet, based on a density profile.\n        This integrates Poisson's equation in radius, under the assumption\n        that the planet is laterally homogeneous.\n        Used to update the gravity profile in _evaluate_eos()\n        \"\"\"\n\n        start_gravity = gravity_bottom\n        grav = []\n        for layer in self.layers:\n            grav.extend(\n                layer._compute_gravity(\n                    density[layer.n_start : layer.n_end], start_gravity\n                )\n            )\n            start_gravity = grav[-1]\n\n        return np.array(grav)\n\n    def _compute_pressure(self, density, gravity, pressure_top):\n        \"\"\"\n        Calculate the pressure profile based on density and gravity.\n        This integrates the equation for hydrostatic equilibrium P = rho g z.\n        Used to update the pressure profile in _evaluate_eos()\n        \"\"\"\n        start_pressure = pressure_top\n        press = []\n        for layer in self.layers[::-1]:\n            press.extend(\n                layer._compute_pressure(\n                    density[layer.n_start : layer.n_end],\n                    gravity[layer.n_start : layer.n_end],\n                    start_pressure,\n                )[::-1]\n            )\n            start_pressure = press[-1]\n        return np.array(press)[::-1]\n\n    @property\n    def mass(self):\n        \"\"\"\n        calculates the mass of the entire planet [kg]\n        \"\"\"\n        return np.sum([layer.mass for layer in self.layers])\n\n    @property\n    def average_density(self):\n        \"\"\"\n        calculates the average density of the entire planet [kg/m^3]\n        \"\"\"\n        return self.mass / self.volume\n\n    @property\n    def moment_of_inertia(self):\n        \"\"\"\n        #Returns the moment of inertia of the planet [kg m^2]\n        \"\"\"\n        return np.sum([layer.moment_of_inertia for layer in self.layers])\n\n    @property\n    def moment_of_inertia_factor(self):\n        \"\"\"\n        #Returns the moment of inertia of the planet [kg m^2]\n        \"\"\"\n        moment_factor = (\n            self.moment_of_inertia / self.mass / self.radius_planet / self.radius_planet\n        )\n        return moment_factor\n\n    @property\n    def depth(self):\n        \"\"\"\n        Returns depth of the layer [m]\n        \"\"\"\n        return self.evaluate([\"depth\"])\n\n    @property\n    def gravity(self):\n        \"\"\"\n        Returns gravity of the layer [m s^(-2)]\n        \"\"\"\n        return self.evaluate([\"gravity\"])\n\n    @property\n    def bullen(self):\n        \"\"\"\n        Returns the Bullen parameter\n        \"\"\"\n        return self.evaluate([\"bullen\"])\n\n    @property\n    def brunt_vasala(self):\n        return self.evaluate([\"brunt_vasala\"])\n\n    @property\n    def pressure(self):\n        \"\"\"\n        Returns current pressure that was set with\n        :func:`~burnman.Material.set_state`.\n\n        Aliased with :func:`~burnman.Material.P`.\n\n        :returns: Pressure in [Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.pressures\n\n    @property\n    def temperature(self):\n        \"\"\"\n        Returns current temperature that was set with\n        :func:`~burnman.Material.set_state`.\n\n        Aliased with :func:`~burnman.Material.T`.\n\n        :returns: Temperature in [K].\n        :rtype: array of floats\n        \"\"\"\n        return self.temperatures\n\n    @material_property\n    def molar_internal_energy(self):\n        \"\"\"\n        Returns the molar internal energy of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.energy`.\n\n        :returns: The internal energy in [J/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_internal_energy\"])\n\n    @material_property\n    def molar_gibbs(self):\n        \"\"\"\n        Returns the molar Gibbs free energy of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.gibbs`.\n\n        :returns: Gibbs energy in [J/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_gibbs\"])\n\n    @material_property\n    def molar_helmholtz(self):\n        \"\"\"\n        Returns the molar Helmholtz free energy of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.helmholtz`.\n\n        :returns: Helmholtz energy in [J/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_helmholtz\"])\n\n    @material_property\n    def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the planet.\n\n        Needs to be implemented in derived classes.\n\n        :returns: Molar mass in [kg/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_mass\"])\n\n    @material_property\n    def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.V`.\n\n        :returns: Molar volume in [m^3/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_volume\"])\n\n    @material_property\n    def density(self):\n        \"\"\"\n        Returns the density of this planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.rho`.\n\n        :returns: The density of this material in [kg/m^3].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"density\"])\n\n    @material_property\n    def molar_entropy(self):\n        \"\"\"\n        Returns molar entropy of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.S`.\n\n        :returns: Entropy in [J/K/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_entropy\"])\n\n    @material_property\n    def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpy of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.H`.\n\n        :returns: Enthalpy in [J/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_enthalpy\"])\n\n    @material_property\n    def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.K_T`.\n\n        :returns: Isothermal bulk modulus in [Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"isothermal_bulk_modulus\"])\n\n    @material_property\n    def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns the adiabatic bulk modulus of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.K_S`.\n\n        :returns: Adiabatic bulk modulus in [Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"adiabatic_bulk_modulus\"])\n\n    @material_property\n    def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the planet\n        (or inverse isothermal bulk modulus).\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_T`.\n\n        :returns: Isothermal compressibility in [1/Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"istothermal_compressibility\"])\n\n    @material_property\n    def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibility of the planet\n        (or inverse adiabatic bulk modulus).\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_S`.\n\n        :returns: Adiabatic compressibility in [1/Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"adiabatic_compressibility\"])\n\n    @material_property\n    def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_G`.\n\n        :returns: Shear modulus in [Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"shear_modulus\"])\n\n    @material_property\n    def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_p`.\n\n        :returns: P wave speed in [m/s].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"p_wave_velocity\"])\n\n    @material_property\n    def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_phi`.\n\n        :returns: Bulk sound velocity in [m/s].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"bulk_sound_velocity\"])\n\n    @material_property\n    def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_s`.\n\n        :returns: Shear wave speed in [m/s].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"shear_wave_velocity\"])\n\n    @material_property\n    def grueneisen_parameter(self):\n        \"\"\"\n        Returns the grueneisen parameter of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.gr`.\n\n        :returns: Grueneisen parameters [unitless].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"grueneisen_parameter\"])\n\n    @material_property\n    def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.alpha`.\n\n        :returns: Thermal expansivity in [1/K].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"thermal_expansivity\"])\n\n    @material_property\n    def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volume of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.C_v`.\n\n        :returns: Isochoric heat capacity in [J/K/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_heat_capacity_v\"])\n\n    @material_property\n    def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar heat capacity at constant pressure of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.C_p`.\n\n        :returns: Isobaric heat capacity in [J/K/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_heat_capacity_p\"])\n\n    #\n    # Aliased properties\n    @property\n    def P(self):\n        \"\"\"Alias for :func:`~burnman.Material.pressure`\"\"\"\n        return self.pressure\n\n    @property\n    def T(self):\n        \"\"\"Alias for :func:`~burnman.Material.temperature`\"\"\"\n        return self.temperature\n\n    @property\n    def energy(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_internal_energy`\"\"\"\n        return self.molar_internal_energy\n\n    @property\n    def helmholtz(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_helmholtz`\"\"\"\n        return self.molar_helmholtz\n\n    @property\n    def gibbs(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_gibbs`\"\"\"\n        return self.molar_gibbs\n\n    @property\n    def V(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_volume`\"\"\"\n        return self.molar_volume\n\n    @property\n    def rho(self):\n        \"\"\"Alias for :func:`~burnman.Material.density`\"\"\"\n        return self.density\n\n    @property\n    def S(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_entropy`\"\"\"\n        return self.molar_entropy\n\n    @property\n    def H(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_enthalpy`\"\"\"\n        return self.molar_enthalpy\n\n    @property\n    def K_T(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_bulk_modulus`\"\"\"\n        return self.isothermal_bulk_modulus\n\n    @property\n    def K_S(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_bulk_modulus`\"\"\"\n        return self.adiabatic_bulk_modulus\n\n    @property\n    def beta_T(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_compressibility`\"\"\"\n        return self.isothermal_compressibility\n\n    @property\n    def beta_S(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_compressibility`\"\"\"\n        return self.adiabatic_compressibility\n\n    @property\n    def G(self):\n        \"\"\"Alias for :func:`~burnman.Material.shear_modulus`\"\"\"\n        return self.shear_modulus\n\n    @property\n    def v_p(self):\n        \"\"\"Alias for :func:`~burnman.Material.p_wave_velocity`\"\"\"\n        return self.p_wave_velocity\n\n    @property\n    def v_phi(self):\n        \"\"\"Alias for :func:`~burnman.Material.bulk_sound_velocity`\"\"\"\n        return self.bulk_sound_velocity\n\n    @property\n    def v_s(self):\n        \"\"\"Alias for :func:`~burnman.Material.shear_wave_velocity`\"\"\"\n        return self.shear_wave_velocity\n\n    @property\n    def gr(self):\n        \"\"\"Alias for :func:`~burnman.Material.grueneisen_parameter`\"\"\"\n        return self.grueneisen_parameter\n\n    @property\n    def alpha(self):\n        \"\"\"Alias for :func:`~burnman.Material.thermal_expansivity`\"\"\"\n        return self.thermal_expansivity\n\n    @property\n    def C_v(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_v`\"\"\"\n        return self.molar_heat_capacity_v\n\n    @property\n    def C_p(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_p`\"\"\"\n        return self.molar_heat_capacity_p",
  "def __init__(\n        self, name, layers, n_max_iterations=50, max_delta=1.0e-5, verbose=False\n    ):\n        \"\"\"\n        :param name: Name of planet.\n        :type name: str\n        :param layers: Layers to build the planet out of\n            (layers are sorted within the planet).\n        :type layers: list of :class:`burnman.Layer`\n        :param n_max_iterations: Maximum number of iterations to reach\n            self-consistent planet.\n        :type n_max_iterations: int\n        :param max_delta: Relative update to the center pressure of the planet between\n            iterations to stop iterations.\n        :type max_delta: float\n        \"\"\"\n        # sort layers\n        self.layers = sorted(layers, key=lambda x: x.inner_radius)\n        # assert layers attach to one another\n        if len(self.layers) > 1:\n            for i in range(1, len(self.layers)):\n                assert self.layers[i].inner_radius == self.layers[i - 1].outer_radius\n\n        self.name = name\n\n        self.radii = self.evaluate([\"radii\"])\n        self.n_slices = len(self.radii)\n        self.radius_planet = max(self.radii)\n        self.volume = 4.0 / 3.0 * np.pi * np.power(self.radius_planet, 3.0)\n\n        for layer in self.layers:\n            layer.n_start = np.where(self.radii == layer.inner_radius)[0][-1]\n            layer.n_end = np.where(self.radii == layer.outer_radius)[0][0] + 1\n        self._cached = {}\n        self.verbose = verbose\n        self.set_pressure_mode(n_max_iterations=n_max_iterations, max_delta=max_delta)",
  "def __iter__(self):\n        \"\"\"\n        Planet object will iterate over Layers.\n        \"\"\"\n        return list(self.layers).__iter__()",
  "def __str__(self):\n        \"\"\"\n        Prints details of the planet\n        \"\"\"\n        writing = \"{0} consists of {1} layers:\\n\".format(self.name, len(self.layers))\n        for layer in self:\n            writing = writing + layer.__str__()\n        return writing",
  "def reset(self):\n        \"\"\"\n        Resets all cached material properties.\n        It is typically not required for the user to call this function.\n        \"\"\"\n        self._cached = {}",
  "def get_layer(self, name):\n        \"\"\"\n        Returns a layer with a given name\n\n        :param name: Given name of a layer\n        :type name: str\n\n        :returns: Layer with the given name.\n        :rtype: :class:`burnman.Layer`\n        \"\"\"\n        for layer in self.layers:\n            if layer.name == name:\n                return layer\n        raise LookupError()",
  "def get_layer_by_radius(self, radius):\n        \"\"\"\n        Returns a layer in which this radius lies\n\n        :param radius: Radius at which to evaluate the layer.\n        :type radius: float\n\n        :returns: Layer in which the radius lies.\n        :rtype: :class:`burnman.Layer`\n        \"\"\"\n        for layer in self.layers:\n            if layer.outer_radius >= radius:\n                return layer\n        raise LookupError()",
  "def evaluate(self, properties, radlist=None):\n        \"\"\"\n        Function that is generally used to evaluate properties\n        of the different layers and stitch them together.\n        If asking for different radii than the internal radlist,\n        pressure and temperature values are interpolated and the\n        layer material evaluated at those pressures and\n        temperatures.\n\n        :param properties: List of properties to evaluate\n        :type properties: list of strings\n        :param radlist: Radii to evaluate properties at. If left empty,\n            internal radius lists are used.\n        :type radlist: array of floats\n\n        :returns: 1D or 2D array of requested properties\n            (1D if only one property was requested)\n        :rtype: numpy.array\n        \"\"\"\n        if radlist is None:\n            values = np.empty(\n                [len(properties), np.sum([len(layer.radii) for layer in self.layers])]\n            )\n            for i, prop in enumerate(properties):\n                if prop == \"depth\":\n                    values[i] = np.array(\n                        [\n                            self.radius_planet - r\n                            for layer in self.layers\n                            for r in layer.radii\n                        ]\n                    )\n                else:\n                    j = 0\n                    for layer in self.layers:\n                        vals = getattr(layer, prop)\n                        values[i, j : j + len(vals)] = vals\n                        j += len(vals)\n        else:\n            values = np.empty([len(properties), len(radlist)])\n            l_idx = [\n                i\n                for i, layer in enumerate(self.layers)\n                for r in radlist\n                if r >= layer.inner_radius and r <= layer.outer_radius\n            ]\n\n            for j, r in enumerate(radlist):\n                values[:, j] = (\n                    self.layers[l_idx[j]]\n                    .evaluate(properties, [r], self.radius_planet)\n                    .T[0]\n                )\n\n        if values.shape[0] == 1:\n            values = values[0]\n        return values",
  "def set_pressure_mode(\n        self,\n        pressure_mode=\"self-consistent\",\n        pressures=None,\n        pressure_top=0.0,\n        gravity_bottom=0.0,\n        n_max_iterations=50,\n        max_delta=1.0e-5,\n    ):\n        \"\"\"\n        Sets the pressure mode of the planet by user-defined values are in a\n        self-consistent fashion.\n        pressure_mode is 'user-defined' or 'self-consistent'.\n        The default for the planet is self-consistent, with zero pressure at\n        the surface and zero pressure at the center.\n\n        :param pressure_mode: This can be set to 'user-defined' or 'self-consistent'.\n        :type pressure_mode: str\n        :param pressures: Pressures (Pa) to set layer to ('user-defined').\n            This should be the same length as defined radius array for the layer.\n        :type pressures: array of floats\n        :param pressure_top: Pressure (Pa) at the top of the layer.\n        :type pressure_top: float\n        :param gravity_bottom: Gravity (m/s^2) at the bottom the layer\n        :type gravity_bottom: float\n        :param n_max_iterations: Maximum number of iterations to reach\n            self-consistent pressures.\n        :type n_max_iterations: int\n        \"\"\"\n        self.reset()\n        assert pressure_mode == \"user-defined\" or pressure_mode == \"self-consistent\"\n\n        self.pressure_mode = pressure_mode\n        self.gravity_bottom = gravity_bottom\n\n        if pressure_mode == \"user-defined\":\n            assert len(pressures) == len(self.radii)\n            self._pressures = pressures\n            warnings.warn(\n                \"User-defined pressures mean that the planet is \"\n                \"unlikely to be self-consistent\"\n            )\n\n        if pressure_mode == \"self-consistent\":\n            self.pressure_top = pressure_top\n            self.n_max_iterations = n_max_iterations\n            self.max_delta = max_delta",
  "def make(self):\n        \"\"\"\n        This routine needs to be called before evaluating any properties.\n        If pressures and temperatures are self-consistent, they\n        are computed across the planet here. Also initializes an array of materials\n        in each Layer to compute properties from.\n        \"\"\"\n\n        self.reset()\n        for layer in self.layers:\n            assert layer.temperature_mode is not None\n\n        if self.pressure_mode == \"user-defined\":\n            self._temperatures = self._evaluate_temperature(self._pressures)\n\n        if self.pressure_mode == \"self-consistent\":\n            new_press = (\n                self.pressure_top + (-self.radii + max(self.radii)) * 1.0e3\n            )  # initial pressure curve guess\n            temperatures = self._evaluate_temperature(new_press)\n\n            # Make it self-consistent!!!\n            i = 0\n            while i < self.n_max_iterations:\n                i += 1\n                ref_press = new_press\n                new_grav, new_press = self._evaluate_eos(\n                    new_press, temperatures, self.gravity_bottom, self.pressure_top\n                )\n                temperatures = self._evaluate_temperature(new_press)\n                rel_err = abs((max(ref_press) - max(new_press)) / max(new_press))\n                if self.verbose:\n                    print(\n                        f\"Iteration {i:0d} maximum relative pressure error: \"\n                        f\"{rel_err:.1e}\"\n                    )\n\n                if rel_err < self.max_delta:\n                    break\n\n            self.pressures = new_press\n            self.temperatures = temperatures\n            self._gravity = new_grav\n\n        for layer in self.layers:\n            layer.sublayers = []\n            layer.pressures = self.pressures[layer.n_start : layer.n_end]\n            layer.temperatures = self.temperatures[layer.n_start : layer.n_end]\n            layer.gravity_bottom = self._gravity[layer.n_start - 1]\n            layer.pressure_mode = \"set-in-planet\"\n            for i in range(len(layer.radii)):\n                layer.sublayers.append(layer.material.copy())\n                layer.sublayers[i].set_state(layer.pressures[i], layer.temperatures[i])",
  "def _evaluate_eos(self, pressures, temperatures, gravity_bottom, pressure_top):\n        \"\"\"\n        Used to update the pressure profile in set_state()\n        \"\"\"\n        density = self._evaluate_density(pressures, temperatures)\n        grav = self._compute_gravity(density, gravity_bottom)\n        press = self._compute_pressure(density, grav, pressure_top)\n        return grav, press",
  "def _evaluate_density(self, pressures, temperatures):\n        \"\"\"\n        Used to update the density profile in _evaluate_eos()\n        \"\"\"\n        density = []\n        for layer in self.layers:\n            density.append(\n                layer.material.evaluate(\n                    [\"density\"],\n                    pressures[layer.n_start : layer.n_end],\n                    temperatures[layer.n_start : layer.n_end],\n                )\n            )\n        return np.squeeze(np.hstack(density))",
  "def _evaluate_temperature(self, pressures):\n        \"\"\"\n        Returns the temperatures of different layers for given pressures.\n        Used by set_state()\n        \"\"\"\n        temps = []\n        temperature_top = None\n        for layer in self.layers[::-1]:\n            if temperature_top is None or layer.temperature_top is not None:\n                temperature_top = layer.temperature_top\n            temps.extend(\n                layer._evaluate_temperature(\n                    (pressures[layer.n_start : layer.n_end]), temperature_top\n                )[::-1]\n            )\n            temperature_top = temps[-1]\n        return np.hstack(np.squeeze(temps))[::-1]",
  "def _compute_gravity(self, density, gravity_bottom):\n        \"\"\"\n        Calculate the gravity of the planet, based on a density profile.\n        This integrates Poisson's equation in radius, under the assumption\n        that the planet is laterally homogeneous.\n        Used to update the gravity profile in _evaluate_eos()\n        \"\"\"\n\n        start_gravity = gravity_bottom\n        grav = []\n        for layer in self.layers:\n            grav.extend(\n                layer._compute_gravity(\n                    density[layer.n_start : layer.n_end], start_gravity\n                )\n            )\n            start_gravity = grav[-1]\n\n        return np.array(grav)",
  "def _compute_pressure(self, density, gravity, pressure_top):\n        \"\"\"\n        Calculate the pressure profile based on density and gravity.\n        This integrates the equation for hydrostatic equilibrium P = rho g z.\n        Used to update the pressure profile in _evaluate_eos()\n        \"\"\"\n        start_pressure = pressure_top\n        press = []\n        for layer in self.layers[::-1]:\n            press.extend(\n                layer._compute_pressure(\n                    density[layer.n_start : layer.n_end],\n                    gravity[layer.n_start : layer.n_end],\n                    start_pressure,\n                )[::-1]\n            )\n            start_pressure = press[-1]\n        return np.array(press)[::-1]",
  "def mass(self):\n        \"\"\"\n        calculates the mass of the entire planet [kg]\n        \"\"\"\n        return np.sum([layer.mass for layer in self.layers])",
  "def average_density(self):\n        \"\"\"\n        calculates the average density of the entire planet [kg/m^3]\n        \"\"\"\n        return self.mass / self.volume",
  "def moment_of_inertia(self):\n        \"\"\"\n        #Returns the moment of inertia of the planet [kg m^2]\n        \"\"\"\n        return np.sum([layer.moment_of_inertia for layer in self.layers])",
  "def moment_of_inertia_factor(self):\n        \"\"\"\n        #Returns the moment of inertia of the planet [kg m^2]\n        \"\"\"\n        moment_factor = (\n            self.moment_of_inertia / self.mass / self.radius_planet / self.radius_planet\n        )\n        return moment_factor",
  "def depth(self):\n        \"\"\"\n        Returns depth of the layer [m]\n        \"\"\"\n        return self.evaluate([\"depth\"])",
  "def gravity(self):\n        \"\"\"\n        Returns gravity of the layer [m s^(-2)]\n        \"\"\"\n        return self.evaluate([\"gravity\"])",
  "def bullen(self):\n        \"\"\"\n        Returns the Bullen parameter\n        \"\"\"\n        return self.evaluate([\"bullen\"])",
  "def brunt_vasala(self):\n        return self.evaluate([\"brunt_vasala\"])",
  "def pressure(self):\n        \"\"\"\n        Returns current pressure that was set with\n        :func:`~burnman.Material.set_state`.\n\n        Aliased with :func:`~burnman.Material.P`.\n\n        :returns: Pressure in [Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.pressures",
  "def temperature(self):\n        \"\"\"\n        Returns current temperature that was set with\n        :func:`~burnman.Material.set_state`.\n\n        Aliased with :func:`~burnman.Material.T`.\n\n        :returns: Temperature in [K].\n        :rtype: array of floats\n        \"\"\"\n        return self.temperatures",
  "def molar_internal_energy(self):\n        \"\"\"\n        Returns the molar internal energy of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.energy`.\n\n        :returns: The internal energy in [J/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_internal_energy\"])",
  "def molar_gibbs(self):\n        \"\"\"\n        Returns the molar Gibbs free energy of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.gibbs`.\n\n        :returns: Gibbs energy in [J/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_gibbs\"])",
  "def molar_helmholtz(self):\n        \"\"\"\n        Returns the molar Helmholtz free energy of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.helmholtz`.\n\n        :returns: Helmholtz energy in [J/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_helmholtz\"])",
  "def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the planet.\n\n        Needs to be implemented in derived classes.\n\n        :returns: Molar mass in [kg/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_mass\"])",
  "def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.V`.\n\n        :returns: Molar volume in [m^3/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_volume\"])",
  "def density(self):\n        \"\"\"\n        Returns the density of this planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.rho`.\n\n        :returns: The density of this material in [kg/m^3].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"density\"])",
  "def molar_entropy(self):\n        \"\"\"\n        Returns molar entropy of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.S`.\n\n        :returns: Entropy in [J/K/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_entropy\"])",
  "def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpy of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.H`.\n\n        :returns: Enthalpy in [J/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_enthalpy\"])",
  "def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.K_T`.\n\n        :returns: Isothermal bulk modulus in [Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"isothermal_bulk_modulus\"])",
  "def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns the adiabatic bulk modulus of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.K_S`.\n\n        :returns: Adiabatic bulk modulus in [Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"adiabatic_bulk_modulus\"])",
  "def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the planet\n        (or inverse isothermal bulk modulus).\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_T`.\n\n        :returns: Isothermal compressibility in [1/Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"istothermal_compressibility\"])",
  "def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibility of the planet\n        (or inverse adiabatic bulk modulus).\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_S`.\n\n        :returns: Adiabatic compressibility in [1/Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"adiabatic_compressibility\"])",
  "def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_G`.\n\n        :returns: Shear modulus in [Pa].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"shear_modulus\"])",
  "def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_p`.\n\n        :returns: P wave speed in [m/s].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"p_wave_velocity\"])",
  "def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_phi`.\n\n        :returns: Bulk sound velocity in [m/s].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"bulk_sound_velocity\"])",
  "def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_s`.\n\n        :returns: Shear wave speed in [m/s].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"shear_wave_velocity\"])",
  "def grueneisen_parameter(self):\n        \"\"\"\n        Returns the grueneisen parameter of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.gr`.\n\n        :returns: Grueneisen parameters [unitless].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"grueneisen_parameter\"])",
  "def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.alpha`.\n\n        :returns: Thermal expansivity in [1/K].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"thermal_expansivity\"])",
  "def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volume of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.C_v`.\n\n        :returns: Isochoric heat capacity in [J/K/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_heat_capacity_v\"])",
  "def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar heat capacity at constant pressure of the planet.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.C_p`.\n\n        :returns: Isobaric heat capacity in [J/K/mol].\n        :rtype: array of floats\n        \"\"\"\n        return self.evaluate([\"molar_heat_capacity_p\"])",
  "def P(self):\n        \"\"\"Alias for :func:`~burnman.Material.pressure`\"\"\"\n        return self.pressure",
  "def T(self):\n        \"\"\"Alias for :func:`~burnman.Material.temperature`\"\"\"\n        return self.temperature",
  "def energy(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_internal_energy`\"\"\"\n        return self.molar_internal_energy",
  "def helmholtz(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_helmholtz`\"\"\"\n        return self.molar_helmholtz",
  "def gibbs(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_gibbs`\"\"\"\n        return self.molar_gibbs",
  "def V(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_volume`\"\"\"\n        return self.molar_volume",
  "def rho(self):\n        \"\"\"Alias for :func:`~burnman.Material.density`\"\"\"\n        return self.density",
  "def S(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_entropy`\"\"\"\n        return self.molar_entropy",
  "def H(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_enthalpy`\"\"\"\n        return self.molar_enthalpy",
  "def K_T(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_bulk_modulus`\"\"\"\n        return self.isothermal_bulk_modulus",
  "def K_S(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_bulk_modulus`\"\"\"\n        return self.adiabatic_bulk_modulus",
  "def beta_T(self):\n        \"\"\"Alias for :func:`~burnman.Material.isothermal_compressibility`\"\"\"\n        return self.isothermal_compressibility",
  "def beta_S(self):\n        \"\"\"Alias for :func:`~burnman.Material.adiabatic_compressibility`\"\"\"\n        return self.adiabatic_compressibility",
  "def G(self):\n        \"\"\"Alias for :func:`~burnman.Material.shear_modulus`\"\"\"\n        return self.shear_modulus",
  "def v_p(self):\n        \"\"\"Alias for :func:`~burnman.Material.p_wave_velocity`\"\"\"\n        return self.p_wave_velocity",
  "def v_phi(self):\n        \"\"\"Alias for :func:`~burnman.Material.bulk_sound_velocity`\"\"\"\n        return self.bulk_sound_velocity",
  "def v_s(self):\n        \"\"\"Alias for :func:`~burnman.Material.shear_wave_velocity`\"\"\"\n        return self.shear_wave_velocity",
  "def gr(self):\n        \"\"\"Alias for :func:`~burnman.Material.grueneisen_parameter`\"\"\"\n        return self.grueneisen_parameter",
  "def alpha(self):\n        \"\"\"Alias for :func:`~burnman.Material.thermal_expansivity`\"\"\"\n        return self.thermal_expansivity",
  "def C_v(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_v`\"\"\"\n        return self.molar_heat_capacity_v",
  "def C_p(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_p`\"\"\"\n        return self.molar_heat_capacity_p",
  "class Mineral(Material):\n\n    \"\"\"\n    This is the base class for all minerals. States of the mineral\n    can only be queried after setting the pressure and temperature\n    using set_state(). The method for computing properties of\n    the material is set using set_method(). This is done during\n    initialisation if the param 'equation_of_state' has been defined.\n    The method can be overridden later by the user.\n\n    This class is available as ``burnman.Mineral``.\n\n    If deriving from this class, set the properties in self.params\n    to the desired values. For more complicated materials you\n    can overwrite set_state(), change the params and then call\n    set_state() from this class.\n\n    All the material parameters are expected to be in plain SI units.  This\n    means that the elastic moduli should be in Pascals and NOT Gigapascals,\n    and the Debye temperature should be in K not C.  Additionally, the\n    reference volume should be in m^3/(mol molecule) and not in unit cell\n    volume and 'n' should be the number of atoms per molecule.  Frequently in\n    the literature the reference volume is given in Angstrom^3 per unit cell.\n    To convert this to m^3/(mol of molecule) you should multiply by 10^(-30) *\n    N_a / Z, where N_a is Avogadro's number and Z is the number of formula units per\n    unit cell. You can look up Z in many places, including www.mindat.org\n    \"\"\"\n\n    def __init__(self, params=None, property_modifiers=None):\n        Material.__init__(self)\n        if params is not None:\n            self.params = params\n        elif \"params\" not in self.__dict__:\n            self.params = {}\n\n        if property_modifiers is not None:\n            self.property_modifiers = property_modifiers\n        elif \"property_modifiers\" not in self.__dict__:\n            self.property_modifiers = []\n\n        self.method = None\n        if \"equation_of_state\" in self.params:\n            self.set_method(self.params[\"equation_of_state\"])\n        if \"name\" in self.params:\n            self.name = self.params[\"name\"]\n\n    def set_method(self, equation_of_state):\n        \"\"\"\n        Set the equation of state to be used for this mineral.\n        Takes a string corresponding to any of the predefined\n        equations of state:  'bm2', 'bm3', 'mgd2', 'mgd3', 'slb2', 'slb3',\n        'mt', 'hp_tmt', or 'cork'.  Alternatively, you can pass a user defined\n        class which derives from the equation_of_state base class.\n        After calling set_method(), any existing derived properties\n        (e.g., elastic parameters or thermodynamic potentials) will be out\n        of date, so set_state() will need to be called again.\n        \"\"\"\n\n        if equation_of_state is None:\n            self.method = None\n            return\n\n        new_method = eos.create(equation_of_state)\n        if self.method is not None and \"equation_of_state\" in self.params:\n            self.method = eos.create(self.params[\"equation_of_state\"])\n\n        if type(new_method).__name__ == \"instance\":\n            raise Exception(\n                \"Please derive your method from object (see python old style classes)\"\n            )\n\n        if (\n            self.method is not None\n            and isinstance(new_method, type(self.method)) is False\n        ):\n            # Warn user that they are changing the EoS\n            warnings.warn(\n                \"Warning, you are changing the method to \"\n                f\"{new_method.__class__.__name__} even though the \"\n                \"material is designed to be used with the method \"\n                f\"{self.method.__class__.__name__}. \"\n                \"This does not overwrite any mineral attributes\",\n                stacklevel=2,\n            )\n            self.reset()\n\n        self.method = new_method\n\n        # Validate the params object on the requested EOS.\n        try:\n            self.method.validate_parameters(self.params)\n        except Exception as e:\n            print(\n                f\"Mineral {self.to_string()} failed to validate parameters \"\n                f'with message: \"{e.message}\"'\n            )\n            raise\n\n        # Invalidate the cache upon resetting the method\n        self.reset()\n\n    def to_string(self):\n        \"\"\"\n        Returns the name of the mineral class\n        \"\"\"\n        return (\n            \"'\"\n            + self.__class__.__module__.replace(\".minlib_\", \".\")\n            + \".\"\n            + self.__class__.__name__\n            + \"'\"\n        )\n\n    def debug_print(self, indent=\"\"):\n        print(\"%s%s\" % (indent, self.to_string()))\n\n    def unroll(self):\n        return ([self], [1.0])\n\n    @copy_documentation(Material.set_state)\n    def set_state(self, pressure, temperature):\n        Material.set_state(self, pressure, temperature)\n        self._property_modifiers = (\n            eos.property_modifiers.calculate_property_modifications(self)\n        )\n\n        if self.method is None:\n            raise AttributeError(\n                \"no method set for mineral, or equation_of_state given in mineral.params\"\n            )\n\n    \"\"\"\n    Properties from equations of state\n    We choose the P, T properties (e.g. Gibbs(P, T) rather than Helmholtz(V, T)),\n    as it allows us to more easily apply corrections to the free energy\n    \"\"\"\n\n    @material_property\n    @copy_documentation(Material.molar_gibbs)\n    def molar_gibbs(self):\n        return (\n            self.method.gibbs_free_energy(\n                self.pressure,\n                self.temperature,\n                self._molar_volume_unmodified,\n                self.params,\n            )\n            + self._property_modifiers[\"G\"]\n        )\n\n    @material_property\n    def _molar_volume_unmodified(self):\n        return self.method.volume(self.pressure, self.temperature, self.params)\n\n    @material_property\n    @copy_documentation(Material.molar_volume)\n    def molar_volume(self):\n        return self._molar_volume_unmodified + self._property_modifiers[\"dGdP\"]\n\n    @material_property\n    @copy_documentation(Material.molar_entropy)\n    def molar_entropy(self):\n        return (\n            self.method.entropy(\n                self.pressure,\n                self.temperature,\n                self._molar_volume_unmodified,\n                self.params,\n            )\n            - self._property_modifiers[\"dGdT\"]\n        )\n\n    @material_property\n    @copy_documentation(Material.isothermal_bulk_modulus)\n    def isothermal_bulk_modulus(self):\n        K_T_orig = self.method.isothermal_bulk_modulus(\n            self.pressure, self.temperature, self._molar_volume_unmodified, self.params\n        )\n\n        return self.molar_volume / (\n            (self._molar_volume_unmodified / K_T_orig)\n            - self._property_modifiers[\"d2GdP2\"]\n        )\n\n    @material_property\n    @copy_documentation(Material.molar_heat_capacity_p)\n    def molar_heat_capacity_p(self):\n        return (\n            self.method.molar_heat_capacity_p(\n                self.pressure,\n                self.temperature,\n                self._molar_volume_unmodified,\n                self.params,\n            )\n            - self.temperature * self._property_modifiers[\"d2GdT2\"]\n        )\n\n    @material_property\n    @copy_documentation(Material.thermal_expansivity)\n    def thermal_expansivity(self):\n        return (\n            (\n                self.method.thermal_expansivity(\n                    self.pressure,\n                    self.temperature,\n                    self._molar_volume_unmodified,\n                    self.params,\n                )\n                * self._molar_volume_unmodified\n            )\n            + self._property_modifiers[\"d2GdPdT\"]\n        ) / self.molar_volume\n\n    @material_property\n    @copy_documentation(Material.shear_modulus)\n    def shear_modulus(self):\n        G = self.method.shear_modulus(\n            self.pressure, self.temperature, self._molar_volume_unmodified, self.params\n        )\n        if G < np.finfo(\"float\").eps:\n            warnings.formatwarning = (\n                lambda msg, *a: \"Warning from file '{0}', line {1}:\\n{2}\\n\\n\".format(\n                    a[1], a[2], msg\n                )\n            )\n            warnings.warn(\n                \"You are trying to calculate shear modulus for {0} when it is exactly zero. \\n\"\n                \"If {0} is a liquid, then you can safely ignore this warning, but consider \\n\"\n                \"calculating bulk modulus or bulk sound rather than Vp or Vs. \\n\"\n                \"If {0} is not a liquid, then shear modulus calculations for the \\n\"\n                \"underlying equation of state ({1}) have not been implemented, \\n\"\n                \"and Vp and Vs estimates will be incorrect.\".format(\n                    self.name, self.method.__class__.__name__\n                ),\n                stacklevel=1,\n            )\n        return G\n\n    \"\"\"\n    Properties from mineral parameters,\n    Legendre transformations\n    or Maxwell relations\n    \"\"\"\n\n    @material_property\n    def formula(self):\n        \"\"\"\n        Returns the chemical formula of the Mineral class\n        \"\"\"\n        if \"formula\" in self.params:\n            return self.params[\"formula\"]\n        else:\n            raise ValueError(\n                \"No formula parameter for mineral {0}.\".format(self.to_string)\n            )\n\n    @material_property\n    @copy_documentation(Material.molar_mass)\n    def molar_mass(self):\n        if \"molar_mass\" in self.params:\n            return self.params[\"molar_mass\"]\n        else:\n            raise ValueError(\n                \"No molar_mass parameter for mineral {0}.\".format(self.to_string)\n            )\n\n    @material_property\n    @copy_documentation(Material.density)\n    def density(self):\n        return self.molar_mass / self.molar_volume\n\n    @material_property\n    @copy_documentation(Material.molar_internal_energy)\n    def molar_internal_energy(self):\n        return (\n            self.molar_gibbs\n            - self.pressure * self.molar_volume\n            + self.temperature * self.molar_entropy\n        )\n\n    @material_property\n    @copy_documentation(Material.molar_helmholtz)\n    def molar_helmholtz(self):\n        return self.molar_gibbs - self.pressure * self.molar_volume\n\n    @material_property\n    @copy_documentation(Material.molar_enthalpy)\n    def molar_enthalpy(self):\n        return self.molar_gibbs + self.temperature * self.molar_entropy\n\n    @material_property\n    @copy_documentation(Material.adiabatic_bulk_modulus)\n    def adiabatic_bulk_modulus(self):\n        if self.temperature < 1.0e-10:\n            return self.isothermal_bulk_modulus\n        else:\n            return (\n                self.isothermal_bulk_modulus\n                * self.molar_heat_capacity_p\n                / self.molar_heat_capacity_v\n            )\n\n    @material_property\n    @copy_documentation(Material.isothermal_compressibility)\n    def isothermal_compressibility(self):\n        return 1.0 / self.isothermal_bulk_modulus\n\n    @material_property\n    @copy_documentation(Material.adiabatic_compressibility)\n    def adiabatic_compressibility(self):\n        return 1.0 / self.adiabatic_bulk_modulus\n\n    @material_property\n    @copy_documentation(Material.p_wave_velocity)\n    def p_wave_velocity(self):\n        return np.sqrt(\n            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)\n            / self.density\n        )\n\n    @material_property\n    @copy_documentation(Material.bulk_sound_velocity)\n    def bulk_sound_velocity(self):\n        return np.sqrt(self.adiabatic_bulk_modulus / self.density)\n\n    @material_property\n    @copy_documentation(Material.shear_wave_velocity)\n    def shear_wave_velocity(self):\n        return np.sqrt(self.shear_modulus / self.density)\n\n    @material_property\n    @copy_documentation(Material.grueneisen_parameter)\n    def grueneisen_parameter(self):\n        eps = np.finfo(\"float\").eps\n        if np.abs(self.molar_heat_capacity_v) > eps:\n            return (\n                self.thermal_expansivity\n                * self.isothermal_bulk_modulus\n                * self.molar_volume\n                / self.molar_heat_capacity_v\n            )\n        elif (\n            (np.abs(self._property_modifiers[\"d2GdPdT\"]) < eps)\n            and (np.abs(self._property_modifiers[\"d2GdP2\"]) < eps)\n            and (np.abs(self._property_modifiers[\"dGdP\"]) < eps)\n            and (np.abs(self._property_modifiers[\"d2GdT2\"]) < eps)\n        ):\n            return self.method.grueneisen_parameter(\n                self.pressure, self.temperature, self.molar_volume, self.params\n            )\n        else:\n            raise Exception(\n                \"You are trying to calculate the grueneisen parameter at a temperature where the heat capacity is very low and where you have defined Gibbs property modifiers.\"\n            )\n\n    @material_property\n    @copy_documentation(Material.molar_heat_capacity_v)\n    def molar_heat_capacity_v(self):\n        return (\n            self.molar_heat_capacity_p\n            - self.molar_volume\n            * self.temperature\n            * self.thermal_expansivity\n            * self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n        )",
  "def __init__(self, params=None, property_modifiers=None):\n        Material.__init__(self)\n        if params is not None:\n            self.params = params\n        elif \"params\" not in self.__dict__:\n            self.params = {}\n\n        if property_modifiers is not None:\n            self.property_modifiers = property_modifiers\n        elif \"property_modifiers\" not in self.__dict__:\n            self.property_modifiers = []\n\n        self.method = None\n        if \"equation_of_state\" in self.params:\n            self.set_method(self.params[\"equation_of_state\"])\n        if \"name\" in self.params:\n            self.name = self.params[\"name\"]",
  "def set_method(self, equation_of_state):\n        \"\"\"\n        Set the equation of state to be used for this mineral.\n        Takes a string corresponding to any of the predefined\n        equations of state:  'bm2', 'bm3', 'mgd2', 'mgd3', 'slb2', 'slb3',\n        'mt', 'hp_tmt', or 'cork'.  Alternatively, you can pass a user defined\n        class which derives from the equation_of_state base class.\n        After calling set_method(), any existing derived properties\n        (e.g., elastic parameters or thermodynamic potentials) will be out\n        of date, so set_state() will need to be called again.\n        \"\"\"\n\n        if equation_of_state is None:\n            self.method = None\n            return\n\n        new_method = eos.create(equation_of_state)\n        if self.method is not None and \"equation_of_state\" in self.params:\n            self.method = eos.create(self.params[\"equation_of_state\"])\n\n        if type(new_method).__name__ == \"instance\":\n            raise Exception(\n                \"Please derive your method from object (see python old style classes)\"\n            )\n\n        if (\n            self.method is not None\n            and isinstance(new_method, type(self.method)) is False\n        ):\n            # Warn user that they are changing the EoS\n            warnings.warn(\n                \"Warning, you are changing the method to \"\n                f\"{new_method.__class__.__name__} even though the \"\n                \"material is designed to be used with the method \"\n                f\"{self.method.__class__.__name__}. \"\n                \"This does not overwrite any mineral attributes\",\n                stacklevel=2,\n            )\n            self.reset()\n\n        self.method = new_method\n\n        # Validate the params object on the requested EOS.\n        try:\n            self.method.validate_parameters(self.params)\n        except Exception as e:\n            print(\n                f\"Mineral {self.to_string()} failed to validate parameters \"\n                f'with message: \"{e.message}\"'\n            )\n            raise\n\n        # Invalidate the cache upon resetting the method\n        self.reset()",
  "def to_string(self):\n        \"\"\"\n        Returns the name of the mineral class\n        \"\"\"\n        return (\n            \"'\"\n            + self.__class__.__module__.replace(\".minlib_\", \".\")\n            + \".\"\n            + self.__class__.__name__\n            + \"'\"\n        )",
  "def debug_print(self, indent=\"\"):\n        print(\"%s%s\" % (indent, self.to_string()))",
  "def unroll(self):\n        return ([self], [1.0])",
  "def set_state(self, pressure, temperature):\n        Material.set_state(self, pressure, temperature)\n        self._property_modifiers = (\n            eos.property_modifiers.calculate_property_modifications(self)\n        )\n\n        if self.method is None:\n            raise AttributeError(\n                \"no method set for mineral, or equation_of_state given in mineral.params\"\n            )",
  "def molar_gibbs(self):\n        return (\n            self.method.gibbs_free_energy(\n                self.pressure,\n                self.temperature,\n                self._molar_volume_unmodified,\n                self.params,\n            )\n            + self._property_modifiers[\"G\"]\n        )",
  "def _molar_volume_unmodified(self):\n        return self.method.volume(self.pressure, self.temperature, self.params)",
  "def molar_volume(self):\n        return self._molar_volume_unmodified + self._property_modifiers[\"dGdP\"]",
  "def molar_entropy(self):\n        return (\n            self.method.entropy(\n                self.pressure,\n                self.temperature,\n                self._molar_volume_unmodified,\n                self.params,\n            )\n            - self._property_modifiers[\"dGdT\"]\n        )",
  "def isothermal_bulk_modulus(self):\n        K_T_orig = self.method.isothermal_bulk_modulus(\n            self.pressure, self.temperature, self._molar_volume_unmodified, self.params\n        )\n\n        return self.molar_volume / (\n            (self._molar_volume_unmodified / K_T_orig)\n            - self._property_modifiers[\"d2GdP2\"]\n        )",
  "def molar_heat_capacity_p(self):\n        return (\n            self.method.molar_heat_capacity_p(\n                self.pressure,\n                self.temperature,\n                self._molar_volume_unmodified,\n                self.params,\n            )\n            - self.temperature * self._property_modifiers[\"d2GdT2\"]\n        )",
  "def thermal_expansivity(self):\n        return (\n            (\n                self.method.thermal_expansivity(\n                    self.pressure,\n                    self.temperature,\n                    self._molar_volume_unmodified,\n                    self.params,\n                )\n                * self._molar_volume_unmodified\n            )\n            + self._property_modifiers[\"d2GdPdT\"]\n        ) / self.molar_volume",
  "def shear_modulus(self):\n        G = self.method.shear_modulus(\n            self.pressure, self.temperature, self._molar_volume_unmodified, self.params\n        )\n        if G < np.finfo(\"float\").eps:\n            warnings.formatwarning = (\n                lambda msg, *a: \"Warning from file '{0}', line {1}:\\n{2}\\n\\n\".format(\n                    a[1], a[2], msg\n                )\n            )\n            warnings.warn(\n                \"You are trying to calculate shear modulus for {0} when it is exactly zero. \\n\"\n                \"If {0} is a liquid, then you can safely ignore this warning, but consider \\n\"\n                \"calculating bulk modulus or bulk sound rather than Vp or Vs. \\n\"\n                \"If {0} is not a liquid, then shear modulus calculations for the \\n\"\n                \"underlying equation of state ({1}) have not been implemented, \\n\"\n                \"and Vp and Vs estimates will be incorrect.\".format(\n                    self.name, self.method.__class__.__name__\n                ),\n                stacklevel=1,\n            )\n        return G",
  "def formula(self):\n        \"\"\"\n        Returns the chemical formula of the Mineral class\n        \"\"\"\n        if \"formula\" in self.params:\n            return self.params[\"formula\"]\n        else:\n            raise ValueError(\n                \"No formula parameter for mineral {0}.\".format(self.to_string)\n            )",
  "def molar_mass(self):\n        if \"molar_mass\" in self.params:\n            return self.params[\"molar_mass\"]\n        else:\n            raise ValueError(\n                \"No molar_mass parameter for mineral {0}.\".format(self.to_string)\n            )",
  "def density(self):\n        return self.molar_mass / self.molar_volume",
  "def molar_internal_energy(self):\n        return (\n            self.molar_gibbs\n            - self.pressure * self.molar_volume\n            + self.temperature * self.molar_entropy\n        )",
  "def molar_helmholtz(self):\n        return self.molar_gibbs - self.pressure * self.molar_volume",
  "def molar_enthalpy(self):\n        return self.molar_gibbs + self.temperature * self.molar_entropy",
  "def adiabatic_bulk_modulus(self):\n        if self.temperature < 1.0e-10:\n            return self.isothermal_bulk_modulus\n        else:\n            return (\n                self.isothermal_bulk_modulus\n                * self.molar_heat_capacity_p\n                / self.molar_heat_capacity_v\n            )",
  "def isothermal_compressibility(self):\n        return 1.0 / self.isothermal_bulk_modulus",
  "def adiabatic_compressibility(self):\n        return 1.0 / self.adiabatic_bulk_modulus",
  "def p_wave_velocity(self):\n        return np.sqrt(\n            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)\n            / self.density\n        )",
  "def bulk_sound_velocity(self):\n        return np.sqrt(self.adiabatic_bulk_modulus / self.density)",
  "def shear_wave_velocity(self):\n        return np.sqrt(self.shear_modulus / self.density)",
  "def grueneisen_parameter(self):\n        eps = np.finfo(\"float\").eps\n        if np.abs(self.molar_heat_capacity_v) > eps:\n            return (\n                self.thermal_expansivity\n                * self.isothermal_bulk_modulus\n                * self.molar_volume\n                / self.molar_heat_capacity_v\n            )\n        elif (\n            (np.abs(self._property_modifiers[\"d2GdPdT\"]) < eps)\n            and (np.abs(self._property_modifiers[\"d2GdP2\"]) < eps)\n            and (np.abs(self._property_modifiers[\"dGdP\"]) < eps)\n            and (np.abs(self._property_modifiers[\"d2GdT2\"]) < eps)\n        ):\n            return self.method.grueneisen_parameter(\n                self.pressure, self.temperature, self.molar_volume, self.params\n            )\n        else:\n            raise Exception(\n                \"You are trying to calculate the grueneisen parameter at a temperature where the heat capacity is very low and where you have defined Gibbs property modifiers.\"\n            )",
  "def molar_heat_capacity_v(self):\n        return (\n            self.molar_heat_capacity_p\n            - self.molar_volume\n            * self.temperature\n            * self.thermal_expansivity\n            * self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n        )",
  "class Layer(object):\n    \"\"\"\n    The base class for a planetary layer.\n    The user needs to set the following before properties can be computed:\n\n    - set_material(), which sets the material of the layer,\n      e.g. a mineral, solid_solution, or composite\n    - set_temperature_mode(), either predefine, or set to an adiabatic profile\n    - set_pressure_mode(), to set the self-consistent pressure\n      (with user-defined option the pressures can be overwritten).\n      To set the self-consistent pressure the pressure at the top and the\n      gravity at the bottom of the layer need to be set.\n    - make(), computes the self-consistent part of the layer and starts the\n      settings to compute properties within the layer\n\n    Note that the entire planet this layer sits in is not necessarily\n    self-consistent, as the pressure at the top of the layer is a\n    function of the density within the layer (through the gravity).\n    Entire planets can be computed self-consistently with the planet class.\n    Properties will be returned at the pre-defined radius array,\n    although the evaluate() function can take a newly defined depthlist\n    and values are interpolated between these (sufficient sampling of the layer\n    is needed for this to be accurate).\n    \"\"\"\n\n    def __init__(self, name=None, radii=None, verbose=False):\n        self.name = name\n        assert np.all(np.diff(radii) > 0)\n        self.radii = radii\n        self.outer_radius = max(self.radii)\n        self.inner_radius = min(self.radii)\n        self.thickness = self.outer_radius - self.inner_radius\n        self.n_slices = len(self.radii)\n        self.verbose = verbose\n        self._cached = {}\n        self._pressures = None\n        self._temperatures = None\n        self.sublayers = None\n        self.material = None\n        self.pressure_mode = \"self-consistent\"\n        self.temperature_mode = None\n\n    def __str__(self):\n        \"\"\"\n        Prints details of the layer\n        \"\"\"\n        writing = (\n            f\"The {self.name} is made of {self.material.name}\"\n            f\" with {self.temperature_mode} temperatures and \"\n            f\"{self.pressure_mode} pressures\\n\"\n        )\n        return writing\n\n    def reset(self):\n        \"\"\"\n        Resets all cached material properties.\n        It is typically not required for the user to call this function.\n        \"\"\"\n        self._cached = {}\n        self._pressures = None\n        self._temperatures = None\n        self.sublayers = None\n\n    def set_material(self, material):\n        \"\"\"\n        Set the material of a Layer with a Material\n        \"\"\"\n        assert isinstance(material, Material)\n        self.material = material\n        self.reset()\n\n    def set_temperature_mode(\n        self, temperature_mode=\"adiabatic\", temperatures=None, temperature_top=None\n    ):\n        \"\"\"\n        Sets temperatures within the layer as user-defined values or as\n        a (potentially perturbed) adiabat.\n\n        :param temperature_mode: This can be set to 'user-defined', 'adiabatic',\n            or 'perturbed-adiabatic'. 'user-defined' fixes the temperature\n            with the profile input by the user. 'adiabatic' self-consistently\n            computes the adiabat when setting the state of the layer.\n            'perturbed-adiabatic' adds the user input array to the adiabat.\n            This allows the user to apply boundary layers (for example).\n        :type temperature_mode: string\n        :param temperatures: The desired fixed temperatures in [K].\n            Should have same length as defined radii in layer.\n        :type temperatures: array of float\n        :param temperature_top: Temperature at the top of the layer.\n            Used if the temperature mode is chosen to be 'adiabatic' or\n            'perturbed-adiabatic'. If 'perturbed-adiabatic' is chosen as the\n            temperature mode, temperature_top corresponds to the true temperature\n            at the top of the layer, and the reference isentrope at this radius\n            is defined to lie at a temperature of\n            temperature_top - temperatures[-1].\n        :type temperature_top: float\n        \"\"\"\n        self.reset()\n        assert (\n            temperature_mode == \"user-defined\"\n            or temperature_mode == \"adiabatic\"\n            or temperature_mode == \"perturbed-adiabatic\"\n        )\n\n        self.temperature_mode = temperature_mode\n\n        if (\n            temperature_mode == \"user-defined\"\n            or temperature_mode == \"perturbed-adiabatic\"\n        ):\n            assert len(temperatures) == len(self.radii)\n            self.usertemperatures = temperatures\n        else:\n            self.usertemperatures = np.zeros_like(self.radii)\n\n        if temperature_mode == \"adiabatic\" or temperature_mode == \"perturbed-adiabatic\":\n            self.temperature_top = temperature_top\n        else:\n            self.temperature_top = None\n\n    def set_pressure_mode(\n        self,\n        pressure_mode=\"self-consistent\",\n        pressures=None,\n        gravity_bottom=None,\n        pressure_top=None,\n        n_max_iterations=50,\n        max_delta=1.0e-5,\n    ):\n        \"\"\"\n        Sets the pressure mode of the layer,\n        which can either be 'user-defined', or 'self-consistent'.\n\n        :param pressure_mode: This can be set to 'user-defined' or 'self-consistent'.\n            'user-defined' fixes the pressures with the profile input\n            by the user in the 'pressures' argument.\n            'self-consistent' forces Layer to calculate pressures\n            self-consistently. If this is selected, the user will need\n            to supply values for the gravity_bottom [m/s^2]\n            and pressure_top [Pa] arguments.\n        :type pressure_mode: string\n        :param pressures: Pressures [Pa] to set layer to\n            (if the 'user-defined' pressure_mode has been selected).\n            The array should be the same length as\n            the layers user-defined radii array.\n        :type pressures: array of floats\n        :param pressure_top: Pressure [Pa] at the top of the layer.\n        :type pressure_top: float\n        :param gravity_bottom: Gravity [m/s^2] at the bottom of the layer.\n        :type gravity_bottom: float\n        :param n_max_iterations: Maximum number of iterations to reach\n            self-consistent pressures.\n        :type n_max_iterations: integer\n        :param max_delta: Relative update to the highest pressure in the layer between\n            iterations to stop iterations.\n        :type max_delta: float\n        \"\"\"\n        self.reset()\n        assert pressure_mode == \"user-defined\" or pressure_mode == \"self-consistent\"\n        self.pressure_mode = pressure_mode\n\n        assert gravity_bottom is not None\n        self.gravity_bottom = gravity_bottom\n\n        if pressure_mode == \"user-defined\":\n            assert pressures is not None\n            assert len(pressures) == len(self.radii)\n            self.pressures = pressures\n            warnings.warn(\n                \"By setting the pressures in Layer they \"\n                \"are unlikely to be self-consistent\"\n            )\n        elif pressure_mode == \"self-consistent\":\n            self.pressure_top = pressure_top\n            self.n_max_iterations = n_max_iterations\n            self.max_delta = max_delta\n        else:\n            raise NotImplementedError(\n                f\"pressure mode {pressure_mode} \" \"not recognised\"\n            )\n\n    def make(self):\n        \"\"\"\n        This routine needs to be called before evaluating any properties.\n        If pressures and temperatures are not user-defined, they\n        are computed here. This method also initializes an array of copied\n        materials from which properties can be computed.\n        \"\"\"\n        self.reset()\n        if not hasattr(self, \"material\"):\n            raise AttributeError(\n                \"You must set_material() for the layer \" \"before running make().\"\n            )\n        if not hasattr(self, \"temperature_mode\"):\n            raise AttributeError(\n                \"You must set_temperature_mode() for the \"\n                \"layer before running make().\"\n            )\n        if not hasattr(self, \"pressure_mode\"):\n            raise AttributeError(\n                \"You must set_pressure_mode() for the layer \" \"before running make().\"\n            )\n\n        if self.pressure_mode == \"user-defined\":\n            self.temperatures = self._evaluate_temperature(\n                self.pressures, self.temperature_top\n            )\n        elif self.pressure_mode == \"self-consistent\":\n            new_press = (\n                self.pressure_top + (-self.radii + max(self.radii)) * 1.0e3\n            )  # initial pressure curve guess\n            temperatures = self._evaluate_temperature(new_press, self.temperature_top)\n            # Make it self-consistent!!!\n            i = 0\n\n            while i < self.n_max_iterations:\n                i += 1\n                ref_press = new_press\n                new_grav, new_press = self._evaluate_eos(\n                    new_press, temperatures, self.gravity_bottom, self.pressure_top\n                )\n                temperatures = self._evaluate_temperature(\n                    new_press, self.temperature_top\n                )\n                rel_err = abs((max(ref_press) - max(new_press)) / max(new_press))\n                if self.verbose:\n                    print(\n                        f\"Iteration {i:0d} maximum relative pressure error: \"\n                        f\"{rel_err:.1f}\"\n                    )\n\n                if rel_err < self.max_delta:\n                    break\n\n            self.pressures = new_press\n            self.temperatures = temperatures\n        else:\n            raise NotImplementedError(\"pressure mode not recognised\")\n\n        self.sublayers = []\n        for r in range(len(self.radii)):\n            self.sublayers.append(self.material.copy())\n            self.sublayers[r].set_state(self.pressures[r], self.temperatures[r])\n\n    def evaluate(self, properties, radlist=None, radius_planet=None):\n        \"\"\"\n        Function that is used to evaluate properties\n        across the layer. If radlist is not defined, values are\n        returned at the internal radlist.\n        If asking for different radii than the internal radlist,\n        pressure and temperature values are interpolated and the\n        layer material evaluated at those pressures and\n        temperatures.\n\n        :param properties: List of properties to evaluate.\n        :type properties: list of strings\n        :param radlist: Radii to evaluate properties at. If left empty,\n            internal radii list is used.\n        :type radlist: array of floats\n        :param planet_radius: Planet outer radius. Used only to calculate depth.\n        :type planet_radius: float\n\n        :returns: 1D or 2D array of requested properties\n            (1D if only one property was requested)\n        :rtype: numpy.array\n        \"\"\"\n\n        if radlist is None:\n            values = np.empty([len(properties), len(self.radii)])\n            for i, prop in enumerate(properties):\n                if prop == \"depth\":\n                    values[i] = radius_planet - self.radii\n                else:\n                    try:\n                        values[i] = getattr(self, prop)\n                    except:\n                        values[i] = np.array(\n                            [\n                                getattr(self.sublayers[i], prop)\n                                for i in range(len(self.sublayers))\n                            ]\n                        )\n        else:\n            func_p = interp1d(self.radii, self.pressures)\n            pressures = func_p(radlist)\n            func_t = interp1d(self.radii, self.temperatures)\n            temperatures = func_t(radlist)\n            values = np.empty([len(properties), len(radlist)])\n            for i, prop in enumerate(properties):\n                if prop == \"depth\":\n                    values[i] = radius_planet - radlist\n                else:\n                    try:\n                        values[i] = self.material.evaluate(\n                            [prop], pressures, temperatures\n                        )\n                    except:\n                        func_prop = interp1d(self.radii, getattr(self, prop))\n                        values[i] = func_prop(radlist)\n\n        if values.shape[0] == 1:\n            values = values[0]\n        return values\n\n    def _evaluate_temperature(self, pressures=None, temperature_top=None):\n        \"\"\"\n        Returns the temperatures of the layer for given pressures.\n        Used by make()\n        \"\"\"\n        if (\n            self.temperature_mode == \"adiabatic\"\n            or self.temperature_mode == \"perturbed-adiabatic\"\n        ):\n            adiabat = geotherm.adiabatic(\n                pressures[::-1],\n                temperature_top - self.usertemperatures[-1],\n                self.material,\n            )[::-1]\n        else:\n            adiabat = np.zeros_like(self.radii)\n        return adiabat + self.usertemperatures\n\n    def _evaluate_eos(self, pressures, temperatures, gravity_bottom, pressure_top):\n        \"\"\"\n        Returns updated gravity and pressure\n        make() loops over this until consistency is achieved.\n        \"\"\"\n        [density] = self.material.evaluate([\"density\"], pressures, temperatures)\n        grav = self._compute_gravity(density, gravity_bottom)\n        press = self._compute_pressure(density, grav, pressure_top)\n        return grav, press\n\n    # Functions needed to compute self-consistent radii-pressures\n    def _compute_gravity(self, density, gravity_bottom):\n        \"\"\"\n        Computes the gravity of a layer\n        Used by _evaluate_eos()\n        \"\"\"\n        # Create a spline fit of density as a function of radius\n        rhofunc = UnivariateSpline(self.radii, density)\n        # Numerically integrate Poisson's equation\n\n        def poisson(p, x):\n            return 4.0 * np.pi * constants.G * rhofunc(x) * x * x\n\n        grav = np.ravel(\n            odeint(poisson, gravity_bottom * self.radii[0] * self.radii[0], self.radii)\n        )\n\n        if self.radii[0] == 0:\n            grav[0] = 0\n            grav[1:] = grav[1:] / self.radii[1:] / self.radii[1:]\n        else:\n            grav[:] = grav[:] / self.radii[:] / self.radii[:]\n        return grav\n\n    def _compute_pressure(self, density, gravity, pressure_top):\n        \"\"\"\n        Calculate the pressure profile based on density and gravity.\n        This integrates the equation for hydrostatic equilibrium P = rho g z.\n        Used by _evaluate_eos()\n        \"\"\"\n        # flip radius, density and gravity to increasing pressure\n        depthfromtop = -self.radii[::-1] + max(self.radii)\n        density = density[::-1]\n        gravity = gravity[::-1]\n        # Make a spline fit of density as a function of depth\n        rhofunc = UnivariateSpline(depthfromtop, density)\n        # Make a spline fit of gravity as a function of depth\n        gfunc = UnivariateSpline(depthfromtop, gravity)\n\n        # integrate the hydrostatic equation\n        pressure = np.ravel(\n            odeint((lambda p, x: gfunc(x) * rhofunc(x)), pressure_top, depthfromtop)\n        )\n\n        return pressure[::-1]\n\n    @property\n    def mass(self):\n        \"\"\"\n        Calculates the mass of the layer [kg]\n        \"\"\"\n        mass = 0.0\n        radii = self.radii\n        density = self.evaluate([\"density\"])\n        rhofunc = UnivariateSpline(radii, density)\n        mass = np.abs(\n            quad(lambda r: 4 * np.pi * rhofunc(r) * r * r, radii[0], radii[-1])[0]\n        )\n        return mass\n\n    @property\n    def moment_of_inertia(self):\n        \"\"\"\n        Returns the moment of inertia of the layer [kg m^2]\n        \"\"\"\n        moment = 0.0\n        radii = self.radii\n        density = self.evaluate([\"density\"])\n        rhofunc = UnivariateSpline(radii, density)\n        moment = np.abs(\n            quad(\n                lambda r: 8.0 / 3.0 * np.pi * rhofunc(r) * r * r * r * r,\n                radii[0],\n                radii[-1],\n            )[0]\n        )\n        return moment\n\n    @property\n    def gravity(self):\n        \"\"\"\n        Returns gravity profile of the layer [m s^(-2)]\n        \"\"\"\n        return self._compute_gravity(self.density, self.gravity_bottom)\n\n    @property\n    def bullen(self):\n        \"\"\"\n        Returns the Bullen parameter across the layer.\n        The Bullen parameter assess if compression as a function of pressure is\n        like homogeneous, adiabatic compression.\n        Bullen parameter =1  , homogeneous, adiabatic compression\n        Bullen parameter > 1 , more compressed with pressure,\n        e.g. across phase transitions Bullen parameter < 1,\n        less compressed with pressure, e.g. across a boundary layer.\n        \"\"\"\n        kappa = self.bulk_sound_velocity * self.bulk_sound_velocity * self.density\n        phi = self.bulk_sound_velocity * self.bulk_sound_velocity\n        try:\n            dkappadP = np.gradient(kappa, edge_order=2) / np.gradient(\n                self.pressures, edge_order=2\n            )\n            dphidr = (\n                np.gradient(phi, edge_order=2)\n                / np.gradient(self.radii, edge_order=2)\n                / self.gravity\n            )\n        except:\n            dkappadP = np.gradient(kappa) / np.gradient(self.pressures)\n            dphidr = np.gradient(phi) / np.gradient(self.radii) / self.gravity\n        bullen = dkappadP + dphidr\n        return bullen\n\n    @property\n    def brunt_vasala(self):\n        \"\"\"\n        Returns the brunt-vasala (or buoyancy) frequency, N, across the layer.\n        This frequency assess the stabilty of the layer:\n        N < 0, fluid will convect\n        N= 0, fluid is neutral\n        N > 0, fluid is stabily stratified.\n        \"\"\"\n        kappa = self.bulk_sound_velocity * self.bulk_sound_velocity * self.density\n        brunt_vasala = (\n            self.density * self.gravity * self.gravity * (self.bullen - 1.0) / kappa\n        )\n        return brunt_vasala\n\n    @property\n    def pressure(self):\n        \"\"\"\n        Returns current pressures across the layer that was set\n        with :func:`~burnman.Material.set_state`.\n\n        Aliased with :func:`~burnman.Material.P`.\n\n        :returns: Pressures in [Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return self.pressures\n\n    @property\n    def temperature(self):\n        \"\"\"\n        Returns current temperature  across the layer that was set with\n        :func:`~burnman.Material.set_state`.\n\n        - Aliased with :func:`~burnman.Material.T`.\n\n        :returns: Temperatures in [K] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return self.temperatures\n\n    @material_property\n    def molar_internal_energy(self):\n        \"\"\"\n        Returns the molar internal energies across the layer.\n\n        Notes\n        -----\n        - Needs to be implemented in derived classes.\n        - Aliased with :func:`~burnman.Material.energy`.\n\n        :returns: The internal energies in [J/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].molar_internal_energy\n                for i in range(len(self.sublayers))\n            ]\n        )\n\n    @material_property\n    def molar_gibbs(self):\n        \"\"\"\n        Returns the molar Gibbs free energies across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.gibbs`.\n\n        :returns: Gibbs energies in [J/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_gibbs for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def molar_helmholtz(self):\n        \"\"\"\n        Returns the molar Helmholtz free energies across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.helmholtz`.\n\n        :returns: Helmholtz energies in [J/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_helmholtz for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the layer.\n\n        Needs to be implemented in derived classes.\n\n        :returns: Molar mass in [kg/mol].\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_mass for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def molar_volume(self):\n        \"\"\"\n        Returns molar volumes across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.V`.\n\n        :returns: Molar volumes in [m^3/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_volume for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def density(self):\n        \"\"\"\n        Returns the densities across this layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.rho`.\n\n        :returns: The densities of this material in [kg/m^3] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array([self.sublayers[i].density for i in range(len(self.sublayers))])\n\n    @material_property\n    def molar_entropy(self):\n        \"\"\"\n        Returns molar entropies acroos the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.S`.\n\n        :returns: Entropies in [J/K/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_entropy for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpies across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.H`.\n\n        :returns: Enthalpies in [J/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_enthalpy for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk moduli across the layer.\n\n        Notes\n        -----\n        - Needs to be implemented in derived classes.\n        - Aliased with :func:`~burnman.Material.K_T`.\n\n        :returns: Bulk moduli in [Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].isothermal_bulk_modulus\n                for i in range(len(self.sublayers))\n            ]\n        )\n\n    @material_property\n    def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns the adiabatic bulk moduli across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.K_S`.\n\n        :returns: Adiabatic bulk modulus in [Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].adiabatic_bulk_modulus\n                for i in range(len(self.sublayers))\n            ]\n        )\n\n    @material_property\n    def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibilities across the layer\n        (or inverse isothermal bulk moduli).\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_T`.\n\n        :returns: Isothermal compressibilities in [1/Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].isothermal_compressibility\n                for i in range(len(self.sublayers))\n            ]\n        )\n\n    @material_property\n    def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibilities across the layer\n        (or inverse adiabatic bulk moduli).\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_S`.\n\n        :returns: Adiabatic compressibilities in [1/Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].adiabatic_compressibility\n                for i in range(len(self.sublayers))\n            ]\n        )\n\n    @material_property\n    def shear_modulus(self):\n        \"\"\"\n        Returns shear moduli across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_G`.\n\n        :returns: Shear moduli in [Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].shear_modulus for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speeds across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_p`.\n\n        :returns: P wave speeds in [m/s] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].p_wave_velocity for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speeds across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_phi`.\n\n        :returns: Bulk sound velocities in [m/s] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].bulk_sound_velocity for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speeds across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_s`.\n\n        :returns: Shear wave speeds in [m/s] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].shear_wave_velocity for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def grueneisen_parameter(self):\n        \"\"\"\n        Returns the grueneisen parameters across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.gr`.\n\n        :returns: Grueneisen parameters [unitless] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].grueneisen_parameter for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficients across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.alpha`.\n\n        :returns: Thermal expansivities in [1/K] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].thermal_expansivity for i in range(len(self.sublayers))]\n        )\n\n    @material_property\n    def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volumes across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.C_v`.\n\n        :returns: Heat capacities in [J/K/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].molar_heat_capacity_v\n                for i in range(len(self.sublayers))\n            ]\n        )\n\n    @material_property\n    def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar_heat capacity at constant pressures across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.C_p`.\n\n        :returns: Heat capacities in [J/K/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].molar_heat_capacity_p\n                for i in range(len(self.sublayers))\n            ]\n        )\n\n    # Aliased properties\n    @property\n    def P(self):\n        \"\"\"Alias for :func:`~burnman.Layer.pressure`\"\"\"\n        return self.pressure\n\n    @property\n    def T(self):\n        \"\"\"Alias for :func:`~burnman.Layer.temperature`\"\"\"\n        return self.temperature\n\n    @property\n    def energy(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_internal_energy`\"\"\"\n        return self.molar_internal_energy\n\n    @property\n    def helmholtz(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_helmholtz`\"\"\"\n        return self.molar_helmholtz\n\n    @property\n    def gibbs(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_gibbs`\"\"\"\n        return self.molar_gibbs\n\n    @property\n    def V(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_volume`\"\"\"\n        return self.molar_volume\n\n    @property\n    def rho(self):\n        \"\"\"Alias for :func:`~burnman.Layer.density`\"\"\"\n        return self.density\n\n    @property\n    def S(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_entropy`\"\"\"\n        return self.molar_entropy\n\n    @property\n    def H(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_enthalpy`\"\"\"\n        return self.molar_enthalpy\n\n    @property\n    def K_T(self):\n        \"\"\"Alias for :func:`~burnman.Layer.isothermal_bulk_modulus`\"\"\"\n        return self.isothermal_bulk_modulus\n\n    @property\n    def K_S(self):\n        \"\"\"Alias for :func:`~burnman.Layer.adiabatic_bulk_modulus`\"\"\"\n        return self.adiabatic_bulk_modulus\n\n    @property\n    def beta_T(self):\n        \"\"\"Alias for :func:`~burnman.Layer.isothermal_compressibility`\"\"\"\n        return self.isothermal_compressibility\n\n    @property\n    def beta_S(self):\n        \"\"\"Alias for :func:`~burnman.Layer.adiabatic_compressibility`\"\"\"\n        return self.adiabatic_compressibility\n\n    @property\n    def G(self):\n        \"\"\"Alias for :func:`~burnman.Layer.shear_modulus`\"\"\"\n        return self.shear_modulus\n\n    @property\n    def v_p(self):\n        \"\"\"Alias for :func:`~burnman.Layer.p_wave_velocity`\"\"\"\n        return self.p_wave_velocity\n\n    @property\n    def v_phi(self):\n        \"\"\"Alias for :func:`~burnman.Layer.bulk_sound_velocity`\"\"\"\n        return self.bulk_sound_velocity\n\n    @property\n    def v_s(self):\n        \"\"\"Alias for :func:`~burnman.Layer.shear_wave_velocity`\"\"\"\n        return self.shear_wave_velocity\n\n    @property\n    def gr(self):\n        \"\"\"Alias for :func:`~burnman.Layer.grueneisen_parameter`\"\"\"\n        return self.grueneisen_parameter\n\n    @property\n    def alpha(self):\n        \"\"\"Alias for :func:`~burnman.Layer.thermal_expansivity`\"\"\"\n        return self.thermal_expansivity\n\n    @property\n    def C_v(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_v`\"\"\"\n        return self.molar_heat_capacity_v\n\n    @property\n    def C_p(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_p`\"\"\"\n        return self.molar_heat_capacity_p",
  "class BoundaryLayerPerturbation(object):\n    \"\"\"\n    A class that implements a temperature perturbation model corresponding to a\n    simple thermal boundary layer.\n    The model takes the following form:\n    T = a*exp((r - r1)/(r0 - r1)*c) + b*exp((r - r0)/(r1 - r0)*c)\n    The relationships between the input parameters and a, b and c are\n    given below.\n\n    This model is a simpler version of that proposed\n    by :cite:`Richter1981`.\n\n    :param radius_bottom: The radius at the bottom of the layer (r0) [m].\n    :type radius_bottom: float\n\n    :param radius_top: The radius at the top of the layer (r1) [m].\n    :type radius_top: float\n\n    :param rayleigh_number: The Rayleigh number of convection within the layer. The\n        exponential scale factor is this number to the power of 1/4\n        (Ra = c^4).\n    :type rayleigh_number: float\n\n    :param temperature_change: The total difference in potential\n        temperature across the layer [K]. temperature_change = (a + b)*exp(c).\n    :type temperature_change: float\n\n    :param boundary_layer_ratio: The ratio of the linear scale factors (a/b)\n        corresponding to the thermal boundary layers at the top and bottom of\n        the layer. A number greater than 1 implies a larger change in\n        temperature across the top boundary than the bottom boundary.\n    :type boundary_layer_ratio: float\n    \"\"\"\n\n    def __init__(\n        self,\n        radius_bottom,\n        radius_top,\n        rayleigh_number,\n        temperature_change,\n        boundary_layer_ratio,\n    ):\n        self.r0 = radius_bottom\n        self.r1 = radius_top\n\n        self.Ra = rayleigh_number\n        self.c = np.power(self.Ra, 1.0 / 4.0)\n\n        self.a = temperature_change / (np.exp(self.c) * (1.0 + boundary_layer_ratio))\n        self.b = -boundary_layer_ratio * self.a\n\n    def temperature(self, radii):\n        \"\"\"\n        Returns the temperature at one or more radii [K].\n\n        :param radii: The radii at which to evaluate the temperature.\n        :type radii: float or numpy.array\n\n        :returns: The temperatures at the requested radii.\n        :rtype: float or numpy.array\n        \"\"\"\n        return self.a * np.exp(\n            (radii - self.r1) / (self.r0 - self.r1) * self.c\n        ) + self.b * np.exp((radii - self.r0) / (self.r1 - self.r0) * self.c)\n\n    def dTdr(self, radii):\n        \"\"\"\n        Returns the thermal gradient at one or more radii [K/m].\n\n        :param radii: The radii at which to evaluate the thermal gradients.\n        :type radii: float or numpy.array\n\n        :returns: The thermal gradient at the requested radii.\n        :rtype: float or numpy.array\n        \"\"\"\n        return (\n            self.c\n            / (self.r0 - self.r1)\n            * (\n                self.a * np.exp((radii - self.r1) / (self.r0 - self.r1) * self.c)\n                - self.b * np.exp((radii - self.r0) / (self.r1 - self.r0) * self.c)\n            )\n        )\n\n    def set_model_thermal_gradients(self, dTdr_bottom, dTdr_top):\n        \"\"\"\n        Reparameterizes the model based on the thermal gradients\n        at the bottom and top of the model.\n\n        :param dTdr_bottom: The thermal gradient at the bottom of the model [K/m].\n            Typically negative for a cooling planet.\n        :type dTdr_bottom: float\n\n        :param dTdr_top: The thermal gradient at the top of the model [K/m].\n            Typically negative for a cooling planet.\n        :type dTdr_top: float\n        \"\"\"\n\n        def delta_dTdrs(args, dTdr_bottom, dTdr_top):\n            a, b = args\n            self.a = a\n            self.b = b\n\n            return [dTdr_bottom - self.dTdr(self.r0), dTdr_top - self.dTdr(self.r1)]\n\n        fsolve(delta_dTdrs, [self.a, self.b], args=(dTdr_bottom, dTdr_top))",
  "def __init__(self, name=None, radii=None, verbose=False):\n        self.name = name\n        assert np.all(np.diff(radii) > 0)\n        self.radii = radii\n        self.outer_radius = max(self.radii)\n        self.inner_radius = min(self.radii)\n        self.thickness = self.outer_radius - self.inner_radius\n        self.n_slices = len(self.radii)\n        self.verbose = verbose\n        self._cached = {}\n        self._pressures = None\n        self._temperatures = None\n        self.sublayers = None\n        self.material = None\n        self.pressure_mode = \"self-consistent\"\n        self.temperature_mode = None",
  "def __str__(self):\n        \"\"\"\n        Prints details of the layer\n        \"\"\"\n        writing = (\n            f\"The {self.name} is made of {self.material.name}\"\n            f\" with {self.temperature_mode} temperatures and \"\n            f\"{self.pressure_mode} pressures\\n\"\n        )\n        return writing",
  "def reset(self):\n        \"\"\"\n        Resets all cached material properties.\n        It is typically not required for the user to call this function.\n        \"\"\"\n        self._cached = {}\n        self._pressures = None\n        self._temperatures = None\n        self.sublayers = None",
  "def set_material(self, material):\n        \"\"\"\n        Set the material of a Layer with a Material\n        \"\"\"\n        assert isinstance(material, Material)\n        self.material = material\n        self.reset()",
  "def set_temperature_mode(\n        self, temperature_mode=\"adiabatic\", temperatures=None, temperature_top=None\n    ):\n        \"\"\"\n        Sets temperatures within the layer as user-defined values or as\n        a (potentially perturbed) adiabat.\n\n        :param temperature_mode: This can be set to 'user-defined', 'adiabatic',\n            or 'perturbed-adiabatic'. 'user-defined' fixes the temperature\n            with the profile input by the user. 'adiabatic' self-consistently\n            computes the adiabat when setting the state of the layer.\n            'perturbed-adiabatic' adds the user input array to the adiabat.\n            This allows the user to apply boundary layers (for example).\n        :type temperature_mode: string\n        :param temperatures: The desired fixed temperatures in [K].\n            Should have same length as defined radii in layer.\n        :type temperatures: array of float\n        :param temperature_top: Temperature at the top of the layer.\n            Used if the temperature mode is chosen to be 'adiabatic' or\n            'perturbed-adiabatic'. If 'perturbed-adiabatic' is chosen as the\n            temperature mode, temperature_top corresponds to the true temperature\n            at the top of the layer, and the reference isentrope at this radius\n            is defined to lie at a temperature of\n            temperature_top - temperatures[-1].\n        :type temperature_top: float\n        \"\"\"\n        self.reset()\n        assert (\n            temperature_mode == \"user-defined\"\n            or temperature_mode == \"adiabatic\"\n            or temperature_mode == \"perturbed-adiabatic\"\n        )\n\n        self.temperature_mode = temperature_mode\n\n        if (\n            temperature_mode == \"user-defined\"\n            or temperature_mode == \"perturbed-adiabatic\"\n        ):\n            assert len(temperatures) == len(self.radii)\n            self.usertemperatures = temperatures\n        else:\n            self.usertemperatures = np.zeros_like(self.radii)\n\n        if temperature_mode == \"adiabatic\" or temperature_mode == \"perturbed-adiabatic\":\n            self.temperature_top = temperature_top\n        else:\n            self.temperature_top = None",
  "def set_pressure_mode(\n        self,\n        pressure_mode=\"self-consistent\",\n        pressures=None,\n        gravity_bottom=None,\n        pressure_top=None,\n        n_max_iterations=50,\n        max_delta=1.0e-5,\n    ):\n        \"\"\"\n        Sets the pressure mode of the layer,\n        which can either be 'user-defined', or 'self-consistent'.\n\n        :param pressure_mode: This can be set to 'user-defined' or 'self-consistent'.\n            'user-defined' fixes the pressures with the profile input\n            by the user in the 'pressures' argument.\n            'self-consistent' forces Layer to calculate pressures\n            self-consistently. If this is selected, the user will need\n            to supply values for the gravity_bottom [m/s^2]\n            and pressure_top [Pa] arguments.\n        :type pressure_mode: string\n        :param pressures: Pressures [Pa] to set layer to\n            (if the 'user-defined' pressure_mode has been selected).\n            The array should be the same length as\n            the layers user-defined radii array.\n        :type pressures: array of floats\n        :param pressure_top: Pressure [Pa] at the top of the layer.\n        :type pressure_top: float\n        :param gravity_bottom: Gravity [m/s^2] at the bottom of the layer.\n        :type gravity_bottom: float\n        :param n_max_iterations: Maximum number of iterations to reach\n            self-consistent pressures.\n        :type n_max_iterations: integer\n        :param max_delta: Relative update to the highest pressure in the layer between\n            iterations to stop iterations.\n        :type max_delta: float\n        \"\"\"\n        self.reset()\n        assert pressure_mode == \"user-defined\" or pressure_mode == \"self-consistent\"\n        self.pressure_mode = pressure_mode\n\n        assert gravity_bottom is not None\n        self.gravity_bottom = gravity_bottom\n\n        if pressure_mode == \"user-defined\":\n            assert pressures is not None\n            assert len(pressures) == len(self.radii)\n            self.pressures = pressures\n            warnings.warn(\n                \"By setting the pressures in Layer they \"\n                \"are unlikely to be self-consistent\"\n            )\n        elif pressure_mode == \"self-consistent\":\n            self.pressure_top = pressure_top\n            self.n_max_iterations = n_max_iterations\n            self.max_delta = max_delta\n        else:\n            raise NotImplementedError(\n                f\"pressure mode {pressure_mode} \" \"not recognised\"\n            )",
  "def make(self):\n        \"\"\"\n        This routine needs to be called before evaluating any properties.\n        If pressures and temperatures are not user-defined, they\n        are computed here. This method also initializes an array of copied\n        materials from which properties can be computed.\n        \"\"\"\n        self.reset()\n        if not hasattr(self, \"material\"):\n            raise AttributeError(\n                \"You must set_material() for the layer \" \"before running make().\"\n            )\n        if not hasattr(self, \"temperature_mode\"):\n            raise AttributeError(\n                \"You must set_temperature_mode() for the \"\n                \"layer before running make().\"\n            )\n        if not hasattr(self, \"pressure_mode\"):\n            raise AttributeError(\n                \"You must set_pressure_mode() for the layer \" \"before running make().\"\n            )\n\n        if self.pressure_mode == \"user-defined\":\n            self.temperatures = self._evaluate_temperature(\n                self.pressures, self.temperature_top\n            )\n        elif self.pressure_mode == \"self-consistent\":\n            new_press = (\n                self.pressure_top + (-self.radii + max(self.radii)) * 1.0e3\n            )  # initial pressure curve guess\n            temperatures = self._evaluate_temperature(new_press, self.temperature_top)\n            # Make it self-consistent!!!\n            i = 0\n\n            while i < self.n_max_iterations:\n                i += 1\n                ref_press = new_press\n                new_grav, new_press = self._evaluate_eos(\n                    new_press, temperatures, self.gravity_bottom, self.pressure_top\n                )\n                temperatures = self._evaluate_temperature(\n                    new_press, self.temperature_top\n                )\n                rel_err = abs((max(ref_press) - max(new_press)) / max(new_press))\n                if self.verbose:\n                    print(\n                        f\"Iteration {i:0d} maximum relative pressure error: \"\n                        f\"{rel_err:.1f}\"\n                    )\n\n                if rel_err < self.max_delta:\n                    break\n\n            self.pressures = new_press\n            self.temperatures = temperatures\n        else:\n            raise NotImplementedError(\"pressure mode not recognised\")\n\n        self.sublayers = []\n        for r in range(len(self.radii)):\n            self.sublayers.append(self.material.copy())\n            self.sublayers[r].set_state(self.pressures[r], self.temperatures[r])",
  "def evaluate(self, properties, radlist=None, radius_planet=None):\n        \"\"\"\n        Function that is used to evaluate properties\n        across the layer. If radlist is not defined, values are\n        returned at the internal radlist.\n        If asking for different radii than the internal radlist,\n        pressure and temperature values are interpolated and the\n        layer material evaluated at those pressures and\n        temperatures.\n\n        :param properties: List of properties to evaluate.\n        :type properties: list of strings\n        :param radlist: Radii to evaluate properties at. If left empty,\n            internal radii list is used.\n        :type radlist: array of floats\n        :param planet_radius: Planet outer radius. Used only to calculate depth.\n        :type planet_radius: float\n\n        :returns: 1D or 2D array of requested properties\n            (1D if only one property was requested)\n        :rtype: numpy.array\n        \"\"\"\n\n        if radlist is None:\n            values = np.empty([len(properties), len(self.radii)])\n            for i, prop in enumerate(properties):\n                if prop == \"depth\":\n                    values[i] = radius_planet - self.radii\n                else:\n                    try:\n                        values[i] = getattr(self, prop)\n                    except:\n                        values[i] = np.array(\n                            [\n                                getattr(self.sublayers[i], prop)\n                                for i in range(len(self.sublayers))\n                            ]\n                        )\n        else:\n            func_p = interp1d(self.radii, self.pressures)\n            pressures = func_p(radlist)\n            func_t = interp1d(self.radii, self.temperatures)\n            temperatures = func_t(radlist)\n            values = np.empty([len(properties), len(radlist)])\n            for i, prop in enumerate(properties):\n                if prop == \"depth\":\n                    values[i] = radius_planet - radlist\n                else:\n                    try:\n                        values[i] = self.material.evaluate(\n                            [prop], pressures, temperatures\n                        )\n                    except:\n                        func_prop = interp1d(self.radii, getattr(self, prop))\n                        values[i] = func_prop(radlist)\n\n        if values.shape[0] == 1:\n            values = values[0]\n        return values",
  "def _evaluate_temperature(self, pressures=None, temperature_top=None):\n        \"\"\"\n        Returns the temperatures of the layer for given pressures.\n        Used by make()\n        \"\"\"\n        if (\n            self.temperature_mode == \"adiabatic\"\n            or self.temperature_mode == \"perturbed-adiabatic\"\n        ):\n            adiabat = geotherm.adiabatic(\n                pressures[::-1],\n                temperature_top - self.usertemperatures[-1],\n                self.material,\n            )[::-1]\n        else:\n            adiabat = np.zeros_like(self.radii)\n        return adiabat + self.usertemperatures",
  "def _evaluate_eos(self, pressures, temperatures, gravity_bottom, pressure_top):\n        \"\"\"\n        Returns updated gravity and pressure\n        make() loops over this until consistency is achieved.\n        \"\"\"\n        [density] = self.material.evaluate([\"density\"], pressures, temperatures)\n        grav = self._compute_gravity(density, gravity_bottom)\n        press = self._compute_pressure(density, grav, pressure_top)\n        return grav, press",
  "def _compute_gravity(self, density, gravity_bottom):\n        \"\"\"\n        Computes the gravity of a layer\n        Used by _evaluate_eos()\n        \"\"\"\n        # Create a spline fit of density as a function of radius\n        rhofunc = UnivariateSpline(self.radii, density)\n        # Numerically integrate Poisson's equation\n\n        def poisson(p, x):\n            return 4.0 * np.pi * constants.G * rhofunc(x) * x * x\n\n        grav = np.ravel(\n            odeint(poisson, gravity_bottom * self.radii[0] * self.radii[0], self.radii)\n        )\n\n        if self.radii[0] == 0:\n            grav[0] = 0\n            grav[1:] = grav[1:] / self.radii[1:] / self.radii[1:]\n        else:\n            grav[:] = grav[:] / self.radii[:] / self.radii[:]\n        return grav",
  "def _compute_pressure(self, density, gravity, pressure_top):\n        \"\"\"\n        Calculate the pressure profile based on density and gravity.\n        This integrates the equation for hydrostatic equilibrium P = rho g z.\n        Used by _evaluate_eos()\n        \"\"\"\n        # flip radius, density and gravity to increasing pressure\n        depthfromtop = -self.radii[::-1] + max(self.radii)\n        density = density[::-1]\n        gravity = gravity[::-1]\n        # Make a spline fit of density as a function of depth\n        rhofunc = UnivariateSpline(depthfromtop, density)\n        # Make a spline fit of gravity as a function of depth\n        gfunc = UnivariateSpline(depthfromtop, gravity)\n\n        # integrate the hydrostatic equation\n        pressure = np.ravel(\n            odeint((lambda p, x: gfunc(x) * rhofunc(x)), pressure_top, depthfromtop)\n        )\n\n        return pressure[::-1]",
  "def mass(self):\n        \"\"\"\n        Calculates the mass of the layer [kg]\n        \"\"\"\n        mass = 0.0\n        radii = self.radii\n        density = self.evaluate([\"density\"])\n        rhofunc = UnivariateSpline(radii, density)\n        mass = np.abs(\n            quad(lambda r: 4 * np.pi * rhofunc(r) * r * r, radii[0], radii[-1])[0]\n        )\n        return mass",
  "def moment_of_inertia(self):\n        \"\"\"\n        Returns the moment of inertia of the layer [kg m^2]\n        \"\"\"\n        moment = 0.0\n        radii = self.radii\n        density = self.evaluate([\"density\"])\n        rhofunc = UnivariateSpline(radii, density)\n        moment = np.abs(\n            quad(\n                lambda r: 8.0 / 3.0 * np.pi * rhofunc(r) * r * r * r * r,\n                radii[0],\n                radii[-1],\n            )[0]\n        )\n        return moment",
  "def gravity(self):\n        \"\"\"\n        Returns gravity profile of the layer [m s^(-2)]\n        \"\"\"\n        return self._compute_gravity(self.density, self.gravity_bottom)",
  "def bullen(self):\n        \"\"\"\n        Returns the Bullen parameter across the layer.\n        The Bullen parameter assess if compression as a function of pressure is\n        like homogeneous, adiabatic compression.\n        Bullen parameter =1  , homogeneous, adiabatic compression\n        Bullen parameter > 1 , more compressed with pressure,\n        e.g. across phase transitions Bullen parameter < 1,\n        less compressed with pressure, e.g. across a boundary layer.\n        \"\"\"\n        kappa = self.bulk_sound_velocity * self.bulk_sound_velocity * self.density\n        phi = self.bulk_sound_velocity * self.bulk_sound_velocity\n        try:\n            dkappadP = np.gradient(kappa, edge_order=2) / np.gradient(\n                self.pressures, edge_order=2\n            )\n            dphidr = (\n                np.gradient(phi, edge_order=2)\n                / np.gradient(self.radii, edge_order=2)\n                / self.gravity\n            )\n        except:\n            dkappadP = np.gradient(kappa) / np.gradient(self.pressures)\n            dphidr = np.gradient(phi) / np.gradient(self.radii) / self.gravity\n        bullen = dkappadP + dphidr\n        return bullen",
  "def brunt_vasala(self):\n        \"\"\"\n        Returns the brunt-vasala (or buoyancy) frequency, N, across the layer.\n        This frequency assess the stabilty of the layer:\n        N < 0, fluid will convect\n        N= 0, fluid is neutral\n        N > 0, fluid is stabily stratified.\n        \"\"\"\n        kappa = self.bulk_sound_velocity * self.bulk_sound_velocity * self.density\n        brunt_vasala = (\n            self.density * self.gravity * self.gravity * (self.bullen - 1.0) / kappa\n        )\n        return brunt_vasala",
  "def pressure(self):\n        \"\"\"\n        Returns current pressures across the layer that was set\n        with :func:`~burnman.Material.set_state`.\n\n        Aliased with :func:`~burnman.Material.P`.\n\n        :returns: Pressures in [Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return self.pressures",
  "def temperature(self):\n        \"\"\"\n        Returns current temperature  across the layer that was set with\n        :func:`~burnman.Material.set_state`.\n\n        - Aliased with :func:`~burnman.Material.T`.\n\n        :returns: Temperatures in [K] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return self.temperatures",
  "def molar_internal_energy(self):\n        \"\"\"\n        Returns the molar internal energies across the layer.\n\n        Notes\n        -----\n        - Needs to be implemented in derived classes.\n        - Aliased with :func:`~burnman.Material.energy`.\n\n        :returns: The internal energies in [J/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].molar_internal_energy\n                for i in range(len(self.sublayers))\n            ]\n        )",
  "def molar_gibbs(self):\n        \"\"\"\n        Returns the molar Gibbs free energies across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.gibbs`.\n\n        :returns: Gibbs energies in [J/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_gibbs for i in range(len(self.sublayers))]\n        )",
  "def molar_helmholtz(self):\n        \"\"\"\n        Returns the molar Helmholtz free energies across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.helmholtz`.\n\n        :returns: Helmholtz energies in [J/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_helmholtz for i in range(len(self.sublayers))]\n        )",
  "def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the layer.\n\n        Needs to be implemented in derived classes.\n\n        :returns: Molar mass in [kg/mol].\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_mass for i in range(len(self.sublayers))]\n        )",
  "def molar_volume(self):\n        \"\"\"\n        Returns molar volumes across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.V`.\n\n        :returns: Molar volumes in [m^3/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_volume for i in range(len(self.sublayers))]\n        )",
  "def density(self):\n        \"\"\"\n        Returns the densities across this layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.rho`.\n\n        :returns: The densities of this material in [kg/m^3] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array([self.sublayers[i].density for i in range(len(self.sublayers))])",
  "def molar_entropy(self):\n        \"\"\"\n        Returns molar entropies acroos the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.S`.\n\n        :returns: Entropies in [J/K/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_entropy for i in range(len(self.sublayers))]\n        )",
  "def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpies across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.H`.\n\n        :returns: Enthalpies in [J/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].molar_enthalpy for i in range(len(self.sublayers))]\n        )",
  "def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk moduli across the layer.\n\n        Notes\n        -----\n        - Needs to be implemented in derived classes.\n        - Aliased with :func:`~burnman.Material.K_T`.\n\n        :returns: Bulk moduli in [Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].isothermal_bulk_modulus\n                for i in range(len(self.sublayers))\n            ]\n        )",
  "def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns the adiabatic bulk moduli across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.K_S`.\n\n        :returns: Adiabatic bulk modulus in [Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].adiabatic_bulk_modulus\n                for i in range(len(self.sublayers))\n            ]\n        )",
  "def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibilities across the layer\n        (or inverse isothermal bulk moduli).\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_T`.\n\n        :returns: Isothermal compressibilities in [1/Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].isothermal_compressibility\n                for i in range(len(self.sublayers))\n            ]\n        )",
  "def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibilities across the layer\n        (or inverse adiabatic bulk moduli).\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_S`.\n\n        :returns: Adiabatic compressibilities in [1/Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].adiabatic_compressibility\n                for i in range(len(self.sublayers))\n            ]\n        )",
  "def shear_modulus(self):\n        \"\"\"\n        Returns shear moduli across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.beta_G`.\n\n        :returns: Shear moduli in [Pa] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].shear_modulus for i in range(len(self.sublayers))]\n        )",
  "def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speeds across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_p`.\n\n        :returns: P wave speeds in [m/s] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].p_wave_velocity for i in range(len(self.sublayers))]\n        )",
  "def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speeds across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_phi`.\n\n        :returns: Bulk sound velocities in [m/s] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].bulk_sound_velocity for i in range(len(self.sublayers))]\n        )",
  "def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speeds across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.v_s`.\n\n        :returns: Shear wave speeds in [m/s] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].shear_wave_velocity for i in range(len(self.sublayers))]\n        )",
  "def grueneisen_parameter(self):\n        \"\"\"\n        Returns the grueneisen parameters across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.gr`.\n\n        :returns: Grueneisen parameters [unitless] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].grueneisen_parameter for i in range(len(self.sublayers))]\n        )",
  "def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficients across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.alpha`.\n\n        :returns: Thermal expansivities in [1/K] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [self.sublayers[i].thermal_expansivity for i in range(len(self.sublayers))]\n        )",
  "def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volumes across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.C_v`.\n\n        :returns: Heat capacities in [J/K/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].molar_heat_capacity_v\n                for i in range(len(self.sublayers))\n            ]\n        )",
  "def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar_heat capacity at constant pressures across the layer.\n\n        Needs to be implemented in derived classes.\n        Aliased with :func:`~burnman.Material.C_p`.\n\n        :returns: Heat capacities in [J/K/mol] at the predefined radii.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array(\n            [\n                self.sublayers[i].molar_heat_capacity_p\n                for i in range(len(self.sublayers))\n            ]\n        )",
  "def P(self):\n        \"\"\"Alias for :func:`~burnman.Layer.pressure`\"\"\"\n        return self.pressure",
  "def T(self):\n        \"\"\"Alias for :func:`~burnman.Layer.temperature`\"\"\"\n        return self.temperature",
  "def energy(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_internal_energy`\"\"\"\n        return self.molar_internal_energy",
  "def helmholtz(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_helmholtz`\"\"\"\n        return self.molar_helmholtz",
  "def gibbs(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_gibbs`\"\"\"\n        return self.molar_gibbs",
  "def V(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_volume`\"\"\"\n        return self.molar_volume",
  "def rho(self):\n        \"\"\"Alias for :func:`~burnman.Layer.density`\"\"\"\n        return self.density",
  "def S(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_entropy`\"\"\"\n        return self.molar_entropy",
  "def H(self):\n        \"\"\"Alias for :func:`~burnman.Layer.molar_enthalpy`\"\"\"\n        return self.molar_enthalpy",
  "def K_T(self):\n        \"\"\"Alias for :func:`~burnman.Layer.isothermal_bulk_modulus`\"\"\"\n        return self.isothermal_bulk_modulus",
  "def K_S(self):\n        \"\"\"Alias for :func:`~burnman.Layer.adiabatic_bulk_modulus`\"\"\"\n        return self.adiabatic_bulk_modulus",
  "def beta_T(self):\n        \"\"\"Alias for :func:`~burnman.Layer.isothermal_compressibility`\"\"\"\n        return self.isothermal_compressibility",
  "def beta_S(self):\n        \"\"\"Alias for :func:`~burnman.Layer.adiabatic_compressibility`\"\"\"\n        return self.adiabatic_compressibility",
  "def G(self):\n        \"\"\"Alias for :func:`~burnman.Layer.shear_modulus`\"\"\"\n        return self.shear_modulus",
  "def v_p(self):\n        \"\"\"Alias for :func:`~burnman.Layer.p_wave_velocity`\"\"\"\n        return self.p_wave_velocity",
  "def v_phi(self):\n        \"\"\"Alias for :func:`~burnman.Layer.bulk_sound_velocity`\"\"\"\n        return self.bulk_sound_velocity",
  "def v_s(self):\n        \"\"\"Alias for :func:`~burnman.Layer.shear_wave_velocity`\"\"\"\n        return self.shear_wave_velocity",
  "def gr(self):\n        \"\"\"Alias for :func:`~burnman.Layer.grueneisen_parameter`\"\"\"\n        return self.grueneisen_parameter",
  "def alpha(self):\n        \"\"\"Alias for :func:`~burnman.Layer.thermal_expansivity`\"\"\"\n        return self.thermal_expansivity",
  "def C_v(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_v`\"\"\"\n        return self.molar_heat_capacity_v",
  "def C_p(self):\n        \"\"\"Alias for :func:`~burnman.Material.molar_heat_capacity_p`\"\"\"\n        return self.molar_heat_capacity_p",
  "def __init__(\n        self,\n        radius_bottom,\n        radius_top,\n        rayleigh_number,\n        temperature_change,\n        boundary_layer_ratio,\n    ):\n        self.r0 = radius_bottom\n        self.r1 = radius_top\n\n        self.Ra = rayleigh_number\n        self.c = np.power(self.Ra, 1.0 / 4.0)\n\n        self.a = temperature_change / (np.exp(self.c) * (1.0 + boundary_layer_ratio))\n        self.b = -boundary_layer_ratio * self.a",
  "def temperature(self, radii):\n        \"\"\"\n        Returns the temperature at one or more radii [K].\n\n        :param radii: The radii at which to evaluate the temperature.\n        :type radii: float or numpy.array\n\n        :returns: The temperatures at the requested radii.\n        :rtype: float or numpy.array\n        \"\"\"\n        return self.a * np.exp(\n            (radii - self.r1) / (self.r0 - self.r1) * self.c\n        ) + self.b * np.exp((radii - self.r0) / (self.r1 - self.r0) * self.c)",
  "def dTdr(self, radii):\n        \"\"\"\n        Returns the thermal gradient at one or more radii [K/m].\n\n        :param radii: The radii at which to evaluate the thermal gradients.\n        :type radii: float or numpy.array\n\n        :returns: The thermal gradient at the requested radii.\n        :rtype: float or numpy.array\n        \"\"\"\n        return (\n            self.c\n            / (self.r0 - self.r1)\n            * (\n                self.a * np.exp((radii - self.r1) / (self.r0 - self.r1) * self.c)\n                - self.b * np.exp((radii - self.r0) / (self.r1 - self.r0) * self.c)\n            )\n        )",
  "def set_model_thermal_gradients(self, dTdr_bottom, dTdr_top):\n        \"\"\"\n        Reparameterizes the model based on the thermal gradients\n        at the bottom and top of the model.\n\n        :param dTdr_bottom: The thermal gradient at the bottom of the model [K/m].\n            Typically negative for a cooling planet.\n        :type dTdr_bottom: float\n\n        :param dTdr_top: The thermal gradient at the top of the model [K/m].\n            Typically negative for a cooling planet.\n        :type dTdr_top: float\n        \"\"\"\n\n        def delta_dTdrs(args, dTdr_bottom, dTdr_top):\n            a, b = args\n            self.a = a\n            self.b = b\n\n            return [dTdr_bottom - self.dTdr(self.r0), dTdr_top - self.dTdr(self.r1)]\n\n        fsolve(delta_dTdrs, [self.a, self.b], args=(dTdr_bottom, dTdr_top))",
  "def poisson(p, x):\n            return 4.0 * np.pi * constants.G * rhofunc(x) * x * x",
  "def delta_dTdrs(args, dTdr_bottom, dTdr_top):\n            a, b = args\n            self.a = a\n            self.b = b\n\n            return [dTdr_bottom - self.dTdr(self.r0), dTdr_top - self.dTdr(self.r1)]",
  "class ElasticSolution(Mineral):\n    \"\"\"\n    This is the base class for all Elastic solutions.\n    Site occupancies, endmember activities and the constant\n    and volume and temperature dependencies of the excess\n    properties can be queried after using set_composition().\n    States of the solution can only be queried after setting\n    the pressure, temperature and composition using set_state()\n    and set_composition.\n\n    This class is available as :class:`burnman.ElasticSolution`.\n    It uses an instance of :class:`burnman.ElasticSolutionModel` to\n    calculate interaction terms between endmembers.\n\n    All the solution parameters are expected to be in SI units.  This\n    means that the interaction parameters should be in J/mol, with the T\n    and V derivatives in J/K/mol and Pa/mol.\n\n    The parameters are relevant to all Elastic solution models. Please\n    see the documentation for individual models for details about\n    other parameters.\n\n    :param name: Name of the solution.\n    :type name: string\n    :param solution_model: The ElasticSolutionModel object defining the\n        properties of the solution.\n    :type solution_model: :class:`burnman.ElasticSolutionModel`\n    :param molar_fractions: The molar fractions of each endmember in the solution.\n        Can be reset using the set_composition() method.\n    :type molar_fractions: numpy.array\n    \"\"\"\n\n    def __init__(self, name=None, solution_model=None, molar_fractions=None):\n        \"\"\"\n        Set up matrices to speed up calculations for when P, T, X is defined.\n        \"\"\"\n        Mineral.__init__(self)\n\n        # Solution needs a method attribute to call Mineral.set_state().\n        # Note that set_method() below will not change self.method\n        self.method = \"ElasticSolutionMethod\"\n\n        if name is not None:\n            self.name = name\n        if solution_model is not None:\n            self.solution_model = solution_model\n\n        if isinstance(solution_model, ElasticMechanicalSolution):\n            self.solution_type = \"mechanical\"\n        else:\n            self.solution_type = \"chemical\"\n\n        # Starting guess and delta for pressure iteration\n        self.min_V0 = min(\n            [mbr[0].params[\"V_0\"] for mbr in self.solution_model.endmembers]\n        )\n        self.dV = 0.01 * self.min_V0\n\n        # Equation of state\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_method(\n                self.solution_model.endmembers[i][0].params[\"equation_of_state\"]\n            )\n\n        # Molar fractions\n        if molar_fractions is not None:\n            self.set_composition(molar_fractions)\n\n    @cached_property\n    def endmembers(self):\n        return self.solution_model.endmembers\n\n    def set_composition(self, molar_fractions):\n        \"\"\"\n        Set the composition for this solution.\n        Resets cached properties.\n\n        :param molar_fractions: Molar abundance for each endmember,\n            needs to sum to one.\n        :type molar_fractions: list of float\n        \"\"\"\n        assert len(self.solution_model.endmembers) == len(molar_fractions)\n\n        if self.solution_type != \"mechanical\":\n            assert sum(molar_fractions) > 0.9999\n            assert sum(molar_fractions) < 1.0001\n\n        self.reset()\n        self.molar_fractions = np.array(molar_fractions)\n\n        if self.temperature is not None:\n            _ = self.molar_volume\n\n    def set_method(self, method):\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_method(method)\n        # note: do not set self.method here!\n        self.reset()\n\n    def set_state(self, pressure, temperature):\n        Mineral.set_state(self, pressure, temperature)\n\n        try:\n            _ = self.molar_volume\n        except AttributeError:\n            pass\n\n    @material_property\n    def formula(self):\n        \"\"\"\n        Returns molar chemical formula of the solution.\n        \"\"\"\n        return sum_formulae(self.endmember_formulae, self.molar_fractions)\n\n    @material_property\n    def activities(self):\n        \"\"\"\n        Returns a list of endmember activities [unitless].\n        \"\"\"\n        volumes = [\n            self.solution_model.endmembers[i][0].method.volume(\n                self.pressure,\n                self.temperature,\n                self.solution_model.endmembers[i][0].params,\n            )\n            for i in range(self.n_endmembers)\n        ]\n\n        gibbs_pure = [\n            self.solution_model.endmembers[i][0].method.gibbs_free_energy(\n                self.pressure,\n                self.temperature,\n                volumes[i],\n                self.solution_model.endmembers[i][0].params,\n            )\n            for i in range(self.n_endmembers)\n        ]\n\n        acts = np.exp(\n            (self.partial_gibbs - np.array(gibbs_pure))\n            / (gas_constant * self.temperature)\n        )\n        return acts\n\n    @material_property\n    def activity_coefficients(self):\n        \"\"\"\n        Returns a list of endmember activity coefficients\n        (gamma = activity / ideal activity) [unitless].\n        \"\"\"\n        return np.exp(\n            np.log(self.activities)\n            - IdealSolution._log_ideal_activities(\n                self.solution_model, self.molar_fractions\n            )\n        )\n\n    @material_property\n    def molar_internal_energy(self):\n        \"\"\"\n        Returns molar internal energy of the mineral [J/mol].\n        Aliased with self.energy\n        \"\"\"\n        return self.molar_helmholtz + self.temperature * self.molar_entropy\n\n    @material_property\n    def _excess_partial_helmholtz(self):\n        \"\"\"\n        Returns excess partial molar helmholtz energy\n        at constant volume [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_helmholtz_energies(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def _excess_partial_pressures(self):\n        \"\"\"\n        Returns excess partial pressures at constant volume [Pa].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_pressures(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def _excess_partial_entropies(self):\n        \"\"\"\n        Returns excess partial entropies at constant volume [J/K].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_entropies(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def _partial_helmholtz(self):\n        \"\"\"\n        Returns endmember partial molar Helmholtz energy at constant volume [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].helmholtz\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self._excess_partial_helmholtz\n        )\n\n    @material_property\n    def _partial_pressures(self):\n        \"\"\"\n        Returns endmember partial pressures at constant volume [Pa].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].pressure\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self._excess_partial_pressures\n        )\n\n    @material_property\n    def _partial_entropies(self):\n        \"\"\"\n        Returns endmember partial entropies at constant volume [J/K].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].molar_entropy\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self._excess_partial_entropies\n        )\n\n    @material_property\n    def partial_gibbs(self):\n        \"\"\"\n        Returns endmember partial molar Gibbs energy\n        at constant pressure [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self._partial_helmholtz + self.pressure * self.molar_volume\n\n    @material_property\n    def _dPdX(self):\n        \"\"\"\n        Returns the change in pressure with amount of each endmember\n        at constant volume.\n        \"\"\"\n        sumX = np.sum(self.molar_fractions)\n        sumXP = np.einsum(\"i,i->\", self.molar_fractions, self._partial_pressures)\n        return (self._partial_pressures * sumX - sumXP) / (sumX * sumX)\n\n    @material_property\n    def _dVdX(self):\n        \"\"\"\n        Returns the change in pressure with amount of each endmember\n        at constant pressure.\n        \"\"\"\n        return self.molar_volume / self.isothermal_bulk_modulus * self._dPdX\n\n    @material_property\n    def _dSdX_mod(self):\n        \"\"\"\n        Returns the additional change in entropy with\n        amount of each endmember due to converting from constant volume\n        to constant pressure\n        \"\"\"\n        return self.alpha * self.molar_volume * self._dPdX\n\n    @material_property\n    def partial_volumes(self):\n        \"\"\"\n        Returns endmember partial molar volumes [m^3/mol].\n        Property specific to solutions.\n        \"\"\"\n        A = np.eye(self.n_endmembers) - self.molar_fractions\n        Vs = self.molar_volume + np.einsum(\"ij, j->i\", A, self._dVdX)\n        return Vs\n\n    @material_property\n    def partial_entropies(self):\n        \"\"\"\n        Returns endmember partial molar entropies [J/K/mol].\n        Property specific to solutions.\n        \"\"\"\n        A = np.eye(self.n_endmembers) - self.molar_fractions\n        Ss = self._partial_entropies + np.einsum(\"ij, j->i\", A, self._dSdX_mod)\n        return Ss\n\n    @material_property\n    def _excess_helmholtz(self):\n        \"\"\"\n        Returns molar excess Helmholtz energy at constant volume [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_helmholtz_energy(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def _helmholtz_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the Helmholtz energy at constant volume [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.helmholtz_hessian(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def _entropy_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the entropy at constant volume [J/K].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.entropy_hessian(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def _pressure_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the pressure at constant volume [Pa].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.pressure_hessian(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def gibbs_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the Gibbs energy at constant pressure [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        raise NotImplementedError\n\n    @material_property\n    def molar_helmholtz(self):\n        \"\"\"\n        Returns molar Helmholtz energy of the solution [J/mol].\n        Aliased with self.helmholtz.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].molar_helmholtz\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self._excess_helmholtz\n        )\n\n    @material_property\n    def molar_gibbs(self):\n        \"\"\"\n        Returns molar Gibbs free energy of the solution [J/mol].\n        Aliased with self.gibbs.\n        \"\"\"\n        return self.molar_helmholtz + self.pressure * self.molar_volume\n\n    @material_property\n    def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the solution [kg/mol].\n        \"\"\"\n        return sum(\n            [\n                self.solution_model.endmembers[i][0].molar_mass\n                * self.molar_fractions[i]\n                for i in range(self.n_endmembers)\n            ]\n        )\n\n    @material_property\n    def excess_pressure(self):\n        \"\"\"\n        Returns excess pressure of the solution [Pa].\n        Specific property for solutions.\n        \"\"\"\n        return self.solution_model.excess_pressure(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the solution [m^3/mol].\n        Aliased with self.V.\n        \"\"\"\n\n        def _delta_pressure(volume):\n            self._ptmp = [\n                self.solution_model.endmembers[i][0].method.pressure(\n                    self.temperature,\n                    volume,\n                    self.solution_model.endmembers[i][0].params,\n                )\n                for i in range(self.n_endmembers)\n            ]\n\n            pressure_try = sum(\n                [\n                    self._ptmp[i] * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            ) + self.solution_model.excess_pressure(\n                volume, self.temperature, self.molar_fractions\n            )\n\n            return pressure_try - self.pressure\n\n        def _K_T(volume):\n            # Note, this only works when the excess pressure is not a function\n            # of V or T.\n\n            return sum(\n                [\n                    self.solution_model.endmembers[i][0].method.isothermal_bulk_modulus(\n                        0.0,\n                        self.temperature,\n                        volume,\n                        self.solution_model.endmembers[i][0].params,\n                    )\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n\n        try:\n            # The first attempt to find a bracket for\n            # root finding uses V_0 as a starting point\n            sol = bracket(_delta_pressure, self.min_V0, self.dV)\n        except Exception:\n            # At high temperature, the naive bracketing above may\n            # try a volume guess that exceeds the point at which the\n            # bulk modulus goes negative at that temperature.\n            # In this case, we try a more nuanced approach by\n            # first finding the volume at which the bulk modulus goes\n            # negative, and then either (a) raising an exception if the\n            # desired pressure is less than the pressure at that volume,\n            # or (b) using that pressure to create a better bracket for\n            # brentq.\n\n            sol_K_T = bracket(_K_T, self.min_V0, self.dV)\n            V_crit = opt.brentq(_K_T, sol_K_T[0], sol_K_T[1])\n            P_min = self.pressure + _delta_pressure(V_crit)\n            if P_min > self.pressure:\n                raise Exception(\n                    \"The desired pressure is not achievable \"\n                    \"at this temperature. The minimum pressure \"\n                    f\"achievable is {P_min:.2e} Pa.\"\n                )\n            else:\n                try:\n                    sol = bracket(_delta_pressure, V_crit - self.dV, self.dV)\n                except Exception:\n                    raise Exception(\n                        \"Cannot find a volume, perhaps you are \"\n                        \"outside of the range of validity for \"\n                        \"the equation of state?\"\n                    )\n\n        V = opt.brentq(_delta_pressure, sol[0], sol[1])\n\n        _delta_pressure(V)\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_state(\n                self._ptmp[i], self.temperature\n            )\n\n        return V\n\n    @material_property\n    def density(self):\n        \"\"\"\n        Returns density of the solution [kg/m^3].\n        Aliased with self.rho.\n        \"\"\"\n        return self.molar_mass / self.molar_volume\n\n    @material_property\n    def excess_entropy(self):\n        \"\"\"\n        Returns excess molar entropy [J/K/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_entropy(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def molar_entropy(self):\n        \"\"\"\n        Returns molar entropy of the solution [J/K/mol].\n        Aliased with self.S.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].S * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_entropy\n        )\n\n    @material_property\n    def excess_enthalpy(self):\n        \"\"\"\n        Returns excess molar enthalpy [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_enthalpy(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )\n\n    @material_property\n    def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpy of the solution [J/mol].\n        Aliased with self.H.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].H * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_enthalpy\n        )\n\n    @material_property\n    def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the solution [Pa].\n        Aliased with self.K_T.\n        \"\"\"\n        return sum(\n            [\n                self.solution_model.endmembers[i][0].isothermal_bulk_modulus\n                * self.molar_fractions[i]\n                for i in range(self.n_endmembers)\n            ]\n        )\n\n    @material_property\n    def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns adiabatic bulk modulus of the solution [Pa].\n        Aliased with self.K_S.\n        \"\"\"\n        if self.temperature < 1e-10:\n            return self.isothermal_bulk_modulus\n        else:\n            return (\n                self.isothermal_bulk_modulus\n                * self.molar_heat_capacity_p\n                / self.molar_heat_capacity_v\n            )\n\n    @material_property\n    def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the solution.\n        (or inverse isothermal bulk modulus) [1/Pa].\n        Aliased with self.K_T.\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus\n\n    @material_property\n    def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibility of the solution.\n        (or inverse adiabatic bulk modulus) [1/Pa].\n        Aliased with self.K_S.\n        \"\"\"\n        return 1.0 / self.adiabatic_bulk_modulus\n\n    @material_property\n    def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the solution [Pa].\n        Aliased with self.G.\n        \"\"\"\n        G_list = np.fromiter(\n            (e[0].G for e in self.solution_model.endmembers),\n            dtype=float,\n            count=self.n_endmembers,\n        )\n        return reuss_average_function(self.molar_fractions, G_list)\n\n    @material_property\n    def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the solution [m/s].\n        Aliased with self.v_p.\n        \"\"\"\n        return np.sqrt(\n            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)\n            / self.density\n        )\n\n    @material_property\n    def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the solution [m/s].\n        Aliased with self.v_phi.\n        \"\"\"\n        return np.sqrt(self.adiabatic_bulk_modulus / self.density)\n\n    @material_property\n    def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the solution [m/s].\n        Aliased with self.v_s.\n        \"\"\"\n        return np.sqrt(self.shear_modulus / self.density)\n\n    @material_property\n    def grueneisen_parameter(self):\n        \"\"\"\n        Returns grueneisen parameter of the solution [unitless].\n        Aliased with self.gr.\n        \"\"\"\n        if self.temperature < 1e-10:\n            return float(\"nan\")\n        else:\n            return (\n                self.thermal_expansivity\n                * self.isothermal_bulk_modulus\n                * self.molar_volume\n                / self.molar_heat_capacity_v\n            )\n\n    @material_property\n    def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient (alpha)\n        of the solution [1/K].\n        Aliased with self.alpha.\n        \"\"\"\n        alphaKT = sum(\n            [\n                self.solution_model.endmembers[i][0].isothermal_bulk_modulus\n                * self.solution_model.endmembers[i][0].alpha\n                * self.molar_fractions[i]\n                for i in range(self.n_endmembers)\n            ]\n        )\n        return alphaKT / self.isothermal_bulk_modulus\n\n    @material_property\n    def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volume of the\n        solution [J/K/mol].\n        Aliased with self.C_v.\n        \"\"\"\n        return sum(\n            [\n                self.solution_model.endmembers[i][0].molar_heat_capacity_v\n                * self.molar_fractions[i]\n                for i in range(self.n_endmembers)\n            ]\n        )\n\n    @material_property\n    def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar heat capacity at constant pressure\n        of the solution [J/K/mol].\n        Aliased with self.C_p.\n        \"\"\"\n        return (\n            self.molar_heat_capacity_v\n            + self.molar_volume\n            * self.temperature\n            * self.thermal_expansivity\n            * self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n        )\n\n    @cached_property\n    def stoichiometric_matrix(self):\n        \"\"\"\n        A sympy Matrix where each element M[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n\n        def f(i, j):\n            e = self.elements[j]\n            if e in self.endmember_formulae[i]:\n                return nsimplify(self.endmember_formulae[i][e])\n            else:\n                return 0\n\n        return Matrix(len(self.endmember_formulae), len(self.elements), f)\n\n    @cached_property\n    def stoichiometric_array(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n        return np.array(self.stoichiometric_matrix)\n\n    @cached_property\n    def reaction_basis(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of moles of endmember[j] involved in reaction[i].\n        \"\"\"\n        reaction_basis = np.array(\n            [v[:] for v in self.stoichiometric_matrix.T.nullspace()]\n        )\n\n        if len(reaction_basis) == 0:\n            reaction_basis = np.empty((0, len(self.endmember_names)))\n\n        return reaction_basis\n\n    @cached_property\n    def n_reactions(self):\n        \"\"\"\n        The number of reactions in reaction_basis.\n        \"\"\"\n        return len(self.reaction_basis[:, 0])\n\n    @cached_property\n    def independent_element_indices(self):\n        \"\"\"\n        A list of an independent set of element indices. If the amounts of\n        these elements are known (element_amounts),\n        the amounts of the other elements can be inferred by\n        -compositional_null_basis[independent_element_indices].dot(element_amounts).\n        \"\"\"\n        return sorted(independent_row_indices(self.stoichiometric_matrix.T))\n\n    @cached_property\n    def dependent_element_indices(self):\n        \"\"\"\n        The element indices not included in the independent list.\n        \"\"\"\n        return [\n            i\n            for i in range(len(self.elements))\n            if i not in self.independent_element_indices\n        ]\n\n    @cached_property\n    def compositional_null_basis(self):\n        \"\"\"\n        An array N such that N.b = 0 for all bulk compositions that can\n        be produced with a linear sum of the endmembers in the solution.\n        \"\"\"\n        null_basis = np.array([v[:] for v in self.stoichiometric_matrix.nullspace()])\n\n        M = null_basis[:, self.dependent_element_indices]\n        assert (M.shape[0] == M.shape[1]) and (M == np.eye(M.shape[0])).all()\n\n        return null_basis\n\n    @cached_property\n    def endmember_formulae(self):\n        \"\"\"\n        A list of formulae for all the endmember in the solution.\n        \"\"\"\n        return [mbr[0].params[\"formula\"] for mbr in self.solution_model.endmembers]\n\n    @cached_property\n    def endmember_names(self):\n        \"\"\"\n        A list of names for all the endmember in the solution.\n        \"\"\"\n        return [mbr[0].name for mbr in self.solution_model.endmembers]\n\n    @cached_property\n    def n_endmembers(self):\n        \"\"\"\n        The number of endmembers in the solution.\n        \"\"\"\n        return len(self.solution_model.endmembers)\n\n    @cached_property\n    def elements(self):\n        \"\"\"\n        A list of the elements which could be contained in the solution,\n        returned in the IUPAC element order.\n        \"\"\"\n        keys = []\n        for f in self.endmember_formulae:\n            keys.extend(f.keys())\n\n        return sort_element_list_to_IUPAC_order(set(keys))",
  "def __init__(self, name=None, solution_model=None, molar_fractions=None):\n        \"\"\"\n        Set up matrices to speed up calculations for when P, T, X is defined.\n        \"\"\"\n        Mineral.__init__(self)\n\n        # Solution needs a method attribute to call Mineral.set_state().\n        # Note that set_method() below will not change self.method\n        self.method = \"ElasticSolutionMethod\"\n\n        if name is not None:\n            self.name = name\n        if solution_model is not None:\n            self.solution_model = solution_model\n\n        if isinstance(solution_model, ElasticMechanicalSolution):\n            self.solution_type = \"mechanical\"\n        else:\n            self.solution_type = \"chemical\"\n\n        # Starting guess and delta for pressure iteration\n        self.min_V0 = min(\n            [mbr[0].params[\"V_0\"] for mbr in self.solution_model.endmembers]\n        )\n        self.dV = 0.01 * self.min_V0\n\n        # Equation of state\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_method(\n                self.solution_model.endmembers[i][0].params[\"equation_of_state\"]\n            )\n\n        # Molar fractions\n        if molar_fractions is not None:\n            self.set_composition(molar_fractions)",
  "def endmembers(self):\n        return self.solution_model.endmembers",
  "def set_composition(self, molar_fractions):\n        \"\"\"\n        Set the composition for this solution.\n        Resets cached properties.\n\n        :param molar_fractions: Molar abundance for each endmember,\n            needs to sum to one.\n        :type molar_fractions: list of float\n        \"\"\"\n        assert len(self.solution_model.endmembers) == len(molar_fractions)\n\n        if self.solution_type != \"mechanical\":\n            assert sum(molar_fractions) > 0.9999\n            assert sum(molar_fractions) < 1.0001\n\n        self.reset()\n        self.molar_fractions = np.array(molar_fractions)\n\n        if self.temperature is not None:\n            _ = self.molar_volume",
  "def set_method(self, method):\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_method(method)\n        # note: do not set self.method here!\n        self.reset()",
  "def set_state(self, pressure, temperature):\n        Mineral.set_state(self, pressure, temperature)\n\n        try:\n            _ = self.molar_volume\n        except AttributeError:\n            pass",
  "def formula(self):\n        \"\"\"\n        Returns molar chemical formula of the solution.\n        \"\"\"\n        return sum_formulae(self.endmember_formulae, self.molar_fractions)",
  "def activities(self):\n        \"\"\"\n        Returns a list of endmember activities [unitless].\n        \"\"\"\n        volumes = [\n            self.solution_model.endmembers[i][0].method.volume(\n                self.pressure,\n                self.temperature,\n                self.solution_model.endmembers[i][0].params,\n            )\n            for i in range(self.n_endmembers)\n        ]\n\n        gibbs_pure = [\n            self.solution_model.endmembers[i][0].method.gibbs_free_energy(\n                self.pressure,\n                self.temperature,\n                volumes[i],\n                self.solution_model.endmembers[i][0].params,\n            )\n            for i in range(self.n_endmembers)\n        ]\n\n        acts = np.exp(\n            (self.partial_gibbs - np.array(gibbs_pure))\n            / (gas_constant * self.temperature)\n        )\n        return acts",
  "def activity_coefficients(self):\n        \"\"\"\n        Returns a list of endmember activity coefficients\n        (gamma = activity / ideal activity) [unitless].\n        \"\"\"\n        return np.exp(\n            np.log(self.activities)\n            - IdealSolution._log_ideal_activities(\n                self.solution_model, self.molar_fractions\n            )\n        )",
  "def molar_internal_energy(self):\n        \"\"\"\n        Returns molar internal energy of the mineral [J/mol].\n        Aliased with self.energy\n        \"\"\"\n        return self.molar_helmholtz + self.temperature * self.molar_entropy",
  "def _excess_partial_helmholtz(self):\n        \"\"\"\n        Returns excess partial molar helmholtz energy\n        at constant volume [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_helmholtz_energies(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )",
  "def _excess_partial_pressures(self):\n        \"\"\"\n        Returns excess partial pressures at constant volume [Pa].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_pressures(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )",
  "def _excess_partial_entropies(self):\n        \"\"\"\n        Returns excess partial entropies at constant volume [J/K].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_partial_entropies(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )",
  "def _partial_helmholtz(self):\n        \"\"\"\n        Returns endmember partial molar Helmholtz energy at constant volume [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].helmholtz\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self._excess_partial_helmholtz\n        )",
  "def _partial_pressures(self):\n        \"\"\"\n        Returns endmember partial pressures at constant volume [Pa].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].pressure\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self._excess_partial_pressures\n        )",
  "def _partial_entropies(self):\n        \"\"\"\n        Returns endmember partial entropies at constant volume [J/K].\n        Property specific to solutions.\n        \"\"\"\n        return (\n            np.array(\n                [\n                    self.solution_model.endmembers[i][0].molar_entropy\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self._excess_partial_entropies\n        )",
  "def partial_gibbs(self):\n        \"\"\"\n        Returns endmember partial molar Gibbs energy\n        at constant pressure [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self._partial_helmholtz + self.pressure * self.molar_volume",
  "def _dPdX(self):\n        \"\"\"\n        Returns the change in pressure with amount of each endmember\n        at constant volume.\n        \"\"\"\n        sumX = np.sum(self.molar_fractions)\n        sumXP = np.einsum(\"i,i->\", self.molar_fractions, self._partial_pressures)\n        return (self._partial_pressures * sumX - sumXP) / (sumX * sumX)",
  "def _dVdX(self):\n        \"\"\"\n        Returns the change in pressure with amount of each endmember\n        at constant pressure.\n        \"\"\"\n        return self.molar_volume / self.isothermal_bulk_modulus * self._dPdX",
  "def _dSdX_mod(self):\n        \"\"\"\n        Returns the additional change in entropy with\n        amount of each endmember due to converting from constant volume\n        to constant pressure\n        \"\"\"\n        return self.alpha * self.molar_volume * self._dPdX",
  "def partial_volumes(self):\n        \"\"\"\n        Returns endmember partial molar volumes [m^3/mol].\n        Property specific to solutions.\n        \"\"\"\n        A = np.eye(self.n_endmembers) - self.molar_fractions\n        Vs = self.molar_volume + np.einsum(\"ij, j->i\", A, self._dVdX)\n        return Vs",
  "def partial_entropies(self):\n        \"\"\"\n        Returns endmember partial molar entropies [J/K/mol].\n        Property specific to solutions.\n        \"\"\"\n        A = np.eye(self.n_endmembers) - self.molar_fractions\n        Ss = self._partial_entropies + np.einsum(\"ij, j->i\", A, self._dSdX_mod)\n        return Ss",
  "def _excess_helmholtz(self):\n        \"\"\"\n        Returns molar excess Helmholtz energy at constant volume [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_helmholtz_energy(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )",
  "def _helmholtz_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the Helmholtz energy at constant volume [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.helmholtz_hessian(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )",
  "def _entropy_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the entropy at constant volume [J/K].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.entropy_hessian(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )",
  "def _pressure_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the pressure at constant volume [Pa].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.pressure_hessian(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )",
  "def gibbs_hessian(self):\n        \"\"\"\n        Returns an array containing the second compositional derivative\n        of the Gibbs energy at constant pressure [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        raise NotImplementedError",
  "def molar_helmholtz(self):\n        \"\"\"\n        Returns molar Helmholtz energy of the solution [J/mol].\n        Aliased with self.helmholtz.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].molar_helmholtz\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self._excess_helmholtz\n        )",
  "def molar_gibbs(self):\n        \"\"\"\n        Returns molar Gibbs free energy of the solution [J/mol].\n        Aliased with self.gibbs.\n        \"\"\"\n        return self.molar_helmholtz + self.pressure * self.molar_volume",
  "def molar_mass(self):\n        \"\"\"\n        Returns molar mass of the solution [kg/mol].\n        \"\"\"\n        return sum(\n            [\n                self.solution_model.endmembers[i][0].molar_mass\n                * self.molar_fractions[i]\n                for i in range(self.n_endmembers)\n            ]\n        )",
  "def excess_pressure(self):\n        \"\"\"\n        Returns excess pressure of the solution [Pa].\n        Specific property for solutions.\n        \"\"\"\n        return self.solution_model.excess_pressure(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )",
  "def molar_volume(self):\n        \"\"\"\n        Returns molar volume of the solution [m^3/mol].\n        Aliased with self.V.\n        \"\"\"\n\n        def _delta_pressure(volume):\n            self._ptmp = [\n                self.solution_model.endmembers[i][0].method.pressure(\n                    self.temperature,\n                    volume,\n                    self.solution_model.endmembers[i][0].params,\n                )\n                for i in range(self.n_endmembers)\n            ]\n\n            pressure_try = sum(\n                [\n                    self._ptmp[i] * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            ) + self.solution_model.excess_pressure(\n                volume, self.temperature, self.molar_fractions\n            )\n\n            return pressure_try - self.pressure\n\n        def _K_T(volume):\n            # Note, this only works when the excess pressure is not a function\n            # of V or T.\n\n            return sum(\n                [\n                    self.solution_model.endmembers[i][0].method.isothermal_bulk_modulus(\n                        0.0,\n                        self.temperature,\n                        volume,\n                        self.solution_model.endmembers[i][0].params,\n                    )\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n\n        try:\n            # The first attempt to find a bracket for\n            # root finding uses V_0 as a starting point\n            sol = bracket(_delta_pressure, self.min_V0, self.dV)\n        except Exception:\n            # At high temperature, the naive bracketing above may\n            # try a volume guess that exceeds the point at which the\n            # bulk modulus goes negative at that temperature.\n            # In this case, we try a more nuanced approach by\n            # first finding the volume at which the bulk modulus goes\n            # negative, and then either (a) raising an exception if the\n            # desired pressure is less than the pressure at that volume,\n            # or (b) using that pressure to create a better bracket for\n            # brentq.\n\n            sol_K_T = bracket(_K_T, self.min_V0, self.dV)\n            V_crit = opt.brentq(_K_T, sol_K_T[0], sol_K_T[1])\n            P_min = self.pressure + _delta_pressure(V_crit)\n            if P_min > self.pressure:\n                raise Exception(\n                    \"The desired pressure is not achievable \"\n                    \"at this temperature. The minimum pressure \"\n                    f\"achievable is {P_min:.2e} Pa.\"\n                )\n            else:\n                try:\n                    sol = bracket(_delta_pressure, V_crit - self.dV, self.dV)\n                except Exception:\n                    raise Exception(\n                        \"Cannot find a volume, perhaps you are \"\n                        \"outside of the range of validity for \"\n                        \"the equation of state?\"\n                    )\n\n        V = opt.brentq(_delta_pressure, sol[0], sol[1])\n\n        _delta_pressure(V)\n        for i in range(self.n_endmembers):\n            self.solution_model.endmembers[i][0].set_state(\n                self._ptmp[i], self.temperature\n            )\n\n        return V",
  "def density(self):\n        \"\"\"\n        Returns density of the solution [kg/m^3].\n        Aliased with self.rho.\n        \"\"\"\n        return self.molar_mass / self.molar_volume",
  "def excess_entropy(self):\n        \"\"\"\n        Returns excess molar entropy [J/K/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_entropy(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )",
  "def molar_entropy(self):\n        \"\"\"\n        Returns molar entropy of the solution [J/K/mol].\n        Aliased with self.S.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].S * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_entropy\n        )",
  "def excess_enthalpy(self):\n        \"\"\"\n        Returns excess molar enthalpy [J/mol].\n        Property specific to solutions.\n        \"\"\"\n        return self.solution_model.excess_enthalpy(\n            self.molar_volume, self.temperature, self.molar_fractions\n        )",
  "def molar_enthalpy(self):\n        \"\"\"\n        Returns molar enthalpy of the solution [J/mol].\n        Aliased with self.H.\n        \"\"\"\n        return (\n            sum(\n                [\n                    self.solution_model.endmembers[i][0].H * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )\n            + self.excess_enthalpy\n        )",
  "def isothermal_bulk_modulus(self):\n        \"\"\"\n        Returns isothermal bulk modulus of the solution [Pa].\n        Aliased with self.K_T.\n        \"\"\"\n        return sum(\n            [\n                self.solution_model.endmembers[i][0].isothermal_bulk_modulus\n                * self.molar_fractions[i]\n                for i in range(self.n_endmembers)\n            ]\n        )",
  "def adiabatic_bulk_modulus(self):\n        \"\"\"\n        Returns adiabatic bulk modulus of the solution [Pa].\n        Aliased with self.K_S.\n        \"\"\"\n        if self.temperature < 1e-10:\n            return self.isothermal_bulk_modulus\n        else:\n            return (\n                self.isothermal_bulk_modulus\n                * self.molar_heat_capacity_p\n                / self.molar_heat_capacity_v\n            )",
  "def isothermal_compressibility(self):\n        \"\"\"\n        Returns isothermal compressibility of the solution.\n        (or inverse isothermal bulk modulus) [1/Pa].\n        Aliased with self.K_T.\n        \"\"\"\n        return 1.0 / self.isothermal_bulk_modulus",
  "def adiabatic_compressibility(self):\n        \"\"\"\n        Returns adiabatic compressibility of the solution.\n        (or inverse adiabatic bulk modulus) [1/Pa].\n        Aliased with self.K_S.\n        \"\"\"\n        return 1.0 / self.adiabatic_bulk_modulus",
  "def shear_modulus(self):\n        \"\"\"\n        Returns shear modulus of the solution [Pa].\n        Aliased with self.G.\n        \"\"\"\n        G_list = np.fromiter(\n            (e[0].G for e in self.solution_model.endmembers),\n            dtype=float,\n            count=self.n_endmembers,\n        )\n        return reuss_average_function(self.molar_fractions, G_list)",
  "def p_wave_velocity(self):\n        \"\"\"\n        Returns P wave speed of the solution [m/s].\n        Aliased with self.v_p.\n        \"\"\"\n        return np.sqrt(\n            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)\n            / self.density\n        )",
  "def bulk_sound_velocity(self):\n        \"\"\"\n        Returns bulk sound speed of the solution [m/s].\n        Aliased with self.v_phi.\n        \"\"\"\n        return np.sqrt(self.adiabatic_bulk_modulus / self.density)",
  "def shear_wave_velocity(self):\n        \"\"\"\n        Returns shear wave speed of the solution [m/s].\n        Aliased with self.v_s.\n        \"\"\"\n        return np.sqrt(self.shear_modulus / self.density)",
  "def grueneisen_parameter(self):\n        \"\"\"\n        Returns grueneisen parameter of the solution [unitless].\n        Aliased with self.gr.\n        \"\"\"\n        if self.temperature < 1e-10:\n            return float(\"nan\")\n        else:\n            return (\n                self.thermal_expansivity\n                * self.isothermal_bulk_modulus\n                * self.molar_volume\n                / self.molar_heat_capacity_v\n            )",
  "def thermal_expansivity(self):\n        \"\"\"\n        Returns thermal expansion coefficient (alpha)\n        of the solution [1/K].\n        Aliased with self.alpha.\n        \"\"\"\n        alphaKT = sum(\n            [\n                self.solution_model.endmembers[i][0].isothermal_bulk_modulus\n                * self.solution_model.endmembers[i][0].alpha\n                * self.molar_fractions[i]\n                for i in range(self.n_endmembers)\n            ]\n        )\n        return alphaKT / self.isothermal_bulk_modulus",
  "def molar_heat_capacity_v(self):\n        \"\"\"\n        Returns molar heat capacity at constant volume of the\n        solution [J/K/mol].\n        Aliased with self.C_v.\n        \"\"\"\n        return sum(\n            [\n                self.solution_model.endmembers[i][0].molar_heat_capacity_v\n                * self.molar_fractions[i]\n                for i in range(self.n_endmembers)\n            ]\n        )",
  "def molar_heat_capacity_p(self):\n        \"\"\"\n        Returns molar heat capacity at constant pressure\n        of the solution [J/K/mol].\n        Aliased with self.C_p.\n        \"\"\"\n        return (\n            self.molar_heat_capacity_v\n            + self.molar_volume\n            * self.temperature\n            * self.thermal_expansivity\n            * self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n        )",
  "def stoichiometric_matrix(self):\n        \"\"\"\n        A sympy Matrix where each element M[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n\n        def f(i, j):\n            e = self.elements[j]\n            if e in self.endmember_formulae[i]:\n                return nsimplify(self.endmember_formulae[i][e])\n            else:\n                return 0\n\n        return Matrix(len(self.endmember_formulae), len(self.elements), f)",
  "def stoichiometric_array(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of atoms of element[j] in endmember[i].\n        \"\"\"\n        return np.array(self.stoichiometric_matrix)",
  "def reaction_basis(self):\n        \"\"\"\n        An array where each element arr[i,j] corresponds\n        to the number of moles of endmember[j] involved in reaction[i].\n        \"\"\"\n        reaction_basis = np.array(\n            [v[:] for v in self.stoichiometric_matrix.T.nullspace()]\n        )\n\n        if len(reaction_basis) == 0:\n            reaction_basis = np.empty((0, len(self.endmember_names)))\n\n        return reaction_basis",
  "def n_reactions(self):\n        \"\"\"\n        The number of reactions in reaction_basis.\n        \"\"\"\n        return len(self.reaction_basis[:, 0])",
  "def independent_element_indices(self):\n        \"\"\"\n        A list of an independent set of element indices. If the amounts of\n        these elements are known (element_amounts),\n        the amounts of the other elements can be inferred by\n        -compositional_null_basis[independent_element_indices].dot(element_amounts).\n        \"\"\"\n        return sorted(independent_row_indices(self.stoichiometric_matrix.T))",
  "def dependent_element_indices(self):\n        \"\"\"\n        The element indices not included in the independent list.\n        \"\"\"\n        return [\n            i\n            for i in range(len(self.elements))\n            if i not in self.independent_element_indices\n        ]",
  "def compositional_null_basis(self):\n        \"\"\"\n        An array N such that N.b = 0 for all bulk compositions that can\n        be produced with a linear sum of the endmembers in the solution.\n        \"\"\"\n        null_basis = np.array([v[:] for v in self.stoichiometric_matrix.nullspace()])\n\n        M = null_basis[:, self.dependent_element_indices]\n        assert (M.shape[0] == M.shape[1]) and (M == np.eye(M.shape[0])).all()\n\n        return null_basis",
  "def endmember_formulae(self):\n        \"\"\"\n        A list of formulae for all the endmember in the solution.\n        \"\"\"\n        return [mbr[0].params[\"formula\"] for mbr in self.solution_model.endmembers]",
  "def endmember_names(self):\n        \"\"\"\n        A list of names for all the endmember in the solution.\n        \"\"\"\n        return [mbr[0].name for mbr in self.solution_model.endmembers]",
  "def n_endmembers(self):\n        \"\"\"\n        The number of endmembers in the solution.\n        \"\"\"\n        return len(self.solution_model.endmembers)",
  "def elements(self):\n        \"\"\"\n        A list of the elements which could be contained in the solution,\n        returned in the IUPAC element order.\n        \"\"\"\n        keys = []\n        for f in self.endmember_formulae:\n            keys.extend(f.keys())\n\n        return sort_element_list_to_IUPAC_order(set(keys))",
  "def _delta_pressure(volume):\n            self._ptmp = [\n                self.solution_model.endmembers[i][0].method.pressure(\n                    self.temperature,\n                    volume,\n                    self.solution_model.endmembers[i][0].params,\n                )\n                for i in range(self.n_endmembers)\n            ]\n\n            pressure_try = sum(\n                [\n                    self._ptmp[i] * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            ) + self.solution_model.excess_pressure(\n                volume, self.temperature, self.molar_fractions\n            )\n\n            return pressure_try - self.pressure",
  "def _K_T(volume):\n            # Note, this only works when the excess pressure is not a function\n            # of V or T.\n\n            return sum(\n                [\n                    self.solution_model.endmembers[i][0].method.isothermal_bulk_modulus(\n                        0.0,\n                        self.temperature,\n                        volume,\n                        self.solution_model.endmembers[i][0].params,\n                    )\n                    * self.molar_fractions[i]\n                    for i in range(self.n_endmembers)\n                ]\n            )",
  "def f(i, j):\n            e = self.elements[j]\n            if e in self.endmember_formulae[i]:\n                return nsimplify(self.endmember_formulae[i][e])\n            else:\n                return 0",
  "class ElasticSolutionModel(object):\n\n    \"\"\"\n    This is the base class for an Elastic solution model, intended for use\n    in defining solutions and performing thermodynamic calculations\n    on them.  All minerals of type :class:`burnman.Solution` use\n    a solution model for defining how the endmembers in the solution\n    interact.\n\n    A user wanting a new solution model should define the functions included\n    in the base class. All of the functions in the base class return zero,\n    so if the user-defined solution model does not implement them,\n    they essentially have no effect, and the Helmholtz energy and\n    pressure of a solution will be equal to the weighted arithmetic\n    averages of the different endmember values.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Does nothing.\n        \"\"\"\n        pass\n\n    def excess_helmholtz_energy(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess Helmholtz free energy of the solution.\n        The base class implementation assumes that the excess Helmholtz\n        energy is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess Helmholtz energy.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            np.array(molar_fractions),\n            self.excess_partial_helmholtz_energies(\n                volume, temperature, molar_fractions\n            ),\n        )\n\n    def excess_pressure(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess pressure of the solution.\n        The base class implementation assumes that the excess pressure is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess pressure of the solution.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            molar_fractions,\n            self.excess_partial_pressures(volume, temperature, molar_fractions),\n        )\n\n    def excess_entropy(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess entropy of the solution.\n        The base class implementation assumes that the excess entropy is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess entropy of the solution.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            molar_fractions,\n            self.excess_partial_entropies(volume, temperature, molar_fractions),\n        )\n\n    def excess_enthalpy(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess enthalpy of the solution.\n        The base class implementation assumes that the excess enthalpy is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess enthalpy of the solution.\n        :rtype: float\n        \"\"\"\n        return (\n            self.excess_helmholtz_energy(volume, temperature, molar_fractions)\n            + temperature * self.excess_entropy(volume, temperature, molar_fractions)\n            - volume * self.excess_pressure(volume, temperature, molar_fractions)\n        )\n\n    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess Helmholtz energy for each endmember of the solution.\n        The base class implementation assumes that the excess Helmholtz energy\n        is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess Helmholtz energy of each endmember\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(molar_fractions)\n\n    def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess entropy for each endmember of the solution.\n        The base class implementation assumes that the excess entropy\n        is zero (true for mechanical solutions).\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess entropy of each endmember.\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(molar_fractions)\n\n    def excess_partial_pressures(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess pressure for each endmember of the solution.\n        The base class implementation assumes that the excess pressure\n        is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess pressure of each endmember.\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(np.array(molar_fractions))",
  "class ElasticMechanicalSolution(ElasticSolutionModel):\n\n    \"\"\"\n    An extremely simple class representing a mechanical solution model.\n    A mechanical solution experiences no interaction between endmembers.\n    Therefore, unlike ideal solutions there is no entropy of mixing;\n    the total Helmholtz energy of the solution is equal to the\n    dot product of the molar Helmholtz energies and molar fractions\n    of the constituent materials.\n    \"\"\"\n\n    def __init__(self, endmembers):\n        self.endmembers = endmembers\n        self.n_endmembers = len(endmembers)\n        self.formulas = [e[1] for e in endmembers]\n\n    def excess_helmholtz_energy(self, volume, temperature, molar_fractions):\n        return 0.0\n\n    def excess_pressure(self, volume, temperature, molar_fractions):\n        return 0.0\n\n    def excess_entropy(self, volume, temperature, molar_fractions):\n        return 0.0\n\n    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        return np.zeros_like(molar_fractions)\n\n    def excess_partial_pressures(self, volume, temperature, molar_fractions):\n        return np.zeros_like(molar_fractions)\n\n    def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        return np.zeros_like(molar_fractions)",
  "class ElasticIdealSolution(ElasticSolutionModel):\n\n    \"\"\"\n    A class representing an ideal solution model.\n    Calculates the excess Helmholtz energy and entropy due to configurational\n    entropy. Excess internal energy and volume are equal to zero.\n\n    The multiplicity of each type of site in the structure is allowed to\n    change linearly as a function of endmember proportions. This class\n    is therefore equivalent to the entropic part of\n    a Temkin-type model :cite:`Temkin1945`.\n    \"\"\"\n\n    def __init__(self, endmembers):\n        self.endmembers = endmembers\n        self.n_endmembers = len(endmembers)\n        self.formulas = [e[1] for e in endmembers]\n\n        # Process solution chemistry\n        process_solution_chemistry(self)\n\n        self._calculate_endmember_configurational_entropies()\n\n    def _calculate_endmember_configurational_entropies(self):\n        S_conf = -(\n            constants.gas_constant\n            * (self.endmember_noccupancies * logish(self.endmember_occupancies)).sum(-1)\n        )\n        self.endmember_configurational_entropies = S_conf\n\n    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        return self._ideal_excess_partial_helmholtz(temperature, molar_fractions)\n\n    def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        return self._ideal_excess_partial_entropies(temperature, molar_fractions)\n\n    def excess_partial_pressures(self, volume, temperature, molar_fractions):\n        return np.zeros((self.n_endmembers))\n\n    def helmholtz_hessian(self, volume, temperature, molar_fractions):\n        hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)\n        return -temperature * hess_S\n\n    def entropy_hessian(self, volume, temperature, molar_fractions):\n        hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)\n        return hess_S\n\n    def pressure_hessian(self, volume, temperature, molar_fractions):\n        return np.zeros((len(molar_fractions), len(molar_fractions)))\n\n    def _configurational_entropy(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n        site_occupancies = site_noccupancies * inverseish(site_multiplicities)\n        conf_entropy = -(\n            constants.gas_constant\n            * (site_noccupancies * logish(site_occupancies)).sum(-1)\n        )\n        return conf_entropy\n\n    def _ideal_excess_partial_helmholtz(self, temperature, molar_fractions):\n        return -(\n            temperature\n            * self._ideal_excess_partial_entropies(temperature, molar_fractions)\n        )\n\n    def _ideal_excess_partial_entropies(self, temperature, molar_fractions):\n        return -(constants.gas_constant * self._log_ideal_activities(molar_fractions))\n\n    def _ideal_entropy_hessian(self, temperature, molar_fractions):\n        hessian = -constants.gas_constant * self._log_ideal_activity_derivatives(\n            molar_fractions\n        )\n        return hessian\n\n    def _log_ideal_activities(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n\n        lna = np.einsum(\n            \"ij, j->i\",\n            self.endmember_noccupancies,\n            logish(site_noccupancies) - logish(site_multiplicities),\n        )\n\n        normalisation_constants = (\n            self.endmember_configurational_entropies / constants.gas_constant\n        )\n        return lna + normalisation_constants\n\n    def _log_ideal_activity_derivatives(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n\n        dlnadp = np.einsum(\n            \"pj, qj, j->pq\",\n            self.endmember_noccupancies,\n            self.endmember_noccupancies,\n            inverseish(site_noccupancies),\n        ) - np.einsum(\n            \"pj, qj, j->pq\",\n            self.endmember_noccupancies,\n            self.site_multiplicities,\n            inverseish(site_multiplicities),\n        )\n\n        return dlnadp\n\n    def _ideal_activities(self, molar_fractions):\n        return _ideal_activities_fct(\n            molar_fractions,\n            self.endmember_noccupancies,\n            self.n_endmembers,\n            self.n_occupancies,\n            self.site_multiplicities,\n            self.endmember_configurational_entropies,\n        )",
  "class ElasticAsymmetricRegularSolution(ElasticIdealSolution):\n\n    \"\"\"\n    Solution model implementing the asymmetric regular solution model\n    formulation as described in :cite:`HP2003`.\n\n    The excess nonconfigurational Helmholtz energy is given by the\n    expression:\n\n    .. math::\n        \\\\mathcal{F}_{\\\\textrm{excess}} = \\\\alpha^T p (\\\\phi^T W \\\\phi)\n\n    :math:`\\\\alpha` is a vector of van Laar parameters governing asymmetry\n    in the excess properties.\n\n    .. math::\n        \\\\phi_i = \\\\frac{\\\\alpha_i p_i}{\\\\sum_{k=1}^{n} \\\\alpha_k p_k},\n        W_{ij} = \\\\frac{2 w_{ij}}{\\\\alpha_i + \\\\alpha_j} \\\\textrm{for i<j}\n    \"\"\"\n\n    def __init__(\n        self,\n        endmembers,\n        alphas,\n        energy_interaction,\n        pressure_interaction=None,\n        entropy_interaction=None,\n    ):\n        self.n_endmembers = len(endmembers)\n\n        # Create array of van Laar parameters\n        self.alphas = np.array(alphas)\n\n        # Create 2D arrays of interaction parameters\n        self.We = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n        self.We[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n            [i for row in energy_interaction for i in row]\n        )\n\n        if entropy_interaction is not None:\n            self.Ws = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n            self.Ws[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n                [i for row in entropy_interaction for i in row]\n            )\n        else:\n            self.Ws = np.zeros((self.n_endmembers, self.n_endmembers))\n\n        if pressure_interaction is not None:\n            self.Wp = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n            self.Wp[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n                [i for row in pressure_interaction for i in row]\n            )\n        else:\n            self.Wp = np.zeros((self.n_endmembers, self.n_endmembers))\n\n        # initialize ideal solution model\n        ElasticIdealSolution.__init__(self, endmembers)\n\n    def _phi(self, molar_fractions):\n        phi = self.alphas * molar_fractions\n        phi = np.divide(phi, np.sum(phi))\n        return phi\n\n    def _non_ideal_interactions(self, W, molar_fractions):\n        # -sum(sum(qi.qj.Wij*)\n        # equation (2) of Holland and Powell 2003\n        phi = self._phi(molar_fractions)\n        return _non_ideal_interactions_fct(\n            phi, np.array(molar_fractions), self.n_endmembers, self.alphas, W\n        )\n\n    def _non_ideal_excess_partial_helmholtz(self, volume, temperature, molar_fractions):\n        Eint = self._non_ideal_interactions(self.We, molar_fractions)\n        Sint = self._non_ideal_interactions(self.Ws, molar_fractions)\n        Pint = self._non_ideal_interactions(self.Wp, molar_fractions)\n        return Eint - temperature * Sint - volume * Pint\n\n    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        ideal_helmholtz = ElasticIdealSolution._ideal_excess_partial_helmholtz(\n            self, temperature, molar_fractions\n        )\n        non_ideal_helmholtz = self._non_ideal_excess_partial_helmholtz(\n            volume, temperature, molar_fractions\n        )\n        return ideal_helmholtz + non_ideal_helmholtz\n\n    def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        ideal_entropies = ElasticIdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_interactions(self.Ws, molar_fractions)\n        return ideal_entropies + non_ideal_entropies\n\n    def excess_partial_pressures(self, volume, temperature, molar_fractions):\n        return self._non_ideal_interactions(self.Wp, molar_fractions)\n\n    def helmholtz_hessian(self, volume, temperature, molar_fractions):\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        phi = self._phi(molar_fractions)\n        nonideal_helmholtz_hessian = _non_ideal_hessian_fct(\n            phi,\n            molar_fractions,\n            self.n_endmembers,\n            self.alphas,\n            self.We - temperature * self.Ws - volume * self.Wp,\n        )\n\n        return nonideal_helmholtz_hessian - temperature * ideal_entropy_hessian\n\n    def entropy_hessian(self, volume, temperature, molar_fractions):\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        phi = self._phi(molar_fractions)\n        nonideal_entropy_hessian = _non_ideal_hessian_fct(\n            phi, molar_fractions, self.n_endmembers, self.alphas, self.Ws\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian\n\n    def pressure_hessian(self, volume, temperature, molar_fractions):\n        phi = self._phi(molar_fractions)\n        return _non_ideal_hessian_fct(\n            phi, molar_fractions, self.n_endmembers, self.alphas, self.Wp\n        )",
  "class ElasticSymmetricRegularSolution(ElasticAsymmetricRegularSolution):\n\n    \"\"\"\n    Solution model implementing the symmetric regular solution model.\n    This is a special case of the\n    :class:`burnman.solutionmodel.AsymmetricRegularSolution` class.\n    \"\"\"\n\n    def __init__(\n        self,\n        endmembers,\n        energy_interaction,\n        pressure_interaction=None,\n        entropy_interaction=None,\n    ):\n        alphas = np.ones(len(endmembers))\n        ElasticAsymmetricRegularSolution.__init__(\n            self,\n            endmembers,\n            alphas,\n            energy_interaction,\n            pressure_interaction,\n            entropy_interaction,\n        )",
  "class ElasticSubregularSolution(ElasticIdealSolution):\n\n    \"\"\"\n    Solution model implementing the subregular solution model formulation\n    as described in :cite:`HW1989`. The excess conconfigurational\n    Helmholtz energy is given by the expression:\n\n    .. math::\n        \\\\mathcal{F}_{\\\\textrm{excess}} = \\\\sum_i \\\\sum_{j > i} (p_i p_j^2\n        W_{ij} + p_j p_i^2 W_{ji} + \\\\sum_{k > j > i} p_i p_j p_k W_{ijk})\n\n    Interaction parameters are inserted into a 3D interaction matrix during\n    initialization to make use of numpy vector algebra.\n\n    :param endmembers: A list of all the independent endmembers in the solution.\n        The first item of each list gives the Mineral object corresponding\n        to the endmember. The second item gives the site-species formula.\n    :type endmembers: list of lists\n    :param energy_interaction: The binary endmember interaction energies.\n        Each interaction[i, j-i-1, 0] corresponds to W(i,j), while\n        interaction[i, j-i-1, 1] corresponds to W(j,i).\n    :type energy_interaction: list of list of lists\n    :param pressure_interaction: The binary endmember interaction pressures.\n        Each interaction[i, j-i-1, 0] corresponds to W(i,j), while\n        interaction[i, j-i-1, 1] corresponds to W(j,i).\n    :type pressure_interaction: list of list of lists\n    :param entropy_interaction: The binary endmember interaction entropies.\n        Each interaction[i, j-i-1, 0] corresponds to W(i,j), while\n        interaction[i, j-i-1, 1] corresponds to W(j,i).\n    :type entropy_interaction: list of list of lists\n    :param energy_ternary_terms: The ternary interaction energies.\n        Each list should contain four entries: the indices i, j, k\n        and the value of the interaction.\n    :type energy_ternary_terms: list of lists\n    :param pressure_ternary_terms: The ternary interaction pressures.\n        Each list should contain four entries: the indices i, j, k\n        and the value of the interaction.\n    :type pressure_ternary_terms: list of lists\n    :param entropy_ternary_terms: The ternary interaction entropies.\n        Each list should contain four entries:\n        the indices i, j, k and the value of the interaction.\n    :type entropy_ternary_terms: list of lists\n    \"\"\"\n\n    def __init__(\n        self,\n        endmembers,\n        energy_interaction,\n        pressure_interaction=None,\n        entropy_interaction=None,\n        energy_ternary_terms=None,\n        pressure_ternary_terms=None,\n        entropy_ternary_terms=None,\n    ):\n        \"\"\"\n        Initialization function for the SubregularSolution class.\n        \"\"\"\n\n        self.n_endmembers = len(endmembers)\n\n        # Create 3D arrays of interaction parameters\n        self.Wijke = np.zeros(\n            shape=(self.n_endmembers, self.n_endmembers, self.n_endmembers)\n        )\n        self.Wijks = np.zeros_like(self.Wijke)\n        self.Wijkp = np.zeros_like(self.Wijke)\n\n        # setup excess enthalpy interaction matrix\n        for i in range(self.n_endmembers):\n            for j in range(i + 1, self.n_endmembers):\n                w0 = energy_interaction[i][j - i - 1][0] / 2.0\n                w1 = energy_interaction[i][j - i - 1][1] / 2.0\n                self.Wijke[:, i, j] += w0\n                self.Wijke[:, j, i] += w1\n\n                self.Wijke[i, j, j] += w0\n                self.Wijke[j, i, i] += w1\n\n                self.Wijke[i, j, i] -= w0\n                self.Wijke[j, i, j] -= w1\n\n        if energy_ternary_terms is not None:\n            for i, j, k, v in energy_ternary_terms:\n                self.Wijke[i, j, k] += v\n\n        if entropy_interaction is not None:\n            for i in range(self.n_endmembers):\n                for j in range(i + 1, self.n_endmembers):\n                    w0 = entropy_interaction[i][j - i - 1][0] / 2.0\n                    w1 = entropy_interaction[i][j - i - 1][1] / 2.0\n                    self.Wijks[:, i, j] += w0\n                    self.Wijks[:, j, i] += w1\n\n                    self.Wijks[i, j, j] += w0\n                    self.Wijks[j, i, i] += w1\n\n                    self.Wijks[i, j, i] -= w0\n                    self.Wijks[j, i, j] -= w1\n\n        if entropy_ternary_terms is not None:\n            for i, j, k, v in entropy_ternary_terms:\n                self.Wijks[i, j, k] += v\n\n        if pressure_interaction is not None:\n            for i in range(self.n_endmembers):\n                for j in range(i + 1, self.n_endmembers):\n                    w0 = pressure_interaction[i][j - i - 1][0] / 2.0\n                    w1 = pressure_interaction[i][j - i - 1][1] / 2.0\n                    self.Wijkp[:, i, j] += w0\n                    self.Wijkp[:, j, i] += w1\n\n                    self.Wijkp[i, j, j] += w0\n                    self.Wijkp[j, i, i] += w1\n\n                    self.Wijkp[i, j, i] -= w0\n                    self.Wijkp[j, i, j] -= w1\n\n        if pressure_ternary_terms is not None:\n            for i, j, k, v in pressure_ternary_terms:\n                self.Wijkv[i, j, k] += v\n\n        # initialize ideal solution model\n        ElasticIdealSolution.__init__(self, endmembers)\n\n    def _non_ideal_function(self, Wijk, molar_fractions):\n        n = len(molar_fractions)\n        return _non_ideal_interactions_subreg(molar_fractions, n, Wijk)\n\n    def _non_ideal_interactions(self, molar_fractions):\n        # equation (6') of Helffrich and Wood, 1989\n        Eint = self._non_ideal_function(self.Wijke, molar_fractions)\n        Sint = self._non_ideal_function(self.Wijks, molar_fractions)\n        Pint = self._non_ideal_function(self.Wijkp, molar_fractions)\n        return Eint, Sint, Pint\n\n    def _non_ideal_excess_partial_helmholtz(self, volume, temperature, molar_fractions):\n        Eint, Sint, Pint = self._non_ideal_interactions(molar_fractions)\n        return Eint - temperature * Sint - volume * Pint\n\n    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        ideal_helmholtz = ElasticIdealSolution._ideal_excess_partial_helmholtz(\n            self, temperature, molar_fractions\n        )\n        non_ideal_helmholtz = self._non_ideal_excess_partial_helmholtz(\n            volume, temperature, molar_fractions\n        )\n        return ideal_helmholtz + non_ideal_helmholtz\n\n    def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        ideal_entropies = ElasticIdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_function(self.Wijks, molar_fractions)\n        return ideal_entropies + non_ideal_entropies\n\n    def excess_partial_pressures(self, volume, temperature, molar_fractions):\n        non_ideal_pressures = self._non_ideal_function(self.Wijkp, molar_fractions)\n        return non_ideal_pressures\n\n    def helmholtz_hessian(self, volume, temperature, molar_fractions):\n        n = len(molar_fractions)\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_helmholtz_hessian = _non_ideal_hessian_subreg(\n            molar_fractions,\n            n,\n            self.Wijke - temperature * self.Wijks - volume * self.Wijkp,\n        )\n\n        return nonideal_helmholtz_hessian - temperature * ideal_entropy_hessian\n\n    def entropy_hessian(self, volume, temperature, molar_fractions):\n        n = len(molar_fractions)\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_entropy_hessian = _non_ideal_hessian_subreg(\n            molar_fractions, n, self.Wijks\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian\n\n    def pressure_hessian(self, volume, temperature, molar_fractions):\n        n = len(molar_fractions)\n        return _non_ideal_hessian_subreg(molar_fractions, n, self.Wijkp)",
  "class ElasticFunctionSolution(ElasticIdealSolution):\n    \"\"\"\n    Solution model implementing a generalized elastic solution model.\n    The extensive excess nonconfigurational Helmholtz energy is\n    provided as a function by the user.\n\n    Derivatives are calculated using the autograd module,\n    and so the user-defined excess Helmholtz energy function\n    should be defined using autograd-friendly expressions.\n\n    :param endmembers: A list of all the independent endmembers in the solution.\n        The first item of each list gives the Mineral object corresponding\n        to the endmember. The second item gives the site-species formula.\n    :type endmembers: list of lists\n\n    :param excess_helmholtz_function: The nonconfigurational\n        Helmholtz energy function with arguments volume,\n        temperature and molar_amounts, in that order.\n        Note that the function must be extensive; if the molar amounts\n        are doubled, the Helmholtz energy must also double.\n    :type excess_helmholtz_function: function\n    \"\"\"\n\n    def __init__(self, endmembers, excess_helmholtz_function):\n        \"\"\"\n        Initialization function for the GeneralSolution class.\n        \"\"\"\n\n        # initialize ideal solution model\n        ElasticIdealSolution.__init__(self, endmembers)\n\n        self.n_endmembers = len(endmembers)\n        self._excess_helmholtz_function = excess_helmholtz_function\n\n        self._non_ideal_excess_partial_helmholtz = ag.jacobian(\n            excess_helmholtz_function, argnum=2\n        )\n\n        def partial_entropies(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return -ag.jacobian(self._non_ideal_excess_partial_helmholtz, argnum=1)(\n                    volume, temperature, molar_amounts\n                )\n\n        self._non_ideal_excess_partial_entropies = partial_entropies\n\n        def partial_pressures(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return -ag.jacobian(self._non_ideal_excess_partial_helmholtz, argnum=0)(\n                    volume, temperature, molar_amounts\n                )\n\n        self.excess_partial_pressures = partial_pressures\n\n        self._non_ideal_helmholtz_hessian = ag.jacobian(\n            self._non_ideal_excess_partial_helmholtz, argnum=2\n        )\n\n        def entropy_hess(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_entropies, argnum=2)(\n                    volume, temperature, molar_amounts\n                )\n\n        self._non_ideal_entropy_hessian = entropy_hess\n\n        def pressure_hess(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_pressures, argnum=2)(\n                    volume, temperature, molar_amounts\n                )\n\n        self.pressure_hessian = pressure_hess\n\n    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        ideal_helmholtz = ElasticIdealSolution._ideal_excess_partial_helmholtz(\n            self, temperature, molar_fractions\n        )\n        non_ideal_helmholtz = self._non_ideal_excess_partial_helmholtz(\n            volume, temperature, molar_fractions\n        )\n        return ideal_helmholtz + non_ideal_helmholtz\n\n    def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        ideal_entropies = ElasticIdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_excess_partial_entropies(\n            volume, temperature, molar_fractions\n        )\n        return ideal_entropies + non_ideal_entropies\n\n    def helmholtz_hessian(self, volume, temperature, molar_fractions):\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_helmholtz_hessian = self._non_ideal_helmholtz_hessian(\n            volume, temperature, molar_fractions\n        )\n\n        return nonideal_helmholtz_hessian - temperature * ideal_entropy_hessian\n\n    def entropy_hessian(self, volume, temperature, molar_fractions):\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_entropy_hessian = self._non_ideal_entropy_hessian(\n            volume, temperature, molar_fractions\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian",
  "def __init__(self):\n        \"\"\"\n        Does nothing.\n        \"\"\"\n        pass",
  "def excess_helmholtz_energy(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess Helmholtz free energy of the solution.\n        The base class implementation assumes that the excess Helmholtz\n        energy is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess Helmholtz energy.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            np.array(molar_fractions),\n            self.excess_partial_helmholtz_energies(\n                volume, temperature, molar_fractions\n            ),\n        )",
  "def excess_pressure(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess pressure of the solution.\n        The base class implementation assumes that the excess pressure is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess pressure of the solution.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            molar_fractions,\n            self.excess_partial_pressures(volume, temperature, molar_fractions),\n        )",
  "def excess_entropy(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess entropy of the solution.\n        The base class implementation assumes that the excess entropy is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess entropy of the solution.\n        :rtype: float\n        \"\"\"\n        return np.dot(\n            molar_fractions,\n            self.excess_partial_entropies(volume, temperature, molar_fractions),\n        )",
  "def excess_enthalpy(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess enthalpy of the solution.\n        The base class implementation assumes that the excess enthalpy is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess enthalpy of the solution.\n        :rtype: float\n        \"\"\"\n        return (\n            self.excess_helmholtz_energy(volume, temperature, molar_fractions)\n            + temperature * self.excess_entropy(volume, temperature, molar_fractions)\n            - volume * self.excess_pressure(volume, temperature, molar_fractions)\n        )",
  "def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess Helmholtz energy for each endmember of the solution.\n        The base class implementation assumes that the excess Helmholtz energy\n        is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess Helmholtz energy of each endmember\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(molar_fractions)",
  "def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess entropy for each endmember of the solution.\n        The base class implementation assumes that the excess entropy\n        is zero (true for mechanical solutions).\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess entropy of each endmember.\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(molar_fractions)",
  "def excess_partial_pressures(self, volume, temperature, molar_fractions):\n        \"\"\"\n        Given a list of molar fractions of different phases,\n        compute the excess pressure for each endmember of the solution.\n        The base class implementation assumes that the excess pressure\n        is zero.\n\n        :param volume: Volume at which to evaluate the solution model. [m^3/mol]\n        :type volume: float\n\n        :param temperature: Temperature at which to evaluate the solution. [K]\n        :type temperature: float\n\n        :param molar_fractions: List of molar fractions of the different\n            endmembers in solution.\n        :type molar_fractions: list of floats\n\n        :returns: The excess pressure of each endmember.\n        :rtype: numpy.array\n        \"\"\"\n        return np.zeros_like(np.array(molar_fractions))",
  "def __init__(self, endmembers):\n        self.endmembers = endmembers\n        self.n_endmembers = len(endmembers)\n        self.formulas = [e[1] for e in endmembers]",
  "def excess_helmholtz_energy(self, volume, temperature, molar_fractions):\n        return 0.0",
  "def excess_pressure(self, volume, temperature, molar_fractions):\n        return 0.0",
  "def excess_entropy(self, volume, temperature, molar_fractions):\n        return 0.0",
  "def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        return np.zeros_like(molar_fractions)",
  "def excess_partial_pressures(self, volume, temperature, molar_fractions):\n        return np.zeros_like(molar_fractions)",
  "def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        return np.zeros_like(molar_fractions)",
  "def __init__(self, endmembers):\n        self.endmembers = endmembers\n        self.n_endmembers = len(endmembers)\n        self.formulas = [e[1] for e in endmembers]\n\n        # Process solution chemistry\n        process_solution_chemistry(self)\n\n        self._calculate_endmember_configurational_entropies()",
  "def _calculate_endmember_configurational_entropies(self):\n        S_conf = -(\n            constants.gas_constant\n            * (self.endmember_noccupancies * logish(self.endmember_occupancies)).sum(-1)\n        )\n        self.endmember_configurational_entropies = S_conf",
  "def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        return self._ideal_excess_partial_helmholtz(temperature, molar_fractions)",
  "def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        return self._ideal_excess_partial_entropies(temperature, molar_fractions)",
  "def excess_partial_pressures(self, volume, temperature, molar_fractions):\n        return np.zeros((self.n_endmembers))",
  "def helmholtz_hessian(self, volume, temperature, molar_fractions):\n        hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)\n        return -temperature * hess_S",
  "def entropy_hessian(self, volume, temperature, molar_fractions):\n        hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)\n        return hess_S",
  "def pressure_hessian(self, volume, temperature, molar_fractions):\n        return np.zeros((len(molar_fractions), len(molar_fractions)))",
  "def _configurational_entropy(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n        site_occupancies = site_noccupancies * inverseish(site_multiplicities)\n        conf_entropy = -(\n            constants.gas_constant\n            * (site_noccupancies * logish(site_occupancies)).sum(-1)\n        )\n        return conf_entropy",
  "def _ideal_excess_partial_helmholtz(self, temperature, molar_fractions):\n        return -(\n            temperature\n            * self._ideal_excess_partial_entropies(temperature, molar_fractions)\n        )",
  "def _ideal_excess_partial_entropies(self, temperature, molar_fractions):\n        return -(constants.gas_constant * self._log_ideal_activities(molar_fractions))",
  "def _ideal_entropy_hessian(self, temperature, molar_fractions):\n        hessian = -constants.gas_constant * self._log_ideal_activity_derivatives(\n            molar_fractions\n        )\n        return hessian",
  "def _log_ideal_activities(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n\n        lna = np.einsum(\n            \"ij, j->i\",\n            self.endmember_noccupancies,\n            logish(site_noccupancies) - logish(site_multiplicities),\n        )\n\n        normalisation_constants = (\n            self.endmember_configurational_entropies / constants.gas_constant\n        )\n        return lna + normalisation_constants",
  "def _log_ideal_activity_derivatives(self, molar_fractions):\n        site_noccupancies = np.einsum(\n            \"i, ij\", molar_fractions, self.endmember_noccupancies\n        )\n        site_multiplicities = np.einsum(\n            \"i, ij\", molar_fractions, self.site_multiplicities\n        )\n\n        dlnadp = np.einsum(\n            \"pj, qj, j->pq\",\n            self.endmember_noccupancies,\n            self.endmember_noccupancies,\n            inverseish(site_noccupancies),\n        ) - np.einsum(\n            \"pj, qj, j->pq\",\n            self.endmember_noccupancies,\n            self.site_multiplicities,\n            inverseish(site_multiplicities),\n        )\n\n        return dlnadp",
  "def _ideal_activities(self, molar_fractions):\n        return _ideal_activities_fct(\n            molar_fractions,\n            self.endmember_noccupancies,\n            self.n_endmembers,\n            self.n_occupancies,\n            self.site_multiplicities,\n            self.endmember_configurational_entropies,\n        )",
  "def __init__(\n        self,\n        endmembers,\n        alphas,\n        energy_interaction,\n        pressure_interaction=None,\n        entropy_interaction=None,\n    ):\n        self.n_endmembers = len(endmembers)\n\n        # Create array of van Laar parameters\n        self.alphas = np.array(alphas)\n\n        # Create 2D arrays of interaction parameters\n        self.We = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n        self.We[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n            [i for row in energy_interaction for i in row]\n        )\n\n        if entropy_interaction is not None:\n            self.Ws = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n            self.Ws[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n                [i for row in entropy_interaction for i in row]\n            )\n        else:\n            self.Ws = np.zeros((self.n_endmembers, self.n_endmembers))\n\n        if pressure_interaction is not None:\n            self.Wp = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)\n            self.Wp[np.triu_indices(self.n_endmembers, 1)] *= np.array(\n                [i for row in pressure_interaction for i in row]\n            )\n        else:\n            self.Wp = np.zeros((self.n_endmembers, self.n_endmembers))\n\n        # initialize ideal solution model\n        ElasticIdealSolution.__init__(self, endmembers)",
  "def _phi(self, molar_fractions):\n        phi = self.alphas * molar_fractions\n        phi = np.divide(phi, np.sum(phi))\n        return phi",
  "def _non_ideal_interactions(self, W, molar_fractions):\n        # -sum(sum(qi.qj.Wij*)\n        # equation (2) of Holland and Powell 2003\n        phi = self._phi(molar_fractions)\n        return _non_ideal_interactions_fct(\n            phi, np.array(molar_fractions), self.n_endmembers, self.alphas, W\n        )",
  "def _non_ideal_excess_partial_helmholtz(self, volume, temperature, molar_fractions):\n        Eint = self._non_ideal_interactions(self.We, molar_fractions)\n        Sint = self._non_ideal_interactions(self.Ws, molar_fractions)\n        Pint = self._non_ideal_interactions(self.Wp, molar_fractions)\n        return Eint - temperature * Sint - volume * Pint",
  "def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        ideal_helmholtz = ElasticIdealSolution._ideal_excess_partial_helmholtz(\n            self, temperature, molar_fractions\n        )\n        non_ideal_helmholtz = self._non_ideal_excess_partial_helmholtz(\n            volume, temperature, molar_fractions\n        )\n        return ideal_helmholtz + non_ideal_helmholtz",
  "def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        ideal_entropies = ElasticIdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_interactions(self.Ws, molar_fractions)\n        return ideal_entropies + non_ideal_entropies",
  "def excess_partial_pressures(self, volume, temperature, molar_fractions):\n        return self._non_ideal_interactions(self.Wp, molar_fractions)",
  "def helmholtz_hessian(self, volume, temperature, molar_fractions):\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        phi = self._phi(molar_fractions)\n        nonideal_helmholtz_hessian = _non_ideal_hessian_fct(\n            phi,\n            molar_fractions,\n            self.n_endmembers,\n            self.alphas,\n            self.We - temperature * self.Ws - volume * self.Wp,\n        )\n\n        return nonideal_helmholtz_hessian - temperature * ideal_entropy_hessian",
  "def entropy_hessian(self, volume, temperature, molar_fractions):\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        phi = self._phi(molar_fractions)\n        nonideal_entropy_hessian = _non_ideal_hessian_fct(\n            phi, molar_fractions, self.n_endmembers, self.alphas, self.Ws\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian",
  "def pressure_hessian(self, volume, temperature, molar_fractions):\n        phi = self._phi(molar_fractions)\n        return _non_ideal_hessian_fct(\n            phi, molar_fractions, self.n_endmembers, self.alphas, self.Wp\n        )",
  "def __init__(\n        self,\n        endmembers,\n        energy_interaction,\n        pressure_interaction=None,\n        entropy_interaction=None,\n    ):\n        alphas = np.ones(len(endmembers))\n        ElasticAsymmetricRegularSolution.__init__(\n            self,\n            endmembers,\n            alphas,\n            energy_interaction,\n            pressure_interaction,\n            entropy_interaction,\n        )",
  "def __init__(\n        self,\n        endmembers,\n        energy_interaction,\n        pressure_interaction=None,\n        entropy_interaction=None,\n        energy_ternary_terms=None,\n        pressure_ternary_terms=None,\n        entropy_ternary_terms=None,\n    ):\n        \"\"\"\n        Initialization function for the SubregularSolution class.\n        \"\"\"\n\n        self.n_endmembers = len(endmembers)\n\n        # Create 3D arrays of interaction parameters\n        self.Wijke = np.zeros(\n            shape=(self.n_endmembers, self.n_endmembers, self.n_endmembers)\n        )\n        self.Wijks = np.zeros_like(self.Wijke)\n        self.Wijkp = np.zeros_like(self.Wijke)\n\n        # setup excess enthalpy interaction matrix\n        for i in range(self.n_endmembers):\n            for j in range(i + 1, self.n_endmembers):\n                w0 = energy_interaction[i][j - i - 1][0] / 2.0\n                w1 = energy_interaction[i][j - i - 1][1] / 2.0\n                self.Wijke[:, i, j] += w0\n                self.Wijke[:, j, i] += w1\n\n                self.Wijke[i, j, j] += w0\n                self.Wijke[j, i, i] += w1\n\n                self.Wijke[i, j, i] -= w0\n                self.Wijke[j, i, j] -= w1\n\n        if energy_ternary_terms is not None:\n            for i, j, k, v in energy_ternary_terms:\n                self.Wijke[i, j, k] += v\n\n        if entropy_interaction is not None:\n            for i in range(self.n_endmembers):\n                for j in range(i + 1, self.n_endmembers):\n                    w0 = entropy_interaction[i][j - i - 1][0] / 2.0\n                    w1 = entropy_interaction[i][j - i - 1][1] / 2.0\n                    self.Wijks[:, i, j] += w0\n                    self.Wijks[:, j, i] += w1\n\n                    self.Wijks[i, j, j] += w0\n                    self.Wijks[j, i, i] += w1\n\n                    self.Wijks[i, j, i] -= w0\n                    self.Wijks[j, i, j] -= w1\n\n        if entropy_ternary_terms is not None:\n            for i, j, k, v in entropy_ternary_terms:\n                self.Wijks[i, j, k] += v\n\n        if pressure_interaction is not None:\n            for i in range(self.n_endmembers):\n                for j in range(i + 1, self.n_endmembers):\n                    w0 = pressure_interaction[i][j - i - 1][0] / 2.0\n                    w1 = pressure_interaction[i][j - i - 1][1] / 2.0\n                    self.Wijkp[:, i, j] += w0\n                    self.Wijkp[:, j, i] += w1\n\n                    self.Wijkp[i, j, j] += w0\n                    self.Wijkp[j, i, i] += w1\n\n                    self.Wijkp[i, j, i] -= w0\n                    self.Wijkp[j, i, j] -= w1\n\n        if pressure_ternary_terms is not None:\n            for i, j, k, v in pressure_ternary_terms:\n                self.Wijkv[i, j, k] += v\n\n        # initialize ideal solution model\n        ElasticIdealSolution.__init__(self, endmembers)",
  "def _non_ideal_function(self, Wijk, molar_fractions):\n        n = len(molar_fractions)\n        return _non_ideal_interactions_subreg(molar_fractions, n, Wijk)",
  "def _non_ideal_interactions(self, molar_fractions):\n        # equation (6') of Helffrich and Wood, 1989\n        Eint = self._non_ideal_function(self.Wijke, molar_fractions)\n        Sint = self._non_ideal_function(self.Wijks, molar_fractions)\n        Pint = self._non_ideal_function(self.Wijkp, molar_fractions)\n        return Eint, Sint, Pint",
  "def _non_ideal_excess_partial_helmholtz(self, volume, temperature, molar_fractions):\n        Eint, Sint, Pint = self._non_ideal_interactions(molar_fractions)\n        return Eint - temperature * Sint - volume * Pint",
  "def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        ideal_helmholtz = ElasticIdealSolution._ideal_excess_partial_helmholtz(\n            self, temperature, molar_fractions\n        )\n        non_ideal_helmholtz = self._non_ideal_excess_partial_helmholtz(\n            volume, temperature, molar_fractions\n        )\n        return ideal_helmholtz + non_ideal_helmholtz",
  "def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        ideal_entropies = ElasticIdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_function(self.Wijks, molar_fractions)\n        return ideal_entropies + non_ideal_entropies",
  "def excess_partial_pressures(self, volume, temperature, molar_fractions):\n        non_ideal_pressures = self._non_ideal_function(self.Wijkp, molar_fractions)\n        return non_ideal_pressures",
  "def helmholtz_hessian(self, volume, temperature, molar_fractions):\n        n = len(molar_fractions)\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_helmholtz_hessian = _non_ideal_hessian_subreg(\n            molar_fractions,\n            n,\n            self.Wijke - temperature * self.Wijks - volume * self.Wijkp,\n        )\n\n        return nonideal_helmholtz_hessian - temperature * ideal_entropy_hessian",
  "def entropy_hessian(self, volume, temperature, molar_fractions):\n        n = len(molar_fractions)\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_entropy_hessian = _non_ideal_hessian_subreg(\n            molar_fractions, n, self.Wijks\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian",
  "def pressure_hessian(self, volume, temperature, molar_fractions):\n        n = len(molar_fractions)\n        return _non_ideal_hessian_subreg(molar_fractions, n, self.Wijkp)",
  "def __init__(self, endmembers, excess_helmholtz_function):\n        \"\"\"\n        Initialization function for the GeneralSolution class.\n        \"\"\"\n\n        # initialize ideal solution model\n        ElasticIdealSolution.__init__(self, endmembers)\n\n        self.n_endmembers = len(endmembers)\n        self._excess_helmholtz_function = excess_helmholtz_function\n\n        self._non_ideal_excess_partial_helmholtz = ag.jacobian(\n            excess_helmholtz_function, argnum=2\n        )\n\n        def partial_entropies(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return -ag.jacobian(self._non_ideal_excess_partial_helmholtz, argnum=1)(\n                    volume, temperature, molar_amounts\n                )\n\n        self._non_ideal_excess_partial_entropies = partial_entropies\n\n        def partial_pressures(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return -ag.jacobian(self._non_ideal_excess_partial_helmholtz, argnum=0)(\n                    volume, temperature, molar_amounts\n                )\n\n        self.excess_partial_pressures = partial_pressures\n\n        self._non_ideal_helmholtz_hessian = ag.jacobian(\n            self._non_ideal_excess_partial_helmholtz, argnum=2\n        )\n\n        def entropy_hess(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_entropies, argnum=2)(\n                    volume, temperature, molar_amounts\n                )\n\n        self._non_ideal_entropy_hessian = entropy_hess\n\n        def pressure_hess(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_pressures, argnum=2)(\n                    volume, temperature, molar_amounts\n                )\n\n        self.pressure_hessian = pressure_hess",
  "def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):\n        ideal_helmholtz = ElasticIdealSolution._ideal_excess_partial_helmholtz(\n            self, temperature, molar_fractions\n        )\n        non_ideal_helmholtz = self._non_ideal_excess_partial_helmholtz(\n            volume, temperature, molar_fractions\n        )\n        return ideal_helmholtz + non_ideal_helmholtz",
  "def excess_partial_entropies(self, volume, temperature, molar_fractions):\n        ideal_entropies = ElasticIdealSolution._ideal_excess_partial_entropies(\n            self, temperature, molar_fractions\n        )\n        non_ideal_entropies = self._non_ideal_excess_partial_entropies(\n            volume, temperature, molar_fractions\n        )\n        return ideal_entropies + non_ideal_entropies",
  "def helmholtz_hessian(self, volume, temperature, molar_fractions):\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_helmholtz_hessian = self._non_ideal_helmholtz_hessian(\n            volume, temperature, molar_fractions\n        )\n\n        return nonideal_helmholtz_hessian - temperature * ideal_entropy_hessian",
  "def entropy_hessian(self, volume, temperature, molar_fractions):\n        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(\n            self, temperature, molar_fractions\n        )\n        nonideal_entropy_hessian = self._non_ideal_entropy_hessian(\n            volume, temperature, molar_fractions\n        )\n        return ideal_entropy_hessian + nonideal_entropy_hessian",
  "def partial_entropies(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return -ag.jacobian(self._non_ideal_excess_partial_helmholtz, argnum=1)(\n                    volume, temperature, molar_amounts\n                )",
  "def partial_pressures(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return -ag.jacobian(self._non_ideal_excess_partial_helmholtz, argnum=0)(\n                    volume, temperature, molar_amounts\n                )",
  "def entropy_hess(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_entropies, argnum=2)(\n                    volume, temperature, molar_amounts\n                )",
  "def pressure_hess(volume, temperature, molar_amounts):\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"always\")\n                return ag.jacobian(partial_pressures, argnum=2)(\n                    volume, temperature, molar_amounts\n                )",
  "class Calibrant(object):\n    \"\"\"\n    The base class for a pressure calibrant material.\n\n    :param calibrant_function: A function that takes either pressure,\n        temperature and a params object as arguments, returning the volume,\n        or takes volume, temperature and a params object, returning the pressure.\n    :type calibrant_function: function\n\n    :param calibrant_function_return_type: The return type of the calibrant function.\n        Valid values are 'pressure' or 'volume'.\n    :type calibrant_function_return_type: str\n\n    :param params: A dictionary containing the parameters required by the\n        calibrant function.\n    :type params: dictionary\n    \"\"\"\n\n    def __init__(self, calibrant_function, calibrant_function_return_type, params):\n        if calibrant_function_return_type == \"pressure\":\n            self.pressure_function = calibrant_function\n            self.volume_function = self._volume_using_pressure_function\n        elif calibrant_function_return_type == \"volume\":\n            self.volume_function = calibrant_function\n            self.pressure_function = self._pressure_using_volume_function\n        else:\n            raise Exception(\n                \"calibrant function return type must either \" \"be pressure or volume\"\n            )\n\n        self.calibrant_function = calibrant_function\n\n        self.params = params\n\n    def _volume_using_pressure_function(self, pressure, temperature, params):\n        \"\"\"\n        Helper function to compute volume iteratively by Brent's method using\n        a function of the form pressure(volume, temperature).\n        \"\"\"\n\n        def func(x):\n            return self.pressure_function(x, temperature, params) - pressure\n\n        try:\n            sol = bracket(func, params[\"V_0\"], 1.0e-2 * params[\"V_0\"])\n        except ValueError:\n            raise ValueError(\n                \"Cannot find a volume, perhaps you are outside \"\n                \"of the range of validity for the equation \"\n                \"of state?\"\n            )\n        return opt.brentq(func, sol[0], sol[1])\n\n    def _pressure_using_volume_function(self, volume, temperature, params):\n        \"\"\"\n        Helper function to compute pressure iteratively by Brent's method using\n        a function of the form volume(pressure, temperature).\n        \"\"\"\n\n        def func(x):\n            (self.volume_function(x, temperature, params) - volume)\n\n        try:\n            sol = bracket(func, 0.0, 300.0e9)\n        except ValueError:\n            raise ValueError(\n                \"Cannot find a pressure, perhaps you are outside \"\n                \"of the range of validity for the equation \"\n                \"of state?\"\n            )\n        return opt.brentq(func, sol[0], sol[1])\n\n    def pressure(self, volume, temperature, VT_covariance=None):\n        \"\"\"\n        Returns the pressure of the calibrant as a function of\n        volume, temperature and (optionally) a volume-temperature\n        variance-covariance matrix.\n\n        :param volume: The volume of the calibrant [m^3/mol].\n        :type volume: float\n\n        :param temperature: The temperature of the calibrant [K].\n        :type temperature: float\n\n        :param VT_covariance: The volume-temperature\n            variance-covariance matrix [optional].\n        :type VT_covariance: 2x2 numpy.array\n\n        :returns: The pressure of the calibrant [Pa] and the\n            pressure-volume-temperature variance-covariance matrix\n            if PT_covariance is provided.\n        :rtype: float, tuple of a float and a numpy.array (3x3)\n        \"\"\"\n        if VT_covariance is None:\n            return self.pressure_function(volume, temperature, self.params)\n        else:\n            # Here we take the centered differences\n            # We could alternatively use thermodynamic properties\n            # but these have not yet been implemented.\n            dV = volume / 1.0e7\n            dT = 0.01\n            PdV0 = self.pressure_function(volume - dV / 2.0, temperature, self.params)\n            PdV1 = self.pressure_function(volume + dV / 2.0, temperature, self.params)\n            PdT0 = self.pressure_function(volume, temperature - dT / 2.0, self.params)\n            PdT1 = self.pressure_function(volume, temperature + dT / 2.0, self.params)\n            pressure = (PdV0 + PdV1 + PdT0 + PdT1) / 4.0\n\n            gradPVT = np.zeros((2, 3))\n            gradPVT[:, 1:] = np.eye(2)\n            gradPVT[:, 0] = [(PdV1 - PdV0) / dV, (PdT1 - PdT0) / dT]\n            PVT_covariance = gradPVT.T.dot(VT_covariance).dot(gradPVT)\n            return pressure, PVT_covariance\n\n    def volume(self, pressure, temperature, PT_covariance=None):\n        \"\"\"\n        Returns the volume of the calibrant as a function of\n        pressure, temperature and (optionally) a pressure-temperature\n        variance-covariance matrix.\n\n        :param pressure: The pressure of the calibrant [Pa].\n        :type pressure: float\n\n        :param temperature: The temperature of the calibrant [K].\n        :type temperature: float\n\n        :param PT_covariance: The pressure-temperature\n            variance-covariance matrix [optional].\n        :type PT_covariance: 2x2 numpy.array\n\n        :returns: The volume of the calibrant [m^3/mol] and\n            the volume-pressure-temperature variance-covariance matrix\n            if VT_covariance is provided.\n        :rtype: float, tuple of a float and a numpy.array (3x3)\n        \"\"\"\n        if PT_covariance is None:\n            return self.volume_function(pressure, temperature, self.params)\n        else:\n            # Here we take the centered differences\n            # We could alternatively use thermodynamic properties\n            # but these have not yet been implemented.\n            dP = 100.0\n            dT = 0.01\n            VdP0 = self.volume_function(pressure - dP / 2.0, temperature, self.params)\n            VdP1 = self.volume_function(pressure + dP / 2.0, temperature, self.params)\n            VdT0 = self.volume_function(pressure, temperature - dT / 2.0, self.params)\n            VdT1 = self.volume_function(pressure, temperature + dT / 2.0, self.params)\n            volume = (VdP0 + VdP1 + VdT0 + VdT1) / 4.0\n\n            gradVPT = np.zeros((2, 3))\n            gradVPT[:, 1:] = np.eye(2)\n            gradVPT[:, 0] = [(VdP1 - VdP0) / dP, (VdT1 - VdT0) / dT]\n            VPT_covariance = gradVPT.T.dot(PT_covariance).dot(gradVPT)\n            return volume, VPT_covariance",
  "def __init__(self, calibrant_function, calibrant_function_return_type, params):\n        if calibrant_function_return_type == \"pressure\":\n            self.pressure_function = calibrant_function\n            self.volume_function = self._volume_using_pressure_function\n        elif calibrant_function_return_type == \"volume\":\n            self.volume_function = calibrant_function\n            self.pressure_function = self._pressure_using_volume_function\n        else:\n            raise Exception(\n                \"calibrant function return type must either \" \"be pressure or volume\"\n            )\n\n        self.calibrant_function = calibrant_function\n\n        self.params = params",
  "def _volume_using_pressure_function(self, pressure, temperature, params):\n        \"\"\"\n        Helper function to compute volume iteratively by Brent's method using\n        a function of the form pressure(volume, temperature).\n        \"\"\"\n\n        def func(x):\n            return self.pressure_function(x, temperature, params) - pressure\n\n        try:\n            sol = bracket(func, params[\"V_0\"], 1.0e-2 * params[\"V_0\"])\n        except ValueError:\n            raise ValueError(\n                \"Cannot find a volume, perhaps you are outside \"\n                \"of the range of validity for the equation \"\n                \"of state?\"\n            )\n        return opt.brentq(func, sol[0], sol[1])",
  "def _pressure_using_volume_function(self, volume, temperature, params):\n        \"\"\"\n        Helper function to compute pressure iteratively by Brent's method using\n        a function of the form volume(pressure, temperature).\n        \"\"\"\n\n        def func(x):\n            (self.volume_function(x, temperature, params) - volume)\n\n        try:\n            sol = bracket(func, 0.0, 300.0e9)\n        except ValueError:\n            raise ValueError(\n                \"Cannot find a pressure, perhaps you are outside \"\n                \"of the range of validity for the equation \"\n                \"of state?\"\n            )\n        return opt.brentq(func, sol[0], sol[1])",
  "def pressure(self, volume, temperature, VT_covariance=None):\n        \"\"\"\n        Returns the pressure of the calibrant as a function of\n        volume, temperature and (optionally) a volume-temperature\n        variance-covariance matrix.\n\n        :param volume: The volume of the calibrant [m^3/mol].\n        :type volume: float\n\n        :param temperature: The temperature of the calibrant [K].\n        :type temperature: float\n\n        :param VT_covariance: The volume-temperature\n            variance-covariance matrix [optional].\n        :type VT_covariance: 2x2 numpy.array\n\n        :returns: The pressure of the calibrant [Pa] and the\n            pressure-volume-temperature variance-covariance matrix\n            if PT_covariance is provided.\n        :rtype: float, tuple of a float and a numpy.array (3x3)\n        \"\"\"\n        if VT_covariance is None:\n            return self.pressure_function(volume, temperature, self.params)\n        else:\n            # Here we take the centered differences\n            # We could alternatively use thermodynamic properties\n            # but these have not yet been implemented.\n            dV = volume / 1.0e7\n            dT = 0.01\n            PdV0 = self.pressure_function(volume - dV / 2.0, temperature, self.params)\n            PdV1 = self.pressure_function(volume + dV / 2.0, temperature, self.params)\n            PdT0 = self.pressure_function(volume, temperature - dT / 2.0, self.params)\n            PdT1 = self.pressure_function(volume, temperature + dT / 2.0, self.params)\n            pressure = (PdV0 + PdV1 + PdT0 + PdT1) / 4.0\n\n            gradPVT = np.zeros((2, 3))\n            gradPVT[:, 1:] = np.eye(2)\n            gradPVT[:, 0] = [(PdV1 - PdV0) / dV, (PdT1 - PdT0) / dT]\n            PVT_covariance = gradPVT.T.dot(VT_covariance).dot(gradPVT)\n            return pressure, PVT_covariance",
  "def volume(self, pressure, temperature, PT_covariance=None):\n        \"\"\"\n        Returns the volume of the calibrant as a function of\n        pressure, temperature and (optionally) a pressure-temperature\n        variance-covariance matrix.\n\n        :param pressure: The pressure of the calibrant [Pa].\n        :type pressure: float\n\n        :param temperature: The temperature of the calibrant [K].\n        :type temperature: float\n\n        :param PT_covariance: The pressure-temperature\n            variance-covariance matrix [optional].\n        :type PT_covariance: 2x2 numpy.array\n\n        :returns: The volume of the calibrant [m^3/mol] and\n            the volume-pressure-temperature variance-covariance matrix\n            if VT_covariance is provided.\n        :rtype: float, tuple of a float and a numpy.array (3x3)\n        \"\"\"\n        if PT_covariance is None:\n            return self.volume_function(pressure, temperature, self.params)\n        else:\n            # Here we take the centered differences\n            # We could alternatively use thermodynamic properties\n            # but these have not yet been implemented.\n            dP = 100.0\n            dT = 0.01\n            VdP0 = self.volume_function(pressure - dP / 2.0, temperature, self.params)\n            VdP1 = self.volume_function(pressure + dP / 2.0, temperature, self.params)\n            VdT0 = self.volume_function(pressure, temperature - dT / 2.0, self.params)\n            VdT1 = self.volume_function(pressure, temperature + dT / 2.0, self.params)\n            volume = (VdP0 + VdP1 + VdT0 + VdT1) / 4.0\n\n            gradVPT = np.zeros((2, 3))\n            gradVPT[:, 1:] = np.eye(2)\n            gradVPT[:, 0] = [(VdP1 - VdP0) / dP, (VdT1 - VdT0) / dT]\n            VPT_covariance = gradVPT.T.dot(PT_covariance).dot(gradVPT)\n            return volume, VPT_covariance",
  "def func(x):\n            return self.pressure_function(x, temperature, params) - pressure",
  "def func(x):\n            (self.volume_function(x, temperature, params) - volume)",
  "class AveragingScheme(object):\n\n    \"\"\"\n    Base class defining an interface for determining average\n    elastic properties of a rock.  Given a list of volume\n    fractions for the different mineral phases in a rock,\n    as well as their bulk and shear moduli, an averaging\n    will give back a single scalar values for the averages.\n    New averaging schemes should define the functions\n    average_bulk_moduli and average_shear_moduli, as\n    specified here.\n    \"\"\"\n\n    def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli :math:`K` for a composite. This defines the interface\n        for this method, and is not implemented in the base class.\n\n        :param volumes: List of the volume of each phase in the composite\n            :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli : List of bulk moduli of each phase in the composite\n            :math:`[Pa]`.\n        :type bulk_moduli: list of floats\n        :param shear_moduli : List of shear moduli of each phase in the composite\n            :math:`[Pa]`.\n        :type shear_moduli: list of floats\n\n        :returns: The average bulk modulus :math:`K`. :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli :math:`G` for a composite.  This defines the interface\n        for this method, and is not implemented in the base class.\n\n        :param volumes: List of the volume of each phase in the composite\n            :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli of each phase in the composite\n            :math:`[Pa]`.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli of each phase in the composite\n            :math:`[Pa]`.\n        :type shear_moduli: list of floats\n\n        :returns: The average shear modulus :math:`G`. :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def average_density(self, volumes, densities):\n        \"\"\"\n        Average the densities of a composite, given a list of volume\n        fractions and densitites. This is implemented in the base class,\n        as how to calculate it is not dependent on the geometry of the rock.\n        The formula for density is given by\n\n        .. math::\n            \\\\rho = \\\\frac{\\\\Sigma_i \\\\rho_i V_i }{\\\\Sigma_i V_i}\n\n        :param volumes: List of the volume of each phase in the composite\n            :math:`[m^3]`.\n        :type volumes: list of floats\n        :param densities: List of densities of each phase in the composite\n            :math:`[kg/m^3]`.\n        :type densities: list of floats\n\n        :returns: Density :math:`\\\\rho` :math:`[kg/m^3]`.\n        :rtype: float\n        \"\"\"\n        total_mass = np.sum(np.array(densities) * np.array(volumes))\n        total_vol = np.sum(np.array(volumes))  # should sum to one\n        density = total_mass / total_vol\n        return density\n\n    def average_thermal_expansivity(self, volumes, alphas):\n        \"\"\"\n        Averages the thermal expansion coefficient of the mineral :math:`\\\\alpha`\n        :math:`[1/K]`.\n\n        :param volumes: List of volume fractions of each phase\n            in the composite (should sum to 1.0).\n        :type volumes: list of floats\n        :param alphas: List of thermal expansivities :math:`\\\\alpha`\n            of each phase in the composite. :math:`[1/K]`\n        :type alphas: list of floats\n\n        :returns: Thermal expansivity of the composite :math:`\\\\alpha`. :math:`[1/K]`\n        :rtype: float\n        \"\"\"\n        total_vol = np.sum(np.array(volumes))\n        return np.sum(np.array(alphas) * np.array(volumes)) / total_vol\n\n    def average_heat_capacity_v(self, fractions, c_v):\n        # TODO: double-check that the formula we use is appropriate here.\n        \"\"\"\n        Averages the heat capacities at constant volume :math:`C_V` by molar fractions\n        as in eqn. (16) in :cite:`Ita1992`.\n\n        :param fractions: List of molar fractions of each phase\n            in the composite (should sum to 1.0).\n        :type fractions: list of floats\n        :param c_v: List of heat capacities at constant volume :math:`C_V`\n            of each phase in the composite. :math:`[J/K/mol]`\n        :type c_v: list of floats\n\n        :returns: Heat capacity at constant volume of the composite :math:`C_V`\n            :math:`[J/K/mol]`.\n        :rtype: float\n        \"\"\"\n        return np.sum(np.array(fractions) * np.array(c_v))\n\n    def average_heat_capacity_p(self, fractions, c_p):\n        # TODO: double-check that the formula we use is correct.\n        \"\"\"\n        Averages the heat capacities at constant pressure :math:`C_P`\n        by molar fractions.\n\n        :param fractions: List of molar fractions of each phase in the composite\n            (should sum to 1.0).\n        :type fractions: list of floats\n        :param c_p: List of heat capacities at constant pressure :math:`C_P` of each\n            phase in the composite :math:`[J/K/mol]`.\n        :type c_p: list of floats\n\n        :returns: Heat capacity at constant pressure :math:`C_P` of the composite\n            :math:`[J/K/mol]`.\n        :rtype: float\n        \"\"\"\n        return np.sum(np.array(fractions) * np.array(c_p))",
  "class VoigtReussHill(AveragingScheme):\n\n    \"\"\"\n    Class for computing the Voigt-Reuss-Hill average for elastic properties.\n    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,\n    and implements the\n    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`\n    and\n    :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli`\n    functions.\n    \"\"\"\n\n    def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the Voigt-Reuss-Hill average,\n        given by:\n\n        .. math::\n            K_{VRH} = \\\\frac{K_V + K_R}{2}\n\n        This is simply a shorthand for an arithmetic average of the bounds given\n        by :class:`burnman.averaging_schemes.voigt`\n        and :class:`burnman.averaging_schemes.reuss`.\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type shear_moduli: list of floats\n\n        :returns: The Voigt-Reuss-Hill average bulk modulus :math:`K_{VRH}`\n            :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return voigt_reuss_hill_function(volumes, bulk_moduli)\n\n    def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli :math:`G` of a composite with the\n        Voigt-Reuss-Hill average, given by:\n\n        .. math::\n            G_{VRH} = \\\\frac{G_V + G_R}{2}\n\n        This is simply a shorthand for an arithmetic average of the bounds given\n        by :class:`burnman.averaging_schemes.voigt`\n        and :class:`burnman.averaging_schemes.reuss`.\n\n        .. math::\n            G_V = \\\\Sigma_i V_i G_i\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n        :type shear_moduli: list of floats\n\n        :returns: The Voigt-Reuss-Hill average shear modulus :math:`G_{VRH}`\n            :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return voigt_reuss_hill_function(volumes, shear_moduli)",
  "class Voigt(AveragingScheme):\n\n    \"\"\"\n    Class for computing the Voigt (iso-strain) bound for elastic properties.\n    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,\n    and implements the\n    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli` and\n    :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli` functions.\n    \"\"\"\n\n    def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite :math:`K` with the Voigt (iso-strain)\n        bound, given by:\n\n        .. math::\n            K_V = \\\\Sigma_i V_i K_i\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type shear_moduli: list of floats\n\n        :returns: The Voigt average bulk modulus :math:`K_R` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return voigt_average_function(volumes, bulk_moduli)\n\n    def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli of a composite with the Voigt (iso-strain)\n        bound, given by:\n\n        .. math::\n            G_V = \\\\Sigma_i V_i G_i\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n        :type shear_moduli: list of floats\n\n        :returns: The Voigt average shear modulus :math:`G_V` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return voigt_average_function(volumes, shear_moduli)",
  "class Reuss(AveragingScheme):\n\n    \"\"\"\n    Class for computing the Reuss (iso-stress) bound for elastic properties.\n    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,\n    and implements the\n    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli` and\n    :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli` functions.\n    \"\"\"\n\n    def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the Reuss (iso-stress)\n        bound, given by:\n\n        .. math::\n            K_R = \\\\left(\\\\Sigma_i \\\\frac{V_i}{K_i} \\\\right)^{-1}\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type shear_moduli: list of floats\n\n        :returns: The Reuss average bulk modulus :math:`K_R` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return reuss_average_function(volumes, bulk_moduli)\n\n    def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli of a composite with the Reuss (iso-stress)\n        bound, given by:\n\n        .. math::\n            G_R = \\\\left( \\\\Sigma_i \\\\frac{V_i}{G_i} \\\\right)^{-1}\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n        :type shear_moduli: list of floats\n\n        :returns: The Reuss average shear modulus :math:`G_R` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return reuss_average_function(volumes, shear_moduli)",
  "class HashinShtrikmanUpper(AveragingScheme):\n\n    \"\"\"\n    Class for computing the upper Hashin-Shtrikman bound for elastic properties.\n    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,\n    and implements the\n    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`\n    and :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli`\n    functions. Implements formulas from :cite:`Watt1976`.\n    The Hashin-Shtrikman bounds\n    are tighter than the Voigt and Reuss bounds because they make the\n    additional assumption that the orientation of the phases are statistically\n    isotropic.  In some cases this may be a good assumption, and in others it\n    may not be.\n    \"\"\"\n\n    def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the upper Hashin-Shtrikman bound.\n        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce\n        here.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. :math:`[m^3]`\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The upper Hashin-Shtrikman average bulk modulus :math:`K`.\n            :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n\n        K_n = max(bulk_moduli)\n        G_n = max(shear_moduli)\n\n        vol_frac = volumes / sum(volumes)\n\n        alpha_n = -3.0 / (3.0 * K_n + 4.0 * G_n)\n        A_n = 0\n        for i in range(len(vol_frac)):\n            if bulk_moduli[i] != K_n:\n                A_n += vol_frac[i] / (1.0 / (bulk_moduli[i] - K_n) - alpha_n)\n\n        K_upper = K_n + A_n / (1.0 + alpha_n * A_n)\n        return K_upper\n\n    def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli of a composite with the upper Hashin-Shtrikman bound.\n        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce\n        here.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. :math:`[m^3]`\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The upper Hashin-Shtrikman average shear modulus :math:`G`.\n            :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n\n        K_n = max(bulk_moduli)\n        G_n = max(shear_moduli)\n\n        vol_frac = volumes / sum(volumes)\n\n        beta_n = -3.0 * (K_n + 2.0 * G_n) / (5.0 * G_n * (3.0 * K_n + 4.0 * G_n))\n        B_n = 0\n        for i in range(len(vol_frac)):\n            if shear_moduli[i] != G_n:\n                B_n += vol_frac[i] / (1.0 / (2.0 * (shear_moduli[i] - G_n)) - beta_n)\n\n        G_upper = G_n + (0.5) * B_n / (1.0 + beta_n * B_n)\n        return G_upper",
  "class HashinShtrikmanLower(AveragingScheme):\n\n    \"\"\"\n    Class for computing the lower Hashin-Shtrikman bound for elastic properties.\n    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,\n    and implements the\n    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`\n    and :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli`\n    functions.\n    Implements Formulas from :cite:`Watt1976`.  The Hashin-Shtrikman bounds\n    are tighter than the Voigt and Reuss bounds because they make the\n    additional assumption that the orientation of the phases are statistically\n    isotropic.  In some cases this may be a good assumption, and in others it\n    may not be.\n    \"\"\"\n\n    def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the lower Hashin-Shtrikman bound.\n        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce\n        here.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. :math:`[m^3]`\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The lower Hashin-Shtrikman average bulk modulus :math:`K`.\n            :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n\n        K_1 = min(bulk_moduli)\n        G_1 = min(shear_moduli)\n\n        vol_frac = volumes / sum(volumes)\n\n        alpha_1 = -3.0 / (3.0 * K_1 + 4.0 * G_1)\n        A_1 = 0\n        for i in range(len(vol_frac)):\n            if bulk_moduli[i] != K_1:\n                A_1 += vol_frac[i] / (1.0 / (bulk_moduli[i] - K_1) - alpha_1)\n\n        K_lower = K_1 + A_1 / (1.0 + alpha_1 * A_1)\n        return K_lower\n\n    def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli of a composite with the lower Hashin-Shtrikman bound.\n        Implements Formulas from :cite:`Watt1976`,\n        which are too lengthy to reproduce here.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. :math:`[m^3]`\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The lower Hashin-Shtrikman average shear modulus :math:`G`.\n            :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n\n        K_1 = min(bulk_moduli)\n        G_1 = min(shear_moduli)\n\n        vol_frac = volumes / sum(volumes)\n\n        beta_1 = -3.0 * (K_1 + 2.0 * G_1) / (5.0 * G_1 * (3.0 * K_1 + 4.0 * G_1))\n        B_1 = 0\n        for i in range(len(vol_frac)):\n            if shear_moduli[i] != G_1:\n                B_1 += vol_frac[i] / (1.0 / (2.0 * (shear_moduli[i] - G_1)) - beta_1)\n\n        G_lower = G_1 + (0.5) * B_1 / (1.0 + beta_1 * B_1)\n        return G_lower",
  "class HashinShtrikmanAverage(AveragingScheme):\n\n    \"\"\"\n    Class for computing arithmetic mean of the Hashin-Shtrikman bounds on\n    elastic properties.\n    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,\n    and implements the\n    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`\n    and\n    :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli`\n    functions.\n    \"\"\"\n\n    def __init__(self):\n        self.upper = HashinShtrikmanUpper()\n        self.lower = HashinShtrikmanLower()\n\n    def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the arithmetic mean of the upper\n        and lower Hashin-Shtrikman bounds.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. :math:`[m^3]`\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. Not used in this average. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The arithmetic mean of the Hashin-Shtrikman bounds on bulk modulus\n            :math:`K` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return (\n            self.upper.average_bulk_moduli(volumes, bulk_moduli, shear_moduli)\n            + self.lower.average_bulk_moduli(volumes, bulk_moduli, shear_moduli)\n        ) / 2.0\n\n    def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the arithmetic mean of the upper\n        and lower Hashin-Shtrikman bounds.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. [m^3].\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. Not used in this average. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The arithmetic mean of the Hashin-Shtrikman bounds on shear modulus\n            :math:`G` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return (\n            self.upper.average_shear_moduli(volumes, bulk_moduli, shear_moduli)\n            + self.lower.average_shear_moduli(volumes, bulk_moduli, shear_moduli)\n        ) / 2.0",
  "def voigt_average_function(phase_volume, X):\n    \"\"\"\n    Calculates the Voigt (iso-strain) average.  Rather like\n    resistors in series.  Called by voigt and\n    voigt_reuss_hill classes.\n\n    :param phase_volume: Phase volumes.\n    :type phase_volume: List of floats\n\n    :param X: Phase moduli.\n    :type X: List of floats\n\n    :returns: Voigt-averaged modulus\n    :rtype: float\n    \"\"\"\n    vol_frac = phase_volume / np.sum(phase_volume)\n    X_voigt = sum(f * x for f, x in zip(vol_frac, X))\n    return X_voigt",
  "def reuss_average_function(phase_volume, X):\n    \"\"\"\n    Calculates the Reuss (iso-stress) average.  Rather like\n    resistors in parallel.  Called by reuss and\n    voigt_reuss_hill classes.\n\n\n    :param phase_volume: Phase volumes.\n    :type phase_volume: List of floats\n\n    :param X: Phase moduli.\n    :type X: List of floats\n\n    :returns: Reuss-averaged modulus\n    :rtype: float\n    \"\"\"\n    vol_frac = phase_volume / np.sum(phase_volume)\n    for f, x in zip(vol_frac, X):\n        if x <= 0 and np.abs(f) > np.finfo(float).eps:\n            warnings.warn(\"Oops, called reuss_average with Xi<=0!\")\n            return 0.0\n    X_reuss = 1.0 / sum(f / x for f, x in zip(vol_frac, X))\n    return X_reuss",
  "def voigt_reuss_hill_function(phase_volume, X):\n    \"\"\"\n    Calculates the Voigt-Reuss-Hill average (arithmetic mean\n    of Voigt and Reuss bounds).  Called by\n    voigt_reuss_hill class.\n\n    :param phase_volume: Phase volumes.\n    :type phase_volume: List of floats\n\n    :param X: Phase moduli.\n    :type X: List of floats\n\n    :returns: Voigt-Reuss-Hill-averaged modulus\n    :rtype: float\n    \"\"\"\n    X_vrh = (\n        voigt_average_function(phase_volume, X)\n        + reuss_average_function(phase_volume, X)\n    ) / 2.0\n    return X_vrh",
  "def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli :math:`K` for a composite. This defines the interface\n        for this method, and is not implemented in the base class.\n\n        :param volumes: List of the volume of each phase in the composite\n            :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli : List of bulk moduli of each phase in the composite\n            :math:`[Pa]`.\n        :type bulk_moduli: list of floats\n        :param shear_moduli : List of shear moduli of each phase in the composite\n            :math:`[Pa]`.\n        :type shear_moduli: list of floats\n\n        :returns: The average bulk modulus :math:`K`. :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli :math:`G` for a composite.  This defines the interface\n        for this method, and is not implemented in the base class.\n\n        :param volumes: List of the volume of each phase in the composite\n            :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli of each phase in the composite\n            :math:`[Pa]`.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli of each phase in the composite\n            :math:`[Pa]`.\n        :type shear_moduli: list of floats\n\n        :returns: The average shear modulus :math:`G`. :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def average_density(self, volumes, densities):\n        \"\"\"\n        Average the densities of a composite, given a list of volume\n        fractions and densitites. This is implemented in the base class,\n        as how to calculate it is not dependent on the geometry of the rock.\n        The formula for density is given by\n\n        .. math::\n            \\\\rho = \\\\frac{\\\\Sigma_i \\\\rho_i V_i }{\\\\Sigma_i V_i}\n\n        :param volumes: List of the volume of each phase in the composite\n            :math:`[m^3]`.\n        :type volumes: list of floats\n        :param densities: List of densities of each phase in the composite\n            :math:`[kg/m^3]`.\n        :type densities: list of floats\n\n        :returns: Density :math:`\\\\rho` :math:`[kg/m^3]`.\n        :rtype: float\n        \"\"\"\n        total_mass = np.sum(np.array(densities) * np.array(volumes))\n        total_vol = np.sum(np.array(volumes))  # should sum to one\n        density = total_mass / total_vol\n        return density",
  "def average_thermal_expansivity(self, volumes, alphas):\n        \"\"\"\n        Averages the thermal expansion coefficient of the mineral :math:`\\\\alpha`\n        :math:`[1/K]`.\n\n        :param volumes: List of volume fractions of each phase\n            in the composite (should sum to 1.0).\n        :type volumes: list of floats\n        :param alphas: List of thermal expansivities :math:`\\\\alpha`\n            of each phase in the composite. :math:`[1/K]`\n        :type alphas: list of floats\n\n        :returns: Thermal expansivity of the composite :math:`\\\\alpha`. :math:`[1/K]`\n        :rtype: float\n        \"\"\"\n        total_vol = np.sum(np.array(volumes))\n        return np.sum(np.array(alphas) * np.array(volumes)) / total_vol",
  "def average_heat_capacity_v(self, fractions, c_v):\n        # TODO: double-check that the formula we use is appropriate here.\n        \"\"\"\n        Averages the heat capacities at constant volume :math:`C_V` by molar fractions\n        as in eqn. (16) in :cite:`Ita1992`.\n\n        :param fractions: List of molar fractions of each phase\n            in the composite (should sum to 1.0).\n        :type fractions: list of floats\n        :param c_v: List of heat capacities at constant volume :math:`C_V`\n            of each phase in the composite. :math:`[J/K/mol]`\n        :type c_v: list of floats\n\n        :returns: Heat capacity at constant volume of the composite :math:`C_V`\n            :math:`[J/K/mol]`.\n        :rtype: float\n        \"\"\"\n        return np.sum(np.array(fractions) * np.array(c_v))",
  "def average_heat_capacity_p(self, fractions, c_p):\n        # TODO: double-check that the formula we use is correct.\n        \"\"\"\n        Averages the heat capacities at constant pressure :math:`C_P`\n        by molar fractions.\n\n        :param fractions: List of molar fractions of each phase in the composite\n            (should sum to 1.0).\n        :type fractions: list of floats\n        :param c_p: List of heat capacities at constant pressure :math:`C_P` of each\n            phase in the composite :math:`[J/K/mol]`.\n        :type c_p: list of floats\n\n        :returns: Heat capacity at constant pressure :math:`C_P` of the composite\n            :math:`[J/K/mol]`.\n        :rtype: float\n        \"\"\"\n        return np.sum(np.array(fractions) * np.array(c_p))",
  "def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the Voigt-Reuss-Hill average,\n        given by:\n\n        .. math::\n            K_{VRH} = \\\\frac{K_V + K_R}{2}\n\n        This is simply a shorthand for an arithmetic average of the bounds given\n        by :class:`burnman.averaging_schemes.voigt`\n        and :class:`burnman.averaging_schemes.reuss`.\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type shear_moduli: list of floats\n\n        :returns: The Voigt-Reuss-Hill average bulk modulus :math:`K_{VRH}`\n            :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return voigt_reuss_hill_function(volumes, bulk_moduli)",
  "def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli :math:`G` of a composite with the\n        Voigt-Reuss-Hill average, given by:\n\n        .. math::\n            G_{VRH} = \\\\frac{G_V + G_R}{2}\n\n        This is simply a shorthand for an arithmetic average of the bounds given\n        by :class:`burnman.averaging_schemes.voigt`\n        and :class:`burnman.averaging_schemes.reuss`.\n\n        .. math::\n            G_V = \\\\Sigma_i V_i G_i\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n        :type shear_moduli: list of floats\n\n        :returns: The Voigt-Reuss-Hill average shear modulus :math:`G_{VRH}`\n            :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return voigt_reuss_hill_function(volumes, shear_moduli)",
  "def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite :math:`K` with the Voigt (iso-strain)\n        bound, given by:\n\n        .. math::\n            K_V = \\\\Sigma_i V_i K_i\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type shear_moduli: list of floats\n\n        :returns: The Voigt average bulk modulus :math:`K_R` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return voigt_average_function(volumes, bulk_moduli)",
  "def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli of a composite with the Voigt (iso-strain)\n        bound, given by:\n\n        .. math::\n            G_V = \\\\Sigma_i V_i G_i\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n        :type shear_moduli: list of floats\n\n        :returns: The Voigt average shear modulus :math:`G_V` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return voigt_average_function(volumes, shear_moduli)",
  "def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the Reuss (iso-stress)\n        bound, given by:\n\n        .. math::\n            K_R = \\\\left(\\\\Sigma_i \\\\frac{V_i}{K_i} \\\\right)^{-1}\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type shear_moduli: list of floats\n\n        :returns: The Reuss average bulk modulus :math:`K_R` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return reuss_average_function(volumes, bulk_moduli)",
  "def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli of a composite with the Reuss (iso-stress)\n        bound, given by:\n\n        .. math::\n            G_R = \\\\left( \\\\Sigma_i \\\\frac{V_i}{G_i} \\\\right)^{-1}\n\n        :param volumes: List of the volume of each phase\n            in the composite :math:`[m^3]`.\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K`\n            of each phase in the composite :math:`[Pa]`.\n            Not used in this average.\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite :math:`[Pa]`.\n        :type shear_moduli: list of floats\n\n        :returns: The Reuss average shear modulus :math:`G_R` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return reuss_average_function(volumes, shear_moduli)",
  "def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the upper Hashin-Shtrikman bound.\n        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce\n        here.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. :math:`[m^3]`\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The upper Hashin-Shtrikman average bulk modulus :math:`K`.\n            :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n\n        K_n = max(bulk_moduli)\n        G_n = max(shear_moduli)\n\n        vol_frac = volumes / sum(volumes)\n\n        alpha_n = -3.0 / (3.0 * K_n + 4.0 * G_n)\n        A_n = 0\n        for i in range(len(vol_frac)):\n            if bulk_moduli[i] != K_n:\n                A_n += vol_frac[i] / (1.0 / (bulk_moduli[i] - K_n) - alpha_n)\n\n        K_upper = K_n + A_n / (1.0 + alpha_n * A_n)\n        return K_upper",
  "def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli of a composite with the upper Hashin-Shtrikman bound.\n        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce\n        here.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. :math:`[m^3]`\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The upper Hashin-Shtrikman average shear modulus :math:`G`.\n            :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n\n        K_n = max(bulk_moduli)\n        G_n = max(shear_moduli)\n\n        vol_frac = volumes / sum(volumes)\n\n        beta_n = -3.0 * (K_n + 2.0 * G_n) / (5.0 * G_n * (3.0 * K_n + 4.0 * G_n))\n        B_n = 0\n        for i in range(len(vol_frac)):\n            if shear_moduli[i] != G_n:\n                B_n += vol_frac[i] / (1.0 / (2.0 * (shear_moduli[i] - G_n)) - beta_n)\n\n        G_upper = G_n + (0.5) * B_n / (1.0 + beta_n * B_n)\n        return G_upper",
  "def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the lower Hashin-Shtrikman bound.\n        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce\n        here.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. :math:`[m^3]`\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The lower Hashin-Shtrikman average bulk modulus :math:`K`.\n            :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n\n        K_1 = min(bulk_moduli)\n        G_1 = min(shear_moduli)\n\n        vol_frac = volumes / sum(volumes)\n\n        alpha_1 = -3.0 / (3.0 * K_1 + 4.0 * G_1)\n        A_1 = 0\n        for i in range(len(vol_frac)):\n            if bulk_moduli[i] != K_1:\n                A_1 += vol_frac[i] / (1.0 / (bulk_moduli[i] - K_1) - alpha_1)\n\n        K_lower = K_1 + A_1 / (1.0 + alpha_1 * A_1)\n        return K_lower",
  "def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the shear moduli of a composite with the lower Hashin-Shtrikman bound.\n        Implements Formulas from :cite:`Watt1976`,\n        which are too lengthy to reproduce here.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. :math:`[m^3]`\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The lower Hashin-Shtrikman average shear modulus :math:`G`.\n            :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n\n        K_1 = min(bulk_moduli)\n        G_1 = min(shear_moduli)\n\n        vol_frac = volumes / sum(volumes)\n\n        beta_1 = -3.0 * (K_1 + 2.0 * G_1) / (5.0 * G_1 * (3.0 * K_1 + 4.0 * G_1))\n        B_1 = 0\n        for i in range(len(vol_frac)):\n            if shear_moduli[i] != G_1:\n                B_1 += vol_frac[i] / (1.0 / (2.0 * (shear_moduli[i] - G_1)) - beta_1)\n\n        G_lower = G_1 + (0.5) * B_1 / (1.0 + beta_1 * B_1)\n        return G_lower",
  "def __init__(self):\n        self.upper = HashinShtrikmanUpper()\n        self.lower = HashinShtrikmanLower()",
  "def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the arithmetic mean of the upper\n        and lower Hashin-Shtrikman bounds.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. :math:`[m^3]`\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. Not used in this average. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The arithmetic mean of the Hashin-Shtrikman bounds on bulk modulus\n            :math:`K` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return (\n            self.upper.average_bulk_moduli(volumes, bulk_moduli, shear_moduli)\n            + self.lower.average_bulk_moduli(volumes, bulk_moduli, shear_moduli)\n        ) / 2.0",
  "def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):\n        \"\"\"\n        Average the bulk moduli of a composite with the arithmetic mean of the upper\n        and lower Hashin-Shtrikman bounds.\n\n        :param volumes: List of the volumes of each phase\n            in the composite. [m^3].\n        :type volumes: list of floats\n        :param bulk_moduli: List of bulk moduli :math:`K` of each phase\n            in the composite. Not used in this average. :math:`[Pa]`\n        :type bulk_moduli: list of floats\n        :param shear_moduli: List of shear moduli :math:`G` of each phase\n            in the composite. :math:`[Pa]`\n        :type shear_moduli: list of floats\n\n        :returns: The arithmetic mean of the Hashin-Shtrikman bounds on shear modulus\n            :math:`G` :math:`[Pa]`.\n        :rtype: float\n        \"\"\"\n        return (\n            self.upper.average_shear_moduli(volumes, bulk_moduli, shear_moduli)\n            + self.lower.average_shear_moduli(volumes, bulk_moduli, shear_moduli)\n        ) / 2.0",
  "def create_perplex_table(\n    werami_path,\n    project_name,\n    outfile,\n    n_pressures,\n    n_temperatures,\n    pressure_range=None,\n    temperature_range=None,\n):\n    \"\"\"\n    This function uses PerpleX's werami software to output a table file\n    containing the following material properties.\n    2 - Density (kg/m3)\n    4 - Expansivity (1/K, for volume)\n    5 - Compressibility (1/bar, for volume)\n    10 - Adiabatic bulk modulus (bar)\n    11 - Adiabatic shear modulus (bar)\n    12 - Sound velocity (km/s)\n    13 - P-wave velocity (Vp, km/s)\n    14 - S-wave velocity (Vs, km/s)\n    17 - Entropy (J/K/kg)\n    18 - Enthalpy (J/kg)\n    19 - Heat Capacity (J/K/kg)\n    22 - Molar Volume (J/bar)\n\n    The user must already have a PerpleX build file,\n    and have run vertex on that build file.\n    \"\"\"\n\n    print(\n        \"Creating a {0}x{1} P-T table file using werami. Please wait.\\n\".format(\n            n_pressures, n_temperatures\n        )\n    )\n\n    try:\n        str2 = \"y\\n{0} {1}\\n{2} {3}\\n\".format(\n            pressure_range[0] / 1.0e5,\n            pressure_range[1] / 1.0e5,\n            temperature_range[0],\n            temperature_range[1],\n        )\n    except TypeError:\n        print(\"Keeping P-T range the same as the original project range.\\n\")\n        str2 = \"n\\n\"\n\n    stdin = (\n        \"{0:s}\\n2\\n\"\n        \"2\\nn\\n\"\n        \"4\\nn\\n\"\n        \"5\\nn\\n\"\n        \"10\\nn\\n\"\n        \"11\\nn\\n\"\n        \"12\\nn\\n\"\n        \"13\\nn\\n\"\n        \"14\\nn\\n\"\n        \"17\\nn\\n\"\n        \"18\\nn\\n\"\n        \"19\\nn\\n\"\n        \"22\\nn\\n\"\n        \"0\\n\"\n        \"{1:s}\"\n        \"{2:d} {3:d}\\n\"\n        \"0\\n\".format(project_name, str2, n_pressures, n_temperatures)\n    )\n\n    with subprocess.Popen(\n        werami_path,\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        encoding=\"utf8\",\n    ) as process:\n        process.stdin.write(stdin)\n        process.stdin.flush()\n\n        out = \"\"\n        # Grab stdout line by line as it becomes available.\n        # This will loop until the process terminates.\n        stdoutput = \"\"\n        while process.poll() is not None:\n            line = process.stdout.readline()\n            stdoutput += line\n\n            # Check if vertex has been run on the build file\n            if \"missing *.tof file\" in line:\n                raise Exception(\n                    \"You must run Perple_X vertex \"\n                    f\"({werami_path[0].split('werami')[0]}vertex) \"\n                    \"using the PerpleX build file ({project_name}) \"\n                    \"before running this script.\"\n                )\n\n        while process.poll() is None:\n            line = process.stdout.readline()\n            stdoutput += line\n\n            # Check if werami is trying to create a standard resolution grid\n            # Tell the user to modify their local perplex option file if so.\n            if \"Continue (y/n)?\" in line:\n                raise Exception(\n                    \"If you do not want to define your own P-T range for the grid,\\n\"\n                    \"you must set sample_on_grid to F in the perplex option file\\n\"\n                    \"(default is perplex_option.dat).\"\n                )\n\n            # Get the output file name\n            if \"Output has been written to the\" in line:\n                out = line.split()[-1]\n\n        # Print stdoutput\n        print(stdoutput)\n        print(process.stdout.read())\n\n        # Rename the file to the user-specified filename\n        rename(out, outfile)\n        print(\"Output file renamed to {0:s}\".format(outfile))\n        print(\"Processing complete\")",
  "class PerplexMaterial(Material):\n    \"\"\"\n    This is the base class for a PerpleX material. States of the material\n    can only be queried after setting the pressure and temperature\n    using set_state().\n\n    Instances of this class are initialised with\n    a 2D PerpleX tab file. This file should be in the standard format\n    (as output by werami), and should have columns with the following names:\n    'rho,kg/m3', 'alpha,1/K', 'beta,1/bar', 'Ks,bar', 'Gs,bar', 'v0,km/s',\n    'vp,km/s', 'vs,km/s', 's,J/K/kg', 'h,J/kg', 'cp,J/K/kg', 'V,J/bar/mol'.\n    The order of these names is not important.\n\n    Properties of the material are determined by linear interpolation from\n    the PerpleX grid. They are all returned in SI units on a molar basis,\n    even though the PerpleX tab file is not in these units.\n\n    This class is available as ``burnman.PerplexMaterial``.\n    \"\"\"\n\n    def __init__(self, tab_file, name=\"Perple_X material\"):\n        self.name = name\n        self.params = {\"name\": name}\n        (\n            self._property_interpolators,\n            self.params[\"molar_mass\"],\n            self.bounds,\n        ) = self._read_2D_perplex_file(tab_file)\n        Material.__init__(self)\n\n    def _read_2D_perplex_file(self, filename):\n        with open(filename, \"r\") as f:\n            datastream = f.read()\n\n        lines = [\n            line.strip().split() for line in datastream.split(\"\\n\") if line.strip()\n        ]\n\n        if lines[2][0] != \"2\":\n            raise Exception(\"This is not a 2D PerpleX table\")\n\n        bounds = [\n            (float(lines[4][0]), float(lines[5][0]), int(lines[6][0])),\n            (float(lines[8][0]), float(lines[9][0]), int(lines[10][0])),\n        ]\n\n        if lines[3][0] == \"P(bar)\" and lines[7][0] == \"T(K)\":\n            Pmin, Pint, nP = bounds[0]\n            Tmin, Tint, nT = bounds[1]\n        elif lines[3][0] == \"T(K)\" and lines[7][0] == \"P(bar)\":\n            Pmin, Pint, nP = bounds[1]\n            Tmin, Tint, nT = bounds[0]\n        else:\n            raise Exception(\n                \"This file does not have a recognised PerpleX structure.\\n\"\n                \"Are the independent variables P(bar) and T(K)?\"\n            )\n\n        Pmin = Pmin * 1.0e5  # bar to Pa\n        Pint = Pint * 1.0e5  # bar to Pa\n        Pmax = Pmin + Pint * (nP - 1.0)\n        Tmax = Tmin + Tint * (nT - 1.0)\n        pressures = np.linspace(Pmin, Pmax, nP)\n        temperatures = np.linspace(Tmin, Tmax, nT)\n        n_properties = int(lines[11][0])\n        property_list = lines[12]\n\n        # property_table[i][j][k] returns the kth property at the ith pressure and jth temperature\n        table = np.array(\n            [[float(string) for string in line] for line in lines[13 : 13 + nP * nT]]\n        )\n\n        if lines[3][0] == \"P(bar)\":\n            property_table = np.swapaxes(table.reshape(nT, nP, n_properties), 0, 1)\n        else:\n            property_table = table.reshape(nP, nT, n_properties)\n\n        ordered_property_list = [\n            \"rho,kg/m3\",\n            \"alpha,1/K\",\n            \"beta,1/bar\",\n            \"Ks,bar\",\n            \"Gs,bar\",\n            \"v0,km/s\",\n            \"vp,km/s\",\n            \"vs,km/s\",\n            \"s,J/K/kg\",\n            \"h,J/kg\",\n            \"cp,J/K/kg\",\n            \"V,J/bar/mol\",\n        ]\n        p_indices = [\n            i\n            for i, p in enumerate(property_list)\n            for ordered_p in ordered_property_list\n            if p == ordered_p\n        ]\n\n        properties = {}\n        for i, p_idx in enumerate(p_indices):\n            # Fill in NaNs as long as they aren't in the corners of the P-T grid\n            a = np.array(property_table[:, :, [p_idx]][:, :, 0])\n            x, y = np.indices(a.shape)\n            a[np.isnan(a)] = griddata(\n                (x[~np.isnan(a)], y[~np.isnan(a)]),  # points we know\n                a[~np.isnan(a)],  # values we know\n                (x[np.isnan(a)], y[np.isnan(a)]),\n            )\n\n            # Fill any remaining NaNs with zeros\n            properties[ordered_property_list[i]] = np.nan_to_num(a, 0.0)\n\n        densities = properties[\"rho,kg/m3\"]\n        volumes = 1.0e-5 * properties[\"V,J/bar/mol\"]\n        molar_masses = densities * volumes\n        molar_mass = np.mean(molar_masses)\n\n        property_interpolators = {\n            \"rho\": RegularGridInterpolator(\n                (pressures, temperatures), densities, bounds_error=True\n            ),\n            \"alpha\": RegularGridInterpolator(\n                (pressures, temperatures), properties[\"alpha,1/K\"], bounds_error=True\n            ),\n            \"K_T\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e5 / properties[\"beta,1/bar\"],\n                bounds_error=True,\n            ),\n            \"K_S\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e5 * properties[\"Ks,bar\"],\n                bounds_error=True,\n            ),\n            \"G_S\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e5 * properties[\"Gs,bar\"],\n                bounds_error=True,\n            ),\n            \"bulk_sound_velocity\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e3 * properties[\"v0,km/s\"],\n                bounds_error=True,\n            ),\n            \"p_wave_velocity\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e3 * properties[\"vp,km/s\"],\n                bounds_error=True,\n            ),\n            \"s_wave_velocity\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e3 * properties[\"vs,km/s\"],\n                bounds_error=True,\n            ),\n            \"S\": RegularGridInterpolator(\n                (pressures, temperatures),\n                properties[\"s,J/K/kg\"] * molar_masses,\n                bounds_error=True,\n            ),\n            \"H\": RegularGridInterpolator(\n                (pressures, temperatures),\n                properties[\"h,J/kg\"] * molar_masses,\n                bounds_error=True,\n            ),\n            \"C_p\": RegularGridInterpolator(\n                (pressures, temperatures),\n                properties[\"cp,J/K/kg\"] * molar_masses,\n                bounds_error=True,\n            ),\n            \"V\": RegularGridInterpolator(\n                (pressures, temperatures), volumes, bounds_error=True\n            ),\n        }\n\n        bounds = [[Pmin, Pmax], [Tmin, Tmax]]\n        return property_interpolators, molar_mass, bounds\n\n    @copy_documentation(Material.set_state)\n    def set_state(self, pressure, temperature):\n        if not np.logical_and(\n            np.all(self.bounds[0][0] <= pressure), np.all(pressure <= self.bounds[0][1])\n        ):\n            raise ValueError(\n                \"The set_state pressure ({0:.4f}) is outside the bounds of this rock ({1:.4f}-{2:.4f} GPa)\".format(\n                    pressure, self.bounds[0][0] / 1.0e9, self.bounds[0][1] / 1.0e9\n                )\n            )\n        if not np.logical_and(\n            np.all(self.bounds[1][0] <= temperature),\n            np.all(temperature <= self.bounds[1][1]),\n        ):\n            raise ValueError(\n                \"The set_state temperature ({0:.1f}) is outside the bounds of this rock ({1:.1f}-{2:.1f} K)\".format(\n                    temperature, self.bounds[1][0], self.bounds[1][1]\n                )\n            )\n        Material.set_state(self, pressure, temperature)\n\n    \"\"\"\n    Properties by linear interpolation of Perple_X output\n    \"\"\"\n\n    @material_property\n    @copy_documentation(Material.molar_volume)\n    def molar_volume(self):\n        return self._property_interpolators[\"V\"]([self.pressure, self.temperature])[0]\n\n    @material_property\n    @copy_documentation(Material.molar_enthalpy)\n    def molar_enthalpy(self):\n        return self._property_interpolators[\"H\"]([self.pressure, self.temperature])[0]\n\n    @material_property\n    @copy_documentation(Material.molar_entropy)\n    def molar_entropy(self):\n        return self._property_interpolators[\"S\"]([self.pressure, self.temperature])[0]\n\n    @material_property\n    @copy_documentation(Material.isothermal_bulk_modulus)\n    def isothermal_bulk_modulus(self):\n        return self._property_interpolators[\"K_T\"]([self.pressure, self.temperature])[0]\n\n    @material_property\n    @copy_documentation(Material.adiabatic_bulk_modulus)\n    def adiabatic_bulk_modulus(self):\n        return self._property_interpolators[\"K_S\"]([self.pressure, self.temperature])[0]\n\n    @material_property\n    @copy_documentation(Material.molar_heat_capacity_p)\n    def molar_heat_capacity_p(self):\n        return self._property_interpolators[\"C_p\"]([self.pressure, self.temperature])[0]\n\n    @material_property\n    @copy_documentation(Material.thermal_expansivity)\n    def thermal_expansivity(self):\n        return self._property_interpolators[\"alpha\"]([self.pressure, self.temperature])[\n            0\n        ]\n\n    @material_property\n    @copy_documentation(Material.shear_modulus)\n    def shear_modulus(self):\n        return self._property_interpolators[\"G_S\"]([self.pressure, self.temperature])[0]\n\n    @material_property\n    @copy_documentation(Material.p_wave_velocity)\n    def p_wave_velocity(self):\n        return self._property_interpolators[\"p_wave_velocity\"](\n            [self.pressure, self.temperature]\n        )[0]\n\n    @material_property\n    @copy_documentation(Material.bulk_sound_velocity)\n    def bulk_sound_velocity(self):\n        return self._property_interpolators[\"bulk_sound_velocity\"](\n            [self.pressure, self.temperature]\n        )[0]\n\n    @material_property\n    @copy_documentation(Material.shear_wave_velocity)\n    def shear_wave_velocity(self):\n        return self._property_interpolators[\"s_wave_velocity\"](\n            [self.pressure, self.temperature]\n        )[0]\n\n    \"\"\"\n    Properties from mineral parameters,\n    Legendre transformations\n    or Maxwell relations\n    \"\"\"\n\n    @material_property\n    @copy_documentation(Material.molar_gibbs)\n    def molar_gibbs(self):\n        return self.molar_enthalpy - self.temperature * self.molar_entropy\n\n    @material_property\n    @copy_documentation(Material.molar_mass)\n    def molar_mass(self):\n        if \"molar_mass\" in self.params:\n            return self.params[\"molar_mass\"]\n        else:\n            raise ValueError(\n                \"No molar_mass parameter for mineral \" + self.to_string + \".\"\n            )\n\n    @material_property\n    @copy_documentation(Material.density)\n    def density(self):\n        return self._property_interpolators[\"rho\"]([self.pressure, self.temperature])[0]\n\n    @material_property\n    @copy_documentation(Material.molar_internal_energy)\n    def molar_internal_energy(self):\n        return (\n            self.molar_gibbs\n            - self.pressure * self.molar_volume\n            + self.temperature * self.molar_entropy\n        )\n\n    @material_property\n    @copy_documentation(Material.molar_helmholtz)\n    def molar_helmholtz(self):\n        return self.molar_gibbs - self.pressure * self.molar_volume\n\n    @material_property\n    @copy_documentation(Material.isothermal_compressibility)\n    def isothermal_compressibility(self):\n        return 1.0 / self.isothermal_bulk_modulus\n\n    @material_property\n    @copy_documentation(Material.adiabatic_compressibility)\n    def adiabatic_compressibility(self):\n        return 1.0 / self.adiabatic_bulk_modulus\n\n    @material_property\n    @copy_documentation(Material.molar_heat_capacity_v)\n    def molar_heat_capacity_v(self):\n        return (\n            self.molar_heat_capacity_p\n            - self.molar_volume\n            * self.temperature\n            * self.thermal_expansivity\n            * self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n        )\n\n    @material_property\n    @copy_documentation(Material.grueneisen_parameter)\n    def grueneisen_parameter(self):\n        return (\n            self.thermal_expansivity\n            * self.molar_volume\n            * self.adiabatic_bulk_modulus\n            / self.molar_heat_capacity_p\n        )",
  "def __init__(self, tab_file, name=\"Perple_X material\"):\n        self.name = name\n        self.params = {\"name\": name}\n        (\n            self._property_interpolators,\n            self.params[\"molar_mass\"],\n            self.bounds,\n        ) = self._read_2D_perplex_file(tab_file)\n        Material.__init__(self)",
  "def _read_2D_perplex_file(self, filename):\n        with open(filename, \"r\") as f:\n            datastream = f.read()\n\n        lines = [\n            line.strip().split() for line in datastream.split(\"\\n\") if line.strip()\n        ]\n\n        if lines[2][0] != \"2\":\n            raise Exception(\"This is not a 2D PerpleX table\")\n\n        bounds = [\n            (float(lines[4][0]), float(lines[5][0]), int(lines[6][0])),\n            (float(lines[8][0]), float(lines[9][0]), int(lines[10][0])),\n        ]\n\n        if lines[3][0] == \"P(bar)\" and lines[7][0] == \"T(K)\":\n            Pmin, Pint, nP = bounds[0]\n            Tmin, Tint, nT = bounds[1]\n        elif lines[3][0] == \"T(K)\" and lines[7][0] == \"P(bar)\":\n            Pmin, Pint, nP = bounds[1]\n            Tmin, Tint, nT = bounds[0]\n        else:\n            raise Exception(\n                \"This file does not have a recognised PerpleX structure.\\n\"\n                \"Are the independent variables P(bar) and T(K)?\"\n            )\n\n        Pmin = Pmin * 1.0e5  # bar to Pa\n        Pint = Pint * 1.0e5  # bar to Pa\n        Pmax = Pmin + Pint * (nP - 1.0)\n        Tmax = Tmin + Tint * (nT - 1.0)\n        pressures = np.linspace(Pmin, Pmax, nP)\n        temperatures = np.linspace(Tmin, Tmax, nT)\n        n_properties = int(lines[11][0])\n        property_list = lines[12]\n\n        # property_table[i][j][k] returns the kth property at the ith pressure and jth temperature\n        table = np.array(\n            [[float(string) for string in line] for line in lines[13 : 13 + nP * nT]]\n        )\n\n        if lines[3][0] == \"P(bar)\":\n            property_table = np.swapaxes(table.reshape(nT, nP, n_properties), 0, 1)\n        else:\n            property_table = table.reshape(nP, nT, n_properties)\n\n        ordered_property_list = [\n            \"rho,kg/m3\",\n            \"alpha,1/K\",\n            \"beta,1/bar\",\n            \"Ks,bar\",\n            \"Gs,bar\",\n            \"v0,km/s\",\n            \"vp,km/s\",\n            \"vs,km/s\",\n            \"s,J/K/kg\",\n            \"h,J/kg\",\n            \"cp,J/K/kg\",\n            \"V,J/bar/mol\",\n        ]\n        p_indices = [\n            i\n            for i, p in enumerate(property_list)\n            for ordered_p in ordered_property_list\n            if p == ordered_p\n        ]\n\n        properties = {}\n        for i, p_idx in enumerate(p_indices):\n            # Fill in NaNs as long as they aren't in the corners of the P-T grid\n            a = np.array(property_table[:, :, [p_idx]][:, :, 0])\n            x, y = np.indices(a.shape)\n            a[np.isnan(a)] = griddata(\n                (x[~np.isnan(a)], y[~np.isnan(a)]),  # points we know\n                a[~np.isnan(a)],  # values we know\n                (x[np.isnan(a)], y[np.isnan(a)]),\n            )\n\n            # Fill any remaining NaNs with zeros\n            properties[ordered_property_list[i]] = np.nan_to_num(a, 0.0)\n\n        densities = properties[\"rho,kg/m3\"]\n        volumes = 1.0e-5 * properties[\"V,J/bar/mol\"]\n        molar_masses = densities * volumes\n        molar_mass = np.mean(molar_masses)\n\n        property_interpolators = {\n            \"rho\": RegularGridInterpolator(\n                (pressures, temperatures), densities, bounds_error=True\n            ),\n            \"alpha\": RegularGridInterpolator(\n                (pressures, temperatures), properties[\"alpha,1/K\"], bounds_error=True\n            ),\n            \"K_T\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e5 / properties[\"beta,1/bar\"],\n                bounds_error=True,\n            ),\n            \"K_S\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e5 * properties[\"Ks,bar\"],\n                bounds_error=True,\n            ),\n            \"G_S\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e5 * properties[\"Gs,bar\"],\n                bounds_error=True,\n            ),\n            \"bulk_sound_velocity\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e3 * properties[\"v0,km/s\"],\n                bounds_error=True,\n            ),\n            \"p_wave_velocity\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e3 * properties[\"vp,km/s\"],\n                bounds_error=True,\n            ),\n            \"s_wave_velocity\": RegularGridInterpolator(\n                (pressures, temperatures),\n                1.0e3 * properties[\"vs,km/s\"],\n                bounds_error=True,\n            ),\n            \"S\": RegularGridInterpolator(\n                (pressures, temperatures),\n                properties[\"s,J/K/kg\"] * molar_masses,\n                bounds_error=True,\n            ),\n            \"H\": RegularGridInterpolator(\n                (pressures, temperatures),\n                properties[\"h,J/kg\"] * molar_masses,\n                bounds_error=True,\n            ),\n            \"C_p\": RegularGridInterpolator(\n                (pressures, temperatures),\n                properties[\"cp,J/K/kg\"] * molar_masses,\n                bounds_error=True,\n            ),\n            \"V\": RegularGridInterpolator(\n                (pressures, temperatures), volumes, bounds_error=True\n            ),\n        }\n\n        bounds = [[Pmin, Pmax], [Tmin, Tmax]]\n        return property_interpolators, molar_mass, bounds",
  "def set_state(self, pressure, temperature):\n        if not np.logical_and(\n            np.all(self.bounds[0][0] <= pressure), np.all(pressure <= self.bounds[0][1])\n        ):\n            raise ValueError(\n                \"The set_state pressure ({0:.4f}) is outside the bounds of this rock ({1:.4f}-{2:.4f} GPa)\".format(\n                    pressure, self.bounds[0][0] / 1.0e9, self.bounds[0][1] / 1.0e9\n                )\n            )\n        if not np.logical_and(\n            np.all(self.bounds[1][0] <= temperature),\n            np.all(temperature <= self.bounds[1][1]),\n        ):\n            raise ValueError(\n                \"The set_state temperature ({0:.1f}) is outside the bounds of this rock ({1:.1f}-{2:.1f} K)\".format(\n                    temperature, self.bounds[1][0], self.bounds[1][1]\n                )\n            )\n        Material.set_state(self, pressure, temperature)",
  "def molar_volume(self):\n        return self._property_interpolators[\"V\"]([self.pressure, self.temperature])[0]",
  "def molar_enthalpy(self):\n        return self._property_interpolators[\"H\"]([self.pressure, self.temperature])[0]",
  "def molar_entropy(self):\n        return self._property_interpolators[\"S\"]([self.pressure, self.temperature])[0]",
  "def isothermal_bulk_modulus(self):\n        return self._property_interpolators[\"K_T\"]([self.pressure, self.temperature])[0]",
  "def adiabatic_bulk_modulus(self):\n        return self._property_interpolators[\"K_S\"]([self.pressure, self.temperature])[0]",
  "def molar_heat_capacity_p(self):\n        return self._property_interpolators[\"C_p\"]([self.pressure, self.temperature])[0]",
  "def thermal_expansivity(self):\n        return self._property_interpolators[\"alpha\"]([self.pressure, self.temperature])[\n            0\n        ]",
  "def shear_modulus(self):\n        return self._property_interpolators[\"G_S\"]([self.pressure, self.temperature])[0]",
  "def p_wave_velocity(self):\n        return self._property_interpolators[\"p_wave_velocity\"](\n            [self.pressure, self.temperature]\n        )[0]",
  "def bulk_sound_velocity(self):\n        return self._property_interpolators[\"bulk_sound_velocity\"](\n            [self.pressure, self.temperature]\n        )[0]",
  "def shear_wave_velocity(self):\n        return self._property_interpolators[\"s_wave_velocity\"](\n            [self.pressure, self.temperature]\n        )[0]",
  "def molar_gibbs(self):\n        return self.molar_enthalpy - self.temperature * self.molar_entropy",
  "def molar_mass(self):\n        if \"molar_mass\" in self.params:\n            return self.params[\"molar_mass\"]\n        else:\n            raise ValueError(\n                \"No molar_mass parameter for mineral \" + self.to_string + \".\"\n            )",
  "def density(self):\n        return self._property_interpolators[\"rho\"]([self.pressure, self.temperature])[0]",
  "def molar_internal_energy(self):\n        return (\n            self.molar_gibbs\n            - self.pressure * self.molar_volume\n            + self.temperature * self.molar_entropy\n        )",
  "def molar_helmholtz(self):\n        return self.molar_gibbs - self.pressure * self.molar_volume",
  "def isothermal_compressibility(self):\n        return 1.0 / self.isothermal_bulk_modulus",
  "def adiabatic_compressibility(self):\n        return 1.0 / self.adiabatic_bulk_modulus",
  "def molar_heat_capacity_v(self):\n        return (\n            self.molar_heat_capacity_p\n            - self.molar_volume\n            * self.temperature\n            * self.thermal_expansivity\n            * self.thermal_expansivity\n            * self.isothermal_bulk_modulus\n        )",
  "def grueneisen_parameter(self):\n        return (\n            self.thermal_expansivity\n            * self.molar_volume\n            * self.adiabatic_bulk_modulus\n            / self.molar_heat_capacity_p\n        )",
  "class SimplexGrid(object):\n    \"\"\"\n    A class that creates objects that can efficiently generate a set of points\n    that grid a simplex with a user-defined number of vertices. The class\n    contains both a generator method and a grid method. It also contains\n    an n_points attribute that returns the number of points in the gridded\n    simplex.\n\n    This class is available as :class:`burnman.polytope.SimplexGrid`.\n    \"\"\"\n\n    def __init__(self, vertices, points_per_edge):\n        \"\"\"\n        Initialize SimplexGrid object with the desired number of vertices\n        and points per edge.\n        \"\"\"\n        assert vertices >= 2, \"need at least two vertices\"\n        assert points_per_edge >= 2, \"need at least 2 points per edge\"\n\n        self.vertices = vertices\n        self.points_per_edge = points_per_edge\n\n    def generate(self, generate_type=\"list\"):\n        \"\"\"\n        Generates the grid points of the simplex in lexicographic order.\n\n        :param generate_type: Determines whether the generator returns\n            lists or arrays corresponding to each point in the simplex grid.\n            Valid options are 'list' or 'array'.\n        :type generate_type: str\n\n        :returns: Grid points of the simplex.\n        :rtype: generator of lists or ndarrays (int, ndim=1)\n        \"\"\"\n\n        if generate_type == \"list\":\n            x = [0] * self.vertices\n        elif generate_type == \"array\":\n            x = np.zeros(self.vertices, dtype=int)\n        else:\n            raise Exception(\"generate_type must be of type list or array.\")\n\n        x[self.vertices - 1] = self.points_per_edge - 1\n\n        h = self.vertices\n        while True:\n            yield copy(x)\n\n            h -= 1\n            if h == 0:\n                return\n\n            val = x[h]\n            x[h] = 0\n            x[self.vertices - 1] = val - 1\n            x[h - 1] += 1\n            if val != 1:\n                h = self.vertices\n\n    def grid(self, generate_type=\"list\"):\n        \"\"\"\n        Returns either a list or a numpy array\n        corresponding the the points in the simplex grid, depending on\n        whether the user chooses 'list' (default) or 'array' as\n        the generate_type parameter.\n        \"\"\"\n        if generate_type == \"list\":\n            return list(self.generate(generate_type))\n        elif generate_type == \"array\":\n            return np.array(list(self.generate(generate_type)))\n        else:\n            raise Exception(\"generate_type must be of type list or array.\")\n\n    def n_points(self):\n        \"\"\"\n        The number of points corresponding to the number of vertices and\n        points per edge chosen by the user.\n        \"\"\"\n        return comb(\n            self.vertices + self.points_per_edge - 2, self.vertices - 1, exact=True\n        )",
  "class MaterialPolytope(object):\n    \"\"\"\n    A class that can be instantiated to create pycddlib polytope objects.\n    These objects can be interrogated to provide the vertices satisfying the\n    input constraints.\n\n    This class is available as :class:`burnman.polytope.MaterialPolytope`.\n    \"\"\"\n\n    def __init__(\n        self,\n        equalities,\n        inequalities,\n        number_type=\"fraction\",\n        return_fractions=False,\n        independent_endmember_occupancies=None,\n    ):\n        \"\"\"\n        Initialization function for the MaterialPolytope class.\n        Declares basis attributes of the class.\n\n        :param equalities: A numpy array containing all the\n            equalities defining the polytope. Each row should evaluate to 0.\n        :type equalities: numpy.array (2D)\n        :param inequalities: A numpy array containing all the inequalities\n            defining the polytope. Each row should evaluate to <= 0.\n        :type inequalities: numpy.array (2D)\n        :param number_type: Whether pycddlib should read the input arrays as\n            fractions or floats. Valid options are 'fraction' or 'float'.\n        :type number_type: str\n        :param return_fractions: Choose whether the generated polytope object\n            should return fractions or floats.\n        :type return_fractions: bool\n        :param independent_endmember_occupancies: If specified, this array provides\n            the independent endmember set against which the dependent endmembers\n            are defined.\n        :type independent_endmember_occupancies: numpy.array (2D) or None\n        \"\"\"\n        self.set_return_type(return_fractions)\n        self.equality_matrix = equalities[:, 1:]\n        self.equality_vector = -equalities[:, 0]\n\n        self.polytope_matrix = cdd.Matrix(\n            equalities, linear=True, number_type=number_type\n        )\n        self.polytope_matrix.rep_type = cdd.RepType.INEQUALITY\n        self.polytope_matrix.extend(inequalities, linear=False)\n        self.polytope = cdd.Polyhedron(self.polytope_matrix)\n\n        if independent_endmember_occupancies is not None:\n            self.independent_endmember_occupancies = independent_endmember_occupancies\n\n    def set_return_type(self, return_fractions=False):\n        \"\"\"\n        Sets the return_type for the polytope object. Also deletes the cached\n        endmember_occupancies property.\n\n        :param return_fractions: Choose whether the generated polytope object\n            should return fractions or floats.\n        :type return_fractions: bool\n        \"\"\"\n        try:\n            del self.__dict__[\"endmember_occupancies\"]\n        except KeyError:\n            pass\n        self.return_fractions = return_fractions\n\n    @cached_property\n    def raw_vertices(self):\n        \"\"\"\n        Returns a list of the vertices of the polytope without any\n        postprocessing. See also endmember_occupancies.\n        \"\"\"\n        return self.polytope.get_generators()[:]\n\n    @cached_property\n    def limits(self):\n        \"\"\"\n        Return the limits of the polytope (the set of bounding inequalities).\n        \"\"\"\n        return np.array(self.polytope.get_inequalities(), dtype=float)\n\n    @cached_property\n    def n_endmembers(self):\n        \"\"\"\n        Return the number of endmembers\n        (the number of vertices of the polytope).\n        \"\"\"\n        return len(self.raw_vertices)\n\n    @cached_property\n    def endmember_occupancies(self):\n        \"\"\"\n        Return the endmember occupancies\n        (a processed list of all of the vertex locations).\n        \"\"\"\n        if self.return_fractions:\n            if self.polytope.number_type == \"fraction\":\n                v = np.array(\n                    [[Fraction(value) for value in v] for v in self.raw_vertices]\n                )\n            else:\n                v = np.array(\n                    [\n                        [Rational(value).limit_denominator(1000000) for value in v]\n                        for v in self.raw_vertices\n                    ]\n                )\n        else:\n            v = np.array([[float(value) for value in v] for v in self.raw_vertices])\n\n        if len(v.shape) == 1:\n            raise ValueError(\n                \"The combined equality and positivity \"\n                \"constraints result in a null polytope.\"\n            )\n\n        return v[:, 1:] / v[:, 0, np.newaxis]\n\n    @cached_property\n    def independent_endmember_occupancies(self):\n        \"\"\"\n        Return an independent set of endmember occupancies\n        (a linearly-independent set of vertex locations)\n        \"\"\"\n        arr = self.endmember_occupancies\n        return arr[independent_row_indices(arr)]\n\n    @cached_property\n    def endmembers_as_independent_endmember_amounts(self):\n        \"\"\"\n        Return a list of all the endmembers as a linear sum of\n        the independent endmembers.\n        \"\"\"\n        ind = self.independent_endmember_occupancies\n\n        sol = (\n            np.linalg.lstsq(\n                np.array(ind.T).astype(float),\n                np.array(self.endmember_occupancies.T).astype(float),\n                rcond=0,\n            )[0]\n            .round(decimals=12)\n            .T\n        )\n        return sol\n\n    def _decompose_vertices_into_simplices(self, vertices):\n        \"\"\"\n        Decomposes a set of vertices into simplices by Delaunay triangulation.\n        \"\"\"\n        # Delaunay triangulation only works in dimensions > 1\n        # and we remove the nullspace (sum(fractions) = 1)\n        if len(vertices) > 2:\n            nulls = np.repeat(vertices[:, -1], vertices.shape[1]).reshape(\n                vertices.shape\n            )\n            tri = Delaunay((vertices - nulls)[:, :-1])\n            return tri.simplices\n        else:\n            return [[0, 1]]\n\n    @cached_property\n    def independent_endmember_polytope(self):\n        \"\"\"\n        Returns the polytope expressed in terms of proportions of the\n        independent endmembers. The polytope involves the first\n        n-1 independent endmembers. The last endmember proportion makes\n        the sum equal to one.\n        \"\"\"\n        arr = self.endmembers_as_independent_endmember_amounts\n        arr = np.hstack((np.ones((len(arr), 1)), arr[:, :-1]))\n        M = cdd.Matrix(arr, number_type=\"fraction\")\n        M.rep_type = cdd.RepType.GENERATOR\n        return cdd.Polyhedron(M)\n\n    @cached_property\n    def independent_endmember_limits(self):\n        \"\"\"\n        Gets the limits of the polytope as a function of the independent\n        endmembers.\n        \"\"\"\n        return np.array(\n            self.independent_endmember_polytope.get_inequalities(), dtype=float\n        )\n\n    def subpolytope_from_independent_endmember_limits(self, limits):\n        \"\"\"\n        Returns a smaller polytope by applying additional limits to the amounts\n        of the independent endmembers.\n        \"\"\"\n        modified_limits = self.independent_endmember_polytope.get_inequalities().copy()\n        modified_limits.extend(limits, linear=False)\n        return cdd.Polyhedron(modified_limits)\n\n    def subpolytope_from_site_occupancy_limits(self, limits):\n        \"\"\"\n        Returns a smaller polytope by applying additional limits to the\n        individual site occupancies.\n        \"\"\"\n        modified_limits = self.polytope_matrix.copy()\n        modified_limits.extend(limits, linear=False)\n        return cdd.Polyhedron(modified_limits)\n\n    def grid(\n        self,\n        points_per_edge=2,\n        unique_sorted=True,\n        grid_type=\"independent endmember proportions\",\n        limits=None,\n    ):\n        \"\"\"\n        Create a grid of points which span the polytope.\n\n        :param points_per_edge: Number of points per edge of the polytope.\n        :type points_per_edge: int\n        :param unique_sorted: The gridding is done by splitting the polytope into\n            a set of simplices. This means that points will be duplicated along\n            vertices, faces etc. If unique_sorted is True, this function\n            will sort and make the points unique. This is an expensive\n            operation for large polytopes, and may not always be necessary.\n        :type unique_sorted: bool\n        :param grid_type: Whether to grid the polytope in terms of\n            independent endmember proportions or site occupancies.\n            Choices are 'independent endmember proportions' or 'site occupancies'\n        :type grid_type: str\n        :param limits: Additional inequalities restricting the\n            gridded area of the polytope.\n        :type limits: numpy.array (2D)\n\n        :returns: A list of points gridding the polytope.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        if limits is None:\n            if grid_type == \"independent endmember proportions\":\n                f_occ = self.endmembers_as_independent_endmember_amounts / (\n                    points_per_edge - 1\n                )\n            elif grid_type == \"site occupancies\":\n                f_occ = self.endmember_occupancies / (points_per_edge - 1)\n            else:\n                raise Exception(\n                    \"grid type not recognised. Should be one of \"\n                    \"independent endmember proportions \"\n                    \"or site occupancies\"\n                )\n\n            simplices = self._decompose_vertices_into_simplices(\n                self.endmembers_as_independent_endmember_amounts\n            )\n        else:\n            if grid_type == \"independent endmember proportions\":\n                ppns = np.array(\n                    self.subpolytope_from_independent_endmember_limits(\n                        limits\n                    ).get_generators()[:]\n                )[:, 1:]\n                last_ppn = np.array([1.0 - sum(p) for p in ppns]).reshape(\n                    (len(ppns), 1)\n                )\n                vertices_as_independent_endmember_proportions = np.hstack(\n                    (ppns, last_ppn)\n                )\n                f_occ = vertices_as_independent_endmember_proportions / (\n                    points_per_edge - 1\n                )\n\n            elif grid_type == \"site occupancies\":\n                occ = np.array(\n                    self.subpolytope_from_site_occupancy_limits(\n                        limits\n                    ).get_generators()[:]\n                )[:, 1:]\n                f_occ = occ / (points_per_edge - 1)\n\n                ind = self.independent_endmember_occupancies\n\n                vertices_as_independent_endmember_proportions = (\n                    np.linalg.lstsq(\n                        np.array(ind.T).astype(float),\n                        np.array(occ.T).astype(float),\n                        rcond=None,\n                    )[0]\n                    .round(decimals=12)\n                    .T\n                )\n            else:\n                raise Exception(\n                    \"grid_type not recognised. \"\n                    \"Should be one of \"\n                    \"independent endmember proportions \"\n                    \"or site occupancies\"\n                )\n\n            simplices = self._decompose_vertices_into_simplices(\n                vertices_as_independent_endmember_proportions\n            )\n\n        n_ind = f_occ.shape[1]\n        n_simplices = len(simplices)\n        dim = len(simplices[0])\n        simplex_grid = SimplexGrid(dim, points_per_edge)\n        grid = simplex_grid.grid(\"array\")\n        points_per_simplex = simplex_grid.n_points()\n        n_points = n_simplices * points_per_simplex\n\n        points = np.empty((n_points, n_ind))\n        idx = 0\n        for i in range(0, n_simplices):\n            points[idx : idx + points_per_simplex] = grid.dot(f_occ[simplices[i]])\n            idx += points_per_simplex\n\n        if unique_sorted:\n            points = np.unique(points, axis=0)\n        return points",
  "def __init__(self, vertices, points_per_edge):\n        \"\"\"\n        Initialize SimplexGrid object with the desired number of vertices\n        and points per edge.\n        \"\"\"\n        assert vertices >= 2, \"need at least two vertices\"\n        assert points_per_edge >= 2, \"need at least 2 points per edge\"\n\n        self.vertices = vertices\n        self.points_per_edge = points_per_edge",
  "def generate(self, generate_type=\"list\"):\n        \"\"\"\n        Generates the grid points of the simplex in lexicographic order.\n\n        :param generate_type: Determines whether the generator returns\n            lists or arrays corresponding to each point in the simplex grid.\n            Valid options are 'list' or 'array'.\n        :type generate_type: str\n\n        :returns: Grid points of the simplex.\n        :rtype: generator of lists or ndarrays (int, ndim=1)\n        \"\"\"\n\n        if generate_type == \"list\":\n            x = [0] * self.vertices\n        elif generate_type == \"array\":\n            x = np.zeros(self.vertices, dtype=int)\n        else:\n            raise Exception(\"generate_type must be of type list or array.\")\n\n        x[self.vertices - 1] = self.points_per_edge - 1\n\n        h = self.vertices\n        while True:\n            yield copy(x)\n\n            h -= 1\n            if h == 0:\n                return\n\n            val = x[h]\n            x[h] = 0\n            x[self.vertices - 1] = val - 1\n            x[h - 1] += 1\n            if val != 1:\n                h = self.vertices",
  "def grid(self, generate_type=\"list\"):\n        \"\"\"\n        Returns either a list or a numpy array\n        corresponding the the points in the simplex grid, depending on\n        whether the user chooses 'list' (default) or 'array' as\n        the generate_type parameter.\n        \"\"\"\n        if generate_type == \"list\":\n            return list(self.generate(generate_type))\n        elif generate_type == \"array\":\n            return np.array(list(self.generate(generate_type)))\n        else:\n            raise Exception(\"generate_type must be of type list or array.\")",
  "def n_points(self):\n        \"\"\"\n        The number of points corresponding to the number of vertices and\n        points per edge chosen by the user.\n        \"\"\"\n        return comb(\n            self.vertices + self.points_per_edge - 2, self.vertices - 1, exact=True\n        )",
  "def __init__(\n        self,\n        equalities,\n        inequalities,\n        number_type=\"fraction\",\n        return_fractions=False,\n        independent_endmember_occupancies=None,\n    ):\n        \"\"\"\n        Initialization function for the MaterialPolytope class.\n        Declares basis attributes of the class.\n\n        :param equalities: A numpy array containing all the\n            equalities defining the polytope. Each row should evaluate to 0.\n        :type equalities: numpy.array (2D)\n        :param inequalities: A numpy array containing all the inequalities\n            defining the polytope. Each row should evaluate to <= 0.\n        :type inequalities: numpy.array (2D)\n        :param number_type: Whether pycddlib should read the input arrays as\n            fractions or floats. Valid options are 'fraction' or 'float'.\n        :type number_type: str\n        :param return_fractions: Choose whether the generated polytope object\n            should return fractions or floats.\n        :type return_fractions: bool\n        :param independent_endmember_occupancies: If specified, this array provides\n            the independent endmember set against which the dependent endmembers\n            are defined.\n        :type independent_endmember_occupancies: numpy.array (2D) or None\n        \"\"\"\n        self.set_return_type(return_fractions)\n        self.equality_matrix = equalities[:, 1:]\n        self.equality_vector = -equalities[:, 0]\n\n        self.polytope_matrix = cdd.Matrix(\n            equalities, linear=True, number_type=number_type\n        )\n        self.polytope_matrix.rep_type = cdd.RepType.INEQUALITY\n        self.polytope_matrix.extend(inequalities, linear=False)\n        self.polytope = cdd.Polyhedron(self.polytope_matrix)\n\n        if independent_endmember_occupancies is not None:\n            self.independent_endmember_occupancies = independent_endmember_occupancies",
  "def set_return_type(self, return_fractions=False):\n        \"\"\"\n        Sets the return_type for the polytope object. Also deletes the cached\n        endmember_occupancies property.\n\n        :param return_fractions: Choose whether the generated polytope object\n            should return fractions or floats.\n        :type return_fractions: bool\n        \"\"\"\n        try:\n            del self.__dict__[\"endmember_occupancies\"]\n        except KeyError:\n            pass\n        self.return_fractions = return_fractions",
  "def raw_vertices(self):\n        \"\"\"\n        Returns a list of the vertices of the polytope without any\n        postprocessing. See also endmember_occupancies.\n        \"\"\"\n        return self.polytope.get_generators()[:]",
  "def limits(self):\n        \"\"\"\n        Return the limits of the polytope (the set of bounding inequalities).\n        \"\"\"\n        return np.array(self.polytope.get_inequalities(), dtype=float)",
  "def n_endmembers(self):\n        \"\"\"\n        Return the number of endmembers\n        (the number of vertices of the polytope).\n        \"\"\"\n        return len(self.raw_vertices)",
  "def endmember_occupancies(self):\n        \"\"\"\n        Return the endmember occupancies\n        (a processed list of all of the vertex locations).\n        \"\"\"\n        if self.return_fractions:\n            if self.polytope.number_type == \"fraction\":\n                v = np.array(\n                    [[Fraction(value) for value in v] for v in self.raw_vertices]\n                )\n            else:\n                v = np.array(\n                    [\n                        [Rational(value).limit_denominator(1000000) for value in v]\n                        for v in self.raw_vertices\n                    ]\n                )\n        else:\n            v = np.array([[float(value) for value in v] for v in self.raw_vertices])\n\n        if len(v.shape) == 1:\n            raise ValueError(\n                \"The combined equality and positivity \"\n                \"constraints result in a null polytope.\"\n            )\n\n        return v[:, 1:] / v[:, 0, np.newaxis]",
  "def independent_endmember_occupancies(self):\n        \"\"\"\n        Return an independent set of endmember occupancies\n        (a linearly-independent set of vertex locations)\n        \"\"\"\n        arr = self.endmember_occupancies\n        return arr[independent_row_indices(arr)]",
  "def endmembers_as_independent_endmember_amounts(self):\n        \"\"\"\n        Return a list of all the endmembers as a linear sum of\n        the independent endmembers.\n        \"\"\"\n        ind = self.independent_endmember_occupancies\n\n        sol = (\n            np.linalg.lstsq(\n                np.array(ind.T).astype(float),\n                np.array(self.endmember_occupancies.T).astype(float),\n                rcond=0,\n            )[0]\n            .round(decimals=12)\n            .T\n        )\n        return sol",
  "def _decompose_vertices_into_simplices(self, vertices):\n        \"\"\"\n        Decomposes a set of vertices into simplices by Delaunay triangulation.\n        \"\"\"\n        # Delaunay triangulation only works in dimensions > 1\n        # and we remove the nullspace (sum(fractions) = 1)\n        if len(vertices) > 2:\n            nulls = np.repeat(vertices[:, -1], vertices.shape[1]).reshape(\n                vertices.shape\n            )\n            tri = Delaunay((vertices - nulls)[:, :-1])\n            return tri.simplices\n        else:\n            return [[0, 1]]",
  "def independent_endmember_polytope(self):\n        \"\"\"\n        Returns the polytope expressed in terms of proportions of the\n        independent endmembers. The polytope involves the first\n        n-1 independent endmembers. The last endmember proportion makes\n        the sum equal to one.\n        \"\"\"\n        arr = self.endmembers_as_independent_endmember_amounts\n        arr = np.hstack((np.ones((len(arr), 1)), arr[:, :-1]))\n        M = cdd.Matrix(arr, number_type=\"fraction\")\n        M.rep_type = cdd.RepType.GENERATOR\n        return cdd.Polyhedron(M)",
  "def independent_endmember_limits(self):\n        \"\"\"\n        Gets the limits of the polytope as a function of the independent\n        endmembers.\n        \"\"\"\n        return np.array(\n            self.independent_endmember_polytope.get_inequalities(), dtype=float\n        )",
  "def subpolytope_from_independent_endmember_limits(self, limits):\n        \"\"\"\n        Returns a smaller polytope by applying additional limits to the amounts\n        of the independent endmembers.\n        \"\"\"\n        modified_limits = self.independent_endmember_polytope.get_inequalities().copy()\n        modified_limits.extend(limits, linear=False)\n        return cdd.Polyhedron(modified_limits)",
  "def subpolytope_from_site_occupancy_limits(self, limits):\n        \"\"\"\n        Returns a smaller polytope by applying additional limits to the\n        individual site occupancies.\n        \"\"\"\n        modified_limits = self.polytope_matrix.copy()\n        modified_limits.extend(limits, linear=False)\n        return cdd.Polyhedron(modified_limits)",
  "def grid(\n        self,\n        points_per_edge=2,\n        unique_sorted=True,\n        grid_type=\"independent endmember proportions\",\n        limits=None,\n    ):\n        \"\"\"\n        Create a grid of points which span the polytope.\n\n        :param points_per_edge: Number of points per edge of the polytope.\n        :type points_per_edge: int\n        :param unique_sorted: The gridding is done by splitting the polytope into\n            a set of simplices. This means that points will be duplicated along\n            vertices, faces etc. If unique_sorted is True, this function\n            will sort and make the points unique. This is an expensive\n            operation for large polytopes, and may not always be necessary.\n        :type unique_sorted: bool\n        :param grid_type: Whether to grid the polytope in terms of\n            independent endmember proportions or site occupancies.\n            Choices are 'independent endmember proportions' or 'site occupancies'\n        :type grid_type: str\n        :param limits: Additional inequalities restricting the\n            gridded area of the polytope.\n        :type limits: numpy.array (2D)\n\n        :returns: A list of points gridding the polytope.\n        :rtype: numpy.array (2D)\n        \"\"\"\n        if limits is None:\n            if grid_type == \"independent endmember proportions\":\n                f_occ = self.endmembers_as_independent_endmember_amounts / (\n                    points_per_edge - 1\n                )\n            elif grid_type == \"site occupancies\":\n                f_occ = self.endmember_occupancies / (points_per_edge - 1)\n            else:\n                raise Exception(\n                    \"grid type not recognised. Should be one of \"\n                    \"independent endmember proportions \"\n                    \"or site occupancies\"\n                )\n\n            simplices = self._decompose_vertices_into_simplices(\n                self.endmembers_as_independent_endmember_amounts\n            )\n        else:\n            if grid_type == \"independent endmember proportions\":\n                ppns = np.array(\n                    self.subpolytope_from_independent_endmember_limits(\n                        limits\n                    ).get_generators()[:]\n                )[:, 1:]\n                last_ppn = np.array([1.0 - sum(p) for p in ppns]).reshape(\n                    (len(ppns), 1)\n                )\n                vertices_as_independent_endmember_proportions = np.hstack(\n                    (ppns, last_ppn)\n                )\n                f_occ = vertices_as_independent_endmember_proportions / (\n                    points_per_edge - 1\n                )\n\n            elif grid_type == \"site occupancies\":\n                occ = np.array(\n                    self.subpolytope_from_site_occupancy_limits(\n                        limits\n                    ).get_generators()[:]\n                )[:, 1:]\n                f_occ = occ / (points_per_edge - 1)\n\n                ind = self.independent_endmember_occupancies\n\n                vertices_as_independent_endmember_proportions = (\n                    np.linalg.lstsq(\n                        np.array(ind.T).astype(float),\n                        np.array(occ.T).astype(float),\n                        rcond=None,\n                    )[0]\n                    .round(decimals=12)\n                    .T\n                )\n            else:\n                raise Exception(\n                    \"grid_type not recognised. \"\n                    \"Should be one of \"\n                    \"independent endmember proportions \"\n                    \"or site occupancies\"\n                )\n\n            simplices = self._decompose_vertices_into_simplices(\n                vertices_as_independent_endmember_proportions\n            )\n\n        n_ind = f_occ.shape[1]\n        n_simplices = len(simplices)\n        dim = len(simplices[0])\n        simplex_grid = SimplexGrid(dim, points_per_edge)\n        grid = simplex_grid.grid(\"array\")\n        points_per_simplex = simplex_grid.n_points()\n        n_points = n_simplices * points_per_simplex\n\n        points = np.empty((n_points, n_ind))\n        idx = 0\n        for i in range(0, n_simplices):\n            points[idx : idx + points_per_simplex] = grid.dot(f_occ[simplices[i]])\n            idx += points_per_simplex\n\n        if unique_sorted:\n            points = np.unique(points, axis=0)\n        return points",
  "def bulk_modulus_fourth(volume, params):\n    \"\"\"\n    compute the bulk modulus as per the fourth order\n    birch-murnaghan equation of state.  Returns bulk\n    modulus in the same units as the reference bulk\n    modulus.  Pressure must be in :math:`[Pa]`.\n    \"\"\"\n\n    x = params[\"V_0\"] / volume\n    f = 0.5 * (pow(x, 2.0 / 3.0) - 1.0)\n\n    Xi = (3.0 / 4.0) * (4.0 - params[\"Kprime_0\"])\n    Zeta = (3.0 / 8.0) * (\n        (params[\"K_0\"] * params[\"Kprime_prime_0\"])\n        + params[\"Kprime_0\"] * (params[\"Kprime_0\"] - 7.0)\n        + 143.0 / 9.0\n    )\n\n    K = (\n        5.0\n        * f\n        * pow((1.0 + 2.0 * f), 5.0 / 2.0)\n        * params[\"K_0\"]\n        * (1.0 - (2.0 * Xi * f) + (4.0 * Zeta * pow(f, 2.0)))\n    ) + (\n        pow(1.0 + (2.0 * f), 7.0 / 2.0)\n        * params[\"K_0\"]\n        * (1.0 - (4.0 * Xi * f) + (12.0 * Zeta * pow(f, 2.0)))\n    )\n\n    return K",
  "def volume_fourth_order(pressure, params):\n    func = lambda x: birch_murnaghan_fourth(params[\"V_0\"] / x, params) - pressure\n    try:\n        sol = bracket(func, params[\"V_0\"], 1.0e-2 * params[\"V_0\"])\n    except:\n        raise ValueError(\n            \"Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?\"\n        )\n    return opt.brentq(func, sol[0], sol[1])",
  "def birch_murnaghan_fourth(x, params):\n    \"\"\"\n    equation for the fourth order birch-murnaghan equation of state, returns\n    pressure in the same units that are supplied for the reference bulk\n    modulus (params['K_0'])\n    \"\"\"\n\n    f = 0.5 * (pow(x, 2.0 / 3.0) - 1.0)\n    Xi = (3.0 / 4.0) * (4.0 - params[\"Kprime_0\"])\n    Zeta = (3.0 / 8.0) * (\n        (params[\"K_0\"] * params[\"Kprime_prime_0\"])\n        + params[\"Kprime_0\"] * (params[\"Kprime_0\"] - 7.0)\n        + 143.0 / 9.0\n    )\n\n    return (\n        3.0\n        * f\n        * pow(1.0 + 2.0 * f, 5.0 / 2.0)\n        * params[\"K_0\"]\n        * (1.0 - (2.0 * Xi * f) + (4.0 * Zeta * pow(f, 2.0)))\n        + params[\"P_0\"]\n    )",
  "class BM4(eos.EquationOfState):\n\n    \"\"\"\n    Base class for the isothermal Birch Murnaghan equation of state.  This is fourth order in strain, and\n    has no temperature dependence.\n    \"\"\"\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume_fourth_order(pressure, params)\n\n    def pressure(self, temperature, volume, params):\n        return birch_murnaghan_fourth(volume / params[\"V_0\"], params)\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus_fourth(volume, params)\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus_fourth(volume, params)\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        \"\"\"\n        return 0.0\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        x = np.power(volume / params[\"V_0\"], -1.0 / 3.0)\n        x2 = x * x\n        x4 = x2 * x2\n        x6 = x4 * x2\n        x8 = x4 * x4\n\n        xi1 = 3.0 * (4.0 - params[\"Kprime_0\"]) / 4.0\n        xi2 = (\n            3.0\n            / 8.0\n            * (\n                params[\"K_0\"] * params[\"Kprime_prime_0\"]\n                + params[\"Kprime_0\"] * (params[\"Kprime_0\"] - 7.0)\n            )\n            + 143.0 / 24.0\n        )\n\n        intPdV = (\n            -9.0\n            / 2.0\n            * params[\"V_0\"]\n            * params[\"K_0\"]\n            * (\n                (xi1 + 1.0) * (x4 / 4.0 - x2 / 2.0 + 1.0 / 4.0)\n                - xi1 * (x6 / 6.0 - x4 / 4.0 + 1.0 / 12.0)\n                + xi2 * (x8 / 8 - x6 / 2 + 3.0 * x4 / 4.0 - x2 / 2.0 + 1.0 / 8.0)\n            )\n        )\n\n        return -intPdV + params[\"E_0\"]\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # G = int VdP = [PV] - int PdV = E + PV\n\n        return (\n            self.molar_internal_energy(pressure, temperature, volume, params)\n            + volume * pressure\n        )\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # If G and Gprime are not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)\n        if params[\"Kprime_prime_0\"] > 0.0 or params[\"Kprime_prime_0\"] < -10.0:\n            warnings.warn(\"Unusual value for Kprime_prime_0\", stacklevel=2)",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume_fourth_order(pressure, params)",
  "def pressure(self, temperature, volume, params):\n        return birch_murnaghan_fourth(volume / params[\"V_0\"], params)",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus_fourth(volume, params)",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus_fourth(volume, params)",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        \"\"\"\n        return 0.0",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        x = np.power(volume / params[\"V_0\"], -1.0 / 3.0)\n        x2 = x * x\n        x4 = x2 * x2\n        x6 = x4 * x2\n        x8 = x4 * x4\n\n        xi1 = 3.0 * (4.0 - params[\"Kprime_0\"]) / 4.0\n        xi2 = (\n            3.0\n            / 8.0\n            * (\n                params[\"K_0\"] * params[\"Kprime_prime_0\"]\n                + params[\"Kprime_0\"] * (params[\"Kprime_0\"] - 7.0)\n            )\n            + 143.0 / 24.0\n        )\n\n        intPdV = (\n            -9.0\n            / 2.0\n            * params[\"V_0\"]\n            * params[\"K_0\"]\n            * (\n                (xi1 + 1.0) * (x4 / 4.0 - x2 / 2.0 + 1.0 / 4.0)\n                - xi1 * (x6 / 6.0 - x4 / 4.0 + 1.0 / 12.0)\n                + xi2 * (x8 / 8 - x6 / 2 + 3.0 * x4 / 4.0 - x2 / 2.0 + 1.0 / 8.0)\n            )\n        )\n\n        return -intPdV + params[\"E_0\"]",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # G = int VdP = [PV] - int PdV = E + PV\n\n        return (\n            self.molar_internal_energy(pressure, temperature, volume, params)\n            + volume * pressure\n        )",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # If G and Gprime are not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)\n        if params[\"Kprime_prime_0\"] > 0.0 or params[\"Kprime_prime_0\"] < -10.0:\n            warnings.warn(\"Unusual value for Kprime_prime_0\", stacklevel=2)",
  "def bulk_modulus(volume, params):\n    \"\"\"\n    Compute the bulk modulus as per the Morse potential\n    equation of state.\n    Returns bulk modulus in the same units as\n    the reference bulk modulus.\n    Pressure must be in :math:`[Pa]`.\n    \"\"\"\n\n    VoverV0 = volume / params[\"V_0\"]\n    x = (params[\"Kprime_0\"] - 1.0) * (1.0 - np.power(VoverV0, 1.0 / 3.0))\n    K = params[\"K_0\"] * (\n        (\n            2.0\n            / (params[\"Kprime_0\"] - 1.0)\n            * np.power(VoverV0, -2.0 / 3.0)\n            * (np.exp(2.0 * x) - np.exp(x))\n        )\n        + (np.power(VoverV0, -1.0 / 3.0) * (2.0 * np.exp(2.0 * x) - np.exp(x)))\n    )\n    return K",
  "def shear_modulus(volume, params):\n    \"\"\"\n    Shear modulus not currently implemented for this equation of state\n    \"\"\"\n    return 0.0",
  "def morse_potential(VoverV0, params):\n    \"\"\"\n    Equation for the Morse Potential equation of state,\n    returns pressure in the same units that are supplied\n    for the reference bulk modulus (params['K_0'])\n    \"\"\"\n    x = (params[\"Kprime_0\"] - 1.0) * (1.0 - np.power(VoverV0, 1.0 / 3.0))\n    return (\n        3.0\n        * params[\"K_0\"]\n        / (params[\"Kprime_0\"] - 1.0)\n        * np.power(VoverV0, -2.0 / 3.0)\n        * (np.exp(2.0 * x) - np.exp(x))\n    ) + params[\"P_0\"]",
  "def volume(pressure, params):\n    \"\"\"\n    Get the Morse Potential volume at a\n    reference temperature for a given pressure :math:`[Pa]`.\n    Returns molar volume in :math:`[m^3]`\n    \"\"\"\n    func = lambda V: morse_potential(V / params[\"V_0\"], params) - pressure\n    try:\n        sol = bracket(func, params[\"V_0\"], 1.0e-2 * params[\"V_0\"])\n    except:\n        raise ValueError(\n            \"Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?\"\n        )\n    return opt.brentq(func, sol[0], sol[1])",
  "class Morse(eos.EquationOfState):\n\n    \"\"\"\n    Class for the isothermal Morse Potential equation of state\n    detailed in :cite:`Stacey1981`.\n    This equation of state has no temperature dependence.\n    \"\"\"\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume(pressure, params)\n\n    def pressure(self, temperature, volume, params):\n        return morse_potential(volume / params[\"V_0\"], params)\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus(volume, params)\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(volume, params)\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        \"\"\"\n        return shear_modulus(volume, params)\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n\n        x = (params[\"Kprime_0\"] - 1) * (1 - np.power(volume / params[\"V_0\"], 1.0 / 3.0))\n        intPdV = (\n            9.0\n            / 2.0\n            * params[\"V_0\"]\n            * params[\"K_0\"]\n            / np.power(params[\"Kprime_0\"] - 1.0, 2.0)\n            * (2.0 * np.exp(x) - np.exp(2.0 * x) - 1.0)\n        )\n\n        return -intPdV + params[\"E_0\"]\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        return (\n            self.molar_internal_energy(pressure, temperature, volume, params)\n            + volume * pressure\n        )\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # If G and Gprime are not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\", \"G_0\", \"Gprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)\n        if params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume(pressure, params)",
  "def pressure(self, temperature, volume, params):\n        return morse_potential(volume / params[\"V_0\"], params)",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus(volume, params)",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(volume, params)",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        \"\"\"\n        return shear_modulus(volume, params)",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n\n        x = (params[\"Kprime_0\"] - 1) * (1 - np.power(volume / params[\"V_0\"], 1.0 / 3.0))\n        intPdV = (\n            9.0\n            / 2.0\n            * params[\"V_0\"]\n            * params[\"K_0\"]\n            / np.power(params[\"Kprime_0\"] - 1.0, 2.0)\n            * (2.0 * np.exp(x) - np.exp(2.0 * x) - 1.0)\n        )\n\n        return -intPdV + params[\"E_0\"]",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        return (\n            self.molar_internal_energy(pressure, temperature, volume, params)\n            + volume * pressure\n        )",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # If G and Gprime are not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\", \"G_0\", \"Gprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)\n        if params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)",
  "class AA(eos.EquationOfState):\n    \"\"\"\n    Class for the :math`E-V-S` liquid metal EOS detailed in :cite:`AA1994`.\n    Internal energy (:math:`E`) is first calculated\n    along a reference isentrope using a fourth order BM EoS\n    (:math:`V_0`, :math:`KS`, :math:`KS'`, :math:`KS''`),\n    which gives volume as a function of pressure,\n    coupled with the thermodynamic identity:\n\n    :math:`-\\partial E/ \\partial V |_S = P`.\n\n    The temperature along the isentrope is calculated via\n\n    :math:`\\partial (\\ln T)/\\partial (\\ln \\\\rho) |_S = \\gamma`\n\n    which gives:\n\n    :math:`T_S/T_0 = \\exp(\\int( \\gamma/\\\\rho ) d \\\\rho)`\n\n    The thermal effect on internal energy is calculated at constant volume\n    using expressions for the kinetic, electronic and potential contributions\n    to the volumetric heat capacity, which can then be integrated with respect\n    to temperature:\n\n    :math:`\\partial E/\\partial T |_V = C_V`\n\n    :math:`\\partial E/\\partial S |_V = T`\n\n    We note that :cite:`AA1994` also include a detailed description\n    of the Gruneisen parameter as a function of volume and energy (Equation 15),\n    and use this to determine the temperature along the principal isentrope\n    (Equations B1-B10) and the thermal pressure away from that isentrope\n    (Equation 23). However, this expression is inconsistent with\n    the equation of state away from the principal isentrope. Here we choose\n    to calculate the thermal pressure and Grueneisen parameter thus:\n\n    1) As energy and entropy are defined by the equation of state at any\n    temperature and volume, pressure can be found by via the expression:\n\n    :math:`\\partial E/\\partial V |_S = P`\n\n    2) The Grueneisen parameter can now be determined as\n    :math:`\\gamma = V \\partial P/\\partial E |_V`\n\n    To reiterate: away from the reference isentrope, the Grueneisen parameter\n    calculated using these expressions is *not* equal to the\n    (thermodynamically inconsistent) analytical expression given by :cite:`AA1994`.\n\n    A final note: the expression for :math:`\\Lambda` (Equation 17).\n    does not reproduce Figure 5. We assume here that the figure matches the model\n    actually used by :cite:`AA1994`, which has the form:\n    :math:`F(-325.23 + 302.07 (\\\\rho/\\\\rho_0) + 30.45 (\\\\rho/\\\\rho_0)^{0.4})`.\n    \"\"\"\n\n    def _ABTheta(self, V, params):\n        \"\"\"\n        Electronic heat capacity functions\n        \"\"\"\n        Vfrac = V / params[\"V_0\"]\n\n        A = params[\"a\"][0] + params[\"a\"][1] * Vfrac  # A2\n        B = params[\"b\"][0] + params[\"b\"][1] * Vfrac * Vfrac  # A3\n        Theta = params[\"Theta\"][0] * np.power(Vfrac, -params[\"Theta\"][1])  # A4\n\n        return A, B, Theta\n\n    def _lambdaxi(self, V, params):\n        \"\"\"\n        Potential heat capacity functions\n        \"\"\"\n        rhofrac = params[\"V_0\"] / V\n        xi = params[\"xi_0\"] * np.power(rhofrac, -0.6)  # A16\n        F = 1.0 / (1.0 + np.exp((rhofrac - params[\"F\"][0]) / params[\"F\"][1]))  # A18\n        # lmda = (F*(params['lmda'][0] + params['lmda'][1]*rhofrac) + params['lmda'][2])*np.power(rhofrac, 0.4) # A17\n        lmda = F * (\n            params[\"lmda\"][0]\n            + params[\"lmda\"][1] * rhofrac\n            + params[\"lmda\"][2] * np.power(rhofrac, 0.4)\n        )  # this incorrect expression for lmda seems to provide a very close fit to figure 5\n\n        return lmda, xi\n\n    def _rhofracxksis(self, V, params):\n        \"\"\"\n        Functions for the fourth order Birch-Murnaghan equation of state\n        \"\"\"\n        rhofrac = params[\"V_0\"] / V  # rho/rho0 = V0/V\n        x = np.power(rhofrac, 1.0 / 3.0)  # equation 18\n        ksi1 = 0.75 * (4.0 - params[\"Kprime_S\"])  # equation 19\n        ksi2 = (\n            0.375\n            * (\n                params[\"K_S\"] * params[\"Kprime_prime_S\"]\n                + params[\"Kprime_S\"] * (params[\"Kprime_S\"] - 7.0)\n            )\n            + 143.0 / 24.0\n        )  # equation 20\n        return rhofrac, x, ksi1, ksi2\n\n    def _isentropic_temperature(self, V, params):\n        \"\"\"\n        Temperature along the reference isentrope\n        \"\"\"\n\n        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)\n\n        # equation B6 -- B10\n        a1 = ksi2 / 8.0\n        a2 = (ksi1 + 3.0 * ksi2) / 6.0\n        a3 = (1.0 + 2.0 * ksi1 + 3.0 * ksi2) / 4.0\n        a4 = (1.0 + ksi1 + ksi2) / 2.0\n        a5 = (6.0 + 4.0 * ksi1 + 3.0 * ksi2) / 24.0\n\n        # equation B5\n        Ts = params[\"T_0\"] * np.exp(\n            params[\"grueneisen_0\"] * np.log(rhofrac)\n            + 13.5\n            * params[\"grueneisen_prime\"]\n            * params[\"V_0\"]\n            * params[\"K_S\"]\n            * (\n                (a1 / (3 * params[\"grueneisen_n\"] + 8.0))\n                * (np.power(x, (3 * params[\"grueneisen_n\"] + 8.0)) - 1.0)\n                - (a2 / (3 * params[\"grueneisen_n\"] + 6.0))\n                * (np.power(x, (3 * params[\"grueneisen_n\"] + 6.0)) - 1.0)\n                + (a3 / (3 * params[\"grueneisen_n\"] + 4.0))\n                * (np.power(x, (3 * params[\"grueneisen_n\"] + 4.0)) - 1.0)\n                - (a4 / (3 * params[\"grueneisen_n\"] + 2.0))\n                * (np.power(x, (3 * params[\"grueneisen_n\"] + 2.0)) - 1.0)\n                + (a5 / (3 * params[\"grueneisen_n\"] + 0.0))\n                * (np.power(x, (3 * params[\"grueneisen_n\"] + 0.0)) - 1.0)\n            )\n        )\n\n        return Ts\n\n    def _isentropic_pressure(self, V, params):\n        \"\"\"\n        Pressure along the reference isentrope\n        \"\"\"\n        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)\n        x2 = x * x\n        x3 = x * x * x\n        x5 = x3 * x2\n        x7 = x5 * x2\n\n        Ps = (\n            1.5\n            * params[\"K_S\"]\n            * (x7 - x5)\n            * (1.0 + ksi1 - ksi1 * x2 + ksi2 * (x2 - 1.0) * (x2 - 1.0))\n        )  # Eq. 17\n\n        return Ps\n\n    def _isentropic_energy_change(self, V, params):\n        \"\"\"\n        Birch Murnaghan equation of state expression for the energy change along an isentrope\n        \"\"\"\n        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)\n        x2 = x * x\n        x4 = x2 * x2\n        x6 = x4 * x2\n        x8 = x4 * x4\n\n        E_S = (\n            4.5\n            * params[\"V_0\"]\n            * params[\"K_S\"]\n            * (\n                (ksi1 + 1.0) * (x4 / 4.0 - x2 / 2.0 + 1.0 / 4.0)\n                - ksi1 * (x6 / 6.0 - x4 / 4.0 + 1.0 / 12.0)\n                + ksi2 * (x8 / 8.0 - x6 / 2.0 + 3.0 * x4 / 4.0 - x2 / 2.0 + 1.0 / 8.0)\n            )\n        )  # Eq. 21\n        return E_S\n\n    def _isochoric_energy_change(self, Ts, T, V, params):\n        \"\"\"\n        int Cv dT\n        \"\"\"\n        A, B, Theta = self._ABTheta(V, params)\n        lmda, xi = self._lambdaxi(V, params)\n\n        E_kin = 1.5 * params[\"n\"] * gas_constant * (T - Ts)\n        E_el = A * (\n            T - Ts - Theta * (np.arctan(T / Theta) - np.arctan(Ts / Theta))\n        ) + 5.0 / 8 * B * (\n            np.power(T, 1.6) - np.power(Ts, 1.6)\n        )  # A5\n        E_pot = lmda * (T - Ts) + params[\"theta\"] * (xi - lmda) * np.log(\n            (params[\"theta\"] + T) / (params[\"theta\"] + Ts)\n        )  # A19\n\n        return E_kin + E_el + E_pot\n\n    def volume_dependent_q(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`q`, the isotropic volume strain\n        derivative of the grueneisen parameter.\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def _isotropic_eta_s(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`eta_{s0}`, the isotropic shear\n        strain derivative of the grueneisen parameter.\n        Zero for a liquid\n        \"\"\"\n        return 0.0\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns molar volume. :math:`[m^3]`\n        \"\"\"\n\n        _volume = lambda V, P, T, params: (P - self.pressure(T, V, params))\n\n        return brentq(\n            _volume,\n            params[\"V_0\"] * 0.1,\n            params[\"V_0\"] * 2.0,\n            args=(pressure, temperature, params),\n        )\n\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns the pressure of the mineral at a given temperature and volume [Pa]\n        \"\"\"\n\n        \"\"\"\n        Ts = self._isentropic_temperature(volume, params)\n\n\n        dE = self._isochoric_energy_change(Ts, temperature, volume, params)\n        E1 = self._isentropic_energy_change(volume, params) - params['E_0']\n        E2 = E1 + dE\n\n        # Integrate at constant volume (V \\int dP = \\int gr dE)\n        dP = (params['grueneisen_0']*(E2 - E1) +\n              (0.5*params['grueneisen_prime'] *\n               np.power(params['V_0']/volume, params['grueneisen_n']) *\n               (E2*E2 - E1*E1))) / volume # eq. 23\n\n        P = self._isentropic_pressure(volume, params) + dP\n        \"\"\"\n\n        dV = volume * 1.0e-4\n        S = self.entropy(0.0, temperature, volume, params)\n\n        delta_S = lambda T, S, V: S - self.entropy(0.0, T, V, params)\n\n        T0 = brentq(\n            delta_S, temperature * 0.97, temperature * 1.03, args=(S, volume - 0.5 * dV)\n        )\n        T1 = brentq(\n            delta_S, temperature * 0.97, temperature * 1.03, args=(S, volume + 0.5 * dV)\n        )\n\n        E0 = self.molar_internal_energy(0.0, T0, volume - 0.5 * dV, params)\n        E1 = self.molar_internal_energy(0.0, T1, volume + 0.5 * dV, params)\n\n        P = -(E1 - E0) / dV  # |S\n\n        return P\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter :math:`[unitless]`\n        \"\"\"\n        \"\"\"\n        gr = (params['grueneisen_0'] +\n              params['grueneisen_prime'] *\n              (np.power(params['V_0']/volume, params['grueneisen_n']) *\n               (self.molar_internal_energy(pressure, temperature, volume, params) -\n                params['E_0'])))\n        \"\"\"\n        dT = 1.0\n        dE = self.molar_internal_energy(\n            0.0, temperature + 0.5 * dT, volume, params\n        ) - self.molar_internal_energy(0.0, temperature - 0.5 * dT, volume, params)\n        dP = self.pressure(temperature + 0.5 * dT, volume, params) - self.pressure(\n            temperature - 0.5 * dT, volume, params\n        )\n        gr = volume * dP / dE\n\n        return gr\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`[Pa]`\n        \"\"\"\n        # K_T = -V * dP/dV\n        dV = volume * 1.0e-3\n        P0 = self.pressure(temperature, volume - 0.5 * dV, params)\n        P1 = self.pressure(temperature, volume + 0.5 * dV, params)\n\n        K_T = -volume * (P1 - P0) / dV\n        return K_T\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus. :math:`[Pa]`\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        K_S = K_T * (1.0 + gr * alpha * temperature)\n        return K_S\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus. :math:`[Pa]`\n        Zero for a liquid\n        \"\"\"\n        return 0.0\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume. :math:`[J/K/mol]`\n        \"\"\"\n\n        A, B, Theta = self._ABTheta(volume, params)\n        lmda, xi = self._lambdaxi(volume, params)\n\n        C_kin = (\n            1.5 * params[\"n\"] * gas_constant\n        )  # HT limit of kinetic contribution (just after equation 29.)\n        C_e = A * (\n            1.0 - (Theta * Theta) / (Theta * Theta + temperature * temperature)\n        ) + B * np.power(\n            temperature, 0.6\n        )  # Equation A1\n        C_pot = (lmda * temperature + xi * params[\"theta\"]) / (\n            params[\"theta\"] + temperature\n        )  # Equation A15\n\n        return C_kin + C_e + C_pot\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure. :math:`[J/K/mol]`\n        \"\"\"\n\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        C_p = C_v * (1.0 + gr * alpha * temperature)\n\n        return C_p\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity. :math:`[1/K]`\n        Currently found by numerical differentiation (1/V * dV/dT)\n        \"\"\"\n\n        delta_T = 1.0\n        V0 = self.volume(pressure, temperature - 0.5 * delta_T, params)\n        V1 = self.volume(pressure, temperature + 0.5 * delta_T, params)\n\n        return (1.0 / volume) * (V1 - V0) / delta_T\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]\n        E + PV\n        \"\"\"\n\n        return self.helmholtz_free_energy(\n            pressure, temperature, volume, params\n        ) + pressure * self.volume(pressure, temperature, params)\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        Ts = self._isentropic_temperature(volume, params)\n        E = (\n            params[\"E_0\"]\n            + self._isentropic_energy_change(volume, params)\n            + self._isochoric_energy_change(Ts, temperature, volume, params)\n        )\n\n        return E\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy at the pressure and temperature of the mineral [J/K/mol]\n        \"\"\"\n        T = temperature\n        Ts = self._isentropic_temperature(volume, params)\n\n        if np.abs(T - Ts) < 1.0e-10:\n            Delta_S = 0.0\n        else:\n            A, B, Theta = self._ABTheta(volume, params)\n            lmda, xi = self._lambdaxi(volume, params)\n            S_kin = 1.5 * params[\"n\"] * gas_constant * (np.log(T) - np.log(Ts))\n            S_el = A * (\n                np.log(T / Ts)\n                - 0.5\n                * np.log(\n                    T\n                    * T\n                    * (Theta * Theta + Ts * Ts)\n                    / (Ts * Ts * (Theta * Theta + T * T))\n                )\n            ) + 5.0 / 3.0 * B * (\n                np.power(T, 0.6) - np.power(Ts, 0.6)\n            )  # A6\n            S_pot = lmda * np.log(\n                (params[\"theta\"] + T) / (params[\"theta\"] + Ts)\n            ) + xi * np.log(\n                (T * (params[\"theta\"] + Ts)) / (Ts * (params[\"theta\"] + T))\n            )  # A20\n            Delta_S = S_kin + S_el + S_pot\n\n        S = params[\"S_0\"] + Delta_S\n        return S\n\n    def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy at the pressure and temperature of the mineral [J/mol]\n        E + PV\n        \"\"\"\n\n        return self.molar_internal_energy(\n            pressure, temperature, volume, params\n        ) + pressure * self.volume(pressure, temperature, params)\n\n    def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]\n        E - TS\n        \"\"\"\n        return self.molar_internal_energy(\n            pressure, temperature, volume, params\n        ) - temperature * self.entropy(pressure, temperature, volume, params)\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"P_0\", \"T_0\", \"S_0\", \"molar_mass\", \"grueneisen_0\"]\n\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 10.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)",
  "def _ABTheta(self, V, params):\n        \"\"\"\n        Electronic heat capacity functions\n        \"\"\"\n        Vfrac = V / params[\"V_0\"]\n\n        A = params[\"a\"][0] + params[\"a\"][1] * Vfrac  # A2\n        B = params[\"b\"][0] + params[\"b\"][1] * Vfrac * Vfrac  # A3\n        Theta = params[\"Theta\"][0] * np.power(Vfrac, -params[\"Theta\"][1])  # A4\n\n        return A, B, Theta",
  "def _lambdaxi(self, V, params):\n        \"\"\"\n        Potential heat capacity functions\n        \"\"\"\n        rhofrac = params[\"V_0\"] / V\n        xi = params[\"xi_0\"] * np.power(rhofrac, -0.6)  # A16\n        F = 1.0 / (1.0 + np.exp((rhofrac - params[\"F\"][0]) / params[\"F\"][1]))  # A18\n        # lmda = (F*(params['lmda'][0] + params['lmda'][1]*rhofrac) + params['lmda'][2])*np.power(rhofrac, 0.4) # A17\n        lmda = F * (\n            params[\"lmda\"][0]\n            + params[\"lmda\"][1] * rhofrac\n            + params[\"lmda\"][2] * np.power(rhofrac, 0.4)\n        )  # this incorrect expression for lmda seems to provide a very close fit to figure 5\n\n        return lmda, xi",
  "def _rhofracxksis(self, V, params):\n        \"\"\"\n        Functions for the fourth order Birch-Murnaghan equation of state\n        \"\"\"\n        rhofrac = params[\"V_0\"] / V  # rho/rho0 = V0/V\n        x = np.power(rhofrac, 1.0 / 3.0)  # equation 18\n        ksi1 = 0.75 * (4.0 - params[\"Kprime_S\"])  # equation 19\n        ksi2 = (\n            0.375\n            * (\n                params[\"K_S\"] * params[\"Kprime_prime_S\"]\n                + params[\"Kprime_S\"] * (params[\"Kprime_S\"] - 7.0)\n            )\n            + 143.0 / 24.0\n        )  # equation 20\n        return rhofrac, x, ksi1, ksi2",
  "def _isentropic_temperature(self, V, params):\n        \"\"\"\n        Temperature along the reference isentrope\n        \"\"\"\n\n        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)\n\n        # equation B6 -- B10\n        a1 = ksi2 / 8.0\n        a2 = (ksi1 + 3.0 * ksi2) / 6.0\n        a3 = (1.0 + 2.0 * ksi1 + 3.0 * ksi2) / 4.0\n        a4 = (1.0 + ksi1 + ksi2) / 2.0\n        a5 = (6.0 + 4.0 * ksi1 + 3.0 * ksi2) / 24.0\n\n        # equation B5\n        Ts = params[\"T_0\"] * np.exp(\n            params[\"grueneisen_0\"] * np.log(rhofrac)\n            + 13.5\n            * params[\"grueneisen_prime\"]\n            * params[\"V_0\"]\n            * params[\"K_S\"]\n            * (\n                (a1 / (3 * params[\"grueneisen_n\"] + 8.0))\n                * (np.power(x, (3 * params[\"grueneisen_n\"] + 8.0)) - 1.0)\n                - (a2 / (3 * params[\"grueneisen_n\"] + 6.0))\n                * (np.power(x, (3 * params[\"grueneisen_n\"] + 6.0)) - 1.0)\n                + (a3 / (3 * params[\"grueneisen_n\"] + 4.0))\n                * (np.power(x, (3 * params[\"grueneisen_n\"] + 4.0)) - 1.0)\n                - (a4 / (3 * params[\"grueneisen_n\"] + 2.0))\n                * (np.power(x, (3 * params[\"grueneisen_n\"] + 2.0)) - 1.0)\n                + (a5 / (3 * params[\"grueneisen_n\"] + 0.0))\n                * (np.power(x, (3 * params[\"grueneisen_n\"] + 0.0)) - 1.0)\n            )\n        )\n\n        return Ts",
  "def _isentropic_pressure(self, V, params):\n        \"\"\"\n        Pressure along the reference isentrope\n        \"\"\"\n        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)\n        x2 = x * x\n        x3 = x * x * x\n        x5 = x3 * x2\n        x7 = x5 * x2\n\n        Ps = (\n            1.5\n            * params[\"K_S\"]\n            * (x7 - x5)\n            * (1.0 + ksi1 - ksi1 * x2 + ksi2 * (x2 - 1.0) * (x2 - 1.0))\n        )  # Eq. 17\n\n        return Ps",
  "def _isentropic_energy_change(self, V, params):\n        \"\"\"\n        Birch Murnaghan equation of state expression for the energy change along an isentrope\n        \"\"\"\n        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)\n        x2 = x * x\n        x4 = x2 * x2\n        x6 = x4 * x2\n        x8 = x4 * x4\n\n        E_S = (\n            4.5\n            * params[\"V_0\"]\n            * params[\"K_S\"]\n            * (\n                (ksi1 + 1.0) * (x4 / 4.0 - x2 / 2.0 + 1.0 / 4.0)\n                - ksi1 * (x6 / 6.0 - x4 / 4.0 + 1.0 / 12.0)\n                + ksi2 * (x8 / 8.0 - x6 / 2.0 + 3.0 * x4 / 4.0 - x2 / 2.0 + 1.0 / 8.0)\n            )\n        )  # Eq. 21\n        return E_S",
  "def _isochoric_energy_change(self, Ts, T, V, params):\n        \"\"\"\n        int Cv dT\n        \"\"\"\n        A, B, Theta = self._ABTheta(V, params)\n        lmda, xi = self._lambdaxi(V, params)\n\n        E_kin = 1.5 * params[\"n\"] * gas_constant * (T - Ts)\n        E_el = A * (\n            T - Ts - Theta * (np.arctan(T / Theta) - np.arctan(Ts / Theta))\n        ) + 5.0 / 8 * B * (\n            np.power(T, 1.6) - np.power(Ts, 1.6)\n        )  # A5\n        E_pot = lmda * (T - Ts) + params[\"theta\"] * (xi - lmda) * np.log(\n            (params[\"theta\"] + T) / (params[\"theta\"] + Ts)\n        )  # A19\n\n        return E_kin + E_el + E_pot",
  "def volume_dependent_q(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`q`, the isotropic volume strain\n        derivative of the grueneisen parameter.\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def _isotropic_eta_s(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`eta_{s0}`, the isotropic shear\n        strain derivative of the grueneisen parameter.\n        Zero for a liquid\n        \"\"\"\n        return 0.0",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns molar volume. :math:`[m^3]`\n        \"\"\"\n\n        _volume = lambda V, P, T, params: (P - self.pressure(T, V, params))\n\n        return brentq(\n            _volume,\n            params[\"V_0\"] * 0.1,\n            params[\"V_0\"] * 2.0,\n            args=(pressure, temperature, params),\n        )",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns the pressure of the mineral at a given temperature and volume [Pa]\n        \"\"\"\n\n        \"\"\"\n        Ts = self._isentropic_temperature(volume, params)\n\n\n        dE = self._isochoric_energy_change(Ts, temperature, volume, params)\n        E1 = self._isentropic_energy_change(volume, params) - params['E_0']\n        E2 = E1 + dE\n\n        # Integrate at constant volume (V \\int dP = \\int gr dE)\n        dP = (params['grueneisen_0']*(E2 - E1) +\n              (0.5*params['grueneisen_prime'] *\n               np.power(params['V_0']/volume, params['grueneisen_n']) *\n               (E2*E2 - E1*E1))) / volume # eq. 23\n\n        P = self._isentropic_pressure(volume, params) + dP\n        \"\"\"\n\n        dV = volume * 1.0e-4\n        S = self.entropy(0.0, temperature, volume, params)\n\n        delta_S = lambda T, S, V: S - self.entropy(0.0, T, V, params)\n\n        T0 = brentq(\n            delta_S, temperature * 0.97, temperature * 1.03, args=(S, volume - 0.5 * dV)\n        )\n        T1 = brentq(\n            delta_S, temperature * 0.97, temperature * 1.03, args=(S, volume + 0.5 * dV)\n        )\n\n        E0 = self.molar_internal_energy(0.0, T0, volume - 0.5 * dV, params)\n        E1 = self.molar_internal_energy(0.0, T1, volume + 0.5 * dV, params)\n\n        P = -(E1 - E0) / dV  # |S\n\n        return P",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter :math:`[unitless]`\n        \"\"\"\n        \"\"\"\n        gr = (params['grueneisen_0'] +\n              params['grueneisen_prime'] *\n              (np.power(params['V_0']/volume, params['grueneisen_n']) *\n               (self.molar_internal_energy(pressure, temperature, volume, params) -\n                params['E_0'])))\n        \"\"\"\n        dT = 1.0\n        dE = self.molar_internal_energy(\n            0.0, temperature + 0.5 * dT, volume, params\n        ) - self.molar_internal_energy(0.0, temperature - 0.5 * dT, volume, params)\n        dP = self.pressure(temperature + 0.5 * dT, volume, params) - self.pressure(\n            temperature - 0.5 * dT, volume, params\n        )\n        gr = volume * dP / dE\n\n        return gr",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`[Pa]`\n        \"\"\"\n        # K_T = -V * dP/dV\n        dV = volume * 1.0e-3\n        P0 = self.pressure(temperature, volume - 0.5 * dV, params)\n        P1 = self.pressure(temperature, volume + 0.5 * dV, params)\n\n        K_T = -volume * (P1 - P0) / dV\n        return K_T",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus. :math:`[Pa]`\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        K_S = K_T * (1.0 + gr * alpha * temperature)\n        return K_S",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus. :math:`[Pa]`\n        Zero for a liquid\n        \"\"\"\n        return 0.0",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume. :math:`[J/K/mol]`\n        \"\"\"\n\n        A, B, Theta = self._ABTheta(volume, params)\n        lmda, xi = self._lambdaxi(volume, params)\n\n        C_kin = (\n            1.5 * params[\"n\"] * gas_constant\n        )  # HT limit of kinetic contribution (just after equation 29.)\n        C_e = A * (\n            1.0 - (Theta * Theta) / (Theta * Theta + temperature * temperature)\n        ) + B * np.power(\n            temperature, 0.6\n        )  # Equation A1\n        C_pot = (lmda * temperature + xi * params[\"theta\"]) / (\n            params[\"theta\"] + temperature\n        )  # Equation A15\n\n        return C_kin + C_e + C_pot",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure. :math:`[J/K/mol]`\n        \"\"\"\n\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        C_p = C_v * (1.0 + gr * alpha * temperature)\n\n        return C_p",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity. :math:`[1/K]`\n        Currently found by numerical differentiation (1/V * dV/dT)\n        \"\"\"\n\n        delta_T = 1.0\n        V0 = self.volume(pressure, temperature - 0.5 * delta_T, params)\n        V1 = self.volume(pressure, temperature + 0.5 * delta_T, params)\n\n        return (1.0 / volume) * (V1 - V0) / delta_T",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]\n        E + PV\n        \"\"\"\n\n        return self.helmholtz_free_energy(\n            pressure, temperature, volume, params\n        ) + pressure * self.volume(pressure, temperature, params)",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        Ts = self._isentropic_temperature(volume, params)\n        E = (\n            params[\"E_0\"]\n            + self._isentropic_energy_change(volume, params)\n            + self._isochoric_energy_change(Ts, temperature, volume, params)\n        )\n\n        return E",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy at the pressure and temperature of the mineral [J/K/mol]\n        \"\"\"\n        T = temperature\n        Ts = self._isentropic_temperature(volume, params)\n\n        if np.abs(T - Ts) < 1.0e-10:\n            Delta_S = 0.0\n        else:\n            A, B, Theta = self._ABTheta(volume, params)\n            lmda, xi = self._lambdaxi(volume, params)\n            S_kin = 1.5 * params[\"n\"] * gas_constant * (np.log(T) - np.log(Ts))\n            S_el = A * (\n                np.log(T / Ts)\n                - 0.5\n                * np.log(\n                    T\n                    * T\n                    * (Theta * Theta + Ts * Ts)\n                    / (Ts * Ts * (Theta * Theta + T * T))\n                )\n            ) + 5.0 / 3.0 * B * (\n                np.power(T, 0.6) - np.power(Ts, 0.6)\n            )  # A6\n            S_pot = lmda * np.log(\n                (params[\"theta\"] + T) / (params[\"theta\"] + Ts)\n            ) + xi * np.log(\n                (T * (params[\"theta\"] + Ts)) / (Ts * (params[\"theta\"] + T))\n            )  # A20\n            Delta_S = S_kin + S_el + S_pot\n\n        S = params[\"S_0\"] + Delta_S\n        return S",
  "def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy at the pressure and temperature of the mineral [J/mol]\n        E + PV\n        \"\"\"\n\n        return self.molar_internal_energy(\n            pressure, temperature, volume, params\n        ) + pressure * self.volume(pressure, temperature, params)",
  "def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]\n        E - TS\n        \"\"\"\n        return self.molar_internal_energy(\n            pressure, temperature, volume, params\n        ) - temperature * self.entropy(pressure, temperature, volume, params)",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"P_0\", \"T_0\", \"S_0\", \"molar_mass\", \"grueneisen_0\"]\n\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 10.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)",
  "def _grueneisen_parameter_fast(V_0, volume, gruen_0, q_0):\n    \"\"\"global function with plain parameters so jit will work\"\"\"\n    x = V_0 / volume\n    f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n    a1_ii = 6.0 * gruen_0  # EQ 47\n    a2_iikk = -12.0 * gruen_0 + 36.0 * gruen_0 * gruen_0 - 18.0 * q_0 * gruen_0  # EQ 47\n    nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41\n    return 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)",
  "def _delta_pressure(\n    x, pressure, temperature, V_0, T_0, Debye_0, n, a1_ii, a2_iikk, b_iikk, b_iikkmm\n):\n    f = 0.5 * (pow(V_0 / x, 2.0 / 3.0) - 1.0)\n    nu_o_nu0_sq = 1.0 + a1_ii * f + 1.0 / 2.0 * a2_iikk * f * f\n    debye_temperature = Debye_0 * np.sqrt(nu_o_nu0_sq)\n    E_th = debye.thermal_energy(\n        temperature, debye_temperature, n\n    )  # thermal energy at temperature T\n    E_th_ref = debye.thermal_energy(\n        T_0, debye_temperature, n\n    )  # thermal energy at reference temperature\n    nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41\n    gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)\n\n    return (\n        (1.0 / 3.0)\n        * (pow(1.0 + 2.0 * f, 5.0 / 2.0))\n        * ((b_iikk * f) + (0.5 * b_iikkmm * f * f))\n        + gr * (E_th - E_th_ref) / x\n        - pressure\n    )",
  "class SLBBase(eos.EquationOfState):\n\n    \"\"\"\n    Base class for the finite strain-Mie-Grueneiesen-Debye equation of state\n    detailed in :cite:`Stixrude2005`.  For the most part the equations are\n    all third order in strain, but see further the :class:`burnman.slb.SLB2`\n    and :class:`burnman.slb.SLB3` classes.\n    \"\"\"\n\n    def _debye_temperature(self, x, params):\n        \"\"\"\n        Finite strain approximation for Debye Temperature [K]\n        x = ref_vol/vol\n        \"\"\"\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n        nu_o_nu0_sq = 1.0 + a1_ii * f + 1.0 / 2.0 * a2_iikk * f * f\n        if nu_o_nu0_sq > 0.0:\n            return params[\"Debye_0\"] * np.sqrt(nu_o_nu0_sq)\n        else:\n            raise Exception(\n                f\"This volume (V = {1./x:.2f}*V_0) exceeds the \"\n                \"valid range of the thermal \"\n                \"part of the slb equation of state.\"\n            )\n\n    def volume_dependent_q(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`q`, the isotropic volume strain\n        derivative of the grueneisen parameter.\n        \"\"\"\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41\n        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)\n        # avoids divide by zero if grueneisen_0 = 0.\n        if np.abs(params[\"grueneisen_0\"]) < 1.0e-10:\n            q = 1.0 / 9.0 * (18.0 * gr - 6.0)\n        else:\n            q = (\n                1.0\n                / 9.0\n                * (\n                    18.0 * gr\n                    - 6.0\n                    - 1.0\n                    / 2.0\n                    / nu_o_nu0_sq\n                    * (2.0 * f + 1.0)\n                    * (2.0 * f + 1.0)\n                    * a2_iikk\n                    / gr\n                )\n            )\n        return q\n\n    def _isotropic_eta_s(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`eta_{s0}`, the isotropic shear\n        strain derivative of the grueneisen parameter.\n        \"\"\"\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        a2_s = -2.0 * params[\"grueneisen_0\"] - 2.0 * params[\"eta_s_0\"]  # EQ 47\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * pow(f, 2.0)  # EQ 41\n        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)\n        # EQ 46 NOTE the typo from Stixrude 2005:\n        eta_s = -gr - (\n            1.0 / 2.0 * pow(nu_o_nu0_sq, -1.0) * pow((2.0 * f) + 1.0, 2.0) * a2_s\n        )\n\n        return eta_s\n\n    # calculate isotropic thermal pressure, see\n    # Matas et. al. (2007) eq B4\n    def _thermal_pressure(self, T, V, params):\n        Debye_T = self._debye_temperature(params[\"V_0\"] / V, params)\n        gr = self.grueneisen_parameter(0.0, T, V, params)  # P not important\n        P_th = gr * debye.thermal_energy(T, Debye_T, params[\"n\"]) / V\n        return P_th\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns molar volume. :math:`[m^3]`\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        Debye_0 = params[\"Debye_0\"]\n        V_0 = params[\"V_0\"]\n        dV = 1.0e-2 * params[\"V_0\"]\n        n = params[\"n\"]\n\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29z\n\n        # Finding the volume at a given pressure requires a\n        # root-finding scheme. Here we use brentq to find the root.\n\n        # Root-finding using brentq requires bounds to be specified.\n        # We do this using a bracketing function.\n        args = (\n            pressure,\n            temperature,\n            V_0,\n            T_0,\n            Debye_0,\n            n,\n            a1_ii,\n            a2_iikk,\n            b_iikk,\n            b_iikkmm,\n        )\n\n        try:\n            # The first attempt to find a bracket for\n            # root finding uses V_0 as a starting point\n            sol = bracket(_delta_pressure, V_0, dV, args)\n        except Exception:\n            # At high temperature, the naive bracketing above may\n            # try a volume guess that exceeds the point at which the\n            # bulk modulus goes negative at that temperature.\n            # In this case, we try a more nuanced approach by\n            # first finding the volume at which the bulk modulus goes\n            # negative, and then either (a) raising an exception if the\n            # desired pressure is less than the pressure at that volume,\n            # or (b) using that pressure to create a better bracket for\n            # brentq.\n            def _K_T(V, T, params):\n                return self.isothermal_bulk_modulus(0.0, T, V, params)\n\n            sol_K_T = bracket(_K_T, V_0, dV, args=(temperature, params))\n            V_crit = opt.brentq(\n                _K_T, sol_K_T[0], sol_K_T[1], args=(temperature, params)\n            )\n            P_min = self.pressure(temperature, V_crit, params)\n            if P_min > pressure:\n                raise Exception(\n                    \"The desired pressure is not achievable \"\n                    \"at this temperature. The minimum pressure \"\n                    f\"achievable is {P_min:.2e} Pa.\"\n                )\n            else:\n                try:\n                    sol = bracket(_delta_pressure, V_crit - dV, dV, args)\n                except Exception:\n                    raise Exception(\n                        \"Cannot find a volume, perhaps you are \"\n                        \"outside of the range of validity for \"\n                        \"the equation of state?\"\n                    )\n\n        return opt.brentq(_delta_pressure, sol[0], sol[1], args=args)\n\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns the pressure of the mineral at a given temperature and volume\n        [Pa]\n        \"\"\"\n        debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        gr = self.grueneisen_parameter(\n            0.0, temperature, volume, params\n        )  # does not depend on pressure\n        # thermal energy at temperature T\n        E_th = debye.thermal_energy(temperature, debye_T, params[\"n\"])\n        # thermal energy at reference temperature\n        E_th_ref = debye.thermal_energy(params[\"T_0\"], debye_T, params[\"n\"])\n\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29\n        f = 0.5 * (pow(params[\"V_0\"] / volume, 2.0 / 3.0) - 1.0)  # EQ 24\n        P = (1.0 / 3.0) * (pow(1.0 + 2.0 * f, 5.0 / 2.0)) * (\n            (b_iikk * f) + (0.5 * b_iikkmm * pow(f, 2.0))\n        ) + gr * (\n            E_th - E_th_ref\n        ) / volume  # EQ 21\n\n        return P\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter :math:`[unitless]`\n        \"\"\"\n        return _grueneisen_parameter_fast(\n            params[\"V_0\"], volume, params[\"grueneisen_0\"], params[\"q_0\"]\n        )\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`[Pa]`\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n\n        # thermal energy at temperature T\n        E_th = debye.thermal_energy(temperature, debye_T, params[\"n\"])\n        # thermal energy at reference temperature\n        E_th_ref = debye.thermal_energy(T_0, debye_T, params[\"n\"])\n\n        # heat capacity at temperature T\n        C_v = debye.molar_heat_capacity_v(temperature, debye_T, params[\"n\"])\n        # heat capacity at reference temperature\n        C_v_ref = debye.molar_heat_capacity_v(T_0, debye_T, params[\"n\"])\n\n        q = self.volume_dependent_q(params[\"V_0\"] / volume, params)\n\n        K = (\n            bm.bulk_modulus(volume, params)\n            + (gr + 1.0 - q) * (gr / volume) * (E_th - E_th_ref)\n            - (pow(gr, 2.0) / volume) * (C_v * temperature - C_v_ref * T_0)\n        )\n\n        return K\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus. :math:`[Pa]`\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        K_S = K_T * (1.0 + gr * alpha * temperature)\n        return K_S\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus. :math:`[Pa]`\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        eta_s = self._isotropic_eta_s(params[\"V_0\"] / volume, params)\n\n        E_th = debye.thermal_energy(temperature, debye_T, params[\"n\"])\n        E_th_ref = debye.thermal_energy(T_0, debye_T, params[\"n\"])\n\n        if self.order == 2:\n            return (\n                bm.shear_modulus_second_order(volume, params)\n                - eta_s * (E_th - E_th_ref) / volume\n            )\n        elif self.order == 3:\n            return (\n                bm.shear_modulus_third_order(volume, params)\n                - eta_s * (E_th - E_th_ref) / volume\n            )\n        else:\n            raise NotImplementedError(\"\")\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume. :math:`[J/K/mol]`\n        \"\"\"\n        debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        return debye.molar_heat_capacity_v(temperature, debye_T, params[\"n\"])\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure. :math:`[J/K/mol]`\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        C_p = C_v * (1.0 + gr * alpha * temperature)\n        return C_p\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity. :math:`[1/K]`\n        \"\"\"\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = gr * C_v / K / volume\n        return alpha\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy at the pressure and temperature\n        of the mineral [J/mol]\n        \"\"\"\n        G = (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n        return G\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy at the pressure and temperature\n        of the mineral [J/mol]\n        \"\"\"\n        return self.helmholtz_free_energy(\n            pressure, temperature, volume, params\n        ) + temperature * self.entropy(pressure, temperature, volume, params)\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy at the pressure and temperature\n        of the mineral [J/K/mol]\n        \"\"\"\n        Debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        S = debye.entropy(temperature, Debye_T, params[\"n\"])\n        return S\n\n    def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy at the pressure and temperature\n        of the mineral [J/mol]\n        \"\"\"\n\n        return (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + temperature * self.entropy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n\n    def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Helmholtz free energy at the pressure and temperature\n        of the mineral [J/mol]\n        \"\"\"\n        x = params[\"V_0\"] / volume\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        Debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n\n        F_quasiharmonic = debye.helmholtz_free_energy(\n            temperature, Debye_T, params[\"n\"]\n        ) - debye.helmholtz_free_energy(params[\"T_0\"], Debye_T, params[\"n\"])\n\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29\n\n        F = (\n            params[\"F_0\"]\n            + 0.5 * b_iikk * f * f * params[\"V_0\"]\n            + (1.0 / 6.0) * params[\"V_0\"] * b_iikkmm * f * f * f\n            + F_quasiharmonic\n        )\n\n        return F\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 300.0\n\n        # If eta_s_0 is not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without it,\n        # so just add it to the dictionary as nan\n        # The same goes for the standard state Helmholtz free energy\n        if \"eta_s_0\" not in params:\n            params[\"eta_s_0\"] = float(\"nan\")\n        if \"F_0\" not in params:\n            params[\"F_0\"] = float(\"nan\")\n\n        # First, let's check the EoS parameters for Tref\n        bm.BirchMurnaghanBase.validate_parameters(bm.BirchMurnaghanBase(), params)\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"molar_mass\", \"n\", \"Debye_0\", \"grueneisen_0\", \"q_0\", \"eta_s_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 10.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)\n        if params[\"Debye_0\"] < 1.0 or params[\"Debye_0\"] > 10000.0:\n            warnings.warn(\"Unusual value for Debye_0\", stacklevel=2)\n        if params[\"grueneisen_0\"] < -1.0 or params[\"grueneisen_0\"] > 10.0:\n            warnings.warn(\"Unusual value for grueneisen_0\", stacklevel=2)\n        if params[\"q_0\"] < -20.0 or params[\"q_0\"] > 20.0:\n            warnings.warn(\"Unusual value for q_0\", stacklevel=2)\n        if params[\"eta_s_0\"] < -10.0 or params[\"eta_s_0\"] > 10.0:\n            warnings.warn(\"Unusual value for eta_s_0\", stacklevel=2)",
  "class SLB3(SLBBase):\n\n    \"\"\"\n    SLB equation of state with third order finite strain expansion for the\n    shear modulus (this should be preferred, as it is more thermodynamically\n    consistent.)\n    \"\"\"\n\n    def __init__(self):\n        self.order = 3",
  "class SLB2(SLBBase):\n\n    \"\"\"\n    SLB equation of state with second order finite strain expansion for the\n    shear modulus.  In general, this should not be used, but sometimes\n    shear modulus data is fit to a second order equation of state.  In that\n    case, you should use this.  The moral is, be careful!\n    \"\"\"\n\n    def __init__(self):\n        self.order = 2",
  "def _debye_temperature(self, x, params):\n        \"\"\"\n        Finite strain approximation for Debye Temperature [K]\n        x = ref_vol/vol\n        \"\"\"\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n        nu_o_nu0_sq = 1.0 + a1_ii * f + 1.0 / 2.0 * a2_iikk * f * f\n        if nu_o_nu0_sq > 0.0:\n            return params[\"Debye_0\"] * np.sqrt(nu_o_nu0_sq)\n        else:\n            raise Exception(\n                f\"This volume (V = {1./x:.2f}*V_0) exceeds the \"\n                \"valid range of the thermal \"\n                \"part of the slb equation of state.\"\n            )",
  "def volume_dependent_q(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`q`, the isotropic volume strain\n        derivative of the grueneisen parameter.\n        \"\"\"\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41\n        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)\n        # avoids divide by zero if grueneisen_0 = 0.\n        if np.abs(params[\"grueneisen_0\"]) < 1.0e-10:\n            q = 1.0 / 9.0 * (18.0 * gr - 6.0)\n        else:\n            q = (\n                1.0\n                / 9.0\n                * (\n                    18.0 * gr\n                    - 6.0\n                    - 1.0\n                    / 2.0\n                    / nu_o_nu0_sq\n                    * (2.0 * f + 1.0)\n                    * (2.0 * f + 1.0)\n                    * a2_iikk\n                    / gr\n                )\n            )\n        return q",
  "def _isotropic_eta_s(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`eta_{s0}`, the isotropic shear\n        strain derivative of the grueneisen parameter.\n        \"\"\"\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        a2_s = -2.0 * params[\"grueneisen_0\"] - 2.0 * params[\"eta_s_0\"]  # EQ 47\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * pow(f, 2.0)  # EQ 41\n        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)\n        # EQ 46 NOTE the typo from Stixrude 2005:\n        eta_s = -gr - (\n            1.0 / 2.0 * pow(nu_o_nu0_sq, -1.0) * pow((2.0 * f) + 1.0, 2.0) * a2_s\n        )\n\n        return eta_s",
  "def _thermal_pressure(self, T, V, params):\n        Debye_T = self._debye_temperature(params[\"V_0\"] / V, params)\n        gr = self.grueneisen_parameter(0.0, T, V, params)  # P not important\n        P_th = gr * debye.thermal_energy(T, Debye_T, params[\"n\"]) / V\n        return P_th",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns molar volume. :math:`[m^3]`\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        Debye_0 = params[\"Debye_0\"]\n        V_0 = params[\"V_0\"]\n        dV = 1.0e-2 * params[\"V_0\"]\n        n = params[\"n\"]\n\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29z\n\n        # Finding the volume at a given pressure requires a\n        # root-finding scheme. Here we use brentq to find the root.\n\n        # Root-finding using brentq requires bounds to be specified.\n        # We do this using a bracketing function.\n        args = (\n            pressure,\n            temperature,\n            V_0,\n            T_0,\n            Debye_0,\n            n,\n            a1_ii,\n            a2_iikk,\n            b_iikk,\n            b_iikkmm,\n        )\n\n        try:\n            # The first attempt to find a bracket for\n            # root finding uses V_0 as a starting point\n            sol = bracket(_delta_pressure, V_0, dV, args)\n        except Exception:\n            # At high temperature, the naive bracketing above may\n            # try a volume guess that exceeds the point at which the\n            # bulk modulus goes negative at that temperature.\n            # In this case, we try a more nuanced approach by\n            # first finding the volume at which the bulk modulus goes\n            # negative, and then either (a) raising an exception if the\n            # desired pressure is less than the pressure at that volume,\n            # or (b) using that pressure to create a better bracket for\n            # brentq.\n            def _K_T(V, T, params):\n                return self.isothermal_bulk_modulus(0.0, T, V, params)\n\n            sol_K_T = bracket(_K_T, V_0, dV, args=(temperature, params))\n            V_crit = opt.brentq(\n                _K_T, sol_K_T[0], sol_K_T[1], args=(temperature, params)\n            )\n            P_min = self.pressure(temperature, V_crit, params)\n            if P_min > pressure:\n                raise Exception(\n                    \"The desired pressure is not achievable \"\n                    \"at this temperature. The minimum pressure \"\n                    f\"achievable is {P_min:.2e} Pa.\"\n                )\n            else:\n                try:\n                    sol = bracket(_delta_pressure, V_crit - dV, dV, args)\n                except Exception:\n                    raise Exception(\n                        \"Cannot find a volume, perhaps you are \"\n                        \"outside of the range of validity for \"\n                        \"the equation of state?\"\n                    )\n\n        return opt.brentq(_delta_pressure, sol[0], sol[1], args=args)",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns the pressure of the mineral at a given temperature and volume\n        [Pa]\n        \"\"\"\n        debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        gr = self.grueneisen_parameter(\n            0.0, temperature, volume, params\n        )  # does not depend on pressure\n        # thermal energy at temperature T\n        E_th = debye.thermal_energy(temperature, debye_T, params[\"n\"])\n        # thermal energy at reference temperature\n        E_th_ref = debye.thermal_energy(params[\"T_0\"], debye_T, params[\"n\"])\n\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29\n        f = 0.5 * (pow(params[\"V_0\"] / volume, 2.0 / 3.0) - 1.0)  # EQ 24\n        P = (1.0 / 3.0) * (pow(1.0 + 2.0 * f, 5.0 / 2.0)) * (\n            (b_iikk * f) + (0.5 * b_iikkmm * pow(f, 2.0))\n        ) + gr * (\n            E_th - E_th_ref\n        ) / volume  # EQ 21\n\n        return P",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter :math:`[unitless]`\n        \"\"\"\n        return _grueneisen_parameter_fast(\n            params[\"V_0\"], volume, params[\"grueneisen_0\"], params[\"q_0\"]\n        )",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`[Pa]`\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n\n        # thermal energy at temperature T\n        E_th = debye.thermal_energy(temperature, debye_T, params[\"n\"])\n        # thermal energy at reference temperature\n        E_th_ref = debye.thermal_energy(T_0, debye_T, params[\"n\"])\n\n        # heat capacity at temperature T\n        C_v = debye.molar_heat_capacity_v(temperature, debye_T, params[\"n\"])\n        # heat capacity at reference temperature\n        C_v_ref = debye.molar_heat_capacity_v(T_0, debye_T, params[\"n\"])\n\n        q = self.volume_dependent_q(params[\"V_0\"] / volume, params)\n\n        K = (\n            bm.bulk_modulus(volume, params)\n            + (gr + 1.0 - q) * (gr / volume) * (E_th - E_th_ref)\n            - (pow(gr, 2.0) / volume) * (C_v * temperature - C_v_ref * T_0)\n        )\n\n        return K",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus. :math:`[Pa]`\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        K_S = K_T * (1.0 + gr * alpha * temperature)\n        return K_S",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus. :math:`[Pa]`\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        eta_s = self._isotropic_eta_s(params[\"V_0\"] / volume, params)\n\n        E_th = debye.thermal_energy(temperature, debye_T, params[\"n\"])\n        E_th_ref = debye.thermal_energy(T_0, debye_T, params[\"n\"])\n\n        if self.order == 2:\n            return (\n                bm.shear_modulus_second_order(volume, params)\n                - eta_s * (E_th - E_th_ref) / volume\n            )\n        elif self.order == 3:\n            return (\n                bm.shear_modulus_third_order(volume, params)\n                - eta_s * (E_th - E_th_ref) / volume\n            )\n        else:\n            raise NotImplementedError(\"\")",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume. :math:`[J/K/mol]`\n        \"\"\"\n        debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        return debye.molar_heat_capacity_v(temperature, debye_T, params[\"n\"])",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure. :math:`[J/K/mol]`\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        C_p = C_v * (1.0 + gr * alpha * temperature)\n        return C_p",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity. :math:`[1/K]`\n        \"\"\"\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = gr * C_v / K / volume\n        return alpha",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy at the pressure and temperature\n        of the mineral [J/mol]\n        \"\"\"\n        G = (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n        return G",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy at the pressure and temperature\n        of the mineral [J/mol]\n        \"\"\"\n        return self.helmholtz_free_energy(\n            pressure, temperature, volume, params\n        ) + temperature * self.entropy(pressure, temperature, volume, params)",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy at the pressure and temperature\n        of the mineral [J/K/mol]\n        \"\"\"\n        Debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        S = debye.entropy(temperature, Debye_T, params[\"n\"])\n        return S",
  "def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy at the pressure and temperature\n        of the mineral [J/mol]\n        \"\"\"\n\n        return (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + temperature * self.entropy(pressure, temperature, volume, params)\n            + pressure * volume\n        )",
  "def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Helmholtz free energy at the pressure and temperature\n        of the mineral [J/mol]\n        \"\"\"\n        x = params[\"V_0\"] / volume\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        Debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n\n        F_quasiharmonic = debye.helmholtz_free_energy(\n            temperature, Debye_T, params[\"n\"]\n        ) - debye.helmholtz_free_energy(params[\"T_0\"], Debye_T, params[\"n\"])\n\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29\n\n        F = (\n            params[\"F_0\"]\n            + 0.5 * b_iikk * f * f * params[\"V_0\"]\n            + (1.0 / 6.0) * params[\"V_0\"] * b_iikkmm * f * f * f\n            + F_quasiharmonic\n        )\n\n        return F",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 300.0\n\n        # If eta_s_0 is not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without it,\n        # so just add it to the dictionary as nan\n        # The same goes for the standard state Helmholtz free energy\n        if \"eta_s_0\" not in params:\n            params[\"eta_s_0\"] = float(\"nan\")\n        if \"F_0\" not in params:\n            params[\"F_0\"] = float(\"nan\")\n\n        # First, let's check the EoS parameters for Tref\n        bm.BirchMurnaghanBase.validate_parameters(bm.BirchMurnaghanBase(), params)\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"molar_mass\", \"n\", \"Debye_0\", \"grueneisen_0\", \"q_0\", \"eta_s_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 10.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)\n        if params[\"Debye_0\"] < 1.0 or params[\"Debye_0\"] > 10000.0:\n            warnings.warn(\"Unusual value for Debye_0\", stacklevel=2)\n        if params[\"grueneisen_0\"] < -1.0 or params[\"grueneisen_0\"] > 10.0:\n            warnings.warn(\"Unusual value for grueneisen_0\", stacklevel=2)\n        if params[\"q_0\"] < -20.0 or params[\"q_0\"] > 20.0:\n            warnings.warn(\"Unusual value for q_0\", stacklevel=2)\n        if params[\"eta_s_0\"] < -10.0 or params[\"eta_s_0\"] > 10.0:\n            warnings.warn(\"Unusual value for eta_s_0\", stacklevel=2)",
  "def __init__(self):\n        self.order = 3",
  "def __init__(self):\n        self.order = 2",
  "def jit(fn):\n        return fn",
  "def _K_T(V, T, params):\n                return self.isothermal_bulk_modulus(0.0, T, V, params)",
  "def bulk_modulus(volume, params):\n    \"\"\"\n    compute the bulk modulus as per the\n    Vinet equation of state.  Reference bulk\n    modulus should be in :math:`[Pa]`.\n    \"\"\"\n\n    x = volume / params[\"V_0\"]\n    eta = (3.0 / 2.0) * (params[\"Kprime_0\"] - 1.0)\n\n    K = (\n        (params[\"K_0\"] * pow(x, -2.0 / 3.0))\n        * (1 + ((eta * pow(x, 1.0 / 3.0) + 1.0) * (1.0 - pow(x, 1.0 / 3.0))))\n        * exp(eta * (1.0 - pow(x, 1.0 / 3.0)))\n    )\n    return K",
  "def vinet(x, params):\n    \"\"\"\n    equation for the  Vinet equation of state, returns\n    pressure in the same units that are supplied for the reference bulk\n    modulus (params['K_0']), which should be in math:`[Pa]`.\n    \"\"\"\n    eta = (3.0 / 2.0) * (params[\"Kprime_0\"] - 1.0)\n    return (\n        3.0\n        * params[\"K_0\"]\n        * (pow(x, -2.0 / 3.0))\n        * (1.0 - (pow(x, 1.0 / 3.0)))\n        * exp(eta * (1.0 - pow(x, 1.0 / 3.0)))\n        + params[\"P_0\"]\n    )",
  "def volume(pressure, params):\n    \"\"\"\n    Get the Vinet volume at a reference temperature for a given\n    pressure :math:`[Pa]`. Returns molar volume in :math:`[m^3]`\n    \"\"\"\n\n    func = lambda x: vinet(x / params[\"V_0\"], params) - pressure\n    V = opt.brentq(func, 0.1 * params[\"V_0\"], 1.5 * params[\"V_0\"])\n    return V",
  "class Vinet(eos.EquationOfState):\n\n    \"\"\"\n    Base class for the isothermal Vinet equation of state.\n    References for this equation of state are :cite:`vinet1986`\n    and :cite:`vinet1987`. This equation of state actually\n    predates Vinet by 55 years :cite:`Rydberg1932`,\n    and was investigated further by :cite:`Stacey1981`.\n    \"\"\"\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume(pressure, params)\n\n    def pressure(self, temperature, volume, params):\n        return vinet(volume / params[\"V_0\"], params)\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus(volume, params)\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(volume, params)\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        Currently not included in the Vinet EOS, so omitted.\n        \"\"\"\n        return 0.0\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        x = pow(volume / params[\"V_0\"], 1.0 / 3.0)\n        eta = (3.0 / 2.0) * (params[\"Kprime_0\"] - 1.0)\n\n        intPdV = (\n            9.0\n            * params[\"V_0\"]\n            * params[\"K_0\"]\n            / (eta * eta)\n            * ((1.0 - eta * (1.0 - x)) * exp(eta * (1.0 - x)) - 1.0)\n        )\n\n        return -intPdV + params[\"E_0\"]\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # G = int VdP = [PV] - int PdV = E + PV\n\n        return (\n            self.molar_internal_energy(pressure, temperature, volume, params)\n            + volume * pressure\n        )\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # G is not included in the Vinet EOS so we shall set them to NaN's\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # now check that the values are reasonable.  I mostly just\n        # made up these values from experience, and we are only\n        # raising a warning.  Better way to do this? [IR]\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < -5.0 or params[\"Kprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume(pressure, params)",
  "def pressure(self, temperature, volume, params):\n        return vinet(volume / params[\"V_0\"], params)",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus(volume, params)",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(volume, params)",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        Currently not included in the Vinet EOS, so omitted.\n        \"\"\"\n        return 0.0",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        x = pow(volume / params[\"V_0\"], 1.0 / 3.0)\n        eta = (3.0 / 2.0) * (params[\"Kprime_0\"] - 1.0)\n\n        intPdV = (\n            9.0\n            * params[\"V_0\"]\n            * params[\"K_0\"]\n            / (eta * eta)\n            * ((1.0 - eta * (1.0 - x)) * exp(eta * (1.0 - x)) - 1.0)\n        )\n\n        return -intPdV + params[\"E_0\"]",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # G = int VdP = [PV] - int PdV = E + PV\n\n        return (\n            self.molar_internal_energy(pressure, temperature, volume, params)\n            + volume * pressure\n        )",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # G is not included in the Vinet EOS so we shall set them to NaN's\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # now check that the values are reasonable.  I mostly just\n        # made up these values from experience, and we are only\n        # raising a warning.  Better way to do this? [IR]\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < -5.0 or params[\"Kprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)",
  "class DKS_L(eos.EquationOfState):\n    \"\"\"\n    Base class for the finite strain liquid equation of state detailed\n    in :cite:`deKoker2013` (supplementary materials).\n    \"\"\"\n\n    \"\"\"\n    Ideal gas contributions (translational and electronic)\n    to thermodynamic properties\n    \"\"\"\n\n    def _ln_partition_function(self, mass, temperature):\n        \"\"\"\n        Calculates the natural log of the partition function\n        \"\"\"\n        return 3.0 / 2.0 * np.log(temperature) + 3.0 / 2.0 * np.log(\n            mass * constants.Boltzmann / (2 * np.pi * constants.Dirac * constants.Dirac)\n        )\n\n    def _F_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the helmholtz free energy\n        Eq. S6, see also eq. 16.72 of Callen., 1985; p. 373\n        \"\"\"\n\n        V = volume / constants.Avogadro\n        figoverRT = 0.0\n        for element, N in params[\"formula\"].items():  # N is a.p.f.u\n            if N > 1.0e-5:\n                mass = atomic_masses[element] / constants.Avogadro\n                figoverRT += -N * (\n                    np.log(V) + self._ln_partition_function(mass, temperature) + 1.0\n                ) + N * np.log(N)\n        return constants.gas_constant * temperature * figoverRT\n\n    def _S_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the entropy\n        \"\"\"\n\n        V = volume / constants.Avogadro\n        entropy_sum = 0.0\n        for element, N in params[\"formula\"].items():  # N is a.p.f.u\n            if N > 1.0e-5:\n                mass = atomic_masses[element] / constants.Avogadro\n                entropy_sum -= -N * (\n                    np.log(V)\n                    + self._ln_partition_function(mass, temperature)\n                    + 5.0 / 2.0\n                ) + N * np.log(N)\n        return constants.gas_constant * entropy_sum\n\n    def _C_v_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the heat capacity\n        \"\"\"\n\n        n_atoms = 0\n        for element, N in params[\"formula\"].items():\n            n_atoms += N\n        return 1.5 * constants.gas_constant * n_atoms\n\n    def _P_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the pressure\n        PV = nRT\n        \"\"\"\n\n        n_atoms = 0\n        for element, N in params[\"formula\"].items():\n            n_atoms += N\n        return n_atoms * constants.gas_constant * temperature / volume\n\n    def _K_T_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the isothermal bulk modulus\n        V * d/dV(-nRT/V) = V*nRT/V^2\n        \"\"\"\n        n_atoms = 0\n        for element, N in params[\"formula\"].items():\n            n_atoms += N\n        return n_atoms * constants.gas_constant * temperature / volume\n\n    def _alphaK_T_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the product of the\n        thermal expansivity and isothermal bulk modulus\n        d/dT(nRT/V) = nR/V\n        \"\"\"\n\n        n_atoms = 0\n        for element, N in params[\"formula\"].items():\n            n_atoms += N\n        return n_atoms * constants.gas_constant / volume\n\n    \"\"\"\n    Electronic contributions to thermodynamic properties\n    \"\"\"\n\n    def _zeta(\n        self, temperature, volume, params\n    ):  # eq. S5a, beta in deKoker thesis (3.34)\n        return params[\"zeta_0\"] * (np.power(volume / params[\"el_V_0\"], params[\"xi\"]))\n\n    def _dzetadV(self, temperature, volume, params):\n        return (\n            params[\"zeta_0\"]\n            * params[\"xi\"]\n            * (np.power(volume / params[\"el_V_0\"], params[\"xi\"]))\n            / volume\n        )\n\n    def _d2zetadV2(self, temperature, volume, params):\n        return (\n            params[\"zeta_0\"]\n            * params[\"xi\"]\n            * (params[\"xi\"] - 1.0)\n            * (np.power(volume / params[\"el_V_0\"], params[\"xi\"]))\n            / volume\n            / volume\n        )\n\n    def _Tel(self, temperature, volume, params):  # eq. S5b\n        return params[\"Tel_0\"] * (np.power(volume / params[\"el_V_0\"], params[\"eta\"]))\n\n    def _dTeldV(self, temperature, volume, params):\n        return (\n            params[\"Tel_0\"]\n            * params[\"eta\"]\n            * (np.power(volume / params[\"el_V_0\"], params[\"eta\"]))\n            / volume\n        )\n\n    def _d2TeldV2(self, temperature, volume, params):\n        return (\n            params[\"Tel_0\"]\n            * params[\"eta\"]\n            * (params[\"eta\"] - 1.0)\n            * (np.power(volume / params[\"el_V_0\"], params[\"eta\"]))\n            / volume\n            / volume\n        )\n\n    def _gimel(\n        self, temperature_el, temperature, volume, params\n    ):  # -F_el/zeta, 3.30 in de Koker thesis\n        return 0.5 * (\n            temperature * temperature - temperature_el * temperature_el\n        ) - temperature * temperature_el * np.log(temperature / temperature_el)\n\n    def _dgimeldTel(self, temperature_el, temperature, volume, params):\n        return (temperature - temperature_el) - temperature * np.log(\n            temperature / temperature_el\n        )\n\n    def _dgimeldT(self, temperature_el, temperature, volume, params):\n        return (temperature - temperature_el) - temperature_el * np.log(\n            temperature / temperature_el\n        )\n\n    def _d2gimeldTdTel(self, temperature_el, temperature, volume, params):\n        return -np.log(temperature / temperature_el)\n\n    def _d2gimeldTel2(self, temperature_el, temperature, volume, params):\n        return (temperature / temperature_el) - 1.0\n\n    def _F_el(self, temperature, volume, params):  # F_el\n        temperature_el = self._Tel(temperature, volume, params)\n        if temperature < temperature_el:\n            F_el = 0\n        else:\n            F_el = -self._zeta(temperature, volume, params) * self._gimel(\n                temperature_el, temperature, volume, params\n            )\n        return F_el\n\n    def _S_el(self, temperature, volume, params):  # S_el\n        temperature_el = self._Tel(temperature, volume, params)\n        if temperature < temperature_el:\n            S_el = 0\n        else:\n            S_el = self._zeta(temperature, volume, params) * self._dgimeldT(\n                temperature_el, temperature, volume, params\n            )\n        return S_el\n\n    def _P_el(self, temperature, volume, params):  # P_el\n        temperature_el = self._Tel(temperature, volume, params)\n        if temperature < temperature_el:\n            P_el = 0\n        else:\n            P_el = self._dzetadV(temperature, volume, params) * self._gimel(\n                temperature_el, temperature, volume, params\n            ) + self._zeta(temperature, volume, params) * self._dTeldV(\n                temperature, volume, params\n            ) * self._dgimeldTel(\n                temperature_el, temperature, volume, params\n            )\n        return P_el\n\n    def _K_T_el(self, temperature, volume, params):  # K_T_el\n        temperature_el = self._Tel(temperature, volume, params)\n        if temperature < temperature_el:\n            K_T_el = 0\n        else:\n            K_T_el = -volume * (\n                self._d2zetadV2(temperature, volume, params)\n                * self._gimel(temperature_el, temperature, volume, params)\n                + 2.0\n                * self._dzetadV(temperature, volume, params)\n                * self._dgimeldTel(temperature_el, temperature, volume, params)\n                * self._dTeldV(temperature, volume, params)\n                + self._zeta(temperature, volume, params)\n                * (\n                    self._d2TeldV2(temperature, volume, params)\n                    * self._dgimeldTel(temperature_el, temperature, volume, params)\n                    + self._dTeldV(temperature, volume, params)\n                    * self._dTeldV(temperature, volume, params)\n                    * self._d2gimeldTel2(temperature_el, temperature, volume, params)\n                )\n            )\n        return K_T_el\n\n    def _alphaK_T_el(self, temperature, volume, params):  # (alphaK_T)_el\n        temperature_el = self._Tel(temperature, volume, params)\n        if temperature < temperature_el:\n            alphaK_T_el = 0\n        else:\n            alphaK_T_el = self._dzetadV(temperature, volume, params) * self._dgimeldT(\n                temperature_el, temperature, volume, params\n            ) + self._zeta(temperature, volume, params) * self._d2gimeldTdTel(\n                temperature_el, temperature, volume, params\n            ) * self._dTeldV(\n                temperature, volume, params\n            )\n        return alphaK_T_el\n\n    def _C_v_el(self, temperature, volume, params):  # C_el, eq. 3.28 of de Koker thesis\n        temperature_el = self._Tel(temperature, volume, params)\n        zeta = self._zeta(temperature, volume, params)\n\n        if temperature > temperature_el:\n            Cv_el = zeta * (temperature - temperature_el)\n        else:\n            Cv_el = 0.0\n        return Cv_el\n\n    \"\"\"\n    Excess (bonding) contributions to thermodynamic properties\n    \"\"\"\n\n    # Finite strain\n    def _finite_strain(self, temperature, volume, params):  # f(V), eq. S3a\n        return (1.0 / 2.0) * (np.power(params[\"V_0\"] / volume, 2.0 / 3.0) - 1.0)\n\n    def _dfdV(self, temperature, volume, params):  # f(V), eq. S3a\n        return (-1.0 / 3.0) * np.power(params[\"V_0\"] / volume, 2.0 / 3.0) / volume\n\n    def _d2fdV2(self, temperature, volume, params):\n        return (\n            (5.0 / 9.0) * np.power(params[\"V_0\"] / volume, 2.0 / 3.0) / volume / volume\n        )\n\n    # Temperature\n    def _theta(self, temperature, volume, params):  # theta, eq. S3b\n        return np.power(temperature / params[\"T_0\"], params[\"m\"]) - 1.0\n\n    def _dthetadT(self, temperature, volume, params):\n        return (\n            params[\"m\"]\n            * np.power(temperature / params[\"T_0\"], params[\"m\"])\n            / temperature\n        )\n\n    def _d2thetadT2(self, temperature, volume, params):\n        return (\n            params[\"m\"]\n            * (params[\"m\"] - 1.0)\n            * np.power(temperature / params[\"T_0\"], params[\"m\"])\n            / temperature\n            / temperature\n        )\n\n    def _F_xs(self, temperature, volume, params):  # F_xs, eq. S2\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        energy = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            for j in range(len(params[\"a\"][0])):\n                jfact = factorial(j, exact=False)\n                energy += (\n                    params[\"a\"][i][j]\n                    * np.power(f, i)\n                    * np.power(theta, j)\n                    / ifact\n                    / jfact\n                )\n        return energy\n\n    def _S_xs(self, temperature, volume, params):  # F_xs, eq. 3.18\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        entropy = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            for j in range(len(params[\"a\"][0])):\n                if j > 0:\n                    jfact = factorial(j, exact=False)\n                    entropy += (\n                        j\n                        * params[\"a\"][i][j]\n                        * np.power(f, i)\n                        * np.power(theta, j - 1.0)\n                        / ifact\n                        / jfact\n                    )\n        return -self._dthetadT(temperature, volume, params) * entropy\n\n    def _P_xs(self, temperature, volume, params):  # P_xs, eq. 3.17 of de Koker thesis\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        pressure = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            if i > 0:\n                for j in range(len(params[\"a\"][0])):\n                    jfact = factorial(j, exact=False)\n                    pressure += (\n                        float(i)\n                        * params[\"a\"][i][j]\n                        * np.power(f, float(i) - 1.0)\n                        * np.power(theta, float(j))\n                        / ifact\n                        / jfact\n                    )\n        return -self._dfdV(temperature, volume, params) * pressure\n\n    def _K_T_xs(\n        self, temperature, volume, params\n    ):  # K_T_xs, eq. 3.20 of de Koker thesis\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        K_ToverV = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            for j in range(len(params[\"a\"][0])):\n                if i > 0:\n                    jfact = factorial(j, exact=False)\n                    prefactor = (\n                        float(i)\n                        * params[\"a\"][i][j]\n                        * np.power(theta, float(j))\n                        / ifact\n                        / jfact\n                    )\n                    K_ToverV += (\n                        prefactor\n                        * self._d2fdV2(temperature, volume, params)\n                        * np.power(f, float(i - 1))\n                    )\n                if i > 1:\n                    dfdV = self._dfdV(temperature, volume, params)\n                    K_ToverV += (\n                        prefactor\n                        * dfdV\n                        * dfdV\n                        * float(i - 1)\n                        * np.power(f, float(i - 2))\n                    )\n        return volume * K_ToverV\n\n    def _alphaK_T_xs(self, temperature, volume, params):  # eq. 3.21 of de Koker thesis\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        sum_factors = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            if i > 0:\n                for j in range(len(params[\"a\"][0])):\n                    if j > 0:\n                        jfact = factorial(j, exact=False)\n                        sum_factors += (\n                            float(i)\n                            * float(j)\n                            * params[\"a\"][i][j]\n                            * np.power(f, float(i - 1))\n                            * np.power(theta, float(j - 1))\n                            / ifact\n                            / jfact\n                        )\n\n        return (\n            -self._dfdV(temperature, volume, params)\n            * self._dthetadT(temperature, volume, params)\n            * sum_factors\n        )\n\n    def _C_v_xs(\n        self, temperature, volume, params\n    ):  # Cv_xs, eq. 3.22 of de Koker thesis\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        C_voverT = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            for j in range(len(params[\"a\"][0])):\n                if j > 0:\n                    jfact = factorial(j, exact=False)\n                    prefactor = (\n                        float(j)\n                        * params[\"a\"][i][j]\n                        * np.power(f, float(i))\n                        / ifact\n                        / jfact\n                    )\n                    C_voverT += (\n                        prefactor\n                        * self._d2thetadT2(temperature, volume, params)\n                        * np.power(theta, float(j - 1))\n                    )\n                if j > 1:\n                    dthetadT = self._dthetadT(temperature, volume, params)\n                    C_voverT += (\n                        prefactor\n                        * dthetadT\n                        * dthetadT\n                        * float(j - 1)\n                        * np.power(theta, float(j - 2))\n                    )\n        return -temperature * C_voverT\n\n    \"\"\"\n    Magnetic contributions to thermodynamic properties\n    (as found in Ramo and Stixrude, 2014)\n    \"\"\"\n\n    def _spin(self, temperature, volume, params):\n        S_a = 0.0\n        S_b = 0.0\n        numerator = 0.0\n        numerator_2 = 0.0\n        n_atoms = 0.0\n        if \"spin_a\" in params:\n            for element, N in params[\"formula\"].items():\n                if element == \"Fe\":\n                    n_atoms += N\n\n            VoverVx = volume / params[\"V_0\"]\n            S_a = params[\"spin_a\"][0] + params[\"spin_a\"][1] * VoverVx\n            S_b = (\n                params[\"spin_b\"][0]\n                + params[\"spin_b\"][1] / VoverVx\n                + params[\"spin_b\"][2] / (np.power(VoverVx, 2.0))\n                + params[\"spin_b\"][3] / (np.power(VoverVx, 3.0))\n            )\n\n            # S = S_a*T + S_b\n            # d(2S + 1)/dV\n            numerator = (\n                -2.0\n                * (\n                    -params[\"spin_a\"][1] * temperature\n                    + params[\"spin_b\"][1] / (np.power(VoverVx, 2.0))\n                    + 2.0 * params[\"spin_b\"][2] / (np.power(VoverVx, 3.0))\n                    + 3.0 * params[\"spin_b\"][3] / (np.power(VoverVx, 4.0))\n                )\n                / params[\"V_0\"]\n            )\n\n            # d2S/dV2\n            numerator_2 = 2.0 * (\n                (\n                    2.0 * params[\"spin_b\"][1] / (np.power(VoverVx, 3.0))\n                    + 6.0 * params[\"spin_b\"][2] / (np.power(VoverVx, 4.0))\n                    + 12.0 * params[\"spin_b\"][3] / (np.power(VoverVx, 5.0))\n                )\n                / np.power(params[\"V_0\"], 2.0)\n            )\n        return S_a, S_b, numerator, numerator_2, n_atoms\n\n    def _F_mag(self, temperature, volume, params):\n        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(\n            temperature, volume, params\n        )\n        S = S_a * temperature + S_b\n        return -n_atoms * constants.gas_constant * temperature * np.log(2.0 * S + 1.0)\n\n    def _S_mag(self, temperature, volume, params):\n        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(\n            temperature, volume, params\n        )\n        S = S_a * temperature + S_b\n        return (\n            n_atoms\n            * constants.gas_constant\n            * ((2.0 * S_a * temperature / (2.0 * S + 1.0) + np.log(2.0 * S + 1.0)))\n        )\n\n    def _P_mag(self, temperature, volume, params):\n        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(\n            temperature, volume, params\n        )\n        S = S_a * temperature + S_b\n        dFdV = (\n            -n_atoms\n            * constants.gas_constant\n            * temperature\n            * numerator\n            / (2.0 * S + 1.0)\n        )\n        return -dFdV\n\n    def _K_T_mag(self, temperature, volume, params):\n        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(\n            temperature, volume, params\n        )\n        S = S_a * temperature + S_b\n        dFdV = numerator / (2.0 * S + 1.0)\n        d2FdV2 = numerator_2 / (2.0 * S + 1.0) - np.power(dFdV, 2.0)\n\n        return -volume * n_atoms * constants.gas_constant * temperature * d2FdV2\n\n    def _alphaK_T_mag(\n        self, temperature, volume, params\n    ):  # WARNING: numeric differentiation a.t.m.\n        return self._P_mag(temperature + 0.5, volume, params) - self._P_mag(\n            temperature - 0.5, volume, params\n        )\n\n    def _C_v_mag(self, temperature, volume, params):\n        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(\n            temperature, volume, params\n        )\n        S = S_a * temperature + S_b\n        return (\n            n_atoms\n            * constants.gas_constant\n            * temperature\n            * 4.0\n            * S_a\n            * (S_a * temperature + 2.0 * S_b + 1.0)\n            / np.power(2.0 * S + 1.0, 2.0)\n        )\n\n    def _aK_T(self, temperature, volume, params):\n        aK_T = (\n            self._alphaK_T_ig(temperature, volume, params)\n            + self._alphaK_T_el(temperature, volume, params)\n            + self._alphaK_T_xs(temperature, volume, params)\n            + self._alphaK_T_mag(temperature, volume, params)\n        )\n        return aK_T\n\n    # Pressure\n    def pressure(self, temperature, volume, params):\n        P = (\n            self._P_ig(temperature, volume, params)\n            + self._P_el(temperature, volume, params)\n            + self._P_xs(temperature, volume, params)\n            + self._P_mag(temperature, volume, params)\n        )\n        return P\n\n    def volume(self, pressure, temperature, params):\n        _delta_pressure = (\n            lambda x, pressure, temperature, params: pressure\n            - self.pressure(temperature, x, params)\n        )\n\n        # we need to have a sign change in [a,b] to find a zero. Let us start with a\n        # conservative guess:\n        args = (pressure, temperature, params)\n        try:\n            sol = bracket(_delta_pressure, params[\"V_0\"], 1.0e-2 * params[\"V_0\"], args)\n        except ValueError:\n            raise Exception(\n                \"Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?\"\n            )\n        return opt.brentq(_delta_pressure, sol[0], sol[1], args=args)\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`[Pa]`\n        \"\"\"\n        K_T = (\n            self._K_T_ig(temperature, volume, params)\n            + self._K_T_el(temperature, volume, params)\n            + self._K_T_xs(temperature, volume, params)\n            + self._K_T_mag(temperature, volume, params)\n        )\n        return K_T\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus. :math:`[Pa]`\n        \"\"\"\n        K_S = self.isothermal_bulk_modulus(pressure, temperature, volume, params) * (\n            1.0\n            + temperature\n            * self.thermal_expansivity(pressure, temperature, volume, params)\n            * self.grueneisen_parameter(pressure, temperature, volume, params)\n        )\n        return K_S\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter. :math:`[unitless]`\n        \"\"\"\n        gamma = (\n            self._aK_T(temperature, volume, params)\n            * volume\n            / self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        )\n        return gamma\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus. :math:`[Pa]`\n        Zero for fluids\n        \"\"\"\n        return 0.0\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume. :math:`[J/K/mol]`\n        \"\"\"\n        C_v = (\n            self._C_v_ig(temperature, volume, params)\n            + self._C_v_el(temperature, volume, params)\n            + self._C_v_xs(temperature, volume, params)\n            + self._C_v_mag(temperature, volume, params)\n        )\n        return C_v\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure. :math:`[J/K/mol]`\n        \"\"\"\n        C_p = self.molar_heat_capacity_v(pressure, temperature, volume, params) * (\n            1.0\n            + temperature\n            * self.thermal_expansivity(pressure, temperature, volume, params)\n            * self.grueneisen_parameter(pressure, temperature, volume, params)\n        )\n        return C_p\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity. :math:`[1/K]`\n        \"\"\"\n        alpha = self._aK_T(temperature, volume, params) / self.isothermal_bulk_modulus(\n            0.0, temperature, volume, params\n        )\n        return alpha\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        G = (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n        return G\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy at the pressure and temperature of the mineral [J/K/mol]\n        \"\"\"\n        S = (\n            self._S_ig(temperature, volume, params)\n            + self._S_el(temperature, volume, params)\n            + self._S_xs(temperature, volume, params)\n            + self._S_mag(temperature, volume, params)\n        )\n        return S\n\n    def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        H = (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + temperature * self.entropy(pressure, temperature, volume, params)\n            + pressure * self.volume(pressure, temperature, params)\n        )\n        return H\n\n    def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        F = (\n            self._F_ig(temperature, volume, params)\n            + self._F_el(temperature, volume, params)\n            + self._F_xs(temperature, volume, params)\n            + self._F_mag(temperature, volume, params)\n        )\n        return F\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        E = self.helmholtz_free_energy(\n            pressure, temperature, volume, params\n        ) + temperature * self.entropy(pressure, temperature, volume, params)\n        return E\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\n            \"V_0\",\n            \"T_0\",\n            \"O_theta\",\n            \"O_f\",\n            \"m\",\n            \"a\",\n            \"zeta_0\",\n            \"xi\",\n            \"Tel_0\",\n            \"eta\",\n        ]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Sometimes the standard electronic volume is different to V_0.\n        # If not, make it the same.\n        if \"el_V_0\" not in params:\n            params[\"el_V_0\"] = params[\"V_0\"]",
  "def _ln_partition_function(self, mass, temperature):\n        \"\"\"\n        Calculates the natural log of the partition function\n        \"\"\"\n        return 3.0 / 2.0 * np.log(temperature) + 3.0 / 2.0 * np.log(\n            mass * constants.Boltzmann / (2 * np.pi * constants.Dirac * constants.Dirac)\n        )",
  "def _F_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the helmholtz free energy\n        Eq. S6, see also eq. 16.72 of Callen., 1985; p. 373\n        \"\"\"\n\n        V = volume / constants.Avogadro\n        figoverRT = 0.0\n        for element, N in params[\"formula\"].items():  # N is a.p.f.u\n            if N > 1.0e-5:\n                mass = atomic_masses[element] / constants.Avogadro\n                figoverRT += -N * (\n                    np.log(V) + self._ln_partition_function(mass, temperature) + 1.0\n                ) + N * np.log(N)\n        return constants.gas_constant * temperature * figoverRT",
  "def _S_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the entropy\n        \"\"\"\n\n        V = volume / constants.Avogadro\n        entropy_sum = 0.0\n        for element, N in params[\"formula\"].items():  # N is a.p.f.u\n            if N > 1.0e-5:\n                mass = atomic_masses[element] / constants.Avogadro\n                entropy_sum -= -N * (\n                    np.log(V)\n                    + self._ln_partition_function(mass, temperature)\n                    + 5.0 / 2.0\n                ) + N * np.log(N)\n        return constants.gas_constant * entropy_sum",
  "def _C_v_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the heat capacity\n        \"\"\"\n\n        n_atoms = 0\n        for element, N in params[\"formula\"].items():\n            n_atoms += N\n        return 1.5 * constants.gas_constant * n_atoms",
  "def _P_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the pressure\n        PV = nRT\n        \"\"\"\n\n        n_atoms = 0\n        for element, N in params[\"formula\"].items():\n            n_atoms += N\n        return n_atoms * constants.gas_constant * temperature / volume",
  "def _K_T_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the isothermal bulk modulus\n        V * d/dV(-nRT/V) = V*nRT/V^2\n        \"\"\"\n        n_atoms = 0\n        for element, N in params[\"formula\"].items():\n            n_atoms += N\n        return n_atoms * constants.gas_constant * temperature / volume",
  "def _alphaK_T_ig(self, temperature, volume, params):\n        \"\"\"\n        The ideal gas contribution to the product of the\n        thermal expansivity and isothermal bulk modulus\n        d/dT(nRT/V) = nR/V\n        \"\"\"\n\n        n_atoms = 0\n        for element, N in params[\"formula\"].items():\n            n_atoms += N\n        return n_atoms * constants.gas_constant / volume",
  "def _zeta(\n        self, temperature, volume, params\n    ):  # eq. S5a, beta in deKoker thesis (3.34)\n        return params[\"zeta_0\"] * (np.power(volume / params[\"el_V_0\"], params[\"xi\"]))",
  "def _dzetadV(self, temperature, volume, params):\n        return (\n            params[\"zeta_0\"]\n            * params[\"xi\"]\n            * (np.power(volume / params[\"el_V_0\"], params[\"xi\"]))\n            / volume\n        )",
  "def _d2zetadV2(self, temperature, volume, params):\n        return (\n            params[\"zeta_0\"]\n            * params[\"xi\"]\n            * (params[\"xi\"] - 1.0)\n            * (np.power(volume / params[\"el_V_0\"], params[\"xi\"]))\n            / volume\n            / volume\n        )",
  "def _Tel(self, temperature, volume, params):  # eq. S5b\n        return params[\"Tel_0\"] * (np.power(volume / params[\"el_V_0\"], params[\"eta\"]))",
  "def _dTeldV(self, temperature, volume, params):\n        return (\n            params[\"Tel_0\"]\n            * params[\"eta\"]\n            * (np.power(volume / params[\"el_V_0\"], params[\"eta\"]))\n            / volume\n        )",
  "def _d2TeldV2(self, temperature, volume, params):\n        return (\n            params[\"Tel_0\"]\n            * params[\"eta\"]\n            * (params[\"eta\"] - 1.0)\n            * (np.power(volume / params[\"el_V_0\"], params[\"eta\"]))\n            / volume\n            / volume\n        )",
  "def _gimel(\n        self, temperature_el, temperature, volume, params\n    ):  # -F_el/zeta, 3.30 in de Koker thesis\n        return 0.5 * (\n            temperature * temperature - temperature_el * temperature_el\n        ) - temperature * temperature_el * np.log(temperature / temperature_el)",
  "def _dgimeldTel(self, temperature_el, temperature, volume, params):\n        return (temperature - temperature_el) - temperature * np.log(\n            temperature / temperature_el\n        )",
  "def _dgimeldT(self, temperature_el, temperature, volume, params):\n        return (temperature - temperature_el) - temperature_el * np.log(\n            temperature / temperature_el\n        )",
  "def _d2gimeldTdTel(self, temperature_el, temperature, volume, params):\n        return -np.log(temperature / temperature_el)",
  "def _d2gimeldTel2(self, temperature_el, temperature, volume, params):\n        return (temperature / temperature_el) - 1.0",
  "def _F_el(self, temperature, volume, params):  # F_el\n        temperature_el = self._Tel(temperature, volume, params)\n        if temperature < temperature_el:\n            F_el = 0\n        else:\n            F_el = -self._zeta(temperature, volume, params) * self._gimel(\n                temperature_el, temperature, volume, params\n            )\n        return F_el",
  "def _S_el(self, temperature, volume, params):  # S_el\n        temperature_el = self._Tel(temperature, volume, params)\n        if temperature < temperature_el:\n            S_el = 0\n        else:\n            S_el = self._zeta(temperature, volume, params) * self._dgimeldT(\n                temperature_el, temperature, volume, params\n            )\n        return S_el",
  "def _P_el(self, temperature, volume, params):  # P_el\n        temperature_el = self._Tel(temperature, volume, params)\n        if temperature < temperature_el:\n            P_el = 0\n        else:\n            P_el = self._dzetadV(temperature, volume, params) * self._gimel(\n                temperature_el, temperature, volume, params\n            ) + self._zeta(temperature, volume, params) * self._dTeldV(\n                temperature, volume, params\n            ) * self._dgimeldTel(\n                temperature_el, temperature, volume, params\n            )\n        return P_el",
  "def _K_T_el(self, temperature, volume, params):  # K_T_el\n        temperature_el = self._Tel(temperature, volume, params)\n        if temperature < temperature_el:\n            K_T_el = 0\n        else:\n            K_T_el = -volume * (\n                self._d2zetadV2(temperature, volume, params)\n                * self._gimel(temperature_el, temperature, volume, params)\n                + 2.0\n                * self._dzetadV(temperature, volume, params)\n                * self._dgimeldTel(temperature_el, temperature, volume, params)\n                * self._dTeldV(temperature, volume, params)\n                + self._zeta(temperature, volume, params)\n                * (\n                    self._d2TeldV2(temperature, volume, params)\n                    * self._dgimeldTel(temperature_el, temperature, volume, params)\n                    + self._dTeldV(temperature, volume, params)\n                    * self._dTeldV(temperature, volume, params)\n                    * self._d2gimeldTel2(temperature_el, temperature, volume, params)\n                )\n            )\n        return K_T_el",
  "def _alphaK_T_el(self, temperature, volume, params):  # (alphaK_T)_el\n        temperature_el = self._Tel(temperature, volume, params)\n        if temperature < temperature_el:\n            alphaK_T_el = 0\n        else:\n            alphaK_T_el = self._dzetadV(temperature, volume, params) * self._dgimeldT(\n                temperature_el, temperature, volume, params\n            ) + self._zeta(temperature, volume, params) * self._d2gimeldTdTel(\n                temperature_el, temperature, volume, params\n            ) * self._dTeldV(\n                temperature, volume, params\n            )\n        return alphaK_T_el",
  "def _C_v_el(self, temperature, volume, params):  # C_el, eq. 3.28 of de Koker thesis\n        temperature_el = self._Tel(temperature, volume, params)\n        zeta = self._zeta(temperature, volume, params)\n\n        if temperature > temperature_el:\n            Cv_el = zeta * (temperature - temperature_el)\n        else:\n            Cv_el = 0.0\n        return Cv_el",
  "def _finite_strain(self, temperature, volume, params):  # f(V), eq. S3a\n        return (1.0 / 2.0) * (np.power(params[\"V_0\"] / volume, 2.0 / 3.0) - 1.0)",
  "def _dfdV(self, temperature, volume, params):  # f(V), eq. S3a\n        return (-1.0 / 3.0) * np.power(params[\"V_0\"] / volume, 2.0 / 3.0) / volume",
  "def _d2fdV2(self, temperature, volume, params):\n        return (\n            (5.0 / 9.0) * np.power(params[\"V_0\"] / volume, 2.0 / 3.0) / volume / volume\n        )",
  "def _theta(self, temperature, volume, params):  # theta, eq. S3b\n        return np.power(temperature / params[\"T_0\"], params[\"m\"]) - 1.0",
  "def _dthetadT(self, temperature, volume, params):\n        return (\n            params[\"m\"]\n            * np.power(temperature / params[\"T_0\"], params[\"m\"])\n            / temperature\n        )",
  "def _d2thetadT2(self, temperature, volume, params):\n        return (\n            params[\"m\"]\n            * (params[\"m\"] - 1.0)\n            * np.power(temperature / params[\"T_0\"], params[\"m\"])\n            / temperature\n            / temperature\n        )",
  "def _F_xs(self, temperature, volume, params):  # F_xs, eq. S2\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        energy = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            for j in range(len(params[\"a\"][0])):\n                jfact = factorial(j, exact=False)\n                energy += (\n                    params[\"a\"][i][j]\n                    * np.power(f, i)\n                    * np.power(theta, j)\n                    / ifact\n                    / jfact\n                )\n        return energy",
  "def _S_xs(self, temperature, volume, params):  # F_xs, eq. 3.18\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        entropy = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            for j in range(len(params[\"a\"][0])):\n                if j > 0:\n                    jfact = factorial(j, exact=False)\n                    entropy += (\n                        j\n                        * params[\"a\"][i][j]\n                        * np.power(f, i)\n                        * np.power(theta, j - 1.0)\n                        / ifact\n                        / jfact\n                    )\n        return -self._dthetadT(temperature, volume, params) * entropy",
  "def _P_xs(self, temperature, volume, params):  # P_xs, eq. 3.17 of de Koker thesis\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        pressure = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            if i > 0:\n                for j in range(len(params[\"a\"][0])):\n                    jfact = factorial(j, exact=False)\n                    pressure += (\n                        float(i)\n                        * params[\"a\"][i][j]\n                        * np.power(f, float(i) - 1.0)\n                        * np.power(theta, float(j))\n                        / ifact\n                        / jfact\n                    )\n        return -self._dfdV(temperature, volume, params) * pressure",
  "def _K_T_xs(\n        self, temperature, volume, params\n    ):  # K_T_xs, eq. 3.20 of de Koker thesis\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        K_ToverV = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            for j in range(len(params[\"a\"][0])):\n                if i > 0:\n                    jfact = factorial(j, exact=False)\n                    prefactor = (\n                        float(i)\n                        * params[\"a\"][i][j]\n                        * np.power(theta, float(j))\n                        / ifact\n                        / jfact\n                    )\n                    K_ToverV += (\n                        prefactor\n                        * self._d2fdV2(temperature, volume, params)\n                        * np.power(f, float(i - 1))\n                    )\n                if i > 1:\n                    dfdV = self._dfdV(temperature, volume, params)\n                    K_ToverV += (\n                        prefactor\n                        * dfdV\n                        * dfdV\n                        * float(i - 1)\n                        * np.power(f, float(i - 2))\n                    )\n        return volume * K_ToverV",
  "def _alphaK_T_xs(self, temperature, volume, params):  # eq. 3.21 of de Koker thesis\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        sum_factors = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            if i > 0:\n                for j in range(len(params[\"a\"][0])):\n                    if j > 0:\n                        jfact = factorial(j, exact=False)\n                        sum_factors += (\n                            float(i)\n                            * float(j)\n                            * params[\"a\"][i][j]\n                            * np.power(f, float(i - 1))\n                            * np.power(theta, float(j - 1))\n                            / ifact\n                            / jfact\n                        )\n\n        return (\n            -self._dfdV(temperature, volume, params)\n            * self._dthetadT(temperature, volume, params)\n            * sum_factors\n        )",
  "def _C_v_xs(\n        self, temperature, volume, params\n    ):  # Cv_xs, eq. 3.22 of de Koker thesis\n        f = self._finite_strain(temperature, volume, params)\n        theta = self._theta(temperature, volume, params)\n        C_voverT = 0.0\n        for i in range(len(params[\"a\"])):\n            ifact = factorial(i, exact=False)\n            for j in range(len(params[\"a\"][0])):\n                if j > 0:\n                    jfact = factorial(j, exact=False)\n                    prefactor = (\n                        float(j)\n                        * params[\"a\"][i][j]\n                        * np.power(f, float(i))\n                        / ifact\n                        / jfact\n                    )\n                    C_voverT += (\n                        prefactor\n                        * self._d2thetadT2(temperature, volume, params)\n                        * np.power(theta, float(j - 1))\n                    )\n                if j > 1:\n                    dthetadT = self._dthetadT(temperature, volume, params)\n                    C_voverT += (\n                        prefactor\n                        * dthetadT\n                        * dthetadT\n                        * float(j - 1)\n                        * np.power(theta, float(j - 2))\n                    )\n        return -temperature * C_voverT",
  "def _spin(self, temperature, volume, params):\n        S_a = 0.0\n        S_b = 0.0\n        numerator = 0.0\n        numerator_2 = 0.0\n        n_atoms = 0.0\n        if \"spin_a\" in params:\n            for element, N in params[\"formula\"].items():\n                if element == \"Fe\":\n                    n_atoms += N\n\n            VoverVx = volume / params[\"V_0\"]\n            S_a = params[\"spin_a\"][0] + params[\"spin_a\"][1] * VoverVx\n            S_b = (\n                params[\"spin_b\"][0]\n                + params[\"spin_b\"][1] / VoverVx\n                + params[\"spin_b\"][2] / (np.power(VoverVx, 2.0))\n                + params[\"spin_b\"][3] / (np.power(VoverVx, 3.0))\n            )\n\n            # S = S_a*T + S_b\n            # d(2S + 1)/dV\n            numerator = (\n                -2.0\n                * (\n                    -params[\"spin_a\"][1] * temperature\n                    + params[\"spin_b\"][1] / (np.power(VoverVx, 2.0))\n                    + 2.0 * params[\"spin_b\"][2] / (np.power(VoverVx, 3.0))\n                    + 3.0 * params[\"spin_b\"][3] / (np.power(VoverVx, 4.0))\n                )\n                / params[\"V_0\"]\n            )\n\n            # d2S/dV2\n            numerator_2 = 2.0 * (\n                (\n                    2.0 * params[\"spin_b\"][1] / (np.power(VoverVx, 3.0))\n                    + 6.0 * params[\"spin_b\"][2] / (np.power(VoverVx, 4.0))\n                    + 12.0 * params[\"spin_b\"][3] / (np.power(VoverVx, 5.0))\n                )\n                / np.power(params[\"V_0\"], 2.0)\n            )\n        return S_a, S_b, numerator, numerator_2, n_atoms",
  "def _F_mag(self, temperature, volume, params):\n        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(\n            temperature, volume, params\n        )\n        S = S_a * temperature + S_b\n        return -n_atoms * constants.gas_constant * temperature * np.log(2.0 * S + 1.0)",
  "def _S_mag(self, temperature, volume, params):\n        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(\n            temperature, volume, params\n        )\n        S = S_a * temperature + S_b\n        return (\n            n_atoms\n            * constants.gas_constant\n            * ((2.0 * S_a * temperature / (2.0 * S + 1.0) + np.log(2.0 * S + 1.0)))\n        )",
  "def _P_mag(self, temperature, volume, params):\n        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(\n            temperature, volume, params\n        )\n        S = S_a * temperature + S_b\n        dFdV = (\n            -n_atoms\n            * constants.gas_constant\n            * temperature\n            * numerator\n            / (2.0 * S + 1.0)\n        )\n        return -dFdV",
  "def _K_T_mag(self, temperature, volume, params):\n        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(\n            temperature, volume, params\n        )\n        S = S_a * temperature + S_b\n        dFdV = numerator / (2.0 * S + 1.0)\n        d2FdV2 = numerator_2 / (2.0 * S + 1.0) - np.power(dFdV, 2.0)\n\n        return -volume * n_atoms * constants.gas_constant * temperature * d2FdV2",
  "def _alphaK_T_mag(\n        self, temperature, volume, params\n    ):  # WARNING: numeric differentiation a.t.m.\n        return self._P_mag(temperature + 0.5, volume, params) - self._P_mag(\n            temperature - 0.5, volume, params\n        )",
  "def _C_v_mag(self, temperature, volume, params):\n        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(\n            temperature, volume, params\n        )\n        S = S_a * temperature + S_b\n        return (\n            n_atoms\n            * constants.gas_constant\n            * temperature\n            * 4.0\n            * S_a\n            * (S_a * temperature + 2.0 * S_b + 1.0)\n            / np.power(2.0 * S + 1.0, 2.0)\n        )",
  "def _aK_T(self, temperature, volume, params):\n        aK_T = (\n            self._alphaK_T_ig(temperature, volume, params)\n            + self._alphaK_T_el(temperature, volume, params)\n            + self._alphaK_T_xs(temperature, volume, params)\n            + self._alphaK_T_mag(temperature, volume, params)\n        )\n        return aK_T",
  "def pressure(self, temperature, volume, params):\n        P = (\n            self._P_ig(temperature, volume, params)\n            + self._P_el(temperature, volume, params)\n            + self._P_xs(temperature, volume, params)\n            + self._P_mag(temperature, volume, params)\n        )\n        return P",
  "def volume(self, pressure, temperature, params):\n        _delta_pressure = (\n            lambda x, pressure, temperature, params: pressure\n            - self.pressure(temperature, x, params)\n        )\n\n        # we need to have a sign change in [a,b] to find a zero. Let us start with a\n        # conservative guess:\n        args = (pressure, temperature, params)\n        try:\n            sol = bracket(_delta_pressure, params[\"V_0\"], 1.0e-2 * params[\"V_0\"], args)\n        except ValueError:\n            raise Exception(\n                \"Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?\"\n            )\n        return opt.brentq(_delta_pressure, sol[0], sol[1], args=args)",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`[Pa]`\n        \"\"\"\n        K_T = (\n            self._K_T_ig(temperature, volume, params)\n            + self._K_T_el(temperature, volume, params)\n            + self._K_T_xs(temperature, volume, params)\n            + self._K_T_mag(temperature, volume, params)\n        )\n        return K_T",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus. :math:`[Pa]`\n        \"\"\"\n        K_S = self.isothermal_bulk_modulus(pressure, temperature, volume, params) * (\n            1.0\n            + temperature\n            * self.thermal_expansivity(pressure, temperature, volume, params)\n            * self.grueneisen_parameter(pressure, temperature, volume, params)\n        )\n        return K_S",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter. :math:`[unitless]`\n        \"\"\"\n        gamma = (\n            self._aK_T(temperature, volume, params)\n            * volume\n            / self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        )\n        return gamma",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus. :math:`[Pa]`\n        Zero for fluids\n        \"\"\"\n        return 0.0",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume. :math:`[J/K/mol]`\n        \"\"\"\n        C_v = (\n            self._C_v_ig(temperature, volume, params)\n            + self._C_v_el(temperature, volume, params)\n            + self._C_v_xs(temperature, volume, params)\n            + self._C_v_mag(temperature, volume, params)\n        )\n        return C_v",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure. :math:`[J/K/mol]`\n        \"\"\"\n        C_p = self.molar_heat_capacity_v(pressure, temperature, volume, params) * (\n            1.0\n            + temperature\n            * self.thermal_expansivity(pressure, temperature, volume, params)\n            * self.grueneisen_parameter(pressure, temperature, volume, params)\n        )\n        return C_p",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity. :math:`[1/K]`\n        \"\"\"\n        alpha = self._aK_T(temperature, volume, params) / self.isothermal_bulk_modulus(\n            0.0, temperature, volume, params\n        )\n        return alpha",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        G = (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n        return G",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy at the pressure and temperature of the mineral [J/K/mol]\n        \"\"\"\n        S = (\n            self._S_ig(temperature, volume, params)\n            + self._S_el(temperature, volume, params)\n            + self._S_xs(temperature, volume, params)\n            + self._S_mag(temperature, volume, params)\n        )\n        return S",
  "def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        H = (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + temperature * self.entropy(pressure, temperature, volume, params)\n            + pressure * self.volume(pressure, temperature, params)\n        )\n        return H",
  "def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        F = (\n            self._F_ig(temperature, volume, params)\n            + self._F_el(temperature, volume, params)\n            + self._F_xs(temperature, volume, params)\n            + self._F_mag(temperature, volume, params)\n        )\n        return F",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        E = self.helmholtz_free_energy(\n            pressure, temperature, volume, params\n        ) + temperature * self.entropy(pressure, temperature, volume, params)\n        return E",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\n            \"V_0\",\n            \"T_0\",\n            \"O_theta\",\n            \"O_f\",\n            \"m\",\n            \"a\",\n            \"zeta_0\",\n            \"xi\",\n            \"Tel_0\",\n            \"eta\",\n        ]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Sometimes the standard electronic volume is different to V_0.\n        # If not, make it the same.\n        if \"el_V_0\" not in params:\n            params[\"el_V_0\"] = params[\"V_0\"]",
  "def bulk_modulus(volume, params):\n    \"\"\"\n    compute the bulk modulus as per the third order\n    birch-murnaghan equation of state.  Returns bulk\n    modulus in the same units as the reference bulk\n    modulus.  Pressure must be in :math:`[Pa]`.\n    \"\"\"\n\n    x = params[\"V_0\"] / volume\n    f = 0.5 * (pow(x, 2.0 / 3.0) - 1.0)\n\n    K = pow(1.0 + 2.0 * f, 5.0 / 2.0) * (\n        params[\"K_0\"]\n        + (3.0 * params[\"K_0\"] * params[\"Kprime_0\"] - 5 * params[\"K_0\"]) * f\n        + 27.0\n        / 2.0\n        * (params[\"K_0\"] * params[\"Kprime_0\"] - 4.0 * params[\"K_0\"])\n        * f\n        * f\n    )\n    return K",
  "def birch_murnaghan(x, params):\n    \"\"\"\n    equation for the third order birch-murnaghan equation of state, returns\n    pressure in the same units that are supplied for the reference bulk\n    modulus (params['K_0'])\n    \"\"\"\n\n    return (\n        3.0\n        * params[\"K_0\"]\n        / 2.0\n        * (pow(x, 7.0 / 3.0) - pow(x, 5.0 / 3.0))\n        * (1.0 - 0.75 * (4.0 - params[\"Kprime_0\"]) * (pow(x, 2.0 / 3.0) - 1.0))\n        + params[\"P_0\"]\n    )",
  "def volume(pressure, params):\n    \"\"\"\n    Get the birch-murnaghan volume at a reference temperature for a given\n    pressure :math:`[Pa]`. Returns molar volume in :math:`[m^3]`\n    \"\"\"\n\n    func = lambda x: birch_murnaghan(params[\"V_0\"] / x, params) - pressure\n    try:\n        sol = bracket(func, params[\"V_0\"], 1.0e-2 * params[\"V_0\"])\n    except:\n        raise ValueError(\n            \"Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?\"\n        )\n    return opt.brentq(func, sol[0], sol[1])",
  "def shear_modulus_second_order(volume, params):\n    \"\"\"\n    Get the birch murnaghan shear modulus at a reference temperature, for a\n    given volume.  Returns shear modulus in :math:`[Pa]` (the same units as in\n    params['G_0']).  This uses a second order finite strain expansion\n    \"\"\"\n\n    x = params[\"V_0\"] / volume\n    G = (\n        params[\"G_0\"]\n        * pow(x, 5.0 / 3.0)\n        * (\n            1.0\n            - 0.5\n            * (pow(x, 2.0 / 3.0) - 1.0)\n            * (5.0 - 3.0 * params[\"Gprime_0\"] * params[\"K_0\"] / params[\"G_0\"])\n        )\n    )\n    return G",
  "def shear_modulus_third_order(volume, params):\n    \"\"\"\n    Get the birch murnaghan shear modulus at a reference temperature, for a\n    given volume.  Returns shear modulus in :math:`[Pa]` (the same units as in\n    params['G_0']).  This uses a third order finite strain expansion\n    \"\"\"\n\n    x = params[\"V_0\"] / volume\n    f = 0.5 * (pow(x, 2.0 / 3.0) - 1.0)\n    G = pow((1.0 + 2.0 * f), 5.0 / 2.0) * (\n        params[\"G_0\"]\n        + (3.0 * params[\"K_0\"] * params[\"Gprime_0\"] - 5.0 * params[\"G_0\"]) * f\n        + (\n            6.0 * params[\"K_0\"] * params[\"Gprime_0\"]\n            - 24.0 * params[\"K_0\"]\n            - 14.0 * params[\"G_0\"]\n            + 9.0 / 2.0 * params[\"K_0\"] * params[\"Kprime_0\"]\n        )\n        * f\n        * f\n    )\n    return G",
  "class BirchMurnaghanBase(eos.EquationOfState):\n\n    \"\"\"\n    Base class for the isothermal Birch Murnaghan equation of state.  This is third order in strain, and\n    has no temperature dependence.  However, the shear modulus is sometimes fit to a second order\n    function, so if this is the case, you should use that.  For more see :class:`burnman.birch_murnaghan.BM2` and :class:`burnman.birch_murnaghan.BM3`.\n    \"\"\"\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume(pressure, params)\n\n    def pressure(self, temperature, volume, params):\n        return birch_murnaghan(params[\"V_0\"] / volume, params)\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus(volume, params)\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(volume, params)\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        \"\"\"\n        if self.order == 2:\n            return shear_modulus_second_order(volume, params)\n        elif self.order == 3:\n            return shear_modulus_third_order(volume, params)\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        x = np.power(volume / params[\"V_0\"], -1.0 / 3.0)\n        x2 = x * x\n        x4 = x2 * x2\n        x6 = x4 * x2\n        x8 = x4 * x4\n\n        xi1 = 3.0 * (4.0 - params[\"Kprime_0\"]) / 4.0\n\n        intPdV = (\n            -9.0\n            / 2.0\n            * params[\"V_0\"]\n            * params[\"K_0\"]\n            * (\n                (xi1 + 1.0) * (x4 / 4.0 - x2 / 2.0 + 1.0 / 4.0)\n                - xi1 * (x6 / 6.0 - x4 / 4.0 + 1.0 / 12.0)\n            )\n        )\n\n        return -intPdV + params[\"E_0\"]\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # G = int VdP = [PV] - int PdV = E + PV\n\n        return (\n            self.molar_internal_energy(pressure, temperature, volume, params)\n            + volume * pressure\n        )\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # If G and Gprime are not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\", \"G_0\", \"Gprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 20.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)\n        if params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)",
  "class BM3(BirchMurnaghanBase):\n\n    \"\"\"\n    Third order Birch Murnaghan isothermal equation of state.\n    This uses the third order expansion for shear modulus.\n    \"\"\"\n\n    def __init__(self):\n        self.order = 3",
  "class BM2(BirchMurnaghanBase):\n\n    \"\"\"\n    Third order Birch Murnaghan isothermal equation of state.\n    This uses the second order expansion for shear modulus.\n    \"\"\"\n\n    def __init__(self):\n        self.order = 2",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume(pressure, params)",
  "def pressure(self, temperature, volume, params):\n        return birch_murnaghan(params[\"V_0\"] / volume, params)",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus(volume, params)",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(volume, params)",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        \"\"\"\n        if self.order == 2:\n            return shear_modulus_second_order(volume, params)\n        elif self.order == 3:\n            return shear_modulus_third_order(volume, params)",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        x = np.power(volume / params[\"V_0\"], -1.0 / 3.0)\n        x2 = x * x\n        x4 = x2 * x2\n        x6 = x4 * x2\n        x8 = x4 * x4\n\n        xi1 = 3.0 * (4.0 - params[\"Kprime_0\"]) / 4.0\n\n        intPdV = (\n            -9.0\n            / 2.0\n            * params[\"V_0\"]\n            * params[\"K_0\"]\n            * (\n                (xi1 + 1.0) * (x4 / 4.0 - x2 / 2.0 + 1.0 / 4.0)\n                - xi1 * (x6 / 6.0 - x4 / 4.0 + 1.0 / 12.0)\n            )\n        )\n\n        return -intPdV + params[\"E_0\"]",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # G = int VdP = [PV] - int PdV = E + PV\n\n        return (\n            self.molar_internal_energy(pressure, temperature, volume, params)\n            + volume * pressure\n        )",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # If G and Gprime are not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\", \"G_0\", \"Gprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 20.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)\n        if params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)",
  "def __init__(self):\n        self.order = 3",
  "def __init__(self):\n        self.order = 2",
  "def volume(pressure, V_0, K_0, Kprime_0):\n    return V_0 * np.power(1.0 + (pressure * Kprime_0 / K_0), -1.0 / Kprime_0)",
  "def pressure(volume, V_0, K_0, Kprime_0):\n    return K_0 / Kprime_0 * (np.power(volume / V_0, -Kprime_0) - 1.0)",
  "def bulk_modulus(pressure, K_0, Kprime_0):\n    return K_0 + pressure * Kprime_0",
  "def energy(volume, E_0, V_0, K_0, Kprime_0):\n    Vrel = volume / V_0\n    return E_0 + K_0 * V_0 * (\n        np.power(Vrel, 1.0 - Kprime_0) / (Kprime_0 * (Kprime_0 - 1))\n        + Vrel / Kprime_0\n        - 1.0 / (Kprime_0 - 1.0)\n    )",
  "def intVdP(pressure, V_0, K_0, Kprime_0):\n    return (\n        V_0\n        * K_0\n        * ((np.power(1.0 + (pressure * Kprime_0 / K_0), 1.0 - (1.0 / Kprime_0))) - 1.0)\n        / (Kprime_0 - 1.0)\n    )",
  "class Murnaghan(eos.EquationOfState):\n\n    \"\"\"\n    Base class for the isothermal Murnaghan equation of state,\n    as described in :cite:`Murnaghan1944`.\n    \"\"\"\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume(pressure, params[\"V_0\"], params[\"K_0\"], params[\"Kprime_0\"])\n\n    def pressure(self, temperature, volume, params):\n        return pressure(volume, params[\"V_0\"], params[\"K_0\"], params[\"Kprime_0\"])\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]`\n        as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus(pressure, params[\"K_0\"], params[\"Kprime_0\"])\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(pressure, params[\"K_0\"], params[\"Kprime_0\"])\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        Currently not included in the Murnghan EOS, so omitted.\n        \"\"\"\n        return 0.0\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral.\n        :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral.\n        :math:`[J/mol]`\n        \"\"\"\n        return energy(\n            volume, params[\"E_0\"], params[\"V_0\"], params[\"K_0\"], params[\"Kprime_0\"]\n        )\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral.\n        :math:`[J/mol]`\n        \"\"\"\n        # G = E + PV\n        return (\n            self.molar_internal_energy(pressure, temperature, volume, params)\n            + volume * pressure\n        )\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects,\n        return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects,\n        return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects,\n        return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects,\n        return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # G is not included in the Murnaghan EOS so we shall set them to NaN's\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # now check that the values are reasonable.  I mostly just\n        # made up these values from experience, and we are only\n        # raising a warning.  Better way to do this? [IR]\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < -5.0 or params[\"Kprime_0\"] > 30.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume(pressure, params[\"V_0\"], params[\"K_0\"], params[\"Kprime_0\"])",
  "def pressure(self, temperature, volume, params):\n        return pressure(volume, params[\"V_0\"], params[\"K_0\"], params[\"Kprime_0\"])",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]`\n        as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus(pressure, params[\"K_0\"], params[\"Kprime_0\"])",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(pressure, params[\"K_0\"], params[\"Kprime_0\"])",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        Currently not included in the Murnghan EOS, so omitted.\n        \"\"\"\n        return 0.0",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral.\n        :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral.\n        :math:`[J/mol]`\n        \"\"\"\n        return energy(\n            volume, params[\"E_0\"], params[\"V_0\"], params[\"K_0\"], params[\"Kprime_0\"]\n        )",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral.\n        :math:`[J/mol]`\n        \"\"\"\n        # G = E + PV\n        return (\n            self.molar_internal_energy(pressure, temperature, volume, params)\n            + volume * pressure\n        )",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects,\n        return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects,\n        return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects,\n        return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects,\n        return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # G is not included in the Murnaghan EOS so we shall set them to NaN's\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # now check that the values are reasonable.  I mostly just\n        # made up these values from experience, and we are only\n        # raising a warning.  Better way to do this? [IR]\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < -5.0 or params[\"Kprime_0\"] > 30.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)",
  "def _landau_excesses(pressure, temperature, params):\n    \"\"\"\n    Applies a tricritical Landau correction to the properties\n    of an endmember which undergoes a displacive phase transition.\n    This correction follows Putnis (1992), and is done relative to\n    the completely *ordered* state (at 0 K).\n    It therefore differs in implementation from both\n    Stixrude and Lithgow-Bertelloni (2011) and\n    Holland and Powell (2011), who compute properties relative to\n    the completely disordered state and standard states respectively.\n\n    The excess entropy (and heat capacity) terms are equal to zero at 0 K.\n\n    N.B. The excesses are for a *completely relaxed* mineral;\n    for example, seismic wave propagation is *slow* compared to the\n    rate of change in order parameter.\n    \"\"\"\n\n    Tc = params[\"Tc_0\"] + params[\"V_D\"] * pressure / params[\"S_D\"]\n\n    G_disordered = -params[\"S_D\"] * ((temperature - Tc) + params[\"Tc_0\"] / 3.0)\n    dGdT_disordered = -params[\"S_D\"]\n    dGdP_disordered = params[\"V_D\"]\n\n    if temperature < Tc:\n        # Wolfram input to check partial differentials\n        # x = T, y = P, a = S, c = Tc0, d = V\n        # D[D[a ((x - c - d*y/a)*(1 - x/(c + d*y/a))^0.5 + c/3*(1 - x/(c +\n        # d*y/a))^1.5), x], x]\n        Q2 = np.sqrt(1.0 - temperature / Tc)\n        G = (\n            params[\"S_D\"]\n            * ((temperature - Tc) * Q2 + params[\"Tc_0\"] * Q2 * Q2 * Q2 / 3.0)\n            + G_disordered\n        )\n        dGdP = (\n            -params[\"V_D\"]\n            * Q2\n            * (1.0 + 0.5 * temperature / Tc * (1.0 - params[\"Tc_0\"] / Tc))\n            + dGdP_disordered\n        )\n        dGdT = params[\"S_D\"] * Q2 * (1.5 - 0.5 * params[\"Tc_0\"] / Tc) + dGdT_disordered\n        d2GdP2 = (\n            params[\"V_D\"]\n            * params[\"V_D\"]\n            * temperature\n            / (params[\"S_D\"] * Tc * Tc * Q2)\n            * (\n                temperature * (1.0 + params[\"Tc_0\"] / Tc) / (4.0 * Tc)\n                + Q2 * Q2 * (1.0 - params[\"Tc_0\"] / Tc)\n                - 1.0\n            )\n        )\n        d2GdT2 = -params[\"S_D\"] / (Tc * Q2) * (0.75 - 0.25 * params[\"Tc_0\"] / Tc)\n        d2GdPdT = (\n            params[\"V_D\"]\n            / (2.0 * Tc * Q2)\n            * (1.0 + (temperature / (2.0 * Tc) - Q2 * Q2) * (1.0 - params[\"Tc_0\"] / Tc))\n        )\n\n    else:\n        Q2 = 0.0\n        G = G_disordered\n        dGdT = dGdT_disordered\n        dGdP = dGdP_disordered\n        d2GdT2 = 0.0\n        d2GdP2 = 0.0\n        d2GdPdT = 0.0\n\n    excesses = {\n        \"G\": G,\n        \"dGdT\": dGdT,\n        \"dGdP\": dGdP,\n        \"d2GdT2\": d2GdT2,\n        \"d2GdP2\": d2GdP2,\n        \"d2GdPdT\": d2GdPdT,\n    }\n\n    return (excesses, {\"Q\": np.sqrt(Q2)})",
  "def _landau_slb_2022_excesses(pressure, temperature, params):\n    \"\"\"\n    Applies a tricritical Landau correction to the properties\n    of an endmember which undergoes a displacive phase transition.\n    This correction follows Stixrude and Lithgow-Bertelloni (2022),\n    and is done relative to the state with order parameter Q=1.\n\n    The order parameter of this formulation can exceed one,\n    at odds with Putnis (above), but in better agreement with\n    atomic intuition (Stixrude and Lithgow-Bertelloni, 2022).\n    Nevertheless, this implementation is still not perfect,\n    as the excess entropy (and heat capacity) terms are not equal\n    to zero at 0 K. Q is limited to values less than or equal to 2\n    to avoid unrealistic stabilisation at ultrahigh pressure.\n\n    N.B. These excesses are for a *completely relaxed* mineral;\n    for example, seismic wave propagation is *slow* compared to the\n    rate of change in order parameter.\n    \"\"\"\n\n    Tc = params[\"Tc_0\"] + params[\"V_D\"] * pressure / params[\"S_D\"]\n\n    G_disordered = -params[\"S_D\"] * ((temperature - Tc) + params[\"Tc_0\"] / 3.0)\n    dGdT_disordered = -params[\"S_D\"]\n    dGdP_disordered = params[\"V_D\"]\n\n    if temperature < Tc:\n        Q2 = np.sqrt((Tc - temperature) / params[\"Tc_0\"])\n\n        if Q2 < 4.0:\n            # Wolfram input to check partial differentials\n            # x = T, y = P, a = S, c = Tc0, d = V\n            # D[D[a ((x - c - d*y/a)*((c + d*y/a - x)/c)^0.5\n            # + c/3*((c + d*y/a - x)/c)^1.5), x], x]\n            # where Q2 = ((c + d*y/a - x)/c)^0.5\n            G = (\n                params[\"S_D\"]\n                * ((temperature - Tc) * Q2 + params[\"Tc_0\"] * Q2 * Q2 * Q2 / 3.0)\n                + G_disordered\n            )\n            dGdP = -params[\"V_D\"] * Q2 + dGdP_disordered\n            dGdT = params[\"S_D\"] * Q2 + dGdT_disordered\n            d2GdP2 = (\n                -0.5\n                * params[\"V_D\"]\n                * params[\"V_D\"]\n                / (params[\"S_D\"] * params[\"Tc_0\"] * Q2)\n            )\n            d2GdT2 = -0.5 * params[\"S_D\"] / (Tc * Q2)\n            d2GdPdT = 0.5 * params[\"V_D\"] / (Tc * Q2)\n        else:\n            # Wolfram input to check partial differentials\n            # x = T, y = P, a = S, c = Tc0, d = V\n            # D[D[a ((x - c - d*y/a)*4 + c/3*64), x], x]\n            G = (\n                params[\"S_D\"] * ((temperature - Tc) * 4.0 + params[\"Tc_0\"] * 64.0 / 3.0)\n                + G_disordered\n            )\n            dGdP = -params[\"V_D\"] * 4.0 + dGdP_disordered\n            dGdT = params[\"S_D\"] * 4.0 + dGdT_disordered\n            d2GdP2 = 0.0\n            d2GdT2 = 0.0\n            d2GdPdT = 0.0\n\n    else:\n        Q2 = 0.0\n        G = G_disordered\n        dGdT = dGdT_disordered\n        dGdP = dGdP_disordered\n        d2GdT2 = 0.0\n        d2GdP2 = 0.0\n        d2GdPdT = 0.0\n\n    excesses = {\n        \"G\": G,\n        \"dGdT\": dGdT,\n        \"dGdP\": dGdP,\n        \"d2GdT2\": d2GdT2,\n        \"d2GdP2\": d2GdP2,\n        \"d2GdPdT\": d2GdPdT,\n    }\n\n    return (excesses, {\"Q\": np.sqrt(Q2)})",
  "def _landau_hp_excesses(pressure, temperature, params):\n    \"\"\"\n    Applies a tricritical Landau correction to the properties\n    of an endmember which undergoes a displacive phase transition.\n    This correction is done relative to the standard state, as per\n    Holland and Powell (1998).\n\n    Includes the correction published within landaunote.pdf\n    (Holland, pers. comm), which 'corrects' the terms involving\n    the critical temperature Tc / Tc*\n\n    This formalism predicts that the order parameter can be greater\n    than one, unlike _landau_excesses.\n\n    N.B. The excesses are for a *completely relaxed* mineral;\n    i.e. the seismic wave propagation is *slow* compared to the\n    rate of change in order parameter.\n    \"\"\"\n\n    P = pressure\n    T = temperature\n\n    if params[\"T_0\"] < params[\"Tc_0\"]:\n        Q_0 = np.power((params[\"Tc_0\"] - params[\"T_0\"]) / params[\"Tc_0\"], 0.25)\n    else:\n        Q_0 = 0.0\n\n    Tc = params[\"Tc_0\"] + params[\"V_D\"] * (P - params[\"P_0\"]) / params[\"S_D\"]\n    if T < Tc:\n        Q = np.power((Tc - T) / params[\"Tc_0\"], 0.25)\n    else:\n        Q = 0.0\n\n    # Gibbs\n    G = (\n        params[\"Tc_0\"] * params[\"S_D\"] * (Q_0 * Q_0 - np.power(Q_0, 6.0) / 3.0)\n        - params[\"S_D\"] * (Tc * Q * Q - params[\"Tc_0\"] * np.power(Q, 6.0) / 3.0)\n        - T * params[\"S_D\"] * (Q_0 * Q_0 - Q * Q)\n        + (P - params[\"P_0\"]) * params[\"V_D\"] * Q_0 * Q_0\n    )\n\n    dGdT = params[\"S_D\"] * (Q * Q - Q_0 * Q_0)\n    dGdP = -params[\"V_D\"] * (Q * Q - Q_0 * Q_0)\n\n    if Q > 1.0e-12:\n        d2GdT2 = -params[\"S_D\"] / (2.0 * params[\"Tc_0\"] * Q * Q)\n        d2GdP2 = (\n            -params[\"V_D\"]\n            * params[\"V_D\"]\n            / (2.0 * params[\"S_D\"] * params[\"Tc_0\"] * Q * Q)\n        )\n        d2GdPdT = params[\"V_D\"] / (2.0 * params[\"Tc_0\"] * Q * Q)\n    else:\n        d2GdT2 = 0.0\n        d2GdP2 = 0.0\n        d2GdPdT = 0.0\n\n    excesses = {\n        \"G\": G,\n        \"dGdT\": dGdT,\n        \"dGdP\": dGdP,\n        \"d2GdT2\": d2GdT2,\n        \"d2GdP2\": d2GdP2,\n        \"d2GdPdT\": d2GdPdT,\n    }\n\n    return (excesses, {\"Q\": Q})",
  "def _linear_excesses(pressure, temperature, params):\n    \"\"\"\n    Applies a 'Darken's quadratic formalism' correction (Powell, 1987)\n    to the thermodynamic properties of a mineral endmember.\n    This correction is relative to P = 0 and T = 0 and linear in P and T\n    and therefore corresponds to a constant volume and entropy correction.\n\n    Applying either a volume or entropy term will generally break\n    equations of state (i.e. the properties of the mineral will\n    no longer obey the equation of state defined in the\n    params dictionary. However, this form of excess is extremely\n    useful as a first order tweak to free energies\n    (especially in solid solution calculations)\n    \"\"\"\n    G = (\n        params[\"delta_E\"]\n        - (temperature) * params[\"delta_S\"]\n        + (pressure) * params[\"delta_V\"]\n    )\n    dGdT = -params[\"delta_S\"]\n    dGdP = params[\"delta_V\"]\n    d2GdT2 = 0.0\n    d2GdP2 = 0.0\n    d2GdPdT = 0.0\n\n    excesses = {\n        \"G\": G,\n        \"dGdT\": dGdT,\n        \"dGdP\": dGdP,\n        \"d2GdT2\": d2GdT2,\n        \"d2GdP2\": d2GdP2,\n        \"d2GdPdT\": d2GdPdT,\n    }\n\n    return (excesses, None)",
  "def _bragg_williams_excesses(pressure, temperature, params):\n    \"\"\"\n    Applies a Bragg-Williams type correction to the thermodynamic\n    properties of a mineral endmember. Used for modelling\n    order-disorder processes.\n    Expressions are from Holland and Powell (1996).\n\n    N.B. The excesses are for a *completely relaxed* mineral;\n    i.e. the seismic wave propagation is *slow* compared to the\n    rate of reaction.\n\n    This may not be reasonable for order-disorder, especially\n    for slow or coupled diffusers (Si-Al, for example).\n    The completely *unrelaxed* mineral (in terms of order-disorder)\n    can be calculated with a solid solution model.\n    \"\"\"\n\n    R = gas_constant\n    n = params[\"n\"]\n    if params[\"factor\"] > 0.0:\n        f = [params[\"factor\"], params[\"factor\"]]\n    else:\n        f = [1.0, -params[\"factor\"]]\n\n    # Equation A2-2\n    def flnarxn(n, Q, f):\n        return (\n            n\n            / (n + 1.0)\n            * (\n                f[0] * np.log(n * (1.0 - Q))\n                + f[1] * np.log(1.0 - Q)\n                - f[0] * np.log(1.0 + n * Q)\n                - f[1] * np.log(n + Q)\n            )\n        )\n\n    # Equation A2-4\n    # Can be derived from A2-2 noting that\n    # delta_H + f*R*T*lnarxn = delta_G + f*R*T*(lnadisord - lnaord)\n    def reaction_bragg_williams(Q, delta_H, temperature, n, f, W):\n        return delta_H + R * temperature * flnarxn(n, Q, f) + (2.0 * Q - 1.0) * W\n\n    def order_gibbs(pressure, temperature, params):\n        W = params[\"Wh\"] + pressure * params[\"Wv\"]\n        H_disord = params[\"deltaH\"] + pressure * params[\"deltaV\"]\n\n        # We can use brentq, but don't let the lower bracket = 0\n        try:\n            Q = opt.brentq(\n                reaction_bragg_williams,\n                1.0e-12,\n                1.0 - 1.0e-12,\n                args=(H_disord, temperature, n, f, W),\n            )\n        except ValueError:\n            Q = 0.0\n\n        S = (\n            -R\n            * (\n                f[0]\n                * (\n                    (1.0 + n * Q) * np.log((1.0 + n * Q) / (n + 1.0))\n                    + n * (1.0 - Q) * np.log(n * (1.0 - Q) / (n + 1.0))\n                )\n                + f[1]\n                * (\n                    n * (1.0 - Q) * np.log((1.0 - Q) / (n + 1.0))\n                    + n * (n + Q) * np.log((n + Q) / (n + 1.0))\n                )\n            )\n            / (n + 1.0)\n        )\n\n        G = (1.0 - Q) * H_disord + (1.0 - Q) * Q * W - temperature * S\n        return Q, G\n\n    # Calculating partial differentials with respect to P and T\n    # are complicated by the fact that Q changes with P and T\n    # TODO: Calculate the analytical derivatives of G via the chain rule.\n    # For now, just use numerical differentiation.\n    dT = 0.1\n    dP = 1000.0\n\n    Q, G = order_gibbs(pressure, temperature, params)\n    Q, GsubPsubT = order_gibbs(pressure - dP, temperature - dT, params)\n    Q, GsubPaddT = order_gibbs(pressure - dP, temperature + dT, params)\n    Q, GaddPsubT = order_gibbs(pressure + dP, temperature - dT, params)\n    Q, GaddPaddT = order_gibbs(pressure + dP, temperature + dT, params)\n    Q, GsubP = order_gibbs(pressure - dP, temperature, params)\n    Q, GaddP = order_gibbs(pressure + dP, temperature, params)\n    Q, GsubT = order_gibbs(pressure, temperature - dT, params)\n    Q, GaddT = order_gibbs(pressure, temperature + dT, params)\n\n    dGdT = (GaddT - GsubT) / (2.0 * dT)\n    dGdP = (GaddP - GsubP) / (2.0 * dP)\n    d2GdT2 = (GaddT + GsubT - 2.0 * G) / (dT * dT)\n    d2GdP2 = (GaddP + GsubP - 2.0 * G) / (dP * dP)\n    d2GdPdT = (GaddPaddT - GsubPaddT - GaddPsubT + GsubPsubT) / (4.0 * dT * dP)\n\n    excesses = {\n        \"G\": G,\n        \"dGdT\": dGdT,\n        \"dGdP\": dGdP,\n        \"d2GdT2\": d2GdT2,\n        \"d2GdP2\": d2GdP2,\n        \"d2GdPdT\": d2GdPdT,\n    }\n\n    return (excesses, {\"Q\": Q})",
  "def _magnetic_excesses_chs(pressure, temperature, params):\n    \"\"\"\n    Applies a magnetic contribution to the thermodynamic\n    properties of a mineral endmember.\n    The expression for the gibbs energy contribution is that\n    used by Chin, Hertzman and Sundman (1987) as reported\n    in the Journal of Phase Equilibria (Sundman, 1991).\n    \"\"\"\n\n    structural_parameter = params[\"structural_parameter\"]\n    curie_temperature = (\n        params[\"curie_temperature\"][0] + pressure * params[\"curie_temperature\"][1]\n    )\n    tau = temperature / curie_temperature\n    dtaudT = 1.0 / curie_temperature\n    dtaudP = -(temperature * params[\"curie_temperature\"][1]) / (\n        curie_temperature * curie_temperature\n    )\n    d2taudPdT = params[\"curie_temperature\"][1] / (curie_temperature * curie_temperature)\n    d2taudP2 = (\n        2.0\n        * temperature\n        * params[\"curie_temperature\"][1]\n        * params[\"curie_temperature\"][1]\n        / (curie_temperature * curie_temperature * curie_temperature)\n    )\n    magnetic_moment = (\n        params[\"magnetic_moment\"][0] + pressure * params[\"magnetic_moment\"][1]\n    )\n    dmagnetic_momentdP = params[\"magnetic_moment\"][1]\n\n    A = (518.0 / 1125.0) + (11692.0 / 15975.0) * ((1.0 / structural_parameter) - 1.0)\n    if tau < 1:\n        f = 1.0 - (1.0 / A) * (\n            79.0 / (140.0 * structural_parameter * tau)\n            + (474.0 / 497.0)\n            * (1.0 / structural_parameter - 1.0)\n            * (\n                np.power(tau, 3.0) / 6.0\n                + np.power(tau, 9.0) / 135.0\n                + np.power(tau, 15.0) / 600.0\n            )\n        )\n        dfdtau = -(1.0 / A) * (\n            -79.0 / (140.0 * structural_parameter * tau * tau)\n            + (474.0 / 497.0)\n            * (1.0 / structural_parameter - 1.0)\n            * (tau * tau / 2.0 + np.power(tau, 8.0) / 15.0 + np.power(tau, 14.0) / 40.0)\n        )\n        d2fdtau2 = -(1.0 / A) * (\n            2.0 * 79.0 / (140.0 * structural_parameter * np.power(tau, 3.0))\n            + (474.0 / 497.0)\n            * (1.0 / structural_parameter - 1.0)\n            * (\n                tau\n                + 8.0 * np.power(tau, 7.0) / 15.0\n                + 14.0 * np.power(tau, 13.0) / 40.0\n            )\n        )\n\n    else:\n        f = -(1.0 / A) * (\n            np.power(tau, -5.0) / 10.0\n            + np.power(tau, -15.0) / 315.0\n            + np.power(tau, -25.0) / 1500.0\n        )\n        dfdtau = (1.0 / A) * (\n            np.power(tau, -6.0) / 2.0\n            + np.power(tau, -16.0) / 21.0\n            + np.power(tau, -26.0) / 60.0\n        )\n        d2fdtau2 = -(1.0 / A) * (\n            6.0 * np.power(tau, -7.0) / 2.0\n            + 16.0 * np.power(tau, -17.0) / 21.0\n            + 26.0 * np.power(tau, -27.0) / 60.0\n        )\n\n    dfdT = dfdtau * dtaudT\n    d2fdT2 = d2fdtau2 * dtaudT * dtaudT\n    dfdP = dfdtau * dtaudP\n    d2fdP2 = d2fdtau2 * dtaudP * dtaudP + dfdtau * d2taudP2\n    d2fdPdT = d2fdtau2 * dtaudT * dtaudP - dfdtau * d2taudPdT\n\n    G = gas_constant * temperature * np.log(magnetic_moment + 1.0) * f\n    dGdT = gas_constant * np.log(magnetic_moment + 1.0) * (f + temperature * dfdT)\n    d2GdT2 = (\n        gas_constant\n        * np.log(magnetic_moment + 1.0)\n        * (2.0 * dfdT + temperature * d2fdT2)\n    )\n\n    dGdP = (\n        gas_constant\n        * temperature\n        * (\n            f * dmagnetic_momentdP / (magnetic_moment + 1.0)\n            + dfdP * np.log(magnetic_moment + 1.0)\n        )\n    )\n    d2GdP2 = (\n        gas_constant\n        * temperature\n        * (\n            -f * np.power(dmagnetic_momentdP / (magnetic_moment + 1.0), 2.0)\n            + 2 * dfdP * dmagnetic_momentdP / (magnetic_moment + 1.0)\n            + d2fdP2 * np.log(magnetic_moment + 1.0)\n        )\n    )\n    d2GdPdT = dGdP / temperature + (\n        gas_constant * temperature * np.log(magnetic_moment + 1.0) * d2fdPdT\n        + gas_constant\n        * temperature\n        * dmagnetic_momentdP\n        / (magnetic_moment + 1.0)\n        * dfdT\n    )\n\n    excesses = {\n        \"G\": G,\n        \"dGdT\": dGdT,\n        \"dGdP\": dGdP,\n        \"d2GdT2\": d2GdT2,\n        \"d2GdP2\": d2GdP2,\n        \"d2GdPdT\": d2GdPdT,\n    }\n\n    return (excesses, None)",
  "def _debye_excesses(pressure, temperature, params):\n    \"\"\"\n    Applies an excess contribution based\n    on a Debye model. The excess heat capacity\n    tends toward a constant value at high temperature.\n    \"\"\"\n    f = params[\"Cv_inf\"] / 3.0 / gas_constant\n    theta = params[\"Theta_0\"]\n\n    G = debye.helmholtz_free_energy(temperature, theta, f)\n    dGdT = -debye.entropy(temperature, theta, f)\n    dGdP = 0.0\n    if temperature > 1.0e-20:\n        d2GdT2 = -debye.molar_heat_capacity_v(temperature, theta, f) / temperature\n    else:\n        d2GdT2 = 0.0\n    d2GdP2 = 0.0\n    d2GdPdT = 0.0\n\n    excesses = {\n        \"G\": G,\n        \"dGdT\": dGdT,\n        \"dGdP\": dGdP,\n        \"d2GdT2\": d2GdT2,\n        \"d2GdP2\": d2GdP2,\n        \"d2GdPdT\": d2GdPdT,\n    }\n\n    return (excesses, None)",
  "def _debye_delta_excesses(pressure, temperature, params):\n    \"\"\"\n    Applies an excess contribution based\n    on the thermal derivatives of a Debye model.\n    The excess entropy tends toward a\n    constant value at high temperature\n    and behaves like the heat capacity of a Debye model\n    at finite temperature.\n    \"\"\"\n    f = params[\"S_inf\"] / 3.0 / gas_constant\n    theta = params[\"Theta_0\"]\n\n    G = -debye.thermal_energy(temperature, theta, f)\n    dGdT = -debye.molar_heat_capacity_v(temperature, theta, f)\n    dGdP = 0.0\n    d2GdT2 = -debye.dmolar_heat_capacity_v_dT(temperature, theta, f)\n    d2GdP2 = 0.0\n    d2GdPdT = 0.0\n\n    excesses = {\n        \"G\": G,\n        \"dGdT\": dGdT,\n        \"dGdP\": dGdP,\n        \"d2GdT2\": d2GdT2,\n        \"d2GdP2\": d2GdP2,\n        \"d2GdPdT\": d2GdPdT,\n    }\n\n    return (excesses, None)",
  "def _einstein_excesses(pressure, temperature, params):\n    \"\"\"\n    Applies an excess contribution based\n    on an Einstein model. The excess heat capacity\n    tends toward a constant value at high temperature.\n    \"\"\"\n    f = params[\"Cv_inf\"] / 3.0 / gas_constant\n    theta = params[\"Theta_0\"]\n\n    G = einstein.helmholtz_free_energy(temperature, theta, f)\n    dGdT = -einstein.entropy(temperature, theta, f)\n    dGdP = 0.0\n    if temperature > 1.0e-20:\n        d2GdT2 = -einstein.molar_heat_capacity_v(temperature, theta, f) / temperature\n    else:\n        d2GdT2 = 0.0\n    d2GdP2 = 0.0\n    d2GdPdT = 0.0\n\n    excesses = {\n        \"G\": G,\n        \"dGdT\": dGdT,\n        \"dGdP\": dGdP,\n        \"d2GdT2\": d2GdT2,\n        \"d2GdP2\": d2GdP2,\n        \"d2GdPdT\": d2GdPdT,\n    }\n\n    return (excesses, None)",
  "def _einstein_delta_excesses(pressure, temperature, params):\n    \"\"\"\n    Applies an excess contribution based\n    on the thermal derivatives of an Einstein model.\n    The excess entropy tends toward a\n    constant value at high temperature\n    and behaves like the heat capacity of an Einstein model\n    at finite temperature.\n    \"\"\"\n    f = params[\"S_inf\"] / 3.0 / gas_constant\n    theta = params[\"Theta_0\"]\n\n    G = -einstein.thermal_energy(temperature, theta, f)\n    dGdT = -einstein.molar_heat_capacity_v(temperature, theta, f)\n    dGdP = 0.0\n    d2GdT2 = -einstein.dmolar_heat_capacity_v_dT(temperature, theta, f)\n    d2GdP2 = 0.0\n    d2GdPdT = 0.0\n\n    excesses = {\n        \"G\": G,\n        \"dGdT\": dGdT,\n        \"dGdP\": dGdP,\n        \"d2GdT2\": d2GdT2,\n        \"d2GdP2\": d2GdP2,\n        \"d2GdPdT\": d2GdPdT,\n    }\n\n    return (excesses, None)",
  "def calculate_property_modifications(mineral):\n    \"\"\"\n    Sums the excesses from all the modifiers.\n\n    To calculate thermodynamic properties from the outputs,\n    the following functions should be used\n    (the _o suffix stands for original value):\n\n    gibbs = gibbs_o + excesses['G']\n    S = S_o - excesses['dGdT']\n    V = V_o + excesses['dGdP']\n    K_T = V / ((V_o / K_T_o) - excesses['d2GdP2'])\n    C_p = C_p_o - temperature*excesses['d2GdT2']\n    alpha = ((alpha_o*V_o) + excesses['d2GdPdT']) / V\n\n    H = gibbs + temperature*S\n    helmholtz = gibbs - pressure*V\n    C_v = C_p - V*temperature*alpha*alpha*K_T\n    gr = alpha*K_T*V/C_v\n    K_S = K_T*C_p/C_v\n    \"\"\"\n    excesses = {\n        \"G\": 0.0,\n        \"dGdT\": 0.0,\n        \"dGdP\": 0.0,\n        \"d2GdT2\": 0.0,\n        \"d2GdP2\": 0.0,\n        \"d2GdPdT\": 0.0,\n    }\n    mineral.property_modifier_properties = []\n    for modifier in mineral.property_modifiers:\n        if modifier[0] == \"landau\":\n            xs_function = _landau_excesses\n        elif modifier[0] == \"landau_slb_2022\":\n            xs_function = _landau_slb_2022_excesses\n        elif modifier[0] == \"landau_hp\":\n            xs_function = _landau_hp_excesses\n        elif modifier[0] == \"linear\":\n            xs_function = _linear_excesses\n        elif modifier[0] == \"bragg_williams\":\n            xs_function = _bragg_williams_excesses\n        elif modifier[0] == \"magnetic_chs\":\n            xs_function = _magnetic_excesses_chs\n        elif modifier[0] == \"debye\":\n            xs_function = _debye_excesses\n        elif modifier[0] == \"debye_delta\":\n            xs_function = _debye_delta_excesses\n        elif modifier[0] == \"einstein\":\n            xs_function = _einstein_excesses\n        elif modifier[0] == \"einstein_delta\":\n            xs_function = _einstein_delta_excesses\n        else:\n            raise Exception(\n                f\"Property modifier label for {mineral.name} ({modifier[0]}) not recognised.\"\n            )\n\n        xs_component, properties = xs_function(\n            mineral.pressure, mineral.temperature, modifier[1]\n        )\n        mineral.property_modifier_properties.append(properties)\n        for key in xs_component:\n            excesses[key] += xs_component[key]\n\n    return excesses",
  "def flnarxn(n, Q, f):\n        return (\n            n\n            / (n + 1.0)\n            * (\n                f[0] * np.log(n * (1.0 - Q))\n                + f[1] * np.log(1.0 - Q)\n                - f[0] * np.log(1.0 + n * Q)\n                - f[1] * np.log(n + Q)\n            )\n        )",
  "def reaction_bragg_williams(Q, delta_H, temperature, n, f, W):\n        return delta_H + R * temperature * flnarxn(n, Q, f) + (2.0 * Q - 1.0) * W",
  "def order_gibbs(pressure, temperature, params):\n        W = params[\"Wh\"] + pressure * params[\"Wv\"]\n        H_disord = params[\"deltaH\"] + pressure * params[\"deltaV\"]\n\n        # We can use brentq, but don't let the lower bracket = 0\n        try:\n            Q = opt.brentq(\n                reaction_bragg_williams,\n                1.0e-12,\n                1.0 - 1.0e-12,\n                args=(H_disord, temperature, n, f, W),\n            )\n        except ValueError:\n            Q = 0.0\n\n        S = (\n            -R\n            * (\n                f[0]\n                * (\n                    (1.0 + n * Q) * np.log((1.0 + n * Q) / (n + 1.0))\n                    + n * (1.0 - Q) * np.log(n * (1.0 - Q) / (n + 1.0))\n                )\n                + f[1]\n                * (\n                    n * (1.0 - Q) * np.log((1.0 - Q) / (n + 1.0))\n                    + n * (n + Q) * np.log((n + Q) / (n + 1.0))\n                )\n            )\n            / (n + 1.0)\n        )\n\n        G = (1.0 - Q) * H_disord + (1.0 - Q) * Q * W - temperature * S\n        return Q, G",
  "class CombinedMineralMethod(object):\n    \"\"\"Dummy class because CombinedMineral objects are derived\n    from a mechanical Solution.\n    Solution needs a method to call Mineral.set_state(),\n    but a CombinedMineral should never have a method that\n    is used for solutions.\"\"\"\n\n    def validate_parameters(self, params):\n        pass\n\n    pass",
  "def create(method):\n    \"\"\"\n    Creates an instance of an EquationOfState from a string,\n    a class EquationOfState, or an instance of EquationOfState.\n    \"\"\"\n    if isinstance(method, str):\n        if method == \"slb2\":\n            return slb.SLB2()\n        elif method == \"vinet\":\n            return vinet.Vinet()\n        elif method == \"morse\":\n            return morse_potential.Morse()\n        elif method == \"rkprime\":\n            return reciprocal_kprime.RKprime()\n        elif method == \"aa\":\n            return aa.AA()\n        elif method == \"mgd2\":\n            return mgd.MGD2()\n        elif method == \"mgd3\":\n            return mgd.MGD3()\n        elif method == \"slb3\":\n            return slb.SLB3()\n        elif method == \"murnaghan\":\n            return murnaghan.Murnaghan()\n        elif method == \"bm2\":\n            return bm.BM2()\n        elif method == \"bm3\":\n            return bm.BM3()\n        elif method == \"bm4\":\n            return bm4.BM4()\n        elif method == \"mt\":\n            return mt.MT()\n        elif method == \"hp98\":\n            return hp.HP98()\n        elif method == \"hp_tmt\":\n            return hp.HP_TMT()\n        elif method == \"hp_tmtL\":\n            return hp.HP_TMTL()\n        elif method == \"cork\":\n            return cork.CORK()\n        elif method == \"dks_l\":\n            return dks_liquid.DKS_L()\n        elif method == \"dks_s\":\n            return dks_solid.DKS_S()\n        elif method == \"brosh_calphad\":\n            return brosh_calphad.BroshCalphad()\n        elif method == \"combined\":\n            return CombinedMineralMethod()\n        else:\n            raise Exception(\"unsupported material method \" + method)\n    elif isinstance(method, EquationOfState):\n        return method\n    elif inspect.isclass(method) and issubclass(method, EquationOfState):\n        return method()\n    else:\n        raise Exception(\"unsupported material method \" + method.__class__.__name__)",
  "def validate_parameters(self, params):\n        pass",
  "def _chebval(x, c):\n    \"\"\"\n    Evaluate a Chebyshev series at points x.\n    This is just a lightly modified copy/paste job from the numpy\n    implementation of the same function, copied over here to put a\n    jit wrapper around it.\n    \"\"\"\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        x2 = 2 * x\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            c0 = c[-i] - c1\n            c1 = tmp + c1 * x2\n    return c0 + c1 * x",
  "def debye_fn(x):\n    \"\"\"\n    Evaluate the Debye function.  Takes the parameter\n    xi = Debye_T/T\n    \"\"\"\n    sol = integrate.quad(\n        lambda xi: (xi * xi * xi) / (np.exp(xi) - 1.0), 0.0, x\n    )  # EQ B3\n    return 3.0 * sol[0] / pow(x, 3.0)",
  "def debye_fn_cheb(x):\n    \"\"\"\n    Evaluate the Debye function using a Chebyshev series expansion coupled with\n    asymptotic solutions of the function.  Shamelessly adapted from the GSL implementation\n    of the same function (Itself adapted from Collected Algorithms from ACM).\n    Should give the same result as debye_fn(x) to near machine-precision.\n    \"\"\"\n    val_infinity = 19.4818182068004875\n    xcut = -log_eps\n\n    assert x > 0.0  # check for invalid x\n\n    if x < 2.0 * np.sqrt(2.0) * sqrt_eps:\n        return 1.0 - 3.0 * x / 8.0 + x * x / 20.0\n    elif x <= 4.0:\n        t = x * x / 8.0 - 1.0\n        c = _chebval(t, chebyshev_representation)\n        return c - 0.375 * x\n    elif x < -(np.log(2.0) + log_eps):\n        nexp = int(np.floor(xcut / x))\n        ex = np.exp(-x)\n        xk = nexp * x\n        rk = nexp\n        sum = 0.0\n        for i in range(nexp, 0, -1):\n            xk_inv = 1.0 / xk\n            sum *= ex\n            sum += (((6.0 * xk_inv + 6.0) * xk_inv + 3.0) * xk_inv + 1.0) / rk\n            rk -= 1.0\n            xk -= x\n        return val_infinity / (x * x * x) - 3.0 * sum * ex\n    elif x < xcut:\n        x3 = x * x * x\n        sum = 6.0 + 6.0 * x + 3.0 * x * x + x3\n        return (val_infinity - 3.0 * sum * np.exp(-x)) / x3\n    else:\n        return ((val_infinity / x) / x) / x",
  "def thermal_energy(T, debye_T, n):\n    \"\"\"\n    calculate the thermal energy of a substance.  Takes the temperature,\n    the Debye temperature, and n, the number of atoms per molecule.\n    Returns thermal energy in J/mol\n    \"\"\"\n    if T <= eps:\n        return 0.0\n    E_th = 3.0 * n * constants.gas_constant * T * debye_fn_cheb(debye_T / T)\n    return E_th",
  "def molar_heat_capacity_v(T, debye_T, n):\n    \"\"\"\n    Heat capacity at constant volume.  In J/K/mol\n    \"\"\"\n    if T <= eps:\n        return 0.0\n    x = debye_T / T\n    C_v = (\n        3.0\n        * n\n        * constants.gas_constant\n        * (4.0 * debye_fn_cheb(x) - 3.0 * x / (np.exp(x) - 1.0))\n    )\n    return C_v",
  "def helmholtz_free_energy(T, debye_T, n):\n    \"\"\"\n    Helmholtz free energy of lattice vibrations in the Debye model [J].\n    It is important to note that this does NOT include the zero\n    point energy for the lattice.  As long as you are\n    calculating relative differences in F, this should cancel anyways.\n    \"\"\"\n    if T <= eps:\n        return 0.0\n    x = debye_T / T\n    F = (\n        n\n        * constants.gas_constant\n        * T\n        * (3.0 * np.log(1.0 - np.exp(-x)) - debye_fn_cheb(x))\n    )\n    return F",
  "def entropy(T, debye_T, n):\n    \"\"\"\n    Entropy due to lattice vibrations in the Debye model [J/K].\n    \"\"\"\n    if T <= eps:\n        return 0.0\n    x = debye_T / T\n    S = (\n        n\n        * constants.gas_constant\n        * (4.0 * debye_fn_cheb(x) - 3.0 * np.log(1.0 - np.exp(-x)))\n    )\n    return S",
  "def dmolar_heat_capacity_v_dT(T, debye_T, n):\n    \"\"\"\n    First temperature derivative of the heat capacity at constant volume\n    [J/K^2/mol].\n    \"\"\"\n    if T <= eps:\n        return 0.0\n    x = debye_T / T\n\n    C_v_over_T = molar_heat_capacity_v(T, debye_T, n) / T\n    E_over_Tsqr = thermal_energy(T, debye_T, n) / T / T\n\n    dCvdT = 3.0 * C_v_over_T + (C_v_over_T - 4.0 * E_over_Tsqr) * x / (1.0 - np.exp(-x))\n\n    return dCvdT",
  "def jit(fn):\n        return fn",
  "def _delta_PoverK_from_P(PoverK, pressure, K_0, Kprime_0, Kprime_inf):\n    return PoverK - (pressure / K_0) * np.power(\n        (1.0 - Kprime_inf * PoverK), Kprime_0 / Kprime_inf\n    )",
  "def _delta_PoverK_from_V(PoverK, V, V_0, K_0, Kprime_0, Kprime_inf):\n    Kprime_ratio = Kprime_0 / Kprime_inf\n    return (\n        np.log(V_0 / V)\n        + Kprime_ratio / Kprime_inf * np.log(1.0 - Kprime_inf * PoverK)\n        + (Kprime_ratio - 1.0) * PoverK\n    )",
  "def _upper_incomplete_gamma(z, a):\n    \"\"\"\n    An implementation of the non-regularised upper incomplete gamma\n    function. Computed using the relationship with the regularised\n    lower incomplete gamma function (scipy.special.gammainc).\n    Uses the recurrence relation wherever z<0.\n    \"\"\"\n    n = int(-np.floor(z))\n    if n > 0:\n        z = z + n\n        u_gamma = (1.0 - gammainc(z, a)) * gamma(z)\n\n        for i in range(n):\n            z = z - 1.0\n            u_gamma = (u_gamma - np.power(a, z) * np.exp(-a)) / z\n        return u_gamma\n    else:\n        return (1.0 - gammainc(z, a)) * gamma(z)",
  "def _PoverK_from_P(pressure, params):\n    \"\"\"\n    Calculates the pressure:bulk modulus ratio\n    from a given pressure using brentq optimization\n    \"\"\"\n    args = (\n        (pressure - params[\"P_0\"]),\n        params[\"K_0\"],\n        params[\"Kprime_0\"],\n        params[\"Kprime_inf\"],\n    )\n    return opt.brentq(\n        _delta_PoverK_from_P,\n        1.0 / (params[\"Kprime_inf\"] - params[\"Kprime_0\"]) + np.finfo(float).eps,\n        1.0 / params[\"Kprime_inf\"] - np.finfo(float).eps,\n        args=args,\n    )",
  "def _PoverK_from_V(volume, params):\n    \"\"\"\n    Calculates the pressure:bulk modulus ratio\n    from a given volume using brentq optimization\n    \"\"\"\n    args = (\n        volume,\n        params[\"V_0\"],\n        params[\"K_0\"],\n        params[\"Kprime_0\"],\n        params[\"Kprime_inf\"],\n    )\n    return opt.brentq(\n        _delta_PoverK_from_V,\n        1.0 / (params[\"Kprime_inf\"] - params[\"Kprime_0\"]) + np.finfo(float).eps,\n        1.0 / params[\"Kprime_inf\"] - np.finfo(float).eps,\n        args=args,\n    )",
  "def bulk_modulus(pressure, params):\n    \"\"\"\n    Returns the bulk modulus at a given pressure\n    \"\"\"\n    PoverK = _PoverK_from_P(pressure, params)\n    K = params[\"K_0\"] * np.power(\n        (1.0 - params[\"Kprime_inf\"] * PoverK),\n        -params[\"Kprime_0\"] / params[\"Kprime_inf\"],\n    )\n    return K",
  "def shear_modulus(pressure, params):\n    \"\"\"\n    Returns the shear modulus at a given pressure\n    \"\"\"\n    G = (\n        params[\"G_0\"] / params[\"K_0\"] * bulk_modulus(pressure, params)\n        - (params[\"G_0\"] / params[\"K_0\"] * params[\"Kprime_inf\"] - params[\"Gprime_inf\"])\n        * pressure\n    )\n    return G",
  "class RKprime(eos.EquationOfState):\n\n    \"\"\"\n    Class for the isothermal reciprocal K-prime equation of state\n    detailed in :cite:`StaceyDavis2004`.  This equation of state is\n    a development of work by :cite:`Keane1954` and :cite:`Stacey2000`,\n    making use of the fact that :math:`K'` typically varies smoothly\n    as a function of :math:`P/K`, and is thermodynamically required to\n    exceed 5/3 at infinite pressure.\n\n    It is worth noting that this equation of state rapidly becomes\n    unstable at negative pressures, so should not be trusted to provide\n    a good *HT-LP* equation of state using a thermal pressure\n    formulation. The negative root of :math:`dP/dK`\n    can be found at :math:`K/P = K'_{\\infty} - K'_0`,\n    which corresponds to a bulk modulus of\n    :math:`K = K_0 ( 1 - K'_{\\infty}/K'_0 )^{K'_0/K'_{\\infty}}`\n    and a volume of\n    :math:`V = V_0 ( K'_0 / (K'_0 - K'_{\\infty}) )^{K'_0/{K'}^2_{\\infty}} \\exp{(-1/K'_{\\infty})}`.\n\n    This equation of state has no temperature dependence.\n    \"\"\"\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        Kprime_ratio = params[\"Kprime_0\"] / params[\"Kprime_inf\"]\n        PoverK = _PoverK_from_P(pressure, params)\n\n        V = params[\"V_0\"] * np.exp(\n            Kprime_ratio\n            / params[\"Kprime_inf\"]\n            * np.log(1.0 - params[\"Kprime_inf\"] * PoverK)\n            + (Kprime_ratio - 1.0) * PoverK\n        )  # Eq. 61\n\n        return V\n\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure :math:`[Pa]` as a function of volume :math:`[m^3]`.\n        \"\"\"\n        PoverK = _PoverK_from_V(volume, params)\n        return params[\"P_0\"] + (\n            params[\"K_0\"]\n            * PoverK\n            * np.power(\n                1.0 - params[\"Kprime_inf\"] * PoverK,\n                -params[\"Kprime_0\"] / params[\"Kprime_inf\"],\n            )\n        )\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus(pressure, params)\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(pressure, params)\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        \"\"\"\n        return shear_modulus(pressure, params)\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0\n\n    def _intVdP(self, xi, params):\n        a = params[\"Kprime_inf\"]\n        b = (\n            params[\"Kprime_0\"] / params[\"Kprime_inf\"] / params[\"Kprime_inf\"]\n            - params[\"Kprime_0\"] / params[\"Kprime_inf\"]\n            - 1.0\n        )\n        c = params[\"Kprime_0\"] - params[\"Kprime_inf\"]\n        f = params[\"Kprime_0\"] / params[\"Kprime_inf\"] - 1.0\n\n        i1 = float(\n            params[\"V_0\"]\n            * params[\"K_0\"]\n            * np.exp(f / a)\n            * np.power(a, b - 1.0)\n            / np.power(f, b + 2.0)\n            * (\n                f\n                * params[\"Kprime_0\"]\n                * _upper_incomplete_gamma(b + 1.0, f * (1.0 / a - xi))\n                - a * c * _upper_incomplete_gamma(b + 2.0, f * (1.0 / a - xi))\n            )\n        )\n\n        return i1\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # G = E0 + int VdP (when S = 0)\n        K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        return (\n            params[\"E_0\"]\n            + params[\"P_0\"] * params[\"V_0\"]\n            + self._intVdP((pressure - params[\"P_0\"]) / K, params)\n            - self._intVdP(0.0, params)\n        )\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # E = G - PV (+ TS)\n        return (\n            self.gibbs_free_energy(pressure, temperature, volume, params)\n            - pressure * volume\n        )\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters.\n        The value for :math:`K'_{\\infty}` is thermodynamically bounded\n        between 5/3 and :math:`K'_0` :cite:`StaceyDavis2004`.\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # If G and Gprime_inf are not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_inf\" not in params:\n            params[\"Gprime_inf\"] = float(\"nan\")\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\", \"Kprime_inf\", \"G_0\", \"Gprime_inf\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)\n        if (\n            params[\"Kprime_inf\"] < 5.0 / 3.0\n            or params[\"Kprime_inf\"] > params[\"Kprime_0\"]\n        ):\n            warnings.warn(\"Unusual value for Kprime_inf\", stacklevel=2)  # eq. 17\n        if params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_inf\"] < -5.0 or params[\"Gprime_inf\"] > 10.0:\n            warnings.warn(\"Unusual value for Gprime_inf\", stacklevel=2)",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        Kprime_ratio = params[\"Kprime_0\"] / params[\"Kprime_inf\"]\n        PoverK = _PoverK_from_P(pressure, params)\n\n        V = params[\"V_0\"] * np.exp(\n            Kprime_ratio\n            / params[\"Kprime_inf\"]\n            * np.log(1.0 - params[\"Kprime_inf\"] * PoverK)\n            + (Kprime_ratio - 1.0) * PoverK\n        )  # Eq. 61\n\n        return V",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure :math:`[Pa]` as a function of volume :math:`[m^3]`.\n        \"\"\"\n        PoverK = _PoverK_from_V(volume, params)\n        return params[\"P_0\"] + (\n            params[\"K_0\"]\n            * PoverK\n            * np.power(\n                1.0 - params[\"Kprime_inf\"] * PoverK,\n                -params[\"Kprime_0\"] / params[\"Kprime_inf\"],\n            )\n        )",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        return bulk_modulus(pressure, params)",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(pressure, params)",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        \"\"\"\n        return shear_modulus(pressure, params)",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0",
  "def _intVdP(self, xi, params):\n        a = params[\"Kprime_inf\"]\n        b = (\n            params[\"Kprime_0\"] / params[\"Kprime_inf\"] / params[\"Kprime_inf\"]\n            - params[\"Kprime_0\"] / params[\"Kprime_inf\"]\n            - 1.0\n        )\n        c = params[\"Kprime_0\"] - params[\"Kprime_inf\"]\n        f = params[\"Kprime_0\"] / params[\"Kprime_inf\"] - 1.0\n\n        i1 = float(\n            params[\"V_0\"]\n            * params[\"K_0\"]\n            * np.exp(f / a)\n            * np.power(a, b - 1.0)\n            / np.power(f, b + 2.0)\n            * (\n                f\n                * params[\"Kprime_0\"]\n                * _upper_incomplete_gamma(b + 1.0, f * (1.0 / a - xi))\n                - a * c * _upper_incomplete_gamma(b + 2.0, f * (1.0 / a - xi))\n            )\n        )\n\n        return i1",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # G = E0 + int VdP (when S = 0)\n        K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        return (\n            params[\"E_0\"]\n            + params[\"P_0\"] * params[\"V_0\"]\n            + self._intVdP((pressure - params[\"P_0\"]) / K, params)\n            - self._intVdP(0.0, params)\n        )",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # E = G - PV (+ TS)\n        return (\n            self.gibbs_free_energy(pressure, temperature, volume, params)\n            - pressure * volume\n        )",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters.\n        The value for :math:`K'_{\\infty}` is thermodynamically bounded\n        between 5/3 and :math:`K'_0` :cite:`StaceyDavis2004`.\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # If G and Gprime_inf are not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_inf\" not in params:\n            params[\"Gprime_inf\"] = float(\"nan\")\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\", \"Kprime_inf\", \"G_0\", \"Gprime_inf\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)\n        if (\n            params[\"Kprime_inf\"] < 5.0 / 3.0\n            or params[\"Kprime_inf\"] > params[\"Kprime_0\"]\n        ):\n            warnings.warn(\"Unusual value for Kprime_inf\", stacklevel=2)  # eq. 17\n        if params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_inf\"] < -5.0 or params[\"Gprime_inf\"] > 10.0:\n            warnings.warn(\"Unusual value for Gprime_inf\", stacklevel=2)",
  "def jit(fn):\n        return fn",
  "def cork_variables(cork, cork_P, cork_T, temperature):\n    a = (\n        cork[0][0] * cork_T ** (2.5) / cork_P\n        + cork[0][1] * cork_T ** (1.5) / cork_P * temperature\n    )\n    b = cork[1][0] * cork_T / cork_P\n    c = (\n        cork[2][0] * cork_T / cork_P ** (1.5)\n        + cork[2][1] / cork_P ** (1.5) * temperature\n    )\n    d = (\n        cork[3][0] * cork_T / cork_P ** (2.0)\n        + cork[3][1] / cork_P ** (2.0) * temperature\n    )\n    return [a, b, c, d]",
  "class CORK(eos.EquationOfState):\n\n    \"\"\"\n    Class for the CoRK equation of state detailed in :cite:`HP1991`. The\n    CoRK EoS is a simple virial-type extension to the modified Redlich-Kwong\n    (MRK) equation of state. It was designed to compensate for the tendency of\n    the MRK equation of state to overestimate volumes at high pressures and\n    accommodate the volume behaviour of coexisting gas and liquid phases along\n    the saturation curve.\n    \"\"\"\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter [unitless] as a function of pressure,\n        temperature, and volume.\n        \"\"\"\n        return 0.0\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n        Eq. 7 in Holland and Powell, 1991\n        \"\"\"\n        cork = cork_variables(\n            params[\"cork_params\"], params[\"cork_P\"], params[\"cork_T\"], temperature\n        )\n        V = constants.gas_constant * temperature / pressure + (\n            cork[1]\n            - cork[0]\n            * constants.gas_constant\n            * np.sqrt(temperature)\n            / (\n                (constants.gas_constant * temperature + cork[1] * pressure)\n                * (constants.gas_constant * temperature + 2.0 * cork[1] * pressure)\n            )\n            + cork[2] * np.sqrt(pressure)\n            + cork[3] * pressure\n        )\n        return V\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].  EQ 13+2\n        \"\"\"\n        return 0.0\n\n    # calculate the shear modulus as a function of P, V, and T\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Not implemented.\n        Returns 0.\n        Could potentially apply a fixed Poissons ratio as a rough estimate.\n        \"\"\"\n        return 0.0\n\n    # Cv, heat capacity at constant volume\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume at the pressure, temperature, and volume [J/K/mol].\n        \"\"\"\n        return 0.0\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity at the pressure, temperature, and volume [1/K]\n        Replace -Pth in EQ 13+1 with P-Pth for non-ambient temperature\n        \"\"\"\n        return 0.0\n\n    # Heat capacity at ambient pressure\n    def molar_heat_capacity_p0(self, temperature, params):\n        \"\"\"\n        Returns heat capacity at ambient pressure as a function of temperature [J/K/mol]\n        Cp = a + bT + cT^-2 + dT^-0.5 in Holland and Powell, 2011\n        \"\"\"\n        Cp = (\n            params[\"Cp\"][0]\n            + params[\"Cp\"][1] * temperature\n            + params[\"Cp\"][2] * np.power(temperature, -2.0)\n            + params[\"Cp\"][3] * np.power(temperature, -0.5)\n        )\n        return Cp\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure at the pressure, temperature, and volume [J/K/mol]\n        \"\"\"\n        return 0\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        return 0.0\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the gibbs free energy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        P_relative = pressure - params[\"P_0\"]\n\n        # Calculate temperature and pressure integrals\n        intCpdT = (\n            params[\"Cp\"][0] * temperature\n            + 0.5 * params[\"Cp\"][1] * np.power(temperature, 2.0)\n            - params[\"Cp\"][2] / temperature\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * T_0\n            + 0.5 * params[\"Cp\"][1] * T_0 * T_0\n            - params[\"Cp\"][2] / T_0\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(T_0)\n        )\n\n        intCpoverTdT = (\n            params[\"Cp\"][0] * np.log(temperature)\n            + params[\"Cp\"][1] * temperature\n            - 0.5 * params[\"Cp\"][2] / np.power(temperature, 2.0)\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * np.log(T_0)\n            + params[\"Cp\"][1] * T_0\n            - 0.5 * params[\"Cp\"][2] / (T_0 * T_0)\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(T_0)\n        )\n\n        if params[\"cork_T\"] == 0:\n            RTlnf = 0.0\n        else:\n            cork = cork_variables(\n                params[\"cork_params\"], params[\"cork_P\"], params[\"cork_T\"], temperature\n            )\n\n            RTlnf = (\n                constants.gas_constant * temperature * np.log(1e-5 * P_relative)\n                + cork[1] * P_relative\n                + cork[0]\n                / (cork[1] * np.sqrt(temperature))\n                * (\n                    np.log(constants.gas_constant * temperature + cork[1] * P_relative)\n                    - np.log(\n                        constants.gas_constant * temperature\n                        + 2.0 * cork[1] * P_relative\n                    )\n                )\n                + 2.0 / 3.0 * cork[2] * P_relative * np.sqrt(P_relative)\n                + cork[3] / 2.0 * P_relative * P_relative\n            )  # Eq. 8 in Holland and Powell, 1991\n\n        return (\n            params[\"H_0\"]\n            + intCpdT\n            - temperature * (params[\"S_0\"] + intCpoverTdT)\n            + RTlnf\n        )\n\n    # calculate P = P(T0) + Pth\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        \"\"\"\n        return 0.0\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 298.15\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # if G and Gprime are not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"H_0\" not in params:\n            params[\"H_0\"] = float(\"nan\")\n        if \"S_0\" not in params:\n            params[\"S_0\"] = float(\"nan\")\n\n        # check that all the required keys are in the dictionary\n        expected_keys = [\"cork_params\", \"cork_T\", \"cork_P\", \"Cp\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # now check that the values are reasonable.  I mostly just\n        # made up these values from experience, and we are only\n        # raising a warning.  Better way to do this? [IR]\n\n        # no test for H_0\n        if params[\"S_0\"] is not float(\"nan\") and params[\"S_0\"] < 0.0:\n            warnings.warn(\"Unusual value for S_0\", stacklevel=2)\n\n        if params[\"cork_T\"] < -1.0:\n            warnings.warn(\"Unusual value for cork_T\", stacklevel=2)\n        if params[\"cork_P\"] < 1.0e4 or params[\"cork_P\"] > 1.0e8:\n            warnings.warn(\"Unusual value for cork_P\", stacklevel=2)\n\n        if self.molar_heat_capacity_p0(params[\"T_0\"], params) < 0.0:\n            warnings.warn(\"Negative heat capacity at T_0\", stacklevel=2)\n        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:\n            warnings.warn(\"Negative heat capacity at 2000K\", stacklevel=2)",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter [unitless] as a function of pressure,\n        temperature, and volume.\n        \"\"\"\n        return 0.0",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n        Eq. 7 in Holland and Powell, 1991\n        \"\"\"\n        cork = cork_variables(\n            params[\"cork_params\"], params[\"cork_P\"], params[\"cork_T\"], temperature\n        )\n        V = constants.gas_constant * temperature / pressure + (\n            cork[1]\n            - cork[0]\n            * constants.gas_constant\n            * np.sqrt(temperature)\n            / (\n                (constants.gas_constant * temperature + cork[1] * pressure)\n                * (constants.gas_constant * temperature + 2.0 * cork[1] * pressure)\n            )\n            + cork[2] * np.sqrt(pressure)\n            + cork[3] * pressure\n        )\n        return V",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].  EQ 13+2\n        \"\"\"\n        return 0.0",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Not implemented.\n        Returns 0.\n        Could potentially apply a fixed Poissons ratio as a rough estimate.\n        \"\"\"\n        return 0.0",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume at the pressure, temperature, and volume [J/K/mol].\n        \"\"\"\n        return 0.0",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity at the pressure, temperature, and volume [1/K]\n        Replace -Pth in EQ 13+1 with P-Pth for non-ambient temperature\n        \"\"\"\n        return 0.0",
  "def molar_heat_capacity_p0(self, temperature, params):\n        \"\"\"\n        Returns heat capacity at ambient pressure as a function of temperature [J/K/mol]\n        Cp = a + bT + cT^-2 + dT^-0.5 in Holland and Powell, 2011\n        \"\"\"\n        Cp = (\n            params[\"Cp\"][0]\n            + params[\"Cp\"][1] * temperature\n            + params[\"Cp\"][2] * np.power(temperature, -2.0)\n            + params[\"Cp\"][3] * np.power(temperature, -0.5)\n        )\n        return Cp",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure at the pressure, temperature, and volume [J/K/mol]\n        \"\"\"\n        return 0",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        return 0.0",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the gibbs free energy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        P_relative = pressure - params[\"P_0\"]\n\n        # Calculate temperature and pressure integrals\n        intCpdT = (\n            params[\"Cp\"][0] * temperature\n            + 0.5 * params[\"Cp\"][1] * np.power(temperature, 2.0)\n            - params[\"Cp\"][2] / temperature\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * T_0\n            + 0.5 * params[\"Cp\"][1] * T_0 * T_0\n            - params[\"Cp\"][2] / T_0\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(T_0)\n        )\n\n        intCpoverTdT = (\n            params[\"Cp\"][0] * np.log(temperature)\n            + params[\"Cp\"][1] * temperature\n            - 0.5 * params[\"Cp\"][2] / np.power(temperature, 2.0)\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * np.log(T_0)\n            + params[\"Cp\"][1] * T_0\n            - 0.5 * params[\"Cp\"][2] / (T_0 * T_0)\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(T_0)\n        )\n\n        if params[\"cork_T\"] == 0:\n            RTlnf = 0.0\n        else:\n            cork = cork_variables(\n                params[\"cork_params\"], params[\"cork_P\"], params[\"cork_T\"], temperature\n            )\n\n            RTlnf = (\n                constants.gas_constant * temperature * np.log(1e-5 * P_relative)\n                + cork[1] * P_relative\n                + cork[0]\n                / (cork[1] * np.sqrt(temperature))\n                * (\n                    np.log(constants.gas_constant * temperature + cork[1] * P_relative)\n                    - np.log(\n                        constants.gas_constant * temperature\n                        + 2.0 * cork[1] * P_relative\n                    )\n                )\n                + 2.0 / 3.0 * cork[2] * P_relative * np.sqrt(P_relative)\n                + cork[3] / 2.0 * P_relative * P_relative\n            )  # Eq. 8 in Holland and Powell, 1991\n\n        return (\n            params[\"H_0\"]\n            + intCpdT\n            - temperature * (params[\"S_0\"] + intCpoverTdT)\n            + RTlnf\n        )",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        \"\"\"\n        return 0.0",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 298.15\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 0.0\n\n        # if G and Gprime are not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"H_0\" not in params:\n            params[\"H_0\"] = float(\"nan\")\n        if \"S_0\" not in params:\n            params[\"S_0\"] = float(\"nan\")\n\n        # check that all the required keys are in the dictionary\n        expected_keys = [\"cork_params\", \"cork_T\", \"cork_P\", \"Cp\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # now check that the values are reasonable.  I mostly just\n        # made up these values from experience, and we are only\n        # raising a warning.  Better way to do this? [IR]\n\n        # no test for H_0\n        if params[\"S_0\"] is not float(\"nan\") and params[\"S_0\"] < 0.0:\n            warnings.warn(\"Unusual value for S_0\", stacklevel=2)\n\n        if params[\"cork_T\"] < -1.0:\n            warnings.warn(\"Unusual value for cork_T\", stacklevel=2)\n        if params[\"cork_P\"] < 1.0e4 or params[\"cork_P\"] > 1.0e8:\n            warnings.warn(\"Unusual value for cork_P\", stacklevel=2)\n\n        if self.molar_heat_capacity_p0(params[\"T_0\"], params) < 0.0:\n            warnings.warn(\"Negative heat capacity at T_0\", stacklevel=2)\n        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:\n            warnings.warn(\"Negative heat capacity at 2000K\", stacklevel=2)",
  "class MGDBase(eos.EquationOfState):\n\n    \"\"\"\n    Base class for a generic finite-strain Mie-Grueneisen-Debye\n    equation of state.  References for this can be found in many\n    places, such as Shim, Duffy and Kenichi (2002) and Jackson and Rigden\n    (1996).  Here we mostly follow the appendices of Matas et al (2007).\n    Of particular note is the thermal correction to the shear modulus, which\n    was developed by Hama and Suito (1998).\n    \"\"\"\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter [unitless] as a function of pressure,\n        temperature, and volume (EQ B6)\n        \"\"\"\n        return self._grueneisen_parameter(params[\"V_0\"] / volume, params)\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n        EQ B7\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        func = (\n            lambda x: bm.birch_murnaghan(params[\"V_0\"] / x, params)\n            + self._thermal_pressure(temperature, x, params)\n            - self._thermal_pressure(T_0, x, params)\n            - pressure\n        )\n        try:\n            sol = bracket(func, params[\"V_0\"], 1.0e-2 * params[\"V_0\"])\n        except:\n            raise ValueError(\n                \"Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?\"\n            )\n        return opt.brentq(func, sol[0], sol[1])\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].  EQ B8\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        K_T = (\n            bm.bulk_modulus(volume, params)\n            + self._thermal_bulk_modulus(temperature, volume, params)\n            - self._thermal_bulk_modulus(T_0, volume, params)\n        )  # EQB13\n        return K_T\n\n    # calculate the mgd shear modulus as a function of P, V, and T\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].  EQ B11\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        if self.order == 2:\n            return (\n                bm.shear_modulus_second_order(volume, params)\n                + self._thermal_shear_modulus(temperature, volume, params)\n                - self._thermal_shear_modulus(T_0, volume, params)\n            )  # EQ B11\n        elif self.order == 3:\n            return (\n                bm.shear_modulus_third_order(volume, params)\n                + self._thermal_shear_modulus(temperature, volume, params)\n                - self._thermal_shear_modulus(T_0, volume, params)\n            )  # EQ B11\n        else:\n            raise NotImplementedError(\"\")\n\n    # heat capacity at constant volume\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume at the pressure, temperature, and volume [J/K/mol]\n        \"\"\"\n        Debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        C_v = debye.molar_heat_capacity_v(temperature, Debye_T, params[\"n\"])\n        return C_v\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity at the pressure, temperature, and volume [1/K]\n        \"\"\"\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        gr = self._grueneisen_parameter(params[\"V_0\"] / volume, params)\n        K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = gr * C_v / K / volume\n        return alpha\n\n    # heat capacity at constant pressure\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure at the pressure, temperature, and volume [J/K/mol]\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self._grueneisen_parameter(params[\"V_0\"] / volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        C_p = C_v * (1.0 + gr * alpha * temperature)\n        return C_p\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].  EQ D6\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self._grueneisen_parameter(params[\"V_0\"] / volume, params)\n        K_S = K_T * (1.0 + gr * alpha * temperature)\n        return K_S\n\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        EQ B7\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        return (\n            bm.birch_murnaghan(params[\"V_0\"] / volume, params)\n            + self._thermal_pressure(temperature, volume, params)\n            - self._thermal_pressure(T_0, volume, params)\n        )\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        G = (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n        return G\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        return self.helmholtz_free_energy(\n            pressure, temperature, volume, params\n        ) + temperature * self.entropy(pressure, temperature, volume, params)\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy at the pressure and temperature of the mineral [J/K/mol]\n        \"\"\"\n        Debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        S = debye.entropy(temperature, Debye_T, params[\"n\"])\n        return S\n\n    def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n\n        return (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + temperature * self.entropy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n\n    def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        x = params[\"V_0\"] / volume\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28, SLB2005\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29, SLB2005\n\n        F_pressure = (\n            0.5 * b_iikk * f * f * params[\"V_0\"]\n            + (1.0 / 6.0) * params[\"V_0\"] * b_iikkmm * f * f * f\n        )\n\n        Debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        F_thermal = debye.helmholtz_free_energy(\n            temperature, Debye_T, params[\"n\"]\n        ) - debye.helmholtz_free_energy(params[\"T_0\"], Debye_T, params[\"n\"])\n\n        return params[\"F_0\"] + F_pressure + F_thermal\n\n    # calculate the thermal correction to the shear modulus as a function of\n    # V, T\n    def _thermal_shear_modulus(self, T, V, params):\n        if T > 1.0e-10:\n            gr = self._grueneisen_parameter(params[\"V_0\"] / V, params)\n            Debye_T = self._debye_temperature(params[\"V_0\"] / V, params)\n            G_th = (\n                3.0\n                / 5.0\n                * (\n                    self._thermal_bulk_modulus(T, V, params)\n                    - 6\n                    * constants.gas_constant\n                    * T\n                    * params[\"n\"]\n                    / V\n                    * gr\n                    * debye.debye_fn(Debye_T / T)\n                )\n            )  # EQ B10\n            return G_th\n        else:\n            return 0.0\n\n    # compute the Debye temperature in K.  Takes the\n    # parameter x, which is V_0/V (molar volumes).\n    # Depends on the reference grueneisen parameter,\n    # the reference Debye temperature, and the factor\n    # q_0, see Matas eq B6\n    def _debye_temperature(self, x, params):\n        return params[\"Debye_0\"] * np.exp(\n            (params[\"grueneisen_0\"] - self._grueneisen_parameter(x, params))\n            / params[\"q_0\"]\n        )\n\n    # compute the grueneisen parameter with depth, according\n    # to q_0.  Takes x=V_0/V. See Matas eq B6\n    def _grueneisen_parameter(self, x, params):\n        return params[\"grueneisen_0\"] * pow(1.0 / x, params[\"q_0\"])\n\n    # calculate isotropic thermal pressure, see\n    # Matas et. al. (2007) eq B4\n    def _thermal_pressure(self, T, V, params):\n        Debye_T = self._debye_temperature(params[\"V_0\"] / V, params)\n        gr = self._grueneisen_parameter(params[\"V_0\"] / V, params)\n        P_th = gr * debye.thermal_energy(T, Debye_T, params[\"n\"]) / V\n        return P_th\n\n    # calculate the thermal correction for the mgd\n    # bulk modulus (see matas et al, 2007)\n    def _thermal_bulk_modulus(self, T, V, params):\n        if T > 1.0e-10:\n            gr = self._grueneisen_parameter(params[\"V_0\"] / V, params)\n            Debye_T = self._debye_temperature(params[\"V_0\"] / V, params)\n            K_th = (\n                3.0\n                * params[\"n\"]\n                * constants.gas_constant\n                * T\n                / V\n                * gr\n                * (\n                    (1.0 - params[\"q_0\"] - 3.0 * gr) * debye.debye_fn(Debye_T / T)\n                    + 3.0 * gr * (Debye_T / T) / (np.exp(Debye_T / T) - 1.0)\n                )\n            )  # EQ B5\n            return K_th\n        else:\n            return 0.0\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 300.0\n        if \"F_0\" not in params:\n            params[\"F_0\"] = 0.0\n\n        # First, let's check the EoS parameters for Tref\n        bm.BirchMurnaghanBase.validate_parameters(bm.BirchMurnaghanBase(), params)\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"molar_mass\", \"n\", \"Debye_0\", \"grueneisen_0\", \"q_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 1.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)\n        if params[\"Debye_0\"] < 1.0 or params[\"Debye_0\"] > 10000.0:\n            warnings.warn(\"Unusual value for Debye_0\", stacklevel=2)\n        if params[\"grueneisen_0\"] < 0.0 or params[\"grueneisen_0\"] > 10.0:\n            warnings.warn(\"Unusual value for grueneisen_0\", stacklevel=2)\n        if params[\"q_0\"] < -10.0 or params[\"q_0\"] > 10.0:\n            warnings.warn(\"Unusual value for q_0\", stacklevel=2)",
  "class MGD3(MGDBase):\n\n    \"\"\"\n    MGD equation of state with third order finite strain expansion for the\n    shear modulus (this should be preferred, as it is more thermodynamically\n    consistent.\n    \"\"\"\n\n    def __init__(self):\n        self.order = 3",
  "class MGD2(MGDBase):\n\n    \"\"\"\n    MGD equation of state with second order finite strain expansion for the\n    shear modulus.  In general, this should not be used, but sometimes\n    shear modulus data is fit to a second order equation of state.  In that\n    case, you should use this.  The moral is, be careful!\n    \"\"\"\n\n    def __init__(self):\n        self.order = 2",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter [unitless] as a function of pressure,\n        temperature, and volume (EQ B6)\n        \"\"\"\n        return self._grueneisen_parameter(params[\"V_0\"] / volume, params)",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n        EQ B7\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        func = (\n            lambda x: bm.birch_murnaghan(params[\"V_0\"] / x, params)\n            + self._thermal_pressure(temperature, x, params)\n            - self._thermal_pressure(T_0, x, params)\n            - pressure\n        )\n        try:\n            sol = bracket(func, params[\"V_0\"], 1.0e-2 * params[\"V_0\"])\n        except:\n            raise ValueError(\n                \"Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?\"\n            )\n        return opt.brentq(func, sol[0], sol[1])",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].  EQ B8\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        K_T = (\n            bm.bulk_modulus(volume, params)\n            + self._thermal_bulk_modulus(temperature, volume, params)\n            - self._thermal_bulk_modulus(T_0, volume, params)\n        )  # EQB13\n        return K_T",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].  EQ B11\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        if self.order == 2:\n            return (\n                bm.shear_modulus_second_order(volume, params)\n                + self._thermal_shear_modulus(temperature, volume, params)\n                - self._thermal_shear_modulus(T_0, volume, params)\n            )  # EQ B11\n        elif self.order == 3:\n            return (\n                bm.shear_modulus_third_order(volume, params)\n                + self._thermal_shear_modulus(temperature, volume, params)\n                - self._thermal_shear_modulus(T_0, volume, params)\n            )  # EQ B11\n        else:\n            raise NotImplementedError(\"\")",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume at the pressure, temperature, and volume [J/K/mol]\n        \"\"\"\n        Debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        C_v = debye.molar_heat_capacity_v(temperature, Debye_T, params[\"n\"])\n        return C_v",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity at the pressure, temperature, and volume [1/K]\n        \"\"\"\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        gr = self._grueneisen_parameter(params[\"V_0\"] / volume, params)\n        K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = gr * C_v / K / volume\n        return alpha",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure at the pressure, temperature, and volume [J/K/mol]\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self._grueneisen_parameter(params[\"V_0\"] / volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        C_p = C_v * (1.0 + gr * alpha * temperature)\n        return C_p",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].  EQ D6\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self._grueneisen_parameter(params[\"V_0\"] / volume, params)\n        K_S = K_T * (1.0 + gr * alpha * temperature)\n        return K_S",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        EQ B7\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        return (\n            bm.birch_murnaghan(params[\"V_0\"] / volume, params)\n            + self._thermal_pressure(temperature, volume, params)\n            - self._thermal_pressure(T_0, volume, params)\n        )",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        G = (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n        return G",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        return self.helmholtz_free_energy(\n            pressure, temperature, volume, params\n        ) + temperature * self.entropy(pressure, temperature, volume, params)",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy at the pressure and temperature of the mineral [J/K/mol]\n        \"\"\"\n        Debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        S = debye.entropy(temperature, Debye_T, params[\"n\"])\n        return S",
  "def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n\n        return (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + temperature * self.entropy(pressure, temperature, volume, params)\n            + pressure * volume\n        )",
  "def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        x = params[\"V_0\"] / volume\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28, SLB2005\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29, SLB2005\n\n        F_pressure = (\n            0.5 * b_iikk * f * f * params[\"V_0\"]\n            + (1.0 / 6.0) * params[\"V_0\"] * b_iikkmm * f * f * f\n        )\n\n        Debye_T = self._debye_temperature(params[\"V_0\"] / volume, params)\n        F_thermal = debye.helmholtz_free_energy(\n            temperature, Debye_T, params[\"n\"]\n        ) - debye.helmholtz_free_energy(params[\"T_0\"], Debye_T, params[\"n\"])\n\n        return params[\"F_0\"] + F_pressure + F_thermal",
  "def _thermal_shear_modulus(self, T, V, params):\n        if T > 1.0e-10:\n            gr = self._grueneisen_parameter(params[\"V_0\"] / V, params)\n            Debye_T = self._debye_temperature(params[\"V_0\"] / V, params)\n            G_th = (\n                3.0\n                / 5.0\n                * (\n                    self._thermal_bulk_modulus(T, V, params)\n                    - 6\n                    * constants.gas_constant\n                    * T\n                    * params[\"n\"]\n                    / V\n                    * gr\n                    * debye.debye_fn(Debye_T / T)\n                )\n            )  # EQ B10\n            return G_th\n        else:\n            return 0.0",
  "def _debye_temperature(self, x, params):\n        return params[\"Debye_0\"] * np.exp(\n            (params[\"grueneisen_0\"] - self._grueneisen_parameter(x, params))\n            / params[\"q_0\"]\n        )",
  "def _grueneisen_parameter(self, x, params):\n        return params[\"grueneisen_0\"] * pow(1.0 / x, params[\"q_0\"])",
  "def _thermal_pressure(self, T, V, params):\n        Debye_T = self._debye_temperature(params[\"V_0\"] / V, params)\n        gr = self._grueneisen_parameter(params[\"V_0\"] / V, params)\n        P_th = gr * debye.thermal_energy(T, Debye_T, params[\"n\"]) / V\n        return P_th",
  "def _thermal_bulk_modulus(self, T, V, params):\n        if T > 1.0e-10:\n            gr = self._grueneisen_parameter(params[\"V_0\"] / V, params)\n            Debye_T = self._debye_temperature(params[\"V_0\"] / V, params)\n            K_th = (\n                3.0\n                * params[\"n\"]\n                * constants.gas_constant\n                * T\n                / V\n                * gr\n                * (\n                    (1.0 - params[\"q_0\"] - 3.0 * gr) * debye.debye_fn(Debye_T / T)\n                    + 3.0 * gr * (Debye_T / T) / (np.exp(Debye_T / T) - 1.0)\n                )\n            )  # EQ B5\n            return K_th\n        else:\n            return 0.0",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 300.0\n        if \"F_0\" not in params:\n            params[\"F_0\"] = 0.0\n\n        # First, let's check the EoS parameters for Tref\n        bm.BirchMurnaghanBase.validate_parameters(bm.BirchMurnaghanBase(), params)\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"molar_mass\", \"n\", \"Debye_0\", \"grueneisen_0\", \"q_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 1.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)\n        if params[\"Debye_0\"] < 1.0 or params[\"Debye_0\"] > 10000.0:\n            warnings.warn(\"Unusual value for Debye_0\", stacklevel=2)\n        if params[\"grueneisen_0\"] < 0.0 or params[\"grueneisen_0\"] > 10.0:\n            warnings.warn(\"Unusual value for grueneisen_0\", stacklevel=2)\n        if params[\"q_0\"] < -10.0 or params[\"q_0\"] > 10.0:\n            warnings.warn(\"Unusual value for q_0\", stacklevel=2)",
  "def __init__(self):\n        self.order = 3",
  "def __init__(self):\n        self.order = 2",
  "class BroshCalphad(eos.EquationOfState):\n    \"\"\"\n    Class for the high pressure CALPHAD equation of state by\n    :cite:`Brosh2007`.\n    \"\"\"\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        X = [\n            1.0\n            / (\n                1.0\n                - params[\"a\"][i - 2]\n                + params[\"a\"][i - 2]\n                * np.power(\n                    1.0 + i / (3.0 * params[\"a\"][i - 2]) * pressure / params[\"K_0\"],\n                    1.0 / float(i),\n                )\n            )\n            for i in range(2, 6)\n        ]\n        V_c = params[\"V_0\"] * np.sum(\n            [params[\"c\"][i - 2] * np.power(X[i - 2], 3.0) for i in range(2, 6)]\n        )\n\n        nu = self._theta(pressure, params) / temperature\n        dP = 1000.0\n        dthetadP = (\n            self._theta(pressure + dP / 2.0, params)\n            - self._theta(pressure - dP / 2.0, params)\n        ) / dP\n        V_qh = (\n            3.0\n            * params[\"n\"]\n            * gas_constant\n            * np.exp(-nu)\n            / (1.0 - np.exp(-nu))\n            * dthetadP\n        )  # eq. 6\n\n        f = np.sqrt(\n            1.0\n            + 2.0\n            * params[\"b\"][1]\n            * (1.0 + params[\"delta\"][1])\n            * pressure\n            / params[\"K_0\"]\n        )\n        dIdP = (\n            (1.0 + params[\"delta\"][1])\n            / (params[\"K_0\"] * (1.0 + params[\"b\"][1]))\n            * np.exp((1.0 - f) / params[\"b\"][1])\n        )\n        V_th = self._C_T(temperature, params) * dIdP\n\n        # V = dG_c/dP + dG_qh/dP - C_T*(dI_P/dP)\n        return V_c + V_qh + V_th\n\n    def pressure(self, temperature, volume, params):\n        def _delta_volume(pressure):\n            return self.volume(pressure, temperature, params) - volume\n\n        try:\n            sol = bracket(_delta_volume, 300.0e9, 1.0e5, ())\n        except ValueError:\n            raise Exception(\n                \"Cannot find a pressure, perhaps you are outside \"\n                \"the range of validity for the equation of state?\"\n            )\n\n        return brentq(_delta_volume, sol[0], sol[1])\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the isothermal bulk modulus :math:`K_T` :math:`[Pa]`\n        as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        dP = 1000.0\n        dV = self.volume(pressure + dP / 2.0, temperature, params) - self.volume(\n            pressure - dP / 2.0, temperature, params\n        )\n\n        return -volume * dP / dV\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the adiabatic bulk modulus of the mineral. :math:`[Pa]`.\n        \"\"\"\n        if temperature < 1.0e-10:\n            return self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        else:\n            return (\n                self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n                * self.molar_heat_capacity_p(pressure, temperature, volume, params)\n                / self.molar_heat_capacity_v(pressure, temperature, volume, params)\n            )\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        \"\"\"\n        return 0.0\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy of the mineral. :math:`[J/mol]`\n        \"\"\"\n\n        return (\n            self.gibbs_free_energy(pressure, temperature, volume, params)\n            - pressure * self.volume(pressure, temperature, params)\n            + temperature * self.entropy(pressure, temperature, volume, params)\n        )\n\n    def _Cp_1bar(self, temperature, params):\n        # first, identify which of the piecewise segments we're in\n        i = np.argmax(\n            [T > temperature for T in list(zip(*params[\"gibbs_coefficients\"]))[0]]\n        )\n\n        # select the appropriate coefficients\n        coeffs = params[\"gibbs_coefficients\"][i][1]\n        Cp = -(\n            coeffs[2]\n            + 2.0 * coeffs[3] / temperature / temperature\n            + 6.0 * coeffs[4] / (temperature * temperature * temperature)\n            + 12.0 * coeffs[5] * np.power(temperature, -4.0)\n            + 90.0 * coeffs[6] * np.power(temperature, -10.0)\n            + 2.0 * coeffs[7] * temperature\n            + 6.0 * coeffs[8] * temperature * temperature\n            + 12.0 * coeffs[9] * temperature * temperature * temperature\n            + 42.0 * coeffs[10] * np.power(temperature, 6.0)\n            - 0.25 * coeffs[11] / np.sqrt(temperature)\n            - coeffs[12] / temperature\n        )\n        return Cp\n\n    def _S_1bar(self, temperature, params):\n        # first, identify which of the piecewise segments we're in\n        i = np.argmax(\n            [T > temperature for T in list(zip(*params[\"gibbs_coefficients\"]))[0]]\n        )\n\n        # select the appropriate coefficients\n        coeffs = params[\"gibbs_coefficients\"][i][1]\n        S = -(\n            coeffs[1]\n            + coeffs[2] * (1.0 + np.log(temperature))\n            - coeffs[3] / temperature / temperature\n            - 2.0 * coeffs[4] / (temperature * temperature * temperature)\n            - 3.0 * coeffs[5] * np.power(temperature, -4.0)\n            - 9.0 * coeffs[6] * np.power(temperature, -10.0)\n            + 2.0 * coeffs[7] * temperature\n            + 3.0 * coeffs[8] * temperature * temperature\n            + 4.0 * coeffs[9] * temperature * temperature * temperature\n            + 7.0 * coeffs[10] * np.power(temperature, 6.0)\n            + 0.5 * coeffs[11] / np.sqrt(temperature)\n            + coeffs[12] / temperature\n        )\n        return S\n\n    def _gibbs_1bar(self, temperature, params):\n        # first, identify which of the piecewise segments we're in\n        i = np.argmax(\n            [T > temperature for T in list(zip(*params[\"gibbs_coefficients\"]))[0]]\n        )\n\n        # select the appropriate coefficients\n        coeffs = params[\"gibbs_coefficients\"][i][1]\n        gibbs = (\n            coeffs[0]\n            + coeffs[1] * temperature\n            + coeffs[2] * temperature * np.log(temperature)\n            + coeffs[3] / temperature\n            + coeffs[4] / (temperature * temperature)\n            + coeffs[5] / (temperature * temperature * temperature)\n            + coeffs[6] * np.power(temperature, -9.0)\n            + coeffs[7] * temperature * temperature\n            + coeffs[8] * temperature * temperature * temperature\n            + coeffs[9] * np.power(temperature, 4.0)\n            + coeffs[10] * np.power(temperature, 7.0)\n            + coeffs[11] * np.sqrt(temperature)\n            + coeffs[12] * np.log(temperature)\n        )\n        return gibbs\n\n    def _X(self, pressure, params):\n        return [\n            1.0\n            / (\n                1.0\n                - params[\"a\"][n - 2]\n                + params[\"a\"][n - 2]\n                * np.power(\n                    1.0\n                    + float(n) / (3.0 * params[\"a\"][n - 2]) * pressure / params[\"K_0\"],\n                    1.0 / float(n),\n                )\n            )\n            for n in range(2, 6)\n        ]  # eq. A2\n\n    def _Gamma(self, n, an, Xn):\n        def d(k, Xn):\n            return (\n                np.power(Xn, 3.0 - float(k)) * float(k) / (float(k) - 3.0)\n                if k != 3\n                else -3.0 * np.log(Xn)\n            )  # eq. A9\n\n        return (\n            3.0\n            * np.power(an, 1.0 - float(n))\n            / float(n)\n            * np.sum(\n                [\n                    binom(n, k) * np.power(an - 1.0, float(n - k)) * d(k, Xn)\n                    for k in range(0, n + 1)\n                ]\n            )\n        )  # eq. A9, CHECKED\n\n    def _theta(self, pressure, params):\n        # Theta (for quasiharmonic term)\n        ab2 = 1.0 / (3.0 * params[\"b\"][0] - 1.0)\n        K0b = params[\"K_0\"] / (1.0 + params[\"delta\"][0])  # eq. B1b\n        XT2 = 1.0 / (\n            1.0 - ab2 + ab2 * np.power(1.0 + 2.0 / (3.0 * ab2) * pressure / K0b, 0.5)\n        )  # eq. 6 b of SE2015\n\n        # eq. B1 (6 of SE2015)\n        return params[\"theta_0\"] * np.exp(\n            params[\"grueneisen_0\"]\n            / (1.0 + params[\"delta\"][0])\n            * (self._Gamma(2, ab2, XT2) - self._Gamma(2, ab2, 1.0))\n        )\n\n    def _interpolating_function(self, pressure, params):\n        f = np.sqrt(\n            1.0\n            + 2.0\n            * params[\"b\"][1]\n            * (1.0 + params[\"delta\"][1])\n            * pressure\n            / params[\"K_0\"]\n        )\n\n        # eq. D2 (9 of SE2015)\n        return (\n            1.0\n            / (1.0 + params[\"b\"][1])\n            * (params[\"b\"][1] + f)\n            * np.exp((1.0 - f) / params[\"b\"][1])\n        )\n\n    def _gibbs_qh(self, temperature, theta, n):\n        return (\n            3.0\n            * n\n            * gas_constant\n            * temperature\n            * np.log(1.0 - np.exp(-theta / temperature))\n        )  # eq. 5\n\n    def _S_qh(self, temperature, theta, n):\n        nu = theta / temperature\n        return (\n            3.0\n            * n\n            * gas_constant\n            * (nu / (np.exp(nu) - 1.0) - np.log(1.0 - np.exp(-nu)))\n        )\n\n    def _C_T(self, temperature, params):\n        # C, which is the (G_qh(t,p0) - G_sgte(t,p0)) term\n        G_SGTE = self._gibbs_1bar(temperature, params)\n        G_qh0 = self._gibbs_qh(temperature, params[\"theta_0\"], params[\"n\"])\n        if temperature < params[\"T_0\"]:\n            C_T = (\n                temperature * temperature / (2.0 * params[\"T_0\"]) * params[\"delta_Cpr\"]\n            )\n\n        else:\n            C_T = (\n                (G_qh0 - G_SGTE)\n                + params[\"delta_Gr\"]\n                - (temperature - params[\"T_0\"]) * params[\"delta_Sr\"]\n                + (temperature - params[\"T_0\"] / 2.0) * params[\"delta_Cpr\"]\n            )\n\n        return C_T\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # Cold compression term, eq. A8\n        X = self._X(pressure, params)\n        G_c = (\n            params[\"K_0\"]\n            * params[\"V_0\"]\n            * np.sum(\n                [\n                    params[\"c\"][n - 2]\n                    * (\n                        self._Gamma(n, params[\"a\"][n - 2], X[n - 2])\n                        - self._Gamma(n, params[\"a\"][n - 2], 1.0)\n                    )\n                    for n in range(2, 6)\n                ]\n            )\n        )\n\n        # G_SGTE\n        G_SGTE = self._gibbs_1bar(temperature, params)\n\n        # G_qh\n        theta = self._theta(pressure, params)\n        G_qh = self._gibbs_qh(temperature, theta, params[\"n\"])\n        G_qh0 = self._gibbs_qh(temperature, params[\"theta_0\"], params[\"n\"])\n\n        C_T = self._C_T(temperature, params)\n        I_P = self._interpolating_function(pressure, params)\n        return G_SGTE + G_c + G_qh - G_qh0 + C_T * (1.0 - I_P)\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n\n        S_SGTE = self._S_1bar(temperature, params)\n\n        # S_qh\n        theta = self._theta(pressure, params)\n        S_qh = self._S_qh(temperature, theta, params[\"n\"])\n        S_qh0 = self._S_qh(temperature, params[\"theta_0\"], params[\"n\"])\n\n        # dCdT, which is the (S_qh(t,p0) - S_sgte(t,p0)) term\n        if temperature < params[\"T_0\"]:\n            dC_TdT = temperature / params[\"T_0\"] * params[\"delta_Cpr\"]\n\n        else:\n            dC_TdT = -(S_qh0 - S_SGTE) - params[\"delta_Sr\"] + params[\"delta_Cpr\"]\n\n        I_P = self._interpolating_function(pressure, params)\n        return S_SGTE + S_qh - S_qh0 - dC_TdT * (1.0 - I_P)\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar isobaric heat capacity :math:`[J/K/mol]`.\n        For now, this is calculated by numerical differentiation.\n        \"\"\"\n        dT = 0.1\n        if temperature < dT / 2.0:\n            return 0.0\n        else:\n            dS = self.entropy(\n                pressure, temperature + dT / 2.0, volume, params\n            ) - self.entropy(pressure, temperature - dT / 2.0, volume, params)\n            return temperature * dS / dT\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the volumetric thermal expansivity :math:`[1/K]`.\n        For now, this is calculated by numerical differentiation.\n        \"\"\"\n        dT = 0.1\n        if temperature < dT / 2.0:\n            return 0.0\n        else:\n            dV = self.volume(pressure, temperature + dT / 2.0, params) - self.volume(\n                pressure, temperature - dT / 2.0, params\n            )\n            return dV / dT / volume\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the grueneisen parameter.\n        This is a dependent thermodynamic variable in this equation of state.\n        \"\"\"\n        Cv = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        if Cv == 0.0:\n            return 0.0\n        else:\n            return (\n                self.thermal_expansivity(pressure, temperature, volume, params)\n                * self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n                * self.volume(pressure, temperature, params)\n            ) / Cv\n\n    def calculate_transformed_parameters(self, params):\n        \"\"\"\n        This function calculates the \"c\" parameters of the :cite:`Brosh2007`\n        equation of state.\n        \"\"\"\n        Zs = pkgutil.get_data(\"burnman\", \"data/input_masses/atomic_numbers.dat\")\n        Zs = Zs.decode(\"ascii\").split(\"\\n\")\n        Z = {\n            str(sl[0]): int(sl[1])\n            for sl in [line.split() for line in Zs if len(line) > 0 and line[0] != \"#\"]\n        }\n\n        nZs = [(n_at, float(Z[el])) for (el, n_at) in params[\"formula\"].items()]\n\n        # eq. A2 at 300 TPa\n        X3_300TPa = [\n            np.power(\n                1.0\n                - params[\"a\"][i - 2]\n                + params[\"a\"][i - 2]\n                * np.power(\n                    (\n                        1.0\n                        + float(i)\n                        / (3.0 * params[\"a\"][i - 2])\n                        * 300.0e12\n                        / params[\"K_0\"]\n                    ),\n                    1.0 / float(i),\n                ),\n                -3.0,\n            )\n            for i in range(2, 6)\n        ]\n\n        # eq. A2 at 330 TPa\n        X3_330TPa = [\n            np.power(\n                1.0\n                - params[\"a\"][i - 2]\n                + params[\"a\"][i - 2]\n                * np.power(\n                    (\n                        1.0\n                        + float(i)\n                        / (3.0 * params[\"a\"][i - 2])\n                        * 330.0e12\n                        / params[\"K_0\"]\n                    ),\n                    1.0 / float(i),\n                ),\n                -3.0,\n            )\n            for i in range(2, 6)\n        ]\n\n        # eq. A6a, m^3/mol\n        V_QSM_300TPa = (\n            np.sum(\n                [\n                    n_at\n                    * (\n                        0.02713\n                        * np.exp(\n                            0.97626 * np.log(Zi) - 0.057848 * np.log(Zi) * np.log(Zi)\n                        )\n                    )\n                    for (n_at, Zi) in nZs\n                ]\n            )\n            * 1.0e-6\n        )\n\n        # eq. A6b, m^3/mol\n        V_QSM_330TPa = (\n            np.sum(\n                [\n                    n_at\n                    * (\n                        0.025692\n                        * np.exp(\n                            0.97914 * np.log(Zi) - 0.057741 * np.log(Zi) * np.log(Zi)\n                        )\n                    )\n                    for (n_at, Zi) in nZs\n                ]\n            )\n            * 1.0e-6\n        )\n\n        A = np.array(\n            [\n                [1.0, 1.0, 1.0, 1.0],  # eq A3\n                [0.0, 6.0, 8.0, 9.0],  # eq A4\n                X3_300TPa,  # eq A5a\n                X3_330TPa,\n            ]\n        )  # eq A5b\n\n        b = np.array(\n            [1.0, 8.0, V_QSM_300TPa / params[\"V_0\"], V_QSM_330TPa / params[\"V_0\"]]\n        )\n\n        # does not quite reproduce the published values of c\n        # A.c consistently gives b[2], b[3] ~1% larger than Brosh\n        return np.linalg.solve(A, b)\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        params[\"T_0\"] = 298.15\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 1.0e5\n\n        if \"a\" not in params:\n            params[\"a\"] = [\n                (float(i) - 1.0) / (3.0 * params[\"Kprime_0\"] - 1.0) for i in range(2, 6)\n            ]  # eq. A2\n\n        if \"c\" not in params:\n            params[\"c\"] = self.calculate_transformed_parameters(params)\n\n        # Calculate reference values for gibbs free energy and heat capacity\n        nur = params[\"theta_0\"] / params[\"T_0\"]\n        G_qhr = self._gibbs_qh(params[\"T_0\"], params[\"theta_0\"], params[\"n\"])\n        S_qhr = self._S_qh(params[\"T_0\"], params[\"theta_0\"], params[\"n\"])\n        Cp_qhr = (\n            3.0\n            * params[\"n\"]\n            * gas_constant\n            * nur\n            * nur\n            * np.exp(nur)\n            / np.power(np.exp(nur) - 1.0, 2.0)\n        )\n\n        G_SGTEr = self._gibbs_1bar(params[\"T_0\"], params)\n        S_SGTEr = self._S_1bar(params[\"T_0\"], params)\n        Cp_SGTEr = self._Cp_1bar(params[\"T_0\"], params)\n\n        params[\"delta_Cpr\"] = Cp_SGTEr - Cp_qhr\n        params[\"delta_Gr\"] = G_SGTEr - G_qhr\n        params[\"delta_Sr\"] = S_SGTEr - S_qhr\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\n            \"gibbs_coefficients\",\n            \"V_0\",\n            \"K_0\",\n            \"Kprime_0\",\n            \"theta_0\",\n            \"grueneisen_0\",\n            \"delta\",\n            \"b\",\n        ]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        X = [\n            1.0\n            / (\n                1.0\n                - params[\"a\"][i - 2]\n                + params[\"a\"][i - 2]\n                * np.power(\n                    1.0 + i / (3.0 * params[\"a\"][i - 2]) * pressure / params[\"K_0\"],\n                    1.0 / float(i),\n                )\n            )\n            for i in range(2, 6)\n        ]\n        V_c = params[\"V_0\"] * np.sum(\n            [params[\"c\"][i - 2] * np.power(X[i - 2], 3.0) for i in range(2, 6)]\n        )\n\n        nu = self._theta(pressure, params) / temperature\n        dP = 1000.0\n        dthetadP = (\n            self._theta(pressure + dP / 2.0, params)\n            - self._theta(pressure - dP / 2.0, params)\n        ) / dP\n        V_qh = (\n            3.0\n            * params[\"n\"]\n            * gas_constant\n            * np.exp(-nu)\n            / (1.0 - np.exp(-nu))\n            * dthetadP\n        )  # eq. 6\n\n        f = np.sqrt(\n            1.0\n            + 2.0\n            * params[\"b\"][1]\n            * (1.0 + params[\"delta\"][1])\n            * pressure\n            / params[\"K_0\"]\n        )\n        dIdP = (\n            (1.0 + params[\"delta\"][1])\n            / (params[\"K_0\"] * (1.0 + params[\"b\"][1]))\n            * np.exp((1.0 - f) / params[\"b\"][1])\n        )\n        V_th = self._C_T(temperature, params) * dIdP\n\n        # V = dG_c/dP + dG_qh/dP - C_T*(dI_P/dP)\n        return V_c + V_qh + V_th",
  "def pressure(self, temperature, volume, params):\n        def _delta_volume(pressure):\n            return self.volume(pressure, temperature, params) - volume\n\n        try:\n            sol = bracket(_delta_volume, 300.0e9, 1.0e5, ())\n        except ValueError:\n            raise Exception(\n                \"Cannot find a pressure, perhaps you are outside \"\n                \"the range of validity for the equation of state?\"\n            )\n\n        return brentq(_delta_volume, sol[0], sol[1])",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the isothermal bulk modulus :math:`K_T` :math:`[Pa]`\n        as a function of pressure :math:`[Pa]`,\n        temperature :math:`[K]` and volume :math:`[m^3]`.\n        \"\"\"\n        dP = 1000.0\n        dV = self.volume(pressure + dP / 2.0, temperature, params) - self.volume(\n            pressure - dP / 2.0, temperature, params\n        )\n\n        return -volume * dP / dV",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the adiabatic bulk modulus of the mineral. :math:`[Pa]`.\n        \"\"\"\n        if temperature < 1.0e-10:\n            return self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        else:\n            return (\n                self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n                * self.molar_heat_capacity_p(pressure, temperature, volume, params)\n                / self.molar_heat_capacity_v(pressure, temperature, volume, params)\n            )",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the shear modulus :math:`G` of the mineral. :math:`[Pa]`\n        \"\"\"\n        return 0.0",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy of the mineral. :math:`[J/mol]`\n        \"\"\"\n\n        return (\n            self.gibbs_free_energy(pressure, temperature, volume, params)\n            - pressure * self.volume(pressure, temperature, params)\n            + temperature * self.entropy(pressure, temperature, volume, params)\n        )",
  "def _Cp_1bar(self, temperature, params):\n        # first, identify which of the piecewise segments we're in\n        i = np.argmax(\n            [T > temperature for T in list(zip(*params[\"gibbs_coefficients\"]))[0]]\n        )\n\n        # select the appropriate coefficients\n        coeffs = params[\"gibbs_coefficients\"][i][1]\n        Cp = -(\n            coeffs[2]\n            + 2.0 * coeffs[3] / temperature / temperature\n            + 6.0 * coeffs[4] / (temperature * temperature * temperature)\n            + 12.0 * coeffs[5] * np.power(temperature, -4.0)\n            + 90.0 * coeffs[6] * np.power(temperature, -10.0)\n            + 2.0 * coeffs[7] * temperature\n            + 6.0 * coeffs[8] * temperature * temperature\n            + 12.0 * coeffs[9] * temperature * temperature * temperature\n            + 42.0 * coeffs[10] * np.power(temperature, 6.0)\n            - 0.25 * coeffs[11] / np.sqrt(temperature)\n            - coeffs[12] / temperature\n        )\n        return Cp",
  "def _S_1bar(self, temperature, params):\n        # first, identify which of the piecewise segments we're in\n        i = np.argmax(\n            [T > temperature for T in list(zip(*params[\"gibbs_coefficients\"]))[0]]\n        )\n\n        # select the appropriate coefficients\n        coeffs = params[\"gibbs_coefficients\"][i][1]\n        S = -(\n            coeffs[1]\n            + coeffs[2] * (1.0 + np.log(temperature))\n            - coeffs[3] / temperature / temperature\n            - 2.0 * coeffs[4] / (temperature * temperature * temperature)\n            - 3.0 * coeffs[5] * np.power(temperature, -4.0)\n            - 9.0 * coeffs[6] * np.power(temperature, -10.0)\n            + 2.0 * coeffs[7] * temperature\n            + 3.0 * coeffs[8] * temperature * temperature\n            + 4.0 * coeffs[9] * temperature * temperature * temperature\n            + 7.0 * coeffs[10] * np.power(temperature, 6.0)\n            + 0.5 * coeffs[11] / np.sqrt(temperature)\n            + coeffs[12] / temperature\n        )\n        return S",
  "def _gibbs_1bar(self, temperature, params):\n        # first, identify which of the piecewise segments we're in\n        i = np.argmax(\n            [T > temperature for T in list(zip(*params[\"gibbs_coefficients\"]))[0]]\n        )\n\n        # select the appropriate coefficients\n        coeffs = params[\"gibbs_coefficients\"][i][1]\n        gibbs = (\n            coeffs[0]\n            + coeffs[1] * temperature\n            + coeffs[2] * temperature * np.log(temperature)\n            + coeffs[3] / temperature\n            + coeffs[4] / (temperature * temperature)\n            + coeffs[5] / (temperature * temperature * temperature)\n            + coeffs[6] * np.power(temperature, -9.0)\n            + coeffs[7] * temperature * temperature\n            + coeffs[8] * temperature * temperature * temperature\n            + coeffs[9] * np.power(temperature, 4.0)\n            + coeffs[10] * np.power(temperature, 7.0)\n            + coeffs[11] * np.sqrt(temperature)\n            + coeffs[12] * np.log(temperature)\n        )\n        return gibbs",
  "def _X(self, pressure, params):\n        return [\n            1.0\n            / (\n                1.0\n                - params[\"a\"][n - 2]\n                + params[\"a\"][n - 2]\n                * np.power(\n                    1.0\n                    + float(n) / (3.0 * params[\"a\"][n - 2]) * pressure / params[\"K_0\"],\n                    1.0 / float(n),\n                )\n            )\n            for n in range(2, 6)\n        ]",
  "def _Gamma(self, n, an, Xn):\n        def d(k, Xn):\n            return (\n                np.power(Xn, 3.0 - float(k)) * float(k) / (float(k) - 3.0)\n                if k != 3\n                else -3.0 * np.log(Xn)\n            )  # eq. A9\n\n        return (\n            3.0\n            * np.power(an, 1.0 - float(n))\n            / float(n)\n            * np.sum(\n                [\n                    binom(n, k) * np.power(an - 1.0, float(n - k)) * d(k, Xn)\n                    for k in range(0, n + 1)\n                ]\n            )\n        )",
  "def _theta(self, pressure, params):\n        # Theta (for quasiharmonic term)\n        ab2 = 1.0 / (3.0 * params[\"b\"][0] - 1.0)\n        K0b = params[\"K_0\"] / (1.0 + params[\"delta\"][0])  # eq. B1b\n        XT2 = 1.0 / (\n            1.0 - ab2 + ab2 * np.power(1.0 + 2.0 / (3.0 * ab2) * pressure / K0b, 0.5)\n        )  # eq. 6 b of SE2015\n\n        # eq. B1 (6 of SE2015)\n        return params[\"theta_0\"] * np.exp(\n            params[\"grueneisen_0\"]\n            / (1.0 + params[\"delta\"][0])\n            * (self._Gamma(2, ab2, XT2) - self._Gamma(2, ab2, 1.0))\n        )",
  "def _interpolating_function(self, pressure, params):\n        f = np.sqrt(\n            1.0\n            + 2.0\n            * params[\"b\"][1]\n            * (1.0 + params[\"delta\"][1])\n            * pressure\n            / params[\"K_0\"]\n        )\n\n        # eq. D2 (9 of SE2015)\n        return (\n            1.0\n            / (1.0 + params[\"b\"][1])\n            * (params[\"b\"][1] + f)\n            * np.exp((1.0 - f) / params[\"b\"][1])\n        )",
  "def _gibbs_qh(self, temperature, theta, n):\n        return (\n            3.0\n            * n\n            * gas_constant\n            * temperature\n            * np.log(1.0 - np.exp(-theta / temperature))\n        )",
  "def _S_qh(self, temperature, theta, n):\n        nu = theta / temperature\n        return (\n            3.0\n            * n\n            * gas_constant\n            * (nu / (np.exp(nu) - 1.0) - np.log(1.0 - np.exp(-nu)))\n        )",
  "def _C_T(self, temperature, params):\n        # C, which is the (G_qh(t,p0) - G_sgte(t,p0)) term\n        G_SGTE = self._gibbs_1bar(temperature, params)\n        G_qh0 = self._gibbs_qh(temperature, params[\"theta_0\"], params[\"n\"])\n        if temperature < params[\"T_0\"]:\n            C_T = (\n                temperature * temperature / (2.0 * params[\"T_0\"]) * params[\"delta_Cpr\"]\n            )\n\n        else:\n            C_T = (\n                (G_qh0 - G_SGTE)\n                + params[\"delta_Gr\"]\n                - (temperature - params[\"T_0\"]) * params[\"delta_Sr\"]\n                + (temperature - params[\"T_0\"] / 2.0) * params[\"delta_Cpr\"]\n            )\n\n        return C_T",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # Cold compression term, eq. A8\n        X = self._X(pressure, params)\n        G_c = (\n            params[\"K_0\"]\n            * params[\"V_0\"]\n            * np.sum(\n                [\n                    params[\"c\"][n - 2]\n                    * (\n                        self._Gamma(n, params[\"a\"][n - 2], X[n - 2])\n                        - self._Gamma(n, params[\"a\"][n - 2], 1.0)\n                    )\n                    for n in range(2, 6)\n                ]\n            )\n        )\n\n        # G_SGTE\n        G_SGTE = self._gibbs_1bar(temperature, params)\n\n        # G_qh\n        theta = self._theta(pressure, params)\n        G_qh = self._gibbs_qh(temperature, theta, params[\"n\"])\n        G_qh0 = self._gibbs_qh(temperature, params[\"theta_0\"], params[\"n\"])\n\n        C_T = self._C_T(temperature, params)\n        I_P = self._interpolating_function(pressure, params)\n        return G_SGTE + G_c + G_qh - G_qh0 + C_T * (1.0 - I_P)",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n\n        S_SGTE = self._S_1bar(temperature, params)\n\n        # S_qh\n        theta = self._theta(pressure, params)\n        S_qh = self._S_qh(temperature, theta, params[\"n\"])\n        S_qh0 = self._S_qh(temperature, params[\"theta_0\"], params[\"n\"])\n\n        # dCdT, which is the (S_qh(t,p0) - S_sgte(t,p0)) term\n        if temperature < params[\"T_0\"]:\n            dC_TdT = temperature / params[\"T_0\"] * params[\"delta_Cpr\"]\n\n        else:\n            dC_TdT = -(S_qh0 - S_SGTE) - params[\"delta_Sr\"] + params[\"delta_Cpr\"]\n\n        I_P = self._interpolating_function(pressure, params)\n        return S_SGTE + S_qh - S_qh0 - dC_TdT * (1.0 - I_P)",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar isobaric heat capacity :math:`[J/K/mol]`.\n        For now, this is calculated by numerical differentiation.\n        \"\"\"\n        dT = 0.1\n        if temperature < dT / 2.0:\n            return 0.0\n        else:\n            dS = self.entropy(\n                pressure, temperature + dT / 2.0, volume, params\n            ) - self.entropy(pressure, temperature - dT / 2.0, volume, params)\n            return temperature * dS / dT",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the volumetric thermal expansivity :math:`[1/K]`.\n        For now, this is calculated by numerical differentiation.\n        \"\"\"\n        dT = 0.1\n        if temperature < dT / 2.0:\n            return 0.0\n        else:\n            dV = self.volume(pressure, temperature + dT / 2.0, params) - self.volume(\n                pressure, temperature - dT / 2.0, params\n            )\n            return dV / dT / volume",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the grueneisen parameter.\n        This is a dependent thermodynamic variable in this equation of state.\n        \"\"\"\n        Cv = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        if Cv == 0.0:\n            return 0.0\n        else:\n            return (\n                self.thermal_expansivity(pressure, temperature, volume, params)\n                * self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n                * self.volume(pressure, temperature, params)\n            ) / Cv",
  "def calculate_transformed_parameters(self, params):\n        \"\"\"\n        This function calculates the \"c\" parameters of the :cite:`Brosh2007`\n        equation of state.\n        \"\"\"\n        Zs = pkgutil.get_data(\"burnman\", \"data/input_masses/atomic_numbers.dat\")\n        Zs = Zs.decode(\"ascii\").split(\"\\n\")\n        Z = {\n            str(sl[0]): int(sl[1])\n            for sl in [line.split() for line in Zs if len(line) > 0 and line[0] != \"#\"]\n        }\n\n        nZs = [(n_at, float(Z[el])) for (el, n_at) in params[\"formula\"].items()]\n\n        # eq. A2 at 300 TPa\n        X3_300TPa = [\n            np.power(\n                1.0\n                - params[\"a\"][i - 2]\n                + params[\"a\"][i - 2]\n                * np.power(\n                    (\n                        1.0\n                        + float(i)\n                        / (3.0 * params[\"a\"][i - 2])\n                        * 300.0e12\n                        / params[\"K_0\"]\n                    ),\n                    1.0 / float(i),\n                ),\n                -3.0,\n            )\n            for i in range(2, 6)\n        ]\n\n        # eq. A2 at 330 TPa\n        X3_330TPa = [\n            np.power(\n                1.0\n                - params[\"a\"][i - 2]\n                + params[\"a\"][i - 2]\n                * np.power(\n                    (\n                        1.0\n                        + float(i)\n                        / (3.0 * params[\"a\"][i - 2])\n                        * 330.0e12\n                        / params[\"K_0\"]\n                    ),\n                    1.0 / float(i),\n                ),\n                -3.0,\n            )\n            for i in range(2, 6)\n        ]\n\n        # eq. A6a, m^3/mol\n        V_QSM_300TPa = (\n            np.sum(\n                [\n                    n_at\n                    * (\n                        0.02713\n                        * np.exp(\n                            0.97626 * np.log(Zi) - 0.057848 * np.log(Zi) * np.log(Zi)\n                        )\n                    )\n                    for (n_at, Zi) in nZs\n                ]\n            )\n            * 1.0e-6\n        )\n\n        # eq. A6b, m^3/mol\n        V_QSM_330TPa = (\n            np.sum(\n                [\n                    n_at\n                    * (\n                        0.025692\n                        * np.exp(\n                            0.97914 * np.log(Zi) - 0.057741 * np.log(Zi) * np.log(Zi)\n                        )\n                    )\n                    for (n_at, Zi) in nZs\n                ]\n            )\n            * 1.0e-6\n        )\n\n        A = np.array(\n            [\n                [1.0, 1.0, 1.0, 1.0],  # eq A3\n                [0.0, 6.0, 8.0, 9.0],  # eq A4\n                X3_300TPa,  # eq A5a\n                X3_330TPa,\n            ]\n        )  # eq A5b\n\n        b = np.array(\n            [1.0, 8.0, V_QSM_300TPa / params[\"V_0\"], V_QSM_330TPa / params[\"V_0\"]]\n        )\n\n        # does not quite reproduce the published values of c\n        # A.c consistently gives b[2], b[3] ~1% larger than Brosh\n        return np.linalg.solve(A, b)",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        params[\"T_0\"] = 298.15\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 1.0e5\n\n        if \"a\" not in params:\n            params[\"a\"] = [\n                (float(i) - 1.0) / (3.0 * params[\"Kprime_0\"] - 1.0) for i in range(2, 6)\n            ]  # eq. A2\n\n        if \"c\" not in params:\n            params[\"c\"] = self.calculate_transformed_parameters(params)\n\n        # Calculate reference values for gibbs free energy and heat capacity\n        nur = params[\"theta_0\"] / params[\"T_0\"]\n        G_qhr = self._gibbs_qh(params[\"T_0\"], params[\"theta_0\"], params[\"n\"])\n        S_qhr = self._S_qh(params[\"T_0\"], params[\"theta_0\"], params[\"n\"])\n        Cp_qhr = (\n            3.0\n            * params[\"n\"]\n            * gas_constant\n            * nur\n            * nur\n            * np.exp(nur)\n            / np.power(np.exp(nur) - 1.0, 2.0)\n        )\n\n        G_SGTEr = self._gibbs_1bar(params[\"T_0\"], params)\n        S_SGTEr = self._S_1bar(params[\"T_0\"], params)\n        Cp_SGTEr = self._Cp_1bar(params[\"T_0\"], params)\n\n        params[\"delta_Cpr\"] = Cp_SGTEr - Cp_qhr\n        params[\"delta_Gr\"] = G_SGTEr - G_qhr\n        params[\"delta_Sr\"] = S_SGTEr - S_qhr\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\n            \"gibbs_coefficients\",\n            \"V_0\",\n            \"K_0\",\n            \"Kprime_0\",\n            \"theta_0\",\n            \"grueneisen_0\",\n            \"delta\",\n            \"b\",\n        ]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)",
  "def _delta_volume(pressure):\n            return self.volume(pressure, temperature, params) - volume",
  "def d(k, Xn):\n            return (\n                np.power(Xn, 3.0 - float(k)) * float(k) / (float(k) - 3.0)\n                if k != 3\n                else -3.0 * np.log(Xn)\n            )",
  "def _grueneisen_parameter_fast(V_0, volume, gruen_0, q_0):\n    \"\"\"global function with plain parameters so jit will work\"\"\"\n    x = V_0 / volume\n    f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n    a1_ii = 6.0 * gruen_0  # EQ 47\n    a2_iikk = -12.0 * gruen_0 + 36.0 * gruen_0 * gruen_0 - 18.0 * q_0 * gruen_0  # EQ 47\n    nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41\n    return 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)",
  "def _intgroverVdV(V_0, volume, gruen_0, q_0):\n    return integrate.quad(\n        lambda x: _grueneisen_parameter_fast(V_0, x, gruen_0, q_0) / x, V_0, volume\n    )[0]",
  "def _delta_pressure(\n    x, pressure, temperature, V_0, T_0, Cv, a1_ii, a2_iikk, b_iikk, b_iikkmm\n):\n    f = 0.5 * (pow(V_0 / x, 2.0 / 3.0) - 1.0)\n    nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41\n    gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)\n\n    return (\n        (1.0 / 3.0)\n        * (pow(1.0 + 2.0 * f, 5.0 / 2.0))\n        * ((b_iikk * f) + (0.5 * b_iikkmm * f * f))\n        + gr * Cv * (temperature - T_0) / x\n        - pressure\n    )",
  "class DKS_S(eos.EquationOfState):\n\n    \"\"\"\n    Base class for the finite strain solid equation of state detailed\n    in :cite:`deKoker2013` (supplementary materials).\n    \"\"\"\n\n    def volume_dependent_q(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`q`, the isotropic volume strain\n        derivative of the grueneisen parameter.\n        \"\"\"\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41\n        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)\n        if (\n            np.abs(params[\"grueneisen_0\"]) < 1.0e-10\n        ):  # avoids divide by zero if grueneisen_0 = 0.\n            q = 1.0 / 9.0 * (18.0 * gr - 6.0)\n        else:\n            q = (\n                1.0\n                / 9.0\n                * (\n                    18.0 * gr\n                    - 6.0\n                    - 1.0\n                    / 2.0\n                    / nu_o_nu0_sq\n                    * (2.0 * f + 1.0)\n                    * (2.0 * f + 1.0)\n                    * a2_iikk\n                    / gr\n                )\n            )\n        return q\n\n    def _isotropic_eta_s(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`eta_{s0}`, the isotropic shear\n        strain derivative of the grueneisen parameter.\n        \"\"\"\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        a2_s = -2.0 * params[\"grueneisen_0\"] - 2.0 * params[\"eta_s_0\"]  # EQ 47\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * pow(f, 2.0)  # EQ 41\n        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)\n        # EQ 46 NOTE the typo from Stixrude 2005:\n        eta_s = -gr - (\n            1.0 / 2.0 * pow(nu_o_nu0_sq, -1.0) * pow((2.0 * f) + 1.0, 2.0) * a2_s\n        )\n\n        return eta_s\n\n    # calculate isotropic thermal pressure, see\n    # Matas et. al. (2007) eq B4\n    def _thermal_pressure(self, T, V, params):\n        gr = self.grueneisen_parameter(0.0, T, V, params)  # P not important\n        return params[\"Cv\"] * (T - params[\"T_0\"]) * gr\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns molar volume. :math:`[m^3]`\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        V_0 = params[\"V_0\"]\n        Cv = params[\"Cv\"]\n\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29z\n\n        # we need to have a sign change in [a,b] to find a zero. Let us start with a\n        # conservative guess:\n        args = (pressure, temperature, V_0, T_0, Cv, a1_ii, a2_iikk, b_iikk, b_iikkmm)\n        try:\n            sol = bracket(_delta_pressure, params[\"V_0\"], 1.0e-2 * params[\"V_0\"], args)\n        except ValueError:\n            raise Exception(\n                \"Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?\"\n            )\n        return opt.brentq(_delta_pressure, sol[0], sol[1], args=args)\n\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns the pressure of the mineral at a given temperature and volume [Pa]\n        \"\"\"\n        gr = self.grueneisen_parameter(\n            0.0, temperature, volume, params\n        )  # does not depend on pressure\n\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29\n        f = 0.5 * (pow(params[\"V_0\"] / volume, 2.0 / 3.0) - 1.0)  # EQ 24\n        P = (1.0 / 3.0) * (pow(1.0 + 2.0 * f, 5.0 / 2.0)) * (\n            (b_iikk * f) + (0.5 * b_iikkmm * pow(f, 2.0))\n        ) + gr * params[\"Cv\"] * (\n            temperature - params[\"T_0\"]\n        ) / volume  # EQ 21\n\n        return P\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter :math:`[unitless]`\n        \"\"\"\n        return _grueneisen_parameter_fast(\n            params[\"V_0\"], volume, params[\"grueneisen_0\"], params[\"q_0\"]\n        )\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`[Pa]`\n        \"\"\"\n\n        E_th_diff = params[\"Cv\"] * (temperature - params[\"T_0\"])\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        q = self.volume_dependent_q(params[\"V_0\"] / volume, params)\n        K = (\n            bm.bulk_modulus(volume, params)\n            + (gr + 1.0 - q) * (gr / volume) * E_th_diff\n            - (pow(gr, 2.0) / volume) * E_th_diff\n        )\n\n        return K\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus. :math:`[Pa]`\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        K_S = K_T * (1.0 + gr * alpha * temperature)\n        return K_S\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus. :math:`[Pa]`\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        eta_s = self._isotropic_eta_s(params[\"V_0\"] / volume, params)\n\n        E_th_diff = params[\"Cv\"] * (temperature - params[\"T_0\"])\n        return (\n            bm.shear_modulus_third_order(volume, params) - eta_s * (E_th_diff) / volume\n        )\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume. :math:`[J/K/mol]`\n        \"\"\"\n        return params[\"Cv\"]\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure. :math:`[J/K/mol]`\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        C_p = C_v * (1.0 + gr * alpha * temperature)\n        return C_p\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity. :math:`[1/K]`\n        \"\"\"\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = gr * C_v / K / volume\n        return alpha\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        G = (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n        return G\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        return self.helmholtz_free_energy(\n            pressure, temperature, volume, params\n        ) + temperature * self.entropy(pressure, temperature, volume, params)\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy at the pressure and temperature of the mineral [J/K/mol]\n        \"\"\"\n        S_0 = params[\"S_0\"]\n        gruen_0 = params[\"grueneisen_0\"]\n        q_0 = params[\"q_0\"]\n        S_th = params[\"Cv\"] * (\n            np.log(temperature / params[\"T_0\"])\n            + _intgroverVdV(params[\"V_0\"], volume, gruen_0, q_0)\n        )\n\n        return S_0 + S_th\n\n    def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n\n        return (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + temperature * self.entropy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n\n    def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        V_0 = params[\"V_0\"]\n        gruen_0 = params[\"grueneisen_0\"]\n        q_0 = params[\"q_0\"]\n        x = V_0 / volume\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29\n\n        T_0 = params[\"T_0\"]\n        T = temperature\n        S_0 = params[\"S_0\"]\n        Cv = params[\"Cv\"]\n        F_0 = params[\"E_0\"] - T_0 * S_0\n        F_cmp = 0.5 * b_iikk * f * f * V_0 + (1.0 / 6.0) * V_0 * b_iikkmm * f * f * f\n        F_th = (\n            -S_0 * (T - T_0)\n            - Cv * (T * np.log(T / T_0) - (T - T_0))\n            - Cv * (T - T_0) * _intgroverVdV(V_0, volume, gruen_0, q_0)\n        )\n\n        return F_0 + F_cmp + F_th\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 300.0\n\n        # If eta_s_0 is not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without it,\n        # so just add it to the dictionary as nan\n        # The same goes for the standard state Helmholtz free energy\n        if \"eta_s_0\" not in params:\n            params[\"eta_s_0\"] = float(\"nan\")\n        if \"E_0\" not in params:\n            params[\"E_0\"] = float(\"nan\")\n\n        # First, let's check the EoS parameters for Tref\n        bm.BirchMurnaghanBase.validate_parameters(bm.BirchMurnaghanBase(), params)\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"Cv\", \"grueneisen_0\", \"q_0\", \"eta_s_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"Cv\"] < 0.0 or params[\"Cv\"] > 1000.0:\n            warnings.warn(\"Unusual value for Cv\", stacklevel=2)\n        if params[\"grueneisen_0\"] < -0.005 or params[\"grueneisen_0\"] > 10.0:\n            warnings.warn(\"Unusual value for grueneisen_0\", stacklevel=2)\n        if params[\"q_0\"] < -10.0 or params[\"q_0\"] > 10.0:\n            warnings.warn(\"Unusual value for q_0\", stacklevel=2)\n        if params[\"eta_s_0\"] < -10.0 or params[\"eta_s_0\"] > 10.0:\n            warnings.warn(\"Unusual value for eta_s_0\", stacklevel=2)",
  "def volume_dependent_q(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`q`, the isotropic volume strain\n        derivative of the grueneisen parameter.\n        \"\"\"\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41\n        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)\n        if (\n            np.abs(params[\"grueneisen_0\"]) < 1.0e-10\n        ):  # avoids divide by zero if grueneisen_0 = 0.\n            q = 1.0 / 9.0 * (18.0 * gr - 6.0)\n        else:\n            q = (\n                1.0\n                / 9.0\n                * (\n                    18.0 * gr\n                    - 6.0\n                    - 1.0\n                    / 2.0\n                    / nu_o_nu0_sq\n                    * (2.0 * f + 1.0)\n                    * (2.0 * f + 1.0)\n                    * a2_iikk\n                    / gr\n                )\n            )\n        return q",
  "def _isotropic_eta_s(self, x, params):\n        \"\"\"\n        Finite strain approximation for :math:`eta_{s0}`, the isotropic shear\n        strain derivative of the grueneisen parameter.\n        \"\"\"\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        a2_s = -2.0 * params[\"grueneisen_0\"] - 2.0 * params[\"eta_s_0\"]  # EQ 47\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * pow(f, 2.0)  # EQ 41\n        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)\n        # EQ 46 NOTE the typo from Stixrude 2005:\n        eta_s = -gr - (\n            1.0 / 2.0 * pow(nu_o_nu0_sq, -1.0) * pow((2.0 * f) + 1.0, 2.0) * a2_s\n        )\n\n        return eta_s",
  "def _thermal_pressure(self, T, V, params):\n        gr = self.grueneisen_parameter(0.0, T, V, params)  # P not important\n        return params[\"Cv\"] * (T - params[\"T_0\"]) * gr",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns molar volume. :math:`[m^3]`\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        V_0 = params[\"V_0\"]\n        Cv = params[\"Cv\"]\n\n        a1_ii = 6.0 * params[\"grueneisen_0\"]  # EQ 47\n        a2_iikk = (\n            -12.0 * params[\"grueneisen_0\"]\n            + 36.0 * pow(params[\"grueneisen_0\"], 2.0)\n            - 18.0 * params[\"q_0\"] * params[\"grueneisen_0\"]\n        )  # EQ 47\n\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29z\n\n        # we need to have a sign change in [a,b] to find a zero. Let us start with a\n        # conservative guess:\n        args = (pressure, temperature, V_0, T_0, Cv, a1_ii, a2_iikk, b_iikk, b_iikkmm)\n        try:\n            sol = bracket(_delta_pressure, params[\"V_0\"], 1.0e-2 * params[\"V_0\"], args)\n        except ValueError:\n            raise Exception(\n                \"Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?\"\n            )\n        return opt.brentq(_delta_pressure, sol[0], sol[1], args=args)",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns the pressure of the mineral at a given temperature and volume [Pa]\n        \"\"\"\n        gr = self.grueneisen_parameter(\n            0.0, temperature, volume, params\n        )  # does not depend on pressure\n\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29\n        f = 0.5 * (pow(params[\"V_0\"] / volume, 2.0 / 3.0) - 1.0)  # EQ 24\n        P = (1.0 / 3.0) * (pow(1.0 + 2.0 * f, 5.0 / 2.0)) * (\n            (b_iikk * f) + (0.5 * b_iikkmm * pow(f, 2.0))\n        ) + gr * params[\"Cv\"] * (\n            temperature - params[\"T_0\"]\n        ) / volume  # EQ 21\n\n        return P",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter :math:`[unitless]`\n        \"\"\"\n        return _grueneisen_parameter_fast(\n            params[\"V_0\"], volume, params[\"grueneisen_0\"], params[\"q_0\"]\n        )",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`[Pa]`\n        \"\"\"\n\n        E_th_diff = params[\"Cv\"] * (temperature - params[\"T_0\"])\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        q = self.volume_dependent_q(params[\"V_0\"] / volume, params)\n        K = (\n            bm.bulk_modulus(volume, params)\n            + (gr + 1.0 - q) * (gr / volume) * E_th_diff\n            - (pow(gr, 2.0) / volume) * E_th_diff\n        )\n\n        return K",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus. :math:`[Pa]`\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        K_S = K_T * (1.0 + gr * alpha * temperature)\n        return K_S",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns shear modulus. :math:`[Pa]`\n        \"\"\"\n        T_0 = params[\"T_0\"]\n        eta_s = self._isotropic_eta_s(params[\"V_0\"] / volume, params)\n\n        E_th_diff = params[\"Cv\"] * (temperature - params[\"T_0\"])\n        return (\n            bm.shear_modulus_third_order(volume, params) - eta_s * (E_th_diff) / volume\n        )",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume. :math:`[J/K/mol]`\n        \"\"\"\n        return params[\"Cv\"]",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure. :math:`[J/K/mol]`\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        C_p = C_v * (1.0 + gr * alpha * temperature)\n        return C_p",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity. :math:`[1/K]`\n        \"\"\"\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        alpha = gr * C_v / K / volume\n        return alpha",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        G = (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + pressure * volume\n        )\n        return G",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        return self.helmholtz_free_energy(\n            pressure, temperature, volume, params\n        ) + temperature * self.entropy(pressure, temperature, volume, params)",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy at the pressure and temperature of the mineral [J/K/mol]\n        \"\"\"\n        S_0 = params[\"S_0\"]\n        gruen_0 = params[\"grueneisen_0\"]\n        q_0 = params[\"q_0\"]\n        S_th = params[\"Cv\"] * (\n            np.log(temperature / params[\"T_0\"])\n            + _intgroverVdV(params[\"V_0\"], volume, gruen_0, q_0)\n        )\n\n        return S_0 + S_th",
  "def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n\n        return (\n            self.helmholtz_free_energy(pressure, temperature, volume, params)\n            + temperature * self.entropy(pressure, temperature, volume, params)\n            + pressure * volume\n        )",
  "def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]\n        \"\"\"\n        V_0 = params[\"V_0\"]\n        gruen_0 = params[\"grueneisen_0\"]\n        q_0 = params[\"q_0\"]\n        x = V_0 / volume\n        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)\n        b_iikk = 9.0 * params[\"K_0\"]  # EQ 28\n        b_iikkmm = 27.0 * params[\"K_0\"] * (params[\"Kprime_0\"] - 4.0)  # EQ 29\n\n        T_0 = params[\"T_0\"]\n        T = temperature\n        S_0 = params[\"S_0\"]\n        Cv = params[\"Cv\"]\n        F_0 = params[\"E_0\"] - T_0 * S_0\n        F_cmp = 0.5 * b_iikk * f * f * V_0 + (1.0 / 6.0) * V_0 * b_iikkmm * f * f * f\n        F_th = (\n            -S_0 * (T - T_0)\n            - Cv * (T * np.log(T / T_0) - (T - T_0))\n            - Cv * (T - T_0) * _intgroverVdV(V_0, volume, gruen_0, q_0)\n        )\n\n        return F_0 + F_cmp + F_th",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 300.0\n\n        # If eta_s_0 is not included this is presumably deliberate,\n        # as we can model density and bulk modulus just fine without it,\n        # so just add it to the dictionary as nan\n        # The same goes for the standard state Helmholtz free energy\n        if \"eta_s_0\" not in params:\n            params[\"eta_s_0\"] = float(\"nan\")\n        if \"E_0\" not in params:\n            params[\"E_0\"] = float(\"nan\")\n\n        # First, let's check the EoS parameters for Tref\n        bm.BirchMurnaghanBase.validate_parameters(bm.BirchMurnaghanBase(), params)\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"Cv\", \"grueneisen_0\", \"q_0\", \"eta_s_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"Cv\"] < 0.0 or params[\"Cv\"] > 1000.0:\n            warnings.warn(\"Unusual value for Cv\", stacklevel=2)\n        if params[\"grueneisen_0\"] < -0.005 or params[\"grueneisen_0\"] > 10.0:\n            warnings.warn(\"Unusual value for grueneisen_0\", stacklevel=2)\n        if params[\"q_0\"] < -10.0 or params[\"q_0\"] > 10.0:\n            warnings.warn(\"Unusual value for q_0\", stacklevel=2)\n        if params[\"eta_s_0\"] < -10.0 or params[\"eta_s_0\"] > 10.0:\n            warnings.warn(\"Unusual value for eta_s_0\", stacklevel=2)",
  "def jit(fn):\n        return fn",
  "class EquationOfState(object):\n\n    \"\"\"\n    This class defines the interface for an equation of state\n    that a mineral uses to determine its properties at a\n    given :math:`P, T`.  In order define a new equation of state, you\n    should define these functions.\n\n    All functions should accept and return values in SI units.\n\n    In general these functions are functions of pressure,\n    temperature, and volume, as well as a \"params\" object,\n    which is a Python dictionary that stores the material\n    parameters of the mineral, such as reference volume,\n    Debye temperature, reference moduli, etc.\n\n    The functions for volume and density are just functions\n    of temperature, pressure, and \"params\"; after all, it\n    does not make sense for them to be functions of volume or density.\n    \"\"\"\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Molar volume of the mineral :math:`[m^3]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Pressure of the mineral, including cold and thermal parts\n            :math:`[m^3]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def density(self, volume, params):\n        \"\"\"\n        Calculate the density of the mineral :math:`[kg/m^3]`.\n        The params object must include a \"molar_mass\" field.\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Density of the mineral. :math:`[kg/m^3]`\n        :rtype: float\n        \"\"\"\n        return params[\"molar_mass\"] / volume\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Grueneisen parameter of the mineral. :math:`[unitless]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Isothermal bulk modulus of the mineral. :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Adiabatic bulk modulus of the mineral. :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Shear modulus of the mineral. :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Heat capacity at constant volume of the mineral. :math:`[J/K/mol]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Heat capacity at constant pressure of the mineral. :math:`[J/K/mol]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Thermal expansivity of the mineral. :math:`[1/K]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Gibbs energy of the mineral :math:`[J/mol]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Helmholtz energy of the mineral :math:`[J/mol]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Entropy of the mineral :math:`[J/K/mol]`.\n        :rtype: float\n        \"\"\"\n\n        raise NotImplementedError(\"\")\n\n    def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Enthalpy of the mineral :math:`[J/mol]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Internal energy of the mineral :math:`[J/mol]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    def validate_parameters(self, params):\n        \"\"\"\n        The params object is just a dictionary associating mineral physics parameters\n        for the equation of state.\n        Different equation of states can have different parameters,\n        and the parameters may have ranges of validity.  The intent of this function is\n        twofold. First, it can check for the existence of the parameters that the\n        equation of state needs, and second, it can check whether the parameters\n        have reasonable values.  Unreasonable values will frequently be due\n        to unit issues (e.g., supplying bulk moduli in GPa instead of Pa).\n        In the base class this function does nothing, and an equation of state\n        is not required to implement it.  This function will\n        not return anything, though it may raise warnings or errors.\n\n        :param params: Dictionary containing material parameters required by the\n            equation of state.\n        :type params: dict\n        \"\"\"\n        pass",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Molar volume of the mineral :math:`[m^3]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Pressure of the mineral, including cold and thermal parts\n            :math:`[m^3]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def density(self, volume, params):\n        \"\"\"\n        Calculate the density of the mineral :math:`[kg/m^3]`.\n        The params object must include a \"molar_mass\" field.\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Density of the mineral. :math:`[kg/m^3]`\n        :rtype: float\n        \"\"\"\n        return params[\"molar_mass\"] / volume",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Grueneisen parameter of the mineral. :math:`[unitless]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Isothermal bulk modulus of the mineral. :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Adiabatic bulk modulus of the mineral. :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Shear modulus of the mineral. :math:`[Pa]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Heat capacity at constant volume of the mineral. :math:`[J/K/mol]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Heat capacity at constant pressure of the mineral. :math:`[J/K/mol]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Thermal expansivity of the mineral. :math:`[1/K]`\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Gibbs energy of the mineral :math:`[J/mol]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Helmholtz energy of the mineral :math:`[J/mol]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Entropy of the mineral :math:`[J/K/mol]`.\n        :rtype: float\n        \"\"\"\n\n        raise NotImplementedError(\"\")",
  "def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Enthalpy of the mineral :math:`[J/mol]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        :param pressure: Pressure at which to evaluate the equation of state\n            :math:`[Pa]`.\n        :type pressure: float\n\n        :param temperature: Temperature at which to evaluate the equation of state\n            :math:`[K]`.\n        :type temperature: float\n\n        :param volume: Molar volume of the mineral. For consistency this should be\n            calculated using :func:`volume` :math:`[m^3]`.\n        :type volume: float\n\n        :param params: Dictionary containing material parameters required by\n            the equation of state.\n        :type params: dict\n\n        :returns: Internal energy of the mineral :math:`[J/mol]`.\n        :rtype: float\n        \"\"\"\n        raise NotImplementedError(\"\")",
  "def validate_parameters(self, params):\n        \"\"\"\n        The params object is just a dictionary associating mineral physics parameters\n        for the equation of state.\n        Different equation of states can have different parameters,\n        and the parameters may have ranges of validity.  The intent of this function is\n        twofold. First, it can check for the existence of the parameters that the\n        equation of state needs, and second, it can check whether the parameters\n        have reasonable values.  Unreasonable values will frequently be due\n        to unit issues (e.g., supplying bulk moduli in GPa instead of Pa).\n        In the base class this function does nothing, and an equation of state\n        is not required to implement it.  This function will\n        not return anything, though it may raise warnings or errors.\n\n        :param params: Dictionary containing material parameters required by the\n            equation of state.\n        :type params: dict\n        \"\"\"\n        pass",
  "def tait_constants(params):\n    \"\"\"\n    returns parameters for the modified Tait equation of state\n    derived from K_T and its two first pressure derivatives\n    EQ 4 from Holland and Powell, 2011\n    \"\"\"\n    a = (1.0 + params[\"Kprime_0\"]) / (\n        1.0 + params[\"Kprime_0\"] + params[\"K_0\"] * params[\"Kdprime_0\"]\n    )\n    b = params[\"Kprime_0\"] / params[\"K_0\"] - params[\"Kdprime_0\"] / (\n        1.0 + params[\"Kprime_0\"]\n    )\n    c = (1.0 + params[\"Kprime_0\"] + params[\"K_0\"] * params[\"Kdprime_0\"]) / (\n        params[\"Kprime_0\"] * params[\"Kprime_0\"]\n        + params[\"Kprime_0\"]\n        - params[\"K_0\"] * params[\"Kdprime_0\"]\n    )\n    return a, b, c",
  "def modified_tait(x, params):\n    \"\"\"\n    equation for the modified Tait equation of state, returns\n    pressure in the same units that are supplied for the reference bulk\n    modulus (params['K_0'])\n    EQ 2 from Holland and Powell, 2011\n    \"\"\"\n    a, b, c = tait_constants(params)\n    return (np.power((x + a - 1.0) / a, -1.0 / c) - 1.0) / b + params[\"P_0\"]",
  "def volume(pressure, params):\n    \"\"\"\n    Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n    EQ 12\n    \"\"\"\n    a, b, c = tait_constants(params)\n    x = 1 - a * (1.0 - np.power((1.0 + b * (pressure - params[\"P_0\"])), -1.0 * c))\n    return x * params[\"V_0\"]",
  "def bulk_modulus(pressure, params):\n    \"\"\"\n    Returns isothermal bulk modulus :math:`K_T` of the mineral. :math:`[Pa]`.\n    EQ 13+2\n    \"\"\"\n    a, b, c = tait_constants(params)\n    return (\n        params[\"K_0\"]\n        * (1.0 + b * (pressure - params[\"P_0\"]))\n        * (a + (1.0 - a) * np.power((1.0 + b * (pressure - params[\"P_0\"])), c))\n    )",
  "def intVdP(pressure, params):\n    \"\"\"\n    Returns the integral of VdP for the mineral. :math:`[J]`.\n    EQ 13\n    \"\"\"\n    a, b, c = tait_constants(params)\n    psubpth = pressure - params[\"P_0\"]\n\n    if pressure != params[\"P_0\"]:\n        intVdP = (\n            (pressure - params[\"P_0\"])\n            * params[\"V_0\"]\n            * (\n                1.0\n                - a\n                + (\n                    a\n                    * (1.0 - np.power((1.0 + b * (psubpth)), 1.0 - c))\n                    / (b * (c - 1.0) * (pressure - params[\"P_0\"]))\n                )\n            )\n        )\n    else:\n        intVdP = 0.0\n    return intVdP",
  "class MT(eos.EquationOfState):\n\n    \"\"\"\n    Base class for the generic modified Tait equation of state.\n    References for this can be found in :cite:`HC1974`\n    and :cite:`HP2011` (followed here).\n\n    An instance \"m\" of a Mineral can be assigned this\n    equation of state with the command m.set_method('mt')\n    (or by initialising the class with the param\n    equation_of_state = 'mt').\n    \"\"\"\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume(pressure, params)\n\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        \"\"\"\n        return modified_tait(params[\"V_0\"] / volume, params)\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(pressure, params)\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[Pa]`\n        \"\"\"\n        return 1.0e99\n\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Not implemented in the Modified Tait EoS. :math:`[Pa]`\n        Returns 0.\n        Could potentially apply a fixed Poissons ratio as a rough estimate.\n        \"\"\"\n        return 0.0\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0\n\n    def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n\n        return (\n            self.gibbs_free_energy(pressure, temperature, volume, params)\n            - volume * pressure\n        )\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # G = int VdP = [PV] - int PdV = E + PV\n        a, b, c = tait_constants(params)\n\n        intVdP = params[\"V_0\"] * (\n            a\n            / (b * (1.0 - c))\n            * (np.power(b * (pressure - params[\"P_0\"]) + 1.0, 1.0 - c) - 1.0)\n            + (1.0 - a) * (pressure - params[\"P_0\"])\n        )\n\n        return intVdP + params[\"E_0\"] + params[\"V_0\"] * params[\"P_0\"]\n\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 1.0e5\n\n        # G and Gprime are not defined in this equation of state,\n        # We can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\", \"Kdprime_0\", \"G_0\", \"Gprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-2:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 40.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)\n        if params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.\n        \"\"\"\n        return volume(pressure, params)",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        \"\"\"\n        return modified_tait(params[\"V_0\"] / volume, params)",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus :math:`K_T` of the mineral. :math:`[Pa]`.\n        \"\"\"\n        return bulk_modulus(pressure, params)",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[Pa]`\n        \"\"\"\n        return 1.0e99",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Not implemented in the Modified Tait EoS. :math:`[Pa]`\n        Returns 0.\n        Could potentially apply a fixed Poissons ratio as a rough estimate.\n        \"\"\"\n        return 0.0",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the molar entropy :math:`\\mathcal{S}` of the mineral. :math:`[J/K/mol]`\n        \"\"\"\n        return 0.0",
  "def molar_internal_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the internal energy :math:`\\mathcal{E}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n\n        return (\n            self.gibbs_free_energy(pressure, temperature, volume, params)\n            - volume * pressure\n        )",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the Gibbs free energy :math:`\\mathcal{G}` of the mineral. :math:`[J/mol]`\n        \"\"\"\n        # G = int VdP = [PV] - int PdV = E + PV\n        a, b, c = tait_constants(params)\n\n        intVdP = params[\"V_0\"] * (\n            a\n            / (b * (1.0 - c))\n            * (np.power(b * (pressure - params[\"P_0\"]) + 1.0, 1.0 - c) - 1.0)\n            + (1.0 - a) * (pressure - params[\"P_0\"])\n        )\n\n        return intVdP + params[\"E_0\"] + params[\"V_0\"] * params[\"P_0\"]",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`\n        \"\"\"\n        return 1.0e99",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`\n        \"\"\"\n        return 0.0",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`\n        \"\"\"\n        return 0.0",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n\n        if \"E_0\" not in params:\n            params[\"E_0\"] = 0.0\n        if \"P_0\" not in params:\n            params[\"P_0\"] = 1.0e5\n\n        # G and Gprime are not defined in this equation of state,\n        # We can model density and bulk modulus just fine without them,\n        # so just add them to the dictionary as nans\n        if \"G_0\" not in params:\n            params[\"G_0\"] = float(\"nan\")\n        if \"Gprime_0\" not in params:\n            params[\"Gprime_0\"] = float(\"nan\")\n\n        # Check that all the required keys are in the dictionary\n        expected_keys = [\"V_0\", \"K_0\", \"Kprime_0\", \"Kdprime_0\", \"G_0\", \"Gprime_0\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"P_0\"] < 0.0:\n            warnings.warn(\"Unusual value for P_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-2:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n        if params[\"K_0\"] < 1.0e9 or params[\"K_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for K_0\", stacklevel=2)\n        if params[\"Kprime_0\"] < 0.0 or params[\"Kprime_0\"] > 40.0:\n            warnings.warn(\"Unusual value for Kprime_0\", stacklevel=2)\n        if params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13:\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0:\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)",
  "class HP_TMT(eos.EquationOfState):\n\n    \"\"\"\n    Base class for the thermal equation of state based on\n    the generic modified Tait equation of state (class MT),\n    as described in :cite:`HP2011`.\n\n\n    An instance \"m\" of a Mineral can be assigned this\n    equation of state with the command m.set_method('hp_tmt')\n    (or by initialising the class with the param\n    equation_of_state = 'hp_tmt'\n    \"\"\"\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n        EQ 12\n        \"\"\"\n        Pth = self.__relative_thermal_pressure(temperature, params)\n        return mt.volume(pressure - Pth, params)\n\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        EQ B7\n        \"\"\"\n        Pth = self.__relative_thermal_pressure(temperature, params)\n        return mt.modified_tait(params[\"V_0\"] / volume, params) + Pth\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter [unitless] as a function of pressure,\n        temperature, and volume.\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_V = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        return alpha * K_T * volume / C_V\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].  EQ 13+2\n        \"\"\"\n        Pth = self.__relative_thermal_pressure(temperature, params)\n        return mt.bulk_modulus(pressure - Pth, params)\n\n    # calculate the shear modulus as a function of P, V, and T\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Not implemented.\n        Returns 0.\n        Could potentially apply a fixed Poissons ratio as a rough estimate.\n        \"\"\"\n        return 0.0\n\n    # Cv, heat capacity at constant volume\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume at the pressure, temperature,\n        and volume [J/K/mol].\n        \"\"\"\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        V = self.volume(pressure, temperature, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        return C_p - V * temperature * alpha * alpha * K_T\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity at the pressure, temperature,\n        and volume [1/K]. This function replaces -Pth in EQ 13+1\n        with P-Pth for non-ambient temperature\n        \"\"\"\n        a, b, c = mt.tait_constants(params)\n        Pth = self.__relative_thermal_pressure(temperature, params)\n        psubpth = pressure - params[\"P_0\"] - Pth\n\n        C_V0 = einstein.molar_heat_capacity_v(\n            params[\"T_0\"], params[\"T_einstein\"], params[\"n\"]\n        )\n        C_V = einstein.molar_heat_capacity_v(\n            temperature, params[\"T_einstein\"], params[\"n\"]\n        )\n        alpha = (\n            params[\"a_0\"]\n            * (C_V / C_V0)\n            * 1.0\n            / ((1.0 + b * psubpth) * (a + (1.0 - a) * np.power((1 + b * psubpth), c)))\n        )\n        return alpha\n\n    def molar_heat_capacity_p0(self, temperature, params):\n        \"\"\"\n        Returns heat capacity at ambient pressure as a function of temperature\n        [J/K/mol]. Cp = a + bT + cT^-2 + dT^-0.5 in :cite:`HP2011`.\n        \"\"\"\n        Cp = (\n            params[\"Cp\"][0]\n            + params[\"Cp\"][1] * temperature\n            + params[\"Cp\"][2] * np.power(temperature, -2.0)\n            + params[\"Cp\"][3] * np.power(temperature, -0.5)\n        )\n        return Cp\n\n    def molar_heat_capacity_p_einstein(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure at the pressure,\n        temperature, and volume, using the C_v and Einstein model [J/K/mol]\n        WARNING: Only for comparison with internally self-consistent C_p\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        C_p = C_v * (1.0 + gr * alpha * temperature)\n        return C_p\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        K_S = K_T * C_p / C_v\n        return K_S\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the gibbs free energy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        # Calculate temperature and pressure integrals\n        a, b, c = mt.tait_constants(params)\n        Pth = self.__relative_thermal_pressure(temperature, params)\n\n        psubpth = pressure - params[\"P_0\"] - Pth\n\n        # EQ 13\n        if pressure != params[\"P_0\"]:\n            intVdP = (\n                (pressure - params[\"P_0\"])\n                * params[\"V_0\"]\n                * (\n                    1.0\n                    - a\n                    + (\n                        a\n                        * (\n                            np.power((1.0 - b * Pth), 1.0 - c)\n                            - np.power((1.0 + b * (psubpth)), 1.0 - c)\n                        )\n                        / (b * (c - 1.0) * (pressure - params[\"P_0\"]))\n                    )\n                )\n            )\n        else:\n            intVdP = 0.0\n        return (\n            params[\"H_0\"]\n            + self.__intCpdT(temperature, params)\n            - temperature * (params[\"S_0\"] + self.__intCpoverTdT(temperature, params))\n            + intVdP\n        )\n\n    def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        return self.gibbs_free_energy(\n            pressure, temperature, volume, params\n        ) - pressure * self.volume(pressure, temperature, params)\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        a, b, c = mt.tait_constants(params)\n        Pth = self.__relative_thermal_pressure(temperature, params)\n\n        ksi_over_ksi_0 = einstein.molar_heat_capacity_v(\n            temperature, params[\"T_einstein\"], params[\"n\"]\n        ) / einstein.molar_heat_capacity_v(\n            params[\"T_0\"], params[\"T_einstein\"], params[\"n\"]\n        )\n\n        dintVdpdT = (\n            params[\"V_0\"] * params[\"a_0\"] * params[\"K_0\"] * a * ksi_over_ksi_0\n        ) * (\n            np.power((1.0 + b * (pressure - params[\"P_0\"] - Pth)), 0.0 - c)\n            - np.power((1.0 - b * Pth), 0.0 - c)\n        )\n        return params[\"S_0\"] + self.__intCpoverTdT(temperature, params) + dintVdpdT\n\n    def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        gibbs = self.gibbs_free_energy(pressure, temperature, volume, params)\n        entropy = self.entropy(pressure, temperature, volume, params)\n        return gibbs + temperature * entropy\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the heat capacity [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        a, b, c = mt.tait_constants(params)\n        T = temperature\n        T_e = params[\"T_einstein\"]\n        n = params[\"n\"]\n        Pth = self.__relative_thermal_pressure(T, params)\n\n        ksi_over_ksi_0 = einstein.molar_heat_capacity_v(\n            T, T_e, n\n        ) / einstein.molar_heat_capacity_v(params[\"T_0\"], T_e, n)\n\n        dintVdpdT = (\n            params[\"V_0\"] * params[\"a_0\"] * params[\"K_0\"] * a * ksi_over_ksi_0\n        ) * (\n            np.power((1.0 + b * (pressure - params[\"P_0\"] - Pth)), 0.0 - c)\n            - np.power((1.0 - b * Pth), 0.0 - c)\n        )\n\n        dSdT0 = (\n            params[\"V_0\"]\n            * params[\"K_0\"]\n            * np.power((ksi_over_ksi_0 * params[\"a_0\"]), 2.0)\n            * (\n                np.power((1.0 + b * (pressure - params[\"P_0\"] - Pth)), -1.0 - c)\n                - np.power((1.0 + b * (-Pth)), -1.0 - c)\n            )\n        )\n\n        x = T_e / T\n        dCv_einstdT = -(\n            einstein.molar_heat_capacity_v(T, T_e, n)\n            * (1 - 2.0 / x + 2.0 / (np.exp(x) - 1.0))\n            * x\n            / T\n        )\n\n        dSdT1 = -dintVdpdT * dCv_einstdT / einstein.molar_heat_capacity_v(T, T_e, n)\n\n        dSdT = dSdT0 + dSdT1\n        return self.molar_heat_capacity_p0(temperature, params) + temperature * dSdT\n\n    def __thermal_pressure(self, T, params):\n        \"\"\"\n        Returns thermal pressure [Pa] as a function of T [K]\n        EQ 12 - 1 of :cite:`HP2011`.\n        \"\"\"\n\n        # This is basically the mie-gruneisen equation of state for thermal\n        # pressure using an Einstein model for heat capacity.  The additional\n        # assumption that they make is that alpha*K/Cv, (or gamma / V) is\n        # constant over a wide range of compressions.\n\n        # Note that the xi function in HP2011 is just the Einstein heat capacity\n        # divided by 3nR. This function is *not* used to calculate the\n        # heat capacity - Holland and Powell (2011) prefer the additional\n        # freedom provided by their polynomial expression.\n\n        E_th = einstein.thermal_energy(T, params[\"T_einstein\"], params[\"n\"])\n        C_V0 = einstein.molar_heat_capacity_v(\n            params[\"T_0\"], params[\"T_einstein\"], params[\"n\"]\n        )\n        P_th = params[\"a_0\"] * params[\"K_0\"] / C_V0 * E_th\n        return P_th\n\n    def __relative_thermal_pressure(self, T, params):\n        \"\"\"\n        Returns relative thermal pressure [Pa] as a function of T-params['T_0'] [K]\n        EQ 12 - 1 of :cite:`HP2011`.\n        \"\"\"\n        return self.__thermal_pressure(T, params) - self.__thermal_pressure(\n            params[\"T_0\"], params\n        )\n\n    def __intCpdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state enthalpy [J/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * temperature\n            + 0.5 * params[\"Cp\"][1] * np.power(temperature, 2.0)\n            - params[\"Cp\"][2] / temperature\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * params[\"T_0\"]\n            + 0.5 * params[\"Cp\"][1] * params[\"T_0\"] * params[\"T_0\"]\n            - params[\"Cp\"][2] / params[\"T_0\"]\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(params[\"T_0\"])\n        )\n\n    def __intCpoverTdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state entropy [J/K/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * np.log(temperature)\n            + params[\"Cp\"][1] * temperature\n            - 0.5 * params[\"Cp\"][2] / np.power(temperature, 2.0)\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * np.log(params[\"T_0\"])\n            + params[\"Cp\"][1] * params[\"T_0\"]\n            - 0.5 * params[\"Cp\"][2] / (params[\"T_0\"] * params[\"T_0\"])\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(params[\"T_0\"])\n        )\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 298.15\n\n        # If standard state enthalpy and entropy are not included\n        # this is presumably deliberate, as we can model density\n        # and bulk modulus just fine without them.\n        # Just add them to the dictionary as nans.\n        if \"H_0\" not in params:\n            params[\"H_0\"] = float(\"nan\")\n        if \"S_0\" not in params:\n            params[\"S_0\"] = float(\"nan\")\n\n        # First, let's check the EoS parameters for Tref\n        mt.MT.validate_parameters(mt.MT(), params)\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"H_0\", \"S_0\", \"V_0\", \"Cp\", \"a_0\", \"n\", \"molar_mass\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # The following line estimates the Einstein temperature\n        # according to the empirical equation of\n        # Holland and Powell, 2011; base of p.346, para.1\n        if \"T_einstein\" not in params:\n            params[\"T_einstein\"] = 10636.0 / (params[\"S_0\"] / params[\"n\"] + 6.44)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"G_0\"] is not float(\"nan\") and (\n            params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13\n        ):\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] is not float(\"nan\") and (\n            params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0\n        ):\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)\n\n        # no test for H_0\n        if params[\"S_0\"] is not float(\"nan\") and params[\"S_0\"] < 0.0:\n            warnings.warn(\"Unusual value for S_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-2:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n\n        if self.molar_heat_capacity_p0(params[\"T_0\"], params) < 0.0:\n            warnings.warn(\"Negative heat capacity at T_0\", stacklevel=2)\n        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:\n            warnings.warn(\"Negative heat capacity at 2000K\", stacklevel=2)\n\n        if params[\"a_0\"] < 0.0 or params[\"a_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for a_0\", stacklevel=2)\n\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 10.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)",
  "class HP_TMTL(eos.EquationOfState):\n\n    \"\"\"\n    Base class for the thermal equation of state\n    described in :cite:`HP1998`, but with the Modified Tait as the static part,\n    as described in :cite:`HP2011`.\n\n    An instance \"m\" of a Mineral can be assigned this\n    equation of state with the command m.set_method('hp_tmtL')\n    (or by initialising the class with the param\n    equation_of_state = 'hp_tmtL'\n    \"\"\"\n\n    def _V_T_1bar(self, temperature, params):\n        # Constant thermal expansivity at standard state pressure\n        # (p.348 of HP2011)\n        return params[\"V_0\"] * np.exp(params[\"a_0\"] * (temperature - params[\"T_0\"]))\n\n    def _K_T_1bar(self, temperature, params):\n        # Linear bulk modulus dependence as in HP1998 (p.348 of HP2011)\n        return params[\"K_0\"] + params[\"dKdT_0\"] * (temperature - params[\"T_0\"])\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n        \"\"\"\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature, params)\n        return mt.volume(pressure, self.static_params)\n\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        \"\"\"\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature, params)\n        return mt.pressure(volume, self.static_params)\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter [unitless] as a function of pressure,\n        temperature, and volume.\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_V = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        return alpha * K_T * volume / C_V\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature, params)\n        return mt.bulk_modulus(pressure, self.static_params)\n\n    # calculate the shear modulus as a function of P, V, and T\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Not implemented.\n        Returns 0.\n        Could potentially apply a fixed Poissons ratio as a rough estimate.\n        \"\"\"\n        return 0.0\n\n    # Cv, heat capacity at constant volume\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume at the pressure, temperature,\n        and volume [J/K/mol].\n        \"\"\"\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        V = self.volume(pressure, temperature, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        return C_p - V * temperature * alpha * alpha * K_T\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity at the pressure, temperature,\n        and volume [1/K]\n        \"\"\"\n        # The derivation of the high pressure thermal expansivity is tedious,\n        # so here we take a numerical derivative.\n        # TODO Derive and use the analytical derivative.\n        dT = 0.1\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature + dT / 2.0, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature + dT / 2.0, params)\n        volume1 = mt.volume(pressure, self.static_params)\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature - dT / 2.0, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature - dT / 2.0, params)\n        volume0 = mt.volume(pressure, self.static_params)\n\n        return 2.0 * (volume1 - volume0) / (volume1 + volume0) / dT\n\n    def molar_heat_capacity_p0(self, temperature, params):\n        \"\"\"\n        Returns heat capacity at ambient pressure as a function of temperature\n        [J/K/mol]\n        Cp = a + bT + cT^-2 + dT^-0.5 in :cite:`HP1998`.\n        \"\"\"\n        Cp = (\n            params[\"Cp\"][0]\n            + params[\"Cp\"][1] * temperature\n            + params[\"Cp\"][2] * np.power(temperature, -2.0)\n            + params[\"Cp\"][3] * np.power(temperature, -0.5)\n        )\n        return Cp\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        K_S = K_T * C_p / C_v\n        return K_S\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the gibbs free energy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature, params)\n        return (\n            params[\"H_0\"]\n            + self.__intCpdT(temperature, params)\n            - temperature * (params[\"S_0\"] + self.__intCpoverTdT(temperature, params))\n            + mt.intVdP(pressure, self.static_params)\n        )\n\n    def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        return self.gibbs_free_energy(\n            pressure, temperature, volume, params\n        ) - pressure * self.volume(pressure, temperature, params)\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        # The derivation of the entropy is tedious,\n        # so here we take a numerical derivative.\n        # TODO Derive and use the analytical derivative.\n        dT = 0.1\n        G1 = self.gibbs_free_energy(pressure, temperature + dT / 2.0, volume, params)\n        G0 = self.gibbs_free_energy(pressure, temperature - dT / 2.0, volume, params)\n\n        return (G0 - G1) / dT\n\n    def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        gibbs = self.gibbs_free_energy(pressure, temperature, volume, params)\n        entropy = self.entropy(pressure, temperature, volume, params)\n        return gibbs + temperature * entropy\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the heat capacity [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        # The differentiation is tedious, so for now we just take the\n        # numerical derivative of S\n        # TODO Derive and use the analytical derivative.\n        dT = 0.1\n        S1 = self.entropy(pressure, temperature + dT / 2.0, volume, params)\n        S0 = self.entropy(pressure, temperature - dT / 2.0, volume, params)\n        return temperature * (S1 - S0) / dT\n\n    def __intCpdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state enthalpy [J/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * temperature\n            + 0.5 * params[\"Cp\"][1] * np.power(temperature, 2.0)\n            - params[\"Cp\"][2] / temperature\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * params[\"T_0\"]\n            + 0.5 * params[\"Cp\"][1] * params[\"T_0\"] * params[\"T_0\"]\n            - params[\"Cp\"][2] / params[\"T_0\"]\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(params[\"T_0\"])\n        )\n\n    def __intCpoverTdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state entropy [J/K/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * np.log(temperature)\n            + params[\"Cp\"][1] * temperature\n            - 0.5 * params[\"Cp\"][2] / np.power(temperature, 2.0)\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * np.log(params[\"T_0\"])\n            + params[\"Cp\"][1] * params[\"T_0\"]\n            - 0.5 * params[\"Cp\"][2] / (params[\"T_0\"] * params[\"T_0\"])\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(params[\"T_0\"])\n        )\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 298.15\n\n        # If standard state enthalpy and entropy are not included\n        # this is presumably deliberate, as we can model density\n        # and bulk modulus just fine without them.\n        # Just add them to the dictionary as nans.\n        if \"H_0\" not in params:\n            params[\"H_0\"] = float(\"nan\")\n        if \"S_0\" not in params:\n            params[\"S_0\"] = float(\"nan\")\n\n        # First, let's check the EoS parameters for Tref\n        mt.MT.validate_parameters(mt.MT(), params)\n        self.static_params = {\n            \"V_0\": params[\"V_0\"],\n            \"K_0\": params[\"K_0\"],\n            \"Kprime_0\": params[\"Kprime_0\"],\n            \"Kdprime_0\": params[\"Kdprime_0\"],\n            \"P_0\": params[\"P_0\"],\n        }\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"H_0\", \"S_0\", \"V_0\", \"Cp\", \"a_0\", \"dKdT_0\", \"n\", \"molar_mass\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"G_0\"] is not float(\"nan\") and (\n            params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13\n        ):\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] is not float(\"nan\") and (\n            params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0\n        ):\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)\n\n        # no test for H_0 or S_0 (several HP endmembers have S_0 < 0)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-2:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n\n        if self.molar_heat_capacity_p0(params[\"T_0\"], params) < 0.0:\n            warnings.warn(\"Negative heat capacity at T_0\", stacklevel=2)\n        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:\n            warnings.warn(\"Negative heat capacity at 2000K\", stacklevel=2)\n\n        if params[\"a_0\"] < 0.0 or params[\"a_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for a_0\", stacklevel=2)\n\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 10.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)",
  "class HP98(eos.EquationOfState):\n\n    \"\"\"\n    Base class for the thermal equation of state\n    described in :cite:`HP1998`.\n\n    An instance \"m\" of a Mineral can be assigned this\n    equation of state with the command m.set_method('hp98')\n    (or by initialising the class with the param\n    equation_of_state = 'hp98'\n    \"\"\"\n\n    def _V_T_1bar(self, temperature, params):\n        return params[\"V_0\"] * (\n            1.0\n            + params[\"a_0\"] * (temperature - params[\"T_0\"])\n            - 20.0 * params[\"a_0\"] * (np.sqrt(temperature) - np.sqrt(params[\"T_0\"]))\n        )\n\n    def _K_T_1bar(self, temperature, params):\n        return params[\"K_0\"] + params[\"dKdT_0\"] * (temperature - params[\"T_0\"])\n\n    def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n        \"\"\"\n        return murn.volume(\n            pressure,\n            self._V_T_1bar(temperature, params),\n            self._K_T_1bar(temperature, params),\n            params[\"Kprime_0\"],\n        )\n\n    def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        \"\"\"\n        return murn.pressure(\n            volume,\n            self._V_T_1bar(temperature, params),\n            self._K_T_1bar(temperature, params),\n            params[\"Kprime_0\"],\n        )\n\n    def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter [unitless] as a function of pressure,\n        temperature, and volume.\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_V = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        return alpha * K_T * volume / C_V\n\n    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        return murn.bulk_modulus(\n            pressure, self._K_T_1bar(temperature, params), params[\"Kprime_0\"]\n        )\n\n    # calculate the shear modulus as a function of P, V, and T\n    def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Not implemented.\n        Returns 0.\n        Could potentially apply a fixed Poissons ratio as a rough estimate.\n        \"\"\"\n        return 0.0\n\n    # Cv, heat capacity at constant volume\n    def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume at the pressure, temperature,\n        and volume [J/K/mol].\n        \"\"\"\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        V = self.volume(pressure, temperature, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        return C_p - V * temperature * alpha * alpha * K_T\n\n    def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity at the pressure, temperature,\n        and volume [1/K]\n        \"\"\"\n        VT = self._V_T_1bar(temperature, params)\n        KT = self._K_T_1bar(temperature, params)\n        volume = murn.volume(pressure, VT, KT, params[\"Kprime_0\"])\n        dVTdT = params[\"V_0\"] * params[\"a_0\"] * (1.0 - 10.0 / np.sqrt(temperature))\n        g = volume / VT\n        dgdKT = (\n            pressure\n            * np.power(\n                1.0 + pressure * params[\"Kprime_0\"] / KT, -1 - 1.0 / params[\"Kprime_0\"]\n            )\n            / (KT * KT)\n        )\n        dVdT = dVTdT * g + VT * dgdKT * params[\"dKdT_0\"]\n        return dVdT / volume\n\n    def molar_heat_capacity_p0(self, temperature, params):\n        \"\"\"\n        Returns heat capacity at ambient pressure as a function of temperature\n        [J/K/mol]\n        Cp = a + bT + cT^-2 + dT^-0.5 in :cite:`HP1998`.\n        \"\"\"\n        Cp = (\n            params[\"Cp\"][0]\n            + params[\"Cp\"][1] * temperature\n            + params[\"Cp\"][2] * np.power(temperature, -2.0)\n            + params[\"Cp\"][3] * np.power(temperature, -0.5)\n        )\n        return Cp\n\n    def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        K_S = K_T * C_p / C_v\n        return K_S\n\n    def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the gibbs free energy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        return (\n            params[\"H_0\"]\n            + self.__intCpdT(temperature, params)\n            - temperature * (params[\"S_0\"] + self.__intCpoverTdT(temperature, params))\n            + murn.intVdP(\n                pressure,\n                self._V_T_1bar(temperature, params),\n                self._K_T_1bar(temperature, params),\n                params[\"Kprime_0\"],\n            )\n        )\n\n    def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        return self.gibbs_free_energy(\n            pressure, temperature, volume, params\n        ) - pressure * self.volume(pressure, temperature, params)\n\n    def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        # The entropy involves differentiating intdVdp\n        # with respect to temperature.\n        # We do this using the product and chain rules\n\n        VT = self._V_T_1bar(temperature, params)\n        KT = self._K_T_1bar(temperature, params)\n        dVTdT = params[\"V_0\"] * params[\"a_0\"] * (1.0 - 10.0 / np.sqrt(temperature))\n        g = murn.intVdP(pressure, VT, KT, params[\"Kprime_0\"]) / VT\n        dgdKT = (\n            (pressure / KT + 1.0)\n            * np.power(\n                1.0 + pressure * params[\"Kprime_0\"] / KT, -1.0 / params[\"Kprime_0\"]\n            )\n            - 1.0\n        ) / (params[\"Kprime_0\"] - 1.0)\n        dintVdpdT = dVTdT * g + VT * dgdKT * params[\"dKdT_0\"]\n        return params[\"S_0\"] + self.__intCpoverTdT(temperature, params) - dintVdpdT\n\n    def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        gibbs = self.gibbs_free_energy(pressure, temperature, volume, params)\n        entropy = self.entropy(pressure, temperature, volume, params)\n        return gibbs + temperature * entropy\n\n    def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the heat capacity [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        # The differentiation is tedious, so for now we just take the\n        # numerical derivative of S\n        # TODO calculate the analytical derivative\n        dT = 0.1\n        S1 = self.entropy(pressure, temperature + dT / 2.0, volume, params)\n        S0 = self.entropy(pressure, temperature - dT / 2.0, volume, params)\n        return temperature * (S1 - S0) / dT\n\n    def __intCpdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state enthalpy [J/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * temperature\n            + 0.5 * params[\"Cp\"][1] * np.power(temperature, 2.0)\n            - params[\"Cp\"][2] / temperature\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * params[\"T_0\"]\n            + 0.5 * params[\"Cp\"][1] * params[\"T_0\"] * params[\"T_0\"]\n            - params[\"Cp\"][2] / params[\"T_0\"]\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(params[\"T_0\"])\n        )\n\n    def __intCpoverTdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state entropy [J/K/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * np.log(temperature)\n            + params[\"Cp\"][1] * temperature\n            - 0.5 * params[\"Cp\"][2] / np.power(temperature, 2.0)\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * np.log(params[\"T_0\"])\n            + params[\"Cp\"][1] * params[\"T_0\"]\n            - 0.5 * params[\"Cp\"][2] / (params[\"T_0\"] * params[\"T_0\"])\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(params[\"T_0\"])\n        )\n\n    def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 298.15\n\n        # If standard state enthalpy and entropy are not included\n        # this is presumably deliberate, as we can model density\n        # and bulk modulus just fine without them.\n        # Just add them to the dictionary as nans.\n        if \"H_0\" not in params:\n            params[\"H_0\"] = float(\"nan\")\n        if \"S_0\" not in params:\n            params[\"S_0\"] = float(\"nan\")\n\n        # First, let's check the EoS parameters for Tref\n        murn.Murnaghan.validate_parameters(murn.Murnaghan(), params)\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"H_0\", \"S_0\", \"V_0\", \"Cp\", \"a_0\", \"dKdT_0\", \"n\", \"molar_mass\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"G_0\"] is not float(\"nan\") and (\n            params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13\n        ):\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] is not float(\"nan\") and (\n            params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0\n        ):\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)\n\n        # no test for H_0 or S_0 (several HP endmembers have S_0 < 0)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-2:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n\n        if self.molar_heat_capacity_p0(params[\"T_0\"], params) < 0.0:\n            warnings.warn(\"Negative heat capacity at T_0\", stacklevel=2)\n        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:\n            warnings.warn(\"Negative heat capacity at 2000K\", stacklevel=2)\n\n        if params[\"a_0\"] < 0.0 or params[\"a_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for a_0\", stacklevel=2)\n\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 10.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n        EQ 12\n        \"\"\"\n        Pth = self.__relative_thermal_pressure(temperature, params)\n        return mt.volume(pressure - Pth, params)",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        EQ B7\n        \"\"\"\n        Pth = self.__relative_thermal_pressure(temperature, params)\n        return mt.modified_tait(params[\"V_0\"] / volume, params) + Pth",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter [unitless] as a function of pressure,\n        temperature, and volume.\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_V = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        return alpha * K_T * volume / C_V",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].  EQ 13+2\n        \"\"\"\n        Pth = self.__relative_thermal_pressure(temperature, params)\n        return mt.bulk_modulus(pressure - Pth, params)",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Not implemented.\n        Returns 0.\n        Could potentially apply a fixed Poissons ratio as a rough estimate.\n        \"\"\"\n        return 0.0",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume at the pressure, temperature,\n        and volume [J/K/mol].\n        \"\"\"\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        V = self.volume(pressure, temperature, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        return C_p - V * temperature * alpha * alpha * K_T",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity at the pressure, temperature,\n        and volume [1/K]. This function replaces -Pth in EQ 13+1\n        with P-Pth for non-ambient temperature\n        \"\"\"\n        a, b, c = mt.tait_constants(params)\n        Pth = self.__relative_thermal_pressure(temperature, params)\n        psubpth = pressure - params[\"P_0\"] - Pth\n\n        C_V0 = einstein.molar_heat_capacity_v(\n            params[\"T_0\"], params[\"T_einstein\"], params[\"n\"]\n        )\n        C_V = einstein.molar_heat_capacity_v(\n            temperature, params[\"T_einstein\"], params[\"n\"]\n        )\n        alpha = (\n            params[\"a_0\"]\n            * (C_V / C_V0)\n            * 1.0\n            / ((1.0 + b * psubpth) * (a + (1.0 - a) * np.power((1 + b * psubpth), c)))\n        )\n        return alpha",
  "def molar_heat_capacity_p0(self, temperature, params):\n        \"\"\"\n        Returns heat capacity at ambient pressure as a function of temperature\n        [J/K/mol]. Cp = a + bT + cT^-2 + dT^-0.5 in :cite:`HP2011`.\n        \"\"\"\n        Cp = (\n            params[\"Cp\"][0]\n            + params[\"Cp\"][1] * temperature\n            + params[\"Cp\"][2] * np.power(temperature, -2.0)\n            + params[\"Cp\"][3] * np.power(temperature, -0.5)\n        )\n        return Cp",
  "def molar_heat_capacity_p_einstein(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant pressure at the pressure,\n        temperature, and volume, using the C_v and Einstein model [J/K/mol]\n        WARNING: Only for comparison with internally self-consistent C_p\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        gr = self.grueneisen_parameter(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        C_p = C_v * (1.0 + gr * alpha * temperature)\n        return C_p",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        K_S = K_T * C_p / C_v\n        return K_S",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the gibbs free energy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        # Calculate temperature and pressure integrals\n        a, b, c = mt.tait_constants(params)\n        Pth = self.__relative_thermal_pressure(temperature, params)\n\n        psubpth = pressure - params[\"P_0\"] - Pth\n\n        # EQ 13\n        if pressure != params[\"P_0\"]:\n            intVdP = (\n                (pressure - params[\"P_0\"])\n                * params[\"V_0\"]\n                * (\n                    1.0\n                    - a\n                    + (\n                        a\n                        * (\n                            np.power((1.0 - b * Pth), 1.0 - c)\n                            - np.power((1.0 + b * (psubpth)), 1.0 - c)\n                        )\n                        / (b * (c - 1.0) * (pressure - params[\"P_0\"]))\n                    )\n                )\n            )\n        else:\n            intVdP = 0.0\n        return (\n            params[\"H_0\"]\n            + self.__intCpdT(temperature, params)\n            - temperature * (params[\"S_0\"] + self.__intCpoverTdT(temperature, params))\n            + intVdP\n        )",
  "def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        return self.gibbs_free_energy(\n            pressure, temperature, volume, params\n        ) - pressure * self.volume(pressure, temperature, params)",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        a, b, c = mt.tait_constants(params)\n        Pth = self.__relative_thermal_pressure(temperature, params)\n\n        ksi_over_ksi_0 = einstein.molar_heat_capacity_v(\n            temperature, params[\"T_einstein\"], params[\"n\"]\n        ) / einstein.molar_heat_capacity_v(\n            params[\"T_0\"], params[\"T_einstein\"], params[\"n\"]\n        )\n\n        dintVdpdT = (\n            params[\"V_0\"] * params[\"a_0\"] * params[\"K_0\"] * a * ksi_over_ksi_0\n        ) * (\n            np.power((1.0 + b * (pressure - params[\"P_0\"] - Pth)), 0.0 - c)\n            - np.power((1.0 - b * Pth), 0.0 - c)\n        )\n        return params[\"S_0\"] + self.__intCpoverTdT(temperature, params) + dintVdpdT",
  "def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        gibbs = self.gibbs_free_energy(pressure, temperature, volume, params)\n        entropy = self.entropy(pressure, temperature, volume, params)\n        return gibbs + temperature * entropy",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the heat capacity [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        a, b, c = mt.tait_constants(params)\n        T = temperature\n        T_e = params[\"T_einstein\"]\n        n = params[\"n\"]\n        Pth = self.__relative_thermal_pressure(T, params)\n\n        ksi_over_ksi_0 = einstein.molar_heat_capacity_v(\n            T, T_e, n\n        ) / einstein.molar_heat_capacity_v(params[\"T_0\"], T_e, n)\n\n        dintVdpdT = (\n            params[\"V_0\"] * params[\"a_0\"] * params[\"K_0\"] * a * ksi_over_ksi_0\n        ) * (\n            np.power((1.0 + b * (pressure - params[\"P_0\"] - Pth)), 0.0 - c)\n            - np.power((1.0 - b * Pth), 0.0 - c)\n        )\n\n        dSdT0 = (\n            params[\"V_0\"]\n            * params[\"K_0\"]\n            * np.power((ksi_over_ksi_0 * params[\"a_0\"]), 2.0)\n            * (\n                np.power((1.0 + b * (pressure - params[\"P_0\"] - Pth)), -1.0 - c)\n                - np.power((1.0 + b * (-Pth)), -1.0 - c)\n            )\n        )\n\n        x = T_e / T\n        dCv_einstdT = -(\n            einstein.molar_heat_capacity_v(T, T_e, n)\n            * (1 - 2.0 / x + 2.0 / (np.exp(x) - 1.0))\n            * x\n            / T\n        )\n\n        dSdT1 = -dintVdpdT * dCv_einstdT / einstein.molar_heat_capacity_v(T, T_e, n)\n\n        dSdT = dSdT0 + dSdT1\n        return self.molar_heat_capacity_p0(temperature, params) + temperature * dSdT",
  "def __thermal_pressure(self, T, params):\n        \"\"\"\n        Returns thermal pressure [Pa] as a function of T [K]\n        EQ 12 - 1 of :cite:`HP2011`.\n        \"\"\"\n\n        # This is basically the mie-gruneisen equation of state for thermal\n        # pressure using an Einstein model for heat capacity.  The additional\n        # assumption that they make is that alpha*K/Cv, (or gamma / V) is\n        # constant over a wide range of compressions.\n\n        # Note that the xi function in HP2011 is just the Einstein heat capacity\n        # divided by 3nR. This function is *not* used to calculate the\n        # heat capacity - Holland and Powell (2011) prefer the additional\n        # freedom provided by their polynomial expression.\n\n        E_th = einstein.thermal_energy(T, params[\"T_einstein\"], params[\"n\"])\n        C_V0 = einstein.molar_heat_capacity_v(\n            params[\"T_0\"], params[\"T_einstein\"], params[\"n\"]\n        )\n        P_th = params[\"a_0\"] * params[\"K_0\"] / C_V0 * E_th\n        return P_th",
  "def __relative_thermal_pressure(self, T, params):\n        \"\"\"\n        Returns relative thermal pressure [Pa] as a function of T-params['T_0'] [K]\n        EQ 12 - 1 of :cite:`HP2011`.\n        \"\"\"\n        return self.__thermal_pressure(T, params) - self.__thermal_pressure(\n            params[\"T_0\"], params\n        )",
  "def __intCpdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state enthalpy [J/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * temperature\n            + 0.5 * params[\"Cp\"][1] * np.power(temperature, 2.0)\n            - params[\"Cp\"][2] / temperature\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * params[\"T_0\"]\n            + 0.5 * params[\"Cp\"][1] * params[\"T_0\"] * params[\"T_0\"]\n            - params[\"Cp\"][2] / params[\"T_0\"]\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(params[\"T_0\"])\n        )",
  "def __intCpoverTdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state entropy [J/K/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * np.log(temperature)\n            + params[\"Cp\"][1] * temperature\n            - 0.5 * params[\"Cp\"][2] / np.power(temperature, 2.0)\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * np.log(params[\"T_0\"])\n            + params[\"Cp\"][1] * params[\"T_0\"]\n            - 0.5 * params[\"Cp\"][2] / (params[\"T_0\"] * params[\"T_0\"])\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(params[\"T_0\"])\n        )",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 298.15\n\n        # If standard state enthalpy and entropy are not included\n        # this is presumably deliberate, as we can model density\n        # and bulk modulus just fine without them.\n        # Just add them to the dictionary as nans.\n        if \"H_0\" not in params:\n            params[\"H_0\"] = float(\"nan\")\n        if \"S_0\" not in params:\n            params[\"S_0\"] = float(\"nan\")\n\n        # First, let's check the EoS parameters for Tref\n        mt.MT.validate_parameters(mt.MT(), params)\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"H_0\", \"S_0\", \"V_0\", \"Cp\", \"a_0\", \"n\", \"molar_mass\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # The following line estimates the Einstein temperature\n        # according to the empirical equation of\n        # Holland and Powell, 2011; base of p.346, para.1\n        if \"T_einstein\" not in params:\n            params[\"T_einstein\"] = 10636.0 / (params[\"S_0\"] / params[\"n\"] + 6.44)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"G_0\"] is not float(\"nan\") and (\n            params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13\n        ):\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] is not float(\"nan\") and (\n            params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0\n        ):\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)\n\n        # no test for H_0\n        if params[\"S_0\"] is not float(\"nan\") and params[\"S_0\"] < 0.0:\n            warnings.warn(\"Unusual value for S_0\", stacklevel=2)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-2:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n\n        if self.molar_heat_capacity_p0(params[\"T_0\"], params) < 0.0:\n            warnings.warn(\"Negative heat capacity at T_0\", stacklevel=2)\n        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:\n            warnings.warn(\"Negative heat capacity at 2000K\", stacklevel=2)\n\n        if params[\"a_0\"] < 0.0 or params[\"a_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for a_0\", stacklevel=2)\n\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 10.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)",
  "def _V_T_1bar(self, temperature, params):\n        # Constant thermal expansivity at standard state pressure\n        # (p.348 of HP2011)\n        return params[\"V_0\"] * np.exp(params[\"a_0\"] * (temperature - params[\"T_0\"]))",
  "def _K_T_1bar(self, temperature, params):\n        # Linear bulk modulus dependence as in HP1998 (p.348 of HP2011)\n        return params[\"K_0\"] + params[\"dKdT_0\"] * (temperature - params[\"T_0\"])",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n        \"\"\"\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature, params)\n        return mt.volume(pressure, self.static_params)",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        \"\"\"\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature, params)\n        return mt.pressure(volume, self.static_params)",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter [unitless] as a function of pressure,\n        temperature, and volume.\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_V = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        return alpha * K_T * volume / C_V",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature, params)\n        return mt.bulk_modulus(pressure, self.static_params)",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Not implemented.\n        Returns 0.\n        Could potentially apply a fixed Poissons ratio as a rough estimate.\n        \"\"\"\n        return 0.0",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume at the pressure, temperature,\n        and volume [J/K/mol].\n        \"\"\"\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        V = self.volume(pressure, temperature, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        return C_p - V * temperature * alpha * alpha * K_T",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity at the pressure, temperature,\n        and volume [1/K]\n        \"\"\"\n        # The derivation of the high pressure thermal expansivity is tedious,\n        # so here we take a numerical derivative.\n        # TODO Derive and use the analytical derivative.\n        dT = 0.1\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature + dT / 2.0, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature + dT / 2.0, params)\n        volume1 = mt.volume(pressure, self.static_params)\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature - dT / 2.0, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature - dT / 2.0, params)\n        volume0 = mt.volume(pressure, self.static_params)\n\n        return 2.0 * (volume1 - volume0) / (volume1 + volume0) / dT",
  "def molar_heat_capacity_p0(self, temperature, params):\n        \"\"\"\n        Returns heat capacity at ambient pressure as a function of temperature\n        [J/K/mol]\n        Cp = a + bT + cT^-2 + dT^-0.5 in :cite:`HP1998`.\n        \"\"\"\n        Cp = (\n            params[\"Cp\"][0]\n            + params[\"Cp\"][1] * temperature\n            + params[\"Cp\"][2] * np.power(temperature, -2.0)\n            + params[\"Cp\"][3] * np.power(temperature, -0.5)\n        )\n        return Cp",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        K_S = K_T * C_p / C_v\n        return K_S",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the gibbs free energy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        self.static_params[\"V_0\"] = self._V_T_1bar(temperature, params)\n        self.static_params[\"K_0\"] = self._K_T_1bar(temperature, params)\n        return (\n            params[\"H_0\"]\n            + self.__intCpdT(temperature, params)\n            - temperature * (params[\"S_0\"] + self.__intCpoverTdT(temperature, params))\n            + mt.intVdP(pressure, self.static_params)\n        )",
  "def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        return self.gibbs_free_energy(\n            pressure, temperature, volume, params\n        ) - pressure * self.volume(pressure, temperature, params)",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        # The derivation of the entropy is tedious,\n        # so here we take a numerical derivative.\n        # TODO Derive and use the analytical derivative.\n        dT = 0.1\n        G1 = self.gibbs_free_energy(pressure, temperature + dT / 2.0, volume, params)\n        G0 = self.gibbs_free_energy(pressure, temperature - dT / 2.0, volume, params)\n\n        return (G0 - G1) / dT",
  "def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        gibbs = self.gibbs_free_energy(pressure, temperature, volume, params)\n        entropy = self.entropy(pressure, temperature, volume, params)\n        return gibbs + temperature * entropy",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the heat capacity [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        # The differentiation is tedious, so for now we just take the\n        # numerical derivative of S\n        # TODO Derive and use the analytical derivative.\n        dT = 0.1\n        S1 = self.entropy(pressure, temperature + dT / 2.0, volume, params)\n        S0 = self.entropy(pressure, temperature - dT / 2.0, volume, params)\n        return temperature * (S1 - S0) / dT",
  "def __intCpdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state enthalpy [J/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * temperature\n            + 0.5 * params[\"Cp\"][1] * np.power(temperature, 2.0)\n            - params[\"Cp\"][2] / temperature\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * params[\"T_0\"]\n            + 0.5 * params[\"Cp\"][1] * params[\"T_0\"] * params[\"T_0\"]\n            - params[\"Cp\"][2] / params[\"T_0\"]\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(params[\"T_0\"])\n        )",
  "def __intCpoverTdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state entropy [J/K/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * np.log(temperature)\n            + params[\"Cp\"][1] * temperature\n            - 0.5 * params[\"Cp\"][2] / np.power(temperature, 2.0)\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * np.log(params[\"T_0\"])\n            + params[\"Cp\"][1] * params[\"T_0\"]\n            - 0.5 * params[\"Cp\"][2] / (params[\"T_0\"] * params[\"T_0\"])\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(params[\"T_0\"])\n        )",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 298.15\n\n        # If standard state enthalpy and entropy are not included\n        # this is presumably deliberate, as we can model density\n        # and bulk modulus just fine without them.\n        # Just add them to the dictionary as nans.\n        if \"H_0\" not in params:\n            params[\"H_0\"] = float(\"nan\")\n        if \"S_0\" not in params:\n            params[\"S_0\"] = float(\"nan\")\n\n        # First, let's check the EoS parameters for Tref\n        mt.MT.validate_parameters(mt.MT(), params)\n        self.static_params = {\n            \"V_0\": params[\"V_0\"],\n            \"K_0\": params[\"K_0\"],\n            \"Kprime_0\": params[\"Kprime_0\"],\n            \"Kdprime_0\": params[\"Kdprime_0\"],\n            \"P_0\": params[\"P_0\"],\n        }\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"H_0\", \"S_0\", \"V_0\", \"Cp\", \"a_0\", \"dKdT_0\", \"n\", \"molar_mass\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"G_0\"] is not float(\"nan\") and (\n            params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13\n        ):\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] is not float(\"nan\") and (\n            params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0\n        ):\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)\n\n        # no test for H_0 or S_0 (several HP endmembers have S_0 < 0)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-2:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n\n        if self.molar_heat_capacity_p0(params[\"T_0\"], params) < 0.0:\n            warnings.warn(\"Negative heat capacity at T_0\", stacklevel=2)\n        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:\n            warnings.warn(\"Negative heat capacity at 2000K\", stacklevel=2)\n\n        if params[\"a_0\"] < 0.0 or params[\"a_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for a_0\", stacklevel=2)\n\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 10.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)",
  "def _V_T_1bar(self, temperature, params):\n        return params[\"V_0\"] * (\n            1.0\n            + params[\"a_0\"] * (temperature - params[\"T_0\"])\n            - 20.0 * params[\"a_0\"] * (np.sqrt(temperature) - np.sqrt(params[\"T_0\"]))\n        )",
  "def _K_T_1bar(self, temperature, params):\n        return params[\"K_0\"] + params[\"dKdT_0\"] * (temperature - params[\"T_0\"])",
  "def volume(self, pressure, temperature, params):\n        \"\"\"\n        Returns volume [m^3] as a function of pressure [Pa] and temperature [K]\n        \"\"\"\n        return murn.volume(\n            pressure,\n            self._V_T_1bar(temperature, params),\n            self._K_T_1bar(temperature, params),\n            params[\"Kprime_0\"],\n        )",
  "def pressure(self, temperature, volume, params):\n        \"\"\"\n        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]\n        \"\"\"\n        return murn.pressure(\n            volume,\n            self._V_T_1bar(temperature, params),\n            self._K_T_1bar(temperature, params),\n            params[\"Kprime_0\"],\n        )",
  "def grueneisen_parameter(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns grueneisen parameter [unitless] as a function of pressure,\n        temperature, and volume.\n        \"\"\"\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_V = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        return alpha * K_T * volume / C_V",
  "def isothermal_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        return murn.bulk_modulus(\n            pressure, self._K_T_1bar(temperature, params), params[\"Kprime_0\"]\n        )",
  "def shear_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Not implemented.\n        Returns 0.\n        Could potentially apply a fixed Poissons ratio as a rough estimate.\n        \"\"\"\n        return 0.0",
  "def molar_heat_capacity_v(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns heat capacity at constant volume at the pressure, temperature,\n        and volume [J/K/mol].\n        \"\"\"\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        V = self.volume(pressure, temperature, params)\n        alpha = self.thermal_expansivity(pressure, temperature, volume, params)\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        return C_p - V * temperature * alpha * alpha * K_T",
  "def thermal_expansivity(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns thermal expansivity at the pressure, temperature,\n        and volume [1/K]\n        \"\"\"\n        VT = self._V_T_1bar(temperature, params)\n        KT = self._K_T_1bar(temperature, params)\n        volume = murn.volume(pressure, VT, KT, params[\"Kprime_0\"])\n        dVTdT = params[\"V_0\"] * params[\"a_0\"] * (1.0 - 10.0 / np.sqrt(temperature))\n        g = volume / VT\n        dgdKT = (\n            pressure\n            * np.power(\n                1.0 + pressure * params[\"Kprime_0\"] / KT, -1 - 1.0 / params[\"Kprime_0\"]\n            )\n            / (KT * KT)\n        )\n        dVdT = dVTdT * g + VT * dgdKT * params[\"dKdT_0\"]\n        return dVdT / volume",
  "def molar_heat_capacity_p0(self, temperature, params):\n        \"\"\"\n        Returns heat capacity at ambient pressure as a function of temperature\n        [J/K/mol]\n        Cp = a + bT + cT^-2 + dT^-0.5 in :cite:`HP1998`.\n        \"\"\"\n        Cp = (\n            params[\"Cp\"][0]\n            + params[\"Cp\"][1] * temperature\n            + params[\"Cp\"][2] * np.power(temperature, -2.0)\n            + params[\"Cp\"][3] * np.power(temperature, -0.5)\n        )\n        return Cp",
  "def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],\n        temperature [K], and volume [m^3].\n        \"\"\"\n        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)\n        C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)\n        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)\n        K_S = K_T * C_p / C_v\n        return K_S",
  "def gibbs_free_energy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the gibbs free energy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        return (\n            params[\"H_0\"]\n            + self.__intCpdT(temperature, params)\n            - temperature * (params[\"S_0\"] + self.__intCpoverTdT(temperature, params))\n            + murn.intVdP(\n                pressure,\n                self._V_T_1bar(temperature, params),\n                self._K_T_1bar(temperature, params),\n                params[\"Kprime_0\"],\n            )\n        )",
  "def helmholtz_free_energy(self, pressure, temperature, volume, params):\n        return self.gibbs_free_energy(\n            pressure, temperature, volume, params\n        ) - pressure * self.volume(pressure, temperature, params)",
  "def entropy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the entropy [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        # The entropy involves differentiating intdVdp\n        # with respect to temperature.\n        # We do this using the product and chain rules\n\n        VT = self._V_T_1bar(temperature, params)\n        KT = self._K_T_1bar(temperature, params)\n        dVTdT = params[\"V_0\"] * params[\"a_0\"] * (1.0 - 10.0 / np.sqrt(temperature))\n        g = murn.intVdP(pressure, VT, KT, params[\"Kprime_0\"]) / VT\n        dgdKT = (\n            (pressure / KT + 1.0)\n            * np.power(\n                1.0 + pressure * params[\"Kprime_0\"] / KT, -1.0 / params[\"Kprime_0\"]\n            )\n            - 1.0\n        ) / (params[\"Kprime_0\"] - 1.0)\n        dintVdpdT = dVTdT * g + VT * dgdKT * params[\"dKdT_0\"]\n        return params[\"S_0\"] + self.__intCpoverTdT(temperature, params) - dintVdpdT",
  "def enthalpy(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the enthalpy [J/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        gibbs = self.gibbs_free_energy(pressure, temperature, volume, params)\n        entropy = self.entropy(pressure, temperature, volume, params)\n        return gibbs + temperature * entropy",
  "def molar_heat_capacity_p(self, pressure, temperature, volume, params):\n        \"\"\"\n        Returns the heat capacity [J/K/mol] as a function of pressure [Pa]\n        and temperature [K].\n        \"\"\"\n        # The differentiation is tedious, so for now we just take the\n        # numerical derivative of S\n        # TODO calculate the analytical derivative\n        dT = 0.1\n        S1 = self.entropy(pressure, temperature + dT / 2.0, volume, params)\n        S0 = self.entropy(pressure, temperature - dT / 2.0, volume, params)\n        return temperature * (S1 - S0) / dT",
  "def __intCpdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state enthalpy [J/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * temperature\n            + 0.5 * params[\"Cp\"][1] * np.power(temperature, 2.0)\n            - params[\"Cp\"][2] / temperature\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * params[\"T_0\"]\n            + 0.5 * params[\"Cp\"][1] * params[\"T_0\"] * params[\"T_0\"]\n            - params[\"Cp\"][2] / params[\"T_0\"]\n            + 2.0 * params[\"Cp\"][3] * np.sqrt(params[\"T_0\"])\n        )",
  "def __intCpoverTdT(self, temperature, params):\n        \"\"\"\n        Returns the thermal addition to the standard state entropy [J/K/mol]\n        at ambient pressure [Pa]\n        \"\"\"\n        return (\n            params[\"Cp\"][0] * np.log(temperature)\n            + params[\"Cp\"][1] * temperature\n            - 0.5 * params[\"Cp\"][2] / np.power(temperature, 2.0)\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(temperature)\n        ) - (\n            params[\"Cp\"][0] * np.log(params[\"T_0\"])\n            + params[\"Cp\"][1] * params[\"T_0\"]\n            - 0.5 * params[\"Cp\"][2] / (params[\"T_0\"] * params[\"T_0\"])\n            - 2.0 * params[\"Cp\"][3] / np.sqrt(params[\"T_0\"])\n        )",
  "def validate_parameters(self, params):\n        \"\"\"\n        Check for existence and validity of the parameters\n        \"\"\"\n        if \"T_0\" not in params:\n            params[\"T_0\"] = 298.15\n\n        # If standard state enthalpy and entropy are not included\n        # this is presumably deliberate, as we can model density\n        # and bulk modulus just fine without them.\n        # Just add them to the dictionary as nans.\n        if \"H_0\" not in params:\n            params[\"H_0\"] = float(\"nan\")\n        if \"S_0\" not in params:\n            params[\"S_0\"] = float(\"nan\")\n\n        # First, let's check the EoS parameters for Tref\n        murn.Murnaghan.validate_parameters(murn.Murnaghan(), params)\n\n        # Now check all the required keys for the\n        # thermal part of the EoS are in the dictionary\n        expected_keys = [\"H_0\", \"S_0\", \"V_0\", \"Cp\", \"a_0\", \"dKdT_0\", \"n\", \"molar_mass\"]\n        for k in expected_keys:\n            if k not in params:\n                raise KeyError(\"params object missing parameter : \" + k)\n\n        # Finally, check that the values are reasonable.\n        if params[\"T_0\"] < 0.0:\n            warnings.warn(\"Unusual value for T_0\", stacklevel=2)\n        if params[\"G_0\"] is not float(\"nan\") and (\n            params[\"G_0\"] < 0.0 or params[\"G_0\"] > 1.0e13\n        ):\n            warnings.warn(\"Unusual value for G_0\", stacklevel=2)\n        if params[\"Gprime_0\"] is not float(\"nan\") and (\n            params[\"Gprime_0\"] < -5.0 or params[\"Gprime_0\"] > 10.0\n        ):\n            warnings.warn(\"Unusual value for Gprime_0\", stacklevel=2)\n\n        # no test for H_0 or S_0 (several HP endmembers have S_0 < 0)\n        if params[\"V_0\"] < 1.0e-7 or params[\"V_0\"] > 1.0e-2:\n            warnings.warn(\"Unusual value for V_0\", stacklevel=2)\n\n        if self.molar_heat_capacity_p0(params[\"T_0\"], params) < 0.0:\n            warnings.warn(\"Negative heat capacity at T_0\", stacklevel=2)\n        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:\n            warnings.warn(\"Negative heat capacity at 2000K\", stacklevel=2)\n\n        if params[\"a_0\"] < 0.0 or params[\"a_0\"] > 1.0e-3:\n            warnings.warn(\"Unusual value for a_0\", stacklevel=2)\n\n        if params[\"n\"] < 1.0 or params[\"n\"] > 1000.0:\n            warnings.warn(\"Unusual value for n\", stacklevel=2)\n        if params[\"molar_mass\"] < 0.001 or params[\"molar_mass\"] > 10.0:\n            warnings.warn(\"Unusual value for molar_mass\", stacklevel=2)",
  "def thermal_energy(T, einstein_T, n):\n    \"\"\"\n    calculate the thermal energy of a substance.  Takes the temperature,\n    the Einstein temperature, and n, the number of atoms per molecule.\n    Returns thermal energy in J/mol\n    \"\"\"\n    if T <= eps:\n        return 0.0\n    x = einstein_T / T\n    E_th = 3.0 * n * constants.gas_constant * einstein_T * (1.0 / (np.exp(x) - 1.0))\n    return E_th",
  "def molar_heat_capacity_v(T, einstein_T, n):\n    \"\"\"\n    Heat capacity at constant volume.  In J/K/mol\n    \"\"\"\n    if T <= eps:\n        return 0.0\n    x = einstein_T / T\n    C_v = (\n        3.0\n        * n\n        * constants.gas_constant\n        * (x * x * np.exp(x) / np.power(np.exp(x) - 1.0, 2.0))\n    )\n    return C_v",
  "def helmholtz_free_energy(T, einstein_T, n):\n    \"\"\"\n    Helmholtz free energy of lattice vibrations in the Einstein model [J].\n    It is important to note that this does NOT include the zero\n    point energy for the lattice.  As long as you are\n    calculating relative differences in F, this should cancel anyway.\n    \"\"\"\n    E = thermal_energy(T, einstein_T, n)\n    S = entropy(T, einstein_T, n)\n    return E - T * S",
  "def entropy(T, einstein_T, n):\n    \"\"\"\n    Entropy due to lattice vibrations in the Einstein model [J/K]\n    \"\"\"\n    if T <= eps:\n        return 0.0\n    x = einstein_T / T\n    S = (\n        3.0\n        * n\n        * constants.gas_constant\n        * (-x * np.exp(-x) / (np.exp(-x) - 1.0) - np.log(1.0 - np.exp(-x)))\n    )\n    return S",
  "def dmolar_heat_capacity_v_dT(T, einstein_T, n):\n    \"\"\"\n    First temperature derivative of the heat capacity at constant volume\n    according to the Einstein model [J/K^2/mol].\n    \"\"\"\n    if T <= eps:\n        return 0.0\n\n    x = einstein_T / T\n    dCvdT = (\n        3.0\n        * n\n        * constants.gas_constant\n        * x\n        * x\n        * np.exp(x)\n        * ((x - 2.0) * np.exp(x) + (x + 2.0))\n        / (T * np.power(np.exp(x) - 1.0, 3.0))\n    )\n\n    return dCvdT",
  "def jit(fn):\n        return fn",
  "class NaCl_B1(Calibrant):\n    \"\"\"\n    The NaCl (B1 structured) pressure standard reported by Decker (1971).\n\n    .. note:: This calibrant is not exactly the same as that proposed by Decker.\n        The cold compression curve has here been approximated by a\n        Birch-Murnaghan EoS.\n\n    .. todo:: Make the calibrant exactly match that published by Decker.\n    \"\"\"\n\n    def __init__(self):\n        def _pressure_Decker_NaCl(volume, temperature, params):\n            p300 = birch_murnaghan(params[\"V_0\"] / volume, params)\n            grueneisen = MGD2._grueneisen_parameter(0.0, params[\"V_0\"] / volume, params)\n            Debye_T = params[\"Debye_0\"] * np.exp(\n                (params[\"grueneisen_0\"] - grueneisen) / params[\"q_0\"]\n            )\n            Eqh = debye.thermal_energy(temperature, Debye_T, params[\"n\"])\n            EqhR = debye.thermal_energy(params[\"refT\"], Debye_T, params[\"n\"])\n            dpqh = (Eqh - EqhR) * (grueneisen / volume)\n            pressure = p300 + dpqh\n            return pressure\n\n        _params_Decker_NaCl = {\n            \"V_0\": 2.7015e-05,\n            \"K_0\": 24.02e9,\n            \"Kprime_0\": 4.7369,\n            \"Debye_0\": 279,\n            \"grueneisen_0\": 1.59,\n            \"q_0\": 0.93,\n            \"n\": 2.0,\n            \"refT\": 298.15,\n            \"P_0\": 0,\n            \"Z\": 4.0,\n        }\n\n        Calibrant.__init__(self, _pressure_Decker_NaCl, \"pressure\", _params_Decker_NaCl)",
  "def __init__(self):\n        def _pressure_Decker_NaCl(volume, temperature, params):\n            p300 = birch_murnaghan(params[\"V_0\"] / volume, params)\n            grueneisen = MGD2._grueneisen_parameter(0.0, params[\"V_0\"] / volume, params)\n            Debye_T = params[\"Debye_0\"] * np.exp(\n                (params[\"grueneisen_0\"] - grueneisen) / params[\"q_0\"]\n            )\n            Eqh = debye.thermal_energy(temperature, Debye_T, params[\"n\"])\n            EqhR = debye.thermal_energy(params[\"refT\"], Debye_T, params[\"n\"])\n            dpqh = (Eqh - EqhR) * (grueneisen / volume)\n            pressure = p300 + dpqh\n            return pressure\n\n        _params_Decker_NaCl = {\n            \"V_0\": 2.7015e-05,\n            \"K_0\": 24.02e9,\n            \"Kprime_0\": 4.7369,\n            \"Debye_0\": 279,\n            \"grueneisen_0\": 1.59,\n            \"q_0\": 0.93,\n            \"n\": 2.0,\n            \"refT\": 298.15,\n            \"P_0\": 0,\n            \"Z\": 4.0,\n        }\n\n        Calibrant.__init__(self, _pressure_Decker_NaCl, \"pressure\", _params_Decker_NaCl)",
  "def _pressure_Decker_NaCl(volume, temperature, params):\n            p300 = birch_murnaghan(params[\"V_0\"] / volume, params)\n            grueneisen = MGD2._grueneisen_parameter(0.0, params[\"V_0\"] / volume, params)\n            Debye_T = params[\"Debye_0\"] * np.exp(\n                (params[\"grueneisen_0\"] - grueneisen) / params[\"q_0\"]\n            )\n            Eqh = debye.thermal_energy(temperature, Debye_T, params[\"n\"])\n            EqhR = debye.thermal_energy(params[\"refT\"], Debye_T, params[\"n\"])\n            dpqh = (Eqh - EqhR) * (grueneisen / volume)\n            pressure = p300 + dpqh\n            return pressure",
  "def pressure_to_pressure(\n    old_calibrant, new_calibrant, pressure, temperature, PT_covariance=None\n):\n    \"\"\"\n    Convert from pressure defined by one calibrated equation of\n    state of a material to pressure defined by an independent\n    calibration of the same material.\n\n    :param old_calibrant: The original calibration used to estimate the pressure\n    :type old_calibrant: :class:`burnman.Calibrant`\n\n    :param new_calibrant: The new calibration from which the pressure is desired\n    :type new_calibrant: :class:`burnman.Calibrant`\n\n    :param pressure: The pressure calculated using the old calibration\n    :type pressure: float\n\n    :param temperature: The temperature of the material\n    :type temperature: float\n\n    :param PT_covariance: The pressure-temperature variance-covariance matrix\n    :type PT_covariance: 2x2 numpy.array [optional]\n\n    :returns: The pressure of the calibrant [Pa] (float) and a 2x2 numpy array\n        (if the PT_covariance is provided) containing the\n        pressure-temperature variance-covariance matrix.\n\n    :rtype: tuple\n    \"\"\"\n\n    if PT_covariance is None:\n        V = old_calibrant.volume(pressure, temperature)\n        P = new_calibrant.pressure(V, temperature)\n        return P\n    else:\n        V, var_VPT = old_calibrant.volume(pressure, temperature, PT_covariance)\n        VT_covariance = var_VPT[np.ix_([0, 2], [0, 2])]\n        P, var_PVT = new_calibrant.pressure(V, temperature, VT_covariance)\n        PT_covariance = var_PVT[np.ix_([0, 2], [0, 2])]\n        return P, PT_covariance",
  "class Endmember:\n    def __init__(self, name, atoms, formula, sites, comp, H, S, V, Cp, a, k, flag, od):\n        if flag != -1 and flag != -2 and k[0] > 0:\n            formula = dictionarize_formula(formula)\n            self.params = OrderedDict(\n                [\n                    (\"name\", name),\n                    (\"formula\", formula),\n                    (\"equation_of_state\", \"hp_tmt\"),\n                    (\"H_0\", round(H * 1e3, 10)),\n                    (\"S_0\", round(S * 1e3, 10)),\n                    (\"V_0\", round(V * 1e-5, 15)),\n                    (\n                        \"Cp\",\n                        [\n                            round(Cp[0] * 1e3, 10),\n                            round(Cp[1] * 1e3, 10),\n                            round(Cp[2] * 1e3, 10),\n                            round(Cp[3] * 1e3, 10),\n                        ],\n                    ),\n                    (\"a_0\", a),\n                    (\"K_0\", round(k[0] * 1e8, 10)),\n                    (\"Kprime_0\", k[1]),\n                    (\"Kdprime_0\", round(k[2] * 1e-8, 15)),\n                    (\"n\", sum(formula.values())),\n                    (\"molar_mass\", round(formula_mass(formula), 10)),\n                ]\n            )\n        if flag == 1:\n            self.landau_hp = OrderedDict(\n                [\n                    (\"P_0\", 1e5),\n                    (\"T_0\", 298.15),\n                    (\"Tc_0\", od[0]),\n                    (\"S_D\", round(od[1] * 1e3, 10)),\n                    (\"V_D\", round(od[2] * 1e-5, 10)),\n                ]\n            )\n\n        if flag == 2:\n            self.bragg_williams = OrderedDict(\n                [\n                    (\"deltaH\", round(od[0] * 1e3, 10)),\n                    (\"deltaV\", round(od[1] * 1e-5, 15)),\n                    (\"Wh\", round(od[2] * 1e3, 10)),\n                    (\"Wv\", round(od[3] * 1e-5, 15)),\n                    (\"n\", od[4]),\n                    (\"factor\", od[5]),\n                ]\n            )\n\n        if flag == -2:\n            formula = dictionarize_formula(formula)\n            self.params = OrderedDict(\n                [\n                    (\"name\", name),\n                    (\"formula\", formula),\n                    (\"equation_of_state\", \"hp_tmtL\"),\n                    (\"H_0\", round(H * 1e3, 10)),\n                    (\"S_0\", round(S * 1e3, 10)),\n                    (\"V_0\", round(V * 1e-5, 15)),\n                    (\n                        \"Cp\",\n                        [\n                            round(Cp[0] * 1e3, 10),\n                            round(Cp[1] * 1e3, 10),\n                            round(Cp[2] * 1e3, 10),\n                            round(Cp[3] * 1e3, 10),\n                        ],\n                    ),\n                    (\"a_0\", a),\n                    (\"K_0\", round(k[0] * 1e8, 10)),\n                    (\"Kprime_0\", k[1]),\n                    (\"Kdprime_0\", round(k[2] * 1e-8, 15)),\n                    (\"dKdT_0\", round(k[3] * 1e8, 15)),\n                    (\"n\", sum(formula.values())),\n                    (\"molar_mass\", round(formula_mass(formula), 10)),\n                ]\n            )",
  "def getmbr(ds, mbr):\n    for i in range(0, int(ds[0][0])):\n        if ds[i * 4 + 3][0] == mbr:\n            atoms = 0.0\n            formula = \"\"\n            for j in range(3, len(ds[i * 4 + 3]) - 1, 2):\n                atoms += float(ds[i * 4 + 3][j])\n                formula = (\n                    formula\n                    + components[int(ds[i * 4 + 3][j - 1]) - 1]\n                    + str(round(float(ds[i * 4 + 3][j]), 10))\n                )\n\n            sites = int(ds[i * 4 + 3][1])\n            comp = list(map(float, ds[i * 4 + 3][2 : (len(ds[i * 4 + 3]) - 1)]))\n            H = float(ds[i * 4 + 4][0])\n            S = float(ds[i * 4 + 4][1])\n            V = float(ds[i * 4 + 4][2])\n            Cp = list(map(float, ds[i * 4 + 5]))\n            a = float(ds[i * 4 + 6][0])\n            k = list(map(float, ds[i * 4 + 6][1:4]))\n            od = list(map(float, ds[i * 4 + 6][5:]))\n\n            if mbr.endswith(\"L\"):\n                flag = -2\n                od = [0]\n                k.append(float(ds[i * 4 + 6][4]))\n            else:\n                flag = int(ds[i * 4 + 6][4])\n\n            endmember = Endmember(\n                mbr, atoms, formula, sites, comp, H, S, V, Cp, a, k, flag, od\n            )\n            return endmember",
  "def __init__(self, name, atoms, formula, sites, comp, H, S, V, Cp, a, k, flag, od):\n        if flag != -1 and flag != -2 and k[0] > 0:\n            formula = dictionarize_formula(formula)\n            self.params = OrderedDict(\n                [\n                    (\"name\", name),\n                    (\"formula\", formula),\n                    (\"equation_of_state\", \"hp_tmt\"),\n                    (\"H_0\", round(H * 1e3, 10)),\n                    (\"S_0\", round(S * 1e3, 10)),\n                    (\"V_0\", round(V * 1e-5, 15)),\n                    (\n                        \"Cp\",\n                        [\n                            round(Cp[0] * 1e3, 10),\n                            round(Cp[1] * 1e3, 10),\n                            round(Cp[2] * 1e3, 10),\n                            round(Cp[3] * 1e3, 10),\n                        ],\n                    ),\n                    (\"a_0\", a),\n                    (\"K_0\", round(k[0] * 1e8, 10)),\n                    (\"Kprime_0\", k[1]),\n                    (\"Kdprime_0\", round(k[2] * 1e-8, 15)),\n                    (\"n\", sum(formula.values())),\n                    (\"molar_mass\", round(formula_mass(formula), 10)),\n                ]\n            )\n        if flag == 1:\n            self.landau_hp = OrderedDict(\n                [\n                    (\"P_0\", 1e5),\n                    (\"T_0\", 298.15),\n                    (\"Tc_0\", od[0]),\n                    (\"S_D\", round(od[1] * 1e3, 10)),\n                    (\"V_D\", round(od[2] * 1e-5, 10)),\n                ]\n            )\n\n        if flag == 2:\n            self.bragg_williams = OrderedDict(\n                [\n                    (\"deltaH\", round(od[0] * 1e3, 10)),\n                    (\"deltaV\", round(od[1] * 1e-5, 15)),\n                    (\"Wh\", round(od[2] * 1e3, 10)),\n                    (\"Wv\", round(od[3] * 1e-5, 15)),\n                    (\"n\", od[4]),\n                    (\"factor\", od[5]),\n                ]\n            )\n\n        if flag == -2:\n            formula = dictionarize_formula(formula)\n            self.params = OrderedDict(\n                [\n                    (\"name\", name),\n                    (\"formula\", formula),\n                    (\"equation_of_state\", \"hp_tmtL\"),\n                    (\"H_0\", round(H * 1e3, 10)),\n                    (\"S_0\", round(S * 1e3, 10)),\n                    (\"V_0\", round(V * 1e-5, 15)),\n                    (\n                        \"Cp\",\n                        [\n                            round(Cp[0] * 1e3, 10),\n                            round(Cp[1] * 1e3, 10),\n                            round(Cp[2] * 1e3, 10),\n                            round(Cp[3] * 1e3, 10),\n                        ],\n                    ),\n                    (\"a_0\", a),\n                    (\"K_0\", round(k[0] * 1e8, 10)),\n                    (\"Kprime_0\", k[1]),\n                    (\"Kdprime_0\", round(k[2] * 1e-8, 15)),\n                    (\"dKdT_0\", round(k[3] * 1e8, 15)),\n                    (\"n\", sum(formula.values())),\n                    (\"molar_mass\", round(formula_mass(formula), 10)),\n                ]\n            )",
  "def pprint_ordered_dict(d, leading_string, extra_whitespace=0, width=200):\n        old_leading_string = \"OrderedDict[\"\n        whitespace = \" \" * (\n            len(leading_string) + extra_whitespace - len(old_leading_string)\n        )\n        s = pprint.pformat(d, width=width)\n        s = s.replace(\"),\\n\", f\",\\n{whitespace}\")\n        s = s.replace(\"), \", f\",\\n{whitespace}\")\n        s = s.replace(\"', \", \"': \").replace(\"(\", \"\")\n        s = s.replace(old_leading_string, leading_string + \"{\").replace(\")])\", \"}\")\n        return s",
  "def all_equal(iterable):\n    g = groupby(iterable)\n    return next(g, True) and not next(g, False)",
  "def rfloat(x, m=1.0):\n    return round(float(x) * m, ndigits=10)",
  "def read_dataset(datafile):\n    f = open(datafile, \"r\")\n    ds = []\n    for line in f:\n        ds.append(line.decode(\"utf-8\").split())\n    return ds",
  "class Endmember:\n    def __init__(self, name, atoms, formula, sites, comp, H, S, V, Cp, a, k, flag, od):\n        if flag != -1 and flag != -2 and k[0] > 0:\n            formula = dictionarize_formula(formula)\n            self.params = OrderedDict(\n                [\n                    (\"name\", name),\n                    (\"formula\", formula),\n                    (\"equation_of_state\", \"hp_tmt\"),\n                    (\"H_0\", round(H * 1e3, 10)),\n                    (\"S_0\", round(S * 1e3, 10)),\n                    (\"V_0\", round(V * 1e-5, 15)),\n                    (\n                        \"Cp\",\n                        [\n                            round(Cp[0] * 1e3, 10),\n                            round(Cp[1] * 1e3, 10),\n                            round(Cp[2] * 1e3, 10),\n                            round(Cp[3] * 1e3, 10),\n                        ],\n                    ),\n                    (\"a_0\", a),\n                    (\"K_0\", round(k[0] * 1e8, 10)),\n                    (\"Kprime_0\", k[1]),\n                    (\"Kdprime_0\", round(k[2] * 1e-8, 15)),\n                    (\"n\", sum(formula.values())),\n                    (\"molar_mass\", round(formula_mass(formula), 10)),\n                ]\n            )\n        if flag == 1:\n            self.landau_hp = OrderedDict(\n                [\n                    (\"P_0\", 1e5),\n                    (\"T_0\", 298.15),\n                    (\"Tc_0\", od[0]),\n                    (\"S_D\", round(od[1] * 1e3, 10)),\n                    (\"V_D\", round(od[2] * 1e-5, 10)),\n                ]\n            )\n\n        if flag == 2:\n            self.bragg_williams = OrderedDict(\n                [\n                    (\"deltaH\", round(od[0] * 1e3, 10)),\n                    (\"deltaV\", round(od[1] * 1e-5, 15)),\n                    (\"Wh\", round(od[2] * 1e3, 10)),\n                    (\"Wv\", round(od[3] * 1e-5, 15)),\n                    (\"n\", od[4]),\n                    (\"factor\", od[5]),\n                ]\n            )\n\n        if flag == -2:\n            formula = dictionarize_formula(formula)\n            self.params = OrderedDict(\n                [\n                    (\"name\", name),\n                    (\"formula\", formula),\n                    (\"equation_of_state\", \"hp_tmtL\"),\n                    (\"H_0\", round(H * 1e3, 10)),\n                    (\"S_0\", round(S * 1e3, 10)),\n                    (\"V_0\", round(V * 1e-5, 15)),\n                    (\n                        \"Cp\",\n                        [\n                            round(Cp[0] * 1e3, 10),\n                            round(Cp[1] * 1e3, 10),\n                            round(Cp[2] * 1e3, 10),\n                            round(Cp[3] * 1e3, 10),\n                        ],\n                    ),\n                    (\"a_0\", a),\n                    (\"K_0\", round(k[0] * 1e8, 10)),\n                    (\"Kprime_0\", k[1]),\n                    (\"Kdprime_0\", round(k[2] * 1e-8, 15)),\n                    (\"dKdT_0\", round(k[3] * 1e8, 15)),\n                    (\"n\", sum(formula.values())),\n                    (\"molar_mass\", round(formula_mass(formula), 10)),\n                ]\n            )",
  "def getmbr(ds, mbr):\n    for i in range(0, int(ds[0][0])):\n        if ds[i * 4 + 3][0] == mbr:\n            atoms = 0.0\n            formula = \"\"\n            for j in range(3, len(ds[i * 4 + 3]) - 1, 2):\n                atoms += float(ds[i * 4 + 3][j])\n                formula = (\n                    formula\n                    + components[int(ds[i * 4 + 3][j - 1]) - 1]\n                    + str(round(float(ds[i * 4 + 3][j]), 10))\n                )\n\n            sites = int(ds[i * 4 + 3][1])\n            comp = list(map(float, ds[i * 4 + 3][2 : (len(ds[i * 4 + 3]) - 1)]))\n            H = float(ds[i * 4 + 4][0])\n            S = float(ds[i * 4 + 4][1])\n            V = float(ds[i * 4 + 4][2])\n            Cp = list(map(float, ds[i * 4 + 5]))\n            a = float(ds[i * 4 + 6][0])\n            k = list(map(float, ds[i * 4 + 6][1:4]))\n            od = list(map(float, ds[i * 4 + 6][5:]))\n\n            if mbr.endswith(\"L\"):\n                flag = -2\n                od = [0]\n                k.append(float(ds[i * 4 + 6][4]))\n            else:\n                flag = int(ds[i * 4 + 6][4])\n\n            endmember = Endmember(\n                mbr, atoms, formula, sites, comp, H, S, V, Cp, a, k, flag, od\n            )\n            return endmember",
  "def __init__(self, name, atoms, formula, sites, comp, H, S, V, Cp, a, k, flag, od):\n        if flag != -1 and flag != -2 and k[0] > 0:\n            formula = dictionarize_formula(formula)\n            self.params = OrderedDict(\n                [\n                    (\"name\", name),\n                    (\"formula\", formula),\n                    (\"equation_of_state\", \"hp_tmt\"),\n                    (\"H_0\", round(H * 1e3, 10)),\n                    (\"S_0\", round(S * 1e3, 10)),\n                    (\"V_0\", round(V * 1e-5, 15)),\n                    (\n                        \"Cp\",\n                        [\n                            round(Cp[0] * 1e3, 10),\n                            round(Cp[1] * 1e3, 10),\n                            round(Cp[2] * 1e3, 10),\n                            round(Cp[3] * 1e3, 10),\n                        ],\n                    ),\n                    (\"a_0\", a),\n                    (\"K_0\", round(k[0] * 1e8, 10)),\n                    (\"Kprime_0\", k[1]),\n                    (\"Kdprime_0\", round(k[2] * 1e-8, 15)),\n                    (\"n\", sum(formula.values())),\n                    (\"molar_mass\", round(formula_mass(formula), 10)),\n                ]\n            )\n        if flag == 1:\n            self.landau_hp = OrderedDict(\n                [\n                    (\"P_0\", 1e5),\n                    (\"T_0\", 298.15),\n                    (\"Tc_0\", od[0]),\n                    (\"S_D\", round(od[1] * 1e3, 10)),\n                    (\"V_D\", round(od[2] * 1e-5, 10)),\n                ]\n            )\n\n        if flag == 2:\n            self.bragg_williams = OrderedDict(\n                [\n                    (\"deltaH\", round(od[0] * 1e3, 10)),\n                    (\"deltaV\", round(od[1] * 1e-5, 15)),\n                    (\"Wh\", round(od[2] * 1e3, 10)),\n                    (\"Wv\", round(od[3] * 1e-5, 15)),\n                    (\"n\", od[4]),\n                    (\"factor\", od[5]),\n                ]\n            )\n\n        if flag == -2:\n            formula = dictionarize_formula(formula)\n            self.params = OrderedDict(\n                [\n                    (\"name\", name),\n                    (\"formula\", formula),\n                    (\"equation_of_state\", \"hp_tmtL\"),\n                    (\"H_0\", round(H * 1e3, 10)),\n                    (\"S_0\", round(S * 1e3, 10)),\n                    (\"V_0\", round(V * 1e-5, 15)),\n                    (\n                        \"Cp\",\n                        [\n                            round(Cp[0] * 1e3, 10),\n                            round(Cp[1] * 1e3, 10),\n                            round(Cp[2] * 1e3, 10),\n                            round(Cp[3] * 1e3, 10),\n                        ],\n                    ),\n                    (\"a_0\", a),\n                    (\"K_0\", round(k[0] * 1e8, 10)),\n                    (\"Kprime_0\", k[1]),\n                    (\"Kdprime_0\", round(k[2] * 1e-8, 15)),\n                    (\"dKdT_0\", round(k[3] * 1e8, 15)),\n                    (\"n\", sum(formula.values())),\n                    (\"molar_mass\", round(formula_mass(formula), 10)),\n                ]\n            )",
  "def pprint_ordered_dict(d, leading_string, extra_whitespace=0, width=200):\n        old_leading_string = \"OrderedDict[\"\n        whitespace = \" \" * (\n            len(leading_string) + extra_whitespace - len(old_leading_string)\n        )\n        s = pprint.pformat(d, width=width)\n        s = s.replace(\"),\\n\", f\",\\n{whitespace}\")\n        s = s.replace(\"), \", f\",\\n{whitespace}\")\n        s = s.replace(\"', \", \"': \").replace(\"(\", \"\")\n        s = s.replace(old_leading_string, leading_string + \"{\").replace(\")])\", \"}\")\n        return s",
  "def read_dataset(datafile):\n    f = open(datafile, \"r\")\n    ds = []\n    for line in f:\n        ds.append(line.split())\n    return ds",
  "def read_dataset_utf8(datafile):\n    f = open(datafile, \"r\")\n    ds = []\n    for line in f:\n        ds.append(line.decode(\"utf-8\").split())\n    return ds",
  "def process_stixrude():\n    perplex_ds = read_dataset(\"stx11ver.dat\")\n    alias_mapping = read_dataset(\"perplex_slb_2011_names.txt\")\n\n    alias = {}\n    accurate_values = {}\n    configurational_entropies = {}\n    for line in alias_mapping:\n        alias[line[0]] = line[2]\n\n    process = 0  # flag to process data or not (to cut out first lines)\n    n = 0  # line number for each record\n    for line in perplex_ds:\n        if len(line) != 0:\n            if process == 1:\n                if line[0] == \"end\":\n                    n = 0\n                else:\n                    n = n + 1\n                if n == 1:\n                    name = alias[line[0]]\n                    data = []\n                    configurational_entropy = \"None\"\n                elif n == 3:\n                    # F0, (n, ignored), -V0\n                    data.extend([float(line[2]), -1.0 * float(line[8])])\n                elif n == 4:\n                    # K_0, K_prime, Debye_0, grueneisen_0, q_0, eta_s0,\n                    # [configurational_and_magnetic_entropy]\n                    data.extend(\n                        [\n                            float(line[2]),\n                            float(line[5]),\n                            float(line[8]),\n                            float(line[11]),\n                            float(line[14]),\n                            float(line[17]),\n                        ]\n                    )\n                    if len(line) == 21:\n                        configurational_entropy = float(line[20])\n                elif n == 5:\n                    # mu_S0, mu_S0_prime\n                    data.extend([float(line[2]), float(line[5])])\n                    # Sort into correct order for processing: F, V, K, K',\n                    #                        Debye, gruen, q, G, Gprime, etaS0\n                    accurate_values[name] = [\n                        data[0] / 1.0e3,\n                        data[1] * 10.0,\n                        data[2] / 1.0e4,\n                        data[3],\n                        data[4],\n                        data[5],\n                        data[6],\n                        data[8] / 1.0e4,\n                        data[9],\n                        data[7],\n                    ]\n                    configurational_entropies[name] = configurational_entropy\n\n            if line[0] == \"end_components\":\n                process = 1\n\n    return accurate_values, configurational_entropies",
  "def write_tvel_file(planet_or_layer, modelname=\"burnmanmodel\", background_model=None):\n    \"\"\"\n    Function to write input file for obspy travel time calculations.\n    Note: Because density isn't defined for most 1D seismic models, densities\n    are output as zeroes.  The tvel format has a column for density,\n    but this column is not used by obspy for travel time calculations.\n\n    :param planet_or_layer: Planet or layer to write out to tvel file\n    :type planet_or_layer: :class:`burnman.Planet` or :class:`burnman.Layer`.\n    :param filename: Filename to read to.\n    :type filename: str\n    :param background_model:  1D seismic model to fill in parts of planet\n        (likely to be an earth model) that aren't defined by layer\n        (only need when using :class:`burnman.Layer`)\n    :type background_model: :class:`burnman.seismic.Seismic1DModel`\n    \"\"\"\n\n    if not isinstance(planet_or_layer, (Planet, Layer)):\n        raise TypeError(\"Input must be a Planet() or Layer() object.\")\n\n    if isinstance(planet_or_layer, Layer):\n        assert background_model\n        layer = planet_or_layer\n        depths = background_model.internal_depth_list()\n\n        above_layer = np.where(depths < (np.max(depths) - layer.outer_radius))[-1]\n        below_layer = np.where(depths > (np.max(depths) - layer.inner_radius))[0]\n\n        data_above = list(\n            zip(\n                depths[above_layer] / 1.0e3,\n                background_model.v_p(depths[above_layer]) / 1.0e3,\n                background_model.v_s(depths[above_layer]) / 1.0e3,\n                np.zeros_like(depths[above_layer]),\n            )\n        )\n        data_layer = list(\n            zip(\n                (np.max(depths) - layer.radii)[::-1] / 1.0e3,\n                layer.v_p[::-1] / 1.0e3,\n                layer.v_s[::-1] / 1.0e3,\n                layer.density[::-1] / 1.0e3,\n            )\n        )\n        data_below = list(\n            zip(\n                depths[below_layer] / 1.0e3,\n                background_model.v_p(depths[below_layer]) / 1.0e3,\n                background_model.v_s(depths[below_layer]) / 1.0e3,\n                np.zeros_like(depths[below_layer]),\n            )\n        )\n\n        data = data_above + data_layer + data_below\n\n        header = (\n            f\"{layer.name}  model from BurnMan between a radius of \"\n            f\"{str(layer.inner_radius)} and \"\n            f\"{str(layer.outer_radius)} km \\n\"\n            f\"{background_model.__class__.__name__} \"\n            f\"for the rest of the Earth\"\n        )\n        with open(modelname + \".tvel\", \"wb\") as f:\n            np.savetxt(f, data, header=header, fmt=\"%5.2f\", delimiter=\"\\t\")\n\n    if isinstance(planet_or_layer, Planet):\n        planet = planet_or_layer\n        data = list(\n            zip(\n                (planet.radius_planet - planet.radii)[::-1] / 1.0e3,\n                planet.v_p[::-1] / 1.0e3,\n                planet.v_s[::-1] / 1.0e3,\n                planet.density[::-1] / 1.0e3,\n            )\n        )\n\n        header = (\n            f\"{planet.name} model from BurnMan with a radius of \"\n            f\"{str(planet.radius_planet)} km \\n\"\n            f\"Layers of planet are \"\n            f'{\", \".join(layer.name for layer in planet.layers)}'\n        )\n        with open(modelname + \".tvel\", \"wb\") as f:\n            np.savetxt(f, data, header=header, fmt=\"%5.2f\", delimiter=\"\\t\")",
  "def write_axisem_input(\n    layers,\n    modelname=\"burnmanmodel_foraxisem\",\n    axisem_ref=\"axisem_prem_ani_noocean.txt\",\n    plotting=False,\n):\n    \"\"\"\n    Writing velocities and densities to AXISEM (www.axisem.info) input file.\n    The input can be a single layer, or a list of layers taken from a planet\n    (planet.layers).\n    Currently this function will implement explicit discontinuities between\n    layers in the seismic model.\n    Currently this function is only set for Earth.\n\n    :param layers: List of layers to put in AXISEM file.\n    :type layers: list of one or more :class:`burnman.Layer`\n    :param modelname: Name of model, appears in name of output file.\n    :type modelname: str\n    :param axisem_ref: Reference file, used to copy the header\n        and for the rest of the planet, in the case of a :class:`burnman.Layer`.\n    :type axisem_ref: str\n    :param plotting: Choose whether to show plot of the old model and replaced model.\n    :type plotting: bool\n    \"\"\"\n\n    if not isinstance(layers[0], Layer):\n        raise TypeError(\"Input must be a list of Layer()\")\n    # Load reference input\n    datastream = pkgutil.get_data(\"burnman\", \"data/input_seismic/\" + axisem_ref)\n    lines = [\n        line.strip() for line in datastream.decode(\"ascii\").split(\"\\n\") if line.strip()\n    ]\n    table = []\n    for line in lines[18:]:\n        numbers = np.fromstring(line, sep=\" \")\n        if len(numbers) > 0:\n            if line[0] != \"#\" and line[0] != \"%\":\n                table.append(numbers)\n    table = np.array(table)\n    # format is\n    # radius density vpv vsv Qk Qmu vph vsh eta\n\n    if plotting:\n        plt.figure(figsize=(12, 6))\n        plt.plot(table[:, 0] / 1.0e3, table[:, 2] / 1.0e3, color=\"g\", linestyle=\"--\")\n        plt.plot(table[:, 0] / 1.0e3, table[:, 3] / 1.0e3, color=\"b\", linestyle=\"--\")\n        plt.plot(table[:, 0] / 1.0e3, table[:, 1] / 1.0e3, color=\"r\", linestyle=\"--\")\n\n    for layer in layers:\n        # Cutting out range to input in Axisem reference file, and adding in\n        # model values at the top and bottom of Layer.\n        i_min = next(x[0] for x in enumerate(table[:, 0]) if x[1] <= layer.outer_radius)\n        if table[i_min, 0] - layer.outer_radius < 0:\n            table = np.insert(table, i_min, None, axis=0)\n            table[i_min, 0] = layer.outer_radius\n\n        i_max = next(x[0] for x in enumerate(table[:, 0]) if x[1] <= layer.inner_radius)\n\n        if table[i_max, 0] - layer.inner_radius < 0:\n            table = np.insert(table, i_max, None, axis=0)\n            table[i_max, 0] = layer.inner_radius\n\n        lvp, lvs, lrho = layer.evaluate(\n            [\"v_p\", \"v_s\", \"density\"],\n            radlist=table[i_min:i_max, 0],\n            radius_planet=np.max(table[:, 0]),\n        )\n\n        table[i_min:i_max, 2] = lvp\n        table[i_min:i_max, 6] = lvp\n        table[i_min:i_max, 3] = lvs\n        table[i_min:i_max, 7] = lvs\n        table[i_min:i_max, 1] = lrho\n\n    # WRITE OUT FILE\n    filename = \"axisem_\" + modelname + \".txt\"\n    f = open(filename, \"w\")\n    print(\"Writing \" + filename + \" ...\")\n    f.write(\n        f\"# Input file {modelname} for AXISEM created using BurnMan, \"\n        f\"replacing {axisem_ref} between \"\n        f\"{str(np.round(layer.inner_radius / 1.e3))} and \"\n        f\"{str(np.round(layer.outer_radius / 1.e3))} km\\n\"\n    )\n\n    discontinuity = 0  # Number discontinuities\n    f.write(\"NAME \" + modelname + \"\\n\")\n    for line in lines[2:18]:\n        f.write(line[:] + \"\\n\")\n    for i in range(len(table[:, 0])):\n        if i > 0 and table[i, 0] == table[i - 1, 0]:\n            discontinuity = discontinuity + 1\n            f.write(\n                f\"#          Discontinuity   {str(discontinuity)}, \"\n                f\"depth:    {str(np.round((6371.e3 - table[i, 0]) / 1.e3, decimals=2))}\"\n                \" km \\n\"\n            )\n\n        f.write(\n            f\"{table[i, 0]:8.0f} {table[i, 1]:9.2f} {table[i, 2]:9.2f} \"\n            f\"{table[i, 3]:9.2f} {table[i, 4]:9.1f} {table[i, 5]:9.1f} \"\n            f\"{table[i, 6]:9.2f} {table[i, 7]:9.2f} {table[i, 8]:9.5f} \\n\"\n        )\n\n    f.close()\n\n    if plotting:\n        plt.plot(\n            table[:, 0] / 1.0e3,\n            table[:, 2] / 1.0e3,\n            color=\"g\",\n            linestyle=\"-\",\n            label=\"V_p\",\n        )\n        plt.plot(\n            table[:, 0] / 1.0e3,\n            table[:, 3] / 1.0e3,\n            color=\"b\",\n            linestyle=\"-\",\n            label=\"V_s\",\n        )\n        plt.plot(\n            table[:, 0] / 1.0e3,\n            table[:, 1] / 1.0e3,\n            color=\"r\",\n            linestyle=\"-\",\n            label=\"density\",\n        )\n\n        plt.title(\n            f\"{filename} = {axisem_ref} replaced between \"\n            f\"{str(layer.inner_radius / 1.e3)} and \"\n            f\"{str(layer.outer_radius / 1.e3)} km\"\n        )\n        plt.legend(loc=\"lower right\")\n        plt.show()",
  "def write_mineos_input(\n    layers,\n    modelname=\"burnmanmodel_formineos\",\n    mineos_ref=\"mineos_prem_noocean.txt\",\n    plotting=False,\n):\n    \"\"\"\n    Writing velocities and densities to\n    Mineos (https://geodynamics.org/cig/software/mineos/) input file\n    Note: currently, this function only honors the discontinuities already\n    in the synthetic input file, so it is best to only replace\n    certain layers with burnman values\n\n    :param layers: List of layers to put in Mineos file.\n    :type layers: list of one or more :class:`burnman.Layer`\n    :param modelname: Name of model, appears in name of output file.\n    :type modelname: str\n    :param mineos_ref: Reference file, used to copy the header\n        and for the rest of the planet, in the case of a :class:`burnman.Layer`.\n    :type mineos_ref: str\n    :param plotting: Choose whether to show plot of the old model and replaced model.\n    :type plotting: bool\n    \"\"\"\n\n    if not isinstance(layers[0], Layer):\n        raise TypeError(\"Input must be a list of Layer()\")\n\n    # Load reference input\n    datastream = pkgutil.get_data(\"burnman\", \"data/input_seismic/\" + mineos_ref)\n    lines = [\n        line.strip() for line in datastream.decode(\"ascii\").split(\"\\n\") if line.strip()\n    ]\n    table = []\n    for line in lines[3:]:\n        numbers = np.fromstring(line, sep=\" \")\n        table.append(numbers)\n    table = np.array(table)\n\n    if plotting:\n        plt.figure(figsize=(12, 6))\n        plt.plot(table[:, 0] / 1.0e3, table[:, 2] / 1.0e3, color=\"g\", linestyle=\"--\")\n        plt.plot(table[:, 0] / 1.0e3, table[:, 3] / 1.0e3, color=\"b\", linestyle=\"--\")\n        plt.plot(table[:, 0] / 1.0e3, table[:, 1] / 1.0e3, color=\"r\", linestyle=\"--\")\n\n    for layer in layers:\n        i_min = next(x[0] for x in enumerate(table[:, 0]) if x[1] >= layer.inner_radius)\n        if table[i_min, 0] - layer.inner_radius > 0:\n            table[i_min, 0] = layer.inner_radius\n\n        i_max = next(x[0] for x in enumerate(table[:, 0]) if x[1] >= layer.outer_radius)\n        if table[i_max, 0] - layer.outer_radius > 0:\n            table[i_max, 0] = layer.outer_radius\n\n        lvp, lvs, lrho = layer.evaluate(\n            [\"v_p\", \"v_s\", \"density\"],\n            radlist=table[i_min:i_max, 0],\n            radius_planet=np.max(table[:, 0]),\n        )\n\n        table[i_min:i_max, 2] = lvp\n        table[i_min:i_max, 6] = lvp\n        table[i_min:i_max, 3] = lvs\n        table[i_min:i_max, 7] = lvs\n        table[i_min:i_max, 1] = lrho\n\n    # WRITE OUT FILE\n    filename = \"mineos_\" + modelname + \".txt\"\n    f = open(filename, \"w\")\n    print(\"Writing \" + filename + \" ...\")\n    f.write(lines[0][:-2] + \" +  \" + filename + \"\\n\")\n    for line in lines[1:3]:\n        f.write(line[:-2] + \"\\n\")\n    for i in range(len(table[:, 0])):\n        f.write(\n            \"%8.0f %9.2f %9.2f %9.2f %9.1f %9.1f %9.2f %9.2f %9.5f \\n\"\n            % (\n                table[i, 0],\n                table[i, 1],\n                table[i, 2],\n                table[i, 3],\n                table[i, 4],\n                table[i, 5],\n                table[i, 6],\n                table[i, 7],\n                table[i, 8],\n            )\n        )\n\n    f.close()\n\n    if plotting:\n        plt.plot(\n            table[:, 0] / 1.0e3,\n            table[:, 2] / 1.0e3,\n            color=\"g\",\n            linestyle=\"-\",\n            label=\"V_p\",\n        )\n        plt.plot(\n            table[:, 0] / 1.0e3,\n            table[:, 3] / 1.0e3,\n            color=\"b\",\n            linestyle=\"-\",\n            label=\"V_s\",\n        )\n        plt.plot(\n            table[:, 0] / 1.0e3,\n            table[:, 1] / 1.0e3,\n            color=\"r\",\n            linestyle=\"-\",\n            label=\"density\",\n        )\n\n        plt.title(\n            f\"{filename} = {mineos_ref} replaced between \"\n            f\"{str(layer.inner_radius / 1.e3)} and \"\n            f\"{str(layer.outer_radius / 1.e3)} km\"\n        )\n        plt.legend(loc=\"lower right\")\n        plt.show()",
  "def _decompose_3D_matrix(W):\n    \"\"\"\n    Decomposes a 3D matrix W_ijk where E = W_ijk p_i p_j p_k\n    into a subregular form where\n    E = G_i p_i + WB_ij (1 - p_j + p_i) / 2 + WT_ijk p_i p_j p_k,\n    and i < j < k.\n\n    :param W: 3D interaction matrix.\n    :type W: numpy.array\n\n    :returns: The 1D array G_i, the 2D upper triangular array WB_ij and\n        the ternary terms in a list where each item is in the form [i, j, k, WT_ijk]\n    :rtype: tuple\n    \"\"\"\n\n    n_mbrs = len(W)\n    # New endmember components\n    # W_iii needs to be copied, otherwise just a view onto W\n    new_endmember_excesses = np.copy(np.einsum(\"iii->i\", W))\n\n    # Removal of endmember components from 3D representation\n    W -= (\n        np.einsum(\n            \"i, j, k->ijk\", new_endmember_excesses, np.ones(n_mbrs), np.ones(n_mbrs)\n        )\n        + np.einsum(\n            \"i, j, k->ijk\", np.ones(n_mbrs), new_endmember_excesses, np.ones(n_mbrs)\n        )\n        + np.einsum(\n            \"i, j, k->ijk\", np.ones(n_mbrs), np.ones(n_mbrs), new_endmember_excesses\n        )\n    ) / 3.0\n\n    # Transformed 2D components\n    # (i=j, i=k, j=k)\n    new_binary_matrix = (\n        np.einsum(\"jki, jk -> ij\", W, np.identity(n_mbrs))\n        + np.einsum(\"jik, jk -> ij\", W, np.identity(n_mbrs))\n        + np.einsum(\"ijk, jk -> ij\", W, np.identity(n_mbrs))\n    ).round(decimals=12)\n\n    # Wb is the 3D matrix corresponding to the terms in the binary matrix,\n    # such that the two following print statements produce the same answer\n    # for a given array of endmember proportions\n    Wb = (\n        np.einsum(\"ijk, ij->ijk\", W, np.identity(n_mbrs))\n        + np.einsum(\"ijk, jk->ijk\", W, np.identity(n_mbrs))\n        + np.einsum(\"ijk, ik->ijk\", W, np.identity(n_mbrs))\n    )\n\n    # Remove binary component from 3D representation\n    # The extra terms are needed because the binary term in the formulation\n    # of a subregular solution model given by\n    # Helffrich and Wood includes ternary components (the sum_k X_k part)..\n    W -= (\n        Wb\n        + (\n            np.einsum(\"ij, k\", new_binary_matrix, np.ones(n_mbrs))\n            - np.einsum(\"ij, ik->ijk\", new_binary_matrix, np.identity(n_mbrs))\n            - np.einsum(\"ij, jk->ijk\", new_binary_matrix, np.identity(n_mbrs))\n        )\n        / 2.0\n    )\n\n    # Find the 3D components Wijk by adding the elements at\n    # the six equivalent positions in the matrix\n    new_ternary_terms = []\n    for i in range(n_mbrs):\n        for j in range(i + 1, n_mbrs):\n            for k in range(j + 1, n_mbrs):\n                val = (\n                    W[i, j, k]\n                    + W[j, k, i]\n                    + W[k, i, j]\n                    + W[k, j, i]\n                    + W[j, i, k]\n                    + W[i, k, j]\n                ).round(decimals=12)\n                if np.abs(val) > 1.0e-12:\n                    new_ternary_terms.append([i, j, k, val])\n\n    return (new_endmember_excesses, new_binary_matrix, new_ternary_terms)",
  "def _subregular_matrix_conversion(\n    new_basis, binary_matrix, ternary_terms=None, endmember_excesses=None\n):\n    \"\"\"\n    Converts the arrays reguired to describe a subregular solution\n    from one endmember basis to another.\n\n    The excess nonconfigurational energies of the subregular solution model\n    are described as follows:\n    E = G_i p_i + WB_ij (1 - p_j + p_i) / 2 + WT_ijk p_i p_j p_k,\n    and i < j < k.\n\n    :param new_basis: The new endmember basis, given as amounts of the old endmembers.\n    :type new_basis: 2D numpy array\n\n    :param binary_matrix: The upper triangular matrix WB_ij.\n    :type binary_matrix: 2D numpy array\n\n    :param ternary_terms: The ternary terms in a list where each\n        item is in the form [i, j, k, WT_ijk]\n    :type ternary_terms: list of lists of length 4\n\n    :param endmember_excesses: The array G_i\n    :type endmember_excesses: 1D numpy array\n\n    :returns: The 1D array G_i, the 2D upper triangular array WB_ij and\n        the ternary terms in a list where each item is in the form [i, j, k, WT_ijk]\n    :rtype: tuple\n    \"\"\"\n    n_mbrs = len(binary_matrix)\n    # Compact 3D representation of original interactions\n    W = (\n        np.einsum(\"i, jk -> ijk\", np.ones(n_mbrs), binary_matrix)\n        + np.einsum(\"ij, jk -> ijk\", binary_matrix, np.identity(n_mbrs))\n        - np.einsum(\"ij, ik -> ijk\", binary_matrix, np.identity(n_mbrs))\n    ) / 2.0\n\n    # Add endmember components to 3D representation\n    if endmember_excesses is not None:\n        W += (\n            np.einsum(\n                \"i, j, k->ijk\", endmember_excesses, np.ones(n_mbrs), np.ones(n_mbrs)\n            )\n            + np.einsum(\n                \"j, i, k->ijk\", endmember_excesses, np.ones(n_mbrs), np.ones(n_mbrs)\n            )\n            + np.einsum(\n                \"k, i, j->ijk\", endmember_excesses, np.ones(n_mbrs), np.ones(n_mbrs)\n            )\n        ) / 3.0\n\n    # Add ternary values to 3D representation\n    if ternary_terms is not None:\n        for i, j, k, val in ternary_terms:\n            W[i, j, k] += val\n\n    # Transformation to new 3D representation\n    A = new_basis.T\n    Wn = np.einsum(\"il, jm, kn, ijk -> lmn\", A, A, A, W)\n\n    new_endmember_excesses, new_binary_terms, new_ternary_terms = _decompose_3D_matrix(\n        Wn\n    )\n\n    return (new_endmember_excesses, new_binary_terms, new_ternary_terms)",
  "def complete_basis(basis):\n    \"\"\"\n    Creates a full basis by filling remaining rows with\n    rows of the identity matrix with row indices not\n    in the column pivot list of the basis RREF\n    \"\"\"\n\n    n, m = basis.shape\n    if n < m:\n        pivots = list(Matrix(basis).rref()[1])\n        return np.concatenate(\n            (basis, np.identity(m)[[i for i in range(m) if i not in pivots], :]), axis=0\n        )\n    else:\n        return basis",
  "def transform_solution_to_new_basis(\n    solution,\n    new_basis,\n    n_mbrs=None,\n    solution_name=None,\n    endmember_names=None,\n    molar_fractions=None,\n):\n    \"\"\"\n    Transforms a solution model from one endmember basis to another.\n    Returns a new Solution object.\n\n    :param solution: The original solution object.\n    :type solution: :class:`burnman.Solution` object\n\n    :param new_basis: The new endmember basis, given as amounts of the old endmembers.\n    :type new_basis: 2D numpy array\n\n    :param n_mbrs: The number of endmembers in the new solution\n        (defaults to the length of new_basis).\n    :type n_mbrs: float, optional\n\n    :param solution_name: A name corresponding to the new solution.\n    :type solution_name: str, optional\n\n    :param endmember_names: A list corresponding to the names of the new endmembers.\n    :type endmember_names: list of str, optional\n\n    :param molar_fractions: Fractions of the new endmembers in the new solution.\n    :type molar_fractions: numpy.array, optional\n\n    :returns: The transformed solution.\n    :rtype: :class:`burnman.Solution` object\n    \"\"\"\n    new_basis = np.array(new_basis)\n    if n_mbrs is None:\n        n_mbrs, n_all_mbrs = new_basis.shape\n    else:\n        _, n_all_mbrs = new_basis.shape\n\n    if solution_name is None:\n        name = \"child solution\"\n    else:\n        name = solution_name\n\n    solution_model = solution.solution_model\n\n    # Use type here to avoid inheritance problems\n    solution_type = type(solution_model)\n    if solution_type == IdealSolution:\n        ESV_modifiers = [[0.0, 0.0, 0.0] for v in new_basis]\n\n    if (\n        solution_type == AsymmetricRegularSolution\n        or solution_type == SymmetricRegularSolution\n    ):\n        A = complete_basis(new_basis).T\n\n        old_alphas = solution.solution_model.alphas\n        alphas = np.einsum(\"i, ij\", solution.solution_model.alphas, A)\n        inv_diag_alphas = np.diag(1.0 / alphas)\n        B = np.einsum(\"ij, jk, kl->il\", np.diag(old_alphas), A, inv_diag_alphas)\n        alphas = list(alphas[0:n_mbrs])\n        Qe = np.einsum(\"ik, ij, kl->jl\", solution.solution_model.We, B, B)\n        Qs = np.einsum(\"ik, ij, kl->jl\", solution.solution_model.Ws, B, B)\n        Qv = np.einsum(\"ik, ij, kl->jl\", solution.solution_model.Wv, B, B)\n\n        def new_interactions(Q, n_mbrs):\n            return [\n                [\n                    float(\n                        (Q[i, j] + Q[j, i] - Q[i, i] - Q[j, j])\n                        * (alphas[i] + alphas[j])\n                        / 2.0\n                    )\n                    for j in range(i + 1, n_mbrs)\n                ]\n                for i in range(n_mbrs - 1)\n            ]\n\n        energy_interaction = new_interactions(Qe, n_mbrs)\n        entropy_interaction = new_interactions(Qs, n_mbrs)\n        volume_interaction = new_interactions(Qv, n_mbrs)\n\n        ESV_modifiers = [\n            [Qe[i, i] * alphas[i], Qs[i, i] * alphas[i], Qv[i, i] * alphas[i]]\n            for i in range(n_mbrs)\n        ]\n\n    elif solution_type == SubregularSolution:\n        full_basis = complete_basis(new_basis)\n\n        def new_interactions(W, n_mbrs):\n            return [\n                [[W[i, j], W[j, i]] for j in range(i + 1, n_mbrs)]\n                for i in range(n_mbrs - 1)\n            ]\n\n        # N.B. initial endmember_excesses are zero\n        Emod, We, ternary_e = _subregular_matrix_conversion(\n            full_basis,\n            solution.solution_model.We,\n            solution.solution_model.ternary_terms_e,\n        )\n        Smod, Ws, ternary_s = _subregular_matrix_conversion(\n            full_basis,\n            solution.solution_model.Ws,\n            solution.solution_model.ternary_terms_s,\n        )\n        Vmod, Wv, ternary_v = _subregular_matrix_conversion(\n            full_basis,\n            solution.solution_model.Wv,\n            solution.solution_model.ternary_terms_v,\n        )\n\n        energy_interaction = new_interactions(We, n_mbrs)\n        entropy_interaction = new_interactions(Ws, n_mbrs)\n        volume_interaction = new_interactions(Wv, n_mbrs)\n\n        ESV_modifiers = [[Emod[i], Smod[i], Vmod[i]] for i in range(n_mbrs)]\n\n    else:\n        raise Exception(\n            \"The function to change basis for the \"\n            \"{0} solution type has not yet been \"\n            \"implemented.\".format(solution_type)\n        )\n\n    # Create site formulae\n    new_occupancies = np.array(new_basis).dot(\n        solution.solution_model.endmember_occupancies\n    )\n    new_multiplicities = np.array(new_basis).dot(\n        solution.solution_model.site_multiplicities\n    )\n    site_formulae = site_occupancies_to_strings(\n        solution.solution_model.sites, new_multiplicities, new_occupancies\n    )\n\n    # Create endmembers\n    endmembers = []\n    for i, vector in enumerate(new_basis):\n        nonzero_indices = np.nonzero(vector)[0]\n        if len(nonzero_indices) == 1:\n            endmembers.append(\n                [solution_model.endmembers[nonzero_indices[0]][0], site_formulae[i]]\n            )\n        else:\n            mbr = CombinedMineral(\n                [solution_model.endmembers[idx][0] for idx in nonzero_indices],\n                [vector[idx] for idx in nonzero_indices],\n                ESV_modifiers[i],\n            )\n            mbr.params[\"formula\"] = {\n                key: value\n                for (key, value) in mbr.params[\"formula\"].items()\n                if value > 1.0e-12\n            }\n            endmembers.append([mbr, site_formulae[i]])\n\n    if endmember_names is not None:\n        for i in range(n_mbrs):\n            endmembers[i][0].params[\"name\"] = endmember_names[i]\n            endmembers[i][0].name = endmember_names[i]\n\n    if n_mbrs == 1:\n        endmembers[0][0].name = name\n        endmembers[0][0].parent = solution\n        endmembers[0][0].basis = new_basis\n        return endmembers[0][0]\n    else:\n        if solution_type == IdealSolution:\n            new_solution_model = IdealSolution(endmembers=endmembers)\n        elif (\n            solution_type == SymmetricRegularSolution\n            or solution_type == SubregularSolution\n        ):\n            new_solution_model = type(solution_model)(\n                endmembers=endmembers,\n                energy_interaction=energy_interaction,\n                volume_interaction=volume_interaction,\n                entropy_interaction=entropy_interaction,\n            )\n        else:\n            new_solution_model = type(solution_model)(\n                endmembers=endmembers,\n                energy_interaction=energy_interaction,\n                volume_interaction=volume_interaction,\n                entropy_interaction=entropy_interaction,\n                alphas=alphas,\n            )\n        new_solution = Solution(\n            name=name,\n            solution_model=new_solution_model,\n            molar_fractions=molar_fractions,\n        )\n        new_solution.parent = solution\n        new_solution.basis = new_basis\n        return new_solution",
  "def new_interactions(Q, n_mbrs):\n            return [\n                [\n                    float(\n                        (Q[i, j] + Q[j, i] - Q[i, i] - Q[j, j])\n                        * (alphas[i] + alphas[j])\n                        / 2.0\n                    )\n                    for j in range(i + 1, n_mbrs)\n                ]\n                for i in range(n_mbrs - 1)\n            ]",
  "def new_interactions(W, n_mbrs):\n            return [\n                [[W[i, j], W[j, i]] for j in range(i + 1, n_mbrs)]\n                for i in range(n_mbrs - 1)\n            ]",
  "def calculate_nakajima_fp_pv_partition_coefficient(\n    pressure, temperature, bulk_composition_mol, initial_distribution_coefficient\n):\n    \"\"\"\n    Calculate the partitioning of iron between periclase and bridgmanite as given\n    by Nakajima et al., 2012.\n\n    :param pressure: Equilibrium pressure [Pa]\n    :type pressure: float\n    :param temperature: Equilibrium temperature [K]\n    :type temperature: float\n    :param bulk_composition_mol: Bulk composition [mol].\n        Only Mg, Fe, and Si are assumed to explicitly affect the partitioning\n        with Al playing an implicit role.\n    :type bulk_composition_mol: dict\n    :param initial_distribution_coefficient: The distribution coefficient (Kd_0)\n        at 25 GPa and 0 K.\n    :type initial_distribution_coefficient: float\n\n    :returns: The proportion of Fe in ferropericlase and perovskite, respectively\n    :rtype: tuple\n    \"\"\"\n\n    norm = bulk_composition_mol[\"Mg\"] + bulk_composition_mol[\"Fe\"]\n    f_FeO = bulk_composition_mol[\"Fe\"] / norm\n    f_SiO2 = bulk_composition_mol[\"Si\"] / norm\n\n    Kd_0 = initial_distribution_coefficient\n    delV = 2.0e-7  # in m^3/mol, average taken from Nakajima et al 2012, JGR\n\n    # eq 5 Nakajima et al 2012, JGR. Solved for ln(K(P,T,X))\n    rs = ((25.0e9 - pressure) * delV / (constants.gas_constant * temperature)) + np.log(\n        Kd_0\n    )\n\n    # The exchange coefficent at P and T. K(P,T,X) in eq 5 Nakajima et al 2012\n    K = np.exp(rs)\n\n    # Solving equation 6 in Nakajima et al., 2012 for X_Fe_fp and X_Fe_pv\n    # Solved using the definition of the distribution coefficient\n    # to define X_Fe_fp as a function of X_Fe_pv\n\n    num_to_sqrt = (-4.0 * f_FeO * (K - 1.0) * K * f_SiO2) + (\n        pow(1.0 + (f_FeO * (K - 1)) + ((K - 1.0) * f_SiO2), 2.0)\n    )\n\n    X_Fe_pv = (\n        -1.0 + f_FeO - (f_FeO * K) + f_SiO2 - (f_SiO2 * K) + np.sqrt(num_to_sqrt)\n    ) / (2.0 * f_SiO2 * (1.0 - K))\n\n    X_Fe_fp = X_Fe_pv / (((1.0 - X_Fe_pv) * K) + X_Fe_pv)\n\n    return (X_Fe_fp, X_Fe_pv)",
  "def check_eos_consistency(\n    m, P=1.0e9, T=300.0, tol=1.0e-4, verbose=False, including_shear_properties=True\n):\n    \"\"\"\n    Checks that numerical derivatives of the Gibbs energy of a mineral\n    under given conditions are equal to those provided\n    analytically by the equation of state.\n\n    :param m: The mineral for which the equation of state\n        is to be checked for consistency.\n    :type m: :class:`burnman.Mineral`\n\n    :param P: The pressure at which to check consistency.\n    :type P: float\n\n    :param T: The temperature at which to check consistency.\n    :type T: float\n\n    :param tol: The fractional tolerance for each of the checks.\n    :type tol: float\n\n    :param verbose: Decide whether to print information about each check.\n    :type verbose: bool\n\n    :param including_shear_properties: Decide whether to check shear information,\n        which is pointless for liquids and equations of state\n        without shear modulus parameterizations.\n    :type including_shear_properties: bool\n\n    :returns: Boolean stating whether all checks have passed.\n    :rtype: bool\n    \"\"\"\n    dT = 1.0\n    dP = 1000.0\n\n    m.set_state(P, T)\n    G0 = m.gibbs\n    S0 = m.S\n    V0 = m.V\n\n    expr = [\"G = F + PV\", \"G = H - TS\", \"G = E - TS + PV\"]\n    eq = [\n        [m.gibbs, (m.helmholtz + P * m.V)],\n        [m.gibbs, (m.H - T * m.S)],\n        [m.gibbs, (m.molar_internal_energy - T * m.S + P * m.V)],\n    ]\n\n    m.set_state(P, T + dT)\n    G1 = m.gibbs\n    S1 = m.S\n    V1 = m.V\n\n    m.set_state(P + dP, T)\n    G2 = m.gibbs\n    V2 = m.V\n\n    # T derivatives\n    m.set_state(P, T + 0.5 * dT)\n    expr.extend([\"S = -dG/dT\", \"alpha = 1/V dV/dT\", \"C_p = T dS/dT\"])\n    eq.extend(\n        [\n            [m.S, -(G1 - G0) / dT],\n            [m.alpha, (V1 - V0) / dT / m.V],\n            [m.molar_heat_capacity_p, (T + 0.5 * dT) * (S1 - S0) / dT],\n        ]\n    )\n\n    # P derivatives\n    m.set_state(P + 0.5 * dP, T)\n    expr.extend([\"V = dG/dP\", \"K_T = -V dP/dV\"])\n    eq.extend([[m.V, (G2 - G0) / dP], [m.K_T, -0.5 * (V2 + V0) * dP / (V2 - V0)]])\n\n    expr.extend(\n        [\"C_v = Cp - alpha^2*K_T*V*T\", \"K_S = K_T*Cp/Cv\", \"gr = alpha*K_T*V/Cv\"]\n    )\n    eq.extend(\n        [\n            [\n                m.molar_heat_capacity_v,\n                m.molar_heat_capacity_p - m.alpha * m.alpha * m.K_T * m.V * T,\n            ],\n            [m.K_S, m.K_T * m.molar_heat_capacity_p / m.molar_heat_capacity_v],\n            [m.gr, m.alpha * m.K_T * m.V / m.molar_heat_capacity_v],\n        ]\n    )\n\n    expr.append(\"Vphi = np.sqrt(K_S/rho)\")\n    eq.append([m.bulk_sound_velocity, np.sqrt(m.K_S / m.rho)])\n\n    if including_shear_properties:\n        expr.extend([\"Vp = np.sqrt((K_S + 4G/3)/rho)\", \"Vs = np.sqrt(G_S/rho)\"])\n\n        with warnings.catch_warnings(record=True) as w:\n            warnings.simplefilter(\"always\")\n            eq.extend(\n                [\n                    [m.p_wave_velocity, np.sqrt((m.K_S + 4.0 * m.G / 3.0) / m.rho)],\n                    [m.shear_wave_velocity, np.sqrt(m.G / m.rho)],\n                ]\n            )\n            if len(w) == 1:\n                print(w[0].message)\n                print(\n                    \"\\nYou can suppress this message by setting the \"\n                    \"parameter\\nincluding_shear_properties to False \"\n                    \"when calling check_eos_consistency.\\n\"\n                )\n        note = \"\"\n    else:\n        note = \" (not including shear properties)\"\n\n    consistencies = [\n        np.abs(e[0] - e[1]) < np.abs(tol * e[1]) + np.finfo(\"float\").eps for e in eq\n    ]\n    eos_is_consistent = np.all(consistencies)\n\n    if verbose:\n        print(\"Checking EoS consistency for {0:s}{1}\".format(m.to_string(), note))\n        print(\"Expressions within tolerance of {0:2f}\".format(tol))\n        for i, c in enumerate(consistencies):\n            print(\"{0:10s} : {1:5s}\".format(expr[i], str(c)))\n        if eos_is_consistent:\n            print(\n                \"All EoS consistency constraints satisfied for {0:s}\".format(\n                    m.to_string()\n                )\n            )\n        else:\n            print(\n                \"Not satisfied all EoS consistency constraints for {0:s}\".format(\n                    m.to_string()\n                )\n            )\n\n    return eos_is_consistent",
  "def check_anisotropic_eos_consistency(m, P=1.0e9, T=2000.0, tol=1.0e-4, verbose=False):\n    \"\"\"\n    Checks that numerical derivatives of the Gibbs energy of an anisotropic mineral\n    under given conditions are equal to those provided\n    analytically by the equation of state.\n\n    :param m: The anisotropic mineral for which the equation of state\n        is to be checked for consistency.\n    :type m: :class:`burnman.AnisotropicMineral`\n\n    :param P: The pressure at which to check consistency.\n    :type P: float\n\n    :param T: The temperature at which to check consistency.\n    :type T: float\n\n    :param tol: The fractional tolerance for each of the checks.\n    :type tol: float\n\n    :param verbose: Decide whether to print information about each check.\n    :type verbose: bool\n\n    :returns: Boolean stating whether all checks have passed.\n    :rtype: bool\n    \"\"\"\n    dT = 1.0\n    dP = 1000.0\n\n    m.set_state(P, T)\n    G0 = m.gibbs\n    S0 = m.S\n    V0 = m.V\n\n    expr = [\"G = F + PV\", \"G = H - TS\", \"G = E - TS + PV\"]\n    eq = [\n        [m.gibbs, (m.helmholtz + P * m.V)],\n        [m.gibbs, (m.H - T * m.S)],\n        [m.gibbs, (m.molar_internal_energy - T * m.S + P * m.V)],\n    ]\n\n    m.set_state(P, T + dT)\n    G1 = m.gibbs\n    S1 = m.S\n    V1 = m.V\n\n    m.set_state(P + dP, T)\n    G2 = m.gibbs\n    V2 = m.V\n\n    # T derivatives\n    m.set_state(P, T + 0.5 * dT)\n    expr.extend([\"S = -dG/dT\", \"alpha = 1/V dV/dT\", \"C_p = T dS/dT\"])\n    eq.extend(\n        [\n            [m.S, -(G1 - G0) / dT],\n            [m.alpha, (V1 - V0) / dT / m.V],\n            [m.molar_heat_capacity_p, (T + 0.5 * dT) * (S1 - S0) / dT],\n        ]\n    )\n\n    # P derivatives\n    m.set_state(P + 0.5 * dP, T)\n    expr.extend([\"V = dG/dP\", \"K_T = -V dP/dV\"])\n    eq.extend(\n        [\n            [m.V, (G2 - G0) / dP],\n            [m.isothermal_bulk_modulus_reuss, -0.5 * (V2 + V0) * dP / (V2 - V0)],\n        ]\n    )\n\n    expr.extend([\"C_v = Cp - alpha^2*K_T*V*T\", \"K_S = K_T*Cp/Cv\"])\n    eq.extend(\n        [\n            [\n                m.molar_heat_capacity_v,\n                m.molar_heat_capacity_p - m.alpha * m.alpha * m.K_T * m.V * T,\n            ],\n            [\n                m.isentropic_bulk_modulus_reuss,\n                m.isothermal_bulk_modulus_reuss\n                * m.molar_heat_capacity_p\n                / m.molar_heat_capacity_v,\n            ],\n        ]\n    )\n\n    # Third derivative\n    m.set_state(P + 0.5 * dP, T)\n    b0 = m.isothermal_compressibility_tensor\n    F0 = m.deformation_gradient_tensor\n\n    m.set_state(P + 0.5 * dP, T + dT)\n    b1 = m.isothermal_compressibility_tensor\n    F1 = m.deformation_gradient_tensor\n\n    m.set_state(P, T + 0.5 * dT)\n    a0 = m.thermal_expansivity_tensor\n    F2 = m.deformation_gradient_tensor\n\n    m.set_state(P + dP, T + 0.5 * dT)\n    a1 = m.thermal_expansivity_tensor\n    F3 = m.deformation_gradient_tensor\n\n    m.set_state(P + 0.5 * dP, T + 0.5 * dT)\n\n    beta0 = -(logm(F3) - logm(F2)) / dP\n    alpha0 = (logm(F1) - logm(F0)) / dT\n\n    Q = m.deformed_coordinate_frame\n    beta1 = m.isothermal_compressibility_tensor\n    alpha1 = m.thermal_expansivity_tensor\n\n    beta1 = np.einsum(\"mi, nj, ij->mn\", Q, Q, beta1)\n    alpha1 = np.einsum(\"mi, nj, ij->mn\", Q, Q, alpha1)\n\n    expr.extend([f\"SI = -d(lnm(F))/dP ({i}{j})\" for i in range(3) for j in range(i, 3)])\n    eq.extend([[beta0[i, j], beta1[i, j]] for i in range(3) for j in range(i, 3)])\n\n    expr.extend(\n        [f\"alpha = d(lnm(F))/dT ({i}{j})\" for i in range(3) for j in range(i, 3)]\n    )\n    eq.extend([[alpha0[i, j], alpha1[i, j]] for i in range(3) for j in range(i, 3)])\n\n    expr.extend(\n        [f\"d(alpha)/dP = -d(beta_T)/dT ({i}{j})\" for i in range(3) for j in range(i, 3)]\n    )\n    eq.extend(\n        [\n            [(a1[i, j] - a0[i, j]) / dP, -(b1[i, j] - b0[i, j]) / dT]\n            for i in range(3)\n            for j in range(i, 3)\n        ]\n    )\n\n    # Consistent Phi\n    expr.extend([\"dPsidf_Voigt[:3,:3] == 1\"])\n    eq.extend(\n        [\n            [\n                np.sum(m.isothermal_compliance_tensor[:3, :3]),\n                m.isothermal_compressibility_reuss,\n            ]\n        ]\n    )\n\n    # Consistent inverses\n    expr.extend([f\"S_T = inv(C_T) ({i}{j})\" for i in range(6) for j in range(i, 6)])\n    S_T = m.isothermal_compliance_tensor\n    S_T2 = np.linalg.inv(m.isothermal_stiffness_tensor)\n    eq.extend([[S_T[i, j], S_T2[i, j]] for i in range(6) for j in range(i, 6)])\n\n    expr.extend([f\"S_N = inv(C_N) ({i}{j})\" for i in range(6) for j in range(i, 6)])\n    S_N = m.isentropic_compliance_tensor\n    S_N2 = np.linalg.inv(m.isentropic_stiffness_tensor)\n    eq.extend([[S_N[i, j], S_N2[i, j]] for i in range(6) for j in range(i, 6)])\n\n    # Consistent isotropic and anisotropic properties\n    expr.extend(\n        [\n            \"V = det(M)\",\n            \"alpha_v = tr(alpha)\",\n            \"beta_T = sum(S_T I)\",\n            \"beta_S = sum(S_S I)\",\n        ]\n    )\n    eq.extend(\n        [\n            [m.V, np.linalg.det(m.cell_vectors)],\n            [m.alpha, np.trace(m.thermal_expansivity_tensor)],\n            [m.beta_T, np.sum(m.isothermal_compliance_tensor[:3, :3])],\n            [m.beta_S, np.sum(m.isentropic_compliance_tensor[:3, :3])],\n        ]\n    )\n\n    expr.append(\"Vphi = np.sqrt(K_S/rho)\")\n    eq.append([m.bulk_sound_velocity, np.sqrt(m.K_S / m.rho)])\n\n    consistencies = [\n        np.abs(e[0] - e[1]) < np.abs(tol * e[1]) + np.finfo(\"float\").eps for e in eq\n    ]\n    eos_is_consistent = np.all(consistencies)\n\n    if verbose:\n        print(\"Checking EoS consistency for {0:s}\".format(m.to_string()))\n        print(\"Expressions within tolerance of {0:2f}\".format(tol))\n        for i, c in enumerate(consistencies):\n            print(\"{0:10s} : {1:5s}\".format(expr[i], str(c)))\n        if eos_is_consistent:\n            print(\n                \"All EoS consistency constraints satisfied for {0:s}\".format(\n                    m.to_string()\n                )\n            )\n        else:\n            print(\n                \"Not satisfied all EoS consistency constraints for {0:s}\".format(\n                    m.to_string()\n                )\n            )\n\n    return eos_is_consistent",
  "def calculate_constraints(assemblage, n_free_compositional_vectors):\n    \"\"\"\n    This function calculates the linear inequality constraints bounding\n    the valid parameter space for a given assemblage.\n\n    The constraints are as follows:\n\n      - Pressure and temperature must be positive\n      - All phase fractions must be positive\n      - All site-species occupancies must be positive\n\n    The constraints are stored in a vector (b) and matrix (A).\n    The sign convention is chosen such that the constraint is satisfied\n    if A.x + b < eps.\n\n    :param assemblage: The assemblage for which the constraints are calculated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :returns: The constraints vector and matrix.\n    :rtype: tuple\n    \"\"\"\n    bounds = []\n    n_constraints = 0\n    for i, n in enumerate(assemblage.endmembers_per_phase):\n        n_constraints += 1\n        if n == 1:\n            bounds.append(np.array([[]]))\n        else:\n            bounds.append(assemblage.phases[i].solution_model.endmember_occupancies)\n            n_constraints += len(bounds[-1][0])\n\n    c_vector = np.zeros((n_constraints + 2))\n    c_matrix = np.zeros(\n        (n_constraints + 2, assemblage.n_endmembers + 2 + n_free_compositional_vectors)\n    )  # includes P, T\n\n    c_matrix[0, 0] = -1  # P>0\n    c_matrix[1, 1] = -1  # T>0\n\n    cidx = 2  # index of current compositional constraint\n    pidx = 0  # starting index of current phase\n    for i, n in enumerate(assemblage.endmembers_per_phase):\n        m = len(bounds[i][0])\n        # The first endmember proportion is not a free variable\n        # (all endmembers in any solution must sum to one)\n        # Re-express the constraints without the first endmember\n        c_matrix[cidx, pidx + 2] = -1.0  # need phase proportions > 0\n        cidx += 1\n        if m != 0:\n            c_vector[cidx : cidx + m] = -bounds[i][0]\n            c_matrix[cidx : cidx + m, pidx + 1 + 2 : pidx + n + 2] = (\n                np.einsum(\"i, j\", bounds[i][0], np.ones_like(bounds[i][1:, 0]))\n                - bounds[i].T[:, 1:]\n            )\n            cidx += m\n        pidx += n\n\n    return c_vector, c_matrix",
  "def get_parameters(assemblage, n_free_compositional_vectors=0):\n    \"\"\"\n    Gets the starting parameters vector (x) for the current equilibrium problem.\n    These are:\n\n      - pressure\n      - temperature\n      - absolute amount of each phase. if a phase is a solution\n        with >1 endmember, the following parameters are the mole fractions\n        of the independent endmembers in the solution, except for the first\n        endmember (as the mole fractions must sum to one).\n\n    :param assemblage: The assemblage to be equilibrated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :returns: The current values of all the parameters.\n    :rtype: numpy.array\n    \"\"\"\n    params = np.zeros(assemblage.n_endmembers + 2 + n_free_compositional_vectors)\n    n_moles_phase = assemblage.n_moles * np.array(assemblage.molar_fractions)\n\n    try:\n        params[:2] = [assemblage.pressure, assemblage.temperature]\n    except AttributeError:\n        raise Exception(\"You need to set_state before getting parameters\")\n\n    j = 2\n    for i, ph in enumerate(assemblage.phases):\n        params[j] = n_moles_phase[i]\n        if isinstance(ph, Solution):\n            params[j + 1 : j + assemblage.endmembers_per_phase[i]] = assemblage.phases[\n                i\n            ].molar_fractions[1:]\n        j += assemblage.endmembers_per_phase[i]\n\n    return params",
  "def get_endmember_amounts(assemblage):\n    \"\"\"\n    Gets the absolute amounts of all the endmembers in the solution.\n\n    :param assemblage: The assemblage to be equilibrated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :returns: The current amounts of all the endmembers.\n    :rtype: numpy.array\n    \"\"\"\n    phase_amounts = assemblage.n_moles * assemblage.molar_fractions\n    amounts = np.empty(assemblage.n_endmembers)\n    j = 0\n    for i, ph in enumerate(assemblage.phases):\n        if isinstance(ph, Solution):\n            amounts[j : j + assemblage.endmembers_per_phase[i]] = (\n                phase_amounts[i] * assemblage.phases[i].molar_fractions\n            )\n        else:\n            amounts[j] = phase_amounts[i]\n        j += assemblage.endmembers_per_phase[i]\n\n    return amounts",
  "def set_compositions_and_state_from_parameters(assemblage, parameters):\n    \"\"\"\n    Sets the phase compositions, amounts and state of the assemblage\n    from a list of parameter values.\n\n    :param assemblage: The assemblage to be equilibrated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :param parameters: The current parameter values.\n    :type parameters: numpy.array\n    \"\"\"\n    assemblage.set_state(parameters[0], parameters[1])\n    i = 2\n    phase_amounts = np.zeros(len(assemblage.phases))\n    for phase_idx, ph in enumerate(assemblage.phases):\n        phase_amounts[phase_idx] = parameters[i]\n        if isinstance(ph, Solution):\n            n_mbrs = len(ph.endmembers)\n            f = [0.0] * n_mbrs\n            f[1:] = parameters[i + 1 : i + n_mbrs]\n            f[0] = 1.0 - sum(f)\n            ph.set_composition(f)\n            i += n_mbrs\n        else:\n            i += 1\n\n    assert np.all(phase_amounts > -1.0e-8)\n    phase_amounts = np.abs(phase_amounts)\n    assemblage.n_moles = sum(phase_amounts)\n    assemblage.set_fractions(phase_amounts / assemblage.n_moles)\n    return None",
  "def F(\n    x,\n    assemblage,\n    equality_constraints,\n    reduced_composition_vector,\n    reduced_free_composition_vectors,\n):\n    \"\"\"\n    The vector-valued function for which the root is sought.\n    The first two vector values depend on the\n    equality_constraints chosen. For example, if\n      - eq[i][0] = 'P', F[i] = P - eq[i][1]\n      - eq[i][0] = 'T', F[i] = T - eq[i][1]\n      - eq[i][0] = 'S', F[i] = entropy - eq[i][1]\n      - eq[i][0] = 'V', F[i] = volume - eq[i][1]\n      - eq[i][0] = 'PT_ellipse', F[i] = norm(([P, T] - eq[i][1][0])/eq[i][1][1]) - 1\n      - eq[i][0] = 'X', np.dot(eq[i][1][0], x) - eq[i][1][1]\n\n    The next set of vector values correspond to the reaction affinities.\n    The final set of vector values correspond to the bulk\n    composition constraints.\n\n    :param x: Parameter values for the equilibrium problem to be solved.\n    :type x: numpy array\n\n    :param assemblage: The assemblage to be equilibrated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :param equality_constraints: A list of the equality constraints\n        (see above for valid formats).\n    :type equality_constraints: list of lists\n\n    :param reduced_composition_vector: The amounts of the independent\n        elements.\n    :type reduced_composition_vector: numpy.array\n\n    :param reduced_free_composition_vectors: The amounts of the\n        independent elements in each of the free_compositional_vectors.\n    :type reduced_free_composition_vectors: 2D numpy.array\n\n    :returns: The vector corresponding to F(x).\n    :rtype: numpy.array\n    \"\"\"\n\n    set_compositions_and_state_from_parameters(assemblage, x)\n    new_endmember_amounts = get_endmember_amounts(assemblage)\n\n    # We want to find the root of the following equations\n    n_equality_constraints = len(equality_constraints)\n    eqns = np.zeros((assemblage.n_endmembers + n_equality_constraints))\n    i = 0\n    for i, (type_c, eq_c) in enumerate(equality_constraints):\n        if type_c == \"P\":\n            eqns[i] = x[0] - eq_c\n        elif type_c == \"T\":\n            eqns[i] = x[1] - eq_c\n        elif type_c == \"S\":\n            eqns[i] = assemblage.molar_entropy * assemblage.n_moles - eq_c\n        elif type_c == \"V\":\n            eqns[i] = assemblage.molar_volume * assemblage.n_moles - eq_c\n        elif type_c == \"PT_ellipse\":\n            v_scaled = (x[0:2] - eq_c[0]) / eq_c[1]\n            eqns[i] = np.linalg.norm(v_scaled) - 1.0\n        elif type_c == \"X\":\n            eqns[i] = np.dot(eq_c[0], x) - eq_c[1]  # i.e. Ax = b\n        else:\n            raise Exception(\"constraint type not recognised\")\n    i += 1\n    if n_equality_constraints > 2:\n        new_reduced_composition_vector = reduced_composition_vector + x[\n            2 - n_equality_constraints :\n        ].dot(reduced_free_composition_vectors)\n    else:\n        new_reduced_composition_vector = reduced_composition_vector\n    eqns[i : i + assemblage.n_reactions] = assemblage.reaction_affinities\n    eqns[i + assemblage.n_reactions :] = (\n        np.dot(assemblage.reduced_stoichiometric_array.T, new_endmember_amounts)\n        - new_reduced_composition_vector\n    )\n    return eqns",
  "def jacobian(x, assemblage, equality_constraints, reduced_free_composition_vectors):\n    \"\"\"\n    The Jacobian of the vector-valued function :math:`F` for which the\n    root is sought (:math:`\\\\partial F / \\\\partial x`).\n    See documentation for :func:`F` and :func:`get_parameters`\n    (which return :math:`F` and :math:`x` respectively) for more details.\n\n    :param x: Parameter values for the equilibrium problem to be solved.\n    :type x: numpy.array\n\n    :param assemblage: The assemblage to be equilibrated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :param equality_constraints: A list of the equality constraints\n        (see documentation for :func:`burnman.tools.equilbration.F`).\n    :type equality_constraints: list of lists\n\n    :param reduced_free_composition_vectors: The amounts of the\n        independent elements in each of the free_compositional_vectors.\n    :type reduced_free_composition_vectors: 2D numpy array\n\n    :returns: The Jacobian for the equilibrium problem.\n    :rtype: 2D numpy.array\n\n    \"\"\"\n    # The solver always calls the Jacobian with the same\n    # x parameters as used previously for the root functions\n    # Therefore we don't need to set compositions or state again here.\n\n    # First, we find out the effect of the two constraint parameters F[:2]\n    # on the pressure (x[0]) and temperature (x[1]):\n    n_equality_constraints = len(equality_constraints)\n    jacobian = np.zeros(\n        (\n            assemblage.n_endmembers + n_equality_constraints,\n            assemblage.n_endmembers + n_equality_constraints,\n        )\n    )\n    ic = 0\n    for ic, (type_c, eq_c) in enumerate(equality_constraints):\n        if type_c == \"P\":  # dP/dx\n            jacobian[ic, 0] = 1.0  # jacobian[i, j!=0] = 0\n        elif type_c == \"T\":  # dT/dx\n            jacobian[ic, 1] = 1.0  # jacobian[i, j!=1] = 0\n        elif type_c == \"S\":  # dS/dx\n            # dS/dP = -aV, dS/dT = Cp/T\n            jacobian[ic, 0:2] = [\n                -assemblage.n_moles * assemblage.alpha * assemblage.molar_volume,\n                assemblage.n_moles * assemblage.molar_heat_capacity_p / x[1],\n            ]\n            j = 2\n            for k, n in enumerate(assemblage.endmembers_per_phase):\n                jacobian[ic, j] = assemblage.phases[k].molar_entropy\n                if n > 1:  # for solutions with >1 endmember\n                    jacobian[ic, j + 1 : j + n] = (\n                        assemblage.n_moles\n                        * assemblage.molar_fractions[k]\n                        * (\n                            assemblage.phases[k].partial_entropies[1:]\n                            - assemblage.phases[k].partial_entropies[0]\n                        )\n                    )\n                j += n\n        elif type_c == \"V\":  # dV/dx\n            # dV/dP = -V/K_T, dV/dT = aV\n            jacobian[ic, 0:2] = [\n                -assemblage.n_moles * assemblage.molar_volume / assemblage.K_T,\n                assemblage.n_moles * assemblage.molar_volume,\n            ]\n            j = 2\n            for k, n in enumerate(assemblage.endmembers_per_phase):\n                jacobian[ic, j] = assemblage.phases[k].molar_volume\n                if n > 1:  # for solutions with >1 stable endmember\n                    jacobian[ic, j + 1 : j + n] = (\n                        assemblage.n_moles\n                        * assemblage.molar_fractions[k]\n                        * (\n                            assemblage.phases[k].partial_volumes[1:]\n                            - assemblage.phases[k].partial_volumes[0]\n                        )\n                    )\n                j += n\n        elif type_c == \"PT_ellipse\":\n            v_scaled = (x[0:2] - eq_c[0]) / eq_c[1]\n            jacobian[ic, 0:2] = v_scaled / (np.linalg.norm(v_scaled) * eq_c[1])\n        elif type_c == \"X\":\n            jacobian[ic, :] = eq_c[0]\n        else:\n            raise Exception(\"constraint type not recognised\")\n    ic += 1\n\n    # Next, let's get the effect of pressure and temperature\n    # on each of the independent reactions\n    # i.e. dF(i, reactions)/dx[0] and dF(i, reactions)/dx[1]\n    partial_volumes_vector = np.zeros((assemblage.n_endmembers))\n    partial_entropies_vector = np.zeros((assemblage.n_endmembers))\n    j = 0\n    for i, n in enumerate(assemblage.endmembers_per_phase):\n        if n == 1:  # for endmembers\n            partial_volumes_vector[j] = assemblage.phases[i].molar_volume\n            partial_entropies_vector[j] = assemblage.phases[i].molar_entropy\n        else:  # for solutions\n            partial_volumes_vector[j : j + n] = assemblage.phases[i].partial_volumes\n            partial_entropies_vector[j : j + n] = assemblage.phases[i].partial_entropies\n        j += n\n    reaction_volumes = np.dot(assemblage.reaction_basis, partial_volumes_vector)\n    reaction_entropies = np.dot(assemblage.reaction_basis, partial_entropies_vector)\n\n    # dGi/dP = deltaVi; dGi/dT = -deltaSi\n    jacobian[ic : ic + len(reaction_volumes), 0] = reaction_volumes\n    jacobian[ic : ic + len(reaction_volumes), 1] = -reaction_entropies\n\n    # Pressure and temperature have no effect on the bulk\n    # compositional constraints\n    # i.e. dF(i, bulk)/dx[0] and dF(i, bulk)/dx[1] = 0\n\n    # Finally, let's build the compositional Hessian d2G/dfidfj = dmui/dfj\n    # where fj is the fraction of endmember j in a phase\n    phase_amounts = np.array(assemblage.molar_fractions) * assemblage.n_moles\n    comp_hessian = np.zeros((assemblage.n_endmembers, assemblage.n_endmembers))\n    dfi_dxj = np.zeros((assemblage.n_endmembers, assemblage.n_endmembers))\n    dpi_dxj = np.zeros((assemblage.n_endmembers, assemblage.n_endmembers))\n    j = 0\n    for i, n in enumerate(assemblage.endmembers_per_phase):\n        if n == 1:\n            # changing the amount (p) of a pure phase\n            # does not change its fraction in that phase,\n            # so dfi_dxj remains unchanged\n            dpi_dxj[j, j] = 1.0\n        else:\n            comp_hessian[j : j + n, j : j + n] = assemblage.phases[i].gibbs_hessian\n\n            # x[0] = p(phase) and x[1:] = f[1:] - f[0]\n            # Therefore\n            # df[0]/dx[0] = 0\n            # df[0]/dx[1:] = -1\n            # (because changing the fraction of any endmember\n            # depletes the fraction of the first endmember)\n            # df[1:]/dx[1:] = 1 on diagonal, 0 otherwise\n            # (because all other fractions are independent of each other)\n            dfi_dxj[j : j + n, j : j + n] = np.eye(n)\n            dfi_dxj[j, j : j + n] -= 1.0\n            # Total amounts of endmembers (p) are the fractions\n            # multiplied by the amounts of their representative phases\n            dpi_dxj[j : j + n, j : j + n] = (\n                dfi_dxj[j : j + n, j : j + n] * phase_amounts[i]\n            )\n            # The derivative of the amount of each endmember with respect\n            # to the amount of each phase is equal to the molar fractions\n            # of the endmembers.\n            dpi_dxj[j : j + n, j] = assemblage.phases[i].molar_fractions\n        j += n\n\n    # dfi_dxj converts the endmember hessian to the parameter hessian.\n    reaction_hessian = assemblage.reaction_basis.dot(comp_hessian).dot(dfi_dxj)\n    bulk_hessian = assemblage.reduced_stoichiometric_array.T.dot(dpi_dxj)\n\n    if reaction_hessian.shape[0] > 0:\n        jacobian[ic:, 2 : 2 + len(reaction_hessian[0])] = np.concatenate(\n            (reaction_hessian, bulk_hessian)\n        )\n    else:\n        jacobian[ic:, 2 : 2 + len(bulk_hessian[0])] = bulk_hessian\n\n    if len(reduced_free_composition_vectors) > 0:\n        jacobian[\n            -reduced_free_composition_vectors.shape[1] :, 2 + len(reaction_hessian[0]) :\n        ] = -reduced_free_composition_vectors.T\n\n    return jacobian",
  "def lambda_bounds(dx, x, endmembers_per_phase):\n    \"\"\"\n    Returns the lambda bounds for the damped affine invariant modification\n    to Newton's method for nonlinear problems (Deuflhard, 1974;1975;2004).\n\n    :param dx: The proposed newton step.\n    :type dx: numpy.array\n\n    :param x: Parameter values for the equilibrium problem to be solved.\n    :type x: numpy.array\n\n    :param endmembers_per_phase: A list of the number of endmembers in each phase.\n    :type endmembers_per_phase: list of int\n\n    :returns: Minimum and maximum allowed fractions of the full newton step (dx).\n    :rtype: tuple of floats\n    \"\"\"\n\n    max_steps = np.ones((len(x))) * 100000.0\n\n    # first two constraints are P and T\n    max_steps[0:2] = [20.0e9, 500.0]  # biggest reasonable P and T steps\n\n    j = 2\n    for i, n in enumerate(endmembers_per_phase):\n        # if the phase fraction constraint would be broken,\n        # set a step that is marginally smaller\n        if x[j] + dx[j] < 0.0:\n            max_steps[j] = max(x[j] * 0.999, 0.001)\n        max_steps[j + 1 : j + n] = [\n            max(xi * 0.99, 0.01) for xi in x[j + 1 : j + n]\n        ]  # maximum compositional step\n        j += n\n\n    max_lmda = min(\n        [\n            1.0 if step <= max_steps[i] else max_steps[i] / step\n            for i, step in enumerate(np.abs(dx))\n        ]\n    )\n\n    return (1.0e-8, max_lmda)",
  "def phase_fraction_constraints(phase, assemblage, fractions, prm):\n    \"\"\"\n    Converts a phase fraction constraint into standard linear form\n    that can be processed by the root finding problem.\n\n    We start with a single fraction or an array of fractions\n    for a particular phase (:math:`n_p / \\\\sum n = f`).\n    These are then converted into the \"X\" form of constraint\n    by multiplying by :math:`\\\\sum n` and moving all terms to\n    the LHS of the equation:\n\n    :math:`-f n_0 - f n_1 - \\\\ldots + (1-f) n_p - \\\\ldots = 0`\n\n    This form is less readable, but easier to use as a constraint\n    in a nonlinear solve.\n\n    :param phase: The phase for which the fraction is to be constrained\n    :type phase: :class:`burnman.Solution` or :class:`burnman.Mineral`\n\n    :param assemblage: The assemblage to be equilibrated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :param fractions: The phase fractions to be satified at equilibrium.\n    :type fractions: numpy.array\n\n    :param prm: A tuple with attributes n_parameters\n        (the number of parameters for the current equilibrium problem)\n        and phase_amount_indices (the indices of the parameters that\n        correspond to phase amounts).\n    :type prm: namedtuple\n\n    :returns: The phase fraction constraints.\n    :rtype: list\n    \"\"\"\n    phase_idx = assemblage.phases.index(phase)\n\n    constraints = []\n    for fraction in fractions:\n        constraints.append([\"X\", [np.zeros((prm.n_parameters)), 0.0]])\n        constraints[-1][-1][0][prm.phase_amount_indices] = -fraction\n        constraints[-1][-1][0][prm.phase_amount_indices[phase_idx]] += 1.0\n\n    return constraints",
  "def phase_composition_constraints(phase, assemblage, constraints, prm):\n    \"\"\"\n    Converts a phase composition constraint into standard linear form\n    that can be processed by the root finding problem.\n\n    We start with constraints in the form (site_names, n, d, v), where\n    :math:`(n x)/ (d x) = v` and :math:`n` and :math:`d` are fixed vectors of\n    site coefficients. So, one could for example choose a constraint\n    ([Mg_A, Fe_A], [1., 0.], [1., 1.], [0.5]) which would\n    correspond to equal amounts Mg and Fe on the A site.\n\n    This function converts the user-defined vectors of site constraints\n    :math:`n` and :math:`d` into vectors of endmember proportion\n    constraints :math:`n'` and :math:`d'`, such that\n    :math:`(n' x)/ (d' x) = v`. This is done via linear transformation\n    using the site occupancy matrix provided by :class:`burnman.Solution`.\n    By multiplying by the denominator, we have the following scalar\n    comparison: :math:`(n' x) = v (d' x)`\n\n    The equilibration function does not use the proportion of\n    the first endmember (as the endmember proportions must sum to one),\n    and so we split :math:`x`, :math:`n'` and :math:`d'` into the first\n    element and following elements:\n    :math:`(n'_0 x_0 + n'_i x_i) = v (d'_0 x_0 + d'_i x_i)`\n    where :math:`i` is taken over all elements apart from the first.\n\n    With some more rearranging we can express the constraint in standard\n    linear form:\n    :math:`(n'_0 (1 - \\\\sum_j x_j) + n'_i x_i) = v (d'_0 (1 - \\\\sum_j x_j) + d'_i x_i)`\n\n    :math:`(n'_0 + (n'_i - 1_i n'_0) x_i) = v (d'_0 + (d'_i - 1_i d'_0) x_i)`\n\n    :math:`(((n'_i - 1_i n'_0) - v(d'_i - 1_i d'_0)) x_i) = (v d'_0 - n'_0)`\n\n    This form is less readable, but easier to use as a constraint\n    in a nonlinear solve.\n\n    :param phase: The phase for which the composition is to be constrained.\n    :type phase: :class:`burnman.Solution`\n\n    :param assemblage: The assemblage to be equilibrated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :param constraints: The desired constraints in the form:\n        site_names (list of strings), numerator (numpy.array),\n        denominator (numpy.array), values (numpy.array).\n    :type constraints: tuple\n\n    :returns: The phase composition constraints in standard form.\n    :rtype: list\n    \"\"\"\n    phase_idx = assemblage.phases.index(phase)\n\n    site_names, numerator, denominator, values = constraints\n    site_indices = [phase.solution_model.site_names.index(name) for name in site_names]\n    noccs = phase.solution_model.endmember_noccupancies\n\n    # Converts site constraints into endmember constraints\n    # Ends up with shape (n_endmembers, 2)\n    endmembers = np.dot(noccs[:, site_indices], np.array([numerator, denominator]).T)\n\n    numer0, denom0 = endmembers[0]\n    endmembers -= endmembers[0]\n    numer, denom = endmembers.T[:, 1:]\n\n    # We start from the correct index\n    start_idx = sum(assemblage.endmembers_per_phase[:phase_idx]) + 3\n    n_indices = assemblage.endmembers_per_phase[phase_idx] - 1\n\n    x_constraints = []\n    for v in values:\n        f = v * denom0 - numer0\n        x_constraints.append([\"X\", [np.zeros((prm.n_parameters)), f]])\n        x_constraints[-1][1][0][start_idx : start_idx + n_indices] = numer - v * denom\n\n    return x_constraints",
  "def get_equilibration_parameters(assemblage, composition, free_compositional_vectors):\n    \"\"\"\n    Builds a named tuple containing the parameter names and\n    various other parameters needed by the equilibrium solve.\n\n    :param assemblage: The assemblage to be equilibrated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :param composition: The bulk composition for the equilibrium problem.\n    :type composition: dict\n\n    :param free_compositional_vectors: The bulk compositional\n        degrees of freedom for the equilibrium problem.\n    :type free_compositional_vectors: list of dictionaries\n\n    :returns: A tuple with attributes n_parameters\n        (the number of parameters for the current equilibrium problem)\n        and phase_amount_indices (the indices of the parameters that\n        correspond to phase amounts).\n    :rtype: namedtuple\n    \"\"\"\n    # Initialize a named tuple for the equilibration parameters\n    prm = namedtuple(\"assemblage_parameters\", [])\n\n    # Process parameter names\n    prm.parameter_names = [\"Pressure (Pa)\", \"Temperature (K)\"]\n    for i, n in enumerate(assemblage.endmembers_per_phase):\n        prm.parameter_names.append(\"x({0})\".format(assemblage.phases[i].name))\n        if n > 1:\n            p_names = [\n                \"p({0} in {1})\".format(n, assemblage.phases[i].name)\n                for n in assemblage.phases[i].endmember_names[1:]\n            ]\n            prm.parameter_names.extend(p_names)\n\n    n_free_compositional_vectors = len(free_compositional_vectors)\n    for i in range(n_free_compositional_vectors):\n        prm.parameter_names.append(f\"v_{i}\")\n\n    prm.n_parameters = len(prm.parameter_names)\n    prm.phase_amount_indices = [\n        i for i in range(len(prm.parameter_names)) if \"x(\" in prm.parameter_names[i]\n    ]\n\n    # Find the bulk composition vector\n    prm.bulk_composition_vector = np.array(\n        [composition[e] for e in assemblage.elements]\n    )\n\n    if n_free_compositional_vectors > 0:\n        prm.free_compositional_vectors = np.array(\n            [\n                [\n                    free_compositional_vectors[i][e]\n                    if e in free_compositional_vectors[i]\n                    else 0.0\n                    for e in assemblage.elements\n                ]\n                for i in range(n_free_compositional_vectors)\n            ]\n        )\n    else:\n        prm.free_compositional_vectors = np.empty((0, len(assemblage.elements)))\n\n    if assemblage.compositional_null_basis.shape[0] != 0:\n        if (\n            np.abs(\n                assemblage.compositional_null_basis.dot(prm.bulk_composition_vector)[0]\n            )\n            > 1.0e-12\n        ):\n            raise Exception(\n                \"The bulk composition is not within the \"\n                \"compositional space of the assemblage\"\n            )\n\n    prm.reduced_composition_vector = prm.bulk_composition_vector[\n        assemblage.independent_element_indices\n    ]\n    prm.reduced_free_composition_vectors = prm.free_compositional_vectors[\n        :, assemblage.independent_element_indices\n    ]\n    prm.constraint_vector, prm.constraint_matrix = calculate_constraints(\n        assemblage, n_free_compositional_vectors\n    )\n    return prm",
  "def process_eq_constraints(equality_constraints, assemblage, prm):\n    \"\"\"\n    A function that processes the equality constraints\n    into a form that can be processed by the F and jacobian functions.\n\n    This function has two main tasks: it turns phase_fraction and\n    phase_composition constraints into standard linear constraints in the\n    solution parameters. It also turns vector-valued constraints into a\n    list of scalar-valued constraints.\n\n    :param equality_constraints: A list of equality constraints.\n        For valid types of constraints, please see the documentation for\n        :func:`burnman.equilibrate`.\n    :type equality_constraints: list\n\n    :param assemblage: The assemblage to be equilibrated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :param prm: A tuple with attributes n_parameters\n        (the number of parameters for the current equilibrium problem)\n        and phase_amount_indices (the indices of the parameters that\n        correspond to phase amounts).\n    :type prm: namedtuple\n\n    :returns: Equality constraints in a form that can be processed\n        by the F and jacobian functions.\n    :rtype: list of lists\n    \"\"\"\n    eq_constraint_lists = []\n    for i in range(len(equality_constraints)):\n        if equality_constraints[i][0] == \"phase_fraction\":\n            phase = equality_constraints[i][1][0]\n            fraction = equality_constraints[i][1][1]\n            if isinstance(fraction, float):\n                fraction = np.array([fraction])\n            if not isinstance(fraction, np.ndarray):\n                raise Exception(\n                    \"The constraint fraction in equality {0} \"\n                    \"should be a float or numpy array\".format(i + 1)\n                )\n            eq_constraint_lists.append(\n                phase_fraction_constraints(phase, assemblage, fraction, prm)\n            )\n        elif equality_constraints[i][0] == \"phase_composition\":\n            phase = equality_constraints[i][1][0]\n            constraint = equality_constraints[i][1][1]\n            if isinstance(constraint[3], float):\n                constraint = (\n                    constraint[0],\n                    constraint[1],\n                    constraint[2],\n                    np.array([constraint[3]]),\n                )\n            if not isinstance(constraint[3], np.ndarray):\n                raise Exception(\n                    \"The last constraint parameter in equality \"\n                    \"{0} should be a float \"\n                    \"or numpy array\".format(i + 1)\n                )\n\n            eq_constraint_lists.append(\n                phase_composition_constraints(phase, assemblage, constraint, prm)\n            )\n        elif equality_constraints[i][0] == \"X\":\n            constraint = equality_constraints[i][1]\n            if isinstance(constraint[-1], float):\n                constraint = (constraint[0], np.array([constraint[-1]]))\n            if not isinstance(constraint[-1], np.ndarray):\n                raise Exception(\n                    \"The last constraint parameter in \"\n                    \"equality {0} should be \"\n                    \"a float or numpy array\".format(i + 1)\n                )\n\n            eq_constraint_lists.append(\n                [[\"X\", [constraint[0], p]] for p in constraint[1]]\n            )\n\n        elif (\n            equality_constraints[i][0] == \"P\"\n            or equality_constraints[i][0] == \"T\"\n            or equality_constraints[i][0] == \"PT_ellipse\"\n            or equality_constraints[i][0] == \"S\"\n            or equality_constraints[i][0] == \"V\"\n        ):\n            if isinstance(equality_constraints[i][1], float):\n                equality_constraints[i] = (\n                    equality_constraints[i][0],\n                    np.array([equality_constraints[i][1]]),\n                )\n            if not isinstance(equality_constraints[i][1], np.ndarray):\n                raise Exception(\n                    \"The last parameter in \"\n                    f\"equality_constraint[{i+1}] should be a \"\n                    \"float or numpy array\"\n                )\n            eq_constraint_lists.append(\n                [[equality_constraints[i][0], p] for p in equality_constraints[i][1]]\n            )\n        else:\n            raise Exception(\n                \"The type of equality_constraint is \"\n                \"not recognised for constraint {0}.\\n\"\n                \"Should be one of P, T, S, V, X,\\n\"\n                \"PT_ellipse, phase_fraction, \"\n                \"or phase_composition.\".format(i + 1)\n            )\n    return eq_constraint_lists",
  "def equilibrate(\n    composition,\n    assemblage,\n    equality_constraints,\n    free_compositional_vectors=[],\n    tol=1.0e-3,\n    store_iterates=False,\n    store_assemblage=True,\n    max_iterations=100.0,\n    verbose=False,\n):\n    \"\"\"\n    A function that finds the thermodynamic equilibrium state of an\n    assemblage subject to given equality constraints by solving a set of\n    nonlinear equations related to the chemical potentials and\n    other state variables of the system.\n\n    The user chooses an assemblage (e.g. olivine, garnet and orthopyroxene)\n    and :math:`2+n_c` equality constraints, where :math:`n_c` is the number of\n    bulk compositional degrees of freedom. The equilibrate function attempts to\n    find the remaining unknowns that satisfy those constraints.\n\n    There are a number of equality constraints implemented in burnman. These are\n    given as a list of lists. Each constraint should have the form:\n    [<constraint type>, <constraint>], where\n    <constraint type> is one of 'P', 'T', 'S', 'V', 'X', 'PT_ellipse',\n    'phase_fraction', or 'phase_composition'. The format of the\n    <constraint> object depends on the constraint type:\n        - P: float or numpy.array of\n            pressures [Pa]\n        - T: float or numpy.array of\n            temperatures [K]\n        - S: float or numpy.array of\n            entropies [J/K]\n        - V: float or numpy.array of\n            volumes [m:math:`^3`]\n        - PT_ellipse: list of two floats or numpy.arrays, where the equality\n            satifies the equation norm(([P, T] - arr[0])/arr[1]) = 1\n        - phase_fraction: tuple with the form (<phase> <fraction(s)>),\n            where <phase> is one of the phase objects in the assemblage\n            and <fraction(s)> is a float or numpy.array corresponding\n            to the desired phase fractions.\n        - phase_composition: tuple with the form (<phase> <constraint>),\n            where <phase> is one of the phase objects in the assemblage\n            and <constraint> has the form (site_names, n, d, v),\n            where :math:`(nx)/(dx) = v`, n and d are constant vectors of\n            site coefficients, and v is a float or numpy.array. For example,\n            a constraint of the form ([Mg_A, Fe_A], [1., 0.], [1., 1.], [0.5])\n            would correspond to equal amounts Mg and Fe on the A site\n            (Mg_A / (Mg_A + Fe_A) = 0.5).\n        - X: list of a numpy.array and a float or numpy.array,\n            where the equality satisfies the linear equation arr[0] x = arr[1].\n            The first numpy.array is fixed, and the second is to be looped over\n            by the equilibrate function.\n            This is a generic compositional equality constraint.\n\n    :param composition: The bulk composition that the assemblage must satisfy.\n    :type composition: dict\n\n    :param assemblage: The assemblage to be equilibrated.\n    :type assemblage: :class:`burnman.Composite`\n\n    :param equality_constraints: The list of equality constraints. See above\n        for valid formats.\n    :type equality_constraints: list of list\n\n    :param free_compositional_vectors: A list of dictionaries containing\n        the compositional freedom of the solution. For example, if the list\n        contains the vector {'Mg': 1., 'Fe': -1}, that implies that the bulk\n        composition is equal to composition + :math:`a` (n_Mg - n_Fe),\n        where the value of :math:`a` is to be determined by the solve.\n        Vector given in atomic (molar) units of elements.\n    :type free_compositional_vectors: list of dict\n\n    :param tol: The tolerance for the nonlinear solver.\n    :type tol: float\n\n    :param store_iterates: Whether to store the parameter values for\n        each iteration in each solution object.\n    :type store_iterates: bool\n\n    :param store_assemblage: Whether to store a copy of the assemblage\n        object in each solution object.\n    :type store_assemblage: bool\n\n    :param max_iterations: The maximum number of iterations for the\n        nonlinear solver.\n    :type max_iterations: int\n\n    :param verbose: Whether to print output updating the user on the status of\n        equilibration.\n    :type verbose: bool\n\n    :returns: Solver solution object (or a list, or a 2D list of solution objects)\n        created by :func:`burnman.optimize.nonlinear_solvers.damped_newton_solve`,\n        and a namedtuple object created by\n        :func:`burnman.tools.equilibration.get_equilibration_parameters`. See\n        documentation of these functions for the return types. If store_assemblage\n        is True, each solution object also has an attribute called `assemblage`,\n        which contains a copy of the input assemblage with the equilibrated\n        properties. So, for a 2D grid of solution objects, one could call either\n        sols[0][1].x[0] or sols[0][1].assemblage.pressure to get the pressure.\n    :rtype: tuple\n    \"\"\"\n    for ph in assemblage.phases:\n        if isinstance(ph, Solution) and not hasattr(ph, \"molar_fractions\"):\n            raise Exception(\n                f\"set_composition for solution {ph} before running equilibrate.\"\n            )\n\n    if assemblage.molar_fractions is None:\n        n_phases = len(assemblage.phases)\n        f = 1.0 / float(n_phases)\n        assemblage.set_fractions([f for i in range(n_phases)])\n\n    assemblage.n_moles = sum(composition.values()) / sum(assemblage.formula.values())\n\n    n_equality_constraints = len(equality_constraints)\n    n_free_compositional_vectors = len(free_compositional_vectors)\n\n    if n_equality_constraints != n_free_compositional_vectors + 2:\n        raise Exception(\n            \"The number of equality constraints \"\n            f\"(currently {n_equality_constraints}) \"\n            \"must be two more than the number of \"\n            \"free_compositional vectors \"\n            f\"(currently {n_free_compositional_vectors}).\"\n        )\n\n    for v in free_compositional_vectors:\n        if np.abs(sum(v.values())) > 1.0e-12:\n            raise Exception(\n                \"The amounts of each free_compositional_vector\" \"must sum to zero\"\n            )\n\n    # Make parameter tuple\n    prm = get_equilibration_parameters(\n        assemblage, composition, free_compositional_vectors\n    )\n\n    # Check equality constraints have the correct structure\n    # Convert into the format readable by the function and jacobian functions\n    eq_constraint_lists = process_eq_constraints(equality_constraints, assemblage, prm)\n\n    # Set up solves\n    nc = [len(eq_constraint_list) for eq_constraint_list in eq_constraint_lists]\n\n    # Find the initial state (could be none here)\n    initial_state = [assemblage.pressure, assemblage.temperature]\n\n    # Reset initial state if equality constraints\n    # are related to pressure or temperature\n    for i in range(n_equality_constraints):\n        if eq_constraint_lists[i][0][0] == \"P\":\n            initial_state[0] = eq_constraint_lists[i][0][1]\n        elif eq_constraint_lists[i][0][0] == \"T\":\n            initial_state[1] = eq_constraint_lists[i][0][1]\n        elif eq_constraint_lists[i][0][0] == \"PT_ellipse\":\n            initial_state = eq_constraint_lists[i][0][1][1]\n\n    if initial_state[0] is None:\n        initial_state[0] = 5.0e9\n    if initial_state[1] is None:\n        initial_state[1] = 1200.0\n\n    assemblage.set_state(*initial_state)\n    parameters = get_parameters(assemblage, n_free_compositional_vectors)\n\n    # Solve the system of equations, loop over input parameters\n    sol_array = np.empty(shape=tuple(nc), dtype=\"object\")\n\n    # Loop over problems\n    problems = list(product(*[list(range(nc[i])) for i in range(len(nc))]))\n    n_problems = len(problems)\n    for i_problem, i_c in enumerate(problems):\n        if verbose:\n            string = \"Processing solution\"\n            for i in range(len(i_c)):\n                string += \" {0}/{1}\".format(i_c[i] + 1, nc[i])\n\n            print(string + \":\")\n\n        equality_constraints = [eq_constraint_lists[i][i_c[i]] for i in range(len(nc))]\n\n        # Set the initial fractions and compositions\n        # of the phases in the assemblage:\n        sol = damped_newton_solve(\n            F=lambda x: F(\n                x,\n                assemblage,\n                equality_constraints,\n                prm.reduced_composition_vector,\n                prm.reduced_free_composition_vectors,\n            ),\n            J=lambda x: jacobian(\n                x,\n                assemblage,\n                equality_constraints,\n                prm.reduced_free_composition_vectors,\n            ),\n            lambda_bounds=lambda dx, x: lambda_bounds(\n                dx, x, assemblage.endmembers_per_phase\n            ),\n            guess=parameters,\n            linear_constraints=(prm.constraint_matrix, prm.constraint_vector),\n            tol=tol,\n            store_iterates=store_iterates,\n            max_iterations=max_iterations,\n        )\n\n        if sol.success and len(assemblage.reaction_affinities) > 0.0:\n            maxres = np.max(np.abs(assemblage.reaction_affinities)) + 1.0e-5\n            assemblage.equilibrium_tolerance = maxres\n\n        if store_assemblage:\n            sol.assemblage = assemblage.copy()\n            if sol.success and len(assemblage.reaction_affinities) > 0.0:\n                sol.assemblage.equilibrium_tolerance = maxres\n\n        if verbose:\n            print(sol.text)\n\n        sol_array[i_c] = sol\n\n        # Next, we use the solution values and Jacobian\n        # to provide a starting guess for the next problem.\n        # First, we find the equality constraints for the next problem\n        if i_problem < n_problems - 1:\n            next_i_c = problems[i_problem + 1]\n\n            next_equality_constraints = [\n                eq_constraint_lists[i][next_i_c[i]] for i in range(len(nc))\n            ]\n\n            # We use the nearest solutions as potential starting points\n            # to make the next guess\n            prev_sols = []\n            for i in range(len(nc)):\n                if next_i_c[i] != 0:\n                    prev_i_c = np.copy(next_i_c)\n                    prev_i_c[i] -= 1\n                    prev_sols.append(sol_array[tuple(prev_i_c)])\n\n            updated_params = False\n            for s in prev_sols:\n                if s.success and not updated_params:\n                    # next guess based on a Newton step\n                    # using the old solution vector and Jacobian\n                    # with the new constraints.\n                    dF = F(\n                        s.x,\n                        assemblage,\n                        next_equality_constraints,\n                        prm.reduced_composition_vector,\n                        prm.reduced_free_composition_vectors,\n                    )\n                    luJ = lu_factor(s.J)\n                    new_parameters = s.x + lu_solve(luJ, -dF)\n                    c = (\n                        prm.constraint_matrix.dot(new_parameters)\n                        + prm.constraint_vector\n                    )\n                    if all(c <= 0.0):  # accept new guess\n                        parameters = new_parameters\n                    else:  # use the parameters from this step\n                        parameters = s.x\n                        exhausted_phases = [\n                            assemblage.phases[phase_idx].name\n                            for phase_idx, v in enumerate(\n                                new_parameters[prm.phase_amount_indices]\n                            )\n                            if v < 0.0\n                        ]\n                        if len(exhausted_phases) > 0 and verbose:\n                            print(\n                                \"A phase might be exhausted before the \"\n                                f\"next step: {exhausted_phases}\"\n                            )\n\n                    updated_params = True\n\n    # Finally, make dimensions of sol_array equal the input dimensions\n    if np.product(sol_array.shape) > 1:\n        sol_array = np.squeeze(sol_array)\n    else:\n        sol_array = sol_array.flatten()[0]\n\n    return sol_array, prm",
  "def fugacity(standard_material, assemblage):\n    \"\"\"\n    Calculates the fugacity of a standard material in another assemblage.\n\n    .. note:: set_method and set_state should already have been\n        used on both assemblages.\n\n    :param standard_material: Standard material for which to calculate the fugacity.\n        The material must have a formula as a dictionary parameter.\n    :type assemblage: :class:`burnman.Material`\n\n    :param assemblage: Assemblage for which to calculate the fugacity.\n    :type assemblage: :class:`burnman.Composite`\n\n    :returns: Value of the fugacity of the component with respect to\n        the standard material.\n    :rtype: float\n    \"\"\"\n    component_formula = standard_material.params[\"formula\"]\n    chemical_potential = assemblage.chemical_potential([component_formula])[0]\n\n    fugacity = np.exp(\n        (chemical_potential - standard_material.gibbs)\n        / (constants.gas_constant * assemblage.temperature)\n    )\n    return fugacity",
  "def relative_fugacity(component_formula, assemblage, reference_assemblage):\n    \"\"\"\n    Calculates the fugacity of a chemical component in one assemblage\n    relative to another one.\n\n    .. note:: set_method and set_state should already have been\n        used on both assemblages.\n\n    :param component_formula: Chemical formula for which to compute the\n        relative fugacity.\n    :type component_formula: dictionary\n\n    :param assemblage: Assemblage for which to calculate the fugacity.\n    :type assemblage: :class:`burnman.Composite`\n\n    :param reference_assemblage: Reference assemblage against which to\n        measure the fugacity.\n    :type reference_assemblage: :class:`burnman.Composite`\n\n    :returns: Value of the fugacity of the component in the assemblage\n        with respect to the reference_assemblage.\n    :rtype: float\n    \"\"\"\n    chemical_potential = assemblage.chemical_potential([component_formula])[0]\n    reference_chemical_potential = reference_assemblage.chemical_potential(\n        [component_formula]\n    )[0]\n\n    relative_fugacity = np.exp(\n        (chemical_potential - reference_chemical_potential)\n        / (constants.gas_constant * assemblage.temperature)\n    )\n    return relative_fugacity",
  "def equilibrium_pressure(\n    minerals, stoichiometry, temperature, pressure_initial_guess=1.0e5\n):\n    \"\"\"\n    Given a list of minerals, their reaction stoichiometries\n    and a temperature of interest, compute the\n    equilibrium pressure of the reaction.\n\n    :param minerals: List of minerals involved in the reaction.\n    :type minerals: list of :class:`burnman.Mineral`\n\n    :param stoichiometry: Reaction stoichiometry for the minerals provided.\n        Reactants and products should have the opposite signs [mol].\n    :type stoichiometry: list of floats\n\n    :param temperature: Temperature of interest [K].\n    :type temperature: float\n\n    :param pressure_initial_guess: Initial pressure guess [Pa].\n    :type pressure_initial_guess: float\n\n    :returns: The equilibrium pressure of the reaction [Pa].\n    :rtype: float\n    \"\"\"\n\n    def eqm(P, T):\n        gibbs = 0.0\n        for i, mineral in enumerate(minerals):\n            mineral.set_state(P[0], T)\n            gibbs = gibbs + mineral.gibbs * stoichiometry[i]\n        return gibbs\n\n    pressure = fsolve(eqm, [pressure_initial_guess], args=(temperature))[0]\n\n    return pressure",
  "def equilibrium_temperature(\n    minerals, stoichiometry, pressure, temperature_initial_guess=1000.0\n):\n    \"\"\"\n    Given a list of minerals, their reaction stoichiometries\n    and a pressure of interest, compute the\n    equilibrium temperature of the reaction.\n\n    :param minerals: List of minerals involved in the reaction.\n    :type minerals: list of :class:`burnman.Mineral`\n\n    :param stoichiometry: Reaction stoichiometry for the minerals provided.\n        Reactants and products should have the opposite signs [mol].\n    :type stoichiometry: list of floats\n\n    :param pressure: Pressure of interest [Pa].\n    :type pressure: float\n\n    :param temperature_initial_guess: Initial temperature guess [K].\n    :type temperature_initial_guess: float\n\n    :returns: The equilibrium temperature of the reaction [K].\n    :rtype: float\n    \"\"\"\n\n    def eqm(T, P):\n        gibbs = 0.0\n        for i, mineral in enumerate(minerals):\n            mineral.set_state(P, T[0])\n            gibbs = gibbs + mineral.gibbs * stoichiometry[i]\n        return gibbs\n\n    temperature = fsolve(eqm, [temperature_initial_guess], args=(pressure))[0]\n\n    return temperature",
  "def invariant_point(\n    minerals_r1,\n    stoichiometry_r1,\n    minerals_r2,\n    stoichiometry_r2,\n    pressure_temperature_initial_guess=[1.0e9, 1000.0],\n):\n    \"\"\"\n    Given a list of minerals, their reaction stoichiometries\n    and a pressure of interest, compute the\n    equilibrium temperature of the reaction.\n\n    :param minerals: List of minerals involved in the reaction.\n    :type minerals: list of :class:`burnman.Mineral`\n\n    :param stoichiometry: Reaction stoichiometry for the minerals provided.\n        Reactants and products should have the opposite signs [mol].\n    :type stoichiometry: list of floats\n\n    :param pressure: Pressure of interest [Pa].\n    :type pressure: float\n\n    :param temperature_initial_guess: Initial temperature guess [K].\n    :type temperature_initial_guess: float\n\n    :returns: The equilibrium temperature of the reaction [K].\n    :rtype: float\n    \"\"\"\n\n    def eqm(PT):\n        P, T = PT\n        gibbs_r1 = 0.0\n        for i, mineral in enumerate(minerals_r1):\n            mineral.set_state(P, T)\n            gibbs_r1 = gibbs_r1 + mineral.gibbs * stoichiometry_r1[i]\n        gibbs_r2 = 0.0\n        for i, mineral in enumerate(minerals_r2):\n            mineral.set_state(P, T)\n            gibbs_r2 = gibbs_r2 + mineral.gibbs * stoichiometry_r2[i]\n        return [gibbs_r1, gibbs_r2]\n\n    pressure, temperature = fsolve(eqm, pressure_temperature_initial_guess)\n    return pressure, temperature",
  "def hugoniot(mineral, P_ref, T_ref, pressures, reference_mineral=None):\n    \"\"\"\n    Calculates the temperatures (and volumes) along a Hugoniot\n    as a function of pressure according to the Hugoniot equation\n    U2-U1 = 0.5*(p2 - p1)(V1 - V2) where U and V are the\n    internal energies and volumes (mass or molar) and U = F + TS\n\n    :param mineral:  Mineral for which the Hugoniot is to be calculated.\n    :type mineral: :class:`burnman.Mineral`\n\n    :param P_ref: Reference pressure [Pa]\n    :type P_ref: float\n\n    :param T_ref:  Reference temperature [K]\n    :type T_ref: float\n\n    :param pressures: Set of pressures [Pa] for which the Hugoniot temperature\n        and volume should be calculated.\n    :type pressures: numpy.array of floats\n\n    :param reference_mineral: Mineral which is stable at the reference conditions\n        Provides an alternative U_0 and V_0 when the reference\n        mineral transforms to the mineral of interest at some\n        (unspecified) pressure.\n    :type reference_mineral: :class:`burnman.Mineral`\n\n    :returns: The Hugoniot temperatures and volumes at the given pressures.\n    :rtype: tuple of numpy.arrays\n    \"\"\"\n\n    def Ediff(T, mineral, P, P_ref, U_ref, V_ref):\n        mineral.set_state(P, T[0])\n        U = mineral.helmholtz + T[0] * mineral.S\n        V = mineral.V\n\n        return (U - U_ref) - 0.5 * (P - P_ref) * (V_ref - V)\n\n    if reference_mineral is None:\n        reference_mineral = mineral\n\n    reference_mineral.set_state(P_ref, T_ref)\n    U_ref = reference_mineral.helmholtz + T_ref * reference_mineral.S\n    V_ref = reference_mineral.V\n\n    temperatures = np.empty_like(pressures)\n    volumes = np.empty_like(pressures)\n\n    for i, P in enumerate(pressures):\n        temperatures[i] = fsolve(\n            Ediff, [T_ref], args=(mineral, P, P_ref, U_ref, V_ref)\n        )[0]\n        volumes[i] = mineral.V\n\n    return temperatures, volumes",
  "def reactions_from_stoichiometric_matrix(stoichiometric_matrix):\n    \"\"\"\n    Returns a list of all the balanced reactions between compounds\n    of fixed chemical composition. Includes both the forward and\n    reverse reactions\n    (so there will always be an even number of reactions).\n\n    :param stoichiometric_matrix: An array of the stoichiometric\n        (molar) amounts of component j in compound i.\n    :type stoichiometric_matrix: 2D numpy array\n\n    :returns: An array of the stoichiometric (molar) amounts of\n        compound j in reaction i.\n    :rtype: 2D numpy array\n    \"\"\"\n    n_components = stoichiometric_matrix.shape[1]\n\n    equalities = np.concatenate(([np.zeros(n_components)], stoichiometric_matrix)).T\n\n    polys = [\n        MaterialPolytope(equalities, np.diag(v))\n        for v in itertools.product(*[[-1, 1]] * len(equalities[0]))\n    ]\n    reactions = []\n    for p in polys:\n        v = np.array([[value for value in v] for v in p.raw_vertices])\n\n        if v is not []:\n            reactions.extend(v)\n\n    reactions = np.unique(np.array(reactions, dtype=float), axis=0)\n\n    reactions = np.array(\n        [[Rational(value).limit_denominator(1000000) for value in v] for v in reactions]\n    )\n\n    assert np.max(reactions[:-1, 0]) == 0\n    assert np.max(reactions[-1, 1:]) == 0\n    reactions = reactions[:-1, 1:]\n    return reactions",
  "def reactions_from_formulae(formulae, compound_names, return_strings=True):\n    \"\"\"\n    Returns a list of all the balanced reactions between compounds\n    of fixed chemical composition. Includes both the forward and\n    reverse reactions\n    (so there will always be an even number of reactions).\n\n    :param formulae: List of the chemical formulae, either as strings or\n        as a list of dictionaries of elements.\n    :type formulae: list of dictionaries or list of strings\n\n    :param compound_names: List of the compound names in the formula list.\n    :type compound_names: list of strings\n\n    :param return_strings: Whether to return the reactions as strings or array.\n    :type return_strings: bool\n\n    :returns: Either a 2D array of the stoichiometric (molar) amounts of\n        compound j in reaction i, or a list of strings.\n        The parameter compound_names is only used if strings\n        are requested.\n    :rtype: 2D numpy array or list of strings\n    \"\"\"\n    if isinstance(formulae[0], str):\n        dict_formulae = [dictionarize_formula(f) for f in formulae]\n    else:\n        dict_formulae = formulae\n    stoichiometric_matrix, elements = compositional_array(dict_formulae)\n    R = reactions_from_stoichiometric_matrix(stoichiometric_matrix)\n    if return_strings:\n        return reaction_matrix_as_strings(R, compound_names)\n    else:\n        return R",
  "def eqm(P, T):\n        gibbs = 0.0\n        for i, mineral in enumerate(minerals):\n            mineral.set_state(P[0], T)\n            gibbs = gibbs + mineral.gibbs * stoichiometry[i]\n        return gibbs",
  "def eqm(T, P):\n        gibbs = 0.0\n        for i, mineral in enumerate(minerals):\n            mineral.set_state(P, T[0])\n            gibbs = gibbs + mineral.gibbs * stoichiometry[i]\n        return gibbs",
  "def eqm(PT):\n        P, T = PT\n        gibbs_r1 = 0.0\n        for i, mineral in enumerate(minerals_r1):\n            mineral.set_state(P, T)\n            gibbs_r1 = gibbs_r1 + mineral.gibbs * stoichiometry_r1[i]\n        gibbs_r2 = 0.0\n        for i, mineral in enumerate(minerals_r2):\n            mineral.set_state(P, T)\n            gibbs_r2 = gibbs_r2 + mineral.gibbs * stoichiometry_r2[i]\n        return [gibbs_r1, gibbs_r2]",
  "def Ediff(T, mineral, P, P_ref, U_ref, V_ref):\n        mineral.set_state(P, T[0])\n        U = mineral.helmholtz + T[0] * mineral.S\n        V = mineral.V\n\n        return (U - U_ref) - 0.5 * (P - P_ref) * (V_ref - V)",
  "def solution_polytope_from_charge_balance(\n    charges, charge_total, return_fractions=False\n):\n    \"\"\"\n    Creates a polytope object from a list of the charges for each species on\n    each site and the total charge for all site-species.\n\n    :param charges: 2D list containing the total charge for species j on site i,\n        including the site multiplicity. So, for example,\n        a solution with the site formula [Mg,Fe]3[Mg,Al,Si]2Si3O12 would\n        have the following list: [[6., 6.], [4., 6., 8.]].\n    :type charges: 2D list of floats\n    :param charge_total: The total charge for all site-species per formula unit.\n        The example given above would have charge_total = 12.\n    :type charge_total: float\n    :param return_fractions: Determines whether the created polytope object returns its\n        attributes (such as endmember occupancies) as fractions or as floats.\n        Default is False.\n    :type return_fractions: bool\n\n    :returns: A polytope object corresponding to the parameters provided.\n    :rtype: :class:`burnman.polytope.MaterialPolytope` object\n    \"\"\"\n    n_sites = len(charges)\n    all_charges = np.concatenate(charges)\n    n_site_elements = len(all_charges)\n    equalities = np.empty((n_sites + 1, n_site_elements + 1))\n    equalities[:-1, 0] = -1\n    i = 0\n    for i_site, site_charges in enumerate(charges):\n        equalities[i_site, 1:] = [\n            1 if (j >= i and j < i + len(site_charges)) else 0\n            for j in range(n_site_elements)\n        ]\n        i += len(site_charges)\n\n    equalities[-1, 0] = -charge_total\n    equalities[-1, 1:] = all_charges\n\n    pos_constraints = np.concatenate(\n        (np.zeros((len(equalities[0]) - 1, 1)), np.identity(len(equalities[0]) - 1)),\n        axis=1,\n    )\n    return MaterialPolytope(\n        equalities, pos_constraints, return_fractions=return_fractions\n    )",
  "def solution_polytope_from_endmember_occupancies(\n    endmember_occupancies, return_fractions=False\n):\n    \"\"\"\n    Creates a polytope object from a list of independent endmember occupancies.\n\n    :param endmember_occupancies: 2D list containing the\n        site-species occupancies j for endmember i.\n        So, for example, a solution with independent endmembers\n        [Mg]3[Al]2Si3O12, [Mg]3[Mg0.5Si0.5]2Si3O12, [Fe]3[Al]2Si3O12\n        might have the following array:\n        [[1., 0., 1., 0., 0.],\n        [1., 0., 0., 0.5, 0.5],\n        [0., 1., 1., 0., 0.]],\n        where the order of site-species is Mg_A, Fe_A, Al_B, Mg_B, Si_B.\n    :type endmember_occupancies: 2D numpy array\n\n    :param return_fractions: Determines whether the created polytope object\n        returns its attributes (such as endmember occupancies) as fractions\n        or as floats.\n    :type return_fractions: bool\n\n    :returns: A polytope object corresponding to the parameters provided.\n    :rtype: :class:`burnman.polytope.MaterialPolytope` object\n    \"\"\"\n    n_sites = sum(endmember_occupancies[0])\n    n_occs = endmember_occupancies.shape[1]\n\n    nullspace = np.array(Matrix(endmember_occupancies).nullspace(), dtype=float)\n\n    equalities = np.zeros((len(nullspace) + 1, n_occs + 1))\n    equalities[0, 0] = -n_sites\n    equalities[0, 1:] = 1\n\n    if len(nullspace) > 0:\n        try:\n            equalities[1:, 1:] = nullspace\n        except ValueError:\n            equalities[1:, 1:] = nullspace[:, :, 0]\n\n    pos_constraints = np.concatenate(\n        (np.zeros((len(equalities[0]) - 1, 1)), np.identity(len(equalities[0]) - 1)),\n        axis=1,\n    )\n\n    return MaterialPolytope(\n        equalities,\n        pos_constraints,\n        return_fractions=return_fractions,\n        independent_endmember_occupancies=endmember_occupancies,\n    )",
  "def composite_polytope_at_constrained_composition(\n    composite, composition, return_fractions=False\n):\n    \"\"\"\n    Creates a polytope object from a Composite object and a composition.\n    This polytope describes the complete set of valid composite\n    endmember amounts that satisfy the compositional constraints.\n\n    :param composite: A composite containing one or more Solution and Mineral objects.\n    :type composite: :class:`burnman.Composite` object\n\n    :param composition: A dictionary containing the amounts of each element.\n    :type composition: dict\n\n    :param return_fractions: Determines whether the created polytope object returns its\n        attributes (such as endmember occupancies) as fractions or as floats.\n    :type return_fractions: bool\n\n\n    :returns: A polytope object corresponding to the parameters provided.\n    :rtype: :class:`burnman.polytope.MaterialPolytope` object\n    \"\"\"\n    c_array = np.empty((composite.n_elements, 1))\n    c_array[:, 0] = [\n        -composition[e] if e in composition else 0.0 for e in composite.elements\n    ]\n\n    equalities = np.concatenate((c_array, composite.stoichiometric_array.T), axis=1)\n\n    eoccs = []\n    for i, ph in enumerate(composite.phases):\n        if isinstance(ph, Solution):\n            eoccs.append(ph.solution_model.endmember_occupancies.T)\n        else:\n            eoccs.append(np.ones((1, 1)))\n\n    eoccs = block_diag(*eoccs)\n    inequalities = np.concatenate((np.zeros((len(eoccs), 1)), eoccs), axis=1)\n\n    return MaterialPolytope(\n        equalities, inequalities, number_type=\"float\", return_fractions=return_fractions\n    )",
  "def simplify_composite_with_composition(composite, composition):\n    \"\"\"\n    Takes a composite and a composition, and returns the simplest composite\n    object that spans the solution space at the given composition.\n\n    For example, if the composition is given as {'Mg': 2., 'Si': 1.5, 'O': 5.},\n    and the composite is given as a mix of Mg,Fe olivine and pyroxene\n    solutions, this function will return a composite that only contains\n    the Mg-bearing endmembers.\n\n    :param composite: The initial Composite object.\n    :type composite: :class:`burnman.Composite` object\n\n    :param composition: A dictionary containing the amounts of each element.\n    :type composition: dict\n\n    :returns: The simplified Composite object\n    :rtype: :class:`burnman.Composite` object\n    \"\"\"\n    polytope = composite_polytope_at_constrained_composition(\n        composite, composition, return_fractions=True\n    )\n\n    composite_changed = False\n    new_phases = []\n    mbr_amounts = polytope.endmember_occupancies\n    i = 0\n    for i_ph, n_mbrs in enumerate(composite.endmembers_per_phase):\n        ph = composite.phases[i_ph]\n\n        amounts = mbr_amounts[:, i : i + n_mbrs].astype(float)\n        i += n_mbrs\n\n        rank = np.linalg.matrix_rank(amounts, tol=1.0e-8)\n\n        if rank < n_mbrs:\n            if isinstance(ph, Solution) and rank > 0:\n                if len(amounts) > 1:\n                    c_mean = np.mean(amounts, axis=0)\n                else:\n                    c_mean = amounts[0]\n\n                poly = solution_polytope_from_endmember_occupancies(\n                    ph.solution_model.endmember_occupancies\n                )\n                dmbrs = poly.endmembers_as_independent_endmember_amounts\n\n                x = cp.Variable(dmbrs.shape[0])\n                objective = cp.Minimize(cp.sum_squares(x))\n                constraints = [dmbrs.T @ x == c_mean, x >= 0]\n\n                prob = cp.Problem(objective, constraints)\n                prob.solve()\n\n                mbr_indices = np.argsort(x.value)[::-1]\n                ind_indices = [i for i in mbr_indices if x.value[i] > 1.0e-6]\n                new_basis = dmbrs[ind_indices]\n\n                # And now reduce the new basis if necessary\n                new_basis = new_basis[independent_row_indices(new_basis)]\n\n                if len(new_basis) < ph.n_endmembers:\n                    logging.info(\n                        f\"Phase {i_ph} ({ph.name}) is \"\n                        \"rank-deficient ({rank} < {n_mbrs}). \"\n                        \"The transformed solution is described \"\n                        f\"using {len(new_basis)} endmembers.\"\n                    )\n\n                    composite_changed = True\n                    soln = transform_solution_to_new_basis(ph, new_basis)\n                    new_phases.append(soln)\n                else:\n                    logging.info(\n                        \"This solution is rank-deficient \"\n                        f\"({rank} < {n_mbrs}), \"\n                        \"but its composition requires all \"\n                        \"independent endmembers.\"\n                    )\n            else:\n                composite_changed = True\n                logging.info(\n                    f\"Phase {i_ph} ({ph.name}) removed from \" \"composite (rank = 0).\"\n                )\n        else:\n            new_phases.append(ph)\n\n    if composite_changed:\n        return Composite(new_phases)\n    else:\n        return composite",
  "def pretty_plot():\n    \"\"\"\n    Makes pretty plots. Overwrites the matplotlib default settings to allow\n    for better fonts. Slows down plotting\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    plt.rc(\"text\", usetex=True)\n    plt.rcParams[\"text.latex.preamble\"] = \"\\\\usepackage{relsize}\"\n    plt.rc(\"font\", family=\"sanserif\")",
  "def plot_projected_elastic_properties(\n    mineral, plot_types, axes, n_zenith=31, n_azimuth=91, n_divs=100\n):\n    \"\"\"\n    :param mineral: Mineral object on which calculations should be done\n    :type mineral: :class:`burnman.Mineral`\n\n    :param plot_types: Plot types must be one of the following\n        * 'vp' - V$_{P}$ (km/s)\n        * 'vs1' - 'V$_{S1}$ (km/s)\n        * 'vs2' - V$_{S2}$ (km/s)\n        * 'vp/vs1' - V$_{P}$/V$_{S1}$\n        * 'vp/vs2' - V$_{P}$/V$_{S2}$\n        * 's anisotropy' - S-wave anisotropy (%), 200(vs1s - vs2s)/(vs1s + vs2s))\n        * 'linear compressibility' - Linear compressibility (GPa$^{-1}$)\n        * 'youngs modulus' - Youngs Modulus (GPa)\n    :type plot_types: list of str\n\n    :param axes: axes objects to be modified.\n        Must be initialised with projection='polar'.\n    :type axes: matplotlib.pyplot.axes objects\n\n    :param n_zenith: Number of zeniths (plot resolution).\n    :type n_zenith: int\n\n    :param n_azimuth: Number of azimuths (plot resolution).\n    :type n_azimuth: int\n\n    :param n_divs: Number of divisions for the color scale.\n    :type n_divs: int\n    \"\"\"\n\n    assert len(plot_types) == len(axes)\n\n    zeniths = np.linspace(np.pi / 2.0, np.pi, n_zenith)\n    azimuths = np.linspace(0.0, 2.0 * np.pi, n_azimuth)\n    Rs = np.sin(zeniths) / (1.0 - np.cos(zeniths))\n    r, theta = np.meshgrid(Rs, azimuths)\n\n    vps = np.empty_like(r)\n    vs1s = np.empty_like(r)\n    vs2s = np.empty_like(r)\n    betas = np.empty_like(r)\n    Es = np.empty_like(r)\n    for i, az in enumerate(azimuths):\n        for j, phi in enumerate(zeniths):\n            d = np.array(\n                [np.cos(az) * np.sin(phi), np.sin(az) * np.sin(phi), -np.cos(phi)]\n            )  # change_hemispheres\n            velocities = mineral.wave_velocities(d)\n            betas[i][j] = mineral.isentropic_linear_compressibility(d)\n            Es[i][j] = mineral.isentropic_youngs_modulus(d)\n            vps[i][j] = velocities[0][0]\n            vs1s[i][j] = velocities[0][1]\n            vs2s[i][j] = velocities[0][2]\n\n    prps = []\n    for type in plot_types:\n        if type == \"vp\":\n            prps.append((\"V$_{P}$ (km/s)\", vps / 1000.0))\n        elif type == \"vs1\":\n            prps.append((\"V$_{S1}$ (km/s)\", vs1s / 1000.0))\n        elif type == \"vs2\":\n            prps.append((\"V$_{S2}$ (km/s)\", vs2s / 1000.0))\n        elif type == \"vp/vs1\":\n            prps.append((\"V$_{P}$/V$_{S1}$\", vps / vs1s))\n        elif type == \"vp/vs2\":\n            prps.append((\"V$_{P}$/V$_{S2}$\", vps / vs2s))\n        elif type == \"s anisotropy\":\n            prps.append(\n                (\"S-wave anisotropy (%)\", 200.0 * (vs1s - vs2s) / (vs1s + vs2s))\n            )\n        elif type == \"linear compressibility\":\n            prps.append((\"Linear compressibility (GPa$^{-1}$)\", betas * 1.0e9))\n        elif type == \"youngs modulus\":\n            prps.append((\"Youngs Modulus (GPa)\", Es / 1.0e9))\n        else:\n            raise Exception(\"plot_type not recognised.\")\n\n    contour_sets = []\n    ticks = []\n    lines = []\n    for i, prp in enumerate(prps):\n        title, item = prp\n\n        axes[i].set_title(title)\n\n        vmin = np.min(item)\n        vmax = np.max(item)\n        spacing = np.power(10.0, np.floor(np.log10(vmax - vmin)))\n        nt = int((vmax - vmin - vmax % spacing + vmin % spacing) / spacing)\n        if nt == 1:\n            spacing = spacing / 4.0\n        elif nt < 4:\n            spacing = spacing / 2.0\n        elif nt > 8:\n            spacing = spacing * 2.0\n\n        tmin = vmin + (spacing - vmin % spacing)\n        tmax = vmax - vmax % spacing\n        nt = int((tmax - tmin) / spacing + 1)\n\n        ticks.append(np.linspace(tmin, tmax, nt))\n        contour_sets.append(\n            axes[i].contourf(\n                theta, r, item, n_divs, cmap=plt.cm.jet_r, vmin=vmin, vmax=vmax\n            )\n        )\n        lines.append(\n            axes[i].contour(\n                theta, r, item, ticks[-1], colors=(\"black\",), linewidths=(1,)\n            )\n        )\n        axes[i].set_yticks([100])\n\n    return contour_sets, ticks, lines",
  "class fo(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fo\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2172590.0,\n            \"S_0\": 95.1,\n            \"V_0\": 4.366e-05,\n            \"Cp\": [233.3, 0.001494, -603800.0, -1869.7],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 128500e6,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "class fa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fa\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1477720.0,\n            \"S_0\": 151.0,\n            \"V_0\": 4.631e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.82e-05,\n            \"K_0\": 125600e6,\n            \"Kprime_0\": 4.68,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "class teph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"teph\",\n            \"formula\": {\"Mn\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1733970.0,\n            \"S_0\": 155.9,\n            \"V_0\": 4.899e-05,\n            \"Cp\": [219.6, 0.0, -1292700.0, -1308.3],\n            \"a_0\": 2.86e-05,\n            \"K_0\": 125600e6,\n            \"Kprime_0\": 4.68,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2019591,\n        }\n        Mineral.__init__(self)",
  "class lrn(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lrn\",\n            \"formula\": {\"Ca\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2306920.0,\n            \"S_0\": 127.6,\n            \"V_0\": 5.16e-05,\n            \"Cp\": [247.5, -0.003206, 0.0, -2051.9],\n            \"a_0\": 2.9e-05,\n            \"K_0\": 98500e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1722391,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1710.0,\n                    \"S_D\": 10.03,\n                    \"V_D\": 5e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class mont(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mont\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2251260.0,\n            \"S_0\": 109.5,\n            \"V_0\": 5.148e-05,\n            \"Cp\": [250.7, -0.010433, -797200.0, -1996.1],\n            \"a_0\": 2.87e-05,\n            \"K_0\": 113400e6,\n            \"Kprime_0\": 3.87,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1564661,\n        }\n        Mineral.__init__(self)",
  "class chum(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"chum\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 9.0, \"O\": 18.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9613540.0,\n            \"S_0\": 440.5,\n            \"V_0\": 0.00019801,\n            \"Cp\": [1071.0, -0.016533, -7899600.0, -7373.9],\n            \"a_0\": 3.2e-05,\n            \"K_0\": 119900e6,\n            \"Kprime_0\": 4.58,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 33.0,\n            \"molar_mass\": 0.62109208,\n        }\n        Mineral.__init__(self)",
  "class chdr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"chdr\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 5.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5254890.0,\n            \"S_0\": 260.0,\n            \"V_0\": 0.00011084,\n            \"Cp\": [625.0, -0.001088, -2259900.0, -4910.7],\n            \"a_0\": 1.82e-05,\n            \"K_0\": 116100e6,\n            \"Kprime_0\": 4.8,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.33970588,\n        }\n        Mineral.__init__(self)",
  "class mwd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mwd\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2138520.0,\n            \"S_0\": 93.9,\n            \"V_0\": 4.051e-05,\n            \"Cp\": [208.7, 0.003942, -1709500.0, -1302.8],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 172600e6,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "class fwd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fwd\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1467900.0,\n            \"S_0\": 146.0,\n            \"V_0\": 4.321e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 169000e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "class mrw(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mrw\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2127680.0,\n            \"S_0\": 90.0,\n            \"V_0\": 3.949e-05,\n            \"Cp\": [213.3, 0.00269, -1410400.0, -1495.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 178100e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "class frw(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"frw\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1471760.0,\n            \"S_0\": 140.0,\n            \"V_0\": 4.203e-05,\n            \"Cp\": [166.8, 0.04261, -1705400.0, -541.4],\n            \"a_0\": 2.22e-05,\n            \"K_0\": 197700e6,\n            \"Kprime_0\": 4.92,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "class mpv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mpv\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1443030.0,\n            \"S_0\": 62.6,\n            \"V_0\": 2.445e-05,\n            \"Cp\": [149.3, 0.002918, -2983000.0, -799.1],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 251000e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "class fpv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fpv\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1084640.0,\n            \"S_0\": 91.0,\n            \"V_0\": 2.548e-05,\n            \"Cp\": [133.2, 0.01083, -3661400.0, -314.7],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 281000e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1319287,\n        }\n        Mineral.__init__(self)",
  "class apv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"apv\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1646630.0,\n            \"S_0\": 51.8,\n            \"V_0\": 2.54e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 203000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "class cpv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cpv\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1541730.0,\n            \"S_0\": 73.5,\n            \"V_0\": 2.745e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 236000e6,\n            \"Kprime_0\": 3.9,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "class mak(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mak\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1490870.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 211000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "class fak(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fak\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1142140.0,\n            \"S_0\": 91.5,\n            \"V_0\": 2.76e-05,\n            \"Cp\": [100.3, 0.013328, -4364900.0, 419.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 218000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1319287,\n        }\n        Mineral.__init__(self)",
  "class maj(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"maj\",\n            \"formula\": {\"Mg\": 4.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6050400.0,\n            \"S_0\": 255.2,\n            \"V_0\": 0.00011457,\n            \"Cp\": [713.6, -0.000997, -1158200.0, -6622.3],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 160000e6,\n            \"Kprime_0\": 4.56,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4015548,\n        }\n        Mineral.__init__(self)",
  "class py(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"py\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6281960.0,\n            \"S_0\": 269.5,\n            \"V_0\": 0.00011313,\n            \"Cp\": [633.5, 0.0, -5196100.0, -4315.2],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 174300e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4031273,\n        }\n        Mineral.__init__(self)",
  "class alm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"alm\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5260700.0,\n            \"S_0\": 342.0,\n            \"V_0\": 0.00011525,\n            \"Cp\": [677.3, 0.0, -3772700.0, -5044.0],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 190000e6,\n            \"Kprime_0\": 2.98,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4977473,\n        }\n        Mineral.__init__(self)",
  "class spss(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"spss\",\n            \"formula\": {\"Al\": 2.0, \"Mn\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5693490.0,\n            \"S_0\": 335.3,\n            \"V_0\": 0.00011792,\n            \"Cp\": [646.9, 0.0, -4525800.0, -4452.8],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 6.68,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4950263,\n        }\n        Mineral.__init__(self)",
  "class gr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"gr\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6643010.0,\n            \"S_0\": 255.0,\n            \"V_0\": 0.00012535,\n            \"Cp\": [626.0, 0.0, -5779200.0, -4002.9],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 172000e6,\n            \"Kprime_0\": 5.53,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4504463,\n        }\n        Mineral.__init__(self)",
  "class andr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"andr\",\n            \"formula\": {\"Ca\": 3.0, \"Fe\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5769100.0,\n            \"S_0\": 316.4,\n            \"V_0\": 0.00013204,\n            \"Cp\": [638.6, 0.0, -4955100.0, -3989.2],\n            \"a_0\": 2.86e-05,\n            \"K_0\": 158800e6,\n            \"Kprime_0\": 5.68,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.5081733,\n        }\n        Mineral.__init__(self)",
  "class knor(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"knor\",\n            \"formula\": {\"Cr\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5687710.0,\n            \"S_0\": 317.0,\n            \"V_0\": 0.00011738,\n            \"Cp\": [613.0, 0.003606, -4178000.0, -3729.4],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 174300e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4531565,\n        }\n        Mineral.__init__(self)",
  "class osma(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"osma\",\n            \"formula\": {\"Al\": 5.0, \"K\": 1.0, \"Mg\": 2.0, \"O\": 30.0, \"Si\": 10.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14896310.0,\n            \"S_0\": 755.0,\n            \"V_0\": 0.00037893,\n            \"Cp\": [1540.7, -0.011359, -10339000.0, -11699.0],\n            \"a_0\": 4.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 0.9834528,\n        }\n        Mineral.__init__(self)",
  "class osmm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"osmm\",\n            \"formula\": {\"Al\": 3.0, \"K\": 1.0, \"Mg\": 3.0, \"O\": 30.0, \"Si\": 11.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14786740.0,\n            \"S_0\": 740.0,\n            \"V_0\": 0.0003844,\n            \"Cp\": [1525.5, -0.010267, -10538000.0, -11337.0],\n            \"a_0\": 4.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 0.9818803,\n        }\n        Mineral.__init__(self)",
  "class osfa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"osfa\",\n            \"formula\": {\"Al\": 5.0, \"Fe\": 2.0, \"K\": 1.0, \"O\": 30.0, \"Si\": 10.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14215490.0,\n            \"S_0\": 780.0,\n            \"V_0\": 0.0003845,\n            \"Cp\": [1558.6, -0.011359, -9476500.0, -11845.0],\n            \"a_0\": 4.9e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 1.0465328,\n        }\n        Mineral.__init__(self)",
  "class vsv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"vsv\",\n            \"formula\": {\n                \"Al\": 11.0,\n                \"Ca\": 19.0,\n                \"H\": 9.0,\n                \"Mg\": 2.0,\n                \"O\": 78.0,\n                \"Si\": 18.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -42345820.0,\n            \"S_0\": 1890.0,\n            \"V_0\": 0.000852,\n            \"Cp\": [4488.0, -0.057952, -22269300.0, -33478.0],\n            \"a_0\": 2.75e-05,\n            \"K_0\": 125500e6,\n            \"Kprime_0\": 4.8,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 137.0,\n            \"molar_mass\": 2.86945216,\n        }\n        Mineral.__init__(self)",
  "class andalusite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"and\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2588670.0,\n            \"S_0\": 92.7,\n            \"V_0\": 5.153e-05,\n            \"Cp\": [277.3, -0.006588, -1914100.0, -2265.6],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 144200e6,\n            \"Kprime_0\": 6.89,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "class ky(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ky\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2592970.0,\n            \"S_0\": 83.5,\n            \"V_0\": 4.414e-05,\n            \"Cp\": [279.4, -0.007124, -2055600.0, -2289.4],\n            \"a_0\": 1.92e-05,\n            \"K_0\": 160100e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "class sill(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sill\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2585790.0,\n            \"S_0\": 95.4,\n            \"V_0\": 4.986e-05,\n            \"Cp\": [280.2, -0.0069, -1375700.0, -2399.4],\n            \"a_0\": 1.12e-05,\n            \"K_0\": 164000e6,\n            \"Kprime_0\": 5.06,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 4750.0,\n                    \"deltaV\": 1e-07,\n                    \"Wh\": 4750.0,\n                    \"Wv\": 1e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.25,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class smul(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"smul\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2569210.0,\n            \"S_0\": 101.5,\n            \"V_0\": 4.987e-05,\n            \"Cp\": [280.2, -0.0069, -1375700.0, -2399.4],\n            \"a_0\": 1.36e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "class amul(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"amul\",\n            \"formula\": {\"Al\": 2.5, \"O\": 4.75, \"Si\": 0.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2485530.0,\n            \"S_0\": 113.0,\n            \"V_0\": 5.083e-05,\n            \"Cp\": [244.8, 0.000968, -2533300.0, -1641.6],\n            \"a_0\": 1.36e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 7.75,\n            \"molar_mass\": 0.15749365,\n        }\n        Mineral.__init__(self)",
  "class tpz(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tpz\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2900710.0,\n            \"S_0\": 100.5,\n            \"V_0\": 5.339e-05,\n            \"Cp\": [387.7, -0.00712, -857200.0, -3744.2],\n            \"a_0\": 1.57e-05,\n            \"K_0\": 131500e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 11.0,\n            \"molar_mass\": 0.18006078,\n        }\n        Mineral.__init__(self)",
  "class mst(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mst\",\n            \"formula\": {\"Al\": 18.0, \"H\": 4.0, \"Mg\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -25123740.0,\n            \"S_0\": 910.0,\n            \"V_0\": 0.0004426,\n            \"Cp\": [2820.5, -0.059366, -13774000.0, -24126.0],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 168400e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.56553121,\n        }\n        Mineral.__init__(self)",
  "class fst(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fst\",\n            \"formula\": {\"Al\": 18.0, \"Fe\": 4.0, \"H\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -23754630.0,\n            \"S_0\": 1010.0,\n            \"V_0\": 0.0004488,\n            \"Cp\": [2880.0, -0.056595, -10642000.0, -25373.0],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.76,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.69169121,\n        }\n        Mineral.__init__(self)",
  "class mnst(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mnst\",\n            \"formula\": {\"Al\": 18.0, \"H\": 4.0, \"Mn\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -24245850.0,\n            \"S_0\": 1034.0,\n            \"V_0\": 0.0004546,\n            \"Cp\": [2873.3, -0.089064, -12688000.0, -24749.0],\n            \"a_0\": 2.09e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.76,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.68806321,\n        }\n        Mineral.__init__(self)",
  "class mctd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mctd\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mg\": 1.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3549250.0,\n            \"S_0\": 146.0,\n            \"V_0\": 6.875e-05,\n            \"Cp\": [417.4, -0.003771, -2920600.0, -3417.8],\n            \"a_0\": 2.63e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.22036518,\n        }\n        Mineral.__init__(self)",
  "class fctd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fctd\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"H\": 2.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3208290.0,\n            \"S_0\": 167.0,\n            \"V_0\": 6.98e-05,\n            \"Cp\": [416.1, -0.003477, -2835900.0, -3360.3],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.25190518,\n        }\n        Mineral.__init__(self)",
  "class mnctd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mnctd\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mn\": 1.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3336150.0,\n            \"S_0\": 166.0,\n            \"V_0\": 7.175e-05,\n            \"Cp\": [464.4, -0.012654, -1147200.0, -4341.0],\n            \"a_0\": 2.6e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.25099818,\n        }\n        Mineral.__init__(self)",
  "class merw(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"merw\",\n            \"formula\": {\"Ca\": 3.0, \"Mg\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4545700.0,\n            \"S_0\": 253.1,\n            \"V_0\": 9.847e-05,\n            \"Cp\": [417.5, 0.008117, -2923000.0, -2320.3],\n            \"a_0\": 3.19e-05,\n            \"K_0\": 120000e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 14.0,\n            \"molar_mass\": 0.3287052,\n        }\n        Mineral.__init__(self)",
  "class spu(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"spu\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 5.0, \"O\": 11.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5846720.0,\n            \"S_0\": 332.0,\n            \"V_0\": 0.00014697,\n            \"Cp\": [614.1, -0.003508, -2493100.0, -4168.0],\n            \"a_0\": 3.4e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.4445651,\n        }\n        Mineral.__init__(self)",
  "class zo(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"zo\",\n            \"formula\": {\"Al\": 3.0, \"Ca\": 2.0, \"H\": 1.0, \"O\": 13.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6896290.0,\n            \"S_0\": 298.0,\n            \"V_0\": 0.00013575,\n            \"Cp\": [662.0, 0.010416, -6006400.0, -4260.7],\n            \"a_0\": 3.12e-05,\n            \"K_0\": 104400e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.45435714,\n        }\n        Mineral.__init__(self)",
  "class cz(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cz\",\n            \"formula\": {\"Al\": 3.0, \"Ca\": 2.0, \"H\": 1.0, \"O\": 13.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6895540.0,\n            \"S_0\": 301.0,\n            \"V_0\": 0.0001363,\n            \"Cp\": [630.9, 0.013693, -6645800.0, -3731.1],\n            \"a_0\": 2.33e-05,\n            \"K_0\": 119700e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.45435714,\n        }\n        Mineral.__init__(self)",
  "class ep(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ep\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Ca\": 2.0,\n                \"Fe\": 1.0,\n                \"H\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6473830.0,\n            \"S_0\": 315.0,\n            \"V_0\": 0.0001392,\n            \"Cp\": [613.3, 0.02207, -7160000.0, -2987.7],\n            \"a_0\": 2.34e-05,\n            \"K_0\": 134000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.48322064,\n        }\n        Mineral.__init__(self)",
  "class fep(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fep\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"Ca\": 2.0,\n                \"Fe\": 2.0,\n                \"H\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6028590.0,\n            \"S_0\": 329.0,\n            \"V_0\": 0.0001421,\n            \"Cp\": [584.7, 0.030447, -7674200.0, -2244.3],\n            \"a_0\": 2.31e-05,\n            \"K_0\": 151300e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.51208414,\n        }\n        Mineral.__init__(self)",
  "class pmt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pmt\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Ca\": 2.0,\n                \"H\": 1.0,\n                \"Mn\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6543030.0,\n            \"S_0\": 340.0,\n            \"V_0\": 0.0001382,\n            \"Cp\": [569.8, 0.02779, -5442900.0, -2812.6],\n            \"a_0\": 2.38e-05,\n            \"K_0\": 119700e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.48231364,\n        }\n        Mineral.__init__(self)",
  "class law(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"law\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 4.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4868630.0,\n            \"S_0\": 229.0,\n            \"V_0\": 0.00010132,\n            \"Cp\": [687.8, 0.001566, 375900.0, -7179.2],\n            \"a_0\": 2.65e-05,\n            \"K_0\": 122900e6,\n            \"Kprime_0\": 5.45,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.31423776,\n        }\n        Mineral.__init__(self)",
  "class mpm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mpm\",\n            \"formula\": {\n                \"Al\": 5.0,\n                \"Ca\": 4.0,\n                \"H\": 7.0,\n                \"Mg\": 1.0,\n                \"O\": 28.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14386910.0,\n            \"S_0\": 629.0,\n            \"V_0\": 0.0002955,\n            \"Cp\": [1720.8, -0.024928, -5998700.0, -14620.3],\n            \"a_0\": 2.48e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 0.94307628,\n        }\n        Mineral.__init__(self)",
  "class fpm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fpm\",\n            \"formula\": {\n                \"Al\": 5.0,\n                \"Ca\": 4.0,\n                \"Fe\": 1.0,\n                \"H\": 7.0,\n                \"O\": 28.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14034040.0,\n            \"S_0\": 657.0,\n            \"V_0\": 0.0002968,\n            \"Cp\": [1737.2, -0.024582, -5161100.0, -14963.0],\n            \"a_0\": 2.49e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 0.97461628,\n        }\n        Mineral.__init__(self)",
  "class jgd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"jgd\",\n            \"formula\": {\"Ca\": 4.0, \"Fe\": 6.0, \"H\": 7.0, \"O\": 28.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11808960.0,\n            \"S_0\": 830.0,\n            \"V_0\": 0.0003108,\n            \"Cp\": [1795.4, -0.037986, -4455700.0, -14888.0],\n            \"a_0\": 2.49e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 1.11893378,\n        }\n        Mineral.__init__(self)",
  "class geh(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"geh\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 2.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3992240.0,\n            \"S_0\": 198.5,\n            \"V_0\": 9.024e-05,\n            \"Cp\": [405.7, -0.007099, -1188300.0, -3174.4],\n            \"a_0\": 2.23e-05,\n            \"K_0\": 108000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2742003,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 7510.0,\n                    \"deltaV\": 9e-07,\n                    \"Wh\": 7500.0,\n                    \"Wv\": 9e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.8,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class ak(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ak\",\n            \"formula\": {\"Ca\": 2.0, \"Mg\": 1.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3865620.0,\n            \"S_0\": 212.5,\n            \"V_0\": 9.254e-05,\n            \"Cp\": [385.4, 0.003209, -247500.0, -2889.9],\n            \"a_0\": 2.57e-05,\n            \"K_0\": 142000e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.9e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2726278,\n        }\n        Mineral.__init__(self)",
  "class rnk(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"rnk\",\n            \"formula\": {\"Ca\": 3.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3943820.0,\n            \"S_0\": 210.0,\n            \"V_0\": 9.651e-05,\n            \"Cp\": [372.3, -0.002893, -2462400.0, -2181.3],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2884008,\n        }\n        Mineral.__init__(self)",
  "class ty(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ty\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 5.0, \"O\": 13.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6368040.0,\n            \"S_0\": 390.0,\n            \"V_0\": 0.00017039,\n            \"Cp\": [741.7, -0.005345, -1434600.0, -5878.5],\n            \"a_0\": 3.42e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.4885746,\n        }\n        Mineral.__init__(self)",
  "class crd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"crd\",\n            \"formula\": {\"Al\": 4.0, \"Mg\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9163430.0,\n            \"S_0\": 404.1,\n            \"V_0\": 0.00023322,\n            \"Cp\": [906.1, 0.0, -7902000.0, -6293.4],\n            \"a_0\": 6.8e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.5849527,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class hcrd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hcrd\",\n            \"formula\": {\"Al\": 4.0, \"H\": 2.0, \"Mg\": 2.0, \"O\": 19.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9448520.0,\n            \"S_0\": 483.0,\n            \"V_0\": 0.00023322,\n            \"Cp\": [955.3, 0.0, -8352600.0, -6301.2],\n            \"a_0\": 6.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 32.0,\n            \"molar_mass\": 0.60296798,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class fcrd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fcrd\",\n            \"formula\": {\"Al\": 4.0, \"Fe\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8444070.0,\n            \"S_0\": 461.0,\n            \"V_0\": 0.0002371,\n            \"Cp\": [924.0, 0.0, -7039400.0, -6439.6],\n            \"a_0\": 6.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.6480327,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class mncrd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mncrd\",\n            \"formula\": {\"Al\": 4.0, \"Mn\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8693590.0,\n            \"S_0\": 473.0,\n            \"V_0\": 0.00024027,\n            \"Cp\": [886.5, 0.0, -8840000.0, -5590.4],\n            \"a_0\": 6.9e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.6462187,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class phA(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"phA\",\n            \"formula\": {\"H\": 6.0, \"Mg\": 7.0, \"O\": 14.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7129620.0,\n            \"S_0\": 350.5,\n            \"V_0\": 0.00015422,\n            \"Cp\": [962.0, -0.011521, -4517800.0, -7724.7],\n            \"a_0\": 3.55e-05,\n            \"K_0\": 145000e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.45634524,\n        }\n        Mineral.__init__(self)",
  "class sph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sph\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 5.0, \"Si\": 1.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2601660.0,\n            \"S_0\": 124.0,\n            \"V_0\": 5.565e-05,\n            \"Cp\": [227.9, 0.002924, -3539500.0, -894.3],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 101700e6,\n            \"Kprime_0\": 9.85,\n            \"Kdprime_0\": -9.7e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1960275,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 485.0,\n                    \"S_D\": 0.4,\n                    \"V_D\": 5e-08,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class cstn(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cstn\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 5.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2496350.0,\n            \"S_0\": 99.5,\n            \"V_0\": 4.818e-05,\n            \"Cp\": [205.6, 0.006034, -5517700.0, -352.6],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 178200e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.176246,\n        }\n        Mineral.__init__(self)",
  "class zrc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"zrc\",\n            \"formula\": {\"O\": 4.0, \"Si\": 1.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2035070.0,\n            \"S_0\": 83.03,\n            \"V_0\": 3.926e-05,\n            \"Cp\": [232.0, -0.014405, 0.0, -2238.2],\n            \"a_0\": 1.25e-05,\n            \"K_0\": 230100e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.1833071,\n        }\n        Mineral.__init__(self)",
  "class en(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"en\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3090220.0,\n            \"S_0\": 132.5,\n            \"V_0\": 6.262e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "class pren(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pren\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3084560.0,\n            \"S_0\": 137.0,\n            \"V_0\": 6.476e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.3e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "class cen(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cen\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3091110.0,\n            \"S_0\": 132.0,\n            \"V_0\": 6.264e-05,\n            \"Cp\": [306.0, -0.003793, -3041700.0, -1852.1],\n            \"a_0\": 2.11e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "class hen(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hen\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3082730.0,\n            \"S_0\": 131.7,\n            \"V_0\": 6.099e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.26e-05,\n            \"K_0\": 150000e6,\n            \"Kprime_0\": 5.5,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "class fs(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fs\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2388710.0,\n            \"S_0\": 189.9,\n            \"V_0\": 6.592e-05,\n            \"Cp\": [398.7, -0.006579, 1290100.0, -4058.0],\n            \"a_0\": 3.26e-05,\n            \"K_0\": 101000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2638574,\n        }\n        Mineral.__init__(self)",
  "class mgts(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mgts\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3196670.0,\n            \"S_0\": 131.0,\n            \"V_0\": 6.05e-05,\n            \"Cp\": [371.4, -0.004082, -398400.0, -3547.1],\n            \"a_0\": 2.17e-05,\n            \"K_0\": 102800e6,\n            \"Kprime_0\": 8.55,\n            \"Kdprime_0\": -8.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2023499,\n        }\n        Mineral.__init__(self)",
  "class di(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"di\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3201850.0,\n            \"S_0\": 142.9,\n            \"V_0\": 6.619e-05,\n            \"Cp\": [314.5, 4.1e-05, -2745900.0, -2020.1],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2165504,\n        }\n        Mineral.__init__(self)",
  "class hed(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hed\",\n            \"formula\": {\"Ca\": 1.0, \"Fe\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2842060.0,\n            \"S_0\": 175.0,\n            \"V_0\": 6.795e-05,\n            \"Cp\": [340.2, 0.000812, -1047800.0, -2646.7],\n            \"a_0\": 2.38e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 3.97,\n            \"Kdprime_0\": -3.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2480904,\n        }\n        Mineral.__init__(self)",
  "class jd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"jd\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3025270.0,\n            \"S_0\": 133.5,\n            \"V_0\": 6.04e-05,\n            \"Cp\": [319.4, 0.003616, -1173900.0, -2469.5],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 128100e6,\n            \"Kprime_0\": 3.81,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2021387,\n        }\n        Mineral.__init__(self)",
  "class acm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"acm\",\n            \"formula\": {\"Fe\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2583430.0,\n            \"S_0\": 170.6,\n            \"V_0\": 6.459e-05,\n            \"Cp\": [307.1, 0.016758, -1685500.0, -2125.8],\n            \"a_0\": 2.11e-05,\n            \"K_0\": 106000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2310022,\n        }\n        Mineral.__init__(self)",
  "class kos(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kos\",\n            \"formula\": {\"Cr\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2746840.0,\n            \"S_0\": 149.65,\n            \"V_0\": 6.309e-05,\n            \"Cp\": [309.2, 0.005419, -664600.0, -2176.6],\n            \"a_0\": 1.94e-05,\n            \"K_0\": 130800e6,\n            \"Kprime_0\": 3.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2271533,\n        }\n        Mineral.__init__(self)",
  "class cats(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cats\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3310110.0,\n            \"S_0\": 135.0,\n            \"V_0\": 6.356e-05,\n            \"Cp\": [347.6, -0.006974, -1781600.0, -2757.5],\n            \"a_0\": 2.08e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2181229,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 3800.0,\n                    \"deltaV\": 1e-07,\n                    \"Wh\": 3800.0,\n                    \"Wv\": 1e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.25,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class caes(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"caes\",\n            \"formula\": {\"Al\": 1.0, \"Ca\": 0.5, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3002020.0,\n            \"S_0\": 127.0,\n            \"V_0\": 6.05e-05,\n            \"Cp\": [362.0, -0.016944, -175900.0, -3565.7],\n            \"a_0\": 2.31e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 9.5,\n            \"molar_mass\": 0.1991879,\n        }\n        Mineral.__init__(self)",
  "class rhod(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"rhod\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1322380.0,\n            \"S_0\": 100.5,\n            \"V_0\": 3.494e-05,\n            \"Cp\": [138.4, 0.004088, -1936000.0, -538.9],\n            \"a_0\": 2.81e-05,\n            \"K_0\": 84000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1310217,\n        }\n        Mineral.__init__(self)",
  "class pxmn(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pxmn\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1323160.0,\n            \"S_0\": 99.3,\n            \"V_0\": 3.472e-05,\n            \"Cp\": [138.4, 0.004088, -1936000.0, -538.9],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 84000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1310217,\n        }\n        Mineral.__init__(self)",
  "class wo(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"wo\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1633770.0,\n            \"S_0\": 82.5,\n            \"V_0\": 3.993e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2.54e-05,\n            \"K_0\": 79500e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "class pswo(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pswo\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1627960.0,\n            \"S_0\": 87.8,\n            \"V_0\": 4.008e-05,\n            \"Cp\": [157.8, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 110000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "class wal(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"wal\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1625900.0,\n            \"S_0\": 83.5,\n            \"V_0\": 3.7633e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2.54e-05,\n            \"K_0\": 79500e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "class tr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tr\",\n            \"formula\": {\"Ca\": 2.0, \"H\": 2.0, \"Mg\": 5.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12304870.0,\n            \"S_0\": 553.0,\n            \"V_0\": 0.0002727,\n            \"Cp\": [1260.2, 0.00383, -11455000.0, -8237.6],\n            \"a_0\": 2.61e-05,\n            \"K_0\": 76200e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.81236648,\n        }\n        Mineral.__init__(self)",
  "class fact(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fact\",\n            \"formula\": {\"Ca\": 2.0, \"Fe\": 5.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10504120.0,\n            \"S_0\": 710.0,\n            \"V_0\": 0.0002842,\n            \"Cp\": [1290.0, 0.029992, -8447500.0, -8947.0],\n            \"a_0\": 2.88e-05,\n            \"K_0\": 76000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.97006648,\n        }\n        Mineral.__init__(self)",
  "class ts(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ts\",\n            \"formula\": {\n                \"Al\": 4.0,\n                \"Ca\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"O\": 24.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12555270.0,\n            \"S_0\": 533.0,\n            \"V_0\": 0.000268,\n            \"Cp\": [1244.8, 0.024348, -11965000.0, -8112.1],\n            \"a_0\": 2.66e-05,\n            \"K_0\": 76000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.81551148,\n        }\n        Mineral.__init__(self)",
  "class parg(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"parg\",\n            \"formula\": {\n                \"Al\": 3.0,\n                \"Ca\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 4.0,\n                \"Na\": 1.0,\n                \"O\": 24.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12664730.0,\n            \"S_0\": 635.0,\n            \"V_0\": 0.0002719,\n            \"Cp\": [1280.2, 0.022997, -12359500.0, -8065.8],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 91200e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.5e-11,\n            \"n\": 42.0,\n            \"molar_mass\": 0.83582478,\n        }\n        Mineral.__init__(self)",
  "class gl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"gl\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 2.0,\n                \"O\": 24.0,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11960240.0,\n            \"S_0\": 530.0,\n            \"V_0\": 0.0002598,\n            \"Cp\": [1717.5, -0.12107, 7075000.0, -19272.0],\n            \"a_0\": 1.49e-05,\n            \"K_0\": 88300e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78354308,\n        }\n        Mineral.__init__(self)",
  "class fgl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fgl\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Fe\": 3.0,\n                \"H\": 2.0,\n                \"Na\": 2.0,\n                \"O\": 24.0,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10880210.0,\n            \"S_0\": 624.0,\n            \"V_0\": 0.0002659,\n            \"Cp\": [1762.9, -0.118992, 9423700.0, -20207.1],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 89000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.87816308,\n        }\n        Mineral.__init__(self)",
  "class rieb(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"rieb\",\n            \"formula\": {\"Fe\": 5.0, \"H\": 2.0, \"Na\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10024780.0,\n            \"S_0\": 695.0,\n            \"V_0\": 0.0002749,\n            \"Cp\": [1787.3, -0.124882, 9627100.0, -20275.5],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 89000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.93589008,\n        }\n        Mineral.__init__(self)",
  "class anth(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"anth\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 7.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12066840.0,\n            \"S_0\": 537.0,\n            \"V_0\": 0.0002654,\n            \"Cp\": [1277.3, 0.025825, -9704600.0, -9074.7],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78082048,\n        }\n        Mineral.__init__(self)",
  "class fanth(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fanth\",\n            \"formula\": {\"Fe\": 7.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9624520.0,\n            \"S_0\": 725.0,\n            \"V_0\": 0.0002787,\n            \"Cp\": [1383.1, 0.030669, -4224700.0, -11257.6],\n            \"a_0\": 2.74e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 1.00160048,\n        }\n        Mineral.__init__(self)",
  "class cumm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cumm\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 7.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12064690.0,\n            \"S_0\": 538.0,\n            \"V_0\": 0.0002633,\n            \"Cp\": [1277.3, 0.025825, -9704600.0, -9074.7],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78082048,\n        }\n        Mineral.__init__(self)",
  "class grun(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"grun\",\n            \"formula\": {\"Fe\": 7.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9607150.0,\n            \"S_0\": 735.0,\n            \"V_0\": 0.0002784,\n            \"Cp\": [1383.1, 0.030669, -4224700.0, -11257.6],\n            \"a_0\": 2.74e-05,\n            \"K_0\": 64800e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 1.00160048,\n        }\n        Mineral.__init__(self)",
  "class ged(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ged\",\n            \"formula\": {\"Al\": 4.0, \"H\": 2.0, \"Mg\": 5.0, \"O\": 24.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12329140.0,\n            \"S_0\": 517.0,\n            \"V_0\": 0.00025548,\n            \"Cp\": [1307.7, 0.023642, -9307400.0, -9799.0],\n            \"a_0\": 2.41e-05,\n            \"K_0\": 77000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.3e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78396548,\n        }\n        Mineral.__init__(self)",
  "class spr4(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"spr4\",\n            \"formula\": {\"Al\": 8.0, \"Mg\": 4.0, \"O\": 20.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11022020.0,\n            \"S_0\": 425.5,\n            \"V_0\": 0.000199,\n            \"Cp\": [1133.1, -0.007596, -8816600.0, -8180.6],\n            \"a_0\": 2.05e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.689231,\n        }\n        Mineral.__init__(self)",
  "class spr5(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"spr5\",\n            \"formula\": {\"Al\": 10.0, \"Mg\": 3.0, \"O\": 20.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11135570.0,\n            \"S_0\": 419.5,\n            \"V_0\": 0.0001975,\n            \"Cp\": [1103.4, 0.001015, -10957000.0, -7409.2],\n            \"a_0\": 2.06e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.6908035,\n        }\n        Mineral.__init__(self)",
  "class fspr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fspr\",\n            \"formula\": {\"Al\": 8.0, \"Fe\": 4.0, \"O\": 20.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9659530.0,\n            \"S_0\": 485.0,\n            \"V_0\": 0.00019923,\n            \"Cp\": [1132.9, -0.007348, -10420200.0, -7036.6],\n            \"a_0\": 1.96e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.815391,\n        }\n        Mineral.__init__(self)",
  "class mcar(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mcar\",\n            \"formula\": {\"Al\": 2.0, \"H\": 4.0, \"Mg\": 1.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4771050.0,\n            \"S_0\": 221.5,\n            \"V_0\": 0.0001059,\n            \"Cp\": [683.0, -0.014054, 291000.0, -6976.4],\n            \"a_0\": 2.43e-05,\n            \"K_0\": 52500e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -7.9e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.29846476,\n        }\n        Mineral.__init__(self)",
  "class fcar(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fcar\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"H\": 4.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4411440.0,\n            \"S_0\": 251.1,\n            \"V_0\": 0.00010695,\n            \"Cp\": [686.6, -0.012415, 186000.0, -6884.0],\n            \"a_0\": 2.21e-05,\n            \"K_0\": 52500e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -7.9e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.33000476,\n        }\n        Mineral.__init__(self)",
  "class deer(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"deer\",\n            \"formula\": {\"Fe\": 18.0, \"H\": 10.0, \"O\": 50.0, \"Si\": 12.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -18341400.0,\n            \"S_0\": 1650.0,\n            \"V_0\": 0.0005574,\n            \"Cp\": [3164.4, -0.027883, -5039100.0, -26721.0],\n            \"a_0\": 2.75e-05,\n            \"K_0\": 63000e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.5e-11,\n            \"n\": 90.0,\n            \"molar_mass\": 2.1522854,\n        }\n        Mineral.__init__(self)",
  "class mu(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mu\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5976510.0,\n            \"S_0\": 292.0,\n            \"V_0\": 0.00014083,\n            \"Cp\": [756.4, -0.01984, -2170000.0, -6979.2],\n            \"a_0\": 3.07e-05,\n            \"K_0\": 49000e6,\n            \"Kprime_0\": 4.15,\n            \"Kdprime_0\": -8.5e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39830798,\n        }\n        Mineral.__init__(self)",
  "class cel(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cel\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 1.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5834840.0,\n            \"S_0\": 290.0,\n            \"V_0\": 0.00013957,\n            \"Cp\": [741.2, -0.018748, -2368800.0, -6616.9],\n            \"a_0\": 3.07e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39673548,\n        }\n        Mineral.__init__(self)",
  "class fcel(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fcel\",\n            \"formula\": {\"Al\": 1.0, \"Fe\": 1.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5468490.0,\n            \"S_0\": 330.0,\n            \"V_0\": 0.0001407,\n            \"Cp\": [756.3, -0.019147, -1586100.0, -6928.7],\n            \"a_0\": 3.18e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.42827548,\n        }\n        Mineral.__init__(self)",
  "class pa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pa\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"Na\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5942840.0,\n            \"S_0\": 277.0,\n            \"V_0\": 0.00013211,\n            \"Cp\": [803.0, -0.03158, 217000.0, -8151.0],\n            \"a_0\": 3.7e-05,\n            \"K_0\": 51500e6,\n            \"Kprime_0\": 6.51,\n            \"Kdprime_0\": -1.26e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.38219948,\n        }\n        Mineral.__init__(self)",
  "class ma(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ma\",\n            \"formula\": {\"Al\": 4.0, \"Ca\": 1.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6242070.0,\n            \"S_0\": 265.0,\n            \"V_0\": 0.00012964,\n            \"Cp\": [744.4, -0.0168, -2074400.0, -6783.2],\n            \"a_0\": 2.33e-05,\n            \"K_0\": 100000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39818368,\n        }\n        Mineral.__init__(self)",
  "class phl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"phl\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6214880.0,\n            \"S_0\": 326.0,\n            \"V_0\": 0.00014964,\n            \"Cp\": [770.3, -0.036939, -2328900.0, -6531.6],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.41725998,\n        }\n        Mineral.__init__(self)",
  "class ann(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ann\",\n            \"formula\": {\"Al\": 1.0, \"Fe\": 3.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5143720.0,\n            \"S_0\": 420.0,\n            \"V_0\": 0.00015432,\n            \"Cp\": [815.7, -0.034861, 19800.0, -7466.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.51187998,\n        }\n        Mineral.__init__(self)",
  "class mnbi(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mnbi\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mn\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5477520.0,\n            \"S_0\": 433.0,\n            \"V_0\": 0.00015264,\n            \"Cp\": [809.9, -0.059213, -1514400.0, -6998.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 53000e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.50915898,\n        }\n        Mineral.__init__(self)",
  "class east(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"east\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 2.0, \"O\": 12.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6330380.0,\n            \"S_0\": 318.0,\n            \"V_0\": 0.00014738,\n            \"Cp\": [785.5, -0.038031, -2130300.0, -6893.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 53000e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.41883248,\n        }\n        Mineral.__init__(self)",
  "class naph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"naph\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 1.0,\n                \"O\": 12.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6172010.0,\n            \"S_0\": 318.0,\n            \"V_0\": 0.0001445,\n            \"Cp\": [773.5, -0.040229, -2597900.0, -6512.6],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.40115148,\n        }\n        Mineral.__init__(self)",
  "class clin(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"clin\",\n            \"formula\": {\"Al\": 2.0, \"H\": 8.0, \"Mg\": 5.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8909160.0,\n            \"S_0\": 437.0,\n            \"V_0\": 0.0002114,\n            \"Cp\": [1170.8, -0.001508, -3825800.0, -10315.0],\n            \"a_0\": 2.04e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55579722,\n        }\n        Mineral.__init__(self)",
  "class ames(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ames\",\n            \"formula\": {\"Al\": 4.0, \"H\": 8.0, \"Mg\": 4.0, \"O\": 18.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9040460.0,\n            \"S_0\": 412.0,\n            \"V_0\": 0.0002071,\n            \"Cp\": [1186.0, -0.002599, -3627200.0, -10677.0],\n            \"a_0\": 2e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55736972,\n        }\n        Mineral.__init__(self)",
  "class afchl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"afchl\",\n            \"formula\": {\"H\": 8.0, \"Mg\": 6.0, \"O\": 18.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8727860.0,\n            \"S_0\": 439.0,\n            \"V_0\": 0.0002157,\n            \"Cp\": [1155.0, -0.000417, -4024400.0, -9952.9],\n            \"a_0\": 2.04e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55422472,\n        }\n        Mineral.__init__(self)",
  "class daph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"daph\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 5.0, \"H\": 8.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7116910.0,\n            \"S_0\": 584.0,\n            \"V_0\": 0.0002162,\n            \"Cp\": [1192.0, -0.00594, -4826400.0, -9768.3],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.71349722,\n        }\n        Mineral.__init__(self)",
  "class mnchl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mnchl\",\n            \"formula\": {\"Al\": 2.0, \"H\": 8.0, \"Mn\": 5.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7702320.0,\n            \"S_0\": 595.0,\n            \"V_0\": 0.0002259,\n            \"Cp\": [1136.5, -0.005243, -5548100.0, -8911.5],\n            \"a_0\": 2.23e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.70896222,\n        }\n        Mineral.__init__(self)",
  "class sud(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sud\",\n            \"formula\": {\"Al\": 4.0, \"H\": 8.0, \"Mg\": 2.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8626540.0,\n            \"S_0\": 395.0,\n            \"V_0\": 0.000203,\n            \"Cp\": [1436.1, -0.048749, -2748500.0, -13764.0],\n            \"a_0\": 1.99e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 35.0,\n            \"molar_mass\": 0.53684522,\n        }\n        Mineral.__init__(self)",
  "class fsud(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fsud\",\n            \"formula\": {\"Al\": 4.0, \"Fe\": 2.0, \"H\": 8.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7899850.0,\n            \"S_0\": 456.0,\n            \"V_0\": 0.000204,\n            \"Cp\": [1466.3, -0.047365, -1182800.0, -14388.0],\n            \"a_0\": 2.08e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 35.0,\n            \"molar_mass\": 0.59992522,\n        }\n        Mineral.__init__(self)",
  "class prl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"prl\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5640610.0,\n            \"S_0\": 239.0,\n            \"V_0\": 0.00012804,\n            \"Cp\": [784.5, -0.042948, 1251000.0, -8495.9],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 37000e6,\n            \"Kprime_0\": 10.0,\n            \"Kdprime_0\": -2.71e-10,\n            \"n\": 20.0,\n            \"molar_mass\": 0.36031368,\n        }\n        Mineral.__init__(self)",
  "class ta(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ta\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5897170.0,\n            \"S_0\": 259.0,\n            \"V_0\": 0.00013665,\n            \"Cp\": [622.2, 0.0, -6385500.0, -3916.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.37926568,\n        }\n        Mineral.__init__(self)",
  "class fta(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fta\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4798540.0,\n            \"S_0\": 352.0,\n            \"V_0\": 0.00014225,\n            \"Cp\": [579.7, 0.039494, -6459300.0, -3088.1],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.47388568,\n        }\n        Mineral.__init__(self)",
  "class tats(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tats\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mg\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6001290.0,\n            \"S_0\": 259.0,\n            \"V_0\": 0.0001351,\n            \"Cp\": [549.5, 0.036324, -8606600.0, -2515.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.38083818,\n        }\n        Mineral.__init__(self)",
  "class tap(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tap\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5649780.0,\n            \"S_0\": 235.0,\n            \"V_0\": 0.0001345,\n            \"Cp\": [784.5, -0.042948, 1251000.0, -8495.9],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 37000e6,\n            \"Kprime_0\": 10.0,\n            \"Kdprime_0\": -2.71e-10,\n            \"n\": 20.0,\n            \"molar_mass\": 0.36031368,\n        }\n        Mineral.__init__(self)",
  "class minn(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"minn\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4819310.0,\n            \"S_0\": 355.0,\n            \"V_0\": 0.00014851,\n            \"Cp\": [579.7, 0.039494, -6459300.0, -3088.1],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.47388568,\n        }\n        Mineral.__init__(self)",
  "class minm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"minm\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5866000.0,\n            \"S_0\": 263.9,\n            \"V_0\": 0.00014291,\n            \"Cp\": [622.2, 0.0, -6385500.0, -3916.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.37926568,\n        }\n        Mineral.__init__(self)",
  "class kao(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kao\",\n            \"formula\": {\"Al\": 2.0, \"H\": 4.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4122000.0,\n            \"S_0\": 203.7,\n            \"V_0\": 9.934e-05,\n            \"Cp\": [436.7, -0.034295, -4055900.0, -2699.1],\n            \"a_0\": 2.51e-05,\n            \"K_0\": 64500e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 17.0,\n            \"molar_mass\": 0.25816036,\n        }\n        Mineral.__init__(self)",
  "class pre(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pre\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6202170.0,\n            \"S_0\": 292.8,\n            \"V_0\": 0.00014026,\n            \"Cp\": [724.9, -0.013865, -2059000.0, -6323.9],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 109300e6,\n            \"Kprime_0\": 4.01,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.41238418,\n        }\n        Mineral.__init__(self)",
  "class fpre(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fpre\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"Ca\": 2.0,\n                \"Fe\": 1.0,\n                \"H\": 2.0,\n                \"O\": 12.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5766640.0,\n            \"S_0\": 320.0,\n            \"V_0\": 0.000148,\n            \"Cp\": [737.1, -0.01681, -1957300.0, -6358.1],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 109300e6,\n            \"Kprime_0\": 4.01,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.44124768,\n        }\n        Mineral.__init__(self)",
  "class chr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"chr\",\n            \"formula\": {\"H\": 4.0, \"Mg\": 3.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4361000.0,\n            \"S_0\": 221.3,\n            \"V_0\": 0.00010746,\n            \"Cp\": [624.7, -0.02077, -1721800.0, -5619.4],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 62800e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.27711236,\n        }\n        Mineral.__init__(self)",
  "class liz(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"liz\",\n            \"formula\": {\"H\": 4.0, \"Mg\": 3.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4369190.0,\n            \"S_0\": 212.0,\n            \"V_0\": 0.00010645,\n            \"Cp\": [614.7, -0.02077, -1721800.0, -5619.4],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 71000e6,\n            \"Kprime_0\": 3.2,\n            \"Kdprime_0\": -4.5e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.27711236,\n        }\n        Mineral.__init__(self)",
  "class glt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"glt\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 4.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3297620.0,\n            \"S_0\": 310.0,\n            \"V_0\": 0.0001198,\n            \"Cp\": [576.4, 0.002984, -3757000.0, -4166.2],\n            \"a_0\": 2.28e-05,\n            \"K_0\": 63000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.37173236,\n        }\n        Mineral.__init__(self)",
  "class fstp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fstp\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Fe\": 5.0,\n                \"H\": 12.5,\n                \"K\": 0.5,\n                \"O\": 30.5,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12551070.0,\n            \"S_0\": 930.2,\n            \"V_0\": 0.00037239,\n            \"Cp\": [1944.3, -0.012289, -4840200.0, -16635.0],\n            \"a_0\": 3.68e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 58.5,\n            \"molar_mass\": 1.0780021,\n        }\n        Mineral.__init__(self)",
  "class mstp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mstp\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"H\": 12.5,\n                \"K\": 0.5,\n                \"Mg\": 5.0,\n                \"O\": 30.5,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14288380.0,\n            \"S_0\": 847.4,\n            \"V_0\": 0.00036577,\n            \"Cp\": [1862.2, -0.014018, -8983100.0, -14923.0],\n            \"a_0\": 3.71e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 58.5,\n            \"molar_mass\": 0.9203021,\n        }\n        Mineral.__init__(self)",
  "class atg(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"atg\",\n            \"formula\": {\"H\": 62.0, \"Mg\": 48.0, \"O\": 147.0, \"Si\": 34.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -71404690.0,\n            \"S_0\": 3620.0,\n            \"V_0\": 0.0017548,\n            \"Cp\": [9621.0, -0.091183, -35941600.0, -83034.2],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 63100e6,\n            \"Kprime_0\": 5.92,\n            \"Kdprime_0\": -9.4e-11,\n            \"n\": 291.0,\n            \"molar_mass\": 4.53595108,\n        }\n        Mineral.__init__(self)",
  "class ab(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ab\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3935480.0,\n            \"S_0\": 207.4,\n            \"V_0\": 0.00010067,\n            \"Cp\": [452.0, -0.013364, -1275900.0, -3953.6],\n            \"a_0\": 2.36e-05,\n            \"K_0\": 54100e6,\n            \"Kprime_0\": 5.91,\n            \"Kdprime_0\": -1.09e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 14000.0,\n                    \"deltaV\": 4.2e-07,\n                    \"Wh\": 13000.0,\n                    \"Wv\": 4.2e-07,\n                    \"n\": 3.0,\n                    \"factor\": 0.9,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class abh(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"abh\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3921480.0,\n            \"S_0\": 224.3,\n            \"V_0\": 0.00010105,\n            \"Cp\": [452.0, -0.013364, -1275900.0, -3953.6],\n            \"a_0\": 2.41e-05,\n            \"K_0\": 54100e6,\n            \"Kprime_0\": 5.91,\n            \"Kdprime_0\": -1.09e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        Mineral.__init__(self)",
  "class mic(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mic\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3975350.0,\n            \"S_0\": 214.3,\n            \"V_0\": 0.00010871,\n            \"Cp\": [448.8, -0.010075, -1007300.0, -3973.1],\n            \"a_0\": 1.66e-05,\n            \"K_0\": 58300e6,\n            \"Kprime_0\": 4.02,\n            \"Kdprime_0\": -6.9e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "class san(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"san\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3966700.0,\n            \"S_0\": 214.3,\n            \"V_0\": 0.00010871,\n            \"Cp\": [448.8, -0.010075, -1007300.0, -3973.1],\n            \"a_0\": 1.66e-05,\n            \"K_0\": 58300e6,\n            \"Kprime_0\": 4.02,\n            \"Kdprime_0\": -6.9e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 8650.0,\n                    \"deltaV\": 2.4e-07,\n                    \"Wh\": 8500.0,\n                    \"Wv\": 2.4e-07,\n                    \"n\": 3.0,\n                    \"factor\": 0.8,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class an(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"an\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4232690.0,\n            \"S_0\": 200.5,\n            \"V_0\": 0.00010079,\n            \"Cp\": [370.5, 0.01001, -4339100.0, -1960.6],\n            \"a_0\": 1.41e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2782072,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 42010.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 42000.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 1.0,\n                    \"factor\": 2.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class kcm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kcm\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"O\": 9.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4232640.0,\n            \"S_0\": 281.5,\n            \"V_0\": 0.00011438,\n            \"Cp\": [536.5, -0.01009, -980400.0, -4735.0],\n            \"a_0\": 3.21e-05,\n            \"K_0\": 42500e6,\n            \"Kprime_0\": 2.0,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 16.0,\n            \"molar_mass\": 0.29634678,\n        }\n        Mineral.__init__(self)",
  "class wa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"wa\",\n            \"formula\": {\"K\": 2.0, \"O\": 9.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4271890.0,\n            \"S_0\": 254.0,\n            \"V_0\": 0.00010844,\n            \"Cp\": [499.1, 0.0, 0.0, -4350.1],\n            \"a_0\": 2.66e-05,\n            \"K_0\": 90000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 15.0,\n            \"molar_mass\": 0.3345332,\n        }\n        Mineral.__init__(self)",
  "class hol(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hol\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3791960.0,\n            \"S_0\": 166.2,\n            \"V_0\": 7.128e-05,\n            \"Cp\": [417.6, -0.003617, -4748100.0, -2819.9],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "class q(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"q\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -910720.0,\n            \"S_0\": 41.43,\n            \"V_0\": 2.269e-05,\n            \"Cp\": [92.9, -0.000642, -714900.0, -716.1],\n            \"a_0\": 0.0,\n            \"K_0\": 73000e6,\n            \"Kprime_0\": 6.0,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 847.0,\n                    \"S_D\": 4.95,\n                    \"V_D\": 1.188e-06,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class trd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"trd\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -907110.0,\n            \"S_0\": 44.1,\n            \"V_0\": 2.8e-05,\n            \"Cp\": [74.9, 0.0031, -1174000.0, -236.7],\n            \"a_0\": 0.0,\n            \"K_0\": 15000e6,\n            \"Kprime_0\": 4.36,\n            \"Kdprime_0\": -2.91e-10,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "class crst(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"crst\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -904270.0,\n            \"S_0\": 50.86,\n            \"V_0\": 2.745e-05,\n            \"Cp\": [72.7, 0.001304, -4129000.0, 0.0],\n            \"a_0\": 0.0,\n            \"K_0\": 16000e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.72e-10,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "class coe(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"coe\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -907000.0,\n            \"S_0\": 39.6,\n            \"V_0\": 2.064e-05,\n            \"Cp\": [107.8, -0.003279, -190300.0, -1041.6],\n            \"a_0\": 1.23e-05,\n            \"K_0\": 97900e6,\n            \"Kprime_0\": 4.19,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "class stv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"stv\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -876390.0,\n            \"S_0\": 24.0,\n            \"V_0\": 1.401e-05,\n            \"Cp\": [68.1, 0.00601, -1978200.0, -82.1],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 309000e6,\n            \"Kprime_0\": 4.6,\n            \"Kdprime_0\": -1.5e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "class ne(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ne\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2094560.0,\n            \"S_0\": 124.4,\n            \"V_0\": 5.419e-05,\n            \"Cp\": [272.7, -0.012398, 0.0, -2763.1],\n            \"a_0\": 4.63e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 467.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 8e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class cg(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cg\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2091719.9999999998,\n            \"S_0\": 118.7,\n            \"V_0\": 5.603e-05,\n            \"Cp\": [116.1, 0.086021, -1992700.0, 0.0],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "class cgh(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cgh\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2078010.0000000002,\n            \"S_0\": 135.0,\n            \"V_0\": 5.67e-05,\n            \"Cp\": [229.2, 0.011876, 0.0, -1970.7],\n            \"a_0\": 4.67e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "class sdl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sdl\",\n            \"formula\": {\"Al\": 6.0, \"Cl\": 2.0, \"Na\": 8.0, \"O\": 24.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -13405530.0,\n            \"S_0\": 910.0,\n            \"V_0\": 0.0004213,\n            \"Cp\": [1532.7, 0.047747, -2972800.0, -12427.0],\n            \"a_0\": 4.63e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 46.0,\n            \"molar_mass\": 0.969212,\n        }\n        Mineral.__init__(self)",
  "class kls(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kls\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2122960.0,\n            \"S_0\": 136.0,\n            \"V_0\": 6.052e-05,\n            \"Cp\": [242.0, -0.004482, -895800.0, -1935.8],\n            \"a_0\": 3.16e-05,\n            \"K_0\": 51400e6,\n            \"Kprime_0\": 2.0,\n            \"Kdprime_0\": -3.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1581629,\n        }\n        Mineral.__init__(self)",
  "class lc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lc\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3029270.0,\n            \"S_0\": 198.5,\n            \"V_0\": 8.826e-05,\n            \"Cp\": [369.8, -0.016332, 684700.0, -3683.1],\n            \"a_0\": 1.85e-05,\n            \"K_0\": 45000e6,\n            \"Kprime_0\": 5.7,\n            \"Kdprime_0\": -1.27e-10,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2182472,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11610.0,\n                    \"deltaV\": 4e-06,\n                    \"Wh\": 11600.0,\n                    \"Wv\": 4e-06,\n                    \"n\": 2.0,\n                    \"factor\": 0.7,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class me(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"me\",\n            \"formula\": {\"Al\": 6.0, \"C\": 1.0, \"Ca\": 4.0, \"O\": 27.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -13841820.0,\n            \"S_0\": 752.0,\n            \"V_0\": 0.00033985,\n            \"Cp\": [1359.0, 0.036442, -8594700.0, -9598.2],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 44.0,\n            \"molar_mass\": 0.9347085,\n        }\n        Mineral.__init__(self)",
  "class wrk(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"wrk\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 4.0, \"O\": 14.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6662450.0,\n            \"S_0\": 380.0,\n            \"V_0\": 0.0001904,\n            \"Cp\": [838.3, -0.02146, -2272000.0, -7292.3],\n            \"a_0\": 1.49e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 25.0,\n            \"molar_mass\": 0.43440636,\n        }\n        Mineral.__init__(self)",
  "class lmt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lmt\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 8.0, \"O\": 16.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7262700.0,\n            \"S_0\": 465.0,\n            \"V_0\": 0.0002037,\n            \"Cp\": [1013.4, -0.021413, -2235800.0, -8806.7],\n            \"a_0\": 1.37e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 31.0,\n            \"molar_mass\": 0.47043692,\n        }\n        Mineral.__init__(self)",
  "class heu(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"heu\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 12.0, \"O\": 24.0, \"Si\": 7.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10545220.0,\n            \"S_0\": 783.0,\n            \"V_0\": 0.000317,\n            \"Cp\": [1504.8, -0.033224, -2959300.0, -13297.2],\n            \"a_0\": 1.57e-05,\n            \"K_0\": 27400e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.46e-10,\n            \"n\": 46.0,\n            \"molar_mass\": 0.68672038,\n        }\n        Mineral.__init__(self)",
  "class stlb(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"stlb\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 14.0, \"O\": 25.0, \"Si\": 7.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10896760.0,\n            \"S_0\": 710.0,\n            \"V_0\": 0.0003287,\n            \"Cp\": [1588.4, -0.032043, -3071600.0, -13966.9],\n            \"a_0\": 1.51e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 49.0,\n            \"molar_mass\": 0.70473566,\n        }\n        Mineral.__init__(self)",
  "class anl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"anl\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"Na\": 1.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3307220.0,\n            \"S_0\": 232.0,\n            \"V_0\": 9.74e-05,\n            \"Cp\": [643.5, -0.016067, 9302300.0, -9179.6],\n            \"a_0\": 2.76e-05,\n            \"K_0\": 40000e6,\n            \"Kprime_0\": 4.18,\n            \"Kdprime_0\": -1.04e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.22015398,\n        }\n        Mineral.__init__(self)",
  "class lime(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lime\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -634530.0,\n            \"S_0\": 38.1,\n            \"V_0\": 1.676e-05,\n            \"Cp\": [52.4, 0.003673, -750700.0, -51.0],\n            \"a_0\": 3.41e-05,\n            \"K_0\": 113000e6,\n            \"Kprime_0\": 3.87,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0560774,\n        }\n        Mineral.__init__(self)",
  "class ru(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ru\",\n            \"formula\": {\"O\": 2.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -944360.0,\n            \"S_0\": 50.5,\n            \"V_0\": 1.882e-05,\n            \"Cp\": [90.4, 0.0029, 0.0, -623.8],\n            \"a_0\": 2.24e-05,\n            \"K_0\": 222000e6,\n            \"Kprime_0\": 4.24,\n            \"Kdprime_0\": -1.9e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0798658,\n        }\n        Mineral.__init__(self)",
  "class per(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"per\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -601530.0,\n            \"S_0\": 26.5,\n            \"V_0\": 1.125e-05,\n            \"Cp\": [60.5, 0.000362, -535800.0, -299.2],\n            \"a_0\": 3.11e-05,\n            \"K_0\": 161600e6,\n            \"Kprime_0\": 3.95,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0403044,\n        }\n        Mineral.__init__(self)",
  "class fper(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fper\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -259870.0,\n            \"S_0\": 58.6,\n            \"V_0\": 1.206e-05,\n            \"Cp\": [44.4, 0.00828, -1214200.0, 185.2],\n            \"a_0\": 3.22e-05,\n            \"K_0\": 152000e6,\n            \"Kprime_0\": 4.9,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0718444,\n        }\n        Mineral.__init__(self)",
  "class mang(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mang\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -385550.0,\n            \"S_0\": 59.7,\n            \"V_0\": 1.322e-05,\n            \"Cp\": [59.8, 0.0036, -31400.0, -282.6],\n            \"a_0\": 3.69e-05,\n            \"K_0\": 164500e6,\n            \"Kprime_0\": 4.46,\n            \"Kdprime_0\": -2.7e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0709374,\n        }\n        Mineral.__init__(self)",
  "class cor(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cor\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1675270.0,\n            \"S_0\": 50.9,\n            \"V_0\": 2.558e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 254000e6,\n            \"Kprime_0\": 4.34,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "class mcor(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mcor\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1474440.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 211000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "class hem(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hem\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -825610.0,\n            \"S_0\": 87.4,\n            \"V_0\": 3.027e-05,\n            \"Cp\": [163.9, 0.0, -2257200.0, -657.6],\n            \"a_0\": 2.79e-05,\n            \"K_0\": 223000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1596882,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 955.0,\n                    \"S_D\": 15.6,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class esk(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"esk\",\n            \"formula\": {\"Cr\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1137320.0,\n            \"S_0\": 83.0,\n            \"V_0\": 2.909e-05,\n            \"Cp\": [119.0, 0.009496, -1442000.0, -3.4],\n            \"a_0\": 1.59e-05,\n            \"K_0\": 238000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1519904,\n        }\n        Mineral.__init__(self)",
  "class bix(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"bix\",\n            \"formula\": {\"Mn\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -959000.0,\n            \"S_0\": 113.7,\n            \"V_0\": 3.137e-05,\n            \"Cp\": [145.1, 0.023534, 721600.0, -1008.4],\n            \"a_0\": 2.91e-05,\n            \"K_0\": 223000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1578742,\n        }\n        Mineral.__init__(self)",
  "class NiO(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"NiO\",\n            \"formula\": {\"Ni\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -239470.0,\n            \"S_0\": 38.0,\n            \"V_0\": 1.097e-05,\n            \"Cp\": [47.7, 0.007824, -392500.0, 0.0],\n            \"a_0\": 3.3e-05,\n            \"K_0\": 200000e6,\n            \"Kprime_0\": 3.94,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0746928,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\"P_0\": 100000.0, \"T_0\": 298.15, \"Tc_0\": 520.0, \"S_D\": 5.7, \"V_D\": 0.0},\n            ]\n        ]\n        Mineral.__init__(self)",
  "class pnt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pnt\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1361950.0,\n            \"S_0\": 105.5,\n            \"V_0\": 3.288e-05,\n            \"Cp\": [143.5, 0.003373, -1940700.0, -407.6],\n            \"a_0\": 2.4e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1508032,\n        }\n        Mineral.__init__(self)",
  "class geik(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"geik\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1568960.0,\n            \"S_0\": 73.6,\n            \"V_0\": 3.086e-05,\n            \"Cp\": [151.0, 0.0, -1890400.0, -652.2],\n            \"a_0\": 2.15e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1201702,\n        }\n        Mineral.__init__(self)",
  "class ilm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ilm\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1230450.0,\n            \"S_0\": 109.5,\n            \"V_0\": 3.169e-05,\n            \"Cp\": [138.9, 0.005081, -1288800.0, -463.7],\n            \"a_0\": 2.4e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1517102,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1900.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 2e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class bdy(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"bdy\",\n            \"formula\": {\"O\": 2.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1100340.0,\n            \"S_0\": 50.4,\n            \"V_0\": 2.115e-05,\n            \"Cp\": [103.5, -0.004547, -416200.0, -713.6],\n            \"a_0\": 2e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1232228,\n        }\n        Mineral.__init__(self)",
  "class ten(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ten\",\n            \"formula\": {\"Cu\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -156100.0,\n            \"S_0\": 42.6,\n            \"V_0\": 1.222e-05,\n            \"Cp\": [31.0, 0.01374, -1258000.0, 369.3],\n            \"a_0\": 3.57e-05,\n            \"K_0\": 200000e6,\n            \"Kprime_0\": 3.94,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0795454,\n        }\n        Mineral.__init__(self)",
  "class cup(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cup\",\n            \"formula\": {\"Cu\": 2.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -170600.0,\n            \"S_0\": 92.4,\n            \"V_0\": 2.344e-05,\n            \"Cp\": [110.3, 0.0, 0.0, -674.8],\n            \"a_0\": 3.33e-05,\n            \"K_0\": 131000e6,\n            \"Kprime_0\": 5.7,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1430914,\n        }\n        Mineral.__init__(self)",
  "class sp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sp\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2301190.0,\n            \"S_0\": 82.0,\n            \"V_0\": 3.978e-05,\n            \"Cp\": [222.9, 0.006127, -1686000.0, -1551.0],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1422656,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 8000.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": 1200.0,\n                    \"Wv\": 0.0,\n                    \"n\": 2.0,\n                    \"factor\": 0.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class herc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"herc\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1953030.0,\n            \"S_0\": 113.9,\n            \"V_0\": 4.075e-05,\n            \"Cp\": [216.7, 0.005868, -2430200.0, -1178.3],\n            \"a_0\": 2.06e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1738056,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 18300.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": 13600.0,\n                    \"Wv\": 0.0,\n                    \"n\": 2.0,\n                    \"factor\": 1.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class mt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mt\",\n            \"formula\": {\"Fe\": 3.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1114500.0,\n            \"S_0\": 146.9,\n            \"V_0\": 4.452e-05,\n            \"Cp\": [262.5, -0.007205, -1926200.0, -1655.7],\n            \"a_0\": 3.71e-05,\n            \"K_0\": 185700e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2315326,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 848.0,\n                    \"S_D\": 35.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class mft(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mft\",\n            \"formula\": {\"Fe\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1442290.0,\n            \"S_0\": 121.0,\n            \"V_0\": 4.457e-05,\n            \"Cp\": [270.5, -0.007505, -999200.0, -2022.4],\n            \"a_0\": 3.63e-05,\n            \"K_0\": 185700e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1999926,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 665.0,\n                    \"S_D\": 17.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class usp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"usp\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1491120.0,\n            \"S_0\": 180.0,\n            \"V_0\": 4.682e-05,\n            \"Cp\": [-102.6, 0.14252, -9144500.0, 5270.7],\n            \"a_0\": 3.86e-05,\n            \"K_0\": 185700e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2235546,\n        }\n        Mineral.__init__(self)",
  "class picr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"picr\",\n            \"formula\": {\"Cr\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1762600.0,\n            \"S_0\": 118.3,\n            \"V_0\": 4.356e-05,\n            \"Cp\": [196.1, 0.005398, -3126000.0, -616.9],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1922948,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 8000.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": 1200.0,\n                    \"Wv\": 0.0,\n                    \"n\": 2.0,\n                    \"factor\": 0.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class br(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"br\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -925560.0,\n            \"S_0\": 63.2,\n            \"V_0\": 2.463e-05,\n            \"Cp\": [158.4, -0.004076, -1052300.0, -1171.3],\n            \"a_0\": 6.2e-05,\n            \"K_0\": 41500e6,\n            \"Kprime_0\": 6.45,\n            \"Kdprime_0\": -1.55e-10,\n            \"n\": 5.0,\n            \"molar_mass\": 0.05831968,\n        }\n        Mineral.__init__(self)",
  "class dsp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"dsp\",\n            \"formula\": {\"Al\": 1.0, \"H\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -999840.0,\n            \"S_0\": 34.5,\n            \"V_0\": 1.786e-05,\n            \"Cp\": [145.1, 0.008709, 584400.0, -1741.1],\n            \"a_0\": 3.57e-05,\n            \"K_0\": 228000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 4.0,\n            \"molar_mass\": 0.05998824,\n        }\n        Mineral.__init__(self)",
  "class gth(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"gth\",\n            \"formula\": {\"Fe\": 1.0, \"H\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -561770.0,\n            \"S_0\": 60.3,\n            \"V_0\": 2.082e-05,\n            \"Cp\": [139.3, 0.000147, -212700.0, -1077.8],\n            \"a_0\": 4.35e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.03,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 4.0,\n            \"molar_mass\": 0.08885174,\n        }\n        Mineral.__init__(self)",
  "class cc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cc\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1207760.0,\n            \"S_0\": 92.5,\n            \"V_0\": 3.689e-05,\n            \"Cp\": [140.9, 0.005029, -950700.0, -858.4],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 73300e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -5.5e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1000869,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1240.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 4e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class arag(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"arag\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1207650.0,\n            \"S_0\": 89.8,\n            \"V_0\": 3.415e-05,\n            \"Cp\": [167.1, 0.010695, 162000.0, -1564.9],\n            \"a_0\": 6.14e-05,\n            \"K_0\": 61400e6,\n            \"Kprime_0\": 5.87,\n            \"Kdprime_0\": -9.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1000869,\n        }\n        Mineral.__init__(self)",
  "class mag(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mag\",\n            \"formula\": {\"C\": 1.0, \"Mg\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1110920.0,\n            \"S_0\": 65.5,\n            \"V_0\": 2.803e-05,\n            \"Cp\": [186.4, -0.003772, 0.0, -1886.2],\n            \"a_0\": 3.38e-05,\n            \"K_0\": 102800e6,\n            \"Kprime_0\": 5.41,\n            \"Kdprime_0\": -5.3e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.0843139,\n        }\n        Mineral.__init__(self)",
  "class sid(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sid\",\n            \"formula\": {\"C\": 1.0, \"Fe\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -762220.0,\n            \"S_0\": 93.3,\n            \"V_0\": 2.943e-05,\n            \"Cp\": [168.4, 0.0, 0.0, -1483.6],\n            \"a_0\": 4.39e-05,\n            \"K_0\": 120000e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1158539,\n        }\n        Mineral.__init__(self)",
  "class rhc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"rhc\",\n            \"formula\": {\"C\": 1.0, \"Mn\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -892280.0,\n            \"S_0\": 98.0,\n            \"V_0\": 3.107e-05,\n            \"Cp\": [169.5, 0.0, 0.0, -1534.3],\n            \"a_0\": 2.44e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1149469,\n        }\n        Mineral.__init__(self)",
  "class dol(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"dol\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2326220.0,\n            \"S_0\": 156.1,\n            \"V_0\": 6.429e-05,\n            \"Cp\": [358.9, -0.004905, 0.0, -3456.2],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 94300e6,\n            \"Kprime_0\": 3.74,\n            \"Kdprime_0\": -4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.1844008,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11910.0,\n                    \"deltaV\": 1.6e-07,\n                    \"Wh\": 11900.0,\n                    \"Wv\": 1.6e-07,\n                    \"n\": 1.0,\n                    \"factor\": 1.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class ank(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ank\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 1.0, \"Fe\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1971410.0,\n            \"S_0\": 188.46,\n            \"V_0\": 6.606e-05,\n            \"Cp\": [341.0, -0.001161, 0.0, -3054.8],\n            \"a_0\": 3.46e-05,\n            \"K_0\": 91400e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2159408,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11910.0,\n                    \"deltaV\": 1.6e-07,\n                    \"Wh\": 11900.0,\n                    \"Wv\": 1.6e-07,\n                    \"n\": 1.0,\n                    \"factor\": 1.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class syv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"syv\",\n            \"formula\": {\"Cl\": 1.0, \"K\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -436500.0,\n            \"S_0\": 82.6,\n            \"V_0\": 3.752e-05,\n            \"Cp\": [46.2, 0.01797, 0.0, 0.0],\n            \"a_0\": 0.0001109,\n            \"K_0\": 17000e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -2.94e-10,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0745513,\n        }\n        Mineral.__init__(self)",
  "class hlt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hlt\",\n            \"formula\": {\"Cl\": 1.0, \"Na\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -411300.0,\n            \"S_0\": 72.1,\n            \"V_0\": 2.702e-05,\n            \"Cp\": [45.2, 0.01797, 0.0, 0.0],\n            \"a_0\": 0.0001147,\n            \"K_0\": 23800e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -2.1e-10,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0584428,\n        }\n        Mineral.__init__(self)",
  "class pyr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pyr\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -171640.0,\n            \"S_0\": 52.9,\n            \"V_0\": 2.394e-05,\n            \"Cp\": [37.3, 0.026715, -1817000.0, 649.3],\n            \"a_0\": 3.1e-05,\n            \"K_0\": 139500e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -2.9e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.119975,\n        }\n        Mineral.__init__(self)",
  "class trot(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"trot\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -99030.0,\n            \"S_0\": 65.5,\n            \"V_0\": 1.819e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 5.68e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 598.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 4.1e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class tro(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tro\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -97760.0,\n            \"S_0\": 70.8,\n            \"V_0\": 1.819e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 5.73e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 598.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 4.1e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class lot(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lot\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -102160.0,\n            \"S_0\": 60.0,\n            \"V_0\": 1.818e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 4.93e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 420.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class trov(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"trov\",\n            \"formula\": {\"Fe\": 0.875, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -96020.0,\n            \"S_0\": 57.5,\n            \"V_0\": 1.738e-05,\n            \"Cp\": [51.1, 0.008307, -669700.0, 0.0],\n            \"a_0\": 5.94e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 1.875,\n            \"molar_mass\": 0.080929375,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 595.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 1.6e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class any(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"any\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 4.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1434400.0,\n            \"S_0\": 106.9,\n            \"V_0\": 4.594e-05,\n            \"Cp\": [128.7, 0.048545, -1223000.0, -560.5],\n            \"a_0\": 4.18e-05,\n            \"K_0\": 54379999999.99999,\n            \"Kprime_0\": 4.19,\n            \"Kdprime_0\": -7.7e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.1361406,\n        }\n        Mineral.__init__(self)",
  "class iron(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"iron\",\n            \"formula\": {\"Fe\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -0.0,\n            \"S_0\": 27.09,\n            \"V_0\": 7.09e-06,\n            \"Cp\": [46.2, 0.005159, 723100.0, -556.2],\n            \"a_0\": 3.56e-05,\n            \"K_0\": 164000e6,\n            \"Kprime_0\": 5.16,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.055845,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1042.0,\n                    \"S_D\": 8.3,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class Ni(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Ni\",\n            \"formula\": {\"Ni\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 29.87,\n            \"V_0\": 6.59e-06,\n            \"Cp\": [49.8, 0.0, 585900.0, -533.9],\n            \"a_0\": 4.28e-05,\n            \"K_0\": 190500e6,\n            \"Kprime_0\": 4.25,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0586934,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\"P_0\": 100000.0, \"T_0\": 298.15, \"Tc_0\": 631.0, \"S_D\": 3.0, \"V_D\": 0.0},\n            ]\n        ]\n        Mineral.__init__(self)",
  "class Cu(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Cu\",\n            \"formula\": {\"Cu\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -0.0,\n            \"S_0\": 33.14,\n            \"V_0\": 7.11e-06,\n            \"Cp\": [12.4, 0.00922, -379900.0, 233.5],\n            \"a_0\": 3.58e-05,\n            \"K_0\": 162500e6,\n            \"Kprime_0\": 4.24,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.063546,\n        }\n        Mineral.__init__(self)",
  "class gph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"gph\",\n            \"formula\": {\"C\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 5.76,\n            \"V_0\": 5.3e-06,\n            \"Cp\": [34.3, 0.0, -240700.0, -403.8],\n            \"a_0\": 1.65e-05,\n            \"K_0\": 31200e6,\n            \"Kprime_0\": 3.9,\n            \"Kdprime_0\": -1.25e-10,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0120107,\n        }\n        Mineral.__init__(self)",
  "class diam(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"diam\",\n            \"formula\": {\"C\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 1890.0,\n            \"S_0\": 2.36,\n            \"V_0\": 3.42e-06,\n            \"Cp\": [40.0, 0.0, -28500.0, -580.5],\n            \"a_0\": 4e-06,\n            \"K_0\": 446500e6,\n            \"Kprime_0\": 1.61,\n            \"Kdprime_0\": -3.6e-12,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0120107,\n        }\n        Mineral.__init__(self)",
  "class S(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"S\",\n            \"formula\": {\"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 32.05,\n            \"V_0\": 1.551e-05,\n            \"Cp\": [56.6, -0.004557, 638000.0, -681.8],\n            \"a_0\": 6.4e-05,\n            \"K_0\": 14500e6,\n            \"Kprime_0\": 7.0,\n            \"Kdprime_0\": -4.8e-10,\n            \"n\": 1.0,\n            \"molar_mass\": 0.032065,\n        }\n        Mineral.__init__(self)",
  "class syvL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"syvL\",\n            \"formula\": {\"Cl\": 1.0, \"K\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -417410.0,\n            \"S_0\": 94.5,\n            \"V_0\": 3.822e-05,\n            \"Cp\": [66.9, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000301,\n            \"K_0\": 5600e6,\n            \"Kprime_0\": 4.65,\n            \"Kdprime_0\": -8.3e-10,\n            \"dKdT_0\": -2e6,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0745513,\n        }\n        Mineral.__init__(self)",
  "class hltL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hltL\",\n            \"formula\": {\"Cl\": 1.0, \"Na\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -392990.0,\n            \"S_0\": 80.1,\n            \"V_0\": 2.938e-05,\n            \"Cp\": [72.0, -0.003223, 0.0, 0.0],\n            \"a_0\": 0.000295,\n            \"K_0\": 6400e6,\n            \"Kprime_0\": 4.61,\n            \"Kdprime_0\": -7.2e-10,\n            \"dKdT_0\": -1500000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0584428,\n        }\n        Mineral.__init__(self)",
  "class perL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"perL\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -654120.0,\n            \"S_0\": -64.3,\n            \"V_0\": 8.39e-06,\n            \"Cp\": [99.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000226,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4100000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0403044,\n        }\n        Mineral.__init__(self)",
  "class limL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"limL\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -692280.0,\n            \"S_0\": -47.5,\n            \"V_0\": 1.303e-05,\n            \"Cp\": [99.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000175,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4100000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0560774,\n        }\n        Mineral.__init__(self)",
  "class corL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"corL\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1632160.0,\n            \"S_0\": 14.9,\n            \"V_0\": 3.369e-05,\n            \"Cp\": [157.6, 0.0, 0.0, 0.0],\n            \"a_0\": 7.03e-05,\n            \"K_0\": 15000e6,\n            \"Kprime_0\": 6.0,\n            \"Kdprime_0\": 4e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "class qL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"qL\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -921070.0,\n            \"S_0\": 16.3,\n            \"V_0\": 2.73e-05,\n            \"Cp\": [82.5, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0,\n            \"K_0\": 22000e6,\n            \"Kprime_0\": 9.46,\n            \"Kdprime_0\": -4.3e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "class h2oL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"h2oL\",\n            \"formula\": {\"H\": 2.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -295010.0,\n            \"S_0\": 45.5,\n            \"V_0\": 1.39e-05,\n            \"Cp\": [80.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000521,\n            \"K_0\": 5060e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -7.9e-10,\n            \"dKdT_0\": -370000.0,\n            \"n\": 3.0,\n            \"molar_mass\": 0.01801528,\n        }\n        Mineral.__init__(self)",
  "class foL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"foL\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2237350.0,\n            \"S_0\": -62.0,\n            \"V_0\": 4.312e-05,\n            \"Cp\": [269.4, 0.0, 0.0, 0.0],\n            \"a_0\": 9.2e-05,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4400000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "class faL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"faL\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1463020.0,\n            \"S_0\": 96.0,\n            \"V_0\": 4.677e-05,\n            \"Cp\": [243.7, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0001071,\n            \"K_0\": 29000e6,\n            \"Kprime_0\": 10.42,\n            \"Kdprime_0\": -3.59e-10,\n            \"dKdT_0\": -5500000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "class woL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"woL\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1642220.0,\n            \"S_0\": 22.5,\n            \"V_0\": 3.965e-05,\n            \"Cp\": [167.4, 0.0, 0.0, 0.0],\n            \"a_0\": 6.69e-05,\n            \"K_0\": 30500e6,\n            \"Kprime_0\": 9.38,\n            \"Kdprime_0\": -3.08e-10,\n            \"dKdT_0\": -2e6,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "class enL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"enL\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3096570.0,\n            \"S_0\": -4.0,\n            \"V_0\": 6.984e-05,\n            \"Cp\": [353.6, 0.0, 0.0, 0.0],\n            \"a_0\": 6.81e-05,\n            \"K_0\": 21800e6,\n            \"Kprime_0\": 7.2,\n            \"Kdprime_0\": -3.3e-10,\n            \"dKdT_0\": -2400000.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "class diL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"diL\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3193870.0,\n            \"S_0\": 42.1,\n            \"V_0\": 7.288e-05,\n            \"Cp\": [334.0, 0.0, 0.0, 0.0],\n            \"a_0\": 8.51e-05,\n            \"K_0\": 24900e6,\n            \"Kprime_0\": 8.04,\n            \"Kdprime_0\": -3.23e-10,\n            \"dKdT_0\": -3730000.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2165504,\n        }\n        Mineral.__init__(self)",
  "class silL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"silL\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2593430.0,\n            \"S_0\": 10.0,\n            \"V_0\": 6.051e-05,\n            \"Cp\": [253.0, 0.0, 0.0, 0.0],\n            \"a_0\": 4.08e-05,\n            \"K_0\": 22000e6,\n            \"Kprime_0\": 6.36,\n            \"Kdprime_0\": -2.89e-10,\n            \"dKdT_0\": -2900000.0,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "class anL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"anL\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -4277970.0,\n            \"S_0\": 29.0,\n            \"V_0\": 0.00010014,\n            \"Cp\": [430.0, 0.0, 0.0, 0.0],\n            \"a_0\": 5.14e-05,\n            \"K_0\": 21000e6,\n            \"Kprime_0\": 6.38,\n            \"Kdprime_0\": -3.04e-10,\n            \"dKdT_0\": -5500000.0,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2782072,\n        }\n        Mineral.__init__(self)",
  "class kspL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kspL\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3985190.0,\n            \"S_0\": 129.2,\n            \"V_0\": 0.00011431,\n            \"Cp\": [368.0, 0.0, 0.0, 0.0],\n            \"a_0\": 4.93e-05,\n            \"K_0\": 17300e6,\n            \"Kprime_0\": 6.84,\n            \"Kdprime_0\": -3.93e-10,\n            \"dKdT_0\": -899999.9999999999,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "class abL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"abL\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3926520.0,\n            \"S_0\": 149.9,\n            \"V_0\": 0.00010858,\n            \"Cp\": [358.0, 0.0, 0.0, 0.0],\n            \"a_0\": 3.37e-05,\n            \"K_0\": 17600e6,\n            \"Kprime_0\": 14.35,\n            \"Kdprime_0\": -8.15e-10,\n            \"dKdT_0\": -2600000.0,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        Mineral.__init__(self)",
  "class neL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"neL\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2116730.0,\n            \"S_0\": 52.9,\n            \"V_0\": 5.2e-05,\n            \"Cp\": [216.5, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000137,\n            \"K_0\": 25000e6,\n            \"Kprime_0\": 7.37,\n            \"Kdprime_0\": -2.95e-10,\n            \"dKdT_0\": -800000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "class lcL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lcL\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3068410.0,\n            \"S_0\": 102.0,\n            \"V_0\": 8.59e-05,\n            \"Cp\": [287.0, 0.0, 0.0, 0.0],\n            \"a_0\": 6.7e-05,\n            \"K_0\": 17500e6,\n            \"Kprime_0\": 7.0,\n            \"Kdprime_0\": -3.94e-10,\n            \"dKdT_0\": -0.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2182472,\n        }\n        Mineral.__init__(self)",
  "def cov():\n    \"\"\"\n    A function which loads and returns the variance-covariance matrix of the\n    zero-point energies of all the endmembers in the dataset.\n\n    Returns\n    -------\n    cov : dictionary\n        Dictionary keys are:\n        - endmember_names: a list of endmember names, and\n        - covariance_matrix: a 2D variance-covariance array for the\n          endmember zero-point energies of formation\n    \"\"\"\n\n    from .HP_2011_ds62_cov import cov\n\n    return cov",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fo\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2172590.0,\n            \"S_0\": 95.1,\n            \"V_0\": 4.366e-05,\n            \"Cp\": [233.3, 0.001494, -603800.0, -1869.7],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 128500e6,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fa\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1477720.0,\n            \"S_0\": 151.0,\n            \"V_0\": 4.631e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.82e-05,\n            \"K_0\": 125600e6,\n            \"Kprime_0\": 4.68,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"teph\",\n            \"formula\": {\"Mn\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1733970.0,\n            \"S_0\": 155.9,\n            \"V_0\": 4.899e-05,\n            \"Cp\": [219.6, 0.0, -1292700.0, -1308.3],\n            \"a_0\": 2.86e-05,\n            \"K_0\": 125600e6,\n            \"Kprime_0\": 4.68,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2019591,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lrn\",\n            \"formula\": {\"Ca\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2306920.0,\n            \"S_0\": 127.6,\n            \"V_0\": 5.16e-05,\n            \"Cp\": [247.5, -0.003206, 0.0, -2051.9],\n            \"a_0\": 2.9e-05,\n            \"K_0\": 98500e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1722391,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1710.0,\n                    \"S_D\": 10.03,\n                    \"V_D\": 5e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mont\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2251260.0,\n            \"S_0\": 109.5,\n            \"V_0\": 5.148e-05,\n            \"Cp\": [250.7, -0.010433, -797200.0, -1996.1],\n            \"a_0\": 2.87e-05,\n            \"K_0\": 113400e6,\n            \"Kprime_0\": 3.87,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1564661,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"chum\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 9.0, \"O\": 18.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9613540.0,\n            \"S_0\": 440.5,\n            \"V_0\": 0.00019801,\n            \"Cp\": [1071.0, -0.016533, -7899600.0, -7373.9],\n            \"a_0\": 3.2e-05,\n            \"K_0\": 119900e6,\n            \"Kprime_0\": 4.58,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 33.0,\n            \"molar_mass\": 0.62109208,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"chdr\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 5.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5254890.0,\n            \"S_0\": 260.0,\n            \"V_0\": 0.00011084,\n            \"Cp\": [625.0, -0.001088, -2259900.0, -4910.7],\n            \"a_0\": 1.82e-05,\n            \"K_0\": 116100e6,\n            \"Kprime_0\": 4.8,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.33970588,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mwd\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2138520.0,\n            \"S_0\": 93.9,\n            \"V_0\": 4.051e-05,\n            \"Cp\": [208.7, 0.003942, -1709500.0, -1302.8],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 172600e6,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fwd\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1467900.0,\n            \"S_0\": 146.0,\n            \"V_0\": 4.321e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 169000e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mrw\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2127680.0,\n            \"S_0\": 90.0,\n            \"V_0\": 3.949e-05,\n            \"Cp\": [213.3, 0.00269, -1410400.0, -1495.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 178100e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"frw\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1471760.0,\n            \"S_0\": 140.0,\n            \"V_0\": 4.203e-05,\n            \"Cp\": [166.8, 0.04261, -1705400.0, -541.4],\n            \"a_0\": 2.22e-05,\n            \"K_0\": 197700e6,\n            \"Kprime_0\": 4.92,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mpv\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1443030.0,\n            \"S_0\": 62.6,\n            \"V_0\": 2.445e-05,\n            \"Cp\": [149.3, 0.002918, -2983000.0, -799.1],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 251000e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fpv\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1084640.0,\n            \"S_0\": 91.0,\n            \"V_0\": 2.548e-05,\n            \"Cp\": [133.2, 0.01083, -3661400.0, -314.7],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 281000e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1319287,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"apv\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1646630.0,\n            \"S_0\": 51.8,\n            \"V_0\": 2.54e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 203000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cpv\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1541730.0,\n            \"S_0\": 73.5,\n            \"V_0\": 2.745e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 236000e6,\n            \"Kprime_0\": 3.9,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mak\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1490870.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 211000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fak\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1142140.0,\n            \"S_0\": 91.5,\n            \"V_0\": 2.76e-05,\n            \"Cp\": [100.3, 0.013328, -4364900.0, 419.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 218000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1319287,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"maj\",\n            \"formula\": {\"Mg\": 4.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6050400.0,\n            \"S_0\": 255.2,\n            \"V_0\": 0.00011457,\n            \"Cp\": [713.6, -0.000997, -1158200.0, -6622.3],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 160000e6,\n            \"Kprime_0\": 4.56,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4015548,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"py\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6281960.0,\n            \"S_0\": 269.5,\n            \"V_0\": 0.00011313,\n            \"Cp\": [633.5, 0.0, -5196100.0, -4315.2],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 174300e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4031273,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"alm\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5260700.0,\n            \"S_0\": 342.0,\n            \"V_0\": 0.00011525,\n            \"Cp\": [677.3, 0.0, -3772700.0, -5044.0],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 190000e6,\n            \"Kprime_0\": 2.98,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4977473,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"spss\",\n            \"formula\": {\"Al\": 2.0, \"Mn\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5693490.0,\n            \"S_0\": 335.3,\n            \"V_0\": 0.00011792,\n            \"Cp\": [646.9, 0.0, -4525800.0, -4452.8],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 6.68,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4950263,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"gr\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6643010.0,\n            \"S_0\": 255.0,\n            \"V_0\": 0.00012535,\n            \"Cp\": [626.0, 0.0, -5779200.0, -4002.9],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 172000e6,\n            \"Kprime_0\": 5.53,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4504463,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"andr\",\n            \"formula\": {\"Ca\": 3.0, \"Fe\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5769100.0,\n            \"S_0\": 316.4,\n            \"V_0\": 0.00013204,\n            \"Cp\": [638.6, 0.0, -4955100.0, -3989.2],\n            \"a_0\": 2.86e-05,\n            \"K_0\": 158800e6,\n            \"Kprime_0\": 5.68,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.5081733,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"knor\",\n            \"formula\": {\"Cr\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5687710.0,\n            \"S_0\": 317.0,\n            \"V_0\": 0.00011738,\n            \"Cp\": [613.0, 0.003606, -4178000.0, -3729.4],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 174300e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4531565,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"osma\",\n            \"formula\": {\"Al\": 5.0, \"K\": 1.0, \"Mg\": 2.0, \"O\": 30.0, \"Si\": 10.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14896310.0,\n            \"S_0\": 755.0,\n            \"V_0\": 0.00037893,\n            \"Cp\": [1540.7, -0.011359, -10339000.0, -11699.0],\n            \"a_0\": 4.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 0.9834528,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"osmm\",\n            \"formula\": {\"Al\": 3.0, \"K\": 1.0, \"Mg\": 3.0, \"O\": 30.0, \"Si\": 11.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14786740.0,\n            \"S_0\": 740.0,\n            \"V_0\": 0.0003844,\n            \"Cp\": [1525.5, -0.010267, -10538000.0, -11337.0],\n            \"a_0\": 4.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 0.9818803,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"osfa\",\n            \"formula\": {\"Al\": 5.0, \"Fe\": 2.0, \"K\": 1.0, \"O\": 30.0, \"Si\": 10.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14215490.0,\n            \"S_0\": 780.0,\n            \"V_0\": 0.0003845,\n            \"Cp\": [1558.6, -0.011359, -9476500.0, -11845.0],\n            \"a_0\": 4.9e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 1.0465328,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"vsv\",\n            \"formula\": {\n                \"Al\": 11.0,\n                \"Ca\": 19.0,\n                \"H\": 9.0,\n                \"Mg\": 2.0,\n                \"O\": 78.0,\n                \"Si\": 18.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -42345820.0,\n            \"S_0\": 1890.0,\n            \"V_0\": 0.000852,\n            \"Cp\": [4488.0, -0.057952, -22269300.0, -33478.0],\n            \"a_0\": 2.75e-05,\n            \"K_0\": 125500e6,\n            \"Kprime_0\": 4.8,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 137.0,\n            \"molar_mass\": 2.86945216,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"and\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2588670.0,\n            \"S_0\": 92.7,\n            \"V_0\": 5.153e-05,\n            \"Cp\": [277.3, -0.006588, -1914100.0, -2265.6],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 144200e6,\n            \"Kprime_0\": 6.89,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ky\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2592970.0,\n            \"S_0\": 83.5,\n            \"V_0\": 4.414e-05,\n            \"Cp\": [279.4, -0.007124, -2055600.0, -2289.4],\n            \"a_0\": 1.92e-05,\n            \"K_0\": 160100e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sill\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2585790.0,\n            \"S_0\": 95.4,\n            \"V_0\": 4.986e-05,\n            \"Cp\": [280.2, -0.0069, -1375700.0, -2399.4],\n            \"a_0\": 1.12e-05,\n            \"K_0\": 164000e6,\n            \"Kprime_0\": 5.06,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 4750.0,\n                    \"deltaV\": 1e-07,\n                    \"Wh\": 4750.0,\n                    \"Wv\": 1e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.25,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"smul\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2569210.0,\n            \"S_0\": 101.5,\n            \"V_0\": 4.987e-05,\n            \"Cp\": [280.2, -0.0069, -1375700.0, -2399.4],\n            \"a_0\": 1.36e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"amul\",\n            \"formula\": {\"Al\": 2.5, \"O\": 4.75, \"Si\": 0.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2485530.0,\n            \"S_0\": 113.0,\n            \"V_0\": 5.083e-05,\n            \"Cp\": [244.8, 0.000968, -2533300.0, -1641.6],\n            \"a_0\": 1.36e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 7.75,\n            \"molar_mass\": 0.15749365,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tpz\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2900710.0,\n            \"S_0\": 100.5,\n            \"V_0\": 5.339e-05,\n            \"Cp\": [387.7, -0.00712, -857200.0, -3744.2],\n            \"a_0\": 1.57e-05,\n            \"K_0\": 131500e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 11.0,\n            \"molar_mass\": 0.18006078,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mst\",\n            \"formula\": {\"Al\": 18.0, \"H\": 4.0, \"Mg\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -25123740.0,\n            \"S_0\": 910.0,\n            \"V_0\": 0.0004426,\n            \"Cp\": [2820.5, -0.059366, -13774000.0, -24126.0],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 168400e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.56553121,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fst\",\n            \"formula\": {\"Al\": 18.0, \"Fe\": 4.0, \"H\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -23754630.0,\n            \"S_0\": 1010.0,\n            \"V_0\": 0.0004488,\n            \"Cp\": [2880.0, -0.056595, -10642000.0, -25373.0],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.76,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.69169121,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mnst\",\n            \"formula\": {\"Al\": 18.0, \"H\": 4.0, \"Mn\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -24245850.0,\n            \"S_0\": 1034.0,\n            \"V_0\": 0.0004546,\n            \"Cp\": [2873.3, -0.089064, -12688000.0, -24749.0],\n            \"a_0\": 2.09e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.76,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.68806321,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mctd\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mg\": 1.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3549250.0,\n            \"S_0\": 146.0,\n            \"V_0\": 6.875e-05,\n            \"Cp\": [417.4, -0.003771, -2920600.0, -3417.8],\n            \"a_0\": 2.63e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.22036518,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fctd\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"H\": 2.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3208290.0,\n            \"S_0\": 167.0,\n            \"V_0\": 6.98e-05,\n            \"Cp\": [416.1, -0.003477, -2835900.0, -3360.3],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.25190518,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mnctd\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mn\": 1.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3336150.0,\n            \"S_0\": 166.0,\n            \"V_0\": 7.175e-05,\n            \"Cp\": [464.4, -0.012654, -1147200.0, -4341.0],\n            \"a_0\": 2.6e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.25099818,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"merw\",\n            \"formula\": {\"Ca\": 3.0, \"Mg\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4545700.0,\n            \"S_0\": 253.1,\n            \"V_0\": 9.847e-05,\n            \"Cp\": [417.5, 0.008117, -2923000.0, -2320.3],\n            \"a_0\": 3.19e-05,\n            \"K_0\": 120000e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 14.0,\n            \"molar_mass\": 0.3287052,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"spu\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 5.0, \"O\": 11.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5846720.0,\n            \"S_0\": 332.0,\n            \"V_0\": 0.00014697,\n            \"Cp\": [614.1, -0.003508, -2493100.0, -4168.0],\n            \"a_0\": 3.4e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.4445651,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"zo\",\n            \"formula\": {\"Al\": 3.0, \"Ca\": 2.0, \"H\": 1.0, \"O\": 13.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6896290.0,\n            \"S_0\": 298.0,\n            \"V_0\": 0.00013575,\n            \"Cp\": [662.0, 0.010416, -6006400.0, -4260.7],\n            \"a_0\": 3.12e-05,\n            \"K_0\": 104400e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.45435714,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cz\",\n            \"formula\": {\"Al\": 3.0, \"Ca\": 2.0, \"H\": 1.0, \"O\": 13.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6895540.0,\n            \"S_0\": 301.0,\n            \"V_0\": 0.0001363,\n            \"Cp\": [630.9, 0.013693, -6645800.0, -3731.1],\n            \"a_0\": 2.33e-05,\n            \"K_0\": 119700e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.45435714,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ep\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Ca\": 2.0,\n                \"Fe\": 1.0,\n                \"H\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6473830.0,\n            \"S_0\": 315.0,\n            \"V_0\": 0.0001392,\n            \"Cp\": [613.3, 0.02207, -7160000.0, -2987.7],\n            \"a_0\": 2.34e-05,\n            \"K_0\": 134000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.48322064,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fep\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"Ca\": 2.0,\n                \"Fe\": 2.0,\n                \"H\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6028590.0,\n            \"S_0\": 329.0,\n            \"V_0\": 0.0001421,\n            \"Cp\": [584.7, 0.030447, -7674200.0, -2244.3],\n            \"a_0\": 2.31e-05,\n            \"K_0\": 151300e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.51208414,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pmt\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Ca\": 2.0,\n                \"H\": 1.0,\n                \"Mn\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6543030.0,\n            \"S_0\": 340.0,\n            \"V_0\": 0.0001382,\n            \"Cp\": [569.8, 0.02779, -5442900.0, -2812.6],\n            \"a_0\": 2.38e-05,\n            \"K_0\": 119700e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.48231364,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"law\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 4.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4868630.0,\n            \"S_0\": 229.0,\n            \"V_0\": 0.00010132,\n            \"Cp\": [687.8, 0.001566, 375900.0, -7179.2],\n            \"a_0\": 2.65e-05,\n            \"K_0\": 122900e6,\n            \"Kprime_0\": 5.45,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.31423776,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mpm\",\n            \"formula\": {\n                \"Al\": 5.0,\n                \"Ca\": 4.0,\n                \"H\": 7.0,\n                \"Mg\": 1.0,\n                \"O\": 28.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14386910.0,\n            \"S_0\": 629.0,\n            \"V_0\": 0.0002955,\n            \"Cp\": [1720.8, -0.024928, -5998700.0, -14620.3],\n            \"a_0\": 2.48e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 0.94307628,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fpm\",\n            \"formula\": {\n                \"Al\": 5.0,\n                \"Ca\": 4.0,\n                \"Fe\": 1.0,\n                \"H\": 7.0,\n                \"O\": 28.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14034040.0,\n            \"S_0\": 657.0,\n            \"V_0\": 0.0002968,\n            \"Cp\": [1737.2, -0.024582, -5161100.0, -14963.0],\n            \"a_0\": 2.49e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 0.97461628,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"jgd\",\n            \"formula\": {\"Ca\": 4.0, \"Fe\": 6.0, \"H\": 7.0, \"O\": 28.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11808960.0,\n            \"S_0\": 830.0,\n            \"V_0\": 0.0003108,\n            \"Cp\": [1795.4, -0.037986, -4455700.0, -14888.0],\n            \"a_0\": 2.49e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 1.11893378,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"geh\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 2.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3992240.0,\n            \"S_0\": 198.5,\n            \"V_0\": 9.024e-05,\n            \"Cp\": [405.7, -0.007099, -1188300.0, -3174.4],\n            \"a_0\": 2.23e-05,\n            \"K_0\": 108000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2742003,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 7510.0,\n                    \"deltaV\": 9e-07,\n                    \"Wh\": 7500.0,\n                    \"Wv\": 9e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.8,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ak\",\n            \"formula\": {\"Ca\": 2.0, \"Mg\": 1.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3865620.0,\n            \"S_0\": 212.5,\n            \"V_0\": 9.254e-05,\n            \"Cp\": [385.4, 0.003209, -247500.0, -2889.9],\n            \"a_0\": 2.57e-05,\n            \"K_0\": 142000e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.9e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2726278,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"rnk\",\n            \"formula\": {\"Ca\": 3.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3943820.0,\n            \"S_0\": 210.0,\n            \"V_0\": 9.651e-05,\n            \"Cp\": [372.3, -0.002893, -2462400.0, -2181.3],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2884008,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ty\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 5.0, \"O\": 13.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6368040.0,\n            \"S_0\": 390.0,\n            \"V_0\": 0.00017039,\n            \"Cp\": [741.7, -0.005345, -1434600.0, -5878.5],\n            \"a_0\": 3.42e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.4885746,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"crd\",\n            \"formula\": {\"Al\": 4.0, \"Mg\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9163430.0,\n            \"S_0\": 404.1,\n            \"V_0\": 0.00023322,\n            \"Cp\": [906.1, 0.0, -7902000.0, -6293.4],\n            \"a_0\": 6.8e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.5849527,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hcrd\",\n            \"formula\": {\"Al\": 4.0, \"H\": 2.0, \"Mg\": 2.0, \"O\": 19.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9448520.0,\n            \"S_0\": 483.0,\n            \"V_0\": 0.00023322,\n            \"Cp\": [955.3, 0.0, -8352600.0, -6301.2],\n            \"a_0\": 6.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 32.0,\n            \"molar_mass\": 0.60296798,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fcrd\",\n            \"formula\": {\"Al\": 4.0, \"Fe\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8444070.0,\n            \"S_0\": 461.0,\n            \"V_0\": 0.0002371,\n            \"Cp\": [924.0, 0.0, -7039400.0, -6439.6],\n            \"a_0\": 6.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.6480327,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mncrd\",\n            \"formula\": {\"Al\": 4.0, \"Mn\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8693590.0,\n            \"S_0\": 473.0,\n            \"V_0\": 0.00024027,\n            \"Cp\": [886.5, 0.0, -8840000.0, -5590.4],\n            \"a_0\": 6.9e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.6462187,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"phA\",\n            \"formula\": {\"H\": 6.0, \"Mg\": 7.0, \"O\": 14.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7129620.0,\n            \"S_0\": 350.5,\n            \"V_0\": 0.00015422,\n            \"Cp\": [962.0, -0.011521, -4517800.0, -7724.7],\n            \"a_0\": 3.55e-05,\n            \"K_0\": 145000e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.45634524,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sph\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 5.0, \"Si\": 1.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2601660.0,\n            \"S_0\": 124.0,\n            \"V_0\": 5.565e-05,\n            \"Cp\": [227.9, 0.002924, -3539500.0, -894.3],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 101700e6,\n            \"Kprime_0\": 9.85,\n            \"Kdprime_0\": -9.7e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1960275,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 485.0,\n                    \"S_D\": 0.4,\n                    \"V_D\": 5e-08,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cstn\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 5.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2496350.0,\n            \"S_0\": 99.5,\n            \"V_0\": 4.818e-05,\n            \"Cp\": [205.6, 0.006034, -5517700.0, -352.6],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 178200e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.176246,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"zrc\",\n            \"formula\": {\"O\": 4.0, \"Si\": 1.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2035070.0,\n            \"S_0\": 83.03,\n            \"V_0\": 3.926e-05,\n            \"Cp\": [232.0, -0.014405, 0.0, -2238.2],\n            \"a_0\": 1.25e-05,\n            \"K_0\": 230100e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.1833071,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"en\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3090220.0,\n            \"S_0\": 132.5,\n            \"V_0\": 6.262e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pren\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3084560.0,\n            \"S_0\": 137.0,\n            \"V_0\": 6.476e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.3e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cen\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3091110.0,\n            \"S_0\": 132.0,\n            \"V_0\": 6.264e-05,\n            \"Cp\": [306.0, -0.003793, -3041700.0, -1852.1],\n            \"a_0\": 2.11e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hen\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3082730.0,\n            \"S_0\": 131.7,\n            \"V_0\": 6.099e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.26e-05,\n            \"K_0\": 150000e6,\n            \"Kprime_0\": 5.5,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fs\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2388710.0,\n            \"S_0\": 189.9,\n            \"V_0\": 6.592e-05,\n            \"Cp\": [398.7, -0.006579, 1290100.0, -4058.0],\n            \"a_0\": 3.26e-05,\n            \"K_0\": 101000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2638574,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mgts\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3196670.0,\n            \"S_0\": 131.0,\n            \"V_0\": 6.05e-05,\n            \"Cp\": [371.4, -0.004082, -398400.0, -3547.1],\n            \"a_0\": 2.17e-05,\n            \"K_0\": 102800e6,\n            \"Kprime_0\": 8.55,\n            \"Kdprime_0\": -8.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2023499,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"di\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3201850.0,\n            \"S_0\": 142.9,\n            \"V_0\": 6.619e-05,\n            \"Cp\": [314.5, 4.1e-05, -2745900.0, -2020.1],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2165504,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hed\",\n            \"formula\": {\"Ca\": 1.0, \"Fe\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2842060.0,\n            \"S_0\": 175.0,\n            \"V_0\": 6.795e-05,\n            \"Cp\": [340.2, 0.000812, -1047800.0, -2646.7],\n            \"a_0\": 2.38e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 3.97,\n            \"Kdprime_0\": -3.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2480904,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"jd\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3025270.0,\n            \"S_0\": 133.5,\n            \"V_0\": 6.04e-05,\n            \"Cp\": [319.4, 0.003616, -1173900.0, -2469.5],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 128100e6,\n            \"Kprime_0\": 3.81,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2021387,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"acm\",\n            \"formula\": {\"Fe\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2583430.0,\n            \"S_0\": 170.6,\n            \"V_0\": 6.459e-05,\n            \"Cp\": [307.1, 0.016758, -1685500.0, -2125.8],\n            \"a_0\": 2.11e-05,\n            \"K_0\": 106000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2310022,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kos\",\n            \"formula\": {\"Cr\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2746840.0,\n            \"S_0\": 149.65,\n            \"V_0\": 6.309e-05,\n            \"Cp\": [309.2, 0.005419, -664600.0, -2176.6],\n            \"a_0\": 1.94e-05,\n            \"K_0\": 130800e6,\n            \"Kprime_0\": 3.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2271533,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cats\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3310110.0,\n            \"S_0\": 135.0,\n            \"V_0\": 6.356e-05,\n            \"Cp\": [347.6, -0.006974, -1781600.0, -2757.5],\n            \"a_0\": 2.08e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2181229,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 3800.0,\n                    \"deltaV\": 1e-07,\n                    \"Wh\": 3800.0,\n                    \"Wv\": 1e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.25,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"caes\",\n            \"formula\": {\"Al\": 1.0, \"Ca\": 0.5, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3002020.0,\n            \"S_0\": 127.0,\n            \"V_0\": 6.05e-05,\n            \"Cp\": [362.0, -0.016944, -175900.0, -3565.7],\n            \"a_0\": 2.31e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 9.5,\n            \"molar_mass\": 0.1991879,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"rhod\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1322380.0,\n            \"S_0\": 100.5,\n            \"V_0\": 3.494e-05,\n            \"Cp\": [138.4, 0.004088, -1936000.0, -538.9],\n            \"a_0\": 2.81e-05,\n            \"K_0\": 84000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1310217,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pxmn\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1323160.0,\n            \"S_0\": 99.3,\n            \"V_0\": 3.472e-05,\n            \"Cp\": [138.4, 0.004088, -1936000.0, -538.9],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 84000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1310217,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"wo\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1633770.0,\n            \"S_0\": 82.5,\n            \"V_0\": 3.993e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2.54e-05,\n            \"K_0\": 79500e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pswo\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1627960.0,\n            \"S_0\": 87.8,\n            \"V_0\": 4.008e-05,\n            \"Cp\": [157.8, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 110000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"wal\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1625900.0,\n            \"S_0\": 83.5,\n            \"V_0\": 3.7633e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2.54e-05,\n            \"K_0\": 79500e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tr\",\n            \"formula\": {\"Ca\": 2.0, \"H\": 2.0, \"Mg\": 5.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12304870.0,\n            \"S_0\": 553.0,\n            \"V_0\": 0.0002727,\n            \"Cp\": [1260.2, 0.00383, -11455000.0, -8237.6],\n            \"a_0\": 2.61e-05,\n            \"K_0\": 76200e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.81236648,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fact\",\n            \"formula\": {\"Ca\": 2.0, \"Fe\": 5.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10504120.0,\n            \"S_0\": 710.0,\n            \"V_0\": 0.0002842,\n            \"Cp\": [1290.0, 0.029992, -8447500.0, -8947.0],\n            \"a_0\": 2.88e-05,\n            \"K_0\": 76000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.97006648,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ts\",\n            \"formula\": {\n                \"Al\": 4.0,\n                \"Ca\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"O\": 24.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12555270.0,\n            \"S_0\": 533.0,\n            \"V_0\": 0.000268,\n            \"Cp\": [1244.8, 0.024348, -11965000.0, -8112.1],\n            \"a_0\": 2.66e-05,\n            \"K_0\": 76000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.81551148,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"parg\",\n            \"formula\": {\n                \"Al\": 3.0,\n                \"Ca\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 4.0,\n                \"Na\": 1.0,\n                \"O\": 24.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12664730.0,\n            \"S_0\": 635.0,\n            \"V_0\": 0.0002719,\n            \"Cp\": [1280.2, 0.022997, -12359500.0, -8065.8],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 91200e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.5e-11,\n            \"n\": 42.0,\n            \"molar_mass\": 0.83582478,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"gl\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 2.0,\n                \"O\": 24.0,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11960240.0,\n            \"S_0\": 530.0,\n            \"V_0\": 0.0002598,\n            \"Cp\": [1717.5, -0.12107, 7075000.0, -19272.0],\n            \"a_0\": 1.49e-05,\n            \"K_0\": 88300e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78354308,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fgl\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Fe\": 3.0,\n                \"H\": 2.0,\n                \"Na\": 2.0,\n                \"O\": 24.0,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10880210.0,\n            \"S_0\": 624.0,\n            \"V_0\": 0.0002659,\n            \"Cp\": [1762.9, -0.118992, 9423700.0, -20207.1],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 89000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.87816308,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"rieb\",\n            \"formula\": {\"Fe\": 5.0, \"H\": 2.0, \"Na\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10024780.0,\n            \"S_0\": 695.0,\n            \"V_0\": 0.0002749,\n            \"Cp\": [1787.3, -0.124882, 9627100.0, -20275.5],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 89000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.93589008,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"anth\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 7.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12066840.0,\n            \"S_0\": 537.0,\n            \"V_0\": 0.0002654,\n            \"Cp\": [1277.3, 0.025825, -9704600.0, -9074.7],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78082048,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fanth\",\n            \"formula\": {\"Fe\": 7.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9624520.0,\n            \"S_0\": 725.0,\n            \"V_0\": 0.0002787,\n            \"Cp\": [1383.1, 0.030669, -4224700.0, -11257.6],\n            \"a_0\": 2.74e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 1.00160048,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cumm\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 7.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12064690.0,\n            \"S_0\": 538.0,\n            \"V_0\": 0.0002633,\n            \"Cp\": [1277.3, 0.025825, -9704600.0, -9074.7],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78082048,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"grun\",\n            \"formula\": {\"Fe\": 7.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9607150.0,\n            \"S_0\": 735.0,\n            \"V_0\": 0.0002784,\n            \"Cp\": [1383.1, 0.030669, -4224700.0, -11257.6],\n            \"a_0\": 2.74e-05,\n            \"K_0\": 64800e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 1.00160048,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ged\",\n            \"formula\": {\"Al\": 4.0, \"H\": 2.0, \"Mg\": 5.0, \"O\": 24.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12329140.0,\n            \"S_0\": 517.0,\n            \"V_0\": 0.00025548,\n            \"Cp\": [1307.7, 0.023642, -9307400.0, -9799.0],\n            \"a_0\": 2.41e-05,\n            \"K_0\": 77000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.3e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78396548,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"spr4\",\n            \"formula\": {\"Al\": 8.0, \"Mg\": 4.0, \"O\": 20.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11022020.0,\n            \"S_0\": 425.5,\n            \"V_0\": 0.000199,\n            \"Cp\": [1133.1, -0.007596, -8816600.0, -8180.6],\n            \"a_0\": 2.05e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.689231,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"spr5\",\n            \"formula\": {\"Al\": 10.0, \"Mg\": 3.0, \"O\": 20.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11135570.0,\n            \"S_0\": 419.5,\n            \"V_0\": 0.0001975,\n            \"Cp\": [1103.4, 0.001015, -10957000.0, -7409.2],\n            \"a_0\": 2.06e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.6908035,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fspr\",\n            \"formula\": {\"Al\": 8.0, \"Fe\": 4.0, \"O\": 20.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9659530.0,\n            \"S_0\": 485.0,\n            \"V_0\": 0.00019923,\n            \"Cp\": [1132.9, -0.007348, -10420200.0, -7036.6],\n            \"a_0\": 1.96e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.815391,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mcar\",\n            \"formula\": {\"Al\": 2.0, \"H\": 4.0, \"Mg\": 1.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4771050.0,\n            \"S_0\": 221.5,\n            \"V_0\": 0.0001059,\n            \"Cp\": [683.0, -0.014054, 291000.0, -6976.4],\n            \"a_0\": 2.43e-05,\n            \"K_0\": 52500e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -7.9e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.29846476,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fcar\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"H\": 4.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4411440.0,\n            \"S_0\": 251.1,\n            \"V_0\": 0.00010695,\n            \"Cp\": [686.6, -0.012415, 186000.0, -6884.0],\n            \"a_0\": 2.21e-05,\n            \"K_0\": 52500e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -7.9e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.33000476,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"deer\",\n            \"formula\": {\"Fe\": 18.0, \"H\": 10.0, \"O\": 50.0, \"Si\": 12.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -18341400.0,\n            \"S_0\": 1650.0,\n            \"V_0\": 0.0005574,\n            \"Cp\": [3164.4, -0.027883, -5039100.0, -26721.0],\n            \"a_0\": 2.75e-05,\n            \"K_0\": 63000e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.5e-11,\n            \"n\": 90.0,\n            \"molar_mass\": 2.1522854,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mu\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5976510.0,\n            \"S_0\": 292.0,\n            \"V_0\": 0.00014083,\n            \"Cp\": [756.4, -0.01984, -2170000.0, -6979.2],\n            \"a_0\": 3.07e-05,\n            \"K_0\": 49000e6,\n            \"Kprime_0\": 4.15,\n            \"Kdprime_0\": -8.5e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39830798,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cel\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 1.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5834840.0,\n            \"S_0\": 290.0,\n            \"V_0\": 0.00013957,\n            \"Cp\": [741.2, -0.018748, -2368800.0, -6616.9],\n            \"a_0\": 3.07e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39673548,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fcel\",\n            \"formula\": {\"Al\": 1.0, \"Fe\": 1.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5468490.0,\n            \"S_0\": 330.0,\n            \"V_0\": 0.0001407,\n            \"Cp\": [756.3, -0.019147, -1586100.0, -6928.7],\n            \"a_0\": 3.18e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.42827548,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pa\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"Na\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5942840.0,\n            \"S_0\": 277.0,\n            \"V_0\": 0.00013211,\n            \"Cp\": [803.0, -0.03158, 217000.0, -8151.0],\n            \"a_0\": 3.7e-05,\n            \"K_0\": 51500e6,\n            \"Kprime_0\": 6.51,\n            \"Kdprime_0\": -1.26e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.38219948,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ma\",\n            \"formula\": {\"Al\": 4.0, \"Ca\": 1.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6242070.0,\n            \"S_0\": 265.0,\n            \"V_0\": 0.00012964,\n            \"Cp\": [744.4, -0.0168, -2074400.0, -6783.2],\n            \"a_0\": 2.33e-05,\n            \"K_0\": 100000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39818368,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"phl\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6214880.0,\n            \"S_0\": 326.0,\n            \"V_0\": 0.00014964,\n            \"Cp\": [770.3, -0.036939, -2328900.0, -6531.6],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.41725998,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ann\",\n            \"formula\": {\"Al\": 1.0, \"Fe\": 3.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5143720.0,\n            \"S_0\": 420.0,\n            \"V_0\": 0.00015432,\n            \"Cp\": [815.7, -0.034861, 19800.0, -7466.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.51187998,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mnbi\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mn\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5477520.0,\n            \"S_0\": 433.0,\n            \"V_0\": 0.00015264,\n            \"Cp\": [809.9, -0.059213, -1514400.0, -6998.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 53000e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.50915898,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"east\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 2.0, \"O\": 12.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6330380.0,\n            \"S_0\": 318.0,\n            \"V_0\": 0.00014738,\n            \"Cp\": [785.5, -0.038031, -2130300.0, -6893.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 53000e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.41883248,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"naph\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 1.0,\n                \"O\": 12.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6172010.0,\n            \"S_0\": 318.0,\n            \"V_0\": 0.0001445,\n            \"Cp\": [773.5, -0.040229, -2597900.0, -6512.6],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.40115148,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"clin\",\n            \"formula\": {\"Al\": 2.0, \"H\": 8.0, \"Mg\": 5.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8909160.0,\n            \"S_0\": 437.0,\n            \"V_0\": 0.0002114,\n            \"Cp\": [1170.8, -0.001508, -3825800.0, -10315.0],\n            \"a_0\": 2.04e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55579722,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ames\",\n            \"formula\": {\"Al\": 4.0, \"H\": 8.0, \"Mg\": 4.0, \"O\": 18.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9040460.0,\n            \"S_0\": 412.0,\n            \"V_0\": 0.0002071,\n            \"Cp\": [1186.0, -0.002599, -3627200.0, -10677.0],\n            \"a_0\": 2e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55736972,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"afchl\",\n            \"formula\": {\"H\": 8.0, \"Mg\": 6.0, \"O\": 18.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8727860.0,\n            \"S_0\": 439.0,\n            \"V_0\": 0.0002157,\n            \"Cp\": [1155.0, -0.000417, -4024400.0, -9952.9],\n            \"a_0\": 2.04e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55422472,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"daph\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 5.0, \"H\": 8.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7116910.0,\n            \"S_0\": 584.0,\n            \"V_0\": 0.0002162,\n            \"Cp\": [1192.0, -0.00594, -4826400.0, -9768.3],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.71349722,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mnchl\",\n            \"formula\": {\"Al\": 2.0, \"H\": 8.0, \"Mn\": 5.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7702320.0,\n            \"S_0\": 595.0,\n            \"V_0\": 0.0002259,\n            \"Cp\": [1136.5, -0.005243, -5548100.0, -8911.5],\n            \"a_0\": 2.23e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.70896222,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sud\",\n            \"formula\": {\"Al\": 4.0, \"H\": 8.0, \"Mg\": 2.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8626540.0,\n            \"S_0\": 395.0,\n            \"V_0\": 0.000203,\n            \"Cp\": [1436.1, -0.048749, -2748500.0, -13764.0],\n            \"a_0\": 1.99e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 35.0,\n            \"molar_mass\": 0.53684522,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fsud\",\n            \"formula\": {\"Al\": 4.0, \"Fe\": 2.0, \"H\": 8.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7899850.0,\n            \"S_0\": 456.0,\n            \"V_0\": 0.000204,\n            \"Cp\": [1466.3, -0.047365, -1182800.0, -14388.0],\n            \"a_0\": 2.08e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 35.0,\n            \"molar_mass\": 0.59992522,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"prl\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5640610.0,\n            \"S_0\": 239.0,\n            \"V_0\": 0.00012804,\n            \"Cp\": [784.5, -0.042948, 1251000.0, -8495.9],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 37000e6,\n            \"Kprime_0\": 10.0,\n            \"Kdprime_0\": -2.71e-10,\n            \"n\": 20.0,\n            \"molar_mass\": 0.36031368,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ta\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5897170.0,\n            \"S_0\": 259.0,\n            \"V_0\": 0.00013665,\n            \"Cp\": [622.2, 0.0, -6385500.0, -3916.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.37926568,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fta\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4798540.0,\n            \"S_0\": 352.0,\n            \"V_0\": 0.00014225,\n            \"Cp\": [579.7, 0.039494, -6459300.0, -3088.1],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.47388568,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tats\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mg\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6001290.0,\n            \"S_0\": 259.0,\n            \"V_0\": 0.0001351,\n            \"Cp\": [549.5, 0.036324, -8606600.0, -2515.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.38083818,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tap\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5649780.0,\n            \"S_0\": 235.0,\n            \"V_0\": 0.0001345,\n            \"Cp\": [784.5, -0.042948, 1251000.0, -8495.9],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 37000e6,\n            \"Kprime_0\": 10.0,\n            \"Kdprime_0\": -2.71e-10,\n            \"n\": 20.0,\n            \"molar_mass\": 0.36031368,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"minn\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4819310.0,\n            \"S_0\": 355.0,\n            \"V_0\": 0.00014851,\n            \"Cp\": [579.7, 0.039494, -6459300.0, -3088.1],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.47388568,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"minm\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5866000.0,\n            \"S_0\": 263.9,\n            \"V_0\": 0.00014291,\n            \"Cp\": [622.2, 0.0, -6385500.0, -3916.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.37926568,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kao\",\n            \"formula\": {\"Al\": 2.0, \"H\": 4.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4122000.0,\n            \"S_0\": 203.7,\n            \"V_0\": 9.934e-05,\n            \"Cp\": [436.7, -0.034295, -4055900.0, -2699.1],\n            \"a_0\": 2.51e-05,\n            \"K_0\": 64500e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 17.0,\n            \"molar_mass\": 0.25816036,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pre\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6202170.0,\n            \"S_0\": 292.8,\n            \"V_0\": 0.00014026,\n            \"Cp\": [724.9, -0.013865, -2059000.0, -6323.9],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 109300e6,\n            \"Kprime_0\": 4.01,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.41238418,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fpre\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"Ca\": 2.0,\n                \"Fe\": 1.0,\n                \"H\": 2.0,\n                \"O\": 12.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5766640.0,\n            \"S_0\": 320.0,\n            \"V_0\": 0.000148,\n            \"Cp\": [737.1, -0.01681, -1957300.0, -6358.1],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 109300e6,\n            \"Kprime_0\": 4.01,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.44124768,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"chr\",\n            \"formula\": {\"H\": 4.0, \"Mg\": 3.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4361000.0,\n            \"S_0\": 221.3,\n            \"V_0\": 0.00010746,\n            \"Cp\": [624.7, -0.02077, -1721800.0, -5619.4],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 62800e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.27711236,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"liz\",\n            \"formula\": {\"H\": 4.0, \"Mg\": 3.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4369190.0,\n            \"S_0\": 212.0,\n            \"V_0\": 0.00010645,\n            \"Cp\": [614.7, -0.02077, -1721800.0, -5619.4],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 71000e6,\n            \"Kprime_0\": 3.2,\n            \"Kdprime_0\": -4.5e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.27711236,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"glt\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 4.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3297620.0,\n            \"S_0\": 310.0,\n            \"V_0\": 0.0001198,\n            \"Cp\": [576.4, 0.002984, -3757000.0, -4166.2],\n            \"a_0\": 2.28e-05,\n            \"K_0\": 63000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.37173236,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fstp\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Fe\": 5.0,\n                \"H\": 12.5,\n                \"K\": 0.5,\n                \"O\": 30.5,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12551070.0,\n            \"S_0\": 930.2,\n            \"V_0\": 0.00037239,\n            \"Cp\": [1944.3, -0.012289, -4840200.0, -16635.0],\n            \"a_0\": 3.68e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 58.5,\n            \"molar_mass\": 1.0780021,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mstp\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"H\": 12.5,\n                \"K\": 0.5,\n                \"Mg\": 5.0,\n                \"O\": 30.5,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14288380.0,\n            \"S_0\": 847.4,\n            \"V_0\": 0.00036577,\n            \"Cp\": [1862.2, -0.014018, -8983100.0, -14923.0],\n            \"a_0\": 3.71e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 58.5,\n            \"molar_mass\": 0.9203021,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"atg\",\n            \"formula\": {\"H\": 62.0, \"Mg\": 48.0, \"O\": 147.0, \"Si\": 34.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -71404690.0,\n            \"S_0\": 3620.0,\n            \"V_0\": 0.0017548,\n            \"Cp\": [9621.0, -0.091183, -35941600.0, -83034.2],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 63100e6,\n            \"Kprime_0\": 5.92,\n            \"Kdprime_0\": -9.4e-11,\n            \"n\": 291.0,\n            \"molar_mass\": 4.53595108,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ab\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3935480.0,\n            \"S_0\": 207.4,\n            \"V_0\": 0.00010067,\n            \"Cp\": [452.0, -0.013364, -1275900.0, -3953.6],\n            \"a_0\": 2.36e-05,\n            \"K_0\": 54100e6,\n            \"Kprime_0\": 5.91,\n            \"Kdprime_0\": -1.09e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 14000.0,\n                    \"deltaV\": 4.2e-07,\n                    \"Wh\": 13000.0,\n                    \"Wv\": 4.2e-07,\n                    \"n\": 3.0,\n                    \"factor\": 0.9,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"abh\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3921480.0,\n            \"S_0\": 224.3,\n            \"V_0\": 0.00010105,\n            \"Cp\": [452.0, -0.013364, -1275900.0, -3953.6],\n            \"a_0\": 2.41e-05,\n            \"K_0\": 54100e6,\n            \"Kprime_0\": 5.91,\n            \"Kdprime_0\": -1.09e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mic\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3975350.0,\n            \"S_0\": 214.3,\n            \"V_0\": 0.00010871,\n            \"Cp\": [448.8, -0.010075, -1007300.0, -3973.1],\n            \"a_0\": 1.66e-05,\n            \"K_0\": 58300e6,\n            \"Kprime_0\": 4.02,\n            \"Kdprime_0\": -6.9e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"san\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3966700.0,\n            \"S_0\": 214.3,\n            \"V_0\": 0.00010871,\n            \"Cp\": [448.8, -0.010075, -1007300.0, -3973.1],\n            \"a_0\": 1.66e-05,\n            \"K_0\": 58300e6,\n            \"Kprime_0\": 4.02,\n            \"Kdprime_0\": -6.9e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 8650.0,\n                    \"deltaV\": 2.4e-07,\n                    \"Wh\": 8500.0,\n                    \"Wv\": 2.4e-07,\n                    \"n\": 3.0,\n                    \"factor\": 0.8,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"an\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4232690.0,\n            \"S_0\": 200.5,\n            \"V_0\": 0.00010079,\n            \"Cp\": [370.5, 0.01001, -4339100.0, -1960.6],\n            \"a_0\": 1.41e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2782072,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 42010.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 42000.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 1.0,\n                    \"factor\": 2.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kcm\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"O\": 9.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4232640.0,\n            \"S_0\": 281.5,\n            \"V_0\": 0.00011438,\n            \"Cp\": [536.5, -0.01009, -980400.0, -4735.0],\n            \"a_0\": 3.21e-05,\n            \"K_0\": 42500e6,\n            \"Kprime_0\": 2.0,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 16.0,\n            \"molar_mass\": 0.29634678,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"wa\",\n            \"formula\": {\"K\": 2.0, \"O\": 9.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4271890.0,\n            \"S_0\": 254.0,\n            \"V_0\": 0.00010844,\n            \"Cp\": [499.1, 0.0, 0.0, -4350.1],\n            \"a_0\": 2.66e-05,\n            \"K_0\": 90000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 15.0,\n            \"molar_mass\": 0.3345332,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hol\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3791960.0,\n            \"S_0\": 166.2,\n            \"V_0\": 7.128e-05,\n            \"Cp\": [417.6, -0.003617, -4748100.0, -2819.9],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"q\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -910720.0,\n            \"S_0\": 41.43,\n            \"V_0\": 2.269e-05,\n            \"Cp\": [92.9, -0.000642, -714900.0, -716.1],\n            \"a_0\": 0.0,\n            \"K_0\": 73000e6,\n            \"Kprime_0\": 6.0,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 847.0,\n                    \"S_D\": 4.95,\n                    \"V_D\": 1.188e-06,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"trd\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -907110.0,\n            \"S_0\": 44.1,\n            \"V_0\": 2.8e-05,\n            \"Cp\": [74.9, 0.0031, -1174000.0, -236.7],\n            \"a_0\": 0.0,\n            \"K_0\": 15000e6,\n            \"Kprime_0\": 4.36,\n            \"Kdprime_0\": -2.91e-10,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"crst\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -904270.0,\n            \"S_0\": 50.86,\n            \"V_0\": 2.745e-05,\n            \"Cp\": [72.7, 0.001304, -4129000.0, 0.0],\n            \"a_0\": 0.0,\n            \"K_0\": 16000e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.72e-10,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"coe\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -907000.0,\n            \"S_0\": 39.6,\n            \"V_0\": 2.064e-05,\n            \"Cp\": [107.8, -0.003279, -190300.0, -1041.6],\n            \"a_0\": 1.23e-05,\n            \"K_0\": 97900e6,\n            \"Kprime_0\": 4.19,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"stv\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -876390.0,\n            \"S_0\": 24.0,\n            \"V_0\": 1.401e-05,\n            \"Cp\": [68.1, 0.00601, -1978200.0, -82.1],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 309000e6,\n            \"Kprime_0\": 4.6,\n            \"Kdprime_0\": -1.5e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ne\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2094560.0,\n            \"S_0\": 124.4,\n            \"V_0\": 5.419e-05,\n            \"Cp\": [272.7, -0.012398, 0.0, -2763.1],\n            \"a_0\": 4.63e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 467.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 8e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cg\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2091719.9999999998,\n            \"S_0\": 118.7,\n            \"V_0\": 5.603e-05,\n            \"Cp\": [116.1, 0.086021, -1992700.0, 0.0],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cgh\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2078010.0000000002,\n            \"S_0\": 135.0,\n            \"V_0\": 5.67e-05,\n            \"Cp\": [229.2, 0.011876, 0.0, -1970.7],\n            \"a_0\": 4.67e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sdl\",\n            \"formula\": {\"Al\": 6.0, \"Cl\": 2.0, \"Na\": 8.0, \"O\": 24.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -13405530.0,\n            \"S_0\": 910.0,\n            \"V_0\": 0.0004213,\n            \"Cp\": [1532.7, 0.047747, -2972800.0, -12427.0],\n            \"a_0\": 4.63e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 46.0,\n            \"molar_mass\": 0.969212,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kls\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2122960.0,\n            \"S_0\": 136.0,\n            \"V_0\": 6.052e-05,\n            \"Cp\": [242.0, -0.004482, -895800.0, -1935.8],\n            \"a_0\": 3.16e-05,\n            \"K_0\": 51400e6,\n            \"Kprime_0\": 2.0,\n            \"Kdprime_0\": -3.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1581629,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lc\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3029270.0,\n            \"S_0\": 198.5,\n            \"V_0\": 8.826e-05,\n            \"Cp\": [369.8, -0.016332, 684700.0, -3683.1],\n            \"a_0\": 1.85e-05,\n            \"K_0\": 45000e6,\n            \"Kprime_0\": 5.7,\n            \"Kdprime_0\": -1.27e-10,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2182472,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11610.0,\n                    \"deltaV\": 4e-06,\n                    \"Wh\": 11600.0,\n                    \"Wv\": 4e-06,\n                    \"n\": 2.0,\n                    \"factor\": 0.7,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"me\",\n            \"formula\": {\"Al\": 6.0, \"C\": 1.0, \"Ca\": 4.0, \"O\": 27.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -13841820.0,\n            \"S_0\": 752.0,\n            \"V_0\": 0.00033985,\n            \"Cp\": [1359.0, 0.036442, -8594700.0, -9598.2],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 44.0,\n            \"molar_mass\": 0.9347085,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"wrk\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 4.0, \"O\": 14.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6662450.0,\n            \"S_0\": 380.0,\n            \"V_0\": 0.0001904,\n            \"Cp\": [838.3, -0.02146, -2272000.0, -7292.3],\n            \"a_0\": 1.49e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 25.0,\n            \"molar_mass\": 0.43440636,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lmt\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 8.0, \"O\": 16.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7262700.0,\n            \"S_0\": 465.0,\n            \"V_0\": 0.0002037,\n            \"Cp\": [1013.4, -0.021413, -2235800.0, -8806.7],\n            \"a_0\": 1.37e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 31.0,\n            \"molar_mass\": 0.47043692,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"heu\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 12.0, \"O\": 24.0, \"Si\": 7.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10545220.0,\n            \"S_0\": 783.0,\n            \"V_0\": 0.000317,\n            \"Cp\": [1504.8, -0.033224, -2959300.0, -13297.2],\n            \"a_0\": 1.57e-05,\n            \"K_0\": 27400e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.46e-10,\n            \"n\": 46.0,\n            \"molar_mass\": 0.68672038,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"stlb\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 14.0, \"O\": 25.0, \"Si\": 7.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10896760.0,\n            \"S_0\": 710.0,\n            \"V_0\": 0.0003287,\n            \"Cp\": [1588.4, -0.032043, -3071600.0, -13966.9],\n            \"a_0\": 1.51e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 49.0,\n            \"molar_mass\": 0.70473566,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"anl\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"Na\": 1.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3307220.0,\n            \"S_0\": 232.0,\n            \"V_0\": 9.74e-05,\n            \"Cp\": [643.5, -0.016067, 9302300.0, -9179.6],\n            \"a_0\": 2.76e-05,\n            \"K_0\": 40000e6,\n            \"Kprime_0\": 4.18,\n            \"Kdprime_0\": -1.04e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.22015398,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lime\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -634530.0,\n            \"S_0\": 38.1,\n            \"V_0\": 1.676e-05,\n            \"Cp\": [52.4, 0.003673, -750700.0, -51.0],\n            \"a_0\": 3.41e-05,\n            \"K_0\": 113000e6,\n            \"Kprime_0\": 3.87,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0560774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ru\",\n            \"formula\": {\"O\": 2.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -944360.0,\n            \"S_0\": 50.5,\n            \"V_0\": 1.882e-05,\n            \"Cp\": [90.4, 0.0029, 0.0, -623.8],\n            \"a_0\": 2.24e-05,\n            \"K_0\": 222000e6,\n            \"Kprime_0\": 4.24,\n            \"Kdprime_0\": -1.9e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0798658,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"per\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -601530.0,\n            \"S_0\": 26.5,\n            \"V_0\": 1.125e-05,\n            \"Cp\": [60.5, 0.000362, -535800.0, -299.2],\n            \"a_0\": 3.11e-05,\n            \"K_0\": 161600e6,\n            \"Kprime_0\": 3.95,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0403044,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fper\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -259870.0,\n            \"S_0\": 58.6,\n            \"V_0\": 1.206e-05,\n            \"Cp\": [44.4, 0.00828, -1214200.0, 185.2],\n            \"a_0\": 3.22e-05,\n            \"K_0\": 152000e6,\n            \"Kprime_0\": 4.9,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0718444,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mang\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -385550.0,\n            \"S_0\": 59.7,\n            \"V_0\": 1.322e-05,\n            \"Cp\": [59.8, 0.0036, -31400.0, -282.6],\n            \"a_0\": 3.69e-05,\n            \"K_0\": 164500e6,\n            \"Kprime_0\": 4.46,\n            \"Kdprime_0\": -2.7e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0709374,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cor\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1675270.0,\n            \"S_0\": 50.9,\n            \"V_0\": 2.558e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 254000e6,\n            \"Kprime_0\": 4.34,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mcor\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1474440.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 211000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hem\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -825610.0,\n            \"S_0\": 87.4,\n            \"V_0\": 3.027e-05,\n            \"Cp\": [163.9, 0.0, -2257200.0, -657.6],\n            \"a_0\": 2.79e-05,\n            \"K_0\": 223000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1596882,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 955.0,\n                    \"S_D\": 15.6,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"esk\",\n            \"formula\": {\"Cr\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1137320.0,\n            \"S_0\": 83.0,\n            \"V_0\": 2.909e-05,\n            \"Cp\": [119.0, 0.009496, -1442000.0, -3.4],\n            \"a_0\": 1.59e-05,\n            \"K_0\": 238000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1519904,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"bix\",\n            \"formula\": {\"Mn\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -959000.0,\n            \"S_0\": 113.7,\n            \"V_0\": 3.137e-05,\n            \"Cp\": [145.1, 0.023534, 721600.0, -1008.4],\n            \"a_0\": 2.91e-05,\n            \"K_0\": 223000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1578742,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"NiO\",\n            \"formula\": {\"Ni\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -239470.0,\n            \"S_0\": 38.0,\n            \"V_0\": 1.097e-05,\n            \"Cp\": [47.7, 0.007824, -392500.0, 0.0],\n            \"a_0\": 3.3e-05,\n            \"K_0\": 200000e6,\n            \"Kprime_0\": 3.94,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0746928,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\"P_0\": 100000.0, \"T_0\": 298.15, \"Tc_0\": 520.0, \"S_D\": 5.7, \"V_D\": 0.0},\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pnt\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1361950.0,\n            \"S_0\": 105.5,\n            \"V_0\": 3.288e-05,\n            \"Cp\": [143.5, 0.003373, -1940700.0, -407.6],\n            \"a_0\": 2.4e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1508032,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"geik\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1568960.0,\n            \"S_0\": 73.6,\n            \"V_0\": 3.086e-05,\n            \"Cp\": [151.0, 0.0, -1890400.0, -652.2],\n            \"a_0\": 2.15e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1201702,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ilm\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1230450.0,\n            \"S_0\": 109.5,\n            \"V_0\": 3.169e-05,\n            \"Cp\": [138.9, 0.005081, -1288800.0, -463.7],\n            \"a_0\": 2.4e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1517102,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1900.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 2e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"bdy\",\n            \"formula\": {\"O\": 2.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1100340.0,\n            \"S_0\": 50.4,\n            \"V_0\": 2.115e-05,\n            \"Cp\": [103.5, -0.004547, -416200.0, -713.6],\n            \"a_0\": 2e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1232228,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ten\",\n            \"formula\": {\"Cu\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -156100.0,\n            \"S_0\": 42.6,\n            \"V_0\": 1.222e-05,\n            \"Cp\": [31.0, 0.01374, -1258000.0, 369.3],\n            \"a_0\": 3.57e-05,\n            \"K_0\": 200000e6,\n            \"Kprime_0\": 3.94,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0795454,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cup\",\n            \"formula\": {\"Cu\": 2.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -170600.0,\n            \"S_0\": 92.4,\n            \"V_0\": 2.344e-05,\n            \"Cp\": [110.3, 0.0, 0.0, -674.8],\n            \"a_0\": 3.33e-05,\n            \"K_0\": 131000e6,\n            \"Kprime_0\": 5.7,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1430914,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sp\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2301190.0,\n            \"S_0\": 82.0,\n            \"V_0\": 3.978e-05,\n            \"Cp\": [222.9, 0.006127, -1686000.0, -1551.0],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1422656,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 8000.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": 1200.0,\n                    \"Wv\": 0.0,\n                    \"n\": 2.0,\n                    \"factor\": 0.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"herc\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1953030.0,\n            \"S_0\": 113.9,\n            \"V_0\": 4.075e-05,\n            \"Cp\": [216.7, 0.005868, -2430200.0, -1178.3],\n            \"a_0\": 2.06e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1738056,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 18300.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": 13600.0,\n                    \"Wv\": 0.0,\n                    \"n\": 2.0,\n                    \"factor\": 1.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mt\",\n            \"formula\": {\"Fe\": 3.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1114500.0,\n            \"S_0\": 146.9,\n            \"V_0\": 4.452e-05,\n            \"Cp\": [262.5, -0.007205, -1926200.0, -1655.7],\n            \"a_0\": 3.71e-05,\n            \"K_0\": 185700e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2315326,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 848.0,\n                    \"S_D\": 35.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mft\",\n            \"formula\": {\"Fe\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1442290.0,\n            \"S_0\": 121.0,\n            \"V_0\": 4.457e-05,\n            \"Cp\": [270.5, -0.007505, -999200.0, -2022.4],\n            \"a_0\": 3.63e-05,\n            \"K_0\": 185700e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1999926,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 665.0,\n                    \"S_D\": 17.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"usp\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1491120.0,\n            \"S_0\": 180.0,\n            \"V_0\": 4.682e-05,\n            \"Cp\": [-102.6, 0.14252, -9144500.0, 5270.7],\n            \"a_0\": 3.86e-05,\n            \"K_0\": 185700e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2235546,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"picr\",\n            \"formula\": {\"Cr\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1762600.0,\n            \"S_0\": 118.3,\n            \"V_0\": 4.356e-05,\n            \"Cp\": [196.1, 0.005398, -3126000.0, -616.9],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1922948,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 8000.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": 1200.0,\n                    \"Wv\": 0.0,\n                    \"n\": 2.0,\n                    \"factor\": 0.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"br\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -925560.0,\n            \"S_0\": 63.2,\n            \"V_0\": 2.463e-05,\n            \"Cp\": [158.4, -0.004076, -1052300.0, -1171.3],\n            \"a_0\": 6.2e-05,\n            \"K_0\": 41500e6,\n            \"Kprime_0\": 6.45,\n            \"Kdprime_0\": -1.55e-10,\n            \"n\": 5.0,\n            \"molar_mass\": 0.05831968,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"dsp\",\n            \"formula\": {\"Al\": 1.0, \"H\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -999840.0,\n            \"S_0\": 34.5,\n            \"V_0\": 1.786e-05,\n            \"Cp\": [145.1, 0.008709, 584400.0, -1741.1],\n            \"a_0\": 3.57e-05,\n            \"K_0\": 228000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 4.0,\n            \"molar_mass\": 0.05998824,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"gth\",\n            \"formula\": {\"Fe\": 1.0, \"H\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -561770.0,\n            \"S_0\": 60.3,\n            \"V_0\": 2.082e-05,\n            \"Cp\": [139.3, 0.000147, -212700.0, -1077.8],\n            \"a_0\": 4.35e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.03,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 4.0,\n            \"molar_mass\": 0.08885174,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cc\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1207760.0,\n            \"S_0\": 92.5,\n            \"V_0\": 3.689e-05,\n            \"Cp\": [140.9, 0.005029, -950700.0, -858.4],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 73300e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -5.5e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1000869,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1240.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 4e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"arag\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1207650.0,\n            \"S_0\": 89.8,\n            \"V_0\": 3.415e-05,\n            \"Cp\": [167.1, 0.010695, 162000.0, -1564.9],\n            \"a_0\": 6.14e-05,\n            \"K_0\": 61400e6,\n            \"Kprime_0\": 5.87,\n            \"Kdprime_0\": -9.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1000869,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mag\",\n            \"formula\": {\"C\": 1.0, \"Mg\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1110920.0,\n            \"S_0\": 65.5,\n            \"V_0\": 2.803e-05,\n            \"Cp\": [186.4, -0.003772, 0.0, -1886.2],\n            \"a_0\": 3.38e-05,\n            \"K_0\": 102800e6,\n            \"Kprime_0\": 5.41,\n            \"Kdprime_0\": -5.3e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.0843139,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sid\",\n            \"formula\": {\"C\": 1.0, \"Fe\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -762220.0,\n            \"S_0\": 93.3,\n            \"V_0\": 2.943e-05,\n            \"Cp\": [168.4, 0.0, 0.0, -1483.6],\n            \"a_0\": 4.39e-05,\n            \"K_0\": 120000e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1158539,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"rhc\",\n            \"formula\": {\"C\": 1.0, \"Mn\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -892280.0,\n            \"S_0\": 98.0,\n            \"V_0\": 3.107e-05,\n            \"Cp\": [169.5, 0.0, 0.0, -1534.3],\n            \"a_0\": 2.44e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1149469,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"dol\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2326220.0,\n            \"S_0\": 156.1,\n            \"V_0\": 6.429e-05,\n            \"Cp\": [358.9, -0.004905, 0.0, -3456.2],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 94300e6,\n            \"Kprime_0\": 3.74,\n            \"Kdprime_0\": -4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.1844008,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11910.0,\n                    \"deltaV\": 1.6e-07,\n                    \"Wh\": 11900.0,\n                    \"Wv\": 1.6e-07,\n                    \"n\": 1.0,\n                    \"factor\": 1.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ank\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 1.0, \"Fe\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1971410.0,\n            \"S_0\": 188.46,\n            \"V_0\": 6.606e-05,\n            \"Cp\": [341.0, -0.001161, 0.0, -3054.8],\n            \"a_0\": 3.46e-05,\n            \"K_0\": 91400e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2159408,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11910.0,\n                    \"deltaV\": 1.6e-07,\n                    \"Wh\": 11900.0,\n                    \"Wv\": 1.6e-07,\n                    \"n\": 1.0,\n                    \"factor\": 1.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"syv\",\n            \"formula\": {\"Cl\": 1.0, \"K\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -436500.0,\n            \"S_0\": 82.6,\n            \"V_0\": 3.752e-05,\n            \"Cp\": [46.2, 0.01797, 0.0, 0.0],\n            \"a_0\": 0.0001109,\n            \"K_0\": 17000e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -2.94e-10,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0745513,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hlt\",\n            \"formula\": {\"Cl\": 1.0, \"Na\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -411300.0,\n            \"S_0\": 72.1,\n            \"V_0\": 2.702e-05,\n            \"Cp\": [45.2, 0.01797, 0.0, 0.0],\n            \"a_0\": 0.0001147,\n            \"K_0\": 23800e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -2.1e-10,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0584428,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pyr\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -171640.0,\n            \"S_0\": 52.9,\n            \"V_0\": 2.394e-05,\n            \"Cp\": [37.3, 0.026715, -1817000.0, 649.3],\n            \"a_0\": 3.1e-05,\n            \"K_0\": 139500e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -2.9e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.119975,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"trot\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -99030.0,\n            \"S_0\": 65.5,\n            \"V_0\": 1.819e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 5.68e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 598.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 4.1e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tro\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -97760.0,\n            \"S_0\": 70.8,\n            \"V_0\": 1.819e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 5.73e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 598.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 4.1e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lot\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -102160.0,\n            \"S_0\": 60.0,\n            \"V_0\": 1.818e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 4.93e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 420.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"trov\",\n            \"formula\": {\"Fe\": 0.875, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -96020.0,\n            \"S_0\": 57.5,\n            \"V_0\": 1.738e-05,\n            \"Cp\": [51.1, 0.008307, -669700.0, 0.0],\n            \"a_0\": 5.94e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 1.875,\n            \"molar_mass\": 0.080929375,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 595.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 1.6e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"any\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 4.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1434400.0,\n            \"S_0\": 106.9,\n            \"V_0\": 4.594e-05,\n            \"Cp\": [128.7, 0.048545, -1223000.0, -560.5],\n            \"a_0\": 4.18e-05,\n            \"K_0\": 54379999999.99999,\n            \"Kprime_0\": 4.19,\n            \"Kdprime_0\": -7.7e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.1361406,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"iron\",\n            \"formula\": {\"Fe\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -0.0,\n            \"S_0\": 27.09,\n            \"V_0\": 7.09e-06,\n            \"Cp\": [46.2, 0.005159, 723100.0, -556.2],\n            \"a_0\": 3.56e-05,\n            \"K_0\": 164000e6,\n            \"Kprime_0\": 5.16,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.055845,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1042.0,\n                    \"S_D\": 8.3,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Ni\",\n            \"formula\": {\"Ni\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 29.87,\n            \"V_0\": 6.59e-06,\n            \"Cp\": [49.8, 0.0, 585900.0, -533.9],\n            \"a_0\": 4.28e-05,\n            \"K_0\": 190500e6,\n            \"Kprime_0\": 4.25,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0586934,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\"P_0\": 100000.0, \"T_0\": 298.15, \"Tc_0\": 631.0, \"S_D\": 3.0, \"V_D\": 0.0},\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Cu\",\n            \"formula\": {\"Cu\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -0.0,\n            \"S_0\": 33.14,\n            \"V_0\": 7.11e-06,\n            \"Cp\": [12.4, 0.00922, -379900.0, 233.5],\n            \"a_0\": 3.58e-05,\n            \"K_0\": 162500e6,\n            \"Kprime_0\": 4.24,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.063546,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"gph\",\n            \"formula\": {\"C\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 5.76,\n            \"V_0\": 5.3e-06,\n            \"Cp\": [34.3, 0.0, -240700.0, -403.8],\n            \"a_0\": 1.65e-05,\n            \"K_0\": 31200e6,\n            \"Kprime_0\": 3.9,\n            \"Kdprime_0\": -1.25e-10,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0120107,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"diam\",\n            \"formula\": {\"C\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 1890.0,\n            \"S_0\": 2.36,\n            \"V_0\": 3.42e-06,\n            \"Cp\": [40.0, 0.0, -28500.0, -580.5],\n            \"a_0\": 4e-06,\n            \"K_0\": 446500e6,\n            \"Kprime_0\": 1.61,\n            \"Kdprime_0\": -3.6e-12,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0120107,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"S\",\n            \"formula\": {\"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 32.05,\n            \"V_0\": 1.551e-05,\n            \"Cp\": [56.6, -0.004557, 638000.0, -681.8],\n            \"a_0\": 6.4e-05,\n            \"K_0\": 14500e6,\n            \"Kprime_0\": 7.0,\n            \"Kdprime_0\": -4.8e-10,\n            \"n\": 1.0,\n            \"molar_mass\": 0.032065,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"syvL\",\n            \"formula\": {\"Cl\": 1.0, \"K\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -417410.0,\n            \"S_0\": 94.5,\n            \"V_0\": 3.822e-05,\n            \"Cp\": [66.9, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000301,\n            \"K_0\": 5600e6,\n            \"Kprime_0\": 4.65,\n            \"Kdprime_0\": -8.3e-10,\n            \"dKdT_0\": -2e6,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0745513,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hltL\",\n            \"formula\": {\"Cl\": 1.0, \"Na\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -392990.0,\n            \"S_0\": 80.1,\n            \"V_0\": 2.938e-05,\n            \"Cp\": [72.0, -0.003223, 0.0, 0.0],\n            \"a_0\": 0.000295,\n            \"K_0\": 6400e6,\n            \"Kprime_0\": 4.61,\n            \"Kdprime_0\": -7.2e-10,\n            \"dKdT_0\": -1500000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0584428,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"perL\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -654120.0,\n            \"S_0\": -64.3,\n            \"V_0\": 8.39e-06,\n            \"Cp\": [99.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000226,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4100000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0403044,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"limL\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -692280.0,\n            \"S_0\": -47.5,\n            \"V_0\": 1.303e-05,\n            \"Cp\": [99.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000175,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4100000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0560774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"corL\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1632160.0,\n            \"S_0\": 14.9,\n            \"V_0\": 3.369e-05,\n            \"Cp\": [157.6, 0.0, 0.0, 0.0],\n            \"a_0\": 7.03e-05,\n            \"K_0\": 15000e6,\n            \"Kprime_0\": 6.0,\n            \"Kdprime_0\": 4e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"qL\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -921070.0,\n            \"S_0\": 16.3,\n            \"V_0\": 2.73e-05,\n            \"Cp\": [82.5, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0,\n            \"K_0\": 22000e6,\n            \"Kprime_0\": 9.46,\n            \"Kdprime_0\": -4.3e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"h2oL\",\n            \"formula\": {\"H\": 2.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -295010.0,\n            \"S_0\": 45.5,\n            \"V_0\": 1.39e-05,\n            \"Cp\": [80.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000521,\n            \"K_0\": 5060e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -7.9e-10,\n            \"dKdT_0\": -370000.0,\n            \"n\": 3.0,\n            \"molar_mass\": 0.01801528,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"foL\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2237350.0,\n            \"S_0\": -62.0,\n            \"V_0\": 4.312e-05,\n            \"Cp\": [269.4, 0.0, 0.0, 0.0],\n            \"a_0\": 9.2e-05,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4400000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"faL\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1463020.0,\n            \"S_0\": 96.0,\n            \"V_0\": 4.677e-05,\n            \"Cp\": [243.7, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0001071,\n            \"K_0\": 29000e6,\n            \"Kprime_0\": 10.42,\n            \"Kdprime_0\": -3.59e-10,\n            \"dKdT_0\": -5500000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"woL\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1642220.0,\n            \"S_0\": 22.5,\n            \"V_0\": 3.965e-05,\n            \"Cp\": [167.4, 0.0, 0.0, 0.0],\n            \"a_0\": 6.69e-05,\n            \"K_0\": 30500e6,\n            \"Kprime_0\": 9.38,\n            \"Kdprime_0\": -3.08e-10,\n            \"dKdT_0\": -2e6,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"enL\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3096570.0,\n            \"S_0\": -4.0,\n            \"V_0\": 6.984e-05,\n            \"Cp\": [353.6, 0.0, 0.0, 0.0],\n            \"a_0\": 6.81e-05,\n            \"K_0\": 21800e6,\n            \"Kprime_0\": 7.2,\n            \"Kdprime_0\": -3.3e-10,\n            \"dKdT_0\": -2400000.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"diL\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3193870.0,\n            \"S_0\": 42.1,\n            \"V_0\": 7.288e-05,\n            \"Cp\": [334.0, 0.0, 0.0, 0.0],\n            \"a_0\": 8.51e-05,\n            \"K_0\": 24900e6,\n            \"Kprime_0\": 8.04,\n            \"Kdprime_0\": -3.23e-10,\n            \"dKdT_0\": -3730000.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2165504,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"silL\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2593430.0,\n            \"S_0\": 10.0,\n            \"V_0\": 6.051e-05,\n            \"Cp\": [253.0, 0.0, 0.0, 0.0],\n            \"a_0\": 4.08e-05,\n            \"K_0\": 22000e6,\n            \"Kprime_0\": 6.36,\n            \"Kdprime_0\": -2.89e-10,\n            \"dKdT_0\": -2900000.0,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"anL\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -4277970.0,\n            \"S_0\": 29.0,\n            \"V_0\": 0.00010014,\n            \"Cp\": [430.0, 0.0, 0.0, 0.0],\n            \"a_0\": 5.14e-05,\n            \"K_0\": 21000e6,\n            \"Kprime_0\": 6.38,\n            \"Kdprime_0\": -3.04e-10,\n            \"dKdT_0\": -5500000.0,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2782072,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kspL\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3985190.0,\n            \"S_0\": 129.2,\n            \"V_0\": 0.00011431,\n            \"Cp\": [368.0, 0.0, 0.0, 0.0],\n            \"a_0\": 4.93e-05,\n            \"K_0\": 17300e6,\n            \"Kprime_0\": 6.84,\n            \"Kdprime_0\": -3.93e-10,\n            \"dKdT_0\": -899999.9999999999,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"abL\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3926520.0,\n            \"S_0\": 149.9,\n            \"V_0\": 0.00010858,\n            \"Cp\": [358.0, 0.0, 0.0, 0.0],\n            \"a_0\": 3.37e-05,\n            \"K_0\": 17600e6,\n            \"Kprime_0\": 14.35,\n            \"Kdprime_0\": -8.15e-10,\n            \"dKdT_0\": -2600000.0,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"neL\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2116730.0,\n            \"S_0\": 52.9,\n            \"V_0\": 5.2e-05,\n            \"Cp\": [216.5, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000137,\n            \"K_0\": 25000e6,\n            \"Kprime_0\": 7.37,\n            \"Kdprime_0\": -2.95e-10,\n            \"dKdT_0\": -800000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lcL\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3068410.0,\n            \"S_0\": 102.0,\n            \"V_0\": 8.59e-05,\n            \"Cp\": [287.0, 0.0, 0.0, 0.0],\n            \"a_0\": 6.7e-05,\n            \"K_0\": 17500e6,\n            \"Kprime_0\": 7.0,\n            \"Kdprime_0\": -3.94e-10,\n            \"dKdT_0\": -0.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2182472,\n        }\n        Mineral.__init__(self)",
  "class bcc_iron(Mineral):\n    \"\"\"\n    BCC iron from :cite:`SE2015`.\n    \"\"\"\n\n    def __init__(self):\n        formula = {\"Fe\": 1.0}\n        m = formula_mass(formula)\n        self.params = {\n            \"name\": \"BCC iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"brosh_calphad\",\n            \"molar_mass\": m,\n            \"n\": sum(formula.values()),\n            \"gibbs_coefficients\": [\n                [\n                    1811.0,\n                    [\n                        1225.7,\n                        124.134,\n                        -23.5143,\n                        77359.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        -0.439752e-2,\n                        -5.8927e-8,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    6000.0,\n                    [\n                        -25383.6,\n                        299.3126,\n                        -46.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        2.29603e31,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    12000.0,\n                    [\n                        -25383.4,\n                        299.3122,\n                        -45.99997,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n            ],\n            \"V_0\": 7.05e-6,  # V0\n            \"K_0\": 170.0e9,  # b8\n            \"Kprime_0\": 6.2,  # b9\n            \"theta_0\": 300,  # b3\n            \"grueneisen_0\": 1.55,  # b1\n            \"delta\": [6.0, 15.0],  # b5, b7\n            \"b\": [1.0, 3.0],  # b4, b6\n        }\n        self.property_modifiers = [\n            [\n                \"magnetic_chs\",\n                {\n                    \"structural_parameter\": 0.4,\n                    \"curie_temperature\": [1043.0, 0.0],\n                    \"magnetic_moment\": [2.22, 0.0],\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class fcc_iron(Mineral):\n    \"\"\"\n    FCC iron from :cite:`SE2015`.\n    \"\"\"\n\n    def __init__(self):\n        formula = {\"Fe\": 1.0}\n        m = formula_mass(formula)\n        self.params = {\n            \"name\": \"FCC iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"brosh_calphad\",\n            \"molar_mass\": m,\n            \"n\": sum(formula.values()),\n            \"gibbs_coefficients\": [\n                [\n                    1811.0,\n                    [\n                        -236.7,\n                        132.416,\n                        -24.6643,\n                        77359.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        -0.375752e-2,\n                        -5.8927e-8,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    6000.0,\n                    [\n                        -27097.4,\n                        300.2526,\n                        -46.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        2.78854e31,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    12000.0,\n                    [\n                        -27097.1,\n                        300.2522,\n                        -45.99996,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n            ],\n            \"V_0\": 6.826e-6,  # V0\n            \"K_0\": 140.0e9,  # b8\n            \"Kprime_0\": 8.0,  # b9\n            \"theta_0\": 250.0,  # b3\n            \"grueneisen_0\": 2.0,  # b1\n            \"delta\": [4.0, 10.0],  # b5, b7\n            \"b\": [1.0, 3.0],  # b2, b6\n        }\n\n        self.property_modifiers = [\n            [\n                \"magnetic_chs\",\n                {\n                    \"structural_parameter\": 0.28,\n                    \"curie_temperature\": [201.0, 0.0],\n                    \"magnetic_moment\": [2.1, 0.0],\n                },\n            ]\n        ]\n\n        Mineral.__init__(self)",
  "class hcp_iron(Mineral):\n    \"\"\"\n    HCP iron from :cite:`SE2015`.\n    \"\"\"\n\n    def __init__(self):\n        formula = {\"Fe\": 1.0}\n        m = formula_mass(formula)\n        self.params = {\n            \"name\": \"HCP iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"brosh_calphad\",\n            \"molar_mass\": m,\n            \"n\": sum(formula.values()),\n            \"gibbs_coefficients\": [\n                [\n                    1811.0,\n                    [\n                        -2480.08,\n                        136.725,\n                        -24.6643,\n                        77359.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        -0.375752e-2,\n                        -5.8927e-8,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    6000.0,\n                    [\n                        -29340.8,\n                        304.5616,\n                        -46.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        2.78854e31,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    12000.0,\n                    [\n                        -29340.5,\n                        304.5612,\n                        -45.99996,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n            ],\n            \"V_0\": 6.677e-6,  # V0\n            \"K_0\": 170.0e9,  # b8\n            \"Kprime_0\": 5.5,  # b9\n            \"theta_0\": 250.0,  # b3\n            \"grueneisen_0\": 2.85,  # b1\n            \"delta\": [6.0, 10.0],  # b5, b7\n            \"b\": [0.7, 2.49614],  # b4, b6\n        }\n        Mineral.__init__(self)",
  "class liquid_iron(Mineral):\n    \"\"\"\n    Liquid iron from :cite:`SE2015`.\n    \"\"\"\n\n    def __init__(self):\n        formula = {\"Fe\": 1.0}\n        m = formula_mass(formula)\n        self.params = {\n            \"name\": \"Liquid iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"brosh_calphad\",\n            \"molar_mass\": m,\n            \"n\": sum(formula.values()),\n            \"gibbs_coefficients\": [\n                [\n                    1811.0,\n                    [\n                        13265.87,\n                        117.5756,\n                        -23.5143,\n                        77359.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        -0.439752e-2,\n                        -5.8927e-8,\n                        0.0,\n                        -0.3675155e-20,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    12000.0,\n                    [\n                        -10838.8,\n                        291.302,\n                        -46.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n            ],\n            \"V_0\": 7.4602e-6,  # V0\n            \"K_0\": 165.0e9,  # b8\n            \"Kprime_0\": 4.4729,  # b9\n            \"theta_0\": 250.0,  # b3\n            \"grueneisen_0\": 2.0,  # b1\n            \"delta\": [6.0, 4.0],  # b5, b7\n            \"b\": [1.0, 5.10624],  # b4, b6\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Fe\": 1.0}\n        m = formula_mass(formula)\n        self.params = {\n            \"name\": \"BCC iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"brosh_calphad\",\n            \"molar_mass\": m,\n            \"n\": sum(formula.values()),\n            \"gibbs_coefficients\": [\n                [\n                    1811.0,\n                    [\n                        1225.7,\n                        124.134,\n                        -23.5143,\n                        77359.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        -0.439752e-2,\n                        -5.8927e-8,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    6000.0,\n                    [\n                        -25383.6,\n                        299.3126,\n                        -46.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        2.29603e31,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    12000.0,\n                    [\n                        -25383.4,\n                        299.3122,\n                        -45.99997,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n            ],\n            \"V_0\": 7.05e-6,  # V0\n            \"K_0\": 170.0e9,  # b8\n            \"Kprime_0\": 6.2,  # b9\n            \"theta_0\": 300,  # b3\n            \"grueneisen_0\": 1.55,  # b1\n            \"delta\": [6.0, 15.0],  # b5, b7\n            \"b\": [1.0, 3.0],  # b4, b6\n        }\n        self.property_modifiers = [\n            [\n                \"magnetic_chs\",\n                {\n                    \"structural_parameter\": 0.4,\n                    \"curie_temperature\": [1043.0, 0.0],\n                    \"magnetic_moment\": [2.22, 0.0],\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Fe\": 1.0}\n        m = formula_mass(formula)\n        self.params = {\n            \"name\": \"FCC iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"brosh_calphad\",\n            \"molar_mass\": m,\n            \"n\": sum(formula.values()),\n            \"gibbs_coefficients\": [\n                [\n                    1811.0,\n                    [\n                        -236.7,\n                        132.416,\n                        -24.6643,\n                        77359.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        -0.375752e-2,\n                        -5.8927e-8,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    6000.0,\n                    [\n                        -27097.4,\n                        300.2526,\n                        -46.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        2.78854e31,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    12000.0,\n                    [\n                        -27097.1,\n                        300.2522,\n                        -45.99996,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n            ],\n            \"V_0\": 6.826e-6,  # V0\n            \"K_0\": 140.0e9,  # b8\n            \"Kprime_0\": 8.0,  # b9\n            \"theta_0\": 250.0,  # b3\n            \"grueneisen_0\": 2.0,  # b1\n            \"delta\": [4.0, 10.0],  # b5, b7\n            \"b\": [1.0, 3.0],  # b2, b6\n        }\n\n        self.property_modifiers = [\n            [\n                \"magnetic_chs\",\n                {\n                    \"structural_parameter\": 0.28,\n                    \"curie_temperature\": [201.0, 0.0],\n                    \"magnetic_moment\": [2.1, 0.0],\n                },\n            ]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Fe\": 1.0}\n        m = formula_mass(formula)\n        self.params = {\n            \"name\": \"HCP iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"brosh_calphad\",\n            \"molar_mass\": m,\n            \"n\": sum(formula.values()),\n            \"gibbs_coefficients\": [\n                [\n                    1811.0,\n                    [\n                        -2480.08,\n                        136.725,\n                        -24.6643,\n                        77359.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        -0.375752e-2,\n                        -5.8927e-8,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    6000.0,\n                    [\n                        -29340.8,\n                        304.5616,\n                        -46.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        2.78854e31,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    12000.0,\n                    [\n                        -29340.5,\n                        304.5612,\n                        -45.99996,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n            ],\n            \"V_0\": 6.677e-6,  # V0\n            \"K_0\": 170.0e9,  # b8\n            \"Kprime_0\": 5.5,  # b9\n            \"theta_0\": 250.0,  # b3\n            \"grueneisen_0\": 2.85,  # b1\n            \"delta\": [6.0, 10.0],  # b5, b7\n            \"b\": [0.7, 2.49614],  # b4, b6\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Fe\": 1.0}\n        m = formula_mass(formula)\n        self.params = {\n            \"name\": \"Liquid iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"brosh_calphad\",\n            \"molar_mass\": m,\n            \"n\": sum(formula.values()),\n            \"gibbs_coefficients\": [\n                [\n                    1811.0,\n                    [\n                        13265.87,\n                        117.5756,\n                        -23.5143,\n                        77359.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        -0.439752e-2,\n                        -5.8927e-8,\n                        0.0,\n                        -0.3675155e-20,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n                [\n                    12000.0,\n                    [\n                        -10838.8,\n                        291.302,\n                        -46.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                        0.0,\n                    ],\n                ],\n            ],\n            \"V_0\": 7.4602e-6,  # V0\n            \"K_0\": 165.0e9,  # b8\n            \"Kprime_0\": 4.4729,  # b9\n            \"theta_0\": 250.0,  # b3\n            \"grueneisen_0\": 2.0,  # b1\n            \"delta\": [6.0, 4.0],  # b5, b7\n            \"b\": [1.0, 5.10624],  # b4, b6\n        }\n        Mineral.__init__(self)",
  "class EPOC_vinet(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"vinet\",\n            \"V_0\": 8.18e-6,\n            \"K_0\": 67.5e9,\n            \"Kprime_0\": 6.12,\n            \"molar_mass\": 0.05,\n        }\n        Mineral.__init__(self)",
  "class EPOC_bm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"bm3\",\n            \"V_0\": 7.63e-6,\n            \"K_0\": 120e9,\n            \"Kprime_0\": 4.6,\n            \"molar_mass\": 0.05,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"vinet\",\n            \"V_0\": 8.18e-6,\n            \"K_0\": 67.5e9,\n            \"Kprime_0\": 6.12,\n            \"molar_mass\": 0.05,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"bm3\",\n            \"V_0\": 7.63e-6,\n            \"K_0\": 120e9,\n            \"Kprime_0\": 4.6,\n            \"molar_mass\": 0.05,\n        }\n        Mineral.__init__(self)",
  "class Fe2SiO4_liquid(Mineral):\n    def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe2SiO4_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 59.7717e-6,  # modified for T_0\n            \"T_0\": 1900.0,  # corrected\n            \"O_theta\": 1,\n            \"O_f\": 4,\n            \"m\": 0.6,\n            \"a\": np.array(\n                [\n                    [-4252948.0, 997810.188],\n                    [-599315.125, 12032.8936],\n                    [12572739.0, 7299239.5],\n                    [53442800.0, -26791676.0],\n                    [52981912.0, 0.0],\n                ]\n            ),  # corrected order\n            \"zeta_0\": 0.0161350928,  # 0.0166734, # the comment is a refit to David's dataset\n            \"xi\": 0.34431043,  # 0.34431053, # the comment is a refit to David's dataset\n            \"Tel_0\": 1919.3553,  # 1921.6813, # the comment is a refit to David's dataset\n            \"eta\": 0.0127067110,  # 0.0127067, # the comment is a refit to David's dataset\n            \"spin_a\": [-0.00011134, 0.00010863],\n            \"spin_b\": [3.53793, -3.81421, 2.83703, -0.676241],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe2SiO4_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 59.7717e-6,  # modified for T_0\n            \"T_0\": 1900.0,  # corrected\n            \"O_theta\": 1,\n            \"O_f\": 4,\n            \"m\": 0.6,\n            \"a\": np.array(\n                [\n                    [-4252948.0, 997810.188],\n                    [-599315.125, 12032.8936],\n                    [12572739.0, 7299239.5],\n                    [53442800.0, -26791676.0],\n                    [52981912.0, 0.0],\n                ]\n            ),  # corrected order\n            \"zeta_0\": 0.0161350928,  # 0.0166734, # the comment is a refit to David's dataset\n            \"xi\": 0.34431043,  # 0.34431053, # the comment is a refit to David's dataset\n            \"Tel_0\": 1919.3553,  # 1921.6813, # the comment is a refit to David's dataset\n            \"eta\": 0.0127067110,  # 0.0127067, # the comment is a refit to David's dataset\n            \"spin_a\": [-0.00011134, 0.00010863],\n            \"spin_b\": [3.53793, -3.81421, 2.83703, -0.676241],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "class mg_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 24.45e-6,  # S & L-B 2005\n            \"K_0\": 281e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 173e9,\n            \"Gprime_0\": 1.56,\n            \"molar_mass\": 0.100,\n            \"n\": 5,\n            \"Debye_0\": 1070.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.4,\n        }\n\n        Mineral.__init__(self)",
  "class mg_perovskite_3rdorder(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 24.45e-6,  # S & L-B 2005\n            \"K_0\": 281e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 171.42e9,\n            \"Gprime_0\": 1.83,\n            \"molar_mass\": 0.100,\n            \"n\": 5,\n            \"Debye_0\": 1070.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.4,\n        }\n\n        Mineral.__init__(self)",
  "class fe_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 24.607e-6,\n            \"K_0\": 251.9e9,\n            \"Kprime_0\": 4.01,\n            \"G_0\": 164.7e9,\n            \"Gprime_0\": 1.58,\n            \"molar_mass\": 0.102,\n            \"n\": 5,\n            \"Debye_0\": 1054.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.4,\n        }\n\n        Mineral.__init__(self)",
  "class mg_periclase(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 11.24e-6,  # S & L-B 2005\n            \"K_0\": 161e9,\n            \"Kprime_0\": 3.9,\n            \"G_0\": 131e9,\n            \"Gprime_0\": 1.92,\n            \"molar_mass\": 0.0403,\n            \"n\": 2,\n            \"Debye_0\": 773.0,  # S& L-B 2005\n            \"grueneisen_0\": 1.5,\n            \"q_0\": 1.5,  # S&L-B 2005\n            \"eta_s_0\": 3.0,\n        }\n\n        Mineral.__init__(self)",
  "class fe_periclase(helpers.HelperSpinTransition):\n    def __init__(self):\n        helpers.HelperSpinTransition.__init__(\n            self, 63.0e9, fe_periclase_LS(), fe_periclase_HS()\n        )",
  "class fe_periclase_3rd(helpers.HelperSpinTransition):\n    def __init__(self):\n        helpers.HelperSpinTransition.__init__(\n            self, 63.0e9, fe_periclase_LS(), fe_periclase_HS()\n        )",
  "class fe_periclase_HS(\n    Mineral\n):  # From Murakami's emails, see Cayman for details, represents Mg# = .79\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 11.412e-6,\n            \"K_0\": 159.1e9,\n            \"Kprime_0\": 4.11,\n            \"G_0\": 105.43e9,\n            \"Gprime_0\": 1.773,\n            \"molar_mass\": 0.047,\n            \"n\": 2,\n            \"Debye_0\": 706.0,\n            \"grueneisen_0\": 1.45,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.54,\n        }\n\n        Mineral.__init__(self)",
  "class fe_periclase_LS(\n    Mineral\n):  # From Murakami's emails, see Cayman for details, represents Mg# = .79\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 11.171e-6,\n            \"K_0\": 170.0e9,\n            \"Kprime_0\": 4.00,\n            \"G_0\": 116.34e9,\n            \"Gprime_0\": 1.668,\n            \"molar_mass\": 0.047,\n            \"n\": 2,\n            \"Debye_0\": 706.0,\n            \"grueneisen_0\": 1.45,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.54,\n        }\n\n        Mineral.__init__(self)",
  "class fe_periclase_HS_3rd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 11.412e-6,\n            \"K_0\": 159.1e9,\n            \"Kprime_0\": 4.11,\n            \"G_0\": 129.35e9,\n            \"Gprime_0\": 1.993,\n            \"molar_mass\": 0.0469,\n            \"n\": 2,\n            \"Debye_0\": 706.0,\n            \"grueneisen_0\": 1.45,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.54,\n        }\n\n        Mineral.__init__(self)",
  "class fe_periclase_LS_3rd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 11.171e-6,\n            \"K_0\": 170.0e9,\n            \"Kprime_0\": 4.0,\n            \"G_0\": 151.67e9,\n            \"Gprime_0\": 1.754,\n            \"molar_mass\": 0.0469,\n            \"n\": 2,\n            \"Debye_0\": 706.0,\n            \"grueneisen_0\": 1.45,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.54,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 24.45e-6,  # S & L-B 2005\n            \"K_0\": 281e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 173e9,\n            \"Gprime_0\": 1.56,\n            \"molar_mass\": 0.100,\n            \"n\": 5,\n            \"Debye_0\": 1070.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.4,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 24.45e-6,  # S & L-B 2005\n            \"K_0\": 281e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 171.42e9,\n            \"Gprime_0\": 1.83,\n            \"molar_mass\": 0.100,\n            \"n\": 5,\n            \"Debye_0\": 1070.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.4,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 24.607e-6,\n            \"K_0\": 251.9e9,\n            \"Kprime_0\": 4.01,\n            \"G_0\": 164.7e9,\n            \"Gprime_0\": 1.58,\n            \"molar_mass\": 0.102,\n            \"n\": 5,\n            \"Debye_0\": 1054.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.4,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 11.24e-6,  # S & L-B 2005\n            \"K_0\": 161e9,\n            \"Kprime_0\": 3.9,\n            \"G_0\": 131e9,\n            \"Gprime_0\": 1.92,\n            \"molar_mass\": 0.0403,\n            \"n\": 2,\n            \"Debye_0\": 773.0,  # S& L-B 2005\n            \"grueneisen_0\": 1.5,\n            \"q_0\": 1.5,  # S&L-B 2005\n            \"eta_s_0\": 3.0,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        helpers.HelperSpinTransition.__init__(\n            self, 63.0e9, fe_periclase_LS(), fe_periclase_HS()\n        )",
  "def __init__(self):\n        helpers.HelperSpinTransition.__init__(\n            self, 63.0e9, fe_periclase_LS(), fe_periclase_HS()\n        )",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 11.412e-6,\n            \"K_0\": 159.1e9,\n            \"Kprime_0\": 4.11,\n            \"G_0\": 105.43e9,\n            \"Gprime_0\": 1.773,\n            \"molar_mass\": 0.047,\n            \"n\": 2,\n            \"Debye_0\": 706.0,\n            \"grueneisen_0\": 1.45,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.54,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 11.171e-6,\n            \"K_0\": 170.0e9,\n            \"Kprime_0\": 4.00,\n            \"G_0\": 116.34e9,\n            \"Gprime_0\": 1.668,\n            \"molar_mass\": 0.047,\n            \"n\": 2,\n            \"Debye_0\": 706.0,\n            \"grueneisen_0\": 1.45,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.54,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 11.412e-6,\n            \"K_0\": 159.1e9,\n            \"Kprime_0\": 4.11,\n            \"G_0\": 129.35e9,\n            \"Gprime_0\": 1.993,\n            \"molar_mass\": 0.0469,\n            \"n\": 2,\n            \"Debye_0\": 706.0,\n            \"grueneisen_0\": 1.45,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.54,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 11.171e-6,\n            \"K_0\": 170.0e9,\n            \"Kprime_0\": 4.0,\n            \"G_0\": 151.67e9,\n            \"Gprime_0\": 1.754,\n            \"molar_mass\": 0.0469,\n            \"n\": 2,\n            \"Debye_0\": 706.0,\n            \"grueneisen_0\": 1.45,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.54,\n        }\n\n        Mineral.__init__(self)",
  "class ab(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Albite\",\n            \"formula\": {\"Na\": 1.0, \"Al\": 1.0, \"Si\": 3.0, \"O\": 8.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3720147.5999999996,\n            \"V_0\": 0.000100452,\n            \"K_0\": 59752680000.0,\n            \"Kprime_0\": 2.77841,\n            \"Debye_0\": 720.00359,\n            \"grueneisen_0\": 0.57885,\n            \"q_0\": 1.0,\n            \"G_0\": 36000000000.0,\n            \"Gprime_0\": 1.38571,\n            \"eta_s_0\": 1.02978,\n            \"n\": 13.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.262223,\n        }\n\n        Mineral.__init__(self)",
  "class al(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Almandine\",\n            \"formula\": {\"Fe\": 3.0, \"Al\": 2.0, \"Si\": 3.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -4933027.97,\n            \"V_0\": 0.00011543,\n            \"K_0\": 173896370000.0,\n            \"Kprime_0\": 4.91341,\n            \"Debye_0\": 741.38227,\n            \"grueneisen_0\": 1.06493,\n            \"q_0\": 1.42169,\n            \"G_0\": 96000000000.0,\n            \"Gprime_0\": 1.40927,\n            \"eta_s_0\": 2.09289,\n            \"n\": 20.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.49776,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 7.5, \"S_D\": 40.14405, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class alpv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Al-Perovskite\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1517728.6300000001,\n            \"V_0\": 2.4944e-05,\n            \"K_0\": 242400000000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 858.26509,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 169199620000.0,\n            \"Gprime_0\": 1.55703,\n            \"eta_s_0\": 2.2751,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.101961,\n        }\n\n        Mineral.__init__(self)",
  "class an(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Anorthite\",\n            \"formula\": {\"Ca\": 1.0, \"Al\": 2.0, \"Si\": 2.0, \"O\": 8.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -4013369.04,\n            \"V_0\": 0.00010061,\n            \"K_0\": 84093310000.0,\n            \"Kprime_0\": 6.73404,\n            \"Debye_0\": 752.34537,\n            \"grueneisen_0\": 0.38497,\n            \"q_0\": 1.0,\n            \"G_0\": 39900000000.0,\n            \"Gprime_0\": 1.09129,\n            \"eta_s_0\": 1.63323,\n            \"n\": 13.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.278211,\n        }\n\n        Mineral.__init__(self)",
  "class anao(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"alpha-NaO2_phase\",\n            \"formula\": {\"Na\": 2.0, \"Al\": 2.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2114835.79,\n            \"V_0\": 4.542e-05,\n            \"K_0\": 161143930000.0,\n            \"Kprime_0\": 3.90838,\n            \"Debye_0\": 753.49641,\n            \"grueneisen_0\": 1.45033,\n            \"q_0\": 1.5487,\n            \"G_0\": 108455900000.0,\n            \"Gprime_0\": 2.14668,\n            \"eta_s_0\": 0.78047,\n            \"n\": 8.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.16394023,\n        }\n\n        Mineral.__init__(self)",
  "class apbo(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"alpha-PbO_2-SiO_2\",\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -793366.84,\n            \"V_0\": 1.367e-05,\n            \"K_0\": 327156010000.0,\n            \"Kprime_0\": 4.01662,\n            \"Debye_0\": 1128.9459,\n            \"grueneisen_0\": 1.55674,\n            \"q_0\": 2.2096,\n            \"G_0\": 227411590000.0,\n            \"Gprime_0\": 1.77078,\n            \"eta_s_0\": 4.55828,\n            \"n\": 3.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.060085,\n        }\n\n        Mineral.__init__(self)",
  "class appv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Al-Post-Perovskite\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1336464.73,\n            \"V_0\": 2.3847e-05,\n            \"K_0\": 249000000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 722.93835,\n            \"grueneisen_0\": 1.88758,\n            \"q_0\": 2.04631,\n            \"G_0\": 91965260000.0,\n            \"Gprime_0\": 1.81603,\n            \"eta_s_0\": 2.52605,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.101961,\n        }\n\n        Mineral.__init__(self)",
  "class capv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Ca-Perovskite\",\n            \"formula\": {\"Ca\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1459910.1800000002,\n            \"V_0\": 2.745e-05,\n            \"K_0\": 236000000000.0,\n            \"Kprime_0\": 3.9,\n            \"Debye_0\": 798.78581,\n            \"grueneisen_0\": 1.88943,\n            \"q_0\": 0.89662,\n            \"G_0\": 155205240000.0,\n            \"Gprime_0\": 2.22637,\n            \"eta_s_0\": 1.23493,\n            \"n\": 5.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.116164,\n        }\n\n        Mineral.__init__(self)",
  "class cats(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Lime_Tschermak'\",\n            \"formula\": {\"Ca\": 1.0, \"Al\": 2.0, \"Si\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3119447.41,\n            \"V_0\": 6.3574e-05,\n            \"K_0\": 113759900000.0,\n            \"Kprime_0\": 4.8061,\n            \"Debye_0\": 804.36068,\n            \"grueneisen_0\": 0.82288,\n            \"q_0\": 0.60142,\n            \"G_0\": 74424990000.0,\n            \"Gprime_0\": 1.71384,\n            \"eta_s_0\": 1.73383,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.218123,\n        }\n\n        Mineral.__init__(self)",
  "class cen(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Clinoenstatite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2906835.53,\n            \"V_0\": 6.25e-05,\n            \"K_0\": 113759900000.0,\n            \"Kprime_0\": 4.8061,\n            \"Debye_0\": 806.64315,\n            \"grueneisen_0\": 1.00921,\n            \"q_0\": 0.60142,\n            \"G_0\": 76970360000.0,\n            \"Gprime_0\": 1.71384,\n            \"eta_s_0\": 1.43121,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2007774,\n        }\n\n        Mineral.__init__(self)",
  "class co(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Corundum\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1582440.3199999998,\n            \"V_0\": 2.5577e-05,\n            \"K_0\": 252585720000.0,\n            \"Kprime_0\": 3.88671,\n            \"Debye_0\": 932.21586,\n            \"grueneisen_0\": 1.3081,\n            \"q_0\": 1.71245,\n            \"G_0\": 163200000000.0,\n            \"Gprime_0\": 1.81492,\n            \"eta_s_0\": 2.63052,\n            \"n\": 5.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.101961,\n        }\n\n        Mineral.__init__(self)",
  "class coes(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Coesite\",\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -856110.36,\n            \"V_0\": 2.0657e-05,\n            \"K_0\": 103538150000.0,\n            \"Kprime_0\": 2.9007,\n            \"Debye_0\": 880.23946,\n            \"grueneisen_0\": 0.29064,\n            \"q_0\": 1.0,\n            \"G_0\": 61600000000.0,\n            \"Gprime_0\": 0.49686,\n            \"eta_s_0\": 2.75988,\n            \"n\": 3.0,\n            \"Z\": 16.0,\n            \"molar_mass\": 0.060085,\n        }\n\n        Mineral.__init__(self)",
  "class crst(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Cristobalite\",\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -852539.43,\n            \"V_0\": 2.72397e-05,\n            \"K_0\": 11500000000.0,\n            \"Kprime_0\": 9.0,\n            \"Debye_0\": 794.74452,\n            \"grueneisen_0\": 0.01515,\n            \"q_0\": 1.0,\n            \"G_0\": 20327540000.0,\n            \"Gprime_0\": 4.06551,\n            \"eta_s_0\": 1.17003,\n            \"n\": 3.0,\n            \"Z\": 16.0,\n            \"molar_mass\": 0.060085,\n        }\n\n        Mineral.__init__(self)",
  "class di(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Diopside\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3029608.3800000004,\n            \"V_0\": 6.6039e-05,\n            \"K_0\": 113759900000.0,\n            \"Kprime_0\": 4.8061,\n            \"Debye_0\": 782.57306,\n            \"grueneisen_0\": 1.00921,\n            \"q_0\": 0.60142,\n            \"G_0\": 72700000000.0,\n            \"Gprime_0\": 1.71384,\n            \"eta_s_0\": 1.06175,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2165504,\n        }\n\n        Mineral.__init__(self)",
  "class en(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Enstatite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2914163.5999999996,\n            \"V_0\": 6.2676e-05,\n            \"K_0\": 107076810000.0,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 812.21227,\n            \"grueneisen_0\": 0.78477,\n            \"q_0\": 3.43847,\n            \"G_0\": 76800000000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 2.5045,\n            \"n\": 10.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.2007774,\n        }\n\n        Mineral.__init__(self)",
  "class fa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fayalite\",\n            \"formula\": {\"Fe\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1371695.6600000001,\n            \"V_0\": 4.629e-05,\n            \"K_0\": 136485580000.0,\n            \"Kprime_0\": 4.88157,\n            \"Debye_0\": 618.96116,\n            \"grueneisen_0\": 1.08388,\n            \"q_0\": 2.88055,\n            \"G_0\": 51220000000.0,\n            \"Gprime_0\": 0.85893,\n            \"eta_s_0\": 1.65937,\n            \"n\": 7.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.203777,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 65.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class fapv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"FeAlO3-Perovskite_HS\",\n            \"formula\": {\"Fe\": 1.0, \"Al\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -848315.02,\n            \"V_0\": 2.72604e-05,\n            \"K_0\": 223325500000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 755.38117,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 150042090000.0,\n            \"Gprime_0\": 1.73259,\n            \"eta_s_0\": 2.55505,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.1308249,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 10.0, \"S_D\": 14.89723, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class fec2(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"HP-Clinoferrosilite\",\n            \"formula\": {\"Fe\": 2.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2224211.0,\n            \"V_0\": 6.38541e-05,\n            \"K_0\": 116024900000.0,\n            \"Kprime_0\": 6.23682,\n            \"Debye_0\": 698.72086,\n            \"grueneisen_0\": 1.12442,\n            \"q_0\": 0.20362,\n            \"G_0\": 75147210000.0,\n            \"Gprime_0\": 1.8412,\n            \"eta_s_0\": 0.98031,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2638614,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class fecf(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Ca-Ferrite\",\n            \"formula\": {\"Fe\": 1.0, \"Al\": 2.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1774197.05,\n            \"V_0\": 3.7216e-05,\n            \"K_0\": 213000000000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 734.07527,\n            \"grueneisen_0\": 1.56672,\n            \"q_0\": 1.0,\n            \"G_0\": 159709650000.0,\n            \"Gprime_0\": 1.93591,\n            \"eta_s_0\": 2.34163,\n            \"n\": 7.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.173806,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 13.38135, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class feil(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Akimotoite\",\n            \"formula\": {\"Fe\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1047531.34,\n            \"V_0\": 2.6854e-05,\n            \"K_0\": 210693870000.0,\n            \"Kprime_0\": 5.2154,\n            \"Debye_0\": 781.36175,\n            \"grueneisen_0\": 1.19458,\n            \"q_0\": 2.2246,\n            \"G_0\": 160833570000.0,\n            \"Gprime_0\": 1.81492,\n            \"eta_s_0\": 3.43813,\n            \"n\": 5.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.131931,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 13.38135, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class fepv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Perovskite\",\n            \"formula\": {\"Fe\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1002662.5299999999,\n            \"V_0\": 2.5321e-05,\n            \"K_0\": 270582550000.00003,\n            \"Kprime_0\": 4.01,\n            \"Debye_0\": 746.56455,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 130020980000.00002,\n            \"Gprime_0\": 1.37254,\n            \"eta_s_0\": 2.0941,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.131931,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 13.38135, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class feri(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Ringwoodite\",\n            \"formula\": {\"Fe\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1359229.67,\n            \"V_0\": 4.186e-05,\n            \"K_0\": 213410280000.0,\n            \"Kprime_0\": 4.22034,\n            \"Debye_0\": 662.84304,\n            \"grueneisen_0\": 1.26584,\n            \"q_0\": 2.39042,\n            \"G_0\": 92000000000.0,\n            \"Gprime_0\": 1.35412,\n            \"eta_s_0\": 1.77066,\n            \"n\": 7.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.203777,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class fewa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Wadsleyite\",\n            \"formula\": {\"Fe\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1358363.34,\n            \"V_0\": 4.28e-05,\n            \"K_0\": 168579210000.0,\n            \"Kprime_0\": 4.12303,\n            \"Debye_0\": 647.34559,\n            \"grueneisen_0\": 1.20388,\n            \"q_0\": 2.21007,\n            \"G_0\": 72000000000.0,\n            \"Gprime_0\": 1.50973,\n            \"eta_s_0\": 0.95246,\n            \"n\": 7.0,\n            \"Z\": 8.0,\n            \"molar_mass\": 0.203777,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class flpv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Perovskite_Low_Spin\",\n            \"formula\": {\"Fe\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -879526.2000000001,\n            \"V_0\": 2.497e-05,\n            \"K_0\": 270582550000.00003,\n            \"Kprime_0\": 4.01,\n            \"Debye_0\": 692.38659,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 130337050000.0,\n            \"Gprime_0\": 1.37411,\n            \"eta_s_0\": 1.99344,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.131931,\n        }\n\n        Mineral.__init__(self)",
  "class fnal(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fe-NAL_Phase\",\n            \"formula\": {\"Na\": 1.0, \"Fe\": 2.0, \"Al\": 5.0, \"Si\": 1.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5475295.42,\n            \"V_0\": 0.000112045,\n            \"K_0\": 203995010000.0,\n            \"Kprime_0\": 4.31884,\n            \"Debye_0\": 795.29328,\n            \"grueneisen_0\": 1.42971,\n            \"q_0\": 1.0,\n            \"G_0\": 149593770000.0,\n            \"Gprime_0\": 1.7423,\n            \"eta_s_0\": 2.65939,\n            \"n\": 21.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.48966601,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class fo(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Forsterite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2055371.19,\n            \"V_0\": 4.3603e-05,\n            \"K_0\": 127955500000.0,\n            \"Kprime_0\": 4.21796,\n            \"Debye_0\": 809.1977,\n            \"grueneisen_0\": 0.9928,\n            \"q_0\": 2.10671,\n            \"G_0\": 81600000000.0,\n            \"Gprime_0\": 1.46257,\n            \"eta_s_0\": 2.29968,\n            \"n\": 7.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.140695,\n        }\n\n        Mineral.__init__(self)",
  "class fppv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fe-PostPerovskite\",\n            \"formula\": {\"Fe\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -982035.5,\n            \"V_0\": 2.46519e-05,\n            \"K_0\": 292000000000.0,\n            \"Kprime_0\": 3.74,\n            \"Debye_0\": 794.15823,\n            \"grueneisen_0\": 1.76958,\n            \"q_0\": 2.04631,\n            \"G_0\": 129500000000.0,\n            \"Gprime_0\": 1.31526,\n            \"eta_s_0\": 1.72601,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.131931,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 13.38135, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class fs(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Ferrosilite\",\n            \"formula\": {\"Fe\": 2.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2228327.6999999997,\n            \"V_0\": 6.5941e-05,\n            \"K_0\": 100545910000.0,\n            \"Kprime_0\": 7.87534,\n            \"Debye_0\": 682.67865,\n            \"grueneisen_0\": 0.71519,\n            \"q_0\": 3.43847,\n            \"G_0\": 52000000000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 1.08309,\n            \"n\": 10.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.2638614,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class gr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Grossular\",\n            \"formula\": {\"Ca\": 3.0, \"Al\": 2.0, \"Si\": 3.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -6275179.81,\n            \"V_0\": 0.00012512,\n            \"K_0\": 167062260000.0,\n            \"Kprime_0\": 3.91544,\n            \"Debye_0\": 822.77062,\n            \"grueneisen_0\": 1.05402,\n            \"q_0\": 1.88886,\n            \"G_0\": 109000000000.0,\n            \"Gprime_0\": 1.16274,\n            \"eta_s_0\": 2.38415,\n            \"n\": 20.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.450449,\n        }\n\n        Mineral.__init__(self)",
  "class hc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Hercynite\",\n            \"formula\": {\"Fe\": 4.0, \"Al\": 8.0, \"O\": 16.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -7356185.029999999,\n            \"V_0\": 0.000163372,\n            \"K_0\": 208982310000.0,\n            \"Kprime_0\": 4.62659,\n            \"Debye_0\": 794.21184,\n            \"grueneisen_0\": 1.19332,\n            \"q_0\": 4.05077,\n            \"G_0\": 84500000000.0,\n            \"Gprime_0\": 0.62792,\n            \"eta_s_0\": 2.49369,\n            \"n\": 28.0,\n            \"Z\": 8.0,\n            \"molar_mass\": 0.69524,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 53.5254, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class he(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Hedenbergite\",\n            \"formula\": {\"Ca\": 1.0, \"Fe\": 1.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2676991.78,\n            \"V_0\": 6.7867e-05,\n            \"K_0\": 119204720000.0,\n            \"Kprime_0\": 4.81927,\n            \"Debye_0\": 702.08234,\n            \"grueneisen_0\": 0.96665,\n            \"q_0\": 0.60142,\n            \"G_0\": 61000000000.0,\n            \"Gprime_0\": 1.71384,\n            \"eta_s_0\": 1.01745,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2480924,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 13.38135, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class hem(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Hematite\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -744041.62,\n            \"V_0\": 3.0287e-05,\n            \"K_0\": 204245330000.0,\n            \"Kprime_0\": 4.0997,\n            \"Debye_0\": 653.80768,\n            \"grueneisen_0\": 1.58945,\n            \"q_0\": 2.2246,\n            \"G_0\": 91000000000.0,\n            \"Gprime_0\": 1.81492,\n            \"eta_s_0\": 0.52408,\n            \"n\": 5.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.15968852,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 950.01, \"S_D\": 29.79445, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class hepv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fe2O3-Perovskite_HS\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -721269.05,\n            \"V_0\": 3.08668e-05,\n            \"K_0\": 135000000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 613.90405,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 88766580000.0,\n            \"Gprime_0\": 1.73259,\n            \"eta_s_0\": 0.66524,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.15968852,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 10.0, \"S_D\": 29.79445, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class hlpv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Fe2O3-Perovskite_LS\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -617631.95,\n            \"V_0\": 2.75209e-05,\n            \"K_0\": 204251000000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 725.62214,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 163996000000.0,\n            \"Gprime_0\": 1.73259,\n            \"eta_s_0\": 3.0318,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.15968852,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 10.0, \"S_D\": 20.66026, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class hmag(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"High-Pressure_Magnetit\",\n            \"formula\": {\"Fe\": 3.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -964475.2200000001,\n            \"V_0\": 4.1702e-05,\n            \"K_0\": 172000000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 533.17958,\n            \"grueneisen_0\": 1.56672,\n            \"q_0\": 1.0,\n            \"G_0\": 108730730000.0,\n            \"Gprime_0\": 1.93591,\n            \"eta_s_0\": 0.90477,\n            \"n\": 7.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.23153307,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 845.5, \"S_D\": 43.1758, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class hppv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"HS_Fe2O3-Post-Perovski\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -622376.42,\n            \"V_0\": 2.76884e-05,\n            \"K_0\": 176500000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 688.0644,\n            \"grueneisen_0\": 1.76958,\n            \"q_0\": 2.04631,\n            \"G_0\": 159009520000.0,\n            \"Gprime_0\": 1.85188,\n            \"eta_s_0\": 2.00124,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.15968852,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 10.0, \"S_D\": 29.79445, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class jd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Jadeite\",\n            \"formula\": {\"Na\": 1.0, \"Al\": 1.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2855195.56,\n            \"V_0\": 6.0508e-05,\n            \"K_0\": 142292260000.0,\n            \"Kprime_0\": 4.8061,\n            \"Debye_0\": 820.78389,\n            \"grueneisen_0\": 0.89983,\n            \"q_0\": 0.78628,\n            \"G_0\": 85000000000.0,\n            \"Gprime_0\": 1.71384,\n            \"eta_s_0\": 1.88167,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2021387,\n        }\n\n        Mineral.__init__(self)",
  "class ky(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Kyanite\",\n            \"formula\": {\"Al\": 2.0, \"Si\": 1.0, \"O\": 5.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2446081.74,\n            \"V_0\": 4.4227e-05,\n            \"K_0\": 160000000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 943.19593,\n            \"grueneisen_0\": 0.92549,\n            \"q_0\": 1.0,\n            \"G_0\": 117854530000.0,\n            \"Gprime_0\": 1.69416,\n            \"eta_s_0\": 2.90375,\n            \"n\": 8.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.1620456,\n        }\n\n        Mineral.__init__(self)",
  "class lppv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"LS_Fe2O3-Post-Perovski\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -407182.57,\n            \"V_0\": 2.62534e-05,\n            \"K_0\": 176500000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 720.85819,\n            \"grueneisen_0\": 1.76958,\n            \"q_0\": 2.04631,\n            \"G_0\": 207396350000.0,\n            \"Gprime_0\": 1.85188,\n            \"eta_s_0\": 3.23888,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.15968852,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 10.0, \"S_D\": 20.66026, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class mag(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Magnetite\",\n            \"formula\": {\"Fe\": 3.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -987192.39,\n            \"V_0\": 4.4528e-05,\n            \"K_0\": 183965710000.0,\n            \"Kprime_0\": 5.24573,\n            \"Debye_0\": 520.10184,\n            \"grueneisen_0\": 1.32115,\n            \"q_0\": 1.5487,\n            \"G_0\": 60300000000.0,\n            \"Gprime_0\": -0.05466,\n            \"eta_s_0\": 2.43429,\n            \"n\": 7.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.23153307,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 845.5, \"S_D\": 43.1758, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class mgc2(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"HP-Clinoenstatite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2905475.75,\n            \"V_0\": 6.076e-05,\n            \"K_0\": 116024900000.0,\n            \"Kprime_0\": 6.23682,\n            \"Debye_0\": 822.89602,\n            \"grueneisen_0\": 1.12442,\n            \"q_0\": 0.20362,\n            \"G_0\": 87927160000.0,\n            \"Gprime_0\": 1.8412,\n            \"eta_s_0\": 2.14112,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2007774,\n        }\n\n        Mineral.__init__(self)",
  "class mgcf(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Ca-Ferrite\",\n            \"formula\": {\"Mg\": 1.0, \"Al\": 2.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2122873.69,\n            \"V_0\": 3.6135e-05,\n            \"K_0\": 213000000000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 831.14221,\n            \"grueneisen_0\": 1.56672,\n            \"q_0\": 1.0,\n            \"G_0\": 129699999999.99998,\n            \"Gprime_0\": 1.93591,\n            \"eta_s_0\": 1.30302,\n            \"n\": 7.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.142266,\n        }\n\n        Mineral.__init__(self)",
  "class mgil(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Akimotoite\",\n            \"formula\": {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1409831.95,\n            \"V_0\": 2.6354e-05,\n            \"K_0\": 210693870000.0,\n            \"Kprime_0\": 5.2154,\n            \"Debye_0\": 932.602,\n            \"grueneisen_0\": 1.19458,\n            \"q_0\": 2.2246,\n            \"G_0\": 132000000000.0,\n            \"Gprime_0\": 1.81492,\n            \"eta_s_0\": 3.40174,\n            \"n\": 5.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.100389,\n        }\n\n        Mineral.__init__(self)",
  "class mgmj(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Majorite\",\n            \"formula\": {\"Mg\": 4.0, \"Si\": 4.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5693291.79,\n            \"V_0\": 0.000114324,\n            \"K_0\": 165118370000.0,\n            \"Kprime_0\": 4.21183,\n            \"Debye_0\": 822.48562,\n            \"grueneisen_0\": 0.97681,\n            \"q_0\": 1.53581,\n            \"G_0\": 85000000000.0,\n            \"Gprime_0\": 1.42969,\n            \"eta_s_0\": 1.01779,\n            \"n\": 20.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.40156,\n        }\n\n        Mineral.__init__(self)",
  "class mgpv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Perovskite\",\n            \"formula\": {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1362442.75,\n            \"V_0\": 2.4445e-05,\n            \"K_0\": 250546900000.0,\n            \"Kprime_0\": 4.13499,\n            \"Debye_0\": 880.01895,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 172900000000.0,\n            \"Gprime_0\": 1.73259,\n            \"eta_s_0\": 1.65573,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.100389,\n        }\n\n        Mineral.__init__(self)",
  "class mgri(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Ringwoodite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2017223.98,\n            \"V_0\": 3.9493e-05,\n            \"K_0\": 184899930000.0,\n            \"Kprime_0\": 4.22034,\n            \"Debye_0\": 875.13511,\n            \"grueneisen_0\": 1.1072,\n            \"q_0\": 2.39042,\n            \"G_0\": 123000000000.0,\n            \"Gprime_0\": 1.35412,\n            \"eta_s_0\": 2.30288,\n            \"n\": 7.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.140693,\n        }\n\n        Mineral.__init__(self)",
  "class mgts(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Tschermak's\",\n            \"formula\": {\"Mg\": 1.0, \"Al\": 2.0, \"Si\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3002410.17,\n            \"V_0\": 5.914e-05,\n            \"K_0\": 107076810000.0,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 783.94073,\n            \"grueneisen_0\": 0.78477,\n            \"q_0\": 3.43847,\n            \"G_0\": 93471460000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 2.39416,\n            \"n\": 10.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.20235,\n        }\n\n        Mineral.__init__(self)",
  "class mgwa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Wadsleyite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2028172.68,\n            \"V_0\": 4.0515e-05,\n            \"K_0\": 168701060000.0,\n            \"Kprime_0\": 4.12303,\n            \"Debye_0\": 845.20132,\n            \"grueneisen_0\": 1.20388,\n            \"q_0\": 2.21007,\n            \"G_0\": 112000000000.0,\n            \"Gprime_0\": 1.50973,\n            \"eta_s_0\": 2.56133,\n            \"n\": 7.0,\n            \"Z\": 8.0,\n            \"molar_mass\": 0.140695,\n        }\n\n        Mineral.__init__(self)",
  "class mnal(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Mg-NAL_Phase\",\n            \"formula\": {\"Na\": 1.0, \"Mg\": 2.0, \"Al\": 5.0, \"Si\": 1.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -6167391.6,\n            \"V_0\": 0.000109883,\n            \"K_0\": 203995010000.0,\n            \"Kprime_0\": 4.31884,\n            \"Debye_0\": 858.38264,\n            \"grueneisen_0\": 1.42971,\n            \"q_0\": 1.0,\n            \"G_0\": 129000000000.0,\n            \"Gprime_0\": 1.7423,\n            \"eta_s_0\": 1.93069,\n            \"n\": 21.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.42658581,\n        }\n\n        Mineral.__init__(self)",
  "class mppv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Mg-PostPerovskite\",\n            \"formula\": {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1313625.76,\n            \"V_0\": 2.35252e-05,\n            \"K_0\": 292000000000.0,\n            \"Kprime_0\": 3.74,\n            \"Debye_0\": 941.49795,\n            \"grueneisen_0\": 1.76958,\n            \"q_0\": 2.04631,\n            \"G_0\": 171135870000.0,\n            \"Gprime_0\": 1.85188,\n            \"eta_s_0\": 1.2881,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.100389,\n        }\n\n        Mineral.__init__(self)",
  "class nacf(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Na-Ca-Ferrite\",\n            \"formula\": {\"Na\": 1.0, \"Al\": 1.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1835429.51,\n            \"V_0\": 3.627e-05,\n            \"K_0\": 220000000000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 683.31827,\n            \"grueneisen_0\": 1.56672,\n            \"q_0\": 1.0,\n            \"G_0\": 135326619999.99998,\n            \"Gprime_0\": 1.93591,\n            \"eta_s_0\": 1.36827,\n            \"n\": 7.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.142054,\n        }\n\n        Mineral.__init__(self)",
  "class namj(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Na-Majorite\",\n            \"formula\": {\"Na\": 2.0, \"Mg\": 1.0, \"Si\": 5.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5303066.24,\n            \"V_0\": 0.000110842,\n            \"K_0\": 172035150000.0,\n            \"Kprime_0\": 5.2005,\n            \"Debye_0\": 844.73722,\n            \"grueneisen_0\": 1.25078,\n            \"q_0\": 0.10916,\n            \"G_0\": 114700000000.0,\n            \"Gprime_0\": 1.35756,\n            \"eta_s_0\": 2.4849,\n            \"n\": 20.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.40270437,\n        }\n\n        Mineral.__init__(self)",
  "class neph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Nepheline\",\n            \"formula\": {\"Na\": 1.0, \"Al\": 1.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1994469.57,\n            \"V_0\": 5.38684e-05,\n            \"K_0\": 53055500000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 743.57985,\n            \"grueneisen_0\": 0.6969,\n            \"q_0\": 1.0,\n            \"G_0\": 30700000000.0,\n            \"Gprime_0\": 1.33087,\n            \"eta_s_0\": 0.6241,\n            \"n\": 7.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.14205431,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 467.0, \"S_D\": 10.0, \"V_D\": 0.8}]\n        ]\n\n        Mineral.__init__(self)",
  "class nnal(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Na-NAL_Phase\",\n            \"formula\": {\"Na\": 3.0, \"Al\": 3.0, \"Si\": 3.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5567127.9,\n            \"V_0\": 0.000109401,\n            \"K_0\": 203995010000.0,\n            \"Kprime_0\": 4.31884,\n            \"Debye_0\": 850.32833,\n            \"grueneisen_0\": 1.42971,\n            \"q_0\": 1.0,\n            \"G_0\": 144451020000.0,\n            \"Gprime_0\": 1.7423,\n            \"eta_s_0\": 2.42502,\n            \"n\": 21.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.42616294,\n        }\n\n        Mineral.__init__(self)",
  "class odi(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Ortho-Diopside\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3015734.13,\n            \"V_0\": 6.8054e-05,\n            \"K_0\": 107076810000.0,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 744.54893,\n            \"grueneisen_0\": 0.78477,\n            \"q_0\": 3.43847,\n            \"G_0\": 57508750000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 1.31909,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2165504,\n        }\n\n        Mineral.__init__(self)",
  "class pe(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Periclase\",\n            \"formula\": {\"Mg\": 4.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2278109.88,\n            \"V_0\": 4.4976e-05,\n            \"K_0\": 161143930000.0,\n            \"Kprime_0\": 3.90838,\n            \"Debye_0\": 770.90151,\n            \"grueneisen_0\": 1.45033,\n            \"q_0\": 1.5487,\n            \"G_0\": 130900000000.0,\n            \"Gprime_0\": 2.14668,\n            \"eta_s_0\": 2.56123,\n            \"n\": 8.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.16121782,\n        }\n\n        Mineral.__init__(self)",
  "class py(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Pyrope\",\n            \"formula\": {\"Mg\": 3.0, \"Al\": 2.0, \"Si\": 3.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5937137.35,\n            \"V_0\": 0.00011308,\n            \"K_0\": 170239640000.0,\n            \"Kprime_0\": 4.11067,\n            \"Debye_0\": 823.23783,\n            \"grueneisen_0\": 1.01422,\n            \"q_0\": 1.42169,\n            \"G_0\": 93700000000.0,\n            \"Gprime_0\": 1.35756,\n            \"eta_s_0\": 0.98186,\n            \"n\": 20.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.40313,\n        }\n\n        Mineral.__init__(self)",
  "class qtz(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Quartz\",\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -860118.03,\n            \"V_0\": 2.24211e-05,\n            \"K_0\": 61425370000.0,\n            \"Kprime_0\": 19.78011,\n            \"Debye_0\": 884.20481,\n            \"grueneisen_0\": -0.03958,\n            \"q_0\": 1.0,\n            \"G_0\": 44857760000.0,\n            \"Gprime_0\": -0.04277,\n            \"eta_s_0\": 2.40509,\n            \"n\": 3.0,\n            \"Z\": 16.0,\n            \"molar_mass\": 0.060085,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 847.0, \"S_D\": 5.76, \"V_D\": 1.35936}]\n        ]\n\n        Mineral.__init__(self)",
  "class sp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Spinel\",\n            \"formula\": {\"Mg\": 4.0, \"Al\": 8.0, \"O\": 16.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -8680043.36,\n            \"V_0\": 0.000159048,\n            \"K_0\": 195139330000.0,\n            \"Kprime_0\": 4.62659,\n            \"Debye_0\": 856.3695,\n            \"grueneisen_0\": 0.97518,\n            \"q_0\": 4.05077,\n            \"G_0\": 109000000000.0,\n            \"Gprime_0\": 0.62792,\n            \"eta_s_0\": 2.44263,\n            \"n\": 28.0,\n            \"Z\": 8.0,\n            \"molar_mass\": 0.569068,\n        }\n\n        Mineral.__init__(self)",
  "class st(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Stishovite\",\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -817491.62,\n            \"V_0\": 1.4017e-05,\n            \"K_0\": 305833020000.0,\n            \"Kprime_0\": 4.0292,\n            \"Debye_0\": 1092.17047,\n            \"grueneisen_0\": 1.55674,\n            \"q_0\": 2.2096,\n            \"G_0\": 228000000000.0,\n            \"Gprime_0\": 1.94045,\n            \"eta_s_0\": 4.40394,\n            \"n\": 3.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.060085,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": -4250.0, \"S_D\": 4e-05, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class wu(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": 'W\\\\\"ustite',\n            \"formula\": {\"Fe\": 4.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -974607.49,\n            \"V_0\": 4.9024e-05,\n            \"K_0\": 160700000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 454.1752,\n            \"grueneisen_0\": 1.45033,\n            \"q_0\": 1.5487,\n            \"G_0\": 59000000000.0,\n            \"Gprime_0\": 1.44764,\n            \"eta_s_0\": 0.06776,\n            \"n\": 8.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.28737822,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 191.0, \"S_D\": 53.5254, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "class wuls(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": 'W\\\\\"ustite_Low_Spin',\n            \"formula\": {\"Fe\": 4.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -621968.16,\n            \"V_0\": 4.33997e-05,\n            \"K_0\": 199700000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 524.57881,\n            \"grueneisen_0\": 1.45033,\n            \"q_0\": 1.5487,\n            \"G_0\": 59000000000.0,\n            \"Gprime_0\": 1.44073,\n            \"eta_s_0\": -0.13801,\n            \"n\": 8.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.28737822,\n        }\n\n        Mineral.__init__(self)",
  "class c2c_pyroxene(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"c2c_pyroxene\"\n        self.solution_model = IdealSolution(\n            endmembers=[\n                [mgc2(), \"[Mg]2\"],\n                [fec2(), \"[Fe]2\"],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class calcium_ferrite_structured_phase(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"calcium_ferrite_structured_phase\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [mgcf(), \"[Mg][Al]\"],\n                [fecf(), \"[Fe][Al]\"],\n                [nacf(), \"[Na][Si]\"],\n            ],\n            alphas=[1.0, 1.0, 4.4532],\n            energy_interaction=[[0.0, 60825.08], [60825.08]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class clinopyroxene(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"clinopyroxene\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [di(), \"[Ca][Mg][Si]2\"],\n                [he(), \"[Ca][Fe][Si]2\"],\n                [cen(), \"[Mg][Mg][Si]2\"],\n                [cats(), \"[Ca][Al][Si1/2Al1/2]2\"],\n                [jd(), \"[Na][Al][Si]2\"],\n            ],\n            alphas=[1.0, 1.0, 1.0, 3.5, 1.0],\n            energy_interaction=[\n                [0.0, 24740.0, 26000.0, 24300.0],\n                [24740.0, 26000.0, 24300.0],\n                [60132.81, 46046.07],\n                [10000.0],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class garnet(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"garnet\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [py(), \"[Mg]3[Al][Al]\"],\n                [al(), \"[Fe]3[Al][Al]\"],\n                [gr(), \"[Ca]3[Al][Al]\"],\n                [mgmj(), \"[Mg]3[Mg][Si]\"],\n                [namj(), \"[Na2/3Mg1/3]3[Si][Si]\"],\n            ],\n            energy_interaction=[\n                [0.0, 21117.58, 22672.42, 22672.42],\n                [21117.58, 22672.42, 22672.42],\n                [60718.2, 60718.2],\n                [70879.14],\n            ],\n            volume_interaction=[\n                [0.0, 1.03e-06, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [1.03e-06, 0.0],\n                [0.0],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class ilmenite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"ilmenite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mgil(), \"[Mg][Si]\"],\n                [feil(), \"[Fe][Si]\"],\n                [co(), \"[Al][Al]\"],\n            ],\n            energy_interaction=[[0.0, 59348.69], [59348.69]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class ferropericlase(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"ferropericlase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [pe(), \"[Mg]2[Mg]2\"],\n                [wu(), \"[Fe]2[Fe]2\"],\n                [anao(), \"[Na]2[Al]2\"],\n            ],\n            energy_interaction=[[44000.0, 120000.0], [120000.0]],\n            volume_interaction=[[4.4e-07, 0.0], [0.0]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class new_aluminous_phase(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"new_aluminous_phase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mnal(), \"[Mg]2[Al5/6Si1/6]6\"],\n                [fnal(), \"[Fe]2[Al5/6Si1/6]6\"],\n                [nnal(), \"[Na]2[Al3/6Si3/6]6\"],\n            ],\n            energy_interaction=[[0.0, -60781.47], [-60781.47]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class olivine(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"olivine\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [fo(), \"[Mg]2\"],\n                [fa(), \"[Fe]2\"],\n            ],\n            energy_interaction=[[4694.66]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class orthopyroxene(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [en(), \"[Mg][Mg]\"],\n                [fs(), \"[Fe][Fe]\"],\n                [mgts(), \"[Mg][Al]\"],\n                [odi(), \"[Ca][Mg]\"],\n            ],\n            energy_interaction=[[0.0, 0.0, 32217.44], [0.0, 32217.44], [48370.41]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class plagioclase(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"plagioclase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [an(), \"[Ca]\"],\n                [ab(), \"[Na]\"],\n            ],\n            energy_interaction=[[13000.0]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class post_perovskite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"post_perovskite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mppv(), \"[Mg][Si]\"],\n                [fppv(), \"[Fe][Si]\"],\n                [appv(), \"[Al][Al]\"],\n            ],\n            energy_interaction=[[-10955.49, 34979.87], [34979.87]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class bridgmanite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"bridgmanite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mgpv(), \"[Mg][Si]\"],\n                [fepv(), \"[Fe][Si]\"],\n                [alpv(), \"[Al][Al]\"],\n            ],\n            energy_interaction=[[-11396.17, 34979.87], [0.0]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class ringwoodite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"ringwoodite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mgri(), \"[Mg]2\"],\n                [feri(), \"[Fe]2\"],\n            ],\n            energy_interaction=[[7600.74]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class mg_fe_aluminous_spinel(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"mg_fe_aluminous_spinel\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [sp(), \"[Mg3/4Al1/4]4[Al7/8Mg1/8]8\"],\n                [hc(), \"[Fe3/4Al1/4]4[Al7/8Fe1/8]8\"],\n            ],\n            energy_interaction=[[-533.21]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class wadsleyite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"wadsleyite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mgwa(), \"[Mg]2\"],\n                [fewa(), \"[Fe]2\"],\n            ],\n            energy_interaction=[[13202.38]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Albite\",\n            \"formula\": {\"Na\": 1.0, \"Al\": 1.0, \"Si\": 3.0, \"O\": 8.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3720147.5999999996,\n            \"V_0\": 0.000100452,\n            \"K_0\": 59752680000.0,\n            \"Kprime_0\": 2.77841,\n            \"Debye_0\": 720.00359,\n            \"grueneisen_0\": 0.57885,\n            \"q_0\": 1.0,\n            \"G_0\": 36000000000.0,\n            \"Gprime_0\": 1.38571,\n            \"eta_s_0\": 1.02978,\n            \"n\": 13.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.262223,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Almandine\",\n            \"formula\": {\"Fe\": 3.0, \"Al\": 2.0, \"Si\": 3.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -4933027.97,\n            \"V_0\": 0.00011543,\n            \"K_0\": 173896370000.0,\n            \"Kprime_0\": 4.91341,\n            \"Debye_0\": 741.38227,\n            \"grueneisen_0\": 1.06493,\n            \"q_0\": 1.42169,\n            \"G_0\": 96000000000.0,\n            \"Gprime_0\": 1.40927,\n            \"eta_s_0\": 2.09289,\n            \"n\": 20.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.49776,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 7.5, \"S_D\": 40.14405, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Al-Perovskite\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1517728.6300000001,\n            \"V_0\": 2.4944e-05,\n            \"K_0\": 242400000000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 858.26509,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 169199620000.0,\n            \"Gprime_0\": 1.55703,\n            \"eta_s_0\": 2.2751,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.101961,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Anorthite\",\n            \"formula\": {\"Ca\": 1.0, \"Al\": 2.0, \"Si\": 2.0, \"O\": 8.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -4013369.04,\n            \"V_0\": 0.00010061,\n            \"K_0\": 84093310000.0,\n            \"Kprime_0\": 6.73404,\n            \"Debye_0\": 752.34537,\n            \"grueneisen_0\": 0.38497,\n            \"q_0\": 1.0,\n            \"G_0\": 39900000000.0,\n            \"Gprime_0\": 1.09129,\n            \"eta_s_0\": 1.63323,\n            \"n\": 13.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.278211,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"alpha-NaO2_phase\",\n            \"formula\": {\"Na\": 2.0, \"Al\": 2.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2114835.79,\n            \"V_0\": 4.542e-05,\n            \"K_0\": 161143930000.0,\n            \"Kprime_0\": 3.90838,\n            \"Debye_0\": 753.49641,\n            \"grueneisen_0\": 1.45033,\n            \"q_0\": 1.5487,\n            \"G_0\": 108455900000.0,\n            \"Gprime_0\": 2.14668,\n            \"eta_s_0\": 0.78047,\n            \"n\": 8.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.16394023,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"alpha-PbO_2-SiO_2\",\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -793366.84,\n            \"V_0\": 1.367e-05,\n            \"K_0\": 327156010000.0,\n            \"Kprime_0\": 4.01662,\n            \"Debye_0\": 1128.9459,\n            \"grueneisen_0\": 1.55674,\n            \"q_0\": 2.2096,\n            \"G_0\": 227411590000.0,\n            \"Gprime_0\": 1.77078,\n            \"eta_s_0\": 4.55828,\n            \"n\": 3.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.060085,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Al-Post-Perovskite\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1336464.73,\n            \"V_0\": 2.3847e-05,\n            \"K_0\": 249000000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 722.93835,\n            \"grueneisen_0\": 1.88758,\n            \"q_0\": 2.04631,\n            \"G_0\": 91965260000.0,\n            \"Gprime_0\": 1.81603,\n            \"eta_s_0\": 2.52605,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.101961,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Ca-Perovskite\",\n            \"formula\": {\"Ca\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1459910.1800000002,\n            \"V_0\": 2.745e-05,\n            \"K_0\": 236000000000.0,\n            \"Kprime_0\": 3.9,\n            \"Debye_0\": 798.78581,\n            \"grueneisen_0\": 1.88943,\n            \"q_0\": 0.89662,\n            \"G_0\": 155205240000.0,\n            \"Gprime_0\": 2.22637,\n            \"eta_s_0\": 1.23493,\n            \"n\": 5.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.116164,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Lime_Tschermak'\",\n            \"formula\": {\"Ca\": 1.0, \"Al\": 2.0, \"Si\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3119447.41,\n            \"V_0\": 6.3574e-05,\n            \"K_0\": 113759900000.0,\n            \"Kprime_0\": 4.8061,\n            \"Debye_0\": 804.36068,\n            \"grueneisen_0\": 0.82288,\n            \"q_0\": 0.60142,\n            \"G_0\": 74424990000.0,\n            \"Gprime_0\": 1.71384,\n            \"eta_s_0\": 1.73383,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.218123,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Clinoenstatite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2906835.53,\n            \"V_0\": 6.25e-05,\n            \"K_0\": 113759900000.0,\n            \"Kprime_0\": 4.8061,\n            \"Debye_0\": 806.64315,\n            \"grueneisen_0\": 1.00921,\n            \"q_0\": 0.60142,\n            \"G_0\": 76970360000.0,\n            \"Gprime_0\": 1.71384,\n            \"eta_s_0\": 1.43121,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2007774,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Corundum\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1582440.3199999998,\n            \"V_0\": 2.5577e-05,\n            \"K_0\": 252585720000.0,\n            \"Kprime_0\": 3.88671,\n            \"Debye_0\": 932.21586,\n            \"grueneisen_0\": 1.3081,\n            \"q_0\": 1.71245,\n            \"G_0\": 163200000000.0,\n            \"Gprime_0\": 1.81492,\n            \"eta_s_0\": 2.63052,\n            \"n\": 5.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.101961,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Coesite\",\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -856110.36,\n            \"V_0\": 2.0657e-05,\n            \"K_0\": 103538150000.0,\n            \"Kprime_0\": 2.9007,\n            \"Debye_0\": 880.23946,\n            \"grueneisen_0\": 0.29064,\n            \"q_0\": 1.0,\n            \"G_0\": 61600000000.0,\n            \"Gprime_0\": 0.49686,\n            \"eta_s_0\": 2.75988,\n            \"n\": 3.0,\n            \"Z\": 16.0,\n            \"molar_mass\": 0.060085,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Cristobalite\",\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -852539.43,\n            \"V_0\": 2.72397e-05,\n            \"K_0\": 11500000000.0,\n            \"Kprime_0\": 9.0,\n            \"Debye_0\": 794.74452,\n            \"grueneisen_0\": 0.01515,\n            \"q_0\": 1.0,\n            \"G_0\": 20327540000.0,\n            \"Gprime_0\": 4.06551,\n            \"eta_s_0\": 1.17003,\n            \"n\": 3.0,\n            \"Z\": 16.0,\n            \"molar_mass\": 0.060085,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Diopside\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3029608.3800000004,\n            \"V_0\": 6.6039e-05,\n            \"K_0\": 113759900000.0,\n            \"Kprime_0\": 4.8061,\n            \"Debye_0\": 782.57306,\n            \"grueneisen_0\": 1.00921,\n            \"q_0\": 0.60142,\n            \"G_0\": 72700000000.0,\n            \"Gprime_0\": 1.71384,\n            \"eta_s_0\": 1.06175,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2165504,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Enstatite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2914163.5999999996,\n            \"V_0\": 6.2676e-05,\n            \"K_0\": 107076810000.0,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 812.21227,\n            \"grueneisen_0\": 0.78477,\n            \"q_0\": 3.43847,\n            \"G_0\": 76800000000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 2.5045,\n            \"n\": 10.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.2007774,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fayalite\",\n            \"formula\": {\"Fe\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1371695.6600000001,\n            \"V_0\": 4.629e-05,\n            \"K_0\": 136485580000.0,\n            \"Kprime_0\": 4.88157,\n            \"Debye_0\": 618.96116,\n            \"grueneisen_0\": 1.08388,\n            \"q_0\": 2.88055,\n            \"G_0\": 51220000000.0,\n            \"Gprime_0\": 0.85893,\n            \"eta_s_0\": 1.65937,\n            \"n\": 7.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.203777,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 65.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"FeAlO3-Perovskite_HS\",\n            \"formula\": {\"Fe\": 1.0, \"Al\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -848315.02,\n            \"V_0\": 2.72604e-05,\n            \"K_0\": 223325500000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 755.38117,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 150042090000.0,\n            \"Gprime_0\": 1.73259,\n            \"eta_s_0\": 2.55505,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.1308249,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 10.0, \"S_D\": 14.89723, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"HP-Clinoferrosilite\",\n            \"formula\": {\"Fe\": 2.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2224211.0,\n            \"V_0\": 6.38541e-05,\n            \"K_0\": 116024900000.0,\n            \"Kprime_0\": 6.23682,\n            \"Debye_0\": 698.72086,\n            \"grueneisen_0\": 1.12442,\n            \"q_0\": 0.20362,\n            \"G_0\": 75147210000.0,\n            \"Gprime_0\": 1.8412,\n            \"eta_s_0\": 0.98031,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2638614,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Ca-Ferrite\",\n            \"formula\": {\"Fe\": 1.0, \"Al\": 2.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1774197.05,\n            \"V_0\": 3.7216e-05,\n            \"K_0\": 213000000000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 734.07527,\n            \"grueneisen_0\": 1.56672,\n            \"q_0\": 1.0,\n            \"G_0\": 159709650000.0,\n            \"Gprime_0\": 1.93591,\n            \"eta_s_0\": 2.34163,\n            \"n\": 7.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.173806,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 13.38135, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Akimotoite\",\n            \"formula\": {\"Fe\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1047531.34,\n            \"V_0\": 2.6854e-05,\n            \"K_0\": 210693870000.0,\n            \"Kprime_0\": 5.2154,\n            \"Debye_0\": 781.36175,\n            \"grueneisen_0\": 1.19458,\n            \"q_0\": 2.2246,\n            \"G_0\": 160833570000.0,\n            \"Gprime_0\": 1.81492,\n            \"eta_s_0\": 3.43813,\n            \"n\": 5.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.131931,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 13.38135, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Perovskite\",\n            \"formula\": {\"Fe\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1002662.5299999999,\n            \"V_0\": 2.5321e-05,\n            \"K_0\": 270582550000.00003,\n            \"Kprime_0\": 4.01,\n            \"Debye_0\": 746.56455,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 130020980000.00002,\n            \"Gprime_0\": 1.37254,\n            \"eta_s_0\": 2.0941,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.131931,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 13.38135, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Ringwoodite\",\n            \"formula\": {\"Fe\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1359229.67,\n            \"V_0\": 4.186e-05,\n            \"K_0\": 213410280000.0,\n            \"Kprime_0\": 4.22034,\n            \"Debye_0\": 662.84304,\n            \"grueneisen_0\": 1.26584,\n            \"q_0\": 2.39042,\n            \"G_0\": 92000000000.0,\n            \"Gprime_0\": 1.35412,\n            \"eta_s_0\": 1.77066,\n            \"n\": 7.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.203777,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Wadsleyite\",\n            \"formula\": {\"Fe\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1358363.34,\n            \"V_0\": 4.28e-05,\n            \"K_0\": 168579210000.0,\n            \"Kprime_0\": 4.12303,\n            \"Debye_0\": 647.34559,\n            \"grueneisen_0\": 1.20388,\n            \"q_0\": 2.21007,\n            \"G_0\": 72000000000.0,\n            \"Gprime_0\": 1.50973,\n            \"eta_s_0\": 0.95246,\n            \"n\": 7.0,\n            \"Z\": 8.0,\n            \"molar_mass\": 0.203777,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fe-Perovskite_Low_Spin\",\n            \"formula\": {\"Fe\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -879526.2000000001,\n            \"V_0\": 2.497e-05,\n            \"K_0\": 270582550000.00003,\n            \"Kprime_0\": 4.01,\n            \"Debye_0\": 692.38659,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 130337050000.0,\n            \"Gprime_0\": 1.37411,\n            \"eta_s_0\": 1.99344,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.131931,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fe-NAL_Phase\",\n            \"formula\": {\"Na\": 1.0, \"Fe\": 2.0, \"Al\": 5.0, \"Si\": 1.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5475295.42,\n            \"V_0\": 0.000112045,\n            \"K_0\": 203995010000.0,\n            \"Kprime_0\": 4.31884,\n            \"Debye_0\": 795.29328,\n            \"grueneisen_0\": 1.42971,\n            \"q_0\": 1.0,\n            \"G_0\": 149593770000.0,\n            \"Gprime_0\": 1.7423,\n            \"eta_s_0\": 2.65939,\n            \"n\": 21.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.48966601,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Forsterite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2055371.19,\n            \"V_0\": 4.3603e-05,\n            \"K_0\": 127955500000.0,\n            \"Kprime_0\": 4.21796,\n            \"Debye_0\": 809.1977,\n            \"grueneisen_0\": 0.9928,\n            \"q_0\": 2.10671,\n            \"G_0\": 81600000000.0,\n            \"Gprime_0\": 1.46257,\n            \"eta_s_0\": 2.29968,\n            \"n\": 7.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.140695,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fe-PostPerovskite\",\n            \"formula\": {\"Fe\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -982035.5,\n            \"V_0\": 2.46519e-05,\n            \"K_0\": 292000000000.0,\n            \"Kprime_0\": 3.74,\n            \"Debye_0\": 794.15823,\n            \"grueneisen_0\": 1.76958,\n            \"q_0\": 2.04631,\n            \"G_0\": 129500000000.0,\n            \"Gprime_0\": 1.31526,\n            \"eta_s_0\": 1.72601,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.131931,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 13.38135, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Ferrosilite\",\n            \"formula\": {\"Fe\": 2.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2228327.6999999997,\n            \"V_0\": 6.5941e-05,\n            \"K_0\": 100545910000.0,\n            \"Kprime_0\": 7.87534,\n            \"Debye_0\": 682.67865,\n            \"grueneisen_0\": 0.71519,\n            \"q_0\": 3.43847,\n            \"G_0\": 52000000000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 1.08309,\n            \"n\": 10.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.2638614,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 26.7627, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Grossular\",\n            \"formula\": {\"Ca\": 3.0, \"Al\": 2.0, \"Si\": 3.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -6275179.81,\n            \"V_0\": 0.00012512,\n            \"K_0\": 167062260000.0,\n            \"Kprime_0\": 3.91544,\n            \"Debye_0\": 822.77062,\n            \"grueneisen_0\": 1.05402,\n            \"q_0\": 1.88886,\n            \"G_0\": 109000000000.0,\n            \"Gprime_0\": 1.16274,\n            \"eta_s_0\": 2.38415,\n            \"n\": 20.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.450449,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Hercynite\",\n            \"formula\": {\"Fe\": 4.0, \"Al\": 8.0, \"O\": 16.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -7356185.029999999,\n            \"V_0\": 0.000163372,\n            \"K_0\": 208982310000.0,\n            \"Kprime_0\": 4.62659,\n            \"Debye_0\": 794.21184,\n            \"grueneisen_0\": 1.19332,\n            \"q_0\": 4.05077,\n            \"G_0\": 84500000000.0,\n            \"Gprime_0\": 0.62792,\n            \"eta_s_0\": 2.49369,\n            \"n\": 28.0,\n            \"Z\": 8.0,\n            \"molar_mass\": 0.69524,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 53.5254, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Hedenbergite\",\n            \"formula\": {\"Ca\": 1.0, \"Fe\": 1.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2676991.78,\n            \"V_0\": 6.7867e-05,\n            \"K_0\": 119204720000.0,\n            \"Kprime_0\": 4.81927,\n            \"Debye_0\": 702.08234,\n            \"grueneisen_0\": 0.96665,\n            \"q_0\": 0.60142,\n            \"G_0\": 61000000000.0,\n            \"Gprime_0\": 1.71384,\n            \"eta_s_0\": 1.01745,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2480924,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 5.0, \"S_D\": 13.38135, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Hematite\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -744041.62,\n            \"V_0\": 3.0287e-05,\n            \"K_0\": 204245330000.0,\n            \"Kprime_0\": 4.0997,\n            \"Debye_0\": 653.80768,\n            \"grueneisen_0\": 1.58945,\n            \"q_0\": 2.2246,\n            \"G_0\": 91000000000.0,\n            \"Gprime_0\": 1.81492,\n            \"eta_s_0\": 0.52408,\n            \"n\": 5.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.15968852,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 950.01, \"S_D\": 29.79445, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fe2O3-Perovskite_HS\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -721269.05,\n            \"V_0\": 3.08668e-05,\n            \"K_0\": 135000000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 613.90405,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 88766580000.0,\n            \"Gprime_0\": 1.73259,\n            \"eta_s_0\": 0.66524,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.15968852,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 10.0, \"S_D\": 29.79445, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Fe2O3-Perovskite_LS\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -617631.95,\n            \"V_0\": 2.75209e-05,\n            \"K_0\": 204251000000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 725.62214,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 163996000000.0,\n            \"Gprime_0\": 1.73259,\n            \"eta_s_0\": 3.0318,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.15968852,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 10.0, \"S_D\": 20.66026, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"High-Pressure_Magnetit\",\n            \"formula\": {\"Fe\": 3.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -964475.2200000001,\n            \"V_0\": 4.1702e-05,\n            \"K_0\": 172000000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 533.17958,\n            \"grueneisen_0\": 1.56672,\n            \"q_0\": 1.0,\n            \"G_0\": 108730730000.0,\n            \"Gprime_0\": 1.93591,\n            \"eta_s_0\": 0.90477,\n            \"n\": 7.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.23153307,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 845.5, \"S_D\": 43.1758, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"HS_Fe2O3-Post-Perovski\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -622376.42,\n            \"V_0\": 2.76884e-05,\n            \"K_0\": 176500000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 688.0644,\n            \"grueneisen_0\": 1.76958,\n            \"q_0\": 2.04631,\n            \"G_0\": 159009520000.0,\n            \"Gprime_0\": 1.85188,\n            \"eta_s_0\": 2.00124,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.15968852,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 10.0, \"S_D\": 29.79445, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Jadeite\",\n            \"formula\": {\"Na\": 1.0, \"Al\": 1.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2855195.56,\n            \"V_0\": 6.0508e-05,\n            \"K_0\": 142292260000.0,\n            \"Kprime_0\": 4.8061,\n            \"Debye_0\": 820.78389,\n            \"grueneisen_0\": 0.89983,\n            \"q_0\": 0.78628,\n            \"G_0\": 85000000000.0,\n            \"Gprime_0\": 1.71384,\n            \"eta_s_0\": 1.88167,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2021387,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Kyanite\",\n            \"formula\": {\"Al\": 2.0, \"Si\": 1.0, \"O\": 5.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2446081.74,\n            \"V_0\": 4.4227e-05,\n            \"K_0\": 160000000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 943.19593,\n            \"grueneisen_0\": 0.92549,\n            \"q_0\": 1.0,\n            \"G_0\": 117854530000.0,\n            \"Gprime_0\": 1.69416,\n            \"eta_s_0\": 2.90375,\n            \"n\": 8.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.1620456,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"LS_Fe2O3-Post-Perovski\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -407182.57,\n            \"V_0\": 2.62534e-05,\n            \"K_0\": 176500000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 720.85819,\n            \"grueneisen_0\": 1.76958,\n            \"q_0\": 2.04631,\n            \"G_0\": 207396350000.0,\n            \"Gprime_0\": 1.85188,\n            \"eta_s_0\": 3.23888,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.15968852,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 10.0, \"S_D\": 20.66026, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Magnetite\",\n            \"formula\": {\"Fe\": 3.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -987192.39,\n            \"V_0\": 4.4528e-05,\n            \"K_0\": 183965710000.0,\n            \"Kprime_0\": 5.24573,\n            \"Debye_0\": 520.10184,\n            \"grueneisen_0\": 1.32115,\n            \"q_0\": 1.5487,\n            \"G_0\": 60300000000.0,\n            \"Gprime_0\": -0.05466,\n            \"eta_s_0\": 2.43429,\n            \"n\": 7.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.23153307,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 845.5, \"S_D\": 43.1758, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"HP-Clinoenstatite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2905475.75,\n            \"V_0\": 6.076e-05,\n            \"K_0\": 116024900000.0,\n            \"Kprime_0\": 6.23682,\n            \"Debye_0\": 822.89602,\n            \"grueneisen_0\": 1.12442,\n            \"q_0\": 0.20362,\n            \"G_0\": 87927160000.0,\n            \"Gprime_0\": 1.8412,\n            \"eta_s_0\": 2.14112,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2007774,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Ca-Ferrite\",\n            \"formula\": {\"Mg\": 1.0, \"Al\": 2.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2122873.69,\n            \"V_0\": 3.6135e-05,\n            \"K_0\": 213000000000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 831.14221,\n            \"grueneisen_0\": 1.56672,\n            \"q_0\": 1.0,\n            \"G_0\": 129699999999.99998,\n            \"Gprime_0\": 1.93591,\n            \"eta_s_0\": 1.30302,\n            \"n\": 7.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.142266,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Akimotoite\",\n            \"formula\": {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1409831.95,\n            \"V_0\": 2.6354e-05,\n            \"K_0\": 210693870000.0,\n            \"Kprime_0\": 5.2154,\n            \"Debye_0\": 932.602,\n            \"grueneisen_0\": 1.19458,\n            \"q_0\": 2.2246,\n            \"G_0\": 132000000000.0,\n            \"Gprime_0\": 1.81492,\n            \"eta_s_0\": 3.40174,\n            \"n\": 5.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.100389,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Majorite\",\n            \"formula\": {\"Mg\": 4.0, \"Si\": 4.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5693291.79,\n            \"V_0\": 0.000114324,\n            \"K_0\": 165118370000.0,\n            \"Kprime_0\": 4.21183,\n            \"Debye_0\": 822.48562,\n            \"grueneisen_0\": 0.97681,\n            \"q_0\": 1.53581,\n            \"G_0\": 85000000000.0,\n            \"Gprime_0\": 1.42969,\n            \"eta_s_0\": 1.01779,\n            \"n\": 20.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.40156,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Perovskite\",\n            \"formula\": {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1362442.75,\n            \"V_0\": 2.4445e-05,\n            \"K_0\": 250546900000.0,\n            \"Kprime_0\": 4.13499,\n            \"Debye_0\": 880.01895,\n            \"grueneisen_0\": 1.54222,\n            \"q_0\": 0.84088,\n            \"G_0\": 172900000000.0,\n            \"Gprime_0\": 1.73259,\n            \"eta_s_0\": 1.65573,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.100389,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Ringwoodite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2017223.98,\n            \"V_0\": 3.9493e-05,\n            \"K_0\": 184899930000.0,\n            \"Kprime_0\": 4.22034,\n            \"Debye_0\": 875.13511,\n            \"grueneisen_0\": 1.1072,\n            \"q_0\": 2.39042,\n            \"G_0\": 123000000000.0,\n            \"Gprime_0\": 1.35412,\n            \"eta_s_0\": 2.30288,\n            \"n\": 7.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.140693,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Tschermak's\",\n            \"formula\": {\"Mg\": 1.0, \"Al\": 2.0, \"Si\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3002410.17,\n            \"V_0\": 5.914e-05,\n            \"K_0\": 107076810000.0,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 783.94073,\n            \"grueneisen_0\": 0.78477,\n            \"q_0\": 3.43847,\n            \"G_0\": 93471460000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 2.39416,\n            \"n\": 10.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.20235,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Mg-Wadsleyite\",\n            \"formula\": {\"Mg\": 2.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2028172.68,\n            \"V_0\": 4.0515e-05,\n            \"K_0\": 168701060000.0,\n            \"Kprime_0\": 4.12303,\n            \"Debye_0\": 845.20132,\n            \"grueneisen_0\": 1.20388,\n            \"q_0\": 2.21007,\n            \"G_0\": 112000000000.0,\n            \"Gprime_0\": 1.50973,\n            \"eta_s_0\": 2.56133,\n            \"n\": 7.0,\n            \"Z\": 8.0,\n            \"molar_mass\": 0.140695,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Mg-NAL_Phase\",\n            \"formula\": {\"Na\": 1.0, \"Mg\": 2.0, \"Al\": 5.0, \"Si\": 1.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -6167391.6,\n            \"V_0\": 0.000109883,\n            \"K_0\": 203995010000.0,\n            \"Kprime_0\": 4.31884,\n            \"Debye_0\": 858.38264,\n            \"grueneisen_0\": 1.42971,\n            \"q_0\": 1.0,\n            \"G_0\": 129000000000.0,\n            \"Gprime_0\": 1.7423,\n            \"eta_s_0\": 1.93069,\n            \"n\": 21.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.42658581,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Mg-PostPerovskite\",\n            \"formula\": {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1313625.76,\n            \"V_0\": 2.35252e-05,\n            \"K_0\": 292000000000.0,\n            \"Kprime_0\": 3.74,\n            \"Debye_0\": 941.49795,\n            \"grueneisen_0\": 1.76958,\n            \"q_0\": 2.04631,\n            \"G_0\": 171135870000.0,\n            \"Gprime_0\": 1.85188,\n            \"eta_s_0\": 1.2881,\n            \"n\": 5.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.100389,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Na-Ca-Ferrite\",\n            \"formula\": {\"Na\": 1.0, \"Al\": 1.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1835429.51,\n            \"V_0\": 3.627e-05,\n            \"K_0\": 220000000000.0,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 683.31827,\n            \"grueneisen_0\": 1.56672,\n            \"q_0\": 1.0,\n            \"G_0\": 135326619999.99998,\n            \"Gprime_0\": 1.93591,\n            \"eta_s_0\": 1.36827,\n            \"n\": 7.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.142054,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Na-Majorite\",\n            \"formula\": {\"Na\": 2.0, \"Mg\": 1.0, \"Si\": 5.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5303066.24,\n            \"V_0\": 0.000110842,\n            \"K_0\": 172035150000.0,\n            \"Kprime_0\": 5.2005,\n            \"Debye_0\": 844.73722,\n            \"grueneisen_0\": 1.25078,\n            \"q_0\": 0.10916,\n            \"G_0\": 114700000000.0,\n            \"Gprime_0\": 1.35756,\n            \"eta_s_0\": 2.4849,\n            \"n\": 20.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.40270437,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Nepheline\",\n            \"formula\": {\"Na\": 1.0, \"Al\": 1.0, \"Si\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1994469.57,\n            \"V_0\": 5.38684e-05,\n            \"K_0\": 53055500000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 743.57985,\n            \"grueneisen_0\": 0.6969,\n            \"q_0\": 1.0,\n            \"G_0\": 30700000000.0,\n            \"Gprime_0\": 1.33087,\n            \"eta_s_0\": 0.6241,\n            \"n\": 7.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.14205431,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 467.0, \"S_D\": 10.0, \"V_D\": 0.8}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Na-NAL_Phase\",\n            \"formula\": {\"Na\": 3.0, \"Al\": 3.0, \"Si\": 3.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5567127.9,\n            \"V_0\": 0.000109401,\n            \"K_0\": 203995010000.0,\n            \"Kprime_0\": 4.31884,\n            \"Debye_0\": 850.32833,\n            \"grueneisen_0\": 1.42971,\n            \"q_0\": 1.0,\n            \"G_0\": 144451020000.0,\n            \"Gprime_0\": 1.7423,\n            \"eta_s_0\": 2.42502,\n            \"n\": 21.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.42616294,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Ortho-Diopside\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"Si\": 2.0, \"O\": 6.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3015734.13,\n            \"V_0\": 6.8054e-05,\n            \"K_0\": 107076810000.0,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 744.54893,\n            \"grueneisen_0\": 0.78477,\n            \"q_0\": 3.43847,\n            \"G_0\": 57508750000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 1.31909,\n            \"n\": 10.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.2165504,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Periclase\",\n            \"formula\": {\"Mg\": 4.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2278109.88,\n            \"V_0\": 4.4976e-05,\n            \"K_0\": 161143930000.0,\n            \"Kprime_0\": 3.90838,\n            \"Debye_0\": 770.90151,\n            \"grueneisen_0\": 1.45033,\n            \"q_0\": 1.5487,\n            \"G_0\": 130900000000.0,\n            \"Gprime_0\": 2.14668,\n            \"eta_s_0\": 2.56123,\n            \"n\": 8.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.16121782,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Pyrope\",\n            \"formula\": {\"Mg\": 3.0, \"Al\": 2.0, \"Si\": 3.0, \"O\": 12.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5937137.35,\n            \"V_0\": 0.00011308,\n            \"K_0\": 170239640000.0,\n            \"Kprime_0\": 4.11067,\n            \"Debye_0\": 823.23783,\n            \"grueneisen_0\": 1.01422,\n            \"q_0\": 1.42169,\n            \"G_0\": 93700000000.0,\n            \"Gprime_0\": 1.35756,\n            \"eta_s_0\": 0.98186,\n            \"n\": 20.0,\n            \"Z\": 4.0,\n            \"molar_mass\": 0.40313,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Quartz\",\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -860118.03,\n            \"V_0\": 2.24211e-05,\n            \"K_0\": 61425370000.0,\n            \"Kprime_0\": 19.78011,\n            \"Debye_0\": 884.20481,\n            \"grueneisen_0\": -0.03958,\n            \"q_0\": 1.0,\n            \"G_0\": 44857760000.0,\n            \"Gprime_0\": -0.04277,\n            \"eta_s_0\": 2.40509,\n            \"n\": 3.0,\n            \"Z\": 16.0,\n            \"molar_mass\": 0.060085,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 847.0, \"S_D\": 5.76, \"V_D\": 1.35936}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Spinel\",\n            \"formula\": {\"Mg\": 4.0, \"Al\": 8.0, \"O\": 16.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -8680043.36,\n            \"V_0\": 0.000159048,\n            \"K_0\": 195139330000.0,\n            \"Kprime_0\": 4.62659,\n            \"Debye_0\": 856.3695,\n            \"grueneisen_0\": 0.97518,\n            \"q_0\": 4.05077,\n            \"G_0\": 109000000000.0,\n            \"Gprime_0\": 0.62792,\n            \"eta_s_0\": 2.44263,\n            \"n\": 28.0,\n            \"Z\": 8.0,\n            \"molar_mass\": 0.569068,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Stishovite\",\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -817491.62,\n            \"V_0\": 1.4017e-05,\n            \"K_0\": 305833020000.0,\n            \"Kprime_0\": 4.0292,\n            \"Debye_0\": 1092.17047,\n            \"grueneisen_0\": 1.55674,\n            \"q_0\": 2.2096,\n            \"G_0\": 228000000000.0,\n            \"Gprime_0\": 1.94045,\n            \"eta_s_0\": 4.40394,\n            \"n\": 3.0,\n            \"Z\": 2.0,\n            \"molar_mass\": 0.060085,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": -4250.0, \"S_D\": 4e-05, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": 'W\\\\\"ustite',\n            \"formula\": {\"Fe\": 4.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -974607.49,\n            \"V_0\": 4.9024e-05,\n            \"K_0\": 160700000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 454.1752,\n            \"grueneisen_0\": 1.45033,\n            \"q_0\": 1.5487,\n            \"G_0\": 59000000000.0,\n            \"Gprime_0\": 1.44764,\n            \"eta_s_0\": 0.06776,\n            \"n\": 8.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.28737822,\n        }\n\n        self.property_modifiers = [\n            [\"landau_slb_2022\", {\"Tc_0\": 191.0, \"S_D\": 53.5254, \"V_D\": 0.0}]\n        ]\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": 'W\\\\\"ustite_Low_Spin',\n            \"formula\": {\"Fe\": 4.0, \"O\": 4.0},\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -621968.16,\n            \"V_0\": 4.33997e-05,\n            \"K_0\": 199700000000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 524.57881,\n            \"grueneisen_0\": 1.45033,\n            \"q_0\": 1.5487,\n            \"G_0\": 59000000000.0,\n            \"Gprime_0\": 1.44073,\n            \"eta_s_0\": -0.13801,\n            \"n\": 8.0,\n            \"Z\": 1.0,\n            \"molar_mass\": 0.28737822,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"c2c_pyroxene\"\n        self.solution_model = IdealSolution(\n            endmembers=[\n                [mgc2(), \"[Mg]2\"],\n                [fec2(), \"[Fe]2\"],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"calcium_ferrite_structured_phase\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [mgcf(), \"[Mg][Al]\"],\n                [fecf(), \"[Fe][Al]\"],\n                [nacf(), \"[Na][Si]\"],\n            ],\n            alphas=[1.0, 1.0, 4.4532],\n            energy_interaction=[[0.0, 60825.08], [60825.08]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"clinopyroxene\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [di(), \"[Ca][Mg][Si]2\"],\n                [he(), \"[Ca][Fe][Si]2\"],\n                [cen(), \"[Mg][Mg][Si]2\"],\n                [cats(), \"[Ca][Al][Si1/2Al1/2]2\"],\n                [jd(), \"[Na][Al][Si]2\"],\n            ],\n            alphas=[1.0, 1.0, 1.0, 3.5, 1.0],\n            energy_interaction=[\n                [0.0, 24740.0, 26000.0, 24300.0],\n                [24740.0, 26000.0, 24300.0],\n                [60132.81, 46046.07],\n                [10000.0],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"garnet\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [py(), \"[Mg]3[Al][Al]\"],\n                [al(), \"[Fe]3[Al][Al]\"],\n                [gr(), \"[Ca]3[Al][Al]\"],\n                [mgmj(), \"[Mg]3[Mg][Si]\"],\n                [namj(), \"[Na2/3Mg1/3]3[Si][Si]\"],\n            ],\n            energy_interaction=[\n                [0.0, 21117.58, 22672.42, 22672.42],\n                [21117.58, 22672.42, 22672.42],\n                [60718.2, 60718.2],\n                [70879.14],\n            ],\n            volume_interaction=[\n                [0.0, 1.03e-06, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [1.03e-06, 0.0],\n                [0.0],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"ilmenite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mgil(), \"[Mg][Si]\"],\n                [feil(), \"[Fe][Si]\"],\n                [co(), \"[Al][Al]\"],\n            ],\n            energy_interaction=[[0.0, 59348.69], [59348.69]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"ferropericlase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [pe(), \"[Mg]2[Mg]2\"],\n                [wu(), \"[Fe]2[Fe]2\"],\n                [anao(), \"[Na]2[Al]2\"],\n            ],\n            energy_interaction=[[44000.0, 120000.0], [120000.0]],\n            volume_interaction=[[4.4e-07, 0.0], [0.0]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"new_aluminous_phase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mnal(), \"[Mg]2[Al5/6Si1/6]6\"],\n                [fnal(), \"[Fe]2[Al5/6Si1/6]6\"],\n                [nnal(), \"[Na]2[Al3/6Si3/6]6\"],\n            ],\n            energy_interaction=[[0.0, -60781.47], [-60781.47]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"olivine\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [fo(), \"[Mg]2\"],\n                [fa(), \"[Fe]2\"],\n            ],\n            energy_interaction=[[4694.66]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [en(), \"[Mg][Mg]\"],\n                [fs(), \"[Fe][Fe]\"],\n                [mgts(), \"[Mg][Al]\"],\n                [odi(), \"[Ca][Mg]\"],\n            ],\n            energy_interaction=[[0.0, 0.0, 32217.44], [0.0, 32217.44], [48370.41]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"plagioclase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [an(), \"[Ca]\"],\n                [ab(), \"[Na]\"],\n            ],\n            energy_interaction=[[13000.0]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"post_perovskite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mppv(), \"[Mg][Si]\"],\n                [fppv(), \"[Fe][Si]\"],\n                [appv(), \"[Al][Al]\"],\n            ],\n            energy_interaction=[[-10955.49, 34979.87], [34979.87]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"bridgmanite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mgpv(), \"[Mg][Si]\"],\n                [fepv(), \"[Fe][Si]\"],\n                [alpv(), \"[Al][Al]\"],\n            ],\n            energy_interaction=[[-11396.17, 34979.87], [0.0]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"ringwoodite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mgri(), \"[Mg]2\"],\n                [feri(), \"[Fe]2\"],\n            ],\n            energy_interaction=[[7600.74]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"mg_fe_aluminous_spinel\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [sp(), \"[Mg3/4Al1/4]4[Al7/8Mg1/8]8\"],\n                [hc(), \"[Fe3/4Al1/4]4[Al7/8Fe1/8]8\"],\n            ],\n            energy_interaction=[[-533.21]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"wadsleyite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mgwa(), \"[Mg]2\"],\n                [fewa(), \"[Fe]2\"],\n            ],\n            energy_interaction=[[13202.38]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class stishovite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 14.02e-6,\n            \"K_0\": 314.0e9,\n            \"Kprime_0\": 4.4,\n            \"G_0\": 220.0e9,\n            \"Gprime_0\": 1.6,\n            \"molar_mass\": 0.0601,\n            \"n\": 3,\n            \"Debye_0\": 1044.0,\n            \"grueneisen_0\": 1.34,\n            \"q_0\": 2.4,\n            \"eta_s_0\": 5.0,\n        }\n\n        Mineral.__init__(self)",
  "class periclase(Mineral):\n    def __init__(self):\n        self.params = {\n            \"formula\": {\"Mg\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 11.24e-6,\n            \"K_0\": 161.0e9,\n            \"Kprime_0\": 3.8,\n            \"G_0\": 131.0e9,\n            \"Gprime_0\": 2.1,\n            \"molar_mass\": 0.0403,\n            \"n\": 2,\n            \"Debye_0\": 773.0,\n            \"grueneisen_0\": 1.5,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.8,\n        }\n        Mineral.__init__(self)",
  "class wuestite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 1.0},\n            \"V_0\": 12.06e-6,\n            \"K_0\": 152.0e9,\n            \"Kprime_0\": 4.9,\n            \"G_0\": 47.0e9,\n            \"Gprime_0\": 0.7,\n            \"molar_mass\": 0.0718,\n            \"n\": 2,\n            \"Debye_0\": 455.0,\n            \"grueneisen_0\": 1.28,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 0.8,\n        }\n\n        Mineral.__init__(self)",
  "class mg_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"formula\": {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 24.45e-6,\n            \"K_0\": 251.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 175.0e9,\n            \"Gprime_0\": 1.7,\n            \"molar_mass\": 0.1000,\n            \"n\": 5,\n            \"Debye_0\": 1070.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.6,\n        }\n\n        Mineral.__init__(self)",
  "class fe_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"formula\": {\"Fe\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 25.48e-6,\n            \"K_0\": 281.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 138.0e9,\n            \"Gprime_0\": 1.7,\n            \"molar_mass\": 0.1319,\n            \"n\": 5,\n            \"Debye_0\": 841.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.1,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"formula\": {\"Si\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 14.02e-6,\n            \"K_0\": 314.0e9,\n            \"Kprime_0\": 4.4,\n            \"G_0\": 220.0e9,\n            \"Gprime_0\": 1.6,\n            \"molar_mass\": 0.0601,\n            \"n\": 3,\n            \"Debye_0\": 1044.0,\n            \"grueneisen_0\": 1.34,\n            \"q_0\": 2.4,\n            \"eta_s_0\": 5.0,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"formula\": {\"Mg\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 11.24e-6,\n            \"K_0\": 161.0e9,\n            \"Kprime_0\": 3.8,\n            \"G_0\": 131.0e9,\n            \"Gprime_0\": 2.1,\n            \"molar_mass\": 0.0403,\n            \"n\": 2,\n            \"Debye_0\": 773.0,\n            \"grueneisen_0\": 1.5,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.8,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 1.0},\n            \"V_0\": 12.06e-6,\n            \"K_0\": 152.0e9,\n            \"Kprime_0\": 4.9,\n            \"G_0\": 47.0e9,\n            \"Gprime_0\": 0.7,\n            \"molar_mass\": 0.0718,\n            \"n\": 2,\n            \"Debye_0\": 455.0,\n            \"grueneisen_0\": 1.28,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 0.8,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"formula\": {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 24.45e-6,\n            \"K_0\": 251.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 175.0e9,\n            \"Gprime_0\": 1.7,\n            \"molar_mass\": 0.1000,\n            \"n\": 5,\n            \"Debye_0\": 1070.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.6,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"formula\": {\"Fe\": 1.0, \"Si\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 25.48e-6,\n            \"K_0\": 281.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 138.0e9,\n            \"Gprime_0\": 1.7,\n            \"molar_mass\": 0.1319,\n            \"n\": 5,\n            \"Debye_0\": 841.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.1,\n        }\n\n        Mineral.__init__(self)",
  "class mg_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 24.43e-6,\n            \"K_0\": 250.0e9,\n            \"Kprime_0\": 4.0,\n            \"G_0\": 175.0e9,\n            \"Gprime_0\": 1.8,\n            \"molar_mass\": 0.1020,\n            \"n\": 5,\n            \"Debye_0\": 1070.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n        }\n\n        Mineral.__init__(self)",
  "class fe_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 25.34e-6,\n            \"K_0\": 250.0e9,\n            \"Kprime_0\": 4.0,\n            \"G_0\": 135.0e9,\n            \"Gprime_0\": 1.3,\n            \"molar_mass\": 0.1319,\n            \"n\": 5,\n            \"Debye_0\": 841.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n        }\n\n        Mineral.__init__(self)",
  "class al_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 24.58e-6,\n            \"K_0\": 249.0e9,\n            \"Kprime_0\": 4.0,\n            \"G_0\": 165.0e9,\n            \"Gprime_0\": 1.8,\n            \"molar_mass\": 0.1005,\n            \"n\": 5,\n            \"Debye_0\": 1021.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n        }\n\n        Mineral.__init__(self)",
  "class ca_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 27.45e-6,\n            \"K_0\": 236.0e9,\n            \"Kprime_0\": 3.9,\n            \"G_0\": 165.0e9,\n            \"Gprime_0\": 2.46,\n            \"molar_mass\": 0.11616,\n            \"n\": 5,\n            \"Debye_0\": 984.0,\n            \"grueneisen_0\": 1.53,\n            \"q_0\": 1.6,\n        }\n\n        Mineral.__init__(self)",
  "class periclase(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 11.25e-6,\n            \"K_0\": 160.1e9,\n            \"Kprime_0\": 3.83,\n            \"G_0\": 130.0e9,\n            \"Gprime_0\": 2.2,\n            \"molar_mass\": 0.0403,\n            \"n\": 2,\n            \"Debye_0\": 673.0,\n            \"grueneisen_0\": 1.41,\n            \"q_0\": 1.3,\n        }\n\n        Mineral.__init__(self)",
  "class wuestite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 12.26e-6,\n            \"K_0\": 160.1e9,\n            \"Kprime_0\": 3.83,\n            \"G_0\": 46.0e9,\n            \"Gprime_0\": 0.6,\n            \"molar_mass\": 0.0718,\n            \"n\": 2,\n            \"Debye_0\": 673.0,\n            \"grueneisen_0\": 1.41,\n            \"q_0\": 1.3,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 24.43e-6,\n            \"K_0\": 250.0e9,\n            \"Kprime_0\": 4.0,\n            \"G_0\": 175.0e9,\n            \"Gprime_0\": 1.8,\n            \"molar_mass\": 0.1020,\n            \"n\": 5,\n            \"Debye_0\": 1070.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 25.34e-6,\n            \"K_0\": 250.0e9,\n            \"Kprime_0\": 4.0,\n            \"G_0\": 135.0e9,\n            \"Gprime_0\": 1.3,\n            \"molar_mass\": 0.1319,\n            \"n\": 5,\n            \"Debye_0\": 841.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 24.58e-6,\n            \"K_0\": 249.0e9,\n            \"Kprime_0\": 4.0,\n            \"G_0\": 165.0e9,\n            \"Gprime_0\": 1.8,\n            \"molar_mass\": 0.1005,\n            \"n\": 5,\n            \"Debye_0\": 1021.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 27.45e-6,\n            \"K_0\": 236.0e9,\n            \"Kprime_0\": 3.9,\n            \"G_0\": 165.0e9,\n            \"Gprime_0\": 2.46,\n            \"molar_mass\": 0.11616,\n            \"n\": 5,\n            \"Debye_0\": 984.0,\n            \"grueneisen_0\": 1.53,\n            \"q_0\": 1.6,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 11.25e-6,\n            \"K_0\": 160.1e9,\n            \"Kprime_0\": 3.83,\n            \"G_0\": 130.0e9,\n            \"Gprime_0\": 2.2,\n            \"molar_mass\": 0.0403,\n            \"n\": 2,\n            \"Debye_0\": 673.0,\n            \"grueneisen_0\": 1.41,\n            \"q_0\": 1.3,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd2\",\n            \"V_0\": 12.26e-6,\n            \"K_0\": 160.1e9,\n            \"Kprime_0\": 3.83,\n            \"G_0\": 46.0e9,\n            \"Gprime_0\": 0.6,\n            \"molar_mass\": 0.0718,\n            \"n\": 2,\n            \"Debye_0\": 673.0,\n            \"grueneisen_0\": 1.41,\n            \"q_0\": 1.3,\n        }\n\n        Mineral.__init__(self)",
  "class liquid_iron(Mineral):\n    \"\"\"\n    Liquid iron equation of state from Anderson and Ahrens (1994)\n    \"\"\"\n\n    def __init__(self):\n        formula = \"Fe1.0\"\n        formula = dictionarize_formula(formula)\n        m = formula_mass(formula)\n        rho_0 = 7019.0\n        V_0 = m / rho_0\n        D = 7766.0\n        Lambda = 1146.0\n        self.params = {\n            \"name\": \"liquid iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"aa\",\n            \"P_0\": 1.0e5,\n            \"T_0\": 1811.0,\n            \"S_0\": 100.0,  # to fit\n            \"molar_mass\": m,\n            \"V_0\": V_0,\n            \"E_0\": 0.0,\n            \"K_S\": 109.7e9,\n            \"Kprime_S\": 4.661,\n            \"Kprime_prime_S\": -0.043e-9,\n            \"grueneisen_0\": 1.735,\n            \"grueneisen_prime\": -0.130 / m * 1.0e-6,\n            \"grueneisen_n\": -1.870,\n            \"a\": [248.92 * m, 289.48 * m],\n            \"b\": [0.4057 * m, -1.1499 * m],\n            \"Theta\": [1747.3, 1.537],\n            \"theta\": 5000.0,\n            \"lmda\": [-325.23 * m, 302.07 * m, 30.45 * m],\n            \"xi_0\": 282.67 * m,\n            \"F\": [D / rho_0, Lambda / rho_0],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": m,\n        }\n        Mineral.__init__(self)",
  "class ZSB_2013_mg_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 24.45e-6,\n            \"K_0\": 250.5e9,\n            \"Kprime_0\": 4.01,\n            \"G_0\": 172.9e9,\n            \"Gprime_0\": 1.74,\n            \"molar_mass\": 0.1000,\n            \"n\": 5,\n            \"Debye_0\": 905.9,\n            \"grueneisen_0\": 1.44,\n            \"q_0\": 1.09,\n            \"eta_s_0\": 2.13,\n        }  # 2.6\n\n        self.uncertainties = {\n            \"err_K_0\": 3.0e9,\n            \"err_Kprime_0\": 0.1,\n            \"err_G_0\": 2.0e9,\n            \"err_Gprime_0\": 0.0,\n            \"err_Debye_0\": 5.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.3,\n            \"err_eta_s_0\": 0.3,\n        }\n\n        Mineral.__init__(self)",
  "class ZSB_2013_fe_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 25.49e-6,\n            \"K_0\": 272.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 133.0e9,\n            \"Gprime_0\": 1.4,\n            \"molar_mass\": 0.1319,\n            \"n\": 5,\n            \"Debye_0\": 871.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"eta_s_0\": 2.3,\n        }  # 2.3\n\n        self.uncertainties = {\n            \"err_K_0\": 40e9,\n            \"err_Kprime_0\": 1.0,\n            \"err_G_0\": 40e9,\n            \"err_Gprime_0\": 0.0,\n            \"err_Debye_0\": 26.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_eta_s_0\": 1.0,\n        }\n\n        Mineral.__init__(self)",
  "class Speziale_fe_periclase(helpers.HelperSpinTransition):\n    def __init__(self):\n        helpers.HelperSpinTransition.__init__(\n            self, 60.0e9, Speziale_fe_periclase_LS(), Speziale_fe_periclase_HS()\n        )\n        self.cite = \"Speziale et al. 2007\"",
  "class Speziale_fe_periclase_HS(Mineral):\n\n    \"\"\"\n    Speziale et al. 2007, Mg#=83\n    \"\"\"\n\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd3\",\n            \"V_0\": 22.9e-6,\n            \"K_0\": 157.5e9,\n            \"Kprime_0\": 3.92,\n            \"molar_mass\": 0.04567,\n            \"n\": 2,\n            \"Debye_0\": 587,\n            \"grueneisen_0\": 1.46,\n            \"q_0\": 1.2,\n        }\n        Mineral.__init__(self)",
  "class Speziale_fe_periclase_LS(Mineral):\n\n    \"\"\"\n    Speziale et al. 2007, Mg#=83\n    \"\"\"\n\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd3\",\n            \"V_0\": 21.49e-6,\n            \"K_0\": 186.0e9,\n            \"Kprime_0\": 4.6,\n            \"molar_mass\": 0.04567,\n            \"n\": 2,\n            \"Debye_0\": 587.0,\n            \"grueneisen_0\": 1.46,\n            \"q_0\": 1.2,\n        }\n        Mineral.__init__(self)",
  "class Liquid_Fe_Anderson(Mineral):\n\n    \"\"\"\n    Anderson & Ahrens, 1994 JGR\n    \"\"\"\n\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"bm4\",\n            \"V_0\": 7.95626e-6,\n            \"K_0\": 109.7e9,\n            \"Kprime_0\": 4.66,\n            \"Kprime_prime_0\": -0.043e-9,\n            \"molar_mass\": 0.055845,\n        }\n        Mineral.__init__(self)",
  "class Fe_Dewaele(Mineral):\n\n    \"\"\"\n    Dewaele et al., 2006, Physical Review Letters\n    \"\"\"\n\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"vinet\",\n            \"V_0\": 6.75e-6,\n            \"K_0\": 163.4e9,\n            \"Kprime_0\": 5.38,\n            \"molar_mass\": 0.055845,\n            \"n\": 1,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe1.0\"\n        formula = dictionarize_formula(formula)\n        m = formula_mass(formula)\n        rho_0 = 7019.0\n        V_0 = m / rho_0\n        D = 7766.0\n        Lambda = 1146.0\n        self.params = {\n            \"name\": \"liquid iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"aa\",\n            \"P_0\": 1.0e5,\n            \"T_0\": 1811.0,\n            \"S_0\": 100.0,  # to fit\n            \"molar_mass\": m,\n            \"V_0\": V_0,\n            \"E_0\": 0.0,\n            \"K_S\": 109.7e9,\n            \"Kprime_S\": 4.661,\n            \"Kprime_prime_S\": -0.043e-9,\n            \"grueneisen_0\": 1.735,\n            \"grueneisen_prime\": -0.130 / m * 1.0e-6,\n            \"grueneisen_n\": -1.870,\n            \"a\": [248.92 * m, 289.48 * m],\n            \"b\": [0.4057 * m, -1.1499 * m],\n            \"Theta\": [1747.3, 1.537],\n            \"theta\": 5000.0,\n            \"lmda\": [-325.23 * m, 302.07 * m, 30.45 * m],\n            \"xi_0\": 282.67 * m,\n            \"F\": [D / rho_0, Lambda / rho_0],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": m,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 24.45e-6,\n            \"K_0\": 250.5e9,\n            \"Kprime_0\": 4.01,\n            \"G_0\": 172.9e9,\n            \"Gprime_0\": 1.74,\n            \"molar_mass\": 0.1000,\n            \"n\": 5,\n            \"Debye_0\": 905.9,\n            \"grueneisen_0\": 1.44,\n            \"q_0\": 1.09,\n            \"eta_s_0\": 2.13,\n        }  # 2.6\n\n        self.uncertainties = {\n            \"err_K_0\": 3.0e9,\n            \"err_Kprime_0\": 0.1,\n            \"err_G_0\": 2.0e9,\n            \"err_Gprime_0\": 0.0,\n            \"err_Debye_0\": 5.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.3,\n            \"err_eta_s_0\": 0.3,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 25.49e-6,\n            \"K_0\": 272.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 133.0e9,\n            \"Gprime_0\": 1.4,\n            \"molar_mass\": 0.1319,\n            \"n\": 5,\n            \"Debye_0\": 871.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"eta_s_0\": 2.3,\n        }  # 2.3\n\n        self.uncertainties = {\n            \"err_K_0\": 40e9,\n            \"err_Kprime_0\": 1.0,\n            \"err_G_0\": 40e9,\n            \"err_Gprime_0\": 0.0,\n            \"err_Debye_0\": 26.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_eta_s_0\": 1.0,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        helpers.HelperSpinTransition.__init__(\n            self, 60.0e9, Speziale_fe_periclase_LS(), Speziale_fe_periclase_HS()\n        )\n        self.cite = \"Speziale et al. 2007\"",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd3\",\n            \"V_0\": 22.9e-6,\n            \"K_0\": 157.5e9,\n            \"Kprime_0\": 3.92,\n            \"molar_mass\": 0.04567,\n            \"n\": 2,\n            \"Debye_0\": 587,\n            \"grueneisen_0\": 1.46,\n            \"q_0\": 1.2,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"mgd3\",\n            \"V_0\": 21.49e-6,\n            \"K_0\": 186.0e9,\n            \"Kprime_0\": 4.6,\n            \"molar_mass\": 0.04567,\n            \"n\": 2,\n            \"Debye_0\": 587.0,\n            \"grueneisen_0\": 1.46,\n            \"q_0\": 1.2,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"bm4\",\n            \"V_0\": 7.95626e-6,\n            \"K_0\": 109.7e9,\n            \"Kprime_0\": 4.66,\n            \"Kprime_prime_0\": -0.043e-9,\n            \"molar_mass\": 0.055845,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"vinet\",\n            \"V_0\": 6.75e-6,\n            \"K_0\": 163.4e9,\n            \"Kprime_0\": 5.38,\n            \"molar_mass\": 0.055845,\n            \"n\": 1,\n        }\n        Mineral.__init__(self)",
  "class CO2(Mineral):\n    def __init__(self):\n        formula = \"CO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"carbon dioxide\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 304.2,\n            \"cork_P\": 0.0738e8,\n            \"H_0\": -393.51e3,\n            \"S_0\": 213.7,\n            \"Cp\": [87.8, -2.644e-3, 706.4e3, -998.9],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "class CH4(Mineral):\n    def __init__(self):\n        formula = \"CH4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"methane\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 190.6,\n            \"cork_P\": 0.0460e8,\n            \"H_0\": -74.81e3,\n            \"S_0\": 186.26,\n            \"Cp\": [150.1, 0.002063, 3427700.0, -2650.4],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "class O2(Mineral):\n    def __init__(self):\n        formula = \"O2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"oxygen\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 0.0,\n            \"cork_P\": 1.0e5,\n            \"H_0\": 0.0,\n            \"S_0\": 205.2,\n            \"Cp\": [48.3, -0.000691, 499200.0, -420.7],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "class H2(Mineral):\n    def __init__(self):\n        formula = \"H2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"hydrogen\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 41.2,\n            \"cork_P\": 0.0211e8,\n            \"H_0\": 0.0,\n            \"S_0\": 130.7,\n            \"Cp\": [23.3, 0.004627, 0.0, 76.3],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "class S2(Mineral):\n    def __init__(self):\n        formula = \"S2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"sulfur\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 1314.00,\n            \"cork_P\": 0.21000e8,\n            \"H_0\": 128.54e3,\n            \"S_0\": 231.0,\n            \"Cp\": [37.1, 0.002398, -161000.0, -65.0],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "class H2S(Mineral):\n    def __init__(self):\n        formula = \"H2S\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"hydrogen sulfide\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 373.15,\n            \"cork_P\": 0.08937e8,\n            \"H_0\": 128.54e3,\n            \"S_0\": 231.0,\n            \"Cp\": [47.4, 0.010240, 615900.0, -397.8],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"carbon dioxide\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 304.2,\n            \"cork_P\": 0.0738e8,\n            \"H_0\": -393.51e3,\n            \"S_0\": 213.7,\n            \"Cp\": [87.8, -2.644e-3, 706.4e3, -998.9],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CH4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"methane\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 190.6,\n            \"cork_P\": 0.0460e8,\n            \"H_0\": -74.81e3,\n            \"S_0\": 186.26,\n            \"Cp\": [150.1, 0.002063, 3427700.0, -2650.4],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"O2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"oxygen\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 0.0,\n            \"cork_P\": 1.0e5,\n            \"H_0\": 0.0,\n            \"S_0\": 205.2,\n            \"Cp\": [48.3, -0.000691, 499200.0, -420.7],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"H2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"hydrogen\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 41.2,\n            \"cork_P\": 0.0211e8,\n            \"H_0\": 0.0,\n            \"S_0\": 130.7,\n            \"Cp\": [23.3, 0.004627, 0.0, 76.3],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"S2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"sulfur\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 1314.00,\n            \"cork_P\": 0.21000e8,\n            \"H_0\": 128.54e3,\n            \"S_0\": 231.0,\n            \"Cp\": [37.1, 0.002398, -161000.0, -65.0],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"H2S\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"hydrogen sulfide\",\n            \"formula\": formula,\n            \"equation_of_state\": \"cork\",\n            \"cork_params\": [\n                [5.45963e1, -8.63920e0],\n                [9.18301e-1],\n                [-3.30558e-2, 2.30524e-3],\n                [6.93054e-4, -8.38293e-5],\n            ],\n            \"cork_T\": 373.15,\n            \"cork_P\": 0.08937e8,\n            \"H_0\": 128.54e3,\n            \"S_0\": 231.0,\n            \"Cp\": [47.4, 0.010240, 615900.0, -397.8],\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "class c2c_pyroxene(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"C2/c pyroxene\"\n        self.solution_model = IdealSolution(\n            endmembers=[\n                [hp_clinoenstatite(), \"[Mg]2Si2O6\"],\n                [hp_clinoferrosilite(), \"[Fe]2Si2O6\"],\n            ]\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class ca_ferrite_structured_phase(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"calcium ferrite structured phase\"\n        self.solution_model = IdealSolution(\n            endmembers=[\n                [mg_ca_ferrite(), \"[Mg]Al[Al]O4\"],\n                [fe_ca_ferrite(), \"[Fe]Al[Al]O4\"],\n                [na_ca_ferrite(), \"[Na]Al[Si]O4\"],\n            ]\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class clinopyroxene(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"clinopyroxene\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [diopside(), \"[Ca][Mg][Si]2O6\"],\n                [hedenbergite(), \"[Ca][Fe][Si]2O6\"],\n                [clinoenstatite(), \"[Mg][Mg][Si]2O6\"],\n                [ca_tschermaks(), \"[Ca][Al][Si1/2Al1/2]2O6\"],\n                [jadeite(), \"[Na][Al][Si]2O6\"],\n            ],\n            alphas=[1.0, 1.0, 1.0, 3.5, 1.0],\n            energy_interaction=[\n                [0.0, 24.74e3, 26.0e3, 24.3e3],\n                [24.74e3, 0.0, 0.0e3],\n                [60.53136e3, 0.0],\n                [10.0e3],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class garnet(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"garnet\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [pyrope(), \"[Mg]3[Al][Al]Si3O12\"],\n                [almandine(), \"[Fe]3[Al][Al]Si3O12\"],\n                [grossular(), \"[Ca]3[Al][Al]Si3O12\"],\n                [mg_majorite(), \"[Mg]3[Mg][Si]Si3O12\"],\n                [jd_majorite(), \"[Na2/3Al1/3]3[Al][Si]Si3O12\"],\n            ],\n            energy_interaction=[\n                [0.0, 30.0e3, 21.20278e3, 0.0],\n                [0.0, 0.0, 0.0],\n                [57.77596e3, 0.0],\n                [0.0],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class akimotoite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"akimotoite/ilmenite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mg_akimotoite(), \"[Mg][Si]O3\"],\n                [fe_akimotoite(), \"[Fe][Si]O3\"],\n                [corundum(), \"[Al][Al]O3\"],\n            ],\n            energy_interaction=[[0.0, 66.0e3], [0.0e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class ferropericlase(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"magnesiowustite/ferropericlase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[[periclase(), \"[Mg]O\"], [wuestite(), \"[Fe]O\"]],\n            energy_interaction=[[13.0e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class mg_fe_olivine(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"olivine\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[[forsterite(), \"[Mg]2SiO4\"], [fayalite(), \"[Fe]2SiO4\"]],\n            energy_interaction=[[7.81322e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class orthopyroxene(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [enstatite(), \"[Mg][Mg]SiSiO6\"],\n                [ferrosilite(), \"[Fe][Fe]SiSiO6\"],\n                [mg_tschermaks(), \"[Mg][Al]AlSiO6\"],\n                [ortho_diopside(), \"[Ca][Mg]SiSiO6\"],\n            ],  # Al avoidance, see Figure 3\n            energy_interaction=[[0.0, 0.0, 32.11352e3], [0.0, 0.0], [48.35316e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class plagioclase(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"plagioclase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [anorthite(), \"[Ca][Al]2Si2O8\"],\n                [albite(), \"[Na][Al1/2Si1/2]2Si2O8\"],\n            ],\n            energy_interaction=[[26.0e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class post_perovskite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"post-perovskite/bridgmanite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mg_post_perovskite(), \"[Mg][Si]O3\"],\n                [fe_post_perovskite(), \"[Fe][Si]O3\"],\n                [al_post_perovskite(), \"[Al][Al]O3\"],\n            ],\n            energy_interaction=[[0.0, 60.0e3], [0.0]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class mg_fe_perovskite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"magnesium silicate perovskite/bridgmanite\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [mg_perovskite(), \"[Mg][Si]O3\"],\n                [fe_perovskite(), \"[Fe][Si]O3\"],\n                [al_perovskite(), \"[Al][Al]O3\"],\n            ],\n            energy_interaction=[[0.0, 116.0e3], [0.0]],\n            alphas=[1.0, 1.0, 0.39],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class mg_fe_ringwoodite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"ringwoodite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mg_ringwoodite(), \"[Mg]2SiO4\"],\n                [fe_ringwoodite(), \"[Fe]2SiO4\"],\n            ],\n            energy_interaction=[[9.34084e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class mg_fe_aluminous_spinel(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"spinel-hercynite binary, fixed order\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [spinel(), \"[Mg3/4Al1/4]4[Al7/8Mg1/8]8O16\"],\n                [hercynite(), \"[Fe3/4Al1/4]4[Al7/8Fe1/8]8O16\"],\n            ],\n            energy_interaction=[[5.87646e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class mg_fe_wadsleyite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"wadsleyite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mg_wadsleyite(), \"[Mg]2SiO4\"],\n                [fe_wadsleyite(), \"[Fe]2SiO4\"],\n            ],\n            energy_interaction=[[16.74718e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class anorthite(Mineral):\n    def __init__(self):\n        formula = \"CaAl2Si2O8\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Anorthite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -4014619.0,\n            \"V_0\": 0.00010061,\n            \"K_0\": 84089150000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 752.3911,\n            \"grueneisen_0\": 0.39241,\n            \"q_0\": 1.0,\n            \"G_0\": 39900000000.0,\n            \"Gprime_0\": 1.09134,\n            \"eta_s_0\": 1.6254,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 5000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 2.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 3000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class albite(Mineral):\n    def __init__(self):\n        formula = \"NaAlSi3O8\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Albite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3718799.0,\n            \"V_0\": 0.000100452,\n            \"K_0\": 59761620000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 713.7824,\n            \"grueneisen_0\": 0.56704,\n            \"q_0\": 1.0,\n            \"G_0\": 36000000000.0,\n            \"Gprime_0\": 1.3855,\n            \"eta_s_0\": 1.04208,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 5000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 5000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 13.0,\n            \"err_grueneisen_0\": 0.03,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 5000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class spinel(Mineral):\n    def __init__(self):\n        formula = \"Mg4Al8O16\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Spinel\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -8667568.0,\n            \"V_0\": 0.000159048,\n            \"K_0\": 1.969428e11,\n            \"Kprime_0\": 5.68282,\n            \"Debye_0\": 842.8104,\n            \"grueneisen_0\": 1.02283,\n            \"q_0\": 2.71208,\n            \"G_0\": 1.085e11,\n            \"Gprime_0\": 0.37303,\n            \"eta_s_0\": 2.66282,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 43.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 32000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 33.0,\n            \"err_grueneisen_0\": 0.04,\n            \"err_q_0\": 0.6,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 0.6,\n        }\n        Mineral.__init__(self)",
  "class hercynite(Mineral):\n    def __init__(self):\n        formula = \"Fe4Al8O16\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Hercynite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -7324009.0,\n            \"V_0\": 0.000163372,\n            \"K_0\": 2.088965e11,\n            \"Kprime_0\": 5.68282,\n            \"Debye_0\": 763.231,\n            \"grueneisen_0\": 1.21719,\n            \"q_0\": 2.71208,\n            \"G_0\": 84500000000.0,\n            \"Gprime_0\": 0.37303,\n            \"eta_s_0\": 2.768,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 97.28, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 35000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 32.0,\n            \"err_grueneisen_0\": 0.07,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 13000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class forsterite(Mineral):\n    def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Forsterite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2055403.0,\n            \"V_0\": 4.3603e-05,\n            \"K_0\": 1.279555e11,\n            \"Kprime_0\": 4.21796,\n            \"Debye_0\": 809.1703,\n            \"grueneisen_0\": 0.99282,\n            \"q_0\": 2.10672,\n            \"G_0\": 81599990000.0,\n            \"Gprime_0\": 1.46257,\n            \"eta_s_0\": 2.29972,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 1.0,\n            \"err_grueneisen_0\": 0.03,\n            \"err_q_0\": 0.2,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.1,\n        }\n        Mineral.__init__(self)",
  "class fayalite(Mineral):\n    def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fayalite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1370519.0,\n            \"V_0\": 4.629e-05,\n            \"K_0\": 1.349622e11,\n            \"Kprime_0\": 4.21796,\n            \"Debye_0\": 618.7007,\n            \"grueneisen_0\": 1.06023,\n            \"q_0\": 3.6466,\n            \"G_0\": 50899990000.0,\n            \"Gprime_0\": 1.46257,\n            \"eta_s_0\": 1.02497,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 26.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 2.0,\n            \"err_grueneisen_0\": 0.07,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 0.6,\n        }\n        Mineral.__init__(self)",
  "class mg_wadsleyite(Mineral):\n    def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Wadsleyite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2027837.0,\n            \"V_0\": 4.0515e-05,\n            \"K_0\": 1.686948e11,\n            \"Kprime_0\": 4.3229,\n            \"Debye_0\": 843.4973,\n            \"grueneisen_0\": 1.2061,\n            \"q_0\": 2.0188,\n            \"G_0\": 1.12e11,\n            \"Gprime_0\": 1.44424,\n            \"eta_s_0\": 2.63683,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 3000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 7.0,\n            \"err_grueneisen_0\": 0.09,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.2,\n            \"err_eta_s_0\": 0.4,\n        }\n        Mineral.__init__(self)",
  "class fe_wadsleyite(Mineral):\n    def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Wadsleyite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1364668.0,\n            \"V_0\": 4.28e-05,\n            \"K_0\": 1.68591e11,\n            \"Kprime_0\": 4.3229,\n            \"Debye_0\": 665.4492,\n            \"grueneisen_0\": 1.2061,\n            \"q_0\": 2.0188,\n            \"G_0\": 72000000000.0,\n            \"Gprime_0\": 1.44424,\n            \"eta_s_0\": 1.04017,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 26.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 7000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 13000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 21.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 12000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class mg_ringwoodite(Mineral):\n    def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Ringwoodite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2017557.0,\n            \"V_0\": 3.9493e-05,\n            \"K_0\": 1.849009e11,\n            \"Kprime_0\": 4.22035,\n            \"Debye_0\": 877.7094,\n            \"grueneisen_0\": 1.10791,\n            \"q_0\": 2.3914,\n            \"G_0\": 1.23e11,\n            \"Gprime_0\": 1.35412,\n            \"eta_s_0\": 2.30461,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 8.0,\n            \"err_grueneisen_0\": 0.1,\n            \"err_q_0\": 0.4,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.5,\n        }\n        Mineral.__init__(self)",
  "class fe_ringwoodite(Mineral):\n    def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Ringwoodite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1362772.0,\n            \"V_0\": 4.186e-05,\n            \"K_0\": 2.13412e11,\n            \"Kprime_0\": 4.22035,\n            \"Debye_0\": 677.7177,\n            \"grueneisen_0\": 1.27193,\n            \"q_0\": 2.3914,\n            \"G_0\": 92000000000.0,\n            \"Gprime_0\": 1.35412,\n            \"eta_s_0\": 1.77249,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 26.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 7000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 8.0,\n            \"err_grueneisen_0\": 0.23,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class enstatite(Mineral):\n    def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Enstatite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2913596.0,\n            \"V_0\": 6.2676e-05,\n            \"K_0\": 1.070768e11,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 812.1848,\n            \"grueneisen_0\": 0.78479,\n            \"q_0\": 3.43846,\n            \"G_0\": 76800000000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 2.50453,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.4,\n            \"err_Debye_0\": 4.0,\n            \"err_grueneisen_0\": 0.04,\n            \"err_q_0\": 0.4,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.1,\n        }\n        Mineral.__init__(self)",
  "class ferrosilite(Mineral):\n    def __init__(self):\n        formula = \"Fe2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Ferrosilite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2225718.0,\n            \"V_0\": 6.5941e-05,\n            \"K_0\": 1.005386e11,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 674.4769,\n            \"grueneisen_0\": 0.71889,\n            \"q_0\": 3.43846,\n            \"G_0\": 52000000000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 1.07706,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 26.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 4000000000.0,\n            \"err_K_prime_0\": 0.5,\n            \"err_Debye_0\": 10.0,\n            \"err_grueneisen_0\": 0.08,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 5000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class mg_tschermaks(Mineral):\n    def __init__(self):\n        formula = \"MgAl2SiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Tschermaks\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3002470.0,\n            \"V_0\": 5.914e-05,\n            \"K_0\": 1.070768e11,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 783.8404,\n            \"grueneisen_0\": 0.78479,\n            \"q_0\": 3.43846,\n            \"G_0\": 95950860000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 2.49099,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 9000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 24.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class ortho_diopside(Mineral):\n    def __init__(self):\n        formula = \"CaMgSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Ortho_Diopside\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3015827.0,\n            \"V_0\": 6.8054e-05,\n            \"K_0\": 1.070768e11,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 744.6988,\n            \"grueneisen_0\": 0.78479,\n            \"q_0\": 3.43846,\n            \"G_0\": 58458950000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 1.36161,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 9.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class diopside(Mineral):\n    def __init__(self):\n        formula = \"CaMgSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Diopside\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3029531.0,\n            \"V_0\": 6.6039e-05,\n            \"K_0\": 1.122413e11,\n            \"Kprime_0\": 5.23885,\n            \"Debye_0\": 781.6146,\n            \"grueneisen_0\": 0.95873,\n            \"q_0\": 1.52852,\n            \"G_0\": 67000000000.0,\n            \"Gprime_0\": 1.37293,\n            \"eta_s_0\": 1.57351,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 5000000000.0,\n            \"err_K_prime_0\": 1.8,\n            \"err_Debye_0\": 3.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 2.0,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class hedenbergite(Mineral):\n    def __init__(self):\n        formula = \"CaFeSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Hedenbergite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2677330.0,\n            \"V_0\": 6.7867e-05,\n            \"K_0\": 1.192555e11,\n            \"Kprime_0\": 5.23885,\n            \"Debye_0\": 701.5851,\n            \"grueneisen_0\": 0.93516,\n            \"q_0\": 1.52852,\n            \"G_0\": 61000000000.0,\n            \"Gprime_0\": 1.17647,\n            \"eta_s_0\": 1.5703,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 45000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 4000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 2.0,\n            \"err_grueneisen_0\": 0.06,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class clinoenstatite(Mineral):\n    def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Clinoenstatite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2905918.0,\n            \"V_0\": 6.25e-05,\n            \"K_0\": 1.122413e11,\n            \"Kprime_0\": 5.23885,\n            \"Debye_0\": 805.0547,\n            \"grueneisen_0\": 0.95873,\n            \"q_0\": 1.52852,\n            \"G_0\": 79496860000.0,\n            \"Gprime_0\": 1.62901,\n            \"eta_s_0\": 1.69074,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 10.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class ca_tschermaks(Mineral):\n    def __init__(self):\n        formula = \"CaAl2SiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Ca_Tschermaks\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3120253.0,\n            \"V_0\": 6.3574e-05,\n            \"K_0\": 1.122413e11,\n            \"Kprime_0\": 5.23885,\n            \"Debye_0\": 803.6626,\n            \"grueneisen_0\": 0.78126,\n            \"q_0\": 1.52852,\n            \"G_0\": 75160660000.0,\n            \"Gprime_0\": 1.54016,\n            \"eta_s_0\": 1.9672,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 11.525, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 5000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 5.0,\n            \"err_grueneisen_0\": 0.0,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class jadeite(Mineral):\n    def __init__(self):\n        formula = \"NaAlSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Jadeite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2855192.0,\n            \"V_0\": 6.0508e-05,\n            \"K_0\": 1.422873e11,\n            \"Kprime_0\": 5.23885,\n            \"Debye_0\": 820.7623,\n            \"grueneisen_0\": 0.903,\n            \"q_0\": 0.39234,\n            \"G_0\": 85000000000.0,\n            \"Gprime_0\": 1.37398,\n            \"eta_s_0\": 2.18453,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 12.0,\n            \"err_grueneisen_0\": 0.08,\n            \"err_q_0\": 1.4,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class hp_clinoenstatite(Mineral):\n    def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"HP_Clinoenstatite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2905788.0,\n            \"V_0\": 6.076e-05,\n            \"K_0\": 1.160254e11,\n            \"Kprime_0\": 6.23685,\n            \"Debye_0\": 824.4439,\n            \"grueneisen_0\": 1.12473,\n            \"q_0\": 0.20401,\n            \"G_0\": 87927170000.0,\n            \"Gprime_0\": 1.84119,\n            \"eta_s_0\": 2.14181,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.3,\n            \"err_Debye_0\": 7.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.5,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.5,\n        }\n        Mineral.__init__(self)",
  "class hp_clinoferrosilite(Mineral):\n    def __init__(self):\n        formula = \"Fe2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"HP_Clinoferrosilite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2222183.0,\n            \"V_0\": 6.385413e-05,\n            \"K_0\": 1.160254e11,\n            \"Kprime_0\": 6.23685,\n            \"Debye_0\": 691.564,\n            \"grueneisen_0\": 1.12473,\n            \"q_0\": 0.20401,\n            \"G_0\": 70623090000.0,\n            \"Gprime_0\": 1.84119,\n            \"eta_s_0\": 0.79216,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 26.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 11.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class ca_perovskite(Mineral):\n    def __init__(self):\n        formula = \"CaSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Ca_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1463358.0,\n            \"V_0\": 2.745e-05,\n            \"K_0\": 2.36e11,\n            \"Kprime_0\": 3.9,\n            \"Debye_0\": 795.779,\n            \"grueneisen_0\": 1.88839,\n            \"q_0\": 0.89769,\n            \"G_0\": 1.568315e11,\n            \"Gprime_0\": 2.22713,\n            \"eta_s_0\": 1.28818,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 8000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 4000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 44.0,\n            \"err_grueneisen_0\": 0.07,\n            \"err_q_0\": 1.6,\n            \"err_G_0\": 12000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class mg_akimotoite(Mineral):\n    def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Akimotoite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1410850.0,\n            \"V_0\": 2.6354e-05,\n            \"K_0\": 2.10706e11,\n            \"Kprime_0\": 5.62088,\n            \"Debye_0\": 935.9778,\n            \"grueneisen_0\": 1.18984,\n            \"q_0\": 2.34514,\n            \"G_0\": 1.32e11,\n            \"Gprime_0\": 1.57889,\n            \"eta_s_0\": 2.80782,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 4000000000.0,\n            \"err_K_prime_0\": 0.8,\n            \"err_Debye_0\": 12.0,\n            \"err_grueneisen_0\": 0.13,\n            \"err_q_0\": 0.8,\n            \"err_G_0\": 8000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class fe_akimotoite(Mineral):\n    def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Akimotoite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1067598.0,\n            \"V_0\": 2.6854e-05,\n            \"K_0\": 2.10706e11,\n            \"Kprime_0\": 5.62088,\n            \"Debye_0\": 887.8709,\n            \"grueneisen_0\": 1.18984,\n            \"q_0\": 2.34514,\n            \"G_0\": 1.523046e11,\n            \"Gprime_0\": 1.57889,\n            \"eta_s_0\": 3.5716,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 21000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 120.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class corundum(Mineral):\n    def __init__(self):\n        formula = \"AlAlO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Corundum\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1582454.0,\n            \"V_0\": 2.5577e-05,\n            \"K_0\": 2.525457e11,\n            \"Kprime_0\": 4.33728,\n            \"Debye_0\": 932.5696,\n            \"grueneisen_0\": 1.32442,\n            \"q_0\": 1.30316,\n            \"G_0\": 1.632e11,\n            \"Gprime_0\": 1.64174,\n            \"eta_s_0\": 2.8316,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 5000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 3.0,\n            \"err_grueneisen_0\": 0.04,\n            \"err_q_0\": 0.2,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.2,\n        }\n        Mineral.__init__(self)",
  "class pyrope(Mineral):\n    def __init__(self):\n        formula = \"Mg3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Pyrope\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5936538.0,\n            \"V_0\": 0.00011308,\n            \"K_0\": 1.702396e11,\n            \"Kprime_0\": 4.11067,\n            \"Debye_0\": 823.2102,\n            \"grueneisen_0\": 1.01424,\n            \"q_0\": 1.42169,\n            \"G_0\": 93699990000.0,\n            \"Gprime_0\": 1.35756,\n            \"eta_s_0\": 0.98186,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 10000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.3,\n            \"err_Debye_0\": 4.0,\n            \"err_grueneisen_0\": 0.06,\n            \"err_q_0\": 0.5,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.2,\n            \"err_eta_s_0\": 0.3,\n        }\n        Mineral.__init__(self)",
  "class almandine(Mineral):\n    def __init__(self):\n        formula = \"Fe3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Almandine\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -4935516.0,\n            \"V_0\": 0.00011543,\n            \"K_0\": 1.738963e11,\n            \"Kprime_0\": 4.91341,\n            \"Debye_0\": 741.356,\n            \"grueneisen_0\": 1.06495,\n            \"q_0\": 1.42169,\n            \"G_0\": 96000000000.0,\n            \"Gprime_0\": 1.40927,\n            \"eta_s_0\": 2.09292,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 40.14, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 29000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 5.0,\n            \"err_grueneisen_0\": 0.06,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class grossular(Mineral):\n    def __init__(self):\n        formula = \"Ca3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Grossular\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -6277935.0,\n            \"V_0\": 0.00012512,\n            \"K_0\": 1.670622e11,\n            \"Kprime_0\": 3.91544,\n            \"Debye_0\": 822.743,\n            \"grueneisen_0\": 1.05404,\n            \"q_0\": 1.88887,\n            \"G_0\": 1.09e11,\n            \"Gprime_0\": 1.16274,\n            \"eta_s_0\": 2.38418,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 11000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 2.0,\n            \"err_grueneisen_0\": 0.06,\n            \"err_q_0\": 0.2,\n            \"err_G_0\": 4000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.1,\n        }\n        Mineral.__init__(self)",
  "class mg_majorite(Mineral):\n    def __init__(self):\n        formula = \"Mg4Si4O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Majorite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5691614.0,\n            \"V_0\": 0.000114324,\n            \"K_0\": 1.651183e11,\n            \"Kprime_0\": 4.21183,\n            \"Debye_0\": 822.458,\n            \"grueneisen_0\": 0.97682,\n            \"q_0\": 1.53581,\n            \"G_0\": 84999990000.0,\n            \"Gprime_0\": 1.42969,\n            \"eta_s_0\": 1.0178,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 10000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 3000000000.0,\n            \"err_K_prime_0\": 0.3,\n            \"err_Debye_0\": 4.0,\n            \"err_grueneisen_0\": 0.07,\n            \"err_q_0\": 0.5,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.2,\n            \"err_eta_s_0\": 0.3,\n        }\n        Mineral.__init__(self)",
  "class jd_majorite(Mineral):\n    def __init__(self):\n        formula = \"Na2Al2Si4O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Jd_Majorite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5518542.0,\n            \"V_0\": 0.00011094,\n            \"K_0\": 1.770772e11,\n            \"Kprime_0\": 4.11067,\n            \"Debye_0\": 895.914,\n            \"grueneisen_0\": 1.01424,\n            \"q_0\": 1.42169,\n            \"G_0\": 1.25e11,\n            \"Gprime_0\": 1.35756,\n            \"eta_s_0\": 3.30517,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 14000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 7000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 18.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 4000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class quartz(Mineral):\n    def __init__(self):\n        formula = \"SiO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Quartz\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -858853.4,\n            \"V_0\": 2.367003e-05,\n            \"K_0\": 49547430000.0,\n            \"Kprime_0\": 4.33155,\n            \"Debye_0\": 816.3307,\n            \"grueneisen_0\": -0.00296,\n            \"q_0\": 1.0,\n            \"G_0\": 44856170000.0,\n            \"Gprime_0\": 0.95315,\n            \"eta_s_0\": 2.36469,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"landau\", {\"Tc_0\": 847.0, \"S_D\": 5.164, \"V_D\": 1.222e-06}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 31.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class coesite(Mineral):\n    def __init__(self):\n        formula = \"SiO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Coesite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -855068.5,\n            \"V_0\": 2.0657e-05,\n            \"K_0\": 1.135856e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 852.4267,\n            \"grueneisen_0\": 0.39157,\n            \"q_0\": 1.0,\n            \"G_0\": 61600010000.0,\n            \"Gprime_0\": 1.24734,\n            \"eta_s_0\": 2.39793,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 9.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class stishovite(Mineral):\n    def __init__(self):\n        formula = \"SiO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Stishovite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -818984.6,\n            \"V_0\": 1.4017e-05,\n            \"K_0\": 3.143352e11,\n            \"Kprime_0\": 3.75122,\n            \"Debye_0\": 1107.824,\n            \"grueneisen_0\": 1.37466,\n            \"q_0\": 2.83517,\n            \"G_0\": 2.2e11,\n            \"Gprime_0\": 1.93334,\n            \"eta_s_0\": 4.60904,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"landau\", {\"Tc_0\": -4250.0, \"S_D\": 0.012, \"V_D\": 1e-09}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 8000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 13.0,\n            \"err_grueneisen_0\": 0.17,\n            \"err_q_0\": 2.2,\n            \"err_G_0\": 12000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class seifertite(Mineral):\n    def __init__(self):\n        formula = \"SiO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Seifertite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -794335.4,\n            \"V_0\": 1.367e-05,\n            \"K_0\": 3.275843e11,\n            \"Kprime_0\": 4.01553,\n            \"Debye_0\": 1140.772,\n            \"grueneisen_0\": 1.37466,\n            \"q_0\": 2.83517,\n            \"G_0\": 2.274532e11,\n            \"Gprime_0\": 1.76965,\n            \"eta_s_0\": 4.97108,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 16.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class mg_perovskite(Mineral):\n    def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1368283.0,\n            \"V_0\": 2.4445e-05,\n            \"K_0\": 2.505264e11,\n            \"Kprime_0\": 4.14,\n            \"Debye_0\": 905.9412,\n            \"grueneisen_0\": 1.56508,\n            \"q_0\": 1.10945,\n            \"G_0\": 1.729e11,\n            \"Gprime_0\": 1.69037,\n            \"eta_s_0\": 2.56536,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 3000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 5.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.3,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.0,\n            \"err_eta_s_0\": 0.3,\n        }\n        Mineral.__init__(self)",
  "class fe_perovskite(Mineral):\n    def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1040920.0,\n            \"V_0\": 2.5485e-05,\n            \"K_0\": 2.721152e11,\n            \"Kprime_0\": 4.14,\n            \"Debye_0\": 870.8122,\n            \"grueneisen_0\": 1.56508,\n            \"q_0\": 1.10945,\n            \"G_0\": 1.326849e11,\n            \"Gprime_0\": 1.37485,\n            \"eta_s_0\": 2.29211,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 6000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 40000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 26.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 40000000000.0,\n            \"err_Gprime_0\": 0.0,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class al_perovskite(Mineral):\n    def __init__(self):\n        formula = \"AlAlO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Al_perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1533878.0,\n            \"V_0\": 2.4944e-05,\n            \"K_0\": 2.582e11,\n            \"Kprime_0\": 4.14,\n            \"Debye_0\": 886.4601,\n            \"grueneisen_0\": 1.56508,\n            \"q_0\": 1.10945,\n            \"G_0\": 1.713116e11,\n            \"Gprime_0\": 1.49706,\n            \"eta_s_0\": 2.47126,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 0.5,\n            \"err_Debye_0\": 7.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.5,\n        }\n        Mineral.__init__(self)",
  "class mg_post_perovskite(Mineral):\n    def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Post_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1348641.0,\n            \"V_0\": 2.4419e-05,\n            \"K_0\": 2.312e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 855.8173,\n            \"grueneisen_0\": 1.89155,\n            \"q_0\": 1.09081,\n            \"G_0\": 1.50167e11,\n            \"Gprime_0\": 1.97874,\n            \"eta_s_0\": 1.16704,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 7.0,\n            \"err_grueneisen_0\": 0.03,\n            \"err_q_0\": 0.1,\n            \"err_G_0\": 4000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.2,\n        }\n        Mineral.__init__(self)",
  "class fe_post_perovskite(Mineral):\n    def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Post_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -981806.9,\n            \"V_0\": 2.5459e-05,\n            \"K_0\": 2.312e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 781.3465,\n            \"grueneisen_0\": 1.89155,\n            \"q_0\": 1.09081,\n            \"G_0\": 1.295e11,\n            \"Gprime_0\": 1.44675,\n            \"eta_s_0\": 1.36382,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 21000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 52.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 5000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class al_post_perovskite(Mineral):\n    def __init__(self):\n        formula = \"AlAlO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Al_Post_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1377582.0,\n            \"V_0\": 2.3847e-05,\n            \"K_0\": 2.49e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 762.1951,\n            \"grueneisen_0\": 1.64573,\n            \"q_0\": 1.09081,\n            \"G_0\": 91965310000.0,\n            \"Gprime_0\": 1.81603,\n            \"eta_s_0\": 2.83762,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 20000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 9.0,\n            \"err_grueneisen_0\": 0.02,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.2,\n        }\n        Mineral.__init__(self)",
  "class periclase(Mineral):\n    def __init__(self):\n        formula = \"MgO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Periclase\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -569444.6,\n            \"V_0\": 1.1244e-05,\n            \"K_0\": 1.613836e11,\n            \"Kprime_0\": 3.84045,\n            \"Debye_0\": 767.0977,\n            \"grueneisen_0\": 1.36127,\n            \"q_0\": 1.7217,\n            \"G_0\": 1.309e11,\n            \"Gprime_0\": 2.1438,\n            \"eta_s_0\": 2.81765,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 0.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 3000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 9.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.2,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.2,\n        }\n        Mineral.__init__(self)",
  "class wuestite(Mineral):\n    def __init__(self):\n        formula = \"FeO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Wuestite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -242146.0,\n            \"V_0\": 1.2264e-05,\n            \"K_0\": 1.794442e11,\n            \"Kprime_0\": 4.9376,\n            \"Debye_0\": 454.1592,\n            \"grueneisen_0\": 1.53047,\n            \"q_0\": 1.7217,\n            \"G_0\": 59000000000.0,\n            \"Gprime_0\": 1.44673,\n            \"eta_s_0\": -0.05731,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 21.0,\n            \"err_grueneisen_0\": 0.13,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class mg_ca_ferrite(Mineral):\n    def __init__(self):\n        formula = \"MgAl2O4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Ca_Ferrite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2122169.0,\n            \"V_0\": 3.6177e-05,\n            \"K_0\": 2.106663e11,\n            \"Kprime_0\": 4.0528,\n            \"Debye_0\": 838.6291,\n            \"grueneisen_0\": 1.31156,\n            \"q_0\": 1.0,\n            \"G_0\": 1.29826e11,\n            \"Gprime_0\": 1.75878,\n            \"eta_s_0\": 2.1073,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 16.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class fe_ca_ferrite(Mineral):\n    def __init__(self):\n        formula = \"FeAl2O4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Ca_Ferrite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1790284.0,\n            \"V_0\": 3.7258e-05,\n            \"K_0\": 2.106663e11,\n            \"Kprime_0\": 4.0528,\n            \"Debye_0\": 804.1986,\n            \"grueneisen_0\": 1.31156,\n            \"q_0\": 1.0,\n            \"G_0\": 1.535236e11,\n            \"Gprime_0\": 1.75878,\n            \"eta_s_0\": 3.0268,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 25000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 69.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class na_ca_ferrite(Mineral):\n    def __init__(self):\n        formula = \"NaAlSiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Na_Ca_Ferrite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1844129.0,\n            \"V_0\": 3.627e-05,\n            \"K_0\": 1.613385e11,\n            \"Kprime_0\": 4.32479,\n            \"Debye_0\": 812.4769,\n            \"grueneisen_0\": 0.69428,\n            \"q_0\": 1.0,\n            \"G_0\": 1.220049e11,\n            \"Gprime_0\": 2.07687,\n            \"eta_s_0\": 2.79016,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 11000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 51.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class kyanite(Mineral):\n    def __init__(self):\n        formula = \"Al2SiO5\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Kyanite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2446058.0,\n            \"V_0\": 4.4227e-05,\n            \"K_0\": 1.6e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 943.1665,\n            \"grueneisen_0\": 0.9255,\n            \"q_0\": 1.0,\n            \"G_0\": 1.204033e11,\n            \"Gprime_0\": 1.7308,\n            \"eta_s_0\": 2.96665,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.0,\n            \"err_Debye_0\": 8.0,\n            \"err_grueneisen_0\": 0.07,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class nepheline(Mineral):\n    def __init__(self):\n        formula = \"NaAlSiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Nepheline\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1992104.0,\n            \"V_0\": 5.46684e-05,\n            \"K_0\": 53077990000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 700.9422,\n            \"grueneisen_0\": 0.69428,\n            \"q_0\": 1.0,\n            \"G_0\": 30700000000.0,\n            \"Gprime_0\": 1.33031,\n            \"eta_s_0\": 0.6291,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 13.0,\n            \"err_grueneisen_0\": 0.03,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"C2/c pyroxene\"\n        self.solution_model = IdealSolution(\n            endmembers=[\n                [hp_clinoenstatite(), \"[Mg]2Si2O6\"],\n                [hp_clinoferrosilite(), \"[Fe]2Si2O6\"],\n            ]\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"calcium ferrite structured phase\"\n        self.solution_model = IdealSolution(\n            endmembers=[\n                [mg_ca_ferrite(), \"[Mg]Al[Al]O4\"],\n                [fe_ca_ferrite(), \"[Fe]Al[Al]O4\"],\n                [na_ca_ferrite(), \"[Na]Al[Si]O4\"],\n            ]\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"clinopyroxene\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [diopside(), \"[Ca][Mg][Si]2O6\"],\n                [hedenbergite(), \"[Ca][Fe][Si]2O6\"],\n                [clinoenstatite(), \"[Mg][Mg][Si]2O6\"],\n                [ca_tschermaks(), \"[Ca][Al][Si1/2Al1/2]2O6\"],\n                [jadeite(), \"[Na][Al][Si]2O6\"],\n            ],\n            alphas=[1.0, 1.0, 1.0, 3.5, 1.0],\n            energy_interaction=[\n                [0.0, 24.74e3, 26.0e3, 24.3e3],\n                [24.74e3, 0.0, 0.0e3],\n                [60.53136e3, 0.0],\n                [10.0e3],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"garnet\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [pyrope(), \"[Mg]3[Al][Al]Si3O12\"],\n                [almandine(), \"[Fe]3[Al][Al]Si3O12\"],\n                [grossular(), \"[Ca]3[Al][Al]Si3O12\"],\n                [mg_majorite(), \"[Mg]3[Mg][Si]Si3O12\"],\n                [jd_majorite(), \"[Na2/3Al1/3]3[Al][Si]Si3O12\"],\n            ],\n            energy_interaction=[\n                [0.0, 30.0e3, 21.20278e3, 0.0],\n                [0.0, 0.0, 0.0],\n                [57.77596e3, 0.0],\n                [0.0],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"akimotoite/ilmenite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mg_akimotoite(), \"[Mg][Si]O3\"],\n                [fe_akimotoite(), \"[Fe][Si]O3\"],\n                [corundum(), \"[Al][Al]O3\"],\n            ],\n            energy_interaction=[[0.0, 66.0e3], [0.0e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"magnesiowustite/ferropericlase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[[periclase(), \"[Mg]O\"], [wuestite(), \"[Fe]O\"]],\n            energy_interaction=[[13.0e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"olivine\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[[forsterite(), \"[Mg]2SiO4\"], [fayalite(), \"[Fe]2SiO4\"]],\n            energy_interaction=[[7.81322e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"orthopyroxene\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [enstatite(), \"[Mg][Mg]SiSiO6\"],\n                [ferrosilite(), \"[Fe][Fe]SiSiO6\"],\n                [mg_tschermaks(), \"[Mg][Al]AlSiO6\"],\n                [ortho_diopside(), \"[Ca][Mg]SiSiO6\"],\n            ],  # Al avoidance, see Figure 3\n            energy_interaction=[[0.0, 0.0, 32.11352e3], [0.0, 0.0], [48.35316e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"plagioclase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [anorthite(), \"[Ca][Al]2Si2O8\"],\n                [albite(), \"[Na][Al1/2Si1/2]2Si2O8\"],\n            ],\n            energy_interaction=[[26.0e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"post-perovskite/bridgmanite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mg_post_perovskite(), \"[Mg][Si]O3\"],\n                [fe_post_perovskite(), \"[Fe][Si]O3\"],\n                [al_post_perovskite(), \"[Al][Al]O3\"],\n            ],\n            energy_interaction=[[0.0, 60.0e3], [0.0]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"magnesium silicate perovskite/bridgmanite\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [mg_perovskite(), \"[Mg][Si]O3\"],\n                [fe_perovskite(), \"[Fe][Si]O3\"],\n                [al_perovskite(), \"[Al][Al]O3\"],\n            ],\n            energy_interaction=[[0.0, 116.0e3], [0.0]],\n            alphas=[1.0, 1.0, 0.39],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"ringwoodite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mg_ringwoodite(), \"[Mg]2SiO4\"],\n                [fe_ringwoodite(), \"[Fe]2SiO4\"],\n            ],\n            energy_interaction=[[9.34084e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"spinel-hercynite binary, fixed order\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [spinel(), \"[Mg3/4Al1/4]4[Al7/8Mg1/8]8O16\"],\n                [hercynite(), \"[Fe3/4Al1/4]4[Al7/8Fe1/8]8O16\"],\n            ],\n            energy_interaction=[[5.87646e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"wadsleyite\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [mg_wadsleyite(), \"[Mg]2SiO4\"],\n                [fe_wadsleyite(), \"[Fe]2SiO4\"],\n            ],\n            energy_interaction=[[16.74718e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self):\n        formula = \"CaAl2Si2O8\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Anorthite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -4014619.0,\n            \"V_0\": 0.00010061,\n            \"K_0\": 84089150000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 752.3911,\n            \"grueneisen_0\": 0.39241,\n            \"q_0\": 1.0,\n            \"G_0\": 39900000000.0,\n            \"Gprime_0\": 1.09134,\n            \"eta_s_0\": 1.6254,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 5000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 2.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 3000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"NaAlSi3O8\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Albite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3718799.0,\n            \"V_0\": 0.000100452,\n            \"K_0\": 59761620000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 713.7824,\n            \"grueneisen_0\": 0.56704,\n            \"q_0\": 1.0,\n            \"G_0\": 36000000000.0,\n            \"Gprime_0\": 1.3855,\n            \"eta_s_0\": 1.04208,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 5000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 5000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 13.0,\n            \"err_grueneisen_0\": 0.03,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 5000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg4Al8O16\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Spinel\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -8667568.0,\n            \"V_0\": 0.000159048,\n            \"K_0\": 1.969428e11,\n            \"Kprime_0\": 5.68282,\n            \"Debye_0\": 842.8104,\n            \"grueneisen_0\": 1.02283,\n            \"q_0\": 2.71208,\n            \"G_0\": 1.085e11,\n            \"Gprime_0\": 0.37303,\n            \"eta_s_0\": 2.66282,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 43.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 32000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 33.0,\n            \"err_grueneisen_0\": 0.04,\n            \"err_q_0\": 0.6,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 0.6,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe4Al8O16\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Hercynite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -7324009.0,\n            \"V_0\": 0.000163372,\n            \"K_0\": 2.088965e11,\n            \"Kprime_0\": 5.68282,\n            \"Debye_0\": 763.231,\n            \"grueneisen_0\": 1.21719,\n            \"q_0\": 2.71208,\n            \"G_0\": 84500000000.0,\n            \"Gprime_0\": 0.37303,\n            \"eta_s_0\": 2.768,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 97.28, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 35000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 32.0,\n            \"err_grueneisen_0\": 0.07,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 13000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Forsterite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2055403.0,\n            \"V_0\": 4.3603e-05,\n            \"K_0\": 1.279555e11,\n            \"Kprime_0\": 4.21796,\n            \"Debye_0\": 809.1703,\n            \"grueneisen_0\": 0.99282,\n            \"q_0\": 2.10672,\n            \"G_0\": 81599990000.0,\n            \"Gprime_0\": 1.46257,\n            \"eta_s_0\": 2.29972,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 1.0,\n            \"err_grueneisen_0\": 0.03,\n            \"err_q_0\": 0.2,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.1,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fayalite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1370519.0,\n            \"V_0\": 4.629e-05,\n            \"K_0\": 1.349622e11,\n            \"Kprime_0\": 4.21796,\n            \"Debye_0\": 618.7007,\n            \"grueneisen_0\": 1.06023,\n            \"q_0\": 3.6466,\n            \"G_0\": 50899990000.0,\n            \"Gprime_0\": 1.46257,\n            \"eta_s_0\": 1.02497,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 26.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 2.0,\n            \"err_grueneisen_0\": 0.07,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 0.6,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Wadsleyite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2027837.0,\n            \"V_0\": 4.0515e-05,\n            \"K_0\": 1.686948e11,\n            \"Kprime_0\": 4.3229,\n            \"Debye_0\": 843.4973,\n            \"grueneisen_0\": 1.2061,\n            \"q_0\": 2.0188,\n            \"G_0\": 1.12e11,\n            \"Gprime_0\": 1.44424,\n            \"eta_s_0\": 2.63683,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 3000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 7.0,\n            \"err_grueneisen_0\": 0.09,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.2,\n            \"err_eta_s_0\": 0.4,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Wadsleyite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1364668.0,\n            \"V_0\": 4.28e-05,\n            \"K_0\": 1.68591e11,\n            \"Kprime_0\": 4.3229,\n            \"Debye_0\": 665.4492,\n            \"grueneisen_0\": 1.2061,\n            \"q_0\": 2.0188,\n            \"G_0\": 72000000000.0,\n            \"Gprime_0\": 1.44424,\n            \"eta_s_0\": 1.04017,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 26.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 7000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 13000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 21.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 12000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Ringwoodite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2017557.0,\n            \"V_0\": 3.9493e-05,\n            \"K_0\": 1.849009e11,\n            \"Kprime_0\": 4.22035,\n            \"Debye_0\": 877.7094,\n            \"grueneisen_0\": 1.10791,\n            \"q_0\": 2.3914,\n            \"G_0\": 1.23e11,\n            \"Gprime_0\": 1.35412,\n            \"eta_s_0\": 2.30461,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 8.0,\n            \"err_grueneisen_0\": 0.1,\n            \"err_q_0\": 0.4,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.5,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Ringwoodite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1362772.0,\n            \"V_0\": 4.186e-05,\n            \"K_0\": 2.13412e11,\n            \"Kprime_0\": 4.22035,\n            \"Debye_0\": 677.7177,\n            \"grueneisen_0\": 1.27193,\n            \"q_0\": 2.3914,\n            \"G_0\": 92000000000.0,\n            \"Gprime_0\": 1.35412,\n            \"eta_s_0\": 1.77249,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 26.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 7000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 8.0,\n            \"err_grueneisen_0\": 0.23,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Enstatite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2913596.0,\n            \"V_0\": 6.2676e-05,\n            \"K_0\": 1.070768e11,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 812.1848,\n            \"grueneisen_0\": 0.78479,\n            \"q_0\": 3.43846,\n            \"G_0\": 76800000000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 2.50453,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.4,\n            \"err_Debye_0\": 4.0,\n            \"err_grueneisen_0\": 0.04,\n            \"err_q_0\": 0.4,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.1,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Ferrosilite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2225718.0,\n            \"V_0\": 6.5941e-05,\n            \"K_0\": 1.005386e11,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 674.4769,\n            \"grueneisen_0\": 0.71889,\n            \"q_0\": 3.43846,\n            \"G_0\": 52000000000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 1.07706,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 26.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 4000000000.0,\n            \"err_K_prime_0\": 0.5,\n            \"err_Debye_0\": 10.0,\n            \"err_grueneisen_0\": 0.08,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 5000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgAl2SiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Tschermaks\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3002470.0,\n            \"V_0\": 5.914e-05,\n            \"K_0\": 1.070768e11,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 783.8404,\n            \"grueneisen_0\": 0.78479,\n            \"q_0\": 3.43846,\n            \"G_0\": 95950860000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 2.49099,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 9000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 24.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaMgSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Ortho_Diopside\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3015827.0,\n            \"V_0\": 6.8054e-05,\n            \"K_0\": 1.070768e11,\n            \"Kprime_0\": 7.02751,\n            \"Debye_0\": 744.6988,\n            \"grueneisen_0\": 0.78479,\n            \"q_0\": 3.43846,\n            \"G_0\": 58458950000.0,\n            \"Gprime_0\": 1.54596,\n            \"eta_s_0\": 1.36161,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 9.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaMgSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Diopside\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3029531.0,\n            \"V_0\": 6.6039e-05,\n            \"K_0\": 1.122413e11,\n            \"Kprime_0\": 5.23885,\n            \"Debye_0\": 781.6146,\n            \"grueneisen_0\": 0.95873,\n            \"q_0\": 1.52852,\n            \"G_0\": 67000000000.0,\n            \"Gprime_0\": 1.37293,\n            \"eta_s_0\": 1.57351,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 5000000000.0,\n            \"err_K_prime_0\": 1.8,\n            \"err_Debye_0\": 3.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 2.0,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaFeSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Hedenbergite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2677330.0,\n            \"V_0\": 6.7867e-05,\n            \"K_0\": 1.192555e11,\n            \"Kprime_0\": 5.23885,\n            \"Debye_0\": 701.5851,\n            \"grueneisen_0\": 0.93516,\n            \"q_0\": 1.52852,\n            \"G_0\": 61000000000.0,\n            \"Gprime_0\": 1.17647,\n            \"eta_s_0\": 1.5703,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 45000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 4000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 2.0,\n            \"err_grueneisen_0\": 0.06,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Clinoenstatite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2905918.0,\n            \"V_0\": 6.25e-05,\n            \"K_0\": 1.122413e11,\n            \"Kprime_0\": 5.23885,\n            \"Debye_0\": 805.0547,\n            \"grueneisen_0\": 0.95873,\n            \"q_0\": 1.52852,\n            \"G_0\": 79496860000.0,\n            \"Gprime_0\": 1.62901,\n            \"eta_s_0\": 1.69074,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 10.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaAl2SiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Ca_Tschermaks\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -3120253.0,\n            \"V_0\": 6.3574e-05,\n            \"K_0\": 1.122413e11,\n            \"Kprime_0\": 5.23885,\n            \"Debye_0\": 803.6626,\n            \"grueneisen_0\": 0.78126,\n            \"q_0\": 1.52852,\n            \"G_0\": 75160660000.0,\n            \"Gprime_0\": 1.54016,\n            \"eta_s_0\": 1.9672,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 11.525, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 5000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 5.0,\n            \"err_grueneisen_0\": 0.0,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"NaAlSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Jadeite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2855192.0,\n            \"V_0\": 6.0508e-05,\n            \"K_0\": 1.422873e11,\n            \"Kprime_0\": 5.23885,\n            \"Debye_0\": 820.7623,\n            \"grueneisen_0\": 0.903,\n            \"q_0\": 0.39234,\n            \"G_0\": 85000000000.0,\n            \"Gprime_0\": 1.37398,\n            \"eta_s_0\": 2.18453,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 12.0,\n            \"err_grueneisen_0\": 0.08,\n            \"err_q_0\": 1.4,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"HP_Clinoenstatite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2905788.0,\n            \"V_0\": 6.076e-05,\n            \"K_0\": 1.160254e11,\n            \"Kprime_0\": 6.23685,\n            \"Debye_0\": 824.4439,\n            \"grueneisen_0\": 1.12473,\n            \"q_0\": 0.20401,\n            \"G_0\": 87927170000.0,\n            \"Gprime_0\": 1.84119,\n            \"eta_s_0\": 2.14181,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.3,\n            \"err_Debye_0\": 7.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.5,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.5,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"HP_Clinoferrosilite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2222183.0,\n            \"V_0\": 6.385413e-05,\n            \"K_0\": 1.160254e11,\n            \"Kprime_0\": 6.23685,\n            \"Debye_0\": 691.564,\n            \"grueneisen_0\": 1.12473,\n            \"q_0\": 0.20401,\n            \"G_0\": 70623090000.0,\n            \"Gprime_0\": 1.84119,\n            \"eta_s_0\": 0.79216,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 26.76, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 11.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Ca_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1463358.0,\n            \"V_0\": 2.745e-05,\n            \"K_0\": 2.36e11,\n            \"Kprime_0\": 3.9,\n            \"Debye_0\": 795.779,\n            \"grueneisen_0\": 1.88839,\n            \"q_0\": 0.89769,\n            \"G_0\": 1.568315e11,\n            \"Gprime_0\": 2.22713,\n            \"eta_s_0\": 1.28818,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 8000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 4000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 44.0,\n            \"err_grueneisen_0\": 0.07,\n            \"err_q_0\": 1.6,\n            \"err_G_0\": 12000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Akimotoite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1410850.0,\n            \"V_0\": 2.6354e-05,\n            \"K_0\": 2.10706e11,\n            \"Kprime_0\": 5.62088,\n            \"Debye_0\": 935.9778,\n            \"grueneisen_0\": 1.18984,\n            \"q_0\": 2.34514,\n            \"G_0\": 1.32e11,\n            \"Gprime_0\": 1.57889,\n            \"eta_s_0\": 2.80782,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 4000000000.0,\n            \"err_K_prime_0\": 0.8,\n            \"err_Debye_0\": 12.0,\n            \"err_grueneisen_0\": 0.13,\n            \"err_q_0\": 0.8,\n            \"err_G_0\": 8000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Akimotoite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1067598.0,\n            \"V_0\": 2.6854e-05,\n            \"K_0\": 2.10706e11,\n            \"Kprime_0\": 5.62088,\n            \"Debye_0\": 887.8709,\n            \"grueneisen_0\": 1.18984,\n            \"q_0\": 2.34514,\n            \"G_0\": 1.523046e11,\n            \"Gprime_0\": 1.57889,\n            \"eta_s_0\": 3.5716,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 21000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 120.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"AlAlO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Corundum\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1582454.0,\n            \"V_0\": 2.5577e-05,\n            \"K_0\": 2.525457e11,\n            \"Kprime_0\": 4.33728,\n            \"Debye_0\": 932.5696,\n            \"grueneisen_0\": 1.32442,\n            \"q_0\": 1.30316,\n            \"G_0\": 1.632e11,\n            \"Gprime_0\": 1.64174,\n            \"eta_s_0\": 2.8316,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 5000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 3.0,\n            \"err_grueneisen_0\": 0.04,\n            \"err_q_0\": 0.2,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.2,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Pyrope\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5936538.0,\n            \"V_0\": 0.00011308,\n            \"K_0\": 1.702396e11,\n            \"Kprime_0\": 4.11067,\n            \"Debye_0\": 823.2102,\n            \"grueneisen_0\": 1.01424,\n            \"q_0\": 1.42169,\n            \"G_0\": 93699990000.0,\n            \"Gprime_0\": 1.35756,\n            \"eta_s_0\": 0.98186,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 10000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.3,\n            \"err_Debye_0\": 4.0,\n            \"err_grueneisen_0\": 0.06,\n            \"err_q_0\": 0.5,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.2,\n            \"err_eta_s_0\": 0.3,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Almandine\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -4935516.0,\n            \"V_0\": 0.00011543,\n            \"K_0\": 1.738963e11,\n            \"Kprime_0\": 4.91341,\n            \"Debye_0\": 741.356,\n            \"grueneisen_0\": 1.06495,\n            \"q_0\": 1.42169,\n            \"G_0\": 96000000000.0,\n            \"Gprime_0\": 1.40927,\n            \"eta_s_0\": 2.09292,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 40.14, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 29000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 5.0,\n            \"err_grueneisen_0\": 0.06,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Ca3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Grossular\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -6277935.0,\n            \"V_0\": 0.00012512,\n            \"K_0\": 1.670622e11,\n            \"Kprime_0\": 3.91544,\n            \"Debye_0\": 822.743,\n            \"grueneisen_0\": 1.05404,\n            \"q_0\": 1.88887,\n            \"G_0\": 1.09e11,\n            \"Gprime_0\": 1.16274,\n            \"eta_s_0\": 2.38418,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 11000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 2.0,\n            \"err_grueneisen_0\": 0.06,\n            \"err_q_0\": 0.2,\n            \"err_G_0\": 4000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.1,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg4Si4O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Majorite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5691614.0,\n            \"V_0\": 0.000114324,\n            \"K_0\": 1.651183e11,\n            \"Kprime_0\": 4.21183,\n            \"Debye_0\": 822.458,\n            \"grueneisen_0\": 0.97682,\n            \"q_0\": 1.53581,\n            \"G_0\": 84999990000.0,\n            \"Gprime_0\": 1.42969,\n            \"eta_s_0\": 1.0178,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 10000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 3000000000.0,\n            \"err_K_prime_0\": 0.3,\n            \"err_Debye_0\": 4.0,\n            \"err_grueneisen_0\": 0.07,\n            \"err_q_0\": 0.5,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.2,\n            \"err_eta_s_0\": 0.3,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Na2Al2Si4O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Jd_Majorite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -5518542.0,\n            \"V_0\": 0.00011094,\n            \"K_0\": 1.770772e11,\n            \"Kprime_0\": 4.11067,\n            \"Debye_0\": 895.914,\n            \"grueneisen_0\": 1.01424,\n            \"q_0\": 1.42169,\n            \"G_0\": 1.25e11,\n            \"Gprime_0\": 1.35756,\n            \"eta_s_0\": 3.30517,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 14000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 7000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 18.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 4000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"SiO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Quartz\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -858853.4,\n            \"V_0\": 2.367003e-05,\n            \"K_0\": 49547430000.0,\n            \"Kprime_0\": 4.33155,\n            \"Debye_0\": 816.3307,\n            \"grueneisen_0\": -0.00296,\n            \"q_0\": 1.0,\n            \"G_0\": 44856170000.0,\n            \"Gprime_0\": 0.95315,\n            \"eta_s_0\": 2.36469,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"landau\", {\"Tc_0\": 847.0, \"S_D\": 5.164, \"V_D\": 1.222e-06}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 31.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"SiO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Coesite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -855068.5,\n            \"V_0\": 2.0657e-05,\n            \"K_0\": 1.135856e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 852.4267,\n            \"grueneisen_0\": 0.39157,\n            \"q_0\": 1.0,\n            \"G_0\": 61600010000.0,\n            \"Gprime_0\": 1.24734,\n            \"eta_s_0\": 2.39793,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 9.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"SiO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Stishovite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -818984.6,\n            \"V_0\": 1.4017e-05,\n            \"K_0\": 3.143352e11,\n            \"Kprime_0\": 3.75122,\n            \"Debye_0\": 1107.824,\n            \"grueneisen_0\": 1.37466,\n            \"q_0\": 2.83517,\n            \"G_0\": 2.2e11,\n            \"Gprime_0\": 1.93334,\n            \"eta_s_0\": 4.60904,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"landau\", {\"Tc_0\": -4250.0, \"S_D\": 0.012, \"V_D\": 1e-09}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 8000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 13.0,\n            \"err_grueneisen_0\": 0.17,\n            \"err_q_0\": 2.2,\n            \"err_G_0\": 12000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"SiO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Seifertite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -794335.4,\n            \"V_0\": 1.367e-05,\n            \"K_0\": 3.275843e11,\n            \"Kprime_0\": 4.01553,\n            \"Debye_0\": 1140.772,\n            \"grueneisen_0\": 1.37466,\n            \"q_0\": 2.83517,\n            \"G_0\": 2.274532e11,\n            \"Gprime_0\": 1.76965,\n            \"eta_s_0\": 4.97108,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 2000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 16.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1368283.0,\n            \"V_0\": 2.4445e-05,\n            \"K_0\": 2.505264e11,\n            \"Kprime_0\": 4.14,\n            \"Debye_0\": 905.9412,\n            \"grueneisen_0\": 1.56508,\n            \"q_0\": 1.10945,\n            \"G_0\": 1.729e11,\n            \"Gprime_0\": 1.69037,\n            \"eta_s_0\": 2.56536,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 3000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 5.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.3,\n            \"err_G_0\": 2000000000.0,\n            \"err_Gprime_0\": 0.0,\n            \"err_eta_s_0\": 0.3,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1040920.0,\n            \"V_0\": 2.5485e-05,\n            \"K_0\": 2.721152e11,\n            \"Kprime_0\": 4.14,\n            \"Debye_0\": 870.8122,\n            \"grueneisen_0\": 1.56508,\n            \"q_0\": 1.10945,\n            \"G_0\": 1.326849e11,\n            \"Gprime_0\": 1.37485,\n            \"eta_s_0\": 2.29211,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 6000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 40000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 26.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 40000000000.0,\n            \"err_Gprime_0\": 0.0,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"AlAlO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Al_perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1533878.0,\n            \"V_0\": 2.4944e-05,\n            \"K_0\": 2.582e11,\n            \"Kprime_0\": 4.14,\n            \"Debye_0\": 886.4601,\n            \"grueneisen_0\": 1.56508,\n            \"q_0\": 1.10945,\n            \"G_0\": 1.713116e11,\n            \"Gprime_0\": 1.49706,\n            \"eta_s_0\": 2.47126,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 2000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 0.5,\n            \"err_Debye_0\": 7.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.5,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Post_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1348641.0,\n            \"V_0\": 2.4419e-05,\n            \"K_0\": 2.312e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 855.8173,\n            \"grueneisen_0\": 1.89155,\n            \"q_0\": 1.09081,\n            \"G_0\": 1.50167e11,\n            \"Gprime_0\": 1.97874,\n            \"eta_s_0\": 1.16704,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 7.0,\n            \"err_grueneisen_0\": 0.03,\n            \"err_q_0\": 0.1,\n            \"err_G_0\": 4000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.2,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Post_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -981806.9,\n            \"V_0\": 2.5459e-05,\n            \"K_0\": 2.312e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 781.3465,\n            \"grueneisen_0\": 1.89155,\n            \"q_0\": 1.09081,\n            \"G_0\": 1.295e11,\n            \"Gprime_0\": 1.44675,\n            \"eta_s_0\": 1.36382,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 21000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 52.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 5000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"AlAlO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Al_Post_Perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1377582.0,\n            \"V_0\": 2.3847e-05,\n            \"K_0\": 2.49e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 762.1951,\n            \"grueneisen_0\": 1.64573,\n            \"q_0\": 1.09081,\n            \"G_0\": 91965310000.0,\n            \"Gprime_0\": 1.81603,\n            \"eta_s_0\": 2.83762,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 20000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 9.0,\n            \"err_grueneisen_0\": 0.02,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.2,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Periclase\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -569444.6,\n            \"V_0\": 1.1244e-05,\n            \"K_0\": 1.613836e11,\n            \"Kprime_0\": 3.84045,\n            \"Debye_0\": 767.0977,\n            \"grueneisen_0\": 1.36127,\n            \"q_0\": 1.7217,\n            \"G_0\": 1.309e11,\n            \"Gprime_0\": 2.1438,\n            \"eta_s_0\": 2.81765,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 0.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 3000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 9.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.2,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 0.2,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Wuestite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -242146.0,\n            \"V_0\": 1.2264e-05,\n            \"K_0\": 1.794442e11,\n            \"Kprime_0\": 4.9376,\n            \"Debye_0\": 454.1592,\n            \"grueneisen_0\": 1.53047,\n            \"q_0\": 1.7217,\n            \"G_0\": 59000000000.0,\n            \"Gprime_0\": 1.44673,\n            \"eta_s_0\": -0.05731,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 1000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.2,\n            \"err_Debye_0\": 21.0,\n            \"err_grueneisen_0\": 0.13,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgAl2O4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Mg_Ca_Ferrite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2122169.0,\n            \"V_0\": 3.6177e-05,\n            \"K_0\": 2.106663e11,\n            \"Kprime_0\": 4.0528,\n            \"Debye_0\": 838.6291,\n            \"grueneisen_0\": 1.31156,\n            \"q_0\": 1.0,\n            \"G_0\": 1.29826e11,\n            \"Gprime_0\": 1.75878,\n            \"eta_s_0\": 2.1073,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 16.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeAl2O4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Fe_Ca_Ferrite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1790284.0,\n            \"V_0\": 3.7258e-05,\n            \"K_0\": 2.106663e11,\n            \"Kprime_0\": 4.0528,\n            \"Debye_0\": 804.1986,\n            \"grueneisen_0\": 1.31156,\n            \"q_0\": 1.0,\n            \"G_0\": 1.535236e11,\n            \"Gprime_0\": 1.75878,\n            \"eta_s_0\": 3.0268,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.property_modifiers = [\n            [\"linear\", {\"delta_E\": 0.0, \"delta_S\": 13.38, \"delta_V\": 0.0}]\n        ]\n\n        self.uncertainties = {\n            \"err_F_0\": 25000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 10000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 69.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"NaAlSiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Na_Ca_Ferrite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1844129.0,\n            \"V_0\": 3.627e-05,\n            \"K_0\": 1.613385e11,\n            \"Kprime_0\": 4.32479,\n            \"Debye_0\": 812.4769,\n            \"grueneisen_0\": 0.69428,\n            \"q_0\": 1.0,\n            \"G_0\": 1.220049e11,\n            \"Gprime_0\": 2.07687,\n            \"eta_s_0\": 2.79016,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 11000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.1,\n            \"err_Debye_0\": 51.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.1,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Al2SiO5\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Kyanite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -2446058.0,\n            \"V_0\": 4.4227e-05,\n            \"K_0\": 1.6e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 943.1665,\n            \"grueneisen_0\": 0.9255,\n            \"q_0\": 1.0,\n            \"G_0\": 1.204033e11,\n            \"Gprime_0\": 1.7308,\n            \"eta_s_0\": 2.96665,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 4000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 0.0,\n            \"err_Debye_0\": 8.0,\n            \"err_grueneisen_0\": 0.07,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 10000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"NaAlSiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Nepheline\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1992104.0,\n            \"V_0\": 5.46684e-05,\n            \"K_0\": 53077990000.0,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 700.9422,\n            \"grueneisen_0\": 0.69428,\n            \"q_0\": 1.0,\n            \"G_0\": 30700000000.0,\n            \"Gprime_0\": 1.33031,\n            \"eta_s_0\": 0.6291,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\n            \"err_F_0\": 3000.0,\n            \"err_V_0\": 0.0,\n            \"err_K_0\": 1000000000.0,\n            \"err_K_prime_0\": 1.0,\n            \"err_Debye_0\": 13.0,\n            \"err_grueneisen_0\": 0.03,\n            \"err_q_0\": 1.0,\n            \"err_G_0\": 1000000000.0,\n            \"err_Gprime_0\": 0.5,\n            \"err_eta_s_0\": 1.0,\n        }\n        Mineral.__init__(self)",
  "class periclase(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 11.24e-6,\n            \"K_0\": 161.0e9,\n            \"Kprime_0\": 3.9,\n            \"G_0\": 130.9e9,\n            \"Gprime_0\": 1.92,\n            \"molar_mass\": 0.0403,\n            \"n\": 2,\n            \"Debye_0\": 773.0,\n            \"grueneisen_0\": 1.5,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.3,\n        }\n        Mineral.__init__(self)",
  "class wuestite(Mineral):\n\n    \"\"\"\n    Murakami 2013 and references therein\n    \"\"\"\n\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 12.06e-6,\n            \"K_0\": 152.0e9,\n            \"Kprime_0\": 4.9,\n            \"G_0\": 47.0e9,\n            \"Gprime_0\": 0.7,\n            \"molar_mass\": 0.0718,\n            \"n\": 2,\n            \"Debye_0\": 455.0,\n            \"grueneisen_0\": 1.28,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 0.8,\n        }\n\n        Mineral.__init__(self)",
  "class mg_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 24.45e-6,\n            \"K_0\": 253.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 172.9e9,\n            \"Gprime_0\": 1.56,\n            \"molar_mass\": 0.1000,\n            \"n\": 5,\n            \"Debye_0\": 1100.0,\n            \"grueneisen_0\": 1.4,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.6,\n        }\n\n        Mineral.__init__(self)",
  "class fe_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 25.49e-6,\n            \"K_0\": 281.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 138.0e9,\n            \"Gprime_0\": 1.7,\n            \"molar_mass\": 0.1319,\n            \"n\": 5,\n            \"Debye_0\": 841.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.1,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 11.24e-6,\n            \"K_0\": 161.0e9,\n            \"Kprime_0\": 3.9,\n            \"G_0\": 130.9e9,\n            \"Gprime_0\": 1.92,\n            \"molar_mass\": 0.0403,\n            \"n\": 2,\n            \"Debye_0\": 773.0,\n            \"grueneisen_0\": 1.5,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 2.3,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 12.06e-6,\n            \"K_0\": 152.0e9,\n            \"Kprime_0\": 4.9,\n            \"G_0\": 47.0e9,\n            \"Gprime_0\": 0.7,\n            \"molar_mass\": 0.0718,\n            \"n\": 2,\n            \"Debye_0\": 455.0,\n            \"grueneisen_0\": 1.28,\n            \"q_0\": 1.5,\n            \"eta_s_0\": 0.8,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 24.45e-6,\n            \"K_0\": 253.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 172.9e9,\n            \"Gprime_0\": 1.56,\n            \"molar_mass\": 0.1000,\n            \"n\": 5,\n            \"Debye_0\": 1100.0,\n            \"grueneisen_0\": 1.4,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.6,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb2\",\n            \"V_0\": 25.49e-6,\n            \"K_0\": 281.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 138.0e9,\n            \"Gprime_0\": 1.7,\n            \"molar_mass\": 0.1319,\n            \"n\": 5,\n            \"Debye_0\": 841.0,\n            \"grueneisen_0\": 1.48,\n            \"q_0\": 1.4,\n            \"eta_s_0\": 2.1,\n        }\n\n        Mineral.__init__(self)",
  "class ferropericlase(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"ferropericlase (FM)\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.per(), \"[Mg]O\"],\n                [HP_2011_ds62.fper(), \"[Fe]O\"],\n            ],\n            energy_interaction=[[18.0e3]],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class plagioclase(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"plagioclase (NCAS)\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.an(), \"[Ca][Al]2Si2O8\"],\n                [HP_2011_ds62.abh(), \"[Na][Al1/2Si1/2]2Si2O8\"],\n            ],  # Al-avoidance model\n            alphas=[0.39, 1.0],\n            energy_interaction=[[22.4e3]],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class clinopyroxene(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"clinopyroxene (NCFMASCrO)\"\n\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.di(), \"[Mg][Ca][Si]1/2O6\"],\n                [cfs(), \"[Fe][Fe][Si]1/2O6\"],\n                [HP_2011_ds62.cats(), \"[Al][Ca][Si1/2Al1/2]1/2O6\"],\n                [crdi(), \"[Cr][Ca][Si1/2Al1/2]1/2O6\"],\n                [cess(), \"[Fef][Ca][Si1/2Al1/2]1/2O6\"],\n                [HP_2011_ds62.jd(), \"[Al][Na][Si]1/2O6\"],\n                [cen(), \"[Mg][Mg][Si]1/2O6\"],\n                [cfm(), \"[Mg][Fe][Si]1/2O6\"],\n            ],  # note cfm ordered endmember\n            alphas=[1.2, 1.0, 1.9, 1.9, 1.9, 1.2, 1.0, 1.0],\n            energy_interaction=[\n                [20.0e3, 12.3e3, 8.0e3, 8.0e3, 26.0e3, 29.8e3, 18.0e3],\n                [25.0e3, 34.0e3, 34.0e3, 24.0e3, 7.0e3, 4.0e3],\n                [2.0e3, 2.0e3, 6.0e3, 45.7e3, 27.0e3],\n                [2.0e3, 3.0e3, 48.0e3, 36.0e3],\n                [3.0e3, 58.0e3, 36.0e3],\n                [40.0e3, 40.0e3],\n                [4.0e3],\n            ],\n            volume_interaction=[\n                [0.0, -0.1e-5, 0.0, 0.0, 0.0, -0.03e-5, 0.0],\n                [-0.1e-5, 0.0, 0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, -0.29e-5, -0.1e-5],\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0],\n                [0.0],\n            ],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class cfs(CombinedMineral):\n    def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"clinoferrosilite\",\n            mineral_list=[HP_2011_ds62.fs()],\n            molar_amounts=[1.0],\n            free_energy_adjustment=[3.8e3, 3.0, 0.03e-5],\n        )",
  "class crdi(CombinedMineral):\n    def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"chromium diopside\",\n            mineral_list=[HP_2011_ds62.cats(), HP_2011_ds62.kos(), HP_2011_ds62.jd()],\n            molar_amounts=[1.0, 1.0, -1.0],\n            free_energy_adjustment=[-3.0e3, 0.0, 0.0],\n        )",
  "class cess(CombinedMineral):\n    def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"ferric diopside\",\n            mineral_list=[HP_2011_ds62.cats(), HP_2011_ds62.acm(), HP_2011_ds62.jd()],\n            molar_amounts=[1.0, 1.0, -1.0],\n            free_energy_adjustment=[-6.0e3, 0.0, 0.0],\n        )",
  "class cen(CombinedMineral):\n    def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"clinoenstatite\",\n            mineral_list=[HP_2011_ds62.en()],\n            molar_amounts=[1.0],\n            free_energy_adjustment=[3.5e3, 2.0, 0.048e-5],\n        )",
  "class cfm(CombinedMineral):\n    def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"ordered clinoferroenstatite\",\n            mineral_list=[HP_2011_ds62.en(), HP_2011_ds62.fs()],\n            molar_amounts=[0.5, 0.5],\n            free_energy_adjustment=[-3.0e3, 0.0, 0.0],\n        )",
  "class olivine(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"olivine (FMS)\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.fo(), \"[Mg]2SiO4\"],\n                [HP_2011_ds62.fa(), \"[Fe]2SiO4\"],\n            ],\n            energy_interaction=[[9.0e3]],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class spinel(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"disordered spinel (CFMASO)\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.sp(), \"[Al2/3Mg1/3]3O4\"],\n                [HP_2011_ds62.herc(), \"[Al2/3Fe1/3]3O4\"],\n                [HP_2011_ds62.mt(), \"[Fef2/3Fe1/3]3O4\"],\n                [HP_2011_ds62.picr(), \"[Cr2/3Mg1/3]3O4\"],\n            ],\n            energy_interaction=[[4.0e3, 56.0e3, 39.0e3], [32.0e3, 27.0e3], [36.0e3]],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class garnet(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"garnet (CFMASCrO, low pressure)\"\n\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.py(), \"[Mg]3[Al]2Si3O12\"],\n                [HP_2011_ds62.alm(), \"[Fe]3[Al]2Si3O12\"],\n                [HP_2011_ds62.gr(), \"[Ca]3[Al]2Si3O12\"],\n                [HP_2011_ds62.andr(), \"[Ca]3[Fef]2Si3O12\"],\n                [HP_2011_ds62.knor(), \"[Mg]3[Cr]2Si3O12\"],\n            ],\n            energy_interaction=[\n                [4.0e3, 35.0e3, 91.0e3, 2.0e3],\n                [4.0e3, 60.0e3, 6.0e3],\n                [2.0e3, 47.0e3],\n                [101.0e3],\n            ],\n            entropy_interaction=[\n                [0.0, 0.0, -1.7, 0.0],\n                [0.0, -1.7, 0.0],\n                [0.0, 33.8],\n                [32.1],\n            ],  # note huge entropy additions! (and sign change from a + bT + cP format)\n            volume_interaction=[\n                [0.1e-5, 0.1e-5, 0.032e-5, 0.0],\n                [0.1e-5, 0.032e-5, 0.01e-5],\n                [0.0, 0.221e-5],\n                [0.153e-5],\n            ],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class orthopyroxene(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"orthopyroxene (CFMASCrO)\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.en(), \"[Mg][Mg][Si]0.5Si1.5O6\"],\n                [HP_2011_ds62.fs(), \"[Fe][Fe][Si]0.5Si1.5O6\"],\n                [fm(), \"[Fe][Mg][Si]0.5Si1.5O6\"],\n                [odi(), \"[Mg][Ca][Si]0.5Si1.5O6\"],\n                [HP_2011_ds62.mgts(), \"[Al][Mg][Si1/2Al1/2]0.5Si1.5O6\"],\n                [cren(), \"[Cr][Mg][Si1/2Al1/2]0.5Si1.5O6\"],\n                [mess(), \"[Fef][Mg][Si1/2Al1/2]0.5Si1.5O6\"],\n            ],  # fm ordered phase, fake T-site multiplicity\n            alphas=[1.0, 1.0, 1.0, 1.2, 1.0, 1.0, 1.0],\n            energy_interaction=[\n                [5.2e3, 4.0e3, 32.2e3, 13.0e3, 8.0e3, 8.0e3],\n                [4.0e3, 24.0e3, 7.0e3, 10.0e3, 10.0e3],\n                [18.0e3, 2.0e3, 12.0e3, 12.0e3],\n                [75.4e3, 30.0e3, 30.0e3],\n                [2.0e3, 2.0e3],\n                [2.0e3],\n            ],\n            volume_interaction=[\n                [0.0, 0.0, 0.12e-5, -0.15e-5, 0.0, 0.0],\n                [0.0, 0.0, -0.15e-5, 0.0, 0.0],\n                [0.0, -0.15e-5, 0.0, 0.0],\n                [-0.94e-5, 0.0, 0.0],\n                [0.0, 0.0],\n                [0.0],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class fm(CombinedMineral):\n    def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"ordered ferroenstatite\",\n            mineral_list=[HP_2011_ds62.en(), HP_2011_ds62.fs()],\n            molar_amounts=[0.5, 0.5],\n            free_energy_adjustment=[-6.0e3, 0.0, 0.0],\n        )",
  "class odi(CombinedMineral):\n    def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"orthodiopside\",\n            mineral_list=[HP_2011_ds62.di()],\n            molar_amounts=[1.0],\n            free_energy_adjustment=[-0.1e3, -0.211, 0.005e-5],\n        )",
  "class cren(CombinedMineral):\n    def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"chromium enstatite\",\n            mineral_list=[HP_2011_ds62.mgts(), HP_2011_ds62.kos(), HP_2011_ds62.jd()],\n            molar_amounts=[1.0, 1.0, -1.0],\n            free_energy_adjustment=[3.0e3, 0.0, 0.0],\n        )",
  "class mess(CombinedMineral):\n    def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"ferrienstatite\",\n            mineral_list=[HP_2011_ds62.mgts(), HP_2011_ds62.acm(), HP_2011_ds62.jd()],\n            molar_amounts=[1.0, 1.0, -1.0],\n            free_energy_adjustment=[-15.0e3, 0.0, 0.15e-5],\n        )",
  "def construct_combined_covariance(\n    original_covariance_dictionary, combined_mineral_list\n):\n    \"\"\"\n    This function takes a dictionary containing a list of endmember_names\n    and a covariance_matrix, and a list of CombinedMineral instances,\n    and creates an updated covariance dictionary containing those\n    CombinedMinerals\n\n    Parameters\n    ----------\n    original_covariance_dictionary : dictionary\n        Contains a list of strings of endmember_names of length n\n        and a 2D numpy array covariance_matrix of shape n x n\n\n    combined_mineral_list : list of instances of :class:`burnman.CombinedMineral`\n        List of minerals to be added to the covariance matrix\n\n    Returns\n    -------\n    cov : dictionary\n        Updated covariance dictionary, with the same keys as the original\n\n    \"\"\"\n    cov_orig = original_covariance_dictionary\n\n    # Update names\n    cov = {\"endmember_names\": copy(cov_orig[\"endmember_names\"])}\n    for c in combined_mineral_list:\n        cov[\"endmember_names\"].append(c.name)\n\n    # Update covariance matrix\n    A = np.identity(len(cov_orig[\"endmember_names\"]))\n    for i, indices in enumerate(\n        [\n            [\n                cov_orig[\"endmember_names\"].index(name)\n                for name in [mbr[0].params[\"name\"] for mbr in c.mixture.endmembers]\n            ]\n            for c in combined_mineral_list\n        ]\n    ):\n        B = np.zeros(len(cov_orig[\"endmember_names\"]))\n        B[indices] = combined_mineral_list[i].mixture.molar_fractions\n        A = np.vstack((A, B))\n\n    cov[\"covariance_matrix\"] = A.dot(cov_orig[\"covariance_matrix\"]).dot(A.T)\n\n    return cov",
  "def cov():\n    \"\"\"\n    A function which returns the variance-covariance matrix of the\n    zero-point energies of all the endmembers in the dataset.\n    Derived from HP_2011_ds62, modified to include all\n    the new CombinedMinerals.\n\n    Returns\n    -------\n    cov : dictionary\n        Dictionary keys are:\n        - endmember_names: a list of endmember names, and\n        - covariance_matrix: a 2D variance-covariance array for the endmember enthalpies of formation\n    \"\"\"\n    return construct_combined_covariance(\n        original_covariance_dictionary=HP_2011_ds62.cov(),\n        combined_mineral_list=[\n            cfs(),\n            crdi(),\n            cess(),\n            cen(),\n            cfm(),\n            fm(),\n            odi(),\n            cren(),\n            mess(),\n        ],\n    )",
  "def __init__(self, molar_fractions=None):\n        self.name = \"ferropericlase (FM)\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.per(), \"[Mg]O\"],\n                [HP_2011_ds62.fper(), \"[Fe]O\"],\n            ],\n            energy_interaction=[[18.0e3]],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"plagioclase (NCAS)\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.an(), \"[Ca][Al]2Si2O8\"],\n                [HP_2011_ds62.abh(), \"[Na][Al1/2Si1/2]2Si2O8\"],\n            ],  # Al-avoidance model\n            alphas=[0.39, 1.0],\n            energy_interaction=[[22.4e3]],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"clinopyroxene (NCFMASCrO)\"\n\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.di(), \"[Mg][Ca][Si]1/2O6\"],\n                [cfs(), \"[Fe][Fe][Si]1/2O6\"],\n                [HP_2011_ds62.cats(), \"[Al][Ca][Si1/2Al1/2]1/2O6\"],\n                [crdi(), \"[Cr][Ca][Si1/2Al1/2]1/2O6\"],\n                [cess(), \"[Fef][Ca][Si1/2Al1/2]1/2O6\"],\n                [HP_2011_ds62.jd(), \"[Al][Na][Si]1/2O6\"],\n                [cen(), \"[Mg][Mg][Si]1/2O6\"],\n                [cfm(), \"[Mg][Fe][Si]1/2O6\"],\n            ],  # note cfm ordered endmember\n            alphas=[1.2, 1.0, 1.9, 1.9, 1.9, 1.2, 1.0, 1.0],\n            energy_interaction=[\n                [20.0e3, 12.3e3, 8.0e3, 8.0e3, 26.0e3, 29.8e3, 18.0e3],\n                [25.0e3, 34.0e3, 34.0e3, 24.0e3, 7.0e3, 4.0e3],\n                [2.0e3, 2.0e3, 6.0e3, 45.7e3, 27.0e3],\n                [2.0e3, 3.0e3, 48.0e3, 36.0e3],\n                [3.0e3, 58.0e3, 36.0e3],\n                [40.0e3, 40.0e3],\n                [4.0e3],\n            ],\n            volume_interaction=[\n                [0.0, -0.1e-5, 0.0, 0.0, 0.0, -0.03e-5, 0.0],\n                [-0.1e-5, 0.0, 0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, -0.29e-5, -0.1e-5],\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0],\n                [0.0],\n            ],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"clinoferrosilite\",\n            mineral_list=[HP_2011_ds62.fs()],\n            molar_amounts=[1.0],\n            free_energy_adjustment=[3.8e3, 3.0, 0.03e-5],\n        )",
  "def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"chromium diopside\",\n            mineral_list=[HP_2011_ds62.cats(), HP_2011_ds62.kos(), HP_2011_ds62.jd()],\n            molar_amounts=[1.0, 1.0, -1.0],\n            free_energy_adjustment=[-3.0e3, 0.0, 0.0],\n        )",
  "def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"ferric diopside\",\n            mineral_list=[HP_2011_ds62.cats(), HP_2011_ds62.acm(), HP_2011_ds62.jd()],\n            molar_amounts=[1.0, 1.0, -1.0],\n            free_energy_adjustment=[-6.0e3, 0.0, 0.0],\n        )",
  "def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"clinoenstatite\",\n            mineral_list=[HP_2011_ds62.en()],\n            molar_amounts=[1.0],\n            free_energy_adjustment=[3.5e3, 2.0, 0.048e-5],\n        )",
  "def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"ordered clinoferroenstatite\",\n            mineral_list=[HP_2011_ds62.en(), HP_2011_ds62.fs()],\n            molar_amounts=[0.5, 0.5],\n            free_energy_adjustment=[-3.0e3, 0.0, 0.0],\n        )",
  "def __init__(self, molar_fractions=None):\n        self.name = \"olivine (FMS)\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.fo(), \"[Mg]2SiO4\"],\n                [HP_2011_ds62.fa(), \"[Fe]2SiO4\"],\n            ],\n            energy_interaction=[[9.0e3]],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"disordered spinel (CFMASO)\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.sp(), \"[Al2/3Mg1/3]3O4\"],\n                [HP_2011_ds62.herc(), \"[Al2/3Fe1/3]3O4\"],\n                [HP_2011_ds62.mt(), \"[Fef2/3Fe1/3]3O4\"],\n                [HP_2011_ds62.picr(), \"[Cr2/3Mg1/3]3O4\"],\n            ],\n            energy_interaction=[[4.0e3, 56.0e3, 39.0e3], [32.0e3, 27.0e3], [36.0e3]],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"garnet (CFMASCrO, low pressure)\"\n\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.py(), \"[Mg]3[Al]2Si3O12\"],\n                [HP_2011_ds62.alm(), \"[Fe]3[Al]2Si3O12\"],\n                [HP_2011_ds62.gr(), \"[Ca]3[Al]2Si3O12\"],\n                [HP_2011_ds62.andr(), \"[Ca]3[Fef]2Si3O12\"],\n                [HP_2011_ds62.knor(), \"[Mg]3[Cr]2Si3O12\"],\n            ],\n            energy_interaction=[\n                [4.0e3, 35.0e3, 91.0e3, 2.0e3],\n                [4.0e3, 60.0e3, 6.0e3],\n                [2.0e3, 47.0e3],\n                [101.0e3],\n            ],\n            entropy_interaction=[\n                [0.0, 0.0, -1.7, 0.0],\n                [0.0, -1.7, 0.0],\n                [0.0, 33.8],\n                [32.1],\n            ],  # note huge entropy additions! (and sign change from a + bT + cP format)\n            volume_interaction=[\n                [0.1e-5, 0.1e-5, 0.032e-5, 0.0],\n                [0.1e-5, 0.032e-5, 0.01e-5],\n                [0.0, 0.221e-5],\n                [0.153e-5],\n            ],\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"orthopyroxene (CFMASCrO)\"\n        self.solution_model = AsymmetricRegularSolution(\n            endmembers=[\n                [HP_2011_ds62.en(), \"[Mg][Mg][Si]0.5Si1.5O6\"],\n                [HP_2011_ds62.fs(), \"[Fe][Fe][Si]0.5Si1.5O6\"],\n                [fm(), \"[Fe][Mg][Si]0.5Si1.5O6\"],\n                [odi(), \"[Mg][Ca][Si]0.5Si1.5O6\"],\n                [HP_2011_ds62.mgts(), \"[Al][Mg][Si1/2Al1/2]0.5Si1.5O6\"],\n                [cren(), \"[Cr][Mg][Si1/2Al1/2]0.5Si1.5O6\"],\n                [mess(), \"[Fef][Mg][Si1/2Al1/2]0.5Si1.5O6\"],\n            ],  # fm ordered phase, fake T-site multiplicity\n            alphas=[1.0, 1.0, 1.0, 1.2, 1.0, 1.0, 1.0],\n            energy_interaction=[\n                [5.2e3, 4.0e3, 32.2e3, 13.0e3, 8.0e3, 8.0e3],\n                [4.0e3, 24.0e3, 7.0e3, 10.0e3, 10.0e3],\n                [18.0e3, 2.0e3, 12.0e3, 12.0e3],\n                [75.4e3, 30.0e3, 30.0e3],\n                [2.0e3, 2.0e3],\n                [2.0e3],\n            ],\n            volume_interaction=[\n                [0.0, 0.0, 0.12e-5, -0.15e-5, 0.0, 0.0],\n                [0.0, 0.0, -0.15e-5, 0.0, 0.0],\n                [0.0, -0.15e-5, 0.0, 0.0],\n                [-0.94e-5, 0.0, 0.0],\n                [0.0, 0.0],\n                [0.0],\n            ],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"ordered ferroenstatite\",\n            mineral_list=[HP_2011_ds62.en(), HP_2011_ds62.fs()],\n            molar_amounts=[0.5, 0.5],\n            free_energy_adjustment=[-6.0e3, 0.0, 0.0],\n        )",
  "def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"orthodiopside\",\n            mineral_list=[HP_2011_ds62.di()],\n            molar_amounts=[1.0],\n            free_energy_adjustment=[-0.1e3, -0.211, 0.005e-5],\n        )",
  "def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"chromium enstatite\",\n            mineral_list=[HP_2011_ds62.mgts(), HP_2011_ds62.kos(), HP_2011_ds62.jd()],\n            molar_amounts=[1.0, 1.0, -1.0],\n            free_energy_adjustment=[3.0e3, 0.0, 0.0],\n        )",
  "def __init__(self):\n        CombinedMineral.__init__(\n            self,\n            name=\"ferrienstatite\",\n            mineral_list=[HP_2011_ds62.mgts(), HP_2011_ds62.acm(), HP_2011_ds62.jd()],\n            molar_amounts=[1.0, 1.0, -1.0],\n            free_energy_adjustment=[-15.0e3, 0.0, 0.15e-5],\n        )",
  "class fo(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fo\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2172500.0,\n            \"S_0\": 95.1,\n            \"V_0\": 4.366e-05,\n            \"Cp\": [233.3, 0.001494, -603800.0, -1869.7],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 128500e6,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "class fa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fa\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1477510.0,\n            \"S_0\": 151.0,\n            \"V_0\": 4.631e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.82e-05,\n            \"K_0\": 125600e6,\n            \"Kprime_0\": 4.68,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "class teph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"teph\",\n            \"formula\": {\"Mn\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1733910.0,\n            \"S_0\": 155.9,\n            \"V_0\": 4.899e-05,\n            \"Cp\": [219.6, 0.0, -1292700.0, -1308.3],\n            \"a_0\": 2.86e-05,\n            \"K_0\": 125600e6,\n            \"Kprime_0\": 4.68,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2019591,\n        }\n        Mineral.__init__(self)",
  "class lrn(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lrn\",\n            \"formula\": {\"Ca\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2306940.0,\n            \"S_0\": 127.6,\n            \"V_0\": 5.16e-05,\n            \"Cp\": [247.5, -0.003206, 0.0, -2051.9],\n            \"a_0\": 2.9e-05,\n            \"K_0\": 98500e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1722391,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1710.0,\n                    \"S_D\": 10.03,\n                    \"V_D\": 5e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class mont(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mont\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2251230.0,\n            \"S_0\": 109.5,\n            \"V_0\": 5.148e-05,\n            \"Cp\": [250.7, -0.010433, -797200.0, -1996.1],\n            \"a_0\": 2.87e-05,\n            \"K_0\": 113400e6,\n            \"Kprime_0\": 3.87,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1564661,\n        }\n        Mineral.__init__(self)",
  "class chum(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"chum\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 9.0, \"O\": 18.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9613220.0,\n            \"S_0\": 440.5,\n            \"V_0\": 0.00019801,\n            \"Cp\": [1071.0, -0.016533, -7899600.0, -7373.9],\n            \"a_0\": 3.2e-05,\n            \"K_0\": 119900e6,\n            \"Kprime_0\": 4.58,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 33.0,\n            \"molar_mass\": 0.62109208,\n        }\n        Mineral.__init__(self)",
  "class chdr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"chdr\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 5.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5254760.0,\n            \"S_0\": 260.0,\n            \"V_0\": 0.00011084,\n            \"Cp\": [625.0, -0.001088, -2259900.0, -4910.7],\n            \"a_0\": 1.82e-05,\n            \"K_0\": 116100e6,\n            \"Kprime_0\": 4.8,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.33970588,\n        }\n        Mineral.__init__(self)",
  "class mwd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mwd\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2138060.0,\n            \"S_0\": 93.9,\n            \"V_0\": 4.051e-05,\n            \"Cp\": [208.7, 0.003942, -1709500.0, -1302.8],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 172600e6,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "class fwd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fwd\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1467690.0,\n            \"S_0\": 146.0,\n            \"V_0\": 4.321e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 169000e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "class mrw(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mrw\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2126800.0,\n            \"S_0\": 90.0,\n            \"V_0\": 3.949e-05,\n            \"Cp\": [213.3, 0.00269, -1410400.0, -1495.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 178100e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "class frw(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"frw\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1471510.0,\n            \"S_0\": 140.0,\n            \"V_0\": 4.203e-05,\n            \"Cp\": [166.8, 0.04261, -1705400.0, -541.4],\n            \"a_0\": 2.22e-05,\n            \"K_0\": 197700e6,\n            \"Kprime_0\": 4.92,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "class mpv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mpv\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1442170.0,\n            \"S_0\": 62.6,\n            \"V_0\": 2.445e-05,\n            \"Cp\": [149.3, 0.002918, -2983000.0, -799.1],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 251000e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "class fpv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fpv\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1082690.0,\n            \"S_0\": 95.0,\n            \"V_0\": 2.534e-05,\n            \"Cp\": [133.2, 0.01083, -3661400.0, -314.7],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 281000e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1319287,\n        }\n        Mineral.__init__(self)",
  "class apv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"apv\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1619680.0,\n            \"S_0\": 51.8,\n            \"V_0\": 2.54e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 203000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "class npv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"npv\",\n            \"formula\": {\"Al\": 0.5, \"Na\": 0.5, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1365000.0,\n            \"S_0\": 63.0,\n            \"V_0\": 2.334e-05,\n            \"Cp\": [135.0, 0.00846, -1850300.0, -600.8],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 203000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.10106935,\n        }\n        Mineral.__init__(self)",
  "class ppv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ppv\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1418480.0,\n            \"S_0\": 60.4,\n            \"V_0\": 2.442e-05,\n            \"Cp\": [149.3, 0.002918, -2983000.0, -799.1],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 231200e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "class cpv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cpv\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1533570.0,\n            \"S_0\": 74.5,\n            \"V_0\": 2.745e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2e-05,\n            \"K_0\": 236000e6,\n            \"Kprime_0\": 3.9,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "class mak(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mak\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1489550.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 211000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "class fak(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fak\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1142110.0,\n            \"S_0\": 91.5,\n            \"V_0\": 2.76e-05,\n            \"Cp\": [100.3, 0.013328, -4364900.0, 419.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 218000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1319287,\n        }\n        Mineral.__init__(self)",
  "class maj(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"maj\",\n            \"formula\": {\"Mg\": 4.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6041720.0,\n            \"S_0\": 260.2,\n            \"V_0\": 0.00011457,\n            \"Cp\": [713.6, -0.000997, -1158200.0, -6622.3],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 160000e6,\n            \"Kprime_0\": 4.56,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4015548,\n        }\n        Mineral.__init__(self)",
  "class nagt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"nagt\",\n            \"formula\": {\"Al\": 1.0, \"Mg\": 2.0, \"Na\": 1.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5985000.0,\n            \"S_0\": 260.6,\n            \"V_0\": 0.0001109,\n            \"Cp\": [620.8, 0.0112, -3755900.0, -4421.3],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4029161,\n        }\n        Mineral.__init__(self)",
  "class py(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"py\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6284740.0,\n            \"S_0\": 267.0,\n            \"V_0\": 0.00011313,\n            \"Cp\": [633.5, 0.0, -5196100.0, -4315.2],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 174300e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4031273,\n        }\n        Mineral.__init__(self)",
  "class alm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"alm\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5267060.0,\n            \"S_0\": 337.0,\n            \"V_0\": 0.00011525,\n            \"Cp\": [716.2, -0.01241, -3160800.0, -5863.5],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 190000e6,\n            \"Kprime_0\": 2.98,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4977473,\n        }\n        Mineral.__init__(self)",
  "class spss(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"spss\",\n            \"formula\": {\"Al\": 2.0, \"Mn\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5692410.0,\n            \"S_0\": 335.3,\n            \"V_0\": 0.00011792,\n            \"Cp\": [646.9, 0.0, -4525800.0, -4452.8],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 6.68,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4950263,\n        }\n        Mineral.__init__(self)",
  "class gr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"gr\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6642910.0,\n            \"S_0\": 255.0,\n            \"V_0\": 0.00012535,\n            \"Cp\": [626.0, 0.0, -5779200.0, -4002.9],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 172000e6,\n            \"Kprime_0\": 5.53,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4504463,\n        }\n        Mineral.__init__(self)",
  "class andr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"andr\",\n            \"formula\": {\"Ca\": 3.0, \"Fe\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5768870.0,\n            \"S_0\": 316.4,\n            \"V_0\": 0.00013204,\n            \"Cp\": [638.6, 0.0, -4955100.0, -3989.2],\n            \"a_0\": 2.86e-05,\n            \"K_0\": 158800e6,\n            \"Kprime_0\": 5.68,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.5081733,\n        }\n        Mineral.__init__(self)",
  "class ski(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ski\",\n            \"formula\": {\"Fe\": 5.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4330840.0,\n            \"S_0\": 403.4,\n            \"V_0\": 0.00012144,\n            \"Cp\": [689.9, 0.0, -2948600.0, -5030.3],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 157400e6,\n            \"Kprime_0\": 6.7,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.5554743,\n        }\n        Mineral.__init__(self)",
  "class knor(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"knor\",\n            \"formula\": {\"Cr\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5701180.0,\n            \"S_0\": 302.0,\n            \"V_0\": 0.00011738,\n            \"Cp\": [613.0, 0.003606, -4178000.0, -3729.4],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 153400e6,\n            \"Kprime_0\": 4.34,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4531565,\n        }\n        Mineral.__init__(self)",
  "class uv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"uv\",\n            \"formula\": {\"Ca\": 3.0, \"Cr\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6057590.0,\n            \"S_0\": 320.9,\n            \"V_0\": 0.00013077,\n            \"Cp\": [605.1, 0.003606, -4760600.0, -3417.1],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 162000e6,\n            \"Kprime_0\": 4.7,\n            \"Kdprime_0\": -2.9e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.5004755,\n        }\n        Mineral.__init__(self)",
  "class osma(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"osma\",\n            \"formula\": {\"Al\": 5.0, \"K\": 1.0, \"Mg\": 2.0, \"O\": 30.0, \"Si\": 10.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14896020.0,\n            \"S_0\": 755.0,\n            \"V_0\": 0.00037893,\n            \"Cp\": [1540.7, -0.011359, -10339000.0, -11699.0],\n            \"a_0\": 4.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 0.9834528,\n        }\n        Mineral.__init__(self)",
  "class osmm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"osmm\",\n            \"formula\": {\"Al\": 3.0, \"K\": 1.0, \"Mg\": 3.0, \"O\": 30.0, \"Si\": 11.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14786240.0,\n            \"S_0\": 740.0,\n            \"V_0\": 0.0003844,\n            \"Cp\": [1525.5, -0.010267, -10538000.0, -11337.0],\n            \"a_0\": 4.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 0.9818803,\n        }\n        Mineral.__init__(self)",
  "class osfa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"osfa\",\n            \"formula\": {\"Al\": 5.0, \"Fe\": 2.0, \"K\": 1.0, \"O\": 30.0, \"Si\": 10.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14215310.0,\n            \"S_0\": 780.0,\n            \"V_0\": 0.0003845,\n            \"Cp\": [1558.6, -0.011359, -9476500.0, -11845.0],\n            \"a_0\": 4.9e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 1.0465328,\n        }\n        Mineral.__init__(self)",
  "class vsv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"vsv\",\n            \"formula\": {\n                \"Al\": 11.0,\n                \"Ca\": 19.0,\n                \"H\": 9.0,\n                \"Mg\": 2.0,\n                \"O\": 78.0,\n                \"Si\": 18.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -42345130.0,\n            \"S_0\": 1890.0,\n            \"V_0\": 0.000852,\n            \"Cp\": [4488.0, -0.057952, -22269300.0, -33478.0],\n            \"a_0\": 2.75e-05,\n            \"K_0\": 125500e6,\n            \"Kprime_0\": 4.8,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 137.0,\n            \"molar_mass\": 2.86945216,\n        }\n        Mineral.__init__(self)",
  "class andalusite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"and\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2588600.0,\n            \"S_0\": 92.7,\n            \"V_0\": 5.153e-05,\n            \"Cp\": [277.3, -0.006588, -1914100.0, -2265.6],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 144200e6,\n            \"Kprime_0\": 6.89,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "class ky(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ky\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2592900.0,\n            \"S_0\": 83.5,\n            \"V_0\": 4.414e-05,\n            \"Cp\": [279.4, -0.007124, -2055600.0, -2289.4],\n            \"a_0\": 1.92e-05,\n            \"K_0\": 160100e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "class sill(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sill\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2585690.0,\n            \"S_0\": 95.4,\n            \"V_0\": 4.986e-05,\n            \"Cp\": [280.2, -0.0069, -1375700.0, -2399.4],\n            \"a_0\": 1.12e-05,\n            \"K_0\": 164000e6,\n            \"Kprime_0\": 5.06,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 4750.0,\n                    \"deltaV\": 1e-07,\n                    \"Wh\": 4750.0,\n                    \"Wv\": 1e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.25,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class smul(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"smul\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2569210.0,\n            \"S_0\": 101.5,\n            \"V_0\": 4.987e-05,\n            \"Cp\": [280.2, -0.0069, -1375700.0, -2399.4],\n            \"a_0\": 1.36e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "class amul(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"amul\",\n            \"formula\": {\"Al\": 2.5, \"O\": 4.75, \"Si\": 0.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2485660.0,\n            \"S_0\": 113.0,\n            \"V_0\": 5.083e-05,\n            \"Cp\": [244.8, 0.000968, -2533300.0, -1641.6],\n            \"a_0\": 1.36e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 7.75,\n            \"molar_mass\": 0.15749365,\n        }\n        Mineral.__init__(self)",
  "class tpz(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tpz\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2900640.0,\n            \"S_0\": 100.5,\n            \"V_0\": 5.339e-05,\n            \"Cp\": [387.7, -0.00712, -857200.0, -3744.2],\n            \"a_0\": 1.57e-05,\n            \"K_0\": 131500e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 11.0,\n            \"molar_mass\": 0.18006078,\n        }\n        Mineral.__init__(self)",
  "class mst(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mst\",\n            \"formula\": {\"Al\": 18.0, \"H\": 4.0, \"Mg\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -25122970.0,\n            \"S_0\": 910.0,\n            \"V_0\": 0.0004426,\n            \"Cp\": [2820.5, -0.059366, -13774000.0, -24126.0],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 168400e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.56553121,\n        }\n        Mineral.__init__(self)",
  "class fst(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fst\",\n            \"formula\": {\"Al\": 18.0, \"Fe\": 4.0, \"H\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -23755130.0,\n            \"S_0\": 1010.0,\n            \"V_0\": 0.0004488,\n            \"Cp\": [2880.0, -0.056595, -10642000.0, -25373.0],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.76,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.69169121,\n        }\n        Mineral.__init__(self)",
  "class mnst(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mnst\",\n            \"formula\": {\"Al\": 18.0, \"H\": 4.0, \"Mn\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -24242690.0,\n            \"S_0\": 1034.0,\n            \"V_0\": 0.0004546,\n            \"Cp\": [2873.3, -0.089064, -12688000.0, -24749.0],\n            \"a_0\": 2.09e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.76,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.68806321,\n        }\n        Mineral.__init__(self)",
  "class mctd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mctd\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mg\": 1.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3549210.0,\n            \"S_0\": 146.0,\n            \"V_0\": 6.875e-05,\n            \"Cp\": [417.4, -0.003771, -2920600.0, -3417.8],\n            \"a_0\": 2.63e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.22036518,\n        }\n        Mineral.__init__(self)",
  "class fctd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fctd\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"H\": 2.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3208500.0,\n            \"S_0\": 167.0,\n            \"V_0\": 6.98e-05,\n            \"Cp\": [416.1, -0.003477, -2835900.0, -3360.3],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.25190518,\n        }\n        Mineral.__init__(self)",
  "class mnctd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mnctd\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mn\": 1.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3335510.0,\n            \"S_0\": 166.0,\n            \"V_0\": 7.175e-05,\n            \"Cp\": [464.4, -0.012654, -1147200.0, -4341.0],\n            \"a_0\": 2.6e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.25099818,\n        }\n        Mineral.__init__(self)",
  "class merw(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"merw\",\n            \"formula\": {\"Ca\": 3.0, \"Mg\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4545690.0,\n            \"S_0\": 253.1,\n            \"V_0\": 9.847e-05,\n            \"Cp\": [417.5, 0.008117, -2923000.0, -2320.3],\n            \"a_0\": 3.19e-05,\n            \"K_0\": 120000e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 14.0,\n            \"molar_mass\": 0.3287052,\n        }\n        Mineral.__init__(self)",
  "class spu(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"spu\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 5.0, \"O\": 11.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5846800.0,\n            \"S_0\": 332.0,\n            \"V_0\": 0.00014697,\n            \"Cp\": [614.1, -0.003508, -2493100.0, -4168.0],\n            \"a_0\": 3.4e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.4445651,\n        }\n        Mineral.__init__(self)",
  "class zo(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"zo\",\n            \"formula\": {\"Al\": 3.0, \"Ca\": 2.0, \"H\": 1.0, \"O\": 13.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6896150.0,\n            \"S_0\": 298.0,\n            \"V_0\": 0.00013575,\n            \"Cp\": [662.0, 0.010416, -6006400.0, -4260.7],\n            \"a_0\": 3.12e-05,\n            \"K_0\": 104400e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.45435714,\n        }\n        Mineral.__init__(self)",
  "class cz(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cz\",\n            \"formula\": {\"Al\": 3.0, \"Ca\": 2.0, \"H\": 1.0, \"O\": 13.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6895400.0,\n            \"S_0\": 301.0,\n            \"V_0\": 0.0001363,\n            \"Cp\": [630.9, 0.013693, -6645800.0, -3731.1],\n            \"a_0\": 2.33e-05,\n            \"K_0\": 119700e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.45435714,\n        }\n        Mineral.__init__(self)",
  "class ep(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ep\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Ca\": 2.0,\n                \"Fe\": 1.0,\n                \"H\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6473650.0,\n            \"S_0\": 315.0,\n            \"V_0\": 0.0001392,\n            \"Cp\": [613.3, 0.02207, -7160000.0, -2987.7],\n            \"a_0\": 2.34e-05,\n            \"K_0\": 134000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.48322064,\n        }\n        Mineral.__init__(self)",
  "class fep(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fep\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"Ca\": 2.0,\n                \"Fe\": 2.0,\n                \"H\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6028290.0,\n            \"S_0\": 329.0,\n            \"V_0\": 0.0001421,\n            \"Cp\": [584.7, 0.030447, -7674200.0, -2244.3],\n            \"a_0\": 2.31e-05,\n            \"K_0\": 151300e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.51208414,\n        }\n        Mineral.__init__(self)",
  "class pmt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pmt\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Ca\": 2.0,\n                \"H\": 1.0,\n                \"Mn\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6542600.0,\n            \"S_0\": 340.0,\n            \"V_0\": 0.0001382,\n            \"Cp\": [569.8, 0.02779, -5442900.0, -2812.6],\n            \"a_0\": 2.38e-05,\n            \"K_0\": 119700e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.48231364,\n        }\n        Mineral.__init__(self)",
  "class law(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"law\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 4.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4868550.0,\n            \"S_0\": 229.0,\n            \"V_0\": 0.00010132,\n            \"Cp\": [687.8, 0.001566, 375900.0, -7179.2],\n            \"a_0\": 2.65e-05,\n            \"K_0\": 122900e6,\n            \"Kprime_0\": 5.45,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.31423776,\n        }\n        Mineral.__init__(self)",
  "class mpm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mpm\",\n            \"formula\": {\n                \"Al\": 5.0,\n                \"Ca\": 4.0,\n                \"H\": 7.0,\n                \"Mg\": 1.0,\n                \"O\": 28.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14386650.0,\n            \"S_0\": 629.0,\n            \"V_0\": 0.0002955,\n            \"Cp\": [1720.8, -0.024928, -5998700.0, -14620.3],\n            \"a_0\": 2.48e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 0.94307628,\n        }\n        Mineral.__init__(self)",
  "class fpm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fpm\",\n            \"formula\": {\n                \"Al\": 5.0,\n                \"Ca\": 4.0,\n                \"Fe\": 1.0,\n                \"H\": 7.0,\n                \"O\": 28.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14034030.0,\n            \"S_0\": 657.0,\n            \"V_0\": 0.0002968,\n            \"Cp\": [1737.2, -0.024582, -5161100.0, -14963.0],\n            \"a_0\": 2.49e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 0.97461628,\n        }\n        Mineral.__init__(self)",
  "class jgd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"jgd\",\n            \"formula\": {\"Ca\": 4.0, \"Fe\": 6.0, \"H\": 7.0, \"O\": 28.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11808710.0,\n            \"S_0\": 830.0,\n            \"V_0\": 0.0003108,\n            \"Cp\": [1795.4, -0.037986, -4455700.0, -14888.0],\n            \"a_0\": 2.49e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 1.11893378,\n        }\n        Mineral.__init__(self)",
  "class geh(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"geh\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 2.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3992180.0,\n            \"S_0\": 198.5,\n            \"V_0\": 9.024e-05,\n            \"Cp\": [405.7, -0.007099, -1188300.0, -3174.4],\n            \"a_0\": 2.23e-05,\n            \"K_0\": 108000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2742003,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 7510.0,\n                    \"deltaV\": 9e-07,\n                    \"Wh\": 7500.0,\n                    \"Wv\": 9e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.8,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class ak(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ak\",\n            \"formula\": {\"Ca\": 2.0, \"Mg\": 1.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3865580.0,\n            \"S_0\": 212.5,\n            \"V_0\": 9.254e-05,\n            \"Cp\": [385.4, 0.003209, -247500.0, -2889.9],\n            \"a_0\": 2.57e-05,\n            \"K_0\": 142000e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.9e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2726278,\n        }\n        Mineral.__init__(self)",
  "class rnk(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"rnk\",\n            \"formula\": {\"Ca\": 3.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3943840.0,\n            \"S_0\": 210.0,\n            \"V_0\": 9.651e-05,\n            \"Cp\": [372.3, -0.002893, -2462400.0, -2181.3],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2884008,\n        }\n        Mineral.__init__(self)",
  "class ty(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ty\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 5.0, \"O\": 13.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6368130.0,\n            \"S_0\": 390.0,\n            \"V_0\": 0.00017039,\n            \"Cp\": [741.7, -0.005345, -1434600.0, -5878.5],\n            \"a_0\": 3.42e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.4885746,\n        }\n        Mineral.__init__(self)",
  "class crd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"crd\",\n            \"formula\": {\"Al\": 4.0, \"Mg\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9163180.0,\n            \"S_0\": 404.1,\n            \"V_0\": 0.00023322,\n            \"Cp\": [906.1, 0.0, -7902000.0, -6293.4],\n            \"a_0\": 6.8e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.5849527,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class hcrd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hcrd\",\n            \"formula\": {\"Al\": 4.0, \"H\": 2.0, \"Mg\": 2.0, \"O\": 19.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9448270.0,\n            \"S_0\": 483.0,\n            \"V_0\": 0.00023322,\n            \"Cp\": [955.3, 0.0, -8352600.0, -6301.2],\n            \"a_0\": 6.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 32.0,\n            \"molar_mass\": 0.60296798,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class fcrd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fcrd\",\n            \"formula\": {\"Al\": 4.0, \"Fe\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8444070.0,\n            \"S_0\": 461.0,\n            \"V_0\": 0.0002371,\n            \"Cp\": [924.0, 0.0, -7039400.0, -6439.6],\n            \"a_0\": 6.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.6480327,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class mncrd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mncrd\",\n            \"formula\": {\"Al\": 4.0, \"Mn\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8692150.0,\n            \"S_0\": 473.0,\n            \"V_0\": 0.00024027,\n            \"Cp\": [886.5, 0.0, -8840000.0, -5590.4],\n            \"a_0\": 6.9e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.6462187,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class phA(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"phA\",\n            \"formula\": {\"H\": 6.0, \"Mg\": 7.0, \"O\": 14.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7129610.0,\n            \"S_0\": 350.5,\n            \"V_0\": 0.00015422,\n            \"Cp\": [962.0, -0.011521, -4517800.0, -7724.7],\n            \"a_0\": 3.55e-05,\n            \"K_0\": 145000e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.45634524,\n        }\n        Mineral.__init__(self)",
  "class phD(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"phD\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2670160.0,\n            \"S_0\": 111.2,\n            \"V_0\": 5.103e-05,\n            \"Cp\": [294.6, 0.007944, -5008700.0, -1335.5],\n            \"a_0\": 3.79e-05,\n            \"K_0\": 165000e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 11.0,\n            \"molar_mass\": 0.17848828,\n        }\n        Mineral.__init__(self)",
  "class phE(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"phE\",\n            \"formula\": {\"H\": 2.4, \"Mg\": 2.4, \"O\": 6.0, \"Si\": 1.2},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2931150.0,\n            \"S_0\": 169.0,\n            \"V_0\": 6.435e-05,\n            \"Cp\": [397.4, -0.003533, -1344400.0, -3290.2],\n            \"a_0\": 3.79e-05,\n            \"K_0\": 93000e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.190450056,\n        }\n        Mineral.__init__(self)",
  "class shB(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"shB\",\n            \"formula\": {\"H\": 4.0, \"Mg\": 10.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9477320.0,\n            \"S_0\": 396.0,\n            \"V_0\": 0.00018615,\n            \"Cp\": [1077.7, 0.000642, -7407400.0, -7428.7],\n            \"a_0\": 3.56e-05,\n            \"K_0\": 132000e6,\n            \"Kprime_0\": 5.3,\n            \"Kdprime_0\": -3.91e-11,\n            \"n\": 35.0,\n            \"molar_mass\": 0.61932746,\n        }\n        Mineral.__init__(self)",
  "class sph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sph\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 5.0, \"Si\": 1.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2601450.0,\n            \"S_0\": 124.0,\n            \"V_0\": 5.565e-05,\n            \"Cp\": [227.9, 0.002924, -3539500.0, -894.3],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 101700e6,\n            \"Kprime_0\": 9.85,\n            \"Kdprime_0\": -9.7e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1960275,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 485.0,\n                    \"S_D\": 0.4,\n                    \"V_D\": 5e-08,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class cstn(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cstn\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 5.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2482910.0,\n            \"S_0\": 99.5,\n            \"V_0\": 4.818e-05,\n            \"Cp\": [205.6, 0.006034, -5517700.0, -352.6],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 178200e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.176246,\n        }\n        Mineral.__init__(self)",
  "class zrc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"zrc\",\n            \"formula\": {\"O\": 4.0, \"Si\": 1.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2035140.0,\n            \"S_0\": 83.03,\n            \"V_0\": 3.926e-05,\n            \"Cp\": [232.0, -0.014405, 0.0, -2238.2],\n            \"a_0\": 1.25e-05,\n            \"K_0\": 230100e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.1833071,\n        }\n        Mineral.__init__(self)",
  "class zrt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"zrt\",\n            \"formula\": {\"O\": 4.0, \"Ti\": 1.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1998020.0,\n            \"S_0\": 98.0,\n            \"V_0\": 4.42e-05,\n            \"Cp\": [214.6, -0.008226, 190300.0, -1820.4],\n            \"a_0\": 1.25e-05,\n            \"K_0\": 230100e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.2030886,\n        }\n        Mineral.__init__(self)",
  "class tcn(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tcn\",\n            \"formula\": {\"O\": 4.0, \"Si\": 1.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1766360.0,\n            \"S_0\": 77.0,\n            \"V_0\": 3.493e-05,\n            \"Cp\": [208.6, -0.003669, 113000.0, -1906.9],\n            \"a_0\": 1.25e-05,\n            \"K_0\": 230100e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.1399501,\n        }\n        Mineral.__init__(self)",
  "class en(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"en\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3089960.0,\n            \"S_0\": 132.5,\n            \"V_0\": 6.262e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "class pren(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pren\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3084300.0,\n            \"S_0\": 137.0,\n            \"V_0\": 6.476e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.3e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "class cen(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cen\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3090850.0,\n            \"S_0\": 132.0,\n            \"V_0\": 6.264e-05,\n            \"Cp\": [306.0, -0.003793, -3041700.0, -1852.1],\n            \"a_0\": 2.11e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "class hen(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hen\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3082460.0,\n            \"S_0\": 131.7,\n            \"V_0\": 6.099e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.26e-05,\n            \"K_0\": 150000e6,\n            \"Kprime_0\": 5.5,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "class hfs(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hfs\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2380550.0,\n            \"S_0\": 189.0,\n            \"V_0\": 6.405e-05,\n            \"Cp\": [398.7, -0.006579, 1290100.0, -4058.0],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 150000e6,\n            \"Kprime_0\": 5.5,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2638574,\n        }\n        Mineral.__init__(self)",
  "class fs(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fs\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2388500.0,\n            \"S_0\": 189.9,\n            \"V_0\": 6.592e-05,\n            \"Cp\": [398.7, -0.006579, 1290100.0, -4058.0],\n            \"a_0\": 3.26e-05,\n            \"K_0\": 101000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2638574,\n        }\n        Mineral.__init__(self)",
  "class mgts(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mgts\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3200660.0,\n            \"S_0\": 128.5,\n            \"V_0\": 6.05e-05,\n            \"Cp\": [371.4, -0.004082, -398400.0, -3547.1],\n            \"a_0\": 2.17e-05,\n            \"K_0\": 102800e6,\n            \"Kprime_0\": 8.55,\n            \"Kdprime_0\": -8.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2023499,\n        }\n        Mineral.__init__(self)",
  "class di(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"di\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3201780.0,\n            \"S_0\": 142.9,\n            \"V_0\": 6.619e-05,\n            \"Cp\": [314.5, 4.1e-05, -2745900.0, -2020.1],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2165504,\n        }\n        Mineral.__init__(self)",
  "class hed(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hed\",\n            \"formula\": {\"Ca\": 1.0, \"Fe\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2841970.0,\n            \"S_0\": 175.0,\n            \"V_0\": 6.795e-05,\n            \"Cp\": [340.2, 0.000812, -1047800.0, -2646.7],\n            \"a_0\": 2.38e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 3.97,\n            \"Kdprime_0\": -3.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2480904,\n        }\n        Mineral.__init__(self)",
  "class jd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"jd\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3025370.0,\n            \"S_0\": 133.5,\n            \"V_0\": 6.04e-05,\n            \"Cp\": [319.4, 0.003616, -1173900.0, -2469.5],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 128100e6,\n            \"Kprime_0\": 3.81,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2021387,\n        }\n        Mineral.__init__(self)",
  "class kjd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kjd\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2932700.0,\n            \"S_0\": 141.24,\n            \"V_0\": 6.479e-05,\n            \"Cp\": [316.2, 0.006905, -905300.0, -2489.0],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 145000e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2182472,\n        }\n        Mineral.__init__(self)",
  "class acm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"acm\",\n            \"formula\": {\"Fe\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2583270.0,\n            \"S_0\": 170.6,\n            \"V_0\": 6.459e-05,\n            \"Cp\": [307.1, 0.016758, -1685500.0, -2125.8],\n            \"a_0\": 2.11e-05,\n            \"K_0\": 106000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2310022,\n        }\n        Mineral.__init__(self)",
  "class kos(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kos\",\n            \"formula\": {\"Cr\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2744890.0,\n            \"S_0\": 149.65,\n            \"V_0\": 6.309e-05,\n            \"Cp\": [309.2, 0.005419, -664600.0, -2176.6],\n            \"a_0\": 1.94e-05,\n            \"K_0\": 130800e6,\n            \"Kprime_0\": 3.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2271533,\n        }\n        Mineral.__init__(self)",
  "class cats(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cats\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3310050.0,\n            \"S_0\": 135.0,\n            \"V_0\": 6.356e-05,\n            \"Cp\": [347.6, -0.006974, -1781600.0, -2757.5],\n            \"a_0\": 2.08e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2181229,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 3800.0,\n                    \"deltaV\": 1e-07,\n                    \"Wh\": 3800.0,\n                    \"Wv\": 1e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.25,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class caes(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"caes\",\n            \"formula\": {\"Al\": 1.0, \"Ca\": 0.5, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3001960.0,\n            \"S_0\": 127.0,\n            \"V_0\": 6.05e-05,\n            \"Cp\": [362.0, -0.016944, -175900.0, -3565.7],\n            \"a_0\": 2.31e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 9.5,\n            \"molar_mass\": 0.1991879,\n        }\n        Mineral.__init__(self)",
  "class rhod(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"rhod\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1322350.0,\n            \"S_0\": 100.5,\n            \"V_0\": 3.494e-05,\n            \"Cp\": [138.4, 0.004088, -1936000.0, -538.9],\n            \"a_0\": 2.81e-05,\n            \"K_0\": 84000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1310217,\n        }\n        Mineral.__init__(self)",
  "class pxmn(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pxmn\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1323130.0,\n            \"S_0\": 99.3,\n            \"V_0\": 3.472e-05,\n            \"Cp\": [138.4, 0.004088, -1936000.0, -538.9],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 84000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1310217,\n        }\n        Mineral.__init__(self)",
  "class wo(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"wo\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1633760.0,\n            \"S_0\": 82.5,\n            \"V_0\": 3.993e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2.54e-05,\n            \"K_0\": 79500e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "class pswo(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pswo\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1627960.0,\n            \"S_0\": 87.8,\n            \"V_0\": 4.008e-05,\n            \"Cp\": [157.8, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 110000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "class wal(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"wal\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1625600.0,\n            \"S_0\": 84.5,\n            \"V_0\": 3.7633e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 3.2e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "class tr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tr\",\n            \"formula\": {\"Ca\": 2.0, \"H\": 2.0, \"Mg\": 5.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12304300.0,\n            \"S_0\": 553.0,\n            \"V_0\": 0.0002727,\n            \"Cp\": [1260.2, 0.00383, -11455000.0, -8237.6],\n            \"a_0\": 2.61e-05,\n            \"K_0\": 76200e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.81236648,\n        }\n        Mineral.__init__(self)",
  "class fact(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fact\",\n            \"formula\": {\"Ca\": 2.0, \"Fe\": 5.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10503600.0,\n            \"S_0\": 710.0,\n            \"V_0\": 0.0002842,\n            \"Cp\": [1290.0, 0.029992, -8447500.0, -8947.0],\n            \"a_0\": 2.88e-05,\n            \"K_0\": 76000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.97006648,\n        }\n        Mineral.__init__(self)",
  "class ts(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ts\",\n            \"formula\": {\n                \"Al\": 4.0,\n                \"Ca\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"O\": 24.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12554640.0,\n            \"S_0\": 533.0,\n            \"V_0\": 0.000268,\n            \"Cp\": [1244.8, 0.024348, -11965000.0, -8112.1],\n            \"a_0\": 2.66e-05,\n            \"K_0\": 76000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.81551148,\n        }\n        Mineral.__init__(self)",
  "class parg(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"parg\",\n            \"formula\": {\n                \"Al\": 3.0,\n                \"Ca\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 4.0,\n                \"Na\": 1.0,\n                \"O\": 24.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12664760.0,\n            \"S_0\": 635.0,\n            \"V_0\": 0.0002719,\n            \"Cp\": [1280.2, 0.022997, -12359500.0, -8065.8],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 91200e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.5e-11,\n            \"n\": 42.0,\n            \"molar_mass\": 0.83582478,\n        }\n        Mineral.__init__(self)",
  "class gl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"gl\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 2.0,\n                \"O\": 24.0,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11955920.0,\n            \"S_0\": 530.0,\n            \"V_0\": 0.0002598,\n            \"Cp\": [1717.5, -0.12107, 7075000.0, -19272.0],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 88300e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78354308,\n        }\n        Mineral.__init__(self)",
  "class fgl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fgl\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Fe\": 3.0,\n                \"H\": 2.0,\n                \"Na\": 2.0,\n                \"O\": 24.0,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10879520.0,\n            \"S_0\": 624.0,\n            \"V_0\": 0.0002659,\n            \"Cp\": [1762.9, -0.118992, 9423700.0, -20207.1],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 89000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.87816308,\n        }\n        Mineral.__init__(self)",
  "class nyb(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"nyb\",\n            \"formula\": {\n                \"Al\": 3.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 3.0,\n                \"O\": 24.0,\n                \"Si\": 7.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12165450.0,\n            \"S_0\": 622.0,\n            \"V_0\": 0.00026314,\n            \"Cp\": [1745.2, -0.112162, 6425500.0, -19163.0],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 91000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.5e-11,\n            \"n\": 42.0,\n            \"molar_mass\": 0.80542888,\n        }\n        Mineral.__init__(self)",
  "class rieb(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"rieb\",\n            \"formula\": {\"Fe\": 5.0, \"H\": 2.0, \"Na\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10024100.0,\n            \"S_0\": 695.0,\n            \"V_0\": 0.0002749,\n            \"Cp\": [1787.3, -0.124882, 9627100.0, -20275.5],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 89000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.93589008,\n        }\n        Mineral.__init__(self)",
  "class anth(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"anth\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 7.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12065900.0,\n            \"S_0\": 537.0,\n            \"V_0\": 0.0002654,\n            \"Cp\": [1277.3, 0.025825, -9704600.0, -9074.7],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78082048,\n        }\n        Mineral.__init__(self)",
  "class fanth(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fanth\",\n            \"formula\": {\"Fe\": 7.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9623750.0,\n            \"S_0\": 725.0,\n            \"V_0\": 0.0002787,\n            \"Cp\": [1383.1, 0.030669, -4224700.0, -11257.6],\n            \"a_0\": 2.74e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 1.00160048,\n        }\n        Mineral.__init__(self)",
  "class cumm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cumm\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 7.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12063750.0,\n            \"S_0\": 538.0,\n            \"V_0\": 0.0002633,\n            \"Cp\": [1277.3, 0.025825, -9704600.0, -9074.7],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78082048,\n        }\n        Mineral.__init__(self)",
  "class grun(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"grun\",\n            \"formula\": {\"Fe\": 7.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9606390.0,\n            \"S_0\": 735.0,\n            \"V_0\": 0.0002784,\n            \"Cp\": [1383.1, 0.030669, -4224700.0, -11257.6],\n            \"a_0\": 2.74e-05,\n            \"K_0\": 64800e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 1.00160048,\n        }\n        Mineral.__init__(self)",
  "class ged(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ged\",\n            \"formula\": {\"Al\": 4.0, \"H\": 2.0, \"Mg\": 5.0, \"O\": 24.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12306610.0,\n            \"S_0\": 535.0,\n            \"V_0\": 0.00025956,\n            \"Cp\": [1307.7, 0.023642, -9307400.0, -9799.0],\n            \"a_0\": 2.41e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78396548,\n        }\n        Mineral.__init__(self)",
  "class spr4(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"spr4\",\n            \"formula\": {\"Al\": 8.0, \"Mg\": 4.0, \"O\": 20.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11020350.0,\n            \"S_0\": 425.5,\n            \"V_0\": 0.000199,\n            \"Cp\": [1133.1, -0.007596, -8816600.0, -8180.6],\n            \"a_0\": 2.05e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.689231,\n        }\n        Mineral.__init__(self)",
  "class spr5(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"spr5\",\n            \"formula\": {\"Al\": 10.0, \"Mg\": 3.0, \"O\": 20.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11135050.0,\n            \"S_0\": 419.5,\n            \"V_0\": 0.0001975,\n            \"Cp\": [1103.4, 0.001015, -10957000.0, -7409.2],\n            \"a_0\": 2.06e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.6908035,\n        }\n        Mineral.__init__(self)",
  "class fspr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fspr\",\n            \"formula\": {\"Al\": 8.0, \"Fe\": 4.0, \"O\": 20.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9658040.0,\n            \"S_0\": 485.0,\n            \"V_0\": 0.00019923,\n            \"Cp\": [1132.9, -0.007348, -10420200.0, -7036.6],\n            \"a_0\": 1.96e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.815391,\n        }\n        Mineral.__init__(self)",
  "class mcar(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mcar\",\n            \"formula\": {\"Al\": 2.0, \"H\": 4.0, \"Mg\": 1.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4770850.0,\n            \"S_0\": 221.5,\n            \"V_0\": 0.0001059,\n            \"Cp\": [683.0, -0.014054, 291000.0, -6976.4],\n            \"a_0\": 2.43e-05,\n            \"K_0\": 52500e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -7.9e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.29846476,\n        }\n        Mineral.__init__(self)",
  "class fcar(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fcar\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"H\": 4.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4411490.0,\n            \"S_0\": 251.1,\n            \"V_0\": 0.00010695,\n            \"Cp\": [686.6, -0.012415, 186000.0, -6884.0],\n            \"a_0\": 2.21e-05,\n            \"K_0\": 52500e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -7.9e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.33000476,\n        }\n        Mineral.__init__(self)",
  "class deer(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"deer\",\n            \"formula\": {\"Fe\": 18.0, \"H\": 10.0, \"O\": 50.0, \"Si\": 12.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -18339500.0,\n            \"S_0\": 1650.0,\n            \"V_0\": 0.0005574,\n            \"Cp\": [3164.4, -0.027883, -5039100.0, -26721.0],\n            \"a_0\": 2.75e-05,\n            \"K_0\": 63000e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.5e-11,\n            \"n\": 90.0,\n            \"molar_mass\": 2.1522854,\n        }\n        Mineral.__init__(self)",
  "class mu(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mu\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5976510.0,\n            \"S_0\": 292.0,\n            \"V_0\": 0.00014083,\n            \"Cp\": [756.4, -0.01984, -2170000.0, -6979.2],\n            \"a_0\": 3.07e-05,\n            \"K_0\": 49000e6,\n            \"Kprime_0\": 4.15,\n            \"Kdprime_0\": -8.5e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39830798,\n        }\n        Mineral.__init__(self)",
  "class cel(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cel\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 1.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5834860.0,\n            \"S_0\": 290.0,\n            \"V_0\": 0.00013957,\n            \"Cp\": [741.2, -0.018748, -2368800.0, -6616.9],\n            \"a_0\": 3.07e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39673548,\n        }\n        Mineral.__init__(self)",
  "class fcel(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fcel\",\n            \"formula\": {\"Al\": 1.0, \"Fe\": 1.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5468630.0,\n            \"S_0\": 330.0,\n            \"V_0\": 0.0001407,\n            \"Cp\": [756.3, -0.019147, -1586100.0, -6928.7],\n            \"a_0\": 3.18e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.42827548,\n        }\n        Mineral.__init__(self)",
  "class pa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pa\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"Na\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5942660.0,\n            \"S_0\": 277.0,\n            \"V_0\": 0.00013211,\n            \"Cp\": [803.0, -0.03158, 217000.0, -8151.0],\n            \"a_0\": 3.7e-05,\n            \"K_0\": 51500e6,\n            \"Kprime_0\": 6.51,\n            \"Kdprime_0\": -1.26e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.38219948,\n        }\n        Mineral.__init__(self)",
  "class ma(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ma\",\n            \"formula\": {\"Al\": 4.0, \"Ca\": 1.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6241920.0,\n            \"S_0\": 265.0,\n            \"V_0\": 0.00012964,\n            \"Cp\": [744.4, -0.0168, -2074400.0, -6783.2],\n            \"a_0\": 2.33e-05,\n            \"K_0\": 100000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39818368,\n        }\n        Mineral.__init__(self)",
  "class phl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"phl\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6214610.0,\n            \"S_0\": 326.0,\n            \"V_0\": 0.00014964,\n            \"Cp\": [770.3, -0.036939, -2328900.0, -6531.6],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.41725998,\n        }\n        Mineral.__init__(self)",
  "class ann(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ann\",\n            \"formula\": {\"Al\": 1.0, \"Fe\": 3.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5143590.0,\n            \"S_0\": 420.0,\n            \"V_0\": 0.00015432,\n            \"Cp\": [815.7, -0.034861, 19800.0, -7466.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.51187998,\n        }\n        Mineral.__init__(self)",
  "class mnbi(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mnbi\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mn\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5475460.0,\n            \"S_0\": 433.0,\n            \"V_0\": 0.00015264,\n            \"Cp\": [809.9, -0.059213, -1514400.0, -6998.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 53000e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.50915898,\n        }\n        Mineral.__init__(self)",
  "class east(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"east\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 2.0, \"O\": 12.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6330120.0,\n            \"S_0\": 318.0,\n            \"V_0\": 0.00014738,\n            \"Cp\": [785.5, -0.038031, -2130300.0, -6893.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 53000e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.41883248,\n        }\n        Mineral.__init__(self)",
  "class naph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"naph\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 1.0,\n                \"O\": 12.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6164670.0,\n            \"S_0\": 318.0,\n            \"V_0\": 0.0001445,\n            \"Cp\": [773.5, -0.040229, -2597900.0, -6512.6],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.40115148,\n        }\n        Mineral.__init__(self)",
  "class tan(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tan\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5899790.0,\n            \"S_0\": 259.0,\n            \"V_0\": 0.00013665,\n            \"Cp\": [622.2, 0.0, -6385500.0, -3916.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.37926568,\n        }\n        Mineral.__init__(self)",
  "class clin(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"clin\",\n            \"formula\": {\"Al\": 2.0, \"H\": 8.0, \"Mg\": 5.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8908950.0,\n            \"S_0\": 437.0,\n            \"V_0\": 0.0002114,\n            \"Cp\": [1170.8, -0.001508, -3825800.0, -10315.0],\n            \"a_0\": 2.04e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55579722,\n        }\n        Mineral.__init__(self)",
  "class ames(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ames\",\n            \"formula\": {\"Al\": 4.0, \"H\": 8.0, \"Mg\": 4.0, \"O\": 18.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9040330.0,\n            \"S_0\": 412.0,\n            \"V_0\": 0.0002071,\n            \"Cp\": [1186.0, -0.002599, -3627200.0, -10677.0],\n            \"a_0\": 2e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55736972,\n        }\n        Mineral.__init__(self)",
  "class afchl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"afchl\",\n            \"formula\": {\"H\": 8.0, \"Mg\": 6.0, \"O\": 18.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8727580.0,\n            \"S_0\": 439.0,\n            \"V_0\": 0.0002157,\n            \"Cp\": [1155.0, -0.000417, -4024400.0, -9952.9],\n            \"a_0\": 2.04e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55422472,\n        }\n        Mineral.__init__(self)",
  "class daph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"daph\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 5.0, \"H\": 8.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7117950.0,\n            \"S_0\": 584.0,\n            \"V_0\": 0.0002162,\n            \"Cp\": [1192.0, -0.00594, -4826400.0, -9768.3],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.71349722,\n        }\n        Mineral.__init__(self)",
  "class mnchl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mnchl\",\n            \"formula\": {\"Al\": 2.0, \"H\": 8.0, \"Mn\": 5.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7699120.0,\n            \"S_0\": 595.0,\n            \"V_0\": 0.0002259,\n            \"Cp\": [1136.5, -0.005243, -5548100.0, -8911.5],\n            \"a_0\": 2.23e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.70896222,\n        }\n        Mineral.__init__(self)",
  "class sud(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sud\",\n            \"formula\": {\"Al\": 4.0, \"H\": 8.0, \"Mg\": 2.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8626150.0,\n            \"S_0\": 395.0,\n            \"V_0\": 0.000203,\n            \"Cp\": [1436.1, -0.048749, -2748500.0, -13764.0],\n            \"a_0\": 1.99e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 35.0,\n            \"molar_mass\": 0.53684522,\n        }\n        Mineral.__init__(self)",
  "class fsud(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fsud\",\n            \"formula\": {\"Al\": 4.0, \"Fe\": 2.0, \"H\": 8.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7899960.0,\n            \"S_0\": 456.0,\n            \"V_0\": 0.000204,\n            \"Cp\": [1466.3, -0.047365, -1182800.0, -14388.0],\n            \"a_0\": 2.08e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 35.0,\n            \"molar_mass\": 0.59992522,\n        }\n        Mineral.__init__(self)",
  "class prl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"prl\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5640520.0,\n            \"S_0\": 239.0,\n            \"V_0\": 0.00012804,\n            \"Cp\": [784.5, -0.042948, 1251000.0, -8495.9],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 37000e6,\n            \"Kprime_0\": 10.0,\n            \"Kdprime_0\": -2.71e-10,\n            \"n\": 20.0,\n            \"molar_mass\": 0.36031368,\n        }\n        Mineral.__init__(self)",
  "class ta(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ta\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5896740.0,\n            \"S_0\": 259.0,\n            \"V_0\": 0.00013665,\n            \"Cp\": [622.2, 0.0, -6385500.0, -3916.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.37926568,\n        }\n        Mineral.__init__(self)",
  "class fta(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fta\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4798850.0,\n            \"S_0\": 352.0,\n            \"V_0\": 0.00014225,\n            \"Cp\": [579.7, 0.039494, -6459300.0, -3088.1],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.47388568,\n        }\n        Mineral.__init__(self)",
  "class tats(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tats\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mg\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6000930.0,\n            \"S_0\": 259.0,\n            \"V_0\": 0.0001351,\n            \"Cp\": [549.5, 0.036324, -8606600.0, -2515.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.38083818,\n        }\n        Mineral.__init__(self)",
  "class tap(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tap\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5649650.0,\n            \"S_0\": 235.0,\n            \"V_0\": 0.0001345,\n            \"Cp\": [784.5, -0.042948, 1251000.0, -8495.9],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 37000e6,\n            \"Kprime_0\": 10.0,\n            \"Kdprime_0\": -2.71e-10,\n            \"n\": 20.0,\n            \"molar_mass\": 0.36031368,\n        }\n        Mineral.__init__(self)",
  "class nta(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"nta\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 1.0,\n                \"O\": 12.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6163460.0,\n            \"S_0\": 318.0,\n            \"V_0\": 0.0001445,\n            \"Cp\": [773.5, -0.040229, -2597900.0, -6512.6],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.40115148,\n        }\n        Mineral.__init__(self)",
  "class minn(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"minn\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4818980.0,\n            \"S_0\": 355.0,\n            \"V_0\": 0.00014851,\n            \"Cp\": [579.7, 0.039494, -6459300.0, -3088.1],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.47388568,\n        }\n        Mineral.__init__(self)",
  "class minm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"minm\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5865930.0,\n            \"S_0\": 263.9,\n            \"V_0\": 0.00014291,\n            \"Cp\": [622.2, 0.0, -6385500.0, -3916.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.37926568,\n        }\n        Mineral.__init__(self)",
  "class kao(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kao\",\n            \"formula\": {\"Al\": 2.0, \"H\": 4.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4121930.0000000005,\n            \"S_0\": 203.7,\n            \"V_0\": 9.934e-05,\n            \"Cp\": [436.7, -0.034295, -4055900.0, -2699.1],\n            \"a_0\": 2.51e-05,\n            \"K_0\": 64500e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 17.0,\n            \"molar_mass\": 0.25816036,\n        }\n        Mineral.__init__(self)",
  "class pre(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pre\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6202070.0,\n            \"S_0\": 292.8,\n            \"V_0\": 0.00014026,\n            \"Cp\": [724.9, -0.013865, -2059000.0, -6323.9],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 109300e6,\n            \"Kprime_0\": 4.01,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.41238418,\n        }\n        Mineral.__init__(self)",
  "class fpre(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fpre\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"Ca\": 2.0,\n                \"Fe\": 1.0,\n                \"H\": 2.0,\n                \"O\": 12.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5766490.0,\n            \"S_0\": 320.0,\n            \"V_0\": 0.000148,\n            \"Cp\": [737.1, -0.01681, -1957300.0, -6358.1],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 109300e6,\n            \"Kprime_0\": 4.01,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.44124768,\n        }\n        Mineral.__init__(self)",
  "class chr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"chr\",\n            \"formula\": {\"H\": 4.0, \"Mg\": 3.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4360800.0,\n            \"S_0\": 221.3,\n            \"V_0\": 0.00010746,\n            \"Cp\": [624.7, -0.02077, -1721800.0, -5619.4],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 62800e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.27711236,\n        }\n        Mineral.__init__(self)",
  "class liz(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"liz\",\n            \"formula\": {\"H\": 4.0, \"Mg\": 3.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4368980.0,\n            \"S_0\": 212.0,\n            \"V_0\": 0.00010645,\n            \"Cp\": [614.7, -0.02077, -1721800.0, -5619.4],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 71000e6,\n            \"Kprime_0\": 3.2,\n            \"Kdprime_0\": -4.5e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.27711236,\n        }\n        Mineral.__init__(self)",
  "class glt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"glt\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 4.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3297310.0,\n            \"S_0\": 310.0,\n            \"V_0\": 0.0001198,\n            \"Cp\": [576.4, 0.002984, -3757000.0, -4166.2],\n            \"a_0\": 2.28e-05,\n            \"K_0\": 63000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.37173236,\n        }\n        Mineral.__init__(self)",
  "class fstp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fstp\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Fe\": 5.0,\n                \"H\": 12.5,\n                \"K\": 0.5,\n                \"O\": 30.5,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12552150.0,\n            \"S_0\": 930.2,\n            \"V_0\": 0.00037239,\n            \"Cp\": [1944.3, -0.012289, -4840200.0, -16635.0],\n            \"a_0\": 3.68e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 58.5,\n            \"molar_mass\": 1.0780021,\n        }\n        Mineral.__init__(self)",
  "class mstp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mstp\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"H\": 12.5,\n                \"K\": 0.5,\n                \"Mg\": 5.0,\n                \"O\": 30.5,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14288210.0,\n            \"S_0\": 847.4,\n            \"V_0\": 0.00036577,\n            \"Cp\": [1862.2, -0.014018, -8983100.0, -14923.0],\n            \"a_0\": 3.71e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 58.5,\n            \"molar_mass\": 0.9203021,\n        }\n        Mineral.__init__(self)",
  "class atg(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"atg\",\n            \"formula\": {\"H\": 62.0, \"Mg\": 48.0, \"O\": 147.0, \"Si\": 34.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -71400990.0,\n            \"S_0\": 3620.0,\n            \"V_0\": 0.0017548,\n            \"Cp\": [9621.0, -0.091183, -35941600.0, -83034.2],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 63100e6,\n            \"Kprime_0\": 5.92,\n            \"Kdprime_0\": -9.4e-11,\n            \"n\": 291.0,\n            \"molar_mass\": 4.53595108,\n        }\n        Mineral.__init__(self)",
  "class ab(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ab\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3935290.0,\n            \"S_0\": 207.4,\n            \"V_0\": 0.00010067,\n            \"Cp\": [452.0, -0.013364, -1275900.0, -3953.6],\n            \"a_0\": 2.36e-05,\n            \"K_0\": 54100e6,\n            \"Kprime_0\": 5.91,\n            \"Kdprime_0\": -1.09e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 14000.0,\n                    \"deltaV\": 4.2e-07,\n                    \"Wh\": 13000.0,\n                    \"Wv\": 4.2e-07,\n                    \"n\": 3.0,\n                    \"factor\": 0.9,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class abh(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"abh\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3921290.0,\n            \"S_0\": 224.3,\n            \"V_0\": 0.00010105,\n            \"Cp\": [452.0, -0.013364, -1275900.0, -3953.6],\n            \"a_0\": 2.41e-05,\n            \"K_0\": 54100e6,\n            \"Kprime_0\": 5.91,\n            \"Kdprime_0\": -1.09e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        Mineral.__init__(self)",
  "class mic(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mic\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3975410.0,\n            \"S_0\": 214.3,\n            \"V_0\": 0.00010871,\n            \"Cp\": [448.8, -0.010075, -1007300.0, -3973.1],\n            \"a_0\": 1.66e-05,\n            \"K_0\": 58300e6,\n            \"Kprime_0\": 4.02,\n            \"Kdprime_0\": -6.9e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "class san(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"san\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3966760.0,\n            \"S_0\": 214.3,\n            \"V_0\": 0.00010871,\n            \"Cp\": [448.8, -0.010075, -1007300.0, -3973.1],\n            \"a_0\": 1.66e-05,\n            \"K_0\": 58300e6,\n            \"Kprime_0\": 4.02,\n            \"Kdprime_0\": -6.9e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 8650.0,\n                    \"deltaV\": 2.4e-07,\n                    \"Wh\": 8500.0,\n                    \"Wv\": 2.4e-07,\n                    \"n\": 3.0,\n                    \"factor\": 0.8,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class an(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"an\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4232600.0,\n            \"S_0\": 200.5,\n            \"V_0\": 0.00010079,\n            \"Cp\": [370.5, 0.01001, -4339100.0, -1960.6],\n            \"a_0\": 1.41e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2782072,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 42010.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 42000.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 1.0,\n                    \"factor\": 2.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class kcm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kcm\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"O\": 9.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4232700.0,\n            \"S_0\": 281.5,\n            \"V_0\": 0.00011438,\n            \"Cp\": [536.5, -0.01009, -980400.0, -4735.0],\n            \"a_0\": 3.21e-05,\n            \"K_0\": 42500e6,\n            \"Kprime_0\": 2.0,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 16.0,\n            \"molar_mass\": 0.29634678,\n        }\n        Mineral.__init__(self)",
  "class wa(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"wa\",\n            \"formula\": {\"K\": 2.0, \"O\": 9.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4272090.0,\n            \"S_0\": 254.0,\n            \"V_0\": 0.00010844,\n            \"Cp\": [499.1, 0.0, 0.0, -4350.1],\n            \"a_0\": 2.66e-05,\n            \"K_0\": 90000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 15.0,\n            \"molar_mass\": 0.3345332,\n        }\n        Mineral.__init__(self)",
  "class hol(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hol\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3792020.0,\n            \"S_0\": 166.2,\n            \"V_0\": 7.128e-05,\n            \"Cp\": [417.6, -0.003617, -4748100.0, -2819.9],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "class q(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"q\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -910710.0,\n            \"S_0\": 41.43,\n            \"V_0\": 2.269e-05,\n            \"Cp\": [92.9, -0.000642, -714900.0, -716.1],\n            \"a_0\": 0.0,\n            \"K_0\": 73000e6,\n            \"Kprime_0\": 6.0,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 847.0,\n                    \"S_D\": 4.95,\n                    \"V_D\": 1.188e-06,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class trd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"trd\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -907100.0,\n            \"S_0\": 44.1,\n            \"V_0\": 2.8e-05,\n            \"Cp\": [74.9, 0.0031, -1174000.0, -236.7],\n            \"a_0\": 0.0,\n            \"K_0\": 15000e6,\n            \"Kprime_0\": 4.36,\n            \"Kdprime_0\": -2.91e-10,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "class crst(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"crst\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -904260.0,\n            \"S_0\": 50.86,\n            \"V_0\": 2.745e-05,\n            \"Cp\": [72.7, 0.001304, -4129000.0, 0.0],\n            \"a_0\": 0.0,\n            \"K_0\": 16000e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.72e-10,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "class coe(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"coe\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -906990.0,\n            \"S_0\": 39.6,\n            \"V_0\": 2.064e-05,\n            \"Cp\": [107.8, -0.003279, -190300.0, -1041.6],\n            \"a_0\": 1.23e-05,\n            \"K_0\": 97900e6,\n            \"Kprime_0\": 4.19,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "class stv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"stv\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -876720.0,\n            \"S_0\": 24.0,\n            \"V_0\": 1.401e-05,\n            \"Cp\": [68.1, 0.00601, -1978200.0, -82.1],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 309000e6,\n            \"Kprime_0\": 4.6,\n            \"Kdprime_0\": -1.5e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "class ne(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ne\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2094860.0000000002,\n            \"S_0\": 124.4,\n            \"V_0\": 5.419e-05,\n            \"Cp\": [272.7, -0.012398, 0.0, -2763.1],\n            \"a_0\": 4.63e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 467.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 8e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class cg(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cg\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2092030.0000000002,\n            \"S_0\": 118.7,\n            \"V_0\": 5.603e-05,\n            \"Cp\": [116.1, 0.086021, -1992700.0, 0.0],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "class cgh(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cgh\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2078310.0,\n            \"S_0\": 135.0,\n            \"V_0\": 5.67e-05,\n            \"Cp\": [229.2, 0.011876, 0.0, -1970.7],\n            \"a_0\": 4.67e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "class macf(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"macf\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2246370.0,\n            \"S_0\": 80.0,\n            \"V_0\": 3.614e-05,\n            \"Cp\": [200.0, 0.006252, -2996400.0, -888.4],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 212000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1422656,\n        }\n        Mineral.__init__(self)",
  "class mscf(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mscf\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2061420.0,\n            \"S_0\": 87.5,\n            \"V_0\": 3.649e-05,\n            \"Cp\": [213.3, 0.00269, -1410400.0, -1495.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 185000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "class fscf(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fscf\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1402500.0,\n            \"S_0\": 143.4,\n            \"V_0\": 3.914e-05,\n            \"Cp\": [181.1, 0.018526, -2767200.0, -527.1],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 185000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "class nacf(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"nacf\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1965650.0,\n            \"S_0\": 110.0,\n            \"V_0\": 3.631e-05,\n            \"Cp\": [272.7, -0.012398, 0.0, -2763.1],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 185000e6,\n            \"Kprime_0\": 4.6,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "class cacf(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cacf\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2325600.0,\n            \"S_0\": 87.6,\n            \"V_0\": 3.976e-05,\n            \"Cp\": [191.9, 0.009563, -3211300.0, -640.2],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 190000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1580386,\n        }\n        Mineral.__init__(self)",
  "class manal(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"manal\",\n            \"formula\": {\"Al\": 6.0, \"Mg\": 3.0, \"O\": 12.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6796630.0,\n            \"S_0\": 250.0,\n            \"V_0\": 0.00011166,\n            \"Cp\": [600.0, 0.018756, -8989200.0, -2665.2],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 184000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.4267968,\n        }\n        Mineral.__init__(self)",
  "class nanal(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"nanal\",\n            \"formula\": {\"Al\": 5.0, \"Mg\": 2.0, \"Na\": 1.0, \"O\": 12.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6610270.0,\n            \"S_0\": 280.0,\n            \"V_0\": 0.00011322,\n            \"Cp\": [672.7, 0.000106, -5992800.0, -4539.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 184000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.4265856,\n        }\n        Mineral.__init__(self)",
  "class msnal(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"msnal\",\n            \"formula\": {\"Mg\": 6.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6172380.0,\n            \"S_0\": 272.5,\n            \"V_0\": 0.00011061,\n            \"Cp\": [639.9, 0.00807, -4231200.0, -4487.7],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 185000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.4220793,\n        }\n        Mineral.__init__(self)",
  "class fsnal(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fsnal\",\n            \"formula\": {\"Fe\": 6.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4146000.0,\n            \"S_0\": 440.2,\n            \"V_0\": 0.00011856,\n            \"Cp\": [543.3, 0.055578, -8301600.0, -1581.3],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 185000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.6113193,\n        }\n        Mineral.__init__(self)",
  "class canal(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"canal\",\n            \"formula\": {\"Al\": 6.0, \"Ca\": 1.0, \"Mg\": 2.0, \"O\": 12.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6840000.0,\n            \"S_0\": 257.6,\n            \"V_0\": 0.00011159,\n            \"Cp\": [591.9, 0.022067, -9204100.0, -2417.0],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 177000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.4425698,\n        }\n        Mineral.__init__(self)",
  "class sdl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sdl\",\n            \"formula\": {\"Al\": 6.0, \"Cl\": 2.0, \"Na\": 8.0, \"O\": 24.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -13407370.0,\n            \"S_0\": 910.0,\n            \"V_0\": 0.0004213,\n            \"Cp\": [1532.7, 0.047747, -2972800.0, -12427.0],\n            \"a_0\": 4.63e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 46.0,\n            \"molar_mass\": 0.969212,\n        }\n        Mineral.__init__(self)",
  "class kls(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kls\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2123210.0,\n            \"S_0\": 136.0,\n            \"V_0\": 6.052e-05,\n            \"Cp\": [242.0, -0.004482, -895800.0, -1935.8],\n            \"a_0\": 3.16e-05,\n            \"K_0\": 51400e6,\n            \"Kprime_0\": 2.0,\n            \"Kdprime_0\": -3.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1581629,\n        }\n        Mineral.__init__(self)",
  "class lc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lc\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3029430.0,\n            \"S_0\": 198.5,\n            \"V_0\": 8.826e-05,\n            \"Cp\": [369.8, -0.016332, 684700.0, -3683.1],\n            \"a_0\": 1.85e-05,\n            \"K_0\": 45000e6,\n            \"Kprime_0\": 5.7,\n            \"Kdprime_0\": -1.27e-10,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2182472,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11610.0,\n                    \"deltaV\": 4e-06,\n                    \"Wh\": 11600.0,\n                    \"Wv\": 4e-06,\n                    \"n\": 2.0,\n                    \"factor\": 0.7,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class me(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"me\",\n            \"formula\": {\"Al\": 6.0, \"C\": 1.0, \"Ca\": 4.0, \"O\": 27.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -13841600.0,\n            \"S_0\": 752.0,\n            \"V_0\": 0.00033985,\n            \"Cp\": [1359.0, 0.036442, -8594700.0, -9598.2],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 44.0,\n            \"molar_mass\": 0.9347085,\n        }\n        Mineral.__init__(self)",
  "class wrk(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"wrk\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 4.0, \"O\": 14.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6662350.0,\n            \"S_0\": 380.0,\n            \"V_0\": 0.0001904,\n            \"Cp\": [838.3, -0.02146, -2272000.0, -7292.3],\n            \"a_0\": 1.49e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 25.0,\n            \"molar_mass\": 0.43440636,\n        }\n        Mineral.__init__(self)",
  "class lmt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lmt\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 8.0, \"O\": 16.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7262590.0,\n            \"S_0\": 465.0,\n            \"V_0\": 0.0002037,\n            \"Cp\": [1013.4, -0.021413, -2235800.0, -8806.7],\n            \"a_0\": 1.37e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 31.0,\n            \"molar_mass\": 0.47043692,\n        }\n        Mineral.__init__(self)",
  "class heu(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"heu\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 12.0, \"O\": 24.0, \"Si\": 7.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10545090.0,\n            \"S_0\": 783.0,\n            \"V_0\": 0.000317,\n            \"Cp\": [1504.8, -0.033224, -2959300.0, -13297.2],\n            \"a_0\": 1.57e-05,\n            \"K_0\": 27400e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.46e-10,\n            \"n\": 46.0,\n            \"molar_mass\": 0.68672038,\n        }\n        Mineral.__init__(self)",
  "class stlb(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"stlb\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 14.0, \"O\": 25.0, \"Si\": 7.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10896630.0,\n            \"S_0\": 710.0,\n            \"V_0\": 0.0003287,\n            \"Cp\": [1588.4, -0.032043, -3071600.0, -13966.9],\n            \"a_0\": 1.51e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 49.0,\n            \"molar_mass\": 0.70473566,\n        }\n        Mineral.__init__(self)",
  "class anl(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"anl\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"Na\": 1.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3307050.0,\n            \"S_0\": 232.0,\n            \"V_0\": 9.74e-05,\n            \"Cp\": [643.5, -0.016067, 9302300.0, -9179.6],\n            \"a_0\": 2.76e-05,\n            \"K_0\": 40000e6,\n            \"Kprime_0\": 4.18,\n            \"Kdprime_0\": -1.04e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.22015398,\n        }\n        Mineral.__init__(self)",
  "class lime(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lime\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -634580.0,\n            \"S_0\": 38.1,\n            \"V_0\": 1.676e-05,\n            \"Cp\": [52.4, 0.003673, -750700.0, -51.0],\n            \"a_0\": 3.41e-05,\n            \"K_0\": 113000e6,\n            \"Kprime_0\": 3.87,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0560774,\n        }\n        Mineral.__init__(self)",
  "class ru(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ru\",\n            \"formula\": {\"O\": 2.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -944160.0,\n            \"S_0\": 50.5,\n            \"V_0\": 1.882e-05,\n            \"Cp\": [90.4, 0.0029, 0.0, -623.8],\n            \"a_0\": 2.24e-05,\n            \"K_0\": 222000e6,\n            \"Kprime_0\": 4.24,\n            \"Kdprime_0\": -1.9e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0798658,\n        }\n        Mineral.__init__(self)",
  "class per(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"per\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -601600.0,\n            \"S_0\": 26.5,\n            \"V_0\": 1.125e-05,\n            \"Cp\": [60.5, 0.000362, -535800.0, -299.2],\n            \"a_0\": 3.11e-05,\n            \"K_0\": 161600e6,\n            \"Kprime_0\": 3.95,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0403044,\n        }\n        Mineral.__init__(self)",
  "class fper(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"fper\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -262160.0,\n            \"S_0\": 58.6,\n            \"V_0\": 1.206e-05,\n            \"Cp\": [44.4, 0.00828, -1214200.0, 185.2],\n            \"a_0\": 3.22e-05,\n            \"K_0\": 152000e6,\n            \"Kprime_0\": 4.9,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0718444,\n        }\n        Mineral.__init__(self)",
  "class wu(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"wu\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -262430.0,\n            \"S_0\": 63.0,\n            \"V_0\": 1.206e-05,\n            \"Cp\": [67.4, 0.003758, 315700.0, -381.7],\n            \"a_0\": 3.22e-05,\n            \"K_0\": 152000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0718444,\n        }\n        Mineral.__init__(self)",
  "class mang(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mang\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -385570.0,\n            \"S_0\": 59.7,\n            \"V_0\": 1.322e-05,\n            \"Cp\": [59.8, 0.0036, -31400.0, -282.6],\n            \"a_0\": 3.69e-05,\n            \"K_0\": 164500e6,\n            \"Kprime_0\": 4.46,\n            \"Kdprime_0\": -2.7e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0709374,\n        }\n        Mineral.__init__(self)",
  "class cor(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cor\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1675220.0,\n            \"S_0\": 50.9,\n            \"V_0\": 2.558e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 254000e6,\n            \"Kprime_0\": 4.34,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "class mcor(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mcor\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1468360.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 211000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "class hem(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hem\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -825420.0,\n            \"S_0\": 87.4,\n            \"V_0\": 3.027e-05,\n            \"Cp\": [163.9, 0.0, -2257200.0, -657.6],\n            \"a_0\": 2.79e-05,\n            \"K_0\": 223000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1596882,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 955.0,\n                    \"S_D\": 15.6,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class esk(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"esk\",\n            \"formula\": {\"Cr\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1128170.0,\n            \"S_0\": 83.0,\n            \"V_0\": 2.898e-05,\n            \"Cp\": [119.0, 0.009496, -1442000.0, -3.4],\n            \"a_0\": 1.59e-05,\n            \"K_0\": 245000e6,\n            \"Kprime_0\": 3.6,\n            \"Kdprime_0\": -1.5e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1519904,\n        }\n        Mineral.__init__(self)",
  "class bix(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"bix\",\n            \"formula\": {\"Mn\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -959000.0,\n            \"S_0\": 113.7,\n            \"V_0\": 3.137e-05,\n            \"Cp\": [145.1, 0.023534, 721600.0, -1008.4],\n            \"a_0\": 2.91e-05,\n            \"K_0\": 223000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1578742,\n        }\n        Mineral.__init__(self)",
  "class NiO(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"NiO\",\n            \"formula\": {\"Ni\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -239470.0,\n            \"S_0\": 38.0,\n            \"V_0\": 1.097e-05,\n            \"Cp\": [47.7, 0.007824, -392500.0, 0.0],\n            \"a_0\": 3.3e-05,\n            \"K_0\": 200000e6,\n            \"Kprime_0\": 3.94,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0746928,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\"P_0\": 100000.0, \"T_0\": 298.15, \"Tc_0\": 520.0, \"S_D\": 5.7, \"V_D\": 0.0},\n            ]\n        ]\n        Mineral.__init__(self)",
  "class pnt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pnt\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1361500.0,\n            \"S_0\": 105.5,\n            \"V_0\": 3.288e-05,\n            \"Cp\": [143.5, 0.003373, -1940700.0, -407.6],\n            \"a_0\": 2.4e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1508032,\n        }\n        Mineral.__init__(self)",
  "class geik(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"geik\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1568390.0,\n            \"S_0\": 73.6,\n            \"V_0\": 3.086e-05,\n            \"Cp\": [115.5, 0.014938, -2637700.0, 45.5],\n            \"a_0\": 2.15e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1201702,\n        }\n        Mineral.__init__(self)",
  "class ilm(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ilm\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1232320.0,\n            \"S_0\": 107.5,\n            \"V_0\": 3.169e-05,\n            \"Cp\": [138.9, 0.005081, -1288800.0, -463.7],\n            \"a_0\": 2.4e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1517102,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1900.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 2e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class bdy(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"bdy\",\n            \"formula\": {\"O\": 2.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1100320.0,\n            \"S_0\": 50.4,\n            \"V_0\": 2.115e-05,\n            \"Cp\": [89.6, 0.000354, -853100.0, -413.7],\n            \"a_0\": 2e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1232228,\n        }\n        Mineral.__init__(self)",
  "class bdyT(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"bdyT\",\n            \"formula\": {\"O\": 2.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1096010.0,\n            \"S_0\": 53.4,\n            \"V_0\": 2.115e-05,\n            \"Cp\": [89.6, 0.000354, -853100.0, -413.7],\n            \"a_0\": 2e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1232228,\n        }\n        Mineral.__init__(self)",
  "class bdyC(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"bdyC\",\n            \"formula\": {\"O\": 2.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1085960.0,\n            \"S_0\": 57.2,\n            \"V_0\": 2.495e-05,\n            \"Cp\": [89.6, 0.000354, -853100.0, -413.7],\n            \"a_0\": 2e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1232228,\n        }\n        Mineral.__init__(self)",
  "class ten(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ten\",\n            \"formula\": {\"Cu\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -156100.0,\n            \"S_0\": 42.6,\n            \"V_0\": 1.222e-05,\n            \"Cp\": [31.0, 0.01374, -1258000.0, 369.3],\n            \"a_0\": 3.57e-05,\n            \"K_0\": 200000e6,\n            \"Kprime_0\": 3.94,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0795454,\n        }\n        Mineral.__init__(self)",
  "class cup(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cup\",\n            \"formula\": {\"Cu\": 2.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -170600.0,\n            \"S_0\": 92.4,\n            \"V_0\": 2.344e-05,\n            \"Cp\": [110.3, 0.0, 0.0, -674.8],\n            \"a_0\": 3.33e-05,\n            \"K_0\": 131000e6,\n            \"Kprime_0\": 5.7,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1430914,\n        }\n        Mineral.__init__(self)",
  "class sp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sp\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2300180.0,\n            \"S_0\": 80.63,\n            \"V_0\": 3.978e-05,\n            \"Cp\": [200.5, 0.006252, -2996400.0, -888.4],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1422656,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 13930.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": -3600.0,\n                    \"Wv\": 0.0,\n                    \"n\": 2.0,\n                    \"factor\": -0.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class herc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"herc\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1949470.0,\n            \"S_0\": 113.9,\n            \"V_0\": 4.075e-05,\n            \"Cp\": [184.9, 0.01417, -3674800.0, -404.0],\n            \"a_0\": 2.06e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1738056,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 13930.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": -3600.0,\n                    \"Wv\": 0.0,\n                    \"n\": 2.0,\n                    \"factor\": -0.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class mt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mt\",\n            \"formula\": {\"Fe\": 3.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1114200.0,\n            \"S_0\": 146.9,\n            \"V_0\": 4.452e-05,\n            \"Cp\": [262.5, -0.007205, -1926200.0, -1655.7],\n            \"a_0\": 3.71e-05,\n            \"K_0\": 185700e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2315326,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 848.0,\n                    \"S_D\": 35.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class mft(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mft\",\n            \"formula\": {\"Fe\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1442210.0,\n            \"S_0\": 121.0,\n            \"V_0\": 4.457e-05,\n            \"Cp\": [270.5, -0.007505, -999200.0, -2022.4],\n            \"a_0\": 3.63e-05,\n            \"K_0\": 185700e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1999926,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 665.0,\n                    \"S_D\": 17.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class qnd(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"qnd\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2157150.0,\n            \"S_0\": 111.0,\n            \"V_0\": 4.529e-05,\n            \"Cp\": [161.7, 0.03286, -2382200.0, -278.6],\n            \"a_0\": 2.63e-05,\n            \"K_0\": 147000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.72e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1604746,\n        }\n        Mineral.__init__(self)",
  "class usp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"usp\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1494180.0,\n            \"S_0\": 171.0,\n            \"V_0\": 4.682e-05,\n            \"Cp\": [129.5, 0.048696, -3739000.0, 690.2],\n            \"a_0\": 3.86e-05,\n            \"K_0\": 147000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.72e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2235546,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 1000.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": 900.0,\n                    \"Wv\": 0.0,\n                    \"n\": 1.0,\n                    \"factor\": 0.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class picr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"picr\",\n            \"formula\": {\"Cr\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1764240.0,\n            \"S_0\": 118.3,\n            \"V_0\": 4.356e-05,\n            \"Cp\": [196.1, 0.005398, -3126000.0, -616.9],\n            \"a_0\": 2.6e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1922948,\n        }\n        Mineral.__init__(self)",
  "class br(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"br\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -925620.0,\n            \"S_0\": 63.2,\n            \"V_0\": 2.463e-05,\n            \"Cp\": [158.4, -0.004076, -1052300.0, -1171.3],\n            \"a_0\": 6.2e-05,\n            \"K_0\": 41500e6,\n            \"Kprime_0\": 6.45,\n            \"Kdprime_0\": -1.55e-10,\n            \"n\": 5.0,\n            \"molar_mass\": 0.05831968,\n        }\n        Mineral.__init__(self)",
  "class dsp(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"dsp\",\n            \"formula\": {\"Al\": 1.0, \"H\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -999810.0,\n            \"S_0\": 34.5,\n            \"V_0\": 1.786e-05,\n            \"Cp\": [145.1, 0.008709, 584400.0, -1741.1],\n            \"a_0\": 3.57e-05,\n            \"K_0\": 228000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 4.0,\n            \"molar_mass\": 0.05998824,\n        }\n        Mineral.__init__(self)",
  "class gth(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"gth\",\n            \"formula\": {\"Fe\": 1.0, \"H\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -561670.0,\n            \"S_0\": 60.3,\n            \"V_0\": 2.082e-05,\n            \"Cp\": [139.3, 0.000147, -212700.0, -1077.8],\n            \"a_0\": 4.35e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.03,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 4.0,\n            \"molar_mass\": 0.08885174,\n        }\n        Mineral.__init__(self)",
  "class cc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"cc\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1207790.0,\n            \"S_0\": 92.5,\n            \"V_0\": 3.689e-05,\n            \"Cp\": [140.9, 0.005029, -950700.0, -858.4],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 73300e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -5.5e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1000869,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1240.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 4e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class arag(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"arag\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1207690.0,\n            \"S_0\": 89.8,\n            \"V_0\": 3.415e-05,\n            \"Cp\": [167.1, 0.010695, 162000.0, -1564.9],\n            \"a_0\": 6.14e-05,\n            \"K_0\": 61400e6,\n            \"Kprime_0\": 5.87,\n            \"Kdprime_0\": -9.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1000869,\n        }\n        Mineral.__init__(self)",
  "class mag(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"mag\",\n            \"formula\": {\"C\": 1.0, \"Mg\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1110910.0,\n            \"S_0\": 65.5,\n            \"V_0\": 2.803e-05,\n            \"Cp\": [186.4, -0.003772, 0.0, -1886.2],\n            \"a_0\": 3.38e-05,\n            \"K_0\": 102800e6,\n            \"Kprime_0\": 5.41,\n            \"Kdprime_0\": -5.3e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.0843139,\n        }\n        Mineral.__init__(self)",
  "class sid(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"sid\",\n            \"formula\": {\"C\": 1.0, \"Fe\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -762120.0,\n            \"S_0\": 93.3,\n            \"V_0\": 2.943e-05,\n            \"Cp\": [168.4, 0.0, 0.0, -1483.6],\n            \"a_0\": 4.39e-05,\n            \"K_0\": 120000e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1158539,\n        }\n        Mineral.__init__(self)",
  "class rhc(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"rhc\",\n            \"formula\": {\"C\": 1.0, \"Mn\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -892280.0,\n            \"S_0\": 98.0,\n            \"V_0\": 3.107e-05,\n            \"Cp\": [169.5, 0.0, 0.0, -1534.3],\n            \"a_0\": 2.44e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1149469,\n        }\n        Mineral.__init__(self)",
  "class dol(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"dol\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2326270.0,\n            \"S_0\": 156.1,\n            \"V_0\": 6.429e-05,\n            \"Cp\": [358.9, -0.004905, 0.0, -3456.2],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 94300e6,\n            \"Kprime_0\": 3.74,\n            \"Kdprime_0\": -4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.1844008,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11910.0,\n                    \"deltaV\": 1.6e-07,\n                    \"Wh\": 11900.0,\n                    \"Wv\": 1.6e-07,\n                    \"n\": 1.0,\n                    \"factor\": 1.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class ank(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ank\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 1.0, \"Fe\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1971340.0,\n            \"S_0\": 188.46,\n            \"V_0\": 6.606e-05,\n            \"Cp\": [341.0, -0.001161, 0.0, -3054.8],\n            \"a_0\": 3.46e-05,\n            \"K_0\": 91400e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2159408,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11910.0,\n                    \"deltaV\": 1.6e-07,\n                    \"Wh\": 11900.0,\n                    \"Wv\": 1.6e-07,\n                    \"n\": 1.0,\n                    \"factor\": 1.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class syv(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"syv\",\n            \"formula\": {\"Cl\": 1.0, \"K\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -436500.0,\n            \"S_0\": 82.6,\n            \"V_0\": 3.752e-05,\n            \"Cp\": [46.2, 0.01797, 0.0, 0.0],\n            \"a_0\": 0.0001109,\n            \"K_0\": 17000e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -2.94e-10,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0745513,\n        }\n        Mineral.__init__(self)",
  "class hlt(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hlt\",\n            \"formula\": {\"Cl\": 1.0, \"Na\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -411300.0,\n            \"S_0\": 72.1,\n            \"V_0\": 2.702e-05,\n            \"Cp\": [45.2, 0.01797, 0.0, 0.0],\n            \"a_0\": 0.0001147,\n            \"K_0\": 23800e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -2.1e-10,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0584428,\n        }\n        Mineral.__init__(self)",
  "class pyr(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"pyr\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -171640.0,\n            \"S_0\": 52.9,\n            \"V_0\": 2.394e-05,\n            \"Cp\": [37.3, 0.026715, -1817000.0, 649.3],\n            \"a_0\": 3.1e-05,\n            \"K_0\": 139500e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -2.9e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.119975,\n        }\n        Mineral.__init__(self)",
  "class trot(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"trot\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -99030.0,\n            \"S_0\": 65.5,\n            \"V_0\": 1.819e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 5.68e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 598.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 4.1e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class tro(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"tro\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -97770.0,\n            \"S_0\": 70.8,\n            \"V_0\": 1.819e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 5.73e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 598.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 4.1e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class lot(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lot\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -102170.0,\n            \"S_0\": 60.0,\n            \"V_0\": 1.818e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 4.93e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 420.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class trov(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"trov\",\n            \"formula\": {\"Fe\": 0.875, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -96020.0,\n            \"S_0\": 57.5,\n            \"V_0\": 1.738e-05,\n            \"Cp\": [51.1, 0.008307, -669700.0, 0.0],\n            \"a_0\": 5.94e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 1.875,\n            \"molar_mass\": 0.080929375,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 595.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 1.6e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class any(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"any\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 4.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1434400.0,\n            \"S_0\": 106.9,\n            \"V_0\": 4.594e-05,\n            \"Cp\": [128.7, 0.048545, -1223000.0, -560.5],\n            \"a_0\": 4.18e-05,\n            \"K_0\": 54379999999.99999,\n            \"Kprime_0\": 4.19,\n            \"Kdprime_0\": -7.7e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.1361406,\n        }\n        Mineral.__init__(self)",
  "class iron(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"iron\",\n            \"formula\": {\"Fe\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -0.0,\n            \"S_0\": 27.09,\n            \"V_0\": 7.09e-06,\n            \"Cp\": [46.2, 0.005159, 723100.0, -556.2],\n            \"a_0\": 3.56e-05,\n            \"K_0\": 164000e6,\n            \"Kprime_0\": 5.16,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.055845,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1042.0,\n                    \"S_D\": 8.3,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class Ni(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Ni\",\n            \"formula\": {\"Ni\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 29.87,\n            \"V_0\": 6.59e-06,\n            \"Cp\": [49.8, 0.0, 585900.0, -533.9],\n            \"a_0\": 4.28e-05,\n            \"K_0\": 190500e6,\n            \"Kprime_0\": 4.25,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0586934,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\"P_0\": 100000.0, \"T_0\": 298.15, \"Tc_0\": 631.0, \"S_D\": 3.0, \"V_D\": 0.0},\n            ]\n        ]\n        Mineral.__init__(self)",
  "class Cu(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"Cu\",\n            \"formula\": {\"Cu\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -0.0,\n            \"S_0\": 33.14,\n            \"V_0\": 7.11e-06,\n            \"Cp\": [12.4, 0.00922, -379900.0, 233.5],\n            \"a_0\": 3.58e-05,\n            \"K_0\": 162500e6,\n            \"Kprime_0\": 4.24,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.063546,\n        }\n        Mineral.__init__(self)",
  "class gph(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"gph\",\n            \"formula\": {\"C\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 5.76,\n            \"V_0\": 5.3e-06,\n            \"Cp\": [34.3, 0.0, -240700.0, -403.8],\n            \"a_0\": 1.65e-05,\n            \"K_0\": 31200e6,\n            \"Kprime_0\": 3.9,\n            \"Kdprime_0\": -1.25e-10,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0120107,\n        }\n        Mineral.__init__(self)",
  "class diam(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"diam\",\n            \"formula\": {\"C\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 1890.0,\n            \"S_0\": 2.36,\n            \"V_0\": 3.42e-06,\n            \"Cp\": [40.0, 0.0, -28500.0, -580.5],\n            \"a_0\": 4e-06,\n            \"K_0\": 446500e6,\n            \"Kprime_0\": 1.61,\n            \"Kdprime_0\": -3.6e-12,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0120107,\n        }\n        Mineral.__init__(self)",
  "class S(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"S\",\n            \"formula\": {\"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 32.05,\n            \"V_0\": 1.551e-05,\n            \"Cp\": [56.6, -0.004557, 638000.0, -681.8],\n            \"a_0\": 6.4e-05,\n            \"K_0\": 14500e6,\n            \"Kprime_0\": 7.0,\n            \"Kdprime_0\": -4.8e-10,\n            \"n\": 1.0,\n            \"molar_mass\": 0.032065,\n        }\n        Mineral.__init__(self)",
  "class syvL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"syvL\",\n            \"formula\": {\"Cl\": 1.0, \"K\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -417410.0,\n            \"S_0\": 94.5,\n            \"V_0\": 3.822e-05,\n            \"Cp\": [66.9, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000301,\n            \"K_0\": 5600e6,\n            \"Kprime_0\": 4.65,\n            \"Kdprime_0\": -8.3e-10,\n            \"dKdT_0\": -2e6,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0745513,\n        }\n        Mineral.__init__(self)",
  "class hltL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hltL\",\n            \"formula\": {\"Cl\": 1.0, \"Na\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -392990.0,\n            \"S_0\": 80.1,\n            \"V_0\": 2.938e-05,\n            \"Cp\": [72.0, -0.003223, 0.0, 0.0],\n            \"a_0\": 0.000295,\n            \"K_0\": 6400e6,\n            \"Kprime_0\": 4.61,\n            \"Kdprime_0\": -7.2e-10,\n            \"dKdT_0\": -1500000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0584428,\n        }\n        Mineral.__init__(self)",
  "class perL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"perL\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -654190.0,\n            \"S_0\": -64.3,\n            \"V_0\": 8.39e-06,\n            \"Cp\": [99.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000226,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4100000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0403044,\n        }\n        Mineral.__init__(self)",
  "class limL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"limL\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -692330.0,\n            \"S_0\": -47.5,\n            \"V_0\": 1.303e-05,\n            \"Cp\": [99.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000175,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4100000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0560774,\n        }\n        Mineral.__init__(self)",
  "class corL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"corL\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1632150.0,\n            \"S_0\": 14.9,\n            \"V_0\": 3.369e-05,\n            \"Cp\": [157.6, 0.0, 0.0, 0.0],\n            \"a_0\": 7.03e-05,\n            \"K_0\": 15000e6,\n            \"Kprime_0\": 6.0,\n            \"Kdprime_0\": 4e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "class eskL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"eskL\",\n            \"formula\": {\"Cr\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1062180.0,\n            \"S_0\": 63.3,\n            \"V_0\": 3.709e-05,\n            \"Cp\": [157.6, 0.0, 0.0, 0.0],\n            \"a_0\": 7.03e-05,\n            \"K_0\": 15000e6,\n            \"Kprime_0\": 6.0,\n            \"Kdprime_0\": 4e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1519904,\n        }\n        Mineral.__init__(self)",
  "class hemL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"hemL\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -875130.0,\n            \"S_0\": -33.2,\n            \"V_0\": 3.2208e-05,\n            \"Cp\": [229.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0001953,\n            \"K_0\": 23000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.74e-10,\n            \"dKdT_0\": -4600000.0,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1596882,\n        }\n        Mineral.__init__(self)",
  "class qL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"qL\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -921080.0,\n            \"S_0\": 16.3,\n            \"V_0\": 2.73e-05,\n            \"Cp\": [82.5, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0,\n            \"K_0\": 22000e6,\n            \"Kprime_0\": 9.46,\n            \"Kdprime_0\": -4.3e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "class h2oL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"h2oL\",\n            \"formula\": {\"H\": 2.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -281650.0,\n            \"S_0\": 66.6,\n            \"V_0\": 1.3355e-05,\n            \"Cp\": [65.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000626,\n            \"K_0\": 4228e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -9.46e-10,\n            \"dKdT_0\": -1060000.0,\n            \"n\": 3.0,\n            \"molar_mass\": 0.01801528,\n        }\n        Mineral.__init__(self)",
  "class foL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"foL\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2237250.0,\n            \"S_0\": -62.0,\n            \"V_0\": 4.312e-05,\n            \"Cp\": [269.4, 0.0, 0.0, 0.0],\n            \"a_0\": 9.2e-05,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4400000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "class faL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"faL\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1462820.0,\n            \"S_0\": 96.0,\n            \"V_0\": 4.677e-05,\n            \"Cp\": [243.7, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0001071,\n            \"K_0\": 29000e6,\n            \"Kprime_0\": 10.42,\n            \"Kdprime_0\": -3.59e-10,\n            \"dKdT_0\": -5500000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "class woL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"woL\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1642570.0,\n            \"S_0\": 22.5,\n            \"V_0\": 3.985e-05,\n            \"Cp\": [167.4, 0.0, 0.0, 0.0],\n            \"a_0\": 6.69e-05,\n            \"K_0\": 32500e6,\n            \"Kprime_0\": 9.38,\n            \"Kdprime_0\": -3.08e-10,\n            \"dKdT_0\": -2e6,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "class enL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"enL\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3096310.0,\n            \"S_0\": -4.0,\n            \"V_0\": 6.984e-05,\n            \"Cp\": [353.6, 0.0, 0.0, 0.0],\n            \"a_0\": 6.81e-05,\n            \"K_0\": 21800e6,\n            \"Kprime_0\": 7.2,\n            \"Kdprime_0\": -3.3e-10,\n            \"dKdT_0\": -2400000.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "class diL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"diL\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3193790.0,\n            \"S_0\": 42.1,\n            \"V_0\": 7.288e-05,\n            \"Cp\": [334.0, 0.0, 0.0, 0.0],\n            \"a_0\": 8.51e-05,\n            \"K_0\": 24900e6,\n            \"Kprime_0\": 8.04,\n            \"Kdprime_0\": -3.23e-10,\n            \"dKdT_0\": -3730000.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2165504,\n        }\n        Mineral.__init__(self)",
  "class silL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"silL\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2593510.0,\n            \"S_0\": 10.0,\n            \"V_0\": 6.051e-05,\n            \"Cp\": [253.0, 0.0, 0.0, 0.0],\n            \"a_0\": 4.08e-05,\n            \"K_0\": 22000e6,\n            \"Kprime_0\": 6.36,\n            \"Kdprime_0\": -2.89e-10,\n            \"dKdT_0\": -2900000.0,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "class anL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"anL\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -4277920.0,\n            \"S_0\": 29.0,\n            \"V_0\": 0.00010014,\n            \"Cp\": [430.0, 0.0, 0.0, 0.0],\n            \"a_0\": 5.14e-05,\n            \"K_0\": 21000e6,\n            \"Kprime_0\": 6.38,\n            \"Kdprime_0\": -3.04e-10,\n            \"dKdT_0\": -5500000.0,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2782072,\n        }\n        Mineral.__init__(self)",
  "class kspL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"kspL\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3985340.0,\n            \"S_0\": 129.2,\n            \"V_0\": 0.00011431,\n            \"Cp\": [368.0, 0.0, 0.0, 0.0],\n            \"a_0\": 4.93e-05,\n            \"K_0\": 17300e6,\n            \"Kprime_0\": 6.84,\n            \"Kdprime_0\": -3.93e-10,\n            \"dKdT_0\": -899999.9999999999,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "class abL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"abL\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3925410.0,\n            \"S_0\": 149.9,\n            \"V_0\": 0.00010858,\n            \"Cp\": [358.0, 0.0, 0.0, 0.0],\n            \"a_0\": 3.37e-05,\n            \"K_0\": 17600e6,\n            \"Kprime_0\": 14.35,\n            \"Kdprime_0\": -8.15e-10,\n            \"dKdT_0\": -2600000.0,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        Mineral.__init__(self)",
  "class neL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"neL\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2117040.0,\n            \"S_0\": 52.9,\n            \"V_0\": 5.2e-05,\n            \"Cp\": [216.5, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000137,\n            \"K_0\": 25000e6,\n            \"Kprime_0\": 7.37,\n            \"Kdprime_0\": -2.95e-10,\n            \"dKdT_0\": -800000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "class lcL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"lcL\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3068560.0,\n            \"S_0\": 102.0,\n            \"V_0\": 8.59e-05,\n            \"Cp\": [287.0, 0.0, 0.0, 0.0],\n            \"a_0\": 6.7e-05,\n            \"K_0\": 17500e6,\n            \"Kprime_0\": 7.0,\n            \"Kdprime_0\": -3.94e-10,\n            \"dKdT_0\": -0.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2182472,\n        }\n        Mineral.__init__(self)",
  "class ruL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"ruL\",\n            \"formula\": {\"O\": 2.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -944300.0,\n            \"S_0\": 1.0,\n            \"V_0\": 1.7032e-05,\n            \"Cp\": [111.8, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0002901,\n            \"K_0\": 14900e6,\n            \"Kprime_0\": 8.0,\n            \"Kdprime_0\": -3.4e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0798658,\n        }\n        Mineral.__init__(self)",
  "class bdyL(Mineral):\n    def __init__(self):\n        self.params = {\n            \"name\": \"bdyL\",\n            \"formula\": {\"O\": 2.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1031880.0000000001,\n            \"S_0\": 48.9,\n            \"V_0\": 1.83e-05,\n            \"Cp\": [90.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0002,\n            \"K_0\": 14900e6,\n            \"Kprime_0\": 8.0,\n            \"Kdprime_0\": -3.4e-10,\n            \"dKdT_0\": -3e6,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1232228,\n        }\n        Mineral.__init__(self)",
  "def cov():\n    \"\"\"\n    A function which loads and returns the variance-covariance matrix of the\n    zero-point energies of all the endmembers in the dataset.\n\n    Returns\n    -------\n    cov : dictionary\n        Dictionary keys are:\n        - endmember_names: a list of endmember names, and\n        - covariance_matrix: a 2D variance-covariance array for the\n          endmember zero-point energies of formation\n    \"\"\"\n\n    from .HGP_2018_ds633_cov import cov\n\n    return cov",
  "def make_melt_class(selected_endmembers):\n    \"\"\"\n    A function that generates a melt class that is a subclass of the\n    Holland et al. (2018) silicate melt model.\n\n    Parameters\n    ----------\n    selected_endmembers: list of Minerals\n        Endmembers to include in the model.\n        Valid endmembers are given in the following list,\n        and should be specified in the same order\n        as they appear in the list:\n        ['q4L', 'sl1L', 'wo1L', 'fo2L', 'fa2L', 'jdL',\n        'hmL', 'ekL', 'tiL', 'kjL', 'ctL', 'h2o1L'].\n\n    Returns\n    -------\n    melt_class: Solution class\n        Melt class spanning the specified endmembers.\n    \"\"\"\n    endmembers = [[mbr, site_formulae[mbr.name]] for mbr in selected_endmembers]\n    alphas = [a[mbr.name] for mbr in selected_endmembers]\n    We = [\n        [\n            W[selected_endmembers[i].name][selected_endmembers[j].name][0] * 1.0e3\n            for j in range(i + 1, len(selected_endmembers))\n        ]\n        for i in range(len(selected_endmembers))\n    ]\n\n    Wv = [\n        [\n            W[selected_endmembers[i].name][selected_endmembers[j].name][2] * 1.0e-5\n            for j in range(i + 1, len(selected_endmembers))\n        ]\n        for i in range(len(selected_endmembers))\n    ]\n\n    class silicate_melt(Solution):\n        def __init__(self, molar_fractions=None):\n            self.name = \"Holland et al. (2018) melt model\"\n            self.solution_model = AsymmetricRegularSolution(\n                endmembers=endmembers,\n                energy_interaction=We,\n                volume_interaction=Wv,\n                alphas=alphas,\n            )\n\n            Solution.__init__(self, molar_fractions=molar_fractions)\n\n    return silicate_melt",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fo\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2172500.0,\n            \"S_0\": 95.1,\n            \"V_0\": 4.366e-05,\n            \"Cp\": [233.3, 0.001494, -603800.0, -1869.7],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 128500e6,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fa\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1477510.0,\n            \"S_0\": 151.0,\n            \"V_0\": 4.631e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.82e-05,\n            \"K_0\": 125600e6,\n            \"Kprime_0\": 4.68,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"teph\",\n            \"formula\": {\"Mn\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1733910.0,\n            \"S_0\": 155.9,\n            \"V_0\": 4.899e-05,\n            \"Cp\": [219.6, 0.0, -1292700.0, -1308.3],\n            \"a_0\": 2.86e-05,\n            \"K_0\": 125600e6,\n            \"Kprime_0\": 4.68,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2019591,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lrn\",\n            \"formula\": {\"Ca\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2306940.0,\n            \"S_0\": 127.6,\n            \"V_0\": 5.16e-05,\n            \"Cp\": [247.5, -0.003206, 0.0, -2051.9],\n            \"a_0\": 2.9e-05,\n            \"K_0\": 98500e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1722391,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1710.0,\n                    \"S_D\": 10.03,\n                    \"V_D\": 5e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mont\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2251230.0,\n            \"S_0\": 109.5,\n            \"V_0\": 5.148e-05,\n            \"Cp\": [250.7, -0.010433, -797200.0, -1996.1],\n            \"a_0\": 2.87e-05,\n            \"K_0\": 113400e6,\n            \"Kprime_0\": 3.87,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1564661,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"chum\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 9.0, \"O\": 18.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9613220.0,\n            \"S_0\": 440.5,\n            \"V_0\": 0.00019801,\n            \"Cp\": [1071.0, -0.016533, -7899600.0, -7373.9],\n            \"a_0\": 3.2e-05,\n            \"K_0\": 119900e6,\n            \"Kprime_0\": 4.58,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 33.0,\n            \"molar_mass\": 0.62109208,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"chdr\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 5.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5254760.0,\n            \"S_0\": 260.0,\n            \"V_0\": 0.00011084,\n            \"Cp\": [625.0, -0.001088, -2259900.0, -4910.7],\n            \"a_0\": 1.82e-05,\n            \"K_0\": 116100e6,\n            \"Kprime_0\": 4.8,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.33970588,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mwd\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2138060.0,\n            \"S_0\": 93.9,\n            \"V_0\": 4.051e-05,\n            \"Cp\": [208.7, 0.003942, -1709500.0, -1302.8],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 172600e6,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fwd\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1467690.0,\n            \"S_0\": 146.0,\n            \"V_0\": 4.321e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 169000e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mrw\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2126800.0,\n            \"S_0\": 90.0,\n            \"V_0\": 3.949e-05,\n            \"Cp\": [213.3, 0.00269, -1410400.0, -1495.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 178100e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"frw\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1471510.0,\n            \"S_0\": 140.0,\n            \"V_0\": 4.203e-05,\n            \"Cp\": [166.8, 0.04261, -1705400.0, -541.4],\n            \"a_0\": 2.22e-05,\n            \"K_0\": 197700e6,\n            \"Kprime_0\": 4.92,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mpv\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1442170.0,\n            \"S_0\": 62.6,\n            \"V_0\": 2.445e-05,\n            \"Cp\": [149.3, 0.002918, -2983000.0, -799.1],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 251000e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fpv\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1082690.0,\n            \"S_0\": 95.0,\n            \"V_0\": 2.534e-05,\n            \"Cp\": [133.2, 0.01083, -3661400.0, -314.7],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 281000e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1319287,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"apv\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1619680.0,\n            \"S_0\": 51.8,\n            \"V_0\": 2.54e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 203000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"npv\",\n            \"formula\": {\"Al\": 0.5, \"Na\": 0.5, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1365000.0,\n            \"S_0\": 63.0,\n            \"V_0\": 2.334e-05,\n            \"Cp\": [135.0, 0.00846, -1850300.0, -600.8],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 203000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.10106935,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ppv\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1418480.0,\n            \"S_0\": 60.4,\n            \"V_0\": 2.442e-05,\n            \"Cp\": [149.3, 0.002918, -2983000.0, -799.1],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 231200e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cpv\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1533570.0,\n            \"S_0\": 74.5,\n            \"V_0\": 2.745e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2e-05,\n            \"K_0\": 236000e6,\n            \"Kprime_0\": 3.9,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mak\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1489550.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 211000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fak\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1142110.0,\n            \"S_0\": 91.5,\n            \"V_0\": 2.76e-05,\n            \"Cp\": [100.3, 0.013328, -4364900.0, 419.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 218000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1319287,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"maj\",\n            \"formula\": {\"Mg\": 4.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6041720.0,\n            \"S_0\": 260.2,\n            \"V_0\": 0.00011457,\n            \"Cp\": [713.6, -0.000997, -1158200.0, -6622.3],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 160000e6,\n            \"Kprime_0\": 4.56,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4015548,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"nagt\",\n            \"formula\": {\"Al\": 1.0, \"Mg\": 2.0, \"Na\": 1.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5985000.0,\n            \"S_0\": 260.6,\n            \"V_0\": 0.0001109,\n            \"Cp\": [620.8, 0.0112, -3755900.0, -4421.3],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4029161,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"py\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6284740.0,\n            \"S_0\": 267.0,\n            \"V_0\": 0.00011313,\n            \"Cp\": [633.5, 0.0, -5196100.0, -4315.2],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 174300e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4031273,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"alm\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5267060.0,\n            \"S_0\": 337.0,\n            \"V_0\": 0.00011525,\n            \"Cp\": [716.2, -0.01241, -3160800.0, -5863.5],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 190000e6,\n            \"Kprime_0\": 2.98,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4977473,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"spss\",\n            \"formula\": {\"Al\": 2.0, \"Mn\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5692410.0,\n            \"S_0\": 335.3,\n            \"V_0\": 0.00011792,\n            \"Cp\": [646.9, 0.0, -4525800.0, -4452.8],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 6.68,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4950263,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"gr\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6642910.0,\n            \"S_0\": 255.0,\n            \"V_0\": 0.00012535,\n            \"Cp\": [626.0, 0.0, -5779200.0, -4002.9],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 172000e6,\n            \"Kprime_0\": 5.53,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4504463,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"andr\",\n            \"formula\": {\"Ca\": 3.0, \"Fe\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5768870.0,\n            \"S_0\": 316.4,\n            \"V_0\": 0.00013204,\n            \"Cp\": [638.6, 0.0, -4955100.0, -3989.2],\n            \"a_0\": 2.86e-05,\n            \"K_0\": 158800e6,\n            \"Kprime_0\": 5.68,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.5081733,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ski\",\n            \"formula\": {\"Fe\": 5.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4330840.0,\n            \"S_0\": 403.4,\n            \"V_0\": 0.00012144,\n            \"Cp\": [689.9, 0.0, -2948600.0, -5030.3],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 157400e6,\n            \"Kprime_0\": 6.7,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.5554743,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"knor\",\n            \"formula\": {\"Cr\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5701180.0,\n            \"S_0\": 302.0,\n            \"V_0\": 0.00011738,\n            \"Cp\": [613.0, 0.003606, -4178000.0, -3729.4],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 153400e6,\n            \"Kprime_0\": 4.34,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.4531565,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"uv\",\n            \"formula\": {\"Ca\": 3.0, \"Cr\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6057590.0,\n            \"S_0\": 320.9,\n            \"V_0\": 0.00013077,\n            \"Cp\": [605.1, 0.003606, -4760600.0, -3417.1],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 162000e6,\n            \"Kprime_0\": 4.7,\n            \"Kdprime_0\": -2.9e-11,\n            \"n\": 20.0,\n            \"molar_mass\": 0.5004755,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"osma\",\n            \"formula\": {\"Al\": 5.0, \"K\": 1.0, \"Mg\": 2.0, \"O\": 30.0, \"Si\": 10.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14896020.0,\n            \"S_0\": 755.0,\n            \"V_0\": 0.00037893,\n            \"Cp\": [1540.7, -0.011359, -10339000.0, -11699.0],\n            \"a_0\": 4.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 0.9834528,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"osmm\",\n            \"formula\": {\"Al\": 3.0, \"K\": 1.0, \"Mg\": 3.0, \"O\": 30.0, \"Si\": 11.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14786240.0,\n            \"S_0\": 740.0,\n            \"V_0\": 0.0003844,\n            \"Cp\": [1525.5, -0.010267, -10538000.0, -11337.0],\n            \"a_0\": 4.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 0.9818803,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"osfa\",\n            \"formula\": {\"Al\": 5.0, \"Fe\": 2.0, \"K\": 1.0, \"O\": 30.0, \"Si\": 10.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14215310.0,\n            \"S_0\": 780.0,\n            \"V_0\": 0.0003845,\n            \"Cp\": [1558.6, -0.011359, -9476500.0, -11845.0],\n            \"a_0\": 4.9e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 48.0,\n            \"molar_mass\": 1.0465328,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"vsv\",\n            \"formula\": {\n                \"Al\": 11.0,\n                \"Ca\": 19.0,\n                \"H\": 9.0,\n                \"Mg\": 2.0,\n                \"O\": 78.0,\n                \"Si\": 18.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -42345130.0,\n            \"S_0\": 1890.0,\n            \"V_0\": 0.000852,\n            \"Cp\": [4488.0, -0.057952, -22269300.0, -33478.0],\n            \"a_0\": 2.75e-05,\n            \"K_0\": 125500e6,\n            \"Kprime_0\": 4.8,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 137.0,\n            \"molar_mass\": 2.86945216,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"and\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2588600.0,\n            \"S_0\": 92.7,\n            \"V_0\": 5.153e-05,\n            \"Cp\": [277.3, -0.006588, -1914100.0, -2265.6],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 144200e6,\n            \"Kprime_0\": 6.89,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ky\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2592900.0,\n            \"S_0\": 83.5,\n            \"V_0\": 4.414e-05,\n            \"Cp\": [279.4, -0.007124, -2055600.0, -2289.4],\n            \"a_0\": 1.92e-05,\n            \"K_0\": 160100e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sill\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2585690.0,\n            \"S_0\": 95.4,\n            \"V_0\": 4.986e-05,\n            \"Cp\": [280.2, -0.0069, -1375700.0, -2399.4],\n            \"a_0\": 1.12e-05,\n            \"K_0\": 164000e6,\n            \"Kprime_0\": 5.06,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 4750.0,\n                    \"deltaV\": 1e-07,\n                    \"Wh\": 4750.0,\n                    \"Wv\": 1e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.25,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"smul\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2569210.0,\n            \"S_0\": 101.5,\n            \"V_0\": 4.987e-05,\n            \"Cp\": [280.2, -0.0069, -1375700.0, -2399.4],\n            \"a_0\": 1.36e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"amul\",\n            \"formula\": {\"Al\": 2.5, \"O\": 4.75, \"Si\": 0.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2485660.0,\n            \"S_0\": 113.0,\n            \"V_0\": 5.083e-05,\n            \"Cp\": [244.8, 0.000968, -2533300.0, -1641.6],\n            \"a_0\": 1.36e-05,\n            \"K_0\": 174000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 7.75,\n            \"molar_mass\": 0.15749365,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tpz\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2900640.0,\n            \"S_0\": 100.5,\n            \"V_0\": 5.339e-05,\n            \"Cp\": [387.7, -0.00712, -857200.0, -3744.2],\n            \"a_0\": 1.57e-05,\n            \"K_0\": 131500e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 11.0,\n            \"molar_mass\": 0.18006078,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mst\",\n            \"formula\": {\"Al\": 18.0, \"H\": 4.0, \"Mg\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -25122970.0,\n            \"S_0\": 910.0,\n            \"V_0\": 0.0004426,\n            \"Cp\": [2820.5, -0.059366, -13774000.0, -24126.0],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 168400e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.56553121,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fst\",\n            \"formula\": {\"Al\": 18.0, \"Fe\": 4.0, \"H\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -23755130.0,\n            \"S_0\": 1010.0,\n            \"V_0\": 0.0004488,\n            \"Cp\": [2880.0, -0.056595, -10642000.0, -25373.0],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.76,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.69169121,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mnst\",\n            \"formula\": {\"Al\": 18.0, \"H\": 4.0, \"Mn\": 4.0, \"O\": 48.0, \"Si\": 7.5},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -24242690.0,\n            \"S_0\": 1034.0,\n            \"V_0\": 0.0004546,\n            \"Cp\": [2873.3, -0.089064, -12688000.0, -24749.0],\n            \"a_0\": 2.09e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.76,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 81.5,\n            \"molar_mass\": 1.68806321,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mctd\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mg\": 1.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3549210.0,\n            \"S_0\": 146.0,\n            \"V_0\": 6.875e-05,\n            \"Cp\": [417.4, -0.003771, -2920600.0, -3417.8],\n            \"a_0\": 2.63e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.22036518,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fctd\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"H\": 2.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3208500.0,\n            \"S_0\": 167.0,\n            \"V_0\": 6.98e-05,\n            \"Cp\": [416.1, -0.003477, -2835900.0, -3360.3],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.25190518,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mnctd\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mn\": 1.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3335510.0,\n            \"S_0\": 166.0,\n            \"V_0\": 7.175e-05,\n            \"Cp\": [464.4, -0.012654, -1147200.0, -4341.0],\n            \"a_0\": 2.6e-05,\n            \"K_0\": 145600e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.25099818,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"merw\",\n            \"formula\": {\"Ca\": 3.0, \"Mg\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4545690.0,\n            \"S_0\": 253.1,\n            \"V_0\": 9.847e-05,\n            \"Cp\": [417.5, 0.008117, -2923000.0, -2320.3],\n            \"a_0\": 3.19e-05,\n            \"K_0\": 120000e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 14.0,\n            \"molar_mass\": 0.3287052,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"spu\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 5.0, \"O\": 11.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5846800.0,\n            \"S_0\": 332.0,\n            \"V_0\": 0.00014697,\n            \"Cp\": [614.1, -0.003508, -2493100.0, -4168.0],\n            \"a_0\": 3.4e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.4445651,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"zo\",\n            \"formula\": {\"Al\": 3.0, \"Ca\": 2.0, \"H\": 1.0, \"O\": 13.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6896150.0,\n            \"S_0\": 298.0,\n            \"V_0\": 0.00013575,\n            \"Cp\": [662.0, 0.010416, -6006400.0, -4260.7],\n            \"a_0\": 3.12e-05,\n            \"K_0\": 104400e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.45435714,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cz\",\n            \"formula\": {\"Al\": 3.0, \"Ca\": 2.0, \"H\": 1.0, \"O\": 13.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6895400.0,\n            \"S_0\": 301.0,\n            \"V_0\": 0.0001363,\n            \"Cp\": [630.9, 0.013693, -6645800.0, -3731.1],\n            \"a_0\": 2.33e-05,\n            \"K_0\": 119700e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.45435714,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ep\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Ca\": 2.0,\n                \"Fe\": 1.0,\n                \"H\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6473650.0,\n            \"S_0\": 315.0,\n            \"V_0\": 0.0001392,\n            \"Cp\": [613.3, 0.02207, -7160000.0, -2987.7],\n            \"a_0\": 2.34e-05,\n            \"K_0\": 134000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.48322064,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fep\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"Ca\": 2.0,\n                \"Fe\": 2.0,\n                \"H\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6028290.0,\n            \"S_0\": 329.0,\n            \"V_0\": 0.0001421,\n            \"Cp\": [584.7, 0.030447, -7674200.0, -2244.3],\n            \"a_0\": 2.31e-05,\n            \"K_0\": 151300e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.51208414,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pmt\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Ca\": 2.0,\n                \"H\": 1.0,\n                \"Mn\": 1.0,\n                \"O\": 13.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6542600.0,\n            \"S_0\": 340.0,\n            \"V_0\": 0.0001382,\n            \"Cp\": [569.8, 0.02779, -5442900.0, -2812.6],\n            \"a_0\": 2.38e-05,\n            \"K_0\": 119700e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.48231364,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"law\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 4.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4868550.0,\n            \"S_0\": 229.0,\n            \"V_0\": 0.00010132,\n            \"Cp\": [687.8, 0.001566, 375900.0, -7179.2],\n            \"a_0\": 2.65e-05,\n            \"K_0\": 122900e6,\n            \"Kprime_0\": 5.45,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.31423776,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mpm\",\n            \"formula\": {\n                \"Al\": 5.0,\n                \"Ca\": 4.0,\n                \"H\": 7.0,\n                \"Mg\": 1.0,\n                \"O\": 28.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14386650.0,\n            \"S_0\": 629.0,\n            \"V_0\": 0.0002955,\n            \"Cp\": [1720.8, -0.024928, -5998700.0, -14620.3],\n            \"a_0\": 2.48e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 0.94307628,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fpm\",\n            \"formula\": {\n                \"Al\": 5.0,\n                \"Ca\": 4.0,\n                \"Fe\": 1.0,\n                \"H\": 7.0,\n                \"O\": 28.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14034030.0,\n            \"S_0\": 657.0,\n            \"V_0\": 0.0002968,\n            \"Cp\": [1737.2, -0.024582, -5161100.0, -14963.0],\n            \"a_0\": 2.49e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 0.97461628,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"jgd\",\n            \"formula\": {\"Ca\": 4.0, \"Fe\": 6.0, \"H\": 7.0, \"O\": 28.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11808710.0,\n            \"S_0\": 830.0,\n            \"V_0\": 0.0003108,\n            \"Cp\": [1795.4, -0.037986, -4455700.0, -14888.0],\n            \"a_0\": 2.49e-05,\n            \"K_0\": 161500e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 51.0,\n            \"molar_mass\": 1.11893378,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"geh\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 2.0, \"O\": 7.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3992180.0,\n            \"S_0\": 198.5,\n            \"V_0\": 9.024e-05,\n            \"Cp\": [405.7, -0.007099, -1188300.0, -3174.4],\n            \"a_0\": 2.23e-05,\n            \"K_0\": 108000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2742003,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 7510.0,\n                    \"deltaV\": 9e-07,\n                    \"Wh\": 7500.0,\n                    \"Wv\": 9e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.8,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ak\",\n            \"formula\": {\"Ca\": 2.0, \"Mg\": 1.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3865580.0,\n            \"S_0\": 212.5,\n            \"V_0\": 9.254e-05,\n            \"Cp\": [385.4, 0.003209, -247500.0, -2889.9],\n            \"a_0\": 2.57e-05,\n            \"K_0\": 142000e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.9e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2726278,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"rnk\",\n            \"formula\": {\"Ca\": 3.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3943840.0,\n            \"S_0\": 210.0,\n            \"V_0\": 9.651e-05,\n            \"Cp\": [372.3, -0.002893, -2462400.0, -2181.3],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.2884008,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ty\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 5.0, \"O\": 13.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6368130.0,\n            \"S_0\": 390.0,\n            \"V_0\": 0.00017039,\n            \"Cp\": [741.7, -0.005345, -1434600.0, -5878.5],\n            \"a_0\": 3.42e-05,\n            \"K_0\": 95000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 22.0,\n            \"molar_mass\": 0.4885746,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"crd\",\n            \"formula\": {\"Al\": 4.0, \"Mg\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9163180.0,\n            \"S_0\": 404.1,\n            \"V_0\": 0.00023322,\n            \"Cp\": [906.1, 0.0, -7902000.0, -6293.4],\n            \"a_0\": 6.8e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.5849527,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hcrd\",\n            \"formula\": {\"Al\": 4.0, \"H\": 2.0, \"Mg\": 2.0, \"O\": 19.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9448270.0,\n            \"S_0\": 483.0,\n            \"V_0\": 0.00023322,\n            \"Cp\": [955.3, 0.0, -8352600.0, -6301.2],\n            \"a_0\": 6.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 32.0,\n            \"molar_mass\": 0.60296798,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fcrd\",\n            \"formula\": {\"Al\": 4.0, \"Fe\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8444070.0,\n            \"S_0\": 461.0,\n            \"V_0\": 0.0002371,\n            \"Cp\": [924.0, 0.0, -7039400.0, -6439.6],\n            \"a_0\": 6.7e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.6480327,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mncrd\",\n            \"formula\": {\"Al\": 4.0, \"Mn\": 2.0, \"O\": 18.0, \"Si\": 5.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8692150.0,\n            \"S_0\": 473.0,\n            \"V_0\": 0.00024027,\n            \"Cp\": [886.5, 0.0, -8840000.0, -5590.4],\n            \"a_0\": 6.9e-06,\n            \"K_0\": 129000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.6462187,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 36710.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 36700.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 2.0,\n                    \"factor\": 1.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"phA\",\n            \"formula\": {\"H\": 6.0, \"Mg\": 7.0, \"O\": 14.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7129610.0,\n            \"S_0\": 350.5,\n            \"V_0\": 0.00015422,\n            \"Cp\": [962.0, -0.011521, -4517800.0, -7724.7],\n            \"a_0\": 3.55e-05,\n            \"K_0\": 145000e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": 29.0,\n            \"molar_mass\": 0.45634524,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"phD\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2670160.0,\n            \"S_0\": 111.2,\n            \"V_0\": 5.103e-05,\n            \"Cp\": [294.6, 0.007944, -5008700.0, -1335.5],\n            \"a_0\": 3.79e-05,\n            \"K_0\": 165000e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 11.0,\n            \"molar_mass\": 0.17848828,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"phE\",\n            \"formula\": {\"H\": 2.4, \"Mg\": 2.4, \"O\": 6.0, \"Si\": 1.2},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2931150.0,\n            \"S_0\": 169.0,\n            \"V_0\": 6.435e-05,\n            \"Cp\": [397.4, -0.003533, -1344400.0, -3290.2],\n            \"a_0\": 3.79e-05,\n            \"K_0\": 93000e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 12.0,\n            \"molar_mass\": 0.190450056,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"shB\",\n            \"formula\": {\"H\": 4.0, \"Mg\": 10.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9477320.0,\n            \"S_0\": 396.0,\n            \"V_0\": 0.00018615,\n            \"Cp\": [1077.7, 0.000642, -7407400.0, -7428.7],\n            \"a_0\": 3.56e-05,\n            \"K_0\": 132000e6,\n            \"Kprime_0\": 5.3,\n            \"Kdprime_0\": -3.91e-11,\n            \"n\": 35.0,\n            \"molar_mass\": 0.61932746,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sph\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 5.0, \"Si\": 1.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2601450.0,\n            \"S_0\": 124.0,\n            \"V_0\": 5.565e-05,\n            \"Cp\": [227.9, 0.002924, -3539500.0, -894.3],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 101700e6,\n            \"Kprime_0\": 9.85,\n            \"Kdprime_0\": -9.7e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1960275,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 485.0,\n                    \"S_D\": 0.4,\n                    \"V_D\": 5e-08,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cstn\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 5.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2482910.0,\n            \"S_0\": 99.5,\n            \"V_0\": 4.818e-05,\n            \"Cp\": [205.6, 0.006034, -5517700.0, -352.6],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 178200e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 8.0,\n            \"molar_mass\": 0.176246,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"zrc\",\n            \"formula\": {\"O\": 4.0, \"Si\": 1.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2035140.0,\n            \"S_0\": 83.03,\n            \"V_0\": 3.926e-05,\n            \"Cp\": [232.0, -0.014405, 0.0, -2238.2],\n            \"a_0\": 1.25e-05,\n            \"K_0\": 230100e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.1833071,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"zrt\",\n            \"formula\": {\"O\": 4.0, \"Ti\": 1.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1998020.0,\n            \"S_0\": 98.0,\n            \"V_0\": 4.42e-05,\n            \"Cp\": [214.6, -0.008226, 190300.0, -1820.4],\n            \"a_0\": 1.25e-05,\n            \"K_0\": 230100e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.2030886,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tcn\",\n            \"formula\": {\"O\": 4.0, \"Si\": 1.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1766360.0,\n            \"S_0\": 77.0,\n            \"V_0\": 3.493e-05,\n            \"Cp\": [208.6, -0.003669, 113000.0, -1906.9],\n            \"a_0\": 1.25e-05,\n            \"K_0\": 230100e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.1399501,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"en\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3089960.0,\n            \"S_0\": 132.5,\n            \"V_0\": 6.262e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pren\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3084300.0,\n            \"S_0\": 137.0,\n            \"V_0\": 6.476e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.3e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cen\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3090850.0,\n            \"S_0\": 132.0,\n            \"V_0\": 6.264e-05,\n            \"Cp\": [306.0, -0.003793, -3041700.0, -1852.1],\n            \"a_0\": 2.11e-05,\n            \"K_0\": 105900e6,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hen\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3082460.0,\n            \"S_0\": 131.7,\n            \"V_0\": 6.099e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.26e-05,\n            \"K_0\": 150000e6,\n            \"Kprime_0\": 5.5,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hfs\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2380550.0,\n            \"S_0\": 189.0,\n            \"V_0\": 6.405e-05,\n            \"Cp\": [398.7, -0.006579, 1290100.0, -4058.0],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 150000e6,\n            \"Kprime_0\": 5.5,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2638574,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fs\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2388500.0,\n            \"S_0\": 189.9,\n            \"V_0\": 6.592e-05,\n            \"Cp\": [398.7, -0.006579, 1290100.0, -4058.0],\n            \"a_0\": 3.26e-05,\n            \"K_0\": 101000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2638574,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mgts\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3200660.0,\n            \"S_0\": 128.5,\n            \"V_0\": 6.05e-05,\n            \"Cp\": [371.4, -0.004082, -398400.0, -3547.1],\n            \"a_0\": 2.17e-05,\n            \"K_0\": 102800e6,\n            \"Kprime_0\": 8.55,\n            \"Kdprime_0\": -8.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2023499,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"di\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3201780.0,\n            \"S_0\": 142.9,\n            \"V_0\": 6.619e-05,\n            \"Cp\": [314.5, 4.1e-05, -2745900.0, -2020.1],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2165504,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hed\",\n            \"formula\": {\"Ca\": 1.0, \"Fe\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2841970.0,\n            \"S_0\": 175.0,\n            \"V_0\": 6.795e-05,\n            \"Cp\": [340.2, 0.000812, -1047800.0, -2646.7],\n            \"a_0\": 2.38e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 3.97,\n            \"Kdprime_0\": -3.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2480904,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"jd\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3025370.0,\n            \"S_0\": 133.5,\n            \"V_0\": 6.04e-05,\n            \"Cp\": [319.4, 0.003616, -1173900.0, -2469.5],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 128100e6,\n            \"Kprime_0\": 3.81,\n            \"Kdprime_0\": -3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2021387,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kjd\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2932700.0,\n            \"S_0\": 141.24,\n            \"V_0\": 6.479e-05,\n            \"Cp\": [316.2, 0.006905, -905300.0, -2489.0],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 145000e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2182472,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"acm\",\n            \"formula\": {\"Fe\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2583270.0,\n            \"S_0\": 170.6,\n            \"V_0\": 6.459e-05,\n            \"Cp\": [307.1, 0.016758, -1685500.0, -2125.8],\n            \"a_0\": 2.11e-05,\n            \"K_0\": 106000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.8e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2310022,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kos\",\n            \"formula\": {\"Cr\": 1.0, \"Na\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2744890.0,\n            \"S_0\": 149.65,\n            \"V_0\": 6.309e-05,\n            \"Cp\": [309.2, 0.005419, -664600.0, -2176.6],\n            \"a_0\": 1.94e-05,\n            \"K_0\": 130800e6,\n            \"Kprime_0\": 3.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2271533,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cats\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 6.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3310050.0,\n            \"S_0\": 135.0,\n            \"V_0\": 6.356e-05,\n            \"Cp\": [347.6, -0.006974, -1781600.0, -2757.5],\n            \"a_0\": 2.08e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2181229,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 3800.0,\n                    \"deltaV\": 1e-07,\n                    \"Wh\": 3800.0,\n                    \"Wv\": 1e-07,\n                    \"n\": 1.0,\n                    \"factor\": 0.25,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"caes\",\n            \"formula\": {\"Al\": 1.0, \"Ca\": 0.5, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3001960.0,\n            \"S_0\": 127.0,\n            \"V_0\": 6.05e-05,\n            \"Cp\": [362.0, -0.016944, -175900.0, -3565.7],\n            \"a_0\": 2.31e-05,\n            \"K_0\": 119200e6,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 9.5,\n            \"molar_mass\": 0.1991879,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"rhod\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1322350.0,\n            \"S_0\": 100.5,\n            \"V_0\": 3.494e-05,\n            \"Cp\": [138.4, 0.004088, -1936000.0, -538.9],\n            \"a_0\": 2.81e-05,\n            \"K_0\": 84000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1310217,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pxmn\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1323130.0,\n            \"S_0\": 99.3,\n            \"V_0\": 3.472e-05,\n            \"Cp\": [138.4, 0.004088, -1936000.0, -538.9],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 84000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1310217,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"wo\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1633760.0,\n            \"S_0\": 82.5,\n            \"V_0\": 3.993e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2.54e-05,\n            \"K_0\": 79500e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pswo\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1627960.0,\n            \"S_0\": 87.8,\n            \"V_0\": 4.008e-05,\n            \"Cp\": [157.8, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 110000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"wal\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1625600.0,\n            \"S_0\": 84.5,\n            \"V_0\": 3.7633e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 3.2e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tr\",\n            \"formula\": {\"Ca\": 2.0, \"H\": 2.0, \"Mg\": 5.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12304300.0,\n            \"S_0\": 553.0,\n            \"V_0\": 0.0002727,\n            \"Cp\": [1260.2, 0.00383, -11455000.0, -8237.6],\n            \"a_0\": 2.61e-05,\n            \"K_0\": 76200e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.81236648,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fact\",\n            \"formula\": {\"Ca\": 2.0, \"Fe\": 5.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10503600.0,\n            \"S_0\": 710.0,\n            \"V_0\": 0.0002842,\n            \"Cp\": [1290.0, 0.029992, -8447500.0, -8947.0],\n            \"a_0\": 2.88e-05,\n            \"K_0\": 76000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.97006648,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ts\",\n            \"formula\": {\n                \"Al\": 4.0,\n                \"Ca\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"O\": 24.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12554640.0,\n            \"S_0\": 533.0,\n            \"V_0\": 0.000268,\n            \"Cp\": [1244.8, 0.024348, -11965000.0, -8112.1],\n            \"a_0\": 2.66e-05,\n            \"K_0\": 76000e6,\n            \"Kprime_0\": 4.1,\n            \"Kdprime_0\": -5.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.81551148,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"parg\",\n            \"formula\": {\n                \"Al\": 3.0,\n                \"Ca\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 4.0,\n                \"Na\": 1.0,\n                \"O\": 24.0,\n                \"Si\": 6.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12664760.0,\n            \"S_0\": 635.0,\n            \"V_0\": 0.0002719,\n            \"Cp\": [1280.2, 0.022997, -12359500.0, -8065.8],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 91200e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.5e-11,\n            \"n\": 42.0,\n            \"molar_mass\": 0.83582478,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"gl\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 2.0,\n                \"O\": 24.0,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11955920.0,\n            \"S_0\": 530.0,\n            \"V_0\": 0.0002598,\n            \"Cp\": [1717.5, -0.12107, 7075000.0, -19272.0],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 88300e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78354308,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fgl\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Fe\": 3.0,\n                \"H\": 2.0,\n                \"Na\": 2.0,\n                \"O\": 24.0,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10879520.0,\n            \"S_0\": 624.0,\n            \"V_0\": 0.0002659,\n            \"Cp\": [1762.9, -0.118992, 9423700.0, -20207.1],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 89000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.87816308,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"nyb\",\n            \"formula\": {\n                \"Al\": 3.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 3.0,\n                \"O\": 24.0,\n                \"Si\": 7.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12165450.0,\n            \"S_0\": 622.0,\n            \"V_0\": 0.00026314,\n            \"Cp\": [1745.2, -0.112162, 6425500.0, -19163.0],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 91000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.5e-11,\n            \"n\": 42.0,\n            \"molar_mass\": 0.80542888,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"rieb\",\n            \"formula\": {\"Fe\": 5.0, \"H\": 2.0, \"Na\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10024100.0,\n            \"S_0\": 695.0,\n            \"V_0\": 0.0002749,\n            \"Cp\": [1787.3, -0.124882, 9627100.0, -20275.5],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 89000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.6e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.93589008,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"anth\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 7.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12065900.0,\n            \"S_0\": 537.0,\n            \"V_0\": 0.0002654,\n            \"Cp\": [1277.3, 0.025825, -9704600.0, -9074.7],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78082048,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fanth\",\n            \"formula\": {\"Fe\": 7.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9623750.0,\n            \"S_0\": 725.0,\n            \"V_0\": 0.0002787,\n            \"Cp\": [1383.1, 0.030669, -4224700.0, -11257.6],\n            \"a_0\": 2.74e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 1.00160048,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cumm\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 7.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12063750.0,\n            \"S_0\": 538.0,\n            \"V_0\": 0.0002633,\n            \"Cp\": [1277.3, 0.025825, -9704600.0, -9074.7],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78082048,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"grun\",\n            \"formula\": {\"Fe\": 7.0, \"H\": 2.0, \"O\": 24.0, \"Si\": 8.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9606390.0,\n            \"S_0\": 735.0,\n            \"V_0\": 0.0002784,\n            \"Cp\": [1383.1, 0.030669, -4224700.0, -11257.6],\n            \"a_0\": 2.74e-05,\n            \"K_0\": 64800e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 1.00160048,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ged\",\n            \"formula\": {\"Al\": 4.0, \"H\": 2.0, \"Mg\": 5.0, \"O\": 24.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12306610.0,\n            \"S_0\": 535.0,\n            \"V_0\": 0.00025956,\n            \"Cp\": [1307.7, 0.023642, -9307400.0, -9799.0],\n            \"a_0\": 2.41e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 41.0,\n            \"molar_mass\": 0.78396548,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"spr4\",\n            \"formula\": {\"Al\": 8.0, \"Mg\": 4.0, \"O\": 20.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11020350.0,\n            \"S_0\": 425.5,\n            \"V_0\": 0.000199,\n            \"Cp\": [1133.1, -0.007596, -8816600.0, -8180.6],\n            \"a_0\": 2.05e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.689231,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"spr5\",\n            \"formula\": {\"Al\": 10.0, \"Mg\": 3.0, \"O\": 20.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -11135050.0,\n            \"S_0\": 419.5,\n            \"V_0\": 0.0001975,\n            \"Cp\": [1103.4, 0.001015, -10957000.0, -7409.2],\n            \"a_0\": 2.06e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.6908035,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fspr\",\n            \"formula\": {\"Al\": 8.0, \"Fe\": 4.0, \"O\": 20.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9658040.0,\n            \"S_0\": 485.0,\n            \"V_0\": 0.00019923,\n            \"Cp\": [1132.9, -0.007348, -10420200.0, -7036.6],\n            \"a_0\": 1.96e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 34.0,\n            \"molar_mass\": 0.815391,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mcar\",\n            \"formula\": {\"Al\": 2.0, \"H\": 4.0, \"Mg\": 1.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4770850.0,\n            \"S_0\": 221.5,\n            \"V_0\": 0.0001059,\n            \"Cp\": [683.0, -0.014054, 291000.0, -6976.4],\n            \"a_0\": 2.43e-05,\n            \"K_0\": 52500e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -7.9e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.29846476,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fcar\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"H\": 4.0, \"O\": 10.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4411490.0,\n            \"S_0\": 251.1,\n            \"V_0\": 0.00010695,\n            \"Cp\": [686.6, -0.012415, 186000.0, -6884.0],\n            \"a_0\": 2.21e-05,\n            \"K_0\": 52500e6,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -7.9e-11,\n            \"n\": 19.0,\n            \"molar_mass\": 0.33000476,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"deer\",\n            \"formula\": {\"Fe\": 18.0, \"H\": 10.0, \"O\": 50.0, \"Si\": 12.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -18339500.0,\n            \"S_0\": 1650.0,\n            \"V_0\": 0.0005574,\n            \"Cp\": [3164.4, -0.027883, -5039100.0, -26721.0],\n            \"a_0\": 2.75e-05,\n            \"K_0\": 63000e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.5e-11,\n            \"n\": 90.0,\n            \"molar_mass\": 2.1522854,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mu\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5976510.0,\n            \"S_0\": 292.0,\n            \"V_0\": 0.00014083,\n            \"Cp\": [756.4, -0.01984, -2170000.0, -6979.2],\n            \"a_0\": 3.07e-05,\n            \"K_0\": 49000e6,\n            \"Kprime_0\": 4.15,\n            \"Kdprime_0\": -8.5e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39830798,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cel\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 1.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5834860.0,\n            \"S_0\": 290.0,\n            \"V_0\": 0.00013957,\n            \"Cp\": [741.2, -0.018748, -2368800.0, -6616.9],\n            \"a_0\": 3.07e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39673548,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fcel\",\n            \"formula\": {\"Al\": 1.0, \"Fe\": 1.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5468630.0,\n            \"S_0\": 330.0,\n            \"V_0\": 0.0001407,\n            \"Cp\": [756.3, -0.019147, -1586100.0, -6928.7],\n            \"a_0\": 3.18e-05,\n            \"K_0\": 70000e6,\n            \"Kprime_0\": 4.11,\n            \"Kdprime_0\": -5.9e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.42827548,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pa\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"Na\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5942660.0,\n            \"S_0\": 277.0,\n            \"V_0\": 0.00013211,\n            \"Cp\": [803.0, -0.03158, 217000.0, -8151.0],\n            \"a_0\": 3.7e-05,\n            \"K_0\": 51500e6,\n            \"Kprime_0\": 6.51,\n            \"Kdprime_0\": -1.26e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.38219948,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ma\",\n            \"formula\": {\"Al\": 4.0, \"Ca\": 1.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6241920.0,\n            \"S_0\": 265.0,\n            \"V_0\": 0.00012964,\n            \"Cp\": [744.4, -0.0168, -2074400.0, -6783.2],\n            \"a_0\": 2.33e-05,\n            \"K_0\": 100000e6,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.39818368,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"phl\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6214610.0,\n            \"S_0\": 326.0,\n            \"V_0\": 0.00014964,\n            \"Cp\": [770.3, -0.036939, -2328900.0, -6531.6],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.41725998,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ann\",\n            \"formula\": {\"Al\": 1.0, \"Fe\": 3.0, \"H\": 2.0, \"K\": 1.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5143590.0,\n            \"S_0\": 420.0,\n            \"V_0\": 0.00015432,\n            \"Cp\": [815.7, -0.034861, 19800.0, -7466.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.51187998,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mnbi\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"Mn\": 3.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5475460.0,\n            \"S_0\": 433.0,\n            \"V_0\": 0.00015264,\n            \"Cp\": [809.9, -0.059213, -1514400.0, -6998.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 53000e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.50915898,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"east\",\n            \"formula\": {\"Al\": 3.0, \"H\": 2.0, \"K\": 1.0, \"Mg\": 2.0, \"O\": 12.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6330120.0,\n            \"S_0\": 318.0,\n            \"V_0\": 0.00014738,\n            \"Cp\": [785.5, -0.038031, -2130300.0, -6893.7],\n            \"a_0\": 3.8e-05,\n            \"K_0\": 53000e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.41883248,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"naph\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 1.0,\n                \"O\": 12.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6164670.0,\n            \"S_0\": 318.0,\n            \"V_0\": 0.0001445,\n            \"Cp\": [773.5, -0.040229, -2597900.0, -6512.6],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.40115148,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tan\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5899790.0,\n            \"S_0\": 259.0,\n            \"V_0\": 0.00013665,\n            \"Cp\": [622.2, 0.0, -6385500.0, -3916.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.37926568,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"clin\",\n            \"formula\": {\"Al\": 2.0, \"H\": 8.0, \"Mg\": 5.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8908950.0,\n            \"S_0\": 437.0,\n            \"V_0\": 0.0002114,\n            \"Cp\": [1170.8, -0.001508, -3825800.0, -10315.0],\n            \"a_0\": 2.04e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55579722,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ames\",\n            \"formula\": {\"Al\": 4.0, \"H\": 8.0, \"Mg\": 4.0, \"O\": 18.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -9040330.0,\n            \"S_0\": 412.0,\n            \"V_0\": 0.0002071,\n            \"Cp\": [1186.0, -0.002599, -3627200.0, -10677.0],\n            \"a_0\": 2e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55736972,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"afchl\",\n            \"formula\": {\"H\": 8.0, \"Mg\": 6.0, \"O\": 18.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8727580.0,\n            \"S_0\": 439.0,\n            \"V_0\": 0.0002157,\n            \"Cp\": [1155.0, -0.000417, -4024400.0, -9952.9],\n            \"a_0\": 2.04e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.55422472,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"daph\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 5.0, \"H\": 8.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7117950.0,\n            \"S_0\": 584.0,\n            \"V_0\": 0.0002162,\n            \"Cp\": [1192.0, -0.00594, -4826400.0, -9768.3],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.71349722,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mnchl\",\n            \"formula\": {\"Al\": 2.0, \"H\": 8.0, \"Mn\": 5.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7699120.0,\n            \"S_0\": 595.0,\n            \"V_0\": 0.0002259,\n            \"Cp\": [1136.5, -0.005243, -5548100.0, -8911.5],\n            \"a_0\": 2.23e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 36.0,\n            \"molar_mass\": 0.70896222,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sud\",\n            \"formula\": {\"Al\": 4.0, \"H\": 8.0, \"Mg\": 2.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -8626150.0,\n            \"S_0\": 395.0,\n            \"V_0\": 0.000203,\n            \"Cp\": [1436.1, -0.048749, -2748500.0, -13764.0],\n            \"a_0\": 1.99e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 35.0,\n            \"molar_mass\": 0.53684522,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fsud\",\n            \"formula\": {\"Al\": 4.0, \"Fe\": 2.0, \"H\": 8.0, \"O\": 18.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7899960.0,\n            \"S_0\": 456.0,\n            \"V_0\": 0.000204,\n            \"Cp\": [1466.3, -0.047365, -1182800.0, -14388.0],\n            \"a_0\": 2.08e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 35.0,\n            \"molar_mass\": 0.59992522,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"prl\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5640520.0,\n            \"S_0\": 239.0,\n            \"V_0\": 0.00012804,\n            \"Cp\": [784.5, -0.042948, 1251000.0, -8495.9],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 37000e6,\n            \"Kprime_0\": 10.0,\n            \"Kdprime_0\": -2.71e-10,\n            \"n\": 20.0,\n            \"molar_mass\": 0.36031368,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ta\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5896740.0,\n            \"S_0\": 259.0,\n            \"V_0\": 0.00013665,\n            \"Cp\": [622.2, 0.0, -6385500.0, -3916.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.37926568,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fta\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4798850.0,\n            \"S_0\": 352.0,\n            \"V_0\": 0.00014225,\n            \"Cp\": [579.7, 0.039494, -6459300.0, -3088.1],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.47388568,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tats\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"Mg\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6000930.0,\n            \"S_0\": 259.0,\n            \"V_0\": 0.0001351,\n            \"Cp\": [549.5, 0.036324, -8606600.0, -2515.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.38083818,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tap\",\n            \"formula\": {\"Al\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5649650.0,\n            \"S_0\": 235.0,\n            \"V_0\": 0.0001345,\n            \"Cp\": [784.5, -0.042948, 1251000.0, -8495.9],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 37000e6,\n            \"Kprime_0\": 10.0,\n            \"Kdprime_0\": -2.71e-10,\n            \"n\": 20.0,\n            \"molar_mass\": 0.36031368,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"nta\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"H\": 2.0,\n                \"Mg\": 3.0,\n                \"Na\": 1.0,\n                \"O\": 12.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6163460.0,\n            \"S_0\": 318.0,\n            \"V_0\": 0.0001445,\n            \"Cp\": [773.5, -0.040229, -2597900.0, -6512.6],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 22.0,\n            \"molar_mass\": 0.40115148,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"minn\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4818980.0,\n            \"S_0\": 355.0,\n            \"V_0\": 0.00014851,\n            \"Cp\": [579.7, 0.039494, -6459300.0, -3088.1],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.47388568,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"minm\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 3.0, \"O\": 12.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5865930.0,\n            \"S_0\": 263.9,\n            \"V_0\": 0.00014291,\n            \"Cp\": [622.2, 0.0, -6385500.0, -3916.3],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 43000e6,\n            \"Kprime_0\": 6.17,\n            \"Kdprime_0\": -1.44e-10,\n            \"n\": 21.0,\n            \"molar_mass\": 0.37926568,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kao\",\n            \"formula\": {\"Al\": 2.0, \"H\": 4.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4121930.0000000005,\n            \"S_0\": 203.7,\n            \"V_0\": 9.934e-05,\n            \"Cp\": [436.7, -0.034295, -4055900.0, -2699.1],\n            \"a_0\": 2.51e-05,\n            \"K_0\": 64500e6,\n            \"Kprime_0\": 4.12,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 17.0,\n            \"molar_mass\": 0.25816036,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pre\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 2.0, \"H\": 2.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6202070.0,\n            \"S_0\": 292.8,\n            \"V_0\": 0.00014026,\n            \"Cp\": [724.9, -0.013865, -2059000.0, -6323.9],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 109300e6,\n            \"Kprime_0\": 4.01,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.41238418,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fpre\",\n            \"formula\": {\n                \"Al\": 1.0,\n                \"Ca\": 2.0,\n                \"Fe\": 1.0,\n                \"H\": 2.0,\n                \"O\": 12.0,\n                \"Si\": 3.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5766490.0,\n            \"S_0\": 320.0,\n            \"V_0\": 0.000148,\n            \"Cp\": [737.1, -0.01681, -1957300.0, -6358.1],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 109300e6,\n            \"Kprime_0\": 4.01,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.44124768,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"chr\",\n            \"formula\": {\"H\": 4.0, \"Mg\": 3.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4360800.0,\n            \"S_0\": 221.3,\n            \"V_0\": 0.00010746,\n            \"Cp\": [624.7, -0.02077, -1721800.0, -5619.4],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 62800e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -6.4e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.27711236,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"liz\",\n            \"formula\": {\"H\": 4.0, \"Mg\": 3.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4368980.0,\n            \"S_0\": 212.0,\n            \"V_0\": 0.00010645,\n            \"Cp\": [614.7, -0.02077, -1721800.0, -5619.4],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 71000e6,\n            \"Kprime_0\": 3.2,\n            \"Kdprime_0\": -4.5e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.27711236,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"glt\",\n            \"formula\": {\"Fe\": 3.0, \"H\": 4.0, \"O\": 9.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3297310.0,\n            \"S_0\": 310.0,\n            \"V_0\": 0.0001198,\n            \"Cp\": [576.4, 0.002984, -3757000.0, -4166.2],\n            \"a_0\": 2.28e-05,\n            \"K_0\": 63000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 18.0,\n            \"molar_mass\": 0.37173236,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fstp\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"Fe\": 5.0,\n                \"H\": 12.5,\n                \"K\": 0.5,\n                \"O\": 30.5,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -12552150.0,\n            \"S_0\": 930.2,\n            \"V_0\": 0.00037239,\n            \"Cp\": [1944.3, -0.012289, -4840200.0, -16635.0],\n            \"a_0\": 3.68e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 58.5,\n            \"molar_mass\": 1.0780021,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mstp\",\n            \"formula\": {\n                \"Al\": 2.0,\n                \"H\": 12.5,\n                \"K\": 0.5,\n                \"Mg\": 5.0,\n                \"O\": 30.5,\n                \"Si\": 8.0,\n            },\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -14288210.0,\n            \"S_0\": 847.4,\n            \"V_0\": 0.00036577,\n            \"Cp\": [1862.2, -0.014018, -8983100.0, -14923.0],\n            \"a_0\": 3.71e-05,\n            \"K_0\": 51300e6,\n            \"Kprime_0\": 7.33,\n            \"Kdprime_0\": -1.43e-10,\n            \"n\": 58.5,\n            \"molar_mass\": 0.9203021,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"atg\",\n            \"formula\": {\"H\": 62.0, \"Mg\": 48.0, \"O\": 147.0, \"Si\": 34.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -71400990.0,\n            \"S_0\": 3620.0,\n            \"V_0\": 0.0017548,\n            \"Cp\": [9621.0, -0.091183, -35941600.0, -83034.2],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 63100e6,\n            \"Kprime_0\": 5.92,\n            \"Kdprime_0\": -9.4e-11,\n            \"n\": 291.0,\n            \"molar_mass\": 4.53595108,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ab\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3935290.0,\n            \"S_0\": 207.4,\n            \"V_0\": 0.00010067,\n            \"Cp\": [452.0, -0.013364, -1275900.0, -3953.6],\n            \"a_0\": 2.36e-05,\n            \"K_0\": 54100e6,\n            \"Kprime_0\": 5.91,\n            \"Kdprime_0\": -1.09e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 14000.0,\n                    \"deltaV\": 4.2e-07,\n                    \"Wh\": 13000.0,\n                    \"Wv\": 4.2e-07,\n                    \"n\": 3.0,\n                    \"factor\": 0.9,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"abh\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3921290.0,\n            \"S_0\": 224.3,\n            \"V_0\": 0.00010105,\n            \"Cp\": [452.0, -0.013364, -1275900.0, -3953.6],\n            \"a_0\": 2.41e-05,\n            \"K_0\": 54100e6,\n            \"Kprime_0\": 5.91,\n            \"Kdprime_0\": -1.09e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mic\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3975410.0,\n            \"S_0\": 214.3,\n            \"V_0\": 0.00010871,\n            \"Cp\": [448.8, -0.010075, -1007300.0, -3973.1],\n            \"a_0\": 1.66e-05,\n            \"K_0\": 58300e6,\n            \"Kprime_0\": 4.02,\n            \"Kdprime_0\": -6.9e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"san\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3966760.0,\n            \"S_0\": 214.3,\n            \"V_0\": 0.00010871,\n            \"Cp\": [448.8, -0.010075, -1007300.0, -3973.1],\n            \"a_0\": 1.66e-05,\n            \"K_0\": 58300e6,\n            \"Kprime_0\": 4.02,\n            \"Kdprime_0\": -6.9e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 8650.0,\n                    \"deltaV\": 2.4e-07,\n                    \"Wh\": 8500.0,\n                    \"Wv\": 2.4e-07,\n                    \"n\": 3.0,\n                    \"factor\": 0.8,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"an\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4232600.0,\n            \"S_0\": 200.5,\n            \"V_0\": 0.00010079,\n            \"Cp\": [370.5, 0.01001, -4339100.0, -1960.6],\n            \"a_0\": 1.41e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2782072,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 42010.0,\n                    \"deltaV\": 1e-06,\n                    \"Wh\": 42000.0,\n                    \"Wv\": 1e-06,\n                    \"n\": 1.0,\n                    \"factor\": 2.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kcm\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"K\": 1.0, \"O\": 9.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4232700.0,\n            \"S_0\": 281.5,\n            \"V_0\": 0.00011438,\n            \"Cp\": [536.5, -0.01009, -980400.0, -4735.0],\n            \"a_0\": 3.21e-05,\n            \"K_0\": 42500e6,\n            \"Kprime_0\": 2.0,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 16.0,\n            \"molar_mass\": 0.29634678,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"wa\",\n            \"formula\": {\"K\": 2.0, \"O\": 9.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4272090.0,\n            \"S_0\": 254.0,\n            \"V_0\": 0.00010844,\n            \"Cp\": [499.1, 0.0, 0.0, -4350.1],\n            \"a_0\": 2.66e-05,\n            \"K_0\": 90000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": 15.0,\n            \"molar_mass\": 0.3345332,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hol\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3792020.0,\n            \"S_0\": 166.2,\n            \"V_0\": 7.128e-05,\n            \"Cp\": [417.6, -0.003617, -4748100.0, -2819.9],\n            \"a_0\": 2.8e-05,\n            \"K_0\": 180000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"q\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -910710.0,\n            \"S_0\": 41.43,\n            \"V_0\": 2.269e-05,\n            \"Cp\": [92.9, -0.000642, -714900.0, -716.1],\n            \"a_0\": 0.0,\n            \"K_0\": 73000e6,\n            \"Kprime_0\": 6.0,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 847.0,\n                    \"S_D\": 4.95,\n                    \"V_D\": 1.188e-06,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"trd\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -907100.0,\n            \"S_0\": 44.1,\n            \"V_0\": 2.8e-05,\n            \"Cp\": [74.9, 0.0031, -1174000.0, -236.7],\n            \"a_0\": 0.0,\n            \"K_0\": 15000e6,\n            \"Kprime_0\": 4.36,\n            \"Kdprime_0\": -2.91e-10,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"crst\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -904260.0,\n            \"S_0\": 50.86,\n            \"V_0\": 2.745e-05,\n            \"Cp\": [72.7, 0.001304, -4129000.0, 0.0],\n            \"a_0\": 0.0,\n            \"K_0\": 16000e6,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.72e-10,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"coe\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -906990.0,\n            \"S_0\": 39.6,\n            \"V_0\": 2.064e-05,\n            \"Cp\": [107.8, -0.003279, -190300.0, -1041.6],\n            \"a_0\": 1.23e-05,\n            \"K_0\": 97900e6,\n            \"Kprime_0\": 4.19,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"stv\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -876720.0,\n            \"S_0\": 24.0,\n            \"V_0\": 1.401e-05,\n            \"Cp\": [68.1, 0.00601, -1978200.0, -82.1],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 309000e6,\n            \"Kprime_0\": 4.6,\n            \"Kdprime_0\": -1.5e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ne\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2094860.0000000002,\n            \"S_0\": 124.4,\n            \"V_0\": 5.419e-05,\n            \"Cp\": [272.7, -0.012398, 0.0, -2763.1],\n            \"a_0\": 4.63e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 467.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 8e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cg\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2092030.0000000002,\n            \"S_0\": 118.7,\n            \"V_0\": 5.603e-05,\n            \"Cp\": [116.1, 0.086021, -1992700.0, 0.0],\n            \"a_0\": 4.5e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cgh\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2078310.0,\n            \"S_0\": 135.0,\n            \"V_0\": 5.67e-05,\n            \"Cp\": [229.2, 0.011876, 0.0, -1970.7],\n            \"a_0\": 4.67e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"macf\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2246370.0,\n            \"S_0\": 80.0,\n            \"V_0\": 3.614e-05,\n            \"Cp\": [200.0, 0.006252, -2996400.0, -888.4],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 212000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1422656,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mscf\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2061420.0,\n            \"S_0\": 87.5,\n            \"V_0\": 3.649e-05,\n            \"Cp\": [213.3, 0.00269, -1410400.0, -1495.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 185000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fscf\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1402500.0,\n            \"S_0\": 143.4,\n            \"V_0\": 3.914e-05,\n            \"Cp\": [181.1, 0.018526, -2767200.0, -527.1],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 185000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"nacf\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1965650.0,\n            \"S_0\": 110.0,\n            \"V_0\": 3.631e-05,\n            \"Cp\": [272.7, -0.012398, 0.0, -2763.1],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 185000e6,\n            \"Kprime_0\": 4.6,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cacf\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2325600.0,\n            \"S_0\": 87.6,\n            \"V_0\": 3.976e-05,\n            \"Cp\": [191.9, 0.009563, -3211300.0, -640.2],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 190000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1580386,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"manal\",\n            \"formula\": {\"Al\": 6.0, \"Mg\": 3.0, \"O\": 12.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6796630.0,\n            \"S_0\": 250.0,\n            \"V_0\": 0.00011166,\n            \"Cp\": [600.0, 0.018756, -8989200.0, -2665.2],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 184000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.4267968,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"nanal\",\n            \"formula\": {\"Al\": 5.0, \"Mg\": 2.0, \"Na\": 1.0, \"O\": 12.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6610270.0,\n            \"S_0\": 280.0,\n            \"V_0\": 0.00011322,\n            \"Cp\": [672.7, 0.000106, -5992800.0, -4539.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 184000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.4265856,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"msnal\",\n            \"formula\": {\"Mg\": 6.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6172380.0,\n            \"S_0\": 272.5,\n            \"V_0\": 0.00011061,\n            \"Cp\": [639.9, 0.00807, -4231200.0, -4487.7],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 185000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.4220793,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fsnal\",\n            \"formula\": {\"Fe\": 6.0, \"O\": 12.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4146000.0,\n            \"S_0\": 440.2,\n            \"V_0\": 0.00011856,\n            \"Cp\": [543.3, 0.055578, -8301600.0, -1581.3],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 185000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.6113193,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"canal\",\n            \"formula\": {\"Al\": 6.0, \"Ca\": 1.0, \"Mg\": 2.0, \"O\": 12.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6840000.0,\n            \"S_0\": 257.6,\n            \"V_0\": 0.00011159,\n            \"Cp\": [591.9, 0.022067, -9204100.0, -2417.0],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 177000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 21.0,\n            \"molar_mass\": 0.4425698,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sdl\",\n            \"formula\": {\"Al\": 6.0, \"Cl\": 2.0, \"Na\": 8.0, \"O\": 24.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -13407370.0,\n            \"S_0\": 910.0,\n            \"V_0\": 0.0004213,\n            \"Cp\": [1532.7, 0.047747, -2972800.0, -12427.0],\n            \"a_0\": 4.63e-05,\n            \"K_0\": 46500e6,\n            \"Kprime_0\": 4.16,\n            \"Kdprime_0\": -8.9e-11,\n            \"n\": 46.0,\n            \"molar_mass\": 0.969212,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kls\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2123210.0,\n            \"S_0\": 136.0,\n            \"V_0\": 6.052e-05,\n            \"Cp\": [242.0, -0.004482, -895800.0, -1935.8],\n            \"a_0\": 3.16e-05,\n            \"K_0\": 51400e6,\n            \"Kprime_0\": 2.0,\n            \"Kdprime_0\": -3.9e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1581629,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lc\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3029430.0,\n            \"S_0\": 198.5,\n            \"V_0\": 8.826e-05,\n            \"Cp\": [369.8, -0.016332, 684700.0, -3683.1],\n            \"a_0\": 1.85e-05,\n            \"K_0\": 45000e6,\n            \"Kprime_0\": 5.7,\n            \"Kdprime_0\": -1.27e-10,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2182472,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11610.0,\n                    \"deltaV\": 4e-06,\n                    \"Wh\": 11600.0,\n                    \"Wv\": 4e-06,\n                    \"n\": 2.0,\n                    \"factor\": 0.7,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"me\",\n            \"formula\": {\"Al\": 6.0, \"C\": 1.0, \"Ca\": 4.0, \"O\": 27.0, \"Si\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -13841600.0,\n            \"S_0\": 752.0,\n            \"V_0\": 0.00033985,\n            \"Cp\": [1359.0, 0.036442, -8594700.0, -9598.2],\n            \"a_0\": 1.81e-05,\n            \"K_0\": 87000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.7e-11,\n            \"n\": 44.0,\n            \"molar_mass\": 0.9347085,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"wrk\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 4.0, \"O\": 14.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6662350.0,\n            \"S_0\": 380.0,\n            \"V_0\": 0.0001904,\n            \"Cp\": [838.3, -0.02146, -2272000.0, -7292.3],\n            \"a_0\": 1.49e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 25.0,\n            \"molar_mass\": 0.43440636,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lmt\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 8.0, \"O\": 16.0, \"Si\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -7262590.0,\n            \"S_0\": 465.0,\n            \"V_0\": 0.0002037,\n            \"Cp\": [1013.4, -0.021413, -2235800.0, -8806.7],\n            \"a_0\": 1.37e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 31.0,\n            \"molar_mass\": 0.47043692,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"heu\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 12.0, \"O\": 24.0, \"Si\": 7.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10545090.0,\n            \"S_0\": 783.0,\n            \"V_0\": 0.000317,\n            \"Cp\": [1504.8, -0.033224, -2959300.0, -13297.2],\n            \"a_0\": 1.57e-05,\n            \"K_0\": 27400e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.46e-10,\n            \"n\": 46.0,\n            \"molar_mass\": 0.68672038,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"stlb\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"H\": 14.0, \"O\": 25.0, \"Si\": 7.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -10896630.0,\n            \"S_0\": 710.0,\n            \"V_0\": 0.0003287,\n            \"Cp\": [1588.4, -0.032043, -3071600.0, -13966.9],\n            \"a_0\": 1.51e-05,\n            \"K_0\": 86000e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -4.8e-11,\n            \"n\": 49.0,\n            \"molar_mass\": 0.70473566,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"anl\",\n            \"formula\": {\"Al\": 1.0, \"H\": 2.0, \"Na\": 1.0, \"O\": 7.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3307050.0,\n            \"S_0\": 232.0,\n            \"V_0\": 9.74e-05,\n            \"Cp\": [643.5, -0.016067, 9302300.0, -9179.6],\n            \"a_0\": 2.76e-05,\n            \"K_0\": 40000e6,\n            \"Kprime_0\": 4.18,\n            \"Kdprime_0\": -1.04e-10,\n            \"n\": 13.0,\n            \"molar_mass\": 0.22015398,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lime\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -634580.0,\n            \"S_0\": 38.1,\n            \"V_0\": 1.676e-05,\n            \"Cp\": [52.4, 0.003673, -750700.0, -51.0],\n            \"a_0\": 3.41e-05,\n            \"K_0\": 113000e6,\n            \"Kprime_0\": 3.87,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0560774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ru\",\n            \"formula\": {\"O\": 2.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -944160.0,\n            \"S_0\": 50.5,\n            \"V_0\": 1.882e-05,\n            \"Cp\": [90.4, 0.0029, 0.0, -623.8],\n            \"a_0\": 2.24e-05,\n            \"K_0\": 222000e6,\n            \"Kprime_0\": 4.24,\n            \"Kdprime_0\": -1.9e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0798658,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"per\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -601600.0,\n            \"S_0\": 26.5,\n            \"V_0\": 1.125e-05,\n            \"Cp\": [60.5, 0.000362, -535800.0, -299.2],\n            \"a_0\": 3.11e-05,\n            \"K_0\": 161600e6,\n            \"Kprime_0\": 3.95,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0403044,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"fper\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -262160.0,\n            \"S_0\": 58.6,\n            \"V_0\": 1.206e-05,\n            \"Cp\": [44.4, 0.00828, -1214200.0, 185.2],\n            \"a_0\": 3.22e-05,\n            \"K_0\": 152000e6,\n            \"Kprime_0\": 4.9,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0718444,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"wu\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -262430.0,\n            \"S_0\": 63.0,\n            \"V_0\": 1.206e-05,\n            \"Cp\": [67.4, 0.003758, 315700.0, -381.7],\n            \"a_0\": 3.22e-05,\n            \"K_0\": 152000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0718444,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mang\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -385570.0,\n            \"S_0\": 59.7,\n            \"V_0\": 1.322e-05,\n            \"Cp\": [59.8, 0.0036, -31400.0, -282.6],\n            \"a_0\": 3.69e-05,\n            \"K_0\": 164500e6,\n            \"Kprime_0\": 4.46,\n            \"Kdprime_0\": -2.7e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0709374,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cor\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1675220.0,\n            \"S_0\": 50.9,\n            \"V_0\": 2.558e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 254000e6,\n            \"Kprime_0\": 4.34,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mcor\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1468360.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 211000e6,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1003887,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hem\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -825420.0,\n            \"S_0\": 87.4,\n            \"V_0\": 3.027e-05,\n            \"Cp\": [163.9, 0.0, -2257200.0, -657.6],\n            \"a_0\": 2.79e-05,\n            \"K_0\": 223000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1596882,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 955.0,\n                    \"S_D\": 15.6,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"esk\",\n            \"formula\": {\"Cr\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1128170.0,\n            \"S_0\": 83.0,\n            \"V_0\": 2.898e-05,\n            \"Cp\": [119.0, 0.009496, -1442000.0, -3.4],\n            \"a_0\": 1.59e-05,\n            \"K_0\": 245000e6,\n            \"Kprime_0\": 3.6,\n            \"Kdprime_0\": -1.5e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1519904,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"bix\",\n            \"formula\": {\"Mn\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -959000.0,\n            \"S_0\": 113.7,\n            \"V_0\": 3.137e-05,\n            \"Cp\": [145.1, 0.023534, 721600.0, -1008.4],\n            \"a_0\": 2.91e-05,\n            \"K_0\": 223000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1578742,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"NiO\",\n            \"formula\": {\"Ni\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -239470.0,\n            \"S_0\": 38.0,\n            \"V_0\": 1.097e-05,\n            \"Cp\": [47.7, 0.007824, -392500.0, 0.0],\n            \"a_0\": 3.3e-05,\n            \"K_0\": 200000e6,\n            \"Kprime_0\": 3.94,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0746928,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\"P_0\": 100000.0, \"T_0\": 298.15, \"Tc_0\": 520.0, \"S_D\": 5.7, \"V_D\": 0.0},\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pnt\",\n            \"formula\": {\"Mn\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1361500.0,\n            \"S_0\": 105.5,\n            \"V_0\": 3.288e-05,\n            \"Cp\": [143.5, 0.003373, -1940700.0, -407.6],\n            \"a_0\": 2.4e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1508032,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"geik\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1568390.0,\n            \"S_0\": 73.6,\n            \"V_0\": 3.086e-05,\n            \"Cp\": [115.5, 0.014938, -2637700.0, 45.5],\n            \"a_0\": 2.15e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1201702,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ilm\",\n            \"formula\": {\"Fe\": 1.0, \"O\": 3.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1232320.0,\n            \"S_0\": 107.5,\n            \"V_0\": 3.169e-05,\n            \"Cp\": [138.9, 0.005081, -1288800.0, -463.7],\n            \"a_0\": 2.4e-05,\n            \"K_0\": 170000e6,\n            \"Kprime_0\": 8.3,\n            \"Kdprime_0\": -4.9e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1517102,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1900.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 2e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"bdy\",\n            \"formula\": {\"O\": 2.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1100320.0,\n            \"S_0\": 50.4,\n            \"V_0\": 2.115e-05,\n            \"Cp\": [89.6, 0.000354, -853100.0, -413.7],\n            \"a_0\": 2e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1232228,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"bdyT\",\n            \"formula\": {\"O\": 2.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1096010.0,\n            \"S_0\": 53.4,\n            \"V_0\": 2.115e-05,\n            \"Cp\": [89.6, 0.000354, -853100.0, -413.7],\n            \"a_0\": 2e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1232228,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"bdyC\",\n            \"formula\": {\"O\": 2.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1085960.0,\n            \"S_0\": 57.2,\n            \"V_0\": 2.495e-05,\n            \"Cp\": [89.6, 0.000354, -853100.0, -413.7],\n            \"a_0\": 2e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1232228,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ten\",\n            \"formula\": {\"Cu\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -156100.0,\n            \"S_0\": 42.6,\n            \"V_0\": 1.222e-05,\n            \"Cp\": [31.0, 0.01374, -1258000.0, 369.3],\n            \"a_0\": 3.57e-05,\n            \"K_0\": 200000e6,\n            \"Kprime_0\": 3.94,\n            \"Kdprime_0\": -2e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0795454,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cup\",\n            \"formula\": {\"Cu\": 2.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -170600.0,\n            \"S_0\": 92.4,\n            \"V_0\": 2.344e-05,\n            \"Cp\": [110.3, 0.0, 0.0, -674.8],\n            \"a_0\": 3.33e-05,\n            \"K_0\": 131000e6,\n            \"Kprime_0\": 5.7,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1430914,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sp\",\n            \"formula\": {\"Al\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2300180.0,\n            \"S_0\": 80.63,\n            \"V_0\": 3.978e-05,\n            \"Cp\": [200.5, 0.006252, -2996400.0, -888.4],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1422656,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 13930.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": -3600.0,\n                    \"Wv\": 0.0,\n                    \"n\": 2.0,\n                    \"factor\": -0.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"herc\",\n            \"formula\": {\"Al\": 2.0, \"Fe\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1949470.0,\n            \"S_0\": 113.9,\n            \"V_0\": 4.075e-05,\n            \"Cp\": [184.9, 0.01417, -3674800.0, -404.0],\n            \"a_0\": 2.06e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1738056,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 13930.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": -3600.0,\n                    \"Wv\": 0.0,\n                    \"n\": 2.0,\n                    \"factor\": -0.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mt\",\n            \"formula\": {\"Fe\": 3.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1114200.0,\n            \"S_0\": 146.9,\n            \"V_0\": 4.452e-05,\n            \"Cp\": [262.5, -0.007205, -1926200.0, -1655.7],\n            \"a_0\": 3.71e-05,\n            \"K_0\": 185700e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2315326,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 848.0,\n                    \"S_D\": 35.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mft\",\n            \"formula\": {\"Fe\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1442210.0,\n            \"S_0\": 121.0,\n            \"V_0\": 4.457e-05,\n            \"Cp\": [270.5, -0.007505, -999200.0, -2022.4],\n            \"a_0\": 3.63e-05,\n            \"K_0\": 185700e6,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1999926,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 665.0,\n                    \"S_D\": 17.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"qnd\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2157150.0,\n            \"S_0\": 111.0,\n            \"V_0\": 4.529e-05,\n            \"Cp\": [161.7, 0.03286, -2382200.0, -278.6],\n            \"a_0\": 2.63e-05,\n            \"K_0\": 147000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.72e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1604746,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"usp\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1494180.0,\n            \"S_0\": 171.0,\n            \"V_0\": 4.682e-05,\n            \"Cp\": [129.5, 0.048696, -3739000.0, 690.2],\n            \"a_0\": 3.86e-05,\n            \"K_0\": 147000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.72e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2235546,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 1000.0,\n                    \"deltaV\": 0.0,\n                    \"Wh\": 900.0,\n                    \"Wv\": 0.0,\n                    \"n\": 1.0,\n                    \"factor\": 0.5,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"picr\",\n            \"formula\": {\"Cr\": 2.0, \"Mg\": 1.0, \"O\": 4.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1764240.0,\n            \"S_0\": 118.3,\n            \"V_0\": 4.356e-05,\n            \"Cp\": [196.1, 0.005398, -3126000.0, -616.9],\n            \"a_0\": 2.6e-05,\n            \"K_0\": 192200e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1922948,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"br\",\n            \"formula\": {\"H\": 2.0, \"Mg\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -925620.0,\n            \"S_0\": 63.2,\n            \"V_0\": 2.463e-05,\n            \"Cp\": [158.4, -0.004076, -1052300.0, -1171.3],\n            \"a_0\": 6.2e-05,\n            \"K_0\": 41500e6,\n            \"Kprime_0\": 6.45,\n            \"Kdprime_0\": -1.55e-10,\n            \"n\": 5.0,\n            \"molar_mass\": 0.05831968,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"dsp\",\n            \"formula\": {\"Al\": 1.0, \"H\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -999810.0,\n            \"S_0\": 34.5,\n            \"V_0\": 1.786e-05,\n            \"Cp\": [145.1, 0.008709, 584400.0, -1741.1],\n            \"a_0\": 3.57e-05,\n            \"K_0\": 228000e6,\n            \"Kprime_0\": 4.04,\n            \"Kdprime_0\": -1.8e-11,\n            \"n\": 4.0,\n            \"molar_mass\": 0.05998824,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"gth\",\n            \"formula\": {\"Fe\": 1.0, \"H\": 1.0, \"O\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -561670.0,\n            \"S_0\": 60.3,\n            \"V_0\": 2.082e-05,\n            \"Cp\": [139.3, 0.000147, -212700.0, -1077.8],\n            \"a_0\": 4.35e-05,\n            \"K_0\": 250000e6,\n            \"Kprime_0\": 4.03,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": 4.0,\n            \"molar_mass\": 0.08885174,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"cc\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1207790.0,\n            \"S_0\": 92.5,\n            \"V_0\": 3.689e-05,\n            \"Cp\": [140.9, 0.005029, -950700.0, -858.4],\n            \"a_0\": 2.52e-05,\n            \"K_0\": 73300e6,\n            \"Kprime_0\": 4.06,\n            \"Kdprime_0\": -5.5e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1000869,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1240.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 4e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"arag\",\n            \"formula\": {\"C\": 1.0, \"Ca\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1207690.0,\n            \"S_0\": 89.8,\n            \"V_0\": 3.415e-05,\n            \"Cp\": [167.1, 0.010695, 162000.0, -1564.9],\n            \"a_0\": 6.14e-05,\n            \"K_0\": 61400e6,\n            \"Kprime_0\": 5.87,\n            \"Kdprime_0\": -9.6e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1000869,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"mag\",\n            \"formula\": {\"C\": 1.0, \"Mg\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1110910.0,\n            \"S_0\": 65.5,\n            \"V_0\": 2.803e-05,\n            \"Cp\": [186.4, -0.003772, 0.0, -1886.2],\n            \"a_0\": 3.38e-05,\n            \"K_0\": 102800e6,\n            \"Kprime_0\": 5.41,\n            \"Kdprime_0\": -5.3e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.0843139,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"sid\",\n            \"formula\": {\"C\": 1.0, \"Fe\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -762120.0,\n            \"S_0\": 93.3,\n            \"V_0\": 2.943e-05,\n            \"Cp\": [168.4, 0.0, 0.0, -1483.6],\n            \"a_0\": 4.39e-05,\n            \"K_0\": 120000e6,\n            \"Kprime_0\": 4.07,\n            \"Kdprime_0\": -3.4e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1158539,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"rhc\",\n            \"formula\": {\"C\": 1.0, \"Mn\": 1.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -892280.0,\n            \"S_0\": 98.0,\n            \"V_0\": 3.107e-05,\n            \"Cp\": [169.5, 0.0, 0.0, -1534.3],\n            \"a_0\": 2.44e-05,\n            \"K_0\": 95300e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.1e-11,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1149469,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"dol\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2326270.0,\n            \"S_0\": 156.1,\n            \"V_0\": 6.429e-05,\n            \"Cp\": [358.9, -0.004905, 0.0, -3456.2],\n            \"a_0\": 3.28e-05,\n            \"K_0\": 94300e6,\n            \"Kprime_0\": 3.74,\n            \"Kdprime_0\": -4e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.1844008,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11910.0,\n                    \"deltaV\": 1.6e-07,\n                    \"Wh\": 11900.0,\n                    \"Wv\": 1.6e-07,\n                    \"n\": 1.0,\n                    \"factor\": 1.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ank\",\n            \"formula\": {\"C\": 2.0, \"Ca\": 1.0, \"Fe\": 1.0, \"O\": 6.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1971340.0,\n            \"S_0\": 188.46,\n            \"V_0\": 6.606e-05,\n            \"Cp\": [341.0, -0.001161, 0.0, -3054.8],\n            \"a_0\": 3.46e-05,\n            \"K_0\": 91400e6,\n            \"Kprime_0\": 3.88,\n            \"Kdprime_0\": -4.3e-11,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2159408,\n        }\n        self.property_modifiers = [\n            [\n                \"bragg_williams\",\n                {\n                    \"deltaH\": 11910.0,\n                    \"deltaV\": 1.6e-07,\n                    \"Wh\": 11900.0,\n                    \"Wv\": 1.6e-07,\n                    \"n\": 1.0,\n                    \"factor\": 1.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"syv\",\n            \"formula\": {\"Cl\": 1.0, \"K\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -436500.0,\n            \"S_0\": 82.6,\n            \"V_0\": 3.752e-05,\n            \"Cp\": [46.2, 0.01797, 0.0, 0.0],\n            \"a_0\": 0.0001109,\n            \"K_0\": 17000e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -2.94e-10,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0745513,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hlt\",\n            \"formula\": {\"Cl\": 1.0, \"Na\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -411300.0,\n            \"S_0\": 72.1,\n            \"V_0\": 2.702e-05,\n            \"Cp\": [45.2, 0.01797, 0.0, 0.0],\n            \"a_0\": 0.0001147,\n            \"K_0\": 23800e6,\n            \"Kprime_0\": 5.0,\n            \"Kdprime_0\": -2.1e-10,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0584428,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"pyr\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 2.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -171640.0,\n            \"S_0\": 52.9,\n            \"V_0\": 2.394e-05,\n            \"Cp\": [37.3, 0.026715, -1817000.0, 649.3],\n            \"a_0\": 3.1e-05,\n            \"K_0\": 139500e6,\n            \"Kprime_0\": 4.09,\n            \"Kdprime_0\": -2.9e-11,\n            \"n\": 3.0,\n            \"molar_mass\": 0.119975,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"trot\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -99030.0,\n            \"S_0\": 65.5,\n            \"V_0\": 1.819e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 5.68e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 598.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 4.1e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"tro\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -97770.0,\n            \"S_0\": 70.8,\n            \"V_0\": 1.819e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 5.73e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 598.0,\n                    \"S_D\": 12.0,\n                    \"V_D\": 4.1e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lot\",\n            \"formula\": {\"Fe\": 1.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -102170.0,\n            \"S_0\": 60.0,\n            \"V_0\": 1.818e-05,\n            \"Cp\": [50.2, 0.011052, -940000.0, 0.0],\n            \"a_0\": 4.93e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 2.0,\n            \"molar_mass\": 0.08791,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 420.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"trov\",\n            \"formula\": {\"Fe\": 0.875, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -96020.0,\n            \"S_0\": 57.5,\n            \"V_0\": 1.738e-05,\n            \"Cp\": [51.1, 0.008307, -669700.0, 0.0],\n            \"a_0\": 5.94e-05,\n            \"K_0\": 65800e6,\n            \"Kprime_0\": 4.17,\n            \"Kdprime_0\": -6.3e-11,\n            \"n\": 1.875,\n            \"molar_mass\": 0.080929375,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 595.0,\n                    \"S_D\": 10.0,\n                    \"V_D\": 1.6e-07,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"any\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 4.0, \"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1434400.0,\n            \"S_0\": 106.9,\n            \"V_0\": 4.594e-05,\n            \"Cp\": [128.7, 0.048545, -1223000.0, -560.5],\n            \"a_0\": 4.18e-05,\n            \"K_0\": 54379999999.99999,\n            \"Kprime_0\": 4.19,\n            \"Kdprime_0\": -7.7e-11,\n            \"n\": 6.0,\n            \"molar_mass\": 0.1361406,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"iron\",\n            \"formula\": {\"Fe\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -0.0,\n            \"S_0\": 27.09,\n            \"V_0\": 7.09e-06,\n            \"Cp\": [46.2, 0.005159, 723100.0, -556.2],\n            \"a_0\": 3.56e-05,\n            \"K_0\": 164000e6,\n            \"Kprime_0\": 5.16,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.055845,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\n                    \"P_0\": 100000.0,\n                    \"T_0\": 298.15,\n                    \"Tc_0\": 1042.0,\n                    \"S_D\": 8.3,\n                    \"V_D\": 0.0,\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Ni\",\n            \"formula\": {\"Ni\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 29.87,\n            \"V_0\": 6.59e-06,\n            \"Cp\": [49.8, 0.0, 585900.0, -533.9],\n            \"a_0\": 4.28e-05,\n            \"K_0\": 190500e6,\n            \"Kprime_0\": 4.25,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0586934,\n        }\n        self.property_modifiers = [\n            [\n                \"landau_hp\",\n                {\"P_0\": 100000.0, \"T_0\": 298.15, \"Tc_0\": 631.0, \"S_D\": 3.0, \"V_D\": 0.0},\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"Cu\",\n            \"formula\": {\"Cu\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -0.0,\n            \"S_0\": 33.14,\n            \"V_0\": 7.11e-06,\n            \"Cp\": [12.4, 0.00922, -379900.0, 233.5],\n            \"a_0\": 3.58e-05,\n            \"K_0\": 162500e6,\n            \"Kprime_0\": 4.24,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": 1.0,\n            \"molar_mass\": 0.063546,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"gph\",\n            \"formula\": {\"C\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 5.76,\n            \"V_0\": 5.3e-06,\n            \"Cp\": [34.3, 0.0, -240700.0, -403.8],\n            \"a_0\": 1.65e-05,\n            \"K_0\": 31200e6,\n            \"Kprime_0\": 3.9,\n            \"Kdprime_0\": -1.25e-10,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0120107,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"diam\",\n            \"formula\": {\"C\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 1890.0,\n            \"S_0\": 2.36,\n            \"V_0\": 3.42e-06,\n            \"Cp\": [40.0, 0.0, -28500.0, -580.5],\n            \"a_0\": 4e-06,\n            \"K_0\": 446500e6,\n            \"Kprime_0\": 1.61,\n            \"Kdprime_0\": -3.6e-12,\n            \"n\": 1.0,\n            \"molar_mass\": 0.0120107,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"S\",\n            \"formula\": {\"S\": 1.0},\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 0.0,\n            \"S_0\": 32.05,\n            \"V_0\": 1.551e-05,\n            \"Cp\": [56.6, -0.004557, 638000.0, -681.8],\n            \"a_0\": 6.4e-05,\n            \"K_0\": 14500e6,\n            \"Kprime_0\": 7.0,\n            \"Kdprime_0\": -4.8e-10,\n            \"n\": 1.0,\n            \"molar_mass\": 0.032065,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"syvL\",\n            \"formula\": {\"Cl\": 1.0, \"K\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -417410.0,\n            \"S_0\": 94.5,\n            \"V_0\": 3.822e-05,\n            \"Cp\": [66.9, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000301,\n            \"K_0\": 5600e6,\n            \"Kprime_0\": 4.65,\n            \"Kdprime_0\": -8.3e-10,\n            \"dKdT_0\": -2e6,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0745513,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hltL\",\n            \"formula\": {\"Cl\": 1.0, \"Na\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -392990.0,\n            \"S_0\": 80.1,\n            \"V_0\": 2.938e-05,\n            \"Cp\": [72.0, -0.003223, 0.0, 0.0],\n            \"a_0\": 0.000295,\n            \"K_0\": 6400e6,\n            \"Kprime_0\": 4.61,\n            \"Kdprime_0\": -7.2e-10,\n            \"dKdT_0\": -1500000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0584428,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"perL\",\n            \"formula\": {\"Mg\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -654190.0,\n            \"S_0\": -64.3,\n            \"V_0\": 8.39e-06,\n            \"Cp\": [99.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000226,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4100000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0403044,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"limL\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -692330.0,\n            \"S_0\": -47.5,\n            \"V_0\": 1.303e-05,\n            \"Cp\": [99.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000175,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4100000.0,\n            \"n\": 2.0,\n            \"molar_mass\": 0.0560774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"corL\",\n            \"formula\": {\"Al\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1632150.0,\n            \"S_0\": 14.9,\n            \"V_0\": 3.369e-05,\n            \"Cp\": [157.6, 0.0, 0.0, 0.0],\n            \"a_0\": 7.03e-05,\n            \"K_0\": 15000e6,\n            \"Kprime_0\": 6.0,\n            \"Kdprime_0\": 4e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1019612,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"eskL\",\n            \"formula\": {\"Cr\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1062180.0,\n            \"S_0\": 63.3,\n            \"V_0\": 3.709e-05,\n            \"Cp\": [157.6, 0.0, 0.0, 0.0],\n            \"a_0\": 7.03e-05,\n            \"K_0\": 15000e6,\n            \"Kprime_0\": 6.0,\n            \"Kdprime_0\": 4e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1519904,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"hemL\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -875130.0,\n            \"S_0\": -33.2,\n            \"V_0\": 3.2208e-05,\n            \"Cp\": [229.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0001953,\n            \"K_0\": 23000e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.74e-10,\n            \"dKdT_0\": -4600000.0,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1596882,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"qL\",\n            \"formula\": {\"O\": 2.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -921080.0,\n            \"S_0\": 16.3,\n            \"V_0\": 2.73e-05,\n            \"Cp\": [82.5, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0,\n            \"K_0\": 22000e6,\n            \"Kprime_0\": 9.46,\n            \"Kdprime_0\": -4.3e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0600843,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"h2oL\",\n            \"formula\": {\"H\": 2.0, \"O\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -281650.0,\n            \"S_0\": 66.6,\n            \"V_0\": 1.3355e-05,\n            \"Cp\": [65.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000626,\n            \"K_0\": 4228e6,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -9.46e-10,\n            \"dKdT_0\": -1060000.0,\n            \"n\": 3.0,\n            \"molar_mass\": 0.01801528,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"foL\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2237250.0,\n            \"S_0\": -62.0,\n            \"V_0\": 4.312e-05,\n            \"Cp\": [269.4, 0.0, 0.0, 0.0],\n            \"a_0\": 9.2e-05,\n            \"K_0\": 36200e6,\n            \"Kprime_0\": 10.06,\n            \"Kdprime_0\": -2.78e-10,\n            \"dKdT_0\": -4400000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1406931,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"faL\",\n            \"formula\": {\"Fe\": 2.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1462820.0,\n            \"S_0\": 96.0,\n            \"V_0\": 4.677e-05,\n            \"Cp\": [243.7, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0001071,\n            \"K_0\": 29000e6,\n            \"Kprime_0\": 10.42,\n            \"Kdprime_0\": -3.59e-10,\n            \"dKdT_0\": -5500000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.2037731,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"woL\",\n            \"formula\": {\"Ca\": 1.0, \"O\": 3.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1642570.0,\n            \"S_0\": 22.5,\n            \"V_0\": 3.985e-05,\n            \"Cp\": [167.4, 0.0, 0.0, 0.0],\n            \"a_0\": 6.69e-05,\n            \"K_0\": 32500e6,\n            \"Kprime_0\": 9.38,\n            \"Kdprime_0\": -3.08e-10,\n            \"dKdT_0\": -2e6,\n            \"n\": 5.0,\n            \"molar_mass\": 0.1161617,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"enL\",\n            \"formula\": {\"Mg\": 2.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3096310.0,\n            \"S_0\": -4.0,\n            \"V_0\": 6.984e-05,\n            \"Cp\": [353.6, 0.0, 0.0, 0.0],\n            \"a_0\": 6.81e-05,\n            \"K_0\": 21800e6,\n            \"Kprime_0\": 7.2,\n            \"Kdprime_0\": -3.3e-10,\n            \"dKdT_0\": -2400000.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2007774,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"diL\",\n            \"formula\": {\"Ca\": 1.0, \"Mg\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3193790.0,\n            \"S_0\": 42.1,\n            \"V_0\": 7.288e-05,\n            \"Cp\": [334.0, 0.0, 0.0, 0.0],\n            \"a_0\": 8.51e-05,\n            \"K_0\": 24900e6,\n            \"Kprime_0\": 8.04,\n            \"Kdprime_0\": -3.23e-10,\n            \"dKdT_0\": -3730000.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2165504,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"silL\",\n            \"formula\": {\"Al\": 2.0, \"O\": 5.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2593510.0,\n            \"S_0\": 10.0,\n            \"V_0\": 6.051e-05,\n            \"Cp\": [253.0, 0.0, 0.0, 0.0],\n            \"a_0\": 4.08e-05,\n            \"K_0\": 22000e6,\n            \"Kprime_0\": 6.36,\n            \"Kdprime_0\": -2.89e-10,\n            \"dKdT_0\": -2900000.0,\n            \"n\": 8.0,\n            \"molar_mass\": 0.1620455,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"anL\",\n            \"formula\": {\"Al\": 2.0, \"Ca\": 1.0, \"O\": 8.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -4277920.0,\n            \"S_0\": 29.0,\n            \"V_0\": 0.00010014,\n            \"Cp\": [430.0, 0.0, 0.0, 0.0],\n            \"a_0\": 5.14e-05,\n            \"K_0\": 21000e6,\n            \"Kprime_0\": 6.38,\n            \"Kdprime_0\": -3.04e-10,\n            \"dKdT_0\": -5500000.0,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2782072,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"kspL\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3985340.0,\n            \"S_0\": 129.2,\n            \"V_0\": 0.00011431,\n            \"Cp\": [368.0, 0.0, 0.0, 0.0],\n            \"a_0\": 4.93e-05,\n            \"K_0\": 17300e6,\n            \"Kprime_0\": 6.84,\n            \"Kdprime_0\": -3.93e-10,\n            \"dKdT_0\": -899999.9999999999,\n            \"n\": 13.0,\n            \"molar_mass\": 0.2783315,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"abL\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 8.0, \"Si\": 3.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3925410.0,\n            \"S_0\": 149.9,\n            \"V_0\": 0.00010858,\n            \"Cp\": [358.0, 0.0, 0.0, 0.0],\n            \"a_0\": 3.37e-05,\n            \"K_0\": 17600e6,\n            \"Kprime_0\": 14.35,\n            \"Kdprime_0\": -8.15e-10,\n            \"dKdT_0\": -2600000.0,\n            \"n\": 13.0,\n            \"molar_mass\": 0.262223,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"neL\",\n            \"formula\": {\"Al\": 1.0, \"Na\": 1.0, \"O\": 4.0, \"Si\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -2117040.0,\n            \"S_0\": 52.9,\n            \"V_0\": 5.2e-05,\n            \"Cp\": [216.5, 0.0, 0.0, 0.0],\n            \"a_0\": 0.000137,\n            \"K_0\": 25000e6,\n            \"Kprime_0\": 7.37,\n            \"Kdprime_0\": -2.95e-10,\n            \"dKdT_0\": -800000.0,\n            \"n\": 7.0,\n            \"molar_mass\": 0.1420544,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"lcL\",\n            \"formula\": {\"Al\": 1.0, \"K\": 1.0, \"O\": 6.0, \"Si\": 2.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -3068560.0,\n            \"S_0\": 102.0,\n            \"V_0\": 8.59e-05,\n            \"Cp\": [287.0, 0.0, 0.0, 0.0],\n            \"a_0\": 6.7e-05,\n            \"K_0\": 17500e6,\n            \"Kprime_0\": 7.0,\n            \"Kdprime_0\": -3.94e-10,\n            \"dKdT_0\": -0.0,\n            \"n\": 10.0,\n            \"molar_mass\": 0.2182472,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"ruL\",\n            \"formula\": {\"O\": 2.0, \"Ti\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -944300.0,\n            \"S_0\": 1.0,\n            \"V_0\": 1.7032e-05,\n            \"Cp\": [111.8, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0002901,\n            \"K_0\": 14900e6,\n            \"Kprime_0\": 8.0,\n            \"Kdprime_0\": -3.4e-10,\n            \"dKdT_0\": -3500000.0000000005,\n            \"n\": 3.0,\n            \"molar_mass\": 0.0798658,\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"name\": \"bdyL\",\n            \"formula\": {\"O\": 2.0, \"Zr\": 1.0},\n            \"equation_of_state\": \"hp_tmtL\",\n            \"H_0\": -1031880.0000000001,\n            \"S_0\": 48.9,\n            \"V_0\": 1.83e-05,\n            \"Cp\": [90.0, 0.0, 0.0, 0.0],\n            \"a_0\": 0.0002,\n            \"K_0\": 14900e6,\n            \"Kprime_0\": 8.0,\n            \"Kdprime_0\": -3.4e-10,\n            \"dKdT_0\": -3e6,\n            \"n\": 3.0,\n            \"molar_mass\": 0.1232228,\n        }\n        Mineral.__init__(self)",
  "class silicate_melt(Solution):\n        def __init__(self, molar_fractions=None):\n            self.name = \"Holland et al. (2018) melt model\"\n            self.solution_model = AsymmetricRegularSolution(\n                endmembers=endmembers,\n                energy_interaction=We,\n                volume_interaction=Wv,\n                alphas=alphas,\n            )\n\n            Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n            self.name = \"Holland et al. (2018) melt model\"\n            self.solution_model = AsymmetricRegularSolution(\n                endmembers=endmembers,\n                energy_interaction=We,\n                volume_interaction=Wv,\n                alphas=alphas,\n            )\n\n            Solution.__init__(self, molar_fractions=molar_fractions)",
  "class stishovite(Mineral):\n    def __init__(self):\n        p_fit = [0.2471304763e05, 0.4793020138e05]\n        V_0 = 0.1513000000e02 * 1e-6\n        K_0 = p_fit[0] / (9.0 * V_0) * 1.0e3\n        a3 = 2.0 * p_fit[1] / (9.0 * K_0 * V_0) * 1.0e3\n        Kp_0 = 4.0 + (a3 / 3.0)\n        Kdp_0 = (-143.0 / 9.0 - Kp_0 * (Kp_0 - 7.0)) / K_0\n        formula = {\"Si\": 1.0, \"O\": 2.0}\n        self.params = {\n            \"name\": \"stishovite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_s\",\n            \"V_0\": V_0,  # [m^3/mol]\n            \"T_0\": 0.3000000000e04,  # [K]\n            \"E_0\": -0.2274840214e04 * 1e3,  # [J/mol]\n            \"S_0\": 0.1668222552e00 * 1e3,  # [J/K/mol]\n            \"K_0\": K_0,\n            \"Kprime_0\": Kp_0,\n            \"Kdprime_0\": Kdp_0,\n            \"n\": 2.0,  # called fsn in param file\n            \"Cv\": 0.7794230433e-01 * 1e3,  # [J/K/mol]\n            \"grueneisen_0\": 0.1389501259e01,\n            \"q_0\": 0.1332025550e01,\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "class perovskite(Mineral):\n    def __init__(self):\n        p_fit = [0.4067243956e05, 0.1177159096e05]\n        V_0 = 0.2705000000e02 * 1e-6\n        K_0 = p_fit[0] / (9.0 * V_0) * 1.0e3\n        a3 = 2.0 * p_fit[1] / (9.0 * K_0 * V_0) * 1.0e3\n        Kp_0 = 4.0 + (a3 / 3.0)\n        Kdp_0 = (-143.0 / 9.0 - Kp_0 * (Kp_0 - 7.0)) / K_0\n        formula = {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0}\n        self.params = {\n            \"name\": \"perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_s\",\n            \"V_0\": V_0,  # [m^3/mol]\n            \"T_0\": 0.3000000000e04,  # [K]\n            \"E_0\": -0.3355012782e04 * 1e3,  # [J/mol]\n            \"S_0\": 0.3384574347e00 * 1e3,  # [J/K/mol]\n            \"K_0\": K_0,\n            \"Kprime_0\": Kp_0,\n            \"Kdprime_0\": Kdp_0,\n            \"n\": 2.0,  # called fsn in param file\n            \"Cv\": 0.1338111589e00 * 1e3,  # [J/K/mol]\n            \"grueneisen_0\": 0.1893754815e01,\n            \"q_0\": 0.1487809730e01,\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "class periclase(Mineral):\n    def __init__(self):\n        p_fit = [0.1208938157e05, 0.1133765229e05]\n        V_0 = 0.1223000000e02 * 1e-6\n        K_0 = p_fit[0] / (9.0 * V_0) * 1.0e3\n        a3 = 2.0 * p_fit[1] / (9.0 * K_0 * V_0) * 1.0e3\n        Kp_0 = 4.0 + (a3 / 3.0)\n        Kdp_0 = (-143.0 / 9.0 - Kp_0 * (Kp_0 - 7.0)) / K_0\n        formula = {\"Mg\": 1.0, \"O\": 1.0}\n        self.params = {\n            \"name\": \"periclase\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_s\",\n            \"V_0\": V_0,  # [m^3/mol]\n            \"T_0\": 0.2000000000e04,  # [K]\n            \"E_0\": -0.1164949141e04 * 1e3,  # [J/mol]\n            \"S_0\": 0.1198358648e00 * 1e3,  # [J/K/mol]\n            \"K_0\": K_0,\n            \"Kprime_0\": Kp_0,\n            \"Kdprime_0\": Kdp_0,\n            \"n\": 2.0,  # called fsn in param file\n            \"Cv\": 0.4904715075e-01 * 1e3,  # [J/K/mol]\n            \"grueneisen_0\": 0.1412003694e01,\n            \"q_0\": 0.6317609916e00,\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        p_fit = [0.2471304763e05, 0.4793020138e05]\n        V_0 = 0.1513000000e02 * 1e-6\n        K_0 = p_fit[0] / (9.0 * V_0) * 1.0e3\n        a3 = 2.0 * p_fit[1] / (9.0 * K_0 * V_0) * 1.0e3\n        Kp_0 = 4.0 + (a3 / 3.0)\n        Kdp_0 = (-143.0 / 9.0 - Kp_0 * (Kp_0 - 7.0)) / K_0\n        formula = {\"Si\": 1.0, \"O\": 2.0}\n        self.params = {\n            \"name\": \"stishovite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_s\",\n            \"V_0\": V_0,  # [m^3/mol]\n            \"T_0\": 0.3000000000e04,  # [K]\n            \"E_0\": -0.2274840214e04 * 1e3,  # [J/mol]\n            \"S_0\": 0.1668222552e00 * 1e3,  # [J/K/mol]\n            \"K_0\": K_0,\n            \"Kprime_0\": Kp_0,\n            \"Kdprime_0\": Kdp_0,\n            \"n\": 2.0,  # called fsn in param file\n            \"Cv\": 0.7794230433e-01 * 1e3,  # [J/K/mol]\n            \"grueneisen_0\": 0.1389501259e01,\n            \"q_0\": 0.1332025550e01,\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        p_fit = [0.4067243956e05, 0.1177159096e05]\n        V_0 = 0.2705000000e02 * 1e-6\n        K_0 = p_fit[0] / (9.0 * V_0) * 1.0e3\n        a3 = 2.0 * p_fit[1] / (9.0 * K_0 * V_0) * 1.0e3\n        Kp_0 = 4.0 + (a3 / 3.0)\n        Kdp_0 = (-143.0 / 9.0 - Kp_0 * (Kp_0 - 7.0)) / K_0\n        formula = {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0}\n        self.params = {\n            \"name\": \"perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_s\",\n            \"V_0\": V_0,  # [m^3/mol]\n            \"T_0\": 0.3000000000e04,  # [K]\n            \"E_0\": -0.3355012782e04 * 1e3,  # [J/mol]\n            \"S_0\": 0.3384574347e00 * 1e3,  # [J/K/mol]\n            \"K_0\": K_0,\n            \"Kprime_0\": Kp_0,\n            \"Kdprime_0\": Kdp_0,\n            \"n\": 2.0,  # called fsn in param file\n            \"Cv\": 0.1338111589e00 * 1e3,  # [J/K/mol]\n            \"grueneisen_0\": 0.1893754815e01,\n            \"q_0\": 0.1487809730e01,\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def __init__(self):\n        p_fit = [0.1208938157e05, 0.1133765229e05]\n        V_0 = 0.1223000000e02 * 1e-6\n        K_0 = p_fit[0] / (9.0 * V_0) * 1.0e3\n        a3 = 2.0 * p_fit[1] / (9.0 * K_0 * V_0) * 1.0e3\n        Kp_0 = 4.0 + (a3 / 3.0)\n        Kdp_0 = (-143.0 / 9.0 - Kp_0 * (Kp_0 - 7.0)) / K_0\n        formula = {\"Mg\": 1.0, \"O\": 1.0}\n        self.params = {\n            \"name\": \"periclase\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_s\",\n            \"V_0\": V_0,  # [m^3/mol]\n            \"T_0\": 0.2000000000e04,  # [K]\n            \"E_0\": -0.1164949141e04 * 1e3,  # [J/mol]\n            \"S_0\": 0.1198358648e00 * 1e3,  # [J/K/mol]\n            \"K_0\": K_0,\n            \"Kprime_0\": Kp_0,\n            \"Kdprime_0\": Kdp_0,\n            \"n\": 2.0,  # called fsn in param file\n            \"Cv\": 0.4904715075e-01 * 1e3,  # [J/K/mol]\n            \"grueneisen_0\": 0.1412003694e01,\n            \"q_0\": 0.6317609916e00,\n            \"molar_mass\": formula_mass(formula),\n        }\n        Mineral.__init__(self)",
  "def vector_to_array(a, Of, Otheta):\n    array = np.empty([Of + 1, Otheta + 1])\n    for i in range(Of + 1):\n        for j in range(Otheta + 1):\n            n = int((i + j) * ((i + j) + 1.0) / 2.0 + j)\n            array[i][j] = a[n]\n    return array",
  "class SiO2_liquid(Mineral):\n    def __init__(self):\n        formula = {\"Si\": 1.0, \"O\": 2.0}\n        self.params = {\n            \"name\": \"SiO2_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 2.78e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 5,\n            \"m\": 0.91,\n            \"a\": [\n                -1945.93156,\n                -226.6835978,\n                455.0286309,\n                2015.65287,\n                -200.585046,\n                -216.6028187,\n                48369.72992,\n                441.5340414,\n                73.07765325,\n                0.0,\n                -651587.652,\n                20701.69954,\n                892.12209,\n                0.0,\n                0.0,\n                4100181.286,\n                -128258.7237,\n                -1228.478753,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.0004266056389,\n            \"xi\": 0.8639433047,\n            \"Tel_0\": 5651.204964,\n            \"eta\": -0.2783503528,\n            \"el_V_0\": 1e-06,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "class MgSiO3_liquid(Mineral):\n    def __init__(self):\n        formula = {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0}\n        self.params = {\n            \"name\": \"MgSiO3_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 4.18e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.83,\n            \"a\": [\n                -2984.241297,\n                -380.9839126,\n                601.8088234,\n                7307.69753,\n                7.626381912,\n                -328.367174,\n                38737.46417,\n                6251.230413,\n                402.4716495,\n                0.0,\n                0.0,\n                -23578.93569,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.008009960983,\n            \"xi\": -0.08859010337,\n            \"Tel_0\": 2194.563521,\n            \"eta\": -0.775354875,\n            \"el_V_0\": 3.89008e-05,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "class MgSi2O5_liquid(Mineral):\n    def __init__(self):\n        formula = {\"Mg\": 1.0, \"Si\": 2.0, \"O\": 5.0}\n        self.params = {\n            \"name\": \"MgSi2O5_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 6.75e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.79,\n            \"a\": [\n                -4958.560203,\n                -607.6635229,\n                1089.553108,\n                9125.144702,\n                -443.9654989,\n                -603.1466364,\n                62485.19233,\n                10927.5085,\n                1425.929331,\n                0.0,\n                0.0,\n                -27738.0811,\n                -4055.024972,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.02219035084,\n            \"xi\": 0.7754599642,\n            \"Tel_0\": 1699.783718,\n            \"eta\": -0.4712864331,\n            \"el_V_0\": 0.0001080643234,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "class MgSi3O7_liquid(Mineral):\n    def __init__(self):\n        formula = {\"Mg\": 1.0, \"Si\": 3.0, \"O\": 7.0}\n        self.params = {\n            \"name\": \"MgSi3O7_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 9.35e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.86,\n            \"a\": [\n                -6925.370617,\n                -832.0455172,\n                1439.840307,\n                12287.35224,\n                -264.7754561,\n                -780.6835127,\n                78558.47091,\n                8145.563063,\n                1444.65423,\n                0.0,\n                0.0,\n                -13036.84144,\n                -2360.783631,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.02273836197,\n            \"xi\": 0.4506392324,\n            \"Tel_0\": 2085.530204,\n            \"eta\": -0.4804823168,\n            \"el_V_0\": 0.0001080643234,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "class MgSi5O11_liquid(Mineral):\n    def __init__(self):\n        formula = {\"Mg\": 1.0, \"Si\": 5.0, \"O\": 11.0}\n        self.params = {\n            \"name\": \"MgSi5O11_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 0.000146,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 4,\n            \"m\": 0.77,\n            \"a\": [\n                -10813.78126,\n                -1297.292175,\n                2642.979479,\n                19993.66381,\n                -1085.821183,\n                -1226.314792,\n                49132.58238,\n                18886.40475,\n                1252.739819,\n                0.0,\n                528358.8509,\n                -54556.11837,\n                2844.969895,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.03318133543,\n            \"xi\": 0.4033708612,\n            \"Tel_0\": 2037.798559,\n            \"eta\": -0.6209203711,\n            \"el_V_0\": 0.00015,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "class Mg2SiO4_liquid(Mineral):\n    def __init__(self):\n        formula = {\"Mg\": 2.0, \"Si\": 1.0, \"O\": 4.0}\n        self.params = {\n            \"name\": \"Mg2SiO4_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 5.84e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.75,\n            \"a\": [\n                -3944.769208,\n                -531.7975964,\n                880.0460994,\n                11401.47398,\n                118.7409191,\n                -456.3140461,\n                55778.07008,\n                12132.5261,\n                519.3612273,\n                0.0,\n                0.0,\n                -48733.22459,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.01101820277,\n            \"xi\": 1.175924196,\n            \"Tel_0\": 2228.185561,\n            \"eta\": -0.464192202,\n            \"el_V_0\": 5.23613e-05,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "class Mg3Si2O7_liquid(Mineral):\n    def __init__(self):\n        formula = {\"Mg\": 3.0, \"Si\": 2.0, \"O\": 7.0}\n        self.params = {\n            \"name\": \"Mg3Si2O7_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 0.0001005,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.79,\n            \"a\": [\n                -6945.262972,\n                -905.8656523,\n                1466.115121,\n                18498.28462,\n                260.3083362,\n                -841.8330982,\n                89795.95729,\n                14752.47411,\n                1120.541194,\n                0.0,\n                0.0,\n                -55594.62308,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.02603891379,\n            \"xi\": 1.129966677,\n            \"Tel_0\": 2230.685379,\n            \"eta\": -0.3689626876,\n            \"el_V_0\": 0.0001080643234,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "class Mg5SiO7_liquid(Mineral):\n    def __init__(self):\n        formula = {\"Mg\": 5.0, \"Si\": 1.0, \"O\": 7.0}\n        self.params = {\n            \"name\": \"Mg5SiO7_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 0.0001075,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.64,\n            \"a\": [\n                -6721.181931,\n                -1008.922671,\n                1800.764267,\n                25856.0057,\n                2169.612789,\n                -753.9019178,\n                103374.7345,\n                17933.40061,\n                127.5989699,\n                0.0,\n                0.0,\n                -80394.40732,\n                570.0622605,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.0163355197,\n            \"xi\": 0.2784006205,\n            \"Tel_0\": 1662.606581,\n            \"eta\": -0.9693629899,\n            \"el_V_0\": 0.0001080643234,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "class MgO_liquid(Mineral):\n    def __init__(self):\n        formula = {\"Mg\": 1.0, \"O\": 1.0}\n        self.params = {\n            \"name\": \"MgO_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 1.646e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.63,\n            \"a\": [\n                -925.2677296,\n                -155.3240992,\n                260.8211743,\n                5323.167667,\n                466.3722398,\n                -88.30035696,\n                10473.87879,\n                1997.967054,\n                50.72520834,\n                0.0,\n                0.0,\n                -9914.621337,\n                71.89989255,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.002194565772,\n            \"xi\": 0.411459446,\n            \"Tel_0\": 1620.106387,\n            \"eta\": -0.986457555,\n            \"el_V_0\": 1.620953559e-05,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Si\": 1.0, \"O\": 2.0}\n        self.params = {\n            \"name\": \"SiO2_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 2.78e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 5,\n            \"m\": 0.91,\n            \"a\": [\n                -1945.93156,\n                -226.6835978,\n                455.0286309,\n                2015.65287,\n                -200.585046,\n                -216.6028187,\n                48369.72992,\n                441.5340414,\n                73.07765325,\n                0.0,\n                -651587.652,\n                20701.69954,\n                892.12209,\n                0.0,\n                0.0,\n                4100181.286,\n                -128258.7237,\n                -1228.478753,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.0004266056389,\n            \"xi\": 0.8639433047,\n            \"Tel_0\": 5651.204964,\n            \"eta\": -0.2783503528,\n            \"el_V_0\": 1e-06,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Mg\": 1.0, \"Si\": 1.0, \"O\": 3.0}\n        self.params = {\n            \"name\": \"MgSiO3_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 4.18e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.83,\n            \"a\": [\n                -2984.241297,\n                -380.9839126,\n                601.8088234,\n                7307.69753,\n                7.626381912,\n                -328.367174,\n                38737.46417,\n                6251.230413,\n                402.4716495,\n                0.0,\n                0.0,\n                -23578.93569,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.008009960983,\n            \"xi\": -0.08859010337,\n            \"Tel_0\": 2194.563521,\n            \"eta\": -0.775354875,\n            \"el_V_0\": 3.89008e-05,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Mg\": 1.0, \"Si\": 2.0, \"O\": 5.0}\n        self.params = {\n            \"name\": \"MgSi2O5_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 6.75e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.79,\n            \"a\": [\n                -4958.560203,\n                -607.6635229,\n                1089.553108,\n                9125.144702,\n                -443.9654989,\n                -603.1466364,\n                62485.19233,\n                10927.5085,\n                1425.929331,\n                0.0,\n                0.0,\n                -27738.0811,\n                -4055.024972,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.02219035084,\n            \"xi\": 0.7754599642,\n            \"Tel_0\": 1699.783718,\n            \"eta\": -0.4712864331,\n            \"el_V_0\": 0.0001080643234,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Mg\": 1.0, \"Si\": 3.0, \"O\": 7.0}\n        self.params = {\n            \"name\": \"MgSi3O7_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 9.35e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.86,\n            \"a\": [\n                -6925.370617,\n                -832.0455172,\n                1439.840307,\n                12287.35224,\n                -264.7754561,\n                -780.6835127,\n                78558.47091,\n                8145.563063,\n                1444.65423,\n                0.0,\n                0.0,\n                -13036.84144,\n                -2360.783631,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.02273836197,\n            \"xi\": 0.4506392324,\n            \"Tel_0\": 2085.530204,\n            \"eta\": -0.4804823168,\n            \"el_V_0\": 0.0001080643234,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Mg\": 1.0, \"Si\": 5.0, \"O\": 11.0}\n        self.params = {\n            \"name\": \"MgSi5O11_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 0.000146,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 4,\n            \"m\": 0.77,\n            \"a\": [\n                -10813.78126,\n                -1297.292175,\n                2642.979479,\n                19993.66381,\n                -1085.821183,\n                -1226.314792,\n                49132.58238,\n                18886.40475,\n                1252.739819,\n                0.0,\n                528358.8509,\n                -54556.11837,\n                2844.969895,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.03318133543,\n            \"xi\": 0.4033708612,\n            \"Tel_0\": 2037.798559,\n            \"eta\": -0.6209203711,\n            \"el_V_0\": 0.00015,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Mg\": 2.0, \"Si\": 1.0, \"O\": 4.0}\n        self.params = {\n            \"name\": \"Mg2SiO4_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 5.84e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.75,\n            \"a\": [\n                -3944.769208,\n                -531.7975964,\n                880.0460994,\n                11401.47398,\n                118.7409191,\n                -456.3140461,\n                55778.07008,\n                12132.5261,\n                519.3612273,\n                0.0,\n                0.0,\n                -48733.22459,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.01101820277,\n            \"xi\": 1.175924196,\n            \"Tel_0\": 2228.185561,\n            \"eta\": -0.464192202,\n            \"el_V_0\": 5.23613e-05,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Mg\": 3.0, \"Si\": 2.0, \"O\": 7.0}\n        self.params = {\n            \"name\": \"Mg3Si2O7_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 0.0001005,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.79,\n            \"a\": [\n                -6945.262972,\n                -905.8656523,\n                1466.115121,\n                18498.28462,\n                260.3083362,\n                -841.8330982,\n                89795.95729,\n                14752.47411,\n                1120.541194,\n                0.0,\n                0.0,\n                -55594.62308,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.02603891379,\n            \"xi\": 1.129966677,\n            \"Tel_0\": 2230.685379,\n            \"eta\": -0.3689626876,\n            \"el_V_0\": 0.0001080643234,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Mg\": 5.0, \"Si\": 1.0, \"O\": 7.0}\n        self.params = {\n            \"name\": \"Mg5SiO7_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 0.0001075,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.64,\n            \"a\": [\n                -6721.181931,\n                -1008.922671,\n                1800.764267,\n                25856.0057,\n                2169.612789,\n                -753.9019178,\n                103374.7345,\n                17933.40061,\n                127.5989699,\n                0.0,\n                0.0,\n                -80394.40732,\n                570.0622605,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.0163355197,\n            \"xi\": 0.2784006205,\n            \"Tel_0\": 1662.606581,\n            \"eta\": -0.9693629899,\n            \"el_V_0\": 0.0001080643234,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Mg\": 1.0, \"O\": 1.0}\n        self.params = {\n            \"name\": \"MgO_liquid\",\n            \"formula\": formula,\n            \"equation_of_state\": \"dks_l\",\n            \"V_0\": 1.646e-05,\n            \"T_0\": 3000.0,\n            \"O_theta\": 2,\n            \"O_f\": 3,\n            \"m\": 0.63,\n            \"a\": [\n                -925.2677296,\n                -155.3240992,\n                260.8211743,\n                5323.167667,\n                466.3722398,\n                -88.30035696,\n                10473.87879,\n                1997.967054,\n                50.72520834,\n                0.0,\n                0.0,\n                -9914.621337,\n                71.89989255,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n                0.0,\n            ],\n            \"zeta_0\": 0.002194565772,\n            \"xi\": 0.411459446,\n            \"Tel_0\": 1620.106387,\n            \"eta\": -0.986457555,\n            \"el_V_0\": 1.620953559e-05,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.params[\"a\"] = (\n            vector_to_array(\n                self.params[\"a\"], self.params[\"O_f\"], self.params[\"O_theta\"]\n            )\n            * 1e3\n        )  # [J/mol]\n        Mineral.__init__(self)",
  "class bridgmanite(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"bridgmanite/perovskite\"\n        self.solution_model = IdealSolution(\n            endmembers=[\n                [mg_si_perovskite(), \"[Mg][Si]O3\"],\n                [fe_si_perovskite(), \"[Fe][Si]O3\"],\n                [al_al_perovskite(), \"[Al][Al]O3\"],\n                [fe_al_perovskite(), \"[Fe][Al]O3\"],\n            ]\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class ferropericlase(Solution):\n    def __init__(self, molar_fractions=None):\n        self.name = \"magnesiowustite/ferropericlase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[[periclase(), \"[Mg]O\"], [wuestite(), \"[Fe]O\"]],\n            energy_interaction=[[13.0e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "class mg_si_perovskite(Mineral):\n    def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"MgSiO3 perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1368000.0,\n            \"V_0\": 2.4445e-05,\n            \"K_0\": 2.51e11,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 905.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"G_0\": 1.73e11,\n            \"Gprime_0\": 1.7,\n            \"eta_s_0\": 2.3,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "class fe_si_perovskite(Mineral):\n    def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"FeSiO3 perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1043000.0,\n            \"V_0\": 2.534e-05,\n            \"K_0\": 2.72e11,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 871.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"G_0\": 1.33 + 11,\n            \"Gprime_0\": 1.4,\n            \"eta_s_0\": 2.3,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "class fe_al_perovskite(Mineral):\n    def __init__(self):\n        formula = \"FeAlO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"FeAlO3 perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 2.69e-05,\n            \"K_0\": 2.20e11,\n            \"Kprime_0\": 1.3,\n            \"Debye_0\": 886.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"G_0\": 96.0e09,\n            \"Gprime_0\": 3.4,\n            \"eta_s_0\": 2.5,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "class al_al_perovskite(Mineral):\n    def __init__(self):\n        formula = \"Al2O3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Al2O3 perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1533878.0,\n            \"V_0\": 2.494e-05,\n            \"K_0\": 2.58e11,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 886.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"G_0\": 1.71e11,\n            \"Gprime_0\": 1.5,\n            \"eta_s_0\": 2.5,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "class periclase(Mineral):\n    def __init__(self):\n        formula = \"MgO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Periclase\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -569000.0,\n            \"V_0\": 1.124e-05,\n            \"K_0\": 1.602e11,\n            \"Kprime_0\": 3.99,\n            \"Debye_0\": 767.0,\n            \"grueneisen_0\": 1.36,\n            \"q_0\": 1.7,\n            \"G_0\": 1.31e11,\n            \"Gprime_0\": 2.1,\n            \"eta_s_0\": 2.8,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "class wuestite(Mineral):\n    def __init__(self):\n        formula = \"FeO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Wuestite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -242000.0,\n            \"V_0\": 1.226e-05,\n            \"K_0\": 1.49e11,\n            \"Kprime_0\": 3.6,\n            \"Debye_0\": 454.0,\n            \"grueneisen_0\": 1.53,\n            \"q_0\": 1.7,\n            \"G_0\": 60.0e9,\n            \"Gprime_0\": 1.8,\n            \"eta_s_0\": 0.6,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "class ca_perovskite(Mineral):\n    def __init__(self):\n        formula = \"CaSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"CaSiO3 perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1463358.0,\n            \"V_0\": 2.754e-05,\n            \"K_0\": 2.36e11,\n            \"Kprime_0\": 3.9,\n            \"Debye_0\": 802.0,\n            \"grueneisen_0\": 1.89,\n            \"q_0\": 0.9,\n            \"G_0\": 1.57e11,\n            \"Gprime_0\": 2.2,\n            \"eta_s_0\": 1.3,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "class hcp_iron(Mineral):\n    def __init__(self):\n        formula = \"Fe\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Hexagonal close packed iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1463358.0,\n            \"V_0\": 0.673e-05,\n            \"K_0\": 1.64e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 422.0,\n            \"grueneisen_0\": 1.71,\n            \"q_0\": 1.4,\n            \"G_0\": 0.815e11,\n            \"Gprime_0\": 1.9,\n            \"eta_s_0\": 7,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"bridgmanite/perovskite\"\n        self.solution_model = IdealSolution(\n            endmembers=[\n                [mg_si_perovskite(), \"[Mg][Si]O3\"],\n                [fe_si_perovskite(), \"[Fe][Si]O3\"],\n                [al_al_perovskite(), \"[Al][Al]O3\"],\n                [fe_al_perovskite(), \"[Fe][Al]O3\"],\n            ]\n        )\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self, molar_fractions=None):\n        self.name = \"magnesiowustite/ferropericlase\"\n        self.solution_model = SymmetricRegularSolution(\n            endmembers=[[periclase(), \"[Mg]O\"], [wuestite(), \"[Fe]O\"]],\n            energy_interaction=[[13.0e3]],\n        )\n\n        Solution.__init__(self, molar_fractions=molar_fractions)",
  "def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"MgSiO3 perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1368000.0,\n            \"V_0\": 2.4445e-05,\n            \"K_0\": 2.51e11,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 905.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"G_0\": 1.73e11,\n            \"Gprime_0\": 1.7,\n            \"eta_s_0\": 2.3,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"FeSiO3 perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1043000.0,\n            \"V_0\": 2.534e-05,\n            \"K_0\": 2.72e11,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 871.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"G_0\": 1.33 + 11,\n            \"Gprime_0\": 1.4,\n            \"eta_s_0\": 2.3,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeAlO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"FeAlO3 perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 2.69e-05,\n            \"K_0\": 2.20e11,\n            \"Kprime_0\": 1.3,\n            \"Debye_0\": 886.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"G_0\": 96.0e09,\n            \"Gprime_0\": 3.4,\n            \"eta_s_0\": 2.5,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Al2O3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Al2O3 perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1533878.0,\n            \"V_0\": 2.494e-05,\n            \"K_0\": 2.58e11,\n            \"Kprime_0\": 4.1,\n            \"Debye_0\": 886.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"G_0\": 1.71e11,\n            \"Gprime_0\": 1.5,\n            \"eta_s_0\": 2.5,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Periclase\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -569000.0,\n            \"V_0\": 1.124e-05,\n            \"K_0\": 1.602e11,\n            \"Kprime_0\": 3.99,\n            \"Debye_0\": 767.0,\n            \"grueneisen_0\": 1.36,\n            \"q_0\": 1.7,\n            \"G_0\": 1.31e11,\n            \"Gprime_0\": 2.1,\n            \"eta_s_0\": 2.8,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Wuestite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -242000.0,\n            \"V_0\": 1.226e-05,\n            \"K_0\": 1.49e11,\n            \"Kprime_0\": 3.6,\n            \"Debye_0\": 454.0,\n            \"grueneisen_0\": 1.53,\n            \"q_0\": 1.7,\n            \"G_0\": 60.0e9,\n            \"Gprime_0\": 1.8,\n            \"eta_s_0\": 0.6,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"CaSiO3 perovskite\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1463358.0,\n            \"V_0\": 2.754e-05,\n            \"K_0\": 2.36e11,\n            \"Kprime_0\": 3.9,\n            \"Debye_0\": 802.0,\n            \"grueneisen_0\": 1.89,\n            \"q_0\": 0.9,\n            \"G_0\": 1.57e11,\n            \"Gprime_0\": 2.2,\n            \"eta_s_0\": 1.3,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"Hexagonal close packed iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"slb3\",\n            \"F_0\": -1463358.0,\n            \"V_0\": 0.673e-05,\n            \"K_0\": 1.64e11,\n            \"Kprime_0\": 4.0,\n            \"Debye_0\": 422.0,\n            \"grueneisen_0\": 1.71,\n            \"q_0\": 1.4,\n            \"G_0\": 0.815e11,\n            \"Gprime_0\": 1.9,\n            \"eta_s_0\": 7,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        Mineral.__init__(self)",
  "class bcc_iron(Mineral):\n    def __init__(self):\n        formula = {\"Fe\": 1.0}\n        self.params = {\n            \"name\": \"BCC iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 9149.0,\n            \"S_0\": 36.868,\n            \"V_0\": 7.09e-06,\n            \"Cp\": [21.09, 0.0101455, -221508.0, 47.1947],\n            \"a_0\": 3.56e-05,\n            \"K_0\": 1.64e11,\n            \"Kprime_0\": 5.16,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.property_modifiers = [\n            [\n                \"magnetic_chs\",\n                {\n                    \"structural_parameter\": 0.4,\n                    \"curie_temperature\": [1043.0, 0.0],\n                    \"magnetic_moment\": [2.22, 0.0],\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class fcc_iron(Mineral):\n    def __init__(self):\n        formula = {\"Fe\": 1.0}\n        self.params = {\n            \"name\": \"FCC iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 7973.0,\n            \"S_0\": 35.907,\n            \"V_0\": 6.93863394593e-06,\n            \"Cp\": [22.24, 0.0088656, -221517.0, 47.1998],\n            \"a_0\": 5.13e-05,\n            \"K_0\": 1.539e11,\n            \"Kprime_0\": 5.2,\n            \"Kdprime_0\": -3.37e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.property_modifiers = [\n            [\n                \"magnetic_chs\",\n                {\n                    \"structural_parameter\": 0.28,\n                    \"curie_temperature\": [201.0, 0.0],\n                    \"magnetic_moment\": [2.1, 0.0],\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Fe\": 1.0}\n        self.params = {\n            \"name\": \"BCC iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 9149.0,\n            \"S_0\": 36.868,\n            \"V_0\": 7.09e-06,\n            \"Cp\": [21.09, 0.0101455, -221508.0, 47.1947],\n            \"a_0\": 3.56e-05,\n            \"K_0\": 1.64e11,\n            \"Kprime_0\": 5.16,\n            \"Kdprime_0\": -3.1e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.property_modifiers = [\n            [\n                \"magnetic_chs\",\n                {\n                    \"structural_parameter\": 0.4,\n                    \"curie_temperature\": [1043.0, 0.0],\n                    \"magnetic_moment\": [2.22, 0.0],\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = {\"Fe\": 1.0}\n        self.params = {\n            \"name\": \"FCC iron\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": 7973.0,\n            \"S_0\": 35.907,\n            \"V_0\": 6.93863394593e-06,\n            \"Cp\": [22.24, 0.0088656, -221517.0, 47.1998],\n            \"a_0\": 5.13e-05,\n            \"K_0\": 1.539e11,\n            \"Kprime_0\": 5.2,\n            \"Kdprime_0\": -3.37e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n        self.property_modifiers = [\n            [\n                \"magnetic_chs\",\n                {\n                    \"structural_parameter\": 0.28,\n                    \"curie_temperature\": [201.0, 0.0],\n                    \"magnetic_moment\": [2.1, 0.0],\n                },\n            ]\n        ]\n        Mineral.__init__(self)",
  "class fo(Mineral):\n    def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fo\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2172450.0,\n            \"S_0\": 95.1,\n            \"V_0\": 4.366e-05,\n            \"Cp\": [233.3, 0.001494, -603800.0, -1869.7],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 1.285e11,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 530.0}\n        Mineral.__init__(self)",
  "class fa(Mineral):\n    def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fa\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1477740.0,\n            \"S_0\": 151.0,\n            \"V_0\": 4.631e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.82e-05,\n            \"K_0\": 1.256e11,\n            \"Kprime_0\": 4.68,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 640.0}\n        Mineral.__init__(self)",
  "class mwd(Mineral):\n    def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mwd\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2138080.0,\n            \"S_0\": 93.9,\n            \"V_0\": 4.051e-05,\n            \"Cp\": [208.7, 0.003942, -1709500.0, -1302.8],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 1.726e11,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 620.0}\n        Mineral.__init__(self)",
  "class fwd(Mineral):\n    def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fwd\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1467920.0,\n            \"S_0\": 146.0,\n            \"V_0\": 4.321e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 1.69e11,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 900.0}\n        Mineral.__init__(self)",
  "class mrw(Mineral):\n    def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mrw\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2126840.0,\n            \"S_0\": 90.0,\n            \"V_0\": 3.949e-05,\n            \"Cp\": [213.3, 0.00269, -1410400.0, -1495.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 1.781e11,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 630.0}\n        Mineral.__init__(self)",
  "class frw(Mineral):\n    def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"frw\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1471760.0,\n            \"S_0\": 140.0,\n            \"V_0\": 4.203e-05,\n            \"Cp\": [166.8, 0.04261, -1705400.0, -541.4],\n            \"a_0\": 2.22e-05,\n            \"K_0\": 1.977e11,\n            \"Kprime_0\": 4.92,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 710.0}\n        Mineral.__init__(self)",
  "class mpv(Mineral):\n    def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mpv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1442310.0,\n            \"S_0\": 62.6,\n            \"V_0\": 2.445e-05,\n            \"Cp\": [149.3, 0.002918, -2983000.0, -799.1],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 2.51e11,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 470.0}\n        Mineral.__init__(self)",
  "class fpv(Mineral):\n    def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fpv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1082910.0,\n            \"S_0\": 95.0,\n            \"V_0\": 2.534e-05,\n            \"Cp\": [133.2, 0.01083, -3661400.0, -314.7],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 2.81e11,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 760.0}\n        Mineral.__init__(self)",
  "class apv(Mineral):\n    def __init__(self):\n        formula = \"AlAlO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"apv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1619990.0,\n            \"S_0\": 51.8,\n            \"V_0\": 2.54e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 2.03e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 770.0}\n        Mineral.__init__(self)",
  "class npv(Mineral):\n    def __init__(self):\n        formula = \"Na0.5Al0.5SiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"npv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1365000.0,\n            \"S_0\": 63.0,\n            \"V_0\": 2.334e-05,\n            \"Cp\": [135.0, 0.00846, -1850300.0, -600.8],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 2.03e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 10240.0}\n        Mineral.__init__(self)",
  "class cpv(Mineral):\n    def __init__(self):\n        formula = \"CaSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"cpv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1533590.0,\n            \"S_0\": 74.5,\n            \"V_0\": 2.745e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2e-05,\n            \"K_0\": 2.36e11,\n            \"Kprime_0\": 3.9,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1090.0}\n        Mineral.__init__(self)",
  "class mak(Mineral):\n    def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mak\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1489610.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 2.11e11,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 420.0}\n        Mineral.__init__(self)",
  "class fak(Mineral):\n    def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fak\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1142130.0,\n            \"S_0\": 91.5,\n            \"V_0\": 2.76e-05,\n            \"Cp\": [100.3, 0.013328, -4364900.0, 419.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 2.18e11,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 9630.0}\n        Mineral.__init__(self)",
  "class maj(Mineral):\n    def __init__(self):\n        formula = \"Mg4Si4O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"maj\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6041550.0,\n            \"S_0\": 260.2,\n            \"V_0\": 0.00011457,\n            \"Cp\": [713.6, -0.000997, -1158200.0, -6622.3],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 1.6e11,\n            \"Kprime_0\": 4.56,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 2260.0}\n        Mineral.__init__(self)",
  "class nagt(Mineral):\n    def __init__(self):\n        formula = \"Mg2NaAlSiSi3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"nagt\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5985000.0,\n            \"S_0\": 260.6,\n            \"V_0\": 0.0001109,\n            \"Cp\": [620.8, 0.0112, -3755900.0, -4421.3],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 1.7e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 5120.0}\n        Mineral.__init__(self)",
  "class py(Mineral):\n    def __init__(self):\n        formula = \"Mg3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"py\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6281770.0,\n            \"S_0\": 269.5,\n            \"V_0\": 0.00011313,\n            \"Cp\": [633.5, 0.0, -5196100.0, -4315.2],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 1.743e11,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 990.0}\n        Mineral.__init__(self)",
  "class alm(Mineral):\n    def __init__(self):\n        formula = \"Fe3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"alm\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5260750.0,\n            \"S_0\": 342.0,\n            \"V_0\": 0.00011525,\n            \"Cp\": [677.3, 0.0, -3772700.0, -5044.0],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 1.9e11,\n            \"Kprime_0\": 2.98,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1200.0}\n        Mineral.__init__(self)",
  "class gr(Mineral):\n    def __init__(self):\n        formula = \"Ca3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"gr\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6643050.0,\n            \"S_0\": 255.0,\n            \"V_0\": 0.00012535,\n            \"Cp\": [626.0, 0.0, -5779200.0, -4002.9],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 1.72e11,\n            \"Kprime_0\": 5.53,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1370.0}\n        Mineral.__init__(self)",
  "class en(Mineral):\n    def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"en\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3090100.0,\n            \"S_0\": 132.5,\n            \"V_0\": 6.262e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 1.059e11,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 620.0}\n        Mineral.__init__(self)",
  "class cen(Mineral):\n    def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"cen\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3090990.0,\n            \"S_0\": 132.0,\n            \"V_0\": 6.264e-05,\n            \"Cp\": [306.0, -0.003793, -3041700.0, -1852.1],\n            \"a_0\": 2.11e-05,\n            \"K_0\": 1.059e11,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 620.0}\n        Mineral.__init__(self)",
  "class hen(Mineral):\n    def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"hen\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3082610.0,\n            \"S_0\": 131.7,\n            \"V_0\": 6.099e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.26e-05,\n            \"K_0\": 1.5e11,\n            \"Kprime_0\": 5.5,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 620.0}\n        Mineral.__init__(self)",
  "class hfs(Mineral):\n    def __init__(self):\n        formula = \"Fe2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"hfs\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2380810.0,\n            \"S_0\": 189.0,\n            \"V_0\": 6.405e-05,\n            \"Cp\": [398.7, -0.006579, 1290100.0, -4058.0],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 1.5e11,\n            \"Kprime_0\": 5.5,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 790.0}\n        Mineral.__init__(self)",
  "class fs(Mineral):\n    def __init__(self):\n        formula = \"Fe2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fs\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2388760.0,\n            \"S_0\": 189.9,\n            \"V_0\": 6.592e-05,\n            \"Cp\": [398.7, -0.006579, 1290100.0, -4058.0],\n            \"a_0\": 3.26e-05,\n            \"K_0\": 1.01e11,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -4e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 750.0}\n        Mineral.__init__(self)",
  "class mgts(Mineral):\n    def __init__(self):\n        formula = \"MgAl2SiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mgts\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3196600.0,\n            \"S_0\": 131.0,\n            \"V_0\": 6.05e-05,\n            \"Cp\": [371.4, -0.004082, -398400.0, -3547.1],\n            \"a_0\": 2.17e-05,\n            \"K_0\": 1.028e11,\n            \"Kprime_0\": 8.55,\n            \"Kdprime_0\": -8.3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 690.0}\n        Mineral.__init__(self)",
  "class di(Mineral):\n    def __init__(self):\n        formula = \"CaMgSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"di\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3201820.0,\n            \"S_0\": 142.9,\n            \"V_0\": 6.619e-05,\n            \"Cp\": [314.5, 4.1e-05, -2745900.0, -2020.1],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 1.192e11,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 580.0}\n        Mineral.__init__(self)",
  "class hed(Mineral):\n    def __init__(self):\n        formula = \"CaFeSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"hed\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2842120.0,\n            \"S_0\": 175.0,\n            \"V_0\": 6.795e-05,\n            \"Cp\": [340.2, 0.000812, -1047800.0, -2646.7],\n            \"a_0\": 2.38e-05,\n            \"K_0\": 1.192e11,\n            \"Kprime_0\": 3.97,\n            \"Kdprime_0\": -3.3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 880.0}\n        Mineral.__init__(self)",
  "class jd(Mineral):\n    def __init__(self):\n        formula = \"NaAlSiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"jd\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3025290.0,\n            \"S_0\": 133.5,\n            \"V_0\": 6.04e-05,\n            \"Cp\": [319.4, 0.003616, -1173900.0, -2469.5],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 1.281e11,\n            \"Kprime_0\": 3.81,\n            \"Kdprime_0\": -3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1520.0}\n        Mineral.__init__(self)",
  "class cats(Mineral):\n    def __init__(self):\n        formula = \"CaAl2SiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"cats\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3310110.0,\n            \"S_0\": 135.0,\n            \"V_0\": 6.356e-05,\n            \"Cp\": [347.6, -0.006974, -1781600.0, -2757.5],\n            \"a_0\": 2.08e-05,\n            \"K_0\": 1.192e11,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 750.0}\n        Mineral.__init__(self)",
  "class stv(Mineral):\n    def __init__(self):\n        formula = \"SiO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"stv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -876820.0,\n            \"S_0\": 24.0,\n            \"V_0\": 1.401e-05,\n            \"Cp\": [68.1, 0.00601, -1978200.0, -82.1],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 3.09e11,\n            \"Kprime_0\": 4.6,\n            \"Kdprime_0\": -1.5e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 420.0}\n        Mineral.__init__(self)",
  "class macf(Mineral):\n    def __init__(self):\n        formula = \"MgAl2O4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"macf\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2246420.0,\n            \"S_0\": 80.0,\n            \"V_0\": 3.614e-05,\n            \"Cp\": [200.0, 0.006252, -2996400.0, -888.4],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 2.12e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1080.0}\n        Mineral.__init__(self)",
  "class mscf(Mineral):\n    def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mscf\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2061130.0,\n            \"S_0\": 87.5,\n            \"V_0\": 3.649e-05,\n            \"Cp\": [213.3, 0.00269, -1410400.0, -1495.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 1.85e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1340.0}\n        Mineral.__init__(self)",
  "class fscf(Mineral):\n    def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fscf\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1405500.0,\n            \"S_0\": 143.4,\n            \"V_0\": 3.914e-05,\n            \"Cp\": [181.1, 0.018526, -2767200.0, -527.1],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 1.85e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 10240.0}\n        Mineral.__init__(self)",
  "class nacf(Mineral):\n    def __init__(self):\n        formula = \"NaAlSiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"nacf\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1965550.0,\n            \"S_0\": 110.0,\n            \"V_0\": 3.631e-05,\n            \"Cp\": [272.7, -0.012398, 0.0, -2763.1],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 1.85e11,\n            \"Kprime_0\": 4.6,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 3440.0}\n        Mineral.__init__(self)",
  "class cacf(Mineral):\n    def __init__(self):\n        formula = \"CaAl2O4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"cacf\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2325600.0,\n            \"S_0\": 87.6,\n            \"V_0\": 3.976e-05,\n            \"Cp\": [191.9, 0.009563, -3211300.0, -640.2],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 1.9e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 10240.0}\n        Mineral.__init__(self)",
  "class manal(Mineral):\n    def __init__(self):\n        formula = \"Mg3Al6O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"manal\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6796630.0,\n            \"S_0\": 250.0,\n            \"V_0\": 0.00011166,\n            \"Cp\": [600.0, 0.018756, -8989200.0, -2665.2],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 1.84e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 5120.0}\n        Mineral.__init__(self)",
  "class nanal(Mineral):\n    def __init__(self):\n        formula = \"NaMg2SiAl5O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"nanal\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6610270.0,\n            \"S_0\": 280.0,\n            \"V_0\": 0.00011322,\n            \"Cp\": [672.7, 0.000106, -5992800.0, -4539.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 1.84e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 5120.0}\n        Mineral.__init__(self)",
  "class msnal(Mineral):\n    def __init__(self):\n        formula = \"MgMg2Si3Mg3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"msnal\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6172380.0,\n            \"S_0\": 272.5,\n            \"V_0\": 0.00011061,\n            \"Cp\": [639.9, 0.00807, -4231200.0, -4487.7],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 1.85e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 5120.0}\n        Mineral.__init__(self)",
  "class fsnal(Mineral):\n    def __init__(self):\n        formula = \"FeFe2Si3Fe3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fsnal\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4146000.0,\n            \"S_0\": 440.2,\n            \"V_0\": 0.00011856,\n            \"Cp\": [543.3, 0.055578, -8301600.0, -1581.3],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 1.85e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 10240.0}\n        Mineral.__init__(self)",
  "class canal(Mineral):\n    def __init__(self):\n        formula = \"CaMg2Al6O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"canal\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6840000.0,\n            \"S_0\": 257.6,\n            \"V_0\": 0.00011159,\n            \"Cp\": [591.9, 0.022067, -9204100.0, -2417.0],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 1.77e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 5120.0}\n        Mineral.__init__(self)",
  "class per(Mineral):\n    def __init__(self):\n        formula = \"MgO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"per\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -601570.0,\n            \"S_0\": 26.5,\n            \"V_0\": 1.125e-05,\n            \"Cp\": [60.5, 0.000362, -535800.0, -299.2],\n            \"a_0\": 3.11e-05,\n            \"K_0\": 1.616e11,\n            \"Kprime_0\": 3.95,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 260.0}\n        Mineral.__init__(self)",
  "class fper(Mineral):\n    def __init__(self):\n        formula = \"FeO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fper\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -262240.0,\n            \"S_0\": 58.6,\n            \"V_0\": 1.206e-05,\n            \"Cp\": [44.4, 0.00828, -1214200.0, 185.2],\n            \"a_0\": 3.22e-05,\n            \"K_0\": 1.52e11,\n            \"Kprime_0\": 4.9,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 680.0}\n        Mineral.__init__(self)",
  "class cor(Mineral):\n    def __init__(self):\n        formula = \"Al2O3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"cor\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1675250.0,\n            \"S_0\": 50.9,\n            \"V_0\": 2.558e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 2.54e11,\n            \"Kprime_0\": 4.34,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 700.0}\n        Mineral.__init__(self)",
  "class mcor(Mineral):\n    def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mcor\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1468000.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 2.11e11,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 880.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fo\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2172450.0,\n            \"S_0\": 95.1,\n            \"V_0\": 4.366e-05,\n            \"Cp\": [233.3, 0.001494, -603800.0, -1869.7],\n            \"a_0\": 2.85e-05,\n            \"K_0\": 1.285e11,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 530.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fa\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1477740.0,\n            \"S_0\": 151.0,\n            \"V_0\": 4.631e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.82e-05,\n            \"K_0\": 1.256e11,\n            \"Kprime_0\": 4.68,\n            \"Kdprime_0\": -3.7e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 640.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mwd\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2138080.0,\n            \"S_0\": 93.9,\n            \"V_0\": 4.051e-05,\n            \"Cp\": [208.7, 0.003942, -1709500.0, -1302.8],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 1.726e11,\n            \"Kprime_0\": 3.84,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 620.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fwd\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1467920.0,\n            \"S_0\": 146.0,\n            \"V_0\": 4.321e-05,\n            \"Cp\": [201.1, 0.01733, -1960600.0, -900.9],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 1.69e11,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 900.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mrw\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2126840.0,\n            \"S_0\": 90.0,\n            \"V_0\": 3.949e-05,\n            \"Cp\": [213.3, 0.00269, -1410400.0, -1495.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 1.781e11,\n            \"Kprime_0\": 4.35,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 630.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"frw\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1471760.0,\n            \"S_0\": 140.0,\n            \"V_0\": 4.203e-05,\n            \"Cp\": [166.8, 0.04261, -1705400.0, -541.4],\n            \"a_0\": 2.22e-05,\n            \"K_0\": 1.977e11,\n            \"Kprime_0\": 4.92,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 710.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mpv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1442310.0,\n            \"S_0\": 62.6,\n            \"V_0\": 2.445e-05,\n            \"Cp\": [149.3, 0.002918, -2983000.0, -799.1],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 2.51e11,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 470.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fpv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1082910.0,\n            \"S_0\": 95.0,\n            \"V_0\": 2.534e-05,\n            \"Cp\": [133.2, 0.01083, -3661400.0, -314.7],\n            \"a_0\": 1.87e-05,\n            \"K_0\": 2.81e11,\n            \"Kprime_0\": 4.14,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 760.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"AlAlO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"apv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1619990.0,\n            \"S_0\": 51.8,\n            \"V_0\": 2.54e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 2.03e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 770.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Na0.5Al0.5SiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"npv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1365000.0,\n            \"S_0\": 63.0,\n            \"V_0\": 2.334e-05,\n            \"Cp\": [135.0, 0.00846, -1850300.0, -600.8],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 2.03e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 10240.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"cpv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1533590.0,\n            \"S_0\": 74.5,\n            \"V_0\": 2.745e-05,\n            \"Cp\": [159.3, 0.0, -967300.0, -1075.4],\n            \"a_0\": 2e-05,\n            \"K_0\": 2.36e11,\n            \"Kprime_0\": 3.9,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1090.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mak\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1489610.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 2.11e11,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 420.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fak\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1142130.0,\n            \"S_0\": 91.5,\n            \"V_0\": 2.76e-05,\n            \"Cp\": [100.3, 0.013328, -4364900.0, 419.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 2.18e11,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 9630.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg4Si4O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"maj\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6041550.0,\n            \"S_0\": 260.2,\n            \"V_0\": 0.00011457,\n            \"Cp\": [713.6, -0.000997, -1158200.0, -6622.3],\n            \"a_0\": 1.83e-05,\n            \"K_0\": 1.6e11,\n            \"Kprime_0\": 4.56,\n            \"Kdprime_0\": -2.8e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 2260.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2NaAlSiSi3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"nagt\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5985000.0,\n            \"S_0\": 260.6,\n            \"V_0\": 0.0001109,\n            \"Cp\": [620.8, 0.0112, -3755900.0, -4421.3],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 1.7e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 5120.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"py\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6281770.0,\n            \"S_0\": 269.5,\n            \"V_0\": 0.00011313,\n            \"Cp\": [633.5, 0.0, -5196100.0, -4315.2],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 1.743e11,\n            \"Kprime_0\": 4.05,\n            \"Kdprime_0\": -2.3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 990.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"alm\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -5260750.0,\n            \"S_0\": 342.0,\n            \"V_0\": 0.00011525,\n            \"Cp\": [677.3, 0.0, -3772700.0, -5044.0],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 1.9e11,\n            \"Kprime_0\": 2.98,\n            \"Kdprime_0\": -1.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1200.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Ca3Al2Si3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"gr\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6643050.0,\n            \"S_0\": 255.0,\n            \"V_0\": 0.00012535,\n            \"Cp\": [626.0, 0.0, -5779200.0, -4002.9],\n            \"a_0\": 2.2e-05,\n            \"K_0\": 1.72e11,\n            \"Kprime_0\": 5.53,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1370.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"en\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3090100.0,\n            \"S_0\": 132.5,\n            \"V_0\": 6.262e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.27e-05,\n            \"K_0\": 1.059e11,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 620.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"cen\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3090990.0,\n            \"S_0\": 132.0,\n            \"V_0\": 6.264e-05,\n            \"Cp\": [306.0, -0.003793, -3041700.0, -1852.1],\n            \"a_0\": 2.11e-05,\n            \"K_0\": 1.059e11,\n            \"Kprime_0\": 8.65,\n            \"Kdprime_0\": -8.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 620.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"hen\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3082610.0,\n            \"S_0\": 131.7,\n            \"V_0\": 6.099e-05,\n            \"Cp\": [356.2, -0.00299, -596900.0, -3185.3],\n            \"a_0\": 2.26e-05,\n            \"K_0\": 1.5e11,\n            \"Kprime_0\": 5.5,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 620.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"hfs\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2380810.0,\n            \"S_0\": 189.0,\n            \"V_0\": 6.405e-05,\n            \"Cp\": [398.7, -0.006579, 1290100.0, -4058.0],\n            \"a_0\": 2.37e-05,\n            \"K_0\": 1.5e11,\n            \"Kprime_0\": 5.5,\n            \"Kdprime_0\": -3.6e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 790.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2Si2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fs\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2388760.0,\n            \"S_0\": 189.9,\n            \"V_0\": 6.592e-05,\n            \"Cp\": [398.7, -0.006579, 1290100.0, -4058.0],\n            \"a_0\": 3.26e-05,\n            \"K_0\": 1.01e11,\n            \"Kprime_0\": 4.08,\n            \"Kdprime_0\": -4e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 750.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgAl2SiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mgts\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3196600.0,\n            \"S_0\": 131.0,\n            \"V_0\": 6.05e-05,\n            \"Cp\": [371.4, -0.004082, -398400.0, -3547.1],\n            \"a_0\": 2.17e-05,\n            \"K_0\": 1.028e11,\n            \"Kprime_0\": 8.55,\n            \"Kdprime_0\": -8.3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 690.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaMgSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"di\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3201820.0,\n            \"S_0\": 142.9,\n            \"V_0\": 6.619e-05,\n            \"Cp\": [314.5, 4.1e-05, -2745900.0, -2020.1],\n            \"a_0\": 2.73e-05,\n            \"K_0\": 1.192e11,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 580.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaFeSi2O6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"hed\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2842120.0,\n            \"S_0\": 175.0,\n            \"V_0\": 6.795e-05,\n            \"Cp\": [340.2, 0.000812, -1047800.0, -2646.7],\n            \"a_0\": 2.38e-05,\n            \"K_0\": 1.192e11,\n            \"Kprime_0\": 3.97,\n            \"Kdprime_0\": -3.3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 880.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"NaAlSiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"jd\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3025290.0,\n            \"S_0\": 133.5,\n            \"V_0\": 6.04e-05,\n            \"Cp\": [319.4, 0.003616, -1173900.0, -2469.5],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 1.281e11,\n            \"Kprime_0\": 3.81,\n            \"Kdprime_0\": -3e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1520.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaAl2SiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"cats\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -3310110.0,\n            \"S_0\": 135.0,\n            \"V_0\": 6.356e-05,\n            \"Cp\": [347.6, -0.006974, -1781600.0, -2757.5],\n            \"a_0\": 2.08e-05,\n            \"K_0\": 1.192e11,\n            \"Kprime_0\": 5.19,\n            \"Kdprime_0\": -4.4e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 750.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"SiO2\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"stv\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -876820.0,\n            \"S_0\": 24.0,\n            \"V_0\": 1.401e-05,\n            \"Cp\": [68.1, 0.00601, -1978200.0, -82.1],\n            \"a_0\": 1.58e-05,\n            \"K_0\": 3.09e11,\n            \"Kprime_0\": 4.6,\n            \"Kdprime_0\": -1.5e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 420.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgAl2O4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"macf\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2246420.0,\n            \"S_0\": 80.0,\n            \"V_0\": 3.614e-05,\n            \"Cp\": [200.0, 0.006252, -2996400.0, -888.4],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 2.12e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1080.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mscf\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2061130.0,\n            \"S_0\": 87.5,\n            \"V_0\": 3.649e-05,\n            \"Cp\": [213.3, 0.00269, -1410400.0, -1495.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 1.85e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 1340.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Fe2SiO4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fscf\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1405500.0,\n            \"S_0\": 143.4,\n            \"V_0\": 3.914e-05,\n            \"Cp\": [181.1, 0.018526, -2767200.0, -527.1],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 1.85e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 10240.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"NaAlSiO6\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"nacf\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1965550.0,\n            \"S_0\": 110.0,\n            \"V_0\": 3.631e-05,\n            \"Cp\": [272.7, -0.012398, 0.0, -2763.1],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 1.85e11,\n            \"Kprime_0\": 4.6,\n            \"Kdprime_0\": -2.5e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 3440.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaAl2O4\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"cacf\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -2325600.0,\n            \"S_0\": 87.6,\n            \"V_0\": 3.976e-05,\n            \"Cp\": [191.9, 0.009563, -3211300.0, -640.2],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 1.9e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.1e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 10240.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Mg3Al6O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"manal\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6796630.0,\n            \"S_0\": 250.0,\n            \"V_0\": 0.00011166,\n            \"Cp\": [600.0, 0.018756, -8989200.0, -2665.2],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 1.84e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 5120.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"NaMg2SiAl5O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"nanal\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6610270.0,\n            \"S_0\": 280.0,\n            \"V_0\": 0.00011322,\n            \"Cp\": [672.7, 0.000106, -5992800.0, -4539.9],\n            \"a_0\": 2.01e-05,\n            \"K_0\": 1.84e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 5120.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgMg2Si3Mg3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"msnal\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6172380.0,\n            \"S_0\": 272.5,\n            \"V_0\": 0.00011061,\n            \"Cp\": [639.9, 0.00807, -4231200.0, -4487.7],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 1.85e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 5120.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeFe2Si3Fe3O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fsnal\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -4146000.0,\n            \"S_0\": 440.2,\n            \"V_0\": 0.00011856,\n            \"Cp\": [543.3, 0.055578, -8301600.0, -1581.3],\n            \"a_0\": 2.1e-05,\n            \"K_0\": 1.85e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 10240.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"CaMg2Al6O12\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"canal\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -6840000.0,\n            \"S_0\": 257.6,\n            \"V_0\": 0.00011159,\n            \"Cp\": [591.9, 0.022067, -9204100.0, -2417.0],\n            \"a_0\": 1.93e-05,\n            \"K_0\": 1.77e11,\n            \"Kprime_0\": 4.0,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 5120.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"per\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -601570.0,\n            \"S_0\": 26.5,\n            \"V_0\": 1.125e-05,\n            \"Cp\": [60.5, 0.000362, -535800.0, -299.2],\n            \"a_0\": 3.11e-05,\n            \"K_0\": 1.616e11,\n            \"Kprime_0\": 3.95,\n            \"Kdprime_0\": -2.4e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 260.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"FeO\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"fper\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -262240.0,\n            \"S_0\": 58.6,\n            \"V_0\": 1.206e-05,\n            \"Cp\": [44.4, 0.00828, -1214200.0, 185.2],\n            \"a_0\": 3.22e-05,\n            \"K_0\": 1.52e11,\n            \"Kprime_0\": 4.9,\n            \"Kdprime_0\": -3.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 680.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"Al2O3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"cor\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1675250.0,\n            \"S_0\": 50.9,\n            \"V_0\": 2.558e-05,\n            \"Cp\": [139.5, 0.00589, -2460600.0, -589.2],\n            \"a_0\": 1.8e-05,\n            \"K_0\": 2.54e11,\n            \"Kprime_0\": 4.34,\n            \"Kdprime_0\": -1.7e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 700.0}\n        Mineral.__init__(self)",
  "def __init__(self):\n        formula = \"MgSiO3\"\n        formula = dictionarize_formula(formula)\n        self.params = {\n            \"name\": \"mcor\",\n            \"formula\": formula,\n            \"equation_of_state\": \"hp_tmt\",\n            \"H_0\": -1468000.0,\n            \"S_0\": 59.3,\n            \"V_0\": 2.635e-05,\n            \"Cp\": [147.8, 0.002015, -2395000.0, -801.8],\n            \"a_0\": 2.12e-05,\n            \"K_0\": 2.11e11,\n            \"Kprime_0\": 4.55,\n            \"Kdprime_0\": -2.2e-11,\n            \"n\": sum(formula.values()),\n            \"molar_mass\": formula_mass(formula),\n        }\n\n        self.uncertainties = {\"err_H_0\": 880.0}\n        Mineral.__init__(self)",
  "class stishovite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 14.02e-6,\n            \"K_0\": 314.0e9,\n            \"Kprime_0\": 3.8,\n            \"G_0\": 220.0e9,\n            \"Gprime_0\": 1.9,\n            \"molar_mass\": 0.0601,\n            \"n\": 3,\n            \"Debye_0\": 1108.0,\n            \"grueneisen_0\": 1.37,\n            \"q_0\": 2.8,\n            \"eta_s_0\": 4.6,\n        }\n\n        self.uncertainties = {\n            \"err_K_0\": 8.0e9,\n            \"err_Kprime_0\": 0.1,\n            \"err_G_0\": 12.0e9,\n            \"err_Gprime_0\": 0.1,\n            \"err_Debye_0\": 13.0,\n            \"err_grueneisen_0\": 0.17,\n            \"err_q_0\": 2.2,\n            \"err_eta_s_0\": 1.0,\n        }\n\n        Mineral.__init__(self)",
  "class periclase(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 11.24e-6,\n            \"K_0\": 161.0e9,\n            \"Kprime_0\": 3.8,\n            \"G_0\": 131.0e9,\n            \"Gprime_0\": 2.1,\n            \"molar_mass\": 0.0403,\n            \"n\": 2,\n            \"Debye_0\": 767.0,\n            \"grueneisen_0\": 1.36,\n            \"q_0\": 1.7,  # 1.7\n            \"eta_s_0\": 2.8,\n        }  # 2.8\n\n        self.uncertainties = {\n            \"err_K_0\": 3.0e9,\n            \"err_Kprime_0\": 0.2,\n            \"err_G_0\": 1.0e9,\n            \"err_Gprime_0\": 0.1,\n            \"err_Debye_0\": 9.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.2,\n            \"err_eta_s_0\": 0.2,\n        }\n\n        Mineral.__init__(self)",
  "class wuestite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 12.26e-6,\n            \"K_0\": 179.0e9,\n            \"Kprime_0\": 4.9,\n            \"G_0\": 59.0e9,\n            \"Gprime_0\": 1.4,\n            \"molar_mass\": 0.0718,\n            \"n\": 2,\n            \"Debye_0\": 454.0,\n            \"grueneisen_0\": 1.53,\n            \"q_0\": 1.7,  # 1.7\n            \"eta_s_0\": -0.1,\n        }\n\n        self.uncertainties = {\n            \"err_K_0\": 1.0e9,\n            \"err_Kprime_0\": 0.2,\n            \"err_G_0\": 1.0e9,\n            \"err_Gprime_0\": 0.1,\n            \"err_Debye_0\": 21.0,\n            \"err_grueneisen_0\": 0.13,\n            \"err_q_0\": 1.0,\n            \"err_eta_s_0\": 1.0,\n        }\n\n        Mineral.__init__(self)",
  "class mg_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 24.45e-6,\n            \"K_0\": 250.5e9,\n            \"Kprime_0\": 4.01,\n            \"G_0\": 172.9e9,\n            \"Gprime_0\": 1.74,\n            \"molar_mass\": 0.1000,\n            \"n\": 5,\n            \"Debye_0\": 905.9,\n            \"grueneisen_0\": 1.44,\n            \"q_0\": 1.09,\n            \"eta_s_0\": 2.13,\n        }  # 2.6\n\n        self.uncertainties = {\n            \"err_K_0\": 3.0e9,\n            \"err_Kprime_0\": 0.1,\n            \"err_G_0\": 2.0e9,\n            \"err_Gprime_0\": 0.0,\n            \"err_Debye_0\": 5.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.3,\n            \"err_eta_s_0\": 0.3,\n        }\n\n        Mineral.__init__(self)",
  "class fe_perovskite(Mineral):\n    def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 25.49e-6,\n            \"K_0\": 272.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 133.0e9,\n            \"Gprime_0\": 1.4,\n            \"molar_mass\": 0.1319,\n            \"n\": 5,\n            \"Debye_0\": 871.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"eta_s_0\": 2.3,\n        }  # 2.3\n\n        self.uncertainties = {\n            \"err_K_0\": 40e9,\n            \"err_Kprime_0\": 1.0,\n            \"err_G_0\": 40e9,\n            \"err_Gprime_0\": 0.0,\n            \"err_Debye_0\": 26.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_eta_s_0\": 1.0,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 14.02e-6,\n            \"K_0\": 314.0e9,\n            \"Kprime_0\": 3.8,\n            \"G_0\": 220.0e9,\n            \"Gprime_0\": 1.9,\n            \"molar_mass\": 0.0601,\n            \"n\": 3,\n            \"Debye_0\": 1108.0,\n            \"grueneisen_0\": 1.37,\n            \"q_0\": 2.8,\n            \"eta_s_0\": 4.6,\n        }\n\n        self.uncertainties = {\n            \"err_K_0\": 8.0e9,\n            \"err_Kprime_0\": 0.1,\n            \"err_G_0\": 12.0e9,\n            \"err_Gprime_0\": 0.1,\n            \"err_Debye_0\": 13.0,\n            \"err_grueneisen_0\": 0.17,\n            \"err_q_0\": 2.2,\n            \"err_eta_s_0\": 1.0,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 11.24e-6,\n            \"K_0\": 161.0e9,\n            \"Kprime_0\": 3.8,\n            \"G_0\": 131.0e9,\n            \"Gprime_0\": 2.1,\n            \"molar_mass\": 0.0403,\n            \"n\": 2,\n            \"Debye_0\": 767.0,\n            \"grueneisen_0\": 1.36,\n            \"q_0\": 1.7,  # 1.7\n            \"eta_s_0\": 2.8,\n        }  # 2.8\n\n        self.uncertainties = {\n            \"err_K_0\": 3.0e9,\n            \"err_Kprime_0\": 0.2,\n            \"err_G_0\": 1.0e9,\n            \"err_Gprime_0\": 0.1,\n            \"err_Debye_0\": 9.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.2,\n            \"err_eta_s_0\": 0.2,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 12.26e-6,\n            \"K_0\": 179.0e9,\n            \"Kprime_0\": 4.9,\n            \"G_0\": 59.0e9,\n            \"Gprime_0\": 1.4,\n            \"molar_mass\": 0.0718,\n            \"n\": 2,\n            \"Debye_0\": 454.0,\n            \"grueneisen_0\": 1.53,\n            \"q_0\": 1.7,  # 1.7\n            \"eta_s_0\": -0.1,\n        }\n\n        self.uncertainties = {\n            \"err_K_0\": 1.0e9,\n            \"err_Kprime_0\": 0.2,\n            \"err_G_0\": 1.0e9,\n            \"err_Gprime_0\": 0.1,\n            \"err_Debye_0\": 21.0,\n            \"err_grueneisen_0\": 0.13,\n            \"err_q_0\": 1.0,\n            \"err_eta_s_0\": 1.0,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 24.45e-6,\n            \"K_0\": 250.5e9,\n            \"Kprime_0\": 4.01,\n            \"G_0\": 172.9e9,\n            \"Gprime_0\": 1.74,\n            \"molar_mass\": 0.1000,\n            \"n\": 5,\n            \"Debye_0\": 905.9,\n            \"grueneisen_0\": 1.44,\n            \"q_0\": 1.09,\n            \"eta_s_0\": 2.13,\n        }  # 2.6\n\n        self.uncertainties = {\n            \"err_K_0\": 3.0e9,\n            \"err_Kprime_0\": 0.1,\n            \"err_G_0\": 2.0e9,\n            \"err_Gprime_0\": 0.0,\n            \"err_Debye_0\": 5.0,\n            \"err_grueneisen_0\": 0.05,\n            \"err_q_0\": 0.3,\n            \"err_eta_s_0\": 0.3,\n        }\n\n        Mineral.__init__(self)",
  "def __init__(self):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 25.49e-6,\n            \"K_0\": 272.0e9,\n            \"Kprime_0\": 4.1,\n            \"G_0\": 133.0e9,\n            \"Gprime_0\": 1.4,\n            \"molar_mass\": 0.1319,\n            \"n\": 5,\n            \"Debye_0\": 871.0,\n            \"grueneisen_0\": 1.57,\n            \"q_0\": 1.1,\n            \"eta_s_0\": 2.3,\n        }  # 2.3\n\n        self.uncertainties = {\n            \"err_K_0\": 40e9,\n            \"err_Kprime_0\": 1.0,\n            \"err_G_0\": 40e9,\n            \"err_Gprime_0\": 0.0,\n            \"err_Debye_0\": 26.0,\n            \"err_grueneisen_0\": 0.3,\n            \"err_q_0\": 1.0,\n            \"err_eta_s_0\": 1.0,\n        }\n\n        Mineral.__init__(self)",
  "def voigt_index_to_ij(m):\n    \"\"\"\n    Returns the ij (or kl) indices of the\n    stiffness tensor which correspond to those\n    of the Voigt notation m (or n).\n    \"\"\"\n    if m == 3:\n        return 1, 2\n    elif m == 4:\n        return 0, 2\n    elif m == 5:\n        return 0, 1\n    else:\n        return m, m",
  "def voigt_notation_to_stiffness_tensor(voigt_notation):\n    \"\"\"\n    Converts a stiffness tensor in Voigt notation (6x6 matrix)\n    to the full fourth rank tensor (3x3x3x3 matrix).\n    \"\"\"\n    stiffness_tensor = np.zeros([3, 3, 3, 3])\n    for m in range(6):\n        i, j = voigt_index_to_ij(m)\n        for n in range(6):\n            k, l = voigt_index_to_ij(n)\n            stiffness_tensor[i][j][k][l] = voigt_notation[m][n]\n            stiffness_tensor[j][i][k][l] = voigt_notation[m][n]\n            stiffness_tensor[i][j][l][k] = voigt_notation[m][n]\n            stiffness_tensor[j][i][l][k] = voigt_notation[m][n]\n    return stiffness_tensor",
  "def voigt_notation_to_compliance_tensor(voigt_notation):\n    return voigt_notation_to_stiffness_tensor(\n        np.divide(voigt_notation, voigt_compliance_factors)\n    )",
  "def contract_stresses(stresses):\n    \"\"\"\n    Takes a stress tensor in standard (3x3) form\n    and returns the Voigt form (6). No factors\n    are required to maintain the relationship\n    with the corresponding stiffness and strain tensors\n    (see contract_strains, which does require\n    multiplicative factors).\n    \"\"\"\n    return stresses[[0, 1, 2, 1, 0, 0], [0, 1, 2, 2, 2, 1]]",
  "def expand_stresses(stresses):\n    \"\"\"\n    Takes a stress tensor in Voigt form (6)\n    and returns the standard form (3x3). No factors\n    are required to maintain the relationship\n    with the corresponding stiffness and strain tensors\n    (see contract_strains, which does require\n    multiplicative factors).\n    \"\"\"\n    return np.array(\n        [\n            [stresses[0], stresses[5], stresses[4]],\n            [stresses[5], stresses[1], stresses[3]],\n            [stresses[4], stresses[3], stresses[2]],\n        ]\n    )",
  "def contract_strains(strains):\n    \"\"\"\n    Takes a stress tensor in standard (3x3) form\n    and returns the Voigt form (6). Note the factors\n    which are required to maintain the relationship\n    with the corresponding stiffness and strain tensors.\n    \"\"\"\n    # next line creates a copy, not just a view.\n    eps = strains[[0, 1, 2, 1, 0, 0], [0, 1, 2, 2, 2, 1]]\n    # only overwrites values in eps, not the input array\n    eps[3:] *= 2.0\n    return eps",
  "def contract_compliances(compliances):\n    \"\"\"\n    Takes a compliance tensor in standard (3x3x3x3) form\n    and returns the Voigt form (6x6). Note the compliance factors\n    which are required to maintain the inverse relationship with the\n    corresponding stiffness tensor.\n    \"\"\"\n    voigt_notation = np.zeros((6, 6))\n    for p in range(6):\n        i, j = voigt_index_to_ij(p)\n        for q in range(6):\n            m, n = voigt_index_to_ij(q)\n            voigt_notation[p, q] = compliances[i, j, m, n]\n    return np.multiply(voigt_notation, voigt_compliance_factors)",
  "def contract_stiffnesses(stiffnesses):\n    \"\"\"\n    Takes a stiffness tensor in standard (3x3x3x3) form\n    and returns the Voigt form (6x6).\n    \"\"\"\n    voigt_notation = np.zeros((6, 6))\n    for p in range(6):\n        i, j = voigt_index_to_ij(p)\n        for q in range(6):\n            m, n = voigt_index_to_ij(q)\n            voigt_notation[p, q] = stiffnesses[i, j, m, n]\n    return voigt_notation",
  "def voigt_array_from_cijs(cijs, index_lists):\n    \"\"\"\n    Takes a list of cijs and a list of list of tuples corresponding to\n    the positions of each cij in the Voigt form matrix.\n    Note that the indices run from 0--5, not 1--6.\n    \"\"\"\n    C = np.zeros([6, 6])\n    for i, index_list in enumerate(index_lists):\n        for indices in index_list:\n            C[indices] = cijs[i]\n            C[indices[::-1]] = cijs[i]\n    return C",
  "def _iszero(x):\n    \"\"\"Returns True if x is zero.\"\"\"\n    return getattr(x, \"is_zero\", None)",
  "def _find_reasonable_pivot(col, iszerofunc=_iszero, simpfunc=_simplify):\n    \"\"\"\n    Find the lowest index of an item in ``col`` that is\n    suitable for a pivot.  If ``col`` consists only of\n    Floats, the pivot with the largest norm is returned.\n    Otherwise, the first element where ``iszerofunc`` returns\n    False is used.  If ``iszerofunc`` doesn't return false,\n    items are simplified and retested until a suitable\n    pivot is found.\n\n    Returns a 4-tuple\n        (pivot_offset, pivot_val, assumed_nonzero, newly_determined)\n    where pivot_offset is the index of the pivot, pivot_val is\n    the (possibly simplified) value of the pivot, assumed_nonzero\n    is True if an assumption that the pivot was non-zero\n    was made without being proved, and newly_determined are\n    elements that were simplified during the process of pivot\n    finding.\"\"\"\n\n    newly_determined = []\n    col = list(col)\n    # a column that contains a mix of floats and integers\n    # but at least one float is considered a numerical\n    # column, and so we do partial pivoting\n    if all(isinstance(x, (Float, Integer)) for x in col) and any(\n        isinstance(x, Float) for x in col\n    ):\n        col_abs = [abs(x) for x in col]\n        max_value = max(col_abs)\n        if iszerofunc(max_value):\n            # just because iszerofunc returned True, doesn't\n            # mean the value is numerically zero.  Make sure\n            # to replace all entries with numerical zeros\n            if max_value != 0:\n                newly_determined = [(i, 0) for i, x in enumerate(col) if x != 0]\n            return (None, None, False, newly_determined)\n        index = col_abs.index(max_value)\n        return (index, col[index], False, newly_determined)\n\n    # PASS 1 (iszerofunc directly)\n    possible_zeros = []\n    for i, x in enumerate(col):\n        is_zero = iszerofunc(x)\n        # is someone wrote a custom iszerofunc, it may return\n        # BooleanFalse or BooleanTrue instead of True or False,\n        # so use == for comparison instead of `is`\n        if is_zero is False:\n            # we found something that is definitely not zero\n            return (i, x, False, newly_determined)\n        possible_zeros.append(is_zero)\n\n    # by this point, we've found no certain non-zeros\n    if all(possible_zeros):\n        # if everything is definitely zero, we have\n        # no pivot\n        return (None, None, False, newly_determined)\n\n    # PASS 2 (iszerofunc after simplify)\n    # we haven't found any for-sure non-zeros, so\n    # go through the elements iszerofunc couldn't\n    # make a determination about and opportunistically\n    # simplify to see if we find something\n    for i, x in enumerate(col):\n        if possible_zeros[i] is not None:\n            continue\n        simped = simpfunc(x)\n        is_zero = iszerofunc(simped)\n        if is_zero is True or is_zero is False:\n            newly_determined.append((i, simped))\n        if is_zero is False:\n            return (i, simped, False, newly_determined)\n        possible_zeros[i] = is_zero\n\n    # after simplifying, some things that were recognized\n    # as zeros might be zeros\n    if all(possible_zeros):\n        # if everything is definitely zero, we have\n        # no pivot\n        return (None, None, False, newly_determined)\n\n    # PASS 3 (.equals(0))\n    # some expressions fail to simplify to zero, but\n    # ``.equals(0)`` evaluates to True.  As a last-ditch\n    # attempt, apply ``.equals`` to these expressions\n    for i, x in enumerate(col):\n        if possible_zeros[i] is not None:\n            continue\n        if x.equals(S.Zero):\n            # ``.iszero`` may return False with\n            # an implicit assumption (e.g., ``x.equals(0)``\n            # when ``x`` is a symbol), so only treat it\n            # as proved when ``.equals(0)`` returns True\n            possible_zeros[i] = True\n            newly_determined.append((i, S.Zero))\n\n    if all(possible_zeros):\n        return (None, None, False, newly_determined)\n\n    # at this point there is nothing that could definitely\n    # be a pivot.  To maintain compatibility with existing\n    # behavior, we'll assume that an illdetermined thing is\n    # non-zero.  We should probably raise a warning in this case\n    i = possible_zeros.index(None)\n    return (i, col[i], True, newly_determined)",
  "def _row_reduce_list(\n    mat,\n    rows,\n    cols,\n    iszerofunc,\n    simpfunc,\n    normalize_last=True,\n    normalize=True,\n    zero_above=True,\n):\n    \"\"\"\n    Row reduce a flat list representation of a matrix and return a tuple\n    (rref_matrix, pivot_cols, swaps) where ``rref_matrix`` is a flat list,\n    ``pivot_cols`` are the pivot columns and ``swaps`` are any row swaps that\n    were used in the process of row reduction.\n\n    :param mat: list of matrix elements, must be ``rows`` * ``cols`` in length.\n    :type mat: list\n\n    :param rows: number of rows in flat list representation.\n    :type rows: integer\n\n    :param cols: number of columns in flat list representation.\n    :type cols: integer\n\n    :param iszerofunc: determines if an entry can be used as a pivot.\n    :type iszerofunc: function\n\n    :param simpfunc: used to simplify elements and test if they are\n        zero if ``iszerofunc`` returns `None`.\n    :type simpfunc: function\n\n    :param normalize_last: indicates where all row reduction should\n        happen in a fraction-free manner and then the rows are\n        normalized (so that the pivots are 1), or whether\n        rows should be normalized along the way (like the naive\n        row reduction algorithm).\n    :type normalize_last: bool\n\n    :param normalize: whether pivot rows should be normalized so that\n        the pivot value is 1\n    :type normalize: bool\n\n    :param zero_above: whether entries above the pivot should be zeroed.\n        If ``zero_above=False``, an echelon matrix will be returned.\n    :type zero_above: bool\n    \"\"\"\n\n    def get_col(i):\n        return mat[i::cols]\n\n    def row_swap(i, j):\n        mat[i * cols : (i + 1) * cols], mat[j * cols : (j + 1) * cols] = (\n            mat[j * cols : (j + 1) * cols],\n            mat[i * cols : (i + 1) * cols],\n        )\n\n    def cross_cancel(a, i, b, j):\n        \"\"\"Does the row op row[i] = a*row[i] - b*row[j]\"\"\"\n        q = (j - i) * cols\n        for p in range(i * cols, (i + 1) * cols):\n            mat[p] = isimp(a * mat[p] - b * mat[p + q])\n\n    def isimp(x):\n        return x\n\n    piv_row, piv_col = 0, 0\n    pivot_cols = []\n    swaps = []\n\n    # use a fraction free method to zero above and below each pivot\n    while piv_col < cols and piv_row < rows:\n        (\n            pivot_offset,\n            pivot_val,\n            assumed_nonzero,\n            newly_determined,\n        ) = _find_reasonable_pivot(get_col(piv_col)[piv_row:], iszerofunc, simpfunc)\n\n        # _find_reasonable_pivot may have simplified some things\n        # in the process.  Let's not let them go to waste\n        for offset, val in newly_determined:\n            offset += piv_row\n            mat[offset * cols + piv_col] = val\n\n        if pivot_offset is None:\n            piv_col += 1\n            continue\n\n        pivot_cols.append(piv_col)\n        if pivot_offset != 0:\n            row_swap(piv_row, pivot_offset + piv_row)\n            swaps.append((piv_row, pivot_offset + piv_row))\n\n        # if we aren't normalizing last, we normalize\n        # before we zero the other rows\n        if normalize_last is False:\n            i, j = piv_row, piv_col\n            mat[i * cols + j] = S.One\n            for p in range(i * cols + j + 1, (i + 1) * cols):\n                mat[p] = isimp(mat[p] / pivot_val)\n            # after normalizing, the pivot value is 1\n            pivot_val = S.One\n\n        # zero above and below the pivot\n        for row in range(rows):\n            # don't zero our current row\n            if row == piv_row:\n                continue\n            # don't zero above the pivot unless we're told.\n            if zero_above is False and row < piv_row:\n                continue\n            # if we're already a zero, don't do anything\n            val = mat[row * cols + piv_col]\n            if iszerofunc(val):\n                continue\n\n            cross_cancel(pivot_val, row, val, piv_row)\n        piv_row += 1\n\n    # normalize each row\n    if normalize_last is True and normalize is True:\n        for piv_i, piv_j in enumerate(pivot_cols):\n            pivot_val = mat[piv_i * cols + piv_j]\n            mat[piv_i * cols + piv_j] = S.One\n            for p in range(piv_i * cols + piv_j + 1, (piv_i + 1) * cols):\n                mat[p] = isimp(mat[p] / pivot_val)\n\n    return mat, tuple(pivot_cols), tuple(swaps)",
  "def row_reduce(\n    M,\n    iszerofunc=lambda x: x.is_zero,\n    simpfunc=lambda x: Rational(x).limit_denominator(1000),\n    normalize_last=True,\n    normalize=True,\n    zero_above=True,\n):\n    mat, pivot_cols, swaps = _row_reduce_list(\n        list(M),\n        M.rows,\n        M.cols,\n        iszerofunc,\n        simpfunc,\n        normalize_last=normalize_last,\n        normalize=normalize,\n        zero_above=zero_above,\n    )\n\n    return M._new(M.rows, M.cols, mat), pivot_cols, swaps",
  "def independent_row_indices(\n    m,\n    iszerofunc=lambda x: x.is_zero,\n    simpfunc=lambda x: Rational(x).limit_denominator(1000),\n):\n    _, pivots, swaps = row_reduce(m, iszerofunc, simpfunc)\n    indices = np.array(range(len(m)))\n    for swap in np.array(swaps):\n        indices[swap] = indices[swap[::-1]]\n    return indices[: len(pivots)]",
  "def get_col(i):\n        return mat[i::cols]",
  "def row_swap(i, j):\n        mat[i * cols : (i + 1) * cols], mat[j * cols : (j + 1) * cols] = (\n            mat[j * cols : (j + 1) * cols],\n            mat[i * cols : (i + 1) * cols],\n        )",
  "def cross_cancel(a, i, b, j):\n        \"\"\"Does the row op row[i] = a*row[i] - b*row[j]\"\"\"\n        q = (j - i) * cols\n        for p in range(i * cols, (i + 1) * cols):\n            mat[p] = isimp(a * mat[p] - b * mat[p + q])",
  "def isimp(x):\n        return x",
  "def brown_shankland(depths):\n    \"\"\"\n    Geotherm from :cite:`Brown1981`. NOTE: Valid only above 270 km\n\n    :param depths: The list of depths at which to evaluate the geotherm.\n        :math:`[m]`\n    :type depths: list of floats\n\n    :returns: The list of temperatures for each of the pressures. :math:`[K]`\n    :rtype: list of floats\n    \"\"\"\n\n    assert min(depths) >= min(table_brown_depth)\n    assert max(depths) <= max(table_brown_depth)\n    temperature = np.empty_like(depths)\n    for i, depth in enumerate(depths):\n        temperature[i] = lookup_and_interpolate(\n            table_brown_depth, table_brown_temperature, depth\n        )\n    return temperature",
  "def anderson(depths):\n    \"\"\"\n    Geotherm from :cite:`anderson1982earth`.\n\n    :param depths: The list of depths at which to evaluate the geotherm.\n        :math:`[m]`\n    :type depths: list of floats\n\n    :returns: The list of temperatures for each of the pressures. :math:`[K]`\n    :rtype: list of floats\n    \"\"\"\n    assert min(depths) >= min(table_anderson_depth)\n    assert max(depths) <= max(table_anderson_depth)\n    temperature = np.empty_like(depths)\n    for i, depth in enumerate(depths):\n        temperature[i] = lookup_and_interpolate(\n            table_anderson_depth, table_anderson_temperature, depth\n        )\n    return temperature",
  "def stacey_continental(depths):\n    \"\"\"\n    Continental geotherm from :cite:`stacey1977`.\n\n    :param depths: The list of depths at which to evaluate the geotherm.\n        :math:`[m]`\n    :type depths: list of floats\n\n    :returns: The list of temperatures for each of the pressures. :math:`[K]`\n    :rtype: list of floats\n    \"\"\"\n    assert min(depths) >= min(table_stacey_c_depth)\n    assert max(depths) <= max(table_stacey_c_depth)\n    temperature = np.empty_like(depths)\n    for i, depth in enumerate(depths):\n        temperature[i] = lookup_and_interpolate(\n            table_stacey_c_depth, table_stacey_c_temperature, depth\n        )\n    return temperature",
  "def stacey_oceanic(depths):\n    \"\"\"\n    Oceanic geotherm from :cite:`stacey1977`.\n\n    :param depths: The list of depths at which to evaluate the geotherm.\n        :math:`[m]`\n    :type depths: list of floats\n\n    :returns: The list of temperatures for each of the pressures. :math:`[K]`\n    :rtype: list of floats\n    \"\"\"\n    assert min(depths) >= min(table_stacey_o_depth)\n    assert max(depths) <= max(table_stacey_o_depth)\n    temperature = np.empty_like(depths)\n    for i, depth in enumerate(depths):\n        temperature[i] = lookup_and_interpolate(\n            table_stacey_o_depth, table_stacey_o_temperature, depth\n        )\n    return temperature",
  "def adiabatic(pressures, T0, rock):\n    \"\"\"\n    This calculates a geotherm based on an anchor temperature and a rock,\n    assuming that the rock's temperature follows an adiabatic gradient with\n    pressure. A good first guess is provided by integrating:\n\n    .. math::\n        \\\\frac{\\partial T}{\\partial P} = \\\\frac{ \\\\gamma  T}{ K_s }\n\n    where :math:`\\\\gamma` is the Grueneisen parameter and :math:`K_s` is\n    the adiabatic bulk modulus.\n\n    :param pressures: The list of pressures in :math:`[Pa]` at which\n        to evaluate the geotherm.\n    :type pressures: list of floats\n\n    :param T0: An anchor temperature, corresponding to the temperature of the first\n        pressure in the list. :math:`[K]`\n    :type T0: float\n\n    :param rock: Composite for which we compute the adiabat.  From this material we\n        must compute average Grueneisen parameters and adiabatic bulk moduli\n        for each pressure/temperature.\n    :type rock: :class:`burnman.composite`\n\n    :returns: The list of temperatures for each pressure. :math:`[K]`\n    :rtype: numpy.array of floats\n    \"\"\"\n\n    rock.set_state(pressures[0], T0)\n    S0 = rock.S\n\n    delta_S = lambda T, P, rock, S0: S0 - rock.evaluate([\"S\"], [P], [T])[0]\n\n    temperatures = np.empty_like(pressures)\n    temperatures[0] = T0\n    for i in range(1, len(pressures)):\n        args = (pressures[i], rock, S0)\n        sol = bracket(\n            fn=delta_S,\n            x0=(\n                temperatures[i - 1]\n                + (rock.gr * temperatures[i - 1] / rock.K_S)\n                * (pressures[i] - pressures[i - 1])\n            ),\n            dx=1.0,\n            args=args,\n        )\n        temperatures[i] = brentq(delta_S, sol[0], sol[1], args=args)\n\n    return temperatures",
  "class OrderedCounter(Counter, OrderedDict):\n    \"\"\"\n    Counter that remembers the order elements are first encountered\n    \"\"\"\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, OrderedDict(self))\n\n    def __reduce__(self):\n        return self.__class__, (OrderedDict(self),)",
  "def copy_documentation(copy_from):\n    \"\"\"\n    Decorator @copy_documentation(another_function) will copy the documentation found in a different\n    function (for example from a base class). The docstring applied to some function a() will be ::\n\n        (copied from BaseClass.some_function):\n        <documentation from BaseClass.some_function>\n        <optionally the documentation found in a()>\n\n    \"\"\"\n\n    def mydecorator(func):\n        def wrapper(*args):\n            return func(*args)\n\n        old = \"\"\n        if func.__doc__:\n            old = \"\\n\" + func.__doc__\n\n        copied_from = \"\"\n        if hasattr(copy_from, \"__name__\"):\n            copied_from = \"(copied from \" + copy_from.__name__ + \"):\\n\"\n        wrapper.__doc__ = copied_from + copy_from.__doc__ + old\n        wrapper.__name__ = func.__name__\n        return wrapper\n\n    return mydecorator",
  "def merge_two_dicts(x, y):\n    \"\"\"Given two dicts, merge them into a new dict as a shallow copy.\"\"\"\n    z = x.copy()\n    z.update(y)\n    return z",
  "def flatten(arr):\n    return (\n        flatten(arr[0]) + (flatten(arr[1:]) if len(arr) > 1 else [])\n        if type(arr) is list or type(arr) is np.ndarray\n        else [arr]\n    )",
  "def pretty_print_values(popt, pcov, params):\n    \"\"\"\n    Takes a numpy array of parameters, the corresponding covariance matrix\n    and a set of parameter names and prints the parameters and\n    principal 1-s.d.uncertainties (np.sqrt(pcov[i][i]))\n    in a nice text based format.\n    \"\"\"\n    for i, p in enumerate(params):\n        p_rnd = round_to_n(popt[i], np.sqrt(pcov[i][i]), 1)\n        c_rnd = round_to_n(np.sqrt(pcov[i][i]), np.sqrt(pcov[i][i]), 1)\n\n        if p_rnd != 0.0:\n            p_expnt = np.floor(np.log10(np.abs(p_rnd)))\n        else:\n            p_expnt = 0.0\n\n        scale = np.power(10.0, p_expnt)\n        nd = p_expnt - np.floor(np.log10(np.abs(c_rnd)))\n        print(\n            \"{0:s}: ({1:{4}{5}f} +/- {2:{4}{5}f}) x {3:.0e}\".format(\n                p, p_rnd / scale, c_rnd / scale, scale, 0, (nd) / 10.0\n            )\n        )",
  "def pretty_print_table(table, use_tabs=False):\n    \"\"\"\n    Takes a 2d table and prints it in a nice text based format. If\n    use_tabs=True then only \\t is used as a separator. This is useful for\n    importing the data into other apps (Excel, ...). The default is to pad\n    the columns with spaces to make them look neat. The first column is\n    left aligned, while the remainder is right aligned.\n    \"\"\"\n    if use_tabs:\n        for r in table:\n            print(\"\\t\".join(r).replace(\"_\", \"\\_\"))\n        return\n\n    def col_width(table, colidx):\n        return max([len(str(row[colidx])) for row in table])\n\n    # create a format string with the first column left aligned, the others right\n    # example:   {:<27}{:>11}{:>6}{:>8}\n    frmt = \"\".join(\n        [\n            (\"{:<\" if i == 0 else \"{:>\") + str(1 + col_width(table, i)) + \"}\"\n            for i in range(len(table[0]))\n        ]\n    )\n    for r in table:\n        print(frmt.format(*r))",
  "def sort_table(table, col=0):\n    \"\"\"\n    Sort the table according to the column number\n    \"\"\"\n    return sorted(table, key=operator.itemgetter(col))",
  "def read_table(filename):\n    datastream = pkgutil.get_data(\"burnman\", \"data/\" + filename)\n    datalines = [\n        line.strip() for line in datastream.decode(\"ascii\").split(\"\\n\") if line.strip()\n    ]\n    table = []\n\n    for line in datalines:\n        if line[0] != \"#\":\n            numbers = np.fromstring(line, sep=\" \")\n            table.append(numbers)\n    return np.array(table)",
  "def array_from_file(filename):\n    \"\"\"\n    Generic function to read a file containing floats and commented lines\n    into a 2D numpy array.\n\n    Commented lines are prefixed by the characters # or %.\n    \"\"\"\n    f = open(filename, \"r\")\n    data = []\n    datastream = f.read()\n    f.close()\n    datalines = [\n        line.strip().split() for line in datastream.split(\"\\n\") if line.strip()\n    ]\n    for line in datalines:\n        if line[0] != \"#\" and line[0] != \"%\":\n            data.append(map(float, line))\n\n    data = np.array(zip(*data))\n    return data",
  "def cut_table(table, min_value, max_value):\n    tablen = []\n    for i in range(min_value, max_value, 1):\n        tablen.append(table[i, :])\n    return tablen",
  "def lookup_and_interpolate(table_x, table_y, x_value):\n    idx = bisect.bisect_left(table_x, x_value) - 1\n    if idx < 0:\n        return table_y[0]\n    elif idx < len(table_x) - 1:\n        return linear_interpol(\n            x_value, table_x[idx], table_x[idx + 1], table_y[idx], table_y[idx + 1]\n        )\n    else:\n        return table_y[idx]",
  "def attribute_function(m, attributes, powers=[]):\n    \"\"\"\n    Function which returns a function which can be used to\n    evaluate material properties at a point. This function\n    allows the user to define the property returned\n    as a string. The function can itself be passed to another\n    function\n    (such as nonlinear_fitting.confidence_prediction_bands()).\n\n    Properties can either be simple attributes (e.g. K_T) or\n    a product of attributes, each raised to some power.\n\n    :param m: The material instance evaluated by the output function.\n    :type m: :class:`burnman.Material`\n\n    :param attributes: The list of material attributes / properties to\n        be evaluated in the product.\n    :type attributes: list of str\n\n    :param powers: The powers to which each attribute should be raised\n        during evaluation.\n    :type powers: list of floats\n\n    :returns: Function which returns the value of product(a_i**p_i)\n        as a function of condition (x = [P, T, V]).\n    :rtype: function\n    \"\"\"\n    if type(attributes) is str:\n        attributes = [attributes]\n    if powers == []:\n        powers = [1.0 for a in attributes]\n\n    def f(x):\n        P, T, V = x\n        m.set_state(P, T)\n        value = 1.0\n        for a, p in zip(*[attributes, powers]):\n            value *= np.power(getattr(m, a), p)\n        return value\n\n    return f",
  "def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, OrderedDict(self))",
  "def __reduce__(self):\n        return self.__class__, (OrderedDict(self),)",
  "def mydecorator(func):\n        def wrapper(*args):\n            return func(*args)\n\n        old = \"\"\n        if func.__doc__:\n            old = \"\\n\" + func.__doc__\n\n        copied_from = \"\"\n        if hasattr(copy_from, \"__name__\"):\n            copied_from = \"(copied from \" + copy_from.__name__ + \"):\\n\"\n        wrapper.__doc__ = copied_from + copy_from.__doc__ + old\n        wrapper.__name__ = func.__name__\n        return wrapper",
  "def col_width(table, colidx):\n        return max([len(str(row[colidx])) for row in table])",
  "def f(x):\n        P, T, V = x\n        m.set_state(P, T)\n        value = 1.0\n        for a, p in zip(*[attributes, powers]):\n            value *= np.power(getattr(m, a), p)\n        return value",
  "def wrapper(*args):\n            return func(*args)",
  "def molar_volume_from_unit_cell_volume(unit_cell_v, z):\n    \"\"\"\n    Converts a unit cell volume from Angstroms^3 per unitcell,\n    to m^3/mol.\n\n    :param unit_cell_v: Unit cell volumes [A^3/unit cell].\n    :type unit_cell_v: float\n\n    :param z: Number of formula units per unit cell.\n    :type z: float\n\n    :returns: Volume [m^3/mol]\n    :rtype: float\n    \"\"\"\n    V = unit_cell_v * constants.Avogadro / 1.0e30 / z\n    return V",
  "def cell_parameters_to_vectors(cell_parameters):\n    \"\"\"\n    Converts cell parameters to unit cell vectors.\n\n    :param cell_parameters: An array containing the three lengths of the\n        unit cell vectors [m], and the three angles [degrees].\n        The first angle (:math:`\\\\alpha`) corresponds to the angle between the\n        second and the third cell vectors, the second (:math:`\\\\beta`) to the\n        angle between the first and third cell vectors, and the third\n        (:math:`\\\\gamma`) to the angle between the first and second vectors.\n    :type cell_parameters: numpy.array (1D)\n\n    :returns: The three vectors defining the parallelopiped cell [m].\n        This function assumes that the first cell vector is colinear with the\n        x-axis, and the second is perpendicular to the z-axis, and the third is\n        defined in a right-handed sense.\n    :rtype: numpy.array (2D)\n    \"\"\"\n    a, b, c, alpha_deg, beta_deg, gamma_deg = cell_parameters\n    alpha = np.radians(alpha_deg)\n    beta = np.radians(beta_deg)\n    gamma = np.radians(gamma_deg)\n\n    n2 = (np.cos(alpha) - np.cos(gamma) * np.cos(beta)) / np.sin(gamma)\n    M = np.array(\n        [\n            [a, 0, 0],\n            [b * np.cos(gamma), b * np.sin(gamma), 0],\n            [c * np.cos(beta), c * n2, c * np.sqrt(np.sin(beta) ** 2 - n2**2)],\n        ]\n    )\n    return M",
  "def cell_vectors_to_parameters(M):\n    \"\"\"\n    Converts unit cell vectors to cell parameters.\n\n    :param M: The three vectors defining the parallelopiped cell [m].\n        This function assumes that the first cell vector is colinear with the\n        x-axis, the second is perpendicular to the z-axis, and the third is\n        defined in a right-handed sense.\n    :type M: numpy.array (2D)\n\n\n    :returns: An array containing the three lengths of the unit cell vectors [m],\n        and the three angles [degrees].\n        The first angle (:math:`\\\\alpha`) corresponds to the angle between the\n        second and the third cell vectors, the second (:math:`\\\\beta`) to the\n        angle between the first and third cell vectors, and the third\n        (:math:`\\\\gamma`) to the angle between the first and second vectors.\n    :rtype: numpy.array (1D)\n    \"\"\"\n\n    assert M[0, 1] == 0\n    assert M[0, 2] == 0\n    assert M[1, 2] == 0\n\n    a = M[0, 0]\n    b = np.sqrt(np.power(M[1, 0], 2.0) + np.power(M[1, 1], 2.0))\n    c = np.sqrt(\n        np.power(M[2, 0], 2.0) + np.power(M[2, 1], 2.0) + np.power(M[2, 2], 2.0)\n    )\n\n    gamma = np.arccos(M[1, 0] / b)\n    beta = np.arccos(M[2, 0] / c)\n    alpha = np.arccos(M[2, 1] / c * np.sin(gamma) + np.cos(gamma) * np.cos(beta))\n\n    gamma_deg = np.degrees(gamma)\n    beta_deg = np.degrees(beta)\n    alpha_deg = np.degrees(alpha)\n\n    return np.array([a, b, c, alpha_deg, beta_deg, gamma_deg])",
  "def round_to_n(x, xerr, n):\n    return round(x, -int(np.floor(np.log10(np.abs(xerr)))) + (n - 1))",
  "def unit_normalize(a, order=2, axis=-1):\n    \"\"\"\n    Calculates the L2 normalized array of numpy array a\n    of a given order and along a given axis.\n    \"\"\"\n    l2 = np.atleast_1d(np.apply_along_axis(np.linalg.norm, axis, a, order))\n\n    l2[l2 == 0] = 1\n    return a / np.expand_dims(l2, axis)[0][0]",
  "def float_eq(a, b):\n    \"\"\"\n    Test if two floats are almost equal to each other\n    \"\"\"\n    return abs(a - b) < 1e-10 * max(1e-5, abs(a), abs(b))",
  "def linear_interpol(x, x1, x2, y1, y2):\n    \"\"\"\n    Linearly interpolate to point x, between\n    the points (x1,y1), (x2,y2)\n    \"\"\"\n    assert x1 <= x\n    assert x2 >= x\n    assert x1 <= x2\n\n    alpha = (x - x1) / (x2 - x1)\n    return (1.0 - alpha) * y1 + alpha * y2",
  "def bracket(fn, x0, dx, args=(), ratio=1.618, maxiter=100):\n    \"\"\"\n    Given a function and a starting guess, find two\n    inputs for the function that bracket a root.\n\n    :param fn: The function to bracket.\n    :type fn: function\n    :param x0: The starting guess.\n    :type x0: float\n    :param dx: Small step for starting the search.\n    :type dx: float\n    :param args: Additional arguments to give to fn.\n    :type args: tuple\n    :param ratio: The step size increases by this ratio\n        every step in the search. Defaults to\n        the golden ratio.\n    :type ratio: float\n    :param maxiter: The maximum number of steps before giving up.\n    :type maxiter: int\n\n    :returns: xa, xb, fa, fb. xa and xb are the inputs which\n        bracket a root of fn. fa and fb are the values of the\n        function at those points.\n        If the bracket function takes more than maxiter steps,\n        it raises a ValueError.\n    :rtype: tuple of floats\n\n    \"\"\"\n    niter = 0\n    dx = np.abs(dx)\n    assert ratio > 1.0\n\n    # Get the starting positions\n    f0 = fn(x0, *args)\n    x_left = x0 - dx\n    x_right = x0 + dx\n    f_left = fn(x_left, *args)\n    f_right = fn(x_right, *args)\n\n    # Overshot zero, try making dx smaller\n    if (f0 - f_left) * (f_right - f0) < 0.0:\n        while (\n            (f0 - f_left) * (f_right - f0) < 0.0\n            and dx > np.finfo(\"float\").eps\n            and niter < maxiter\n        ):\n            dx /= ratio\n            x_left = x0 - dx\n            x_right = x0 + dx\n            f_left = fn(x_left, *args)\n            f_right = fn(x_right, *args)\n            niter += 1\n        if (\n            niter == maxiter\n        ):  # Couldn't find something with same slope in both directions\n            raise ValueError(\"Cannot find zero.\")\n\n    niter = 0\n    slope = f_right - f0\n    if slope > 0.0 and f0 > 0.0:  # Walk left\n        dx = -dx\n        x1 = x_left\n        f1 = f_left\n    elif slope > 0.0 and f0 < 0.0:  # Walk right\n        x1 = x_right\n        f1 = f_right\n    elif slope < 0.0 and f0 > 0:  # Walk right\n        x1 = x_right\n        f1 = f_right\n    else:  # Walk left\n        dx = -dx\n        x1 = x_left\n        f1 = f_left\n\n    # Do the walking\n    while f0 * f1 > 0.0 and niter < maxiter:\n        dx *= ratio\n        xnew = x1 + dx\n        fnew = fn(xnew, *args)\n        x0 = x1\n        f0 = f1\n        x1 = xnew\n        f1 = fnew\n        niter += 1\n\n    if f0 * f1 > 0.0:\n        raise ValueError(\"Cannot find zero.\")\n    else:\n        return x0, x1, f0, f1",
  "def _pad_ndarray_inverse_mirror(array, padding):\n    \"\"\"\n    Pads an ndarray according to an inverse mirror\n    scheme. For example, for a 1D array\n    [2, 4, 6, 7, 8] padded by 3 cells, we have:\n\n     padding  |  original array |  padding\n\n    -3 -2  0  |  2  4  6  7  8  |  9 10 12\n\n    :param array: The array to be padded\n    :type array: numpy.ndarray\n\n    :param padding: The number of elements with which to pad the\n        array in each dimension.\n    :type padding: tuple\n\n    :returns: The padded array.\n    :type: numpy.ndarray\n    \"\"\"\n    padded_shape = [n + 2 * padding[i] for i, n in enumerate(array.shape)]\n    padded_array = np.zeros(padded_shape)\n\n    slices = tuple(\n        [slice(padding[i], padding[i] + l) for i, l in enumerate(array.shape)]\n    )\n    padded_array[slices] = array\n\n    padded_array_indices = list(\n        itertools.product(\n            *[range(n + 2 * padding[i]) for i, n in enumerate(array.shape)]\n        )\n    )\n    inserted_indices = list(\n        itertools.product(\n            *[range(padding[i], padding[i] + l) for i, l in enumerate(array.shape)]\n        )\n    )\n    padded_array_indices.extend(inserted_indices)\n\n    counter = Counter(padded_array_indices)\n    keys = list(counter.keys())\n    padded_indices = [keys[i] for i, value in enumerate(counter.values()) if value == 1]\n    edge_indices = tuple(\n        [\n            tuple(\n                [\n                    np.min(\n                        [\n                            np.max([axis_idx, padding[dimension]]),\n                            padded_array.shape[dimension] - padding[dimension] - 1,\n                        ]\n                    )\n                    for dimension, axis_idx in enumerate(idx)\n                ]\n            )\n            for idx in padded_indices\n        ]\n    )\n    mirror_indices = tuple(\n        [\n            tuple(\n                [\n                    2 * edge_indices[i][j] - padded_indices[i][j]\n                    for j in range(len(array.shape))\n                ]\n            )\n            for i in range(len(padded_indices))\n        ]\n    )\n\n    for i, idx in enumerate(padded_indices):\n        padded_array[idx] = (\n            2.0 * padded_array[edge_indices[i]] - padded_array[mirror_indices[i]]\n        )\n\n    return padded_array",
  "def smooth_array(\n    array, grid_spacing, gaussian_rms_widths, truncate=4.0, mode=\"inverse_mirror\"\n):\n    \"\"\"\n    Creates a smoothed array by convolving it with a gaussian filter.\n    Grid resolutions and gaussian RMS widths are required for each of\n    the axes of the numpy array. The smoothing is truncated at a\n    user-defined number of standard deviations. The edges of the array\n    can be padded in a number of different ways given by the\n    'mode' parameter.\n\n    :param array: The array to smooth.\n    :type array: numpy.ndarray\n    :param grid_spacing: The spacing of points along each axis.\n    :type grid_spacing: numpy.array of floats\n    :param gaussian_rms_widths: The Gaussian RMS widths/standard deviations for the\n        Gaussian convolution.\n    :type gaussian_rms_widths: numpy.array of floats\n    :param truncate: The number of standard deviations at which to truncate\n        the smoothing.\n    :type truncate: float\n    :param mode: {'reflect', 'constant', 'nearest', 'mirror', 'wrap', 'inverse_mirror'}\n        The mode parameter determines how the array borders are handled\n        either by scipy.ndimage.filters.gaussian_filter.\n        Default is 'inverse_mirror', which uses\n        :func:`burnman.tools.math._pad_ndarray_inverse_mirror`.\n    :type mode: str\n\n    :returns: The smoothed array\n    :rtype: numpy.ndarray\n    \"\"\"\n\n    # gaussian_filter works with standard deviations normalised to\n    # the grid spacing.\n    sigma = tuple(np.array(gaussian_rms_widths) / np.array(grid_spacing))\n\n    if mode == \"inverse_mirror\":\n        padding = tuple([int(np.ceil(truncate * s)) for s in sigma])\n        padded_array = _pad_ndarray_inverse_mirror(array, padding)\n        smoothed_padded_array = gaussian_filter(padded_array, sigma=sigma)\n        slices = tuple(\n            [slice(padding[i], padding[i] + l) for i, l in enumerate(array.shape)]\n        )\n        smoothed_array = smoothed_padded_array[slices]\n    else:\n        smoothed_array = gaussian_filter(array, sigma=sigma, mode=mode)\n\n    return smoothed_array",
  "def interp_smoothed_array_and_derivatives(\n    array,\n    x_values,\n    y_values,\n    x_stdev=0.0,\n    y_stdev=0.0,\n    truncate=4.0,\n    mode=\"inverse_mirror\",\n    indexing=\"xy\",\n):\n    \"\"\"\n    Creates a smoothed array on a regular 2D grid. Smoothing\n    is achieved using :func:`burnman.tools.math.smooth_array`.\n    Outputs scipy.interpolate.RegularGridInterpolator() interpolators\n    which can be used to query the array, or its derivatives in the\n    x- and y- directions.\n\n    :param array: The array to smooth. Each element array[i][j]\n        corresponds to the position x_values[i], y_values[j]\n    :type array: numpy.array (2D)\n    :param x_values: The gridded x values over which to create the smoothed grid\n    :type x_values: numpy.array (1D)\n    :param y_values: The gridded y_values over which to create the smoothed grid\n    :type y_values: numpy.array (1D)\n    :param x_stdev: The standard deviation for the Gaussian filter along the x axis\n    :type x_stdev: float\n    :param y_stdev: The standard deviation for the Gaussian filter along the y axis\n    :type y_stdev: float\n    :param truncate: The number of standard deviations at which to truncate\n        the smoothing.\n    :type truncate: float\n    :param mode: {'reflect', 'constant', 'nearest', 'mirror', 'wrap', 'inverse_mirror'}\n        The mode parameter determines how the array borders are handled\n        either by scipy.ndimage.filters.gaussian_filter.\n        Default is 'inverse_mirror', which uses\n        :func:`burnman.tools.math._pad_ndarray_inverse_mirror`.\n    :type mode: str\n    :param indexing: {'xy', 'ij'}, optional\n        Cartesian ('xy', default) or matrix ('ij') indexing of output.\n        See numpy.meshgrid for more details.\n    :type indexing: str\n\n    :returns: Three RegularGridInterpolator functors\n        interpolation functions for the smoothed property and\n        the first derivatives with respect to x and y.\n    :rtype: tuple\n    \"\"\"\n\n    dx = x_values[1] - x_values[0]\n    dy = y_values[1] - y_values[0]\n\n    if indexing == \"xy\":\n        smoothed_array = smooth_array(\n            array=array,\n            grid_spacing=np.array([dy, dx]),\n            gaussian_rms_widths=np.array([y_stdev, x_stdev]),\n            truncate=truncate,\n            mode=mode,\n        ).T\n\n    elif indexing == \"ij\":\n        smoothed_array = smooth_array(\n            array=array,\n            grid_spacing=np.array([dx, dy]),\n            gaussian_rms_widths=np.array([x_stdev, y_stdev]),\n            truncate=truncate,\n            mode=mode,\n        )\n\n    else:\n        raise Exception(\"Indexing scheme not recognised. Should be ij or xy.\")\n\n    dSAdxdx, dSAdydy = np.gradient(smoothed_array)\n\n    interps = (\n        RegularGridInterpolator((x_values, y_values), smoothed_array, method=\"linear\"),\n        RegularGridInterpolator((x_values, y_values), dSAdxdx / dx, method=\"linear\"),\n        RegularGridInterpolator((x_values, y_values), dSAdydy / dy, method=\"linear\"),\n    )\n\n    return interps",
  "def compare_l2(depth, calc, obs):\n    \"\"\"\n    Computes the L2 norm for N profiles at a time (assumed to be linear between points).\n\n    :type depths: array of float\n    :param depths: depths. :math:`[m]`\n    :type calc: list of arrays of float\n    :param calc: N arrays calculated values, e.g. [mat_vs,mat_vphi]\n    :type obs: list of arrays of float\n    :param obs: N arrays of values (observed or calculated) to compare to , e.g. [seis_vs, seis_vphi]\n\n    :returns: array of L2 norms of length N\n    :rtype: array of floats\n    \"\"\"\n    err = []\n    for i in range(len(calc)):\n        err.append(l2(depth, calc[i], obs[i]))\n\n    return err",
  "def compare_chifactor(calc, obs):\n    \"\"\"\n    Computes the chi factor for N profiles at a time. Assumes a 1% a priori uncertainty on the seismic model.\n\n\n    :type calc: list of arrays of float\n    :param calc: N arrays calculated values, e.g. [mat_vs,mat_vphi]\n    :type obs: list of arrays of float\n    :param obs: N arrays of values (observed or calculated) to compare to , e.g. [seis_vs, seis_vphi]\n\n    :returns: error array of length N\n    :rtype: array of floats\n    \"\"\"\n    err = []\n    for i in range(len(calc)):\n        err.append(chi_factor(calc[i], obs[i]))\n\n    return err",
  "def l2(x, funca, funcb):\n    \"\"\"\n    Computes the L2 norm for one profile(assumed to be linear between points).\n\n    :type x: array of float\n    :param x: depths :math:`[m]`.\n    :type funca: list of arrays of float\n    :param funca: array calculated values\n    :type funcb: list of arrays of float\n    :param funcb: array of values (observed or calculated) to compare to\n\n    :returns: L2 norm\n    :rtype: array of floats\n    \"\"\"\n    diff = np.array(funca - funcb)\n    diff = diff * diff\n\n    return integrate.trapz(diff, x)",
  "def nrmse(x, funca, funcb):\n    \"\"\"\n    Normalized root mean square error for one profile\n    :type x: array of float\n    :param x: depths in m.\n    :type funca: list of arrays of float\n    :param funca: array calculated values\n    :type funcb: list of arrays of float\n    :param funcb: array of values (observed or calculated) to compare to\n\n    :returns: RMS error\n    :rtype: array of floats\n    \"\"\"\n    diff = np.array(funca - funcb)\n    diff = diff * diff\n    rmse = np.sqrt(np.sum(diff) / x)\n    nrmse = rmse / (np.max(funca) - np.min(funca))\n\n    return nrmse",
  "def chi_factor(calc, obs):\n    \"\"\"\n    :math:`\\\\chi` factor for one profile assuming 1% uncertainty on the reference model (obs)\n    :type calc: list of arrays of float\n    :param calc: array calculated values\n    :type obs: list of arrays of float\n    :param obs: array of reference values to compare to\n\n    :returns: :math:`\\\\chi` factor\n    :rtype: array of floats\n    \"\"\"\n\n    err = np.empty_like(calc)\n    for i in range(len(calc)):\n        err[i] = pow((calc[i] - obs[i]) / (0.01 * np.mean(obs)), 2.0)\n\n    err_tot = np.sum(err) / len(err)\n\n    return err_tot",
  "def independent_row_indices(array):\n    \"\"\"\n    Returns the indices corresponding to an independent set of rows\n    for a given array. The independent rows are determined from the pivots\n    used during row reduction/Gaussian elimination.\n\n    :param array: The input array.\n    :type array: 2D numpy.array of floats\n\n    :returns: The indices corresponding to a set of independent rows\n        of the input array.\n    :rtype: 1D numpy array of integers\n    \"\"\"\n    m = Matrix(\n        array.shape[0],\n        array.shape[1],\n        lambda i, j: Rational(array[i, j]).limit_denominator(1000),\n    )\n    _, pivots, swaps = row_reduce(\n        m,\n        iszerofunc=lambda x: x.is_zero,\n        simpfunc=lambda x: Rational(x).limit_denominator(1000),\n    )\n    indices = np.array(range(len(array)))\n    for swap in np.array(swaps):\n        indices[swap] = indices[swap[::-1]]\n    return sorted(indices[: len(pivots)])",
  "def array_to_rational_matrix(array):\n    \"\"\"\n    Converts a numpy array into a sympy matrix\n    filled with rationals\n    \"\"\"\n    return Matrix([[Rational(v).limit_denominator(1000) for v in row] for row in array])",
  "def generate_complete_basis(incomplete_basis, array):\n    \"\"\"\n    Given a 2D array with independent rows and a second 2D array that spans a\n    larger space, creates a complete basis for the combined array using all\n    the rows of the first array, followed by any required rows of the\n    second array. So, for example, if the first array is:\n    [[1, 0, 0], [1, 1, 0]] and the second array is:\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]], the complete basis will be:\n    [[1, 0, 0], [1, 1, 0], [0, 0, 1]].\n\n    :param incomplete_basis: An array containing the basis to be completed.\n    :type incomplete_basis: 2D numpy.array\n\n    :param array: An array spanning the full space for which a basis is required.\n    :type array: 2D numpy.array\n\n    :returns: An array containing the basis vectors spanning both of the\n        input arrays.\n    :rtype: 2D numpy array\n    \"\"\"\n\n    incomplete_rank = array_to_rational_matrix(incomplete_basis).rank()\n    if incomplete_rank < len(incomplete_basis):\n        raise Exception(\n            \"The incomplete basis is rank-deficient. \" \"Remove one or more endmembers.\"\n        )\n\n    a = np.concatenate((incomplete_basis, array))\n    complete_basis = np.array(a[independent_row_indices(a)], dtype=float)\n\n    # Store the rank of the matrix for later comparison\n    len_basis = array_to_rational_matrix(complete_basis).rank()\n\n    # This next step ensures that all of the original\n    # rows are contained in the new basis in their original order\n    c = np.linalg.lstsq(\n        np.array(complete_basis).astype(float).T,\n        np.array(incomplete_basis).astype(float).T,\n        rcond=None,\n    )[0].T\n\n    for row in np.eye(len(c[0])):\n        old_rank = array_to_rational_matrix(c).rank()\n        c2 = np.concatenate((c, [row]))\n        new_rank = array_to_rational_matrix(c2).rank()\n\n        if new_rank > old_rank:\n            c = c2\n\n    complete_basis = c.dot(complete_basis)\n\n    # Check that the matrix rank has not changed\n    if len_basis != array_to_rational_matrix(complete_basis).rank():\n        raise Exception(\n            \"Basis length changed during conversion. \" \"Report this bug to developers.\"\n        )\n\n    return complete_basis.round(decimals=12) + 0.0",
  "def read_masses():\n    \"\"\"\n    A simple function to read a file with a two column list of\n    elements and their masses into a dictionary\n    \"\"\"\n    datastream = pkgutil.get_data(\"burnman\", \"data/input_masses/atomic_masses.dat\")\n    datalines = [\n        line.strip() for line in datastream.decode(\"ascii\").split(\"\\n\") if line.strip()\n    ]\n    lookup = dict()\n    for line in datalines:\n        data = \"%\".join(line.split(\"%\")[:1]).split()\n        if data != []:\n            lookup[data[0]] = float(data[1])\n    return lookup",
  "def dictionarize_formula(formula):\n    \"\"\"\n    A function to read a chemical formula string and\n    convert it into a dictionary\n\n    :param formula: Chemical formula, written in the XnYm format, where\n        the formula has n atoms of element X and m atoms of element Y\n    :type formula: str\n\n    :returns: The same chemical formula, but expressed as a dictionary.\n    :rtype: dict\n    \"\"\"\n    f = dict()\n    elements = re.findall(\"[A-Z][^A-Z]*\", formula)\n    for element in elements:\n        element_name = re.split(\"[0-9][^A-Z]*\", element)[0]\n        element_atoms = re.findall(\"[0-9][^A-Z]*\", element)\n        if len(element_atoms) == 0:\n            element_atoms = Fraction(1.0)\n        else:\n            element_atoms = Fraction(element_atoms[0])\n        f[element_name] = f.get(element_name, 0.0) + element_atoms\n\n    return f",
  "def sum_formulae(formulae, amounts=None):\n    \"\"\"\n    Adds together a set of formulae.\n\n    :param formulae: List of chemical formulae.\n    :type formulae: list of dictionary or counter objects\n    :param amounts: List of amounts of each formula.\n    :type amounts: list of floats\n\n    :returns: The sum of the user-provided formulae\n    :rtype: Counter object\n    \"\"\"\n    if amounts is None:\n        amounts = [1.0 for formula in formulae]\n    else:\n        assert len(formulae) == len(amounts)\n\n    summed_formula = Counter()\n    for i, formula in enumerate(formulae):\n        summed_formula.update(\n            Counter(\n                {\n                    element: amounts[i] * n_atoms\n                    for (element, n_atoms) in formula.items()\n                }\n            )\n        )\n    return summed_formula",
  "def formula_mass(formula):\n    \"\"\"\n    A function to take a chemical formula and compute the formula mass.\n\n    :param formula: A chemical formula\n    :type formula: dict or Counter object\n\n    :returns: The mass per mole of formula [kg]\n    :rtype: float\n    \"\"\"\n    mass = sum(formula[element] * atomic_masses[element] for element in formula)\n    return mass",
  "def convert_formula(formula, to_type=\"mass\", normalize=False):\n    \"\"\"\n    Converts a chemical formula from one type (mass or molar)\n    into the other. Renormalises amounts if normalize=True.\n\n    :param formula: A chemical formula.\n    :type formula: dict or Counter object\n\n    :param to_type: Conversion type, one of 'mass' or 'molar'.\n    :type to_type: str\n\n    :param normalize: Whether or not to normalize the converted formula to 1.\n    :type normalize: bool\n\n    :returns: The converted formula.\n    :rtype: dict\n    \"\"\"\n\n    if to_type == \"mass\":\n        f = {\n            element: n_atoms * atomic_masses[element]\n            for (element, n_atoms) in formula.items()\n        }\n    elif to_type == \"molar\":\n        f = {\n            element: n_atoms / atomic_masses[element]\n            for (element, n_atoms) in formula.items()\n        }\n    else:\n        raise Exception(\n            \"Value of parameter to_type not recognised. \"\n            'Should be either \"mass\" or \"molar\".'\n        )\n\n    if normalize:\n        s = np.sum([n for (element, n) in f.items()])\n        f = {element: n / s for (element, n) in f.items()}\n\n    return f",
  "def process_solution_chemistry(solution_model):\n    \"\"\"\n    This function parses a class instance with a \"formulas\"\n    attribute containing site information, e.g.\n\n        [ '[Mg]3[Al]2Si3O12', '[Mg]3[Mg1/2Si1/2]2Si3O12' ]\n\n    It outputs the bulk composition of each endmember\n    (removing the site information), and also a set of\n    variables and arrays which contain the site information.\n    These are output in a format that can easily be used to\n    calculate activities and gibbs free energies, given\n    molar fractions of the phases and pressure\n    and temperature where necessary.\n\n    :param solution_model: Class must have a \"formulas\" attribute,\n        containing a list of chemical formulae with site information\n    :type solution model: instance of class\n\n    :rtype: None\n\n    .. note:: Nothing is returned from this function, but the solution_model\n        object gains the following attributes:\n\n        * solution_formulae [list of dictionaries]\n            List of endmember formulae in dictionary form.\n        * empty_formula [string]\n            Abbreviated chemical formula with sites denoted by empty\n            square brackets.\n        * general_formula [string]\n            General chemical formula with sites denoted by\n            square brackets filled with a comma-separated list of species\n        * n_sites [integer]\n            Number of sites in the solution.\n            Should be the same for all endmembers.\n        * sites [list of lists of strings]\n            A list of species for each site in the solution.\n        * site_names [list of strings]\n            A list of species_site pairs in the solution, where\n            each distinct site is given by a unique uppercase letter\n            e.g. ['Mg_A', 'Fe_A', 'Al_A', 'Al_B', 'Si_B'].\n        * n_occupancies [integer]\n            Sum of the number of possible species on each of the sites\n            in the solution.\n            Example: A binary solution [[A][B],[B][C1/2D1/2]] would have\n            n_occupancies = 5, with two possible species on\n            Site 1 and three on Site 2.\n        * site_multiplicities [2D array of floats]\n            A 1D array for each endmember in the solution,\n            containing the multiplicities of each site per formula unit.\n            To simplify computations later, the multiplicities\n            are repeated for each species on each site, so the shape of\n            this attribute is (n_endmembers, n_site_species).\n        * endmember_occupancies [2d array of floats]\n            A 1D array for each endmember in the solution,\n            containing the fraction of atoms of each species on each site.\n        * endmember_noccupancies [2d array of floats]\n            A 1D array for each endmember in the solution,\n            containing the number of atoms of each species on each site\n            per mole of endmember.\n    \"\"\"\n    formulae = solution_model.formulas\n    n_sites = formulae[0].count(\"[\")\n    n_endmembers = len(formulae)\n\n    # Check the number of sites is the same for all endmembers\n    if not np.all(np.array([f.count(\"[\") for f in formulae]) == n_sites):\n        raise Exception(\"All formulae must have the same \" \"number of distinct sites.\")\n\n    solution_formulae = [{} for i in range(n_endmembers)]\n    sites = [[] for i in range(n_sites)]\n    list_occupancies = []\n    list_multiplicities = np.empty(shape=(n_endmembers, n_sites))\n    n_occupancies = 0\n\n    # Number of unique site occupancies (e.g.. Mg on X etc.)\n    for i_mbr in range(n_endmembers):\n        list_occupancies.append([[0] * len(sites[site]) for site in range(n_sites)])\n        s = re.split(r\"\\[\", formulae[i_mbr])[1:]\n\n        for i_site, site_string in enumerate(s):\n            site_split = re.split(r\"\\]\", site_string)\n            site_occupancy = site_split[0]\n\n            mult = re.split(\"[A-Z][^A-Z]*\", site_split[1])[0]\n            if mult == \"\":\n                list_multiplicities[i_mbr][i_site] = Fraction(1.0)\n            else:\n                list_multiplicities[i_mbr][i_site] = Fraction(mult)\n\n            # Loop over species on a site\n            species = re.findall(\"[A-Z][^A-Z]*\", site_occupancy)\n\n            for sp in species:\n                # Find the species and its proportion on the site\n                species_split = re.split(\"([0-9][^A-Z]*)\", sp)\n                name_of_species = species_split[0]\n                if len(species_split) == 1:\n                    proportion_species_on_site = Fraction(1.0)\n                else:\n                    proportion_species_on_site = Fraction(species_split[1])\n\n                solution_formulae[i_mbr][name_of_species] = solution_formulae[\n                    i_mbr\n                ].get(name_of_species, 0.0) + (\n                    list_multiplicities[i_mbr][i_site] * proportion_species_on_site\n                )\n\n                if name_of_species not in sites[i_site]:\n                    n_occupancies += 1\n                    sites[i_site].append(name_of_species)\n                    i_el = sites[i_site].index(name_of_species)\n                    for parsed_mbr in range(len(list_occupancies)):\n                        list_occupancies[parsed_mbr][i_site].append(0)\n                else:\n                    i_el = sites[i_site].index(name_of_species)\n                list_occupancies[i_mbr][i_site][i_el] = proportion_species_on_site\n\n            # Loop over species after site\n            if len(site_split) != 1:\n                not_in_site = str(filter(None, site_split[1]))\n                not_in_site = not_in_site.replace(mult, \"\", 1)\n                for enamenumber in re.findall(\"[A-Z][^A-Z]*\", not_in_site):\n                    sp = list(filter(None, re.split(r\"(\\d+)\", enamenumber)))\n                    # Look up number of atoms of element\n                    if len(sp) == 1:\n                        nel = 1.0\n                    else:\n                        nel = float(float(sp[1]))\n                    solution_formulae[i_mbr][sp[0]] = (\n                        solution_formulae[i_mbr].get(sp[0], 0.0) + nel\n                    )\n\n    # Site occupancies and multiplicities\n    endmember_occupancies = np.empty(shape=(n_endmembers, n_occupancies))\n    site_multiplicities = np.empty(shape=(n_endmembers, n_occupancies))\n\n    for i_mbr in range(n_endmembers):\n        n_species = 0\n        for i_site in range(n_sites):\n            for i_el in range(len(list_occupancies[i_mbr][i_site])):\n                endmember_occupancies[i_mbr][n_species] = list_occupancies[i_mbr][\n                    i_site\n                ][i_el]\n                site_multiplicities[i_mbr][n_species] = list_multiplicities[i_mbr][\n                    i_site\n                ]\n                n_species += 1\n\n    # Site names\n    solution_model.site_names = []\n    for i, species in enumerate(sites):\n        for sp in species:\n            solution_model.site_names.append(\"{0}_{1}\".format(sp, ucase[i]))\n\n    # Finally, make attributes for solution model instance:\n    solution_model.solution_formulae = solution_formulae\n    solution_model.n_sites = n_sites\n    solution_model.sites = sites\n    solution_model.site_multiplicities = site_multiplicities\n    solution_model.n_occupancies = n_occupancies\n    solution_model.endmember_occupancies = endmember_occupancies\n    solution_model.endmember_noccupancies = np.einsum(\n        \"ij, ij->ij\", endmember_occupancies, site_multiplicities\n    )\n\n    solution_model.empty_formula = re.sub(\n        \"([\\[]).*?([\\]])\", \"\\g<1>\\g<2>\", solution_model.formulas[0]\n    )\n    split_empty = solution_model.empty_formula.split(\"[\")\n    solution_model.general_formula = split_empty[0]\n    for i in range(n_sites):\n        solution_model.general_formula += f\"[{','.join(sites[i])}{split_empty[i+1]}\"",
  "def site_occupancies_to_strings(\n    site_species_names, site_multiplicities, endmember_occupancies\n):\n    \"\"\"\n    Converts a list of endmember site occupancies into a list\n    of string representations of those occupancies.\n\n    :param site_species_names: A list of list of strings,\n        giving the names of the species which reside on each site.\n        List of sites, each of which contains a list of the species\n        occupying each site.\n    :type site_species_names: 2D list of strings\n\n    :param site_multiplicities: List of floats giving the multiplicity\n        of each site. If 2D, must have the same shape as endmember_occupancies.\n        If 1D, must be either the same length as the number of sites, or\n        the same length as site_species_names\n        (with an implied repetition of the same\n        number for each species on a given site).\n    :type site_multiplicities: 1D or 2D numpy array of floats\n\n    :param endmember_occupancies: A list of site-species occupancies\n        for each endmember. The first dimension loops over the endmembers, and the\n        second dimension loops over the site-species occupancies for that endmember.\n        The total number and order of occupancies must\n        be the same as the strings in site_species_names.\n    :type endmember_occupancies: 2D numpy array of floats\n\n    :returns: A list of strings in standard burnman format.\n        For example, [Mg]3[Al]2 would correspond to the\n        classic two-site pyrope garnet.\n    :rtype: list of strings\n    \"\"\"\n\n    site_multiplicities = np.array(site_multiplicities)\n    endmember_occupancies = np.array(endmember_occupancies)\n    n_endmembers = endmember_occupancies.shape[0]\n\n    if len(site_multiplicities.shape) == 1:\n        # Site multiplicities should either be given on a per-site basis,\n        # or a per-species basis\n        if len(site_species_names) == len(site_multiplicities):\n            site_mults = []\n\n            for i, site in enumerate(site_species_names):\n                for species in site:\n                    site_mults.append(site_multiplicities[i])\n\n            site_multiplicities = np.array(site_mults)\n\n        elif len(endmember_occupancies[0]) != len(site_multiplicities):\n            raise Exception(\n                \"Site multiplicities should either be given \"\n                \"on a per-site basis or a per-species basis\"\n            )\n\n        site_multiplicities = np.einsum(\n            \"i, j->ij\", np.ones(n_endmembers), site_multiplicities\n        )\n    elif len(site_multiplicities.shape) == 2:\n        if site_multiplicities.shape != endmember_occupancies.shape:\n            raise Exception(\n                \"If site_multiplicities is 2D, it should have \"\n                \"the same shape as endmember_occupancies. \"\n                \"They currently have shapes \"\n                f\"{site_multiplicities.shape} and \"\n                f\"{endmember_occupancies.shape}.\"\n            )\n    else:\n        raise Exception(\"Site multiplicities should either be 1D or 2D.\")\n\n    site_formulae = []\n    for i_mbr, mbr_occupancies in enumerate(endmember_occupancies):\n        i = 0\n        site_formulae.append(\"\")\n        for site in site_species_names:\n            amounts = mbr_occupancies[i : i + len(site)]\n            mult = site_multiplicities[i_mbr, i]\n            if np.abs(mult - 1.0) < 1.0e-12:\n                mult = \"\"\n            else:\n                mult = str(nsimplify(mult))\n            amounts /= sum(amounts)\n            site_occupancy = formula_to_string(dict(zip(site, amounts)))\n            site_formulae[-1] += \"[{0}]{1}\".format(site_occupancy, mult)\n            i += len(site)\n\n    return site_formulae",
  "def compositional_array(formulae):\n    \"\"\"\n    :param formulae: List of chemical formulae\n    :type formulae: list of dicts\n\n    :returns: Array of endmember formulae and a list of elements.\n    :rtype: 2D numpy.array of floats and a list of strs\n    \"\"\"\n    elements = []\n    for formula in formulae:\n        for element in formula:\n            if element not in elements:\n                elements.append(element)\n\n    formula_array = ordered_compositional_array(formulae, elements)\n\n    return formula_array, elements",
  "def ordered_compositional_array(formulae, elements):\n    \"\"\"\n    :param formulae: List of chemical formulae\n    :type formulae: list of dicts\n\n    :param elements : List of elements\n    :type elements: list of strings\n\n    :returns: Array of endmember formulae\n    :rtype: 2D array of floats\n    \"\"\"\n    formula_array = np.zeros(shape=(len(formulae), len(elements)))\n    for idx, formula in enumerate(formulae):\n        for element in formula:\n            assert element in elements\n            formula_array[idx][elements.index(element)] = formula[element]\n\n    return formula_array",
  "def formula_to_string(formula):\n    \"\"\"\n    :param formula: Chemical formula\n    :type formula: dict or Counter\n\n    :returns: A formula string, with element order as given in the list\n        IUPAC_element_order.\n        If one or more keys in the dictionary are not one of the elements\n        in the periodic table, then they are added at the end of the string.\n    :rtype: str\n    \"\"\"\n\n    formula_string = \"\"\n    for e in IUPAC_element_order:\n        if e in formula and np.abs(formula[e]) > 1.0e-12:\n            if np.abs(formula[e] - 1.0) < 1.0e-12:\n                formula_string += e\n            else:\n                formula_string += e + str(nsimplify(formula[e]))\n\n    for e in formula:\n        if e not in IUPAC_element_order:\n            if e in formula and np.abs(formula[e]) > 1.0e-12:\n                if np.abs(formula[e] - 1.0) < 1.0e-12:\n                    formula_string += e\n                else:\n                    formula_string += e + str(nsimplify(formula[e]))\n\n    return formula_string",
  "def sort_element_list_to_IUPAC_order(element_list):\n    \"\"\"\n    :param element_list : List of elements.\n    :type element_list: list\n\n    :returns: List of elements sorted into IUPAC order\n    :rtype: list\n    \"\"\"\n    sorted_list = [e for e in IUPAC_element_order if e in element_list]\n    assert len(sorted_list) == len(element_list)\n    return sorted_list",
  "def convert_fractions(composite, phase_fractions, input_type, output_type):\n    \"\"\"\n    Takes a composite with a set of user defined molar, volume\n    or mass fractions (which do not have to be the fractions\n    currently associated with the composite) and\n    converts the fractions to molar, mass or volume.\n\n    Conversions to and from mass require a molar mass to be\n    defined for all phases. Conversions to and from volume\n    require set_state to have been called for the composite.\n\n    :param composite: Composite for which fractions are to be defined.\n    :type composite: :class:`~burnman.Composite`\n\n    :param phase_fractions: List of input phase fractions\n        (of type input_type).\n    :type phase_fractions: list of floats\n\n    :param input_type: Input fraction type. One of 'molar', 'mass' or 'volume'.\n    :type input_type: str\n\n    :param output_type: Output fraction type. One of 'molar', 'mass' or 'volume'.\n    :type output_type: str\n\n    :returns: List of output phase fractions (of type output_type)\n    :rtype: list of floats\n    \"\"\"\n    if input_type == \"volume\" or output_type == \"volume\":\n        if composite.temperature is None:\n            raise Exception(\n                composite.to_string()\n                + \".set_state(P, T) has not been called, so volume fractions are currently undefined. Exiting.\"\n            )\n\n    if input_type == \"molar\":\n        molar_fractions = phase_fractions\n    if input_type == \"volume\":\n        total_moles = sum(\n            volume_fraction / phase.molar_volume\n            for volume_fraction, phase in zip(phase_fractions, composite.phases)\n        )\n        molar_fractions = [\n            volume_fraction / (phase.molar_volume * total_moles)\n            for volume_fraction, phase in zip(phase_fractions, composite.phases)\n        ]\n    if input_type == \"mass\":\n        total_moles = sum(\n            mass_fraction / phase.molar_mass\n            for mass_fraction, phase in zip(phase_fractions, composite.phases)\n        )\n        molar_fractions = [\n            mass_fraction / (phase.molar_mass * total_moles)\n            for mass_fraction, phase in zip(phase_fractions, composite.phases)\n        ]\n\n    if output_type == \"volume\":\n        total_volume = sum(\n            molar_fraction * phase.molar_volume\n            for molar_fraction, phase in zip(molar_fractions, composite.phases)\n        )\n        output_fractions = [\n            molar_fraction * phase.molar_volume / total_volume\n            for molar_fraction, phase in zip(molar_fractions, composite.phases)\n        ]\n    elif output_type == \"mass\":\n        total_mass = sum(\n            molar_fraction * phase.molar_mass\n            for molar_fraction, phase in zip(molar_fractions, composite.phases)\n        )\n        output_fractions = [\n            molar_fraction * phase.molar_mass / total_mass\n            for molar_fraction, phase in zip(molar_fractions, composite.phases)\n        ]\n    elif output_type == \"molar\":\n        output_fractions = molar_fractions\n\n    return output_fractions",
  "def reaction_matrix_as_strings(reaction_matrix, compound_names):\n    \"\"\"\n    Returns a list of string representations of all the reactions in\n    reaction_matrix.\n\n    :param reaction_matrix: Matrix of stoichiometric amounts\n        of each compound j in reaction i.\n    :type reaction_matrix: 2D numpy array\n\n    :param compound_names: List of compound names.\n    :type compound_names: list of strings\n\n    :returns: List of strings corresponding to each reaction.\n    :rtype: list of strings\n    \"\"\"\n    reaction_strings = []\n    for reaction in reaction_matrix:\n        lhs, rhs = (\"\", \"\")\n        for i, coefficient in enumerate(reaction):\n            if coefficient < -1.0e-10:\n                if len(lhs) > 0:\n                    lhs += \" + \"\n                lhs += f\"{-coefficient} {compound_names[i]}\"\n            if coefficient > 1.0e-10:\n                if len(rhs) > 0:\n                    rhs += \" + \"\n                rhs += f\"{coefficient} {compound_names[i]}\"\n        reaction_strings.append(f\"{lhs} = {rhs}\")\n\n    return reaction_strings",
  "class MineralFit(object):\n    \"\"\"\n    Class for fitting mineral parameters to experimental data.\n    Instances of this class are passed to\n    :func:`burnman.nonlinear_least_squares_fit`.\n\n    For attributes added to this model when fitting is done,\n    please see the documentation for that function.\n    \"\"\"\n\n    def __init__(\n        self,\n        mineral,\n        data,\n        data_covariances,\n        flags,\n        fit_params,\n        mle_tolerances,\n        delta_params=None,\n        bounds=None,\n    ):\n        self.m = mineral\n        self.data = data\n        self.data_covariances = data_covariances\n        self.flags = flags\n        self.fit_params = fit_params\n        self.mle_tolerances = mle_tolerances\n        if delta_params is None:\n            self.delta_params = self.get_params() * 1.0e-5 + 1.0e-10\n        else:\n            self.delta_params = delta_params\n        self.bounds = bounds\n\n    def set_params(self, param_values):\n        i = 0\n\n        if self.bounds is not None:\n            param_values = np.clip(param_values, self.bounds[:, 0], self.bounds[:, 1])\n\n        for param in self.fit_params:\n            if isinstance(self.m.params[param], float):\n                self.m.params[param] = param_values[i]\n                i += 1\n            else:\n                for j in range(len(self.m.params[param])):\n                    self.m.params[param][j] = param_values[i]\n                    i += 1\n\n    def get_params(self):\n        params = []\n        for i, param in enumerate(self.fit_params):\n            params.append(self.m.params[param])\n        return np.array(flatten([self.m.params[prm] for prm in self.fit_params]))\n\n    def function(self, x, flag):\n        P, T, p = x\n        self.m.set_state(P, T)\n        return np.array([P, T, getattr(self.m, flag)])\n\n    def normal(self, x, flag):\n        P, T, p = x\n\n        if flag == \"V\":\n            self.m.set_state(P, T)\n            dPdp = -self.m.K_T / self.m.V\n            dpdT = self.m.alpha * self.m.V\n        elif flag == \"H\":\n            self.m.set_state(P, T)\n            dPdp = 1.0 / ((1.0 - T * self.m.alpha) * self.m.V)\n            dpdT = self.m.molar_heat_capacity_p\n        elif flag == \"S\":\n            self.m.set_state(P, T)\n            dPdp = -1.0 / (self.m.alpha * self.m.V)\n            dpdT = self.m.molar_heat_capacity_p / T\n        elif flag == \"gibbs\":\n            self.m.set_state(P, T)\n            dPdp = 1.0 / self.m.V\n            dpdT = -self.m.S\n        else:\n            dP = 1.0e5\n            dT = 1.0\n            dPdp = (2.0 * dP) / (\n                self.function([P + dP, T, 0.0], flag)[2]\n                - self.function([P - dP, T, 0.0], flag)[2]\n            )\n            dpdT = (\n                self.function([P, T + dT, 0.0], flag)[2]\n                - self.function([P, T - dT, 0.0], flag)[2]\n            ) / (2.0 * dT)\n        dPdT = -dPdp * dpdT\n        n = np.array([-1.0, dPdT, dPdp])\n        return unit_normalize(n)",
  "def fit_PTp_data(\n    mineral,\n    fit_params,\n    flags,\n    data,\n    data_covariances=[],\n    mle_tolerances=[],\n    param_tolerance=1.0e-5,\n    delta_params=None,\n    bounds=None,\n    max_lm_iterations=50,\n    verbose=True,\n):\n    \"\"\"\n    Given a mineral of any type, a list of fit parameters\n    and a set of P-T-property points and (optional) uncertainties,\n    this function returns a list of optimized parameters\n    and their associated covariances, fitted using the\n    scipy.optimize.curve_fit routine.\n\n    :param mineral: Mineral for which the parameters should be optimized.\n    :type mineral: :class:`burnman.Mineral`\n\n    :param fit_params: List of dictionary keys contained in mineral.params\n        corresponding to the variables to be optimized\n        during fitting. Initial guesses are taken from the existing\n        values for the parameters\n    :type fit_params: list of str\n\n    :param flags: Attribute names for the property to be fit for the whole\n        dataset or each datum individually (e.g. 'V')\n    :type flags: string or list of strings\n\n    :param data: Observed X-P-T-property values\n    :type data: 2D numpy.array\n\n    :param data_covariances: X-P-T-property covariances (optional)\n        If not given, all covariance matrices are chosen\n        such that all data points have equal weight,\n        with all error in the pressure.\n    :type data_covariances: 3D numpy.array\n\n    :param mle_tolerances: Tolerances for termination of the\n        maximum likelihood iterations (optional).\n    :type mle_tolerances: numpy.array\n\n    :param param_tolerance: Fractional tolerance for termination\n        of the nonlinear optimization (optional).\n    :type param_tolerance: float\n\n    :param delta_params: Initial values for the change in parameters (optional).\n    :type delta_params: numpy.array\n\n    :param bounds: Minimum and maximum bounds for the parameters (optional).\n        The shape must be (n_parameters, 2).\n    :type bounds: 2D numpy.array\n\n    :param max_lm_iterations: Maximum number of Levenberg-Marquardt iterations.\n    :type max_lm_iterations: int\n\n    :param verbose: Whether to print detailed information about the\n        optimization to screen.\n    :type verbose: bool\n\n    :returns: Model with optimized parameters.\n    :rtype: :class:`burnman.optimize.eos_fitting.MineralFit`\n    \"\"\"\n\n    # If only one property flag is given, assume it applies to all data\n    if type(flags) is str:\n        flags = np.array([flags] * len(data[:, 0]))\n\n    if len(flags) != len(data):\n        raise Exception(\n            f\"The number of flags (n = {len(flags)}) must be equal \"\n            f\"to the number of data (n = {len(data)}).\"\n        )\n\n    # Apply mle tolerances if they dont exist\n    if mle_tolerances == []:\n        mineral.set_state(1.0e5, 300.0)\n        mle_tolerance_factor = 1.0e-5\n        mle_tolerances = np.empty(len(flags))\n        for i, flag in enumerate(flags):\n            if flag in [\"gibbs\", \"enthalpy\", \"H\", \"helmholtz\"]:\n                mle_tolerances[i] = 1.0  # 1 J\n            else:\n                mle_tolerances[i] = mle_tolerance_factor * getattr(mineral, flag)\n\n    # If covariance matrix is not given, apply unit weighting to all pressures\n    # (with zero errors on T and p)\n    covariances_defined = True\n    if data_covariances == []:\n        covariances_defined = False\n        data_covariances = np.zeros((len(data[:, 0]), len(data[0]), len(data[0])))\n        for i in range(len(data_covariances)):\n            data_covariances[i][0][0] = 1.0\n\n    model = MineralFit(\n        mineral=mineral,\n        data=data,\n        data_covariances=data_covariances,\n        flags=flags,\n        fit_params=fit_params,\n        delta_params=delta_params,\n        mle_tolerances=mle_tolerances,\n        bounds=bounds,\n    )\n\n    nonlinear_least_squares_fit(\n        model,\n        max_lm_iterations=max_lm_iterations,\n        param_tolerance=param_tolerance,\n        verbose=verbose,\n    )\n\n    if verbose is True and covariances_defined is True:\n        confidence_interval = 0.9\n        d = nonlinear_fitting.extreme_values(\n            model.weighted_residuals, confidence_interval\n        )\n        confidence_bound, indices, probabilities = d\n        if indices != []:\n            print(\n                \"The function nonlinear_fitting.extreme_values\"\n                \"(model.weighted_residuals, confidence_interval) \"\n                f\"has determined that there are {len(indices):d} data points\"\n                \" which have residuals which are not expected at the \"\n                f\"{confidence_interval*100.:.1f}% confidence level \"\n                f\"(> {confidence_bound:.1f} s.d. away from the model fit).\\n\"\n                \"Their indices and the probabilities of finding \"\n                \"such extreme values are:\"\n            )\n            for i, idx in enumerate(indices):\n                print(\n                    f\"[{idx:d}]: {probabilities[i]:.4f} \"\n                    f\"({np.abs(model.weighted_residuals[idx]):.1f} s.d. \"\n                    \"from the model)\"\n                )\n            print(\n                \"You might consider removing them from your fit, \"\n                \"or increasing the uncertainties in their \"\n                \"measured values.\\n\"\n            )\n\n    return model",
  "def fit_PTV_data(\n    mineral,\n    fit_params,\n    data,\n    data_covariances=[],\n    delta_params=None,\n    bounds=None,\n    param_tolerance=1.0e-5,\n    max_lm_iterations=50,\n    verbose=True,\n):\n    \"\"\"\n    A simple alias for the fit_PTp_data for when all the data is volume data\n    \"\"\"\n\n    return fit_PTp_data(\n        mineral=mineral,\n        flags=\"V\",\n        data=data,\n        data_covariances=data_covariances,\n        fit_params=fit_params,\n        param_tolerance=param_tolerance,\n        delta_params=delta_params,\n        bounds=bounds,\n        max_lm_iterations=max_lm_iterations,\n        verbose=verbose,\n    )",
  "class SolutionFit(object):\n    \"\"\"\n    Class for fitting mineral parameters to experimental data.\n    Instances of this class are passed to\n    :func:`burnman.nonlinear_least_squares_fit`.\n\n    For attributes added to this model when fitting is done,\n    please see the documentation for that function.\n    \"\"\"\n\n    def __init__(\n        self,\n        solution,\n        data,\n        data_covariances,\n        flags,\n        fit_params,\n        mle_tolerances,\n        delta_params=None,\n        bounds=None,\n    ):\n        self.m = solution\n        self.data = data\n        self.data_covariances = data_covariances\n        self.flags = flags\n        self.fit_params = fit_params\n        self.fit_params_strings = []\n        for p in fit_params:\n            if isinstance(p, list):\n                csv_list_mbrs = \",\".join([str(i) for i in p[1:]])\n                self.fit_params_strings.append(f\"{p[0]} ({csv_list_mbrs})\")\n            else:\n                self.fit_params_strings.append(p)\n\n        self.mle_tolerances = mle_tolerances\n        if delta_params is None:\n            self.delta_params = self.get_params() * 1.0e-5 + 1.0e-10\n        else:\n            self.delta_params = delta_params\n        self.bounds = bounds\n\n    def set_params(self, param_values):\n        # fit_params is a list of lists\n        # if the list has length 2, the first item should be an integer\n        # indicating the endmember number in the solution\n        # if the list has length 3, the first two items should be endmember\n        # numbers, and the third should be the interaction parameter type\n        # (E, S or V).\n        i = 0\n\n        if self.bounds is not None:\n            param_values = np.clip(param_values, self.bounds[:, 0], self.bounds[:, 1])\n\n        for param in self.fit_params:\n            value = param_values[i]\n            if len(param) == 2:\n                key, imbr = param\n                if isinstance(self.m.endmembers[imbr][0].params[key], float):\n                    self.m.endmembers[imbr][0].params[key] = value\n                    i += 1\n                else:\n                    n_values = len(self.m.endmembers[imbr][0].params[key])\n                    for j in range(n_values):\n                        self.m.endmembers[imbr][0].params[key][j] = value\n                        i += 1\n            elif len(param) == 3:\n                key, imbr, jmbr = param\n                ai = self.m.solution_model.alphas[imbr]\n                aj = self.m.solution_model.alphas[jmbr]\n                if key == \"E\":\n                    self.m.solution_model.We[imbr, jmbr] = 2.0 * value / (ai * aj)\n                if key == \"S\":\n                    self.m.solution_model.Ws[imbr, jmbr] = 2.0 * value / (ai * aj)\n                if key == \"V\":\n                    self.m.solution_model.Wv[imbr, jmbr] = 2.0 * value / (ai * aj)\n\n                i += 1\n            else:\n                raise Exception(\"param length must be two or three\")\n\n    def get_params(self):\n        params = []\n        for param in self.fit_params:\n            if len(param) == 2:\n                key, imbr = param\n                value = self.m.endmembers[imbr][0].params[key]\n                if isinstance(value, float):\n                    params.append(value)\n                else:\n                    params.extend(list(value))\n\n            elif len(param) == 3:\n                key, imbr, jmbr = param\n                ai = self.m.solution_model.alphas[imbr]\n                aj = self.m.solution_model.alphas[jmbr]\n                if key == \"E\":\n                    params.append(\n                        self.m.solution_model.We[imbr, jmbr] * (ai * aj) / 2.0\n                    )\n                if key == \"S\":\n                    params.append(\n                        self.m.solution_model.Ws[imbr, jmbr] * (ai * aj) / 2.0\n                    )\n                if key == \"V\":\n                    params.append(\n                        self.m.solution_model.Wv[imbr, jmbr] * (ai * aj) / 2.0\n                    )\n            else:\n                raise Exception(\"param length must be two or three\")\n        return np.array(params)\n\n    def function(self, x, flag):\n        self.m.set_composition(x[: self.m.n_endmembers])\n        P, T, p = x[self.m.n_endmembers :]\n        self.m.set_state(P, T)\n\n        f = np.copy(x)\n        f[-1] = getattr(self.m, flag)\n        return f\n\n    def normal(self, x, flag):\n        self.m.set_composition(x[: self.m.n_endmembers])\n        P, T, p = x[self.m.n_endmembers :]\n\n        if flag == \"V\":\n            self.m.set_state(P, T)\n            dPdp = -self.m.K_T / self.m.V\n            dpdT = self.m.alpha * self.m.V\n        elif flag == \"H\":\n            self.m.set_state(P, T)\n            dPdp = 1.0 / ((1.0 - T * self.m.alpha) * self.m.V)\n            dpdT = self.m.molar_heat_capacity_p\n        elif flag == \"S\":\n            self.m.set_state(P, T)\n            dPdp = -1.0 / (self.m.alpha * self.m.V)\n            dpdT = self.m.molar_heat_capacity_p / T\n        elif flag == \"gibbs\":\n            self.m.set_state(P, T)\n            dPdp = 1.0 / self.m.V\n            dpdT = -self.m.S\n        else:\n            dP = 1.0e5\n            dT = 1.0\n            xP0 = np.copy(x)\n            xP1 = np.copy(x)\n            xT0 = np.copy(x)\n            xT1 = np.copy(x)\n            xP0[-3] = xP1[-3] - dP\n            xP1[-3] = xP1[-3] + dP\n            xT0[-2] = xP1[-2] - dT\n            xT1[-2] = xP1[-2] + dT\n\n            dPdp = (2.0 * dP) / (\n                self.function(xP1, flag)[2] - self.function(xP0, flag)[2]\n            )\n            dpdT = (self.function(xT1, flag)[2] - self.function(xT0, flag)[2]) / (\n                2.0 * dT\n            )\n        dPdT = -dPdp * dpdT\n        n = np.zeros(len(x))\n        n[-3:] = np.array([-1.0, dPdT, dPdp])\n        return unit_normalize(n)",
  "def fit_XPTp_data(\n    solution,\n    fit_params,\n    flags,\n    data,\n    data_covariances=[],\n    mle_tolerances=[],\n    param_tolerance=1.0e-5,\n    delta_params=None,\n    bounds=None,\n    max_lm_iterations=50,\n    verbose=True,\n):\n    \"\"\"\n    Given a symmetric solution, a list of fit parameters\n    and a set of P-T-property points and (optional) uncertainties,\n    this function returns a list of optimized parameters\n    and their associated covariances, fitted using the\n    scipy.optimize.curve_fit routine.\n\n    :param solution: Solution for which the parameters should be optimized.\n    :type solution: :class:`burnman.Solution`\n\n    :param fit_params: Variables to be optimized\n        during fitting. Each list is either of length two or three.\n        The first item of length-2 lists should be a\n        dictionary key contained in one of the endmember\n        mineral.params, and the second item should be the index of\n        the endmember in the solution (indexing starts from 0).\n        The first item of length-3 lists should be one of 'E', 'S' or\n        'V' (the excess energies, entropies or volumes in each binary).\n        The second two items should be the indices of the pair of\n        endmembers bounding the binary, in ascending order\n        (indexing starts from 0). Initial guesses are taken from the existing\n        values for the parameters.\n    :type fit_params: list of lists\n\n    :param flags: Attribute names for the property to be fit for the whole\n        dataset or each datum individually (e.g. 'V')\n    :type flags: string or list of strings\n\n    :param data: Observed X-P-T-property values\n    :type data: 2D numpy.array\n\n    :param data_covariances: X-P-T-property covariances (optional).\n        If not given, all covariance matrices are chosen\n        such that all data points have equal weight,\n        with all error in the pressure.\n    :type data_covariances: 3D numpy.array\n\n    :param mle_tolerances: Tolerances for termination of the\n        maximum likelihood iterations (optional).\n    :type mle_tolerances: numpy.array\n\n    :param param_tolerance: Fractional tolerance for termination\n        of the nonlinear optimization (optional).\n    :type param_tolerance: float\n\n    :param delta_params: Initial values for the change in parameters (optional).\n    :type delta_params: numpy.array\n\n    :param bounds: Minimum and maximum bounds for the parameters (optional).\n        The shape must be (n_parameters, 2).\n    :type bounds: 2D numpy.array\n\n    :param max_lm_iterations: Maximum number of Levenberg-Marquardt iterations.\n    :type max_lm_iterations: int\n\n    :param verbose: Whether to print detailed information about the\n        optimization to screen.\n    :type verbose: bool\n\n    :returns: Model with optimized parameters.\n    :rtype: :class:`burnman.optimize.eos_fitting.SolutionFit`\n    \"\"\"\n    # If only one property flag is given, assume it applies to all data\n    if type(flags) is str:\n        flags = np.array([flags] * len(data[:, 0]))\n\n    if len(flags) != len(data):\n        raise Exception(\n            f\"The number of flags (n = {len(flags)}) must be equal \"\n            f\"to the number of data (n = {len(data)}).\"\n        )\n\n    # Apply mle tolerances if they dont exist\n    if mle_tolerances == []:\n        solution.set_state(1.0e5, 300.0)\n        mle_tolerance_factor = 1.0e-5\n        mle_tolerances = np.empty(len(flags))\n        for i, flag in enumerate(flags):\n            if flag in [\"gibbs\", \"enthalpy\", \"H\", \"helmholtz\"]:\n                mle_tolerances[i] = 1.0  # 1 J\n            else:\n                mle_tolerances[i] = mle_tolerance_factor * getattr(solution, flag)\n\n    # If covariance matrix is not given, apply unit weighting to all pressures\n    # (with zero errors on T and property)\n    covariances_defined = True\n    if data_covariances == []:\n        covariances_defined = False\n        nX = solution.n_endmembers\n        data_covariances = np.zeros((len(data[:, 0]), len(data[0]), len(data[0])))\n        for i in range(len(data_covariances)):\n            data_covariances[i][nX][nX] = 1.0\n\n    model = SolutionFit(\n        solution=solution,\n        data=data,\n        data_covariances=data_covariances,\n        flags=flags,\n        fit_params=fit_params,\n        mle_tolerances=mle_tolerances,\n        delta_params=delta_params,\n        bounds=bounds,\n    )\n\n    nonlinear_least_squares_fit(\n        model,\n        max_lm_iterations=max_lm_iterations,\n        param_tolerance=param_tolerance,\n        verbose=verbose,\n    )\n\n    if verbose is True and covariances_defined is True:\n        confidence_interval = 0.9\n        v_extreme = nonlinear_fitting.extreme_values(\n            model.weighted_residuals, confidence_interval\n        )\n        confidence_bound, indices, probabilities = v_extreme\n        if indices != []:\n            print(\n                \"The function nonlinear_fitting.extreme_values\"\n                \"(model.weighted_residuals, confidence_interval) \"\n                f\"has determined that there are {len(indices):d} \"\n                \"data points which have residuals which are not \"\n                f\"expected at the {confidence_interval*100.:.1f}% \"\n                \"confidence level \"\n                f\"(> {confidence_bound:.1f} s.d. away from the model fit).\\n\"\n                \"Their indices and the probabilities of \"\n                \"finding such extreme values are:\"\n            )\n            for i, idx in enumerate(indices):\n                print(\n                    f\"[{idx:d}]: {probabilities[i]:.4f} \"\n                    f\"({np.abs(model.weighted_residuals[idx]):.1f} s.d. \"\n                    \"from the model)\"\n                )\n            print(\n                \"You might consider removing them from your fit, \"\n                \"or increasing the uncertainties in \"\n                \"their measured values.\\n\"\n            )\n\n    return model",
  "def __init__(\n        self,\n        mineral,\n        data,\n        data_covariances,\n        flags,\n        fit_params,\n        mle_tolerances,\n        delta_params=None,\n        bounds=None,\n    ):\n        self.m = mineral\n        self.data = data\n        self.data_covariances = data_covariances\n        self.flags = flags\n        self.fit_params = fit_params\n        self.mle_tolerances = mle_tolerances\n        if delta_params is None:\n            self.delta_params = self.get_params() * 1.0e-5 + 1.0e-10\n        else:\n            self.delta_params = delta_params\n        self.bounds = bounds",
  "def set_params(self, param_values):\n        i = 0\n\n        if self.bounds is not None:\n            param_values = np.clip(param_values, self.bounds[:, 0], self.bounds[:, 1])\n\n        for param in self.fit_params:\n            if isinstance(self.m.params[param], float):\n                self.m.params[param] = param_values[i]\n                i += 1\n            else:\n                for j in range(len(self.m.params[param])):\n                    self.m.params[param][j] = param_values[i]\n                    i += 1",
  "def get_params(self):\n        params = []\n        for i, param in enumerate(self.fit_params):\n            params.append(self.m.params[param])\n        return np.array(flatten([self.m.params[prm] for prm in self.fit_params]))",
  "def function(self, x, flag):\n        P, T, p = x\n        self.m.set_state(P, T)\n        return np.array([P, T, getattr(self.m, flag)])",
  "def normal(self, x, flag):\n        P, T, p = x\n\n        if flag == \"V\":\n            self.m.set_state(P, T)\n            dPdp = -self.m.K_T / self.m.V\n            dpdT = self.m.alpha * self.m.V\n        elif flag == \"H\":\n            self.m.set_state(P, T)\n            dPdp = 1.0 / ((1.0 - T * self.m.alpha) * self.m.V)\n            dpdT = self.m.molar_heat_capacity_p\n        elif flag == \"S\":\n            self.m.set_state(P, T)\n            dPdp = -1.0 / (self.m.alpha * self.m.V)\n            dpdT = self.m.molar_heat_capacity_p / T\n        elif flag == \"gibbs\":\n            self.m.set_state(P, T)\n            dPdp = 1.0 / self.m.V\n            dpdT = -self.m.S\n        else:\n            dP = 1.0e5\n            dT = 1.0\n            dPdp = (2.0 * dP) / (\n                self.function([P + dP, T, 0.0], flag)[2]\n                - self.function([P - dP, T, 0.0], flag)[2]\n            )\n            dpdT = (\n                self.function([P, T + dT, 0.0], flag)[2]\n                - self.function([P, T - dT, 0.0], flag)[2]\n            ) / (2.0 * dT)\n        dPdT = -dPdp * dpdT\n        n = np.array([-1.0, dPdT, dPdp])\n        return unit_normalize(n)",
  "def __init__(\n        self,\n        solution,\n        data,\n        data_covariances,\n        flags,\n        fit_params,\n        mle_tolerances,\n        delta_params=None,\n        bounds=None,\n    ):\n        self.m = solution\n        self.data = data\n        self.data_covariances = data_covariances\n        self.flags = flags\n        self.fit_params = fit_params\n        self.fit_params_strings = []\n        for p in fit_params:\n            if isinstance(p, list):\n                csv_list_mbrs = \",\".join([str(i) for i in p[1:]])\n                self.fit_params_strings.append(f\"{p[0]} ({csv_list_mbrs})\")\n            else:\n                self.fit_params_strings.append(p)\n\n        self.mle_tolerances = mle_tolerances\n        if delta_params is None:\n            self.delta_params = self.get_params() * 1.0e-5 + 1.0e-10\n        else:\n            self.delta_params = delta_params\n        self.bounds = bounds",
  "def set_params(self, param_values):\n        # fit_params is a list of lists\n        # if the list has length 2, the first item should be an integer\n        # indicating the endmember number in the solution\n        # if the list has length 3, the first two items should be endmember\n        # numbers, and the third should be the interaction parameter type\n        # (E, S or V).\n        i = 0\n\n        if self.bounds is not None:\n            param_values = np.clip(param_values, self.bounds[:, 0], self.bounds[:, 1])\n\n        for param in self.fit_params:\n            value = param_values[i]\n            if len(param) == 2:\n                key, imbr = param\n                if isinstance(self.m.endmembers[imbr][0].params[key], float):\n                    self.m.endmembers[imbr][0].params[key] = value\n                    i += 1\n                else:\n                    n_values = len(self.m.endmembers[imbr][0].params[key])\n                    for j in range(n_values):\n                        self.m.endmembers[imbr][0].params[key][j] = value\n                        i += 1\n            elif len(param) == 3:\n                key, imbr, jmbr = param\n                ai = self.m.solution_model.alphas[imbr]\n                aj = self.m.solution_model.alphas[jmbr]\n                if key == \"E\":\n                    self.m.solution_model.We[imbr, jmbr] = 2.0 * value / (ai * aj)\n                if key == \"S\":\n                    self.m.solution_model.Ws[imbr, jmbr] = 2.0 * value / (ai * aj)\n                if key == \"V\":\n                    self.m.solution_model.Wv[imbr, jmbr] = 2.0 * value / (ai * aj)\n\n                i += 1\n            else:\n                raise Exception(\"param length must be two or three\")",
  "def get_params(self):\n        params = []\n        for param in self.fit_params:\n            if len(param) == 2:\n                key, imbr = param\n                value = self.m.endmembers[imbr][0].params[key]\n                if isinstance(value, float):\n                    params.append(value)\n                else:\n                    params.extend(list(value))\n\n            elif len(param) == 3:\n                key, imbr, jmbr = param\n                ai = self.m.solution_model.alphas[imbr]\n                aj = self.m.solution_model.alphas[jmbr]\n                if key == \"E\":\n                    params.append(\n                        self.m.solution_model.We[imbr, jmbr] * (ai * aj) / 2.0\n                    )\n                if key == \"S\":\n                    params.append(\n                        self.m.solution_model.Ws[imbr, jmbr] * (ai * aj) / 2.0\n                    )\n                if key == \"V\":\n                    params.append(\n                        self.m.solution_model.Wv[imbr, jmbr] * (ai * aj) / 2.0\n                    )\n            else:\n                raise Exception(\"param length must be two or three\")\n        return np.array(params)",
  "def function(self, x, flag):\n        self.m.set_composition(x[: self.m.n_endmembers])\n        P, T, p = x[self.m.n_endmembers :]\n        self.m.set_state(P, T)\n\n        f = np.copy(x)\n        f[-1] = getattr(self.m, flag)\n        return f",
  "def normal(self, x, flag):\n        self.m.set_composition(x[: self.m.n_endmembers])\n        P, T, p = x[self.m.n_endmembers :]\n\n        if flag == \"V\":\n            self.m.set_state(P, T)\n            dPdp = -self.m.K_T / self.m.V\n            dpdT = self.m.alpha * self.m.V\n        elif flag == \"H\":\n            self.m.set_state(P, T)\n            dPdp = 1.0 / ((1.0 - T * self.m.alpha) * self.m.V)\n            dpdT = self.m.molar_heat_capacity_p\n        elif flag == \"S\":\n            self.m.set_state(P, T)\n            dPdp = -1.0 / (self.m.alpha * self.m.V)\n            dpdT = self.m.molar_heat_capacity_p / T\n        elif flag == \"gibbs\":\n            self.m.set_state(P, T)\n            dPdp = 1.0 / self.m.V\n            dpdT = -self.m.S\n        else:\n            dP = 1.0e5\n            dT = 1.0\n            xP0 = np.copy(x)\n            xP1 = np.copy(x)\n            xT0 = np.copy(x)\n            xT1 = np.copy(x)\n            xP0[-3] = xP1[-3] - dP\n            xP1[-3] = xP1[-3] + dP\n            xT0[-2] = xP1[-2] - dT\n            xT1[-2] = xP1[-2] + dT\n\n            dPdp = (2.0 * dP) / (\n                self.function(xP1, flag)[2] - self.function(xP0, flag)[2]\n            )\n            dpdT = (self.function(xT1, flag)[2] - self.function(xT0, flag)[2]) / (\n                2.0 * dT\n            )\n        dPdT = -dPdp * dpdT\n        n = np.zeros(len(x))\n        n[-3:] = np.array([-1.0, dPdT, dPdp])\n        return unit_normalize(n)",
  "class DummyCompositionSolution(Solution):\n    \"\"\"\n    This is a dummy base class for a solution object to\n    facilitate composition fitting when no solution model has\n    been prepared. The model is initialized with appropriate\n    chemical formulae for each endmember, and can do all basic\n    compositional processing that doesn't involve any material\n    properties.\n\n    :param endmember_element_formulae: Formulae for each of the independent endmembers.\n        e.g. ['Mg2SiO4', 'Fe2SiO4'].\n    :type endmember_element_formulae: list of str\n    :param endmember_site_formulae: Site formulae for each of the independent endmembers,\n        in the same order as endmember_element_formulae. e.g. ['[Mg]2SiO4', '[Fe]2SiO4'].\n    :type endmember_site_formulae: list of str\n    \"\"\"\n\n    def __init__(self, endmember_element_formulae, endmember_site_formulae):\n        self.endmember_formulae = [\n            dictionarize_formula(f) for f in endmember_element_formulae\n        ]\n        self.solution_model = type(\n            \"Dimension\", (object,), {\"formulas\": endmember_site_formulae}\n        )()\n        self.solution_model.endmembers = [None for f in endmember_site_formulae]\n        process_solution_chemistry(self.solution_model)",
  "def fit_composition_to_solution(\n    solution,\n    fitted_variables,\n    variable_values,\n    variable_covariances,\n    variable_conversions=None,\n    normalize=True,\n):\n    \"\"\"\n    Takes a Solution object and a set of variable names and\n    associates values and covariances and finds the molar fractions of the\n    solution which provide the best fit (in a least-squares sense)\n    to the variable values.\n\n    The fitting applies appropriate non-negativity constraints\n    (i.e. no species can have a negative occupancy on a site).\n\n    :param solution: The solution to use in the fitting procedure.\n    :type solution: :class:`burnman.Solution`\n\n    :param fitted_variables: A list of the variables used to find the best-fit\n        molar fractions of the solution. These should either be elements\n        such as \"Fe\", site_species such as \"Fef_B\" which would correspond to a\n        species labelled Fef on the second site,\n        or user-defined variables which are arithmetic sums of\n        elements and/or site_species defined in \"variable_conversions\".\n    :type fitted_variables: list of str\n\n    :param variable_values: Numerical values of the fitted variables.\n        These should be given as amounts; they do not need to be normalized.\n    :type variable_values: numpy.array\n\n    :param variable_covariances: Covariance matrix of the variables.\n    :type variable_covariances: 2D numpy.array\n\n    :param variable_conversions: A dictionary converting any user-defined variables\n        into an arithmetic sum of element and site-species amounts. For example,\n        {'Mg_equal': {'Mg_A': 1., 'Mg_B': -1.}}, coupled with Mg_equal = 0\n        would impose a constraint that the amount of Mg would be equal on\n        the first and second site in the solution.\n    :type variable_conversions: dict of dict, or None\n\n    :param normalize: If True, normalizes the optimized molar fractions to sum to unity.\n    :type normalize: bool\n\n    :returns: Optimized molar fractions, corresponding covariance matrix and the\n        weighted residual.\n    :rtype: tuple of 1D numpy.array, 2D numpy.array and float\n    \"\"\"\n\n    solution_variables = deepcopy(solution.elements)\n    solution_variables.extend(solution.solution_model.site_names)\n\n    solution_matrix = np.hstack(\n        (solution.stoichiometric_matrix, solution.solution_model.endmember_noccupancies)\n    )\n\n    n_vars = len(fitted_variables)\n    n_mbrs, n_sol_vars = solution_matrix.shape\n\n    if variable_conversions is not None:\n        solution_matrix = np.hstack(\n            (\n                solution_matrix,\n                np.zeros((solution_matrix.shape[0], len(variable_conversions))),\n            )\n        )\n\n        for i, (new_var, conversion_dict) in enumerate(variable_conversions.items()):\n            assert new_var not in solution_variables\n            solution_variables.append(new_var)\n\n            for var in conversion_dict.keys():\n                solution_matrix[:, n_sol_vars + i] += solution_matrix[\n                    :, solution_variables.index(var)\n                ]\n\n    # Now, construct A using the fitted variables\n    A = np.zeros((n_vars, solution_matrix.shape[0]))\n    for i, var in enumerate(fitted_variables):\n        A[i, :] = solution_matrix[:, solution_variables.index(var)]\n\n    b = variable_values\n    Cov_b = variable_covariances\n\n    # Define the constraints\n    # Ensure that element abundances / site occupancies\n    # are exactly equal to zero if the user specifies that\n    # they are equal to zero.\n    S, S_index = np.unique(A, axis=0, return_index=True)\n    S = np.array(\n        [\n            s\n            for i, s in enumerate(S)\n            if np.abs(b[S_index[i]]) < 1.0e-10 and any(np.abs(s) > 1.0e-10)\n        ]\n    )\n    equality_constraints = [S, np.zeros(len(S))]\n\n    # Ensure all site occupancies are non-negative\n    T = np.array(\n        [\n            -t\n            for t in np.unique(solution.solution_model.endmember_occupancies.T, axis=0)\n            if any(np.abs(t) > 1.0e-10)\n        ]\n    )\n    inequality_constraints = [T, np.zeros(len(T))]\n\n    popt, pcov, res = weighted_constrained_least_squares(\n        A, b, Cov_b, equality_constraints, inequality_constraints\n    )\n\n    if normalize:\n        sump = sum(popt)\n        popt /= sump\n        pcov /= sump * sump\n        res /= sump\n\n    # Convert the variance-covariance matrix from endmember amounts to\n    # endmember proportions\n    dpdx = (np.eye(n_mbrs) - popt).T  # = (1. - p[i] if i == j else -p[i])\n    pcov = dpdx.dot(pcov).dot(dpdx.T)\n    return (popt, pcov, res)",
  "def fit_phase_proportions_to_bulk_composition(phase_compositions, bulk_composition):\n    \"\"\"\n    Performs weighted constrained least squares on a set of phase compositions\n    to find the amount of those phases that best-fits a given bulk composition.\n\n    The fitting applies appropriate non-negativity constraints\n    (i.e. no phase can have a negative abundance in the bulk).\n\n    :param phase_compositions: The composition of each phase.\n        Can be in weight or mole amounts.\n    :type phase_compositions: 2D numpy.array\n\n    :param bulk_composition: The bulk composition of the composite.\n        Must be in the same units as the phase compositions.\n    :type bulk_composition: numpy.array\n\n    :returns: Optimized molar fractions, corresponding covariance matrix and the\n        weighted residual.\n    :rtype: tuple of 1D numpy.array, 2D numpy.array and float\n    \"\"\"\n\n    n_phases = len(phase_compositions[0])\n    inequality_constraints = [-np.eye(n_phases), np.zeros(n_phases)]\n    popt, pcov, res = weighted_constrained_least_squares(\n        phase_compositions, bulk_composition, None, None, inequality_constraints\n    )\n    return (popt, pcov, res)",
  "def __init__(self, endmember_element_formulae, endmember_site_formulae):\n        self.endmember_formulae = [\n            dictionarize_formula(f) for f in endmember_element_formulae\n        ]\n        self.solution_model = type(\n            \"Dimension\", (object,), {\"formulas\": endmember_site_formulae}\n        )()\n        self.solution_model.endmembers = [None for f in endmember_site_formulae]\n        process_solution_chemistry(self.solution_model)",
  "def solve_constraint_lagrangian(x, jac_x, c_x, c_prime):\n    \"\"\"\n    Function which solves the problem\n    minimize || J.dot(x_mod - x) ||\n    subject to C(x_mod) = 0\n    via the method of Lagrange multipliers.\n\n    :param x: Parameter values at x.\n    :type x: 1D numpy array\n\n    :param jac_x: The (estimated, approximate or exact) value of the Jacobian J(x).\n    :type jac_x: 2D numpy array.\n\n    :param c_x: Values of the constraints at x.\n    :type c_x: 1D numpy array\n\n    :param c_prime: The Jacobian of the constraints (A, where A.x + b = 0).\n    :type c_prime: 2D array of floats\n\n    :returns: An array containing the parameter values which minimize the L2-norm\n        of any function which has the Jacobian jac_x, and another array containing\n        the multipliers for each of the equality constraints.\n    :rtype: tuple\n    \"\"\"\n    n_x = len(x)\n    n = n_x + len(c_x)\n    A = np.zeros((n, n))\n    b = np.zeros(n)\n\n    JTJ = jac_x.T.dot(jac_x)\n    A[:n_x, :n_x] = JTJ / np.linalg.norm(JTJ) * n * n  # includes scaling\n    A[:n_x, n_x:] = c_prime.T\n    A[n_x:, :n_x] = c_prime\n    b[n_x:] = c_x\n\n    luA = lu_factor(A)\n    dx_m = lu_solve(luA, -b)  # lu_solve computes the solution of ax = b\n\n    x_mod = x + dx_m[:n_x]\n    lagrange_multipliers = dx_m[n_x:]\n    return (x_mod, lagrange_multipliers)",
  "def damped_newton_solve(\n    F,\n    J,\n    guess,\n    tol=1.0e-6,\n    max_iterations=100,\n    lambda_bounds=lambda dx, x: (1.0e-8, 1.0),\n    linear_constraints=(0.0, np.array([-1.0])),\n    store_iterates=False,\n):\n    \"\"\"\n    Solver for the multivariate nonlinear system F(x)=0\n    with Jacobian J(x), using the damped affine invariant modification\n    to Newton's method (Deuflhard, 1974;1975;2004).\n    Here we follow the algorithm as described in Nowak and Weimann (1991):\n    [Technical Report TR-91-10, Algorithm B], modified to accept\n    linear inequality constraints.\n\n    Linear inequality constraints are provided by the arrays constraints_A and\n    constraints_b. The constraints are satisfied if A*x + b <= 0.\n    If any constraints are not satisfied by the current\n    value of lambda, lambda is reduced to satisfy all the constraints.\n\n    If a current iterate starting point (x_i) lies on one or more constraints\n    and the Newton step violates one or more of those constraints, then\n    the next step is calculated via the method of Lagrangian multipliers,\n    minimizing the L2-norm of F(x_i+1) subject to the violated constraints.\n\n    Successful termination of the solver is based on three criteria:\n        - all(np.abs(dx (simplified newton step) < tol))\n        - all(np.abs(dx (full Newton step) < sqrt(10*tol))) (avoids pathology) and\n        - lambda = lambda_bounds(dx, x)[1] (lambda = 1 for a full Newton step).\n\n    If these criteria are not satisfied, iterations continue until one of the following\n    occurs:\n        - the value of lmda is reduced to its minimum value (for v. nonlinear problems)\n        - successive iterations have descent vectors which violate the constraints\n        - the maximum number of iterations (given by max_iterations) is reached.\n\n    Information on the root (or lack of root) obtained by the solver is provided\n    in the returned namedtuple.\n\n    :param F: Function returning the system function F(x) as a 1D numpy array.\n    :type F: function of x\n\n    :param J: Function returning the Jacobian function J(x) as a 2D numpy array.\n    :type J: function of x\n\n    :param guess: Starting guess for the solver.\n    :type guess: 1D numpy.array\n\n    :param tol: Tolerance(s) for termination.\n    :type tol: float or array of floats\n\n    :param max_iterations: Maximum number of iterations for the solver.\n    :type max_iterations: int\n\n    :param lambda_bounds: A function of dx and x that returns\n        a tuple of floats corresponding to the minimum and maximum\n        allowed fractions of the full newton step (dx).\n    :type lambda bounds: function of dx and x\n\n    :param linear_constraints: tuple of a 2D numpy array (A) and 1D numpy array (b)\n        Constraints are satisfied if A.x + b < eps\n    :type linear_constraints: tuple of a 2D numpy.array (A) and 1D numpy.array (b)\n\n    :returns: A namedtuple with the following attributes:\n\n        - x: The solution vector [1D numpy array].\n        - F: The evaluated function F(x) [1D numpy array].\n        - F_norm: Euclidean norm of F(x) [float].\n        - J: The evaluated Jacobian J(x) [2D numpy array].\n        - n_it: Number of iterations [int].\n        - code: Numerical description of the solver termination [int].\n            - 0: Successful convergence\n            - 1: Failure due to solver hitting lower lambda bound\n            - 2: Failure due to descent vector crossing constraints\n            - 3: Failure due to solver reaching maximum number of iterations\n        - text: Description of the solver termination [str].\n        - success: Solver convergence state [bool].\n        - iterates: [namedtuple]\n            Only present if store_iterates=True\n            Includes the following attributes:\n                - x: list of 1D numpy arrays of floats\n                    The parameters for each iteration\n                - F: list of 2D numpy arrays of floats\n                    The function for each iteration\n                - lmda: list of floats\n                    The value of the damping parameter for each iteration\n    :rtype: namedtuple\n    \"\"\"\n\n    # Make sure damping factor is within bounds, and that the bounds are reasonable\n    # Problem classes in Nowak and Weimann (1991); [lmda_min, lmda_max]:\n    # linear: [0.1, 1.]\n    # mildly nonlinear: [1.e-4, 1.]\n    # highly nonlinear: [1.e-2, 1.e-4]\n    # extremely nonlinear: [1.e-4, 1.e-8]\n    eps = 2.0 * np.finfo(float).eps\n\n    def update_lmda(x, dx, h, lmda_bounds):\n        assert (\n            lmda_bounds[1] < 1.0 + eps\n        ), \"The highest upper bound for lambda is 1. (a full Newton step)\"\n        assert (\n            lmda_bounds[0] > 1.0e-8 - eps\n        ), \"The lowest lower bound for lambda is 1.e-8 (suitable only for extremely nonlinear systems)\"\n\n        lmda_j = min(1.0 / (h + eps), lmda_bounds[1])  # this is lmda_j^0\n        return max(lmda_j, lmda_bounds[0])\n\n    def constraints(x):\n        return np.dot(linear_constraints[0], x) + linear_constraints[1]\n\n    assert np.all(\n        constraints(guess) < eps\n    ), \"The starting guess is outside the supplied constraints.\"\n\n    if not isinstance(tol, float):\n        assert len(tol) < len(\n            guess\n        ), \"tol must either be a float or an array like guess.\"\n\n    sol = namedtuple(\n        \"Solution\", [\"x\", \"n_it\", \"F\", \"F_norm\", \"J\", \"code\", \"text\", \"success\"]\n    )\n\n    # evaluate system\n    sol.x = guess\n    sol.F = F(sol.x)\n\n    if store_iterates:\n        sol.iterates = namedtuple(\"iterates\", [\"x\", \"F\", \"lmda\"])\n        sol.iterates.x = [sol.x]\n        sol.iterates.F = [sol.F]\n        sol.iterates.lmda = [0.0]\n\n    # Begin Newton loop\n\n    # Some dummy variables for the first h calculation (h = 0)\n    lmda = 0.0\n    dxprev = [1.0]\n    dxbar = [1.0]\n\n    sol.n_it = 0\n    n_constraints = len(constraints(sol.x))\n    minimum_lmda = False\n    converged = False\n    persistent_bound_violation = False\n    while (\n        sol.n_it < max_iterations\n        and not minimum_lmda\n        and not persistent_bound_violation\n        and not converged\n    ):\n        sol.J = J(sol.x)  # evaluate Jacobian\n        luJ = lu_factor(sol.J)  # storing the factorisation saves time later\n        dx = lu_solve(luJ, -sol.F)  # compute ordinary Newton step\n        dx_norm = np.linalg.norm(dx, ord=2)\n        lmda_bounds = lambda_bounds(dx, sol.x)\n        h = (\n            lmda\n            * np.linalg.norm((dxbar - dx), ord=2)\n            * dx_norm\n            / (np.linalg.norm(dxprev, ord=2) * np.linalg.norm(dxbar, ord=2))\n        )\n        lmda = update_lmda(sol.x, dx, h, lmda_bounds)\n\n        # Create the (k+1)^0 values\n        x_j = sol.x + lmda * dx\n\n        # Check that all constraints are satisfied. If not, adjust lambda.\n        # This must be done just before every call to F() *if* lambda\n        # has been increased:\n        c_x_j = constraints(x_j)\n        if not np.all(\n            c_x_j < eps\n        ):  # x allowed to lie on constraints but not in forbidden area\n            c_x = constraints(sol.x)\n            violated_constraints = sorted(\n                [\n                    (i, c_x[i] / (c_x[i] - c_x_j[i]))\n                    for i in range(n_constraints)\n                    if c_x_j[i] >= eps\n                ],\n                key=lambda x: x[1],\n            )\n            lmda = lmda * violated_constraints[0][1]\n            x_j = sol.x + lmda * dx\n\n        # If the same current iterate is on a constraint,\n        # and a very small lambda causes the next iterate to leave the\n        # feasible region, then a new step direction must be found,\n        # along with a new guess for lmda\n        # We do this here using Lagrange multipliers\n        if lmda < eps:\n            active_constraint_indices = [\n                i for i, vc in violated_constraints if vc < eps\n            ]\n            inactive_constraint_indices = [\n                i for i, vc in violated_constraints if vc >= eps\n            ]\n            c_newton = constraints(sol.x + dx)[active_constraint_indices]\n            c_A = linear_constraints[0][active_constraint_indices]\n            x_n = sol.x + dx  # newton iterate\n            if np.linalg.matrix_rank(c_A) == len(\n                dx\n            ):  # if true, we must leave a constraint here\n                n_act = len(active_constraint_indices)\n                for i_rm in range(n_act):\n                    potential_active_indices = [\n                        active_constraint_indices[i] for i in range(n_act) if i != i_rm\n                    ]\n                    c_newton = constraints(sol.x + dx)[potential_active_indices]\n                    c_A = linear_constraints[0][potential_active_indices]\n                    x_m = solve_constraint_lagrangian(x_n, sol.J, c_newton, c_A)[0]\n                    if constraints(x_m)[active_constraint_indices[i_rm]] < 0.0:\n                        break\n            else:\n                x_m = solve_constraint_lagrangian(x_n, sol.J, c_newton, c_A)[0]\n\n            dx = x_m - sol.x\n            lmda_bounds = lambda_bounds(dx, sol.x)\n            lmda = lmda_bounds[1]  # no a-priori maximum limit\n            x_j = sol.x + lmda * dx\n\n            # Check that the solution is still able to converge, i.e.\n            # that the constraints aren't stopping our approach to a potential root\n            x_j_min = (\n                sol.x + lmda_bounds[0] * dx\n            )  # because lmda must be getting smaller, no need to check constraints\n            F_j_min = F(x_j_min)\n            dxbar_j_min = lu_solve(luJ, -F_j_min)\n            dxbar_j_min_norm = np.linalg.norm(dxbar_j_min, ord=2)\n\n            # Newton step size must be decreasing and dx must be non-zero\n            if dxbar_j_min_norm > dx_norm or np.linalg.norm(dx, ord=2) < eps:\n                persistent_bound_violation = True\n\n            # Now we need to check for newly violated constraints\n            n_inactive = len(inactive_constraint_indices)\n            c_x_j = constraints(x_j)[inactive_constraint_indices]\n            if not np.all(\n                c_x_j < eps\n            ):  # x allowed to lie on constraints but not in forbidden area\n                c_x = constraints(sol.x)[inactive_constraint_indices]\n                violated_constraints = sorted(\n                    [\n                        (i, c_x[i] / (c_x[i] - c_x_j[i]))\n                        for i in range(n_inactive)\n                        if c_x_j[i] >= eps\n                    ],\n                    key=lambda x: x[1],\n                )\n                lmda = lmda * violated_constraints[0][1]\n                x_j = sol.x + lmda * dx\n\n        F_j = F(x_j)\n        dxbar_j = lu_solve(luJ, -F_j)  # this is the simplified newton step\n        dxbar_j_norm = np.linalg.norm(dxbar_j, ord=2)\n\n        if (\n            all(np.abs(dxbar_j) < tol)  # <- Success requirements\n            and all(np.abs(dx) < np.sqrt(10.0 * tol))  # <- avoids pathological cases\n            and np.abs(lmda - lmda_bounds[1]) < eps\n        ):  # <- end on a maximal newton step\n            require_posteriori_loop = False  # <- No need for the a posteriori loop\n            converged = True  # <- Successful convergence\n        else:\n            require_posteriori_loop = True\n\n        # Begin the a posteriori loop\n        while (\n            require_posteriori_loop\n            and not minimum_lmda\n            and not persistent_bound_violation\n        ):\n            # Monotonicity check\n            # always based on the Newton step, even if on a constraint\n            if dxbar_j_norm <= dx_norm:\n                if (\n                    dxbar_j_norm < eps\n                ):  # <- occasionally the simplified newton step finds the exact solution\n                    converged = True\n                dxbar = dxbar_j\n                sol.x = x_j\n                sol.F = F_j\n\n                require_posteriori_loop = False  # return to Newton step\n                sol.n_it += 1  # move to next iteration\n                dxprev = dx  # to calculate the next value of h\n            else:\n                if np.abs(lmda - lmda_bounds[0]) < eps:\n                    minimum_lmda = True\n                h_j = (\n                    (2.0 / lmda)\n                    * np.linalg.norm((dxbar_j - (1.0 - lmda) * dx), ord=2)\n                    / dx_norm\n                )\n                lmda_j = min(lmda_bounds[1], 1.0 / h_j)\n                lmda = min(lmda_j, lmda / 2.0)\n                lmda = max(\n                    lmda, lmda_bounds[0]\n                )  # allows a check of monotonicity once at minimum lmda\n\n                x_j = (\n                    sol.x + lmda * dx\n                )  # because lmda must be getting smaller, no need to check constraints\n                F_j = F(x_j)\n                dxbar_j = lu_solve(luJ, -F_j)\n                dxbar_j_norm = np.linalg.norm(dxbar_j, ord=2)\n\n        if store_iterates:\n            sol.iterates.x.append(sol.x)\n            sol.iterates.F.append(sol.F)\n            sol.iterates.lmda.append(lmda)\n\n    if converged and not persistent_bound_violation:\n        sol.x = x_j + dxbar_j\n        # Even if the solver succeeds, there may be a small chance\n        # that the last simplified Newton step\n        # shifts the solution just outside the constraints.\n        # If so, shift the solution back to the allowed region\n        c_x = constraints(sol.x)\n        if not np.all(\n            c_x <= 0.0\n        ):  # x allowed to lie on constraints but not in forbidden area\n            sol.x -= dxbar_j\n\n    sol.F = F(sol.x)\n    sol.F_norm = np.linalg.norm(sol.F, ord=2)\n    sol.J = J(sol.x)\n\n    if store_iterates:\n        sol.iterates.x = np.array(sol.iterates.x)\n        sol.iterates.F = np.array(sol.iterates.F)\n\n    sol.success = False\n    if converged:\n        sol.success = True\n        sol.code = 0\n        sol.text = \"The solver successfully found a root after {0} iterations\".format(\n            sol.n_it\n        )\n    elif minimum_lmda:\n        sol.code = 1\n        sol.text = \"The function is too non-linear for lower lambda bound ({0})\".format(\n            lmda_bounds[0]\n        )\n    elif persistent_bound_violation:\n        sol.code = 2\n        sol.text = \"The descent vector crosses the constraints with the following indices: {0}\".format(\n            [i for i, lmda in violated_constraints]\n        )\n    elif sol.n_it == max_iterations:\n        sol.code = 3\n        sol.text = \"The solver reached max_iterations ({0})\".format(max_iterations)\n    else:\n        raise Exception(\"Unknown termination of solver\")\n    return sol",
  "def update_lmda(x, dx, h, lmda_bounds):\n        assert (\n            lmda_bounds[1] < 1.0 + eps\n        ), \"The highest upper bound for lambda is 1. (a full Newton step)\"\n        assert (\n            lmda_bounds[0] > 1.0e-8 - eps\n        ), \"The lowest lower bound for lambda is 1.e-8 (suitable only for extremely nonlinear systems)\"\n\n        lmda_j = min(1.0 / (h + eps), lmda_bounds[1])  # this is lmda_j^0\n        return max(lmda_j, lmda_bounds[0])",
  "def constraints(x):\n        return np.dot(linear_constraints[0], x) + linear_constraints[1]",
  "def nonlinear_least_squares_fit(\n    model, lm_damping=0.0, param_tolerance=1.0e-7, max_lm_iterations=100, verbose=False\n):\n    \"\"\"\n    Function to compute the \"best-fit\" parameters for a model\n    by nonlinear least squares fitting.\n\n    The nonlinear least squares algorithm closely follows the logic in\n    Section 23.1 of Bayesian Probability Theory\n    (von der Linden et al., 2014; Cambridge University Press).\n\n    Parameters\n    ----------\n    :param model: Model containing data to be fit, and functions to\n        aid in fitting.\n    :type model: object\n\n    :param lm_damping: Levenberg-Marquardt parameter for least squares minimization.\n    :type lm_damping: float\n\n    :param param_tolerance: Levenberg-Marquardt iterations are terminated when\n        the maximum fractional change in any of the parameters\n        during an iteration drops below this value\n    :type param_tolerance: float\n\n\n    :param max_lm_iterations: Maximum number of Levenberg-Marquardt iterations\n    :type max_lm_iterations: int\n\n    :param verbose: Print some information to standard output\n    :type verbose: bool\n\n    .. note:: The object passed as model must have the following attributes:\n        * data [2D numpy.array] - Elements of x[i][j] contain the\n            observed position of data point i.\n        * data_covariances [3D numpy.array] Elements of cov[i][j][k] contain\n            the covariance matrix of data point i.\n        * mle_tolerances [numpy.array] - The iterations to find the maximum likelihood\n            estimator for each observed data point will stop when mle_tolerances[i] <\n            np.linalg.norm(data_mle[i] - model.function(data_mle[i], flag))\n        * delta_params [numpy.array] - parameter perturbations used to compute the jacobian\n\n        Must also have the following methods:\n        * set_params(self, param_values) -  Function to set parameters.\n        * get_params(self) - Function to get current model parameters.\n        * function(self, x) - Returns value of model function evaluated at x.\n        * normal(self, x) - Returns value of normal to the model function evaluated at x.\n\n        After this function has been performed, the following attributes are added to model:\n\n        * n_dof [int] - Degrees of freedom of the system.\n        * data_mle [2D numpy array] - Maximum likelihood estimates of the observed data points\n            on the best-fit curve.\n        * jacobian [2D numpy array] - d(weighted_residuals)/d(parameter).\n        * weighted_residuals [numpy array] - Weighted residuals.\n        * weights [numpy array] - 1/(data variances normal to the best fit curve).\n        * WSS [float] - Weighted sum of squares residuals.\n        * popt [numpy array] - Optimized parameters.\n        * pcov [2D numpy array] - Covariance matrix of optimized parameters.\n        * noise_variance [float] - Estimate of the variance of the data normal to the curve.\n\n    This function is available as ``burnman.nonlinear_least_squares_fit``.\n    \"\"\"\n\n    def _mle_estimate(x, x_m, cov, flag):\n        n = model.normal(x_m, flag)\n        var_n = abs_line_project(cov, n)\n        d = (x_m - x).dot(n)\n        x_mle = x + d * ((n.dot(cov)).T) / var_n\n        return x_mle, d, var_n\n\n    def _find_mle():\n        x_mle_arr = np.empty_like(model.data)\n        residual_arr = np.empty(n_data)\n        var_arr = np.empty(n_data)\n        for i, (x, cov, flag) in enumerate(\n            zip(*[model.data, model.data_covariances, model.flags])\n        ):\n            x_mle_arr[i] = model.function(x, flag)\n            x_mle_est, residual_arr[i], var_arr[i] = _mle_estimate(\n                x, x_mle_arr[i], cov, flag\n            )\n            delta_x = x_mle_arr[i] - x\n\n            while np.linalg.norm(delta_x) > model.mle_tolerances[i]:\n                x_mle_est, residual_arr[i], var_arr[i] = _mle_estimate(\n                    x, x_mle_arr[i], cov, flag\n                )\n                x_mle_arr[i] = model.function(x_mle_est, flag)\n                delta_x = x_mle_arr[i] - x_mle_est\n\n        return x_mle_arr, residual_arr / np.sqrt(var_arr), 1.0 / var_arr\n\n    def calculate_jacobian():\n        model.jacobian = np.empty((n_data, n_params))\n        diag_delta = np.diag(model.delta_params)\n        param_values = model.get_params()\n        for prm_i, value in enumerate(param_values):\n            model.set_params(param_values - diag_delta[prm_i])\n            x_mle_arr, residual_arr_0, weights_0 = _find_mle()\n\n            model.set_params(param_values + diag_delta[prm_i])\n            x_mle_arr, residual_arr_1, weights_1 = _find_mle()\n\n            model.jacobian[:, prm_i] = (residual_arr_1 - residual_arr_0) / (\n                2.0 * diag_delta[prm_i][prm_i]\n            )\n        model.set_params(param_values)  # reset params\n\n    def _update_beta(lmbda):\n        # Performs a Levenberg-Marquardt iteration\n        # Note that if lambda = 0, this is a simple Gauss-Newton iteration\n        calculate_jacobian()\n        model.data_mle, model.weighted_residuals, model.weights = _find_mle()\n\n        J = model.jacobian  # this the weighted Jacobian\n        JTJ = J.T.dot(J)\n        delta_beta = (\n            np.linalg.inv(JTJ + lmbda * np.diag(JTJ))\n            .dot(J.T)\n            .dot(model.weighted_residuals)\n        )\n        old_params = np.copy(model.get_params())\n        new_params = old_params - delta_beta\n        # f_delta_beta = delta_beta/new_params\n\n        model.set_params(new_params)\n\n        # set_params may modify the step to satisfy bounds on the problem\n        # We therefore need to get the params before\n        # calculating the fractional change.\n        new_params = model.get_params()\n\n        # In case the new_params object returns a very small value,\n        # modify to avoid a pointless comparison:\n        mod_params = np.where(\n            np.abs(new_params) < param_tolerance, param_tolerance, new_params\n        )\n        f_delta_beta = (old_params - new_params) / mod_params\n        return f_delta_beta\n\n    n_data = len(model.data)\n    params = model.get_params()\n    n_params = len(params)\n    model.dof = n_data - n_params\n\n    if not hasattr(model, \"flags\"):\n        model.flags = [None] * n_data\n\n    for n_it in range(max_lm_iterations):\n        # update the parameters with a LM iteration\n        f_delta_beta = _update_beta(lm_damping)\n        max_f = np.max(np.abs(f_delta_beta))\n        if verbose is True:\n            print(\n                \"Iteration {0:d}: {1}. Max change in param: {2}\".format(\n                    n_it, model.get_params(), max_f\n                )\n            )\n        if max_f < param_tolerance:\n            break\n\n    J = model.jacobian\n    r = model.weighted_residuals\n    model.WSS = r.dot(r.T)\n\n    model.popt = model.get_params()\n    model.pcov = np.linalg.inv(J.T.dot(J)) * r.dot(r.T) / model.dof\n\n    # Estimate the noise variance normal to the curve\n    model.goodness_of_fit = model.WSS / model.dof\n    model.noise_variance = r.dot(np.diag(1.0 / model.weights)).dot(r.T) / model.dof\n\n    if verbose is True:\n        if n_it == max_lm_iterations - 1:\n            print(\n                f\"Max iterations ({max_lm_iterations:d}) reached \"\n                f\"(param tolerance = {param_tolerance:1e})\"\n            )\n        else:\n            print(\"Converged in {0:d} iterations\".format(n_it))\n        print(\"\\nOptimised parameter values:\")\n        print(model.popt)\n        print(\"\\nParameter covariance matrix:\")\n        print(model.pcov)\n        print(\"\")",
  "def confidence_prediction_bands(model, x_array, confidence_interval, f, flag=None):\n    \"\"\"\n    This function calculates the confidence and prediction bands of\n    the function f(x) from a best-fit model with uncertainties in its\n    parameters as calculated (for example) by\n    the function nonlinear_least_squares_fit().\n\n    The values are calculated via the delta method, which estimates\n    the variance of f evaluated at x as var(f(x)) = df(x)/dB var(B) df(x)/dB\n    where df(x)/dB is the vector of partial derivatives of f(x)\n    with respect to B.\n\n    :param model: As modified (for example) by the function\n        :func:`burnman.nonlinear_least_squares_fit`.\n        Should contain the following functions: get_params, set_params, function, normal\n        And attributes: delta_params, pcov, dof, noise_variance\n    :type model: object\n\n    :param x_array: Coordinates at which to evaluate the bounds.\n    :type x_array: 2D numpy.array\n\n    :param confidence_interval: Probability level of finding the true model\n        (confidence bound) or any new data point (probability bound).\n        For example, the 95% confidence bounds should be calculated using a\n        confidence interval of 0.95.\n    :type confidence_interval: float\n\n    :param f: The function defining the variable y=f(x) for which the\n        confidence and prediction bounds are desired.\n    :type f: function\n\n    :param flag: This (optional) flag is passed to model.function to control how the\n        modified position of x is calculated. This value is then used by f(x)\n    :type flag: type informed by model object\n\n    :returns: An element of bounds[i][j] gives the lower and upper confidence\n        (i=0, i=1) and prediction (i=2, i=3) bounds for the jth data point.\n    :rtype: 2D numpy.array\n    \"\"\"\n\n    # Check array dimensions\n    n_dimensions = len(model.data[0])\n    if len(x_array[0]) != n_dimensions:\n        raise Exception(\n            \"Dimensions of each point must be the same as the \"\n            \"total number of dimensions\"\n        )\n\n    param_values = model.get_params()\n    x_m_0s = np.empty_like(x_array)\n    f_m_0s = np.empty_like(x_array[:, 0])\n    for i, x in enumerate(x_array):\n        x_m_0s[i] = model.function(x, flag)\n        f_m_0s[i] = f(x)\n\n    diag_delta = np.diag(model.delta_params)\n    dxdbeta = np.empty([len(param_values), len(x_array)])\n\n    for i, value in enumerate(param_values):\n        model.set_params(param_values + diag_delta[i])\n\n        for j, x_m_0 in enumerate(x_m_0s):\n            x_m_1 = model.function(x_m_0, flag)\n            dxdbeta[i][j] = (f(x_m_1) - f_m_0s[j]) / diag_delta[i][i]\n\n    model.set_params(param_values)  # reset params\n\n    variance = np.empty(len(x_array))\n    for i, Gprime in enumerate(dxdbeta.T):\n        variance[i] = Gprime.T.dot(model.pcov).dot(Gprime)\n\n    critical_value = t.isf(0.5 * (confidence_interval + 1.0), model.dof)\n\n    confidence_half_widths = critical_value * np.sqrt(variance)\n    prediction_half_widths = critical_value * np.sqrt(variance + model.noise_variance)\n\n    confidence_bound_0 = f_m_0s - confidence_half_widths\n    confidence_bound_1 = f_m_0s + confidence_half_widths\n    prediction_bound_0 = f_m_0s - prediction_half_widths\n    prediction_bound_1 = f_m_0s + prediction_half_widths\n\n    return np.array(\n        [confidence_bound_0, confidence_bound_1, prediction_bound_0, prediction_bound_1]\n    )",
  "def abs_line_project(M, n):\n    n = unit_normalize(n)\n    return n.dot(M).dot(n.T)",
  "def plot_cov_ellipse(cov, pos, nstd=2, ax=None, **kwargs):\n    \"\"\"\n    Plots an `nstd` sigma error ellipse based on the specified covariance\n    matrix (`cov`). Additional keyword arguments are passed on to the\n    ellipse patch artist.\n\n    :param cov: The 2x2 covariance matrix to base the ellipse on.\n    :type cov: numpy.array\n\n    :param pos: The location of the center of the ellipse. Expects a 2-element\n        sequence of [x0, y0].\n    :type pos: list or numpy.array\n\n    :param nstd: The radius of the ellipse in numbers of standard deviations.\n        Defaults to 2 standard deviations.\n    :type nstd: float\n\n    :param ax: The axis that the ellipse will be plotted on. Defaults to the\n        current axis.\n    :type ax: matplotlib.pyplot.axes\n\n    :param kwargs: Additional keyword arguments are passed on to the ellipse patch.\n\n    :returns: The covariance ellipse (already applied to the desired axes object).\n    :rtype: matplotlib.patches.Ellipse\n    \"\"\"\n\n    def eigsorted(cov):\n        vals, vecs = np.linalg.eigh(cov)\n        order = vals.argsort()[::-1]\n        return vals[order], vecs[:, order]\n\n    if ax is None:\n        ax = plt.gca()\n\n    vals, vecs = eigsorted(cov)\n    theta = np.degrees(np.arctan2(*vecs[:, 0][::-1]))\n\n    # Width and height are \"full\" widths, not radius\n    width, height = 2 * nstd * np.sqrt(vals)\n    ellip = Ellipse(xy=pos, width=width, height=height, angle=theta, **kwargs)\n\n    ax.add_artist(ellip)\n    return ellip",
  "def corner_plot(popt, pcov, param_names=[], n_std=1.0):\n    \"\"\"\n    Creates a corner plot of covariances\n\n    :param popt: Optimized parameters.\n    :type popt: numpy.array\n\n    :param pcov: Covariance matrix of the parameters.\n    :type pcov: 2D numpy.array\n\n    :param param_names: Parameter names.\n    :type param_names: list\n\n    :param n_std: Number of standard deviations for ellipse.\n    :type n_std: float\n\n    :returns: ``matplotlib.pyplot.figure`` and list of ``matplotlib.pyplot.Axes``\n        objects.\n    :rtype: tuple\n    \"\"\"\n\n    if len(pcov[0]) != len(pcov[:, 0]):\n        raise Exception(\"Covariance matrices must be square\")\n\n    n_params = len(pcov[0])\n    if n_params < 2:\n        raise Exception(\n            \"Covariance matrix must be at least 2x2 for \" \"a corner plot to be plotted\"\n        )\n\n    # ellipse plotting is prone to rounding errors, so we scale the plots here\n    scaling = 1.0 / np.power(10.0, np.around(np.log10(np.abs(popt)) - 0.5))\n    scaling = np.outer(scaling, scaling)\n\n    fig, ax = plt.subplots(n_params - 1, n_params - 1)\n    fig.set_size_inches(3.0 * (n_params - 1), 3.0 * (n_params - 1))\n\n    for j in range(n_params - 1):\n        for i in range(j):\n            fig.delaxes(ax[i][j])\n\n        for i in range(j, n_params - 1):\n            ax[i][j].get_xaxis().get_major_formatter().set_useOffset(False)\n            ax[i][j].get_yaxis().get_major_formatter().set_useOffset(False)\n            ax[i][j].set_box_aspect(1)\n\n            if j > 0:\n                ax[i][j].get_yaxis().set_visible(False)\n            if i < n_params - 2:\n                ax[i][j].get_xaxis().set_visible(False)\n\n            indices = np.array([j, i + 1])\n            projected_cov = (pcov * scaling)[indices[:, None], indices]\n\n            scaled_pos = np.array(\n                [\n                    popt[j] * np.sqrt(scaling[j][j]),\n                    popt[i + 1] * np.sqrt(scaling[i + 1][i + 1]),\n                ]\n            )\n\n            plot_cov_ellipse(\n                cov=projected_cov, pos=scaled_pos, nstd=n_std, ax=ax[i][j], color=\"grey\"\n            )\n            maxx = 1.5 * n_std * np.sqrt(projected_cov[0][0])\n            maxy = 1.5 * n_std * np.sqrt(projected_cov[1][1])\n            ax[i][j].set_xlim(scaled_pos[0] - maxx, scaled_pos[0] + maxx)\n            ax[i][j].set_ylim(scaled_pos[1] - maxy, scaled_pos[1] + maxy)\n\n    if param_names != []:\n        for i in range(n_params - 1):\n            ax[n_params - 2][i].set_xlabel(\n                \"{0:s} (x $10^{{{1:d}}}$)\".format(\n                    param_names[i], -int(np.log10(np.sqrt(scaling[i][i])))\n                )\n            )\n\n        for j in range(1, n_params):\n            ax[j - 1][0].set_ylabel(\n                \"{0:s} (x $10^{{{1:d}}}$)\".format(\n                    param_names[j], -int(np.log10(np.sqrt(scaling[j][j])))\n                )\n            )\n\n    fig.set_tight_layout(True)\n\n    return fig, ax",
  "def weighted_residual_plot(\n    ax,\n    model,\n    flag=None,\n    sd_limit=3,\n    cmap=plt.cm.RdYlBu,\n    plot_axes=[0, 1],\n    scale_axes=[1.0, 1.0],\n):\n    \"\"\"\n    Creates a plot of the weighted residuals\n    The user can choose the projection axes, and scaling to apply to those axes\n    The chosen color palette (cmap) is discretised by standard deviation up\n    to a cut off value of sd_limit.\n\n    :param ax: Plot.\n    :param type: ``matplotlib.pyplot.Axes``\n\n    :param model: A model as used by\n        :func:`burnman.nonlinear_least_squares_fit`.\n        Must contain the attributes model.data,\n        model.weighted_residuals and\n        model.flags (if flag is not None).\n    :type model: object\n\n    :param flag: String to determine which data to plot.\n        Finds matches with model.flags.\n    :type flag: str\n\n    :param sd_limit: Data with weighted residuals exceeding this\n        limit are plotted in black.\n    :type sd_limit: float\n\n    :param cmap: Color palette.\n    :type cmap: matplotlib color palette\n\n    :param plot_axes: Data axes to use as plot axes.\n    :type plot_axes: list of int\n\n    :param scale_axes: Plot axes are scaled by multiplication\n        of the data by these values.\n    :type scale_axes: list of float\n\n    :returns: Coloured scatter plot of the weighted residuals in data space.\n    :rtype: matplotlib Axes object\n    \"\"\"\n    if flag is None:\n        mask = range(len(model.data[:, 0]))\n    else:\n        mask = [i for i, flg in enumerate(model.flags) if flg == flag]\n\n    cmap_cp = copy.copy(cmap)\n    cmap_cp.set_under(\"k\")\n    cmap_cp.set_over(\"k\")\n    bounds = np.linspace(-sd_limit, sd_limit, sd_limit * 2 + 1)\n    norm = colors.BoundaryNorm(bounds, cmap_cp.N)\n\n    im = ax.scatter(\n        model.data[:, plot_axes[0]][mask] * scale_axes[0],\n        model.data[:, plot_axes[1]][mask] * scale_axes[1],\n        c=model.weighted_residuals[mask],\n        cmap=cmap_cp,\n        norm=norm,\n        s=50,\n    )\n    plt.colorbar(im, ax=ax, label=\"Misfit (standard deviations)\")",
  "def extreme_values(weighted_residuals, confidence_interval):\n    \"\"\"\n    This function uses extreme value theory to calculate the number of\n    standard deviations away from the mean at which we should expect to bracket\n    *all* of our n data points at a certain confidence level.\n\n    It then uses that value to identify which (if any) of the data points\n    lie outside that region, and calculates the corresponding probabilities\n    of finding a data point at least that many standard deviations away.\n\n\n    :param weighted_residuals: Array of residuals weighted by the square root\n        of their variances wr_i = r_i/sqrt(var_i).\n    :type weighted_residuals: array of float\n\n    :param confidence_interval: Probability at which all the weighted residuals lie\n        within the confidence bounds.\n    :type confidence_interval: float\n\n    :returns: Number of standard deviations at which we should expect to encompass\n        all data at the user-defined confidence interval, the indices of weighted\n        residuals exceeding the confidence_interval defined by the user, and\n        the probabilities that the extreme data point of the distribution lies\n        further from the mean than the observed position wr_i for each i in\n        the \"indices\" output array.\n    :rtype: tuple of (float, numpy.array, numpy.array)\n    \"\"\"\n\n    n = len(weighted_residuals)\n    mean = norm.isf(1.0 / n)\n    # good approximation for > 10 data points\n    scale = 0.8 / np.power(np.log(n), 1.0 / 2.0)\n    # good approximation for > 10 data points\n    c = 0.33 / np.power(np.log(n), 3.0 / 4.0)\n\n    # We now need a 1-tailed probability from the given confidence_interval\n    # p_total = 1. - confidence_interval = p_upper + p_lower - p_upper*p_lower\n    # p_total = 1. - confidence_interval = 2p - p^2, therefore:\n    p = 1.0 - np.sqrt(confidence_interval)\n    confidence_bound = genextreme.isf(p, c, loc=mean, scale=scale)\n\n    indices = [\n        i for i, r in enumerate(weighted_residuals) if np.abs(r) > confidence_bound\n    ]\n    # Convert back to 2-tailed probabilities\n    probabilities = 1.0 - np.power(\n        genextreme.sf(np.abs(weighted_residuals[indices]), c, loc=mean, scale=scale)\n        - 1.0,\n        2.0,\n    )\n\n    return confidence_bound, indices, probabilities",
  "def plot_residuals(ax, weighted_residuals, n_bins=None, flags=[]):\n    if flags is []:\n        flags = [\"\"] * len(weighted_residuals)\n        list_flags = [\"\"]\n    else:\n        list_flags = list(set(flags))\n\n    if n_bins is None:\n        try:  # Only works for recent versions of numpy\n            bin_heights, bin_bounds = np.histogram(\n                weighted_residuals, bins=\"auto\", density=True\n            )\n            n_bins = len(bin_heights)\n        except:\n            n_bins = 11.0\n\n    mask = [i for i, f in enumerate(flags)]\n    for flag in list_flags:\n        binwidth = np.ptp(weighted_residuals) / n_bins\n        dmin = min(weighted_residuals) - binwidth\n        dmax = max(weighted_residuals) + binwidth\n        bins = np.linspace(dmin, dmax, n_bins)\n        bin_heights, bin_bounds = np.histogram(\n            weighted_residuals[mask], bins=bins, density=True\n        )\n\n        normalisation = float(len(weighted_residuals[mask])) / float(\n            len(weighted_residuals)\n        )\n        bin_centers = (bin_bounds[:-1] + bin_bounds[1:]) / 2.0\n        bin_heights = bin_heights * normalisation\n        bin_widths = bin_bounds[1] - bin_bounds[0]\n        plt.bar(bin_centers, bin_heights, width=bin_widths, label=flag, alpha=0.2)\n        mask = [i for i, f in enumerate(flags) if f != flag and i in mask]\n\n        x = np.linspace(bin_bounds[0], bin_bounds[-1], 1001)\n        ax.plot(x, norm.pdf(x) * normalisation)\n\n    ax.set_title(\"Residual plot versus expected normal distribution\")\n    ax.set_xlabel(\"Number of standard deviations from the mean\")\n    ax.set_ylabel(\"Probability\")\n    ax.legend(loc=\"upper right\")",
  "def _mle_estimate(x, x_m, cov, flag):\n        n = model.normal(x_m, flag)\n        var_n = abs_line_project(cov, n)\n        d = (x_m - x).dot(n)\n        x_mle = x + d * ((n.dot(cov)).T) / var_n\n        return x_mle, d, var_n",
  "def _find_mle():\n        x_mle_arr = np.empty_like(model.data)\n        residual_arr = np.empty(n_data)\n        var_arr = np.empty(n_data)\n        for i, (x, cov, flag) in enumerate(\n            zip(*[model.data, model.data_covariances, model.flags])\n        ):\n            x_mle_arr[i] = model.function(x, flag)\n            x_mle_est, residual_arr[i], var_arr[i] = _mle_estimate(\n                x, x_mle_arr[i], cov, flag\n            )\n            delta_x = x_mle_arr[i] - x\n\n            while np.linalg.norm(delta_x) > model.mle_tolerances[i]:\n                x_mle_est, residual_arr[i], var_arr[i] = _mle_estimate(\n                    x, x_mle_arr[i], cov, flag\n                )\n                x_mle_arr[i] = model.function(x_mle_est, flag)\n                delta_x = x_mle_arr[i] - x_mle_est\n\n        return x_mle_arr, residual_arr / np.sqrt(var_arr), 1.0 / var_arr",
  "def calculate_jacobian():\n        model.jacobian = np.empty((n_data, n_params))\n        diag_delta = np.diag(model.delta_params)\n        param_values = model.get_params()\n        for prm_i, value in enumerate(param_values):\n            model.set_params(param_values - diag_delta[prm_i])\n            x_mle_arr, residual_arr_0, weights_0 = _find_mle()\n\n            model.set_params(param_values + diag_delta[prm_i])\n            x_mle_arr, residual_arr_1, weights_1 = _find_mle()\n\n            model.jacobian[:, prm_i] = (residual_arr_1 - residual_arr_0) / (\n                2.0 * diag_delta[prm_i][prm_i]\n            )\n        model.set_params(param_values)",
  "def _update_beta(lmbda):\n        # Performs a Levenberg-Marquardt iteration\n        # Note that if lambda = 0, this is a simple Gauss-Newton iteration\n        calculate_jacobian()\n        model.data_mle, model.weighted_residuals, model.weights = _find_mle()\n\n        J = model.jacobian  # this the weighted Jacobian\n        JTJ = J.T.dot(J)\n        delta_beta = (\n            np.linalg.inv(JTJ + lmbda * np.diag(JTJ))\n            .dot(J.T)\n            .dot(model.weighted_residuals)\n        )\n        old_params = np.copy(model.get_params())\n        new_params = old_params - delta_beta\n        # f_delta_beta = delta_beta/new_params\n\n        model.set_params(new_params)\n\n        # set_params may modify the step to satisfy bounds on the problem\n        # We therefore need to get the params before\n        # calculating the fractional change.\n        new_params = model.get_params()\n\n        # In case the new_params object returns a very small value,\n        # modify to avoid a pointless comparison:\n        mod_params = np.where(\n            np.abs(new_params) < param_tolerance, param_tolerance, new_params\n        )\n        f_delta_beta = (old_params - new_params) / mod_params\n        return f_delta_beta",
  "def eigsorted(cov):\n        vals, vecs = np.linalg.eigh(cov)\n        order = vals.argsort()[::-1]\n        return vals[order], vecs[:, order]",
  "def weighted_constrained_least_squares(\n    A, b, Cov_b=None, equality_constraints=None, inequality_constraints=None\n):\n    \"\"\"\n    Solves a weighted, constrained least squares problem using cvxpy.\n    The objective function is to minimize the following:\n    sum_squares(Cov_b^(-1/2).A.x - Cov_b^(-1/2).b))\n    subject to\n    C.x == c\n    D.x <= d\n\n    :param A: An array defining matrix A in the objective function above.\n    :type A: 2D numpy array\n\n    :param b: An array defining vector b in the objective function above.\n    :type b: numpy array\n\n    :param Cov_b: A covariance matrix associated with b\n    :type Cov_b: 2D numpy array\n\n    :param equality_constraints: A list containing the matrices C and c\n        in the objective function above.\n    :type equality_constraints: list containing a 2D array and 1D array\n\n    :param inequality_constraints: A list containing the matrices D and d\n        in the objective function above.\n    :type inequality_constraints: list containing a 2D array and 1D array\n\n    :returns: Tuple containing the optimized phase amounts (1D numpy.array),\n        a covariance matrix corresponding to the optimized phase amounts\n        (2D numpy.array), and the weighted residual of the fitting procedure\n        (a float).\n    :rtype: tuple\n    \"\"\"\n\n    if Cov_b is None:\n        Cov_b = np.eye(len(b))\n\n    # Create the standard weighted least squares objective function\n    # (https://stats.stackexchange.com/a/333551)\n    n_vars = A.shape[1]\n    m = inv(sqrtm(Cov_b))\n    mA = m @ A\n    mb = m @ b\n    x = cp.Variable(n_vars)\n    objective = cp.Minimize(cp.sum_squares(mA @ x - mb))\n\n    constraints = []\n    if equality_constraints is not None:\n        n_eq_csts = len(equality_constraints[0])\n        constraints = [\n            equality_constraints[0][i] @ x == equality_constraints[1][i]\n            for i in range(n_eq_csts)\n        ]\n\n    if inequality_constraints is not None:\n        n_ineq_csts = len(inequality_constraints[0])\n        constraints.extend(\n            [\n                inequality_constraints[0][i] @ x <= inequality_constraints[1][i]\n                for i in range(n_ineq_csts)\n            ]\n        )\n\n    # Set up the problem and solve it\n    warns = []\n    if len(constraints) > 1:\n        prob = cp.Problem(objective, constraints)\n    else:\n        prob = cp.Problem(objective)\n\n    try:\n        with warnings.catch_warnings(record=True) as w:\n            res = prob.solve(solver=cp.ECOS)\n            popt = np.array([x.value[i] for i in range(len(A.T))])\n            warns.extend(w)\n    except Exception:\n        print(\"ECOS Solver failed. Trying default solver.\")\n        try:\n            with warnings.catch_warnings(record=True) as w:\n                res = prob.solve()\n                popt = np.array([x.value[i] for i in range(len(A.T))])\n                warns.extend(w)\n        except Exception as e:\n            raise Exception(e)\n\n    # Calculate the covariance matrix\n    # (also from https://stats.stackexchange.com/a/333551)\n    inv_Cov_b = np.linalg.inv(Cov_b)\n    pcov = np.linalg.inv(A.T.dot(inv_Cov_b.dot(A)))\n\n    return (popt, pcov, res)",
  "def misfit(phase_1_fraction):\n        # Here we define the rock as before.\n        phase_2_fraction = 1.0 - phase_1_fraction\n        rock = burnman.Composite(\n            [minerals.SLB_2011.stishovite(), minerals.SLB_2011.wuestite()],\n            [phase_1_fraction, phase_2_fraction],\n        )\n\n        # Just as in step 1, we want to set which equation of state we use,\n        # then call rock.evaluate(), which evaluates the\n        # seismic velocities and density at the requested\n        # pressures and temperatures\n        rock.set_method(\"slb3\")\n        density, vphi, vs = rock.evaluate(\n            [\"density\", \"v_phi\", \"v_s\"], pressure, temperature\n        )\n\n        # Since we will call this misfit function many times, we may be interested\n        # in a status report.  These lines print some debug output so we\n        # can keep track of what the script is doing.\n        print(\"Calculations are done for:\")\n        rock.debug_print()\n\n        # Here we integrate an L2 difference with depth between our calculated seismic\n        # profiles and PREM.  We then return those misfits.\n        [vs_err, vphi_err, rho_err] = burnman.utils.math.compare_l2(\n            depths, [vs, vphi, density], [seis_vs, seis_vphi, seis_rho]\n        )\n\n        return vs_err, vphi_err, rho_err",
  "def realize_mineral(mineral):\n        K_prime_std_dev = 0.0001  # <--------- One sigma uncertainty in K prime\n        G_prime_std_dev = 0.0001  # <--------- One sigma uncertainty in G prime\n\n        # Perturb the G' and K' values by a random number drawn from a normal\n        # distribution\n        mineral.params[\"Kprime_0\"] = mineral.params[\"Kprime_0\"] + numpy.random.normal(\n            scale=K_prime_std_dev\n        )\n        mineral.params[\"Gprime_0\"] = mineral.params[\"Gprime_0\"] + numpy.random.normal(\n            scale=G_prime_std_dev\n        )",
  "def realize_rock():\n        phase_1_fraction = 0.5\n        phase_2_fraction = 1.0 - phase_1_fraction\n\n        # Setup the minerals for the two phase composite.  This is different\n        # from how we did it in step 1 and 2. Instead, we create the two phases\n        # then call realize_mineral() on them to perturb their properties.\n        phase_1 = minerals.SLB_2011.stishovite()\n        realize_mineral(phase_1)\n        phase_2 = minerals.SLB_2011.wuestite()\n        realize_mineral(phase_2)\n\n        # Set up the rock with the now-perturbed mineral phases\n        mantle_rock = burnman.Composite(\n            [phase_1, phase_2], [phase_1_fraction, phase_2_fraction]\n        )\n        mantle_rock.set_method(\"slb3\")\n\n        # Give back the realization of the rock with the perturbed phases.\n        return mantle_rock",
  "def psi_func(f, Pth, params):\n    dPsidf = (\n        params[\"a\"]\n        + params[\"b_1\"] * params[\"c_1\"] * np.exp(params[\"c_1\"] * f)\n        + params[\"b_2\"] * params[\"c_2\"] * np.exp(params[\"c_2\"] * f)\n    )\n    Psi = (\n        0.0\n        + params[\"a\"] * f\n        + params[\"b_1\"] * np.exp(params[\"c_1\"] * f)\n        + params[\"b_2\"] * np.exp(params[\"c_2\"] * f)\n        + params[\"d\"] * Pth / 1.0e9\n    )\n    dPsidPth = params[\"d\"] / 1.0e9\n    return (Psi, dPsidf, dPsidPth)",
  "def make_orthorhombic_mineral_from_parameters(x):\n    # First, make the scalar model\n    san_carlos_params = {\n        \"name\": \"San Carlos olivine\",\n        \"formula\": formula,\n        \"equation_of_state\": \"slb3\",\n        \"F_0\": 0.0,\n        \"V_0\": V_0_guess,  # we overwrite this in a second\n        \"K_0\": 1.263e11,  # Abramson et al. 1997\n        \"Kprime_0\": 4.28,  # Abramson et al. 1997\n        \"Debye_0\": 760.0,  # Robie, forsterite\n        \"grueneisen_0\": 0.99282,  # Fo in SLB2011\n        \"q_0\": 2.10672,  # Fo in SLB2011\n        \"G_0\": 81.6e9,\n        \"Gprime_0\": 1.46257,\n        \"eta_s_0\": 2.29972,\n        \"n\": 7.0,\n        \"molar_mass\": formula_mass,\n    }\n\n    R = burnman.constants.gas_constant\n    san_carlos_property_modifiers = [\n        [\n            \"linear\",\n            {\n                \"delta_E\": 0.0,\n                \"delta_S\": 26.76 * 0.1\n                - 2.0 * R * (0.1 * np.log(0.1) + 0.9 * np.log(0.9)),\n                \"delta_V\": 0.0,\n            },\n        ]\n    ]\n\n    ol = burnman.Mineral(\n        params=san_carlos_params, property_modifiers=san_carlos_property_modifiers\n    )\n\n    # Overwrite some properties\n    y = x\n\n    ol.params[\"V_0\"] = y[0] * V_0_guess  # Abramson et al. 1997\n    ol.params[\"K_0\"] = y[1] * 1.263e11  # Abramson et al. 1997\n    ol.params[\"Kprime_0\"] = y[2] * 4.28  # Abramson et al. 1997\n    ol.params[\"grueneisen_0\"] = y[3] * 0.99282  # Fo in SLB2011\n    ol.params[\"q_0\"] = y[4] * 2.10672  # Fo in SLB2011\n    # ol.params['Debye_0'] = x[5]*809.1703 # Fo in SLB2011 strong tendency to 0\n\n    # Next, each of the eight independent elastic tensor component get\n    # their turn.\n    # We arbitrarily choose S[2,3] as the ninth component,\n    # which is determined by the others.\n    i = 5\n    anisotropic_parameters = {\n        \"a\": np.zeros((6, 6)),\n        \"b_1\": np.zeros((6, 6)),\n        \"c_1\": np.ones((6, 6)),\n        \"d\": np.zeros((6, 6)),\n        \"b_2\": np.zeros((6, 6)),\n        \"c_2\": np.ones((6, 6)),\n    }\n\n    for p, q in ((1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (1, 2), (1, 3)):\n        anisotropic_parameters[\"a\"][p - 1, q - 1] = x[i]\n        anisotropic_parameters[\"a\"][q - 1, p - 1] = x[i]\n        i = i + 1\n        anisotropic_parameters[\"b_1\"][p - 1, q - 1] = x[i]\n        anisotropic_parameters[\"b_1\"][q - 1, p - 1] = x[i]\n        i = i + 1\n        anisotropic_parameters[\"d\"][p - 1, q - 1] = x[i]\n        anisotropic_parameters[\"d\"][q - 1, p - 1] = x[i]\n        i = i + 1\n\n    anisotropic_parameters[\"c_1\"][:3, :3] = x[i]\n    i = i + 1\n    for j in range(3):\n        anisotropic_parameters[\"c_1\"][3 + j, 3 + j] = x[i]\n        i = i + 1\n\n    anisotropic_parameters[\"b_2\"][3, 3] = x[i]\n    i = i + 1\n    anisotropic_parameters[\"b_2\"][4, 4] = x[i]\n    i = i + 1\n    anisotropic_parameters[\"b_2\"][5, 5] = x[i]\n    i = i + 1\n    anisotropic_parameters[\"c_2\"][3, 3] = x[i]\n    i = i + 1\n    anisotropic_parameters[\"c_2\"][4, 4] = x[i]\n    i = i + 1\n    anisotropic_parameters[\"c_2\"][5, 5] = x[i]\n    i = i + 1\n\n    assert len(x) == i\n\n    # Fill the values for the dependent element c[2,3]\n    anisotropic_parameters[\"a\"][1, 2] = (\n        1.0 - np.sum(anisotropic_parameters[\"a\"][:3, :3])\n    ) / 2.0\n    anisotropic_parameters[\"b_1\"][1, 2] = (\n        0.0 - np.sum(anisotropic_parameters[\"b_1\"][:3, :3])\n    ) / 2.0\n    anisotropic_parameters[\"d\"][1, 2] = (\n        0.0 - np.sum(anisotropic_parameters[\"d\"][:3, :3])\n    ) / 2.0\n\n    anisotropic_parameters[\"a\"][2, 1] = anisotropic_parameters[\"a\"][1, 2]\n    anisotropic_parameters[\"b_1\"][2, 1] = anisotropic_parameters[\"b_1\"][1, 2]\n    anisotropic_parameters[\"d\"][2, 1] = anisotropic_parameters[\"d\"][1, 2]\n\n    cell_lengths = cell_lengths_0_guess * np.cbrt(ol.params[\"V_0\"] / V_0_guess)\n    ol_cell_parameters = np.array(\n        [cell_lengths[0], cell_lengths[1], cell_lengths[2], 90, 90, 90]\n    )\n\n    m = AnisotropicMineral(\n        ol, ol_cell_parameters, anisotropic_parameters, psi_func, orthotropic=True\n    )\n    return m",
  "def orthorhombic_misfit(x, imin):\n        m = make_orthorhombic_mineral_from_parameters(x)\n\n        chisqr = 0.0\n        try:\n            for i, d in enumerate(ol_data):\n                TK, PGPa, rho, rhoerr = d[:4]\n\n                PPa = PGPa * 1.0e9\n\n                m.set_state(PPa, TK)\n\n                CN = m.isentropic_stiffness_tensor / 1.0e9\n\n                chisqr += np.power((m.density / 1000.0 - rho) / rhoerr, 2.0)\n                chisqr += np.sum(np.power((CN - CN_data[i]) / CNerr_data[i], 2.0))\n\n            # Not San Carlos, fo92.3, not fo90.4\n            for d in ol_1bar_lattice_data_Suzuki:\n                m.set_state(1.0e5, d[0] + 273.15)  # T in C\n\n                Y = (\n                    (np.diag(m.cell_vectors) / np.diag(m.cell_vectors_0)) - 1.0\n                ) * 1.0e4\n                Y_expt = d[1:4]\n                Y_err = 0.01 * Y_expt + 1.0\n                for i in range(3):\n                    chisqr += np.power((Y_expt[i] - Y[i]) / Y_err[i], 2.0)\n\n            # if chisqr < 1500.:\n            #    print(chisqr)\n            # m.set_state(1.e5, 300)\n            # print(np.diag(m.thermal_expansivity_tensor))\n\n            if np.isnan(chisqr):\n                print(d, \"Noooo, there was a nan\")\n                chisqr = 1.0e7\n\n        except Exception as e:\n            print(e)\n            print(\"There was an exception\")\n            chisqr = 1.0e7\n        imin[0][0] += 1\n        if chisqr < imin[0][1]:\n            imin[0][1] = chisqr\n            print(imin[0])\n            print(repr(x))\n        return chisqr",
  "def make_orthorhombic_mineral_from_parameters(x):\n    f_order = 3\n    Pth_order = 2\n    constants = np.zeros((6, 6, f_order + 1, Pth_order + 1))\n\n    san_carlos_params = {\n        \"name\": \"San Carlos olivine\",\n        \"formula\": formula,\n        \"equation_of_state\": \"slb3\",\n        \"F_0\": 0.0,\n        \"V_0\": V_0_guess,  # we overwrite this in a second\n        \"K_0\": 1.263e11,  # Abramson et al. 1997\n        \"Kprime_0\": 4.28,  # Abramson et al. 1997\n        \"Debye_0\": fo.params[\"Debye_0\"] * 0.9 + fa.params[\"Debye_0\"] * 0.1,  #\n        \"grueneisen_0\": 0.99282,  # Fo in SLB2011\n        \"q_0\": 2.10672,  # Fo in SLB2011\n        \"G_0\": 81.6e9,\n        \"Gprime_0\": 1.46257,\n        \"eta_s_0\": 2.29972,\n        \"n\": 7.0,\n        \"molar_mass\": formula_mass,\n    }\n\n    san_carlos_property_modifiers = [\n        [\n            \"linear\",\n            {\n                \"delta_E\": 0.0,\n                \"delta_S\": 26.76 * 0.1\n                - 2.0\n                * burnman.constants.gas_constant\n                * (0.1 * np.log(0.1) + 0.9 * np.log(0.9)),\n                \"delta_V\": 0.0,\n            },\n        ]\n    ]\n\n    ol = burnman.Mineral(\n        params=san_carlos_params, property_modifiers=san_carlos_property_modifiers\n    )\n\n    # Overwrite some properties\n    ol.params[\"V_0\"] = x[0] * V_0_guess  # Abramson et al. 1997\n    ol.params[\"K_0\"] = x[1] * 1.263e11  # Abramson et al. 1997\n    ol.params[\"Kprime_0\"] = x[2] * 4.28  # Abramson et al. 1997\n    # ol.params['Debye_0'] = x[3]*809.1703 # Fo in SLB2011 strong tendency to 0\n    ol.params[\"grueneisen_0\"] = x[3] * 0.99282  # Fo in SLB2011\n    ol.params[\"q_0\"] = x[4] * 2.10672  # Fo in SLB2011\n\n    # Next, each of the eight independent elastic tensor component get their turn.\n    # We arbitrarily choose S[2,3] as the ninth component, which is determined by the others.\n    i = 5\n    for p, q in ((1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (1, 2), (1, 3)):\n        for m, n in ((1, 0), (2, 0), (3, 0)):\n            constants[p - 1, q - 1, m, n] = x[i]\n            constants[q - 1, p - 1, m, n] = x[i]\n            i += 1\n\n        for m, n in ((0, 1), (1, 1), (2, 1), (3, 1)):\n            constants[p - 1, q - 1, m, n] = x[i] * 1.0e-11\n            constants[q - 1, p - 1, m, n] = x[i] * 1.0e-11\n            i += 1\n\n        for m, n in ((0, 2),):\n            constants[p - 1, q - 1, m, n] = x[i] * 1.0e-22\n            constants[q - 1, p - 1, m, n] = x[i] * 1.0e-22\n            i += 1\n\n    assert i == 69  # 40 parameters\n\n    # Fill the values for the dependent element c[2,3]\n    constants[1, 2, 1, 0] = (1.0 - np.sum(constants[:3, :3, 1, 0])) / 2.0\n    constants[1, 2, 2:, 0] = -np.sum(constants[:3, :3, 2:, 0], axis=(0, 1)) / 2.0\n    constants[1, 2, :, 1:] = -np.sum(constants[:3, :3, :, 1:], axis=(0, 1)) / 2.0\n\n    # And for c[3,2]\n    constants[2, 1, :, :] = constants[1, 2, :, :]\n\n    cell_lengths = cell_lengths_0_guess * np.cbrt(ol.params[\"V_0\"] / V_0_guess)\n    ol_cell_parameters = np.array(\n        [cell_lengths[0], cell_lengths[1], cell_lengths[2], 90, 90, 90]\n    )\n\n    m = AnisotropicMineral(ol, ol_cell_parameters, constants)\n    return m",
  "def orthorhombic_misfit(x, imin):\n        m = make_orthorhombic_mineral_from_parameters(x)\n\n        chisqr = 0.0\n        try:\n            for d in ol_data:\n                TK, PGPa, rho, rhoerr = d[:4]\n                C11, C11err = d[4:6]\n                C22, C22err = d[6:8]\n                C33, C33err = d[8:10]\n                C44, C44err = d[10:12]\n                C55, C55err = d[12:14]\n                C66, C66err = d[14:16]\n                C12, C12err = d[16:18]\n                C13, C13err = d[18:20]\n                C23, C23err = d[20:22]\n\n                PPa = PGPa * 1.0e9\n\n                m.set_state(PPa, TK)\n\n                CN = m.isentropic_stiffness_tensor / 1.0e9\n\n                chisqr += np.power((m.density / 1000.0 - rho) / rhoerr, 2.0)\n                chisqr += np.power((CN[0, 0] - C11) / C11err, 2.0)\n                chisqr += np.power((CN[1, 1] - C22) / C22err, 2.0)\n                chisqr += np.power((CN[2, 2] - C33) / C33err, 2.0)\n                chisqr += np.power((CN[3, 3] - C44) / C44err, 2.0)\n                chisqr += np.power((CN[4, 4] - C55) / C55err, 2.0)\n                chisqr += np.power((CN[5, 5] - C66) / C66err, 2.0)\n                chisqr += np.power((CN[0, 1] - C12) / C12err, 2.0)\n                chisqr += np.power((CN[0, 2] - C13) / C13err, 2.0)\n                chisqr += np.power((CN[1, 2] - C23) / C23err, 2.0)\n\n            # Not San Carlos, fo92.3, not fo90.4\n            for d in ol_1bar_lattice_data_Suzuki:\n                m.set_state(1.0e5, d[0] + 273.15)  # T in C\n\n                Y = (\n                    (np.diag(m.cell_vectors) / np.diag(m.cell_vectors_0)) - 1.0\n                ) * 1.0e4\n                Y_expt = d[1:4]\n                Y_err = 0.01 * Y_expt + 1.0\n                for i in range(3):\n                    chisqr += np.power((Y_expt[i] - Y[i]) / Y_err[i], 2.0)\n\n            # if chisqr < 1500.:\n            #    print(chisqr)\n            # m.set_state(1.e5, 300)\n            # print(np.diag(m.thermal_expansivity_tensor))\n\n            if np.isnan(chisqr):\n                print(d, \"Noooo, there was a nan\")\n                chisqr = 1.0e7\n\n        except:\n            print(\"There was an exception\")\n            chisqr = 1.0e7\n        imin[0][0] += 1\n        if chisqr < imin[0][1]:\n            imin[0][1] = chisqr\n            print(imin[0])\n            print(repr(x))\n        return chisqr",
  "def psi_func(f, Pth, params):\n    dPsidf = (\n        params[\"a\"]\n        + params[\"b_1\"] * params[\"c_1\"] * np.exp(params[\"c_1\"] * f)\n        + params[\"b_2\"] * params[\"c_2\"] * np.exp(params[\"c_2\"] * f)\n    )\n    Psi = (\n        0.0\n        + params[\"a\"] * f\n        + params[\"b_1\"] * np.exp(params[\"c_1\"] * f)\n        + params[\"b_2\"] * np.exp(params[\"c_2\"] * f)\n    )\n    dPsidPth = 0.0 * params[\"b_1\"]\n    return (Psi, dPsidf, dPsidPth)",
  "def make_cubic_mineral_from_parameters(x):\n    anisotropic_parameters = {\n        \"a\": np.zeros((6, 6)),\n        \"b_1\": np.zeros((6, 6)),\n        \"c_1\": np.ones((6, 6)),\n        \"b_2\": np.zeros((6, 6)),\n        \"c_2\": np.ones((6, 6)),\n    }\n\n    per.params[\"V_0\"] = x[0] * V0\n    per.params[\"K_0\"] = x[1] * K0\n    per.params[\"Kprime_0\"] = x[2] * Kprime0\n\n    a = np.cbrt(per.params[\"V_0\"])\n    cell_parameters = np.array([a, a, a, 90, 90, 90])\n\n    i = 3\n    for p in [\"a\", \"b_1\", \"c_1\", \"b_2\", \"c_2\"]:\n        if p == \"a\":\n            anisotropic_parameters[p][:3, :3] = (1.0 - 3.0 * x[i]) / 6.0\n        elif p[0] == \"b\" or p == \"d\":\n            anisotropic_parameters[p][:3, :3] = -3.0 * x[i] / 6.0\n        else:\n            anisotropic_parameters[p][:3, :3] = x[i]\n\n        anisotropic_parameters[p][0, 0] = x[i]\n        anisotropic_parameters[p][1, 1] = x[i]\n        anisotropic_parameters[p][2, 2] = x[i]\n        i = i + 1\n        anisotropic_parameters[p][3, 3] = x[i]\n        anisotropic_parameters[p][4, 4] = x[i]\n        anisotropic_parameters[p][5, 5] = x[i]\n        i = i + 1\n    assert len(x) == i\n\n    return AnisotropicMineral(\n        per, cell_parameters, anisotropic_parameters, psi_func, orthotropic=True\n    )",
  "def cubic_misfit(x, imin):\n        m = make_cubic_mineral_from_parameters(x)\n\n        chisqr = 0.0\n        try:\n            for d in per_data[::1]:\n                T, P, C11S, C12S, C44S, KT, V, betaTminusbetaS = d\n\n                C11Serr = 0.01 * C11S\n                C12Serr = 0.01 * C12S\n                C44Serr = 0.01 * C44S\n                Verr = 0.01 * V\n\n                if T < 500.0:\n                    m.set_state(P, T)\n\n                    chisqr += np.power((m.V - V) / Verr, 2.0)\n                    chisqr += np.power(\n                        (m.isentropic_stiffness_tensor[0, 0] - C11S) / C11Serr, 2.0\n                    )\n                    chisqr += np.power(\n                        (m.isentropic_stiffness_tensor[0, 1] - C12S) / C12Serr, 2.0\n                    )\n                    chisqr += np.power(\n                        (m.isentropic_stiffness_tensor[3, 3] - C44S) / C44Serr, 2.0\n                    )\n\n            if np.isnan(chisqr):\n                print(d, \"Noooo, there was a nan\")\n                chisqr = 1.0e7\n\n        except Exception as e:\n            print(e)\n            print(\"There was an exception\")\n            chisqr = 1.0e7\n        imin[0][0] += 1\n        if chisqr < imin[0][1]:\n            imin[0][1] = chisqr\n            print(imin[0])\n            print(repr(x))\n\n        return chisqr",
  "def psi_func(f, Pth, params):\n    dPsidf = (\n        params[\"a\"]\n        + params[\"b_1\"] * params[\"c_1\"] * np.exp(params[\"c_1\"] * f)\n        + params[\"b_2\"] * params[\"c_2\"] * np.exp(params[\"c_2\"] * f)\n    )\n    dPsidf = dPsidf + Pth / 1.0e9 * (\n        params[\"b_3\"] * params[\"c_3\"] * np.exp(params[\"c_3\"] * f)\n        + params[\"b_4\"] * params[\"c_4\"] * np.exp(params[\"c_4\"] * f)\n    )\n\n    Psi = (\n        0.0\n        + params[\"a\"] * f\n        + params[\"b_1\"] * np.exp(params[\"c_1\"] * f)\n        + params[\"b_2\"] * np.exp(params[\"c_2\"] * f)\n    )\n    Psi = Psi + Pth / 1.0e9 * (\n        params[\"b_3\"] * np.exp(params[\"c_3\"] * f)\n        + params[\"b_4\"] * np.exp(params[\"c_4\"] * f)\n    )\n\n    dPsidPth = (\n        params[\"b_3\"] * np.exp(params[\"c_3\"] * f)\n        + params[\"b_4\"] * np.exp(params[\"c_4\"] * f)\n    ) / 1.0e9\n    return (Psi, dPsidf, dPsidPth)",
  "def make_cubic_mineral_from_parameters(x):\n    anisotropic_parameters = {\n        \"a\": np.zeros((6, 6)),\n        \"b_1\": np.zeros((6, 6)),\n        \"c_1\": np.ones((6, 6)),\n        \"b_2\": np.zeros((6, 6)),\n        \"c_2\": np.ones((6, 6)),\n        \"b_3\": np.zeros((6, 6)),\n        \"c_3\": np.ones((6, 6)),\n        \"b_4\": np.zeros((6, 6)),\n        \"c_4\": np.ones((6, 6)),\n    }\n\n    per.params[\"V_0\"] = x[0] * V0\n    per.params[\"K_0\"] = x[1] * K0\n    per.params[\"Kprime_0\"] = x[2] * Kprime0\n    per.params[\"grueneisen_0\"] = x[3] * gr0\n    per.params[\"q_0\"] = np.power(x[4], 2.0) * q0\n\n    a = np.cbrt(per.params[\"V_0\"])\n    cell_parameters = np.array([a, a, a, 90, 90, 90])\n\n    i = 5\n    for p in [\"a\", \"b_1\", \"c_1\", \"b_2\", \"c_2\", \"b_3\", \"c_3\", \"b_4\", \"c_4\"]:\n        if p == \"a\":\n            anisotropic_parameters[p][:3, :3] = (1.0 - 3.0 * x[i]) / 6.0\n        elif p[0] == \"b\" or p == \"d\":\n            anisotropic_parameters[p][:3, :3] = -3.0 * x[i] / 6.0\n        else:\n            anisotropic_parameters[p][:3, :3] = x[i]\n\n        anisotropic_parameters[p][0, 0] = x[i]\n        anisotropic_parameters[p][1, 1] = x[i]\n        anisotropic_parameters[p][2, 2] = x[i]\n        i = i + 1\n        anisotropic_parameters[p][3, 3] = x[i]\n        anisotropic_parameters[p][4, 4] = x[i]\n        anisotropic_parameters[p][5, 5] = x[i]\n        i = i + 1\n    assert len(x) == i\n\n    return AnisotropicMineral(\n        per, cell_parameters, anisotropic_parameters, psi_func, orthotropic=True\n    )",
  "def cubic_misfit(x, imin):\n        m = make_cubic_mineral_from_parameters(x)\n\n        chisqr = 0.0\n        try:\n            for d in per_data[::1]:\n                T, P, C11S, C12S, C44S, KT, V, betaTminusbetaS = d\n\n                C11Serr = 0.01 * C11S\n                C12Serr = 0.01 * C12S\n                C44Serr = 0.01 * C44S\n                Verr = 0.01 * V\n\n                if T < 3500.0:\n                    m.set_state(P, T)\n\n                    chisqr += np.power((m.V - V) / Verr, 2.0)\n                    chisqr += np.power(\n                        (m.isentropic_stiffness_tensor[0, 0] - C11S) / C11Serr, 2.0\n                    )\n                    chisqr += np.power(\n                        (m.isentropic_stiffness_tensor[0, 1] - C12S) / C12Serr, 2.0\n                    )\n                    chisqr += np.power(\n                        (m.isentropic_stiffness_tensor[3, 3] - C44S) / C44Serr, 2.0\n                    )\n\n            if np.isnan(chisqr):\n                print(d, \"Noooo, there was a nan\")\n                chisqr = 1.0e7\n\n        except Exception as e:\n            print(e)\n            print(\"There was an exception\")\n            chisqr = 1.0e7\n        imin[0][0] += 1\n        if chisqr < imin[0][1]:\n            imin[0][1] = chisqr\n            print(imin[0])\n            print(repr(x))\n\n        return chisqr",
  "def psi_func(f, Pth, params):\n    dPsidf = (\n        params[\"a\"]\n        + params[\"b_1\"] * params[\"c_1\"] * np.exp(params[\"c_1\"] * f)\n        + params[\"b_2\"] * params[\"c_2\"] * np.exp(params[\"c_2\"] * f)\n    )\n    dPsidf = dPsidf + Pth / 1.0e9 * (\n        params[\"b_3\"] * params[\"c_3\"] * np.exp(params[\"c_3\"] * f)\n        + params[\"b_4\"] * params[\"c_4\"] * np.exp(params[\"c_4\"] * f)\n    )\n\n    Psi = (\n        0.0\n        + params[\"a\"] * f\n        + params[\"b_1\"] * np.exp(params[\"c_1\"] * f)\n        + params[\"b_2\"] * np.exp(params[\"c_2\"] * f)\n    )\n    Psi = Psi + Pth / 1.0e9 * (\n        params[\"b_3\"] * np.exp(params[\"c_3\"] * f)\n        + params[\"b_4\"] * np.exp(params[\"c_4\"] * f)\n    )\n\n    dPsidPth = (\n        params[\"b_3\"] * np.exp(params[\"c_3\"] * f)\n        + params[\"b_4\"] * np.exp(params[\"c_4\"] * f)\n    ) / 1.0e9\n    return (Psi, dPsidf, dPsidPth)",
  "def make_cubic_mineral_from_parameters(x):\n    anisotropic_parameters = {\n        \"b_3\": np.zeros((6, 6)),\n        \"c_3\": np.ones((6, 6)),\n        \"b_4\": np.zeros((6, 6)),\n        \"c_4\": np.ones((6, 6)),\n        **atherm_params,\n    }\n\n    per.params[\"V_0\"] = x[0] * V0\n    per.params[\"K_0\"] = x[1] * K0\n    per.params[\"Kprime_0\"] = x[2] * Kprime0\n    per.params[\"grueneisen_0\"] = x[3] * gr0\n    per.params[\"q_0\"] = np.power(x[4], 2.0) * q0\n\n    a = np.cbrt(per.params[\"V_0\"])\n    cell_parameters = np.array([a, a, a, 90, 90, 90])\n\n    i = 5\n    for p in [\"b_3\", \"c_3\", \"b_4\", \"c_4\"]:\n        if p == \"a\":\n            anisotropic_parameters[p][:3, :3] = (1.0 - 3.0 * x[i]) / 6.0\n        elif p[0] == \"b\" or p == \"d\":\n            anisotropic_parameters[p][:3, :3] = -3.0 * x[i] / 6.0\n        else:\n            anisotropic_parameters[p][:3, :3] = x[i]\n\n        anisotropic_parameters[p][0, 0] = x[i]\n        anisotropic_parameters[p][1, 1] = x[i]\n        anisotropic_parameters[p][2, 2] = x[i]\n        i = i + 1\n        anisotropic_parameters[p][3, 3] = x[i]\n        anisotropic_parameters[p][4, 4] = x[i]\n        anisotropic_parameters[p][5, 5] = x[i]\n        i = i + 1\n    assert len(x) == i\n\n    return AnisotropicMineral(\n        per, cell_parameters, anisotropic_parameters, psi_func, orthotropic=True\n    )",
  "def cubic_misfit(x, imin):\n        m = make_cubic_mineral_from_parameters(x)\n\n        chisqr = 0.0\n        try:\n            for d in per_data[::1]:\n                T, P, C11S, C12S, C44S, KT, V, betaTminusbetaS = d\n\n                C11Serr = 0.01 * C11S\n                C12Serr = 0.01 * C12S\n                C44Serr = 0.01 * C44S\n                Verr = 0.01 * V\n\n                if T < 3500.0:\n                    m.set_state(P, T)\n\n                    chisqr += np.power((m.V - V) / Verr, 2.0)\n                    chisqr += np.power(\n                        (m.isentropic_stiffness_tensor[0, 0] - C11S) / C11Serr, 2.0\n                    )\n                    chisqr += np.power(\n                        (m.isentropic_stiffness_tensor[0, 1] - C12S) / C12Serr, 2.0\n                    )\n                    chisqr += np.power(\n                        (m.isentropic_stiffness_tensor[3, 3] - C44S) / C44Serr, 2.0\n                    )\n\n            if np.isnan(chisqr):\n                print(d, \"Noooo, there was a nan\")\n                chisqr = 1.0e7\n\n        except Exception as e:\n            print(e)\n            print(\"There was an exception\")\n            chisqr = 1.0e7\n        imin[0][0] += 1\n        if chisqr < imin[0][1]:\n            imin[0][1] = chisqr\n            print(imin[0])\n            print(repr(x))\n\n        return chisqr",
  "def make_cubic_mineral_from_parameters(x):\n    f_order = 3\n    Pth_order = 1\n    constants = np.zeros((6, 6, f_order + 1, Pth_order + 1))\n\n    S11_0 = x[0]\n    dS11df = x[1]\n    d2S11df2 = x[2]\n    dS11dPth = x[3] * 1.0e-11\n    d2S11dfdPth = x[4] * 1.0e-11\n\n    S44_0 = x[5]\n    dS44df = x[6]\n    d2S44df2 = x[7]\n    dS44dPth = x[8] * 1.0e-11\n    d2S44dfdPth = x[9] * 1.0e-11\n\n    S12_0 = (1.0 - 3.0 * S11_0) / 6.0\n    dS12df = -dS11df / 2.0\n    d2S12df2 = -d2S11df2 / 2.0\n    dS12dPth = -dS11dPth / 2.0\n    d2S12dfdPth = -d2S11dfdPth / 2.0\n\n    constants[:3, :3, 1, 0] = S12_0\n    constants[:3, :3, 2, 0] = dS12df\n    constants[:3, :3, 3, 0] = d2S12df2\n    constants[:3, :3, 0, 1] = dS12dPth\n    constants[:3, :3, 1, 1] = d2S12dfdPth\n    for i in range(3):\n        constants[i, i, 1, 0] = S11_0\n        constants[i, i, 2, 0] = dS11df\n        constants[i, i, 3, 0] = d2S11df2\n\n        constants[i, i, 0, 1] = dS11dPth\n        constants[i, i, 1, 1] = d2S11dfdPth\n\n    for i in range(3, 6):\n        constants[i, i, 1, 0] = S44_0\n        constants[i, i, 2, 0] = dS44df\n        constants[i, i, 3, 0] = d2S44df2\n\n        constants[i, i, 0, 1] = dS44dPth\n        constants[i, i, 1, 1] = d2S44dfdPth\n\n    return AnisotropicMineral(per, cell_parameters, constants)",
  "def cubic_misfit(x):\n        m = make_cubic_mineral_from_parameters(x)\n\n        chisqr = 0.0\n        for d in per_data:\n            T, PGPa, Perr, rho, rhoerr = d[:5]\n            C11S, C11Serr, C12S, C12Serr, C44S, C44Serr = d[5:]\n\n            P = PGPa * 1.0e9\n\n            m.set_state(P, T)\n            chisqr += np.power(\n                (m.isentropic_stiffness_tensor[0, 0] / 1.0e9 - C11S) / C11Serr, 2.0\n            )\n            chisqr += np.power(\n                (m.isentropic_stiffness_tensor[0, 1] / 1.0e9 - C12S) / C12Serr, 2.0\n            )\n            chisqr += np.power(\n                (m.isentropic_stiffness_tensor[3, 3] / 1.0e9 - C44S) / C44Serr, 2.0\n            )\n\n        print(x)\n        print(chisqr)\n\n        return chisqr",
  "def print_table_for_mineral_constants(mineral, indices):\n    constants = []\n    for i, j in indices:\n        constants.append(mineral.anisotropic_params[\"c\"][i - 1, j - 1, :, :])\n\n    constants = np.array(constants)\n\n    mn_pairs = []\n    for n in range(constants.shape[2]):\n        for m in range(constants.shape[1]):\n            if not np.all(constants[:, m, n] == 0):\n                mn_pairs.append((m, n))\n\n    rows = [[f\"$c_{{pq{m}{n}}}$\" for (m, n) in mn_pairs]]\n    for ci, (i, j) in enumerate(indices):\n        row = [f\"$c_{{{i}{j}}}$\"]\n        row.extend([f\"{constants[ci, m, n]:.4e}\" for (m, n) in mn_pairs])\n        rows.append(row)\n\n    print(tabulate(rows, headers=\"firstrow\", tablefmt=\"latex_raw\"))",
  "def print_table_for_mineral_constants_2(mineral, param_list, indices):\n    constants = []\n    for i, j in indices:\n        cs = []\n        for param in param_list:\n            cs.append(mineral.anisotropic_params[param][i - 1, j - 1])\n        constants.append(cs)\n    constants = np.array(constants)\n\n    param_list = [p + \"_\" for p in param_list]\n    rows = [[\"$p$\", \"$q$\"]]\n    rows[0].extend(\n        [f'${param.split(\"_\")[0]}_{{{param.split(\"_\")[1]}pq}}$' for param in param_list]\n    )\n    for ci, (i, j) in enumerate(indices):\n        row = [f\"{i}\", f\"{j}\"]\n        row.extend(\n            [\n                f\"{constants[ci, i]:.4e}\"\n                if constants[ci, i] != 0 and constants[ci, i] != 1\n                else \"-\"\n                for i in range(len(param_list))\n            ]\n        )\n        rows.append(row)\n\n    print(tabulate(rows, headers=\"firstrow\", tablefmt=\"latex_raw\"))",
  "class HelperSolidSolution(burnman.Mineral):\n\n    \"\"\"\n    This material is deprecated!\n\n    Class for coming up with a new mineral based based on a solid\n    solution between two or more end member minerals.  It is not\n    completely clear how to do this, or how valid this approximation\n    is, but here we just do a weighted arithmetic average of the\n    thermoelastic properties of the end members according to their molar fractions\n    \"\"\"\n\n    def __init__(self, endmembers, molar_fractions):\n        \"\"\"\n        Takes a list of end member minerals, and a matching list of\n        molar fractions of those minerals for mixing them.  Simply\n        comes up with a new mineral by doing a weighted arithmetic\n        average of the end member minerals\n        \"\"\"\n        burnman.Mineral.__init__(self)\n        self.endmembers = endmembers\n        self.molar_fractions = molar_fractions\n        assert len(endmembers) == len(molar_fractions)\n        assert sum(molar_fractions) > 0.9999\n        assert sum(molar_fractions) < 1.0001\n\n        self.method = endmembers[0].method\n\n        # does not make sense to do a solid solution with different number of\n        # atoms per formula unit or different equations of state, at least not\n        # simply...\n        for m in endmembers:\n            m.set_method(self.method)\n            if \"n\" in endmembers[0].params:\n                assert m.params[\"n\"] == endmembers[0].params[\"n\"]\n\n        self.params = {}\n\n    def debug_print(self, indent=\"\"):\n        print(\"%sHelperSolidSolution(%s):\" % (indent, self.to_string()))\n        indent += \"  \"\n        for fraction, mat in zip(self.molar_fractions, self.endmembers):\n            print(\"%s%g of\" % (indent, fraction))\n            mat.debug_print(indent + \"  \")\n\n    def set_method(self, method):\n        for mat in self.endmembers:\n            mat.set_method(method)\n        self.method = self.endmembers[0].method\n\n    def set_state(self, pressure, temperature):\n        for mat in self.endmembers:\n            mat.set_state(pressure, temperature)\n\n        itrange = range(0, len(self.endmembers))\n        self.params = {}\n        for prop in self.endmembers[0].params:\n            try:\n                self.params[prop] = sum(\n                    [\n                        self.endmembers[i].params[prop] * self.molar_fractions[i]\n                        for i in itrange\n                    ]\n                )\n            except TypeError:\n                # if there is a type error, it is probably a string. Just go\n                # with the value of the first endmembers.\n                self.params[prop] = self.endmembers[0].params[prop]\n\n        burnman.Mineral.set_state(self, pressure, temperature)",
  "class SLB_2005_ferropericlase(HelperSolidSolution):\n    def __init__(self, fe_num):\n        endmembers = [minerals.SLB_2005.periclase(), minerals.SLB_2005.wuestite()]\n        molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n        # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "class SLB_2005_mg_fe_perovskite(HelperSolidSolution):\n    def __init__(self, fe_num):\n        endmembers = [\n            minerals.SLB_2005.mg_perovskite(),\n            minerals.SLB_2005.fe_perovskite(),\n        ]\n        molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n        # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "class Murakami_2013_ferropericlase(HelperSolidSolution):\n    def __init__(self, fe_num):\n        endmembers = [\n            minerals.Murakami_2013.periclase(),\n            minerals.Murakami_2013.wuestite(),\n        ]\n        molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n        # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "class Murakami_2013_mg_fe_perovskite(HelperSolidSolution):\n    def __init__(self, fe_num):\n        endmembers = [\n            minerals.Murakami_2013.mg_perovskite(),\n            minerals.Murakami_2013.fe_perovskite(),\n        ]\n        molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n        # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "class other_ferropericlase(HelperSolidSolution):\n    def __init__(self, fe_num):\n        endmembers = [minerals.other.periclase(), minerals.other.wuestite()]\n        molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n        # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "class other_mg_fe_perovskite(HelperSolidSolution):\n    def __init__(self, fe_num):\n        endmembers = [minerals.other.mg_perovskite(), minerals.other.fe_perovskite()]\n        molar_fractions = [\n            1.0 - fe_num,\n            0.0 + fe_num,\n        ]  # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "class other_ZSB_2013_mg_fe_perovskite(HelperSolidSolution):\n    def __init__(self, fe_num):\n        endmembers = [\n            minerals.other.ZSB_2013_mg_perovskite(),\n            minerals.other.ZSB_2013_fe_perovskite(),\n        ]\n        molar_fractions = [\n            1.0 - fe_num,\n            0.0 + fe_num,\n        ]  # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "class SLB_2011_ZSB_2013_ferropericlase(HelperSolidSolution):\n    def __init__(self, fe_num):\n        endmembers = [\n            minerals.SLB_2011_ZSB_2013.periclase(),\n            minerals.SLB_2011_ZSB_2013.wuestite(),\n        ]\n        molar_fractions = [\n            1.0 - fe_num,\n            0.0 + fe_num,\n        ]  # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "class SLB_2011_ZSB_2013_mg_fe_perovskite(HelperSolidSolution):\n    def __init__(self, fe_num):\n        endmembers = [\n            minerals.SLB_2011_ZSB_2013.mg_perovskite(),\n            minerals.SLB_2011_ZSB_2013.fe_perovskite(),\n        ]\n        molar_fractions = [\n            1.0 - fe_num,\n            0.0 + fe_num,\n        ]  # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, endmembers, molar_fractions):\n        \"\"\"\n        Takes a list of end member minerals, and a matching list of\n        molar fractions of those minerals for mixing them.  Simply\n        comes up with a new mineral by doing a weighted arithmetic\n        average of the end member minerals\n        \"\"\"\n        burnman.Mineral.__init__(self)\n        self.endmembers = endmembers\n        self.molar_fractions = molar_fractions\n        assert len(endmembers) == len(molar_fractions)\n        assert sum(molar_fractions) > 0.9999\n        assert sum(molar_fractions) < 1.0001\n\n        self.method = endmembers[0].method\n\n        # does not make sense to do a solid solution with different number of\n        # atoms per formula unit or different equations of state, at least not\n        # simply...\n        for m in endmembers:\n            m.set_method(self.method)\n            if \"n\" in endmembers[0].params:\n                assert m.params[\"n\"] == endmembers[0].params[\"n\"]\n\n        self.params = {}",
  "def debug_print(self, indent=\"\"):\n        print(\"%sHelperSolidSolution(%s):\" % (indent, self.to_string()))\n        indent += \"  \"\n        for fraction, mat in zip(self.molar_fractions, self.endmembers):\n            print(\"%s%g of\" % (indent, fraction))\n            mat.debug_print(indent + \"  \")",
  "def set_method(self, method):\n        for mat in self.endmembers:\n            mat.set_method(method)\n        self.method = self.endmembers[0].method",
  "def set_state(self, pressure, temperature):\n        for mat in self.endmembers:\n            mat.set_state(pressure, temperature)\n\n        itrange = range(0, len(self.endmembers))\n        self.params = {}\n        for prop in self.endmembers[0].params:\n            try:\n                self.params[prop] = sum(\n                    [\n                        self.endmembers[i].params[prop] * self.molar_fractions[i]\n                        for i in itrange\n                    ]\n                )\n            except TypeError:\n                # if there is a type error, it is probably a string. Just go\n                # with the value of the first endmembers.\n                self.params[prop] = self.endmembers[0].params[prop]\n\n        burnman.Mineral.set_state(self, pressure, temperature)",
  "def __init__(self, fe_num):\n        endmembers = [minerals.SLB_2005.periclase(), minerals.SLB_2005.wuestite()]\n        molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n        # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, fe_num):\n        endmembers = [\n            minerals.SLB_2005.mg_perovskite(),\n            minerals.SLB_2005.fe_perovskite(),\n        ]\n        molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n        # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, fe_num):\n        endmembers = [\n            minerals.Murakami_2013.periclase(),\n            minerals.Murakami_2013.wuestite(),\n        ]\n        molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n        # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, fe_num):\n        endmembers = [\n            minerals.Murakami_2013.mg_perovskite(),\n            minerals.Murakami_2013.fe_perovskite(),\n        ]\n        molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n        # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, fe_num):\n        endmembers = [minerals.other.periclase(), minerals.other.wuestite()]\n        molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n        # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, fe_num):\n        endmembers = [minerals.other.mg_perovskite(), minerals.other.fe_perovskite()]\n        molar_fractions = [\n            1.0 - fe_num,\n            0.0 + fe_num,\n        ]  # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, fe_num):\n        endmembers = [\n            minerals.other.ZSB_2013_mg_perovskite(),\n            minerals.other.ZSB_2013_fe_perovskite(),\n        ]\n        molar_fractions = [\n            1.0 - fe_num,\n            0.0 + fe_num,\n        ]  # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, fe_num):\n        endmembers = [\n            minerals.SLB_2011_ZSB_2013.periclase(),\n            minerals.SLB_2011_ZSB_2013.wuestite(),\n        ]\n        molar_fractions = [\n            1.0 - fe_num,\n            0.0 + fe_num,\n        ]  # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, fe_num):\n        endmembers = [\n            minerals.SLB_2011_ZSB_2013.mg_perovskite(),\n            minerals.SLB_2011_ZSB_2013.fe_perovskite(),\n        ]\n        molar_fractions = [\n            1.0 - fe_num,\n            0.0 + fe_num,\n        ]  # keep the 0.0 +, otherwise it is an array sometimes\n        HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "class my_perovskite(burnman.Mineral):\n\n    \"\"\"\n    based on Stixrude & Lithgow-Bertelloni 2011 and references therein\n    \"\"\"\n\n    def __init__(self, uncertain):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 24.45e-6,\n            \"K_0\": 251.0e9 * uncertain[0],\n            \"Kprime_0\": 4.1 * uncertain[1],\n            \"G_0\": 173.0e9 * uncertain[2],\n            \"Gprime_0\": 1.7 * uncertain[3],\n            \"molar_mass\": 0.1000,\n            \"n\": 5,\n            \"Debye_0\": 905.0 * uncertain[4],  # less important?\n            \"grueneisen_0\": 1.57 * uncertain[5],\n            \"q_0\": 1.1 * uncertain[6],\n            \"eta_s_0\": 2.6 * uncertain[7],\n        }\n        burnman.Mineral.__init__(self)",
  "def __init__(self, uncertain):\n        self.params = {\n            \"equation_of_state\": \"slb3\",\n            \"V_0\": 24.45e-6,\n            \"K_0\": 251.0e9 * uncertain[0],\n            \"Kprime_0\": 4.1 * uncertain[1],\n            \"G_0\": 173.0e9 * uncertain[2],\n            \"Gprime_0\": 1.7 * uncertain[3],\n            \"molar_mass\": 0.1000,\n            \"n\": 5,\n            \"Debye_0\": 905.0 * uncertain[4],  # less important?\n            \"grueneisen_0\": 1.57 * uncertain[5],\n            \"q_0\": 1.1 * uncertain[6],\n            \"eta_s_0\": 2.6 * uncertain[7],\n        }\n        burnman.Mineral.__init__(self)",
  "def eval(uncertain):\n        rock = burnman.Composite([my_perovskite(uncertain)], [1.0])\n        rock.set_method(\"slb3\")\n\n        temperature = burnman.geotherm.adiabatic(seis_p, 1900 * uncertain[8], rock)\n\n        mat_rho, mat_vs, mat_vphi = rock.evaluate(\n            [\"rho\", \"v_s\", \"v_phi\"], seis_p, temperature\n        )\n\n        return seis_p, mat_vs, mat_vphi, mat_rho",
  "def calc_shear_velocities(G_0, Gprime_0, mineral, pressures):\n    mineral.params[\"G_0\"] = G_0\n    mineral.params[\"Gprime_0\"] = Gprime_0\n\n    shear_velocities = np.empty_like(pressures)\n    for i in range(len(pressures)):\n        # set state with dummy temperature\n        mineral.set_state(pressures[i], 0.0)\n        shear_velocities[i] = mineral.v_s\n\n    return shear_velocities",
  "def error(guess, test_mineral, pressures, obs_vs):\n    vs = calc_shear_velocities(guess[0], guess[1], test_mineral, pressures)\n\n    vs_l2 = [(vs[i] - obs_vs[i]) * (vs[i] - obs_vs[i]) for i in range(len(obs_vs))]\n    l2_error = sum(vs_l2)\n\n    return l2_error",
  "def error_func(mg_perovskite_test, obs_pressures, obs_vs):\n        def func(x):\n            return error(x, mg_perovskite_test, obs_pressures, obs_vs)\n\n        return func",
  "def func(x):\n            return error(x, mg_perovskite_test, obs_pressures, obs_vs)",
  "class ferropericlase(HelperSolidSolution):\n        def __init__(self, fe_num):\n            endmembers = [periclase, wustite]\n            molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n            HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "class perovskite(HelperSolidSolution):\n        def __init__(self, fe_num):\n            endmembers = [mg_perovskite, fe_perovskite]\n            molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n            HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, fe_num):\n            endmembers = [periclase, wustite]\n            molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n            HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def __init__(self, fe_num):\n            endmembers = [mg_perovskite, fe_perovskite]\n            molar_fractions = [1.0 - fe_num, 0.0 + fe_num]\n            HelperSolidSolution.__init__(self, endmembers, molar_fractions)",
  "def check_slb_fig7_txt():\n    \"\"\"\n    Calculates all values for forsterite and benchmarks with values from Stixrude and Lithgow-Bertelloni (personal communication)\n    \"\"\"\n    forsterite = burnman.Mineral()\n    forsterite.params = {\n        \"name\": \"forsterite\",\n        \"V_0\": 43.603e-6,\n        \"K_0\": 127.955e9,\n        \"Kprime_0\": 4.232,\n        \"G_0\": 81.6e9,\n        \"Gprime_0\": 1.4,\n        \"molar_mass\": 0.140695,\n        \"n\": 7.0,\n        \"Debye_0\": 809.183,\n        \"grueneisen_0\": 0.993,\n        \"q_0\": 2.093,\n        \"eta_s_0\": 2.364,\n    }\n    forsterite.set_method(\"slb3\")\n\n    data = np.loadtxt(\"slb_benchmark.txt\", skiprows=1)\n\n    temperature = np.array(data[:, 2])\n    pressure = np.array(data[:, 0])\n    rho = np.array(data[:, 3])\n    frho = np.empty_like(rho)\n    rho_comp = np.empty_like(rho)\n    Kt = np.array(data[:, 4])\n    fKt = np.empty_like(Kt)\n    Kt_comp = np.empty_like(Kt)\n    Ks = np.array(data[:, 5])\n    fKs = np.empty_like(Ks)\n    Ks_comp = np.empty_like(Ks)\n    G = np.array(data[:, 6])\n    fG = np.empty_like(G)\n    G_comp = np.empty_like(G)\n    VB = np.array(data[:, 7])\n    fVB = np.empty_like(VB)\n    VB_comp = np.empty_like(VB)\n    VS = np.array(data[:, 8])\n    fVS = np.empty_like(VS)\n    VS_comp = np.empty_like(VS)\n    VP = np.array(data[:, 9])\n    fVP = np.empty_like(VP)\n    VP_comp = np.empty_like(VP)\n    vol = np.array(data[:, 10])\n    fvol = np.empty_like(vol)\n    vol_comp = np.empty_like(vol)\n    alpha = np.array(data[:, 11])\n    falpha = np.empty_like(alpha)\n    alpha_comp = np.empty_like(alpha)\n    Cp = np.array(data[:, 12])\n    fCp = np.empty_like(Cp)\n    Cp_comp = np.empty_like(Cp)\n    gr = np.array(data[:, 13])\n    gr_comp = np.empty_like(gr)\n\n    for i in range(len(temperature)):\n        forsterite.set_state(pressure[i], temperature[i])\n        rho_comp[i] = 100.0 * (forsterite.density / 1000.0 - rho[i]) / rho[i]\n        Kt_comp[i] = (\n            100.0 * (forsterite.isothermal_bulk_modulus / 1.0e9 - Kt[i]) / Kt[i]\n        )\n        Ks_comp[i] = 100.0 * (forsterite.adiabatic_bulk_modulus / 1.0e9 - Ks[i]) / Ks[i]\n        G_comp[i] = 100.0 * (forsterite.shear_modulus / 1.0e9 - G[i]) / G[i]\n        VB_comp[i] = 100.0 * (forsterite.v_phi / 1000.0 - VB[i]) / VB[i]\n        VS_comp[i] = 100.0 * (forsterite.v_s / 1000.0 - VS[i]) / VS[i]\n        VP_comp[i] = 100.0 * (forsterite.v_p / 1000.0 - VP[i]) / VP[i]\n        vol_comp[i] = 100.0 * (forsterite.molar_volume * 1.0e6 - vol[i]) / vol[i]\n        alpha_comp[i] = (\n            100.0 * (forsterite.thermal_expansivity / 1.0e-5 - alpha[i]) / (alpha[-1])\n        )\n        Cp_comp[i] = (\n            100.0\n            * (\n                forsterite.molar_heat_capacity_p\n                / forsterite.params[\"molar_mass\"]\n                / 1000.0\n                - Cp[i]\n            )\n            / (Cp[-1])\n        )\n        gr_comp[i] = (forsterite.grueneisen_parameter - gr[i]) / gr[i]\n\n    plt.plot(temperature, rho_comp, label=r\"$\\rho$\")\n    plt.plot(temperature, Kt_comp, label=r\"$K_S$\")\n    plt.plot(temperature, Ks_comp, label=r\"$K_T$\")\n    plt.plot(temperature, G_comp, label=r\"$G$\")\n    plt.plot(temperature, VS_comp, label=r\"$V_S$\")\n    plt.plot(temperature, VP_comp, label=r\"$V_P$\")\n    plt.plot(temperature, VB_comp, label=r\"$V_\\phi$\")\n    plt.plot(temperature, vol_comp, label=r\"$V$\")\n    plt.plot(temperature, alpha_comp, label=r\"$\\alpha$\")\n    plt.plot(temperature, Cp_comp, label=r\"$c_P$\")\n    plt.plot(temperature, gr_comp, label=r\"$\\gamma$\")\n\n    plt.xlim([0, 2200])\n    plt.ylim([-0.002, 0.002])\n    plt.yticks([-0.002, -0.001, 0, 0.001, 0.002])\n    plt.xticks([0, 800, 1600, 2200])\n    plt.xlabel(\"Temperature (K)\")\n    plt.ylabel(\"Difference (\\%)\")\n    plt.legend(loc=\"lower center\", prop=prop, ncol=4)\n    if \"RUNNING_TESTS\" not in globals():\n        plt.savefig(\"benchmark1.pdf\", bbox_inches=\"tight\")\n    plt.show()",
  "def color(idx):\n    return c[idx]",
  "def eval_material(amount_perovskite):\n        rock = burnman.Composite(\n            [SLB_2011_ZSB_2013_mg_fe_perovskite(0.07), other_ferropericlase(0.2)],\n            [amount_perovskite, 1.0 - amount_perovskite],\n        )\n        rock.set_method(method)\n        temperature = burnman.geotherm.adiabatic(seis_p, 1900, rock)\n        print(\"Calculations are done for:\")\n        rock.debug_print()\n\n        mat_rho, mat_vs, mat_vphi = rock.evaluate(\n            [\"rho\", \"v_s\", \"v_phi\"], seis_p, temperature\n        )\n        # [rho_err,vphi_err,vs_err]=burnman.utils.compare_chifactor(mat_vs,mat_vphi,mat_rho,seis_vs,seis_vphi,seis_rho)\n\n        return seis_p, mat_vs, mat_vphi, mat_rho",
  "def material_error(x):\n        _, mat_vs, mat_vphi, mat_rho = eval_material(x)\n        [vs_err, vphi_err, rho_err] = burnman.utils.math.compare_l2(\n            depths, [mat_vs, mat_vphi, mat_rho], [seis_vs, seis_vphi, seis_rho]\n        )\n        scale = 2700e3 - 850e3\n        return vs_err / scale, vphi_err / scale",
  "def make_rock():\n    # approximate four component pyrolite model\n    x_pv = 0.67\n    x_fp = 0.33\n    pv_fe_num = 0.07\n    fp_fe_num = 0.2\n\n    mg_perovskite = minerals.SLB_2011_ZSB_2013.mg_perovskite()\n    fe_perovskite = minerals.SLB_2011_ZSB_2013.fe_perovskite()\n    wuestite = minerals.SLB_2011_ZSB_2013.wuestite()\n    periclase = minerals.SLB_2011_ZSB_2013.periclase()\n\n    perovskite = HelperSolidSolution(\n        [mg_perovskite, fe_perovskite], [1.0 - pv_fe_num, pv_fe_num]\n    )\n    ferropericlase = HelperSolidSolution(\n        [periclase, wuestite], [1.0 - fp_fe_num, fp_fe_num]\n    )\n\n    pyrolite = burnman.Composite([perovskite, ferropericlase], [x_pv, x_fp])\n    pyrolite.set_method(\"slb3\")\n    anchor_temperature = 1935.0\n\n    return pyrolite, anchor_temperature",
  "def output_rock(rock, file_handle):\n    for ph in rock.staticphases:\n        if isinstance(ph.mineral, HelperSolidSolution):\n            for mineral in ph.mineral.endmembers:\n                file_handle.write(\"\\t\" + mineral.to_string() + \"\\n\")\n                for key in mineral.params:\n                    file_handle.write(\n                        \"\\t\\t\" + key + \": \" + str(mineral.params[key]) + \"\\n\"\n                    )\n        else:\n            file_handle.write(\"\\t\" + ph.mineral.to_string() + \"\\n\")\n            for key in ph.mineral.params:\n                file_handle.write(\n                    \"\\t\\t\" + key + \": \" + str(ph.mineral.params[key]) + \"\\n\"\n                )",
  "def realization_to_array(rock, anchor_t):\n    arr = [anchor_t]\n    names = [\"anchor_T\"]\n    for ph in rock.staticphases:\n        if isinstance(ph.mineral, burnman.minerals_base.helper_solid_solution):\n            for mineral in ph.mineral.endmembers:\n                for key in mineral.params:\n                    if (\n                        key != \"equation_of_state\"\n                        and key != \"F_0\"\n                        and key != \"T_0\"\n                        and key != \"P_0\"\n                    ):\n                        arr.append(mineral.params[key])\n                        names.append(mineral.to_string() + \".\" + key)\n        else:\n            for key in ph.mineral.params:\n                if (\n                    key != \"equation_of_state\"\n                    and key != \"F_0\"\n                    and key != \"T_0\"\n                    and key != \"P_0\"\n                ):\n                    arr.append(ph.mineral.params[key])\n                    names.append(ph.mineral.to_string() + \".\" + key)\n    return arr, names",
  "def array_to_rock(arr, names):\n    rock, _ = make_rock()\n    anchor_t = arr[0]\n    idx = 1\n    for phase in rock.phases:\n        if isinstance(phase, HelperSolidSolution):\n            for mineral in phase.endmembers:\n                while mineral.to_string() in names[idx]:\n                    key = names[idx].split(\".\")[-1]\n                    if (\n                        key != \"equation_of_state\"\n                        and key != \"F_0\"\n                        and key != \"T_0\"\n                        and key != \"P_0\"\n                    ):\n                        assert mineral.to_string() in names[idx]\n                        mineral.params[key] = arr[idx]\n                        idx += 1\n        else:\n            raise Exception(\"unknown type\")\n    return rock, anchor_t",
  "class nf(float):\n    def __repr__(self):\n        str = \"%.1f\" % (self.__float__(),)\n        if str[-1] == \"0\":\n            return \"%.0f\" % self.__float__()\n        else:\n            return \"%.1f\" % self.__float__()",
  "def equilibrate_px(mineral, x_Fe, P, T):\n    \"\"\"\n    Function to find the equilibrium state of order of a two site pyroxene\n    with site distributions [Fe][Fe], [Mg][Mg] and [Fe][Mg]\n    \"\"\"\n\n    # Try completely disordered as a starting guess\n    mineral.set_state(P, T)\n\n    if x_Fe < 0.5:\n        aord = np.array([0.0, 1.0 - 2 * x_Fe, 2.0 * x_Fe])\n        bord = np.array([2.0 * x_Fe, 1.0, -2.0 * x_Fe])\n    else:\n        x_Mg = 1.0 - x_Fe\n        aord = np.array([1.0 - 2 * x_Mg, 0.0, 2.0 * x_Mg])\n        bord = np.array([1.0, 2.0 * x_Mg, -2.0 * x_Mg])\n\n    def diff_pot(Q):\n        c = aord * Q + bord * (1.0 - Q)\n        mineral.set_composition(c)\n\n        return (\n            mineral.partial_gibbs[0] + mineral.partial_gibbs[1]\n        ) / 2.0 - mineral.partial_gibbs[2]\n\n    root = brentq(diff_pot, 0.01, 1.0)  # make slightly asymmetric\n    return root",
  "def __repr__(self):\n        str = \"%.1f\" % (self.__float__(),)\n        if str[-1] == \"0\":\n            return \"%.0f\" % self.__float__()\n        else:\n            return \"%.1f\" % self.__float__()",
  "def diff_pot(Q):\n        c = aord * Q + bord * (1.0 - Q)\n        mineral.set_composition(c)\n\n        return (\n            mineral.partial_gibbs[0] + mineral.partial_gibbs[1]\n        ) / 2.0 - mineral.partial_gibbs[2]",
  "def closest_factors(n):\n        d = int(np.floor(np.sqrt(n)))\n        for i in reversed(range(1, d + 1)):\n            if (n % i) == 0:\n                return i, int(n / i)",
  "def read_fitting_file(filename):\n    with open(filename, \"r\") as f:\n        data = []\n        datastream = f.read()\n        datalines = [\n            line.strip().split()\n            for line in datastream.split(\"\\n\")\n            if line.strip() and line.strip().split()[0] != \"#\"\n        ]\n\n        comment_index = []\n        for line in datalines:\n            try:\n                comment_index.append(line.index(\"#\"))\n            except ValueError:\n                comment_index.append(len(line))\n\n        datalines = [line[0 : comment_index[i]] for i, line in enumerate(datalines)]\n\n        flags = list(zip(*datalines))[0]\n        values = np.array(\n            [list(map(float, line)) for line in list(zip(*datalines))[1:]]\n        ).T\n\n        n_rows = len(values[0])\n        n_data = len(values[:, 0])\n        if n_rows == 3:\n            data = values\n            data_covariances = np.array([[[0.0] * 3] * 3] * n_data)\n            data_covariances[:, 0, 0] = 1.0\n        elif n_rows == 6:\n            data = values[:, 0:3]\n            data_covariances = np.array([[[0.0] * 3] * 3] * n_data)\n            data_covariances[:, 0, 0] = values[:, 3] * values[:, 3]\n            data_covariances[:, 1, 1] = values[:, 4] * values[:, 4]\n            data_covariances[:, 2, 2] = values[:, 5] * values[:, 5]\n        elif n_rows == 9:\n            data = values[:, 0:3]\n            data_covariances = np.array([[[0.0] * 3] * 3] * n_data)\n            data_covariances[:, 0, 0] = values[:, 3]\n            data_covariances[:, 1, 1] = values[:, 4]\n            data_covariances[:, 2, 2] = values[:, 5]\n            data_covariances[:, 0, 1] = values[:, 6]\n            data_covariances[:, 1, 0] = values[:, 6]\n            data_covariances[:, 0, 2] = values[:, 7]\n            data_covariances[:, 2, 0] = values[:, 7]\n            data_covariances[:, 1, 2] = values[:, 8]\n            data_covariances[:, 2, 1] = values[:, 8]\n        else:\n            raise Exception(\n                \"Your input file must have 4, 7, or 10 rows, where the first row is a string\"\n            )\n\n    return flags, data, data_covariances"
]