[
  "def parse_theme(fp):\n    config_parser.read(fp)\n    theme = dict(config_parser[\"logger\"])\n    # replaces `_` by `.` as rich understands it\n    for key in theme:\n        temp = theme[key]\n        del theme[key]\n        key = key.replace(\"_\", \".\")\n        theme[key] = temp\n    try:\n        customTheme = Theme(theme)\n    except (color.ColorParseError, errors.StyleSyntaxError):\n        customTheme = None\n        printf(\n            \"[logging.level.error]It seems your colour configuration couldn't be parsed. Loading the default color configuration...[/logging.level.error]\"\n        )\n    return customTheme",
  "def open_file_if_needed(file_writer):\n    if file_writer_config[\"quiet\"]:\n        curr_stdout = sys.stdout\n        sys.stdout = open(os.devnull, \"w\")\n\n    open_file = any(\n        [file_writer_config[\"preview\"], file_writer_config[\"show_file_in_finder\"]]\n    )\n    if open_file:\n        current_os = platform.system()\n        file_paths = []\n\n        if file_writer_config[\"save_last_frame\"]:\n            file_paths.append(file_writer.get_image_file_path())\n        if file_writer_config[\"write_to_movie\"]:\n            file_paths.append(file_writer.get_movie_file_path())\n\n        for file_path in file_paths:\n            if current_os == \"Windows\":\n                os.startfile(file_path)\n            else:\n                commands = []\n                if current_os == \"Linux\":\n                    commands.append(\"xdg-open\")\n                elif current_os.startswith(\"CYGWIN\"):\n                    commands.append(\"cygstart\")\n                else:  # Assume macOS\n                    commands.append(\"open\")\n\n                if file_writer_config[\"show_file_in_finder\"]:\n                    commands.append(\"-R\")\n\n                commands.append(file_path)\n\n                # commands.append(\"-g\")\n                FNULL = open(os.devnull, \"w\")\n                sp.call(commands, stdout=FNULL, stderr=sp.STDOUT)\n                FNULL.close()\n\n    if file_writer_config[\"quiet\"]:\n        sys.stdout.close()\n        sys.stdout = curr_stdout",
  "def is_child_scene(obj, module):\n    return (\n        inspect.isclass(obj)\n        and issubclass(obj, Scene)\n        and obj != Scene\n        and obj.__module__.startswith(module.__name__)\n    )",
  "def prompt_user_for_choice(scene_classes):\n    num_to_class = {}\n    for count, scene_class in enumerate(scene_classes):\n        count += 1  # start with 1 instead of 0\n        name = scene_class.__name__\n        console.print(f\"{count}: {name}\", style=\"logging.level.info\")\n        num_to_class[count] = scene_class\n    try:\n        user_input = console.input(\n            f\"[log.message] {constants.CHOOSE_NUMBER_MESSAGE} [/log.message]\"\n        )\n        return [\n            num_to_class[int(num_str)]\n            for num_str in re.split(r\"\\s*,\\s*\", user_input.strip())\n        ]\n    except KeyError:\n        logger.error(constants.INVALID_NUMBER_MESSAGE)\n        sys.exit(2)\n    except EOFError:\n        sys.exit(1)",
  "def get_scenes_to_render(scene_classes):\n    if not scene_classes:\n        logger.error(constants.NO_SCENE_MESSAGE)\n        return []\n    if file_writer_config[\"write_all\"]:\n        return scene_classes\n    result = []\n    for scene_name in file_writer_config[\"scene_names\"]:\n        found = False\n        for scene_class in scene_classes:\n            if scene_class.__name__ == scene_name:\n                result.append(scene_class)\n                found = True\n                break\n        if not found and (scene_name != \"\"):\n            logger.error(constants.SCENE_NOT_FOUND_MESSAGE.format(scene_name))\n    if result:\n        return result\n    return (\n        [scene_classes[0]]\n        if len(scene_classes) == 1\n        else prompt_user_for_choice(scene_classes)\n    )",
  "def get_scene_classes_from_module(module):\n    return [\n        member[1]\n        for member in inspect.getmembers(module, lambda x: is_child_scene(x, module))\n    ]",
  "def get_module(file_name):\n    if file_name == \"-\":\n        module = types.ModuleType(\"input_scenes\")\n        logger.info(\n            \"Enter the animation's code & end with an EOF (CTRL+D on Linux/Unix, CTRL+Z on Windows):\"\n        )\n        code = sys.stdin.read()\n        if not code.startswith(\"from manim import\"):\n            logger.warn(\n                \"Didn't find an import statement for Manim. Importing automatically...\"\n            )\n            code = \"from manim import *\\n\" + code\n        logger.info(\"Rendering animation from typed code...\")\n        try:\n            exec(code, module.__dict__)\n            return module\n        except Exception as e:\n            logger.error(f\"Failed to render scene: {str(e)}\")\n            sys.exit(2)\n    else:\n        if os.path.exists(file_name):\n            if file_name[-3:] != \".py\":\n                raise Exception(f\"{file_name} is not a valid Manim python script.\")\n            module_name = file_name[:-3].replace(os.sep, \".\").split(\".\")[-1]\n            spec = importlib.util.spec_from_file_location(module_name, file_name)\n            module = importlib.util.module_from_spec(spec)\n            spec.loader.exec_module(module)\n            return module\n        else:\n            raise FileNotFoundError(f\"{file_name} not found\")",
  "def main():\n    module = get_module(file_writer_config[\"input_file\"])\n    all_scene_classes = get_scene_classes_from_module(module)\n    scene_classes_to_render = get_scenes_to_render(all_scene_classes)\n    sound_on = file_writer_config[\"sound\"]\n    for SceneClass in scene_classes_to_render:\n        try:\n            # By invoking, this renders the full scene\n            scene = SceneClass()\n            open_file_if_needed(scene.file_writer)\n            if sound_on:\n                play_finish_sound()\n        except Exception:\n            print(\"\\n\\n\")\n            traceback.print_exc()\n            print(\"\\n\\n\")\n            if sound_on:\n                play_error_sound()",
  "def _parse_config(config_parser, args):\n    \"\"\"Parse config files and CLI arguments into a single dictionary.\"\"\"\n    # By default, use the CLI section of the digested .cfg files\n    default = config_parser[\"CLI\"]\n\n    # Handle the *_quality flags.  These determine the section to read\n    # and are stored in 'camera_config'.  Note the highest resolution\n    # passed as argument will be used.\n    for flag in [\"fourk_quality\", \"high_quality\", \"medium_quality\", \"low_quality\"]:\n        if getattr(args, flag):\n            section = config_parser[flag]\n            break\n    else:\n        section = config_parser[\"CLI\"]\n    config = {opt: section.getint(opt) for opt in config_parser[flag]}\n\n    # The -r, --resolution flag overrides the *_quality flags\n    if args.resolution is not None:\n        if \",\" in args.resolution:\n            height_str, width_str = args.resolution.split(\",\")\n            height, width = int(height_str), int(width_str)\n        else:\n            height, width = int(args.resolution), int(16 * height / 9)\n        config[\"camera_config\"].update({\"pixel_height\": height, \"pixel_width\": width})\n\n    # Handle the -c (--color) flag\n    if args.color is not None:\n        try:\n            background_color = colour.Color(args.color)\n        except AttributeError as err:\n            logger.warning(\"Please use a valid color.\")\n            logger.error(err)\n            sys.exit(2)\n    else:\n        background_color = colour.Color(default[\"background_color\"])\n    config[\"background_color\"] = background_color\n\n    # Set the rest of the frame properties\n    config[\"frame_height\"] = 8.0\n    config[\"frame_width\"] = (\n        config[\"frame_height\"] * config[\"pixel_width\"] / config[\"pixel_height\"]\n    )\n    config[\"frame_y_radius\"] = config[\"frame_height\"] / 2\n    config[\"frame_x_radius\"] = config[\"frame_width\"] / 2\n    config[\"top\"] = config[\"frame_y_radius\"] * constants.UP\n    config[\"bottom\"] = config[\"frame_y_radius\"] * constants.DOWN\n    config[\"left_side\"] = config[\"frame_x_radius\"] * constants.LEFT\n    config[\"right_side\"] = config[\"frame_x_radius\"] * constants.RIGHT\n\n    # Handle the --tex_template flag.  Note we accept None if the flag is absent\n    tex_fn = os.path.expanduser(args.tex_template) if args.tex_template else None\n\n    if tex_fn is not None and not os.access(tex_fn, os.R_OK):\n        # custom template not available, fallback to default\n        logger.warning(\n            f\"Custom TeX template {tex_fn} not found or not readable. \"\n            \"Falling back to the default template.\"\n        )\n        tex_fn = None\n    config[\"tex_template_file\"] = tex_fn\n    config[\"tex_template\"] = (\n        TexTemplateFromFile(filename=tex_fn) if tex_fn is not None else TexTemplate()\n    )\n\n    return config",
  "class ValueTracker(Mobject):\n    \"\"\"\n    Not meant to be displayed.  Instead the position encodes some\n    number, often one which another animation or continual_animation\n    uses for its update function, and by treating it as a mobject it can\n    still be animated and manipulated just like anything else.\n    \"\"\"\n\n    def __init__(self, value=0, **kwargs):\n        Mobject.__init__(self, **kwargs)\n        self.points = np.zeros((1, 3))\n        self.set_value(value)\n\n    def get_value(self):\n        return self.points[0, 0]\n\n    def set_value(self, value):\n        self.points[0, 0] = value\n        return self\n\n    def increment_value(self, d_value):\n        self.set_value(self.get_value() + d_value)\n\n    def interpolate(self, mobject1, mobject2, alpha, path_func=straight_path):\n        \"\"\"\n        Turns self into an interpolation between mobject1\n        and mobject2.\n        \"\"\"\n        self.points = path_func(mobject1.points, mobject2.points, alpha)\n        return self",
  "class ExponentialValueTracker(ValueTracker):\n    \"\"\"\n    Operates just like ValueTracker, except it encodes the value as the\n    exponential of a position coordinate, which changes how interpolation\n    behaves\n    \"\"\"\n\n    def get_value(self):\n        return np.exp(ValueTracker.get_value(self))\n\n    def set_value(self, value):\n        return ValueTracker.set_value(self, np.log(value))",
  "class ComplexValueTracker(ValueTracker):\n    def get_value(self):\n        return complex(*self.points[0, :2])\n\n    def set_value(self, z):\n        z = complex(z)\n        self.points[0, :2] = (z.real, z.imag)\n        return self",
  "def __init__(self, value=0, **kwargs):\n        Mobject.__init__(self, **kwargs)\n        self.points = np.zeros((1, 3))\n        self.set_value(value)",
  "def get_value(self):\n        return self.points[0, 0]",
  "def set_value(self, value):\n        self.points[0, 0] = value\n        return self",
  "def increment_value(self, d_value):\n        self.set_value(self.get_value() + d_value)",
  "def interpolate(self, mobject1, mobject2, alpha, path_func=straight_path):\n        \"\"\"\n        Turns self into an interpolation between mobject1\n        and mobject2.\n        \"\"\"\n        self.points = path_func(mobject1.points, mobject2.points, alpha)\n        return self",
  "def get_value(self):\n        return np.exp(ValueTracker.get_value(self))",
  "def set_value(self, value):\n        return ValueTracker.set_value(self, np.log(value))",
  "def get_value(self):\n        return complex(*self.points[0, :2])",
  "def set_value(self, z):\n        z = complex(z)\n        self.points[0, :2] = (z.real, z.imag)\n        return self",
  "class SurroundingRectangle(Rectangle):\n    CONFIG = {\n        \"color\": YELLOW,\n        \"buff\": SMALL_BUFF,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        digest_config(self, kwargs)\n        kwargs[\"width\"] = mobject.get_width() + 2 * self.buff\n        kwargs[\"height\"] = mobject.get_height() + 2 * self.buff\n        Rectangle.__init__(self, **kwargs)\n        self.move_to(mobject)",
  "class BackgroundRectangle(SurroundingRectangle):\n    CONFIG = {\n        \"color\": BLACK,\n        \"stroke_width\": 0,\n        \"stroke_opacity\": 0,\n        \"fill_opacity\": 0.75,\n        \"buff\": 0,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        SurroundingRectangle.__init__(self, mobject, **kwargs)\n        self.original_fill_opacity = self.fill_opacity\n\n    def pointwise_become_partial(self, mobject, a, b):\n        self.set_fill(opacity=b * self.original_fill_opacity)\n        return self\n\n    def set_style_data(\n        self,\n        stroke_color=None,\n        stroke_width=None,\n        fill_color=None,\n        fill_opacity=None,\n        family=True,\n    ):\n        # Unchangable style, except for fill_opacity\n        VMobject.set_style_data(\n            self,\n            stroke_color=BLACK,\n            stroke_width=0,\n            fill_color=BLACK,\n            fill_opacity=fill_opacity,\n        )\n        return self\n\n    def get_fill_color(self):\n        return Color(self.color)",
  "class Cross(VGroup):\n    CONFIG = {\n        \"stroke_color\": RED,\n        \"stroke_width\": 6,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        VGroup.__init__(\n            self, Line(UP + LEFT, DOWN + RIGHT), Line(UP + RIGHT, DOWN + LEFT),\n        )\n        self.replace(mobject, stretch=True)\n        self.set_stroke(self.stroke_color, self.stroke_width)",
  "class Underline(Line):\n    CONFIG = {\n        \"buff\": SMALL_BUFF,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        super().__init__(LEFT, RIGHT, **kwargs)\n        self.match_width(mobject)\n        self.next_to(mobject, DOWN, buff=self.buff)",
  "def __init__(self, mobject, **kwargs):\n        digest_config(self, kwargs)\n        kwargs[\"width\"] = mobject.get_width() + 2 * self.buff\n        kwargs[\"height\"] = mobject.get_height() + 2 * self.buff\n        Rectangle.__init__(self, **kwargs)\n        self.move_to(mobject)",
  "def __init__(self, mobject, **kwargs):\n        SurroundingRectangle.__init__(self, mobject, **kwargs)\n        self.original_fill_opacity = self.fill_opacity",
  "def pointwise_become_partial(self, mobject, a, b):\n        self.set_fill(opacity=b * self.original_fill_opacity)\n        return self",
  "def set_style_data(\n        self,\n        stroke_color=None,\n        stroke_width=None,\n        fill_color=None,\n        fill_opacity=None,\n        family=True,\n    ):\n        # Unchangable style, except for fill_opacity\n        VMobject.set_style_data(\n            self,\n            stroke_color=BLACK,\n            stroke_width=0,\n            fill_color=BLACK,\n            fill_opacity=fill_opacity,\n        )\n        return self",
  "def get_fill_color(self):\n        return Color(self.color)",
  "def __init__(self, mobject, **kwargs):\n        VGroup.__init__(\n            self, Line(UP + LEFT, DOWN + RIGHT), Line(UP + RIGHT, DOWN + LEFT),\n        )\n        self.replace(mobject, stretch=True)\n        self.set_stroke(self.stroke_color, self.stroke_width)",
  "def __init__(self, mobject, **kwargs):\n        super().__init__(LEFT, RIGHT, **kwargs)\n        self.match_width(mobject)\n        self.next_to(mobject, DOWN, buff=self.buff)",
  "class SampleSpace(Rectangle):\n    CONFIG = {\n        \"height\": 3,\n        \"width\": 3,\n        \"fill_color\": DARK_GREY,\n        \"fill_opacity\": 1,\n        \"stroke_width\": 0.5,\n        \"stroke_color\": LIGHT_GREY,\n        ##\n        \"default_label_scale_val\": 1,\n    }\n\n    def add_title(self, title=\"Sample space\", buff=MED_SMALL_BUFF):\n        # TODO, should this really exist in SampleSpaceScene\n        title_mob = TextMobject(title)\n        if title_mob.get_width() > self.get_width():\n            title_mob.set_width(self.get_width())\n        title_mob.next_to(self, UP, buff=buff)\n        self.title = title_mob\n        self.add(title_mob)\n\n    def add_label(self, label):\n        self.label = label\n\n    def complete_p_list(self, p_list):\n        new_p_list = list(tuplify(p_list))\n        remainder = 1.0 - sum(new_p_list)\n        if abs(remainder) > EPSILON:\n            new_p_list.append(remainder)\n        return new_p_list\n\n    def get_division_along_dimension(self, p_list, dim, colors, vect):\n        p_list = self.complete_p_list(p_list)\n        colors = color_gradient(colors, len(p_list))\n\n        last_point = self.get_edge_center(-vect)\n        parts = VGroup()\n        for factor, color in zip(p_list, colors):\n            part = SampleSpace()\n            part.set_fill(color, 1)\n            part.replace(self, stretch=True)\n            part.stretch(factor, dim)\n            part.move_to(last_point, -vect)\n            last_point = part.get_edge_center(vect)\n            parts.add(part)\n        return parts\n\n    def get_horizontal_division(self, p_list, colors=[GREEN_E, BLUE_E], vect=DOWN):\n        return self.get_division_along_dimension(p_list, 1, colors, vect)\n\n    def get_vertical_division(self, p_list, colors=[MAROON_B, YELLOW], vect=RIGHT):\n        return self.get_division_along_dimension(p_list, 0, colors, vect)\n\n    def divide_horizontally(self, *args, **kwargs):\n        self.horizontal_parts = self.get_horizontal_division(*args, **kwargs)\n        self.add(self.horizontal_parts)\n\n    def divide_vertically(self, *args, **kwargs):\n        self.vertical_parts = self.get_vertical_division(*args, **kwargs)\n        self.add(self.vertical_parts)\n\n    def get_subdivision_braces_and_labels(\n        self, parts, labels, direction, buff=SMALL_BUFF, min_num_quads=1\n    ):\n        label_mobs = VGroup()\n        braces = VGroup()\n        for label, part in zip(labels, parts):\n            brace = Brace(part, direction, min_num_quads=min_num_quads, buff=buff)\n            if isinstance(label, Mobject):\n                label_mob = label\n            else:\n                label_mob = TexMobject(label)\n                label_mob.scale(self.default_label_scale_val)\n            label_mob.next_to(brace, direction, buff)\n\n            braces.add(brace)\n            label_mobs.add(label_mob)\n        parts.braces = braces\n        parts.labels = label_mobs\n        parts.label_kwargs = {\n            \"labels\": label_mobs.copy(),\n            \"direction\": direction,\n            \"buff\": buff,\n        }\n        return VGroup(parts.braces, parts.labels)\n\n    def get_side_braces_and_labels(self, labels, direction=LEFT, **kwargs):\n        assert hasattr(self, \"horizontal_parts\")\n        parts = self.horizontal_parts\n        return self.get_subdivision_braces_and_labels(\n            parts, labels, direction, **kwargs\n        )\n\n    def get_top_braces_and_labels(self, labels, **kwargs):\n        assert hasattr(self, \"vertical_parts\")\n        parts = self.vertical_parts\n        return self.get_subdivision_braces_and_labels(parts, labels, UP, **kwargs)\n\n    def get_bottom_braces_and_labels(self, labels, **kwargs):\n        assert hasattr(self, \"vertical_parts\")\n        parts = self.vertical_parts\n        return self.get_subdivision_braces_and_labels(parts, labels, DOWN, **kwargs)\n\n    def add_braces_and_labels(self):\n        for attr in \"horizontal_parts\", \"vertical_parts\":\n            if not hasattr(self, attr):\n                continue\n            parts = getattr(self, attr)\n            for subattr in \"braces\", \"labels\":\n                if hasattr(parts, subattr):\n                    self.add(getattr(parts, subattr))\n\n    def __getitem__(self, index):\n        if hasattr(self, \"horizontal_parts\"):\n            return self.horizontal_parts[index]\n        elif hasattr(self, \"vertical_parts\"):\n            return self.vertical_parts[index]\n        return self.split()[index]",
  "class BarChart(VGroup):\n    CONFIG = {\n        \"height\": 4,\n        \"width\": 6,\n        \"n_ticks\": 4,\n        \"tick_width\": 0.2,\n        \"label_y_axis\": True,\n        \"y_axis_label_height\": 0.25,\n        \"max_value\": 1,\n        \"bar_colors\": [BLUE, YELLOW],\n        \"bar_fill_opacity\": 0.8,\n        \"bar_stroke_width\": 3,\n        \"bar_names\": [],\n        \"bar_label_scale_val\": 0.75,\n    }\n\n    def __init__(self, values, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        if self.max_value is None:\n            self.max_value = max(values)\n\n        self.add_axes()\n        self.add_bars(values)\n        self.center()\n\n    def add_axes(self):\n        x_axis = Line(self.tick_width * LEFT / 2, self.width * RIGHT)\n        y_axis = Line(MED_LARGE_BUFF * DOWN, self.height * UP)\n        ticks = VGroup()\n        heights = np.linspace(0, self.height, self.n_ticks + 1)\n        values = np.linspace(0, self.max_value, self.n_ticks + 1)\n        for y, value in zip(heights, values):\n            tick = Line(LEFT, RIGHT)\n            tick.set_width(self.tick_width)\n            tick.move_to(y * UP)\n            ticks.add(tick)\n        y_axis.add(ticks)\n\n        self.add(x_axis, y_axis)\n        self.x_axis, self.y_axis = x_axis, y_axis\n\n        if self.label_y_axis:\n            labels = VGroup()\n            for tick, value in zip(ticks, values):\n                label = TexMobject(str(np.round(value, 2)))\n                label.set_height(self.y_axis_label_height)\n                label.next_to(tick, LEFT, SMALL_BUFF)\n                labels.add(label)\n            self.y_axis_labels = labels\n            self.add(labels)\n\n    def add_bars(self, values):\n        buff = float(self.width) / (2 * len(values) + 1)\n        bars = VGroup()\n        for i, value in enumerate(values):\n            bar = Rectangle(\n                height=(value / self.max_value) * self.height,\n                width=buff,\n                stroke_width=self.bar_stroke_width,\n                fill_opacity=self.bar_fill_opacity,\n            )\n            bar.move_to((2 * i + 1) * buff * RIGHT, DOWN + LEFT)\n            bars.add(bar)\n        bars.set_color_by_gradient(*self.bar_colors)\n\n        bar_labels = VGroup()\n        for bar, name in zip(bars, self.bar_names):\n            label = TexMobject(str(name))\n            label.scale(self.bar_label_scale_val)\n            label.next_to(bar, DOWN, SMALL_BUFF)\n            bar_labels.add(label)\n\n        self.add(bars, bar_labels)\n        self.bars = bars\n        self.bar_labels = bar_labels\n\n    def change_bar_values(self, values):\n        for bar, value in zip(self.bars, values):\n            bar_bottom = bar.get_bottom()\n            bar.stretch_to_fit_height((value / self.max_value) * self.height)\n            bar.move_to(bar_bottom, DOWN)\n\n    def copy(self):\n        return self.deepcopy()",
  "def add_title(self, title=\"Sample space\", buff=MED_SMALL_BUFF):\n        # TODO, should this really exist in SampleSpaceScene\n        title_mob = TextMobject(title)\n        if title_mob.get_width() > self.get_width():\n            title_mob.set_width(self.get_width())\n        title_mob.next_to(self, UP, buff=buff)\n        self.title = title_mob\n        self.add(title_mob)",
  "def add_label(self, label):\n        self.label = label",
  "def complete_p_list(self, p_list):\n        new_p_list = list(tuplify(p_list))\n        remainder = 1.0 - sum(new_p_list)\n        if abs(remainder) > EPSILON:\n            new_p_list.append(remainder)\n        return new_p_list",
  "def get_division_along_dimension(self, p_list, dim, colors, vect):\n        p_list = self.complete_p_list(p_list)\n        colors = color_gradient(colors, len(p_list))\n\n        last_point = self.get_edge_center(-vect)\n        parts = VGroup()\n        for factor, color in zip(p_list, colors):\n            part = SampleSpace()\n            part.set_fill(color, 1)\n            part.replace(self, stretch=True)\n            part.stretch(factor, dim)\n            part.move_to(last_point, -vect)\n            last_point = part.get_edge_center(vect)\n            parts.add(part)\n        return parts",
  "def get_horizontal_division(self, p_list, colors=[GREEN_E, BLUE_E], vect=DOWN):\n        return self.get_division_along_dimension(p_list, 1, colors, vect)",
  "def get_vertical_division(self, p_list, colors=[MAROON_B, YELLOW], vect=RIGHT):\n        return self.get_division_along_dimension(p_list, 0, colors, vect)",
  "def divide_horizontally(self, *args, **kwargs):\n        self.horizontal_parts = self.get_horizontal_division(*args, **kwargs)\n        self.add(self.horizontal_parts)",
  "def divide_vertically(self, *args, **kwargs):\n        self.vertical_parts = self.get_vertical_division(*args, **kwargs)\n        self.add(self.vertical_parts)",
  "def get_subdivision_braces_and_labels(\n        self, parts, labels, direction, buff=SMALL_BUFF, min_num_quads=1\n    ):\n        label_mobs = VGroup()\n        braces = VGroup()\n        for label, part in zip(labels, parts):\n            brace = Brace(part, direction, min_num_quads=min_num_quads, buff=buff)\n            if isinstance(label, Mobject):\n                label_mob = label\n            else:\n                label_mob = TexMobject(label)\n                label_mob.scale(self.default_label_scale_val)\n            label_mob.next_to(brace, direction, buff)\n\n            braces.add(brace)\n            label_mobs.add(label_mob)\n        parts.braces = braces\n        parts.labels = label_mobs\n        parts.label_kwargs = {\n            \"labels\": label_mobs.copy(),\n            \"direction\": direction,\n            \"buff\": buff,\n        }\n        return VGroup(parts.braces, parts.labels)",
  "def get_side_braces_and_labels(self, labels, direction=LEFT, **kwargs):\n        assert hasattr(self, \"horizontal_parts\")\n        parts = self.horizontal_parts\n        return self.get_subdivision_braces_and_labels(\n            parts, labels, direction, **kwargs\n        )",
  "def get_top_braces_and_labels(self, labels, **kwargs):\n        assert hasattr(self, \"vertical_parts\")\n        parts = self.vertical_parts\n        return self.get_subdivision_braces_and_labels(parts, labels, UP, **kwargs)",
  "def get_bottom_braces_and_labels(self, labels, **kwargs):\n        assert hasattr(self, \"vertical_parts\")\n        parts = self.vertical_parts\n        return self.get_subdivision_braces_and_labels(parts, labels, DOWN, **kwargs)",
  "def add_braces_and_labels(self):\n        for attr in \"horizontal_parts\", \"vertical_parts\":\n            if not hasattr(self, attr):\n                continue\n            parts = getattr(self, attr)\n            for subattr in \"braces\", \"labels\":\n                if hasattr(parts, subattr):\n                    self.add(getattr(parts, subattr))",
  "def __getitem__(self, index):\n        if hasattr(self, \"horizontal_parts\"):\n            return self.horizontal_parts[index]\n        elif hasattr(self, \"vertical_parts\"):\n            return self.vertical_parts[index]\n        return self.split()[index]",
  "def __init__(self, values, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        if self.max_value is None:\n            self.max_value = max(values)\n\n        self.add_axes()\n        self.add_bars(values)\n        self.center()",
  "def add_axes(self):\n        x_axis = Line(self.tick_width * LEFT / 2, self.width * RIGHT)\n        y_axis = Line(MED_LARGE_BUFF * DOWN, self.height * UP)\n        ticks = VGroup()\n        heights = np.linspace(0, self.height, self.n_ticks + 1)\n        values = np.linspace(0, self.max_value, self.n_ticks + 1)\n        for y, value in zip(heights, values):\n            tick = Line(LEFT, RIGHT)\n            tick.set_width(self.tick_width)\n            tick.move_to(y * UP)\n            ticks.add(tick)\n        y_axis.add(ticks)\n\n        self.add(x_axis, y_axis)\n        self.x_axis, self.y_axis = x_axis, y_axis\n\n        if self.label_y_axis:\n            labels = VGroup()\n            for tick, value in zip(ticks, values):\n                label = TexMobject(str(np.round(value, 2)))\n                label.set_height(self.y_axis_label_height)\n                label.next_to(tick, LEFT, SMALL_BUFF)\n                labels.add(label)\n            self.y_axis_labels = labels\n            self.add(labels)",
  "def add_bars(self, values):\n        buff = float(self.width) / (2 * len(values) + 1)\n        bars = VGroup()\n        for i, value in enumerate(values):\n            bar = Rectangle(\n                height=(value / self.max_value) * self.height,\n                width=buff,\n                stroke_width=self.bar_stroke_width,\n                fill_opacity=self.bar_fill_opacity,\n            )\n            bar.move_to((2 * i + 1) * buff * RIGHT, DOWN + LEFT)\n            bars.add(bar)\n        bars.set_color_by_gradient(*self.bar_colors)\n\n        bar_labels = VGroup()\n        for bar, name in zip(bars, self.bar_names):\n            label = TexMobject(str(name))\n            label.scale(self.bar_label_scale_val)\n            label.next_to(bar, DOWN, SMALL_BUFF)\n            bar_labels.add(label)\n\n        self.add(bars, bar_labels)\n        self.bars = bars\n        self.bar_labels = bar_labels",
  "def change_bar_values(self, values):\n        for bar, value in zip(self.bars, values):\n            bar_bottom = bar.get_bottom()\n            bar.stretch_to_fit_height((value / self.max_value) * self.height)\n            bar.move_to(bar_bottom, DOWN)",
  "def copy(self):\n        return self.deepcopy()",
  "class Mobject(Container):\n    \"\"\"\n    Mathematical Object\n    \"\"\"\n\n    CONFIG = {\n        \"color\": WHITE,\n        \"name\": None,\n        \"dim\": 3,\n        \"target\": None,\n        \"z_index\": 0,\n    }\n\n    def __init__(self, **kwargs):\n        Container.__init__(self, **kwargs)\n        self.submobjects = []\n        self.color = Color(self.color)\n        if self.name is None:\n            self.name = self.__class__.__name__\n        self.updaters = []\n        self.updating_suspended = False\n        self.reset_points()\n        self.generate_points()\n        self.init_colors()\n\n    def __str__(self):\n        return str(self.name)\n\n    def reset_points(self):\n        self.points = np.zeros((0, self.dim))\n\n    def init_colors(self):\n        # For subclasses\n        pass\n\n    def generate_points(self):\n        # Typically implemented in subclass, unless purposefully left blank\n        pass\n\n    def add(self, *mobjects):\n        if self in mobjects:\n            raise Exception(\"Mobject cannot contain self\")\n        self.submobjects = list_update(self.submobjects, mobjects)\n        return self\n\n    def add_to_back(self, *mobjects):\n        self.remove(*mobjects)\n        self.submobjects = list(mobjects) + self.submobjects\n        return self\n\n    def remove(self, *mobjects):\n        for mobject in mobjects:\n            if mobject in self.submobjects:\n                self.submobjects.remove(mobject)\n        return self\n\n    def get_array_attrs(self):\n        return [\"points\"]\n\n    def digest_mobject_attrs(self):\n        \"\"\"\n        Ensures all attributes which are mobjects are included\n        in the submobjects list.\n        \"\"\"\n        mobject_attrs = [\n            x for x in list(self.__dict__.values()) if isinstance(x, Mobject)\n        ]\n        self.submobjects = list_update(self.submobjects, mobject_attrs)\n        return self\n\n    def apply_over_attr_arrays(self, func):\n        for attr in self.get_array_attrs():\n            setattr(self, attr, func(getattr(self, attr)))\n        return self\n\n    # Displaying\n\n    def get_image(self, camera=None):\n        if camera is None:\n            from ..camera.camera import Camera\n\n            camera = Camera()\n        camera.capture_mobject(self)\n        return camera.get_image()\n\n    def show(self, camera=None):\n        self.get_image(camera=camera).show()\n\n    def save_image(self, name=None):\n        self.get_image().save(\n            os.path.join(config[\"VIDEO_DIR\"], (name or str(self)) + \".png\")\n        )\n\n    def copy(self):\n        # TODO, either justify reason for shallow copy, or\n        # remove this redundancy everywhere\n        # return self.deepcopy()\n\n        copy_mobject = copy.copy(self)\n        copy_mobject.points = np.array(self.points)\n        copy_mobject.submobjects = [submob.copy() for submob in self.submobjects]\n        copy_mobject.updaters = list(self.updaters)\n        family = self.get_family()\n        for attr, value in list(self.__dict__.items()):\n            if isinstance(value, Mobject) and value in family and value is not self:\n                setattr(copy_mobject, attr, value.copy())\n            if isinstance(value, np.ndarray):\n                setattr(copy_mobject, attr, np.array(value))\n        return copy_mobject\n\n    def deepcopy(self):\n        return copy.deepcopy(self)\n\n    def generate_target(self, use_deepcopy=False):\n        self.target = None  # Prevent exponential explosion\n        if use_deepcopy:\n            self.target = self.deepcopy()\n        else:\n            self.target = self.copy()\n        return self.target\n\n    # Updating\n\n    def update(self, dt=0, recursive=True):\n        if self.updating_suspended:\n            return self\n        for updater in self.updaters:\n            parameters = get_parameters(updater)\n            if \"dt\" in parameters:\n                updater(self, dt)\n            else:\n                updater(self)\n        if recursive:\n            for submob in self.submobjects:\n                submob.update(dt, recursive)\n        return self\n\n    def get_time_based_updaters(self):\n        return [updater for updater in self.updaters if \"dt\" in get_parameters(updater)]\n\n    def has_time_based_updater(self):\n        for updater in self.updaters:\n            if \"dt\" in get_parameters(updater):\n                return True\n        return False\n\n    def get_updaters(self):\n        return self.updaters\n\n    def get_family_updaters(self):\n        return list(it.chain(*[sm.get_updaters() for sm in self.get_family()]))\n\n    def add_updater(self, update_function, index=None, call_updater=True):\n        if index is None:\n            self.updaters.append(update_function)\n        else:\n            self.updaters.insert(index, update_function)\n        if call_updater:\n            self.update(0)\n        return self\n\n    def remove_updater(self, update_function):\n        while update_function in self.updaters:\n            self.updaters.remove(update_function)\n        return self\n\n    def clear_updaters(self, recursive=True):\n        self.updaters = []\n        if recursive:\n            for submob in self.submobjects:\n                submob.clear_updaters()\n        return self\n\n    def match_updaters(self, mobject):\n        self.clear_updaters()\n        for updater in mobject.get_updaters():\n            self.add_updater(updater)\n        return self\n\n    def suspend_updating(self, recursive=True):\n        self.updating_suspended = True\n        if recursive:\n            for submob in self.submobjects:\n                submob.suspend_updating(recursive)\n        return self\n\n    def resume_updating(self, recursive=True):\n        self.updating_suspended = False\n        if recursive:\n            for submob in self.submobjects:\n                submob.resume_updating(recursive)\n        self.update(dt=0, recursive=recursive)\n        return self\n\n    # Transforming operations\n\n    def apply_to_family(self, func):\n        for mob in self.family_members_with_points():\n            func(mob)\n\n    def shift(self, *vectors):\n        total_vector = reduce(op.add, vectors)\n        for mob in self.family_members_with_points():\n            mob.points = mob.points.astype(\"float\")\n            mob.points += total_vector\n        return self\n\n    def scale(self, scale_factor, **kwargs):\n        \"\"\"\n        Default behavior is to scale about the center of the mobject.\n        The argument about_edge can be a vector, indicating which side of\n        the mobject to scale about, e.g., mob.scale(about_edge = RIGHT)\n        scales about mob.get_right().\n\n        Otherwise, if about_point is given a value, scaling is done with\n        respect to that point.\n        \"\"\"\n        self.apply_points_function_about_point(\n            lambda points: scale_factor * points, **kwargs\n        )\n        return self\n\n    def rotate_about_origin(self, angle, axis=OUT, axes=[]):\n        return self.rotate(angle, axis, about_point=ORIGIN)\n\n    def rotate(self, angle, axis=OUT, **kwargs):\n        rot_matrix = rotation_matrix(angle, axis)\n        self.apply_points_function_about_point(\n            lambda points: np.dot(points, rot_matrix.T), **kwargs\n        )\n        return self\n\n    def flip(self, axis=UP, **kwargs):\n        return self.rotate(TAU / 2, axis, **kwargs)\n\n    def stretch(self, factor, dim, **kwargs):\n        def func(points):\n            points[:, dim] *= factor\n            return points\n\n        self.apply_points_function_about_point(func, **kwargs)\n        return self\n\n    def apply_function(self, function, **kwargs):\n        # Default to applying matrix about the origin, not mobjects center\n        if len(kwargs) == 0:\n            kwargs[\"about_point\"] = ORIGIN\n        self.apply_points_function_about_point(\n            lambda points: np.apply_along_axis(function, 1, points), **kwargs\n        )\n        return self\n\n    def apply_function_to_position(self, function):\n        self.move_to(function(self.get_center()))\n        return self\n\n    def apply_function_to_submobject_positions(self, function):\n        for submob in self.submobjects:\n            submob.apply_function_to_position(function)\n        return self\n\n    def apply_matrix(self, matrix, **kwargs):\n        # Default to applying matrix about the origin, not mobjects center\n        if (\"about_point\" not in kwargs) and (\"about_edge\" not in kwargs):\n            kwargs[\"about_point\"] = ORIGIN\n        full_matrix = np.identity(self.dim)\n        matrix = np.array(matrix)\n        full_matrix[: matrix.shape[0], : matrix.shape[1]] = matrix\n        self.apply_points_function_about_point(\n            lambda points: np.dot(points, full_matrix.T), **kwargs\n        )\n        return self\n\n    def apply_complex_function(self, function, **kwargs):\n        def R3_func(point):\n            x, y, z = point\n            xy_complex = function(complex(x, y))\n            return [xy_complex.real, xy_complex.imag, z]\n\n        return self.apply_function(R3_func)\n\n    def wag(self, direction=RIGHT, axis=DOWN, wag_factor=1.0):\n        for mob in self.family_members_with_points():\n            alphas = np.dot(mob.points, np.transpose(axis))\n            alphas -= min(alphas)\n            alphas /= max(alphas)\n            alphas = alphas ** wag_factor\n            mob.points += np.dot(\n                alphas.reshape((len(alphas), 1)),\n                np.array(direction).reshape((1, mob.dim)),\n            )\n        return self\n\n    def reverse_points(self):\n        for mob in self.family_members_with_points():\n            mob.apply_over_attr_arrays(lambda arr: np.array(list(reversed(arr))))\n        return self\n\n    def repeat(self, count):\n        \"\"\"\n        This can make transition animations nicer\n        \"\"\"\n\n        def repeat_array(array):\n            return reduce(lambda a1, a2: np.append(a1, a2, axis=0), [array] * count)\n\n        for mob in self.family_members_with_points():\n            mob.apply_over_attr_arrays(repeat_array)\n        return self\n\n    # In place operations.\n    # Note, much of these are now redundant with default behavior of\n    # above methods\n\n    def apply_points_function_about_point(\n        self, func, about_point=None, about_edge=None\n    ):\n        if about_point is None:\n            if about_edge is None:\n                about_edge = ORIGIN\n            about_point = self.get_critical_point(about_edge)\n        for mob in self.family_members_with_points():\n            mob.points -= about_point\n            mob.points = func(mob.points)\n            mob.points += about_point\n        return self\n\n    def rotate_in_place(self, angle, axis=OUT):\n        # redundant with default behavior of rotate now.\n        return self.rotate(angle, axis=axis)\n\n    def scale_in_place(self, scale_factor, **kwargs):\n        # Redundant with default behavior of scale now.\n        return self.scale(scale_factor, **kwargs)\n\n    def scale_about_point(self, scale_factor, point):\n        # Redundant with default behavior of scale now.\n        return self.scale(scale_factor, about_point=point)\n\n    def pose_at_angle(self, **kwargs):\n        self.rotate(TAU / 14, RIGHT + UP, **kwargs)\n        return self\n\n    # Positioning methods\n\n    def center(self):\n        self.shift(-self.get_center())\n        return self\n\n    def align_on_border(self, direction, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):\n        \"\"\"\n        Direction just needs to be a vector pointing towards side or\n        corner in the 2d plane.\n        \"\"\"\n        target_point = np.sign(direction) * (\n            config[\"frame_x_radius\"],\n            config[\"frame_y_radius\"],\n            0,\n        )\n        point_to_align = self.get_critical_point(direction)\n        shift_val = target_point - point_to_align - buff * np.array(direction)\n        shift_val = shift_val * abs(np.sign(direction))\n        self.shift(shift_val)\n        return self\n\n    def to_corner(self, corner=LEFT + DOWN, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):\n        return self.align_on_border(corner, buff)\n\n    def to_edge(self, edge=LEFT, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):\n        return self.align_on_border(edge, buff)\n\n    def next_to(\n        self,\n        mobject_or_point,\n        direction=RIGHT,\n        buff=DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,\n        aligned_edge=ORIGIN,\n        submobject_to_align=None,\n        index_of_submobject_to_align=None,\n        coor_mask=np.array([1, 1, 1]),\n    ):\n        if isinstance(mobject_or_point, Mobject):\n            mob = mobject_or_point\n            if index_of_submobject_to_align is not None:\n                target_aligner = mob[index_of_submobject_to_align]\n            else:\n                target_aligner = mob\n            target_point = target_aligner.get_critical_point(aligned_edge + direction)\n        else:\n            target_point = mobject_or_point\n        if submobject_to_align is not None:\n            aligner = submobject_to_align\n        elif index_of_submobject_to_align is not None:\n            aligner = self[index_of_submobject_to_align]\n        else:\n            aligner = self\n        point_to_align = aligner.get_critical_point(aligned_edge - direction)\n        self.shift((target_point - point_to_align + buff * direction) * coor_mask)\n        return self\n\n    def shift_onto_screen(self, **kwargs):\n        space_lengths = [config[\"frame_x_radius\"], config[\"frame_y_radius\"]]\n        for vect in UP, DOWN, LEFT, RIGHT:\n            dim = np.argmax(np.abs(vect))\n            buff = kwargs.get(\"buff\", DEFAULT_MOBJECT_TO_EDGE_BUFFER)\n            max_val = space_lengths[dim] - buff\n            edge_center = self.get_edge_center(vect)\n            if np.dot(edge_center, vect) > max_val:\n                self.to_edge(vect, **kwargs)\n        return self\n\n    def is_off_screen(self):\n        if self.get_left()[0] > config[\"frame_x_radius\"]:\n            return True\n        if self.get_right()[0] < -config[\"frame_x_radius\"]:\n            return True\n        if self.get_bottom()[1] > config[\"frame_y_radius\"]:\n            return True\n        if self.get_top()[1] < -config[\"frame_y_radius\"]:\n            return True\n        return False\n\n    def stretch_about_point(self, factor, dim, point):\n        return self.stretch(factor, dim, about_point=point)\n\n    def stretch_in_place(self, factor, dim):\n        # Now redundant with stretch\n        return self.stretch(factor, dim)\n\n    def rescale_to_fit(self, length, dim, stretch=False, **kwargs):\n        old_length = self.length_over_dim(dim)\n        if old_length == 0:\n            return self\n        if stretch:\n            self.stretch(length / old_length, dim, **kwargs)\n        else:\n            self.scale(length / old_length, **kwargs)\n        return self\n\n    def stretch_to_fit_width(self, width, **kwargs):\n        return self.rescale_to_fit(width, 0, stretch=True, **kwargs)\n\n    def stretch_to_fit_height(self, height, **kwargs):\n        return self.rescale_to_fit(height, 1, stretch=True, **kwargs)\n\n    def stretch_to_fit_depth(self, depth, **kwargs):\n        return self.rescale_to_fit(depth, 1, stretch=True, **kwargs)\n\n    def set_width(self, width, stretch=False, **kwargs):\n        return self.rescale_to_fit(width, 0, stretch=stretch, **kwargs)\n\n    def set_height(self, height, stretch=False, **kwargs):\n        return self.rescale_to_fit(height, 1, stretch=stretch, **kwargs)\n\n    def set_depth(self, depth, stretch=False, **kwargs):\n        return self.rescale_to_fit(depth, 2, stretch=stretch, **kwargs)\n\n    def set_coord(self, value, dim, direction=ORIGIN):\n        curr = self.get_coord(dim, direction)\n        shift_vect = np.zeros(self.dim)\n        shift_vect[dim] = value - curr\n        self.shift(shift_vect)\n        return self\n\n    def set_x(self, x, direction=ORIGIN):\n        return self.set_coord(x, 0, direction)\n\n    def set_y(self, y, direction=ORIGIN):\n        return self.set_coord(y, 1, direction)\n\n    def set_z(self, z, direction=ORIGIN):\n        return self.set_coord(z, 2, direction)\n\n    def space_out_submobjects(self, factor=1.5, **kwargs):\n        self.scale(factor, **kwargs)\n        for submob in self.submobjects:\n            submob.scale(1.0 / factor)\n        return self\n\n    def move_to(\n        self, point_or_mobject, aligned_edge=ORIGIN, coor_mask=np.array([1, 1, 1])\n    ):\n        if isinstance(point_or_mobject, Mobject):\n            target = point_or_mobject.get_critical_point(aligned_edge)\n        else:\n            target = point_or_mobject\n        point_to_align = self.get_critical_point(aligned_edge)\n        self.shift((target - point_to_align) * coor_mask)\n        return self\n\n    def replace(self, mobject, dim_to_match=0, stretch=False):\n        if not mobject.get_num_points() and not mobject.submobjects:\n            raise Warning(\"Attempting to replace mobject with no points\")\n            return self\n        if stretch:\n            self.stretch_to_fit_width(mobject.get_width())\n            self.stretch_to_fit_height(mobject.get_height())\n        else:\n            self.rescale_to_fit(\n                mobject.length_over_dim(dim_to_match), dim_to_match, stretch=False\n            )\n        self.shift(mobject.get_center() - self.get_center())\n        return self\n\n    def surround(self, mobject, dim_to_match=0, stretch=False, buff=MED_SMALL_BUFF):\n        self.replace(mobject, dim_to_match, stretch)\n        length = mobject.length_over_dim(dim_to_match)\n        self.scale_in_place((length + buff) / length)\n        return self\n\n    def put_start_and_end_on(self, start, end):\n        curr_start, curr_end = self.get_start_and_end()\n        curr_vect = curr_end - curr_start\n        if np.all(curr_vect == 0):\n            raise Exception(\"Cannot position endpoints of closed loop\")\n        target_vect = np.array(end) - np.array(start)\n        self.scale(\n            get_norm(target_vect) / get_norm(curr_vect), about_point=curr_start,\n        )\n        self.rotate(\n            angle_of_vector(target_vect) - angle_of_vector(curr_vect),\n            about_point=curr_start,\n        )\n        self.shift(start - curr_start)\n        return self\n\n    # Background rectangle\n    def add_background_rectangle(self, color=BLACK, opacity=0.75, **kwargs):\n        # TODO, this does not behave well when the mobject has points,\n        # since it gets displayed on top\n        from ..mobject.shape_matchers import BackgroundRectangle\n\n        self.background_rectangle = BackgroundRectangle(\n            self, color=color, fill_opacity=opacity, **kwargs\n        )\n        self.add_to_back(self.background_rectangle)\n        return self\n\n    def add_background_rectangle_to_submobjects(self, **kwargs):\n        for submobject in self.submobjects:\n            submobject.add_background_rectangle(**kwargs)\n        return self\n\n    def add_background_rectangle_to_family_members_with_points(self, **kwargs):\n        for mob in self.family_members_with_points():\n            mob.add_background_rectangle(**kwargs)\n        return self\n\n    # Color functions\n\n    def set_color(self, color=YELLOW_C, family=True):\n        \"\"\"\n        Condition is function which takes in one arguments, (x, y, z).\n        Here it just recurses to submobjects, but in subclasses this\n        should be further implemented based on the the inner workings\n        of color\n        \"\"\"\n        if family:\n            for submob in self.submobjects:\n                submob.set_color(color, family=family)\n        self.color = color\n        return self\n\n    def set_color_by_gradient(self, *colors):\n        self.set_submobject_colors_by_gradient(*colors)\n        return self\n\n    def set_colors_by_radial_gradient(\n        self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK\n    ):\n        self.set_submobject_colors_by_radial_gradient(\n            center, radius, inner_color, outer_color\n        )\n        return self\n\n    def set_submobject_colors_by_gradient(self, *colors):\n        if len(colors) == 0:\n            raise Exception(\"Need at least one color\")\n        elif len(colors) == 1:\n            return self.set_color(*colors)\n\n        mobs = self.family_members_with_points()\n        new_colors = color_gradient(colors, len(mobs))\n\n        for mob, color in zip(mobs, new_colors):\n            mob.set_color(color, family=False)\n        return self\n\n    def set_submobject_colors_by_radial_gradient(\n        self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK\n    ):\n        if center is None:\n            center = self.get_center()\n\n        for mob in self.family_members_with_points():\n            t = get_norm(mob.get_center() - center) / radius\n            t = min(t, 1)\n            mob_color = interpolate_color(inner_color, outer_color, t)\n            mob.set_color(mob_color, family=False)\n\n        return self\n\n    def to_original_color(self):\n        self.set_color(self.color)\n        return self\n\n    def fade_to(self, color, alpha, family=True):\n        if self.get_num_points() > 0:\n            new_color = interpolate_color(self.get_color(), color, alpha)\n            self.set_color(new_color, family=False)\n        if family:\n            for submob in self.submobjects:\n                submob.fade_to(color, alpha)\n        return self\n\n    def fade(self, darkness=0.5, family=True):\n        if family:\n            for submob in self.submobjects:\n                submob.fade(darkness, family)\n        return self\n\n    def get_color(self):\n        return self.color\n\n    ##\n\n    def save_state(self, use_deepcopy=False):\n        if hasattr(self, \"saved_state\"):\n            # Prevent exponential growth of data\n            self.saved_state = None\n        if use_deepcopy:\n            self.saved_state = self.deepcopy()\n        else:\n            self.saved_state = self.copy()\n        return self\n\n    def restore(self):\n        if not hasattr(self, \"saved_state\") or self.save_state is None:\n            raise Exception(\"Trying to restore without having saved\")\n        self.become(self.saved_state)\n        return self\n\n    ##\n\n    def reduce_across_dimension(self, points_func, reduce_func, dim):\n        points = self.get_all_points()\n        if points is None or len(points) == 0:\n            # Note, this default means things like empty VGroups\n            # will appear to have a center at [0, 0, 0]\n            return 0\n        values = points_func(points[:, dim])\n        return reduce_func(values)\n\n    def nonempty_submobjects(self):\n        return [\n            submob\n            for submob in self.submobjects\n            if len(submob.submobjects) != 0 or len(submob.points) != 0\n        ]\n\n    def get_merged_array(self, array_attr):\n        result = getattr(self, array_attr)\n        for submob in self.submobjects:\n            result = np.append(result, submob.get_merged_array(array_attr), axis=0)\n            submob.get_merged_array(array_attr)\n        return result\n\n    def get_all_points(self):\n        return self.get_merged_array(\"points\")\n\n    # Getters\n\n    def get_points_defining_boundary(self):\n        return self.get_all_points()\n\n    def get_num_points(self):\n        return len(self.points)\n\n    def get_extremum_along_dim(self, points=None, dim=0, key=0):\n        if points is None:\n            points = self.get_points_defining_boundary()\n        values = points[:, dim]\n        if key < 0:\n            return np.min(values)\n        elif key == 0:\n            return (np.min(values) + np.max(values)) / 2\n        else:\n            return np.max(values)\n\n    def get_critical_point(self, direction):\n        \"\"\"\n        Picture a box bounding the mobject.  Such a box has\n        9 'critical points': 4 corners, 4 edge center, the\n        center.  This returns one of them.\n        \"\"\"\n        result = np.zeros(self.dim)\n        all_points = self.get_points_defining_boundary()\n        if len(all_points) == 0:\n            return result\n        for dim in range(self.dim):\n            result[dim] = self.get_extremum_along_dim(\n                all_points, dim=dim, key=direction[dim]\n            )\n        return result\n\n    # Pseudonyms for more general get_critical_point method\n\n    def get_edge_center(self, direction):\n        return self.get_critical_point(direction)\n\n    def get_corner(self, direction):\n        return self.get_critical_point(direction)\n\n    def get_center(self):\n        return self.get_critical_point(np.zeros(self.dim))\n\n    def get_center_of_mass(self):\n        return np.apply_along_axis(np.mean, 0, self.get_all_points())\n\n    def get_boundary_point(self, direction):\n        all_points = self.get_points_defining_boundary()\n        index = np.argmax(np.dot(all_points, np.array(direction).T))\n        return all_points[index]\n\n    def get_top(self):\n        return self.get_edge_center(UP)\n\n    def get_bottom(self):\n        return self.get_edge_center(DOWN)\n\n    def get_right(self):\n        return self.get_edge_center(RIGHT)\n\n    def get_left(self):\n        return self.get_edge_center(LEFT)\n\n    def get_zenith(self):\n        return self.get_edge_center(OUT)\n\n    def get_nadir(self):\n        return self.get_edge_center(IN)\n\n    def length_over_dim(self, dim):\n        return self.reduce_across_dimension(\n            np.max, np.max, dim\n        ) - self.reduce_across_dimension(np.min, np.min, dim)\n\n    def get_width(self):\n        return self.length_over_dim(0)\n\n    def get_height(self):\n        return self.length_over_dim(1)\n\n    def get_depth(self):\n        return self.length_over_dim(2)\n\n    def get_coord(self, dim, direction=ORIGIN):\n        \"\"\"\n        Meant to generalize get_x, get_y, get_z\n        \"\"\"\n        return self.get_extremum_along_dim(dim=dim, key=direction[dim])\n\n    def get_x(self, direction=ORIGIN):\n        return self.get_coord(0, direction)\n\n    def get_y(self, direction=ORIGIN):\n        return self.get_coord(1, direction)\n\n    def get_z(self, direction=ORIGIN):\n        return self.get_coord(2, direction)\n\n    def get_start(self):\n        self.throw_error_if_no_points()\n        return np.array(self.points[0])\n\n    def get_end(self):\n        self.throw_error_if_no_points()\n        return np.array(self.points[-1])\n\n    def get_start_and_end(self):\n        return self.get_start(), self.get_end()\n\n    def point_from_proportion(self, alpha):\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def get_pieces(self, n_pieces):\n        template = self.copy()\n        template.submobjects = []\n        alphas = np.linspace(0, 1, n_pieces + 1)\n        return Group(\n            *[\n                template.copy().pointwise_become_partial(self, a1, a2)\n                for a1, a2 in zip(alphas[:-1], alphas[1:])\n            ]\n        )\n\n    def get_z_index_reference_point(self):\n        # TODO, better place to define default z_index_group?\n        z_index_group = getattr(self, \"z_index_group\", self)\n        return z_index_group.get_center()\n\n    def has_points(self):\n        return len(self.points) > 0\n\n    def has_no_points(self):\n        return not self.has_points()\n\n    # Match other mobject properties\n\n    def match_color(self, mobject):\n        return self.set_color(mobject.get_color())\n\n    def match_dim_size(self, mobject, dim, **kwargs):\n        return self.rescale_to_fit(mobject.length_over_dim(dim), dim, **kwargs)\n\n    def match_width(self, mobject, **kwargs):\n        return self.match_dim_size(mobject, 0, **kwargs)\n\n    def match_height(self, mobject, **kwargs):\n        return self.match_dim_size(mobject, 1, **kwargs)\n\n    def match_depth(self, mobject, **kwargs):\n        return self.match_dim_size(mobject, 2, **kwargs)\n\n    def match_coord(self, mobject, dim, direction=ORIGIN):\n        return self.set_coord(\n            mobject.get_coord(dim, direction), dim=dim, direction=direction,\n        )\n\n    def match_x(self, mobject, direction=ORIGIN):\n        return self.match_coord(mobject, 0, direction)\n\n    def match_y(self, mobject, direction=ORIGIN):\n        return self.match_coord(mobject, 1, direction)\n\n    def match_z(self, mobject, direction=ORIGIN):\n        return self.match_coord(mobject, 2, direction)\n\n    def align_to(self, mobject_or_point, direction=ORIGIN, alignment_vect=UP):\n        \"\"\"\n        Examples:\n        mob1.align_to(mob2, UP) moves mob1 vertically so that its\n        top edge lines ups with mob2's top edge.\n\n        mob1.align_to(mob2, alignment_vect = RIGHT) moves mob1\n        horizontally so that it's center is directly above/below\n        the center of mob2\n        \"\"\"\n        if isinstance(mobject_or_point, Mobject):\n            point = mobject_or_point.get_critical_point(direction)\n        else:\n            point = mobject_or_point\n\n        for dim in range(self.dim):\n            if direction[dim] != 0:\n                self.set_coord(point[dim], dim, direction)\n        return self\n\n    # Family matters\n\n    def __getitem__(self, value):\n        self_list = self.split()\n        if isinstance(value, slice):\n            GroupClass = self.get_group_class()\n            return GroupClass(*self_list.__getitem__(value))\n        return self_list.__getitem__(value)\n\n    def __iter__(self):\n        return iter(self.split())\n\n    def __len__(self):\n        return len(self.split())\n\n    def get_group_class(self):\n        return Group\n\n    def split(self):\n        result = [self] if len(self.points) > 0 else []\n        return result + self.submobjects\n\n    def get_family(self):\n        sub_families = list(map(Mobject.get_family, self.submobjects))\n        all_mobjects = [self] + list(it.chain(*sub_families))\n        return remove_list_redundancies(all_mobjects)\n\n    def family_members_with_points(self):\n        return [m for m in self.get_family() if m.get_num_points() > 0]\n\n    def arrange(self, direction=RIGHT, center=True, **kwargs):\n        for m1, m2 in zip(self.submobjects, self.submobjects[1:]):\n            m2.next_to(m1, direction, **kwargs)\n        if center:\n            self.center()\n        return self\n\n    def arrange_in_grid(self, n_rows=None, n_cols=None, **kwargs):\n        submobs = self.submobjects\n        if n_rows is None and n_cols is None:\n            n_cols = int(np.sqrt(len(submobs)))\n\n        if n_rows is not None:\n            v1 = RIGHT\n            v2 = DOWN\n            n = len(submobs) // n_rows\n        elif n_cols is not None:\n            v1 = DOWN\n            v2 = RIGHT\n            n = len(submobs) // n_cols\n        Group(\n            *[\n                Group(*submobs[i : i + n]).arrange(v1, **kwargs)\n                for i in range(0, len(submobs), n)\n            ]\n        ).arrange(v2, **kwargs)\n        return self\n\n    def sort(self, point_to_num_func=lambda p: p[0], submob_func=None):\n        if submob_func is None:\n            submob_func = lambda m: point_to_num_func(m.get_center())\n        self.submobjects.sort(key=submob_func)\n        return self\n\n    def shuffle(self, recursive=False):\n        if recursive:\n            for submob in self.submobjects:\n                submob.shuffle(recursive=True)\n        random.shuffle(self.submobjects)\n\n    # Just here to keep from breaking old scenes.\n    def arrange_submobjects(self, *args, **kwargs):\n        return self.arrange(*args, **kwargs)\n\n    def sort_submobjects(self, *args, **kwargs):\n        return self.sort(*args, **kwargs)\n\n    def shuffle_submobjects(self, *args, **kwargs):\n        return self.shuffle(*args, **kwargs)\n\n    # Alignment\n    def align_data(self, mobject):\n        self.null_point_align(mobject)\n        self.align_submobjects(mobject)\n        self.align_points(mobject)\n        # Recurse\n        for m1, m2 in zip(self.submobjects, mobject.submobjects):\n            m1.align_data(m2)\n\n    def get_point_mobject(self, center=None):\n        \"\"\"\n        The simplest mobject to be transformed to or from self.\n        Should by a point of the appropriate type\n        \"\"\"\n        msg = f\"get_point_mobject not implemented for {self.__class__.__name__}\"\n        raise NotImplementedError(msg)\n\n    def align_points(self, mobject):\n        count1 = self.get_num_points()\n        count2 = mobject.get_num_points()\n        if count1 < count2:\n            self.align_points_with_larger(mobject)\n        elif count2 < count1:\n            mobject.align_points_with_larger(self)\n        return self\n\n    def align_points_with_larger(self, larger_mobject):\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def align_submobjects(self, mobject):\n        mob1 = self\n        mob2 = mobject\n        n1 = len(mob1.submobjects)\n        n2 = len(mob2.submobjects)\n        mob1.add_n_more_submobjects(max(0, n2 - n1))\n        mob2.add_n_more_submobjects(max(0, n1 - n2))\n        return self\n\n    def null_point_align(self, mobject):\n        \"\"\"\n        If a mobject with points is being aligned to\n        one without, treat both as groups, and push\n        the one with points into its own submobjects\n        list.\n        \"\"\"\n        for m1, m2 in (self, mobject), (mobject, self):\n            if m1.has_no_points() and m2.has_points():\n                m2.push_self_into_submobjects()\n        return self\n\n    def push_self_into_submobjects(self):\n        copy = self.copy()\n        copy.submobjects = []\n        self.reset_points()\n        self.add(copy)\n        return self\n\n    def add_n_more_submobjects(self, n):\n        if n == 0:\n            return\n\n        curr = len(self.submobjects)\n        if curr == 0:\n            # If empty, simply add n point mobjects\n            self.submobjects = [self.get_point_mobject() for k in range(n)]\n            return\n\n        target = curr + n\n        # TODO, factor this out to utils so as to reuse\n        # with VMobject.insert_n_curves\n        repeat_indices = (np.arange(target) * curr) // target\n        split_factors = [sum(repeat_indices == i) for i in range(curr)]\n        new_submobs = []\n        for submob, sf in zip(self.submobjects, split_factors):\n            new_submobs.append(submob)\n            for k in range(1, sf):\n                new_submobs.append(submob.copy().fade(1))\n        self.submobjects = new_submobs\n        return self\n\n    def repeat_submobject(self, submob):\n        return submob.copy()\n\n    def interpolate(self, mobject1, mobject2, alpha, path_func=straight_path):\n        \"\"\"\n        Turns self into an interpolation between mobject1\n        and mobject2.\n        \"\"\"\n        self.points = path_func(mobject1.points, mobject2.points, alpha)\n        self.interpolate_color(mobject1, mobject2, alpha)\n        return self\n\n    def interpolate_color(self, mobject1, mobject2, alpha):\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def pointwise_become_partial(self, mobject, a, b):\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def become(self, mobject, copy_submobjects=True):\n        \"\"\"\n        Edit points, colors and submobjects to be idential\n        to another mobject\n        \"\"\"\n        self.align_data(mobject)\n        for sm1, sm2 in zip(self.get_family(), mobject.get_family()):\n            sm1.points = np.array(sm2.points)\n            sm1.interpolate_color(sm1, sm2, 1)\n        return self\n\n    # Errors\n    def throw_error_if_no_points(self):\n        if self.has_no_points():\n            message = \"Cannot call Mobject.{} \" + \"for a Mobject with no points\"\n            caller_name = sys._getframe(1).f_code.co_name\n            raise Exception(message.format(caller_name))\n\n    # About z-index\n    def set_z_index(self, z_index_value):\n        \"\"\"Sets the mobject's :attr:`z_index` to the value specified in `z_index_value`.\n\n        Parameters\n        ----------\n        z_index_value : Union[:class:`int`, :class:`float`]\n            The new value of :attr:`z_index` set.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)\n        \"\"\"\n        self.z_index = z_index_value\n        return self\n\n    def set_z_index_by_z_coordinate(self):\n        \"\"\"Sets the mobject's z coordinate to the value of :attr:`z_index`.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)\n        \"\"\"\n        z_coord = self.get_center()[-1]\n        self.set_z_index(z_coord)\n        return self",
  "class Group(Mobject):\n    def __init__(self, *mobjects, **kwargs):\n        if not all([isinstance(m, Mobject) for m in mobjects]):\n            raise Exception(\"All submobjects must be of type Mobject\")\n        Mobject.__init__(self, **kwargs)\n        self.add(*mobjects)",
  "def __init__(self, **kwargs):\n        Container.__init__(self, **kwargs)\n        self.submobjects = []\n        self.color = Color(self.color)\n        if self.name is None:\n            self.name = self.__class__.__name__\n        self.updaters = []\n        self.updating_suspended = False\n        self.reset_points()\n        self.generate_points()\n        self.init_colors()",
  "def __str__(self):\n        return str(self.name)",
  "def reset_points(self):\n        self.points = np.zeros((0, self.dim))",
  "def init_colors(self):\n        # For subclasses\n        pass",
  "def generate_points(self):\n        # Typically implemented in subclass, unless purposefully left blank\n        pass",
  "def add(self, *mobjects):\n        if self in mobjects:\n            raise Exception(\"Mobject cannot contain self\")\n        self.submobjects = list_update(self.submobjects, mobjects)\n        return self",
  "def add_to_back(self, *mobjects):\n        self.remove(*mobjects)\n        self.submobjects = list(mobjects) + self.submobjects\n        return self",
  "def remove(self, *mobjects):\n        for mobject in mobjects:\n            if mobject in self.submobjects:\n                self.submobjects.remove(mobject)\n        return self",
  "def get_array_attrs(self):\n        return [\"points\"]",
  "def digest_mobject_attrs(self):\n        \"\"\"\n        Ensures all attributes which are mobjects are included\n        in the submobjects list.\n        \"\"\"\n        mobject_attrs = [\n            x for x in list(self.__dict__.values()) if isinstance(x, Mobject)\n        ]\n        self.submobjects = list_update(self.submobjects, mobject_attrs)\n        return self",
  "def apply_over_attr_arrays(self, func):\n        for attr in self.get_array_attrs():\n            setattr(self, attr, func(getattr(self, attr)))\n        return self",
  "def get_image(self, camera=None):\n        if camera is None:\n            from ..camera.camera import Camera\n\n            camera = Camera()\n        camera.capture_mobject(self)\n        return camera.get_image()",
  "def show(self, camera=None):\n        self.get_image(camera=camera).show()",
  "def save_image(self, name=None):\n        self.get_image().save(\n            os.path.join(config[\"VIDEO_DIR\"], (name or str(self)) + \".png\")\n        )",
  "def copy(self):\n        # TODO, either justify reason for shallow copy, or\n        # remove this redundancy everywhere\n        # return self.deepcopy()\n\n        copy_mobject = copy.copy(self)\n        copy_mobject.points = np.array(self.points)\n        copy_mobject.submobjects = [submob.copy() for submob in self.submobjects]\n        copy_mobject.updaters = list(self.updaters)\n        family = self.get_family()\n        for attr, value in list(self.__dict__.items()):\n            if isinstance(value, Mobject) and value in family and value is not self:\n                setattr(copy_mobject, attr, value.copy())\n            if isinstance(value, np.ndarray):\n                setattr(copy_mobject, attr, np.array(value))\n        return copy_mobject",
  "def deepcopy(self):\n        return copy.deepcopy(self)",
  "def generate_target(self, use_deepcopy=False):\n        self.target = None  # Prevent exponential explosion\n        if use_deepcopy:\n            self.target = self.deepcopy()\n        else:\n            self.target = self.copy()\n        return self.target",
  "def update(self, dt=0, recursive=True):\n        if self.updating_suspended:\n            return self\n        for updater in self.updaters:\n            parameters = get_parameters(updater)\n            if \"dt\" in parameters:\n                updater(self, dt)\n            else:\n                updater(self)\n        if recursive:\n            for submob in self.submobjects:\n                submob.update(dt, recursive)\n        return self",
  "def get_time_based_updaters(self):\n        return [updater for updater in self.updaters if \"dt\" in get_parameters(updater)]",
  "def has_time_based_updater(self):\n        for updater in self.updaters:\n            if \"dt\" in get_parameters(updater):\n                return True\n        return False",
  "def get_updaters(self):\n        return self.updaters",
  "def get_family_updaters(self):\n        return list(it.chain(*[sm.get_updaters() for sm in self.get_family()]))",
  "def add_updater(self, update_function, index=None, call_updater=True):\n        if index is None:\n            self.updaters.append(update_function)\n        else:\n            self.updaters.insert(index, update_function)\n        if call_updater:\n            self.update(0)\n        return self",
  "def remove_updater(self, update_function):\n        while update_function in self.updaters:\n            self.updaters.remove(update_function)\n        return self",
  "def clear_updaters(self, recursive=True):\n        self.updaters = []\n        if recursive:\n            for submob in self.submobjects:\n                submob.clear_updaters()\n        return self",
  "def match_updaters(self, mobject):\n        self.clear_updaters()\n        for updater in mobject.get_updaters():\n            self.add_updater(updater)\n        return self",
  "def suspend_updating(self, recursive=True):\n        self.updating_suspended = True\n        if recursive:\n            for submob in self.submobjects:\n                submob.suspend_updating(recursive)\n        return self",
  "def resume_updating(self, recursive=True):\n        self.updating_suspended = False\n        if recursive:\n            for submob in self.submobjects:\n                submob.resume_updating(recursive)\n        self.update(dt=0, recursive=recursive)\n        return self",
  "def apply_to_family(self, func):\n        for mob in self.family_members_with_points():\n            func(mob)",
  "def shift(self, *vectors):\n        total_vector = reduce(op.add, vectors)\n        for mob in self.family_members_with_points():\n            mob.points = mob.points.astype(\"float\")\n            mob.points += total_vector\n        return self",
  "def scale(self, scale_factor, **kwargs):\n        \"\"\"\n        Default behavior is to scale about the center of the mobject.\n        The argument about_edge can be a vector, indicating which side of\n        the mobject to scale about, e.g., mob.scale(about_edge = RIGHT)\n        scales about mob.get_right().\n\n        Otherwise, if about_point is given a value, scaling is done with\n        respect to that point.\n        \"\"\"\n        self.apply_points_function_about_point(\n            lambda points: scale_factor * points, **kwargs\n        )\n        return self",
  "def rotate_about_origin(self, angle, axis=OUT, axes=[]):\n        return self.rotate(angle, axis, about_point=ORIGIN)",
  "def rotate(self, angle, axis=OUT, **kwargs):\n        rot_matrix = rotation_matrix(angle, axis)\n        self.apply_points_function_about_point(\n            lambda points: np.dot(points, rot_matrix.T), **kwargs\n        )\n        return self",
  "def flip(self, axis=UP, **kwargs):\n        return self.rotate(TAU / 2, axis, **kwargs)",
  "def stretch(self, factor, dim, **kwargs):\n        def func(points):\n            points[:, dim] *= factor\n            return points\n\n        self.apply_points_function_about_point(func, **kwargs)\n        return self",
  "def apply_function(self, function, **kwargs):\n        # Default to applying matrix about the origin, not mobjects center\n        if len(kwargs) == 0:\n            kwargs[\"about_point\"] = ORIGIN\n        self.apply_points_function_about_point(\n            lambda points: np.apply_along_axis(function, 1, points), **kwargs\n        )\n        return self",
  "def apply_function_to_position(self, function):\n        self.move_to(function(self.get_center()))\n        return self",
  "def apply_function_to_submobject_positions(self, function):\n        for submob in self.submobjects:\n            submob.apply_function_to_position(function)\n        return self",
  "def apply_matrix(self, matrix, **kwargs):\n        # Default to applying matrix about the origin, not mobjects center\n        if (\"about_point\" not in kwargs) and (\"about_edge\" not in kwargs):\n            kwargs[\"about_point\"] = ORIGIN\n        full_matrix = np.identity(self.dim)\n        matrix = np.array(matrix)\n        full_matrix[: matrix.shape[0], : matrix.shape[1]] = matrix\n        self.apply_points_function_about_point(\n            lambda points: np.dot(points, full_matrix.T), **kwargs\n        )\n        return self",
  "def apply_complex_function(self, function, **kwargs):\n        def R3_func(point):\n            x, y, z = point\n            xy_complex = function(complex(x, y))\n            return [xy_complex.real, xy_complex.imag, z]\n\n        return self.apply_function(R3_func)",
  "def wag(self, direction=RIGHT, axis=DOWN, wag_factor=1.0):\n        for mob in self.family_members_with_points():\n            alphas = np.dot(mob.points, np.transpose(axis))\n            alphas -= min(alphas)\n            alphas /= max(alphas)\n            alphas = alphas ** wag_factor\n            mob.points += np.dot(\n                alphas.reshape((len(alphas), 1)),\n                np.array(direction).reshape((1, mob.dim)),\n            )\n        return self",
  "def reverse_points(self):\n        for mob in self.family_members_with_points():\n            mob.apply_over_attr_arrays(lambda arr: np.array(list(reversed(arr))))\n        return self",
  "def repeat(self, count):\n        \"\"\"\n        This can make transition animations nicer\n        \"\"\"\n\n        def repeat_array(array):\n            return reduce(lambda a1, a2: np.append(a1, a2, axis=0), [array] * count)\n\n        for mob in self.family_members_with_points():\n            mob.apply_over_attr_arrays(repeat_array)\n        return self",
  "def apply_points_function_about_point(\n        self, func, about_point=None, about_edge=None\n    ):\n        if about_point is None:\n            if about_edge is None:\n                about_edge = ORIGIN\n            about_point = self.get_critical_point(about_edge)\n        for mob in self.family_members_with_points():\n            mob.points -= about_point\n            mob.points = func(mob.points)\n            mob.points += about_point\n        return self",
  "def rotate_in_place(self, angle, axis=OUT):\n        # redundant with default behavior of rotate now.\n        return self.rotate(angle, axis=axis)",
  "def scale_in_place(self, scale_factor, **kwargs):\n        # Redundant with default behavior of scale now.\n        return self.scale(scale_factor, **kwargs)",
  "def scale_about_point(self, scale_factor, point):\n        # Redundant with default behavior of scale now.\n        return self.scale(scale_factor, about_point=point)",
  "def pose_at_angle(self, **kwargs):\n        self.rotate(TAU / 14, RIGHT + UP, **kwargs)\n        return self",
  "def center(self):\n        self.shift(-self.get_center())\n        return self",
  "def align_on_border(self, direction, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):\n        \"\"\"\n        Direction just needs to be a vector pointing towards side or\n        corner in the 2d plane.\n        \"\"\"\n        target_point = np.sign(direction) * (\n            config[\"frame_x_radius\"],\n            config[\"frame_y_radius\"],\n            0,\n        )\n        point_to_align = self.get_critical_point(direction)\n        shift_val = target_point - point_to_align - buff * np.array(direction)\n        shift_val = shift_val * abs(np.sign(direction))\n        self.shift(shift_val)\n        return self",
  "def to_corner(self, corner=LEFT + DOWN, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):\n        return self.align_on_border(corner, buff)",
  "def to_edge(self, edge=LEFT, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER):\n        return self.align_on_border(edge, buff)",
  "def next_to(\n        self,\n        mobject_or_point,\n        direction=RIGHT,\n        buff=DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,\n        aligned_edge=ORIGIN,\n        submobject_to_align=None,\n        index_of_submobject_to_align=None,\n        coor_mask=np.array([1, 1, 1]),\n    ):\n        if isinstance(mobject_or_point, Mobject):\n            mob = mobject_or_point\n            if index_of_submobject_to_align is not None:\n                target_aligner = mob[index_of_submobject_to_align]\n            else:\n                target_aligner = mob\n            target_point = target_aligner.get_critical_point(aligned_edge + direction)\n        else:\n            target_point = mobject_or_point\n        if submobject_to_align is not None:\n            aligner = submobject_to_align\n        elif index_of_submobject_to_align is not None:\n            aligner = self[index_of_submobject_to_align]\n        else:\n            aligner = self\n        point_to_align = aligner.get_critical_point(aligned_edge - direction)\n        self.shift((target_point - point_to_align + buff * direction) * coor_mask)\n        return self",
  "def shift_onto_screen(self, **kwargs):\n        space_lengths = [config[\"frame_x_radius\"], config[\"frame_y_radius\"]]\n        for vect in UP, DOWN, LEFT, RIGHT:\n            dim = np.argmax(np.abs(vect))\n            buff = kwargs.get(\"buff\", DEFAULT_MOBJECT_TO_EDGE_BUFFER)\n            max_val = space_lengths[dim] - buff\n            edge_center = self.get_edge_center(vect)\n            if np.dot(edge_center, vect) > max_val:\n                self.to_edge(vect, **kwargs)\n        return self",
  "def is_off_screen(self):\n        if self.get_left()[0] > config[\"frame_x_radius\"]:\n            return True\n        if self.get_right()[0] < -config[\"frame_x_radius\"]:\n            return True\n        if self.get_bottom()[1] > config[\"frame_y_radius\"]:\n            return True\n        if self.get_top()[1] < -config[\"frame_y_radius\"]:\n            return True\n        return False",
  "def stretch_about_point(self, factor, dim, point):\n        return self.stretch(factor, dim, about_point=point)",
  "def stretch_in_place(self, factor, dim):\n        # Now redundant with stretch\n        return self.stretch(factor, dim)",
  "def rescale_to_fit(self, length, dim, stretch=False, **kwargs):\n        old_length = self.length_over_dim(dim)\n        if old_length == 0:\n            return self\n        if stretch:\n            self.stretch(length / old_length, dim, **kwargs)\n        else:\n            self.scale(length / old_length, **kwargs)\n        return self",
  "def stretch_to_fit_width(self, width, **kwargs):\n        return self.rescale_to_fit(width, 0, stretch=True, **kwargs)",
  "def stretch_to_fit_height(self, height, **kwargs):\n        return self.rescale_to_fit(height, 1, stretch=True, **kwargs)",
  "def stretch_to_fit_depth(self, depth, **kwargs):\n        return self.rescale_to_fit(depth, 1, stretch=True, **kwargs)",
  "def set_width(self, width, stretch=False, **kwargs):\n        return self.rescale_to_fit(width, 0, stretch=stretch, **kwargs)",
  "def set_height(self, height, stretch=False, **kwargs):\n        return self.rescale_to_fit(height, 1, stretch=stretch, **kwargs)",
  "def set_depth(self, depth, stretch=False, **kwargs):\n        return self.rescale_to_fit(depth, 2, stretch=stretch, **kwargs)",
  "def set_coord(self, value, dim, direction=ORIGIN):\n        curr = self.get_coord(dim, direction)\n        shift_vect = np.zeros(self.dim)\n        shift_vect[dim] = value - curr\n        self.shift(shift_vect)\n        return self",
  "def set_x(self, x, direction=ORIGIN):\n        return self.set_coord(x, 0, direction)",
  "def set_y(self, y, direction=ORIGIN):\n        return self.set_coord(y, 1, direction)",
  "def set_z(self, z, direction=ORIGIN):\n        return self.set_coord(z, 2, direction)",
  "def space_out_submobjects(self, factor=1.5, **kwargs):\n        self.scale(factor, **kwargs)\n        for submob in self.submobjects:\n            submob.scale(1.0 / factor)\n        return self",
  "def move_to(\n        self, point_or_mobject, aligned_edge=ORIGIN, coor_mask=np.array([1, 1, 1])\n    ):\n        if isinstance(point_or_mobject, Mobject):\n            target = point_or_mobject.get_critical_point(aligned_edge)\n        else:\n            target = point_or_mobject\n        point_to_align = self.get_critical_point(aligned_edge)\n        self.shift((target - point_to_align) * coor_mask)\n        return self",
  "def replace(self, mobject, dim_to_match=0, stretch=False):\n        if not mobject.get_num_points() and not mobject.submobjects:\n            raise Warning(\"Attempting to replace mobject with no points\")\n            return self\n        if stretch:\n            self.stretch_to_fit_width(mobject.get_width())\n            self.stretch_to_fit_height(mobject.get_height())\n        else:\n            self.rescale_to_fit(\n                mobject.length_over_dim(dim_to_match), dim_to_match, stretch=False\n            )\n        self.shift(mobject.get_center() - self.get_center())\n        return self",
  "def surround(self, mobject, dim_to_match=0, stretch=False, buff=MED_SMALL_BUFF):\n        self.replace(mobject, dim_to_match, stretch)\n        length = mobject.length_over_dim(dim_to_match)\n        self.scale_in_place((length + buff) / length)\n        return self",
  "def put_start_and_end_on(self, start, end):\n        curr_start, curr_end = self.get_start_and_end()\n        curr_vect = curr_end - curr_start\n        if np.all(curr_vect == 0):\n            raise Exception(\"Cannot position endpoints of closed loop\")\n        target_vect = np.array(end) - np.array(start)\n        self.scale(\n            get_norm(target_vect) / get_norm(curr_vect), about_point=curr_start,\n        )\n        self.rotate(\n            angle_of_vector(target_vect) - angle_of_vector(curr_vect),\n            about_point=curr_start,\n        )\n        self.shift(start - curr_start)\n        return self",
  "def add_background_rectangle(self, color=BLACK, opacity=0.75, **kwargs):\n        # TODO, this does not behave well when the mobject has points,\n        # since it gets displayed on top\n        from ..mobject.shape_matchers import BackgroundRectangle\n\n        self.background_rectangle = BackgroundRectangle(\n            self, color=color, fill_opacity=opacity, **kwargs\n        )\n        self.add_to_back(self.background_rectangle)\n        return self",
  "def add_background_rectangle_to_submobjects(self, **kwargs):\n        for submobject in self.submobjects:\n            submobject.add_background_rectangle(**kwargs)\n        return self",
  "def add_background_rectangle_to_family_members_with_points(self, **kwargs):\n        for mob in self.family_members_with_points():\n            mob.add_background_rectangle(**kwargs)\n        return self",
  "def set_color(self, color=YELLOW_C, family=True):\n        \"\"\"\n        Condition is function which takes in one arguments, (x, y, z).\n        Here it just recurses to submobjects, but in subclasses this\n        should be further implemented based on the the inner workings\n        of color\n        \"\"\"\n        if family:\n            for submob in self.submobjects:\n                submob.set_color(color, family=family)\n        self.color = color\n        return self",
  "def set_color_by_gradient(self, *colors):\n        self.set_submobject_colors_by_gradient(*colors)\n        return self",
  "def set_colors_by_radial_gradient(\n        self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK\n    ):\n        self.set_submobject_colors_by_radial_gradient(\n            center, radius, inner_color, outer_color\n        )\n        return self",
  "def set_submobject_colors_by_gradient(self, *colors):\n        if len(colors) == 0:\n            raise Exception(\"Need at least one color\")\n        elif len(colors) == 1:\n            return self.set_color(*colors)\n\n        mobs = self.family_members_with_points()\n        new_colors = color_gradient(colors, len(mobs))\n\n        for mob, color in zip(mobs, new_colors):\n            mob.set_color(color, family=False)\n        return self",
  "def set_submobject_colors_by_radial_gradient(\n        self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK\n    ):\n        if center is None:\n            center = self.get_center()\n\n        for mob in self.family_members_with_points():\n            t = get_norm(mob.get_center() - center) / radius\n            t = min(t, 1)\n            mob_color = interpolate_color(inner_color, outer_color, t)\n            mob.set_color(mob_color, family=False)\n\n        return self",
  "def to_original_color(self):\n        self.set_color(self.color)\n        return self",
  "def fade_to(self, color, alpha, family=True):\n        if self.get_num_points() > 0:\n            new_color = interpolate_color(self.get_color(), color, alpha)\n            self.set_color(new_color, family=False)\n        if family:\n            for submob in self.submobjects:\n                submob.fade_to(color, alpha)\n        return self",
  "def fade(self, darkness=0.5, family=True):\n        if family:\n            for submob in self.submobjects:\n                submob.fade(darkness, family)\n        return self",
  "def get_color(self):\n        return self.color",
  "def save_state(self, use_deepcopy=False):\n        if hasattr(self, \"saved_state\"):\n            # Prevent exponential growth of data\n            self.saved_state = None\n        if use_deepcopy:\n            self.saved_state = self.deepcopy()\n        else:\n            self.saved_state = self.copy()\n        return self",
  "def restore(self):\n        if not hasattr(self, \"saved_state\") or self.save_state is None:\n            raise Exception(\"Trying to restore without having saved\")\n        self.become(self.saved_state)\n        return self",
  "def reduce_across_dimension(self, points_func, reduce_func, dim):\n        points = self.get_all_points()\n        if points is None or len(points) == 0:\n            # Note, this default means things like empty VGroups\n            # will appear to have a center at [0, 0, 0]\n            return 0\n        values = points_func(points[:, dim])\n        return reduce_func(values)",
  "def nonempty_submobjects(self):\n        return [\n            submob\n            for submob in self.submobjects\n            if len(submob.submobjects) != 0 or len(submob.points) != 0\n        ]",
  "def get_merged_array(self, array_attr):\n        result = getattr(self, array_attr)\n        for submob in self.submobjects:\n            result = np.append(result, submob.get_merged_array(array_attr), axis=0)\n            submob.get_merged_array(array_attr)\n        return result",
  "def get_all_points(self):\n        return self.get_merged_array(\"points\")",
  "def get_points_defining_boundary(self):\n        return self.get_all_points()",
  "def get_num_points(self):\n        return len(self.points)",
  "def get_extremum_along_dim(self, points=None, dim=0, key=0):\n        if points is None:\n            points = self.get_points_defining_boundary()\n        values = points[:, dim]\n        if key < 0:\n            return np.min(values)\n        elif key == 0:\n            return (np.min(values) + np.max(values)) / 2\n        else:\n            return np.max(values)",
  "def get_critical_point(self, direction):\n        \"\"\"\n        Picture a box bounding the mobject.  Such a box has\n        9 'critical points': 4 corners, 4 edge center, the\n        center.  This returns one of them.\n        \"\"\"\n        result = np.zeros(self.dim)\n        all_points = self.get_points_defining_boundary()\n        if len(all_points) == 0:\n            return result\n        for dim in range(self.dim):\n            result[dim] = self.get_extremum_along_dim(\n                all_points, dim=dim, key=direction[dim]\n            )\n        return result",
  "def get_edge_center(self, direction):\n        return self.get_critical_point(direction)",
  "def get_corner(self, direction):\n        return self.get_critical_point(direction)",
  "def get_center(self):\n        return self.get_critical_point(np.zeros(self.dim))",
  "def get_center_of_mass(self):\n        return np.apply_along_axis(np.mean, 0, self.get_all_points())",
  "def get_boundary_point(self, direction):\n        all_points = self.get_points_defining_boundary()\n        index = np.argmax(np.dot(all_points, np.array(direction).T))\n        return all_points[index]",
  "def get_top(self):\n        return self.get_edge_center(UP)",
  "def get_bottom(self):\n        return self.get_edge_center(DOWN)",
  "def get_right(self):\n        return self.get_edge_center(RIGHT)",
  "def get_left(self):\n        return self.get_edge_center(LEFT)",
  "def get_zenith(self):\n        return self.get_edge_center(OUT)",
  "def get_nadir(self):\n        return self.get_edge_center(IN)",
  "def length_over_dim(self, dim):\n        return self.reduce_across_dimension(\n            np.max, np.max, dim\n        ) - self.reduce_across_dimension(np.min, np.min, dim)",
  "def get_width(self):\n        return self.length_over_dim(0)",
  "def get_height(self):\n        return self.length_over_dim(1)",
  "def get_depth(self):\n        return self.length_over_dim(2)",
  "def get_coord(self, dim, direction=ORIGIN):\n        \"\"\"\n        Meant to generalize get_x, get_y, get_z\n        \"\"\"\n        return self.get_extremum_along_dim(dim=dim, key=direction[dim])",
  "def get_x(self, direction=ORIGIN):\n        return self.get_coord(0, direction)",
  "def get_y(self, direction=ORIGIN):\n        return self.get_coord(1, direction)",
  "def get_z(self, direction=ORIGIN):\n        return self.get_coord(2, direction)",
  "def get_start(self):\n        self.throw_error_if_no_points()\n        return np.array(self.points[0])",
  "def get_end(self):\n        self.throw_error_if_no_points()\n        return np.array(self.points[-1])",
  "def get_start_and_end(self):\n        return self.get_start(), self.get_end()",
  "def point_from_proportion(self, alpha):\n        raise NotImplementedError(\"Please override in a child class.\")",
  "def get_pieces(self, n_pieces):\n        template = self.copy()\n        template.submobjects = []\n        alphas = np.linspace(0, 1, n_pieces + 1)\n        return Group(\n            *[\n                template.copy().pointwise_become_partial(self, a1, a2)\n                for a1, a2 in zip(alphas[:-1], alphas[1:])\n            ]\n        )",
  "def get_z_index_reference_point(self):\n        # TODO, better place to define default z_index_group?\n        z_index_group = getattr(self, \"z_index_group\", self)\n        return z_index_group.get_center()",
  "def has_points(self):\n        return len(self.points) > 0",
  "def has_no_points(self):\n        return not self.has_points()",
  "def match_color(self, mobject):\n        return self.set_color(mobject.get_color())",
  "def match_dim_size(self, mobject, dim, **kwargs):\n        return self.rescale_to_fit(mobject.length_over_dim(dim), dim, **kwargs)",
  "def match_width(self, mobject, **kwargs):\n        return self.match_dim_size(mobject, 0, **kwargs)",
  "def match_height(self, mobject, **kwargs):\n        return self.match_dim_size(mobject, 1, **kwargs)",
  "def match_depth(self, mobject, **kwargs):\n        return self.match_dim_size(mobject, 2, **kwargs)",
  "def match_coord(self, mobject, dim, direction=ORIGIN):\n        return self.set_coord(\n            mobject.get_coord(dim, direction), dim=dim, direction=direction,\n        )",
  "def match_x(self, mobject, direction=ORIGIN):\n        return self.match_coord(mobject, 0, direction)",
  "def match_y(self, mobject, direction=ORIGIN):\n        return self.match_coord(mobject, 1, direction)",
  "def match_z(self, mobject, direction=ORIGIN):\n        return self.match_coord(mobject, 2, direction)",
  "def align_to(self, mobject_or_point, direction=ORIGIN, alignment_vect=UP):\n        \"\"\"\n        Examples:\n        mob1.align_to(mob2, UP) moves mob1 vertically so that its\n        top edge lines ups with mob2's top edge.\n\n        mob1.align_to(mob2, alignment_vect = RIGHT) moves mob1\n        horizontally so that it's center is directly above/below\n        the center of mob2\n        \"\"\"\n        if isinstance(mobject_or_point, Mobject):\n            point = mobject_or_point.get_critical_point(direction)\n        else:\n            point = mobject_or_point\n\n        for dim in range(self.dim):\n            if direction[dim] != 0:\n                self.set_coord(point[dim], dim, direction)\n        return self",
  "def __getitem__(self, value):\n        self_list = self.split()\n        if isinstance(value, slice):\n            GroupClass = self.get_group_class()\n            return GroupClass(*self_list.__getitem__(value))\n        return self_list.__getitem__(value)",
  "def __iter__(self):\n        return iter(self.split())",
  "def __len__(self):\n        return len(self.split())",
  "def get_group_class(self):\n        return Group",
  "def split(self):\n        result = [self] if len(self.points) > 0 else []\n        return result + self.submobjects",
  "def get_family(self):\n        sub_families = list(map(Mobject.get_family, self.submobjects))\n        all_mobjects = [self] + list(it.chain(*sub_families))\n        return remove_list_redundancies(all_mobjects)",
  "def family_members_with_points(self):\n        return [m for m in self.get_family() if m.get_num_points() > 0]",
  "def arrange(self, direction=RIGHT, center=True, **kwargs):\n        for m1, m2 in zip(self.submobjects, self.submobjects[1:]):\n            m2.next_to(m1, direction, **kwargs)\n        if center:\n            self.center()\n        return self",
  "def arrange_in_grid(self, n_rows=None, n_cols=None, **kwargs):\n        submobs = self.submobjects\n        if n_rows is None and n_cols is None:\n            n_cols = int(np.sqrt(len(submobs)))\n\n        if n_rows is not None:\n            v1 = RIGHT\n            v2 = DOWN\n            n = len(submobs) // n_rows\n        elif n_cols is not None:\n            v1 = DOWN\n            v2 = RIGHT\n            n = len(submobs) // n_cols\n        Group(\n            *[\n                Group(*submobs[i : i + n]).arrange(v1, **kwargs)\n                for i in range(0, len(submobs), n)\n            ]\n        ).arrange(v2, **kwargs)\n        return self",
  "def sort(self, point_to_num_func=lambda p: p[0], submob_func=None):\n        if submob_func is None:\n            submob_func = lambda m: point_to_num_func(m.get_center())\n        self.submobjects.sort(key=submob_func)\n        return self",
  "def shuffle(self, recursive=False):\n        if recursive:\n            for submob in self.submobjects:\n                submob.shuffle(recursive=True)\n        random.shuffle(self.submobjects)",
  "def arrange_submobjects(self, *args, **kwargs):\n        return self.arrange(*args, **kwargs)",
  "def sort_submobjects(self, *args, **kwargs):\n        return self.sort(*args, **kwargs)",
  "def shuffle_submobjects(self, *args, **kwargs):\n        return self.shuffle(*args, **kwargs)",
  "def align_data(self, mobject):\n        self.null_point_align(mobject)\n        self.align_submobjects(mobject)\n        self.align_points(mobject)\n        # Recurse\n        for m1, m2 in zip(self.submobjects, mobject.submobjects):\n            m1.align_data(m2)",
  "def get_point_mobject(self, center=None):\n        \"\"\"\n        The simplest mobject to be transformed to or from self.\n        Should by a point of the appropriate type\n        \"\"\"\n        msg = f\"get_point_mobject not implemented for {self.__class__.__name__}\"\n        raise NotImplementedError(msg)",
  "def align_points(self, mobject):\n        count1 = self.get_num_points()\n        count2 = mobject.get_num_points()\n        if count1 < count2:\n            self.align_points_with_larger(mobject)\n        elif count2 < count1:\n            mobject.align_points_with_larger(self)\n        return self",
  "def align_points_with_larger(self, larger_mobject):\n        raise NotImplementedError(\"Please override in a child class.\")",
  "def align_submobjects(self, mobject):\n        mob1 = self\n        mob2 = mobject\n        n1 = len(mob1.submobjects)\n        n2 = len(mob2.submobjects)\n        mob1.add_n_more_submobjects(max(0, n2 - n1))\n        mob2.add_n_more_submobjects(max(0, n1 - n2))\n        return self",
  "def null_point_align(self, mobject):\n        \"\"\"\n        If a mobject with points is being aligned to\n        one without, treat both as groups, and push\n        the one with points into its own submobjects\n        list.\n        \"\"\"\n        for m1, m2 in (self, mobject), (mobject, self):\n            if m1.has_no_points() and m2.has_points():\n                m2.push_self_into_submobjects()\n        return self",
  "def push_self_into_submobjects(self):\n        copy = self.copy()\n        copy.submobjects = []\n        self.reset_points()\n        self.add(copy)\n        return self",
  "def add_n_more_submobjects(self, n):\n        if n == 0:\n            return\n\n        curr = len(self.submobjects)\n        if curr == 0:\n            # If empty, simply add n point mobjects\n            self.submobjects = [self.get_point_mobject() for k in range(n)]\n            return\n\n        target = curr + n\n        # TODO, factor this out to utils so as to reuse\n        # with VMobject.insert_n_curves\n        repeat_indices = (np.arange(target) * curr) // target\n        split_factors = [sum(repeat_indices == i) for i in range(curr)]\n        new_submobs = []\n        for submob, sf in zip(self.submobjects, split_factors):\n            new_submobs.append(submob)\n            for k in range(1, sf):\n                new_submobs.append(submob.copy().fade(1))\n        self.submobjects = new_submobs\n        return self",
  "def repeat_submobject(self, submob):\n        return submob.copy()",
  "def interpolate(self, mobject1, mobject2, alpha, path_func=straight_path):\n        \"\"\"\n        Turns self into an interpolation between mobject1\n        and mobject2.\n        \"\"\"\n        self.points = path_func(mobject1.points, mobject2.points, alpha)\n        self.interpolate_color(mobject1, mobject2, alpha)\n        return self",
  "def interpolate_color(self, mobject1, mobject2, alpha):\n        raise NotImplementedError(\"Please override in a child class.\")",
  "def pointwise_become_partial(self, mobject, a, b):\n        raise NotImplementedError(\"Please override in a child class.\")",
  "def become(self, mobject, copy_submobjects=True):\n        \"\"\"\n        Edit points, colors and submobjects to be idential\n        to another mobject\n        \"\"\"\n        self.align_data(mobject)\n        for sm1, sm2 in zip(self.get_family(), mobject.get_family()):\n            sm1.points = np.array(sm2.points)\n            sm1.interpolate_color(sm1, sm2, 1)\n        return self",
  "def throw_error_if_no_points(self):\n        if self.has_no_points():\n            message = \"Cannot call Mobject.{} \" + \"for a Mobject with no points\"\n            caller_name = sys._getframe(1).f_code.co_name\n            raise Exception(message.format(caller_name))",
  "def set_z_index(self, z_index_value):\n        \"\"\"Sets the mobject's :attr:`z_index` to the value specified in `z_index_value`.\n\n        Parameters\n        ----------\n        z_index_value : Union[:class:`int`, :class:`float`]\n            The new value of :attr:`z_index` set.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)\n        \"\"\"\n        self.z_index = z_index_value\n        return self",
  "def set_z_index_by_z_coordinate(self):\n        \"\"\"Sets the mobject's z coordinate to the value of :attr:`z_index`.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)\n        \"\"\"\n        z_coord = self.get_center()[-1]\n        self.set_z_index(z_coord)\n        return self",
  "def __init__(self, *mobjects, **kwargs):\n        if not all([isinstance(m, Mobject) for m in mobjects]):\n            raise Exception(\"All submobjects must be of type Mobject\")\n        Mobject.__init__(self, **kwargs)\n        self.add(*mobjects)",
  "def func(points):\n            points[:, dim] *= factor\n            return points",
  "def R3_func(point):\n            x, y, z = point\n            xy_complex = function(complex(x, y))\n            return [xy_complex.real, xy_complex.imag, z]",
  "def repeat_array(array):\n            return reduce(lambda a1, a2: np.append(a1, a2, axis=0), [array] * count)",
  "class DecimalNumber(VMobject):\n    CONFIG = {\n        \"num_decimal_places\": 2,\n        \"include_sign\": False,\n        \"group_with_commas\": True,\n        \"digit_to_digit_buff\": 0.05,\n        \"show_ellipsis\": False,\n        \"unit\": None,  # Aligned to bottom unless it starts with \"^\"\n        \"include_background_rectangle\": False,\n        \"edge_to_fix\": LEFT,\n    }\n\n    def __init__(self, number=0, **kwargs):\n        super().__init__(**kwargs)\n        self.number = number\n        self.initial_config = kwargs\n\n        if isinstance(number, complex):\n            formatter = self.get_complex_formatter()\n        else:\n            formatter = self.get_formatter()\n        num_string = formatter.format(number)\n\n        rounded_num = np.round(number, self.num_decimal_places)\n        if num_string.startswith(\"-\") and rounded_num == 0:\n            if self.include_sign:\n                num_string = \"+\" + num_string[1:]\n            else:\n                num_string = num_string[1:]\n\n        self.add(*[SingleStringTexMobject(char, **kwargs) for char in num_string])\n\n        # Add non-numerical bits\n        if self.show_ellipsis:\n            self.add(SingleStringTexMobject(\"\\\\dots\"))\n\n        if num_string.startswith(\"-\"):\n            minus = self.submobjects[0]\n            minus.next_to(self.submobjects[1], LEFT, buff=self.digit_to_digit_buff)\n\n        if self.unit is not None:\n            self.unit_sign = SingleStringTexMobject(self.unit, color=self.color)\n            self.add(self.unit_sign)\n\n        self.arrange(buff=self.digit_to_digit_buff, aligned_edge=DOWN)\n\n        # Handle alignment of parts that should be aligned\n        # to the bottom\n        for i, c in enumerate(num_string):\n            if c == \"-\" and len(num_string) > i + 1:\n                self[i].align_to(self[i + 1], UP)\n                self[i].shift(self[i + 1].get_height() * DOWN / 2)\n            elif c == \",\":\n                self[i].shift(self[i].get_height() * DOWN / 2)\n        if self.unit and self.unit.startswith(\"^\"):\n            self.unit_sign.align_to(self, UP)\n        #\n        if self.include_background_rectangle:\n            self.add_background_rectangle()\n\n    def get_formatter(self, **kwargs):\n        \"\"\"\n        Configuration is based first off instance attributes,\n        but overwritten by any kew word argument.  Relevant\n        key words:\n        - include_sign\n        - group_with_commas\n        - num_decimal_places\n        - field_name (e.g. 0 or 0.real)\n        \"\"\"\n        config = dict(\n            [\n                (attr, getattr(self, attr))\n                for attr in [\"include_sign\", \"group_with_commas\", \"num_decimal_places\",]\n            ]\n        )\n        config.update(kwargs)\n        return \"\".join(\n            [\n                \"{\",\n                config.get(\"field_name\", \"\"),\n                \":\",\n                \"+\" if config[\"include_sign\"] else \"\",\n                \",\" if config[\"group_with_commas\"] else \"\",\n                \".\",\n                str(config[\"num_decimal_places\"]),\n                \"f\",\n                \"}\",\n            ]\n        )\n\n    def get_complex_formatter(self, **kwargs):\n        return \"\".join(\n            [\n                self.get_formatter(field_name=\"0.real\"),\n                self.get_formatter(field_name=\"0.imag\", include_sign=True),\n                \"i\",\n            ]\n        )\n\n    def set_value(self, number, **config):\n        full_config = dict(self.CONFIG)\n        full_config.update(self.initial_config)\n        full_config.update(config)\n        new_decimal = DecimalNumber(number, **full_config)\n        # Make sure last digit has constant height\n        new_decimal.scale(self[-1].get_height() / new_decimal[-1].get_height())\n        new_decimal.move_to(self, self.edge_to_fix)\n        new_decimal.match_style(self)\n\n        old_family = self.get_family()\n        self.submobjects = new_decimal.submobjects\n        for mob in old_family:\n            # Dumb hack...due to how scene handles families\n            # of animated mobjects\n            mob.points[:] = 0\n        self.number = number\n        return self\n\n    def get_value(self):\n        return self.number\n\n    def increment_value(self, delta_t=1):\n        self.set_value(self.get_value() + delta_t)",
  "class Integer(DecimalNumber):\n    CONFIG = {\n        \"num_decimal_places\": 0,\n    }\n\n    def get_value(self):\n        return int(np.round(super().get_value()))",
  "def __init__(self, number=0, **kwargs):\n        super().__init__(**kwargs)\n        self.number = number\n        self.initial_config = kwargs\n\n        if isinstance(number, complex):\n            formatter = self.get_complex_formatter()\n        else:\n            formatter = self.get_formatter()\n        num_string = formatter.format(number)\n\n        rounded_num = np.round(number, self.num_decimal_places)\n        if num_string.startswith(\"-\") and rounded_num == 0:\n            if self.include_sign:\n                num_string = \"+\" + num_string[1:]\n            else:\n                num_string = num_string[1:]\n\n        self.add(*[SingleStringTexMobject(char, **kwargs) for char in num_string])\n\n        # Add non-numerical bits\n        if self.show_ellipsis:\n            self.add(SingleStringTexMobject(\"\\\\dots\"))\n\n        if num_string.startswith(\"-\"):\n            minus = self.submobjects[0]\n            minus.next_to(self.submobjects[1], LEFT, buff=self.digit_to_digit_buff)\n\n        if self.unit is not None:\n            self.unit_sign = SingleStringTexMobject(self.unit, color=self.color)\n            self.add(self.unit_sign)\n\n        self.arrange(buff=self.digit_to_digit_buff, aligned_edge=DOWN)\n\n        # Handle alignment of parts that should be aligned\n        # to the bottom\n        for i, c in enumerate(num_string):\n            if c == \"-\" and len(num_string) > i + 1:\n                self[i].align_to(self[i + 1], UP)\n                self[i].shift(self[i + 1].get_height() * DOWN / 2)\n            elif c == \",\":\n                self[i].shift(self[i].get_height() * DOWN / 2)\n        if self.unit and self.unit.startswith(\"^\"):\n            self.unit_sign.align_to(self, UP)\n        #\n        if self.include_background_rectangle:\n            self.add_background_rectangle()",
  "def get_formatter(self, **kwargs):\n        \"\"\"\n        Configuration is based first off instance attributes,\n        but overwritten by any kew word argument.  Relevant\n        key words:\n        - include_sign\n        - group_with_commas\n        - num_decimal_places\n        - field_name (e.g. 0 or 0.real)\n        \"\"\"\n        config = dict(\n            [\n                (attr, getattr(self, attr))\n                for attr in [\"include_sign\", \"group_with_commas\", \"num_decimal_places\",]\n            ]\n        )\n        config.update(kwargs)\n        return \"\".join(\n            [\n                \"{\",\n                config.get(\"field_name\", \"\"),\n                \":\",\n                \"+\" if config[\"include_sign\"] else \"\",\n                \",\" if config[\"group_with_commas\"] else \"\",\n                \".\",\n                str(config[\"num_decimal_places\"]),\n                \"f\",\n                \"}\",\n            ]\n        )",
  "def get_complex_formatter(self, **kwargs):\n        return \"\".join(\n            [\n                self.get_formatter(field_name=\"0.real\"),\n                self.get_formatter(field_name=\"0.imag\", include_sign=True),\n                \"i\",\n            ]\n        )",
  "def set_value(self, number, **config):\n        full_config = dict(self.CONFIG)\n        full_config.update(self.initial_config)\n        full_config.update(config)\n        new_decimal = DecimalNumber(number, **full_config)\n        # Make sure last digit has constant height\n        new_decimal.scale(self[-1].get_height() / new_decimal[-1].get_height())\n        new_decimal.move_to(self, self.edge_to_fix)\n        new_decimal.match_style(self)\n\n        old_family = self.get_family()\n        self.submobjects = new_decimal.submobjects\n        for mob in old_family:\n            # Dumb hack...due to how scene handles families\n            # of animated mobjects\n            mob.points[:] = 0\n        self.number = number\n        return self",
  "def get_value(self):\n        return self.number",
  "def increment_value(self, delta_t=1):\n        self.set_value(self.get_value() + delta_t)",
  "def get_value(self):\n        return int(np.round(super().get_value()))",
  "class ThreeDVMobject(VMobject):\n    CONFIG = {\n        \"shade_in_3d\": True,\n    }",
  "class ParametricSurface(VGroup):\n    CONFIG = {\n        \"u_min\": 0,\n        \"u_max\": 1,\n        \"v_min\": 0,\n        \"v_max\": 1,\n        \"resolution\": 32,\n        \"surface_piece_config\": {},\n        \"fill_color\": BLUE_D,\n        \"fill_opacity\": 1.0,\n        \"checkerboard_colors\": [BLUE_D, BLUE_E],\n        \"stroke_color\": LIGHT_GREY,\n        \"stroke_width\": 0.5,\n        \"should_make_jagged\": False,\n        \"pre_function_handle_to_anchor_scale_factor\": 0.00001,\n    }\n\n    def __init__(self, func, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.func = func\n        self.setup_in_uv_space()\n        self.apply_function(lambda p: func(p[0], p[1]))\n        if self.should_make_jagged:\n            self.make_jagged()\n\n    def get_u_values_and_v_values(self):\n        res = tuplify(self.resolution)\n        if len(res) == 1:\n            u_res = v_res = res[0]\n        else:\n            u_res, v_res = res\n        u_min = self.u_min\n        u_max = self.u_max\n        v_min = self.v_min\n        v_max = self.v_max\n\n        u_values = np.linspace(u_min, u_max, u_res + 1)\n        v_values = np.linspace(v_min, v_max, v_res + 1)\n\n        return u_values, v_values\n\n    def setup_in_uv_space(self):\n        u_values, v_values = self.get_u_values_and_v_values()\n        faces = VGroup()\n        for i in range(len(u_values) - 1):\n            for j in range(len(v_values) - 1):\n                u1, u2 = u_values[i : i + 2]\n                v1, v2 = v_values[j : j + 2]\n                face = ThreeDVMobject()\n                face.set_points_as_corners(\n                    [[u1, v1, 0], [u2, v1, 0], [u2, v2, 0], [u1, v2, 0], [u1, v1, 0],]\n                )\n                faces.add(face)\n                face.u_index = i\n                face.v_index = j\n                face.u1 = u1\n                face.u2 = u2\n                face.v1 = v1\n                face.v2 = v2\n        faces.set_fill(color=self.fill_color, opacity=self.fill_opacity)\n        faces.set_stroke(\n            color=self.stroke_color,\n            width=self.stroke_width,\n            opacity=self.stroke_opacity,\n        )\n        self.add(*faces)\n        if self.checkerboard_colors:\n            self.set_fill_by_checkerboard(*self.checkerboard_colors)\n\n    def set_fill_by_checkerboard(self, *colors, opacity=None):\n        n_colors = len(colors)\n        for face in self:\n            c_index = (face.u_index + face.v_index) % n_colors\n            face.set_fill(colors[c_index], opacity=opacity)",
  "class Sphere(ParametricSurface):\n    CONFIG = {\n        \"resolution\": (12, 24),\n        \"radius\": 1,\n        \"u_min\": 0.001,\n        \"u_max\": PI - 0.001,\n        \"v_min\": 0,\n        \"v_max\": TAU,\n    }\n\n    def __init__(self, **kwargs):\n        ParametricSurface.__init__(self, self.func, **kwargs)\n        self.scale(self.radius)\n\n    def func(self, u, v):\n        return np.array([np.cos(v) * np.sin(u), np.sin(v) * np.sin(u), np.cos(u)])",
  "class Cube(VGroup):\n    CONFIG = {\n        \"fill_opacity\": 0.75,\n        \"fill_color\": BLUE,\n        \"stroke_width\": 0,\n        \"side_length\": 2,\n    }\n\n    def generate_points(self):\n        for vect in IN, OUT, LEFT, RIGHT, UP, DOWN:\n            face = Square(side_length=self.side_length, shade_in_3d=True,)\n            face.flip()\n            face.shift(self.side_length * OUT / 2.0)\n            face.apply_matrix(z_to_vector(vect))\n\n            self.add(face)",
  "class Prism(Cube):\n    CONFIG = {\"dimensions\": [3, 2, 1]}\n\n    def generate_points(self):\n        Cube.generate_points(self)\n        for dim, value in enumerate(self.dimensions):\n            self.rescale_to_fit(value, dim, stretch=True)",
  "def __init__(self, func, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.func = func\n        self.setup_in_uv_space()\n        self.apply_function(lambda p: func(p[0], p[1]))\n        if self.should_make_jagged:\n            self.make_jagged()",
  "def get_u_values_and_v_values(self):\n        res = tuplify(self.resolution)\n        if len(res) == 1:\n            u_res = v_res = res[0]\n        else:\n            u_res, v_res = res\n        u_min = self.u_min\n        u_max = self.u_max\n        v_min = self.v_min\n        v_max = self.v_max\n\n        u_values = np.linspace(u_min, u_max, u_res + 1)\n        v_values = np.linspace(v_min, v_max, v_res + 1)\n\n        return u_values, v_values",
  "def setup_in_uv_space(self):\n        u_values, v_values = self.get_u_values_and_v_values()\n        faces = VGroup()\n        for i in range(len(u_values) - 1):\n            for j in range(len(v_values) - 1):\n                u1, u2 = u_values[i : i + 2]\n                v1, v2 = v_values[j : j + 2]\n                face = ThreeDVMobject()\n                face.set_points_as_corners(\n                    [[u1, v1, 0], [u2, v1, 0], [u2, v2, 0], [u1, v2, 0], [u1, v1, 0],]\n                )\n                faces.add(face)\n                face.u_index = i\n                face.v_index = j\n                face.u1 = u1\n                face.u2 = u2\n                face.v1 = v1\n                face.v2 = v2\n        faces.set_fill(color=self.fill_color, opacity=self.fill_opacity)\n        faces.set_stroke(\n            color=self.stroke_color,\n            width=self.stroke_width,\n            opacity=self.stroke_opacity,\n        )\n        self.add(*faces)\n        if self.checkerboard_colors:\n            self.set_fill_by_checkerboard(*self.checkerboard_colors)",
  "def set_fill_by_checkerboard(self, *colors, opacity=None):\n        n_colors = len(colors)\n        for face in self:\n            c_index = (face.u_index + face.v_index) % n_colors\n            face.set_fill(colors[c_index], opacity=opacity)",
  "def __init__(self, **kwargs):\n        ParametricSurface.__init__(self, self.func, **kwargs)\n        self.scale(self.radius)",
  "def func(self, u, v):\n        return np.array([np.cos(v) * np.sin(u), np.sin(v) * np.sin(u), np.cos(u)])",
  "def generate_points(self):\n        for vect in IN, OUT, LEFT, RIGHT, UP, DOWN:\n            face = Square(side_length=self.side_length, shade_in_3d=True,)\n            face.flip()\n            face.shift(self.side_length * OUT / 2.0)\n            face.apply_matrix(z_to_vector(vect))\n\n            self.add(face)",
  "def generate_points(self):\n        Cube.generate_points(self)\n        for dim, value in enumerate(self.dimensions):\n            self.rescale_to_fit(value, dim, stretch=True)",
  "class CoordinateSystem:\n    \"\"\"\n    Abstract class for Axes and NumberPlane\n    \"\"\"\n\n    CONFIG = {\n        \"dimension\": 2,\n        \"x_min\": -config[\"frame_x_radius\"],\n        \"x_max\": config[\"frame_x_radius\"],\n        \"y_min\": -config[\"frame_y_radius\"],\n        \"y_max\": config[\"frame_y_radius\"],\n    }\n\n    def coords_to_point(self, *coords):\n        raise Exception(\"Not implemented\")\n\n    def point_to_coords(self, point):\n        raise Exception(\"Not implemented\")\n\n    def c2p(self, *coords):\n        \"\"\"Abbreviation for coords_to_point\"\"\"\n        return self.coords_to_point(*coords)\n\n    def p2c(self, point):\n        \"\"\"Abbreviation for point_to_coords\"\"\"\n        return self.point_to_coords(point)\n\n    def get_axes(self):\n        raise Exception(\"Not implemented\")\n\n    def get_axis(self, index):\n        return self.get_axes()[index]\n\n    def get_x_axis(self):\n        return self.get_axis(0)\n\n    def get_y_axis(self):\n        return self.get_axis(1)\n\n    def get_z_axis(self):\n        return self.get_axis(2)\n\n    def get_x_axis_label(self, label_tex, edge=RIGHT, direction=DL, **kwargs):\n        return self.get_axis_label(\n            label_tex, self.get_x_axis(), edge, direction, **kwargs\n        )\n\n    def get_y_axis_label(self, label_tex, edge=UP, direction=DR, **kwargs):\n        return self.get_axis_label(\n            label_tex, self.get_y_axis(), edge, direction, **kwargs\n        )\n\n    def get_axis_label(self, label_tex, axis, edge, direction, buff=MED_SMALL_BUFF):\n        label = TexMobject(label_tex)\n        label.next_to(axis.get_edge_center(edge), direction, buff=buff)\n        label.shift_onto_screen(buff=MED_SMALL_BUFF)\n        return label\n\n    def get_axis_labels(self, x_label_tex=\"x\", y_label_tex=\"y\"):\n        self.axis_labels = VGroup(\n            self.get_x_axis_label(x_label_tex), self.get_y_axis_label(y_label_tex),\n        )\n        return self.axis_labels\n\n    def get_graph(self, function, **kwargs):\n        x_min = kwargs.pop(\"x_min\", self.x_min)\n        x_max = kwargs.pop(\"x_max\", self.x_max)\n        graph = ParametricFunction(\n            lambda t: self.coords_to_point(t, function(t)),\n            t_min=x_min,\n            t_max=x_max,\n            **kwargs,\n        )\n        graph.underlying_function = function\n        return graph\n\n    def get_parametric_curve(self, function, **kwargs):\n        dim = self.dimension\n        graph = ParametricFunction(\n            lambda t: self.coords_to_point(*function(t)[:dim]), **kwargs\n        )\n        graph.underlying_function = function\n        return graph\n\n    def input_to_graph_point(self, x, graph):\n        if hasattr(graph, \"underlying_function\"):\n            return self.coords_to_point(x, graph.underlying_function(x))\n        else:\n            alpha = binary_search(\n                function=lambda a: self.point_to_coords(graph.point_from_proportion(a))[\n                    0\n                ],\n                target=x,\n                lower_bound=self.x_min,\n                upper_bound=self.x_max,\n            )\n            if alpha is not None:\n                return graph.point_from_proportion(alpha)\n            else:\n                return None",
  "class Axes(VGroup, CoordinateSystem):\n    CONFIG = {\n        \"axis_config\": {\n            \"color\": LIGHT_GREY,\n            \"include_tip\": True,\n            \"exclude_zero_from_default_numbers\": True,\n        },\n        \"x_axis_config\": {},\n        \"y_axis_config\": {\"label_direction\": LEFT,},\n        \"center_point\": ORIGIN,\n    }\n\n    def __init__(self, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.x_axis = self.create_axis(self.x_min, self.x_max, self.x_axis_config)\n        self.y_axis = self.create_axis(self.y_min, self.y_max, self.y_axis_config)\n        self.y_axis.rotate(90 * DEGREES, about_point=ORIGIN)\n        # Add as a separate group incase various other\n        # mobjects are added to self, as for example in\n        # NumberPlane below\n        self.axes = VGroup(self.x_axis, self.y_axis)\n        self.add(*self.axes)\n        self.shift(self.center_point)\n\n    def create_axis(self, min_val, max_val, axis_config):\n        new_config = merge_dicts_recursively(\n            self.axis_config, {\"x_min\": min_val, \"x_max\": max_val}, axis_config,\n        )\n        return NumberLine(**new_config)\n\n    def coords_to_point(self, *coords):\n        origin = self.x_axis.number_to_point(0)\n        result = np.array(origin)\n        for axis, coord in zip(self.get_axes(), coords):\n            result += axis.number_to_point(coord) - origin\n        return result\n\n    def c2p(self, *coords):\n        return self.coords_to_point(*coords)\n\n    def point_to_coords(self, point):\n        return tuple([axis.point_to_number(point) for axis in self.get_axes()])\n\n    def p2c(self, point):\n        return self.point_to_coords(point)\n\n    def get_axes(self):\n        return self.axes\n\n    def get_coordinate_labels(self, x_vals=None, y_vals=None):\n        if x_vals is None:\n            x_vals = []\n        if y_vals is None:\n            y_vals = []\n        x_mobs = self.get_x_axis().get_number_mobjects(*x_vals)\n        y_mobs = self.get_y_axis().get_number_mobjects(*y_vals)\n\n        self.coordinate_labels = VGroup(x_mobs, y_mobs)\n        return self.coordinate_labels\n\n    def add_coordinates(self, x_vals=None, y_vals=None):\n        self.add(self.get_coordinate_labels(x_vals, y_vals))\n        return self",
  "class ThreeDAxes(Axes):\n    CONFIG = {\n        \"dimension\": 3,\n        \"x_min\": -5.5,\n        \"x_max\": 5.5,\n        \"y_min\": -5.5,\n        \"y_max\": 5.5,\n        \"z_axis_config\": {},\n        \"z_min\": -3.5,\n        \"z_max\": 3.5,\n        \"z_normal\": DOWN,\n        \"num_axis_pieces\": 20,\n        \"light_source\": 9 * DOWN + 7 * LEFT + 10 * OUT,\n    }\n\n    def __init__(self, **kwargs):\n        Axes.__init__(self, **kwargs)\n        z_axis = self.z_axis = self.create_axis(\n            self.z_min, self.z_max, self.z_axis_config\n        )\n        z_axis.rotate(-np.pi / 2, UP, about_point=ORIGIN)\n        z_axis.rotate(angle_of_vector(self.z_normal), OUT, about_point=ORIGIN)\n        self.axes.add(z_axis)\n        self.add(z_axis)\n\n        self.add_3d_pieces()\n        self.set_axis_shading()\n\n    def add_3d_pieces(self):\n        for axis in self.axes:\n            axis.pieces = VGroup(*axis.get_pieces(self.num_axis_pieces))\n            axis.add(axis.pieces)\n            axis.set_stroke(width=0, family=False)\n            axis.set_shade_in_3d(True)\n\n    def set_axis_shading(self):\n        def make_func(axis):\n            vect = self.light_source\n            return lambda: (axis.get_edge_center(-vect), axis.get_edge_center(vect),)\n\n        for axis in self:\n            for submob in axis.family_members_with_points():\n                submob.get_gradient_start_and_end_points = make_func(axis)\n                submob.get_unit_normal = lambda a: np.ones(3)\n                submob.set_sheen(0.2)",
  "class NumberPlane(Axes):\n    CONFIG = {\n        \"axis_config\": {\n            \"stroke_color\": WHITE,\n            \"stroke_width\": 2,\n            \"include_ticks\": False,\n            \"include_tip\": False,\n            \"line_to_number_buff\": SMALL_BUFF,\n            \"label_direction\": DR,\n            \"number_scale_val\": 0.5,\n        },\n        \"y_axis_config\": {\"label_direction\": DR,},\n        \"background_line_style\": {\n            \"stroke_color\": BLUE_D,\n            \"stroke_width\": 2,\n            \"stroke_opacity\": 1,\n        },\n        # Defaults to a faded version of line_config\n        \"faded_line_style\": None,\n        \"x_line_frequency\": 1,\n        \"y_line_frequency\": 1,\n        \"faded_line_ratio\": 1,\n        \"make_smooth_after_applying_functions\": True,\n    }\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.init_background_lines()\n\n    def init_background_lines(self):\n        \"\"\"Will init all the lines of NumberPlanes (faded or not)\"\"\"\n        if self.faded_line_style is None:\n            style = dict(self.background_line_style)\n            # For anything numerical, like stroke_width\n            # and stroke_opacity, chop it in half\n            for key in style:\n                if isinstance(style[key], numbers.Number):\n                    style[key] *= 0.5\n            self.faded_line_style = style\n\n        self.background_lines, self.faded_lines = self.get_lines()\n        self.background_lines.set_style(**self.background_line_style,)\n        self.faded_lines.set_style(**self.faded_line_style,)\n        self.add_to_back(\n            self.faded_lines, self.background_lines,\n        )\n\n    def get_lines(self):\n        \"\"\"Generate all the lines, faded and not faded. Two sets of lines are generated: one parallel to the X-axis, and parallel to the Y-axis.\n        \n        Returns\n        -------\n        Tuple[:class:`~.VGroup`, :class:`~.VGroup`]\n            The first (i.e the non faded lines) and second (i.e the faded lines) sets of lines, respectively.\n        \"\"\"\n        x_axis = self.get_x_axis()\n        y_axis = self.get_y_axis()\n        x_freq = self.x_line_frequency\n        y_freq = self.y_line_frequency\n\n        x_lines1, x_lines2 = self.get_lines_parallel_to_axis(\n            x_axis, y_axis, x_freq, self.faded_line_ratio,\n        )\n        y_lines1, y_lines2 = self.get_lines_parallel_to_axis(\n            y_axis, x_axis, y_freq, self.faded_line_ratio,\n        )\n        lines1 = VGroup(*x_lines1, *y_lines1)\n        lines2 = VGroup(*x_lines2, *y_lines2)\n        return lines1, lines2\n\n    def get_lines_parallel_to_axis(\n        self, axis_parallel_to, axis_perpendicular_to, freq, ratio_faded_lines\n    ):\n        \"\"\"Generate a set of lines parallel to an axis.\n\n        Parameters\n        ----------\n        axis_parallel_to : :class:`~.Line`\n            The axis with which the lines will be parallel.\n\n        axis_perpendicular_to : :class:`~.Line`\n            The axis with which the lines will be perpendicular.\n        \n        ratio_faded_lines : :class:`float`\n            The number of faded lines between each non-faded line. \n\n        freq : :class:`float`\n            Frequency of non-faded lines (number of non-faded lines per graph unit).\n\n        Returns\n        -------\n        Tuple[:class:`~.VGroup`, :class:`~.VGroup`]\n            The first (i.e the non-faded lines parallel to `axis_parallel_to`) and second (i.e the faded lines parallel to `axis_parallel_to`) sets of lines, respectively.     \n        \"\"\"\n        line = Line(axis_parallel_to.get_start(), axis_parallel_to.get_end())\n        dense_freq = ratio_faded_lines\n        step = (1 / dense_freq) * freq\n        lines1 = VGroup()\n        lines2 = VGroup()\n        unit_vector_axis_perp_to = axis_perpendicular_to.get_unit_vector()\n        ranges = (\n            np.arange(0, axis_perpendicular_to.x_max, step),\n            np.arange(0, axis_perpendicular_to.x_min, -step),\n        )\n        for inputs in ranges:\n            for k, x in enumerate(inputs):\n                new_line = line.copy()\n                new_line.shift(unit_vector_axis_perp_to * x)\n                if k % ratio_faded_lines == 0:\n                    lines1.add(new_line)\n                else:\n                    lines2.add(new_line)\n        return lines1, lines2\n\n    def get_center_point(self):\n        return self.coords_to_point(0, 0)\n\n    def get_x_unit_size(self):\n        return self.get_x_axis().get_unit_size()\n\n    def get_y_unit_size(self):\n        return self.get_x_axis().get_unit_size()\n\n    def get_axes(self):\n        return self.axes\n\n    def get_vector(self, coords, **kwargs):\n        kwargs[\"buff\"] = 0\n        return Arrow(\n            self.coords_to_point(0, 0), self.coords_to_point(*coords), **kwargs\n        )\n\n    def prepare_for_nonlinear_transform(self, num_inserted_curves=50):\n        for mob in self.family_members_with_points():\n            num_curves = mob.get_num_curves()\n            if num_inserted_curves > num_curves:\n                mob.insert_n_curves(num_inserted_curves - num_curves)\n        return self",
  "class ComplexPlane(NumberPlane):\n    CONFIG = {\n        \"color\": BLUE,\n        \"line_frequency\": 1,\n    }\n\n    def number_to_point(self, number):\n        number = complex(number)\n        return self.coords_to_point(number.real, number.imag)\n\n    def n2p(self, number):\n        return self.number_to_point(number)\n\n    def point_to_number(self, point):\n        x, y = self.point_to_coords(point)\n        return complex(x, y)\n\n    def p2n(self, point):\n        return self.point_to_number(point)\n\n    def get_default_coordinate_values(self):\n        x_numbers = self.get_x_axis().default_numbers_to_display()\n        y_numbers = self.get_y_axis().default_numbers_to_display()\n        y_numbers = [complex(0, y) for y in y_numbers if y != 0]\n        return [*x_numbers, *y_numbers]\n\n    def get_coordinate_labels(self, *numbers, **kwargs):\n        if len(numbers) == 0:\n            numbers = self.get_default_coordinate_values()\n\n        self.coordinate_labels = VGroup()\n        for number in numbers:\n            z = complex(number)\n            if abs(z.imag) > abs(z.real):\n                axis = self.get_y_axis()\n                value = z.imag\n                kwargs = merge_dicts_recursively(\n                    kwargs, {\"number_config\": {\"unit\": \"i\"}},\n                )\n            else:\n                axis = self.get_x_axis()\n                value = z.real\n            number_mob = axis.get_number_mobject(value, **kwargs)\n            self.coordinate_labels.add(number_mob)\n        return self.coordinate_labels\n\n    def add_coordinates(self, *numbers):\n        self.add(self.get_coordinate_labels(*numbers))\n        return self",
  "def coords_to_point(self, *coords):\n        raise Exception(\"Not implemented\")",
  "def point_to_coords(self, point):\n        raise Exception(\"Not implemented\")",
  "def c2p(self, *coords):\n        \"\"\"Abbreviation for coords_to_point\"\"\"\n        return self.coords_to_point(*coords)",
  "def p2c(self, point):\n        \"\"\"Abbreviation for point_to_coords\"\"\"\n        return self.point_to_coords(point)",
  "def get_axes(self):\n        raise Exception(\"Not implemented\")",
  "def get_axis(self, index):\n        return self.get_axes()[index]",
  "def get_x_axis(self):\n        return self.get_axis(0)",
  "def get_y_axis(self):\n        return self.get_axis(1)",
  "def get_z_axis(self):\n        return self.get_axis(2)",
  "def get_x_axis_label(self, label_tex, edge=RIGHT, direction=DL, **kwargs):\n        return self.get_axis_label(\n            label_tex, self.get_x_axis(), edge, direction, **kwargs\n        )",
  "def get_y_axis_label(self, label_tex, edge=UP, direction=DR, **kwargs):\n        return self.get_axis_label(\n            label_tex, self.get_y_axis(), edge, direction, **kwargs\n        )",
  "def get_axis_label(self, label_tex, axis, edge, direction, buff=MED_SMALL_BUFF):\n        label = TexMobject(label_tex)\n        label.next_to(axis.get_edge_center(edge), direction, buff=buff)\n        label.shift_onto_screen(buff=MED_SMALL_BUFF)\n        return label",
  "def get_axis_labels(self, x_label_tex=\"x\", y_label_tex=\"y\"):\n        self.axis_labels = VGroup(\n            self.get_x_axis_label(x_label_tex), self.get_y_axis_label(y_label_tex),\n        )\n        return self.axis_labels",
  "def get_graph(self, function, **kwargs):\n        x_min = kwargs.pop(\"x_min\", self.x_min)\n        x_max = kwargs.pop(\"x_max\", self.x_max)\n        graph = ParametricFunction(\n            lambda t: self.coords_to_point(t, function(t)),\n            t_min=x_min,\n            t_max=x_max,\n            **kwargs,\n        )\n        graph.underlying_function = function\n        return graph",
  "def get_parametric_curve(self, function, **kwargs):\n        dim = self.dimension\n        graph = ParametricFunction(\n            lambda t: self.coords_to_point(*function(t)[:dim]), **kwargs\n        )\n        graph.underlying_function = function\n        return graph",
  "def input_to_graph_point(self, x, graph):\n        if hasattr(graph, \"underlying_function\"):\n            return self.coords_to_point(x, graph.underlying_function(x))\n        else:\n            alpha = binary_search(\n                function=lambda a: self.point_to_coords(graph.point_from_proportion(a))[\n                    0\n                ],\n                target=x,\n                lower_bound=self.x_min,\n                upper_bound=self.x_max,\n            )\n            if alpha is not None:\n                return graph.point_from_proportion(alpha)\n            else:\n                return None",
  "def __init__(self, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.x_axis = self.create_axis(self.x_min, self.x_max, self.x_axis_config)\n        self.y_axis = self.create_axis(self.y_min, self.y_max, self.y_axis_config)\n        self.y_axis.rotate(90 * DEGREES, about_point=ORIGIN)\n        # Add as a separate group incase various other\n        # mobjects are added to self, as for example in\n        # NumberPlane below\n        self.axes = VGroup(self.x_axis, self.y_axis)\n        self.add(*self.axes)\n        self.shift(self.center_point)",
  "def create_axis(self, min_val, max_val, axis_config):\n        new_config = merge_dicts_recursively(\n            self.axis_config, {\"x_min\": min_val, \"x_max\": max_val}, axis_config,\n        )\n        return NumberLine(**new_config)",
  "def coords_to_point(self, *coords):\n        origin = self.x_axis.number_to_point(0)\n        result = np.array(origin)\n        for axis, coord in zip(self.get_axes(), coords):\n            result += axis.number_to_point(coord) - origin\n        return result",
  "def c2p(self, *coords):\n        return self.coords_to_point(*coords)",
  "def point_to_coords(self, point):\n        return tuple([axis.point_to_number(point) for axis in self.get_axes()])",
  "def p2c(self, point):\n        return self.point_to_coords(point)",
  "def get_axes(self):\n        return self.axes",
  "def get_coordinate_labels(self, x_vals=None, y_vals=None):\n        if x_vals is None:\n            x_vals = []\n        if y_vals is None:\n            y_vals = []\n        x_mobs = self.get_x_axis().get_number_mobjects(*x_vals)\n        y_mobs = self.get_y_axis().get_number_mobjects(*y_vals)\n\n        self.coordinate_labels = VGroup(x_mobs, y_mobs)\n        return self.coordinate_labels",
  "def add_coordinates(self, x_vals=None, y_vals=None):\n        self.add(self.get_coordinate_labels(x_vals, y_vals))\n        return self",
  "def __init__(self, **kwargs):\n        Axes.__init__(self, **kwargs)\n        z_axis = self.z_axis = self.create_axis(\n            self.z_min, self.z_max, self.z_axis_config\n        )\n        z_axis.rotate(-np.pi / 2, UP, about_point=ORIGIN)\n        z_axis.rotate(angle_of_vector(self.z_normal), OUT, about_point=ORIGIN)\n        self.axes.add(z_axis)\n        self.add(z_axis)\n\n        self.add_3d_pieces()\n        self.set_axis_shading()",
  "def add_3d_pieces(self):\n        for axis in self.axes:\n            axis.pieces = VGroup(*axis.get_pieces(self.num_axis_pieces))\n            axis.add(axis.pieces)\n            axis.set_stroke(width=0, family=False)\n            axis.set_shade_in_3d(True)",
  "def set_axis_shading(self):\n        def make_func(axis):\n            vect = self.light_source\n            return lambda: (axis.get_edge_center(-vect), axis.get_edge_center(vect),)\n\n        for axis in self:\n            for submob in axis.family_members_with_points():\n                submob.get_gradient_start_and_end_points = make_func(axis)\n                submob.get_unit_normal = lambda a: np.ones(3)\n                submob.set_sheen(0.2)",
  "def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.init_background_lines()",
  "def init_background_lines(self):\n        \"\"\"Will init all the lines of NumberPlanes (faded or not)\"\"\"\n        if self.faded_line_style is None:\n            style = dict(self.background_line_style)\n            # For anything numerical, like stroke_width\n            # and stroke_opacity, chop it in half\n            for key in style:\n                if isinstance(style[key], numbers.Number):\n                    style[key] *= 0.5\n            self.faded_line_style = style\n\n        self.background_lines, self.faded_lines = self.get_lines()\n        self.background_lines.set_style(**self.background_line_style,)\n        self.faded_lines.set_style(**self.faded_line_style,)\n        self.add_to_back(\n            self.faded_lines, self.background_lines,\n        )",
  "def get_lines(self):\n        \"\"\"Generate all the lines, faded and not faded. Two sets of lines are generated: one parallel to the X-axis, and parallel to the Y-axis.\n        \n        Returns\n        -------\n        Tuple[:class:`~.VGroup`, :class:`~.VGroup`]\n            The first (i.e the non faded lines) and second (i.e the faded lines) sets of lines, respectively.\n        \"\"\"\n        x_axis = self.get_x_axis()\n        y_axis = self.get_y_axis()\n        x_freq = self.x_line_frequency\n        y_freq = self.y_line_frequency\n\n        x_lines1, x_lines2 = self.get_lines_parallel_to_axis(\n            x_axis, y_axis, x_freq, self.faded_line_ratio,\n        )\n        y_lines1, y_lines2 = self.get_lines_parallel_to_axis(\n            y_axis, x_axis, y_freq, self.faded_line_ratio,\n        )\n        lines1 = VGroup(*x_lines1, *y_lines1)\n        lines2 = VGroup(*x_lines2, *y_lines2)\n        return lines1, lines2",
  "def get_lines_parallel_to_axis(\n        self, axis_parallel_to, axis_perpendicular_to, freq, ratio_faded_lines\n    ):\n        \"\"\"Generate a set of lines parallel to an axis.\n\n        Parameters\n        ----------\n        axis_parallel_to : :class:`~.Line`\n            The axis with which the lines will be parallel.\n\n        axis_perpendicular_to : :class:`~.Line`\n            The axis with which the lines will be perpendicular.\n        \n        ratio_faded_lines : :class:`float`\n            The number of faded lines between each non-faded line. \n\n        freq : :class:`float`\n            Frequency of non-faded lines (number of non-faded lines per graph unit).\n\n        Returns\n        -------\n        Tuple[:class:`~.VGroup`, :class:`~.VGroup`]\n            The first (i.e the non-faded lines parallel to `axis_parallel_to`) and second (i.e the faded lines parallel to `axis_parallel_to`) sets of lines, respectively.     \n        \"\"\"\n        line = Line(axis_parallel_to.get_start(), axis_parallel_to.get_end())\n        dense_freq = ratio_faded_lines\n        step = (1 / dense_freq) * freq\n        lines1 = VGroup()\n        lines2 = VGroup()\n        unit_vector_axis_perp_to = axis_perpendicular_to.get_unit_vector()\n        ranges = (\n            np.arange(0, axis_perpendicular_to.x_max, step),\n            np.arange(0, axis_perpendicular_to.x_min, -step),\n        )\n        for inputs in ranges:\n            for k, x in enumerate(inputs):\n                new_line = line.copy()\n                new_line.shift(unit_vector_axis_perp_to * x)\n                if k % ratio_faded_lines == 0:\n                    lines1.add(new_line)\n                else:\n                    lines2.add(new_line)\n        return lines1, lines2",
  "def get_center_point(self):\n        return self.coords_to_point(0, 0)",
  "def get_x_unit_size(self):\n        return self.get_x_axis().get_unit_size()",
  "def get_y_unit_size(self):\n        return self.get_x_axis().get_unit_size()",
  "def get_axes(self):\n        return self.axes",
  "def get_vector(self, coords, **kwargs):\n        kwargs[\"buff\"] = 0\n        return Arrow(\n            self.coords_to_point(0, 0), self.coords_to_point(*coords), **kwargs\n        )",
  "def prepare_for_nonlinear_transform(self, num_inserted_curves=50):\n        for mob in self.family_members_with_points():\n            num_curves = mob.get_num_curves()\n            if num_inserted_curves > num_curves:\n                mob.insert_n_curves(num_inserted_curves - num_curves)\n        return self",
  "def number_to_point(self, number):\n        number = complex(number)\n        return self.coords_to_point(number.real, number.imag)",
  "def n2p(self, number):\n        return self.number_to_point(number)",
  "def point_to_number(self, point):\n        x, y = self.point_to_coords(point)\n        return complex(x, y)",
  "def p2n(self, point):\n        return self.point_to_number(point)",
  "def get_default_coordinate_values(self):\n        x_numbers = self.get_x_axis().default_numbers_to_display()\n        y_numbers = self.get_y_axis().default_numbers_to_display()\n        y_numbers = [complex(0, y) for y in y_numbers if y != 0]\n        return [*x_numbers, *y_numbers]",
  "def get_coordinate_labels(self, *numbers, **kwargs):\n        if len(numbers) == 0:\n            numbers = self.get_default_coordinate_values()\n\n        self.coordinate_labels = VGroup()\n        for number in numbers:\n            z = complex(number)\n            if abs(z.imag) > abs(z.real):\n                axis = self.get_y_axis()\n                value = z.imag\n                kwargs = merge_dicts_recursively(\n                    kwargs, {\"number_config\": {\"unit\": \"i\"}},\n                )\n            else:\n                axis = self.get_x_axis()\n                value = z.real\n            number_mob = axis.get_number_mobject(value, **kwargs)\n            self.coordinate_labels.add(number_mob)\n        return self.coordinate_labels",
  "def add_coordinates(self, *numbers):\n        self.add(self.get_coordinate_labels(*numbers))\n        return self",
  "def make_func(axis):\n            vect = self.light_source\n            return lambda: (axis.get_edge_center(-vect), axis.get_edge_center(vect),)",
  "class NumberLine(Line):\n    CONFIG = {\n        \"color\": LIGHT_GREY,\n        \"x_min\": -config[\"frame_x_radius\"],\n        \"x_max\": config[\"frame_x_radius\"],\n        \"unit_size\": 1,\n        \"include_ticks\": True,\n        \"tick_size\": 0.1,\n        \"tick_frequency\": 1,\n        # Defaults to value near x_min s.t. 0 is a tick\n        # TODO, rename this\n        \"leftmost_tick\": None,\n        # Change name\n        \"numbers_with_elongated_ticks\": [0],\n        \"include_numbers\": False,\n        \"numbers_to_show\": None,\n        \"longer_tick_multiple\": 2,\n        \"number_at_center\": 0,\n        \"number_scale_val\": 0.75,\n        \"label_direction\": DOWN,\n        \"line_to_number_buff\": MED_SMALL_BUFF,\n        \"include_tip\": False,\n        \"tip_width\": 0.25,\n        \"tip_height\": 0.25,\n        \"add_start\": 0,  # extend number line by this amount at its starting point\n        \"add_end\": 0,  # extend number line by this amount at its end point\n        \"decimal_number_config\": {\"num_decimal_places\": 0,},\n        \"exclude_zero_from_default_numbers\": False,\n    }\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        start = self.unit_size * self.x_min * RIGHT\n        end = self.unit_size * self.x_max * RIGHT\n        Line.__init__(\n            self, start - self.add_start * RIGHT, end + self.add_end * RIGHT, **kwargs\n        )\n        self.shift(-self.number_to_point(self.number_at_center))\n\n        self.init_leftmost_tick()\n        if self.include_tip:\n            self.add_tip()\n        if self.include_ticks:\n            self.add_tick_marks()\n        if self.include_numbers:\n            self.add_numbers()\n\n    def init_leftmost_tick(self):\n        if self.leftmost_tick is None:\n            self.leftmost_tick = op.mul(\n                self.tick_frequency, np.ceil(self.x_min / self.tick_frequency)\n            )\n\n    def add_tick_marks(self):\n        tick_size = self.tick_size\n        self.tick_marks = VGroup(\n            *[self.get_tick(x, tick_size) for x in self.get_tick_numbers()]\n        )\n        big_tick_size = tick_size * self.longer_tick_multiple\n        self.big_tick_marks = VGroup(\n            *[\n                self.get_tick(x, big_tick_size)\n                for x in self.numbers_with_elongated_ticks\n            ]\n        )\n        self.add(\n            self.tick_marks, self.big_tick_marks,\n        )\n\n    def get_tick(self, x, size=None):\n        if size is None:\n            size = self.tick_size\n        result = Line(size * DOWN, size * UP)\n        result.rotate(self.get_angle())\n        result.move_to(self.number_to_point(x))\n        result.match_style(self)\n        return result\n\n    def get_tick_marks(self):\n        return VGroup(*self.tick_marks, *self.big_tick_marks,)\n\n    def get_tick_numbers(self):\n        u = -1 if self.include_tip and self.add_end == 0 else 1\n        return np.arange(\n            self.leftmost_tick,\n            self.x_max + u * self.tick_frequency / 2,\n            self.tick_frequency,\n        )\n\n    def number_to_point(self, number):\n        alpha = float(number - self.x_min) / (self.x_max - self.x_min)\n        return interpolate(\n            self.get_start() + self.add_start * RIGHT,\n            self.get_end() - self.add_end * RIGHT,\n            alpha,\n        )\n\n    def point_to_number(self, point):\n        start_point, end_point = self.get_start_and_end()\n        full_vect = end_point - start_point\n        unit_vect = normalize(full_vect)\n\n        def distance_from_start(p):\n            return np.dot(p - start_point, unit_vect)\n\n        proportion = fdiv(distance_from_start(point), distance_from_start(end_point))\n        return interpolate(self.x_min, self.x_max, proportion)\n\n    def n2p(self, number):\n        \"\"\"Abbreviation for number_to_point\"\"\"\n        return self.number_to_point(number)\n\n    def p2n(self, point):\n        \"\"\"Abbreviation for point_to_number\"\"\"\n        return self.point_to_number(point)\n\n    def get_unit_size(self):\n        return (self.x_max - self.x_min) / self.get_length()\n\n    def default_numbers_to_display(self):\n        if self.numbers_to_show is not None:\n            return self.numbers_to_show\n        numbers = np.arange(np.floor(self.leftmost_tick), np.ceil(self.x_max),)\n        if self.exclude_zero_from_default_numbers:\n            numbers = numbers[numbers != 0]\n        return numbers\n\n    def get_number_mobject(\n        self, number, number_config=None, scale_val=None, direction=None, buff=None\n    ):\n        number_config = merge_dicts_recursively(\n            self.decimal_number_config, number_config or {},\n        )\n        if scale_val is None:\n            scale_val = self.number_scale_val\n        if direction is None:\n            direction = self.label_direction\n        buff = buff or self.line_to_number_buff\n\n        num_mob = DecimalNumber(number, **number_config)\n        num_mob.scale(scale_val)\n        num_mob.next_to(self.number_to_point(number), direction=direction, buff=buff)\n        return num_mob\n\n    def get_number_mobjects(self, *numbers, **kwargs):\n        if len(numbers) == 0:\n            numbers = self.default_numbers_to_display()\n        return VGroup(\n            *[self.get_number_mobject(number, **kwargs) for number in numbers]\n        )\n\n    def get_labels(self):\n        return self.get_number_mobjects()\n\n    def add_numbers(self, *numbers, **kwargs):\n        self.numbers = self.get_number_mobjects(*numbers, **kwargs)\n        self.add(self.numbers)\n        return self",
  "class UnitInterval(NumberLine):\n    CONFIG = {\n        \"x_min\": 0,\n        \"x_max\": 1,\n        \"unit_size\": 6,\n        \"tick_frequency\": 0.1,\n        \"numbers_with_elongated_ticks\": [0, 1],\n        \"number_at_center\": 0.5,\n        \"decimal_number_config\": {\"num_decimal_places\": 1,},\n    }",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        start = self.unit_size * self.x_min * RIGHT\n        end = self.unit_size * self.x_max * RIGHT\n        Line.__init__(\n            self, start - self.add_start * RIGHT, end + self.add_end * RIGHT, **kwargs\n        )\n        self.shift(-self.number_to_point(self.number_at_center))\n\n        self.init_leftmost_tick()\n        if self.include_tip:\n            self.add_tip()\n        if self.include_ticks:\n            self.add_tick_marks()\n        if self.include_numbers:\n            self.add_numbers()",
  "def init_leftmost_tick(self):\n        if self.leftmost_tick is None:\n            self.leftmost_tick = op.mul(\n                self.tick_frequency, np.ceil(self.x_min / self.tick_frequency)\n            )",
  "def add_tick_marks(self):\n        tick_size = self.tick_size\n        self.tick_marks = VGroup(\n            *[self.get_tick(x, tick_size) for x in self.get_tick_numbers()]\n        )\n        big_tick_size = tick_size * self.longer_tick_multiple\n        self.big_tick_marks = VGroup(\n            *[\n                self.get_tick(x, big_tick_size)\n                for x in self.numbers_with_elongated_ticks\n            ]\n        )\n        self.add(\n            self.tick_marks, self.big_tick_marks,\n        )",
  "def get_tick(self, x, size=None):\n        if size is None:\n            size = self.tick_size\n        result = Line(size * DOWN, size * UP)\n        result.rotate(self.get_angle())\n        result.move_to(self.number_to_point(x))\n        result.match_style(self)\n        return result",
  "def get_tick_marks(self):\n        return VGroup(*self.tick_marks, *self.big_tick_marks,)",
  "def get_tick_numbers(self):\n        u = -1 if self.include_tip and self.add_end == 0 else 1\n        return np.arange(\n            self.leftmost_tick,\n            self.x_max + u * self.tick_frequency / 2,\n            self.tick_frequency,\n        )",
  "def number_to_point(self, number):\n        alpha = float(number - self.x_min) / (self.x_max - self.x_min)\n        return interpolate(\n            self.get_start() + self.add_start * RIGHT,\n            self.get_end() - self.add_end * RIGHT,\n            alpha,\n        )",
  "def point_to_number(self, point):\n        start_point, end_point = self.get_start_and_end()\n        full_vect = end_point - start_point\n        unit_vect = normalize(full_vect)\n\n        def distance_from_start(p):\n            return np.dot(p - start_point, unit_vect)\n\n        proportion = fdiv(distance_from_start(point), distance_from_start(end_point))\n        return interpolate(self.x_min, self.x_max, proportion)",
  "def n2p(self, number):\n        \"\"\"Abbreviation for number_to_point\"\"\"\n        return self.number_to_point(number)",
  "def p2n(self, point):\n        \"\"\"Abbreviation for point_to_number\"\"\"\n        return self.point_to_number(point)",
  "def get_unit_size(self):\n        return (self.x_max - self.x_min) / self.get_length()",
  "def default_numbers_to_display(self):\n        if self.numbers_to_show is not None:\n            return self.numbers_to_show\n        numbers = np.arange(np.floor(self.leftmost_tick), np.ceil(self.x_max),)\n        if self.exclude_zero_from_default_numbers:\n            numbers = numbers[numbers != 0]\n        return numbers",
  "def get_number_mobject(\n        self, number, number_config=None, scale_val=None, direction=None, buff=None\n    ):\n        number_config = merge_dicts_recursively(\n            self.decimal_number_config, number_config or {},\n        )\n        if scale_val is None:\n            scale_val = self.number_scale_val\n        if direction is None:\n            direction = self.label_direction\n        buff = buff or self.line_to_number_buff\n\n        num_mob = DecimalNumber(number, **number_config)\n        num_mob.scale(scale_val)\n        num_mob.next_to(self.number_to_point(number), direction=direction, buff=buff)\n        return num_mob",
  "def get_number_mobjects(self, *numbers, **kwargs):\n        if len(numbers) == 0:\n            numbers = self.default_numbers_to_display()\n        return VGroup(\n            *[self.get_number_mobject(number, **kwargs) for number in numbers]\n        )",
  "def get_labels(self):\n        return self.get_number_mobjects()",
  "def add_numbers(self, *numbers, **kwargs):\n        self.numbers = self.get_number_mobjects(*numbers, **kwargs)\n        self.add(self.numbers)\n        return self",
  "def distance_from_start(p):\n            return np.dot(p - start_point, unit_vect)",
  "class ScreenRectangle(Rectangle):\n    CONFIG = {\"aspect_ratio\": 16.0 / 9.0, \"height\": 4}\n\n    def __init__(self, **kwargs):\n        Rectangle.__init__(self, **kwargs)\n        self.set_width(self.aspect_ratio * self.get_height(), stretch=True)",
  "class FullScreenRectangle(ScreenRectangle):\n    CONFIG = {\n        \"height\": config[\"frame_height\"],\n    }",
  "class FullScreenFadeRectangle(FullScreenRectangle):\n    CONFIG = {\n        \"stroke_width\": 0,\n        \"fill_color\": BLACK,\n        \"fill_opacity\": 0.7,\n    }",
  "class PictureInPictureFrame(Rectangle):\n    CONFIG = {\"height\": 3, \"aspect_ratio\": 16.0 / 9.0}\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        Rectangle.__init__(\n            self, width=self.aspect_ratio * self.height, height=self.height, **kwargs\n        )",
  "def __init__(self, **kwargs):\n        Rectangle.__init__(self, **kwargs)\n        self.set_width(self.aspect_ratio * self.get_height(), stretch=True)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        Rectangle.__init__(\n            self, width=self.aspect_ratio * self.height, height=self.height, **kwargs\n        )",
  "def get_colored_background_image(\n    scalar_field_func,\n    number_to_rgb_func,\n    pixel_height=config[\"pixel_height\"],\n    pixel_width=config[\"pixel_width\"],\n):\n    ph = config[\"pixel_height\"]\n    pw = config[\"pixel_width\"]\n    fw = config[\"frame_width\"]\n    fh = config[\"frame_height\"]\n    points_array = np.zeros((ph, pw, 3))\n    x_array = np.linspace(-fw / 2, fw / 2, pw)\n    x_array = x_array.reshape((1, len(x_array)))\n    x_array = x_array.repeat(ph, axis=0)\n\n    y_array = np.linspace(fh / 2, -fh / 2, ph)\n    y_array = y_array.reshape((len(y_array), 1))\n    y_array.repeat(pw, axis=1)\n    points_array[:, :, 0] = x_array\n    points_array[:, :, 1] = y_array\n    scalars = np.apply_along_axis(scalar_field_func, 2, points_array)\n    rgb_array = number_to_rgb_func(scalars.flatten()).reshape((ph, pw, 3))\n    return Image.fromarray((rgb_array * 255).astype(\"uint8\"))",
  "def get_rgb_gradient_function(\n    min_value=0, max_value=1, colors=[BLUE, RED], flip_alphas=True,  # Why?\n):\n    rgbs = np.array(list(map(color_to_rgb, colors)))\n\n    def func(values):\n        alphas = inverse_interpolate(min_value, max_value, np.array(values))\n        alphas = np.clip(alphas, 0, 1)\n        # if flip_alphas:\n        #     alphas = 1 - alphas\n        scaled_alphas = alphas * (len(rgbs) - 1)\n        indices = scaled_alphas.astype(int)\n        next_indices = np.clip(indices + 1, 0, len(rgbs) - 1)\n        inter_alphas = scaled_alphas % 1\n        inter_alphas = inter_alphas.repeat(3).reshape((len(indices), 3))\n        result = interpolate(rgbs[indices], rgbs[next_indices], inter_alphas)\n        return result\n\n    return func",
  "def get_color_field_image_file(\n    scalar_func, min_value=0, max_value=2, colors=DEFAULT_SCALAR_FIELD_COLORS\n):\n    # try_hash\n    np.random.seed(0)\n    sample_inputs = 5 * np.random.random(size=(10, 3)) - 10\n    sample_outputs = np.apply_along_axis(scalar_func, 1, sample_inputs)\n    func_hash = hash(\n        str(min_value) + str(max_value) + str(colors) + str(sample_outputs)\n    )\n    file_name = \"%d.png\" % func_hash\n    full_path = os.path.join(RASTER_IMAGE_DIR, file_name)\n    if not os.path.exists(full_path):\n        logger.info(\"Rendering color field image \" + str(func_hash))\n        rgb_gradient_func = get_rgb_gradient_function(\n            min_value=min_value, max_value=max_value, colors=colors\n        )\n        image = get_colored_background_image(scalar_func, rgb_gradient_func)\n        image.save(full_path)\n    return full_path",
  "def move_along_vector_field(mobject, func):\n    mobject.add_updater(lambda m, dt: m.shift(func(m.get_center()) * dt))\n    return mobject",
  "def move_submobjects_along_vector_field(mobject, func):\n    def apply_nudge(mob, dt):\n        for submob in mob:\n            x, y = submob.get_center()[:2]\n            if abs(x) < config[\"frame_width\"] and abs(y) < config[\"frame_height\"]:\n                submob.shift(func(submob.get_center()) * dt)\n\n    mobject.add_updater(apply_nudge)\n    return mobject",
  "def move_points_along_vector_field(mobject, func):\n    def apply_nudge(self, dt):\n        self.mobject.apply_function(lambda p: p + func(p) * dt)\n\n    mobject.add_updater(apply_nudge)\n    return mobject",
  "class VectorField(VGroup):\n    CONFIG = {\n        \"delta_x\": 0.5,\n        \"delta_y\": 0.5,\n        \"x_min\": int(np.floor(-config[\"frame_width\"] / 2)),\n        \"x_max\": int(np.ceil(config[\"frame_width\"] / 2)),\n        \"y_min\": int(np.floor(-config[\"frame_height\"] / 2)),\n        \"y_max\": int(np.ceil(config[\"frame_height\"] / 2)),\n        \"min_magnitude\": 0,\n        \"max_magnitude\": 2,\n        \"colors\": DEFAULT_SCALAR_FIELD_COLORS,\n        # Takes in actual norm, spits out displayed norm\n        \"length_func\": lambda norm: 0.45 * sigmoid(norm),\n        \"opacity\": 1.0,\n        \"vector_config\": {},\n    }\n\n    def __init__(self, func, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.func = func\n        self.rgb_gradient_function = get_rgb_gradient_function(\n            self.min_magnitude, self.max_magnitude, self.colors, flip_alphas=False\n        )\n        x_range = np.arange(self.x_min, self.x_max + self.delta_x, self.delta_x)\n        y_range = np.arange(self.y_min, self.y_max + self.delta_y, self.delta_y)\n        for x, y in it.product(x_range, y_range):\n            point = x * RIGHT + y * UP\n            self.add(self.get_vector(point))\n        self.set_opacity(self.opacity)\n\n    def get_vector(self, point, **kwargs):\n        output = np.array(self.func(point))\n        norm = get_norm(output)\n        if norm == 0:\n            output *= 0\n        else:\n            output *= self.length_func(norm) / norm\n        vector_config = dict(self.vector_config)\n        vector_config.update(kwargs)\n        vect = Vector(output, **vector_config)\n        vect.shift(point)\n        fill_color = rgb_to_color(self.rgb_gradient_function(np.array([norm]))[0])\n        vect.set_color(fill_color)\n        return vect",
  "class StreamLines(VGroup):\n    CONFIG = {\n        # TODO, this is an awkward way to inherit\n        # defaults to a method.\n        \"start_points_generator_config\": {},\n        # Config for choosing start points\n        \"x_min\": -8,\n        \"x_max\": 8,\n        \"y_min\": -5,\n        \"y_max\": 5,\n        \"delta_x\": 0.5,\n        \"delta_y\": 0.5,\n        \"n_repeats\": 1,\n        \"noise_factor\": None,\n        # Config for drawing lines\n        \"dt\": 0.05,\n        \"virtual_time\": 3,\n        \"n_anchors_per_line\": 100,\n        \"stroke_width\": 1,\n        \"stroke_color\": WHITE,\n        \"color_by_arc_length\": True,\n        # Min and max arc lengths meant to define\n        # the color range, should color_by_arc_length be True\n        \"min_arc_length\": 0,\n        \"max_arc_length\": 12,\n        \"color_by_magnitude\": False,\n        # Min and max magnitudes meant to define\n        # the color range, should color_by_magnitude be True\n        \"min_magnitude\": 0.5,\n        \"max_magnitude\": 1.5,\n        \"colors\": DEFAULT_SCALAR_FIELD_COLORS,\n        \"cutoff_norm\": 15,\n    }\n\n    def __init__(self, func, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.func = func\n        dt = self.dt\n\n        start_points = self.get_start_points(**self.start_points_generator_config)\n        for point in start_points:\n            points = [point]\n            for t in np.arange(0, self.virtual_time, dt):\n                last_point = points[-1]\n                points.append(last_point + dt * func(last_point))\n                if get_norm(last_point) > self.cutoff_norm:\n                    break\n            line = VMobject()\n            step = max(1, int(len(points) / self.n_anchors_per_line))\n            line.set_points_smoothly(points[::step])\n            self.add(line)\n\n        self.set_stroke(self.stroke_color, self.stroke_width)\n\n        if self.color_by_arc_length:\n            len_to_rgb = get_rgb_gradient_function(\n                self.min_arc_length, self.max_arc_length, colors=self.colors,\n            )\n            for line in self:\n                arc_length = line.get_arc_length()\n                rgb = len_to_rgb([arc_length])[0]\n                color = rgb_to_color(rgb)\n                line.set_color(color)\n        elif self.color_by_magnitude:\n            image_file = get_color_field_image_file(\n                lambda p: get_norm(func(p)),\n                min_value=self.min_magnitude,\n                max_value=self.max_magnitude,\n                colors=self.colors,\n            )\n            self.color_using_background_image(image_file)\n\n    def get_start_points(self):\n        x_min = self.x_min\n        x_max = self.x_max\n        y_min = self.y_min\n        y_max = self.y_max\n        delta_x = self.delta_x\n        delta_y = self.delta_y\n        n_repeats = self.n_repeats\n        noise_factor = self.noise_factor\n\n        if noise_factor is None:\n            noise_factor = delta_y / 2\n        return np.array(\n            [\n                x * RIGHT + y * UP + noise_factor * np.random.random(3)\n                for n in range(n_repeats)\n                for x in np.arange(x_min, x_max + delta_x, delta_x)\n                for y in np.arange(y_min, y_max + delta_y, delta_y)\n            ]\n        )",
  "class ShowPassingFlashWithThinningStrokeWidth(AnimationGroup):\n    CONFIG = {\"n_segments\": 10, \"time_width\": 0.1, \"remover\": True}\n\n    def __init__(self, vmobject, **kwargs):\n        digest_config(self, kwargs)\n        max_stroke_width = vmobject.get_stroke_width()\n        max_time_width = kwargs.pop(\"time_width\", self.time_width)\n        AnimationGroup.__init__(\n            self,\n            *[\n                ShowPassingFlash(\n                    vmobject.deepcopy().set_stroke(width=stroke_width),\n                    time_width=time_width,\n                    **kwargs,\n                )\n                for stroke_width, time_width in zip(\n                    np.linspace(0, max_stroke_width, self.n_segments),\n                    np.linspace(max_time_width, 0, self.n_segments),\n                )\n            ],\n        )",
  "class AnimatedStreamLines(VGroup):\n    CONFIG = {\n        \"lag_range\": 4,\n        \"line_anim_class\": ShowPassingFlash,\n        \"line_anim_config\": {\"run_time\": 4, \"rate_func\": linear, \"time_width\": 0.3,},\n    }\n\n    def __init__(self, stream_lines, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.stream_lines = stream_lines\n        for line in stream_lines:\n            line.anim = self.line_anim_class(line, **self.line_anim_config)\n            line.anim.begin()\n            line.time = -self.lag_range * random.random()\n            self.add(line.anim.mobject)\n\n        self.add_updater(lambda m, dt: m.update(dt))\n\n    def update(self, dt):\n        stream_lines = self.stream_lines\n        for line in stream_lines:\n            line.time += dt\n            adjusted_time = max(line.time, 0) % line.anim.run_time\n            line.anim.update(adjusted_time / line.anim.run_time)",
  "def func(values):\n        alphas = inverse_interpolate(min_value, max_value, np.array(values))\n        alphas = np.clip(alphas, 0, 1)\n        # if flip_alphas:\n        #     alphas = 1 - alphas\n        scaled_alphas = alphas * (len(rgbs) - 1)\n        indices = scaled_alphas.astype(int)\n        next_indices = np.clip(indices + 1, 0, len(rgbs) - 1)\n        inter_alphas = scaled_alphas % 1\n        inter_alphas = inter_alphas.repeat(3).reshape((len(indices), 3))\n        result = interpolate(rgbs[indices], rgbs[next_indices], inter_alphas)\n        return result",
  "def apply_nudge(mob, dt):\n        for submob in mob:\n            x, y = submob.get_center()[:2]\n            if abs(x) < config[\"frame_width\"] and abs(y) < config[\"frame_height\"]:\n                submob.shift(func(submob.get_center()) * dt)",
  "def apply_nudge(self, dt):\n        self.mobject.apply_function(lambda p: p + func(p) * dt)",
  "def __init__(self, func, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.func = func\n        self.rgb_gradient_function = get_rgb_gradient_function(\n            self.min_magnitude, self.max_magnitude, self.colors, flip_alphas=False\n        )\n        x_range = np.arange(self.x_min, self.x_max + self.delta_x, self.delta_x)\n        y_range = np.arange(self.y_min, self.y_max + self.delta_y, self.delta_y)\n        for x, y in it.product(x_range, y_range):\n            point = x * RIGHT + y * UP\n            self.add(self.get_vector(point))\n        self.set_opacity(self.opacity)",
  "def get_vector(self, point, **kwargs):\n        output = np.array(self.func(point))\n        norm = get_norm(output)\n        if norm == 0:\n            output *= 0\n        else:\n            output *= self.length_func(norm) / norm\n        vector_config = dict(self.vector_config)\n        vector_config.update(kwargs)\n        vect = Vector(output, **vector_config)\n        vect.shift(point)\n        fill_color = rgb_to_color(self.rgb_gradient_function(np.array([norm]))[0])\n        vect.set_color(fill_color)\n        return vect",
  "def __init__(self, func, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.func = func\n        dt = self.dt\n\n        start_points = self.get_start_points(**self.start_points_generator_config)\n        for point in start_points:\n            points = [point]\n            for t in np.arange(0, self.virtual_time, dt):\n                last_point = points[-1]\n                points.append(last_point + dt * func(last_point))\n                if get_norm(last_point) > self.cutoff_norm:\n                    break\n            line = VMobject()\n            step = max(1, int(len(points) / self.n_anchors_per_line))\n            line.set_points_smoothly(points[::step])\n            self.add(line)\n\n        self.set_stroke(self.stroke_color, self.stroke_width)\n\n        if self.color_by_arc_length:\n            len_to_rgb = get_rgb_gradient_function(\n                self.min_arc_length, self.max_arc_length, colors=self.colors,\n            )\n            for line in self:\n                arc_length = line.get_arc_length()\n                rgb = len_to_rgb([arc_length])[0]\n                color = rgb_to_color(rgb)\n                line.set_color(color)\n        elif self.color_by_magnitude:\n            image_file = get_color_field_image_file(\n                lambda p: get_norm(func(p)),\n                min_value=self.min_magnitude,\n                max_value=self.max_magnitude,\n                colors=self.colors,\n            )\n            self.color_using_background_image(image_file)",
  "def get_start_points(self):\n        x_min = self.x_min\n        x_max = self.x_max\n        y_min = self.y_min\n        y_max = self.y_max\n        delta_x = self.delta_x\n        delta_y = self.delta_y\n        n_repeats = self.n_repeats\n        noise_factor = self.noise_factor\n\n        if noise_factor is None:\n            noise_factor = delta_y / 2\n        return np.array(\n            [\n                x * RIGHT + y * UP + noise_factor * np.random.random(3)\n                for n in range(n_repeats)\n                for x in np.arange(x_min, x_max + delta_x, delta_x)\n                for y in np.arange(y_min, y_max + delta_y, delta_y)\n            ]\n        )",
  "def __init__(self, vmobject, **kwargs):\n        digest_config(self, kwargs)\n        max_stroke_width = vmobject.get_stroke_width()\n        max_time_width = kwargs.pop(\"time_width\", self.time_width)\n        AnimationGroup.__init__(\n            self,\n            *[\n                ShowPassingFlash(\n                    vmobject.deepcopy().set_stroke(width=stroke_width),\n                    time_width=time_width,\n                    **kwargs,\n                )\n                for stroke_width, time_width in zip(\n                    np.linspace(0, max_stroke_width, self.n_segments),\n                    np.linspace(max_time_width, 0, self.n_segments),\n                )\n            ],\n        )",
  "def __init__(self, stream_lines, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        self.stream_lines = stream_lines\n        for line in stream_lines:\n            line.anim = self.line_anim_class(line, **self.line_anim_config)\n            line.anim.begin()\n            line.time = -self.lag_range * random.random()\n            self.add(line.anim.mobject)\n\n        self.add_updater(lambda m, dt: m.update(dt))",
  "def update(self, dt):\n        stream_lines = self.stream_lines\n        for line in stream_lines:\n            line.time += dt\n            adjusted_time = max(line.time, 0) % line.anim.run_time\n            line.anim.update(adjusted_time / line.anim.run_time)",
  "def assert_is_mobject_method(method):\n    assert inspect.ismethod(method)\n    mobject = method.__self__\n    assert isinstance(mobject, Mobject)",
  "def always(method, *args, **kwargs):\n    assert_is_mobject_method(method)\n    mobject = method.__self__\n    func = method.__func__\n    mobject.add_updater(lambda m: func(m, *args, **kwargs))\n    return mobject",
  "def f_always(method, *arg_generators, **kwargs):\n    \"\"\"\n    More functional version of always, where instead\n    of taking in args, it takes in functions which ouput\n    the relevant arguments.\n    \"\"\"\n    assert_is_mobject_method(method)\n    mobject = method.__self__\n    func = method.__func__\n\n    def updater(mob):\n        args = [arg_generator() for arg_generator in arg_generators]\n        func(mob, *args, **kwargs)\n\n    mobject.add_updater(updater)\n    return mobject",
  "def always_redraw(func):\n    mob = func()\n    mob.add_updater(lambda m: mob.become(func()))\n    return mob",
  "def always_shift(mobject, direction=RIGHT, rate=0.1):\n    mobject.add_updater(lambda m, dt: m.shift(dt * rate * direction))\n    return mobject",
  "def always_rotate(mobject, rate=20 * DEGREES, **kwargs):\n    mobject.add_updater(lambda m, dt: m.rotate(dt * rate, **kwargs))\n    return mobject",
  "def turn_animation_into_updater(animation, cycle=False, **kwargs):\n    \"\"\"\n    Add an updater to the animation's mobject which applies\n    the interpolation and update functions of the animation\n\n    If cycle is True, this repeats over and over.  Otherwise,\n    the updater will be popped uplon completion\n    \"\"\"\n    mobject = animation.mobject\n    animation.update_config(**kwargs)\n    animation.suspend_mobject_updating = False\n    animation.begin()\n    animation.total_time = 0\n\n    def update(m, dt):\n        run_time = animation.get_run_time()\n        time_ratio = animation.total_time / run_time\n        if cycle:\n            alpha = time_ratio % 1\n        else:\n            alpha = np.clip(time_ratio, 0, 1)\n            if alpha >= 1:\n                animation.finish()\n                m.remove_updater(update)\n                return\n        animation.interpolate(alpha)\n        animation.update_mobjects(dt)\n        animation.total_time += dt\n\n    mobject.add_updater(update)\n    return mobject",
  "def cycle_animation(animation, **kwargs):\n    return turn_animation_into_updater(animation, cycle=True, **kwargs)",
  "def updater(mob):\n        args = [arg_generator() for arg_generator in arg_generators]\n        func(mob, *args, **kwargs)",
  "def update(m, dt):\n        run_time = animation.get_run_time()\n        time_ratio = animation.total_time / run_time\n        if cycle:\n            alpha = time_ratio % 1\n        else:\n            alpha = np.clip(time_ratio, 0, 1)\n            if alpha >= 1:\n                animation.finish()\n                m.remove_updater(update)\n                return\n        animation.interpolate(alpha)\n        animation.update_mobjects(dt)\n        animation.total_time += dt",
  "class ParametricFunction(VMobject):\n    CONFIG = {\n        \"t_min\": 0,\n        \"t_max\": 1,\n        \"step_size\": 0.01,  # Use \"auto\" (lowercase) for automatic step size\n        \"dt\": 1e-8,\n        # TODO, be smarter about figuring these out?\n        \"discontinuities\": [],\n    }\n\n    def __init__(self, function=None, **kwargs):\n        # either get a function from __init__ or from CONFIG\n        self.function = function or self.function\n        VMobject.__init__(self, **kwargs)\n\n    def get_function(self):\n        return self.function\n\n    def get_point_from_function(self, t):\n        return self.function(t)\n\n    def get_step_size(self, t=None):\n        if self.step_size == \"auto\":\n            \"\"\"\n            for x between -1 to 1, return 0.01\n            else, return log10(x) (rounded)\n            e.g.: 10.5 -> 0.1 ; 1040 -> 10\n            \"\"\"\n            if t == 0:\n                scale = 0\n            else:\n                scale = math.log10(abs(t))\n                if scale < 0:\n                    scale = 0\n\n                scale = math.floor(scale)\n\n            scale -= 2\n            return math.pow(10, scale)\n        else:\n            return self.step_size\n\n    def generate_points(self):\n        t_min, t_max = self.t_min, self.t_max\n        dt = self.dt\n\n        discontinuities = filter(lambda t: t_min <= t <= t_max, self.discontinuities)\n        discontinuities = np.array(list(discontinuities))\n        boundary_times = [\n            self.t_min,\n            self.t_max,\n            *(discontinuities - dt),\n            *(discontinuities + dt),\n        ]\n        boundary_times.sort()\n        for t1, t2 in zip(boundary_times[0::2], boundary_times[1::2]):\n            t_range = list(np.arange(t1, t2, self.get_step_size(t1)))\n            if t_range[-1] != t2:\n                t_range.append(t2)\n            points = np.array([self.function(t) for t in t_range])\n            valid_indices = np.apply_along_axis(np.all, 1, np.isfinite(points))\n            points = points[valid_indices]\n            if len(points) > 0:\n                self.start_new_path(points[0])\n                self.add_points_as_corners(points[1:])\n        self.make_smooth()\n        return self",
  "class FunctionGraph(ParametricFunction):\n    CONFIG = {\n        \"color\": YELLOW,\n        \"x_min\": -config[\"frame_x_radius\"],\n        \"x_max\": config[\"frame_x_radius\"],\n    }\n\n    def __init__(self, function, **kwargs):\n        digest_config(self, kwargs)\n        self.parametric_function = lambda t: np.array([t, function(t), 0])\n        ParametricFunction.__init__(\n            self, self.parametric_function, t_min=self.x_min, t_max=self.x_max, **kwargs\n        )\n        self.function = function\n\n    def get_function(self):\n        return self.function\n\n    def get_point_from_function(self, x):\n        return self.parametric_function(x)",
  "def __init__(self, function=None, **kwargs):\n        # either get a function from __init__ or from CONFIG\n        self.function = function or self.function\n        VMobject.__init__(self, **kwargs)",
  "def get_function(self):\n        return self.function",
  "def get_point_from_function(self, t):\n        return self.function(t)",
  "def get_step_size(self, t=None):\n        if self.step_size == \"auto\":\n            \"\"\"\n            for x between -1 to 1, return 0.01\n            else, return log10(x) (rounded)\n            e.g.: 10.5 -> 0.1 ; 1040 -> 10\n            \"\"\"\n            if t == 0:\n                scale = 0\n            else:\n                scale = math.log10(abs(t))\n                if scale < 0:\n                    scale = 0\n\n                scale = math.floor(scale)\n\n            scale -= 2\n            return math.pow(10, scale)\n        else:\n            return self.step_size",
  "def generate_points(self):\n        t_min, t_max = self.t_min, self.t_max\n        dt = self.dt\n\n        discontinuities = filter(lambda t: t_min <= t <= t_max, self.discontinuities)\n        discontinuities = np.array(list(discontinuities))\n        boundary_times = [\n            self.t_min,\n            self.t_max,\n            *(discontinuities - dt),\n            *(discontinuities + dt),\n        ]\n        boundary_times.sort()\n        for t1, t2 in zip(boundary_times[0::2], boundary_times[1::2]):\n            t_range = list(np.arange(t1, t2, self.get_step_size(t1)))\n            if t_range[-1] != t2:\n                t_range.append(t2)\n            points = np.array([self.function(t) for t in t_range])\n            valid_indices = np.apply_along_axis(np.all, 1, np.isfinite(points))\n            points = points[valid_indices]\n            if len(points) > 0:\n                self.start_new_path(points[0])\n                self.add_points_as_corners(points[1:])\n        self.make_smooth()\n        return self",
  "def __init__(self, function, **kwargs):\n        digest_config(self, kwargs)\n        self.parametric_function = lambda t: np.array([t, function(t), 0])\n        ParametricFunction.__init__(\n            self, self.parametric_function, t_min=self.x_min, t_max=self.x_max, **kwargs\n        )\n        self.function = function",
  "def get_function(self):\n        return self.function",
  "def get_point_from_function(self, x):\n        return self.parametric_function(x)",
  "class AnimatedBoundary(VGroup):\n    CONFIG = {\n        \"colors\": [BLUE_D, BLUE_B, BLUE_E, GREY_BROWN],\n        \"max_stroke_width\": 3,\n        \"cycle_rate\": 0.5,\n        \"back_and_forth\": True,\n        \"draw_rate_func\": smooth,\n        \"fade_rate_func\": smooth,\n    }\n\n    def __init__(self, vmobject, **kwargs):\n        super().__init__(**kwargs)\n        self.vmobject = vmobject\n        self.boundary_copies = [\n            vmobject.copy().set_style(stroke_width=0, fill_opacity=0) for x in range(2)\n        ]\n        self.add(*self.boundary_copies)\n        self.total_time = 0\n        self.add_updater(lambda m, dt: self.update_boundary_copies(dt))\n\n    def update_boundary_copies(self, dt):\n        # Not actual time, but something which passes at\n        # an altered rate to make the implementation below\n        # cleaner\n        time = self.total_time * self.cycle_rate\n        growing, fading = self.boundary_copies\n        colors = self.colors\n        msw = self.max_stroke_width\n        vmobject = self.vmobject\n\n        index = int(time % len(colors))\n        alpha = time % 1\n        draw_alpha = self.draw_rate_func(alpha)\n        fade_alpha = self.fade_rate_func(alpha)\n\n        if self.back_and_forth and int(time) % 2 == 1:\n            bounds = (1 - draw_alpha, 1)\n        else:\n            bounds = (0, draw_alpha)\n        self.full_family_become_partial(growing, vmobject, *bounds)\n        growing.set_stroke(colors[index], width=msw)\n\n        if time >= 1:\n            self.full_family_become_partial(fading, vmobject, 0, 1)\n            fading.set_stroke(color=colors[index - 1], width=(1 - fade_alpha) * msw)\n\n        self.total_time += dt\n\n    def full_family_become_partial(self, mob1, mob2, a, b):\n        family1 = mob1.family_members_with_points()\n        family2 = mob2.family_members_with_points()\n        for sm1, sm2 in zip(family1, family2):\n            sm1.pointwise_become_partial(sm2, a, b)\n        return self",
  "class TracedPath(VMobject):\n    CONFIG = {\n        \"stroke_width\": 2,\n        \"stroke_color\": WHITE,\n        \"min_distance_to_new_point\": 0.1,\n    }\n\n    def __init__(self, traced_point_func, **kwargs):\n        super().__init__(**kwargs)\n        self.traced_point_func = traced_point_func\n        self.add_updater(lambda m: m.update_path())\n\n    def update_path(self):\n        new_point = self.traced_point_func()\n        if self.has_no_points():\n            self.start_new_path(new_point)\n            self.add_line_to(new_point)\n        else:\n            # Set the end to be the new point\n            self.points[-1] = new_point\n\n            # Second to last point\n            nppcc = self.n_points_per_cubic_curve\n            dist = get_norm(new_point - self.points[-nppcc])\n            if dist >= self.min_distance_to_new_point:\n                self.add_line_to(new_point)",
  "def __init__(self, vmobject, **kwargs):\n        super().__init__(**kwargs)\n        self.vmobject = vmobject\n        self.boundary_copies = [\n            vmobject.copy().set_style(stroke_width=0, fill_opacity=0) for x in range(2)\n        ]\n        self.add(*self.boundary_copies)\n        self.total_time = 0\n        self.add_updater(lambda m, dt: self.update_boundary_copies(dt))",
  "def update_boundary_copies(self, dt):\n        # Not actual time, but something which passes at\n        # an altered rate to make the implementation below\n        # cleaner\n        time = self.total_time * self.cycle_rate\n        growing, fading = self.boundary_copies\n        colors = self.colors\n        msw = self.max_stroke_width\n        vmobject = self.vmobject\n\n        index = int(time % len(colors))\n        alpha = time % 1\n        draw_alpha = self.draw_rate_func(alpha)\n        fade_alpha = self.fade_rate_func(alpha)\n\n        if self.back_and_forth and int(time) % 2 == 1:\n            bounds = (1 - draw_alpha, 1)\n        else:\n            bounds = (0, draw_alpha)\n        self.full_family_become_partial(growing, vmobject, *bounds)\n        growing.set_stroke(colors[index], width=msw)\n\n        if time >= 1:\n            self.full_family_become_partial(fading, vmobject, 0, 1)\n            fading.set_stroke(color=colors[index - 1], width=(1 - fade_alpha) * msw)\n\n        self.total_time += dt",
  "def full_family_become_partial(self, mob1, mob2, a, b):\n        family1 = mob1.family_members_with_points()\n        family2 = mob2.family_members_with_points()\n        for sm1, sm2 in zip(family1, family2):\n            sm1.pointwise_become_partial(sm2, a, b)\n        return self",
  "def __init__(self, traced_point_func, **kwargs):\n        super().__init__(**kwargs)\n        self.traced_point_func = traced_point_func\n        self.add_updater(lambda m: m.update_path())",
  "def update_path(self):\n        new_point = self.traced_point_func()\n        if self.has_no_points():\n            self.start_new_path(new_point)\n            self.add_line_to(new_point)\n        else:\n            # Set the end to be the new point\n            self.points[-1] = new_point\n\n            # Second to last point\n            nppcc = self.n_points_per_cubic_curve\n            dist = get_norm(new_point - self.points[-nppcc])\n            if dist >= self.min_distance_to_new_point:\n                self.add_line_to(new_point)",
  "def matrix_to_tex_string(matrix):\n    matrix = np.array(matrix).astype(\"str\")\n    if matrix.ndim == 1:\n        matrix = matrix.reshape((matrix.size, 1))\n    n_rows, n_cols = matrix.shape\n    prefix = \"\\\\left[ \\\\begin{array}{%s}\" % (\"c\" * n_cols)\n    suffix = \"\\\\end{array} \\\\right]\"\n    rows = [\" & \".join(row) for row in matrix]\n    return prefix + \" \\\\\\\\ \".join(rows) + suffix",
  "def matrix_to_mobject(matrix):\n    return TexMobject(matrix_to_tex_string(matrix))",
  "def vector_coordinate_label(vector_mob, integer_labels=True, n_dim=2, color=WHITE):\n    vect = np.array(vector_mob.get_end())\n    if integer_labels:\n        vect = np.round(vect).astype(int)\n    vect = vect[:n_dim]\n    vect = vect.reshape((n_dim, 1))\n    label = Matrix(vect, add_background_rectangles_to_entries=True)\n    label.scale(VECTOR_LABEL_SCALE_FACTOR)\n\n    shift_dir = np.array(vector_mob.get_end())\n    if shift_dir[0] >= 0:  # Pointing right\n        shift_dir -= label.get_left() + DEFAULT_MOBJECT_TO_MOBJECT_BUFFER * LEFT\n    else:  # Pointing left\n        shift_dir -= label.get_right() + DEFAULT_MOBJECT_TO_MOBJECT_BUFFER * RIGHT\n    label.shift(shift_dir)\n    label.set_color(color)\n    label.rect = BackgroundRectangle(label)\n    label.add_to_back(label.rect)\n    return label",
  "class Matrix(VMobject):\n    CONFIG = {\n        \"v_buff\": 0.8,\n        \"h_buff\": 1.3,\n        \"bracket_h_buff\": MED_SMALL_BUFF,\n        \"bracket_v_buff\": MED_SMALL_BUFF,\n        \"add_background_rectangles_to_entries\": False,\n        \"include_background_rectangle\": False,\n        \"element_to_mobject\": TexMobject,\n        \"element_to_mobject_config\": {},\n        \"element_alignment_corner\": DR,\n        \"left_bracket\": \"\\\\big[\",\n        \"right_bracket\": \"\\\\big]\",\n    }\n\n    def __init__(self, matrix, **kwargs):\n        \"\"\"\n        Matrix can either either include numbres, tex_strings,\n        or mobjects\n        \"\"\"\n        VMobject.__init__(self, **kwargs)\n        matrix = np.array(matrix, ndmin=1)\n        mob_matrix = self.matrix_to_mob_matrix(matrix)\n        self.organize_mob_matrix(mob_matrix)\n        self.elements = VGroup(*mob_matrix.flatten())\n        self.add(self.elements)\n        self.add_brackets(self.left_bracket, self.right_bracket)\n        self.center()\n        self.mob_matrix = mob_matrix\n        if self.add_background_rectangles_to_entries:\n            for mob in self.elements:\n                mob.add_background_rectangle()\n        if self.include_background_rectangle:\n            self.add_background_rectangle()\n\n    def matrix_to_mob_matrix(self, matrix):\n        return np.vectorize(self.element_to_mobject)(\n            matrix, **self.element_to_mobject_config\n        )\n\n    def organize_mob_matrix(self, matrix):\n        for i, row in enumerate(matrix):\n            for j, elem in enumerate(row):\n                mob = matrix[i][j]\n                mob.move_to(\n                    i * self.v_buff * DOWN + j * self.h_buff * RIGHT,\n                    self.element_alignment_corner,\n                )\n        return self\n\n    def add_brackets(self, left=\"\\\\big[\", right=\"\\\\big]\"):\n        bracket_pair = TexMobject(left, right)\n        bracket_pair.scale(2)\n        bracket_pair.stretch_to_fit_height(self.get_height() + 2 * self.bracket_v_buff)\n        l_bracket, r_bracket = bracket_pair.split()\n        l_bracket.next_to(self, LEFT, self.bracket_h_buff)\n        r_bracket.next_to(self, RIGHT, self.bracket_h_buff)\n        self.add(l_bracket, r_bracket)\n        self.brackets = VGroup(l_bracket, r_bracket)\n        return self\n\n    def get_columns(self):\n        return VGroup(\n            *[VGroup(*self.mob_matrix[:, i]) for i in range(self.mob_matrix.shape[1])]\n        )\n\n    def set_column_colors(self, *colors):\n        columns = self.get_columns()\n        for color, column in zip(colors, columns):\n            column.set_color(color)\n        return self\n\n    def get_rows(self):\n        \"\"\"Return rows of the matrix as VGroups\n        \n        Returns\n        --------\n        List[:class:`~.VGroup`]\n            Each VGroup contains a row of the matrix.\n        \"\"\"\n        return VGroup(\n            *[VGroup(*self.mob_matrix[i, :]) for i in range(self.mob_matrix.shape[1])]\n        )\n\n    def set_row_colors(self, *colors):\n        \"\"\"Set individual colors for each row of the matrix\n        \n        Parameters\n        ----------\n        colors : :class:`str`\n            The list of colors; each color specified corresponds to a row.\n        \n        Returns\n        -------\n        :class:`Matrix`\n            The current matrix object (self).\n        \"\"\"\n        rows = self.get_rows()\n        for color, row in zip(colors, rows):\n            row.set_color(color)\n        return self\n\n    def add_background_to_entries(self):\n        for mob in self.get_entries():\n            mob.add_background_rectangle()\n        return self\n\n    def get_mob_matrix(self):\n        return self.mob_matrix\n\n    def get_entries(self):\n        return VGroup(*self.get_mob_matrix().flatten())\n\n    def get_brackets(self):\n        return self.brackets",
  "class DecimalMatrix(Matrix):\n    CONFIG = {\n        \"element_to_mobject\": DecimalNumber,\n        \"element_to_mobject_config\": {\"num_decimal_places\": 1},\n    }",
  "class IntegerMatrix(Matrix):\n    CONFIG = {\n        \"element_to_mobject\": Integer,\n    }",
  "class MobjectMatrix(Matrix):\n    CONFIG = {\n        \"element_to_mobject\": lambda m: m,\n    }",
  "def get_det_text(\n    matrix, determinant=None, background_rect=False, initial_scale_factor=2\n):\n    parens = TexMobject(\"(\", \")\")\n    parens.scale(initial_scale_factor)\n    parens.stretch_to_fit_height(matrix.get_height())\n    l_paren, r_paren = parens.split()\n    l_paren.next_to(matrix, LEFT, buff=0.1)\n    r_paren.next_to(matrix, RIGHT, buff=0.1)\n    det = TextMobject(\"det\")\n    det.scale(initial_scale_factor)\n    det.next_to(l_paren, LEFT, buff=0.1)\n    if background_rect:\n        det.add_background_rectangle()\n    det_text = VGroup(det, l_paren, r_paren)\n    if determinant is not None:\n        eq = TexMobject(\"=\")\n        eq.next_to(r_paren, RIGHT, buff=0.1)\n        result = TexMobject(str(determinant))\n        result.next_to(eq, RIGHT, buff=0.2)\n        det_text.add(eq, result)\n    return det_text",
  "def __init__(self, matrix, **kwargs):\n        \"\"\"\n        Matrix can either either include numbres, tex_strings,\n        or mobjects\n        \"\"\"\n        VMobject.__init__(self, **kwargs)\n        matrix = np.array(matrix, ndmin=1)\n        mob_matrix = self.matrix_to_mob_matrix(matrix)\n        self.organize_mob_matrix(mob_matrix)\n        self.elements = VGroup(*mob_matrix.flatten())\n        self.add(self.elements)\n        self.add_brackets(self.left_bracket, self.right_bracket)\n        self.center()\n        self.mob_matrix = mob_matrix\n        if self.add_background_rectangles_to_entries:\n            for mob in self.elements:\n                mob.add_background_rectangle()\n        if self.include_background_rectangle:\n            self.add_background_rectangle()",
  "def matrix_to_mob_matrix(self, matrix):\n        return np.vectorize(self.element_to_mobject)(\n            matrix, **self.element_to_mobject_config\n        )",
  "def organize_mob_matrix(self, matrix):\n        for i, row in enumerate(matrix):\n            for j, elem in enumerate(row):\n                mob = matrix[i][j]\n                mob.move_to(\n                    i * self.v_buff * DOWN + j * self.h_buff * RIGHT,\n                    self.element_alignment_corner,\n                )\n        return self",
  "def add_brackets(self, left=\"\\\\big[\", right=\"\\\\big]\"):\n        bracket_pair = TexMobject(left, right)\n        bracket_pair.scale(2)\n        bracket_pair.stretch_to_fit_height(self.get_height() + 2 * self.bracket_v_buff)\n        l_bracket, r_bracket = bracket_pair.split()\n        l_bracket.next_to(self, LEFT, self.bracket_h_buff)\n        r_bracket.next_to(self, RIGHT, self.bracket_h_buff)\n        self.add(l_bracket, r_bracket)\n        self.brackets = VGroup(l_bracket, r_bracket)\n        return self",
  "def get_columns(self):\n        return VGroup(\n            *[VGroup(*self.mob_matrix[:, i]) for i in range(self.mob_matrix.shape[1])]\n        )",
  "def set_column_colors(self, *colors):\n        columns = self.get_columns()\n        for color, column in zip(colors, columns):\n            column.set_color(color)\n        return self",
  "def get_rows(self):\n        \"\"\"Return rows of the matrix as VGroups\n        \n        Returns\n        --------\n        List[:class:`~.VGroup`]\n            Each VGroup contains a row of the matrix.\n        \"\"\"\n        return VGroup(\n            *[VGroup(*self.mob_matrix[i, :]) for i in range(self.mob_matrix.shape[1])]\n        )",
  "def set_row_colors(self, *colors):\n        \"\"\"Set individual colors for each row of the matrix\n        \n        Parameters\n        ----------\n        colors : :class:`str`\n            The list of colors; each color specified corresponds to a row.\n        \n        Returns\n        -------\n        :class:`Matrix`\n            The current matrix object (self).\n        \"\"\"\n        rows = self.get_rows()\n        for color, row in zip(colors, rows):\n            row.set_color(color)\n        return self",
  "def add_background_to_entries(self):\n        for mob in self.get_entries():\n            mob.add_background_rectangle()\n        return self",
  "def get_mob_matrix(self):\n        return self.mob_matrix",
  "def get_entries(self):\n        return VGroup(*self.get_mob_matrix().flatten())",
  "def get_brackets(self):\n        return self.brackets",
  "def get_3d_vmob_gradient_start_and_end_points(vmob):\n    return (\n        get_3d_vmob_start_corner(vmob),\n        get_3d_vmob_end_corner(vmob),\n    )",
  "def get_3d_vmob_start_corner_index(vmob):\n    return 0",
  "def get_3d_vmob_end_corner_index(vmob):\n    return ((len(vmob.points) - 1) // 6) * 3",
  "def get_3d_vmob_start_corner(vmob):\n    if vmob.get_num_points() == 0:\n        return np.array(ORIGIN)\n    return vmob.points[get_3d_vmob_start_corner_index(vmob)]",
  "def get_3d_vmob_end_corner(vmob):\n    if vmob.get_num_points() == 0:\n        return np.array(ORIGIN)\n    return vmob.points[get_3d_vmob_end_corner_index(vmob)]",
  "def get_3d_vmob_unit_normal(vmob, point_index):\n    n_points = vmob.get_num_points()\n    if len(vmob.get_anchors()) <= 2:\n        return np.array(UP)\n    i = point_index\n    im3 = i - 3 if i > 2 else (n_points - 4)\n    ip3 = i + 3 if i < (n_points - 3) else 3\n    unit_normal = get_unit_normal(\n        vmob.points[ip3] - vmob.points[i], vmob.points[im3] - vmob.points[i],\n    )\n    if get_norm(unit_normal) == 0:\n        return np.array(UP)\n    return unit_normal",
  "def get_3d_vmob_start_corner_unit_normal(vmob):\n    return get_3d_vmob_unit_normal(vmob, get_3d_vmob_start_corner_index(vmob))",
  "def get_3d_vmob_end_corner_unit_normal(vmob):\n    return get_3d_vmob_unit_normal(vmob, get_3d_vmob_end_corner_index(vmob))",
  "class TipableVMobject(VMobject):\n    \"\"\"\n    Meant for shared functionality between Arc and Line.\n    Functionality can be classified broadly into these groups:\n\n        * Adding, Creating, Modifying tips\n            - add_tip calls create_tip, before pushing the new tip\n                into the TipableVMobject's list of submobjects\n            - stylistic and positional configuration\n\n        * Checking for tips\n            - Boolean checks for whether the TipableVMobject has a tip\n                and a starting tip\n\n        * Getters\n            - Straightforward accessors, returning information pertaining\n                to the TipableVMobject instance's tip(s), its length etc\n\n    \"\"\"\n\n    CONFIG = {\n        \"tip_length\": DEFAULT_ARROW_TIP_LENGTH,\n        # TODO\n        \"normal_vector\": OUT,\n        \"tip_style\": {\"fill_opacity\": 1, \"stroke_width\": 0,},\n    }\n\n    # Adding, Creating, Modifying tips\n\n    def add_tip(self, tip_length=None, at_start=False):\n        \"\"\"\n        Adds a tip to the TipableVMobject instance, recognising\n        that the endpoints might need to be switched if it's\n        a 'starting tip' or not.\n        \"\"\"\n        tip = self.create_tip(tip_length, at_start)\n        self.reset_endpoints_based_on_tip(tip, at_start)\n        self.asign_tip_attr(tip, at_start)\n        self.add(tip)\n        return self\n\n    def create_tip(self, tip_length=None, at_start=False):\n        \"\"\"\n        Stylises the tip, positions it spacially, and returns\n        the newly instantiated tip to the caller.\n        \"\"\"\n        tip = self.get_unpositioned_tip(tip_length)\n        self.position_tip(tip, at_start)\n        return tip\n\n    def get_unpositioned_tip(self, tip_length=None):\n        \"\"\"\n        Returns a tip that has been stylistically configured,\n        but has not yet been given a position in space.\n        \"\"\"\n        if tip_length is None:\n            tip_length = self.get_default_tip_length()\n        color = self.get_color()\n        style = {\"fill_color\": color, \"stroke_color\": color}\n        style.update(self.tip_style)\n        tip = ArrowTip(length=tip_length, **style)\n        return tip\n\n    def position_tip(self, tip, at_start=False):\n        # Last two control points, defining both\n        # the end, and the tangency direction\n        if at_start:\n            anchor = self.get_start()\n            handle = self.get_first_handle()\n        else:\n            handle = self.get_last_handle()\n            anchor = self.get_end()\n        tip.rotate(angle_of_vector(handle - anchor) - PI - tip.get_angle())\n        tip.shift(anchor - tip.get_tip_point())\n        return tip\n\n    def reset_endpoints_based_on_tip(self, tip, at_start):\n        if self.get_length() == 0:\n            # Zero length, put_start_and_end_on wouldn't\n            # work\n            return self\n\n        if at_start:\n            self.put_start_and_end_on(tip.get_base(), self.get_end())\n        else:\n            self.put_start_and_end_on(\n                self.get_start(), tip.get_base(),\n            )\n        return self\n\n    def asign_tip_attr(self, tip, at_start):\n        if at_start:\n            self.start_tip = tip\n        else:\n            self.tip = tip\n        return self\n\n    # Checking for tips\n\n    def has_tip(self):\n        return hasattr(self, \"tip\") and self.tip in self\n\n    def has_start_tip(self):\n        return hasattr(self, \"start_tip\") and self.start_tip in self\n\n    # Getters\n\n    def pop_tips(self):\n        start, end = self.get_start_and_end()\n        result = VGroup()\n        if self.has_tip():\n            result.add(self.tip)\n            self.remove(self.tip)\n        if self.has_start_tip():\n            result.add(self.start_tip)\n            self.remove(self.start_tip)\n        self.put_start_and_end_on(start, end)\n        return result\n\n    def get_tips(self):\n        \"\"\"\n        Returns a VGroup (collection of VMobjects) containing\n        the TipableVMObject instance's tips.\n        \"\"\"\n        result = VGroup()\n        if hasattr(self, \"tip\"):\n            result.add(self.tip)\n        if hasattr(self, \"start_tip\"):\n            result.add(self.start_tip)\n        return result\n\n    def get_tip(self):\n        \"\"\"Returns the TipableVMobject instance's (first) tip,\n        otherwise throws an exception.\"\"\"\n        tips = self.get_tips()\n        if len(tips) == 0:\n            raise Exception(\"tip not found\")\n        else:\n            return tips[0]\n\n    def get_default_tip_length(self):\n        return self.tip_length\n\n    def get_first_handle(self):\n        return self.points[1]\n\n    def get_last_handle(self):\n        return self.points[-2]\n\n    def get_end(self):\n        if self.has_tip():\n            return self.tip.get_start()\n        else:\n            return VMobject.get_end(self)\n\n    def get_start(self):\n        if self.has_start_tip():\n            return self.start_tip.get_start()\n        else:\n            return VMobject.get_start(self)\n\n    def get_length(self):\n        start, end = self.get_start_and_end()\n        return get_norm(start - end)",
  "class Arc(TipableVMobject):\n    CONFIG = {\n        \"radius\": 1.0,\n        \"num_components\": 9,\n        \"anchors_span_full_range\": True,\n        \"arc_center\": ORIGIN,\n    }\n\n    def __init__(self, start_angle=0, angle=TAU / 4, **kwargs):\n        self.start_angle = start_angle\n        self.angle = angle\n        self._failed_to_get_center = False\n        VMobject.__init__(self, **kwargs)\n\n    def generate_points(self):\n        self.set_pre_positioned_points()\n        self.scale(self.radius, about_point=ORIGIN)\n        self.shift(self.arc_center)\n\n    def set_pre_positioned_points(self):\n        anchors = np.array(\n            [\n                np.cos(a) * RIGHT + np.sin(a) * UP\n                for a in np.linspace(\n                    self.start_angle,\n                    self.start_angle + self.angle,\n                    self.num_components,\n                )\n            ]\n        )\n        # Figure out which control points will give the\n        # Appropriate tangent lines to the circle\n        d_theta = self.angle / (self.num_components - 1.0)\n        tangent_vectors = np.zeros(anchors.shape)\n        # Rotate all 90 degress, via (x, y) -> (-y, x)\n        tangent_vectors[:, 1] = anchors[:, 0]\n        tangent_vectors[:, 0] = -anchors[:, 1]\n        # Use tangent vectors to deduce anchors\n        handles1 = anchors[:-1] + (d_theta / 3) * tangent_vectors[:-1]\n        handles2 = anchors[1:] - (d_theta / 3) * tangent_vectors[1:]\n        self.set_anchors_and_handles(\n            anchors[:-1], handles1, handles2, anchors[1:],\n        )\n\n    def get_arc_center(self, warning=True):\n        \"\"\"\n        Looks at the normals to the first two\n        anchors, and finds their intersection points\n        \"\"\"\n        # First two anchors and handles\n        a1, h1, h2, a2 = self.points[:4]\n        # Tangent vectors\n        t1 = h1 - a1\n        t2 = h2 - a2\n        # Normals\n        n1 = rotate_vector(t1, TAU / 4)\n        n2 = rotate_vector(t2, TAU / 4)\n        try:\n            return line_intersection(line1=(a1, a1 + n1), line2=(a2, a2 + n2),)\n        except Exception:\n            if warning:\n                warnings.warn(\"Can't find Arc center, using ORIGIN instead\")\n            self._failed_to_get_center = True\n            return np.array(ORIGIN)\n\n    def move_arc_center_to(self, point):\n        self.shift(point - self.get_arc_center())\n        return self\n\n    def stop_angle(self):\n        return angle_of_vector(self.points[-1] - self.get_arc_center()) % TAU",
  "class ArcBetweenPoints(Arc):\n    \"\"\"\n    Inherits from Arc and additionally takes 2 points between which the arc is spanned.\n    \"\"\"\n\n    def __init__(self, start, end, angle=TAU / 4, radius=None, **kwargs):\n        if radius is not None:\n            self.radius = radius\n            if radius < 0:\n                sign = -2\n                radius *= -1\n            else:\n                sign = 2\n            halfdist = np.linalg.norm(np.array(start) - np.array(end)) / 2\n            if radius < halfdist:\n                raise ValueError(\n                    \"\"\"ArcBetweenPoints called with a radius that is\n                            smaller than half the distance between the points.\"\"\"\n                )\n            arc_height = radius - math.sqrt(radius ** 2 - halfdist ** 2)\n            angle = math.acos((radius - arc_height) / radius) * sign\n\n        Arc.__init__(\n            self, angle=angle, **kwargs,\n        )\n        if angle == 0:\n            self.set_points_as_corners([LEFT, RIGHT])\n        self.put_start_and_end_on(start, end)\n\n        if radius is None:\n            center = self.get_arc_center(warning=False)\n            if not self._failed_to_get_center:\n                self.radius = np.linalg.norm(np.array(start) - np.array(center))\n            else:\n                self.radius = math.inf",
  "class CurvedArrow(ArcBetweenPoints):\n    def __init__(self, start_point, end_point, **kwargs):\n        ArcBetweenPoints.__init__(self, start_point, end_point, **kwargs)\n        self.add_tip()",
  "class CurvedDoubleArrow(CurvedArrow):\n    def __init__(self, start_point, end_point, **kwargs):\n        CurvedArrow.__init__(self, start_point, end_point, **kwargs)\n        self.add_tip(at_start=True)",
  "class Circle(Arc):\n    CONFIG = {\"color\": RED, \"close_new_points\": True, \"anchors_span_full_range\": False}\n\n    def __init__(self, **kwargs):\n        Arc.__init__(self, 0, TAU, **kwargs)\n\n    def surround(self, mobject, dim_to_match=0, stretch=False, buffer_factor=1.2):\n        # Ignores dim_to_match and stretch; result will always be a circle\n        # TODO: Perhaps create an ellipse class to handle singele-dimension stretching\n\n        # Something goes wrong here when surrounding lines?\n        # TODO: Figure out and fix\n        self.replace(mobject, dim_to_match, stretch)\n\n        self.set_width(np.sqrt(mobject.get_width() ** 2 + mobject.get_height() ** 2))\n        self.scale(buffer_factor)\n\n    def point_at_angle(self, angle):\n        start_angle = angle_of_vector(self.points[0] - self.get_center())\n        return self.point_from_proportion((angle - start_angle) / TAU)",
  "class Dot(Circle):\n    CONFIG = {\n        \"radius\": DEFAULT_DOT_RADIUS,\n        \"stroke_width\": 0,\n        \"fill_opacity\": 1.0,\n        \"color\": WHITE,\n    }\n\n    def __init__(self, point=ORIGIN, **kwargs):\n        Circle.__init__(self, arc_center=point, **kwargs)",
  "class SmallDot(Dot):\n    CONFIG = {\n        \"radius\": DEFAULT_SMALL_DOT_RADIUS,\n    }",
  "class Ellipse(Circle):\n    CONFIG = {\"width\": 2, \"height\": 1}\n\n    def __init__(self, **kwargs):\n        Circle.__init__(self, **kwargs)\n        self.set_width(self.width, stretch=True)\n        self.set_height(self.height, stretch=True)",
  "class AnnularSector(Arc):\n    CONFIG = {\n        \"inner_radius\": 1,\n        \"outer_radius\": 2,\n        \"angle\": TAU / 4,\n        \"start_angle\": 0,\n        \"fill_opacity\": 1,\n        \"stroke_width\": 0,\n        \"color\": WHITE,\n    }\n\n    def generate_points(self):\n        inner_arc, outer_arc = [\n            Arc(\n                start_angle=self.start_angle,\n                angle=self.angle,\n                radius=radius,\n                arc_center=self.arc_center,\n            )\n            for radius in (self.inner_radius, self.outer_radius)\n        ]\n        outer_arc.reverse_points()\n        self.append_points(inner_arc.points)\n        self.add_line_to(outer_arc.points[0])\n        self.append_points(outer_arc.points)\n        self.add_line_to(inner_arc.points[0])",
  "class Sector(AnnularSector):\n    CONFIG = {\"outer_radius\": 1, \"inner_radius\": 0}",
  "class Annulus(Circle):\n    CONFIG = {\n        \"inner_radius\": 1,\n        \"outer_radius\": 2,\n        \"fill_opacity\": 1,\n        \"stroke_width\": 0,\n        \"color\": WHITE,\n        \"mark_paths_closed\": False,\n    }\n\n    def generate_points(self):\n        self.radius = self.outer_radius\n        outer_circle = Circle(radius=self.outer_radius)\n        inner_circle = Circle(radius=self.inner_radius)\n        inner_circle.reverse_points()\n        self.append_points(outer_circle.points)\n        self.append_points(inner_circle.points)\n        self.shift(self.arc_center)",
  "class Line(TipableVMobject):\n    CONFIG = {\n        \"buff\": 0,\n        \"path_arc\": None,  # angle of arc specified here\n    }\n\n    def __init__(self, start=LEFT, end=RIGHT, **kwargs):\n        digest_config(self, kwargs)\n        self.set_start_and_end_attrs(start, end)\n        VMobject.__init__(self, **kwargs)\n\n    def generate_points(self):\n        if self.path_arc:\n            arc = ArcBetweenPoints(self.start, self.end, angle=self.path_arc)\n            self.set_points(arc.points)\n        else:\n            self.set_points_as_corners([self.start, self.end])\n        self.account_for_buff()\n\n    def set_path_arc(self, new_value):\n        self.path_arc = new_value\n        self.generate_points()\n\n    def account_for_buff(self):\n        if self.buff == 0:\n            return\n        #\n        if self.path_arc == 0:\n            length = self.get_length()\n        else:\n            length = self.get_arc_length()\n        #\n        if length < 2 * self.buff:\n            return\n        buff_proportion = self.buff / length\n        self.pointwise_become_partial(self, buff_proportion, 1 - buff_proportion)\n        return self\n\n    def set_start_and_end_attrs(self, start, end):\n        # If either start or end are Mobjects, this\n        # gives their centers\n        rough_start = self.pointify(start)\n        rough_end = self.pointify(end)\n        vect = normalize(rough_end - rough_start)\n        # Now that we know the direction between them,\n        # we can the appropriate boundary point from\n        # start and end, if they're mobjects\n        self.start = self.pointify(start, vect)\n        self.end = self.pointify(end, -vect)\n\n    def pointify(self, mob_or_point, direction=None):\n        if isinstance(mob_or_point, Mobject):\n            mob = mob_or_point\n            if direction is None:\n                return mob.get_center()\n            else:\n                return mob.get_boundary_point(direction)\n        return np.array(mob_or_point)\n\n    def put_start_and_end_on(self, start, end):\n        curr_start, curr_end = self.get_start_and_end()\n        if np.all(curr_start == curr_end):\n            # TODO, any problems with resetting\n            # these attrs?\n            self.start = start\n            self.end = end\n            self.generate_points()\n        return super().put_start_and_end_on(start, end)\n\n    def get_vector(self):\n        return self.get_end() - self.get_start()\n\n    def get_unit_vector(self):\n        return normalize(self.get_vector())\n\n    def get_angle(self):\n        return angle_of_vector(self.get_vector())\n\n    def get_slope(self):\n        return np.tan(self.get_angle())\n\n    def set_angle(self, angle):\n        self.rotate(\n            angle - self.get_angle(), about_point=self.get_start(),\n        )\n\n    def set_length(self, length):\n        self.scale(length / self.get_length())\n\n    def set_opacity(self, opacity, family=True):\n        # Overwrite default, which would set\n        # the fill opacity\n        self.set_stroke(opacity=opacity)\n        if family:\n            for sm in self.submobjects:\n                sm.set_opacity(opacity, family)\n        return self",
  "class DashedLine(Line):\n    CONFIG = {\n        \"dash_length\": DEFAULT_DASH_LENGTH,\n        \"dash_spacing\": None,\n        \"positive_space_ratio\": 0.5,\n    }\n\n    def __init__(self, *args, **kwargs):\n        Line.__init__(self, *args, **kwargs)\n        ps_ratio = self.positive_space_ratio\n        num_dashes = self.calculate_num_dashes(ps_ratio)\n        dashes = DashedVMobject(\n            self, num_dashes=num_dashes, positive_space_ratio=ps_ratio\n        )\n        self.clear_points()\n        self.add(*dashes)\n\n    def calculate_num_dashes(self, positive_space_ratio):\n        try:\n            full_length = self.dash_length / positive_space_ratio\n            return int(np.ceil(self.get_length() / full_length))\n        except ZeroDivisionError:\n            return 1\n\n    def calculate_positive_space_ratio(self):\n        return fdiv(self.dash_length, self.dash_length + self.dash_spacing,)\n\n    def get_start(self):\n        if len(self.submobjects) > 0:\n            return self.submobjects[0].get_start()\n        else:\n            return Line.get_start(self)\n\n    def get_end(self):\n        if len(self.submobjects) > 0:\n            return self.submobjects[-1].get_end()\n        else:\n            return Line.get_end(self)\n\n    def get_first_handle(self):\n        return self.submobjects[0].points[1]\n\n    def get_last_handle(self):\n        return self.submobjects[-1].points[-2]",
  "class TangentLine(Line):\n    CONFIG = {\"length\": 1, \"d_alpha\": 1e-6}\n\n    def __init__(self, vmob, alpha, **kwargs):\n        digest_config(self, kwargs)\n        da = self.d_alpha\n        a1 = np.clip(alpha - da, 0, 1)\n        a2 = np.clip(alpha + da, 0, 1)\n        super().__init__(\n            vmob.point_from_proportion(a1), vmob.point_from_proportion(a2), **kwargs\n        )\n        self.scale(self.length / self.get_length())",
  "class Elbow(VMobject):\n    CONFIG = {\n        \"width\": 0.2,\n        \"angle\": 0,\n    }\n\n    def __init__(self, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.set_points_as_corners([UP, UP + RIGHT, RIGHT])\n        self.set_width(self.width, about_point=ORIGIN)\n        self.rotate(self.angle, about_point=ORIGIN)",
  "class Arrow(Line):\n    CONFIG = {\n        \"stroke_width\": 6,\n        \"buff\": MED_SMALL_BUFF,\n        \"max_tip_length_to_length_ratio\": 0.25,\n        \"max_stroke_width_to_length_ratio\": 5,\n        \"preserve_tip_size_when_scaling\": True,\n    }\n\n    def __init__(self, *args, **kwargs):\n        Line.__init__(self, *args, **kwargs)\n        # TODO, should this be affected when\n        # Arrow.set_stroke is called?\n        self.initial_stroke_width = self.stroke_width\n        self.add_tip()\n        self.set_stroke_width_from_length()\n\n    def scale(self, factor, **kwargs):\n        if self.get_length() == 0:\n            return self\n\n        has_tip = self.has_tip()\n        has_start_tip = self.has_start_tip()\n        if has_tip or has_start_tip:\n            old_tips = self.pop_tips()\n\n        VMobject.scale(self, factor, **kwargs)\n        self.set_stroke_width_from_length()\n\n        # So horribly confusing, must redo\n        if has_tip:\n            self.add_tip()\n            old_tips[0].points[:, :] = self.tip.points\n            self.remove(self.tip)\n            self.tip = old_tips[0]\n            self.add(self.tip)\n        if has_start_tip:\n            self.add_tip(at_start=True)\n            old_tips[1].points[:, :] = self.start_tip.points\n            self.remove(self.start_tip)\n            self.start_tip = old_tips[1]\n            self.add(self.start_tip)\n        return self\n\n    def get_normal_vector(self):\n        p0, p1, p2 = self.tip.get_start_anchors()[:3]\n        return normalize(np.cross(p2 - p1, p1 - p0))\n\n    def reset_normal_vector(self):\n        self.normal_vector = self.get_normal_vector()\n        return self\n\n    def get_default_tip_length(self):\n        max_ratio = self.max_tip_length_to_length_ratio\n        return min(self.tip_length, max_ratio * self.get_length(),)\n\n    def set_stroke_width_from_length(self):\n        max_ratio = self.max_stroke_width_to_length_ratio\n        self.set_stroke(\n            width=min(self.initial_stroke_width, max_ratio * self.get_length(),),\n            family=False,\n        )\n        return self\n\n    # TODO, should this be the default for everything?\n    def copy(self):\n        return self.deepcopy()",
  "class Vector(Arrow):\n    CONFIG = {\n        \"buff\": 0,\n    }\n\n    def __init__(self, direction=RIGHT, **kwargs):\n        if len(direction) == 2:\n            direction = np.append(np.array(direction), 0)\n        Arrow.__init__(self, ORIGIN, direction, **kwargs)",
  "class DoubleArrow(Arrow):\n    def __init__(self, *args, **kwargs):\n        Arrow.__init__(self, *args, **kwargs)\n        self.add_tip(at_start=True)",
  "class CubicBezier(VMobject):\n    def __init__(self, points, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.set_points(points)",
  "class Polygon(VMobject):\n    CONFIG = {\n        \"color\": BLUE,\n    }\n\n    def __init__(self, *vertices, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.set_points_as_corners([*vertices, vertices[0]])\n\n    def get_vertices(self):\n        return self.get_start_anchors()\n\n    def round_corners(self, radius=0.5):\n        vertices = self.get_vertices()\n        arcs = []\n        for v1, v2, v3 in adjacent_n_tuples(vertices, 3):\n            vect1 = v2 - v1\n            vect2 = v3 - v2\n            unit_vect1 = normalize(vect1)\n            unit_vect2 = normalize(vect2)\n            angle = angle_between_vectors(vect1, vect2)\n            # Negative radius gives concave curves\n            angle *= np.sign(radius)\n            # Distance between vertex and start of the arc\n            cut_off_length = radius * np.tan(angle / 2)\n            # Determines counterclockwise vs. clockwise\n            sign = np.sign(np.cross(vect1, vect2)[2])\n            arc = ArcBetweenPoints(\n                v2 - unit_vect1 * cut_off_length,\n                v2 + unit_vect2 * cut_off_length,\n                angle=sign * angle,\n            )\n            arcs.append(arc)\n\n        self.clear_points()\n        # To ensure that we loop through starting with last\n        arcs = [arcs[-1], *arcs[:-1]]\n        for arc1, arc2 in adjacent_pairs(arcs):\n            self.append_points(arc1.points)\n            line = Line(arc1.get_end(), arc2.get_start())\n            # Make sure anchors are evenly distributed\n            len_ratio = line.get_length() / arc1.get_arc_length()\n            line.insert_n_curves(int(arc1.get_num_curves() * len_ratio))\n            self.append_points(line.get_points())\n        return self",
  "class RegularPolygon(Polygon):\n    CONFIG = {\n        \"start_angle\": None,\n    }\n\n    def __init__(self, n=6, **kwargs):\n        digest_config(self, kwargs, locals())\n        if self.start_angle is None:\n            if n % 2 == 0:\n                self.start_angle = 0\n            else:\n                self.start_angle = 90 * DEGREES\n        start_vect = rotate_vector(RIGHT, self.start_angle)\n        vertices = compass_directions(n, start_vect)\n        Polygon.__init__(self, *vertices, **kwargs)",
  "class Triangle(RegularPolygon):\n    def __init__(self, **kwargs):\n        RegularPolygon.__init__(self, n=3, **kwargs)",
  "class ArrowTip(Triangle):\n    CONFIG = {\n        \"fill_opacity\": 1,\n        \"stroke_width\": 0,\n        \"length\": DEFAULT_ARROW_TIP_LENGTH,\n        \"start_angle\": PI,\n    }\n\n    def __init__(self, **kwargs):\n        Triangle.__init__(self, **kwargs)\n        self.set_width(self.length)\n        self.set_height(self.length, stretch=True)\n\n    def get_base(self):\n        return self.point_from_proportion(0.5)\n\n    def get_tip_point(self):\n        return self.points[0]\n\n    def get_vector(self):\n        return self.get_tip_point() - self.get_base()\n\n    def get_angle(self):\n        return angle_of_vector(self.get_vector())\n\n    def get_length(self):\n        return get_norm(self.get_vector())",
  "class Rectangle(Polygon):\n    CONFIG = {\n        \"color\": WHITE,\n        \"height\": 2.0,\n        \"width\": 4.0,\n        \"mark_paths_closed\": True,\n        \"close_new_points\": True,\n    }\n\n    def __init__(self, **kwargs):\n        Polygon.__init__(self, UL, UR, DR, DL, **kwargs)\n        self.set_width(self.width, stretch=True)\n        self.set_height(self.height, stretch=True)",
  "class Square(Rectangle):\n    CONFIG = {\n        \"side_length\": 2.0,\n    }\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        Rectangle.__init__(\n            self, height=self.side_length, width=self.side_length, **kwargs\n        )",
  "class RoundedRectangle(Rectangle):\n    CONFIG = {\n        \"corner_radius\": 0.5,\n    }\n\n    def __init__(self, **kwargs):\n        Rectangle.__init__(self, **kwargs)\n        self.round_corners(self.corner_radius)",
  "def add_tip(self, tip_length=None, at_start=False):\n        \"\"\"\n        Adds a tip to the TipableVMobject instance, recognising\n        that the endpoints might need to be switched if it's\n        a 'starting tip' or not.\n        \"\"\"\n        tip = self.create_tip(tip_length, at_start)\n        self.reset_endpoints_based_on_tip(tip, at_start)\n        self.asign_tip_attr(tip, at_start)\n        self.add(tip)\n        return self",
  "def create_tip(self, tip_length=None, at_start=False):\n        \"\"\"\n        Stylises the tip, positions it spacially, and returns\n        the newly instantiated tip to the caller.\n        \"\"\"\n        tip = self.get_unpositioned_tip(tip_length)\n        self.position_tip(tip, at_start)\n        return tip",
  "def get_unpositioned_tip(self, tip_length=None):\n        \"\"\"\n        Returns a tip that has been stylistically configured,\n        but has not yet been given a position in space.\n        \"\"\"\n        if tip_length is None:\n            tip_length = self.get_default_tip_length()\n        color = self.get_color()\n        style = {\"fill_color\": color, \"stroke_color\": color}\n        style.update(self.tip_style)\n        tip = ArrowTip(length=tip_length, **style)\n        return tip",
  "def position_tip(self, tip, at_start=False):\n        # Last two control points, defining both\n        # the end, and the tangency direction\n        if at_start:\n            anchor = self.get_start()\n            handle = self.get_first_handle()\n        else:\n            handle = self.get_last_handle()\n            anchor = self.get_end()\n        tip.rotate(angle_of_vector(handle - anchor) - PI - tip.get_angle())\n        tip.shift(anchor - tip.get_tip_point())\n        return tip",
  "def reset_endpoints_based_on_tip(self, tip, at_start):\n        if self.get_length() == 0:\n            # Zero length, put_start_and_end_on wouldn't\n            # work\n            return self\n\n        if at_start:\n            self.put_start_and_end_on(tip.get_base(), self.get_end())\n        else:\n            self.put_start_and_end_on(\n                self.get_start(), tip.get_base(),\n            )\n        return self",
  "def asign_tip_attr(self, tip, at_start):\n        if at_start:\n            self.start_tip = tip\n        else:\n            self.tip = tip\n        return self",
  "def has_tip(self):\n        return hasattr(self, \"tip\") and self.tip in self",
  "def has_start_tip(self):\n        return hasattr(self, \"start_tip\") and self.start_tip in self",
  "def pop_tips(self):\n        start, end = self.get_start_and_end()\n        result = VGroup()\n        if self.has_tip():\n            result.add(self.tip)\n            self.remove(self.tip)\n        if self.has_start_tip():\n            result.add(self.start_tip)\n            self.remove(self.start_tip)\n        self.put_start_and_end_on(start, end)\n        return result",
  "def get_tips(self):\n        \"\"\"\n        Returns a VGroup (collection of VMobjects) containing\n        the TipableVMObject instance's tips.\n        \"\"\"\n        result = VGroup()\n        if hasattr(self, \"tip\"):\n            result.add(self.tip)\n        if hasattr(self, \"start_tip\"):\n            result.add(self.start_tip)\n        return result",
  "def get_tip(self):\n        \"\"\"Returns the TipableVMobject instance's (first) tip,\n        otherwise throws an exception.\"\"\"\n        tips = self.get_tips()\n        if len(tips) == 0:\n            raise Exception(\"tip not found\")\n        else:\n            return tips[0]",
  "def get_default_tip_length(self):\n        return self.tip_length",
  "def get_first_handle(self):\n        return self.points[1]",
  "def get_last_handle(self):\n        return self.points[-2]",
  "def get_end(self):\n        if self.has_tip():\n            return self.tip.get_start()\n        else:\n            return VMobject.get_end(self)",
  "def get_start(self):\n        if self.has_start_tip():\n            return self.start_tip.get_start()\n        else:\n            return VMobject.get_start(self)",
  "def get_length(self):\n        start, end = self.get_start_and_end()\n        return get_norm(start - end)",
  "def __init__(self, start_angle=0, angle=TAU / 4, **kwargs):\n        self.start_angle = start_angle\n        self.angle = angle\n        self._failed_to_get_center = False\n        VMobject.__init__(self, **kwargs)",
  "def generate_points(self):\n        self.set_pre_positioned_points()\n        self.scale(self.radius, about_point=ORIGIN)\n        self.shift(self.arc_center)",
  "def set_pre_positioned_points(self):\n        anchors = np.array(\n            [\n                np.cos(a) * RIGHT + np.sin(a) * UP\n                for a in np.linspace(\n                    self.start_angle,\n                    self.start_angle + self.angle,\n                    self.num_components,\n                )\n            ]\n        )\n        # Figure out which control points will give the\n        # Appropriate tangent lines to the circle\n        d_theta = self.angle / (self.num_components - 1.0)\n        tangent_vectors = np.zeros(anchors.shape)\n        # Rotate all 90 degress, via (x, y) -> (-y, x)\n        tangent_vectors[:, 1] = anchors[:, 0]\n        tangent_vectors[:, 0] = -anchors[:, 1]\n        # Use tangent vectors to deduce anchors\n        handles1 = anchors[:-1] + (d_theta / 3) * tangent_vectors[:-1]\n        handles2 = anchors[1:] - (d_theta / 3) * tangent_vectors[1:]\n        self.set_anchors_and_handles(\n            anchors[:-1], handles1, handles2, anchors[1:],\n        )",
  "def get_arc_center(self, warning=True):\n        \"\"\"\n        Looks at the normals to the first two\n        anchors, and finds their intersection points\n        \"\"\"\n        # First two anchors and handles\n        a1, h1, h2, a2 = self.points[:4]\n        # Tangent vectors\n        t1 = h1 - a1\n        t2 = h2 - a2\n        # Normals\n        n1 = rotate_vector(t1, TAU / 4)\n        n2 = rotate_vector(t2, TAU / 4)\n        try:\n            return line_intersection(line1=(a1, a1 + n1), line2=(a2, a2 + n2),)\n        except Exception:\n            if warning:\n                warnings.warn(\"Can't find Arc center, using ORIGIN instead\")\n            self._failed_to_get_center = True\n            return np.array(ORIGIN)",
  "def move_arc_center_to(self, point):\n        self.shift(point - self.get_arc_center())\n        return self",
  "def stop_angle(self):\n        return angle_of_vector(self.points[-1] - self.get_arc_center()) % TAU",
  "def __init__(self, start, end, angle=TAU / 4, radius=None, **kwargs):\n        if radius is not None:\n            self.radius = radius\n            if radius < 0:\n                sign = -2\n                radius *= -1\n            else:\n                sign = 2\n            halfdist = np.linalg.norm(np.array(start) - np.array(end)) / 2\n            if radius < halfdist:\n                raise ValueError(\n                    \"\"\"ArcBetweenPoints called with a radius that is\n                            smaller than half the distance between the points.\"\"\"\n                )\n            arc_height = radius - math.sqrt(radius ** 2 - halfdist ** 2)\n            angle = math.acos((radius - arc_height) / radius) * sign\n\n        Arc.__init__(\n            self, angle=angle, **kwargs,\n        )\n        if angle == 0:\n            self.set_points_as_corners([LEFT, RIGHT])\n        self.put_start_and_end_on(start, end)\n\n        if radius is None:\n            center = self.get_arc_center(warning=False)\n            if not self._failed_to_get_center:\n                self.radius = np.linalg.norm(np.array(start) - np.array(center))\n            else:\n                self.radius = math.inf",
  "def __init__(self, start_point, end_point, **kwargs):\n        ArcBetweenPoints.__init__(self, start_point, end_point, **kwargs)\n        self.add_tip()",
  "def __init__(self, start_point, end_point, **kwargs):\n        CurvedArrow.__init__(self, start_point, end_point, **kwargs)\n        self.add_tip(at_start=True)",
  "def __init__(self, **kwargs):\n        Arc.__init__(self, 0, TAU, **kwargs)",
  "def surround(self, mobject, dim_to_match=0, stretch=False, buffer_factor=1.2):\n        # Ignores dim_to_match and stretch; result will always be a circle\n        # TODO: Perhaps create an ellipse class to handle singele-dimension stretching\n\n        # Something goes wrong here when surrounding lines?\n        # TODO: Figure out and fix\n        self.replace(mobject, dim_to_match, stretch)\n\n        self.set_width(np.sqrt(mobject.get_width() ** 2 + mobject.get_height() ** 2))\n        self.scale(buffer_factor)",
  "def point_at_angle(self, angle):\n        start_angle = angle_of_vector(self.points[0] - self.get_center())\n        return self.point_from_proportion((angle - start_angle) / TAU)",
  "def __init__(self, point=ORIGIN, **kwargs):\n        Circle.__init__(self, arc_center=point, **kwargs)",
  "def __init__(self, **kwargs):\n        Circle.__init__(self, **kwargs)\n        self.set_width(self.width, stretch=True)\n        self.set_height(self.height, stretch=True)",
  "def generate_points(self):\n        inner_arc, outer_arc = [\n            Arc(\n                start_angle=self.start_angle,\n                angle=self.angle,\n                radius=radius,\n                arc_center=self.arc_center,\n            )\n            for radius in (self.inner_radius, self.outer_radius)\n        ]\n        outer_arc.reverse_points()\n        self.append_points(inner_arc.points)\n        self.add_line_to(outer_arc.points[0])\n        self.append_points(outer_arc.points)\n        self.add_line_to(inner_arc.points[0])",
  "def generate_points(self):\n        self.radius = self.outer_radius\n        outer_circle = Circle(radius=self.outer_radius)\n        inner_circle = Circle(radius=self.inner_radius)\n        inner_circle.reverse_points()\n        self.append_points(outer_circle.points)\n        self.append_points(inner_circle.points)\n        self.shift(self.arc_center)",
  "def __init__(self, start=LEFT, end=RIGHT, **kwargs):\n        digest_config(self, kwargs)\n        self.set_start_and_end_attrs(start, end)\n        VMobject.__init__(self, **kwargs)",
  "def generate_points(self):\n        if self.path_arc:\n            arc = ArcBetweenPoints(self.start, self.end, angle=self.path_arc)\n            self.set_points(arc.points)\n        else:\n            self.set_points_as_corners([self.start, self.end])\n        self.account_for_buff()",
  "def set_path_arc(self, new_value):\n        self.path_arc = new_value\n        self.generate_points()",
  "def account_for_buff(self):\n        if self.buff == 0:\n            return\n        #\n        if self.path_arc == 0:\n            length = self.get_length()\n        else:\n            length = self.get_arc_length()\n        #\n        if length < 2 * self.buff:\n            return\n        buff_proportion = self.buff / length\n        self.pointwise_become_partial(self, buff_proportion, 1 - buff_proportion)\n        return self",
  "def set_start_and_end_attrs(self, start, end):\n        # If either start or end are Mobjects, this\n        # gives their centers\n        rough_start = self.pointify(start)\n        rough_end = self.pointify(end)\n        vect = normalize(rough_end - rough_start)\n        # Now that we know the direction between them,\n        # we can the appropriate boundary point from\n        # start and end, if they're mobjects\n        self.start = self.pointify(start, vect)\n        self.end = self.pointify(end, -vect)",
  "def pointify(self, mob_or_point, direction=None):\n        if isinstance(mob_or_point, Mobject):\n            mob = mob_or_point\n            if direction is None:\n                return mob.get_center()\n            else:\n                return mob.get_boundary_point(direction)\n        return np.array(mob_or_point)",
  "def put_start_and_end_on(self, start, end):\n        curr_start, curr_end = self.get_start_and_end()\n        if np.all(curr_start == curr_end):\n            # TODO, any problems with resetting\n            # these attrs?\n            self.start = start\n            self.end = end\n            self.generate_points()\n        return super().put_start_and_end_on(start, end)",
  "def get_vector(self):\n        return self.get_end() - self.get_start()",
  "def get_unit_vector(self):\n        return normalize(self.get_vector())",
  "def get_angle(self):\n        return angle_of_vector(self.get_vector())",
  "def get_slope(self):\n        return np.tan(self.get_angle())",
  "def set_angle(self, angle):\n        self.rotate(\n            angle - self.get_angle(), about_point=self.get_start(),\n        )",
  "def set_length(self, length):\n        self.scale(length / self.get_length())",
  "def set_opacity(self, opacity, family=True):\n        # Overwrite default, which would set\n        # the fill opacity\n        self.set_stroke(opacity=opacity)\n        if family:\n            for sm in self.submobjects:\n                sm.set_opacity(opacity, family)\n        return self",
  "def __init__(self, *args, **kwargs):\n        Line.__init__(self, *args, **kwargs)\n        ps_ratio = self.positive_space_ratio\n        num_dashes = self.calculate_num_dashes(ps_ratio)\n        dashes = DashedVMobject(\n            self, num_dashes=num_dashes, positive_space_ratio=ps_ratio\n        )\n        self.clear_points()\n        self.add(*dashes)",
  "def calculate_num_dashes(self, positive_space_ratio):\n        try:\n            full_length = self.dash_length / positive_space_ratio\n            return int(np.ceil(self.get_length() / full_length))\n        except ZeroDivisionError:\n            return 1",
  "def calculate_positive_space_ratio(self):\n        return fdiv(self.dash_length, self.dash_length + self.dash_spacing,)",
  "def get_start(self):\n        if len(self.submobjects) > 0:\n            return self.submobjects[0].get_start()\n        else:\n            return Line.get_start(self)",
  "def get_end(self):\n        if len(self.submobjects) > 0:\n            return self.submobjects[-1].get_end()\n        else:\n            return Line.get_end(self)",
  "def get_first_handle(self):\n        return self.submobjects[0].points[1]",
  "def get_last_handle(self):\n        return self.submobjects[-1].points[-2]",
  "def __init__(self, vmob, alpha, **kwargs):\n        digest_config(self, kwargs)\n        da = self.d_alpha\n        a1 = np.clip(alpha - da, 0, 1)\n        a2 = np.clip(alpha + da, 0, 1)\n        super().__init__(\n            vmob.point_from_proportion(a1), vmob.point_from_proportion(a2), **kwargs\n        )\n        self.scale(self.length / self.get_length())",
  "def __init__(self, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.set_points_as_corners([UP, UP + RIGHT, RIGHT])\n        self.set_width(self.width, about_point=ORIGIN)\n        self.rotate(self.angle, about_point=ORIGIN)",
  "def __init__(self, *args, **kwargs):\n        Line.__init__(self, *args, **kwargs)\n        # TODO, should this be affected when\n        # Arrow.set_stroke is called?\n        self.initial_stroke_width = self.stroke_width\n        self.add_tip()\n        self.set_stroke_width_from_length()",
  "def scale(self, factor, **kwargs):\n        if self.get_length() == 0:\n            return self\n\n        has_tip = self.has_tip()\n        has_start_tip = self.has_start_tip()\n        if has_tip or has_start_tip:\n            old_tips = self.pop_tips()\n\n        VMobject.scale(self, factor, **kwargs)\n        self.set_stroke_width_from_length()\n\n        # So horribly confusing, must redo\n        if has_tip:\n            self.add_tip()\n            old_tips[0].points[:, :] = self.tip.points\n            self.remove(self.tip)\n            self.tip = old_tips[0]\n            self.add(self.tip)\n        if has_start_tip:\n            self.add_tip(at_start=True)\n            old_tips[1].points[:, :] = self.start_tip.points\n            self.remove(self.start_tip)\n            self.start_tip = old_tips[1]\n            self.add(self.start_tip)\n        return self",
  "def get_normal_vector(self):\n        p0, p1, p2 = self.tip.get_start_anchors()[:3]\n        return normalize(np.cross(p2 - p1, p1 - p0))",
  "def reset_normal_vector(self):\n        self.normal_vector = self.get_normal_vector()\n        return self",
  "def get_default_tip_length(self):\n        max_ratio = self.max_tip_length_to_length_ratio\n        return min(self.tip_length, max_ratio * self.get_length(),)",
  "def set_stroke_width_from_length(self):\n        max_ratio = self.max_stroke_width_to_length_ratio\n        self.set_stroke(\n            width=min(self.initial_stroke_width, max_ratio * self.get_length(),),\n            family=False,\n        )\n        return self",
  "def copy(self):\n        return self.deepcopy()",
  "def __init__(self, direction=RIGHT, **kwargs):\n        if len(direction) == 2:\n            direction = np.append(np.array(direction), 0)\n        Arrow.__init__(self, ORIGIN, direction, **kwargs)",
  "def __init__(self, *args, **kwargs):\n        Arrow.__init__(self, *args, **kwargs)\n        self.add_tip(at_start=True)",
  "def __init__(self, points, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.set_points(points)",
  "def __init__(self, *vertices, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.set_points_as_corners([*vertices, vertices[0]])",
  "def get_vertices(self):\n        return self.get_start_anchors()",
  "def round_corners(self, radius=0.5):\n        vertices = self.get_vertices()\n        arcs = []\n        for v1, v2, v3 in adjacent_n_tuples(vertices, 3):\n            vect1 = v2 - v1\n            vect2 = v3 - v2\n            unit_vect1 = normalize(vect1)\n            unit_vect2 = normalize(vect2)\n            angle = angle_between_vectors(vect1, vect2)\n            # Negative radius gives concave curves\n            angle *= np.sign(radius)\n            # Distance between vertex and start of the arc\n            cut_off_length = radius * np.tan(angle / 2)\n            # Determines counterclockwise vs. clockwise\n            sign = np.sign(np.cross(vect1, vect2)[2])\n            arc = ArcBetweenPoints(\n                v2 - unit_vect1 * cut_off_length,\n                v2 + unit_vect2 * cut_off_length,\n                angle=sign * angle,\n            )\n            arcs.append(arc)\n\n        self.clear_points()\n        # To ensure that we loop through starting with last\n        arcs = [arcs[-1], *arcs[:-1]]\n        for arc1, arc2 in adjacent_pairs(arcs):\n            self.append_points(arc1.points)\n            line = Line(arc1.get_end(), arc2.get_start())\n            # Make sure anchors are evenly distributed\n            len_ratio = line.get_length() / arc1.get_arc_length()\n            line.insert_n_curves(int(arc1.get_num_curves() * len_ratio))\n            self.append_points(line.get_points())\n        return self",
  "def __init__(self, n=6, **kwargs):\n        digest_config(self, kwargs, locals())\n        if self.start_angle is None:\n            if n % 2 == 0:\n                self.start_angle = 0\n            else:\n                self.start_angle = 90 * DEGREES\n        start_vect = rotate_vector(RIGHT, self.start_angle)\n        vertices = compass_directions(n, start_vect)\n        Polygon.__init__(self, *vertices, **kwargs)",
  "def __init__(self, **kwargs):\n        RegularPolygon.__init__(self, n=3, **kwargs)",
  "def __init__(self, **kwargs):\n        Triangle.__init__(self, **kwargs)\n        self.set_width(self.length)\n        self.set_height(self.length, stretch=True)",
  "def get_base(self):\n        return self.point_from_proportion(0.5)",
  "def get_tip_point(self):\n        return self.points[0]",
  "def get_vector(self):\n        return self.get_tip_point() - self.get_base()",
  "def get_angle(self):\n        return angle_of_vector(self.get_vector())",
  "def get_length(self):\n        return get_norm(self.get_vector())",
  "def __init__(self, **kwargs):\n        Polygon.__init__(self, UL, UR, DR, DL, **kwargs)\n        self.set_width(self.width, stretch=True)\n        self.set_height(self.height, stretch=True)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        Rectangle.__init__(\n            self, height=self.side_length, width=self.side_length, **kwargs\n        )",
  "def __init__(self, **kwargs):\n        Rectangle.__init__(self, **kwargs)\n        self.round_corners(self.corner_radius)",
  "def get_3d_vmob_gradient_start_and_end_points(vmob):\n    return (\n        get_3d_vmob_start_corner(vmob),\n        get_3d_vmob_end_corner(vmob),\n    )",
  "def get_3d_vmob_start_corner_index(vmob):\n    return 0",
  "def get_3d_vmob_end_corner_index(vmob):\n    return ((len(vmob.points) - 1) // 6) * 3",
  "def get_3d_vmob_start_corner(vmob):\n    if vmob.get_num_points() == 0:\n        return np.array(ORIGIN)\n    return vmob.points[get_3d_vmob_start_corner_index(vmob)]",
  "def get_3d_vmob_end_corner(vmob):\n    if vmob.get_num_points() == 0:\n        return np.array(ORIGIN)\n    return vmob.points[get_3d_vmob_end_corner_index(vmob)]",
  "def get_3d_vmob_unit_normal(vmob, point_index):\n    n_points = vmob.get_num_points()\n    if vmob.get_num_points() == 0:\n        return np.array(ORIGIN)\n    i = point_index\n    im1 = i - 1 if i > 0 else (n_points - 2)\n    ip1 = i + 1 if i < (n_points - 1) else 1\n    return get_unit_normal(\n        vmob.points[ip1] - vmob.points[i], vmob.points[im1] - vmob.points[i],\n    )",
  "def get_3d_vmob_start_corner_unit_normal(vmob):\n    return get_3d_vmob_unit_normal(vmob, get_3d_vmob_start_corner_index(vmob))",
  "def get_3d_vmob_end_corner_unit_normal(vmob):\n    return get_3d_vmob_unit_normal(vmob, get_3d_vmob_end_corner_index(vmob))",
  "class AbstractImageMobject(Mobject):\n    \"\"\"\n    Automatically filters out black pixels\n    \"\"\"\n\n    CONFIG = {\n        \"height\": 2.0,\n        \"pixel_array_dtype\": \"uint8\",\n    }\n\n    def get_pixel_array(self):\n        raise Exception(\"Not implemented\")\n\n    def set_color(self):\n        # Likely to be implemented in subclasses, but no obgligation\n        pass\n\n    def reset_points(self):\n        # Corresponding corners of image are fixed to these 3 points\n        self.points = np.array([UP + LEFT, UP + RIGHT, DOWN + LEFT,])\n        self.center()\n        h, w = self.get_pixel_array().shape[:2]\n        self.stretch_to_fit_height(self.height)\n        self.stretch_to_fit_width(self.height * w / h)\n\n    def copy(self):\n        return self.deepcopy()",
  "class ImageMobject(AbstractImageMobject):\n    CONFIG = {\n        \"invert\": False,\n        \"image_mode\": \"RGBA\",\n    }\n\n    def __init__(self, filename_or_array, **kwargs):\n        digest_config(self, kwargs)\n        if isinstance(filename_or_array, str):\n            path = get_full_raster_image_path(filename_or_array)\n            image = Image.open(path).convert(self.image_mode)\n            self.pixel_array = np.array(image)\n        else:\n            self.pixel_array = np.array(filename_or_array)\n        self.change_to_rgba_array()\n        if self.invert:\n            self.pixel_array[:, :, :3] = 255 - self.pixel_array[:, :, :3]\n        AbstractImageMobject.__init__(self, **kwargs)\n\n    def change_to_rgba_array(self):\n        pa = self.pixel_array\n        if len(pa.shape) == 2:\n            pa = pa.reshape(list(pa.shape) + [1])\n        if pa.shape[2] == 1:\n            pa = pa.repeat(3, axis=2)\n        if pa.shape[2] == 3:\n            alphas = 255 * np.ones(\n                list(pa.shape[:2]) + [1], dtype=self.pixel_array_dtype\n            )\n            pa = np.append(pa, alphas, axis=2)\n        self.pixel_array = pa\n\n    def get_pixel_array(self):\n        return self.pixel_array\n\n    def set_color(self, color, alpha=None, family=True):\n        rgb = color_to_int_rgb(color)\n        self.pixel_array[:, :, :3] = rgb\n        if alpha is not None:\n            self.pixel_array[:, :, 3] = int(255 * alpha)\n        for submob in self.submobjects:\n            submob.set_color(color, alpha, family)\n        self.color = color\n        return self\n\n    def set_opacity(self, alpha):\n        self.pixel_array[:, :, 3] = int(255 * alpha)\n        return self\n\n    def fade(self, darkness=0.5, family=True):\n        self.set_opacity(1 - darkness)\n        super().fade(darkness, family)\n        return self\n\n    def interpolate_color(self, mobject1, mobject2, alpha):\n        assert mobject1.pixel_array.shape == mobject2.pixel_array.shape\n        self.pixel_array = interpolate(\n            mobject1.pixel_array, mobject2.pixel_array, alpha\n        ).astype(self.pixel_array_dtype)",
  "class ImageMobjectFromCamera(AbstractImageMobject):\n    CONFIG = {\n        \"default_display_frame_config\": {\n            \"stroke_width\": 3,\n            \"stroke_color\": WHITE,\n            \"buff\": 0,\n        }\n    }\n\n    def __init__(self, camera, **kwargs):\n        self.camera = camera\n        AbstractImageMobject.__init__(self, **kwargs)\n\n    def get_pixel_array(self):\n        return self.camera.get_pixel_array()\n\n    def add_display_frame(self, **kwargs):\n        config = dict(self.default_display_frame_config)\n        config.update(kwargs)\n        self.display_frame = SurroundingRectangle(self, **config)\n        self.add(self.display_frame)\n        return self",
  "def get_pixel_array(self):\n        raise Exception(\"Not implemented\")",
  "def set_color(self):\n        # Likely to be implemented in subclasses, but no obgligation\n        pass",
  "def reset_points(self):\n        # Corresponding corners of image are fixed to these 3 points\n        self.points = np.array([UP + LEFT, UP + RIGHT, DOWN + LEFT,])\n        self.center()\n        h, w = self.get_pixel_array().shape[:2]\n        self.stretch_to_fit_height(self.height)\n        self.stretch_to_fit_width(self.height * w / h)",
  "def copy(self):\n        return self.deepcopy()",
  "def __init__(self, filename_or_array, **kwargs):\n        digest_config(self, kwargs)\n        if isinstance(filename_or_array, str):\n            path = get_full_raster_image_path(filename_or_array)\n            image = Image.open(path).convert(self.image_mode)\n            self.pixel_array = np.array(image)\n        else:\n            self.pixel_array = np.array(filename_or_array)\n        self.change_to_rgba_array()\n        if self.invert:\n            self.pixel_array[:, :, :3] = 255 - self.pixel_array[:, :, :3]\n        AbstractImageMobject.__init__(self, **kwargs)",
  "def change_to_rgba_array(self):\n        pa = self.pixel_array\n        if len(pa.shape) == 2:\n            pa = pa.reshape(list(pa.shape) + [1])\n        if pa.shape[2] == 1:\n            pa = pa.repeat(3, axis=2)\n        if pa.shape[2] == 3:\n            alphas = 255 * np.ones(\n                list(pa.shape[:2]) + [1], dtype=self.pixel_array_dtype\n            )\n            pa = np.append(pa, alphas, axis=2)\n        self.pixel_array = pa",
  "def get_pixel_array(self):\n        return self.pixel_array",
  "def set_color(self, color, alpha=None, family=True):\n        rgb = color_to_int_rgb(color)\n        self.pixel_array[:, :, :3] = rgb\n        if alpha is not None:\n            self.pixel_array[:, :, 3] = int(255 * alpha)\n        for submob in self.submobjects:\n            submob.set_color(color, alpha, family)\n        self.color = color\n        return self",
  "def set_opacity(self, alpha):\n        self.pixel_array[:, :, 3] = int(255 * alpha)\n        return self",
  "def fade(self, darkness=0.5, family=True):\n        self.set_opacity(1 - darkness)\n        super().fade(darkness, family)\n        return self",
  "def interpolate_color(self, mobject1, mobject2, alpha):\n        assert mobject1.pixel_array.shape == mobject2.pixel_array.shape\n        self.pixel_array = interpolate(\n            mobject1.pixel_array, mobject2.pixel_array, alpha\n        ).astype(self.pixel_array_dtype)",
  "def __init__(self, camera, **kwargs):\n        self.camera = camera\n        AbstractImageMobject.__init__(self, **kwargs)",
  "def get_pixel_array(self):\n        return self.camera.get_pixel_array()",
  "def add_display_frame(self, **kwargs):\n        config = dict(self.default_display_frame_config)\n        config.update(kwargs)\n        self.display_frame = SurroundingRectangle(self, **config)\n        self.add(self.display_frame)\n        return self",
  "class PMobject(Mobject):\n    CONFIG = {\n        \"stroke_width\": DEFAULT_STROKE_WIDTH,\n    }\n\n    def reset_points(self):\n        self.rgbas = np.zeros((0, 4))\n        self.points = np.zeros((0, 3))\n        return self\n\n    def get_array_attrs(self):\n        return Mobject.get_array_attrs(self) + [\"rgbas\"]\n\n    def add_points(self, points, rgbas=None, color=None, alpha=1):\n        \"\"\"\n        points must be a Nx3 numpy array, as must rgbas if it is not None\n        \"\"\"\n        if not isinstance(points, np.ndarray):\n            points = np.array(points)\n        num_new_points = len(points)\n        self.points = np.append(self.points, points, axis=0)\n        if rgbas is None:\n            color = Color(color) if color else self.color\n            rgbas = np.repeat([color_to_rgba(color, alpha)], num_new_points, axis=0)\n        elif len(rgbas) != len(points):\n            raise Exception(\"points and rgbas must have same shape\")\n        self.rgbas = np.append(self.rgbas, rgbas, axis=0)\n        return self\n\n    def set_color(self, color=YELLOW_C, family=True):\n        rgba = color_to_rgba(color)\n        mobs = self.family_members_with_points() if family else [self]\n        for mob in mobs:\n            mob.rgbas[:, :] = rgba\n        self.color = color\n        return self\n\n    def get_stroke_width(self):\n        return self.stroke_width\n\n    def set_stroke_width(self, width, family=True):\n        mobs = self.family_members_with_points() if family else [self]\n        for mob in mobs:\n            mob.stroke_width = width\n        return self\n\n    # def set_color_by_gradient(self, start_color, end_color):\n    def set_color_by_gradient(self, *colors):\n        self.rgbas = np.array(\n            list(map(color_to_rgba, color_gradient(colors, len(self.points))))\n        )\n        return self\n\n        start_rgba, end_rgba = list(map(color_to_rgba, [start_color, end_color]))\n        for mob in self.family_members_with_points():\n            num_points = mob.get_num_points()\n            mob.rgbas = np.array(\n                [\n                    interpolate(start_rgba, end_rgba, alpha)\n                    for alpha in np.arange(num_points) / float(num_points)\n                ]\n            )\n        return self\n\n    def set_colors_by_radial_gradient(\n        self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK\n    ):\n        start_rgba, end_rgba = list(map(color_to_rgba, [start_color, end_color]))\n        if center is None:\n            center = self.get_center()\n        for mob in self.family_members_with_points():\n            num_points = mob.get_num_points()\n            t = min(1, np.abs(mob.get_center() - center) / radius)\n\n            mob.rgbas = np.array([interpolate(start_rgba, end_rgba, t)] * num_points)\n        return self\n\n    def match_colors(self, mobject):\n        Mobject.align_data(self, mobject)\n        self.rgbas = np.array(mobject.rgbas)\n        return self\n\n    def filter_out(self, condition):\n        for mob in self.family_members_with_points():\n            to_eliminate = ~np.apply_along_axis(condition, 1, mob.points)\n            mob.points = mob.points[to_eliminate]\n            mob.rgbas = mob.rgbas[to_eliminate]\n        return self\n\n    def thin_out(self, factor=5):\n        \"\"\"\n        Removes all but every nth point for n = factor\n        \"\"\"\n        for mob in self.family_members_with_points():\n            num_points = self.get_num_points()\n            mob.apply_over_attr_arrays(\n                lambda arr: arr[np.arange(0, num_points, factor)]\n            )\n        return self\n\n    def sort_points(self, function=lambda p: p[0]):\n        \"\"\"\n        function is any map from R^3 to R\n        \"\"\"\n        for mob in self.family_members_with_points():\n            indices = np.argsort(np.apply_along_axis(function, 1, mob.points))\n            mob.apply_over_attr_arrays(lambda arr: arr[indices])\n        return self\n\n    def fade_to(self, color, alpha):\n        self.rgbas = interpolate(self.rgbas, color_to_rgba(color), alpha)\n        for mob in self.submobjects:\n            mob.fade_to(color, alpha)\n        return self\n\n    def get_all_rgbas(self):\n        return self.get_merged_array(\"rgbas\")\n\n    def ingest_submobjects(self):\n        attrs = self.get_array_attrs()\n        arrays = list(map(self.get_merged_array, attrs))\n        for attr, array in zip(attrs, arrays):\n            setattr(self, attr, array)\n        self.submobjects = []\n        return self\n\n    def get_color(self):\n        return rgba_to_color(self.rgbas[0, :])\n\n    def point_from_proportion(self, alpha):\n        index = alpha * (self.get_num_points() - 1)\n        return self.points[index]\n\n    # Alignment\n    def align_points_with_larger(self, larger_mobject):\n        assert isinstance(larger_mobject, PMobject)\n        self.apply_over_attr_arrays(\n            lambda a: stretch_array_to_length(a, larger_mobject.get_num_points())\n        )\n\n    def get_point_mobject(self, center=None):\n        if center is None:\n            center = self.get_center()\n        return Point(center)\n\n    def interpolate_color(self, mobject1, mobject2, alpha):\n        self.rgbas = interpolate(mobject1.rgbas, mobject2.rgbas, alpha)\n        self.set_stroke_width(\n            interpolate(\n                mobject1.get_stroke_width(), mobject2.get_stroke_width(), alpha,\n            )\n        )\n        return self\n\n    def pointwise_become_partial(self, mobject, a, b):\n        lower_index, upper_index = [int(x * mobject.get_num_points()) for x in (a, b)]\n        for attr in self.get_array_attrs():\n            full_array = getattr(mobject, attr)\n            partial_array = full_array[lower_index:upper_index]\n            setattr(self, attr, partial_array)",
  "class Mobject1D(PMobject):\n    CONFIG = {\n        \"density\": DEFAULT_POINT_DENSITY_1D,\n    }\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        self.epsilon = 1.0 / self.density\n        Mobject.__init__(self, **kwargs)\n\n    def add_line(self, start, end, color=None):\n        start, end = list(map(np.array, [start, end]))\n        length = get_norm(end - start)\n        if length == 0:\n            points = [start]\n        else:\n            epsilon = self.epsilon / length\n            points = [interpolate(start, end, t) for t in np.arange(0, 1, epsilon)]\n        self.add_points(points, color=color)",
  "class Mobject2D(PMobject):\n    CONFIG = {\n        \"density\": DEFAULT_POINT_DENSITY_2D,\n    }\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        self.epsilon = 1.0 / self.density\n        Mobject.__init__(self, **kwargs)",
  "class PGroup(PMobject):\n    def __init__(self, *pmobs, **kwargs):\n        if not all([isinstance(m, PMobject) for m in pmobs]):\n            raise Exception(\"All submobjects must be of type PMobject\")\n        super().__init__(**kwargs)\n        self.add(*pmobs)",
  "class PointCloudDot(Mobject1D):\n    CONFIG = {\n        \"radius\": 0.075,\n        \"stroke_width\": 2,\n        \"density\": DEFAULT_POINT_DENSITY_1D,\n        \"color\": YELLOW,\n    }\n\n    def __init__(self, center=ORIGIN, **kwargs):\n        Mobject1D.__init__(self, **kwargs)\n        self.shift(center)\n\n    def generate_points(self):\n        self.add_points(\n            [\n                r * (np.cos(theta) * RIGHT + np.sin(theta) * UP)\n                for r in np.arange(0, self.radius, self.epsilon)\n                for theta in np.arange(0, 2 * np.pi, self.epsilon / r)\n            ]\n        )",
  "class Point(PMobject):\n    CONFIG = {\n        \"color\": BLACK,\n    }\n\n    def __init__(self, location=ORIGIN, **kwargs):\n        PMobject.__init__(self, **kwargs)\n        self.add_points([location])",
  "def reset_points(self):\n        self.rgbas = np.zeros((0, 4))\n        self.points = np.zeros((0, 3))\n        return self",
  "def get_array_attrs(self):\n        return Mobject.get_array_attrs(self) + [\"rgbas\"]",
  "def add_points(self, points, rgbas=None, color=None, alpha=1):\n        \"\"\"\n        points must be a Nx3 numpy array, as must rgbas if it is not None\n        \"\"\"\n        if not isinstance(points, np.ndarray):\n            points = np.array(points)\n        num_new_points = len(points)\n        self.points = np.append(self.points, points, axis=0)\n        if rgbas is None:\n            color = Color(color) if color else self.color\n            rgbas = np.repeat([color_to_rgba(color, alpha)], num_new_points, axis=0)\n        elif len(rgbas) != len(points):\n            raise Exception(\"points and rgbas must have same shape\")\n        self.rgbas = np.append(self.rgbas, rgbas, axis=0)\n        return self",
  "def set_color(self, color=YELLOW_C, family=True):\n        rgba = color_to_rgba(color)\n        mobs = self.family_members_with_points() if family else [self]\n        for mob in mobs:\n            mob.rgbas[:, :] = rgba\n        self.color = color\n        return self",
  "def get_stroke_width(self):\n        return self.stroke_width",
  "def set_stroke_width(self, width, family=True):\n        mobs = self.family_members_with_points() if family else [self]\n        for mob in mobs:\n            mob.stroke_width = width\n        return self",
  "def set_color_by_gradient(self, *colors):\n        self.rgbas = np.array(\n            list(map(color_to_rgba, color_gradient(colors, len(self.points))))\n        )\n        return self\n\n        start_rgba, end_rgba = list(map(color_to_rgba, [start_color, end_color]))\n        for mob in self.family_members_with_points():\n            num_points = mob.get_num_points()\n            mob.rgbas = np.array(\n                [\n                    interpolate(start_rgba, end_rgba, alpha)\n                    for alpha in np.arange(num_points) / float(num_points)\n                ]\n            )\n        return self",
  "def set_colors_by_radial_gradient(\n        self, center=None, radius=1, inner_color=WHITE, outer_color=BLACK\n    ):\n        start_rgba, end_rgba = list(map(color_to_rgba, [start_color, end_color]))\n        if center is None:\n            center = self.get_center()\n        for mob in self.family_members_with_points():\n            num_points = mob.get_num_points()\n            t = min(1, np.abs(mob.get_center() - center) / radius)\n\n            mob.rgbas = np.array([interpolate(start_rgba, end_rgba, t)] * num_points)\n        return self",
  "def match_colors(self, mobject):\n        Mobject.align_data(self, mobject)\n        self.rgbas = np.array(mobject.rgbas)\n        return self",
  "def filter_out(self, condition):\n        for mob in self.family_members_with_points():\n            to_eliminate = ~np.apply_along_axis(condition, 1, mob.points)\n            mob.points = mob.points[to_eliminate]\n            mob.rgbas = mob.rgbas[to_eliminate]\n        return self",
  "def thin_out(self, factor=5):\n        \"\"\"\n        Removes all but every nth point for n = factor\n        \"\"\"\n        for mob in self.family_members_with_points():\n            num_points = self.get_num_points()\n            mob.apply_over_attr_arrays(\n                lambda arr: arr[np.arange(0, num_points, factor)]\n            )\n        return self",
  "def sort_points(self, function=lambda p: p[0]):\n        \"\"\"\n        function is any map from R^3 to R\n        \"\"\"\n        for mob in self.family_members_with_points():\n            indices = np.argsort(np.apply_along_axis(function, 1, mob.points))\n            mob.apply_over_attr_arrays(lambda arr: arr[indices])\n        return self",
  "def fade_to(self, color, alpha):\n        self.rgbas = interpolate(self.rgbas, color_to_rgba(color), alpha)\n        for mob in self.submobjects:\n            mob.fade_to(color, alpha)\n        return self",
  "def get_all_rgbas(self):\n        return self.get_merged_array(\"rgbas\")",
  "def ingest_submobjects(self):\n        attrs = self.get_array_attrs()\n        arrays = list(map(self.get_merged_array, attrs))\n        for attr, array in zip(attrs, arrays):\n            setattr(self, attr, array)\n        self.submobjects = []\n        return self",
  "def get_color(self):\n        return rgba_to_color(self.rgbas[0, :])",
  "def point_from_proportion(self, alpha):\n        index = alpha * (self.get_num_points() - 1)\n        return self.points[index]",
  "def align_points_with_larger(self, larger_mobject):\n        assert isinstance(larger_mobject, PMobject)\n        self.apply_over_attr_arrays(\n            lambda a: stretch_array_to_length(a, larger_mobject.get_num_points())\n        )",
  "def get_point_mobject(self, center=None):\n        if center is None:\n            center = self.get_center()\n        return Point(center)",
  "def interpolate_color(self, mobject1, mobject2, alpha):\n        self.rgbas = interpolate(mobject1.rgbas, mobject2.rgbas, alpha)\n        self.set_stroke_width(\n            interpolate(\n                mobject1.get_stroke_width(), mobject2.get_stroke_width(), alpha,\n            )\n        )\n        return self",
  "def pointwise_become_partial(self, mobject, a, b):\n        lower_index, upper_index = [int(x * mobject.get_num_points()) for x in (a, b)]\n        for attr in self.get_array_attrs():\n            full_array = getattr(mobject, attr)\n            partial_array = full_array[lower_index:upper_index]\n            setattr(self, attr, partial_array)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        self.epsilon = 1.0 / self.density\n        Mobject.__init__(self, **kwargs)",
  "def add_line(self, start, end, color=None):\n        start, end = list(map(np.array, [start, end]))\n        length = get_norm(end - start)\n        if length == 0:\n            points = [start]\n        else:\n            epsilon = self.epsilon / length\n            points = [interpolate(start, end, t) for t in np.arange(0, 1, epsilon)]\n        self.add_points(points, color=color)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        self.epsilon = 1.0 / self.density\n        Mobject.__init__(self, **kwargs)",
  "def __init__(self, *pmobs, **kwargs):\n        if not all([isinstance(m, PMobject) for m in pmobs]):\n            raise Exception(\"All submobjects must be of type PMobject\")\n        super().__init__(**kwargs)\n        self.add(*pmobs)",
  "def __init__(self, center=ORIGIN, **kwargs):\n        Mobject1D.__init__(self, **kwargs)\n        self.shift(center)",
  "def generate_points(self):\n        self.add_points(\n            [\n                r * (np.cos(theta) * RIGHT + np.sin(theta) * UP)\n                for r in np.arange(0, self.radius, self.epsilon)\n                for theta in np.arange(0, 2 * np.pi, self.epsilon / r)\n            ]\n        )",
  "def __init__(self, location=ORIGIN, **kwargs):\n        PMobject.__init__(self, **kwargs)\n        self.add_points([location])",
  "class VMobject(Mobject):\n    CONFIG = {\n        \"fill_color\": None,\n        \"fill_opacity\": 0.0,\n        \"stroke_color\": None,\n        \"stroke_opacity\": 1.0,\n        \"stroke_width\": DEFAULT_STROKE_WIDTH,\n        # The purpose of background stroke is to have\n        # something that won't overlap the fill, e.g.\n        # For text against some textured background\n        \"background_stroke_color\": BLACK,\n        \"background_stroke_opacity\": 1.0,\n        \"background_stroke_width\": 0,\n        # When a color c is set, there will be a second color\n        # computed based on interpolating c to WHITE by with\n        # sheen_factor, and the display will gradient to this\n        # secondary color in the direction of sheen_direction.\n        \"sheen_factor\": 0.0,\n        \"sheen_direction\": UL,\n        # Indicates that it will not be displayed, but\n        # that it should count in parent mobject's path\n        \"close_new_points\": False,\n        \"pre_function_handle_to_anchor_scale_factor\": 0.01,\n        \"make_smooth_after_applying_functions\": False,\n        \"background_image_file\": None,\n        \"shade_in_3d\": False,\n        # This is within a pixel\n        # TODO, do we care about accounting for\n        # varying zoom levels?\n        \"tolerance_for_point_equality\": 1e-6,\n        \"n_points_per_cubic_curve\": 4,\n    }\n\n    def get_group_class(self):\n        return VGroup\n\n    # Colors\n    def init_colors(self):\n        self.set_fill(\n            color=self.fill_color or self.color, opacity=self.fill_opacity,\n        )\n        self.set_stroke(\n            color=self.stroke_color or self.color,\n            width=self.stroke_width,\n            opacity=self.stroke_opacity,\n        )\n        self.set_background_stroke(\n            color=self.background_stroke_color,\n            width=self.background_stroke_width,\n            opacity=self.background_stroke_opacity,\n        )\n        self.set_sheen(\n            factor=self.sheen_factor, direction=self.sheen_direction,\n        )\n        return self\n\n    def generate_rgbas_array(self, color, opacity):\n        \"\"\"\n        First arg can be either a color, or a tuple/list of colors.\n        Likewise, opacity can either be a float, or a tuple of floats.\n        If self.sheen_factor is not zero, and only\n        one color was passed in, a second slightly light color\n        will automatically be added for the gradient\n        \"\"\"\n        colors = list(tuplify(color))\n        opacities = list(tuplify(opacity))\n        rgbas = np.array(\n            [color_to_rgba(c, o) for c, o in zip(*make_even(colors, opacities))]\n        )\n\n        sheen_factor = self.get_sheen_factor()\n        if sheen_factor != 0 and len(rgbas) == 1:\n            light_rgbas = np.array(rgbas)\n            light_rgbas[:, :3] += sheen_factor\n            clip_in_place(light_rgbas, 0, 1)\n            rgbas = np.append(rgbas, light_rgbas, axis=0)\n        return rgbas\n\n    def update_rgbas_array(self, array_name, color=None, opacity=None):\n        passed_color = color if (color is not None) else BLACK\n        passed_opacity = opacity if (opacity is not None) else 0\n        rgbas = self.generate_rgbas_array(passed_color, passed_opacity)\n        if not hasattr(self, array_name):\n            setattr(self, array_name, rgbas)\n            return self\n        # Match up current rgbas array with the newly calculated\n        # one. 99% of the time they'll be the same.\n        curr_rgbas = getattr(self, array_name)\n        if len(curr_rgbas) < len(rgbas):\n            curr_rgbas = stretch_array_to_length(curr_rgbas, len(rgbas))\n            setattr(self, array_name, curr_rgbas)\n        elif len(rgbas) < len(curr_rgbas):\n            rgbas = stretch_array_to_length(rgbas, len(curr_rgbas))\n        # Only update rgb if color was not None, and only\n        # update alpha channel if opacity was passed in\n        if color is not None:\n            curr_rgbas[:, :3] = rgbas[:, :3]\n        if opacity is not None:\n            curr_rgbas[:, 3] = rgbas[:, 3]\n        return self\n\n    def set_fill(self, color=None, opacity=None, family=True):\n        if family:\n            for submobject in self.submobjects:\n                submobject.set_fill(color, opacity, family)\n        self.update_rgbas_array(\"fill_rgbas\", color, opacity)\n        return self\n\n    def set_stroke(\n        self, color=None, width=None, opacity=None, background=False, family=True\n    ):\n        if family:\n            for submobject in self.submobjects:\n                submobject.set_stroke(color, width, opacity, background, family)\n        if background:\n            array_name = \"background_stroke_rgbas\"\n            width_name = \"background_stroke_width\"\n        else:\n            array_name = \"stroke_rgbas\"\n            width_name = \"stroke_width\"\n        self.update_rgbas_array(array_name, color, opacity)\n        if width is not None:\n            setattr(self, width_name, width)\n        return self\n\n    def set_background_stroke(self, **kwargs):\n        kwargs[\"background\"] = True\n        self.set_stroke(**kwargs)\n        return self\n\n    def set_style(\n        self,\n        fill_color=None,\n        fill_opacity=None,\n        stroke_color=None,\n        stroke_width=None,\n        stroke_opacity=None,\n        background_stroke_color=None,\n        background_stroke_width=None,\n        background_stroke_opacity=None,\n        sheen_factor=None,\n        sheen_direction=None,\n        background_image_file=None,\n        family=True,\n    ):\n        self.set_fill(color=fill_color, opacity=fill_opacity, family=family)\n        self.set_stroke(\n            color=stroke_color,\n            width=stroke_width,\n            opacity=stroke_opacity,\n            family=family,\n        )\n        self.set_background_stroke(\n            color=background_stroke_color,\n            width=background_stroke_width,\n            opacity=background_stroke_opacity,\n            family=family,\n        )\n        if sheen_factor:\n            self.set_sheen(\n                factor=sheen_factor, direction=sheen_direction, family=family,\n            )\n        if background_image_file:\n            self.color_using_background_image(background_image_file)\n        return self\n\n    def get_style(self):\n        return {\n            \"fill_color\": self.get_fill_colors(),\n            \"fill_opacity\": self.get_fill_opacities(),\n            \"stroke_color\": self.get_stroke_colors(),\n            \"stroke_width\": self.get_stroke_width(),\n            \"stroke_opacity\": self.get_stroke_opacity(),\n            \"background_stroke_color\": self.get_stroke_colors(background=True),\n            \"background_stroke_width\": self.get_stroke_width(background=True),\n            \"background_stroke_opacity\": self.get_stroke_opacity(background=True),\n            \"sheen_factor\": self.get_sheen_factor(),\n            \"sheen_direction\": self.get_sheen_direction(),\n            \"background_image_file\": self.get_background_image_file(),\n        }\n\n    def match_style(self, vmobject, family=True):\n        self.set_style(**vmobject.get_style(), family=False)\n\n        if family:\n            # Does its best to match up submobject lists, and\n            # match styles accordingly\n            submobs1, submobs2 = self.submobjects, vmobject.submobjects\n            if len(submobs1) == 0:\n                return self\n            elif len(submobs2) == 0:\n                submobs2 = [vmobject]\n            for sm1, sm2 in zip(*make_even(submobs1, submobs2)):\n                sm1.match_style(sm2)\n        return self\n\n    def set_color(self, color, family=True):\n        self.set_fill(color, family=family)\n        self.set_stroke(color, family=family)\n        return self\n\n    def set_opacity(self, opacity, family=True):\n        self.set_fill(opacity=opacity, family=family)\n        self.set_stroke(opacity=opacity, family=family)\n        self.set_stroke(opacity=opacity, family=family, background=True)\n        return self\n\n    def fade(self, darkness=0.5, family=True):\n        factor = 1.0 - darkness\n        self.set_fill(\n            opacity=factor * self.get_fill_opacity(), family=False,\n        )\n        self.set_stroke(\n            opacity=factor * self.get_stroke_opacity(), family=False,\n        )\n        self.set_background_stroke(\n            opacity=factor * self.get_stroke_opacity(background=True), family=False,\n        )\n        super().fade(darkness, family)\n        return self\n\n    def get_fill_rgbas(self):\n        try:\n            return self.fill_rgbas\n        except AttributeError:\n            return np.zeros((1, 4))\n\n    def get_fill_color(self):\n        \"\"\"\n        If there are multiple colors (for gradient)\n        this returns the first one\n        \"\"\"\n        return self.get_fill_colors()[0]\n\n    def get_fill_opacity(self):\n        \"\"\"\n        If there are multiple opacities, this returns the\n        first\n        \"\"\"\n        return self.get_fill_opacities()[0]\n\n    def get_fill_colors(self):\n        return [Color(rgb=rgba[:3]) for rgba in self.get_fill_rgbas()]\n\n    def get_fill_opacities(self):\n        return self.get_fill_rgbas()[:, 3]\n\n    def get_stroke_rgbas(self, background=False):\n        try:\n            if background:\n                rgbas = self.background_stroke_rgbas\n            else:\n                rgbas = self.stroke_rgbas\n            return rgbas\n        except AttributeError:\n            return np.zeros((1, 4))\n\n    def get_stroke_color(self, background=False):\n        return self.get_stroke_colors(background)[0]\n\n    def get_stroke_width(self, background=False):\n        if background:\n            width = self.background_stroke_width\n        else:\n            width = self.stroke_width\n        return max(0, width)\n\n    def get_stroke_opacity(self, background=False):\n        return self.get_stroke_opacities(background)[0]\n\n    def get_stroke_colors(self, background=False):\n        return [Color(rgb=rgba[:3]) for rgba in self.get_stroke_rgbas(background)]\n\n    def get_stroke_opacities(self, background=False):\n        return self.get_stroke_rgbas(background)[:, 3]\n\n    def get_color(self):\n        if np.all(self.get_fill_opacities() == 0):\n            return self.get_stroke_color()\n        return self.get_fill_color()\n\n    def set_sheen_direction(self, direction, family=True):\n        direction = np.array(direction)\n        if family:\n            for submob in self.get_family():\n                submob.sheen_direction = direction\n        else:\n            self.sheen_direction = direction\n        return self\n\n    def set_sheen(self, factor, direction=None, family=True):\n        if family:\n            for submob in self.submobjects:\n                submob.set_sheen(factor, direction, family)\n        self.sheen_factor = factor\n        if direction is not None:\n            # family set to false because recursion will\n            # already be handled above\n            self.set_sheen_direction(direction, family=False)\n        # Reset color to put sheen_factor into effect\n        if factor != 0:\n            self.set_stroke(self.get_stroke_color(), family=family)\n            self.set_fill(self.get_fill_color(), family=family)\n        return self\n\n    def get_sheen_direction(self):\n        return np.array(self.sheen_direction)\n\n    def get_sheen_factor(self):\n        return self.sheen_factor\n\n    def get_gradient_start_and_end_points(self):\n        if self.shade_in_3d:\n            return get_3d_vmob_gradient_start_and_end_points(self)\n        else:\n            direction = self.get_sheen_direction()\n            c = self.get_center()\n            bases = np.array(\n                [self.get_edge_center(vect) - c for vect in [RIGHT, UP, OUT]]\n            ).transpose()\n            offset = np.dot(bases, direction)\n            return (c - offset, c + offset)\n\n    def color_using_background_image(self, background_image_file):\n        self.background_image_file = background_image_file\n        self.set_color(WHITE)\n        for submob in self.submobjects:\n            submob.color_using_background_image(background_image_file)\n        return self\n\n    def get_background_image_file(self):\n        return self.background_image_file\n\n    def match_background_image_file(self, vmobject):\n        self.color_using_background_image(vmobject.get_background_image_file())\n        return self\n\n    def set_shade_in_3d(self, value=True, z_index_as_group=False):\n        for submob in self.get_family():\n            submob.shade_in_3d = value\n            if z_index_as_group:\n                submob.z_index_group = self\n        return self\n\n    # Points\n    def set_points(self, points):\n        self.points = np.array(points)\n        return self\n\n    def get_points(self):\n        return np.array(self.points)\n\n    def set_anchors_and_handles(self, anchors1, handles1, handles2, anchors2):\n        assert len(anchors1) == len(handles1) == len(handles2) == len(anchors2)\n        nppcc = self.n_points_per_cubic_curve  # 4\n        total_len = nppcc * len(anchors1)\n        self.points = np.zeros((total_len, self.dim))\n        arrays = [anchors1, handles1, handles2, anchors2]\n        for index, array in enumerate(arrays):\n            self.points[index::nppcc] = array\n        return self\n\n    def clear_points(self):\n        self.points = np.zeros((0, self.dim))\n\n    def append_points(self, new_points):\n        # TODO, check that number new points is a multiple of 4?\n        # or else that if len(self.points) % 4 == 1, then\n        # len(new_points) % 4 == 3?\n        self.points = np.append(self.points, new_points, axis=0)\n        return self\n\n    def start_new_path(self, point):\n        # TODO, make sure that len(self.points) % 4 == 0?\n        self.append_points([point])\n        return self\n\n    def add_cubic_bezier_curve(self, anchor1, handle1, handle2, anchor2):\n        # TODO, check the len(self.points) % 4 == 0?\n        self.append_points([anchor1, handle1, handle2, anchor2])\n\n    def add_cubic_bezier_curve_to(self, handle1, handle2, anchor):\n        \"\"\"\n        Add cubic bezier curve to the path.\n        \"\"\"\n        self.throw_error_if_no_points()\n        new_points = [handle1, handle2, anchor]\n        if self.has_new_path_started():\n            self.append_points(new_points)\n        else:\n            self.append_points([self.get_last_point()] + new_points)\n\n    def add_line_to(self, point):\n        nppcc = self.n_points_per_cubic_curve\n        self.add_cubic_bezier_curve_to(\n            *[\n                interpolate(self.get_last_point(), point, a)\n                for a in np.linspace(0, 1, nppcc)[1:]\n            ]\n        )\n        return self\n\n    def add_smooth_curve_to(self, *points):\n        \"\"\"\n        If two points are passed in, the first is intepretted\n        as a handle, the second as an anchor\n        \"\"\"\n        if len(points) == 1:\n            handle2 = None\n            new_anchor = points[0]\n        elif len(points) == 2:\n            handle2, new_anchor = points\n        else:\n            name = sys._getframe(0).f_code.co_name\n            raise Exception(\"Only call {} with 1 or 2 points\".format(name))\n\n        if self.has_new_path_started():\n            self.add_line_to(new_anchor)\n        else:\n            self.throw_error_if_no_points()\n            last_h2, last_a2 = self.points[-2:]\n            last_tangent = last_a2 - last_h2\n            handle1 = last_a2 + last_tangent\n            if handle2 is None:\n                to_anchor_vect = new_anchor - last_a2\n                new_tangent = rotate_vector(last_tangent, PI, axis=to_anchor_vect)\n                handle2 = new_anchor - new_tangent\n            self.append_points([last_a2, handle1, handle2, new_anchor])\n        return self\n\n    def has_new_path_started(self):\n        nppcc = self.n_points_per_cubic_curve  # 4\n        return len(self.points) % nppcc == 1\n\n    def get_last_point(self):\n        return self.points[-1]\n\n    def is_closed(self):\n        return self.consider_points_equals(self.points[0], self.points[-1])\n\n    def add_points_as_corners(self, points):\n        for point in points:\n            self.add_line_to(point)\n        return points\n\n    def set_points_as_corners(self, points):\n        nppcc = self.n_points_per_cubic_curve\n        points = np.array(points)\n        self.set_anchors_and_handles(\n            *[interpolate(points[:-1], points[1:], a) for a in np.linspace(0, 1, nppcc)]\n        )\n        return self\n\n    def set_points_smoothly(self, points):\n        self.set_points_as_corners(points)\n        self.make_smooth()\n        return self\n\n    def change_anchor_mode(self, mode):\n        assert mode in [\"jagged\", \"smooth\"]\n        nppcc = self.n_points_per_cubic_curve\n        for submob in self.family_members_with_points():\n            subpaths = submob.get_subpaths()\n            submob.clear_points()\n            for subpath in subpaths:\n                anchors = np.append(subpath[::nppcc], subpath[-1:], 0)\n                if mode == \"smooth\":\n                    h1, h2 = get_smooth_handle_points(anchors)\n                elif mode == \"jagged\":\n                    a1 = anchors[:-1]\n                    a2 = anchors[1:]\n                    h1 = interpolate(a1, a2, 1.0 / 3)\n                    h2 = interpolate(a1, a2, 2.0 / 3)\n                new_subpath = np.array(subpath)\n                new_subpath[1::nppcc] = h1\n                new_subpath[2::nppcc] = h2\n                submob.append_points(new_subpath)\n        return self\n\n    def make_smooth(self):\n        return self.change_anchor_mode(\"smooth\")\n\n    def make_jagged(self):\n        return self.change_anchor_mode(\"jagged\")\n\n    def add_subpath(self, points):\n        assert len(points) % 4 == 0\n        self.points = np.append(self.points, points, axis=0)\n        return self\n\n    def append_vectorized_mobject(self, vectorized_mobject):\n        new_points = list(vectorized_mobject.points)\n\n        if self.has_new_path_started():\n            # Remove last point, which is starting\n            # a new path\n            self.points = self.points[:-1]\n        self.append_points(new_points)\n\n    def apply_function(self, function):\n        factor = self.pre_function_handle_to_anchor_scale_factor\n        self.scale_handle_to_anchor_distances(factor)\n        Mobject.apply_function(self, function)\n        self.scale_handle_to_anchor_distances(1.0 / factor)\n        if self.make_smooth_after_applying_functions:\n            self.make_smooth()\n        return self\n\n    def scale_handle_to_anchor_distances(self, factor):\n        \"\"\"\n        If the distance between a given handle point H and its associated\n        anchor point A is d, then it changes H to be a distances factor*d\n        away from A, but so that the line from A to H doesn't change.\n        This is mostly useful in the context of applying a (differentiable)\n        function, to preserve tangency properties.  One would pull all the\n        handles closer to their anchors, apply the function then push them out\n        again.\n        \"\"\"\n        for submob in self.family_members_with_points():\n            if len(submob.points) < self.n_points_per_cubic_curve:\n                continue\n            a1, h1, h2, a2 = submob.get_anchors_and_handles()\n            a1_to_h1 = h1 - a1\n            a2_to_h2 = h2 - a2\n            new_h1 = a1 + factor * a1_to_h1\n            new_h2 = a2 + factor * a2_to_h2\n            submob.set_anchors_and_handles(a1, new_h1, new_h2, a2)\n        return self\n\n    #\n    def consider_points_equals(self, p0, p1):\n        return np.allclose(p0, p1, atol=self.tolerance_for_point_equality)\n\n    def consider_points_equals_2d(self, p0, p1):\n        \"\"\"\n        Determine if two points are close enough to be considered equal.\n\n        This uses the algorithm from np.isclose(), but expanded here for the\n        2D point case. NumPy is overkill for such a small question.\n        \"\"\"\n        rtol = 1.0e-5  # default from np.isclose()\n        atol = self.tolerance_for_point_equality\n        if abs(p0[0] - p1[0]) > atol + rtol * abs(p1[0]):\n            return False\n        if abs(p0[1] - p1[1]) > atol + rtol * abs(p1[1]):\n            return False\n        return True\n\n    # Information about line\n    def get_cubic_bezier_tuples_from_points(self, points):\n        return np.array(list(self.gen_cubic_bezier_tuples_from_points(points)))\n\n    def gen_cubic_bezier_tuples_from_points(self, points):\n        \"\"\"\n        Get a generator for the cubic bezier tuples of this object.\n\n        Generator to not materialize a list or np.array needlessly.\n        \"\"\"\n        nppcc = VMobject.CONFIG[\"n_points_per_cubic_curve\"]\n        remainder = len(points) % nppcc\n        points = points[: len(points) - remainder]\n        return (points[i : i + nppcc] for i in range(0, len(points), nppcc))\n\n    def get_cubic_bezier_tuples(self):\n        return self.get_cubic_bezier_tuples_from_points(self.get_points())\n\n    def _gen_subpaths_from_points(self, points, filter_func):\n        nppcc = self.n_points_per_cubic_curve\n        split_indices = filter(filter_func, range(nppcc, len(points), nppcc))\n        split_indices = [0] + list(split_indices) + [len(points)]\n        return (\n            points[i1:i2]\n            for i1, i2 in zip(split_indices, split_indices[1:])\n            if (i2 - i1) >= nppcc\n        )\n\n    def get_subpaths_from_points(self, points):\n        return list(\n            self._gen_subpaths_from_points(\n                points,\n                lambda n: not self.consider_points_equals(points[n - 1], points[n]),\n            )\n        )\n\n    def gen_subpaths_from_points_2d(self, points):\n        return self._gen_subpaths_from_points(\n            points,\n            lambda n: not self.consider_points_equals_2d(points[n - 1], points[n]),\n        )\n\n    def get_subpaths(self):\n        return self.get_subpaths_from_points(self.get_points())\n\n    def get_nth_curve_points(self, n):\n        assert n < self.get_num_curves()\n        nppcc = self.n_points_per_cubic_curve\n        return self.points[nppcc * n : nppcc * (n + 1)]\n\n    def get_nth_curve_function(self, n):\n        return bezier(self.get_nth_curve_points(n))\n\n    def get_num_curves(self):\n        nppcc = self.n_points_per_cubic_curve\n        return len(self.points) // nppcc\n\n    def point_from_proportion(self, alpha):\n        num_cubics = self.get_num_curves()\n        n, residue = integer_interpolate(0, num_cubics, alpha)\n        curve = self.get_nth_curve_function(n)\n        return curve(residue)\n\n    def get_anchors_and_handles(self):\n        \"\"\"\n        returns anchors1, handles1, handles2, anchors2,\n        where (anchors1[i], handles1[i], handles2[i], anchors2[i])\n        will be four points defining a cubic bezier curve\n        for any i in range(0, len(anchors1))\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        return [self.points[i::nppcc] for i in range(nppcc)]\n\n    def get_start_anchors(self):\n        return self.points[0 :: self.n_points_per_cubic_curve]\n\n    def get_end_anchors(self):\n        nppcc = self.n_points_per_cubic_curve\n        return self.points[nppcc - 1 :: nppcc]\n\n    def get_anchors(self):\n        if self.points.shape[0] == 1:\n            return self.points\n        return np.array(\n            list(it.chain(*zip(self.get_start_anchors(), self.get_end_anchors(),)))\n        )\n\n    def get_points_defining_boundary(self):\n        return np.array(list(it.chain(*[sm.get_anchors() for sm in self.get_family()])))\n\n    def get_arc_length(self, n_sample_points=None):\n        if n_sample_points is None:\n            n_sample_points = 4 * self.get_num_curves() + 1\n        points = np.array(\n            [self.point_from_proportion(a) for a in np.linspace(0, 1, n_sample_points)]\n        )\n        diffs = points[1:] - points[:-1]\n        norms = np.apply_along_axis(get_norm, 1, diffs)\n        return np.sum(norms)\n\n    # Alignment\n    def align_points(self, vmobject):\n        self.align_rgbas(vmobject)\n        if self.get_num_points() == vmobject.get_num_points():\n            return\n\n        for mob in self, vmobject:\n            # If there are no points, add one to\n            # whereever the \"center\" is\n            if mob.has_no_points():\n                mob.start_new_path(mob.get_center())\n            # If there's only one point, turn it into\n            # a null curve\n            if mob.has_new_path_started():\n                mob.add_line_to(mob.get_last_point())\n\n        # Figure out what the subpaths are, and align\n        subpaths1 = self.get_subpaths()\n        subpaths2 = vmobject.get_subpaths()\n        n_subpaths = max(len(subpaths1), len(subpaths2))\n        # Start building new ones\n        new_path1 = np.zeros((0, self.dim))\n        new_path2 = np.zeros((0, self.dim))\n\n        nppcc = self.n_points_per_cubic_curve\n\n        def get_nth_subpath(path_list, n):\n            if n >= len(path_list):\n                # Create a null path at the very end\n                return [path_list[-1][-1]] * nppcc\n            return path_list[n]\n\n        for n in range(n_subpaths):\n            sp1 = get_nth_subpath(subpaths1, n)\n            sp2 = get_nth_subpath(subpaths2, n)\n            diff1 = max(0, (len(sp2) - len(sp1)) // nppcc)\n            diff2 = max(0, (len(sp1) - len(sp2)) // nppcc)\n            sp1 = self.insert_n_curves_to_point_list(diff1, sp1)\n            sp2 = self.insert_n_curves_to_point_list(diff2, sp2)\n            new_path1 = np.append(new_path1, sp1, axis=0)\n            new_path2 = np.append(new_path2, sp2, axis=0)\n        self.set_points(new_path1)\n        vmobject.set_points(new_path2)\n        return self\n\n    def insert_n_curves(self, n):\n        new_path_point = None\n        if self.has_new_path_started():\n            new_path_point = self.get_last_point()\n\n        new_points = self.insert_n_curves_to_point_list(n, self.get_points())\n        self.set_points(new_points)\n\n        if new_path_point is not None:\n            self.append_points([new_path_point])\n        return self\n\n    def insert_n_curves_to_point_list(self, n, points):\n        if len(points) == 1:\n            nppcc = self.n_points_per_cubic_curve\n            return np.repeat(points, nppcc * n, 0)\n        bezier_quads = self.get_cubic_bezier_tuples_from_points(points)\n        curr_num = len(bezier_quads)\n        target_num = curr_num + n\n        # This is an array with values ranging from 0\n        # up to curr_num,  with repeats such that\n        # it's total length is target_num.  For example,\n        # with curr_num = 10, target_num = 15, this would\n        # be [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]\n        repeat_indices = (np.arange(target_num) * curr_num) // target_num\n\n        # If the nth term of this list is k, it means\n        # that the nth curve of our path should be split\n        # into k pieces.  In the above example, this would\n        # be [2, 1, 2, 1, 2, 1, 2, 1, 2, 1]\n        split_factors = [sum(repeat_indices == i) for i in range(curr_num)]\n        new_points = np.zeros((0, self.dim))\n        for quad, sf in zip(bezier_quads, split_factors):\n            # What was once a single cubic curve defined\n            # by \"quad\" will now be broken into sf\n            # smaller cubic curves\n            alphas = np.linspace(0, 1, sf + 1)\n            for a1, a2 in zip(alphas, alphas[1:]):\n                new_points = np.append(\n                    new_points, partial_bezier_points(quad, a1, a2), axis=0\n                )\n        return new_points\n\n    def align_rgbas(self, vmobject):\n        attrs = [\"fill_rgbas\", \"stroke_rgbas\", \"background_stroke_rgbas\"]\n        for attr in attrs:\n            a1 = getattr(self, attr)\n            a2 = getattr(vmobject, attr)\n            if len(a1) > len(a2):\n                new_a2 = stretch_array_to_length(a2, len(a1))\n                setattr(vmobject, attr, new_a2)\n            elif len(a2) > len(a1):\n                new_a1 = stretch_array_to_length(a1, len(a2))\n                setattr(self, attr, new_a1)\n        return self\n\n    def get_point_mobject(self, center=None):\n        if center is None:\n            center = self.get_center()\n        point = VectorizedPoint(center)\n        point.match_style(self)\n        return point\n\n    def interpolate_color(self, mobject1, mobject2, alpha):\n        attrs = [\n            \"fill_rgbas\",\n            \"stroke_rgbas\",\n            \"background_stroke_rgbas\",\n            \"stroke_width\",\n            \"background_stroke_width\",\n            \"sheen_direction\",\n            \"sheen_factor\",\n        ]\n        for attr in attrs:\n            setattr(\n                self,\n                attr,\n                interpolate(getattr(mobject1, attr), getattr(mobject2, attr), alpha),\n            )\n            if alpha == 1.0:\n                setattr(self, attr, getattr(mobject2, attr))\n\n    def pointwise_become_partial(self, vmobject, a, b):\n        assert isinstance(vmobject, VMobject)\n        # Partial curve includes three portions:\n        # - A middle section, which matches the curve exactly\n        # - A start, which is some ending portion of an inner cubic\n        # - An end, which is the starting portion of a later inner cubic\n        if a <= 0 and b >= 1:\n            self.set_points(vmobject.points)\n            return self\n        bezier_quads = vmobject.get_cubic_bezier_tuples()\n        num_cubics = len(bezier_quads)\n\n        lower_index, lower_residue = integer_interpolate(0, num_cubics, a)\n        upper_index, upper_residue = integer_interpolate(0, num_cubics, b)\n\n        self.clear_points()\n        if num_cubics == 0:\n            return self\n        if lower_index == upper_index:\n            self.append_points(\n                partial_bezier_points(\n                    bezier_quads[lower_index], lower_residue, upper_residue\n                )\n            )\n        else:\n            self.append_points(\n                partial_bezier_points(bezier_quads[lower_index], lower_residue, 1)\n            )\n            for quad in bezier_quads[lower_index + 1 : upper_index]:\n                self.append_points(quad)\n            self.append_points(\n                partial_bezier_points(bezier_quads[upper_index], 0, upper_residue)\n            )\n        return self\n\n    def get_subcurve(self, a, b):\n        vmob = self.copy()\n        vmob.pointwise_become_partial(self, a, b)\n        return vmob",
  "class VGroup(VMobject):\n    def __init__(self, *vmobjects, **kwargs):\n        if not all([isinstance(m, VMobject) for m in vmobjects]):\n            raise Exception(\"All submobjects must be of type VMobject\")\n        VMobject.__init__(self, **kwargs)\n        self.add(*vmobjects)",
  "class VDict(VMobject):\n    \"\"\"A VGroup-like class, also offering submobject access by\n    key, like a python dict\n\n    Parameters\n    ----------\n    pairs: Tuple[Hashable, :class:`~.VMobject`]\n            Each pair is a 2-element :class:`tuple` wherein the first \n            element is the key for the mobject and the second\n            element is the actual mobject\n    show_keys : :class:`bool`, optional\n            Whether to also display the key associated with \n            the mobject. This might be useful when debugging,\n            especially when there are a lot of mobjects in the\n            :class:`VDict`. Defaults to False\n    kwargs : Any\n            Other arguments to be passed to `Mobject` or the CONFIG.\n\n    Attributes\n    ----------\n    show_keys : :class:`bool`\n            Whether to also display the key associated with \n            the mobject. This might be useful when debugging,\n            especially when there are a lot of mobjects in the\n            :class:`VDict`. When displayed, the key is towards\n            the left of the mobject.\n            Defaults to False\n    submob_dict : :class:`dict`\n            Is the actual python dictionary that is used to bind\n            the keys to the mobjects\n    \"\"\"\n\n    def __init__(self, *pairs, show_keys=False, **kwargs):\n        if not all(isinstance(m[1], VMobject) for m in pairs):\n            raise Exception(\"All submobjects must be of type VMobject\")\n        VMobject.__init__(self, **kwargs)\n        self.show_keys = show_keys\n        self.submob_dict = {}\n        self.add(*pairs)\n\n    def add(self, *pairs):\n        \"\"\"Adds the key-value pairs to the :class:`VDict` object.\n\n        Also, it internally adds the value to the `submobjects` :class:`list`\n        of :class:`~.Mobject`, which is responsible for actual on-screen display\n\n        Parameters\n        ---------\n        pairs : Tuple[Hashable, :class:`~.VMobject`]\n            Each pair is a :class:`tuple` wherein the first \n            element is the key for the mobject and the second\n            element is the actual mobject\n\n        Returns\n        -------\n        :class:`VDict`\n            Returns the :class:`VDict` object on which this method was called\n\n        Examples\n        --------\n        Normal usage::\n            square_obj = Square()\n            my_dict.add(('s', square_obj))\n        \"\"\"\n        for pair in pairs:\n            key = pair[0]\n            value = pair[1]\n\n            mob = value\n            if self.show_keys:\n                # This import is here and not at the top to avoid circular import\n                from ...mobject.svg.tex_mobject import TextMobject\n\n                key_text = TextMobject(str(key)).next_to(value, LEFT)\n                mob.add(key_text)\n\n            self.submob_dict[key] = mob\n            super().add(value)\n        return self\n\n    def remove(self, key):\n        \"\"\"Removes the mobject from the :class:`VDict` object having the key `key`\n        \n        Also, it internally removes the mobject from the `submobjects` :class:`list`\n        of :class:`~.Mobject`, (which is responsible for removing it from the screen)\n\n        Parameters\n        ----------\n        key : Hashable\n            The key of the submoject to be removed\n\n        Returns\n        -------\n        :class:`VDict`\n            Returns the :class:`VDict` object on which this method was called\n\n        Examples\n        --------\n        Normal usage::\n            my_dict.remove('square')\n        \"\"\"\n        if key not in self.submob_dict:\n            raise Exception(\"The given key '%s' is not present in the VDict\" % str(key))\n        super().remove(self.submob_dict[key])\n        del self.submob_dict[key]\n        return self\n\n    def __getitem__(self, key):\n        \"\"\"Overriding the [] operator for getting submobject by key\n        \n        Parameters\n        ----------\n        key : Hashable\n           The key of the submoject to be accessed\n            \n        Returns\n        -------\n        :class:`VMobject`\n           The submobject corresponding to the key `key`\n\n        Examples\n        --------\n        Normal usage::\n           self.play(ShowCreation(my_dict['s']))\n        \"\"\"\n        submob = self.submob_dict[key]\n        return submob\n\n    def __setitem__(self, key, value):\n        \"\"\"Overriding the [] operator for assigning submobject like a python dict\n\n        Parameters\n        ----------\n        key : Hashable\n            The key of the submoject to be assigned\n        value : :class:`VMobject`\n            The submobject to bind the key to\n            \n        Returns\n        -------\n        None\n\n        Examples\n        --------\n        Normal usage::\n            square_obj = Square()\n            my_dict['sq'] = square_obj\n        \"\"\"\n        if key in self.submob_dict:\n            self.remove(key)\n        self.add((key, value))\n\n    def get_all_submobjects(self):\n        \"\"\"To get all the submobjects associated with a particular :class:`VDict` object\n        \n        Returns\n        -------\n        :class:`dict_values`\n            All the submobjects associated with the :class:`VDict` object\n\n        Examples\n        --------\n        Normal usage::\n            for submob in my_dict.get_all_submobjects():\n                self.play(ShowCreation(submob))\n        \"\"\"\n        submobjects = self.submob_dict.values()\n        return submobjects",
  "class VectorizedPoint(VMobject):\n    CONFIG = {\n        \"color\": BLACK,\n        \"fill_opacity\": 0,\n        \"stroke_width\": 0,\n        \"artificial_width\": 0.01,\n        \"artificial_height\": 0.01,\n    }\n\n    def __init__(self, location=ORIGIN, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.set_points(np.array([location]))\n\n    def get_width(self):\n        return self.artificial_width\n\n    def get_height(self):\n        return self.artificial_height\n\n    def get_location(self):\n        return np.array(self.points[0])\n\n    def set_location(self, new_loc):\n        self.set_points(np.array([new_loc]))",
  "class CurvesAsSubmobjects(VGroup):\n    def __init__(self, vmobject, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        tuples = vmobject.get_cubic_bezier_tuples()\n        for tup in tuples:\n            part = VMobject()\n            part.set_points(tup)\n            part.match_style(vmobject)\n            self.add(part)",
  "class DashedVMobject(VMobject):\n    CONFIG = {\"num_dashes\": 15, \"positive_space_ratio\": 0.5, \"color\": WHITE}\n\n    def __init__(self, vmobject, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        num_dashes = self.num_dashes\n        ps_ratio = self.positive_space_ratio\n        if num_dashes > 0:\n            # End points of the unit interval for division\n            alphas = np.linspace(0, 1, num_dashes + 1)\n\n            # This determines the length of each \"dash\"\n            full_d_alpha = 1.0 / num_dashes\n            partial_d_alpha = full_d_alpha * ps_ratio\n\n            # Rescale so that the last point of vmobject will\n            # be the end of the last dash\n            alphas /= 1 - full_d_alpha + partial_d_alpha\n\n            self.add(\n                *[\n                    vmobject.get_subcurve(alpha, alpha + partial_d_alpha)\n                    for alpha in alphas[:-1]\n                ]\n            )\n        # Family is already taken care of by get_subcurve\n        # implementation\n        self.match_style(vmobject, family=False)",
  "def get_group_class(self):\n        return VGroup",
  "def init_colors(self):\n        self.set_fill(\n            color=self.fill_color or self.color, opacity=self.fill_opacity,\n        )\n        self.set_stroke(\n            color=self.stroke_color or self.color,\n            width=self.stroke_width,\n            opacity=self.stroke_opacity,\n        )\n        self.set_background_stroke(\n            color=self.background_stroke_color,\n            width=self.background_stroke_width,\n            opacity=self.background_stroke_opacity,\n        )\n        self.set_sheen(\n            factor=self.sheen_factor, direction=self.sheen_direction,\n        )\n        return self",
  "def generate_rgbas_array(self, color, opacity):\n        \"\"\"\n        First arg can be either a color, or a tuple/list of colors.\n        Likewise, opacity can either be a float, or a tuple of floats.\n        If self.sheen_factor is not zero, and only\n        one color was passed in, a second slightly light color\n        will automatically be added for the gradient\n        \"\"\"\n        colors = list(tuplify(color))\n        opacities = list(tuplify(opacity))\n        rgbas = np.array(\n            [color_to_rgba(c, o) for c, o in zip(*make_even(colors, opacities))]\n        )\n\n        sheen_factor = self.get_sheen_factor()\n        if sheen_factor != 0 and len(rgbas) == 1:\n            light_rgbas = np.array(rgbas)\n            light_rgbas[:, :3] += sheen_factor\n            clip_in_place(light_rgbas, 0, 1)\n            rgbas = np.append(rgbas, light_rgbas, axis=0)\n        return rgbas",
  "def update_rgbas_array(self, array_name, color=None, opacity=None):\n        passed_color = color if (color is not None) else BLACK\n        passed_opacity = opacity if (opacity is not None) else 0\n        rgbas = self.generate_rgbas_array(passed_color, passed_opacity)\n        if not hasattr(self, array_name):\n            setattr(self, array_name, rgbas)\n            return self\n        # Match up current rgbas array with the newly calculated\n        # one. 99% of the time they'll be the same.\n        curr_rgbas = getattr(self, array_name)\n        if len(curr_rgbas) < len(rgbas):\n            curr_rgbas = stretch_array_to_length(curr_rgbas, len(rgbas))\n            setattr(self, array_name, curr_rgbas)\n        elif len(rgbas) < len(curr_rgbas):\n            rgbas = stretch_array_to_length(rgbas, len(curr_rgbas))\n        # Only update rgb if color was not None, and only\n        # update alpha channel if opacity was passed in\n        if color is not None:\n            curr_rgbas[:, :3] = rgbas[:, :3]\n        if opacity is not None:\n            curr_rgbas[:, 3] = rgbas[:, 3]\n        return self",
  "def set_fill(self, color=None, opacity=None, family=True):\n        if family:\n            for submobject in self.submobjects:\n                submobject.set_fill(color, opacity, family)\n        self.update_rgbas_array(\"fill_rgbas\", color, opacity)\n        return self",
  "def set_stroke(\n        self, color=None, width=None, opacity=None, background=False, family=True\n    ):\n        if family:\n            for submobject in self.submobjects:\n                submobject.set_stroke(color, width, opacity, background, family)\n        if background:\n            array_name = \"background_stroke_rgbas\"\n            width_name = \"background_stroke_width\"\n        else:\n            array_name = \"stroke_rgbas\"\n            width_name = \"stroke_width\"\n        self.update_rgbas_array(array_name, color, opacity)\n        if width is not None:\n            setattr(self, width_name, width)\n        return self",
  "def set_background_stroke(self, **kwargs):\n        kwargs[\"background\"] = True\n        self.set_stroke(**kwargs)\n        return self",
  "def set_style(\n        self,\n        fill_color=None,\n        fill_opacity=None,\n        stroke_color=None,\n        stroke_width=None,\n        stroke_opacity=None,\n        background_stroke_color=None,\n        background_stroke_width=None,\n        background_stroke_opacity=None,\n        sheen_factor=None,\n        sheen_direction=None,\n        background_image_file=None,\n        family=True,\n    ):\n        self.set_fill(color=fill_color, opacity=fill_opacity, family=family)\n        self.set_stroke(\n            color=stroke_color,\n            width=stroke_width,\n            opacity=stroke_opacity,\n            family=family,\n        )\n        self.set_background_stroke(\n            color=background_stroke_color,\n            width=background_stroke_width,\n            opacity=background_stroke_opacity,\n            family=family,\n        )\n        if sheen_factor:\n            self.set_sheen(\n                factor=sheen_factor, direction=sheen_direction, family=family,\n            )\n        if background_image_file:\n            self.color_using_background_image(background_image_file)\n        return self",
  "def get_style(self):\n        return {\n            \"fill_color\": self.get_fill_colors(),\n            \"fill_opacity\": self.get_fill_opacities(),\n            \"stroke_color\": self.get_stroke_colors(),\n            \"stroke_width\": self.get_stroke_width(),\n            \"stroke_opacity\": self.get_stroke_opacity(),\n            \"background_stroke_color\": self.get_stroke_colors(background=True),\n            \"background_stroke_width\": self.get_stroke_width(background=True),\n            \"background_stroke_opacity\": self.get_stroke_opacity(background=True),\n            \"sheen_factor\": self.get_sheen_factor(),\n            \"sheen_direction\": self.get_sheen_direction(),\n            \"background_image_file\": self.get_background_image_file(),\n        }",
  "def match_style(self, vmobject, family=True):\n        self.set_style(**vmobject.get_style(), family=False)\n\n        if family:\n            # Does its best to match up submobject lists, and\n            # match styles accordingly\n            submobs1, submobs2 = self.submobjects, vmobject.submobjects\n            if len(submobs1) == 0:\n                return self\n            elif len(submobs2) == 0:\n                submobs2 = [vmobject]\n            for sm1, sm2 in zip(*make_even(submobs1, submobs2)):\n                sm1.match_style(sm2)\n        return self",
  "def set_color(self, color, family=True):\n        self.set_fill(color, family=family)\n        self.set_stroke(color, family=family)\n        return self",
  "def set_opacity(self, opacity, family=True):\n        self.set_fill(opacity=opacity, family=family)\n        self.set_stroke(opacity=opacity, family=family)\n        self.set_stroke(opacity=opacity, family=family, background=True)\n        return self",
  "def fade(self, darkness=0.5, family=True):\n        factor = 1.0 - darkness\n        self.set_fill(\n            opacity=factor * self.get_fill_opacity(), family=False,\n        )\n        self.set_stroke(\n            opacity=factor * self.get_stroke_opacity(), family=False,\n        )\n        self.set_background_stroke(\n            opacity=factor * self.get_stroke_opacity(background=True), family=False,\n        )\n        super().fade(darkness, family)\n        return self",
  "def get_fill_rgbas(self):\n        try:\n            return self.fill_rgbas\n        except AttributeError:\n            return np.zeros((1, 4))",
  "def get_fill_color(self):\n        \"\"\"\n        If there are multiple colors (for gradient)\n        this returns the first one\n        \"\"\"\n        return self.get_fill_colors()[0]",
  "def get_fill_opacity(self):\n        \"\"\"\n        If there are multiple opacities, this returns the\n        first\n        \"\"\"\n        return self.get_fill_opacities()[0]",
  "def get_fill_colors(self):\n        return [Color(rgb=rgba[:3]) for rgba in self.get_fill_rgbas()]",
  "def get_fill_opacities(self):\n        return self.get_fill_rgbas()[:, 3]",
  "def get_stroke_rgbas(self, background=False):\n        try:\n            if background:\n                rgbas = self.background_stroke_rgbas\n            else:\n                rgbas = self.stroke_rgbas\n            return rgbas\n        except AttributeError:\n            return np.zeros((1, 4))",
  "def get_stroke_color(self, background=False):\n        return self.get_stroke_colors(background)[0]",
  "def get_stroke_width(self, background=False):\n        if background:\n            width = self.background_stroke_width\n        else:\n            width = self.stroke_width\n        return max(0, width)",
  "def get_stroke_opacity(self, background=False):\n        return self.get_stroke_opacities(background)[0]",
  "def get_stroke_colors(self, background=False):\n        return [Color(rgb=rgba[:3]) for rgba in self.get_stroke_rgbas(background)]",
  "def get_stroke_opacities(self, background=False):\n        return self.get_stroke_rgbas(background)[:, 3]",
  "def get_color(self):\n        if np.all(self.get_fill_opacities() == 0):\n            return self.get_stroke_color()\n        return self.get_fill_color()",
  "def set_sheen_direction(self, direction, family=True):\n        direction = np.array(direction)\n        if family:\n            for submob in self.get_family():\n                submob.sheen_direction = direction\n        else:\n            self.sheen_direction = direction\n        return self",
  "def set_sheen(self, factor, direction=None, family=True):\n        if family:\n            for submob in self.submobjects:\n                submob.set_sheen(factor, direction, family)\n        self.sheen_factor = factor\n        if direction is not None:\n            # family set to false because recursion will\n            # already be handled above\n            self.set_sheen_direction(direction, family=False)\n        # Reset color to put sheen_factor into effect\n        if factor != 0:\n            self.set_stroke(self.get_stroke_color(), family=family)\n            self.set_fill(self.get_fill_color(), family=family)\n        return self",
  "def get_sheen_direction(self):\n        return np.array(self.sheen_direction)",
  "def get_sheen_factor(self):\n        return self.sheen_factor",
  "def get_gradient_start_and_end_points(self):\n        if self.shade_in_3d:\n            return get_3d_vmob_gradient_start_and_end_points(self)\n        else:\n            direction = self.get_sheen_direction()\n            c = self.get_center()\n            bases = np.array(\n                [self.get_edge_center(vect) - c for vect in [RIGHT, UP, OUT]]\n            ).transpose()\n            offset = np.dot(bases, direction)\n            return (c - offset, c + offset)",
  "def color_using_background_image(self, background_image_file):\n        self.background_image_file = background_image_file\n        self.set_color(WHITE)\n        for submob in self.submobjects:\n            submob.color_using_background_image(background_image_file)\n        return self",
  "def get_background_image_file(self):\n        return self.background_image_file",
  "def match_background_image_file(self, vmobject):\n        self.color_using_background_image(vmobject.get_background_image_file())\n        return self",
  "def set_shade_in_3d(self, value=True, z_index_as_group=False):\n        for submob in self.get_family():\n            submob.shade_in_3d = value\n            if z_index_as_group:\n                submob.z_index_group = self\n        return self",
  "def set_points(self, points):\n        self.points = np.array(points)\n        return self",
  "def get_points(self):\n        return np.array(self.points)",
  "def set_anchors_and_handles(self, anchors1, handles1, handles2, anchors2):\n        assert len(anchors1) == len(handles1) == len(handles2) == len(anchors2)\n        nppcc = self.n_points_per_cubic_curve  # 4\n        total_len = nppcc * len(anchors1)\n        self.points = np.zeros((total_len, self.dim))\n        arrays = [anchors1, handles1, handles2, anchors2]\n        for index, array in enumerate(arrays):\n            self.points[index::nppcc] = array\n        return self",
  "def clear_points(self):\n        self.points = np.zeros((0, self.dim))",
  "def append_points(self, new_points):\n        # TODO, check that number new points is a multiple of 4?\n        # or else that if len(self.points) % 4 == 1, then\n        # len(new_points) % 4 == 3?\n        self.points = np.append(self.points, new_points, axis=0)\n        return self",
  "def start_new_path(self, point):\n        # TODO, make sure that len(self.points) % 4 == 0?\n        self.append_points([point])\n        return self",
  "def add_cubic_bezier_curve(self, anchor1, handle1, handle2, anchor2):\n        # TODO, check the len(self.points) % 4 == 0?\n        self.append_points([anchor1, handle1, handle2, anchor2])",
  "def add_cubic_bezier_curve_to(self, handle1, handle2, anchor):\n        \"\"\"\n        Add cubic bezier curve to the path.\n        \"\"\"\n        self.throw_error_if_no_points()\n        new_points = [handle1, handle2, anchor]\n        if self.has_new_path_started():\n            self.append_points(new_points)\n        else:\n            self.append_points([self.get_last_point()] + new_points)",
  "def add_line_to(self, point):\n        nppcc = self.n_points_per_cubic_curve\n        self.add_cubic_bezier_curve_to(\n            *[\n                interpolate(self.get_last_point(), point, a)\n                for a in np.linspace(0, 1, nppcc)[1:]\n            ]\n        )\n        return self",
  "def add_smooth_curve_to(self, *points):\n        \"\"\"\n        If two points are passed in, the first is intepretted\n        as a handle, the second as an anchor\n        \"\"\"\n        if len(points) == 1:\n            handle2 = None\n            new_anchor = points[0]\n        elif len(points) == 2:\n            handle2, new_anchor = points\n        else:\n            name = sys._getframe(0).f_code.co_name\n            raise Exception(\"Only call {} with 1 or 2 points\".format(name))\n\n        if self.has_new_path_started():\n            self.add_line_to(new_anchor)\n        else:\n            self.throw_error_if_no_points()\n            last_h2, last_a2 = self.points[-2:]\n            last_tangent = last_a2 - last_h2\n            handle1 = last_a2 + last_tangent\n            if handle2 is None:\n                to_anchor_vect = new_anchor - last_a2\n                new_tangent = rotate_vector(last_tangent, PI, axis=to_anchor_vect)\n                handle2 = new_anchor - new_tangent\n            self.append_points([last_a2, handle1, handle2, new_anchor])\n        return self",
  "def has_new_path_started(self):\n        nppcc = self.n_points_per_cubic_curve  # 4\n        return len(self.points) % nppcc == 1",
  "def get_last_point(self):\n        return self.points[-1]",
  "def is_closed(self):\n        return self.consider_points_equals(self.points[0], self.points[-1])",
  "def add_points_as_corners(self, points):\n        for point in points:\n            self.add_line_to(point)\n        return points",
  "def set_points_as_corners(self, points):\n        nppcc = self.n_points_per_cubic_curve\n        points = np.array(points)\n        self.set_anchors_and_handles(\n            *[interpolate(points[:-1], points[1:], a) for a in np.linspace(0, 1, nppcc)]\n        )\n        return self",
  "def set_points_smoothly(self, points):\n        self.set_points_as_corners(points)\n        self.make_smooth()\n        return self",
  "def change_anchor_mode(self, mode):\n        assert mode in [\"jagged\", \"smooth\"]\n        nppcc = self.n_points_per_cubic_curve\n        for submob in self.family_members_with_points():\n            subpaths = submob.get_subpaths()\n            submob.clear_points()\n            for subpath in subpaths:\n                anchors = np.append(subpath[::nppcc], subpath[-1:], 0)\n                if mode == \"smooth\":\n                    h1, h2 = get_smooth_handle_points(anchors)\n                elif mode == \"jagged\":\n                    a1 = anchors[:-1]\n                    a2 = anchors[1:]\n                    h1 = interpolate(a1, a2, 1.0 / 3)\n                    h2 = interpolate(a1, a2, 2.0 / 3)\n                new_subpath = np.array(subpath)\n                new_subpath[1::nppcc] = h1\n                new_subpath[2::nppcc] = h2\n                submob.append_points(new_subpath)\n        return self",
  "def make_smooth(self):\n        return self.change_anchor_mode(\"smooth\")",
  "def make_jagged(self):\n        return self.change_anchor_mode(\"jagged\")",
  "def add_subpath(self, points):\n        assert len(points) % 4 == 0\n        self.points = np.append(self.points, points, axis=0)\n        return self",
  "def append_vectorized_mobject(self, vectorized_mobject):\n        new_points = list(vectorized_mobject.points)\n\n        if self.has_new_path_started():\n            # Remove last point, which is starting\n            # a new path\n            self.points = self.points[:-1]\n        self.append_points(new_points)",
  "def apply_function(self, function):\n        factor = self.pre_function_handle_to_anchor_scale_factor\n        self.scale_handle_to_anchor_distances(factor)\n        Mobject.apply_function(self, function)\n        self.scale_handle_to_anchor_distances(1.0 / factor)\n        if self.make_smooth_after_applying_functions:\n            self.make_smooth()\n        return self",
  "def scale_handle_to_anchor_distances(self, factor):\n        \"\"\"\n        If the distance between a given handle point H and its associated\n        anchor point A is d, then it changes H to be a distances factor*d\n        away from A, but so that the line from A to H doesn't change.\n        This is mostly useful in the context of applying a (differentiable)\n        function, to preserve tangency properties.  One would pull all the\n        handles closer to their anchors, apply the function then push them out\n        again.\n        \"\"\"\n        for submob in self.family_members_with_points():\n            if len(submob.points) < self.n_points_per_cubic_curve:\n                continue\n            a1, h1, h2, a2 = submob.get_anchors_and_handles()\n            a1_to_h1 = h1 - a1\n            a2_to_h2 = h2 - a2\n            new_h1 = a1 + factor * a1_to_h1\n            new_h2 = a2 + factor * a2_to_h2\n            submob.set_anchors_and_handles(a1, new_h1, new_h2, a2)\n        return self",
  "def consider_points_equals(self, p0, p1):\n        return np.allclose(p0, p1, atol=self.tolerance_for_point_equality)",
  "def consider_points_equals_2d(self, p0, p1):\n        \"\"\"\n        Determine if two points are close enough to be considered equal.\n\n        This uses the algorithm from np.isclose(), but expanded here for the\n        2D point case. NumPy is overkill for such a small question.\n        \"\"\"\n        rtol = 1.0e-5  # default from np.isclose()\n        atol = self.tolerance_for_point_equality\n        if abs(p0[0] - p1[0]) > atol + rtol * abs(p1[0]):\n            return False\n        if abs(p0[1] - p1[1]) > atol + rtol * abs(p1[1]):\n            return False\n        return True",
  "def get_cubic_bezier_tuples_from_points(self, points):\n        return np.array(list(self.gen_cubic_bezier_tuples_from_points(points)))",
  "def gen_cubic_bezier_tuples_from_points(self, points):\n        \"\"\"\n        Get a generator for the cubic bezier tuples of this object.\n\n        Generator to not materialize a list or np.array needlessly.\n        \"\"\"\n        nppcc = VMobject.CONFIG[\"n_points_per_cubic_curve\"]\n        remainder = len(points) % nppcc\n        points = points[: len(points) - remainder]\n        return (points[i : i + nppcc] for i in range(0, len(points), nppcc))",
  "def get_cubic_bezier_tuples(self):\n        return self.get_cubic_bezier_tuples_from_points(self.get_points())",
  "def _gen_subpaths_from_points(self, points, filter_func):\n        nppcc = self.n_points_per_cubic_curve\n        split_indices = filter(filter_func, range(nppcc, len(points), nppcc))\n        split_indices = [0] + list(split_indices) + [len(points)]\n        return (\n            points[i1:i2]\n            for i1, i2 in zip(split_indices, split_indices[1:])\n            if (i2 - i1) >= nppcc\n        )",
  "def get_subpaths_from_points(self, points):\n        return list(\n            self._gen_subpaths_from_points(\n                points,\n                lambda n: not self.consider_points_equals(points[n - 1], points[n]),\n            )\n        )",
  "def gen_subpaths_from_points_2d(self, points):\n        return self._gen_subpaths_from_points(\n            points,\n            lambda n: not self.consider_points_equals_2d(points[n - 1], points[n]),\n        )",
  "def get_subpaths(self):\n        return self.get_subpaths_from_points(self.get_points())",
  "def get_nth_curve_points(self, n):\n        assert n < self.get_num_curves()\n        nppcc = self.n_points_per_cubic_curve\n        return self.points[nppcc * n : nppcc * (n + 1)]",
  "def get_nth_curve_function(self, n):\n        return bezier(self.get_nth_curve_points(n))",
  "def get_num_curves(self):\n        nppcc = self.n_points_per_cubic_curve\n        return len(self.points) // nppcc",
  "def point_from_proportion(self, alpha):\n        num_cubics = self.get_num_curves()\n        n, residue = integer_interpolate(0, num_cubics, alpha)\n        curve = self.get_nth_curve_function(n)\n        return curve(residue)",
  "def get_anchors_and_handles(self):\n        \"\"\"\n        returns anchors1, handles1, handles2, anchors2,\n        where (anchors1[i], handles1[i], handles2[i], anchors2[i])\n        will be four points defining a cubic bezier curve\n        for any i in range(0, len(anchors1))\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        return [self.points[i::nppcc] for i in range(nppcc)]",
  "def get_start_anchors(self):\n        return self.points[0 :: self.n_points_per_cubic_curve]",
  "def get_end_anchors(self):\n        nppcc = self.n_points_per_cubic_curve\n        return self.points[nppcc - 1 :: nppcc]",
  "def get_anchors(self):\n        if self.points.shape[0] == 1:\n            return self.points\n        return np.array(\n            list(it.chain(*zip(self.get_start_anchors(), self.get_end_anchors(),)))\n        )",
  "def get_points_defining_boundary(self):\n        return np.array(list(it.chain(*[sm.get_anchors() for sm in self.get_family()])))",
  "def get_arc_length(self, n_sample_points=None):\n        if n_sample_points is None:\n            n_sample_points = 4 * self.get_num_curves() + 1\n        points = np.array(\n            [self.point_from_proportion(a) for a in np.linspace(0, 1, n_sample_points)]\n        )\n        diffs = points[1:] - points[:-1]\n        norms = np.apply_along_axis(get_norm, 1, diffs)\n        return np.sum(norms)",
  "def align_points(self, vmobject):\n        self.align_rgbas(vmobject)\n        if self.get_num_points() == vmobject.get_num_points():\n            return\n\n        for mob in self, vmobject:\n            # If there are no points, add one to\n            # whereever the \"center\" is\n            if mob.has_no_points():\n                mob.start_new_path(mob.get_center())\n            # If there's only one point, turn it into\n            # a null curve\n            if mob.has_new_path_started():\n                mob.add_line_to(mob.get_last_point())\n\n        # Figure out what the subpaths are, and align\n        subpaths1 = self.get_subpaths()\n        subpaths2 = vmobject.get_subpaths()\n        n_subpaths = max(len(subpaths1), len(subpaths2))\n        # Start building new ones\n        new_path1 = np.zeros((0, self.dim))\n        new_path2 = np.zeros((0, self.dim))\n\n        nppcc = self.n_points_per_cubic_curve\n\n        def get_nth_subpath(path_list, n):\n            if n >= len(path_list):\n                # Create a null path at the very end\n                return [path_list[-1][-1]] * nppcc\n            return path_list[n]\n\n        for n in range(n_subpaths):\n            sp1 = get_nth_subpath(subpaths1, n)\n            sp2 = get_nth_subpath(subpaths2, n)\n            diff1 = max(0, (len(sp2) - len(sp1)) // nppcc)\n            diff2 = max(0, (len(sp1) - len(sp2)) // nppcc)\n            sp1 = self.insert_n_curves_to_point_list(diff1, sp1)\n            sp2 = self.insert_n_curves_to_point_list(diff2, sp2)\n            new_path1 = np.append(new_path1, sp1, axis=0)\n            new_path2 = np.append(new_path2, sp2, axis=0)\n        self.set_points(new_path1)\n        vmobject.set_points(new_path2)\n        return self",
  "def insert_n_curves(self, n):\n        new_path_point = None\n        if self.has_new_path_started():\n            new_path_point = self.get_last_point()\n\n        new_points = self.insert_n_curves_to_point_list(n, self.get_points())\n        self.set_points(new_points)\n\n        if new_path_point is not None:\n            self.append_points([new_path_point])\n        return self",
  "def insert_n_curves_to_point_list(self, n, points):\n        if len(points) == 1:\n            nppcc = self.n_points_per_cubic_curve\n            return np.repeat(points, nppcc * n, 0)\n        bezier_quads = self.get_cubic_bezier_tuples_from_points(points)\n        curr_num = len(bezier_quads)\n        target_num = curr_num + n\n        # This is an array with values ranging from 0\n        # up to curr_num,  with repeats such that\n        # it's total length is target_num.  For example,\n        # with curr_num = 10, target_num = 15, this would\n        # be [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]\n        repeat_indices = (np.arange(target_num) * curr_num) // target_num\n\n        # If the nth term of this list is k, it means\n        # that the nth curve of our path should be split\n        # into k pieces.  In the above example, this would\n        # be [2, 1, 2, 1, 2, 1, 2, 1, 2, 1]\n        split_factors = [sum(repeat_indices == i) for i in range(curr_num)]\n        new_points = np.zeros((0, self.dim))\n        for quad, sf in zip(bezier_quads, split_factors):\n            # What was once a single cubic curve defined\n            # by \"quad\" will now be broken into sf\n            # smaller cubic curves\n            alphas = np.linspace(0, 1, sf + 1)\n            for a1, a2 in zip(alphas, alphas[1:]):\n                new_points = np.append(\n                    new_points, partial_bezier_points(quad, a1, a2), axis=0\n                )\n        return new_points",
  "def align_rgbas(self, vmobject):\n        attrs = [\"fill_rgbas\", \"stroke_rgbas\", \"background_stroke_rgbas\"]\n        for attr in attrs:\n            a1 = getattr(self, attr)\n            a2 = getattr(vmobject, attr)\n            if len(a1) > len(a2):\n                new_a2 = stretch_array_to_length(a2, len(a1))\n                setattr(vmobject, attr, new_a2)\n            elif len(a2) > len(a1):\n                new_a1 = stretch_array_to_length(a1, len(a2))\n                setattr(self, attr, new_a1)\n        return self",
  "def get_point_mobject(self, center=None):\n        if center is None:\n            center = self.get_center()\n        point = VectorizedPoint(center)\n        point.match_style(self)\n        return point",
  "def interpolate_color(self, mobject1, mobject2, alpha):\n        attrs = [\n            \"fill_rgbas\",\n            \"stroke_rgbas\",\n            \"background_stroke_rgbas\",\n            \"stroke_width\",\n            \"background_stroke_width\",\n            \"sheen_direction\",\n            \"sheen_factor\",\n        ]\n        for attr in attrs:\n            setattr(\n                self,\n                attr,\n                interpolate(getattr(mobject1, attr), getattr(mobject2, attr), alpha),\n            )\n            if alpha == 1.0:\n                setattr(self, attr, getattr(mobject2, attr))",
  "def pointwise_become_partial(self, vmobject, a, b):\n        assert isinstance(vmobject, VMobject)\n        # Partial curve includes three portions:\n        # - A middle section, which matches the curve exactly\n        # - A start, which is some ending portion of an inner cubic\n        # - An end, which is the starting portion of a later inner cubic\n        if a <= 0 and b >= 1:\n            self.set_points(vmobject.points)\n            return self\n        bezier_quads = vmobject.get_cubic_bezier_tuples()\n        num_cubics = len(bezier_quads)\n\n        lower_index, lower_residue = integer_interpolate(0, num_cubics, a)\n        upper_index, upper_residue = integer_interpolate(0, num_cubics, b)\n\n        self.clear_points()\n        if num_cubics == 0:\n            return self\n        if lower_index == upper_index:\n            self.append_points(\n                partial_bezier_points(\n                    bezier_quads[lower_index], lower_residue, upper_residue\n                )\n            )\n        else:\n            self.append_points(\n                partial_bezier_points(bezier_quads[lower_index], lower_residue, 1)\n            )\n            for quad in bezier_quads[lower_index + 1 : upper_index]:\n                self.append_points(quad)\n            self.append_points(\n                partial_bezier_points(bezier_quads[upper_index], 0, upper_residue)\n            )\n        return self",
  "def get_subcurve(self, a, b):\n        vmob = self.copy()\n        vmob.pointwise_become_partial(self, a, b)\n        return vmob",
  "def __init__(self, *vmobjects, **kwargs):\n        if not all([isinstance(m, VMobject) for m in vmobjects]):\n            raise Exception(\"All submobjects must be of type VMobject\")\n        VMobject.__init__(self, **kwargs)\n        self.add(*vmobjects)",
  "def __init__(self, *pairs, show_keys=False, **kwargs):\n        if not all(isinstance(m[1], VMobject) for m in pairs):\n            raise Exception(\"All submobjects must be of type VMobject\")\n        VMobject.__init__(self, **kwargs)\n        self.show_keys = show_keys\n        self.submob_dict = {}\n        self.add(*pairs)",
  "def add(self, *pairs):\n        \"\"\"Adds the key-value pairs to the :class:`VDict` object.\n\n        Also, it internally adds the value to the `submobjects` :class:`list`\n        of :class:`~.Mobject`, which is responsible for actual on-screen display\n\n        Parameters\n        ---------\n        pairs : Tuple[Hashable, :class:`~.VMobject`]\n            Each pair is a :class:`tuple` wherein the first \n            element is the key for the mobject and the second\n            element is the actual mobject\n\n        Returns\n        -------\n        :class:`VDict`\n            Returns the :class:`VDict` object on which this method was called\n\n        Examples\n        --------\n        Normal usage::\n            square_obj = Square()\n            my_dict.add(('s', square_obj))\n        \"\"\"\n        for pair in pairs:\n            key = pair[0]\n            value = pair[1]\n\n            mob = value\n            if self.show_keys:\n                # This import is here and not at the top to avoid circular import\n                from ...mobject.svg.tex_mobject import TextMobject\n\n                key_text = TextMobject(str(key)).next_to(value, LEFT)\n                mob.add(key_text)\n\n            self.submob_dict[key] = mob\n            super().add(value)\n        return self",
  "def remove(self, key):\n        \"\"\"Removes the mobject from the :class:`VDict` object having the key `key`\n        \n        Also, it internally removes the mobject from the `submobjects` :class:`list`\n        of :class:`~.Mobject`, (which is responsible for removing it from the screen)\n\n        Parameters\n        ----------\n        key : Hashable\n            The key of the submoject to be removed\n\n        Returns\n        -------\n        :class:`VDict`\n            Returns the :class:`VDict` object on which this method was called\n\n        Examples\n        --------\n        Normal usage::\n            my_dict.remove('square')\n        \"\"\"\n        if key not in self.submob_dict:\n            raise Exception(\"The given key '%s' is not present in the VDict\" % str(key))\n        super().remove(self.submob_dict[key])\n        del self.submob_dict[key]\n        return self",
  "def __getitem__(self, key):\n        \"\"\"Overriding the [] operator for getting submobject by key\n        \n        Parameters\n        ----------\n        key : Hashable\n           The key of the submoject to be accessed\n            \n        Returns\n        -------\n        :class:`VMobject`\n           The submobject corresponding to the key `key`\n\n        Examples\n        --------\n        Normal usage::\n           self.play(ShowCreation(my_dict['s']))\n        \"\"\"\n        submob = self.submob_dict[key]\n        return submob",
  "def __setitem__(self, key, value):\n        \"\"\"Overriding the [] operator for assigning submobject like a python dict\n\n        Parameters\n        ----------\n        key : Hashable\n            The key of the submoject to be assigned\n        value : :class:`VMobject`\n            The submobject to bind the key to\n            \n        Returns\n        -------\n        None\n\n        Examples\n        --------\n        Normal usage::\n            square_obj = Square()\n            my_dict['sq'] = square_obj\n        \"\"\"\n        if key in self.submob_dict:\n            self.remove(key)\n        self.add((key, value))",
  "def get_all_submobjects(self):\n        \"\"\"To get all the submobjects associated with a particular :class:`VDict` object\n        \n        Returns\n        -------\n        :class:`dict_values`\n            All the submobjects associated with the :class:`VDict` object\n\n        Examples\n        --------\n        Normal usage::\n            for submob in my_dict.get_all_submobjects():\n                self.play(ShowCreation(submob))\n        \"\"\"\n        submobjects = self.submob_dict.values()\n        return submobjects",
  "def __init__(self, location=ORIGIN, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.set_points(np.array([location]))",
  "def get_width(self):\n        return self.artificial_width",
  "def get_height(self):\n        return self.artificial_height",
  "def get_location(self):\n        return np.array(self.points[0])",
  "def set_location(self, new_loc):\n        self.set_points(np.array([new_loc]))",
  "def __init__(self, vmobject, **kwargs):\n        VGroup.__init__(self, **kwargs)\n        tuples = vmobject.get_cubic_bezier_tuples()\n        for tup in tuples:\n            part = VMobject()\n            part.set_points(tup)\n            part.match_style(vmobject)\n            self.add(part)",
  "def __init__(self, vmobject, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        num_dashes = self.num_dashes\n        ps_ratio = self.positive_space_ratio\n        if num_dashes > 0:\n            # End points of the unit interval for division\n            alphas = np.linspace(0, 1, num_dashes + 1)\n\n            # This determines the length of each \"dash\"\n            full_d_alpha = 1.0 / num_dashes\n            partial_d_alpha = full_d_alpha * ps_ratio\n\n            # Rescale so that the last point of vmobject will\n            # be the end of the last dash\n            alphas /= 1 - full_d_alpha + partial_d_alpha\n\n            self.add(\n                *[\n                    vmobject.get_subcurve(alpha, alpha + partial_d_alpha)\n                    for alpha in alphas[:-1]\n                ]\n            )\n        # Family is already taken care of by get_subcurve\n        # implementation\n        self.match_style(vmobject, family=False)",
  "def get_nth_subpath(path_list, n):\n            if n >= len(path_list):\n                # Create a null path at the very end\n                return [path_list[-1][-1]] * nppcc\n            return path_list[n]",
  "class TextSetting(object):\n    def __init__(self, start, end, font, slant, weight, line_num=-1):\n        self.start = start\n        self.end = end\n        self.font = font\n        self.slant = slant\n        self.weight = weight\n        self.line_num = line_num",
  "class Text(SVGMobject):\n    CONFIG = {\n        # Mobject\n        \"color\": WHITE,\n        \"height\": None,\n        \"width\": None,\n        \"fill_opacity\": 1,\n        \"stroke_width\": 0,\n        \"should_center\": True,\n        \"unpack_groups\": True,\n        # Text\n        \"font\": \"\",\n        \"gradient\": None,\n        \"lsh\": -1,\n        \"size\": 1,\n        \"slant\": NORMAL,\n        \"weight\": NORMAL,\n        \"t2c\": {},\n        \"t2f\": {},\n        \"t2g\": {},\n        \"t2s\": {},\n        \"t2w\": {},\n        \"tab_width\": 4,\n    }\n\n    def __init__(self, text, **config):\n        self.full2short(config)\n        digest_config(self, config)\n        text_without_tabs = text\n        if text.find(\"\\t\") != -1:\n            text_without_tabs = text.replace(\"\\t\", \" \" * self.tab_width)\n        self.text = text_without_tabs\n        self.lsh = self.size if self.lsh == -1 else self.lsh\n\n        file_name = self.text2svg()\n        self.remove_last_M(file_name)\n        SVGMobject.__init__(self, file_name, **config)\n        self.apply_front_and_end_spaces()\n        self.text = text\n        self.apply_space_chars()\n\n        nppc = self.n_points_per_cubic_curve\n        for each in self:\n            if len(each.points) == 0:\n                continue\n            points = each.points\n            last = points[0]\n            each.clear_points()\n            for index, point in enumerate(points):\n                each.append_points([point])\n                if (\n                    index != len(points) - 1\n                    and (index + 1) % nppc == 0\n                    and any(point != points[index + 1])\n                ):\n                    each.add_line_to(last)\n                    last = points[index + 1]\n            each.add_line_to(last)\n\n        if self.t2c:\n            self.set_color_by_t2c()\n        if self.gradient:\n            self.set_color_by_gradient(*self.gradient)\n        if self.t2g:\n            self.set_color_by_t2g()\n\n        # anti-aliasing\n        if self.height is None and self.width is None:\n            self.scale(TEXT_MOB_SCALE_FACTOR)\n\n    def get_space_width(self):\n        size = self.size * 10\n\n        dir_name = file_writer_config[\"text_dir\"]\n        file_name = os.path.join(dir_name, \"space\") + \".svg\"\n\n        surface = cairo.SVGSurface(file_name, 600, 400)\n        context = cairo.Context(surface)\n        context.set_font_size(size)\n        context.move_to(START_X, START_Y)\n        context.select_font_face(\n            self.font, self.str2slant(self.slant), self.str2weight(self.weight)\n        )\n        context.move_to(START_X, START_Y)\n        context.show_text(\"_\")\n        surface.finish()\n        svg_with_space = SVGMobject(\n            file_name,\n            height=self.height,\n            width=self.width,\n            stroke_width=self.stroke_width,\n            should_center=self.should_center,\n            unpack_groups=self.unpack_groups,\n        )\n        space_width = svg_with_space.get_width()\n        return space_width\n\n    def apply_front_and_end_spaces(self):\n        space_width = self.get_space_width()\n        max_height = self.get_height()\n        front_spaces_count = 0\n        i = -1\n        for i in range(self.text.__len__()):\n            if self.text[i] == \" \":\n                front_spaces_count += 1\n                continue\n            else:\n                break\n        first_visible_char_index = i\n        if first_visible_char_index != 0:\n            space = Rectangle(\n                width=space_width * front_spaces_count,\n                height=max_height,\n                fill_opacity=0,\n                stroke_opacity=0,\n                stroke_width=0,\n            )\n            text_width = self.get_width()\n            space.move_to(np.array([-text_width / 2, max_height / 2, 0]))\n            self.next_to(space, direction=RIGHT, buff=0)\n            self.submobjects.insert(0, space)\n\n        i = -1\n        last_spaces_count = 0\n        for i in range(self.text.__len__() - 1, -1, -1):\n            if self.text[i] == \" \":\n                last_spaces_count += 1\n                continue\n            else:\n                break\n        last_visible_char_index = i\n        if last_visible_char_index != self.text.__len__() - 1:\n            space = Rectangle(\n                width=space_width * last_spaces_count,\n                height=max_height,\n                fill_opacity=0,\n                stroke_opacity=0,\n                stroke_width=0,\n            )\n            text_width = self.get_width()\n            space.move_to(np.array([-text_width / 2, max_height / 2, 0]))\n            self.next_to(space, direction=LEFT, buff=0)\n            self.submobjects.append(space)\n        self.move_to(np.array([0, 0, 0]))\n\n    def apply_space_chars(self):\n        char_index = 0\n        while char_index < self.text.__len__() - 1:\n            char_index += 1\n            if (\n                self.text[char_index] == \" \"\n                or self.text[char_index] == \"\\t\"\n                or self.text[char_index] == \"\\n\"\n            ):\n                space = Dot(fill_opacity=0, stroke_opacity=0)\n                space.move_to(self.submobjects[char_index - 1].get_center())\n                self.submobjects.insert(char_index, space)\n\n    def remove_last_M(self, file_name):\n        with open(file_name, \"r\") as fpr:\n            content = fpr.read()\n        content = re.sub(r'Z M [^A-Za-z]*? \"\\/>', 'Z \"/>', content)\n        with open(file_name, \"w\") as fpw:\n            fpw.write(content)\n\n    def find_indexes(self, word):\n        m = re.match(r\"\\[([0-9\\-]{0,}):([0-9\\-]{0,})\\]\", word)\n        if m:\n            start = int(m.group(1)) if m.group(1) != \"\" else 0\n            end = int(m.group(2)) if m.group(2) != \"\" else len(self.text)\n            start = len(self.text) + start if start < 0 else start\n            end = len(self.text) + end if end < 0 else end\n            return [(start, end)]\n\n        indexes = []\n        index = self.text.find(word)\n        while index != -1:\n            indexes.append((index, index + len(word)))\n            index = self.text.find(word, index + len(word))\n        return indexes\n\n    def full2short(self, config):\n        for kwargs in [config, self.CONFIG]:\n            if kwargs.__contains__(\"line_spacing_height\"):\n                kwargs[\"lsh\"] = kwargs.pop(\"line_spacing_height\")\n            if kwargs.__contains__(\"text2color\"):\n                kwargs[\"t2c\"] = kwargs.pop(\"text2color\")\n            if kwargs.__contains__(\"text2font\"):\n                kwargs[\"t2f\"] = kwargs.pop(\"text2font\")\n            if kwargs.__contains__(\"text2gradient\"):\n                kwargs[\"t2g\"] = kwargs.pop(\"text2gradient\")\n            if kwargs.__contains__(\"text2slant\"):\n                kwargs[\"t2s\"] = kwargs.pop(\"text2slant\")\n            if kwargs.__contains__(\"text2weight\"):\n                kwargs[\"t2w\"] = kwargs.pop(\"text2weight\")\n\n    def set_color_by_t2c(self, t2c=None):\n        t2c = t2c if t2c else self.t2c\n        for word, color in list(t2c.items()):\n            for start, end in self.find_indexes(word):\n                self[start:end].set_color(color)\n\n    def set_color_by_t2g(self, t2g=None):\n        t2g = t2g if t2g else self.t2g\n        for word, gradient in list(t2g.items()):\n            for start, end in self.find_indexes(word):\n                self[start:end].set_color_by_gradient(*gradient)\n\n    def str2slant(self, string):\n        if string == NORMAL:\n            return cairo.FontSlant.NORMAL\n        if string == ITALIC:\n            return cairo.FontSlant.ITALIC\n        if string == OBLIQUE:\n            return cairo.FontSlant.OBLIQUE\n\n    def str2weight(self, string):\n        if string == NORMAL:\n            return cairo.FontWeight.NORMAL\n        if string == BOLD:\n            return cairo.FontWeight.BOLD\n\n    def text2hash(self):\n        settings = self.font + self.slant + self.weight\n        settings += str(self.t2f) + str(self.t2s) + str(self.t2w)\n        settings += str(self.lsh) + str(self.size)\n        id_str = self.text + settings\n        hasher = hashlib.sha256()\n        hasher.update(id_str.encode())\n        return hasher.hexdigest()[:16]\n\n    def text2settings(self):\n        settings = []\n        t2x = [self.t2f, self.t2s, self.t2w]\n        for i in range(len(t2x)):\n            fsw = [self.font, self.slant, self.weight]\n            if t2x[i]:\n                for word, x in list(t2x[i].items()):\n                    for start, end in self.find_indexes(word):\n                        fsw[i] = x\n                        settings.append(TextSetting(start, end, *fsw))\n\n        # Set All text settings(default font slant weight)\n        fsw = [self.font, self.slant, self.weight]\n        settings.sort(key=lambda setting: setting.start)\n        temp_settings = settings.copy()\n        start = 0\n        for setting in settings:\n            if setting.start != start:\n                temp_settings.append(TextSetting(start, setting.start, *fsw))\n            start = setting.end\n        if start != len(self.text):\n            temp_settings.append(TextSetting(start, len(self.text), *fsw))\n        settings = sorted(temp_settings, key=lambda setting: setting.start)\n\n        if re.search(r\"\\n\", self.text):\n            line_num = 0\n            for start, end in self.find_indexes(\"\\n\"):\n                for setting in settings:\n                    if setting.line_num == -1:\n                        setting.line_num = line_num\n                    if start < setting.end:\n                        line_num += 1\n                        new_setting = copy.copy(setting)\n                        setting.end = end\n                        new_setting.start = end\n                        new_setting.line_num = line_num\n                        settings.append(new_setting)\n                        settings.sort(key=lambda setting: setting.start)\n                        break\n\n        for setting in settings:\n            if setting.line_num == -1:\n                setting.line_num = 0\n\n        return settings\n\n    def text2svg(self):\n        # anti-aliasing\n        size = self.size * 10\n        lsh = self.lsh * 10\n\n        if self.font == \"\":\n            if NOT_SETTING_FONT_MSG != \"\":\n                logger.warning(NOT_SETTING_FONT_MSG)\n\n        dir_name = file_writer_config[\"text_dir\"]\n        hash_name = self.text2hash()\n        file_name = os.path.join(dir_name, hash_name) + \".svg\"\n        if os.path.exists(file_name):\n            return file_name\n\n        surface = cairo.SVGSurface(file_name, 600, 400)\n        context = cairo.Context(surface)\n        context.set_font_size(size)\n        context.move_to(START_X, START_Y)\n\n        settings = self.text2settings()\n        offset_x = 0\n        last_line_num = 0\n        for setting in settings:\n            font = setting.font\n            slant = self.str2slant(setting.slant)\n            weight = self.str2weight(setting.weight)\n            text = self.text[setting.start : setting.end].replace(\"\\n\", \" \")\n\n            context.select_font_face(font, slant, weight)\n            if setting.line_num != last_line_num:\n                offset_x = 0\n                last_line_num = setting.line_num\n            context.move_to(START_X + offset_x, START_Y + lsh * setting.line_num)\n            context.show_text(text)\n            offset_x += context.text_extents(text)[4]\n\n        return file_name",
  "class TextWithFixHeight(Text):\n    def __init__(self, text, **kwargs):\n        Text.__init__(self, text, **kwargs)\n        max_height = Text(\"(gyt{[/QW\", **kwargs).get_height()\n        rectangle = Rectangle(\n            width=0, height=max_height, fill_opacity=0, stroke_opacity=0, stroke_width=0\n        )\n        self.submobjects.append(rectangle)",
  "class Paragraph(VGroup):\n    CONFIG = {\n        \"line_spacing\": 0.1,\n        \"alignment\": \"center\",\n    }\n\n    def __init__(self, *text, **config):\n        Container.__init__(self, **config)\n        self.lines_list = list(text)\n        self.lines = []\n        self.lines.append([])\n        for line_no in range(self.lines_list.__len__()):\n            if \"\\n\" in self.lines_list[line_no]:\n                self.lines_list[line_no : line_no + 1] = self.lines_list[line_no].split(\n                    \"\\n\"\n                )\n        for line_no in range(self.lines_list.__len__()):\n            self.lines[0].append(TextWithFixHeight(self.lines_list[line_no], **config))\n        self.char_height = TextWithFixHeight(\"(\", **config).get_height()\n        self.lines.append([])\n        self.lines[1].extend([self.alignment for _ in range(self.lines_list.__len__())])\n        self.lines[0][0].move_to(np.array([0, 0, 0]))\n        self.align_lines()\n        VGroup.__init__(\n            self, *[self.lines[0][i] for i in range(self.lines[0].__len__())], **config\n        )\n        self.move_to(np.array([0, 0, 0]))\n\n    def set_all_lines_alignment(self, alignment):\n        self.lines[1] = [alignment for _ in range(self.lines_list.__len__())]\n        for line_no in range(0, self.lines[0].__len__()):\n            self.change_alignment_for_a_line(alignment, line_no)\n        return self\n\n    def set_alignment(self, alignment, line_no):\n        self.change_alignment_for_a_line(alignment, line_no)\n        return self\n\n    def change_alignment_for_a_line(self, alignment, line_no):\n        self.lines[1][line_no] = alignment\n        if self.lines[1][line_no] == \"center\":\n            self[line_no].move_to(\n                self.get_top()\n                + np.array([0, -self.char_height / 2, 0])\n                + np.array([0, -line_no * (self.char_height + self.line_spacing), 0])\n            )\n        elif self.lines[1][line_no] == \"right\":\n            self[line_no].move_to(\n                self.get_top()\n                + np.array([0, -self.char_height / 2, 0])\n                + np.array(\n                    [\n                        self.get_width() / 2 - self.lines[0][line_no].get_width() / 2,\n                        -line_no * (self.char_height + self.line_spacing),\n                        0,\n                    ]\n                )\n            )\n        elif self.lines[1][line_no] == \"left\":\n            self[line_no].move_to(\n                self.get_top()\n                + np.array([0, -self.char_height / 2, 0])\n                + np.array(\n                    [\n                        -self.get_width() / 2 + self.lines[0][line_no].get_width() / 2,\n                        -line_no * (self.char_height + self.line_spacing),\n                        0,\n                    ]\n                )\n            )\n\n    def align_lines(self):\n        for line_no in range(0, self.lines[0].__len__()):\n            if self.lines[1][line_no] == \"center\":\n                self.lines[0][line_no].move_to(\n                    np.array([0, 0, 0])\n                    + np.array(\n                        [0, -line_no * (self.char_height + self.line_spacing), 0]\n                    )\n                )\n            elif self.lines[1][line_no] == \"left\":\n                self.lines[0][line_no].move_to(\n                    np.array([0, 0, 0])\n                    + np.array(\n                        [\n                            self.lines[0][line_no].get_width() / 2,\n                            -line_no * (self.char_height + self.line_spacing),\n                            0,\n                        ]\n                    )\n                )\n            elif self.lines[1][line_no] == \"right\":\n                self.lines[0][line_no].move_to(\n                    np.array([0, 0, 0])\n                    + np.array(\n                        [\n                            -self.lines[0][line_no].get_width() / 2,\n                            -line_no * (self.char_height + self.line_spacing),\n                            0,\n                        ]\n                    )\n                )",
  "def __init__(self, start, end, font, slant, weight, line_num=-1):\n        self.start = start\n        self.end = end\n        self.font = font\n        self.slant = slant\n        self.weight = weight\n        self.line_num = line_num",
  "def __init__(self, text, **config):\n        self.full2short(config)\n        digest_config(self, config)\n        text_without_tabs = text\n        if text.find(\"\\t\") != -1:\n            text_without_tabs = text.replace(\"\\t\", \" \" * self.tab_width)\n        self.text = text_without_tabs\n        self.lsh = self.size if self.lsh == -1 else self.lsh\n\n        file_name = self.text2svg()\n        self.remove_last_M(file_name)\n        SVGMobject.__init__(self, file_name, **config)\n        self.apply_front_and_end_spaces()\n        self.text = text\n        self.apply_space_chars()\n\n        nppc = self.n_points_per_cubic_curve\n        for each in self:\n            if len(each.points) == 0:\n                continue\n            points = each.points\n            last = points[0]\n            each.clear_points()\n            for index, point in enumerate(points):\n                each.append_points([point])\n                if (\n                    index != len(points) - 1\n                    and (index + 1) % nppc == 0\n                    and any(point != points[index + 1])\n                ):\n                    each.add_line_to(last)\n                    last = points[index + 1]\n            each.add_line_to(last)\n\n        if self.t2c:\n            self.set_color_by_t2c()\n        if self.gradient:\n            self.set_color_by_gradient(*self.gradient)\n        if self.t2g:\n            self.set_color_by_t2g()\n\n        # anti-aliasing\n        if self.height is None and self.width is None:\n            self.scale(TEXT_MOB_SCALE_FACTOR)",
  "def get_space_width(self):\n        size = self.size * 10\n\n        dir_name = file_writer_config[\"text_dir\"]\n        file_name = os.path.join(dir_name, \"space\") + \".svg\"\n\n        surface = cairo.SVGSurface(file_name, 600, 400)\n        context = cairo.Context(surface)\n        context.set_font_size(size)\n        context.move_to(START_X, START_Y)\n        context.select_font_face(\n            self.font, self.str2slant(self.slant), self.str2weight(self.weight)\n        )\n        context.move_to(START_X, START_Y)\n        context.show_text(\"_\")\n        surface.finish()\n        svg_with_space = SVGMobject(\n            file_name,\n            height=self.height,\n            width=self.width,\n            stroke_width=self.stroke_width,\n            should_center=self.should_center,\n            unpack_groups=self.unpack_groups,\n        )\n        space_width = svg_with_space.get_width()\n        return space_width",
  "def apply_front_and_end_spaces(self):\n        space_width = self.get_space_width()\n        max_height = self.get_height()\n        front_spaces_count = 0\n        i = -1\n        for i in range(self.text.__len__()):\n            if self.text[i] == \" \":\n                front_spaces_count += 1\n                continue\n            else:\n                break\n        first_visible_char_index = i\n        if first_visible_char_index != 0:\n            space = Rectangle(\n                width=space_width * front_spaces_count,\n                height=max_height,\n                fill_opacity=0,\n                stroke_opacity=0,\n                stroke_width=0,\n            )\n            text_width = self.get_width()\n            space.move_to(np.array([-text_width / 2, max_height / 2, 0]))\n            self.next_to(space, direction=RIGHT, buff=0)\n            self.submobjects.insert(0, space)\n\n        i = -1\n        last_spaces_count = 0\n        for i in range(self.text.__len__() - 1, -1, -1):\n            if self.text[i] == \" \":\n                last_spaces_count += 1\n                continue\n            else:\n                break\n        last_visible_char_index = i\n        if last_visible_char_index != self.text.__len__() - 1:\n            space = Rectangle(\n                width=space_width * last_spaces_count,\n                height=max_height,\n                fill_opacity=0,\n                stroke_opacity=0,\n                stroke_width=0,\n            )\n            text_width = self.get_width()\n            space.move_to(np.array([-text_width / 2, max_height / 2, 0]))\n            self.next_to(space, direction=LEFT, buff=0)\n            self.submobjects.append(space)\n        self.move_to(np.array([0, 0, 0]))",
  "def apply_space_chars(self):\n        char_index = 0\n        while char_index < self.text.__len__() - 1:\n            char_index += 1\n            if (\n                self.text[char_index] == \" \"\n                or self.text[char_index] == \"\\t\"\n                or self.text[char_index] == \"\\n\"\n            ):\n                space = Dot(fill_opacity=0, stroke_opacity=0)\n                space.move_to(self.submobjects[char_index - 1].get_center())\n                self.submobjects.insert(char_index, space)",
  "def remove_last_M(self, file_name):\n        with open(file_name, \"r\") as fpr:\n            content = fpr.read()\n        content = re.sub(r'Z M [^A-Za-z]*? \"\\/>', 'Z \"/>', content)\n        with open(file_name, \"w\") as fpw:\n            fpw.write(content)",
  "def find_indexes(self, word):\n        m = re.match(r\"\\[([0-9\\-]{0,}):([0-9\\-]{0,})\\]\", word)\n        if m:\n            start = int(m.group(1)) if m.group(1) != \"\" else 0\n            end = int(m.group(2)) if m.group(2) != \"\" else len(self.text)\n            start = len(self.text) + start if start < 0 else start\n            end = len(self.text) + end if end < 0 else end\n            return [(start, end)]\n\n        indexes = []\n        index = self.text.find(word)\n        while index != -1:\n            indexes.append((index, index + len(word)))\n            index = self.text.find(word, index + len(word))\n        return indexes",
  "def full2short(self, config):\n        for kwargs in [config, self.CONFIG]:\n            if kwargs.__contains__(\"line_spacing_height\"):\n                kwargs[\"lsh\"] = kwargs.pop(\"line_spacing_height\")\n            if kwargs.__contains__(\"text2color\"):\n                kwargs[\"t2c\"] = kwargs.pop(\"text2color\")\n            if kwargs.__contains__(\"text2font\"):\n                kwargs[\"t2f\"] = kwargs.pop(\"text2font\")\n            if kwargs.__contains__(\"text2gradient\"):\n                kwargs[\"t2g\"] = kwargs.pop(\"text2gradient\")\n            if kwargs.__contains__(\"text2slant\"):\n                kwargs[\"t2s\"] = kwargs.pop(\"text2slant\")\n            if kwargs.__contains__(\"text2weight\"):\n                kwargs[\"t2w\"] = kwargs.pop(\"text2weight\")",
  "def set_color_by_t2c(self, t2c=None):\n        t2c = t2c if t2c else self.t2c\n        for word, color in list(t2c.items()):\n            for start, end in self.find_indexes(word):\n                self[start:end].set_color(color)",
  "def set_color_by_t2g(self, t2g=None):\n        t2g = t2g if t2g else self.t2g\n        for word, gradient in list(t2g.items()):\n            for start, end in self.find_indexes(word):\n                self[start:end].set_color_by_gradient(*gradient)",
  "def str2slant(self, string):\n        if string == NORMAL:\n            return cairo.FontSlant.NORMAL\n        if string == ITALIC:\n            return cairo.FontSlant.ITALIC\n        if string == OBLIQUE:\n            return cairo.FontSlant.OBLIQUE",
  "def str2weight(self, string):\n        if string == NORMAL:\n            return cairo.FontWeight.NORMAL\n        if string == BOLD:\n            return cairo.FontWeight.BOLD",
  "def text2hash(self):\n        settings = self.font + self.slant + self.weight\n        settings += str(self.t2f) + str(self.t2s) + str(self.t2w)\n        settings += str(self.lsh) + str(self.size)\n        id_str = self.text + settings\n        hasher = hashlib.sha256()\n        hasher.update(id_str.encode())\n        return hasher.hexdigest()[:16]",
  "def text2settings(self):\n        settings = []\n        t2x = [self.t2f, self.t2s, self.t2w]\n        for i in range(len(t2x)):\n            fsw = [self.font, self.slant, self.weight]\n            if t2x[i]:\n                for word, x in list(t2x[i].items()):\n                    for start, end in self.find_indexes(word):\n                        fsw[i] = x\n                        settings.append(TextSetting(start, end, *fsw))\n\n        # Set All text settings(default font slant weight)\n        fsw = [self.font, self.slant, self.weight]\n        settings.sort(key=lambda setting: setting.start)\n        temp_settings = settings.copy()\n        start = 0\n        for setting in settings:\n            if setting.start != start:\n                temp_settings.append(TextSetting(start, setting.start, *fsw))\n            start = setting.end\n        if start != len(self.text):\n            temp_settings.append(TextSetting(start, len(self.text), *fsw))\n        settings = sorted(temp_settings, key=lambda setting: setting.start)\n\n        if re.search(r\"\\n\", self.text):\n            line_num = 0\n            for start, end in self.find_indexes(\"\\n\"):\n                for setting in settings:\n                    if setting.line_num == -1:\n                        setting.line_num = line_num\n                    if start < setting.end:\n                        line_num += 1\n                        new_setting = copy.copy(setting)\n                        setting.end = end\n                        new_setting.start = end\n                        new_setting.line_num = line_num\n                        settings.append(new_setting)\n                        settings.sort(key=lambda setting: setting.start)\n                        break\n\n        for setting in settings:\n            if setting.line_num == -1:\n                setting.line_num = 0\n\n        return settings",
  "def text2svg(self):\n        # anti-aliasing\n        size = self.size * 10\n        lsh = self.lsh * 10\n\n        if self.font == \"\":\n            if NOT_SETTING_FONT_MSG != \"\":\n                logger.warning(NOT_SETTING_FONT_MSG)\n\n        dir_name = file_writer_config[\"text_dir\"]\n        hash_name = self.text2hash()\n        file_name = os.path.join(dir_name, hash_name) + \".svg\"\n        if os.path.exists(file_name):\n            return file_name\n\n        surface = cairo.SVGSurface(file_name, 600, 400)\n        context = cairo.Context(surface)\n        context.set_font_size(size)\n        context.move_to(START_X, START_Y)\n\n        settings = self.text2settings()\n        offset_x = 0\n        last_line_num = 0\n        for setting in settings:\n            font = setting.font\n            slant = self.str2slant(setting.slant)\n            weight = self.str2weight(setting.weight)\n            text = self.text[setting.start : setting.end].replace(\"\\n\", \" \")\n\n            context.select_font_face(font, slant, weight)\n            if setting.line_num != last_line_num:\n                offset_x = 0\n                last_line_num = setting.line_num\n            context.move_to(START_X + offset_x, START_Y + lsh * setting.line_num)\n            context.show_text(text)\n            offset_x += context.text_extents(text)[4]\n\n        return file_name",
  "def __init__(self, text, **kwargs):\n        Text.__init__(self, text, **kwargs)\n        max_height = Text(\"(gyt{[/QW\", **kwargs).get_height()\n        rectangle = Rectangle(\n            width=0, height=max_height, fill_opacity=0, stroke_opacity=0, stroke_width=0\n        )\n        self.submobjects.append(rectangle)",
  "def __init__(self, *text, **config):\n        Container.__init__(self, **config)\n        self.lines_list = list(text)\n        self.lines = []\n        self.lines.append([])\n        for line_no in range(self.lines_list.__len__()):\n            if \"\\n\" in self.lines_list[line_no]:\n                self.lines_list[line_no : line_no + 1] = self.lines_list[line_no].split(\n                    \"\\n\"\n                )\n        for line_no in range(self.lines_list.__len__()):\n            self.lines[0].append(TextWithFixHeight(self.lines_list[line_no], **config))\n        self.char_height = TextWithFixHeight(\"(\", **config).get_height()\n        self.lines.append([])\n        self.lines[1].extend([self.alignment for _ in range(self.lines_list.__len__())])\n        self.lines[0][0].move_to(np.array([0, 0, 0]))\n        self.align_lines()\n        VGroup.__init__(\n            self, *[self.lines[0][i] for i in range(self.lines[0].__len__())], **config\n        )\n        self.move_to(np.array([0, 0, 0]))",
  "def set_all_lines_alignment(self, alignment):\n        self.lines[1] = [alignment for _ in range(self.lines_list.__len__())]\n        for line_no in range(0, self.lines[0].__len__()):\n            self.change_alignment_for_a_line(alignment, line_no)\n        return self",
  "def set_alignment(self, alignment, line_no):\n        self.change_alignment_for_a_line(alignment, line_no)\n        return self",
  "def change_alignment_for_a_line(self, alignment, line_no):\n        self.lines[1][line_no] = alignment\n        if self.lines[1][line_no] == \"center\":\n            self[line_no].move_to(\n                self.get_top()\n                + np.array([0, -self.char_height / 2, 0])\n                + np.array([0, -line_no * (self.char_height + self.line_spacing), 0])\n            )\n        elif self.lines[1][line_no] == \"right\":\n            self[line_no].move_to(\n                self.get_top()\n                + np.array([0, -self.char_height / 2, 0])\n                + np.array(\n                    [\n                        self.get_width() / 2 - self.lines[0][line_no].get_width() / 2,\n                        -line_no * (self.char_height + self.line_spacing),\n                        0,\n                    ]\n                )\n            )\n        elif self.lines[1][line_no] == \"left\":\n            self[line_no].move_to(\n                self.get_top()\n                + np.array([0, -self.char_height / 2, 0])\n                + np.array(\n                    [\n                        -self.get_width() / 2 + self.lines[0][line_no].get_width() / 2,\n                        -line_no * (self.char_height + self.line_spacing),\n                        0,\n                    ]\n                )\n            )",
  "def align_lines(self):\n        for line_no in range(0, self.lines[0].__len__()):\n            if self.lines[1][line_no] == \"center\":\n                self.lines[0][line_no].move_to(\n                    np.array([0, 0, 0])\n                    + np.array(\n                        [0, -line_no * (self.char_height + self.line_spacing), 0]\n                    )\n                )\n            elif self.lines[1][line_no] == \"left\":\n                self.lines[0][line_no].move_to(\n                    np.array([0, 0, 0])\n                    + np.array(\n                        [\n                            self.lines[0][line_no].get_width() / 2,\n                            -line_no * (self.char_height + self.line_spacing),\n                            0,\n                        ]\n                    )\n                )\n            elif self.lines[1][line_no] == \"right\":\n                self.lines[0][line_no].move_to(\n                    np.array([0, 0, 0])\n                    + np.array(\n                        [\n                            -self.lines[0][line_no].get_width() / 2,\n                            -line_no * (self.char_height + self.line_spacing),\n                            0,\n                        ]\n                    )\n                )",
  "class Code(VGroup):\n    CONFIG = {\n        \"tab_width\": 3,\n        \"line_spacing\": 0.1,\n        \"scale_factor\": 0.5,\n        \"run_time\": 1,\n        \"font\": \"Monospac821 BT\",\n        \"stroke_width\": 0,\n        \"margin\": 0.3,\n        \"indentation_char\": \"  \",\n        \"background\": \"rectangle\",  # or window\n        \"corner_radius\": 0.2,\n        \"insert_line_no\": True,\n        \"line_no_from\": 1,\n        \"line_no_buff\": 0.4,\n        \"style\": \"vim\",\n        \"language\": \"cpp\",\n        \"generate_html_file\": False,\n    }\n\n    def __init__(self, file_name=None, **kwargs):\n        Container.__init__(self, **kwargs)\n        self.file_name = file_name or self.file_name\n        self.ensure_valid_file()\n        self.style = self.style.lower()\n        self.gen_html_string()\n        strati = self.html_string.find(\"background:\")\n        self.background_color = self.html_string[strati + 12 : strati + 19]\n        self.gen_code_json()\n\n        self.code = self.gen_colored_lines()\n        if self.insert_line_no:\n            self.line_numbers = self.gen_line_numbers()\n            self.line_numbers.next_to(self.code, direction=LEFT, buff=self.line_no_buff)\n\n        if self.background == \"rectangle\":\n            if self.insert_line_no:\n                forground = VGroup(self.code, self.line_numbers)\n            else:\n                forground = self.code\n            self.background_mobject = SurroundingRectangle(\n                forground,\n                buff=self.margin,\n                color=self.background_color,\n                fill_color=self.background_color,\n                stroke_width=0,\n                fill_opacity=1,\n            )\n            self.background_mobject.round_corners(self.corner_radius)\n        else:\n            if self.insert_line_no:\n                forground = VGroup(self.code, self.line_numbers)\n            else:\n                forground = self.code\n\n            height = forground.get_height() + 0.1 * 3 + 2 * self.margin\n            width = forground.get_width() + 0.1 * 3 + 2 * self.margin\n\n            rrect = RoundedRectangle(\n                corner_radius=self.corner_radius,\n                height=height,\n                width=width,\n                stroke_width=0,\n                color=self.background_color,\n                fill_opacity=1,\n            )\n            red_button = Dot(radius=0.1, stroke_width=0, color=\"#ff5f56\")\n            red_button.shift(LEFT * 0.1 * 3)\n            yellow_button = Dot(radius=0.1, stroke_width=0, color=\"#ffbd2e\")\n            green_button = Dot(radius=0.1, stroke_width=0, color=\"#27c93f\")\n            green_button.shift(RIGHT * 0.1 * 3)\n            buttons = VGroup(red_button, yellow_button, green_button)\n            buttons.shift(\n                UP * (height / 2 - 0.1 * 2 - 0.05)\n                + LEFT * (width / 2 - 0.1 * 5 - self.corner_radius / 2 - 0.05)\n            )\n\n            self.background_mobject = VGroup(rrect, buttons)\n            x = (height - forground.get_height()) / 2 - 0.1 * 3\n            self.background_mobject.shift(forground.get_center())\n            self.background_mobject.shift(UP * x)\n\n        if self.insert_line_no:\n            VGroup.__init__(\n                self, self.background_mobject, self.line_numbers, *self.code, **kwargs\n            )\n        else:\n            VGroup.__init__(\n                self,\n                self.background_mobject,\n                Dot(fill_opacity=0, stroke_opacity=0),\n                *self.code,\n                **kwargs,\n            )\n\n        self.move_to(np.array([0, 0, 0]))\n\n    def apply_points_function_about_point(\n        self, func, about_point=None, about_edge=None\n    ):\n        if about_point is None:\n            if about_edge is None:\n                about_edge = self.get_corner(UP + LEFT)\n            about_point = self.get_critical_point(about_edge)\n        for mob in self.family_members_with_points():\n            mob.points -= about_point\n            mob.points = func(mob.points)\n            mob.points += about_point\n        return self\n\n    def ensure_valid_file(self):\n        if self.file_name is None:\n            raise Exception(\"Must specify file for Code\")\n        possible_paths = [\n            os.path.join(os.path.join(\"assets\", \"codes\"), self.file_name),\n            self.file_name,\n        ]\n        for path in possible_paths:\n            if os.path.exists(path):\n                self.file_path = path\n                return\n        raise IOError(\"No file matching %s in codes directory\" % self.file_name)\n\n    def gen_line_numbers(self):\n        line_numbers_array = []\n        for line_no in range(0, self.code_json.__len__()):\n            number = str(self.line_no_from + line_no)\n            line_numbers_array.append(number)\n        line_numbers = Paragraph(\n            *[i for i in line_numbers_array],\n            line_spacing=self.line_spacing,\n            alignment=\"right\",\n            font=self.font,\n            stroke_width=self.stroke_width,\n        ).scale(self.scale_factor)\n        return line_numbers\n\n    def gen_colored_lines(self):\n        lines_text = []\n        for line_no in range(0, self.code_json.__len__()):\n            line_str = \"\"\n            for word_index in range(self.code_json[line_no].__len__()):\n                line_str = line_str + self.code_json[line_no][word_index][0]\n            lines_text.append(self.tab_spaces[line_no] * \"\\t\" + line_str)\n        code = Paragraph(\n            *[i for i in lines_text],\n            line_spacing=self.line_spacing,\n            tab_width=self.tab_width,\n            alignment=\"left\",\n            font=self.font,\n            stroke_width=self.stroke_width,\n        ).scale(self.scale_factor)\n        for line_no in range(code.__len__()):\n            line = code[line_no]\n            line_char_index = self.tab_spaces[line_no]\n            for word_index in range(self.code_json[line_no].__len__()):\n                line[\n                    line_char_index : line_char_index\n                    + self.code_json[line_no][word_index][0].__len__()\n                ].set_color(self.code_json[line_no][word_index][1])\n                line_char_index += self.code_json[line_no][word_index][0].__len__()\n        return code\n\n    def gen_html_string(self):\n        file = open(self.file_path, \"r\")\n        code_str = file.read()\n        file.close()\n        self.html_string = hilite_me(\n            code_str,\n            self.language,\n            {},\n            self.style,\n            self.insert_line_no,\n            \"border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\",\n        )\n        if self.generate_html_file:\n            os.makedirs(\n                os.path.join(\"assets\", \"codes\", \"generated_html_files\"), exist_ok=True\n            )\n            file = open(\n                os.path.join(\n                    \"assets\", \"codes\", \"generated_html_files\", self.file_name + \".html\"\n                ),\n                \"w\",\n            )\n            file.write(self.html_string)\n            file.close()\n\n    def gen_code_json(self):\n        if (\n            self.background_color == \"#111111\"\n            or self.background_color == \"#272822\"\n            or self.background_color == \"#202020\"\n            or self.background_color == \"#000000\"\n        ):\n            self.default_color = \"#ffffff\"\n        else:\n            self.default_color = \"#000000\"\n        for i in range(3, -1, -1):\n            self.html_string = self.html_string.replace(\"</\" + \" \" * i, \"</\")\n        for i in range(10, -1, -1):\n            self.html_string = self.html_string.replace(\n                \"</span>\" + \" \" * i, \" \" * i + \"</span>\"\n            )\n        self.html_string = self.html_string.replace(\"background-color:\", \"background:\")\n\n        if self.insert_line_no:\n            start_point = self.html_string.find(\"</td><td><pre\")\n            start_point = start_point + 9\n        else:\n            start_point = self.html_string.find(\"<pre\")\n        self.html_string = self.html_string[start_point:]\n        # print(self.html_string)\n        lines = self.html_string.split(\"\\n\")\n        lines = lines[0 : lines.__len__() - 2]\n        start_point = lines[0].find(\">\")\n        lines[0] = lines[0][start_point + 1 :]\n        # print(lines)\n        self.code_json = []\n        self.tab_spaces = []\n        code_json_line_index = -1\n        for line_index in range(0, lines.__len__()):\n            if lines[line_index].__len__() == 0:\n                continue\n            # print(lines[line_index])\n            self.code_json.append([])\n            code_json_line_index = code_json_line_index + 1\n            if lines[line_index].startswith(self.indentation_char):\n                start_point = lines[line_index].find(\"<\")\n                starting_string = lines[line_index][:start_point]\n                indentation_char_count = lines[line_index][:start_point].count(\n                    self.indentation_char\n                )\n                if (\n                    starting_string.__len__()\n                    != indentation_char_count * self.indentation_char.__len__()\n                ):\n                    lines[line_index] = (\n                        \"\\t\" * indentation_char_count\n                        + starting_string[\n                            starting_string.rfind(self.indentation_char)\n                            + self.indentation_char.__len__() :\n                        ]\n                        + lines[line_index][start_point:]\n                    )\n                else:\n                    lines[line_index] = (\n                        \"\\t\" * indentation_char_count + lines[line_index][start_point:]\n                    )\n\n            indentation_char_count = 0\n            while lines[line_index][indentation_char_count] == \"\\t\":\n                indentation_char_count = indentation_char_count + 1\n            self.tab_spaces.append(indentation_char_count)\n            # print(lines[line_index])\n            lines[line_index] = self.correct_non_span(lines[line_index])\n            # print(lines[line_index])\n            words = lines[line_index].split(\"<span\")\n            for word_index in range(1, words.__len__()):\n                color_index = words[word_index].find(\"color:\")\n                if color_index == -1:\n                    color = self.default_color\n                else:\n                    starti = words[word_index][color_index:].find(\"#\")\n                    color = words[word_index][\n                        color_index + starti : color_index + starti + 7\n                    ]\n\n                start_point = words[word_index].find(\">\")\n                end_point = words[word_index].find(\"</span>\")\n                text = words[word_index][start_point + 1 : end_point]\n                text = html.unescape(text)\n                if text != \"\":\n                    # print(text, \"'\" + color + \"'\")\n                    self.code_json[code_json_line_index].append([text, color])\n        # print(self.code_json)\n\n    def correct_non_span(self, line_str):\n        words = line_str.split(\"</span>\")\n        line_str = \"\"\n        for i in range(0, words.__len__()):\n            if i != words.__len__() - 1:\n                j = words[i].find(\"<span\")\n            else:\n                j = words[i].__len__()\n            temp = \"\"\n            starti = -1\n            for k in range(0, j):\n                if words[i][k] == \"\\t\" and starti == -1:\n                    continue\n                else:\n                    if starti == -1:\n                        starti = k\n                    temp = temp + words[i][k]\n            if temp != \"\":\n                if i != words.__len__() - 1:\n                    temp = (\n                        '<span style=\"color:'\n                        + self.default_color\n                        + '\">'\n                        + words[i][starti:j]\n                        + \"</span>\"\n                    )\n                else:\n                    temp = (\n                        '<span style=\"color:'\n                        + self.default_color\n                        + '\">'\n                        + words[i][starti:j]\n                    )\n                temp = temp + words[i][j:]\n                words[i] = temp\n            if words[i] != \"\":\n                line_str = line_str + words[i] + \"</span>\"\n        return line_str",
  "def hilite_me(code, lexer, options, style, linenos, divstyles):\n    lexer = lexer or \"python\"\n    style = style or \"colorful\"\n    defstyles = \"overflow:auto;width:auto;\"\n\n    formatter = HtmlFormatter(\n        style=style,\n        linenos=False,\n        noclasses=True,\n        cssclass=\"\",\n        cssstyles=defstyles + divstyles,\n        prestyles=\"margin: 0\",\n    )\n    html = highlight(code, get_lexer_by_name(lexer, **options), formatter)\n    if linenos:\n        html = insert_line_numbers(html)\n    html = \"<!-- HTML generated using hilite.me -->\" + html\n    return html",
  "def get_default_style():\n    return \"border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\"",
  "def insert_line_numbers(html):\n    match = re.search(\"(<pre[^>]*>)(.*)(</pre>)\", html, re.DOTALL)\n    if not match:\n        return html\n\n    pre_open = match.group(1)\n    pre = match.group(2)\n    pre_close = match.group(3)\n\n    html = html.replace(pre_close, \"</pre></td></tr></table>\")\n    numbers = range(1, pre.count(\"\\n\") + 1)\n    format = \"%\" + str(len(str(numbers[-1]))) + \"i\"\n    lines = \"\\n\".join(format % i for i in numbers)\n    html = html.replace(\n        pre_open, \"<table><tr><td>\" + pre_open + lines + \"</pre></td><td>\" + pre_open\n    )\n    return html",
  "def __init__(self, file_name=None, **kwargs):\n        Container.__init__(self, **kwargs)\n        self.file_name = file_name or self.file_name\n        self.ensure_valid_file()\n        self.style = self.style.lower()\n        self.gen_html_string()\n        strati = self.html_string.find(\"background:\")\n        self.background_color = self.html_string[strati + 12 : strati + 19]\n        self.gen_code_json()\n\n        self.code = self.gen_colored_lines()\n        if self.insert_line_no:\n            self.line_numbers = self.gen_line_numbers()\n            self.line_numbers.next_to(self.code, direction=LEFT, buff=self.line_no_buff)\n\n        if self.background == \"rectangle\":\n            if self.insert_line_no:\n                forground = VGroup(self.code, self.line_numbers)\n            else:\n                forground = self.code\n            self.background_mobject = SurroundingRectangle(\n                forground,\n                buff=self.margin,\n                color=self.background_color,\n                fill_color=self.background_color,\n                stroke_width=0,\n                fill_opacity=1,\n            )\n            self.background_mobject.round_corners(self.corner_radius)\n        else:\n            if self.insert_line_no:\n                forground = VGroup(self.code, self.line_numbers)\n            else:\n                forground = self.code\n\n            height = forground.get_height() + 0.1 * 3 + 2 * self.margin\n            width = forground.get_width() + 0.1 * 3 + 2 * self.margin\n\n            rrect = RoundedRectangle(\n                corner_radius=self.corner_radius,\n                height=height,\n                width=width,\n                stroke_width=0,\n                color=self.background_color,\n                fill_opacity=1,\n            )\n            red_button = Dot(radius=0.1, stroke_width=0, color=\"#ff5f56\")\n            red_button.shift(LEFT * 0.1 * 3)\n            yellow_button = Dot(radius=0.1, stroke_width=0, color=\"#ffbd2e\")\n            green_button = Dot(radius=0.1, stroke_width=0, color=\"#27c93f\")\n            green_button.shift(RIGHT * 0.1 * 3)\n            buttons = VGroup(red_button, yellow_button, green_button)\n            buttons.shift(\n                UP * (height / 2 - 0.1 * 2 - 0.05)\n                + LEFT * (width / 2 - 0.1 * 5 - self.corner_radius / 2 - 0.05)\n            )\n\n            self.background_mobject = VGroup(rrect, buttons)\n            x = (height - forground.get_height()) / 2 - 0.1 * 3\n            self.background_mobject.shift(forground.get_center())\n            self.background_mobject.shift(UP * x)\n\n        if self.insert_line_no:\n            VGroup.__init__(\n                self, self.background_mobject, self.line_numbers, *self.code, **kwargs\n            )\n        else:\n            VGroup.__init__(\n                self,\n                self.background_mobject,\n                Dot(fill_opacity=0, stroke_opacity=0),\n                *self.code,\n                **kwargs,\n            )\n\n        self.move_to(np.array([0, 0, 0]))",
  "def apply_points_function_about_point(\n        self, func, about_point=None, about_edge=None\n    ):\n        if about_point is None:\n            if about_edge is None:\n                about_edge = self.get_corner(UP + LEFT)\n            about_point = self.get_critical_point(about_edge)\n        for mob in self.family_members_with_points():\n            mob.points -= about_point\n            mob.points = func(mob.points)\n            mob.points += about_point\n        return self",
  "def ensure_valid_file(self):\n        if self.file_name is None:\n            raise Exception(\"Must specify file for Code\")\n        possible_paths = [\n            os.path.join(os.path.join(\"assets\", \"codes\"), self.file_name),\n            self.file_name,\n        ]\n        for path in possible_paths:\n            if os.path.exists(path):\n                self.file_path = path\n                return\n        raise IOError(\"No file matching %s in codes directory\" % self.file_name)",
  "def gen_line_numbers(self):\n        line_numbers_array = []\n        for line_no in range(0, self.code_json.__len__()):\n            number = str(self.line_no_from + line_no)\n            line_numbers_array.append(number)\n        line_numbers = Paragraph(\n            *[i for i in line_numbers_array],\n            line_spacing=self.line_spacing,\n            alignment=\"right\",\n            font=self.font,\n            stroke_width=self.stroke_width,\n        ).scale(self.scale_factor)\n        return line_numbers",
  "def gen_colored_lines(self):\n        lines_text = []\n        for line_no in range(0, self.code_json.__len__()):\n            line_str = \"\"\n            for word_index in range(self.code_json[line_no].__len__()):\n                line_str = line_str + self.code_json[line_no][word_index][0]\n            lines_text.append(self.tab_spaces[line_no] * \"\\t\" + line_str)\n        code = Paragraph(\n            *[i for i in lines_text],\n            line_spacing=self.line_spacing,\n            tab_width=self.tab_width,\n            alignment=\"left\",\n            font=self.font,\n            stroke_width=self.stroke_width,\n        ).scale(self.scale_factor)\n        for line_no in range(code.__len__()):\n            line = code[line_no]\n            line_char_index = self.tab_spaces[line_no]\n            for word_index in range(self.code_json[line_no].__len__()):\n                line[\n                    line_char_index : line_char_index\n                    + self.code_json[line_no][word_index][0].__len__()\n                ].set_color(self.code_json[line_no][word_index][1])\n                line_char_index += self.code_json[line_no][word_index][0].__len__()\n        return code",
  "def gen_html_string(self):\n        file = open(self.file_path, \"r\")\n        code_str = file.read()\n        file.close()\n        self.html_string = hilite_me(\n            code_str,\n            self.language,\n            {},\n            self.style,\n            self.insert_line_no,\n            \"border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\",\n        )\n        if self.generate_html_file:\n            os.makedirs(\n                os.path.join(\"assets\", \"codes\", \"generated_html_files\"), exist_ok=True\n            )\n            file = open(\n                os.path.join(\n                    \"assets\", \"codes\", \"generated_html_files\", self.file_name + \".html\"\n                ),\n                \"w\",\n            )\n            file.write(self.html_string)\n            file.close()",
  "def gen_code_json(self):\n        if (\n            self.background_color == \"#111111\"\n            or self.background_color == \"#272822\"\n            or self.background_color == \"#202020\"\n            or self.background_color == \"#000000\"\n        ):\n            self.default_color = \"#ffffff\"\n        else:\n            self.default_color = \"#000000\"\n        for i in range(3, -1, -1):\n            self.html_string = self.html_string.replace(\"</\" + \" \" * i, \"</\")\n        for i in range(10, -1, -1):\n            self.html_string = self.html_string.replace(\n                \"</span>\" + \" \" * i, \" \" * i + \"</span>\"\n            )\n        self.html_string = self.html_string.replace(\"background-color:\", \"background:\")\n\n        if self.insert_line_no:\n            start_point = self.html_string.find(\"</td><td><pre\")\n            start_point = start_point + 9\n        else:\n            start_point = self.html_string.find(\"<pre\")\n        self.html_string = self.html_string[start_point:]\n        # print(self.html_string)\n        lines = self.html_string.split(\"\\n\")\n        lines = lines[0 : lines.__len__() - 2]\n        start_point = lines[0].find(\">\")\n        lines[0] = lines[0][start_point + 1 :]\n        # print(lines)\n        self.code_json = []\n        self.tab_spaces = []\n        code_json_line_index = -1\n        for line_index in range(0, lines.__len__()):\n            if lines[line_index].__len__() == 0:\n                continue\n            # print(lines[line_index])\n            self.code_json.append([])\n            code_json_line_index = code_json_line_index + 1\n            if lines[line_index].startswith(self.indentation_char):\n                start_point = lines[line_index].find(\"<\")\n                starting_string = lines[line_index][:start_point]\n                indentation_char_count = lines[line_index][:start_point].count(\n                    self.indentation_char\n                )\n                if (\n                    starting_string.__len__()\n                    != indentation_char_count * self.indentation_char.__len__()\n                ):\n                    lines[line_index] = (\n                        \"\\t\" * indentation_char_count\n                        + starting_string[\n                            starting_string.rfind(self.indentation_char)\n                            + self.indentation_char.__len__() :\n                        ]\n                        + lines[line_index][start_point:]\n                    )\n                else:\n                    lines[line_index] = (\n                        \"\\t\" * indentation_char_count + lines[line_index][start_point:]\n                    )\n\n            indentation_char_count = 0\n            while lines[line_index][indentation_char_count] == \"\\t\":\n                indentation_char_count = indentation_char_count + 1\n            self.tab_spaces.append(indentation_char_count)\n            # print(lines[line_index])\n            lines[line_index] = self.correct_non_span(lines[line_index])\n            # print(lines[line_index])\n            words = lines[line_index].split(\"<span\")\n            for word_index in range(1, words.__len__()):\n                color_index = words[word_index].find(\"color:\")\n                if color_index == -1:\n                    color = self.default_color\n                else:\n                    starti = words[word_index][color_index:].find(\"#\")\n                    color = words[word_index][\n                        color_index + starti : color_index + starti + 7\n                    ]\n\n                start_point = words[word_index].find(\">\")\n                end_point = words[word_index].find(\"</span>\")\n                text = words[word_index][start_point + 1 : end_point]\n                text = html.unescape(text)\n                if text != \"\":\n                    # print(text, \"'\" + color + \"'\")\n                    self.code_json[code_json_line_index].append([text, color])",
  "def correct_non_span(self, line_str):\n        words = line_str.split(\"</span>\")\n        line_str = \"\"\n        for i in range(0, words.__len__()):\n            if i != words.__len__() - 1:\n                j = words[i].find(\"<span\")\n            else:\n                j = words[i].__len__()\n            temp = \"\"\n            starti = -1\n            for k in range(0, j):\n                if words[i][k] == \"\\t\" and starti == -1:\n                    continue\n                else:\n                    if starti == -1:\n                        starti = k\n                    temp = temp + words[i][k]\n            if temp != \"\":\n                if i != words.__len__() - 1:\n                    temp = (\n                        '<span style=\"color:'\n                        + self.default_color\n                        + '\">'\n                        + words[i][starti:j]\n                        + \"</span>\"\n                    )\n                else:\n                    temp = (\n                        '<span style=\"color:'\n                        + self.default_color\n                        + '\">'\n                        + words[i][starti:j]\n                    )\n                temp = temp + words[i][j:]\n                words[i] = temp\n            if words[i] != \"\":\n                line_str = line_str + words[i] + \"</span>\"\n        return line_str",
  "class TexSymbol(VMobjectFromSVGPathstring):\n    \"\"\"Purely a renaming of VMobjectFromSVGPathstring.\"\"\"\n\n    pass",
  "class SingleStringTexMobject(SVGMobject):\n    CONFIG = {\n        \"stroke_width\": 0,\n        \"fill_opacity\": 1.0,\n        \"background_stroke_width\": 1,\n        \"background_stroke_color\": BLACK,\n        \"should_center\": True,\n        \"height\": None,\n        \"organize_left_to_right\": False,\n        \"alignment\": \"\",\n        \"type\": \"tex\",\n    }\n\n    def __init__(self, tex_string, **kwargs):\n        digest_config(self, kwargs)\n        assert isinstance(tex_string, str)\n        self.tex_string = tex_string\n        file_name = tex_to_svg_file(self.get_modified_expression(tex_string), self.type)\n        SVGMobject.__init__(self, file_name=file_name, **kwargs)\n        if self.height is None:\n            self.scale(TEX_MOB_SCALE_FACTOR)\n        if self.organize_left_to_right:\n            self.organize_submobjects_left_to_right()\n\n    def get_modified_expression(self, tex_string):\n        result = self.alignment + \" \" + tex_string\n        result = result.strip()\n        result = self.modify_special_strings(result)\n        return result\n\n    def modify_special_strings(self, tex):\n        tex = self.remove_stray_braces(tex)\n        should_add_filler = reduce(\n            op.or_,\n            [\n                # Fraction line needs something to be over\n                tex == \"\\\\over\",\n                tex == \"\\\\overline\",\n                # Makesure sqrt has overbar\n                tex == \"\\\\sqrt\",\n                # Need to add blank subscript or superscript\n                tex.endswith(\"_\"),\n                tex.endswith(\"^\"),\n                tex.endswith(\"dot\"),\n            ],\n        )\n        if should_add_filler:\n            filler = \"{\\\\quad}\"\n            tex += filler\n\n        if tex == \"\\\\substack\":\n            tex = \"\\\\quad\"\n\n        if tex == \"\":\n            tex = \"\\\\quad\"\n\n        # To keep files from starting with a line break\n        if tex.startswith(\"\\\\\\\\\"):\n            tex = tex.replace(\"\\\\\\\\\", \"\\\\quad\\\\\\\\\")\n\n        # Handle imbalanced \\left and \\right\n        num_lefts, num_rights = [\n            len([s for s in tex.split(substr)[1:] if s and s[0] in \"(){}[]|.\\\\\"])\n            for substr in (\"\\\\left\", \"\\\\right\")\n        ]\n        if num_lefts != num_rights:\n            tex = tex.replace(\"\\\\left\", \"\\\\big\")\n            tex = tex.replace(\"\\\\right\", \"\\\\big\")\n\n        for context in [\"array\"]:\n            begin_in = (\"\\\\begin{%s}\" % context) in tex\n            end_in = (\"\\\\end{%s}\" % context) in tex\n            if begin_in ^ end_in:\n                # Just turn this into a blank string,\n                # which means caller should leave a\n                # stray \\\\begin{...} with other symbols\n                tex = \"\"\n        return tex\n\n    def remove_stray_braces(self, tex):\n        \"\"\"\n        Makes TexMobject resiliant to unmatched { at start\n        \"\"\"\n        num_lefts, num_rights = [tex.count(char) for char in \"{}\"]\n        while num_rights > num_lefts:\n            tex = \"{\" + tex\n            num_lefts += 1\n        while num_lefts > num_rights:\n            tex = tex + \"}\"\n            num_rights += 1\n        return tex\n\n    def get_tex_string(self):\n        return self.tex_string\n\n    def path_string_to_mobject(self, path_string):\n        # Overwrite superclass default to use\n        # specialized path_string mobject\n        return TexSymbol(path_string)\n\n    def organize_submobjects_left_to_right(self):\n        self.sort(lambda p: p[0])\n        return self",
  "class TexMobject(SingleStringTexMobject):\n    CONFIG = {\n        \"arg_separator\": \" \",\n        \"substrings_to_isolate\": [],\n        \"tex_to_color_map\": {},\n    }\n\n    def __init__(self, *tex_strings, **kwargs):\n        digest_config(self, kwargs)\n        tex_strings = self.break_up_tex_strings(tex_strings)\n        self.tex_strings = tex_strings\n        SingleStringTexMobject.__init__(\n            self, self.arg_separator.join(tex_strings), **kwargs\n        )\n        self.break_up_by_substrings()\n        self.set_color_by_tex_to_color_map(self.tex_to_color_map)\n\n        if self.organize_left_to_right:\n            self.organize_submobjects_left_to_right()\n\n    def break_up_tex_strings(self, tex_strings):\n        substrings_to_isolate = op.add(\n            self.substrings_to_isolate, list(self.tex_to_color_map.keys())\n        )\n        split_list = split_string_list_to_isolate_substrings(\n            tex_strings, *substrings_to_isolate\n        )\n        if self.arg_separator == \" \":\n            split_list = [str(x).strip() for x in split_list]\n        # split_list = list(map(str.strip, split_list))\n        split_list = [s for s in split_list if s != \"\"]\n        return split_list\n\n    def break_up_by_substrings(self):\n        \"\"\"\n        Reorganize existing submojects one layer\n        deeper based on the structure of tex_strings (as a list\n        of tex_strings)\n        \"\"\"\n        new_submobjects = []\n        curr_index = 0\n        config = dict(self.CONFIG)\n        config[\"alignment\"] = \"\"\n        for tex_string in self.tex_strings:\n            sub_tex_mob = SingleStringTexMobject(tex_string, **config)\n            num_submobs = len(sub_tex_mob.submobjects)\n            new_index = curr_index + num_submobs\n            if num_submobs == 0:\n                # For cases like empty tex_strings, we want the corresponing\n                # part of the whole TexMobject to be a VectorizedPoint\n                # positioned in the right part of the TexMobject\n                sub_tex_mob.submobjects = [VectorizedPoint()]\n                last_submob_index = min(curr_index, len(self.submobjects) - 1)\n                sub_tex_mob.move_to(self.submobjects[last_submob_index], RIGHT)\n            else:\n                sub_tex_mob.submobjects = self.submobjects[curr_index:new_index]\n            new_submobjects.append(sub_tex_mob)\n            curr_index = new_index\n        self.submobjects = new_submobjects\n        return self\n\n    def get_parts_by_tex(self, tex, substring=True, case_sensitive=True):\n        def test(tex1, tex2):\n            if not case_sensitive:\n                tex1 = tex1.lower()\n                tex2 = tex2.lower()\n            if substring:\n                return tex1 in tex2\n            else:\n                return tex1 == tex2\n\n        return VGroup(*[m for m in self.submobjects if test(tex, m.get_tex_string())])\n\n    def get_part_by_tex(self, tex, **kwargs):\n        all_parts = self.get_parts_by_tex(tex, **kwargs)\n        return all_parts[0] if all_parts else None\n\n    def set_color_by_tex(self, tex, color, **kwargs):\n        parts_to_color = self.get_parts_by_tex(tex, **kwargs)\n        for part in parts_to_color:\n            part.set_color(color)\n        return self\n\n    def set_color_by_tex_to_color_map(self, texs_to_color_map, **kwargs):\n        for texs, color in list(texs_to_color_map.items()):\n            try:\n                # If the given key behaves like tex_strings\n                texs + \"\"\n                self.set_color_by_tex(texs, color, **kwargs)\n            except TypeError:\n                # If the given key is a tuple\n                for tex in texs:\n                    self.set_color_by_tex(tex, color, **kwargs)\n        return self\n\n    def index_of_part(self, part):\n        split_self = self.split()\n        if part not in split_self:\n            raise Exception(\"Trying to get index of part not in TexMobject\")\n        return split_self.index(part)\n\n    def index_of_part_by_tex(self, tex, **kwargs):\n        part = self.get_part_by_tex(tex, **kwargs)\n        return self.index_of_part(part)\n\n    def sort_alphabetically(self):\n        self.submobjects.sort(key=lambda m: m.get_tex_string())",
  "class TextMobject(TexMobject):\n    CONFIG = {\n        \"alignment\": \"\\\\centering\",\n        \"arg_separator\": \"\",\n        \"type\": \"text\",\n    }",
  "class BulletedList(TextMobject):\n    CONFIG = {\n        \"buff\": MED_LARGE_BUFF,\n        \"dot_scale_factor\": 2,\n        # Have to include because of handle_multiple_args implementation\n        \"alignment\": \"\",\n    }\n\n    def __init__(self, *items, **kwargs):\n        line_separated_items = [s + \"\\\\\\\\\" for s in items]\n        TextMobject.__init__(self, *line_separated_items, **kwargs)\n        for part in self:\n            dot = TexMobject(\"\\\\cdot\").scale(self.dot_scale_factor)\n            dot.next_to(part[0], LEFT, SMALL_BUFF)\n            part.add_to_back(dot)\n        self.arrange(DOWN, aligned_edge=LEFT, buff=self.buff)\n\n    def fade_all_but(self, index_or_string, opacity=0.5):\n        arg = index_or_string\n        if isinstance(arg, str):\n            part = self.get_part_by_tex(arg)\n        elif isinstance(arg, int):\n            part = self.submobjects[arg]\n        else:\n            raise Exception(\"Expected int or string, got {0}\".format(arg))\n        for other_part in self.submobjects:\n            if other_part is part:\n                other_part.set_fill(opacity=1)\n            else:\n                other_part.set_fill(opacity=opacity)",
  "class TexMobjectFromPresetString(TexMobject):\n    CONFIG = {\n        # To be filled by subclasses\n        \"tex\": None,\n        \"color\": None,\n    }\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        TexMobject.__init__(self, self.tex, **kwargs)\n        self.set_color(self.color)",
  "class Title(TextMobject):\n    CONFIG = {\n        \"scale_factor\": 1,\n        \"include_underline\": True,\n        \"underline_width\": config[\"frame_width\"] - 2,\n        # This will override underline_width\n        \"match_underline_width_to_text\": False,\n        \"underline_buff\": MED_SMALL_BUFF,\n    }\n\n    def __init__(self, *text_parts, **kwargs):\n        TextMobject.__init__(self, *text_parts, **kwargs)\n        self.scale(self.scale_factor)\n        self.to_edge(UP)\n        if self.include_underline:\n            underline = Line(LEFT, RIGHT)\n            underline.next_to(self, DOWN, buff=self.underline_buff)\n            if self.match_underline_width_to_text:\n                underline.match_width(self)\n            else:\n                underline.set_width(self.underline_width)\n            self.add(underline)\n            self.underline = underline",
  "def __init__(self, tex_string, **kwargs):\n        digest_config(self, kwargs)\n        assert isinstance(tex_string, str)\n        self.tex_string = tex_string\n        file_name = tex_to_svg_file(self.get_modified_expression(tex_string), self.type)\n        SVGMobject.__init__(self, file_name=file_name, **kwargs)\n        if self.height is None:\n            self.scale(TEX_MOB_SCALE_FACTOR)\n        if self.organize_left_to_right:\n            self.organize_submobjects_left_to_right()",
  "def get_modified_expression(self, tex_string):\n        result = self.alignment + \" \" + tex_string\n        result = result.strip()\n        result = self.modify_special_strings(result)\n        return result",
  "def modify_special_strings(self, tex):\n        tex = self.remove_stray_braces(tex)\n        should_add_filler = reduce(\n            op.or_,\n            [\n                # Fraction line needs something to be over\n                tex == \"\\\\over\",\n                tex == \"\\\\overline\",\n                # Makesure sqrt has overbar\n                tex == \"\\\\sqrt\",\n                # Need to add blank subscript or superscript\n                tex.endswith(\"_\"),\n                tex.endswith(\"^\"),\n                tex.endswith(\"dot\"),\n            ],\n        )\n        if should_add_filler:\n            filler = \"{\\\\quad}\"\n            tex += filler\n\n        if tex == \"\\\\substack\":\n            tex = \"\\\\quad\"\n\n        if tex == \"\":\n            tex = \"\\\\quad\"\n\n        # To keep files from starting with a line break\n        if tex.startswith(\"\\\\\\\\\"):\n            tex = tex.replace(\"\\\\\\\\\", \"\\\\quad\\\\\\\\\")\n\n        # Handle imbalanced \\left and \\right\n        num_lefts, num_rights = [\n            len([s for s in tex.split(substr)[1:] if s and s[0] in \"(){}[]|.\\\\\"])\n            for substr in (\"\\\\left\", \"\\\\right\")\n        ]\n        if num_lefts != num_rights:\n            tex = tex.replace(\"\\\\left\", \"\\\\big\")\n            tex = tex.replace(\"\\\\right\", \"\\\\big\")\n\n        for context in [\"array\"]:\n            begin_in = (\"\\\\begin{%s}\" % context) in tex\n            end_in = (\"\\\\end{%s}\" % context) in tex\n            if begin_in ^ end_in:\n                # Just turn this into a blank string,\n                # which means caller should leave a\n                # stray \\\\begin{...} with other symbols\n                tex = \"\"\n        return tex",
  "def remove_stray_braces(self, tex):\n        \"\"\"\n        Makes TexMobject resiliant to unmatched { at start\n        \"\"\"\n        num_lefts, num_rights = [tex.count(char) for char in \"{}\"]\n        while num_rights > num_lefts:\n            tex = \"{\" + tex\n            num_lefts += 1\n        while num_lefts > num_rights:\n            tex = tex + \"}\"\n            num_rights += 1\n        return tex",
  "def get_tex_string(self):\n        return self.tex_string",
  "def path_string_to_mobject(self, path_string):\n        # Overwrite superclass default to use\n        # specialized path_string mobject\n        return TexSymbol(path_string)",
  "def organize_submobjects_left_to_right(self):\n        self.sort(lambda p: p[0])\n        return self",
  "def __init__(self, *tex_strings, **kwargs):\n        digest_config(self, kwargs)\n        tex_strings = self.break_up_tex_strings(tex_strings)\n        self.tex_strings = tex_strings\n        SingleStringTexMobject.__init__(\n            self, self.arg_separator.join(tex_strings), **kwargs\n        )\n        self.break_up_by_substrings()\n        self.set_color_by_tex_to_color_map(self.tex_to_color_map)\n\n        if self.organize_left_to_right:\n            self.organize_submobjects_left_to_right()",
  "def break_up_tex_strings(self, tex_strings):\n        substrings_to_isolate = op.add(\n            self.substrings_to_isolate, list(self.tex_to_color_map.keys())\n        )\n        split_list = split_string_list_to_isolate_substrings(\n            tex_strings, *substrings_to_isolate\n        )\n        if self.arg_separator == \" \":\n            split_list = [str(x).strip() for x in split_list]\n        # split_list = list(map(str.strip, split_list))\n        split_list = [s for s in split_list if s != \"\"]\n        return split_list",
  "def break_up_by_substrings(self):\n        \"\"\"\n        Reorganize existing submojects one layer\n        deeper based on the structure of tex_strings (as a list\n        of tex_strings)\n        \"\"\"\n        new_submobjects = []\n        curr_index = 0\n        config = dict(self.CONFIG)\n        config[\"alignment\"] = \"\"\n        for tex_string in self.tex_strings:\n            sub_tex_mob = SingleStringTexMobject(tex_string, **config)\n            num_submobs = len(sub_tex_mob.submobjects)\n            new_index = curr_index + num_submobs\n            if num_submobs == 0:\n                # For cases like empty tex_strings, we want the corresponing\n                # part of the whole TexMobject to be a VectorizedPoint\n                # positioned in the right part of the TexMobject\n                sub_tex_mob.submobjects = [VectorizedPoint()]\n                last_submob_index = min(curr_index, len(self.submobjects) - 1)\n                sub_tex_mob.move_to(self.submobjects[last_submob_index], RIGHT)\n            else:\n                sub_tex_mob.submobjects = self.submobjects[curr_index:new_index]\n            new_submobjects.append(sub_tex_mob)\n            curr_index = new_index\n        self.submobjects = new_submobjects\n        return self",
  "def get_parts_by_tex(self, tex, substring=True, case_sensitive=True):\n        def test(tex1, tex2):\n            if not case_sensitive:\n                tex1 = tex1.lower()\n                tex2 = tex2.lower()\n            if substring:\n                return tex1 in tex2\n            else:\n                return tex1 == tex2\n\n        return VGroup(*[m for m in self.submobjects if test(tex, m.get_tex_string())])",
  "def get_part_by_tex(self, tex, **kwargs):\n        all_parts = self.get_parts_by_tex(tex, **kwargs)\n        return all_parts[0] if all_parts else None",
  "def set_color_by_tex(self, tex, color, **kwargs):\n        parts_to_color = self.get_parts_by_tex(tex, **kwargs)\n        for part in parts_to_color:\n            part.set_color(color)\n        return self",
  "def set_color_by_tex_to_color_map(self, texs_to_color_map, **kwargs):\n        for texs, color in list(texs_to_color_map.items()):\n            try:\n                # If the given key behaves like tex_strings\n                texs + \"\"\n                self.set_color_by_tex(texs, color, **kwargs)\n            except TypeError:\n                # If the given key is a tuple\n                for tex in texs:\n                    self.set_color_by_tex(tex, color, **kwargs)\n        return self",
  "def index_of_part(self, part):\n        split_self = self.split()\n        if part not in split_self:\n            raise Exception(\"Trying to get index of part not in TexMobject\")\n        return split_self.index(part)",
  "def index_of_part_by_tex(self, tex, **kwargs):\n        part = self.get_part_by_tex(tex, **kwargs)\n        return self.index_of_part(part)",
  "def sort_alphabetically(self):\n        self.submobjects.sort(key=lambda m: m.get_tex_string())",
  "def __init__(self, *items, **kwargs):\n        line_separated_items = [s + \"\\\\\\\\\" for s in items]\n        TextMobject.__init__(self, *line_separated_items, **kwargs)\n        for part in self:\n            dot = TexMobject(\"\\\\cdot\").scale(self.dot_scale_factor)\n            dot.next_to(part[0], LEFT, SMALL_BUFF)\n            part.add_to_back(dot)\n        self.arrange(DOWN, aligned_edge=LEFT, buff=self.buff)",
  "def fade_all_but(self, index_or_string, opacity=0.5):\n        arg = index_or_string\n        if isinstance(arg, str):\n            part = self.get_part_by_tex(arg)\n        elif isinstance(arg, int):\n            part = self.submobjects[arg]\n        else:\n            raise Exception(\"Expected int or string, got {0}\".format(arg))\n        for other_part in self.submobjects:\n            if other_part is part:\n                other_part.set_fill(opacity=1)\n            else:\n                other_part.set_fill(opacity=opacity)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        TexMobject.__init__(self, self.tex, **kwargs)\n        self.set_color(self.color)",
  "def __init__(self, *text_parts, **kwargs):\n        TextMobject.__init__(self, *text_parts, **kwargs)\n        self.scale(self.scale_factor)\n        self.to_edge(UP)\n        if self.include_underline:\n            underline = Line(LEFT, RIGHT)\n            underline.next_to(self, DOWN, buff=self.underline_buff)\n            if self.match_underline_width_to_text:\n                underline.match_width(self)\n            else:\n                underline.set_width(self.underline_width)\n            self.add(underline)\n            self.underline = underline",
  "def test(tex1, tex2):\n            if not case_sensitive:\n                tex1 = tex1.lower()\n                tex2 = tex2.lower()\n            if substring:\n                return tex1 in tex2\n            else:\n                return tex1 == tex2",
  "class Lightbulb(SVGMobject):\n    CONFIG = {\n        \"file_name\": \"lightbulb\",\n        \"height\": 1,\n        \"stroke_color\": YELLOW,\n        \"stroke_width\": 3,\n        \"fill_color\": YELLOW,\n        \"fill_opacity\": 0,\n    }",
  "class BitcoinLogo(SVGMobject):\n    CONFIG = {\n        \"file_name\": \"Bitcoin_logo\",\n        \"height\": 1,\n        \"fill_color\": \"#f7931a\",\n        \"inner_color\": WHITE,\n        \"fill_opacity\": 1,\n        \"stroke_width\": 0,\n    }\n\n    def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        self[0].set_fill(self.fill_color, self.fill_opacity)\n        self[1].set_fill(self.inner_color, 1)",
  "class Guitar(SVGMobject):\n    CONFIG = {\n        \"file_name\": \"guitar\",\n        \"height\": 2.5,\n        \"fill_color\": DARK_GREY,\n        \"fill_opacity\": 1,\n        \"stroke_color\": WHITE,\n        \"stroke_width\": 0.5,\n    }",
  "class Speedometer(VMobject):\n    CONFIG = {\n        \"arc_angle\": 4 * np.pi / 3,\n        \"num_ticks\": 8,\n        \"tick_length\": 0.2,\n        \"needle_width\": 0.1,\n        \"needle_height\": 0.8,\n        \"needle_color\": YELLOW,\n    }\n\n    def generate_points(self):\n        start_angle = np.pi / 2 + self.arc_angle / 2\n        end_angle = np.pi / 2 - self.arc_angle / 2\n        self.add(Arc(start_angle=start_angle, angle=-self.arc_angle))\n        tick_angle_range = np.linspace(start_angle, end_angle, self.num_ticks)\n        for index, angle in enumerate(tick_angle_range):\n            vect = rotate_vector(RIGHT, angle)\n            tick = Line((1 - self.tick_length) * vect, vect)\n            label = TexMobject(str(10 * index))\n            label.set_height(self.tick_length)\n            label.shift((1 + self.tick_length) * vect)\n            self.add(tick, label)\n\n        needle = Polygon(\n            LEFT,\n            UP,\n            RIGHT,\n            stroke_width=0,\n            fill_opacity=1,\n            fill_color=self.needle_color,\n        )\n        needle.stretch_to_fit_width(self.needle_width)\n        needle.stretch_to_fit_height(self.needle_height)\n        needle.rotate(start_angle - np.pi / 2, about_point=ORIGIN)\n        self.add(needle)\n        self.needle = needle\n\n        self.center_offset = self.get_center()\n\n    def get_center(self):\n        result = VMobject.get_center(self)\n        if hasattr(self, \"center_offset\"):\n            result -= self.center_offset\n        return result\n\n    def get_needle_tip(self):\n        return self.needle.get_anchors()[1]\n\n    def get_needle_angle(self):\n        return angle_of_vector(self.get_needle_tip() - self.get_center())\n\n    def rotate_needle(self, angle):\n        self.needle.rotate(angle, about_point=self.get_center())\n        return self\n\n    def move_needle_to_velocity(self, velocity):\n        max_velocity = 10 * (self.num_ticks - 1)\n        proportion = float(velocity) / max_velocity\n        start_angle = np.pi / 2 + self.arc_angle / 2\n        target_angle = start_angle - self.arc_angle * proportion\n        self.rotate_needle(target_angle - self.get_needle_angle())\n        return self",
  "class AoPSLogo(SVGMobject):\n    CONFIG = {\n        \"file_name\": \"aops_logo\",\n        \"height\": 1.5,\n    }\n\n    def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        self.set_stroke(WHITE, width=0)\n        colors = [BLUE_E, \"#008445\", GREEN_B]\n        index_lists = [\n            (10, 11, 12, 13, 14, 21, 22, 23, 24, 27, 28, 29, 30),\n            (0, 1, 2, 3, 4, 15, 16, 17, 26),\n            (5, 6, 7, 8, 9, 18, 19, 20, 25),\n        ]\n        for color, index_list in zip(colors, index_lists):\n            for i in index_list:\n                self.submobjects[i].set_fill(color, opacity=1)\n\n        self.set_height(self.height)\n        self.center()",
  "class PartyHat(SVGMobject):\n    CONFIG = {\n        \"file_name\": \"party_hat\",\n        \"height\": 1.5,\n        \"stroke_width\": 0,\n        \"fill_opacity\": 1,\n        \"frills_colors\": [MAROON_B, PURPLE],\n        \"cone_color\": GREEN,\n        \"dots_colors\": [YELLOW],\n    }\n    NUM_FRILLS = 7\n    NUM_DOTS = 6\n\n    def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        self.set_height(self.height)\n\n        self.frills = VGroup(*self[: self.NUM_FRILLS])\n        self.cone = self[self.NUM_FRILLS]\n        self.dots = VGroup(*self[self.NUM_FRILLS + 1 :])\n\n        self.frills.set_color_by_gradient(*self.frills_colors)\n        self.cone.set_color(self.cone_color)\n        self.dots.set_color_by_gradient(*self.dots_colors)",
  "class Laptop(VGroup):\n    CONFIG = {\n        \"width\": 3,\n        \"body_dimensions\": [4, 3, 0.05],\n        \"screen_thickness\": 0.01,\n        \"keyboard_width_to_body_width\": 0.9,\n        \"keyboard_height_to_body_height\": 0.5,\n        \"screen_width_to_screen_plate_width\": 0.9,\n        \"key_color_kwargs\": {\n            \"stroke_width\": 0,\n            \"fill_color\": BLACK,\n            \"fill_opacity\": 1,\n        },\n        \"fill_opacity\": 1,\n        \"stroke_width\": 0,\n        \"body_color\": LIGHT_GREY,\n        \"shaded_body_color\": GREY,\n        \"open_angle\": np.pi / 4,\n    }\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        body = Cube(side_length=1)\n        for dim, scale_factor in enumerate(self.body_dimensions):\n            body.stretch(scale_factor, dim=dim)\n        body.set_width(self.width)\n        body.set_fill(self.shaded_body_color, opacity=1)\n        body.sort(lambda p: p[2])\n        body[-1].set_fill(self.body_color)\n        screen_plate = body.copy()\n        keyboard = VGroup(\n            *[\n                VGroup(\n                    *[Square(**self.key_color_kwargs) for x in range(12 - y % 2)]\n                ).arrange(RIGHT, buff=SMALL_BUFF)\n                for y in range(4)\n            ]\n        ).arrange(DOWN, buff=MED_SMALL_BUFF)\n        keyboard.stretch_to_fit_width(\n            self.keyboard_width_to_body_width * body.get_width(),\n        )\n        keyboard.stretch_to_fit_height(\n            self.keyboard_height_to_body_height * body.get_height(),\n        )\n        keyboard.next_to(body, OUT, buff=0.1 * SMALL_BUFF)\n        keyboard.shift(MED_SMALL_BUFF * UP)\n        body.add(keyboard)\n\n        screen_plate.stretch(self.screen_thickness / self.body_dimensions[2], dim=2)\n        screen = Rectangle(stroke_width=0, fill_color=BLACK, fill_opacity=1,)\n        screen.replace(screen_plate, stretch=True)\n        screen.scale_in_place(self.screen_width_to_screen_plate_width)\n        screen.next_to(screen_plate, OUT, buff=0.1 * SMALL_BUFF)\n        screen_plate.add(screen)\n        screen_plate.next_to(body, UP, buff=0)\n        screen_plate.rotate(\n            self.open_angle, RIGHT, about_point=screen_plate.get_bottom()\n        )\n        self.screen_plate = screen_plate\n        self.screen = screen\n\n        axis = Line(\n            body.get_corner(UP + LEFT + OUT),\n            body.get_corner(UP + RIGHT + OUT),\n            color=BLACK,\n            stroke_width=2,\n        )\n        self.axis = axis\n\n        self.add(body, screen_plate, axis)\n        self.rotate(5 * np.pi / 12, LEFT, about_point=ORIGIN)\n        self.rotate(np.pi / 6, DOWN, about_point=ORIGIN)",
  "class PatreonLogo(SVGMobject):\n    CONFIG = {\n        \"file_name\": \"patreon_logo\",\n        \"fill_color\": \"#F96854\",\n        # \"fill_color\" : WHITE,\n        \"fill_opacity\": 1,\n        \"stroke_width\": 0,\n        \"width\": 4,\n    }\n\n    def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        self.set_width(self.width)\n        self.center()",
  "class VideoIcon(SVGMobject):\n    CONFIG = {\n        \"file_name\": \"video_icon\",\n        \"width\": config[\"frame_width\"] / 12.0,\n    }\n\n    def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        self.center()\n        self.set_width(self.width)\n        self.set_stroke(color=WHITE, width=0)\n        self.set_fill(color=WHITE, opacity=1)",
  "class VideoSeries(VGroup):\n    CONFIG = {\n        \"num_videos\": 11,\n        \"gradient_colors\": [BLUE_B, BLUE_D],\n    }\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        videos = [VideoIcon() for x in range(self.num_videos)]\n        VGroup.__init__(self, *videos, **kwargs)\n        self.arrange()\n        self.set_width(config[\"frame_width\"] - config[\"med_large_buff\"])\n        self.set_color_by_gradient(*self.gradient_colors)",
  "class Headphones(SVGMobject):\n    CONFIG = {\n        \"file_name\": \"headphones\",\n        \"height\": 2,\n        \"y_stretch_factor\": 0.5,\n        \"color\": GREY,\n    }\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        SVGMobject.__init__(self, file_name=self.file_name, **kwargs)\n        self.stretch(self.y_stretch_factor, 1)\n        self.set_height(self.height)\n        self.set_stroke(width=0)\n        self.set_fill(color=self.color)",
  "class Clock(VGroup):\n    CONFIG = {}\n\n    def __init__(self, **kwargs):\n        circle = Circle(color=WHITE)\n        ticks = []\n        for x in range(12):\n            alpha = x / 12.0\n            point = complex_to_R3(np.exp(2 * np.pi * alpha * complex(0, 1)))\n            length = 0.2 if x % 3 == 0 else 0.1\n            ticks.append(Line(point, (1 - length) * point))\n        self.hour_hand = Line(ORIGIN, 0.3 * UP)\n        self.minute_hand = Line(ORIGIN, 0.6 * UP)\n        # for hand in self.hour_hand, self.minute_hand:\n        #     #Balance out where the center is\n        #     hand.add(VectorizedPoint(-hand.get_end()))\n\n        VGroup.__init__(self, circle, self.hour_hand, self.minute_hand, *ticks)",
  "class ClockPassesTime(Animation):\n    CONFIG = {\n        \"run_time\": 5,\n        \"hours_passed\": 12,\n        \"rate_func\": linear,\n    }\n\n    def __init__(self, clock, **kwargs):\n        digest_config(self, kwargs)\n        assert isinstance(clock, Clock)\n        rot_kwargs = {\"axis\": OUT, \"about_point\": clock.get_center()}\n        hour_radians = -self.hours_passed * 2 * np.pi / 12\n        self.hour_rotation = Rotating(\n            clock.hour_hand, radians=hour_radians, **rot_kwargs\n        )\n        self.hour_rotation.begin()\n        self.minute_rotation = Rotating(\n            clock.minute_hand, radians=12 * hour_radians, **rot_kwargs\n        )\n        self.minute_rotation.begin()\n        Animation.__init__(self, clock, **kwargs)\n\n    def interpolate_mobject(self, alpha):\n        for rotation in self.hour_rotation, self.minute_rotation:\n            rotation.interpolate_mobject(alpha)",
  "class Bubble(SVGMobject):\n    CONFIG = {\n        \"direction\": LEFT,\n        \"center_point\": ORIGIN,\n        \"content_scale_factor\": 0.75,\n        \"height\": 5,\n        \"width\": 8,\n        \"bubble_center_adjustment_factor\": 1.0 / 8,\n        \"file_name\": None,\n        \"fill_color\": BLACK,\n        \"fill_opacity\": 0.8,\n        \"stroke_color\": WHITE,\n        \"stroke_width\": 3,\n    }\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs, locals())\n        if self.file_name is None:\n            raise Exception(\"Must invoke Bubble subclass\")\n        try:\n            SVGMobject.__init__(self, **kwargs)\n        except IOError as err:\n            self.file_name = os.path.join(FILE_DIR, self.file_name)\n            SVGMobject.__init__(self, **kwargs)\n        self.center()\n        self.stretch_to_fit_height(self.height)\n        self.stretch_to_fit_width(self.width)\n        if self.direction[0] > 0:\n            self.flip()\n        self.direction_was_specified = \"direction\" in kwargs\n        self.content = Mobject()\n\n    def get_tip(self):\n        # TODO, find a better way\n        return self.get_corner(DOWN + self.direction) - 0.6 * self.direction\n\n    def get_bubble_center(self):\n        factor = self.bubble_center_adjustment_factor\n        return self.get_center() + factor * self.get_height() * UP\n\n    def move_tip_to(self, point):\n        mover = VGroup(self)\n        if self.content is not None:\n            mover.add(self.content)\n        mover.shift(point - self.get_tip())\n        return self\n\n    def flip(self, axis=UP):\n        Mobject.flip(self, axis=axis)\n        if abs(axis[1]) > 0:\n            self.direction = -np.array(self.direction)\n        return self\n\n    def pin_to(self, mobject):\n        mob_center = mobject.get_center()\n        want_to_flip = np.sign(mob_center[0]) != np.sign(self.direction[0])\n        can_flip = not self.direction_was_specified\n        if want_to_flip and can_flip:\n            self.flip()\n        boundary_point = mobject.get_critical_point(UP - self.direction)\n        vector_from_center = 1.0 * (boundary_point - mob_center)\n        self.move_tip_to(mob_center + vector_from_center)\n        return self\n\n    def position_mobject_inside(self, mobject):\n        scaled_width = self.content_scale_factor * self.get_width()\n        if mobject.get_width() > scaled_width:\n            mobject.set_width(scaled_width)\n        mobject.shift(self.get_bubble_center() - mobject.get_center())\n        return mobject\n\n    def add_content(self, mobject):\n        self.position_mobject_inside(mobject)\n        self.content = mobject\n        return self.content\n\n    def write(self, *text):\n        self.add_content(TextMobject(*text))\n        return self\n\n    def resize_to_content(self):\n        target_width = self.content.get_width()\n        target_width += max(MED_LARGE_BUFF, 2)\n        target_height = self.content.get_height()\n        target_height += 2.5 * LARGE_BUFF\n        tip_point = self.get_tip()\n        self.stretch_to_fit_width(target_width)\n        self.stretch_to_fit_height(target_height)\n        self.move_tip_to(tip_point)\n        self.position_mobject_inside(self.content)\n\n    def clear(self):\n        self.add_content(VMobject())\n        return self",
  "class SpeechBubble(Bubble):\n    CONFIG = {\"file_name\": \"Bubbles_speech.svg\", \"height\": 4}",
  "class DoubleSpeechBubble(Bubble):\n    CONFIG = {\"file_name\": \"Bubbles_double_speech.svg\", \"height\": 4}",
  "class ThoughtBubble(Bubble):\n    CONFIG = {\n        \"file_name\": \"Bubbles_thought.svg\",\n    }\n\n    def __init__(self, **kwargs):\n        Bubble.__init__(self, **kwargs)\n        self.submobjects.sort(key=lambda m: m.get_bottom()[1])\n\n    def make_green_screen(self):\n        self.submobjects[-1].set_fill(GREEN_SCREEN, opacity=1)\n        return self",
  "class Car(SVGMobject):\n    CONFIG = {\n        \"file_name\": \"Car\",\n        \"height\": 1,\n        \"color\": LIGHT_GREY,\n        \"light_colors\": [BLACK, BLACK],\n    }\n\n    def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n\n        path = self.submobjects[0]\n        subpaths = path.get_subpaths()\n        path.clear_points()\n        for indices in [(0, 1), (2, 3), (4, 6, 7), (5,), (8,)]:\n            part = VMobject()\n            for index in indices:\n                part.append_points(subpaths[index])\n            path.add(part)\n\n        self.set_height(self.height)\n        self.set_stroke(color=WHITE, width=0)\n        self.set_fill(self.color, opacity=1)\n\n        orientation_line = Line(self.get_left(), self.get_right())\n        orientation_line.set_stroke(width=0)\n        self.add(orientation_line)\n        self.orientation_line = orientation_line\n\n        for light, color in zip(self.get_lights(), self.light_colors):\n            light.set_fill(color, 1)\n            light.is_subpath = False\n\n        self.add_treds_to_tires()\n\n    def move_to(self, point_or_mobject):\n        vect = rotate_vector(UP + LEFT, self.orientation_line.get_angle())\n        self.next_to(point_or_mobject, vect, buff=0)\n        return self\n\n    def get_front_line(self):\n        return DashedLine(\n            self.get_corner(UP + RIGHT),\n            self.get_corner(DOWN + RIGHT),\n            color=DISTANCE_COLOR,\n            dash_length=0.05,\n        )\n\n    def add_treds_to_tires(self):\n        for tire in self.get_tires():\n            radius = tire.get_width() / 2\n            center = tire.get_center()\n            tred = Line(\n                0.7 * radius * RIGHT, 1.1 * radius * RIGHT, stroke_width=2, color=BLACK\n            )\n            tred.rotate(PI / 5, about_point=tred.get_end())\n            for theta in np.arange(0, 2 * np.pi, np.pi / 4):\n                new_tred = tred.copy()\n                new_tred.rotate(theta, about_point=ORIGIN)\n                new_tred.shift(center)\n                tire.add(new_tred)\n        return self\n\n    def get_tires(self):\n        return VGroup(self[1][0], self[1][1])\n\n    def get_lights(self):\n        return VGroup(self.get_front_light(), self.get_rear_light())\n\n    def get_front_light(self):\n        return self[1][3]\n\n    def get_rear_light(self):\n        return self[1][4]",
  "class VectorizedEarth(SVGMobject):\n    CONFIG = {\n        \"file_name\": \"earth\",\n        \"height\": 1.5,\n        \"fill_color\": BLACK,\n    }\n\n    def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        circle = Circle(\n            stroke_width=3, stroke_color=GREEN, fill_opacity=1, fill_color=BLUE_C,\n        )\n        circle.replace(self)\n        self.add_to_back(circle)",
  "class Logo(VMobject):\n    CONFIG = {\n        \"pupil_radius\": 1.0,\n        \"outer_radius\": 2.0,\n        \"iris_background_blue\": \"#74C0E3\",\n        \"iris_background_brown\": \"#8C6239\",\n        \"blue_spike_colors\": [\"#528EA3\", \"#3E6576\", \"#224C5B\", BLACK,],\n        \"brown_spike_colors\": [\"#754C24\", \"#603813\", \"#42210b\", BLACK,],\n        \"n_spike_layers\": 4,\n        \"n_spikes\": 28,\n        \"spike_angle\": TAU / 28,\n    }\n\n    def __init__(self, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.add_iris_back()\n        self.add_spikes()\n        self.add_pupil()\n\n    def add_iris_back(self):\n        blue_iris_back = AnnularSector(\n            inner_radius=self.pupil_radius,\n            outer_radius=self.outer_radius,\n            angle=270 * DEGREES,\n            start_angle=180 * DEGREES,\n            fill_color=self.iris_background_blue,\n            fill_opacity=1,\n            stroke_width=0,\n        )\n        brown_iris_back = AnnularSector(\n            inner_radius=self.pupil_radius,\n            outer_radius=self.outer_radius,\n            angle=90 * DEGREES,\n            start_angle=90 * DEGREES,\n            fill_color=self.iris_background_brown,\n            fill_opacity=1,\n            stroke_width=0,\n        )\n        self.iris_background = VGroup(blue_iris_back, brown_iris_back,)\n        self.add(self.iris_background)\n\n    def add_spikes(self):\n        layers = VGroup()\n        radii = np.linspace(\n            self.outer_radius, self.pupil_radius, self.n_spike_layers, endpoint=False,\n        )\n        radii[:2] = radii[1::-1]  # Swap first two\n        if self.n_spike_layers > 2:\n            radii[-1] = interpolate(radii[-1], self.pupil_radius, 0.25)\n\n        for radius in radii:\n            tip_angle = self.spike_angle\n            half_base = radius * np.tan(tip_angle)\n            triangle, right_half_triangle = [\n                Polygon(\n                    radius * UP,\n                    half_base * RIGHT,\n                    vertex3,\n                    fill_opacity=1,\n                    stroke_width=0,\n                )\n                for vertex3 in (half_base * LEFT, ORIGIN,)\n            ]\n            left_half_triangle = right_half_triangle.copy()\n            left_half_triangle.flip(UP, about_point=ORIGIN)\n\n            n_spikes = self.n_spikes\n            full_spikes = [\n                triangle.copy().rotate(-angle, about_point=ORIGIN)\n                for angle in np.linspace(0, TAU, n_spikes, endpoint=False)\n            ]\n            index = (3 * n_spikes) // 4\n            if radius == radii[0]:\n                layer = VGroup(*full_spikes)\n                layer.rotate(-TAU / n_spikes / 2, about_point=ORIGIN)\n                layer.brown_index = index\n            else:\n                half_spikes = [\n                    right_half_triangle.copy(),\n                    left_half_triangle.copy().rotate(90 * DEGREES, about_point=ORIGIN,),\n                    right_half_triangle.copy().rotate(\n                        90 * DEGREES, about_point=ORIGIN,\n                    ),\n                    left_half_triangle.copy(),\n                ]\n                layer = VGroup(\n                    *it.chain(\n                        half_spikes[:1],\n                        full_spikes[1:index],\n                        half_spikes[1:3],\n                        full_spikes[index + 1 :],\n                        half_spikes[3:],\n                    )\n                )\n                layer.brown_index = index + 1\n\n            layers.add(layer)\n\n        # Color spikes\n        blues = self.blue_spike_colors\n        browns = self.brown_spike_colors\n        for layer, blue, brown in zip(layers, blues, browns):\n            index = layer.brown_index\n            layer[:index].set_color(blue)\n            layer[index:].set_color(brown)\n\n        self.spike_layers = layers\n        self.add(layers)\n\n    def add_pupil(self):\n        self.pupil = Circle(\n            radius=self.pupil_radius,\n            fill_color=BLACK,\n            fill_opacity=1,\n            stroke_width=0,\n            sheen=0.0,\n        )\n        self.pupil.rotate(90 * DEGREES)\n        self.add(self.pupil)\n\n    def cut_pupil(self):\n        pupil = self.pupil\n        center = pupil.get_center()\n        new_pupil = VGroup(\n            *[\n                pupil.copy().pointwise_become_partial(pupil, a, b)\n                for (a, b) in [(0.25, 1), (0, 0.25)]\n            ]\n        )\n        for sector in new_pupil:\n            sector.add_cubic_bezier_curve_to(\n                [sector.points[-1], *[center] * 3, *[sector.points[0]] * 2]\n            )\n        self.remove(pupil)\n        self.add(new_pupil)\n        self.pupil = new_pupil\n\n    def get_blue_part_and_brown_part(self):\n        if len(self.pupil) == 1:\n            self.cut_pupil()\n        # circle = Circle()\n        # circle.set_stroke(width=0)\n        # circle.set_fill(BLACK, opacity=1)\n        # circle.match_width(self)\n        # circle.move_to(self)\n        blue_part = VGroup(\n            self.iris_background[0],\n            *[layer[: layer.brown_index] for layer in self.spike_layers],\n            self.pupil[0],\n        )\n        brown_part = VGroup(\n            self.iris_background[1],\n            *[layer[layer.brown_index :] for layer in self.spike_layers],\n            self.pupil[1],\n        )\n        return blue_part, brown_part",
  "class DeckOfCards(VGroup):\n    def __init__(self, **kwargs):\n        possible_values = list(map(str, list(range(1, 11)))) + [\"J\", \"Q\", \"K\"]\n        possible_suits = [\"hearts\", \"diamonds\", \"spades\", \"clubs\"]\n        VGroup.__init__(\n            self,\n            *[\n                PlayingCard(value=value, suit=suit, **kwargs)\n                for value in possible_values\n                for suit in possible_suits\n            ],\n        )",
  "class PlayingCard(VGroup):\n    CONFIG = {\n        \"value\": None,\n        \"suit\": None,\n        \"key\": None,  # String like \"8H\" or \"KS\"\n        \"height\": 2,\n        \"height_to_width\": 3.5 / 2.5,\n        \"card_height_to_symbol_height\": 7,\n        \"card_width_to_corner_num_width\": 10,\n        \"card_height_to_corner_num_height\": 10,\n        \"color\": LIGHT_GREY,\n        \"turned_over\": False,\n        \"possible_suits\": [\"hearts\", \"diamonds\", \"spades\", \"clubs\"],\n        \"possible_values\": list(map(str, list(range(2, 11)))) + [\"J\", \"Q\", \"K\", \"A\"],\n    }\n\n    def __init__(self, key=None, **kwargs):\n        VGroup.__init__(self, key=key, **kwargs)\n\n    def generate_points(self):\n        self.add(\n            Rectangle(\n                height=self.height,\n                width=self.height / self.height_to_width,\n                stroke_color=WHITE,\n                stroke_width=2,\n                fill_color=self.color,\n                fill_opacity=1,\n            )\n        )\n        if self.turned_over:\n            self.set_fill(DARK_GREY)\n            self.set_stroke(LIGHT_GREY)\n            contents = VectorizedPoint(self.get_center())\n        else:\n            value = self.get_value()\n            symbol = self.get_symbol()\n            design = self.get_design(value, symbol)\n            corner_numbers = self.get_corner_numbers(value, symbol)\n            contents = VGroup(design, corner_numbers)\n            self.design = design\n            self.corner_numbers = corner_numbers\n        self.add(contents)\n\n    def get_value(self):\n        value = self.value\n        if value is None:\n            if self.key is not None:\n                value = self.key[:-1]\n            else:\n                value = random.choice(self.possible_values)\n        value = string.upper(str(value))\n        if value == \"1\":\n            value = \"A\"\n        if value not in self.possible_values:\n            raise Exception(\"Invalid card value\")\n\n        face_card_to_value = {\n            \"J\": 11,\n            \"Q\": 12,\n            \"K\": 13,\n            \"A\": 14,\n        }\n        try:\n            self.numerical_value = int(value)\n        except:\n            self.numerical_value = face_card_to_value[value]\n        return value\n\n    def get_symbol(self):\n        suit = self.suit\n        if suit is None:\n            if self.key is not None:\n                suit = dict([(string.upper(s[0]), s) for s in self.possible_suits])[\n                    string.upper(self.key[-1])\n                ]\n            else:\n                suit = random.choice(self.possible_suits)\n        if suit not in self.possible_suits:\n            raise Exception(\"Invalud suit value\")\n        self.suit = suit\n        symbol_height = float(self.height) / self.card_height_to_symbol_height\n        symbol = SuitSymbol(suit, height=symbol_height)\n        return symbol\n\n    def get_design(self, value, symbol):\n        if value == \"A\":\n            return self.get_ace_design(symbol)\n        if value in list(map(str, list(range(2, 11)))):\n            return self.get_number_design(value, symbol)\n        else:\n            return self.get_face_card_design(value, symbol)\n\n    def get_ace_design(self, symbol):\n        design = symbol.copy().scale(1.5)\n        design.move_to(self)\n        return design\n\n    def get_number_design(self, value, symbol):\n        num = int(value)\n        n_rows = {2: 2, 3: 3, 4: 2, 5: 2, 6: 3, 7: 3, 8: 3, 9: 4, 10: 4,}[num]\n        n_cols = 1 if num in [2, 3] else 2\n        insertion_indices = {5: [0], 7: [0], 8: [0, 1], 9: [1], 10: [0, 2],}.get(\n            num, []\n        )\n\n        top = self.get_top() + symbol.get_height() * DOWN\n        bottom = self.get_bottom() + symbol.get_height() * UP\n        column_points = [\n            interpolate(top, bottom, alpha) for alpha in np.linspace(0, 1, n_rows)\n        ]\n\n        design = VGroup(*[symbol.copy().move_to(point) for point in column_points])\n        if n_cols == 2:\n            space = 0.2 * self.get_width()\n            column_copy = design.copy().shift(space * RIGHT)\n            design.shift(space * LEFT)\n            design.add(*column_copy)\n        design.add(\n            *[\n                symbol.copy().move_to(center_of_mass(column_points[i : i + 2]))\n                for i in insertion_indices\n            ]\n        )\n        for symbol in design:\n            if symbol.get_center()[1] < self.get_center()[1]:\n                symbol.rotate_in_place(np.pi)\n        return design\n\n    def get_face_card_design(self, value, symbol):\n        return VGroup()\n\n    def get_corner_numbers(self, value, symbol):\n        value_mob = TextMobject(value)\n        width = self.get_width() / self.card_width_to_corner_num_width\n        height = self.get_height() / self.card_height_to_corner_num_height\n        value_mob.set_width(width)\n        value_mob.stretch_to_fit_height(height)\n        value_mob.next_to(\n            self.get_corner(UP + LEFT), DOWN + RIGHT, buff=MED_LARGE_BUFF * width\n        )\n        value_mob.set_color(symbol.get_color())\n        corner_symbol = symbol.copy()\n        corner_symbol.set_width(width)\n        corner_symbol.next_to(value_mob, DOWN, buff=MED_SMALL_BUFF * width)\n        corner_group = VGroup(value_mob, corner_symbol)\n        opposite_corner_group = corner_group.copy()\n        opposite_corner_group.rotate(np.pi, about_point=self.get_center())\n\n        return VGroup(corner_group, opposite_corner_group)",
  "class SuitSymbol(SVGMobject):\n    CONFIG = {\n        \"height\": 0.5,\n        \"fill_opacity\": 1,\n        \"stroke_width\": 0,\n        \"red\": \"#D02028\",\n        \"black\": BLACK,\n    }\n\n    def __init__(self, suit_name, **kwargs):\n        digest_config(self, kwargs)\n        suits_to_colors = {\n            \"hearts\": self.red,\n            \"diamonds\": self.red,\n            \"spades\": self.black,\n            \"clubs\": self.black,\n        }\n        if suit_name not in suits_to_colors:\n            raise Exception(\"Invalid suit name\")\n        SVGMobject.__init__(self, file_name=suit_name, **kwargs)\n\n        color = suits_to_colors[suit_name]\n        self.set_stroke(width=0)\n        self.set_fill(color, 1)\n        self.set_height(self.height)",
  "def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        self[0].set_fill(self.fill_color, self.fill_opacity)\n        self[1].set_fill(self.inner_color, 1)",
  "def generate_points(self):\n        start_angle = np.pi / 2 + self.arc_angle / 2\n        end_angle = np.pi / 2 - self.arc_angle / 2\n        self.add(Arc(start_angle=start_angle, angle=-self.arc_angle))\n        tick_angle_range = np.linspace(start_angle, end_angle, self.num_ticks)\n        for index, angle in enumerate(tick_angle_range):\n            vect = rotate_vector(RIGHT, angle)\n            tick = Line((1 - self.tick_length) * vect, vect)\n            label = TexMobject(str(10 * index))\n            label.set_height(self.tick_length)\n            label.shift((1 + self.tick_length) * vect)\n            self.add(tick, label)\n\n        needle = Polygon(\n            LEFT,\n            UP,\n            RIGHT,\n            stroke_width=0,\n            fill_opacity=1,\n            fill_color=self.needle_color,\n        )\n        needle.stretch_to_fit_width(self.needle_width)\n        needle.stretch_to_fit_height(self.needle_height)\n        needle.rotate(start_angle - np.pi / 2, about_point=ORIGIN)\n        self.add(needle)\n        self.needle = needle\n\n        self.center_offset = self.get_center()",
  "def get_center(self):\n        result = VMobject.get_center(self)\n        if hasattr(self, \"center_offset\"):\n            result -= self.center_offset\n        return result",
  "def get_needle_tip(self):\n        return self.needle.get_anchors()[1]",
  "def get_needle_angle(self):\n        return angle_of_vector(self.get_needle_tip() - self.get_center())",
  "def rotate_needle(self, angle):\n        self.needle.rotate(angle, about_point=self.get_center())\n        return self",
  "def move_needle_to_velocity(self, velocity):\n        max_velocity = 10 * (self.num_ticks - 1)\n        proportion = float(velocity) / max_velocity\n        start_angle = np.pi / 2 + self.arc_angle / 2\n        target_angle = start_angle - self.arc_angle * proportion\n        self.rotate_needle(target_angle - self.get_needle_angle())\n        return self",
  "def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        self.set_stroke(WHITE, width=0)\n        colors = [BLUE_E, \"#008445\", GREEN_B]\n        index_lists = [\n            (10, 11, 12, 13, 14, 21, 22, 23, 24, 27, 28, 29, 30),\n            (0, 1, 2, 3, 4, 15, 16, 17, 26),\n            (5, 6, 7, 8, 9, 18, 19, 20, 25),\n        ]\n        for color, index_list in zip(colors, index_lists):\n            for i in index_list:\n                self.submobjects[i].set_fill(color, opacity=1)\n\n        self.set_height(self.height)\n        self.center()",
  "def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        self.set_height(self.height)\n\n        self.frills = VGroup(*self[: self.NUM_FRILLS])\n        self.cone = self[self.NUM_FRILLS]\n        self.dots = VGroup(*self[self.NUM_FRILLS + 1 :])\n\n        self.frills.set_color_by_gradient(*self.frills_colors)\n        self.cone.set_color(self.cone_color)\n        self.dots.set_color_by_gradient(*self.dots_colors)",
  "def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        body = Cube(side_length=1)\n        for dim, scale_factor in enumerate(self.body_dimensions):\n            body.stretch(scale_factor, dim=dim)\n        body.set_width(self.width)\n        body.set_fill(self.shaded_body_color, opacity=1)\n        body.sort(lambda p: p[2])\n        body[-1].set_fill(self.body_color)\n        screen_plate = body.copy()\n        keyboard = VGroup(\n            *[\n                VGroup(\n                    *[Square(**self.key_color_kwargs) for x in range(12 - y % 2)]\n                ).arrange(RIGHT, buff=SMALL_BUFF)\n                for y in range(4)\n            ]\n        ).arrange(DOWN, buff=MED_SMALL_BUFF)\n        keyboard.stretch_to_fit_width(\n            self.keyboard_width_to_body_width * body.get_width(),\n        )\n        keyboard.stretch_to_fit_height(\n            self.keyboard_height_to_body_height * body.get_height(),\n        )\n        keyboard.next_to(body, OUT, buff=0.1 * SMALL_BUFF)\n        keyboard.shift(MED_SMALL_BUFF * UP)\n        body.add(keyboard)\n\n        screen_plate.stretch(self.screen_thickness / self.body_dimensions[2], dim=2)\n        screen = Rectangle(stroke_width=0, fill_color=BLACK, fill_opacity=1,)\n        screen.replace(screen_plate, stretch=True)\n        screen.scale_in_place(self.screen_width_to_screen_plate_width)\n        screen.next_to(screen_plate, OUT, buff=0.1 * SMALL_BUFF)\n        screen_plate.add(screen)\n        screen_plate.next_to(body, UP, buff=0)\n        screen_plate.rotate(\n            self.open_angle, RIGHT, about_point=screen_plate.get_bottom()\n        )\n        self.screen_plate = screen_plate\n        self.screen = screen\n\n        axis = Line(\n            body.get_corner(UP + LEFT + OUT),\n            body.get_corner(UP + RIGHT + OUT),\n            color=BLACK,\n            stroke_width=2,\n        )\n        self.axis = axis\n\n        self.add(body, screen_plate, axis)\n        self.rotate(5 * np.pi / 12, LEFT, about_point=ORIGIN)\n        self.rotate(np.pi / 6, DOWN, about_point=ORIGIN)",
  "def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        self.set_width(self.width)\n        self.center()",
  "def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        self.center()\n        self.set_width(self.width)\n        self.set_stroke(color=WHITE, width=0)\n        self.set_fill(color=WHITE, opacity=1)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        videos = [VideoIcon() for x in range(self.num_videos)]\n        VGroup.__init__(self, *videos, **kwargs)\n        self.arrange()\n        self.set_width(config[\"frame_width\"] - config[\"med_large_buff\"])\n        self.set_color_by_gradient(*self.gradient_colors)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        SVGMobject.__init__(self, file_name=self.file_name, **kwargs)\n        self.stretch(self.y_stretch_factor, 1)\n        self.set_height(self.height)\n        self.set_stroke(width=0)\n        self.set_fill(color=self.color)",
  "def __init__(self, **kwargs):\n        circle = Circle(color=WHITE)\n        ticks = []\n        for x in range(12):\n            alpha = x / 12.0\n            point = complex_to_R3(np.exp(2 * np.pi * alpha * complex(0, 1)))\n            length = 0.2 if x % 3 == 0 else 0.1\n            ticks.append(Line(point, (1 - length) * point))\n        self.hour_hand = Line(ORIGIN, 0.3 * UP)\n        self.minute_hand = Line(ORIGIN, 0.6 * UP)\n        # for hand in self.hour_hand, self.minute_hand:\n        #     #Balance out where the center is\n        #     hand.add(VectorizedPoint(-hand.get_end()))\n\n        VGroup.__init__(self, circle, self.hour_hand, self.minute_hand, *ticks)",
  "def __init__(self, clock, **kwargs):\n        digest_config(self, kwargs)\n        assert isinstance(clock, Clock)\n        rot_kwargs = {\"axis\": OUT, \"about_point\": clock.get_center()}\n        hour_radians = -self.hours_passed * 2 * np.pi / 12\n        self.hour_rotation = Rotating(\n            clock.hour_hand, radians=hour_radians, **rot_kwargs\n        )\n        self.hour_rotation.begin()\n        self.minute_rotation = Rotating(\n            clock.minute_hand, radians=12 * hour_radians, **rot_kwargs\n        )\n        self.minute_rotation.begin()\n        Animation.__init__(self, clock, **kwargs)",
  "def interpolate_mobject(self, alpha):\n        for rotation in self.hour_rotation, self.minute_rotation:\n            rotation.interpolate_mobject(alpha)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs, locals())\n        if self.file_name is None:\n            raise Exception(\"Must invoke Bubble subclass\")\n        try:\n            SVGMobject.__init__(self, **kwargs)\n        except IOError as err:\n            self.file_name = os.path.join(FILE_DIR, self.file_name)\n            SVGMobject.__init__(self, **kwargs)\n        self.center()\n        self.stretch_to_fit_height(self.height)\n        self.stretch_to_fit_width(self.width)\n        if self.direction[0] > 0:\n            self.flip()\n        self.direction_was_specified = \"direction\" in kwargs\n        self.content = Mobject()",
  "def get_tip(self):\n        # TODO, find a better way\n        return self.get_corner(DOWN + self.direction) - 0.6 * self.direction",
  "def get_bubble_center(self):\n        factor = self.bubble_center_adjustment_factor\n        return self.get_center() + factor * self.get_height() * UP",
  "def move_tip_to(self, point):\n        mover = VGroup(self)\n        if self.content is not None:\n            mover.add(self.content)\n        mover.shift(point - self.get_tip())\n        return self",
  "def flip(self, axis=UP):\n        Mobject.flip(self, axis=axis)\n        if abs(axis[1]) > 0:\n            self.direction = -np.array(self.direction)\n        return self",
  "def pin_to(self, mobject):\n        mob_center = mobject.get_center()\n        want_to_flip = np.sign(mob_center[0]) != np.sign(self.direction[0])\n        can_flip = not self.direction_was_specified\n        if want_to_flip and can_flip:\n            self.flip()\n        boundary_point = mobject.get_critical_point(UP - self.direction)\n        vector_from_center = 1.0 * (boundary_point - mob_center)\n        self.move_tip_to(mob_center + vector_from_center)\n        return self",
  "def position_mobject_inside(self, mobject):\n        scaled_width = self.content_scale_factor * self.get_width()\n        if mobject.get_width() > scaled_width:\n            mobject.set_width(scaled_width)\n        mobject.shift(self.get_bubble_center() - mobject.get_center())\n        return mobject",
  "def add_content(self, mobject):\n        self.position_mobject_inside(mobject)\n        self.content = mobject\n        return self.content",
  "def write(self, *text):\n        self.add_content(TextMobject(*text))\n        return self",
  "def resize_to_content(self):\n        target_width = self.content.get_width()\n        target_width += max(MED_LARGE_BUFF, 2)\n        target_height = self.content.get_height()\n        target_height += 2.5 * LARGE_BUFF\n        tip_point = self.get_tip()\n        self.stretch_to_fit_width(target_width)\n        self.stretch_to_fit_height(target_height)\n        self.move_tip_to(tip_point)\n        self.position_mobject_inside(self.content)",
  "def clear(self):\n        self.add_content(VMobject())\n        return self",
  "def __init__(self, **kwargs):\n        Bubble.__init__(self, **kwargs)\n        self.submobjects.sort(key=lambda m: m.get_bottom()[1])",
  "def make_green_screen(self):\n        self.submobjects[-1].set_fill(GREEN_SCREEN, opacity=1)\n        return self",
  "def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n\n        path = self.submobjects[0]\n        subpaths = path.get_subpaths()\n        path.clear_points()\n        for indices in [(0, 1), (2, 3), (4, 6, 7), (5,), (8,)]:\n            part = VMobject()\n            for index in indices:\n                part.append_points(subpaths[index])\n            path.add(part)\n\n        self.set_height(self.height)\n        self.set_stroke(color=WHITE, width=0)\n        self.set_fill(self.color, opacity=1)\n\n        orientation_line = Line(self.get_left(), self.get_right())\n        orientation_line.set_stroke(width=0)\n        self.add(orientation_line)\n        self.orientation_line = orientation_line\n\n        for light, color in zip(self.get_lights(), self.light_colors):\n            light.set_fill(color, 1)\n            light.is_subpath = False\n\n        self.add_treds_to_tires()",
  "def move_to(self, point_or_mobject):\n        vect = rotate_vector(UP + LEFT, self.orientation_line.get_angle())\n        self.next_to(point_or_mobject, vect, buff=0)\n        return self",
  "def get_front_line(self):\n        return DashedLine(\n            self.get_corner(UP + RIGHT),\n            self.get_corner(DOWN + RIGHT),\n            color=DISTANCE_COLOR,\n            dash_length=0.05,\n        )",
  "def add_treds_to_tires(self):\n        for tire in self.get_tires():\n            radius = tire.get_width() / 2\n            center = tire.get_center()\n            tred = Line(\n                0.7 * radius * RIGHT, 1.1 * radius * RIGHT, stroke_width=2, color=BLACK\n            )\n            tred.rotate(PI / 5, about_point=tred.get_end())\n            for theta in np.arange(0, 2 * np.pi, np.pi / 4):\n                new_tred = tred.copy()\n                new_tred.rotate(theta, about_point=ORIGIN)\n                new_tred.shift(center)\n                tire.add(new_tred)\n        return self",
  "def get_tires(self):\n        return VGroup(self[1][0], self[1][1])",
  "def get_lights(self):\n        return VGroup(self.get_front_light(), self.get_rear_light())",
  "def get_front_light(self):\n        return self[1][3]",
  "def get_rear_light(self):\n        return self[1][4]",
  "def __init__(self, **kwargs):\n        SVGMobject.__init__(self, **kwargs)\n        circle = Circle(\n            stroke_width=3, stroke_color=GREEN, fill_opacity=1, fill_color=BLUE_C,\n        )\n        circle.replace(self)\n        self.add_to_back(circle)",
  "def __init__(self, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.add_iris_back()\n        self.add_spikes()\n        self.add_pupil()",
  "def add_iris_back(self):\n        blue_iris_back = AnnularSector(\n            inner_radius=self.pupil_radius,\n            outer_radius=self.outer_radius,\n            angle=270 * DEGREES,\n            start_angle=180 * DEGREES,\n            fill_color=self.iris_background_blue,\n            fill_opacity=1,\n            stroke_width=0,\n        )\n        brown_iris_back = AnnularSector(\n            inner_radius=self.pupil_radius,\n            outer_radius=self.outer_radius,\n            angle=90 * DEGREES,\n            start_angle=90 * DEGREES,\n            fill_color=self.iris_background_brown,\n            fill_opacity=1,\n            stroke_width=0,\n        )\n        self.iris_background = VGroup(blue_iris_back, brown_iris_back,)\n        self.add(self.iris_background)",
  "def add_spikes(self):\n        layers = VGroup()\n        radii = np.linspace(\n            self.outer_radius, self.pupil_radius, self.n_spike_layers, endpoint=False,\n        )\n        radii[:2] = radii[1::-1]  # Swap first two\n        if self.n_spike_layers > 2:\n            radii[-1] = interpolate(radii[-1], self.pupil_radius, 0.25)\n\n        for radius in radii:\n            tip_angle = self.spike_angle\n            half_base = radius * np.tan(tip_angle)\n            triangle, right_half_triangle = [\n                Polygon(\n                    radius * UP,\n                    half_base * RIGHT,\n                    vertex3,\n                    fill_opacity=1,\n                    stroke_width=0,\n                )\n                for vertex3 in (half_base * LEFT, ORIGIN,)\n            ]\n            left_half_triangle = right_half_triangle.copy()\n            left_half_triangle.flip(UP, about_point=ORIGIN)\n\n            n_spikes = self.n_spikes\n            full_spikes = [\n                triangle.copy().rotate(-angle, about_point=ORIGIN)\n                for angle in np.linspace(0, TAU, n_spikes, endpoint=False)\n            ]\n            index = (3 * n_spikes) // 4\n            if radius == radii[0]:\n                layer = VGroup(*full_spikes)\n                layer.rotate(-TAU / n_spikes / 2, about_point=ORIGIN)\n                layer.brown_index = index\n            else:\n                half_spikes = [\n                    right_half_triangle.copy(),\n                    left_half_triangle.copy().rotate(90 * DEGREES, about_point=ORIGIN,),\n                    right_half_triangle.copy().rotate(\n                        90 * DEGREES, about_point=ORIGIN,\n                    ),\n                    left_half_triangle.copy(),\n                ]\n                layer = VGroup(\n                    *it.chain(\n                        half_spikes[:1],\n                        full_spikes[1:index],\n                        half_spikes[1:3],\n                        full_spikes[index + 1 :],\n                        half_spikes[3:],\n                    )\n                )\n                layer.brown_index = index + 1\n\n            layers.add(layer)\n\n        # Color spikes\n        blues = self.blue_spike_colors\n        browns = self.brown_spike_colors\n        for layer, blue, brown in zip(layers, blues, browns):\n            index = layer.brown_index\n            layer[:index].set_color(blue)\n            layer[index:].set_color(brown)\n\n        self.spike_layers = layers\n        self.add(layers)",
  "def add_pupil(self):\n        self.pupil = Circle(\n            radius=self.pupil_radius,\n            fill_color=BLACK,\n            fill_opacity=1,\n            stroke_width=0,\n            sheen=0.0,\n        )\n        self.pupil.rotate(90 * DEGREES)\n        self.add(self.pupil)",
  "def cut_pupil(self):\n        pupil = self.pupil\n        center = pupil.get_center()\n        new_pupil = VGroup(\n            *[\n                pupil.copy().pointwise_become_partial(pupil, a, b)\n                for (a, b) in [(0.25, 1), (0, 0.25)]\n            ]\n        )\n        for sector in new_pupil:\n            sector.add_cubic_bezier_curve_to(\n                [sector.points[-1], *[center] * 3, *[sector.points[0]] * 2]\n            )\n        self.remove(pupil)\n        self.add(new_pupil)\n        self.pupil = new_pupil",
  "def get_blue_part_and_brown_part(self):\n        if len(self.pupil) == 1:\n            self.cut_pupil()\n        # circle = Circle()\n        # circle.set_stroke(width=0)\n        # circle.set_fill(BLACK, opacity=1)\n        # circle.match_width(self)\n        # circle.move_to(self)\n        blue_part = VGroup(\n            self.iris_background[0],\n            *[layer[: layer.brown_index] for layer in self.spike_layers],\n            self.pupil[0],\n        )\n        brown_part = VGroup(\n            self.iris_background[1],\n            *[layer[layer.brown_index :] for layer in self.spike_layers],\n            self.pupil[1],\n        )\n        return blue_part, brown_part",
  "def __init__(self, **kwargs):\n        possible_values = list(map(str, list(range(1, 11)))) + [\"J\", \"Q\", \"K\"]\n        possible_suits = [\"hearts\", \"diamonds\", \"spades\", \"clubs\"]\n        VGroup.__init__(\n            self,\n            *[\n                PlayingCard(value=value, suit=suit, **kwargs)\n                for value in possible_values\n                for suit in possible_suits\n            ],\n        )",
  "def __init__(self, key=None, **kwargs):\n        VGroup.__init__(self, key=key, **kwargs)",
  "def generate_points(self):\n        self.add(\n            Rectangle(\n                height=self.height,\n                width=self.height / self.height_to_width,\n                stroke_color=WHITE,\n                stroke_width=2,\n                fill_color=self.color,\n                fill_opacity=1,\n            )\n        )\n        if self.turned_over:\n            self.set_fill(DARK_GREY)\n            self.set_stroke(LIGHT_GREY)\n            contents = VectorizedPoint(self.get_center())\n        else:\n            value = self.get_value()\n            symbol = self.get_symbol()\n            design = self.get_design(value, symbol)\n            corner_numbers = self.get_corner_numbers(value, symbol)\n            contents = VGroup(design, corner_numbers)\n            self.design = design\n            self.corner_numbers = corner_numbers\n        self.add(contents)",
  "def get_value(self):\n        value = self.value\n        if value is None:\n            if self.key is not None:\n                value = self.key[:-1]\n            else:\n                value = random.choice(self.possible_values)\n        value = string.upper(str(value))\n        if value == \"1\":\n            value = \"A\"\n        if value not in self.possible_values:\n            raise Exception(\"Invalid card value\")\n\n        face_card_to_value = {\n            \"J\": 11,\n            \"Q\": 12,\n            \"K\": 13,\n            \"A\": 14,\n        }\n        try:\n            self.numerical_value = int(value)\n        except:\n            self.numerical_value = face_card_to_value[value]\n        return value",
  "def get_symbol(self):\n        suit = self.suit\n        if suit is None:\n            if self.key is not None:\n                suit = dict([(string.upper(s[0]), s) for s in self.possible_suits])[\n                    string.upper(self.key[-1])\n                ]\n            else:\n                suit = random.choice(self.possible_suits)\n        if suit not in self.possible_suits:\n            raise Exception(\"Invalud suit value\")\n        self.suit = suit\n        symbol_height = float(self.height) / self.card_height_to_symbol_height\n        symbol = SuitSymbol(suit, height=symbol_height)\n        return symbol",
  "def get_design(self, value, symbol):\n        if value == \"A\":\n            return self.get_ace_design(symbol)\n        if value in list(map(str, list(range(2, 11)))):\n            return self.get_number_design(value, symbol)\n        else:\n            return self.get_face_card_design(value, symbol)",
  "def get_ace_design(self, symbol):\n        design = symbol.copy().scale(1.5)\n        design.move_to(self)\n        return design",
  "def get_number_design(self, value, symbol):\n        num = int(value)\n        n_rows = {2: 2, 3: 3, 4: 2, 5: 2, 6: 3, 7: 3, 8: 3, 9: 4, 10: 4,}[num]\n        n_cols = 1 if num in [2, 3] else 2\n        insertion_indices = {5: [0], 7: [0], 8: [0, 1], 9: [1], 10: [0, 2],}.get(\n            num, []\n        )\n\n        top = self.get_top() + symbol.get_height() * DOWN\n        bottom = self.get_bottom() + symbol.get_height() * UP\n        column_points = [\n            interpolate(top, bottom, alpha) for alpha in np.linspace(0, 1, n_rows)\n        ]\n\n        design = VGroup(*[symbol.copy().move_to(point) for point in column_points])\n        if n_cols == 2:\n            space = 0.2 * self.get_width()\n            column_copy = design.copy().shift(space * RIGHT)\n            design.shift(space * LEFT)\n            design.add(*column_copy)\n        design.add(\n            *[\n                symbol.copy().move_to(center_of_mass(column_points[i : i + 2]))\n                for i in insertion_indices\n            ]\n        )\n        for symbol in design:\n            if symbol.get_center()[1] < self.get_center()[1]:\n                symbol.rotate_in_place(np.pi)\n        return design",
  "def get_face_card_design(self, value, symbol):\n        return VGroup()",
  "def get_corner_numbers(self, value, symbol):\n        value_mob = TextMobject(value)\n        width = self.get_width() / self.card_width_to_corner_num_width\n        height = self.get_height() / self.card_height_to_corner_num_height\n        value_mob.set_width(width)\n        value_mob.stretch_to_fit_height(height)\n        value_mob.next_to(\n            self.get_corner(UP + LEFT), DOWN + RIGHT, buff=MED_LARGE_BUFF * width\n        )\n        value_mob.set_color(symbol.get_color())\n        corner_symbol = symbol.copy()\n        corner_symbol.set_width(width)\n        corner_symbol.next_to(value_mob, DOWN, buff=MED_SMALL_BUFF * width)\n        corner_group = VGroup(value_mob, corner_symbol)\n        opposite_corner_group = corner_group.copy()\n        opposite_corner_group.rotate(np.pi, about_point=self.get_center())\n\n        return VGroup(corner_group, opposite_corner_group)",
  "def __init__(self, suit_name, **kwargs):\n        digest_config(self, kwargs)\n        suits_to_colors = {\n            \"hearts\": self.red,\n            \"diamonds\": self.red,\n            \"spades\": self.black,\n            \"clubs\": self.black,\n        }\n        if suit_name not in suits_to_colors:\n            raise Exception(\"Invalid suit name\")\n        SVGMobject.__init__(self, file_name=suit_name, **kwargs)\n\n        color = suits_to_colors[suit_name]\n        self.set_stroke(width=0)\n        self.set_fill(color, 1)\n        self.set_height(self.height)",
  "def string_to_numbers(num_string):\n    num_string = num_string.replace(\"-\", \",-\")\n    num_string = num_string.replace(\"e,-\", \"e-\")\n    return [float(s) for s in re.split(\"[ ,]\", num_string) if s != \"\"]",
  "class SVGMobject(VMobject):\n    CONFIG = {\n        \"should_center\": True,\n        \"height\": 2,\n        \"width\": None,\n        # Must be filled in in a subclass, or when called\n        \"file_name\": None,\n        \"unpack_groups\": True,  # if False, creates a hierarchy of VGroups\n        \"stroke_width\": DEFAULT_STROKE_WIDTH,\n        \"fill_opacity\": 1.0,\n        # \"fill_color\" : LIGHT_GREY,\n    }\n\n    def __init__(self, file_name=None, **kwargs):\n        digest_config(self, kwargs)\n        self.file_name = file_name or self.file_name\n        self.ensure_valid_file()\n        VMobject.__init__(self, **kwargs)\n        self.move_into_position()\n\n    def ensure_valid_file(self):\n        if self.file_name is None:\n            raise Exception(\"Must specify file for SVGMobject\")\n        possible_paths = [\n            os.path.join(os.path.join(\"assets\", \"svg_images\"), self.file_name),\n            os.path.join(os.path.join(\"assets\", \"svg_images\"), self.file_name + \".svg\"),\n            os.path.join(os.path.join(\"assets\", \"svg_images\"), self.file_name + \".xdv\"),\n            self.file_name,\n        ]\n        for path in possible_paths:\n            if os.path.exists(path):\n                self.file_path = path\n                return\n        raise IOError(\"No file matching %s in image directory\" % self.file_name)\n\n    def generate_points(self):\n        doc = minidom.parse(self.file_path)\n        self.ref_to_element = {}\n        for svg in doc.getElementsByTagName(\"svg\"):\n            mobjects = self.get_mobjects_from(svg)\n            if self.unpack_groups:\n                self.add(*mobjects)\n            else:\n                self.add(*mobjects[0].submobjects)\n        doc.unlink()\n\n    def get_mobjects_from(self, element):\n        result = []\n        if not isinstance(element, minidom.Element):\n            return result\n        if element.tagName == \"defs\":\n            self.update_ref_to_element(element)\n        elif element.tagName == \"style\":\n            pass  # TODO, handle style\n        elif element.tagName in [\"g\", \"svg\", \"symbol\"]:\n            result += it.chain(\n                *[self.get_mobjects_from(child) for child in element.childNodes]\n            )\n        elif element.tagName == \"path\":\n            temp = element.getAttribute(\"d\")\n            if temp != \"\":\n                result.append(self.path_string_to_mobject(temp))\n        elif element.tagName == \"use\":\n            result += self.use_to_mobjects(element)\n        elif element.tagName == \"rect\":\n            result.append(self.rect_to_mobject(element))\n        elif element.tagName == \"circle\":\n            result.append(self.circle_to_mobject(element))\n        elif element.tagName == \"ellipse\":\n            result.append(self.ellipse_to_mobject(element))\n        elif element.tagName in [\"polygon\", \"polyline\"]:\n            result.append(self.polygon_to_mobject(element))\n        else:\n            pass  # TODO\n            # warnings.warn(\"Unknown element type: \" + element.tagName)\n        result = [m for m in result if m is not None]\n        self.handle_transforms(element, VGroup(*result))\n        if len(result) > 1 and not self.unpack_groups:\n            result = [VGroup(*result)]\n\n        return result\n\n    def g_to_mobjects(self, g_element):\n        mob = VGroup(*self.get_mobjects_from(g_element))\n        self.handle_transforms(g_element, mob)\n        return mob.submobjects\n\n    def path_string_to_mobject(self, path_string):\n        return VMobjectFromSVGPathstring(path_string)\n\n    def use_to_mobjects(self, use_element):\n        # Remove initial \"#\" character\n        ref = use_element.getAttribute(\"xlink:href\")[1:]\n        if ref not in self.ref_to_element:\n            warnings.warn(\"%s not recognized\" % ref)\n            return VGroup()\n        return self.get_mobjects_from(self.ref_to_element[ref])\n\n    def attribute_to_float(self, attr):\n        stripped_attr = \"\".join(\n            [char for char in attr if char in string.digits + \".\" + \"-\"]\n        )\n        return float(stripped_attr)\n\n    def polygon_to_mobject(self, polygon_element):\n        # TODO, This seems hacky...\n        path_string = polygon_element.getAttribute(\"points\")\n        for digit in string.digits:\n            path_string = path_string.replace(\" \" + digit, \" L\" + digit)\n        path_string = \"M\" + path_string\n        return self.path_string_to_mobject(path_string)\n\n    # <circle class=\"st1\" cx=\"143.8\" cy=\"268\" r=\"22.6\"/>\n\n    def circle_to_mobject(self, circle_element):\n        x, y, r = [\n            self.attribute_to_float(circle_element.getAttribute(key))\n            if circle_element.hasAttribute(key)\n            else 0.0\n            for key in (\"cx\", \"cy\", \"r\")\n        ]\n        return Circle(radius=r).shift(x * RIGHT + y * DOWN)\n\n    def ellipse_to_mobject(self, circle_element):\n        x, y, rx, ry = [\n            self.attribute_to_float(circle_element.getAttribute(key))\n            if circle_element.hasAttribute(key)\n            else 0.0\n            for key in (\"cx\", \"cy\", \"rx\", \"ry\")\n        ]\n        return Circle().scale(rx * RIGHT + ry * UP).shift(x * RIGHT + y * DOWN)\n\n    def rect_to_mobject(self, rect_element):\n        fill_color = rect_element.getAttribute(\"fill\")\n        stroke_color = rect_element.getAttribute(\"stroke\")\n        stroke_width = rect_element.getAttribute(\"stroke-width\")\n        corner_radius = rect_element.getAttribute(\"rx\")\n\n        # input preprocessing\n        if fill_color in [\"\", \"none\", \"#FFF\", \"#FFFFFF\"] or Color(fill_color) == Color(\n            WHITE\n        ):\n            opacity = 0\n            fill_color = BLACK  # shdn't be necessary but avoids error msgs\n        if fill_color in [\"#000\", \"#000000\"]:\n            fill_color = WHITE\n        if stroke_color in [\"\", \"none\", \"#FFF\", \"#FFFFFF\"] or Color(\n            stroke_color\n        ) == Color(WHITE):\n            stroke_width = 0\n            stroke_color = BLACK\n        if stroke_color in [\"#000\", \"#000000\"]:\n            stroke_color = WHITE\n        if stroke_width in [\"\", \"none\", \"0\"]:\n            stroke_width = 0\n\n        if corner_radius in [\"\", \"0\", \"none\"]:\n            corner_radius = 0\n\n        corner_radius = float(corner_radius)\n\n        if corner_radius == 0:\n            mob = Rectangle(\n                width=self.attribute_to_float(rect_element.getAttribute(\"width\")),\n                height=self.attribute_to_float(rect_element.getAttribute(\"height\")),\n                stroke_width=stroke_width,\n                stroke_color=stroke_color,\n                fill_color=fill_color,\n                fill_opacity=opacity,\n            )\n        else:\n            mob = RoundedRectangle(\n                width=self.attribute_to_float(rect_element.getAttribute(\"width\")),\n                height=self.attribute_to_float(rect_element.getAttribute(\"height\")),\n                stroke_width=stroke_width,\n                stroke_color=stroke_color,\n                fill_color=fill_color,\n                fill_opacity=opacity,\n                corner_radius=corner_radius,\n            )\n\n        mob.shift(mob.get_center() - mob.get_corner(UP + LEFT))\n        return mob\n\n    def handle_transforms(self, element, mobject):\n        x, y = 0, 0\n        try:\n            x = self.attribute_to_float(element.getAttribute(\"x\"))\n            # Flip y\n            y = -self.attribute_to_float(element.getAttribute(\"y\"))\n            mobject.shift(x * RIGHT + y * UP)\n        except:\n            pass\n\n        transform = element.getAttribute(\"transform\")\n\n        try:  # transform matrix\n            prefix = \"matrix(\"\n            suffix = \")\"\n            if not transform.startswith(prefix) or not transform.endswith(suffix):\n                raise Exception()\n            transform = transform[len(prefix) : -len(suffix)]\n            transform = string_to_numbers(transform)\n            transform = np.array(transform).reshape([3, 2])\n            x = transform[2][0]\n            y = -transform[2][1]\n            matrix = np.identity(self.dim)\n            matrix[:2, :2] = transform[:2, :]\n            matrix[1] *= -1\n            matrix[:, 1] *= -1\n\n            for mob in mobject.family_members_with_points():\n                mob.points = np.dot(mob.points, matrix)\n            mobject.shift(x * RIGHT + y * UP)\n        except:\n            pass\n\n        try:  # transform scale\n            prefix = \"scale(\"\n            suffix = \")\"\n            if not transform.startswith(prefix) or not transform.endswith(suffix):\n                raise Exception()\n            transform = transform[len(prefix) : -len(suffix)]\n            scale_values = string_to_numbers(transform)\n            if len(scale_values) == 2:\n                scale_x, scale_y = scale_values\n                mobject.scale(np.array([scale_x, scale_y, 1]), about_point=ORIGIN)\n            elif len(scale_values) == 1:\n                scale = scale_values[0]\n                mobject.scale(np.array([scale, scale, 1]), about_point=ORIGIN)\n        except:\n            pass\n\n        try:  # transform translate\n            prefix = \"translate(\"\n            suffix = \")\"\n            if not transform.startswith(prefix) or not transform.endswith(suffix):\n                raise Exception()\n            transform = transform[len(prefix) : -len(suffix)]\n            x, y = string_to_numbers(transform)\n            mobject.shift(x * RIGHT + y * DOWN)\n        except:\n            pass\n        # TODO, ...\n\n    def flatten(self, input_list):\n        output_list = []\n        for i in input_list:\n            if isinstance(i, list):\n                output_list.extend(self.flatten(i))\n            else:\n                output_list.append(i)\n        return output_list\n\n    def get_all_childNodes_have_id(self, element):\n        all_childNodes_have_id = []\n        if not isinstance(element, minidom.Element):\n            return\n        if element.hasAttribute(\"id\"):\n            return [element]\n        for e in element.childNodes:\n            all_childNodes_have_id.append(self.get_all_childNodes_have_id(e))\n        return self.flatten([e for e in all_childNodes_have_id if e])\n\n    def update_ref_to_element(self, defs):\n        new_refs = dict(\n            [(e.getAttribute(\"id\"), e) for e in self.get_all_childNodes_have_id(defs)]\n        )\n        self.ref_to_element.update(new_refs)\n\n    def move_into_position(self):\n        if self.should_center:\n            self.center()\n        if self.height is not None:\n            self.set_height(self.height)\n        if self.width is not None:\n            self.set_width(self.width)",
  "class VMobjectFromSVGPathstring(VMobject):\n    def __init__(self, path_string, **kwargs):\n        digest_locals(self)\n        VMobject.__init__(self, **kwargs)\n\n    def get_path_commands(self):\n        result = [\n            \"M\",  # moveto\n            \"L\",  # lineto\n            \"H\",  # horizontal lineto\n            \"V\",  # vertical lineto\n            \"C\",  # curveto\n            \"S\",  # smooth curveto\n            \"Q\",  # quadratic Bezier curve\n            \"T\",  # smooth quadratic Bezier curveto\n            \"A\",  # elliptical Arc\n            \"Z\",  # closepath\n        ]\n        result += [s.lower() for s in result]\n        return result\n\n    def generate_points(self):\n        pattern = \"[%s]\" % (\"\".join(self.get_path_commands()))\n        pairs = list(\n            zip(\n                re.findall(pattern, self.path_string),\n                re.split(pattern, self.path_string)[1:],\n            )\n        )\n        # Which mobject should new points be added to\n        self = self\n        for command, coord_string in pairs:\n            self.handle_command(command, coord_string)\n        # people treat y-coordinate differently\n        self.rotate(np.pi, RIGHT, about_point=ORIGIN)\n\n    def handle_command(self, command, coord_string):\n        isLower = command.islower()\n        command = command.upper()\n        # new_points are the points that will be added to the curr_points\n        # list. This variable may get modified in the conditionals below.\n        points = self.points\n        new_points = self.string_to_points(coord_string)\n\n        if isLower and len(points) > 0:\n            new_points += points[-1]\n\n        if command == \"M\":  # moveto\n            self.start_new_path(new_points[0])\n            if len(new_points) <= 1:\n                return\n\n            # Draw relative line-to values.\n            points = self.points\n            new_points = new_points[1:]\n            command = \"L\"\n\n            for p in new_points:\n                if isLower:\n                    # Treat everything as relative line-to until empty\n                    p[0] += self.points[-1, 0]\n                    p[1] += self.points[-1, 1]\n                self.add_line_to(p)\n            return\n\n        elif command in [\"L\", \"H\", \"V\"]:  # lineto\n            if command == \"H\":\n                new_points[0, 1] = points[-1, 1]\n            elif command == \"V\":\n                if isLower:\n                    new_points[0, 0] -= points[-1, 0]\n                    new_points[0, 0] += points[-1, 1]\n                new_points[0, 1] = new_points[0, 0]\n                new_points[0, 0] = points[-1, 0]\n            self.add_line_to(new_points[0])\n            return\n\n        if command == \"C\":  # curveto\n            pass  # Yay! No action required\n        elif command in [\"S\", \"T\"]:  # smooth curveto\n            self.add_smooth_curve_to(*new_points)\n            # handle1 = points[-1] + (points[-1] - points[-2])\n            # new_points = np.append([handle1], new_points, axis=0)\n            return\n        elif command == \"Q\":  # quadratic Bezier curve\n            # TODO, this is a suboptimal approximation\n            new_points = np.append([new_points[0]], new_points, axis=0)\n        elif command == \"A\":  # elliptical Arc\n            raise Exception(\"Not implemented\")\n        elif command == \"Z\":  # closepath\n            return\n\n        # Add first three points\n        self.add_cubic_bezier_curve_to(*new_points[0:3])\n\n        # Handle situations where there's multiple relative control points\n        if len(new_points) > 3:\n            # Add subsequent offset points relatively.\n            for i in range(3, len(new_points), 3):\n                if isLower:\n                    new_points[i : i + 3] -= points[-1]\n                    new_points[i : i + 3] += new_points[i - 1]\n                self.add_cubic_bezier_curve_to(*new_points[i : i + 3])\n\n    def string_to_points(self, coord_string):\n        numbers = string_to_numbers(coord_string)\n        if len(numbers) % 2 == 1:\n            numbers.append(0)\n        num_points = len(numbers) // 2\n        result = np.zeros((num_points, self.dim))\n        result[:, :2] = np.array(numbers).reshape((num_points, 2))\n        return result\n\n    def get_original_path_string(self):\n        return self.path_string",
  "def __init__(self, file_name=None, **kwargs):\n        digest_config(self, kwargs)\n        self.file_name = file_name or self.file_name\n        self.ensure_valid_file()\n        VMobject.__init__(self, **kwargs)\n        self.move_into_position()",
  "def ensure_valid_file(self):\n        if self.file_name is None:\n            raise Exception(\"Must specify file for SVGMobject\")\n        possible_paths = [\n            os.path.join(os.path.join(\"assets\", \"svg_images\"), self.file_name),\n            os.path.join(os.path.join(\"assets\", \"svg_images\"), self.file_name + \".svg\"),\n            os.path.join(os.path.join(\"assets\", \"svg_images\"), self.file_name + \".xdv\"),\n            self.file_name,\n        ]\n        for path in possible_paths:\n            if os.path.exists(path):\n                self.file_path = path\n                return\n        raise IOError(\"No file matching %s in image directory\" % self.file_name)",
  "def generate_points(self):\n        doc = minidom.parse(self.file_path)\n        self.ref_to_element = {}\n        for svg in doc.getElementsByTagName(\"svg\"):\n            mobjects = self.get_mobjects_from(svg)\n            if self.unpack_groups:\n                self.add(*mobjects)\n            else:\n                self.add(*mobjects[0].submobjects)\n        doc.unlink()",
  "def get_mobjects_from(self, element):\n        result = []\n        if not isinstance(element, minidom.Element):\n            return result\n        if element.tagName == \"defs\":\n            self.update_ref_to_element(element)\n        elif element.tagName == \"style\":\n            pass  # TODO, handle style\n        elif element.tagName in [\"g\", \"svg\", \"symbol\"]:\n            result += it.chain(\n                *[self.get_mobjects_from(child) for child in element.childNodes]\n            )\n        elif element.tagName == \"path\":\n            temp = element.getAttribute(\"d\")\n            if temp != \"\":\n                result.append(self.path_string_to_mobject(temp))\n        elif element.tagName == \"use\":\n            result += self.use_to_mobjects(element)\n        elif element.tagName == \"rect\":\n            result.append(self.rect_to_mobject(element))\n        elif element.tagName == \"circle\":\n            result.append(self.circle_to_mobject(element))\n        elif element.tagName == \"ellipse\":\n            result.append(self.ellipse_to_mobject(element))\n        elif element.tagName in [\"polygon\", \"polyline\"]:\n            result.append(self.polygon_to_mobject(element))\n        else:\n            pass  # TODO\n            # warnings.warn(\"Unknown element type: \" + element.tagName)\n        result = [m for m in result if m is not None]\n        self.handle_transforms(element, VGroup(*result))\n        if len(result) > 1 and not self.unpack_groups:\n            result = [VGroup(*result)]\n\n        return result",
  "def g_to_mobjects(self, g_element):\n        mob = VGroup(*self.get_mobjects_from(g_element))\n        self.handle_transforms(g_element, mob)\n        return mob.submobjects",
  "def path_string_to_mobject(self, path_string):\n        return VMobjectFromSVGPathstring(path_string)",
  "def use_to_mobjects(self, use_element):\n        # Remove initial \"#\" character\n        ref = use_element.getAttribute(\"xlink:href\")[1:]\n        if ref not in self.ref_to_element:\n            warnings.warn(\"%s not recognized\" % ref)\n            return VGroup()\n        return self.get_mobjects_from(self.ref_to_element[ref])",
  "def attribute_to_float(self, attr):\n        stripped_attr = \"\".join(\n            [char for char in attr if char in string.digits + \".\" + \"-\"]\n        )\n        return float(stripped_attr)",
  "def polygon_to_mobject(self, polygon_element):\n        # TODO, This seems hacky...\n        path_string = polygon_element.getAttribute(\"points\")\n        for digit in string.digits:\n            path_string = path_string.replace(\" \" + digit, \" L\" + digit)\n        path_string = \"M\" + path_string\n        return self.path_string_to_mobject(path_string)",
  "def circle_to_mobject(self, circle_element):\n        x, y, r = [\n            self.attribute_to_float(circle_element.getAttribute(key))\n            if circle_element.hasAttribute(key)\n            else 0.0\n            for key in (\"cx\", \"cy\", \"r\")\n        ]\n        return Circle(radius=r).shift(x * RIGHT + y * DOWN)",
  "def ellipse_to_mobject(self, circle_element):\n        x, y, rx, ry = [\n            self.attribute_to_float(circle_element.getAttribute(key))\n            if circle_element.hasAttribute(key)\n            else 0.0\n            for key in (\"cx\", \"cy\", \"rx\", \"ry\")\n        ]\n        return Circle().scale(rx * RIGHT + ry * UP).shift(x * RIGHT + y * DOWN)",
  "def rect_to_mobject(self, rect_element):\n        fill_color = rect_element.getAttribute(\"fill\")\n        stroke_color = rect_element.getAttribute(\"stroke\")\n        stroke_width = rect_element.getAttribute(\"stroke-width\")\n        corner_radius = rect_element.getAttribute(\"rx\")\n\n        # input preprocessing\n        if fill_color in [\"\", \"none\", \"#FFF\", \"#FFFFFF\"] or Color(fill_color) == Color(\n            WHITE\n        ):\n            opacity = 0\n            fill_color = BLACK  # shdn't be necessary but avoids error msgs\n        if fill_color in [\"#000\", \"#000000\"]:\n            fill_color = WHITE\n        if stroke_color in [\"\", \"none\", \"#FFF\", \"#FFFFFF\"] or Color(\n            stroke_color\n        ) == Color(WHITE):\n            stroke_width = 0\n            stroke_color = BLACK\n        if stroke_color in [\"#000\", \"#000000\"]:\n            stroke_color = WHITE\n        if stroke_width in [\"\", \"none\", \"0\"]:\n            stroke_width = 0\n\n        if corner_radius in [\"\", \"0\", \"none\"]:\n            corner_radius = 0\n\n        corner_radius = float(corner_radius)\n\n        if corner_radius == 0:\n            mob = Rectangle(\n                width=self.attribute_to_float(rect_element.getAttribute(\"width\")),\n                height=self.attribute_to_float(rect_element.getAttribute(\"height\")),\n                stroke_width=stroke_width,\n                stroke_color=stroke_color,\n                fill_color=fill_color,\n                fill_opacity=opacity,\n            )\n        else:\n            mob = RoundedRectangle(\n                width=self.attribute_to_float(rect_element.getAttribute(\"width\")),\n                height=self.attribute_to_float(rect_element.getAttribute(\"height\")),\n                stroke_width=stroke_width,\n                stroke_color=stroke_color,\n                fill_color=fill_color,\n                fill_opacity=opacity,\n                corner_radius=corner_radius,\n            )\n\n        mob.shift(mob.get_center() - mob.get_corner(UP + LEFT))\n        return mob",
  "def handle_transforms(self, element, mobject):\n        x, y = 0, 0\n        try:\n            x = self.attribute_to_float(element.getAttribute(\"x\"))\n            # Flip y\n            y = -self.attribute_to_float(element.getAttribute(\"y\"))\n            mobject.shift(x * RIGHT + y * UP)\n        except:\n            pass\n\n        transform = element.getAttribute(\"transform\")\n\n        try:  # transform matrix\n            prefix = \"matrix(\"\n            suffix = \")\"\n            if not transform.startswith(prefix) or not transform.endswith(suffix):\n                raise Exception()\n            transform = transform[len(prefix) : -len(suffix)]\n            transform = string_to_numbers(transform)\n            transform = np.array(transform).reshape([3, 2])\n            x = transform[2][0]\n            y = -transform[2][1]\n            matrix = np.identity(self.dim)\n            matrix[:2, :2] = transform[:2, :]\n            matrix[1] *= -1\n            matrix[:, 1] *= -1\n\n            for mob in mobject.family_members_with_points():\n                mob.points = np.dot(mob.points, matrix)\n            mobject.shift(x * RIGHT + y * UP)\n        except:\n            pass\n\n        try:  # transform scale\n            prefix = \"scale(\"\n            suffix = \")\"\n            if not transform.startswith(prefix) or not transform.endswith(suffix):\n                raise Exception()\n            transform = transform[len(prefix) : -len(suffix)]\n            scale_values = string_to_numbers(transform)\n            if len(scale_values) == 2:\n                scale_x, scale_y = scale_values\n                mobject.scale(np.array([scale_x, scale_y, 1]), about_point=ORIGIN)\n            elif len(scale_values) == 1:\n                scale = scale_values[0]\n                mobject.scale(np.array([scale, scale, 1]), about_point=ORIGIN)\n        except:\n            pass\n\n        try:  # transform translate\n            prefix = \"translate(\"\n            suffix = \")\"\n            if not transform.startswith(prefix) or not transform.endswith(suffix):\n                raise Exception()\n            transform = transform[len(prefix) : -len(suffix)]\n            x, y = string_to_numbers(transform)\n            mobject.shift(x * RIGHT + y * DOWN)\n        except:\n            pass",
  "def flatten(self, input_list):\n        output_list = []\n        for i in input_list:\n            if isinstance(i, list):\n                output_list.extend(self.flatten(i))\n            else:\n                output_list.append(i)\n        return output_list",
  "def get_all_childNodes_have_id(self, element):\n        all_childNodes_have_id = []\n        if not isinstance(element, minidom.Element):\n            return\n        if element.hasAttribute(\"id\"):\n            return [element]\n        for e in element.childNodes:\n            all_childNodes_have_id.append(self.get_all_childNodes_have_id(e))\n        return self.flatten([e for e in all_childNodes_have_id if e])",
  "def update_ref_to_element(self, defs):\n        new_refs = dict(\n            [(e.getAttribute(\"id\"), e) for e in self.get_all_childNodes_have_id(defs)]\n        )\n        self.ref_to_element.update(new_refs)",
  "def move_into_position(self):\n        if self.should_center:\n            self.center()\n        if self.height is not None:\n            self.set_height(self.height)\n        if self.width is not None:\n            self.set_width(self.width)",
  "def __init__(self, path_string, **kwargs):\n        digest_locals(self)\n        VMobject.__init__(self, **kwargs)",
  "def get_path_commands(self):\n        result = [\n            \"M\",  # moveto\n            \"L\",  # lineto\n            \"H\",  # horizontal lineto\n            \"V\",  # vertical lineto\n            \"C\",  # curveto\n            \"S\",  # smooth curveto\n            \"Q\",  # quadratic Bezier curve\n            \"T\",  # smooth quadratic Bezier curveto\n            \"A\",  # elliptical Arc\n            \"Z\",  # closepath\n        ]\n        result += [s.lower() for s in result]\n        return result",
  "def generate_points(self):\n        pattern = \"[%s]\" % (\"\".join(self.get_path_commands()))\n        pairs = list(\n            zip(\n                re.findall(pattern, self.path_string),\n                re.split(pattern, self.path_string)[1:],\n            )\n        )\n        # Which mobject should new points be added to\n        self = self\n        for command, coord_string in pairs:\n            self.handle_command(command, coord_string)\n        # people treat y-coordinate differently\n        self.rotate(np.pi, RIGHT, about_point=ORIGIN)",
  "def handle_command(self, command, coord_string):\n        isLower = command.islower()\n        command = command.upper()\n        # new_points are the points that will be added to the curr_points\n        # list. This variable may get modified in the conditionals below.\n        points = self.points\n        new_points = self.string_to_points(coord_string)\n\n        if isLower and len(points) > 0:\n            new_points += points[-1]\n\n        if command == \"M\":  # moveto\n            self.start_new_path(new_points[0])\n            if len(new_points) <= 1:\n                return\n\n            # Draw relative line-to values.\n            points = self.points\n            new_points = new_points[1:]\n            command = \"L\"\n\n            for p in new_points:\n                if isLower:\n                    # Treat everything as relative line-to until empty\n                    p[0] += self.points[-1, 0]\n                    p[1] += self.points[-1, 1]\n                self.add_line_to(p)\n            return\n\n        elif command in [\"L\", \"H\", \"V\"]:  # lineto\n            if command == \"H\":\n                new_points[0, 1] = points[-1, 1]\n            elif command == \"V\":\n                if isLower:\n                    new_points[0, 0] -= points[-1, 0]\n                    new_points[0, 0] += points[-1, 1]\n                new_points[0, 1] = new_points[0, 0]\n                new_points[0, 0] = points[-1, 0]\n            self.add_line_to(new_points[0])\n            return\n\n        if command == \"C\":  # curveto\n            pass  # Yay! No action required\n        elif command in [\"S\", \"T\"]:  # smooth curveto\n            self.add_smooth_curve_to(*new_points)\n            # handle1 = points[-1] + (points[-1] - points[-2])\n            # new_points = np.append([handle1], new_points, axis=0)\n            return\n        elif command == \"Q\":  # quadratic Bezier curve\n            # TODO, this is a suboptimal approximation\n            new_points = np.append([new_points[0]], new_points, axis=0)\n        elif command == \"A\":  # elliptical Arc\n            raise Exception(\"Not implemented\")\n        elif command == \"Z\":  # closepath\n            return\n\n        # Add first three points\n        self.add_cubic_bezier_curve_to(*new_points[0:3])\n\n        # Handle situations where there's multiple relative control points\n        if len(new_points) > 3:\n            # Add subsequent offset points relatively.\n            for i in range(3, len(new_points), 3):\n                if isLower:\n                    new_points[i : i + 3] -= points[-1]\n                    new_points[i : i + 3] += new_points[i - 1]\n                self.add_cubic_bezier_curve_to(*new_points[i : i + 3])",
  "def string_to_points(self, coord_string):\n        numbers = string_to_numbers(coord_string)\n        if len(numbers) % 2 == 1:\n            numbers.append(0)\n        num_points = len(numbers) // 2\n        result = np.zeros((num_points, self.dim))\n        result[:, :2] = np.array(numbers).reshape((num_points, 2))\n        return result",
  "def get_original_path_string(self):\n        return self.path_string",
  "class Brace(TexMobject):\n    CONFIG = {\n        \"buff\": 0.2,\n        \"width_multiplier\": 2,\n        \"max_num_quads\": 15,\n        \"min_num_quads\": 0,\n        \"background_stroke_width\": 0,\n    }\n\n    def __init__(self, mobject, direction=DOWN, **kwargs):\n        digest_config(self, kwargs, locals())\n        angle = -np.arctan2(*direction[:2]) + np.pi\n        mobject.rotate(-angle, about_point=ORIGIN)\n        left = mobject.get_corner(DOWN + LEFT)\n        right = mobject.get_corner(DOWN + RIGHT)\n        target_width = right[0] - left[0]\n\n        # Adding int(target_width) qquads gives approximately the right width\n        num_quads = np.clip(\n            int(self.width_multiplier * target_width),\n            self.min_num_quads,\n            self.max_num_quads,\n        )\n        tex_string = \"\\\\underbrace{%s}\" % (num_quads * \"\\\\qquad\")\n        TexMobject.__init__(self, tex_string, **kwargs)\n        self.tip_point_index = np.argmin(self.get_all_points()[:, 1])\n        self.stretch_to_fit_width(target_width)\n        self.shift(left - self.get_corner(UP + LEFT) + self.buff * DOWN)\n        for mob in mobject, self:\n            mob.rotate(angle, about_point=ORIGIN)\n\n    def put_at_tip(self, mob, use_next_to=True, **kwargs):\n        if use_next_to:\n            mob.next_to(self.get_tip(), np.round(self.get_direction()), **kwargs)\n        else:\n            mob.move_to(self.get_tip())\n            buff = kwargs.get(\"buff\", DEFAULT_MOBJECT_TO_MOBJECT_BUFFER)\n            shift_distance = mob.get_width() / 2.0 + buff\n            mob.shift(self.get_direction() * shift_distance)\n        return self\n\n    def get_text(self, *text, **kwargs):\n        text_mob = TextMobject(*text)\n        self.put_at_tip(text_mob, **kwargs)\n        return text_mob\n\n    def get_tex(self, *tex, **kwargs):\n        tex_mob = TexMobject(*tex)\n        self.put_at_tip(tex_mob, **kwargs)\n        return tex_mob\n\n    def get_tip(self):\n        # Very specific to the LaTeX representation\n        # of a brace, but it's the only way I can think\n        # of to get the tip regardless of orientation.\n        return self.get_all_points()[self.tip_point_index]\n\n    def get_direction(self):\n        vect = self.get_tip() - self.get_center()\n        return vect / get_norm(vect)",
  "class BraceLabel(VMobject):\n    CONFIG = {\n        \"label_constructor\": TexMobject,\n        \"label_scale\": 1,\n    }\n\n    def __init__(self, obj, text, brace_direction=DOWN, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.brace_direction = brace_direction\n        if isinstance(obj, list):\n            obj = VMobject(*obj)\n        self.brace = Brace(obj, brace_direction, **kwargs)\n\n        if isinstance(text, tuple) or isinstance(text, list):\n            self.label = self.label_constructor(*text, **kwargs)\n        else:\n            self.label = self.label_constructor(str(text))\n        if self.label_scale != 1:\n            self.label.scale(self.label_scale)\n\n        self.brace.put_at_tip(self.label)\n        self.submobjects = [self.brace, self.label]\n\n    def creation_anim(self, label_anim=FadeIn, brace_anim=GrowFromCenter):\n        return AnimationGroup(brace_anim(self.brace), label_anim(self.label))\n\n    def shift_brace(self, obj, **kwargs):\n        if isinstance(obj, list):\n            obj = VMobject(*obj)\n        self.brace = Brace(obj, self.brace_direction, **kwargs)\n        self.brace.put_at_tip(self.label)\n        self.submobjects[0] = self.brace\n        return self\n\n    def change_label(self, *text, **kwargs):\n        self.label = self.label_constructor(*text, **kwargs)\n        if self.label_scale != 1:\n            self.label.scale(self.label_scale)\n\n        self.brace.put_at_tip(self.label)\n        self.submobjects[1] = self.label\n        return self\n\n    def change_brace_label(self, obj, *text):\n        self.shift_brace(obj)\n        self.change_label(*text)\n        return self\n\n    def copy(self):\n        copy_mobject = copy.copy(self)\n        copy_mobject.brace = self.brace.copy()\n        copy_mobject.label = self.label.copy()\n        copy_mobject.submobjects = [copy_mobject.brace, copy_mobject.label]\n\n        return copy_mobject",
  "class BraceText(BraceLabel):\n    CONFIG = {\"label_constructor\": TextMobject}",
  "def __init__(self, mobject, direction=DOWN, **kwargs):\n        digest_config(self, kwargs, locals())\n        angle = -np.arctan2(*direction[:2]) + np.pi\n        mobject.rotate(-angle, about_point=ORIGIN)\n        left = mobject.get_corner(DOWN + LEFT)\n        right = mobject.get_corner(DOWN + RIGHT)\n        target_width = right[0] - left[0]\n\n        # Adding int(target_width) qquads gives approximately the right width\n        num_quads = np.clip(\n            int(self.width_multiplier * target_width),\n            self.min_num_quads,\n            self.max_num_quads,\n        )\n        tex_string = \"\\\\underbrace{%s}\" % (num_quads * \"\\\\qquad\")\n        TexMobject.__init__(self, tex_string, **kwargs)\n        self.tip_point_index = np.argmin(self.get_all_points()[:, 1])\n        self.stretch_to_fit_width(target_width)\n        self.shift(left - self.get_corner(UP + LEFT) + self.buff * DOWN)\n        for mob in mobject, self:\n            mob.rotate(angle, about_point=ORIGIN)",
  "def put_at_tip(self, mob, use_next_to=True, **kwargs):\n        if use_next_to:\n            mob.next_to(self.get_tip(), np.round(self.get_direction()), **kwargs)\n        else:\n            mob.move_to(self.get_tip())\n            buff = kwargs.get(\"buff\", DEFAULT_MOBJECT_TO_MOBJECT_BUFFER)\n            shift_distance = mob.get_width() / 2.0 + buff\n            mob.shift(self.get_direction() * shift_distance)\n        return self",
  "def get_text(self, *text, **kwargs):\n        text_mob = TextMobject(*text)\n        self.put_at_tip(text_mob, **kwargs)\n        return text_mob",
  "def get_tex(self, *tex, **kwargs):\n        tex_mob = TexMobject(*tex)\n        self.put_at_tip(tex_mob, **kwargs)\n        return tex_mob",
  "def get_tip(self):\n        # Very specific to the LaTeX representation\n        # of a brace, but it's the only way I can think\n        # of to get the tip regardless of orientation.\n        return self.get_all_points()[self.tip_point_index]",
  "def get_direction(self):\n        vect = self.get_tip() - self.get_center()\n        return vect / get_norm(vect)",
  "def __init__(self, obj, text, brace_direction=DOWN, **kwargs):\n        VMobject.__init__(self, **kwargs)\n        self.brace_direction = brace_direction\n        if isinstance(obj, list):\n            obj = VMobject(*obj)\n        self.brace = Brace(obj, brace_direction, **kwargs)\n\n        if isinstance(text, tuple) or isinstance(text, list):\n            self.label = self.label_constructor(*text, **kwargs)\n        else:\n            self.label = self.label_constructor(str(text))\n        if self.label_scale != 1:\n            self.label.scale(self.label_scale)\n\n        self.brace.put_at_tip(self.label)\n        self.submobjects = [self.brace, self.label]",
  "def creation_anim(self, label_anim=FadeIn, brace_anim=GrowFromCenter):\n        return AnimationGroup(brace_anim(self.brace), label_anim(self.label))",
  "def shift_brace(self, obj, **kwargs):\n        if isinstance(obj, list):\n            obj = VMobject(*obj)\n        self.brace = Brace(obj, self.brace_direction, **kwargs)\n        self.brace.put_at_tip(self.label)\n        self.submobjects[0] = self.brace\n        return self",
  "def change_label(self, *text, **kwargs):\n        self.label = self.label_constructor(*text, **kwargs)\n        if self.label_scale != 1:\n            self.label.scale(self.label_scale)\n\n        self.brace.put_at_tip(self.label)\n        self.submobjects[1] = self.label\n        return self",
  "def change_brace_label(self, obj, *text):\n        self.shift_brace(obj)\n        self.change_label(*text)\n        return self",
  "def copy(self):\n        copy_mobject = copy.copy(self)\n        copy_mobject.brace = self.brace.copy()\n        copy_mobject.label = self.label.copy()\n        copy_mobject.submobjects = [copy_mobject.brace, copy_mobject.label]\n\n        return copy_mobject",
  "class GraphScene(Scene):\n    CONFIG = {\n        \"x_min\": -1,\n        \"x_max\": 10,\n        \"x_axis_width\": 9,\n        \"x_tick_frequency\": 1,\n        \"x_leftmost_tick\": None,  # Change if different from x_min\n        \"x_labeled_nums\": None,\n        \"x_axis_label\": \"$x$\",\n        \"y_min\": -1,\n        \"y_max\": 10,\n        \"y_axis_height\": 6,\n        \"y_tick_frequency\": 1,\n        \"y_bottom_tick\": None,  # Change if different from y_min\n        \"y_labeled_nums\": None,\n        \"y_axis_label\": \"$y$\",\n        \"axes_color\": GREY,\n        \"graph_origin\": 2.5 * DOWN + 4 * LEFT,\n        \"exclude_zero_label\": True,\n        \"default_graph_colors\": [BLUE, GREEN, YELLOW],\n        \"default_derivative_color\": GREEN,\n        \"default_input_color\": YELLOW,\n        \"default_riemann_start_color\": BLUE,\n        \"default_riemann_end_color\": GREEN,\n        \"area_opacity\": 0.8,\n        \"num_rects\": 50,\n        \"include_tip\": False,  # add tip at the end of the axes\n        \"x_axis_visibility\": True,  # show or hide the x axis\n        \"y_axis_visibility\": True,  # show or hide the y axis\n        \"x_label_position\": UP + RIGHT,  # where to place the label of the x axis\n        \"y_label_position\": UP + RIGHT,  # where to place the label of the y axis\n        \"x_add_start\": 0,  # extend the x axis to the left\n        \"x_add_end\": 0,  # extend the x axis to the right\n        \"y_add_start\": 0,  # extend the y axis to the bottom\n        \"y_add_end\": 0,  # extend the y axis to the top\n    }\n\n    def setup(self):\n        \"\"\"\n        This method is used internally by Manim\n        to set up the scene for proper use.\n        \"\"\"\n        self.default_graph_colors_cycle = it.cycle(self.default_graph_colors)\n\n        self.left_T_label = VGroup()\n        self.left_v_line = VGroup()\n        self.right_T_label = VGroup()\n        self.right_v_line = VGroup()\n\n    def setup_axes(self, animate=False):\n        \"\"\"\n        This method sets up the axes of the graph.\n\n        Parameters\n        ----------\n        animate : bool, optional\n            Whether or not to animate the setting up of the Axes.\n        \"\"\"\n        # TODO, once eoc is done, refactor this to be less redundant.\n        x_num_range = float(self.x_max - self.x_min)\n        self.space_unit_to_x = self.x_axis_width / x_num_range\n        if self.x_labeled_nums is None:\n            self.x_labeled_nums = []\n        if self.x_leftmost_tick is None:\n            self.x_leftmost_tick = self.x_min\n        x_axis = NumberLine(\n            x_min=self.x_min,\n            x_max=self.x_max,\n            unit_size=self.space_unit_to_x,\n            tick_frequency=self.x_tick_frequency,\n            leftmost_tick=self.x_leftmost_tick,\n            numbers_with_elongated_ticks=self.x_labeled_nums,\n            color=self.axes_color,\n            include_tip=self.include_tip,\n            add_start=self.x_add_start,\n            add_end=self.x_add_end,\n        )\n        x_axis.shift(self.graph_origin - x_axis.number_to_point(0))\n        if len(self.x_labeled_nums) > 0:\n            if self.exclude_zero_label:\n                self.x_labeled_nums = [x for x in self.x_labeled_nums if x != 0]\n            x_axis.add_numbers(*self.x_labeled_nums)\n        if self.x_axis_label:\n            x_label = TextMobject(self.x_axis_label)\n            x_label.next_to(\n                x_axis.get_tips() if self.include_tip else x_axis.get_tick_marks(),\n                self.x_label_position,\n                buff=SMALL_BUFF,\n            )\n            x_label.shift_onto_screen()\n            x_axis.add(x_label)\n            self.x_axis_label_mob = x_label\n\n        y_num_range = float(self.y_max - self.y_min)\n        self.space_unit_to_y = self.y_axis_height / y_num_range\n\n        if self.y_labeled_nums is None:\n            self.y_labeled_nums = []\n        if self.y_bottom_tick is None:\n            self.y_bottom_tick = self.y_min\n        y_axis = NumberLine(\n            x_min=self.y_min,\n            x_max=self.y_max,\n            unit_size=self.space_unit_to_y,\n            tick_frequency=self.y_tick_frequency,\n            leftmost_tick=self.y_bottom_tick,\n            numbers_with_elongated_ticks=self.y_labeled_nums,\n            color=self.axes_color,\n            line_to_number_vect=LEFT,\n            label_direction=LEFT,\n            include_tip=self.include_tip,\n            add_start=self.y_add_start,\n            add_end=self.y_add_end,\n        )\n        y_axis.shift(self.graph_origin - y_axis.number_to_point(0))\n        y_axis.rotate(np.pi / 2, about_point=y_axis.number_to_point(0))\n        if len(self.y_labeled_nums) > 0:\n            if self.exclude_zero_label:\n                self.y_labeled_nums = [y for y in self.y_labeled_nums if y != 0]\n            y_axis.add_numbers(*self.y_labeled_nums)\n        if self.y_axis_label:\n            y_label = TextMobject(self.y_axis_label)\n            y_label.next_to(\n                y_axis.get_corner(self.y_label_position),\n                self.y_label_position,\n                buff=SMALL_BUFF,\n            )\n            y_label.shift_onto_screen()\n            y_axis.add(y_label)\n            self.y_axis_label_mob = y_label\n\n        axes = []\n        if self.x_axis_visibility:\n            axes.append(x_axis)\n        if self.y_axis_visibility:\n            axes.append(y_axis)\n\n        if animate:\n            self.play(Write(VGroup(*axes)))\n        else:\n            self.add(*axes)\n        self.x_axis, self.y_axis = self.axes = VGroup(x_axis, y_axis)\n        self.default_graph_colors = it.cycle(self.default_graph_colors)\n\n    def coords_to_point(self, x, y):\n        \"\"\"\n        The graph is smaller than the scene.\n        Because of this, coordinates in the scene don't map\n        to coordinates on the graph.\n        This method returns a scaled coordinate for the graph,\n        given cartesian coordinates that correspond to the scene..\n\n        Parameters\n        ----------\n        x : int, float\n            The x value\n\n        y : int, float\n            The y value\n\n        Returns\n        -------\n        np.ndarray\n            The array of the coordinates.\n        \"\"\"\n        assert hasattr(self, \"x_axis\") and hasattr(self, \"y_axis\")\n        result = self.x_axis.number_to_point(x)[0] * RIGHT\n        result += self.y_axis.number_to_point(y)[1] * UP\n        return result\n\n    def point_to_coords(self, point):\n        \"\"\"\n        The scene is smaller than the graph.\n\n        Because of this, coordinates in the graph don't map\n        to coordinates on the scene.\n\n        This method returns a scaled coordinate for the scene,\n        given coordinates that correspond to the graph.\n\n        Parameters\n        ----------\n        point : np.ndarray\n            The point on the graph.\n\n        Returns\n        -------\n        tuple\n            The coordinates on the scene.\n        \"\"\"\n        return (self.x_axis.point_to_number(point), self.y_axis.point_to_number(point))\n\n    def get_graph(self, func, color=None, x_min=None, x_max=None, **kwargs):\n        \"\"\"\n        This method gets a curve to plot on the graph.\n\n        Parameters\n        ----------\n        func : function\n            The function to plot. It's return value should be\n            the y-coordinate for a given x-coordinate\n\n        color : str, optional\n            The string of the RGB color of the curve. in Hexadecimal representation.\n\n        x_min : int, float, optional\n            The lower x_value from which to plot the curve.\n\n        x_max : int, float, optional\n            The higher x_value until which to plot the curve.\n\n        **kwargs :\n            Any valid keyword arguments of ParametricFunction.\n\n        Return\n        ------\n        ParametricFunction\n            The Parametric Curve for the function passed.\n\n        \"\"\"\n        if color is None:\n            color = next(self.default_graph_colors_cycle)\n        if x_min is None:\n            x_min = self.x_min\n        if x_max is None:\n            x_max = self.x_max\n\n        def parameterized_function(alpha):\n            x = interpolate(x_min, x_max, alpha)\n            y = func(x)\n            if not np.isfinite(y):\n                y = self.y_max\n            return self.coords_to_point(x, y)\n\n        graph = ParametricFunction(parameterized_function, color=color, **kwargs)\n        graph.underlying_function = func\n        return graph\n\n    def input_to_graph_point(self, x, graph):\n        \"\"\"\n        This method returns a coordinate on the curve\n        given an x_value and a the graoh-curve for which\n        the corresponding y value should be found.\n\n        Parameters\n        ----------\n        x : int, float\n            The x value for which to find the y value.\n\n        graph : ParametricFunction\n            The ParametricFunction object on which\n            the x and y value lie.\n\n        Returns\n        -------\n        numpy.nparray\n            The array of the coordinates on the graph.\n        \"\"\"\n        return self.coords_to_point(x, graph.underlying_function(x))\n\n    def angle_of_tangent(self, x, graph, dx=0.01):\n        \"\"\"\n        Returns the angle to the x axis of the tangent\n        to the plotted curve at a particular x-value.\n\n        Parameters\n        ----------\n        x : int, float\n            The x value at which the tangent must touch the curve.\n\n        graph : ParametricFunction\n            The ParametricFunction for which to calculate the tangent.\n\n        dx : int, float, optional\n            The small change in x with which a small change in y\n            will be compared in order to obtain the tangent.\n\n        Returns\n        -------\n        float\n            The angle of the tangent with the x axis.\n        \"\"\"\n        vect = self.input_to_graph_point(x + dx, graph) - self.input_to_graph_point(\n            x, graph\n        )\n        return angle_of_vector(vect)\n\n    def slope_of_tangent(self, *args, **kwargs):\n        \"\"\"\n        Returns the slople of the tangent to the plotted curve\n        at a particular x-value.\n\n        Parameters\n        ----------\n        x : int, float\n            The x value at which the tangent must touch the curve.\n\n        graph : ParametricFunction\n            The ParametricFunction for which to calculate the tangent.\n\n        dx : int, float, optional\n            The small change in x with which a small change in y\n            will be compared in order to obtain the tangent.\n\n        Returns\n        -------\n        float\n            The slope of the tangent with the x axis.\n        \"\"\"\n        return np.tan(self.angle_of_tangent(*args, **kwargs))\n\n    def get_derivative_graph(self, graph, dx=0.01, **kwargs):\n        \"\"\"\n        Returns the curve of the derivative of the passed\n        graph.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph for which the derivative must be found.\n\n        dx : float, int, optional\n            The small change in x with which a small change in y\n            will be compared in order to obtain the derivative.\n\n        **kwargs\n            Any valid keyword argument of ParametricFunction\n\n        Returns\n        -------\n        ParametricFunction\n            The curve of the derivative.\n        \"\"\"\n        if \"color\" not in kwargs:\n            kwargs[\"color\"] = self.default_derivative_color\n\n        def deriv(x):\n            return self.slope_of_tangent(x, graph, dx) / self.space_unit_to_y\n\n        return self.get_graph(deriv, **kwargs)\n\n    def get_graph_label(\n        self,\n        graph,\n        label=\"f(x)\",\n        x_val=None,\n        direction=RIGHT,\n        buff=MED_SMALL_BUFF,\n        color=None,\n    ):\n        \"\"\"\n        This method returns a properly positioned label for the passed graph,\n        styled with the passed parameters.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The curve of the function plotted.\n\n        label : str, optional\n            The label for the function's curve.\n\n        x_val : int, float, optional\n            The x_value with which the label should be aligned.\n\n        direction : np.ndarray, list, tuple\n            The cartesian position, relative to the curve that the label will be at.\n            e.g LEFT, RIGHT\n\n        buff : float, int, option\n            The buffer space between the curve and the label\n\n        color : str, optional\n            The color of the label.\n\n        Returns\n        -------\n        TexMobject\n            The LaTeX of the passed 'label' parameter\n\n        \"\"\"\n        label = TexMobject(label)\n        color = color or graph.get_color()\n        label.set_color(color)\n        if x_val is None:\n            # Search from right to left\n            for x in np.linspace(self.x_max, self.x_min, 100):\n                point = self.input_to_graph_point(x, graph)\n                if point[1] < config[\"frame_y_radius\"]:\n                    break\n            x_val = x\n        label.next_to(self.input_to_graph_point(x_val, graph), direction, buff=buff)\n        label.shift_onto_screen()\n        return label\n\n    def get_riemann_rectangles(\n        self,\n        graph,\n        x_min=None,\n        x_max=None,\n        dx=0.1,\n        input_sample_type=\"left\",\n        stroke_width=1,\n        stroke_color=BLACK,\n        fill_opacity=1,\n        start_color=None,\n        end_color=None,\n        show_signed_area=True,\n        width_scale_factor=1.001,\n    ):\n        \"\"\"\n        This method returns the VGroup() of the Riemann Rectangles for\n        a particular curve.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph whose area needs to be approximated\n            by the Riemann Rectangles.\n\n        x_min : int, float, optional\n            The lower bound from which to start adding rectangles\n\n        x_max : int, float, optional\n            The upper bound where the rectangles stop.\n\n        dx : int, float, optional\n            The smallest change in x-values that is\n            considered significant.\n\n        input_sample_type : {\"left\", \"right\", \"center\"}\n            Can be any of \"left\", \"right\" or \"center\n\n        stroke_width : int, float, optional\n            The stroke_width of the border of the rectangles.\n\n        stroke_color : str, optional\n            The string of hex colour of the rectangle's border.\n\n        fill_opacity : int, float\n            The opacity of the rectangles. Takes values from 0 to 1.\n\n        start_color : str, optional\n            The hex starting colour for the rectangles,\n            this will, if end_color is a different colour,\n            make a nice gradient.\n\n        end_color : str, optional\n            The hex ending colour for the rectangles,\n            this will, if start_color is a different colour,\n            make a nice gradient.\n\n        show_signed_area : bool, optional\n            Whether or not to indicate -ve area if curve dips below\n            x-axis.\n\n        width_scale_factor : int, float, optional\n            How much the width of the rectangles are scaled by when transforming.\n\n        Returns\n        -------\n        VGroup\n            A VGroup containing the Riemann Rectangles.\n\n        \"\"\"\n        x_min = x_min if x_min is not None else self.x_min\n        x_max = x_max if x_max is not None else self.x_max\n        if start_color is None:\n            start_color = self.default_riemann_start_color\n        if end_color is None:\n            end_color = self.default_riemann_end_color\n        rectangles = VGroup()\n        x_range = np.arange(x_min, x_max, dx)\n        colors = color_gradient([start_color, end_color], len(x_range))\n        for x, color in zip(x_range, colors):\n            if input_sample_type == \"left\":\n                sample_input = x\n            elif input_sample_type == \"right\":\n                sample_input = x + dx\n            elif input_sample_type == \"center\":\n                sample_input = x + 0.5 * dx\n            else:\n                raise Exception(\"Invalid input sample type\")\n            graph_point = self.input_to_graph_point(sample_input, graph)\n            points = VGroup(\n                *list(\n                    map(\n                        VectorizedPoint,\n                        [\n                            self.coords_to_point(x, 0),\n                            self.coords_to_point(x + width_scale_factor * dx, 0),\n                            graph_point,\n                        ],\n                    )\n                )\n            )\n\n            rect = Rectangle()\n            rect.replace(points, stretch=True)\n            if graph_point[1] < self.graph_origin[1] and show_signed_area:\n                fill_color = invert_color(color)\n            else:\n                fill_color = color\n            rect.set_fill(fill_color, opacity=fill_opacity)\n            rect.set_stroke(stroke_color, width=stroke_width)\n            rectangles.add(rect)\n        return rectangles\n\n    def get_riemann_rectangles_list(\n        self, graph, n_iterations, max_dx=0.5, power_base=2, stroke_width=1, **kwargs\n    ):\n        \"\"\"\n        This method returns a list of multiple VGroups of Riemann\n        Rectangles. The inital VGroups are relatively inaccurate,\n        but the closer you get to the end the more accurate the Riemann\n        rectangles become\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph whose area needs to be approximated\n            by the Riemann Rectangles.\n\n        n_iterations : int,\n            The number of VGroups of successive accuracy that are needed.\n\n        max_dx : int, float, optional\n            The maximum change in x between two VGroups of Riemann Rectangles\n\n        power_base : int, float, optional\n            Defaults to 2\n\n        stroke_width : int, float, optional\n            The stroke_width of the border of the rectangles.\n\n        **kwargs\n            Any valid keyword arguments of get_riemann_rectangles.\n\n        Returns\n        -------\n        list\n            The list of Riemann Rectangles of increasing accuracy.\n        \"\"\"\n        return [\n            self.get_riemann_rectangles(\n                graph=graph,\n                dx=float(max_dx) / (power_base ** n),\n                stroke_width=float(stroke_width) / (power_base ** n),\n                **kwargs,\n            )\n            for n in range(n_iterations)\n        ]\n\n    def get_area(self, graph, t_min, t_max):\n        \"\"\"\n        Returns a VGroup of Riemann rectangles\n        sufficiently small enough to visually\n        approximate the area under the graph passed.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph/curve for which the area needs to be gotten.\n\n        t_min : int, float\n            The lower bound of x from which to approximate the area.\n\n        t_max : int, float\n            The upper bound of x until which the area must be approximated.\n\n        Returns\n        -------\n        VGroup\n            The VGroup containing the Riemann Rectangles.\n        \"\"\"\n        numerator = max(t_max - t_min, 0.0001)\n        dx = float(numerator) / self.num_rects\n        return self.get_riemann_rectangles(\n            graph, x_min=t_min, x_max=t_max, dx=dx, stroke_width=0,\n        ).set_fill(opacity=self.area_opacity)\n\n    def transform_between_riemann_rects(self, curr_rects, new_rects, **kwargs):\n        \"\"\"\n        This method is used to transform between two VGroups of Riemann Rectangles,\n        if they were obtained by get_riemann_rectangles or get_riemann_rectangles_list.\n        No animation is returned, and the animation is directly played.\n\n        Parameters\n        ----------\n        curr_rects : VGroup\n            The current Riemann Rectangles\n\n        new_rects : VGroup\n            The Riemann Rectangles to transform to.\n\n        **kwargs\n            added_anims\n                Any other animations to play simultaneously.\n        \"\"\"\n        transform_kwargs = {\"run_time\": 2, \"lag_ratio\": 0.5}\n        added_anims = kwargs.get(\"added_anims\", [])\n        transform_kwargs.update(kwargs)\n        curr_rects.align_submobjects(new_rects)\n        x_coords = set()  # Keep track of new repetitions\n        for rect in curr_rects:\n            x = rect.get_center()[0]\n            if x in x_coords:\n                rect.set_fill(opacity=0)\n            else:\n                x_coords.add(x)\n        self.play(Transform(curr_rects, new_rects, **transform_kwargs), *added_anims)\n\n    def get_vertical_line_to_graph(self, x, graph, line_class=Line, **line_kwargs):\n        \"\"\"\n        This method returns a Vertical line from the x-axis to\n        the corresponding point on the graph/curve.\n\n        Parameters\n        ----------\n        x : int, float\n            The x-value at which the line should be placed/calculated.\n\n        graph : ParametricFunction\n            The graph on which the line should extend to.\n\n        line_class : Line and similar\n            The type of line that should be used.\n            Defaults to Line.\n\n        **line_kwargs\n            Any valid keyword arguments of the object passed in \"line_class\"\n            If line_class is Line, any valid keyword arguments of Line are allowed.\n\n        Return\n        ------\n        An object of type passed in \"line_class\"\n            Defaults to Line\n        \"\"\"\n        if \"color\" not in line_kwargs:\n            line_kwargs[\"color\"] = graph.get_color()\n        return line_class(\n            self.coords_to_point(x, 0),\n            self.input_to_graph_point(x, graph),\n            **line_kwargs,\n        )\n\n    def get_vertical_lines_to_graph(\n        self, graph, x_min=None, x_max=None, num_lines=20, **kwargs\n    ):\n        \"\"\"\n        Obtains multiple lines from the x axis to the Graph/curve.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph on which the line should extend to.\n\n        x_min : int, float, optional\n            The lower bound from which lines can appear.\n\n        x_max : int, float, optional\n            The upper bound until which the lines can appear.\n\n        num_lines : int, optional\n            The number of lines (evenly spaced)\n            that are needed.\n\n        Returns\n        -------\n        VGroup\n            The VGroup of the evenly spaced lines.\n\n        \"\"\"\n        x_min = x_min or self.x_min\n        x_max = x_max or self.x_max\n        return VGroup(\n            *[\n                self.get_vertical_line_to_graph(x, graph, **kwargs)\n                for x in np.linspace(x_min, x_max, num_lines)\n            ]\n        )\n\n    def get_secant_slope_group(\n        self,\n        x,\n        graph,\n        dx=None,\n        dx_line_color=None,\n        df_line_color=None,\n        dx_label=None,\n        df_label=None,\n        include_secant_line=True,\n        secant_line_color=None,\n        secant_line_length=10,\n    ):\n        \"\"\"\n        This method returns a VGroup of (two lines\n        representing dx and df, the labels for dx and\n        df, and the Secant to the Graph/curve at a\n        particular x value.\n\n        Parameters\n        ----------\n        x : int, float\n            The x value at which the secant enters, and intersects\n            the graph for the first time.\n\n        graph : ParametricFunction\n            The curve/graph for which the secant must\n            be found.\n\n        dx : int, float, optional\n            The change in x after which the secant exits.\n\n        dx_line_color : str, optional\n            The line color for the line that indicates the change in x.\n\n        df_line_color : str, optional\n            The line color for the line that indicates the change in y.\n\n        dx_label : str, optional\n            The label to be provided for the change in x.\n\n        df_label : str, optional\n            The label to be provided for the change in y.\n\n        include_secant_line : bool, optional\n            Whether or not to include the secant line in the graph,\n            or just have the df and dx lines and labels.\n\n        secant_line_color : str, optional\n            The color of the secant line.\n\n        secant_line_length : int, float, optional\n            How long the secant line should be.\n\n        Returns:\n        --------\n        VGroup\n            Resulting group is of the form VGroup(\n                dx_line,\n                df_line,\n                dx_label, (if applicable)\n                df_label, (if applicable)\n                secant_line, (if applicable)\n            )\n            with attributes of those names.\n        \"\"\"\n        kwargs = locals()\n        kwargs.pop(\"self\")\n        group = VGroup()\n        group.kwargs = kwargs\n\n        dx = dx or float(self.x_max - self.x_min) / 10\n        dx_line_color = dx_line_color or self.default_input_color\n        df_line_color = df_line_color or graph.get_color()\n\n        p1 = self.input_to_graph_point(x, graph)\n        p2 = self.input_to_graph_point(x + dx, graph)\n        interim_point = p2[0] * RIGHT + p1[1] * UP\n\n        group.dx_line = Line(p1, interim_point, color=dx_line_color)\n        group.df_line = Line(interim_point, p2, color=df_line_color)\n        group.add(group.dx_line, group.df_line)\n\n        labels = VGroup()\n        if dx_label is not None:\n            group.dx_label = TexMobject(dx_label)\n            labels.add(group.dx_label)\n            group.add(group.dx_label)\n        if df_label is not None:\n            group.df_label = TexMobject(df_label)\n            labels.add(group.df_label)\n            group.add(group.df_label)\n\n        if len(labels) > 0:\n            max_width = 0.8 * group.dx_line.get_width()\n            max_height = 0.8 * group.df_line.get_height()\n            if labels.get_width() > max_width:\n                labels.set_width(max_width)\n            if labels.get_height() > max_height:\n                labels.set_height(max_height)\n\n        if dx_label is not None:\n            group.dx_label.next_to(\n                group.dx_line, np.sign(dx) * DOWN, buff=group.dx_label.get_height() / 2\n            )\n            group.dx_label.set_color(group.dx_line.get_color())\n\n        if df_label is not None:\n            group.df_label.next_to(\n                group.df_line, np.sign(dx) * RIGHT, buff=group.df_label.get_height() / 2\n            )\n            group.df_label.set_color(group.df_line.get_color())\n\n        if include_secant_line:\n            secant_line_color = secant_line_color or self.default_derivative_color\n            group.secant_line = Line(p1, p2, color=secant_line_color)\n            group.secant_line.scale_in_place(\n                secant_line_length / group.secant_line.get_length()\n            )\n            group.add(group.secant_line)\n\n        return group\n\n    def add_T_label(\n        self, x_val, side=RIGHT, label=None, color=WHITE, animated=False, **kwargs\n    ):\n        \"\"\"\n        This method adds to the Scene:\n            -- a Vertical line from the x-axis to the corresponding point on the graph/curve.\n            -- a small vertical Triangle whose top point lies on the base of the vertical line\n            -- a TexMobject to be a label for the Line and Triangle, at the bottom of the Triangle.\n        The scene needs to have the graph have the identifier/variable name self.v_graph.\n\n        Parameters\n        ----------\n        x_val : float, int\n            The x value at which the secant enters, and intersects\n            the graph for the first time.\n\n        side np.array(), optional\n\n        label : str, optional\n            The label to give the vertline and triangle\n\n        color : str, optional\n            The hex color of the label.\n\n        animated : bool, optional\n            Whether or not to animate the addition of the T_label\n\n        **kwargs\n            Any valid keyword argument of a self.play call.\n        \"\"\"\n        triangle = RegularPolygon(n=3, start_angle=np.pi / 2)\n        triangle.set_height(MED_SMALL_BUFF)\n        triangle.move_to(self.coords_to_point(x_val, 0), UP)\n        triangle.set_fill(color, 1)\n        triangle.set_stroke(width=0)\n        if label is None:\n            T_label = TexMobject(self.variable_point_label, fill_color=color)\n        else:\n            T_label = TexMobject(label, fill_color=color)\n\n        T_label.next_to(triangle, DOWN)\n        v_line = self.get_vertical_line_to_graph(x_val, self.v_graph, color=YELLOW)\n\n        if animated:\n            self.play(\n                DrawBorderThenFill(triangle),\n                ShowCreation(v_line),\n                Write(T_label, run_time=1),\n                **kwargs,\n            )\n\n        if np.all(side == LEFT):\n            self.left_T_label_group = VGroup(T_label, triangle)\n            self.left_v_line = v_line\n            self.add(self.left_T_label_group, self.left_v_line)\n        elif np.all(side == RIGHT):\n            self.right_T_label_group = VGroup(T_label, triangle)\n            self.right_v_line = v_line\n            self.add(self.right_T_label_group, self.right_v_line)\n\n    def get_animation_integral_bounds_change(\n        self, graph, new_t_min, new_t_max, fade_close_to_origin=True, run_time=1.0\n    ):\n        \"\"\"\n        This method requires a lot of prerequisites:\n        self.area must be defined from self.get_area()\n        self.left_v_line and self.right_v_line must be defined from self.get_v_line\n        self.left_T_label_group and self.right_T_label_group must be defined from self.add_T_label\n\n        This method will return a VGroup of new mobjects for each of those, when provided the graph/curve,\n        the new t_min and t_max, the run_time and a bool stating whether or not to fade when close to\n        the origin.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph for which this must be done.\n\n        new_t_min : int, float\n            The new lower bound.\n\n        new_t_max : int, float\n            The new upper bound.\n\n        fade_close_to_origin : bool, optional\n            Whether or not to fade when close to the origin.\n\n        run_time : int, float, optional\n            The run_time of the animation of this change.\n        \"\"\"\n        curr_t_min = self.x_axis.point_to_number(self.area.get_left())\n        curr_t_max = self.x_axis.point_to_number(self.area.get_right())\n        if new_t_min is None:\n            new_t_min = curr_t_min\n        if new_t_max is None:\n            new_t_max = curr_t_max\n\n        group = VGroup(self.area)\n        group.add(self.left_v_line)\n        group.add(self.left_T_label_group)\n        group.add(self.right_v_line)\n        group.add(self.right_T_label_group)\n\n        def update_group(group, alpha):\n            area, left_v_line, left_T_label, right_v_line, right_T_label = group\n            t_min = interpolate(curr_t_min, new_t_min, alpha)\n            t_max = interpolate(curr_t_max, new_t_max, alpha)\n            new_area = self.get_area(graph, t_min, t_max)\n\n            new_left_v_line = self.get_vertical_line_to_graph(t_min, graph)\n            new_left_v_line.set_color(left_v_line.get_color())\n            left_T_label.move_to(new_left_v_line.get_bottom(), UP)\n\n            new_right_v_line = self.get_vertical_line_to_graph(t_max, graph)\n            new_right_v_line.set_color(right_v_line.get_color())\n            right_T_label.move_to(new_right_v_line.get_bottom(), UP)\n\n            # Fade close to 0\n            if fade_close_to_origin:\n                if len(left_T_label) > 0:\n                    left_T_label[0].set_fill(opacity=min(1, np.abs(t_min)))\n                if len(right_T_label) > 0:\n                    right_T_label[0].set_fill(opacity=min(1, np.abs(t_max)))\n\n            Transform(area, new_area).update(1)\n            Transform(left_v_line, new_left_v_line).update(1)\n            Transform(right_v_line, new_right_v_line).update(1)\n            return group\n\n        return UpdateFromAlphaFunc(group, update_group, run_time=run_time)\n\n    def animate_secant_slope_group_change(\n        self,\n        secant_slope_group,\n        target_dx=None,\n        target_x=None,\n        run_time=3,\n        added_anims=None,\n        **anim_kwargs,\n    ):\n        \"\"\"\n        This method animates the change of the secant slope group  from\n        the old secant slope group, into a new secant slope group.\n\n        Parameters\n        ----------\n        secant_slope_group : VGroup\n            The old secant_slope_group\n\n        target_dx : int, float, optional\n            The new dx value.\n\n        target_x : int, float, optional\n            The new x value at which the secant should be.\n\n        run_time : int, float, optional\n            The run time for this change when animated.\n\n        added_anims : list, optional\n            Any exta animations that should be played alongside.\n\n        **anim_kwargs\n            Any valid kwargs of a self.play call.\n\n        NOTE: At least one of target_dx and target_x should be not None.\n        \"\"\"\n        if target_dx is None and target_x is None:\n            raise Exception(\"At least one of target_x and target_dx must not be None\")\n        if added_anims is None:\n            added_anims = []\n\n        start_dx = secant_slope_group.kwargs[\"dx\"]\n        start_x = secant_slope_group.kwargs[\"x\"]\n        if target_dx is None:\n            target_dx = start_dx\n        if target_x is None:\n            target_x = start_x\n\n        def update_func(group, alpha):\n            dx = interpolate(start_dx, target_dx, alpha)\n            x = interpolate(start_x, target_x, alpha)\n            kwargs = dict(secant_slope_group.kwargs)\n            kwargs[\"dx\"] = dx\n            kwargs[\"x\"] = x\n            new_group = self.get_secant_slope_group(**kwargs)\n            group.become(new_group)\n            return group\n\n        self.play(\n            UpdateFromAlphaFunc(\n                secant_slope_group, update_func, run_time=run_time, **anim_kwargs\n            ),\n            *added_anims,\n        )\n        secant_slope_group.kwargs[\"x\"] = target_x\n        secant_slope_group.kwargs[\"dx\"] = target_dx",
  "def setup(self):\n        \"\"\"\n        This method is used internally by Manim\n        to set up the scene for proper use.\n        \"\"\"\n        self.default_graph_colors_cycle = it.cycle(self.default_graph_colors)\n\n        self.left_T_label = VGroup()\n        self.left_v_line = VGroup()\n        self.right_T_label = VGroup()\n        self.right_v_line = VGroup()",
  "def setup_axes(self, animate=False):\n        \"\"\"\n        This method sets up the axes of the graph.\n\n        Parameters\n        ----------\n        animate : bool, optional\n            Whether or not to animate the setting up of the Axes.\n        \"\"\"\n        # TODO, once eoc is done, refactor this to be less redundant.\n        x_num_range = float(self.x_max - self.x_min)\n        self.space_unit_to_x = self.x_axis_width / x_num_range\n        if self.x_labeled_nums is None:\n            self.x_labeled_nums = []\n        if self.x_leftmost_tick is None:\n            self.x_leftmost_tick = self.x_min\n        x_axis = NumberLine(\n            x_min=self.x_min,\n            x_max=self.x_max,\n            unit_size=self.space_unit_to_x,\n            tick_frequency=self.x_tick_frequency,\n            leftmost_tick=self.x_leftmost_tick,\n            numbers_with_elongated_ticks=self.x_labeled_nums,\n            color=self.axes_color,\n            include_tip=self.include_tip,\n            add_start=self.x_add_start,\n            add_end=self.x_add_end,\n        )\n        x_axis.shift(self.graph_origin - x_axis.number_to_point(0))\n        if len(self.x_labeled_nums) > 0:\n            if self.exclude_zero_label:\n                self.x_labeled_nums = [x for x in self.x_labeled_nums if x != 0]\n            x_axis.add_numbers(*self.x_labeled_nums)\n        if self.x_axis_label:\n            x_label = TextMobject(self.x_axis_label)\n            x_label.next_to(\n                x_axis.get_tips() if self.include_tip else x_axis.get_tick_marks(),\n                self.x_label_position,\n                buff=SMALL_BUFF,\n            )\n            x_label.shift_onto_screen()\n            x_axis.add(x_label)\n            self.x_axis_label_mob = x_label\n\n        y_num_range = float(self.y_max - self.y_min)\n        self.space_unit_to_y = self.y_axis_height / y_num_range\n\n        if self.y_labeled_nums is None:\n            self.y_labeled_nums = []\n        if self.y_bottom_tick is None:\n            self.y_bottom_tick = self.y_min\n        y_axis = NumberLine(\n            x_min=self.y_min,\n            x_max=self.y_max,\n            unit_size=self.space_unit_to_y,\n            tick_frequency=self.y_tick_frequency,\n            leftmost_tick=self.y_bottom_tick,\n            numbers_with_elongated_ticks=self.y_labeled_nums,\n            color=self.axes_color,\n            line_to_number_vect=LEFT,\n            label_direction=LEFT,\n            include_tip=self.include_tip,\n            add_start=self.y_add_start,\n            add_end=self.y_add_end,\n        )\n        y_axis.shift(self.graph_origin - y_axis.number_to_point(0))\n        y_axis.rotate(np.pi / 2, about_point=y_axis.number_to_point(0))\n        if len(self.y_labeled_nums) > 0:\n            if self.exclude_zero_label:\n                self.y_labeled_nums = [y for y in self.y_labeled_nums if y != 0]\n            y_axis.add_numbers(*self.y_labeled_nums)\n        if self.y_axis_label:\n            y_label = TextMobject(self.y_axis_label)\n            y_label.next_to(\n                y_axis.get_corner(self.y_label_position),\n                self.y_label_position,\n                buff=SMALL_BUFF,\n            )\n            y_label.shift_onto_screen()\n            y_axis.add(y_label)\n            self.y_axis_label_mob = y_label\n\n        axes = []\n        if self.x_axis_visibility:\n            axes.append(x_axis)\n        if self.y_axis_visibility:\n            axes.append(y_axis)\n\n        if animate:\n            self.play(Write(VGroup(*axes)))\n        else:\n            self.add(*axes)\n        self.x_axis, self.y_axis = self.axes = VGroup(x_axis, y_axis)\n        self.default_graph_colors = it.cycle(self.default_graph_colors)",
  "def coords_to_point(self, x, y):\n        \"\"\"\n        The graph is smaller than the scene.\n        Because of this, coordinates in the scene don't map\n        to coordinates on the graph.\n        This method returns a scaled coordinate for the graph,\n        given cartesian coordinates that correspond to the scene..\n\n        Parameters\n        ----------\n        x : int, float\n            The x value\n\n        y : int, float\n            The y value\n\n        Returns\n        -------\n        np.ndarray\n            The array of the coordinates.\n        \"\"\"\n        assert hasattr(self, \"x_axis\") and hasattr(self, \"y_axis\")\n        result = self.x_axis.number_to_point(x)[0] * RIGHT\n        result += self.y_axis.number_to_point(y)[1] * UP\n        return result",
  "def point_to_coords(self, point):\n        \"\"\"\n        The scene is smaller than the graph.\n\n        Because of this, coordinates in the graph don't map\n        to coordinates on the scene.\n\n        This method returns a scaled coordinate for the scene,\n        given coordinates that correspond to the graph.\n\n        Parameters\n        ----------\n        point : np.ndarray\n            The point on the graph.\n\n        Returns\n        -------\n        tuple\n            The coordinates on the scene.\n        \"\"\"\n        return (self.x_axis.point_to_number(point), self.y_axis.point_to_number(point))",
  "def get_graph(self, func, color=None, x_min=None, x_max=None, **kwargs):\n        \"\"\"\n        This method gets a curve to plot on the graph.\n\n        Parameters\n        ----------\n        func : function\n            The function to plot. It's return value should be\n            the y-coordinate for a given x-coordinate\n\n        color : str, optional\n            The string of the RGB color of the curve. in Hexadecimal representation.\n\n        x_min : int, float, optional\n            The lower x_value from which to plot the curve.\n\n        x_max : int, float, optional\n            The higher x_value until which to plot the curve.\n\n        **kwargs :\n            Any valid keyword arguments of ParametricFunction.\n\n        Return\n        ------\n        ParametricFunction\n            The Parametric Curve for the function passed.\n\n        \"\"\"\n        if color is None:\n            color = next(self.default_graph_colors_cycle)\n        if x_min is None:\n            x_min = self.x_min\n        if x_max is None:\n            x_max = self.x_max\n\n        def parameterized_function(alpha):\n            x = interpolate(x_min, x_max, alpha)\n            y = func(x)\n            if not np.isfinite(y):\n                y = self.y_max\n            return self.coords_to_point(x, y)\n\n        graph = ParametricFunction(parameterized_function, color=color, **kwargs)\n        graph.underlying_function = func\n        return graph",
  "def input_to_graph_point(self, x, graph):\n        \"\"\"\n        This method returns a coordinate on the curve\n        given an x_value and a the graoh-curve for which\n        the corresponding y value should be found.\n\n        Parameters\n        ----------\n        x : int, float\n            The x value for which to find the y value.\n\n        graph : ParametricFunction\n            The ParametricFunction object on which\n            the x and y value lie.\n\n        Returns\n        -------\n        numpy.nparray\n            The array of the coordinates on the graph.\n        \"\"\"\n        return self.coords_to_point(x, graph.underlying_function(x))",
  "def angle_of_tangent(self, x, graph, dx=0.01):\n        \"\"\"\n        Returns the angle to the x axis of the tangent\n        to the plotted curve at a particular x-value.\n\n        Parameters\n        ----------\n        x : int, float\n            The x value at which the tangent must touch the curve.\n\n        graph : ParametricFunction\n            The ParametricFunction for which to calculate the tangent.\n\n        dx : int, float, optional\n            The small change in x with which a small change in y\n            will be compared in order to obtain the tangent.\n\n        Returns\n        -------\n        float\n            The angle of the tangent with the x axis.\n        \"\"\"\n        vect = self.input_to_graph_point(x + dx, graph) - self.input_to_graph_point(\n            x, graph\n        )\n        return angle_of_vector(vect)",
  "def slope_of_tangent(self, *args, **kwargs):\n        \"\"\"\n        Returns the slople of the tangent to the plotted curve\n        at a particular x-value.\n\n        Parameters\n        ----------\n        x : int, float\n            The x value at which the tangent must touch the curve.\n\n        graph : ParametricFunction\n            The ParametricFunction for which to calculate the tangent.\n\n        dx : int, float, optional\n            The small change in x with which a small change in y\n            will be compared in order to obtain the tangent.\n\n        Returns\n        -------\n        float\n            The slope of the tangent with the x axis.\n        \"\"\"\n        return np.tan(self.angle_of_tangent(*args, **kwargs))",
  "def get_derivative_graph(self, graph, dx=0.01, **kwargs):\n        \"\"\"\n        Returns the curve of the derivative of the passed\n        graph.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph for which the derivative must be found.\n\n        dx : float, int, optional\n            The small change in x with which a small change in y\n            will be compared in order to obtain the derivative.\n\n        **kwargs\n            Any valid keyword argument of ParametricFunction\n\n        Returns\n        -------\n        ParametricFunction\n            The curve of the derivative.\n        \"\"\"\n        if \"color\" not in kwargs:\n            kwargs[\"color\"] = self.default_derivative_color\n\n        def deriv(x):\n            return self.slope_of_tangent(x, graph, dx) / self.space_unit_to_y\n\n        return self.get_graph(deriv, **kwargs)",
  "def get_graph_label(\n        self,\n        graph,\n        label=\"f(x)\",\n        x_val=None,\n        direction=RIGHT,\n        buff=MED_SMALL_BUFF,\n        color=None,\n    ):\n        \"\"\"\n        This method returns a properly positioned label for the passed graph,\n        styled with the passed parameters.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The curve of the function plotted.\n\n        label : str, optional\n            The label for the function's curve.\n\n        x_val : int, float, optional\n            The x_value with which the label should be aligned.\n\n        direction : np.ndarray, list, tuple\n            The cartesian position, relative to the curve that the label will be at.\n            e.g LEFT, RIGHT\n\n        buff : float, int, option\n            The buffer space between the curve and the label\n\n        color : str, optional\n            The color of the label.\n\n        Returns\n        -------\n        TexMobject\n            The LaTeX of the passed 'label' parameter\n\n        \"\"\"\n        label = TexMobject(label)\n        color = color or graph.get_color()\n        label.set_color(color)\n        if x_val is None:\n            # Search from right to left\n            for x in np.linspace(self.x_max, self.x_min, 100):\n                point = self.input_to_graph_point(x, graph)\n                if point[1] < config[\"frame_y_radius\"]:\n                    break\n            x_val = x\n        label.next_to(self.input_to_graph_point(x_val, graph), direction, buff=buff)\n        label.shift_onto_screen()\n        return label",
  "def get_riemann_rectangles(\n        self,\n        graph,\n        x_min=None,\n        x_max=None,\n        dx=0.1,\n        input_sample_type=\"left\",\n        stroke_width=1,\n        stroke_color=BLACK,\n        fill_opacity=1,\n        start_color=None,\n        end_color=None,\n        show_signed_area=True,\n        width_scale_factor=1.001,\n    ):\n        \"\"\"\n        This method returns the VGroup() of the Riemann Rectangles for\n        a particular curve.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph whose area needs to be approximated\n            by the Riemann Rectangles.\n\n        x_min : int, float, optional\n            The lower bound from which to start adding rectangles\n\n        x_max : int, float, optional\n            The upper bound where the rectangles stop.\n\n        dx : int, float, optional\n            The smallest change in x-values that is\n            considered significant.\n\n        input_sample_type : {\"left\", \"right\", \"center\"}\n            Can be any of \"left\", \"right\" or \"center\n\n        stroke_width : int, float, optional\n            The stroke_width of the border of the rectangles.\n\n        stroke_color : str, optional\n            The string of hex colour of the rectangle's border.\n\n        fill_opacity : int, float\n            The opacity of the rectangles. Takes values from 0 to 1.\n\n        start_color : str, optional\n            The hex starting colour for the rectangles,\n            this will, if end_color is a different colour,\n            make a nice gradient.\n\n        end_color : str, optional\n            The hex ending colour for the rectangles,\n            this will, if start_color is a different colour,\n            make a nice gradient.\n\n        show_signed_area : bool, optional\n            Whether or not to indicate -ve area if curve dips below\n            x-axis.\n\n        width_scale_factor : int, float, optional\n            How much the width of the rectangles are scaled by when transforming.\n\n        Returns\n        -------\n        VGroup\n            A VGroup containing the Riemann Rectangles.\n\n        \"\"\"\n        x_min = x_min if x_min is not None else self.x_min\n        x_max = x_max if x_max is not None else self.x_max\n        if start_color is None:\n            start_color = self.default_riemann_start_color\n        if end_color is None:\n            end_color = self.default_riemann_end_color\n        rectangles = VGroup()\n        x_range = np.arange(x_min, x_max, dx)\n        colors = color_gradient([start_color, end_color], len(x_range))\n        for x, color in zip(x_range, colors):\n            if input_sample_type == \"left\":\n                sample_input = x\n            elif input_sample_type == \"right\":\n                sample_input = x + dx\n            elif input_sample_type == \"center\":\n                sample_input = x + 0.5 * dx\n            else:\n                raise Exception(\"Invalid input sample type\")\n            graph_point = self.input_to_graph_point(sample_input, graph)\n            points = VGroup(\n                *list(\n                    map(\n                        VectorizedPoint,\n                        [\n                            self.coords_to_point(x, 0),\n                            self.coords_to_point(x + width_scale_factor * dx, 0),\n                            graph_point,\n                        ],\n                    )\n                )\n            )\n\n            rect = Rectangle()\n            rect.replace(points, stretch=True)\n            if graph_point[1] < self.graph_origin[1] and show_signed_area:\n                fill_color = invert_color(color)\n            else:\n                fill_color = color\n            rect.set_fill(fill_color, opacity=fill_opacity)\n            rect.set_stroke(stroke_color, width=stroke_width)\n            rectangles.add(rect)\n        return rectangles",
  "def get_riemann_rectangles_list(\n        self, graph, n_iterations, max_dx=0.5, power_base=2, stroke_width=1, **kwargs\n    ):\n        \"\"\"\n        This method returns a list of multiple VGroups of Riemann\n        Rectangles. The inital VGroups are relatively inaccurate,\n        but the closer you get to the end the more accurate the Riemann\n        rectangles become\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph whose area needs to be approximated\n            by the Riemann Rectangles.\n\n        n_iterations : int,\n            The number of VGroups of successive accuracy that are needed.\n\n        max_dx : int, float, optional\n            The maximum change in x between two VGroups of Riemann Rectangles\n\n        power_base : int, float, optional\n            Defaults to 2\n\n        stroke_width : int, float, optional\n            The stroke_width of the border of the rectangles.\n\n        **kwargs\n            Any valid keyword arguments of get_riemann_rectangles.\n\n        Returns\n        -------\n        list\n            The list of Riemann Rectangles of increasing accuracy.\n        \"\"\"\n        return [\n            self.get_riemann_rectangles(\n                graph=graph,\n                dx=float(max_dx) / (power_base ** n),\n                stroke_width=float(stroke_width) / (power_base ** n),\n                **kwargs,\n            )\n            for n in range(n_iterations)\n        ]",
  "def get_area(self, graph, t_min, t_max):\n        \"\"\"\n        Returns a VGroup of Riemann rectangles\n        sufficiently small enough to visually\n        approximate the area under the graph passed.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph/curve for which the area needs to be gotten.\n\n        t_min : int, float\n            The lower bound of x from which to approximate the area.\n\n        t_max : int, float\n            The upper bound of x until which the area must be approximated.\n\n        Returns\n        -------\n        VGroup\n            The VGroup containing the Riemann Rectangles.\n        \"\"\"\n        numerator = max(t_max - t_min, 0.0001)\n        dx = float(numerator) / self.num_rects\n        return self.get_riemann_rectangles(\n            graph, x_min=t_min, x_max=t_max, dx=dx, stroke_width=0,\n        ).set_fill(opacity=self.area_opacity)",
  "def transform_between_riemann_rects(self, curr_rects, new_rects, **kwargs):\n        \"\"\"\n        This method is used to transform between two VGroups of Riemann Rectangles,\n        if they were obtained by get_riemann_rectangles or get_riemann_rectangles_list.\n        No animation is returned, and the animation is directly played.\n\n        Parameters\n        ----------\n        curr_rects : VGroup\n            The current Riemann Rectangles\n\n        new_rects : VGroup\n            The Riemann Rectangles to transform to.\n\n        **kwargs\n            added_anims\n                Any other animations to play simultaneously.\n        \"\"\"\n        transform_kwargs = {\"run_time\": 2, \"lag_ratio\": 0.5}\n        added_anims = kwargs.get(\"added_anims\", [])\n        transform_kwargs.update(kwargs)\n        curr_rects.align_submobjects(new_rects)\n        x_coords = set()  # Keep track of new repetitions\n        for rect in curr_rects:\n            x = rect.get_center()[0]\n            if x in x_coords:\n                rect.set_fill(opacity=0)\n            else:\n                x_coords.add(x)\n        self.play(Transform(curr_rects, new_rects, **transform_kwargs), *added_anims)",
  "def get_vertical_line_to_graph(self, x, graph, line_class=Line, **line_kwargs):\n        \"\"\"\n        This method returns a Vertical line from the x-axis to\n        the corresponding point on the graph/curve.\n\n        Parameters\n        ----------\n        x : int, float\n            The x-value at which the line should be placed/calculated.\n\n        graph : ParametricFunction\n            The graph on which the line should extend to.\n\n        line_class : Line and similar\n            The type of line that should be used.\n            Defaults to Line.\n\n        **line_kwargs\n            Any valid keyword arguments of the object passed in \"line_class\"\n            If line_class is Line, any valid keyword arguments of Line are allowed.\n\n        Return\n        ------\n        An object of type passed in \"line_class\"\n            Defaults to Line\n        \"\"\"\n        if \"color\" not in line_kwargs:\n            line_kwargs[\"color\"] = graph.get_color()\n        return line_class(\n            self.coords_to_point(x, 0),\n            self.input_to_graph_point(x, graph),\n            **line_kwargs,\n        )",
  "def get_vertical_lines_to_graph(\n        self, graph, x_min=None, x_max=None, num_lines=20, **kwargs\n    ):\n        \"\"\"\n        Obtains multiple lines from the x axis to the Graph/curve.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph on which the line should extend to.\n\n        x_min : int, float, optional\n            The lower bound from which lines can appear.\n\n        x_max : int, float, optional\n            The upper bound until which the lines can appear.\n\n        num_lines : int, optional\n            The number of lines (evenly spaced)\n            that are needed.\n\n        Returns\n        -------\n        VGroup\n            The VGroup of the evenly spaced lines.\n\n        \"\"\"\n        x_min = x_min or self.x_min\n        x_max = x_max or self.x_max\n        return VGroup(\n            *[\n                self.get_vertical_line_to_graph(x, graph, **kwargs)\n                for x in np.linspace(x_min, x_max, num_lines)\n            ]\n        )",
  "def get_secant_slope_group(\n        self,\n        x,\n        graph,\n        dx=None,\n        dx_line_color=None,\n        df_line_color=None,\n        dx_label=None,\n        df_label=None,\n        include_secant_line=True,\n        secant_line_color=None,\n        secant_line_length=10,\n    ):\n        \"\"\"\n        This method returns a VGroup of (two lines\n        representing dx and df, the labels for dx and\n        df, and the Secant to the Graph/curve at a\n        particular x value.\n\n        Parameters\n        ----------\n        x : int, float\n            The x value at which the secant enters, and intersects\n            the graph for the first time.\n\n        graph : ParametricFunction\n            The curve/graph for which the secant must\n            be found.\n\n        dx : int, float, optional\n            The change in x after which the secant exits.\n\n        dx_line_color : str, optional\n            The line color for the line that indicates the change in x.\n\n        df_line_color : str, optional\n            The line color for the line that indicates the change in y.\n\n        dx_label : str, optional\n            The label to be provided for the change in x.\n\n        df_label : str, optional\n            The label to be provided for the change in y.\n\n        include_secant_line : bool, optional\n            Whether or not to include the secant line in the graph,\n            or just have the df and dx lines and labels.\n\n        secant_line_color : str, optional\n            The color of the secant line.\n\n        secant_line_length : int, float, optional\n            How long the secant line should be.\n\n        Returns:\n        --------\n        VGroup\n            Resulting group is of the form VGroup(\n                dx_line,\n                df_line,\n                dx_label, (if applicable)\n                df_label, (if applicable)\n                secant_line, (if applicable)\n            )\n            with attributes of those names.\n        \"\"\"\n        kwargs = locals()\n        kwargs.pop(\"self\")\n        group = VGroup()\n        group.kwargs = kwargs\n\n        dx = dx or float(self.x_max - self.x_min) / 10\n        dx_line_color = dx_line_color or self.default_input_color\n        df_line_color = df_line_color or graph.get_color()\n\n        p1 = self.input_to_graph_point(x, graph)\n        p2 = self.input_to_graph_point(x + dx, graph)\n        interim_point = p2[0] * RIGHT + p1[1] * UP\n\n        group.dx_line = Line(p1, interim_point, color=dx_line_color)\n        group.df_line = Line(interim_point, p2, color=df_line_color)\n        group.add(group.dx_line, group.df_line)\n\n        labels = VGroup()\n        if dx_label is not None:\n            group.dx_label = TexMobject(dx_label)\n            labels.add(group.dx_label)\n            group.add(group.dx_label)\n        if df_label is not None:\n            group.df_label = TexMobject(df_label)\n            labels.add(group.df_label)\n            group.add(group.df_label)\n\n        if len(labels) > 0:\n            max_width = 0.8 * group.dx_line.get_width()\n            max_height = 0.8 * group.df_line.get_height()\n            if labels.get_width() > max_width:\n                labels.set_width(max_width)\n            if labels.get_height() > max_height:\n                labels.set_height(max_height)\n\n        if dx_label is not None:\n            group.dx_label.next_to(\n                group.dx_line, np.sign(dx) * DOWN, buff=group.dx_label.get_height() / 2\n            )\n            group.dx_label.set_color(group.dx_line.get_color())\n\n        if df_label is not None:\n            group.df_label.next_to(\n                group.df_line, np.sign(dx) * RIGHT, buff=group.df_label.get_height() / 2\n            )\n            group.df_label.set_color(group.df_line.get_color())\n\n        if include_secant_line:\n            secant_line_color = secant_line_color or self.default_derivative_color\n            group.secant_line = Line(p1, p2, color=secant_line_color)\n            group.secant_line.scale_in_place(\n                secant_line_length / group.secant_line.get_length()\n            )\n            group.add(group.secant_line)\n\n        return group",
  "def add_T_label(\n        self, x_val, side=RIGHT, label=None, color=WHITE, animated=False, **kwargs\n    ):\n        \"\"\"\n        This method adds to the Scene:\n            -- a Vertical line from the x-axis to the corresponding point on the graph/curve.\n            -- a small vertical Triangle whose top point lies on the base of the vertical line\n            -- a TexMobject to be a label for the Line and Triangle, at the bottom of the Triangle.\n        The scene needs to have the graph have the identifier/variable name self.v_graph.\n\n        Parameters\n        ----------\n        x_val : float, int\n            The x value at which the secant enters, and intersects\n            the graph for the first time.\n\n        side np.array(), optional\n\n        label : str, optional\n            The label to give the vertline and triangle\n\n        color : str, optional\n            The hex color of the label.\n\n        animated : bool, optional\n            Whether or not to animate the addition of the T_label\n\n        **kwargs\n            Any valid keyword argument of a self.play call.\n        \"\"\"\n        triangle = RegularPolygon(n=3, start_angle=np.pi / 2)\n        triangle.set_height(MED_SMALL_BUFF)\n        triangle.move_to(self.coords_to_point(x_val, 0), UP)\n        triangle.set_fill(color, 1)\n        triangle.set_stroke(width=0)\n        if label is None:\n            T_label = TexMobject(self.variable_point_label, fill_color=color)\n        else:\n            T_label = TexMobject(label, fill_color=color)\n\n        T_label.next_to(triangle, DOWN)\n        v_line = self.get_vertical_line_to_graph(x_val, self.v_graph, color=YELLOW)\n\n        if animated:\n            self.play(\n                DrawBorderThenFill(triangle),\n                ShowCreation(v_line),\n                Write(T_label, run_time=1),\n                **kwargs,\n            )\n\n        if np.all(side == LEFT):\n            self.left_T_label_group = VGroup(T_label, triangle)\n            self.left_v_line = v_line\n            self.add(self.left_T_label_group, self.left_v_line)\n        elif np.all(side == RIGHT):\n            self.right_T_label_group = VGroup(T_label, triangle)\n            self.right_v_line = v_line\n            self.add(self.right_T_label_group, self.right_v_line)",
  "def get_animation_integral_bounds_change(\n        self, graph, new_t_min, new_t_max, fade_close_to_origin=True, run_time=1.0\n    ):\n        \"\"\"\n        This method requires a lot of prerequisites:\n        self.area must be defined from self.get_area()\n        self.left_v_line and self.right_v_line must be defined from self.get_v_line\n        self.left_T_label_group and self.right_T_label_group must be defined from self.add_T_label\n\n        This method will return a VGroup of new mobjects for each of those, when provided the graph/curve,\n        the new t_min and t_max, the run_time and a bool stating whether or not to fade when close to\n        the origin.\n\n        Parameters\n        ----------\n        graph : ParametricFunction\n            The graph for which this must be done.\n\n        new_t_min : int, float\n            The new lower bound.\n\n        new_t_max : int, float\n            The new upper bound.\n\n        fade_close_to_origin : bool, optional\n            Whether or not to fade when close to the origin.\n\n        run_time : int, float, optional\n            The run_time of the animation of this change.\n        \"\"\"\n        curr_t_min = self.x_axis.point_to_number(self.area.get_left())\n        curr_t_max = self.x_axis.point_to_number(self.area.get_right())\n        if new_t_min is None:\n            new_t_min = curr_t_min\n        if new_t_max is None:\n            new_t_max = curr_t_max\n\n        group = VGroup(self.area)\n        group.add(self.left_v_line)\n        group.add(self.left_T_label_group)\n        group.add(self.right_v_line)\n        group.add(self.right_T_label_group)\n\n        def update_group(group, alpha):\n            area, left_v_line, left_T_label, right_v_line, right_T_label = group\n            t_min = interpolate(curr_t_min, new_t_min, alpha)\n            t_max = interpolate(curr_t_max, new_t_max, alpha)\n            new_area = self.get_area(graph, t_min, t_max)\n\n            new_left_v_line = self.get_vertical_line_to_graph(t_min, graph)\n            new_left_v_line.set_color(left_v_line.get_color())\n            left_T_label.move_to(new_left_v_line.get_bottom(), UP)\n\n            new_right_v_line = self.get_vertical_line_to_graph(t_max, graph)\n            new_right_v_line.set_color(right_v_line.get_color())\n            right_T_label.move_to(new_right_v_line.get_bottom(), UP)\n\n            # Fade close to 0\n            if fade_close_to_origin:\n                if len(left_T_label) > 0:\n                    left_T_label[0].set_fill(opacity=min(1, np.abs(t_min)))\n                if len(right_T_label) > 0:\n                    right_T_label[0].set_fill(opacity=min(1, np.abs(t_max)))\n\n            Transform(area, new_area).update(1)\n            Transform(left_v_line, new_left_v_line).update(1)\n            Transform(right_v_line, new_right_v_line).update(1)\n            return group\n\n        return UpdateFromAlphaFunc(group, update_group, run_time=run_time)",
  "def animate_secant_slope_group_change(\n        self,\n        secant_slope_group,\n        target_dx=None,\n        target_x=None,\n        run_time=3,\n        added_anims=None,\n        **anim_kwargs,\n    ):\n        \"\"\"\n        This method animates the change of the secant slope group  from\n        the old secant slope group, into a new secant slope group.\n\n        Parameters\n        ----------\n        secant_slope_group : VGroup\n            The old secant_slope_group\n\n        target_dx : int, float, optional\n            The new dx value.\n\n        target_x : int, float, optional\n            The new x value at which the secant should be.\n\n        run_time : int, float, optional\n            The run time for this change when animated.\n\n        added_anims : list, optional\n            Any exta animations that should be played alongside.\n\n        **anim_kwargs\n            Any valid kwargs of a self.play call.\n\n        NOTE: At least one of target_dx and target_x should be not None.\n        \"\"\"\n        if target_dx is None and target_x is None:\n            raise Exception(\"At least one of target_x and target_dx must not be None\")\n        if added_anims is None:\n            added_anims = []\n\n        start_dx = secant_slope_group.kwargs[\"dx\"]\n        start_x = secant_slope_group.kwargs[\"x\"]\n        if target_dx is None:\n            target_dx = start_dx\n        if target_x is None:\n            target_x = start_x\n\n        def update_func(group, alpha):\n            dx = interpolate(start_dx, target_dx, alpha)\n            x = interpolate(start_x, target_x, alpha)\n            kwargs = dict(secant_slope_group.kwargs)\n            kwargs[\"dx\"] = dx\n            kwargs[\"x\"] = x\n            new_group = self.get_secant_slope_group(**kwargs)\n            group.become(new_group)\n            return group\n\n        self.play(\n            UpdateFromAlphaFunc(\n                secant_slope_group, update_func, run_time=run_time, **anim_kwargs\n            ),\n            *added_anims,\n        )\n        secant_slope_group.kwargs[\"x\"] = target_x\n        secant_slope_group.kwargs[\"dx\"] = target_dx",
  "def parameterized_function(alpha):\n            x = interpolate(x_min, x_max, alpha)\n            y = func(x)\n            if not np.isfinite(y):\n                y = self.y_max\n            return self.coords_to_point(x, y)",
  "def deriv(x):\n            return self.slope_of_tangent(x, graph, dx) / self.space_unit_to_y",
  "def update_group(group, alpha):\n            area, left_v_line, left_T_label, right_v_line, right_T_label = group\n            t_min = interpolate(curr_t_min, new_t_min, alpha)\n            t_max = interpolate(curr_t_max, new_t_max, alpha)\n            new_area = self.get_area(graph, t_min, t_max)\n\n            new_left_v_line = self.get_vertical_line_to_graph(t_min, graph)\n            new_left_v_line.set_color(left_v_line.get_color())\n            left_T_label.move_to(new_left_v_line.get_bottom(), UP)\n\n            new_right_v_line = self.get_vertical_line_to_graph(t_max, graph)\n            new_right_v_line.set_color(right_v_line.get_color())\n            right_T_label.move_to(new_right_v_line.get_bottom(), UP)\n\n            # Fade close to 0\n            if fade_close_to_origin:\n                if len(left_T_label) > 0:\n                    left_T_label[0].set_fill(opacity=min(1, np.abs(t_min)))\n                if len(right_T_label) > 0:\n                    right_T_label[0].set_fill(opacity=min(1, np.abs(t_max)))\n\n            Transform(area, new_area).update(1)\n            Transform(left_v_line, new_left_v_line).update(1)\n            Transform(right_v_line, new_right_v_line).update(1)\n            return group",
  "def update_func(group, alpha):\n            dx = interpolate(start_dx, target_dx, alpha)\n            x = interpolate(start_x, target_x, alpha)\n            kwargs = dict(secant_slope_group.kwargs)\n            kwargs[\"dx\"] = dx\n            kwargs[\"x\"] = x\n            new_group = self.get_secant_slope_group(**kwargs)\n            group.become(new_group)\n            return group",
  "class ZoomedScene(MovingCameraScene):\n    \"\"\"\n    This is a Scene with special configurations made for when\n    a particular part of the scene must be zoomed in on and displayed\n    separately.\n    \"\"\"\n\n    CONFIG = {\n        \"camera_class\": MultiCamera,\n        \"zoomed_display_height\": 3,\n        \"zoomed_display_width\": 3,\n        \"zoomed_display_center\": None,\n        \"zoomed_display_corner\": UP + RIGHT,\n        \"zoomed_display_corner_buff\": DEFAULT_MOBJECT_TO_EDGE_BUFFER,\n        \"zoomed_camera_config\": {\n            \"default_frame_stroke_width\": 2,\n            \"background_opacity\": 1,\n        },\n        \"zoomed_camera_image_mobject_config\": {},\n        \"zoomed_camera_frame_starting_position\": ORIGIN,\n        \"zoom_factor\": 0.15,\n        \"image_frame_stroke_width\": 3,\n        \"zoom_activated\": False,\n    }\n\n    def setup(self):\n        \"\"\"\n        This method is used internally by Manim to\n        setup the scene for proper use.\n        \"\"\"\n        MovingCameraScene.setup(self)\n        # Initialize camera and display\n        zoomed_camera = MovingCamera(**self.zoomed_camera_config)\n        zoomed_display = ImageMobjectFromCamera(\n            zoomed_camera, **self.zoomed_camera_image_mobject_config\n        )\n        zoomed_display.add_display_frame()\n        for mob in zoomed_camera.frame, zoomed_display:\n            mob.stretch_to_fit_height(self.zoomed_display_height)\n            mob.stretch_to_fit_width(self.zoomed_display_width)\n        zoomed_camera.frame.scale(self.zoom_factor)\n\n        # Position camera and display\n        zoomed_camera.frame.move_to(self.zoomed_camera_frame_starting_position)\n        if self.zoomed_display_center is not None:\n            zoomed_display.move_to(self.zoomed_display_center)\n        else:\n            zoomed_display.to_corner(\n                self.zoomed_display_corner, buff=self.zoomed_display_corner_buff\n            )\n\n        self.zoomed_camera = zoomed_camera\n        self.zoomed_display = zoomed_display\n\n    def activate_zooming(self, animate=False):\n        \"\"\"\n        This method is used to activate the zooming for\n        the zoomed_camera.\n\n        Parameters\n        ----------\n        animate : bool, optional\n            Whether or not to animate the activation\n            of the zoomed camera.\n        \"\"\"\n        self.zoom_activated = True\n        self.camera.add_image_mobject_from_camera(self.zoomed_display)\n        if animate:\n            self.play(self.get_zoom_in_animation())\n            self.play(self.get_zoomed_display_pop_out_animation())\n        self.add_foreground_mobjects(\n            self.zoomed_camera.frame, self.zoomed_display,\n        )\n\n    def get_zoom_in_animation(self, run_time=2, **kwargs):\n        \"\"\"\n        Returns the animation of camera zooming in.\n\n        Parameters\n        ----------\n        run_time : int or float, optional\n            The run_time of the animation of the camera zooming in.\n        **kwargs\n            Any valid keyword arguments of ApplyMethod()\n\n        Returns\n        -------\n        ApplyMethod\n            The animation of the camera zooming in.\n        \"\"\"\n        frame = self.zoomed_camera.frame\n        full_frame_height = self.camera.get_frame_height()\n        full_frame_width = self.camera.get_frame_width()\n        frame.save_state()\n        frame.stretch_to_fit_width(full_frame_width)\n        frame.stretch_to_fit_height(full_frame_height)\n        frame.center()\n        frame.set_stroke(width=0)\n        return ApplyMethod(frame.restore, run_time=run_time, **kwargs)\n\n    def get_zoomed_display_pop_out_animation(self, **kwargs):\n        \"\"\"\n        This is the animation of the popping out of the\n        mini-display that shows the content of the zoomed\n        camera.\n\n        Returns\n        -------\n        ApplyMethod\n            The Animation of the Zoomed Display popping out.\n        \"\"\"\n        display = self.zoomed_display\n        display.save_state(use_deepcopy=True)\n        display.replace(self.zoomed_camera.frame, stretch=True)\n        return ApplyMethod(display.restore)\n\n    def get_zoom_factor(self):\n        \"\"\"\n        Returns the Zoom factor of the Zoomed camera.\n        Defined as the ratio between the height of the\n        zoomed camera and the height of the zoomed mini\n        display.\n        Returns\n        -------\n        float\n            The zoom factor.\n        \"\"\"\n        return fdiv(\n            self.zoomed_camera.frame.get_height(), self.zoomed_display.get_height()\n        )",
  "def setup(self):\n        \"\"\"\n        This method is used internally by Manim to\n        setup the scene for proper use.\n        \"\"\"\n        MovingCameraScene.setup(self)\n        # Initialize camera and display\n        zoomed_camera = MovingCamera(**self.zoomed_camera_config)\n        zoomed_display = ImageMobjectFromCamera(\n            zoomed_camera, **self.zoomed_camera_image_mobject_config\n        )\n        zoomed_display.add_display_frame()\n        for mob in zoomed_camera.frame, zoomed_display:\n            mob.stretch_to_fit_height(self.zoomed_display_height)\n            mob.stretch_to_fit_width(self.zoomed_display_width)\n        zoomed_camera.frame.scale(self.zoom_factor)\n\n        # Position camera and display\n        zoomed_camera.frame.move_to(self.zoomed_camera_frame_starting_position)\n        if self.zoomed_display_center is not None:\n            zoomed_display.move_to(self.zoomed_display_center)\n        else:\n            zoomed_display.to_corner(\n                self.zoomed_display_corner, buff=self.zoomed_display_corner_buff\n            )\n\n        self.zoomed_camera = zoomed_camera\n        self.zoomed_display = zoomed_display",
  "def activate_zooming(self, animate=False):\n        \"\"\"\n        This method is used to activate the zooming for\n        the zoomed_camera.\n\n        Parameters\n        ----------\n        animate : bool, optional\n            Whether or not to animate the activation\n            of the zoomed camera.\n        \"\"\"\n        self.zoom_activated = True\n        self.camera.add_image_mobject_from_camera(self.zoomed_display)\n        if animate:\n            self.play(self.get_zoom_in_animation())\n            self.play(self.get_zoomed_display_pop_out_animation())\n        self.add_foreground_mobjects(\n            self.zoomed_camera.frame, self.zoomed_display,\n        )",
  "def get_zoom_in_animation(self, run_time=2, **kwargs):\n        \"\"\"\n        Returns the animation of camera zooming in.\n\n        Parameters\n        ----------\n        run_time : int or float, optional\n            The run_time of the animation of the camera zooming in.\n        **kwargs\n            Any valid keyword arguments of ApplyMethod()\n\n        Returns\n        -------\n        ApplyMethod\n            The animation of the camera zooming in.\n        \"\"\"\n        frame = self.zoomed_camera.frame\n        full_frame_height = self.camera.get_frame_height()\n        full_frame_width = self.camera.get_frame_width()\n        frame.save_state()\n        frame.stretch_to_fit_width(full_frame_width)\n        frame.stretch_to_fit_height(full_frame_height)\n        frame.center()\n        frame.set_stroke(width=0)\n        return ApplyMethod(frame.restore, run_time=run_time, **kwargs)",
  "def get_zoomed_display_pop_out_animation(self, **kwargs):\n        \"\"\"\n        This is the animation of the popping out of the\n        mini-display that shows the content of the zoomed\n        camera.\n\n        Returns\n        -------\n        ApplyMethod\n            The Animation of the Zoomed Display popping out.\n        \"\"\"\n        display = self.zoomed_display\n        display.save_state(use_deepcopy=True)\n        display.replace(self.zoomed_camera.frame, stretch=True)\n        return ApplyMethod(display.restore)",
  "def get_zoom_factor(self):\n        \"\"\"\n        Returns the Zoom factor of the Zoomed camera.\n        Defined as the ratio between the height of the\n        zoomed camera and the height of the zoomed mini\n        display.\n        Returns\n        -------\n        float\n            The zoom factor.\n        \"\"\"\n        return fdiv(\n            self.zoomed_camera.frame.get_height(), self.zoomed_display.get_height()\n        )",
  "class ThreeDScene(Scene):\n    \"\"\"\n    This is a Scene, with special configurations and properties that\n    make it suitable for Three Dimensional Scenes.\n    \"\"\"\n\n    CONFIG = {\n        \"camera_class\": ThreeDCamera,\n        \"ambient_camera_rotation\": None,\n        \"default_angled_camera_orientation_kwargs\": {\n            \"phi\": 70 * DEGREES,\n            \"theta\": -135 * DEGREES,\n        },\n    }\n\n    def set_camera_orientation(self, phi=None, theta=None, distance=None, gamma=None):\n        \"\"\"\n        This method sets the orientation of the camera in the scene.\n\n        Parameters\n        ----------\n        phi : int or float, optional\n            The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        theta : int or float, optional\n            The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.\n\n        distance : int or float, optional\n            The radial distance between ORIGIN and Camera.\n\n        gamma : int or float, optional\n            The rotation of the camera about the vector from the ORIGIN to the Camera.\n        \"\"\"\n        if phi is not None:\n            self.camera.set_phi(phi)\n        if theta is not None:\n            self.camera.set_theta(theta)\n        if distance is not None:\n            self.camera.set_distance(distance)\n        if gamma is not None:\n            self.camera.set_gamma(gamma)\n\n    def begin_ambient_camera_rotation(self, rate=0.02):\n        \"\"\"\n        This method begins an ambient rotation of the camera about the Z_AXIS,\n        in the anticlockwise direction\n\n        Parameters\n        ----------\n        rate : int or float, optional\n            The rate at which the camera should rotate about the Z_AXIS.\n            Negative rate means clockwise rotation.\n        \"\"\"\n        # TODO, use a ValueTracker for rate, so that it\n        # can begin and end smoothly\n        self.camera.theta_tracker.add_updater(\n            lambda m, dt: m.increment_value(rate * dt)\n        )\n        self.add(self.camera.theta_tracker)\n\n    def stop_ambient_camera_rotation(self):\n        \"\"\"\n        This method stops all ambient camera rotation.\n        \"\"\"\n        self.camera.theta_tracker.clear_updaters()\n        self.remove(self.camera.theta_tracker)\n\n    def move_camera(\n        self,\n        phi=None,\n        theta=None,\n        distance=None,\n        gamma=None,\n        frame_center=None,\n        added_anims=[],\n        **kwargs,\n    ):\n        \"\"\"\n        This method animates the movement of the camera\n        to the given spherical coordinates.\n\n        Parameters\n        ----------\n        phi : int or float, optional\n            The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        theta : int or float, optional\n            The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.\n\n        distance : int or float, optional\n            The radial distance between ORIGIN and Camera.\n\n        gamma : int or float, optional\n            The rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        frame_center : list, tuple or np.array, optional\n            The new center of the camera frame in cartesian coordinates\n\n        added_anims : list, optional\n            Any other animations to be played at the same time.\n\n        \"\"\"\n        anims = []\n        value_tracker_pairs = [\n            (phi, self.camera.phi_tracker),\n            (theta, self.camera.theta_tracker),\n            (distance, self.camera.distance_tracker),\n            (gamma, self.camera.gamma_tracker),\n        ]\n        for value, tracker in value_tracker_pairs:\n            if value is not None:\n                anims.append(ApplyMethod(tracker.set_value, value, **kwargs))\n        if frame_center is not None:\n            anims.append(ApplyMethod(self.camera.frame_center.move_to, frame_center))\n\n        self.play(*anims + added_anims)\n\n    def get_moving_mobjects(self, *animations):\n        \"\"\"\n        This method returns a list of all of the Mobjects in the Scene that\n        are moving, that are also in the animations passed.\n\n        Parameters\n        ----------\n        *animations : Animation\n            The animations whose mobjects will be checked.\n        \"\"\"\n        moving_mobjects = Scene.get_moving_mobjects(self, *animations)\n        camera_mobjects = self.camera.get_value_trackers()\n        if any([cm in moving_mobjects for cm in camera_mobjects]):\n            return self.mobjects\n        return moving_mobjects\n\n    def add_fixed_orientation_mobjects(self, *mobjects, **kwargs):\n        \"\"\"\n        This method is used to prevent the rotation and tilting\n        of mobjects as the camera moves around. The mobject can\n        still move in the x,y,z directions, but will always be\n        at the angle (relative to the camera) that it was at\n        when it was passed through this method.)\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The Mobject(s) whose orientation must be fixed.\n\n        **kwargs\n            Some valid kwargs are\n                use_static_center_func : bool\n                center_func : function\n        \"\"\"\n        self.add(*mobjects)\n        self.camera.add_fixed_orientation_mobjects(*mobjects, **kwargs)\n\n    def add_fixed_in_frame_mobjects(self, *mobjects):\n        \"\"\"\n        This method is used to prevent the rotation and movement\n        of mobjects as the camera moves around. The mobject is\n        essentially overlayed, and is not impacted by the camera's\n        movement in any way.\n\n        Parameters\n        ----------\n        *mobjects : Mobjects\n            The Mobjects whose orientation must be fixed.\n        \"\"\"\n        self.add(*mobjects)\n        self.camera.add_fixed_in_frame_mobjects(*mobjects)\n\n    def remove_fixed_orientation_mobjects(self, *mobjects):\n        \"\"\"\n        This method \"unfixes\" the orientation of the mobjects\n        passed, meaning they will no longer be at the same angle\n        relative to the camera. This only makes sense if the\n        mobject was passed through add_fixed_orientation_mobjects first.\n\n        Parameters\n        ----------\n        *mobjects : Mobjects\n            The Mobjects whose orientation must be unfixed.\n        \"\"\"\n        self.camera.remove_fixed_orientation_mobjects(*mobjects)\n\n    def remove_fixed_in_frame_mobjects(self, *mobjects):\n        \"\"\"\n         This method undoes what add_fixed_in_frame_mobjects does.\n         It allows the mobject to be affected by the movement of\n         the camera.\n\n        Parameters\n        ----------\n        *mobjects : Mobjects\n            The Mobjects whose position and orientation must be unfixed.\n        \"\"\"\n        self.camera.remove_fixed_in_frame_mobjects(*mobjects)\n\n    ##\n    def set_to_default_angled_camera_orientation(self, **kwargs):\n        \"\"\"\n        This method sets the default_angled_camera_orientation to the\n        keyword arguments passed, and sets the camera to that orientation.\n\n        Parameters\n        ----------\n        **kwargs\n            Some recognised kwargs are phi, theta, distance, gamma,\n            which have the same meaning as the parameters in set_camera_orientation.\n        \"\"\"\n        config = dict(self.default_camera_orientation_kwargs)\n        config.update(kwargs)\n        self.set_camera_orientation(**config)",
  "class SpecialThreeDScene(ThreeDScene):\n    \"\"\"\n    This is basically ThreeDScene++ .\n    It has some extra configuration for\n    axes, spheres, lower quality etc.\n\n    Some key differences are:\n        The camera shades applicable 3DMobjects by default,\n        except if rendering in low quality.\n        Some default params for Spheres and Axes have been added.\n    \"\"\"\n\n    CONFIG = {\n        \"cut_axes_at_radius\": True,\n        \"camera_config\": {\n            \"should_apply_shading\": True,\n            \"exponential_projection\": True,\n        },\n        \"three_d_axes_config\": {\n            \"num_axis_pieces\": 1,\n            \"axis_config\": {\n                \"unit_size\": 2,\n                \"tick_frequency\": 1,\n                \"numbers_with_elongated_ticks\": [0, 1, 2],\n                \"stroke_width\": 2,\n            },\n        },\n        \"sphere_config\": {\"radius\": 2, \"resolution\": (24, 48),},\n        \"default_angled_camera_position\": {\n            \"phi\": 70 * DEGREES,\n            \"theta\": -110 * DEGREES,\n        },\n        # When scene is extracted with -l flag, this\n        # configuration will override the above configuration.\n        \"low_quality_config\": {\n            \"camera_config\": {\"should_apply_shading\": False,},\n            \"three_d_axes_config\": {\"num_axis_pieces\": 1,},\n            \"sphere_config\": {\"resolution\": (12, 24),},\n        },\n    }\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        if self.camera_config[\"pixel_width\"] == config[\"CAMERA_CONFIG\"][\"PIXEL_WIDTH\"]:\n            config = {}\n        else:\n            config = self.low_quality_config\n        config = merge_dicts_recursively(config, kwargs)\n        ThreeDScene.__init__(self, **config)\n\n    def get_axes(self):\n        \"\"\"\n        Returns a set of 3D Axes.\n\n        Returns\n        -------\n        ThreeDAxes\n        \"\"\"\n        axes = ThreeDAxes(**self.three_d_axes_config)\n        for axis in axes:\n            if self.cut_axes_at_radius:\n                p0 = axis.get_start()\n                p1 = axis.number_to_point(-1)\n                p2 = axis.number_to_point(1)\n                p3 = axis.get_end()\n                new_pieces = VGroup(Line(p0, p1), Line(p1, p2), Line(p2, p3),)\n                for piece in new_pieces:\n                    piece.shade_in_3d = True\n                new_pieces.match_style(axis.pieces)\n                axis.pieces.submobjects = new_pieces.submobjects\n            for tick in axis.tick_marks:\n                tick.add(VectorizedPoint(1.5 * tick.get_center(),))\n        return axes\n\n    def get_sphere(self, **kwargs):\n        \"\"\"\n        Returns a sphere with the passed **kwargs\n        as properties.\n\n        Parameters\n        ----------\n        **kwargs\n            Some valid kwargs are:\n                Any param of a Sphere or ParametricSurface.\n\n        Returns\n        -------\n        Sphere\n            The sphere object.\n        \"\"\"\n        config = merge_dicts_recursively(self.sphere_config, kwargs)\n        return Sphere(**config)\n\n    def get_default_camera_position(self):\n        \"\"\"\n        Returns the default_angled_camera position.\n\n        Returns\n        -------\n        dict\n            Dictionary of phi, theta, distance, and gamma.\n        \"\"\"\n        return self.default_angled_camera_position\n\n    def set_camera_to_default_position(self):\n        \"\"\"\n        Sets the camera to its default position.\n        \"\"\"\n        self.set_camera_orientation(**self.default_angled_camera_position)",
  "def set_camera_orientation(self, phi=None, theta=None, distance=None, gamma=None):\n        \"\"\"\n        This method sets the orientation of the camera in the scene.\n\n        Parameters\n        ----------\n        phi : int or float, optional\n            The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        theta : int or float, optional\n            The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.\n\n        distance : int or float, optional\n            The radial distance between ORIGIN and Camera.\n\n        gamma : int or float, optional\n            The rotation of the camera about the vector from the ORIGIN to the Camera.\n        \"\"\"\n        if phi is not None:\n            self.camera.set_phi(phi)\n        if theta is not None:\n            self.camera.set_theta(theta)\n        if distance is not None:\n            self.camera.set_distance(distance)\n        if gamma is not None:\n            self.camera.set_gamma(gamma)",
  "def begin_ambient_camera_rotation(self, rate=0.02):\n        \"\"\"\n        This method begins an ambient rotation of the camera about the Z_AXIS,\n        in the anticlockwise direction\n\n        Parameters\n        ----------\n        rate : int or float, optional\n            The rate at which the camera should rotate about the Z_AXIS.\n            Negative rate means clockwise rotation.\n        \"\"\"\n        # TODO, use a ValueTracker for rate, so that it\n        # can begin and end smoothly\n        self.camera.theta_tracker.add_updater(\n            lambda m, dt: m.increment_value(rate * dt)\n        )\n        self.add(self.camera.theta_tracker)",
  "def stop_ambient_camera_rotation(self):\n        \"\"\"\n        This method stops all ambient camera rotation.\n        \"\"\"\n        self.camera.theta_tracker.clear_updaters()\n        self.remove(self.camera.theta_tracker)",
  "def move_camera(\n        self,\n        phi=None,\n        theta=None,\n        distance=None,\n        gamma=None,\n        frame_center=None,\n        added_anims=[],\n        **kwargs,\n    ):\n        \"\"\"\n        This method animates the movement of the camera\n        to the given spherical coordinates.\n\n        Parameters\n        ----------\n        phi : int or float, optional\n            The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        theta : int or float, optional\n            The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.\n\n        distance : int or float, optional\n            The radial distance between ORIGIN and Camera.\n\n        gamma : int or float, optional\n            The rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        frame_center : list, tuple or np.array, optional\n            The new center of the camera frame in cartesian coordinates\n\n        added_anims : list, optional\n            Any other animations to be played at the same time.\n\n        \"\"\"\n        anims = []\n        value_tracker_pairs = [\n            (phi, self.camera.phi_tracker),\n            (theta, self.camera.theta_tracker),\n            (distance, self.camera.distance_tracker),\n            (gamma, self.camera.gamma_tracker),\n        ]\n        for value, tracker in value_tracker_pairs:\n            if value is not None:\n                anims.append(ApplyMethod(tracker.set_value, value, **kwargs))\n        if frame_center is not None:\n            anims.append(ApplyMethod(self.camera.frame_center.move_to, frame_center))\n\n        self.play(*anims + added_anims)",
  "def get_moving_mobjects(self, *animations):\n        \"\"\"\n        This method returns a list of all of the Mobjects in the Scene that\n        are moving, that are also in the animations passed.\n\n        Parameters\n        ----------\n        *animations : Animation\n            The animations whose mobjects will be checked.\n        \"\"\"\n        moving_mobjects = Scene.get_moving_mobjects(self, *animations)\n        camera_mobjects = self.camera.get_value_trackers()\n        if any([cm in moving_mobjects for cm in camera_mobjects]):\n            return self.mobjects\n        return moving_mobjects",
  "def add_fixed_orientation_mobjects(self, *mobjects, **kwargs):\n        \"\"\"\n        This method is used to prevent the rotation and tilting\n        of mobjects as the camera moves around. The mobject can\n        still move in the x,y,z directions, but will always be\n        at the angle (relative to the camera) that it was at\n        when it was passed through this method.)\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The Mobject(s) whose orientation must be fixed.\n\n        **kwargs\n            Some valid kwargs are\n                use_static_center_func : bool\n                center_func : function\n        \"\"\"\n        self.add(*mobjects)\n        self.camera.add_fixed_orientation_mobjects(*mobjects, **kwargs)",
  "def add_fixed_in_frame_mobjects(self, *mobjects):\n        \"\"\"\n        This method is used to prevent the rotation and movement\n        of mobjects as the camera moves around. The mobject is\n        essentially overlayed, and is not impacted by the camera's\n        movement in any way.\n\n        Parameters\n        ----------\n        *mobjects : Mobjects\n            The Mobjects whose orientation must be fixed.\n        \"\"\"\n        self.add(*mobjects)\n        self.camera.add_fixed_in_frame_mobjects(*mobjects)",
  "def remove_fixed_orientation_mobjects(self, *mobjects):\n        \"\"\"\n        This method \"unfixes\" the orientation of the mobjects\n        passed, meaning they will no longer be at the same angle\n        relative to the camera. This only makes sense if the\n        mobject was passed through add_fixed_orientation_mobjects first.\n\n        Parameters\n        ----------\n        *mobjects : Mobjects\n            The Mobjects whose orientation must be unfixed.\n        \"\"\"\n        self.camera.remove_fixed_orientation_mobjects(*mobjects)",
  "def remove_fixed_in_frame_mobjects(self, *mobjects):\n        \"\"\"\n         This method undoes what add_fixed_in_frame_mobjects does.\n         It allows the mobject to be affected by the movement of\n         the camera.\n\n        Parameters\n        ----------\n        *mobjects : Mobjects\n            The Mobjects whose position and orientation must be unfixed.\n        \"\"\"\n        self.camera.remove_fixed_in_frame_mobjects(*mobjects)",
  "def set_to_default_angled_camera_orientation(self, **kwargs):\n        \"\"\"\n        This method sets the default_angled_camera_orientation to the\n        keyword arguments passed, and sets the camera to that orientation.\n\n        Parameters\n        ----------\n        **kwargs\n            Some recognised kwargs are phi, theta, distance, gamma,\n            which have the same meaning as the parameters in set_camera_orientation.\n        \"\"\"\n        config = dict(self.default_camera_orientation_kwargs)\n        config.update(kwargs)\n        self.set_camera_orientation(**config)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        if self.camera_config[\"pixel_width\"] == config[\"CAMERA_CONFIG\"][\"PIXEL_WIDTH\"]:\n            config = {}\n        else:\n            config = self.low_quality_config\n        config = merge_dicts_recursively(config, kwargs)\n        ThreeDScene.__init__(self, **config)",
  "def get_axes(self):\n        \"\"\"\n        Returns a set of 3D Axes.\n\n        Returns\n        -------\n        ThreeDAxes\n        \"\"\"\n        axes = ThreeDAxes(**self.three_d_axes_config)\n        for axis in axes:\n            if self.cut_axes_at_radius:\n                p0 = axis.get_start()\n                p1 = axis.number_to_point(-1)\n                p2 = axis.number_to_point(1)\n                p3 = axis.get_end()\n                new_pieces = VGroup(Line(p0, p1), Line(p1, p2), Line(p2, p3),)\n                for piece in new_pieces:\n                    piece.shade_in_3d = True\n                new_pieces.match_style(axis.pieces)\n                axis.pieces.submobjects = new_pieces.submobjects\n            for tick in axis.tick_marks:\n                tick.add(VectorizedPoint(1.5 * tick.get_center(),))\n        return axes",
  "def get_sphere(self, **kwargs):\n        \"\"\"\n        Returns a sphere with the passed **kwargs\n        as properties.\n\n        Parameters\n        ----------\n        **kwargs\n            Some valid kwargs are:\n                Any param of a Sphere or ParametricSurface.\n\n        Returns\n        -------\n        Sphere\n            The sphere object.\n        \"\"\"\n        config = merge_dicts_recursively(self.sphere_config, kwargs)\n        return Sphere(**config)",
  "def get_default_camera_position(self):\n        \"\"\"\n        Returns the default_angled_camera position.\n\n        Returns\n        -------\n        dict\n            Dictionary of phi, theta, distance, and gamma.\n        \"\"\"\n        return self.default_angled_camera_position",
  "def set_camera_to_default_position(self):\n        \"\"\"\n        Sets the camera to its default position.\n        \"\"\"\n        self.set_camera_orientation(**self.default_angled_camera_position)",
  "class SampleSpaceScene(Scene):\n    def get_sample_space(self, **config):\n        self.sample_space = SampleSpace(**config)\n        return self.sample_space\n\n    def add_sample_space(self, **config):\n        self.add(self.get_sample_space(**config))\n\n    def get_division_change_animations(\n        self, sample_space, parts, p_list, dimension=1, new_label_kwargs=None, **kwargs\n    ):\n        if new_label_kwargs is None:\n            new_label_kwargs = {}\n        anims = []\n        p_list = sample_space.complete_p_list(p_list)\n        space_copy = sample_space.copy()\n\n        vect = DOWN if dimension == 1 else RIGHT\n        parts.generate_target()\n        for part, p in zip(parts.target, p_list):\n            part.replace(space_copy, stretch=True)\n            part.stretch(p, dimension)\n        parts.target.arrange(vect, buff=0)\n        parts.target.move_to(space_copy)\n        anims.append(MoveToTarget(parts))\n        if hasattr(parts, \"labels\") and parts.labels is not None:\n            label_kwargs = parts.label_kwargs\n            label_kwargs.update(new_label_kwargs)\n            new_braces, new_labels = sample_space.get_subdivision_braces_and_labels(\n                parts.target, **label_kwargs\n            )\n            anims += [\n                Transform(parts.braces, new_braces),\n                Transform(parts.labels, new_labels),\n            ]\n        return anims\n\n    def get_horizontal_division_change_animations(self, p_list, **kwargs):\n        assert hasattr(self.sample_space, \"horizontal_parts\")\n        return self.get_division_change_animations(\n            self.sample_space,\n            self.sample_space.horizontal_parts,\n            p_list,\n            dimension=1,\n            **kwargs,\n        )\n\n    def get_vertical_division_change_animations(self, p_list, **kwargs):\n        assert hasattr(self.sample_space, \"vertical_parts\")\n        return self.get_division_change_animations(\n            self.sample_space,\n            self.sample_space.vertical_parts,\n            p_list,\n            dimension=0,\n            **kwargs,\n        )\n\n    def get_conditional_change_anims(\n        self, sub_sample_space_index, value, post_rects=None, **kwargs\n    ):\n        parts = self.sample_space.horizontal_parts\n        sub_sample_space = parts[sub_sample_space_index]\n        anims = self.get_division_change_animations(\n            sub_sample_space,\n            sub_sample_space.vertical_parts,\n            value,\n            dimension=0,\n            **kwargs,\n        )\n        if post_rects is not None:\n            anims += self.get_posterior_rectangle_change_anims(post_rects)\n        return anims\n\n    def get_top_conditional_change_anims(self, *args, **kwargs):\n        return self.get_conditional_change_anims(0, *args, **kwargs)\n\n    def get_bottom_conditional_change_anims(self, *args, **kwargs):\n        return self.get_conditional_change_anims(1, *args, **kwargs)\n\n    def get_prior_rectangles(self):\n        return VGroup(\n            *[self.sample_space.horizontal_parts[i].vertical_parts[0] for i in range(2)]\n        )\n\n    def get_posterior_rectangles(self, buff=MED_LARGE_BUFF):\n        prior_rects = self.get_prior_rectangles()\n        areas = [rect.get_width() * rect.get_height() for rect in prior_rects]\n        total_area = sum(areas)\n        total_height = prior_rects.get_height()\n\n        post_rects = prior_rects.copy()\n        for rect, area in zip(post_rects, areas):\n            rect.stretch_to_fit_height(total_height * area / total_area)\n            rect.stretch_to_fit_width(area / rect.get_height())\n        post_rects.arrange(DOWN, buff=0)\n        post_rects.next_to(self.sample_space, RIGHT, buff)\n        return post_rects\n\n    def get_posterior_rectangle_braces_and_labels(\n        self, post_rects, labels, direction=RIGHT, **kwargs\n    ):\n        return self.sample_space.get_subdivision_braces_and_labels(\n            post_rects, labels, direction, **kwargs\n        )\n\n    def update_posterior_braces(self, post_rects):\n        braces = post_rects.braces\n        labels = post_rects.labels\n        for rect, brace, label in zip(post_rects, braces, labels):\n            brace.stretch_to_fit_height(rect.get_height())\n            brace.next_to(rect, RIGHT, SMALL_BUFF)\n            label.next_to(brace, RIGHT, SMALL_BUFF)\n\n    def get_posterior_rectangle_change_anims(self, post_rects):\n        def update_rects(rects):\n            new_rects = self.get_posterior_rectangles()\n            Transform(rects, new_rects).update(1)\n            if hasattr(rects, \"braces\"):\n                self.update_posterior_braces(rects)\n            return rects\n\n        anims = [UpdateFromFunc(post_rects, update_rects)]\n        if hasattr(post_rects, \"braces\"):\n            anims += list(map(Animation, [post_rects.labels, post_rects.braces]))\n        return anims",
  "def get_sample_space(self, **config):\n        self.sample_space = SampleSpace(**config)\n        return self.sample_space",
  "def add_sample_space(self, **config):\n        self.add(self.get_sample_space(**config))",
  "def get_division_change_animations(\n        self, sample_space, parts, p_list, dimension=1, new_label_kwargs=None, **kwargs\n    ):\n        if new_label_kwargs is None:\n            new_label_kwargs = {}\n        anims = []\n        p_list = sample_space.complete_p_list(p_list)\n        space_copy = sample_space.copy()\n\n        vect = DOWN if dimension == 1 else RIGHT\n        parts.generate_target()\n        for part, p in zip(parts.target, p_list):\n            part.replace(space_copy, stretch=True)\n            part.stretch(p, dimension)\n        parts.target.arrange(vect, buff=0)\n        parts.target.move_to(space_copy)\n        anims.append(MoveToTarget(parts))\n        if hasattr(parts, \"labels\") and parts.labels is not None:\n            label_kwargs = parts.label_kwargs\n            label_kwargs.update(new_label_kwargs)\n            new_braces, new_labels = sample_space.get_subdivision_braces_and_labels(\n                parts.target, **label_kwargs\n            )\n            anims += [\n                Transform(parts.braces, new_braces),\n                Transform(parts.labels, new_labels),\n            ]\n        return anims",
  "def get_horizontal_division_change_animations(self, p_list, **kwargs):\n        assert hasattr(self.sample_space, \"horizontal_parts\")\n        return self.get_division_change_animations(\n            self.sample_space,\n            self.sample_space.horizontal_parts,\n            p_list,\n            dimension=1,\n            **kwargs,\n        )",
  "def get_vertical_division_change_animations(self, p_list, **kwargs):\n        assert hasattr(self.sample_space, \"vertical_parts\")\n        return self.get_division_change_animations(\n            self.sample_space,\n            self.sample_space.vertical_parts,\n            p_list,\n            dimension=0,\n            **kwargs,\n        )",
  "def get_conditional_change_anims(\n        self, sub_sample_space_index, value, post_rects=None, **kwargs\n    ):\n        parts = self.sample_space.horizontal_parts\n        sub_sample_space = parts[sub_sample_space_index]\n        anims = self.get_division_change_animations(\n            sub_sample_space,\n            sub_sample_space.vertical_parts,\n            value,\n            dimension=0,\n            **kwargs,\n        )\n        if post_rects is not None:\n            anims += self.get_posterior_rectangle_change_anims(post_rects)\n        return anims",
  "def get_top_conditional_change_anims(self, *args, **kwargs):\n        return self.get_conditional_change_anims(0, *args, **kwargs)",
  "def get_bottom_conditional_change_anims(self, *args, **kwargs):\n        return self.get_conditional_change_anims(1, *args, **kwargs)",
  "def get_prior_rectangles(self):\n        return VGroup(\n            *[self.sample_space.horizontal_parts[i].vertical_parts[0] for i in range(2)]\n        )",
  "def get_posterior_rectangles(self, buff=MED_LARGE_BUFF):\n        prior_rects = self.get_prior_rectangles()\n        areas = [rect.get_width() * rect.get_height() for rect in prior_rects]\n        total_area = sum(areas)\n        total_height = prior_rects.get_height()\n\n        post_rects = prior_rects.copy()\n        for rect, area in zip(post_rects, areas):\n            rect.stretch_to_fit_height(total_height * area / total_area)\n            rect.stretch_to_fit_width(area / rect.get_height())\n        post_rects.arrange(DOWN, buff=0)\n        post_rects.next_to(self.sample_space, RIGHT, buff)\n        return post_rects",
  "def get_posterior_rectangle_braces_and_labels(\n        self, post_rects, labels, direction=RIGHT, **kwargs\n    ):\n        return self.sample_space.get_subdivision_braces_and_labels(\n            post_rects, labels, direction, **kwargs\n        )",
  "def update_posterior_braces(self, post_rects):\n        braces = post_rects.braces\n        labels = post_rects.labels\n        for rect, brace, label in zip(post_rects, braces, labels):\n            brace.stretch_to_fit_height(rect.get_height())\n            brace.next_to(rect, RIGHT, SMALL_BUFF)\n            label.next_to(brace, RIGHT, SMALL_BUFF)",
  "def get_posterior_rectangle_change_anims(self, post_rects):\n        def update_rects(rects):\n            new_rects = self.get_posterior_rectangles()\n            Transform(rects, new_rects).update(1)\n            if hasattr(rects, \"braces\"):\n                self.update_posterior_braces(rects)\n            return rects\n\n        anims = [UpdateFromFunc(post_rects, update_rects)]\n        if hasattr(post_rects, \"braces\"):\n            anims += list(map(Animation, [post_rects.labels, post_rects.braces]))\n        return anims",
  "def update_rects(rects):\n            new_rects = self.get_posterior_rectangles()\n            Transform(rects, new_rects).update(1)\n            if hasattr(rects, \"braces\"):\n                self.update_posterior_braces(rects)\n            return rects",
  "class MovingCameraScene(Scene):\n    \"\"\"\n    This is a Scene, with special configurations and properties that\n    make it suitable for cases where the camera must be moved around.\n    \"\"\"\n\n    CONFIG = {\"camera_class\": MovingCamera}\n\n    def setup(self):\n        \"\"\"\n        This method is used internally by Manim\n        to set up the scene for proper use.\n        \"\"\"\n        Scene.setup(self)\n        assert isinstance(self.camera, MovingCamera)\n        self.camera_frame = self.camera.frame\n        # Hmm, this currently relies on the fact that MovingCamera\n        # willd default to a full-sized frame.  Is that okay?\n        return self\n\n    def get_moving_mobjects(self, *animations):\n        \"\"\"\n        This method returns a list of all of the Mobjects in the Scene that\n        are moving, that are also in the animations passed.\n\n        Parameters\n        ----------\n        *animations : Animation\n            The Animations whose mobjects will be checked.\n        \"\"\"\n        moving_mobjects = Scene.get_moving_mobjects(self, *animations)\n        all_moving_mobjects = self.camera.extract_mobject_family_members(\n            moving_mobjects\n        )\n        movement_indicators = self.camera.get_mobjects_indicating_movement()\n        for movement_indicator in movement_indicators:\n            if movement_indicator in all_moving_mobjects:\n                # When one of these is moving, the camera should\n                # consider all mobjects to be moving\n                return list_update(self.mobjects, moving_mobjects)\n        return moving_mobjects",
  "def setup(self):\n        \"\"\"\n        This method is used internally by Manim\n        to set up the scene for proper use.\n        \"\"\"\n        Scene.setup(self)\n        assert isinstance(self.camera, MovingCamera)\n        self.camera_frame = self.camera.frame\n        # Hmm, this currently relies on the fact that MovingCamera\n        # willd default to a full-sized frame.  Is that okay?\n        return self",
  "def get_moving_mobjects(self, *animations):\n        \"\"\"\n        This method returns a list of all of the Mobjects in the Scene that\n        are moving, that are also in the animations passed.\n\n        Parameters\n        ----------\n        *animations : Animation\n            The Animations whose mobjects will be checked.\n        \"\"\"\n        moving_mobjects = Scene.get_moving_mobjects(self, *animations)\n        all_moving_mobjects = self.camera.extract_mobject_family_members(\n            moving_mobjects\n        )\n        movement_indicators = self.camera.get_mobjects_indicating_movement()\n        for movement_indicator in movement_indicators:\n            if movement_indicator in all_moving_mobjects:\n                # When one of these is moving, the camera should\n                # consider all mobjects to be moving\n                return list_update(self.mobjects, moving_mobjects)\n        return moving_mobjects",
  "class SceneFileWriter(object):\n    \"\"\"\n    SceneFileWriter is the object that actually writes the animations\n    played, into video files, using FFMPEG, and Sox, if sound is needed.\n    This is mostly for Manim's internal use. You will rarely, if ever,\n    have to use the methods for this class, unless tinkering with the very\n    fabric of Manim's reality.\n\n    Some useful attributes are:\n        \"write_to_movie\" (bool=False)\n            Whether or not to write the animations into a video file.\n        \"png_mode\" (str=\"RGBA\")\n            The PIL image mode to use when outputting PNGs\n        \"movie_file_extension\" (str=\".mp4\")\n            The file-type extension of the outputted video.\n    \"\"\"\n\n    def __init__(self, scene, **kwargs):\n        digest_config(self, kwargs)\n        self.scene = scene\n        self.stream_lock = False\n        self.init_output_directories()\n        self.init_audio()\n        self.frame_count = 0\n\n    # Output directories and files\n    def init_output_directories(self):\n        \"\"\"\n        This method initialises the directories to which video\n        files will be written to and read from (within MEDIA_DIR).\n        If they don't already exist, they will be created.\n        \"\"\"\n        module_directory = self.get_default_module_directory()\n        scene_name = self.get_default_scene_name()\n        if file_writer_config[\"save_last_frame\"] or file_writer_config[\"save_pngs\"]:\n            if file_writer_config[\"media_dir\"] != \"\":\n                image_dir = guarantee_existence(\n                    os.path.join(\n                        file_writer_config[\"media_dir\"], \"images\", module_directory,\n                    )\n                )\n            self.image_file_path = os.path.join(\n                image_dir, add_extension_if_not_present(scene_name, \".png\")\n            )\n\n        if file_writer_config[\"write_to_movie\"]:\n            if file_writer_config[\"video_dir\"]:\n                movie_dir = guarantee_existence(\n                    os.path.join(\n                        file_writer_config[\"video_dir\"],\n                        module_directory,\n                        self.get_resolution_directory(),\n                    )\n                )\n            self.movie_file_path = os.path.join(\n                movie_dir,\n                add_extension_if_not_present(\n                    scene_name, file_writer_config[\"movie_file_extension\"]\n                ),\n            )\n            self.gif_file_path = os.path.join(\n                movie_dir, add_extension_if_not_present(scene_name, GIF_FILE_EXTENSION)\n            )\n            self.partial_movie_directory = guarantee_existence(\n                os.path.join(movie_dir, \"partial_movie_files\", scene_name,)\n            )\n\n    def get_default_module_directory(self):\n        \"\"\"\n        This method gets the name of the directory containing\n        the file that has the Scene that is being rendered.\n\n        Returns\n        -------\n        str\n            The name of the directory.\n        \"\"\"\n        filename = os.path.basename(file_writer_config[\"input_file\"])\n        root, _ = os.path.splitext(filename)\n        return root\n\n    def get_default_scene_name(self):\n        \"\"\"\n        This method returns the default scene name\n        which is the value of \"output_file\", if it exists and\n        the actual name of the class that inherited from\n        Scene in your animation script, if \"output_file\" is None.\n\n        Returns\n        -------\n        str\n            The default scene name.\n        \"\"\"\n        fn = file_writer_config[\"output_file\"]\n        return fn if fn else self.scene.__class__.__name__\n\n    def get_resolution_directory(self):\n        \"\"\"\n        This method gets the name of the directory that immediately contains the\n        video file. This name is <height_in_pixels_of_video>p<frame_rate>\n        E.G:\n            If you are rendering an 854x480 px animation at 15fps, the name of the directory\n            that immediately contains the video file will be\n            480p15.\n            The file structure should look something like:\n\n            MEDIA_DIR\n                |--Tex\n                |--texts\n                |--videos\n                |--<name_of_file_containing_scene>\n                    |--<height_in_pixels_of_video>p<frame_rate>\n                        |--<scene_name>.mp4\n        Returns\n        -------\n        str\n            The name of the directory.\n        \"\"\"\n        pixel_height = self.scene.camera.pixel_height\n        frame_rate = self.scene.camera.frame_rate\n        return \"{}p{}\".format(pixel_height, frame_rate)\n\n    # Directory getters\n    def get_image_file_path(self):\n        \"\"\"\n        This returns the directory path to which any images will be\n        written to.\n        It is usually named \"images\", but can be changed by changing\n        \"image_file_path\".\n\n        Returns\n        -------\n        str\n            The path of the directory.\n        \"\"\"\n        return self.image_file_path\n\n    def get_next_partial_movie_path(self):\n        \"\"\"\n        Manim renders each play-like call in a short partial\n        video file. All such files are then concatenated with\n        the help of FFMPEG.\n\n        This method returns the path of the next partial movie.\n\n        Returns\n        -------\n        str\n            The path of the next partial movie.\n        \"\"\"\n        result = os.path.join(\n            self.partial_movie_directory,\n            \"{:05}{}\".format(\n                self.scene.num_plays, file_writer_config[\"movie_file_extension\"],\n            ),\n        )\n        return result\n\n    def get_movie_file_path(self):\n        \"\"\"\n        Returns the final path of the written video file.\n\n        Returns\n        -------\n        str\n            The path of the movie file.\n        \"\"\"\n        return self.movie_file_path\n\n    # Sound\n    def init_audio(self):\n        \"\"\"\n        Preps the writer for adding audio to the movie.\n        \"\"\"\n        self.includes_sound = False\n\n    def create_audio_segment(self):\n        \"\"\"\n        Creates an empty, silent, Audio Segment.\n        \"\"\"\n        self.audio_segment = AudioSegment.silent()\n\n    def add_audio_segment(self, new_segment, time=None, gain_to_background=None):\n        \"\"\"\n        This method adds an audio segment from an\n        AudioSegment type object and suitable parameters.\n\n        Parameters\n        ----------\n        new_segment : AudioSegment\n            The audio segment to add\n\n        time : int, float, optional\n            the timestamp at which the\n            sound should be added.\n\n        gain_to_background : optional\n            The gain of the segment from the background.\n        \"\"\"\n        if not self.includes_sound:\n            self.includes_sound = True\n            self.create_audio_segment()\n        segment = self.audio_segment\n        curr_end = segment.duration_seconds\n        if time is None:\n            time = curr_end\n        if time < 0:\n            raise Exception(\"Adding sound at timestamp < 0\")\n\n        new_end = time + new_segment.duration_seconds\n        diff = new_end - curr_end\n        if diff > 0:\n            segment = segment.append(\n                AudioSegment.silent(int(np.ceil(diff * 1000))), crossfade=0,\n            )\n        self.audio_segment = segment.overlay(\n            new_segment,\n            position=int(1000 * time),\n            gain_during_overlay=gain_to_background,\n        )\n\n    def add_sound(self, sound_file, time=None, gain=None, **kwargs):\n        \"\"\"\n        This method adds an audio segment from a sound file.\n\n        Parameters\n        ----------\n        sound_file : str\n            The path to the sound file.\n\n        time : float or int, optional\n            The timestamp at which the audio should be added.\n\n        gain : optional\n            The gain of the given audio segment.\n\n        **kwargs\n            This method uses add_audio_segment, so any keyword arguments\n            used there can be referenced here.\n\n        \"\"\"\n        file_path = get_full_sound_file_path(sound_file)\n        new_segment = AudioSegment.from_file(file_path)\n        if gain:\n            new_segment = new_segment.apply_gain(gain)\n        self.add_audio_segment(new_segment, time, **kwargs)\n\n    # Writers\n    def begin_animation(self, allow_write=False):\n        \"\"\"\n        Used internally by manim to stream the animation to FFMPEG for\n        displaying or writing to a file.\n\n        Parameters\n        ----------\n        allow_write : bool, optional\n            Whether or not to write to a video file.\n        \"\"\"\n        if file_writer_config[\"write_to_movie\"] and allow_write:\n            self.open_movie_pipe()\n\n    def end_animation(self, allow_write=False):\n        \"\"\"\n        Internally used by Manim to stop streaming to\n        FFMPEG gracefully.\n\n        Parameters\n        ----------\n        allow_write : bool, optional\n            Whether or not to write to a video file.\n        \"\"\"\n        if file_writer_config[\"write_to_movie\"] and allow_write:\n            self.close_movie_pipe()\n\n    def write_frame(self, frame):\n        \"\"\"\n        Used internally by Manim to write a frame to\n        the FFMPEG input buffer.\n\n        Parameters\n        ----------\n        frame : np.array\n            Pixel array of the frame.\n        \"\"\"\n        if file_writer_config[\"write_to_movie\"]:\n            self.writing_process.stdin.write(frame.tostring())\n        if file_writer_config[\"save_pngs\"]:\n            path, extension = os.path.splitext(self.image_file_path)\n            Image.fromarray(frame).save(f\"{path}{self.frame_count}{extension}\")\n            self.frame_count += 1\n\n    def save_final_image(self, image):\n        \"\"\"\n        The name is a misnomer. This method saves the image\n        passed to it as an in the default image directory.\n\n        Parameters\n        ----------\n        image : np.array\n            The pixel array of the image to save.\n        \"\"\"\n        file_path = self.get_image_file_path()\n        image.save(file_path)\n        self.print_file_ready_message(file_path)\n\n    def idle_stream(self):\n        \"\"\"\n        Doesn't write anything to the FFMPEG frame buffer.\n        \"\"\"\n        while self.stream_lock:\n            a = datetime.datetime.now()\n            self.update_frame()\n            n_frames = 1\n            frame = self.get_frame()\n            self.add_frames(*[frame] * n_frames)\n            b = datetime.datetime.now()\n            time_diff = (b - a).total_seconds()\n            frame_duration = 1 / self.scene.camera.frame_rate\n            if time_diff < frame_duration:\n                sleep(frame_duration - time_diff)\n\n    def finish(self):\n        \"\"\"\n        Finishes writing to the FFMPEG buffer.\n        Combines the partial movie files into the\n        whole scene.\n        If save_last_frame is True, saves the last\n        frame in the default image directory.\n        \"\"\"\n        if file_writer_config[\"write_to_movie\"]:\n            if hasattr(self, \"writing_process\"):\n                self.writing_process.terminate()\n            self.combine_movie_files()\n        if file_writer_config[\"save_last_frame\"]:\n            self.scene.update_frame(ignore_skipping=True)\n            self.save_final_image(self.scene.get_image())\n\n    def open_movie_pipe(self):\n        \"\"\"\n        Used internally by Manim to initalise\n        FFMPEG and begin writing to FFMPEG's input\n        buffer.\n        \"\"\"\n        file_path = self.get_next_partial_movie_path()\n        temp_file_path = (\n            os.path.splitext(file_path)[0]\n            + \"_temp\"\n            + file_writer_config[\"movie_file_extension\"]\n        )\n        self.partial_movie_file_path = file_path\n        self.temp_partial_movie_file_path = temp_file_path\n\n        fps = self.scene.camera.frame_rate\n        height = self.scene.camera.get_pixel_height()\n        width = self.scene.camera.get_pixel_width()\n\n        command = [\n            FFMPEG_BIN,\n            \"-y\",  # overwrite output file if it exists\n            \"-f\",\n            \"rawvideo\",\n            \"-s\",\n            \"%dx%d\" % (width, height),  # size of one frame\n            \"-pix_fmt\",\n            \"rgba\",\n            \"-r\",\n            str(fps),  # frames per second\n            \"-i\",\n            \"-\",  # The imput comes from a pipe\n            \"-an\",  # Tells FFMPEG not to expect any audio\n            \"-loglevel\",\n            \"error\",\n        ]\n        # TODO, the test for a transparent background should not be based on\n        # the file extension.\n        if file_writer_config[\"movie_file_extension\"] == \".mov\":\n            # This is if the background of the exported\n            # video should be transparent.\n            command += [\n                \"-vcodec\",\n                \"qtrle\",\n            ]\n        else:\n            command += [\n                \"-vcodec\",\n                \"libx264\",\n                \"-pix_fmt\",\n                \"yuv420p\",\n            ]\n        command += [temp_file_path]\n        self.writing_process = subprocess.Popen(command, stdin=subprocess.PIPE)\n\n    def close_movie_pipe(self):\n        \"\"\"\n        Used internally by Manim to gracefully stop writing to FFMPEG's\n        input buffer, and move the temporary files into their permananant\n        locations\n        \"\"\"\n        self.writing_process.stdin.close()\n        self.writing_process.wait()\n        shutil.move(\n            self.temp_partial_movie_file_path, self.partial_movie_file_path,\n        )\n\n    def combine_movie_files(self):\n        \"\"\"\n        Used internally by Manim to combine the separate\n        partial movie files that make up a Scene into a single\n        video file for that Scene.\n        \"\"\"\n        # Manim renders the scene as many smaller movie files\n        # which are then concatenated to a larger one.  The reason\n        # for this is that sometimes video-editing is made easier when\n        # one works with the broken up scene, which effectively has\n        # cuts at all the places you might want.  But for viewing\n        # the scene as a whole, one of course wants to see it as a\n        # single piece.\n        kwargs = {\n            \"remove_non_integer_files\": True,\n            \"extension\": file_writer_config[\"movie_file_extension\"],\n        }\n        if file_writer_config['from_animation_number'] is not None:\n            kwargs[\"min_index\"] = file_writer_config['from_animation_number']\n        if file_writer_config['upto_animation_number'] not in [None, np.inf]:\n            kwargs[\"max_index\"] = file_writer_config['upto_animation_number']\n        else:\n            kwargs[\"remove_indices_greater_than\"] = self.scene.num_plays - 1\n        partial_movie_files = get_sorted_integer_files(\n            self.partial_movie_directory, **kwargs\n        )\n        if len(partial_movie_files) == 0:\n            logger.error(\"No animations in this scene\")\n            return\n\n        # Write a file partial_file_list.txt containing all\n        # partial movie files\n        file_list = os.path.join(\n            self.partial_movie_directory, \"partial_movie_file_list.txt\"\n        )\n        with open(file_list, \"w\") as fp:\n            for pf_path in partial_movie_files:\n                if os.name == \"nt\":\n                    pf_path = pf_path.replace(\"\\\\\", \"/\")\n                fp.write(\"file 'file:{}'\\n\".format(pf_path))\n\n        movie_file_path = self.get_movie_file_path()\n        commands = [\n            FFMPEG_BIN,\n            \"-y\",  # overwrite output file if it exists\n            \"-f\",\n            \"concat\",\n            \"-safe\",\n            \"0\",\n            \"-i\",\n            file_list,\n            \"-loglevel\",\n            \"error\",\n        ]\n\n        if self.write_to_movie:\n            commands += [\"-c\", \"copy\", movie_file_path]\n\n        if self.save_as_gif:\n            commands += [self.gif_file_path]\n        if not self.includes_sound:\n            commands.insert(-1, \"-an\")\n\n        combine_process = subprocess.Popen(commands)\n        combine_process.wait()\n\n        if self.includes_sound:\n            sound_file_path = movie_file_path.replace(\n                file_writer_config[\"movie_file_extension\"], \".wav\"\n            )\n            # Makes sure sound file length will match video file\n            self.add_audio_segment(AudioSegment.silent(0))\n            self.audio_segment.export(\n                sound_file_path, bitrate=\"312k\",\n            )\n            temp_file_path = movie_file_path.replace(\".\", \"_temp.\")\n            commands = [\n                FFMPEG_BIN,\n                \"-i\",\n                movie_file_path,\n                \"-i\",\n                sound_file_path,\n                \"-y\",  # overwrite output file if it exists\n                \"-c:v\",\n                \"copy\",\n                \"-c:a\",\n                \"aac\",\n                \"-b:a\",\n                \"320k\",\n                # select video stream from first file\n                \"-map\",\n                \"0:v:0\",\n                # select audio stream from second file\n                \"-map\",\n                \"1:a:0\",\n                \"-loglevel\",\n                \"error\",\n                # \"-shortest\",\n                temp_file_path,\n            ]\n            subprocess.call(commands)\n            shutil.move(temp_file_path, movie_file_path)\n            os.remove(sound_file_path)\n\n        self.print_file_ready_message(movie_file_path)\n\n    def print_file_ready_message(self, file_path):\n        \"\"\"\n        Prints the \"File Ready\" message to STDOUT.\n        \"\"\"\n        logger.info(\"\\nFile ready at {}\\n\".format(file_path))",
  "def __init__(self, scene, **kwargs):\n        digest_config(self, kwargs)\n        self.scene = scene\n        self.stream_lock = False\n        self.init_output_directories()\n        self.init_audio()\n        self.frame_count = 0",
  "def init_output_directories(self):\n        \"\"\"\n        This method initialises the directories to which video\n        files will be written to and read from (within MEDIA_DIR).\n        If they don't already exist, they will be created.\n        \"\"\"\n        module_directory = self.get_default_module_directory()\n        scene_name = self.get_default_scene_name()\n        if file_writer_config[\"save_last_frame\"] or file_writer_config[\"save_pngs\"]:\n            if file_writer_config[\"media_dir\"] != \"\":\n                image_dir = guarantee_existence(\n                    os.path.join(\n                        file_writer_config[\"media_dir\"], \"images\", module_directory,\n                    )\n                )\n            self.image_file_path = os.path.join(\n                image_dir, add_extension_if_not_present(scene_name, \".png\")\n            )\n\n        if file_writer_config[\"write_to_movie\"]:\n            if file_writer_config[\"video_dir\"]:\n                movie_dir = guarantee_existence(\n                    os.path.join(\n                        file_writer_config[\"video_dir\"],\n                        module_directory,\n                        self.get_resolution_directory(),\n                    )\n                )\n            self.movie_file_path = os.path.join(\n                movie_dir,\n                add_extension_if_not_present(\n                    scene_name, file_writer_config[\"movie_file_extension\"]\n                ),\n            )\n            self.gif_file_path = os.path.join(\n                movie_dir, add_extension_if_not_present(scene_name, GIF_FILE_EXTENSION)\n            )\n            self.partial_movie_directory = guarantee_existence(\n                os.path.join(movie_dir, \"partial_movie_files\", scene_name,)\n            )",
  "def get_default_module_directory(self):\n        \"\"\"\n        This method gets the name of the directory containing\n        the file that has the Scene that is being rendered.\n\n        Returns\n        -------\n        str\n            The name of the directory.\n        \"\"\"\n        filename = os.path.basename(file_writer_config[\"input_file\"])\n        root, _ = os.path.splitext(filename)\n        return root",
  "def get_default_scene_name(self):\n        \"\"\"\n        This method returns the default scene name\n        which is the value of \"output_file\", if it exists and\n        the actual name of the class that inherited from\n        Scene in your animation script, if \"output_file\" is None.\n\n        Returns\n        -------\n        str\n            The default scene name.\n        \"\"\"\n        fn = file_writer_config[\"output_file\"]\n        return fn if fn else self.scene.__class__.__name__",
  "def get_resolution_directory(self):\n        \"\"\"\n        This method gets the name of the directory that immediately contains the\n        video file. This name is <height_in_pixels_of_video>p<frame_rate>\n        E.G:\n            If you are rendering an 854x480 px animation at 15fps, the name of the directory\n            that immediately contains the video file will be\n            480p15.\n            The file structure should look something like:\n\n            MEDIA_DIR\n                |--Tex\n                |--texts\n                |--videos\n                |--<name_of_file_containing_scene>\n                    |--<height_in_pixels_of_video>p<frame_rate>\n                        |--<scene_name>.mp4\n        Returns\n        -------\n        str\n            The name of the directory.\n        \"\"\"\n        pixel_height = self.scene.camera.pixel_height\n        frame_rate = self.scene.camera.frame_rate\n        return \"{}p{}\".format(pixel_height, frame_rate)",
  "def get_image_file_path(self):\n        \"\"\"\n        This returns the directory path to which any images will be\n        written to.\n        It is usually named \"images\", but can be changed by changing\n        \"image_file_path\".\n\n        Returns\n        -------\n        str\n            The path of the directory.\n        \"\"\"\n        return self.image_file_path",
  "def get_next_partial_movie_path(self):\n        \"\"\"\n        Manim renders each play-like call in a short partial\n        video file. All such files are then concatenated with\n        the help of FFMPEG.\n\n        This method returns the path of the next partial movie.\n\n        Returns\n        -------\n        str\n            The path of the next partial movie.\n        \"\"\"\n        result = os.path.join(\n            self.partial_movie_directory,\n            \"{:05}{}\".format(\n                self.scene.num_plays, file_writer_config[\"movie_file_extension\"],\n            ),\n        )\n        return result",
  "def get_movie_file_path(self):\n        \"\"\"\n        Returns the final path of the written video file.\n\n        Returns\n        -------\n        str\n            The path of the movie file.\n        \"\"\"\n        return self.movie_file_path",
  "def init_audio(self):\n        \"\"\"\n        Preps the writer for adding audio to the movie.\n        \"\"\"\n        self.includes_sound = False",
  "def create_audio_segment(self):\n        \"\"\"\n        Creates an empty, silent, Audio Segment.\n        \"\"\"\n        self.audio_segment = AudioSegment.silent()",
  "def add_audio_segment(self, new_segment, time=None, gain_to_background=None):\n        \"\"\"\n        This method adds an audio segment from an\n        AudioSegment type object and suitable parameters.\n\n        Parameters\n        ----------\n        new_segment : AudioSegment\n            The audio segment to add\n\n        time : int, float, optional\n            the timestamp at which the\n            sound should be added.\n\n        gain_to_background : optional\n            The gain of the segment from the background.\n        \"\"\"\n        if not self.includes_sound:\n            self.includes_sound = True\n            self.create_audio_segment()\n        segment = self.audio_segment\n        curr_end = segment.duration_seconds\n        if time is None:\n            time = curr_end\n        if time < 0:\n            raise Exception(\"Adding sound at timestamp < 0\")\n\n        new_end = time + new_segment.duration_seconds\n        diff = new_end - curr_end\n        if diff > 0:\n            segment = segment.append(\n                AudioSegment.silent(int(np.ceil(diff * 1000))), crossfade=0,\n            )\n        self.audio_segment = segment.overlay(\n            new_segment,\n            position=int(1000 * time),\n            gain_during_overlay=gain_to_background,\n        )",
  "def add_sound(self, sound_file, time=None, gain=None, **kwargs):\n        \"\"\"\n        This method adds an audio segment from a sound file.\n\n        Parameters\n        ----------\n        sound_file : str\n            The path to the sound file.\n\n        time : float or int, optional\n            The timestamp at which the audio should be added.\n\n        gain : optional\n            The gain of the given audio segment.\n\n        **kwargs\n            This method uses add_audio_segment, so any keyword arguments\n            used there can be referenced here.\n\n        \"\"\"\n        file_path = get_full_sound_file_path(sound_file)\n        new_segment = AudioSegment.from_file(file_path)\n        if gain:\n            new_segment = new_segment.apply_gain(gain)\n        self.add_audio_segment(new_segment, time, **kwargs)",
  "def begin_animation(self, allow_write=False):\n        \"\"\"\n        Used internally by manim to stream the animation to FFMPEG for\n        displaying or writing to a file.\n\n        Parameters\n        ----------\n        allow_write : bool, optional\n            Whether or not to write to a video file.\n        \"\"\"\n        if file_writer_config[\"write_to_movie\"] and allow_write:\n            self.open_movie_pipe()",
  "def end_animation(self, allow_write=False):\n        \"\"\"\n        Internally used by Manim to stop streaming to\n        FFMPEG gracefully.\n\n        Parameters\n        ----------\n        allow_write : bool, optional\n            Whether or not to write to a video file.\n        \"\"\"\n        if file_writer_config[\"write_to_movie\"] and allow_write:\n            self.close_movie_pipe()",
  "def write_frame(self, frame):\n        \"\"\"\n        Used internally by Manim to write a frame to\n        the FFMPEG input buffer.\n\n        Parameters\n        ----------\n        frame : np.array\n            Pixel array of the frame.\n        \"\"\"\n        if file_writer_config[\"write_to_movie\"]:\n            self.writing_process.stdin.write(frame.tostring())\n        if file_writer_config[\"save_pngs\"]:\n            path, extension = os.path.splitext(self.image_file_path)\n            Image.fromarray(frame).save(f\"{path}{self.frame_count}{extension}\")\n            self.frame_count += 1",
  "def save_final_image(self, image):\n        \"\"\"\n        The name is a misnomer. This method saves the image\n        passed to it as an in the default image directory.\n\n        Parameters\n        ----------\n        image : np.array\n            The pixel array of the image to save.\n        \"\"\"\n        file_path = self.get_image_file_path()\n        image.save(file_path)\n        self.print_file_ready_message(file_path)",
  "def idle_stream(self):\n        \"\"\"\n        Doesn't write anything to the FFMPEG frame buffer.\n        \"\"\"\n        while self.stream_lock:\n            a = datetime.datetime.now()\n            self.update_frame()\n            n_frames = 1\n            frame = self.get_frame()\n            self.add_frames(*[frame] * n_frames)\n            b = datetime.datetime.now()\n            time_diff = (b - a).total_seconds()\n            frame_duration = 1 / self.scene.camera.frame_rate\n            if time_diff < frame_duration:\n                sleep(frame_duration - time_diff)",
  "def finish(self):\n        \"\"\"\n        Finishes writing to the FFMPEG buffer.\n        Combines the partial movie files into the\n        whole scene.\n        If save_last_frame is True, saves the last\n        frame in the default image directory.\n        \"\"\"\n        if file_writer_config[\"write_to_movie\"]:\n            if hasattr(self, \"writing_process\"):\n                self.writing_process.terminate()\n            self.combine_movie_files()\n        if file_writer_config[\"save_last_frame\"]:\n            self.scene.update_frame(ignore_skipping=True)\n            self.save_final_image(self.scene.get_image())",
  "def open_movie_pipe(self):\n        \"\"\"\n        Used internally by Manim to initalise\n        FFMPEG and begin writing to FFMPEG's input\n        buffer.\n        \"\"\"\n        file_path = self.get_next_partial_movie_path()\n        temp_file_path = (\n            os.path.splitext(file_path)[0]\n            + \"_temp\"\n            + file_writer_config[\"movie_file_extension\"]\n        )\n        self.partial_movie_file_path = file_path\n        self.temp_partial_movie_file_path = temp_file_path\n\n        fps = self.scene.camera.frame_rate\n        height = self.scene.camera.get_pixel_height()\n        width = self.scene.camera.get_pixel_width()\n\n        command = [\n            FFMPEG_BIN,\n            \"-y\",  # overwrite output file if it exists\n            \"-f\",\n            \"rawvideo\",\n            \"-s\",\n            \"%dx%d\" % (width, height),  # size of one frame\n            \"-pix_fmt\",\n            \"rgba\",\n            \"-r\",\n            str(fps),  # frames per second\n            \"-i\",\n            \"-\",  # The imput comes from a pipe\n            \"-an\",  # Tells FFMPEG not to expect any audio\n            \"-loglevel\",\n            \"error\",\n        ]\n        # TODO, the test for a transparent background should not be based on\n        # the file extension.\n        if file_writer_config[\"movie_file_extension\"] == \".mov\":\n            # This is if the background of the exported\n            # video should be transparent.\n            command += [\n                \"-vcodec\",\n                \"qtrle\",\n            ]\n        else:\n            command += [\n                \"-vcodec\",\n                \"libx264\",\n                \"-pix_fmt\",\n                \"yuv420p\",\n            ]\n        command += [temp_file_path]\n        self.writing_process = subprocess.Popen(command, stdin=subprocess.PIPE)",
  "def close_movie_pipe(self):\n        \"\"\"\n        Used internally by Manim to gracefully stop writing to FFMPEG's\n        input buffer, and move the temporary files into their permananant\n        locations\n        \"\"\"\n        self.writing_process.stdin.close()\n        self.writing_process.wait()\n        shutil.move(\n            self.temp_partial_movie_file_path, self.partial_movie_file_path,\n        )",
  "def combine_movie_files(self):\n        \"\"\"\n        Used internally by Manim to combine the separate\n        partial movie files that make up a Scene into a single\n        video file for that Scene.\n        \"\"\"\n        # Manim renders the scene as many smaller movie files\n        # which are then concatenated to a larger one.  The reason\n        # for this is that sometimes video-editing is made easier when\n        # one works with the broken up scene, which effectively has\n        # cuts at all the places you might want.  But for viewing\n        # the scene as a whole, one of course wants to see it as a\n        # single piece.\n        kwargs = {\n            \"remove_non_integer_files\": True,\n            \"extension\": file_writer_config[\"movie_file_extension\"],\n        }\n        if file_writer_config['from_animation_number'] is not None:\n            kwargs[\"min_index\"] = file_writer_config['from_animation_number']\n        if file_writer_config['upto_animation_number'] not in [None, np.inf]:\n            kwargs[\"max_index\"] = file_writer_config['upto_animation_number']\n        else:\n            kwargs[\"remove_indices_greater_than\"] = self.scene.num_plays - 1\n        partial_movie_files = get_sorted_integer_files(\n            self.partial_movie_directory, **kwargs\n        )\n        if len(partial_movie_files) == 0:\n            logger.error(\"No animations in this scene\")\n            return\n\n        # Write a file partial_file_list.txt containing all\n        # partial movie files\n        file_list = os.path.join(\n            self.partial_movie_directory, \"partial_movie_file_list.txt\"\n        )\n        with open(file_list, \"w\") as fp:\n            for pf_path in partial_movie_files:\n                if os.name == \"nt\":\n                    pf_path = pf_path.replace(\"\\\\\", \"/\")\n                fp.write(\"file 'file:{}'\\n\".format(pf_path))\n\n        movie_file_path = self.get_movie_file_path()\n        commands = [\n            FFMPEG_BIN,\n            \"-y\",  # overwrite output file if it exists\n            \"-f\",\n            \"concat\",\n            \"-safe\",\n            \"0\",\n            \"-i\",\n            file_list,\n            \"-loglevel\",\n            \"error\",\n        ]\n\n        if self.write_to_movie:\n            commands += [\"-c\", \"copy\", movie_file_path]\n\n        if self.save_as_gif:\n            commands += [self.gif_file_path]\n        if not self.includes_sound:\n            commands.insert(-1, \"-an\")\n\n        combine_process = subprocess.Popen(commands)\n        combine_process.wait()\n\n        if self.includes_sound:\n            sound_file_path = movie_file_path.replace(\n                file_writer_config[\"movie_file_extension\"], \".wav\"\n            )\n            # Makes sure sound file length will match video file\n            self.add_audio_segment(AudioSegment.silent(0))\n            self.audio_segment.export(\n                sound_file_path, bitrate=\"312k\",\n            )\n            temp_file_path = movie_file_path.replace(\".\", \"_temp.\")\n            commands = [\n                FFMPEG_BIN,\n                \"-i\",\n                movie_file_path,\n                \"-i\",\n                sound_file_path,\n                \"-y\",  # overwrite output file if it exists\n                \"-c:v\",\n                \"copy\",\n                \"-c:a\",\n                \"aac\",\n                \"-b:a\",\n                \"320k\",\n                # select video stream from first file\n                \"-map\",\n                \"0:v:0\",\n                # select audio stream from second file\n                \"-map\",\n                \"1:a:0\",\n                \"-loglevel\",\n                \"error\",\n                # \"-shortest\",\n                temp_file_path,\n            ]\n            subprocess.call(commands)\n            shutil.move(temp_file_path, movie_file_path)\n            os.remove(sound_file_path)\n\n        self.print_file_ready_message(movie_file_path)",
  "def print_file_ready_message(self, file_path):\n        \"\"\"\n        Prints the \"File Ready\" message to STDOUT.\n        \"\"\"\n        logger.info(\"\\nFile ready at {}\\n\".format(file_path))",
  "class VectorScene(Scene):\n    CONFIG = {\"basis_vector_stroke_width\": 6}\n\n    def add_plane(self, animate=False, **kwargs):\n        \"\"\"\n        Adds a NumberPlane object to the background.\n\n        Parameters\n        ----------\n        animate : bool, optional\n            Whether or not to animate the addition of the plane via ShowCreation.\n        **kwargs\n            Any valid keyword arguments accepted by NumberPlane.\n\n        Returns\n        -------\n        NumberPlane\n            The NumberPlane object.\n        \"\"\"\n        plane = NumberPlane(**kwargs)\n        if animate:\n            self.play(ShowCreation(plane, lag_ratio=0.5))\n        self.add(plane)\n        return plane\n\n    def add_axes(self, animate=False, color=WHITE, **kwargs):\n        \"\"\"\n        Adds a pair of Axes to the Scene.\n\n        Parameters\n        ----------\n        animate : bool, optional\n            Whether or not to animate the addition of the axes through ShowCreation.\n        color : bool, optional\n            The color of the axes. Defaults to WHITE.\n        \"\"\"\n        axes = Axes(color=color, tick_frequency=1)\n        if animate:\n            self.play(ShowCreation(axes))\n        self.add(axes)\n        return axes\n\n    def lock_in_faded_grid(self, dimness=0.7, axes_dimness=0.5):\n        \"\"\"\n        This method freezes the NumberPlane and Axes that were already\n        in the background, and adds new, manipulatable ones to the foreground.\n\n        Parameters\n        ----------\n        dimness : int, float, optional\n            The required dimness of the NumberPlane\n\n        axes_dimness : int, float, optional\n            The required dimness of the Axes.\n        \"\"\"\n        plane = self.add_plane()\n        axes = plane.get_axes()\n        plane.fade(dimness)\n        axes.set_color(WHITE)\n        axes.fade(axes_dimness)\n        self.add(axes)\n        self.freeze_background()\n\n    def get_vector(self, numerical_vector, **kwargs):\n        \"\"\"\n        Returns an arrow on the Plane given an input numerical vector.\n\n        Parameters\n        ----------\n        numerical_vector : np.array, list, tuple\n            The Vector to plot.\n        **kwargs\n            Any valid keyword argument of Arrow.\n\n        Returns\n        -------\n        Arrow\n            The Arrow representing the Vector.\n        \"\"\"\n        return Arrow(\n            self.plane.coords_to_point(0, 0),\n            self.plane.coords_to_point(*numerical_vector[:2]),\n            buff=0,\n            **kwargs,\n        )\n\n    def add_vector(self, vector, color=YELLOW, animate=True, **kwargs):\n        \"\"\"\n        Returns the Vector after adding it to the Plane.\n\n        Parameters\n        ----------\n        vector : Arrow, list, tuple, np.array\n            It can be a pre-made graphical vector, or the\n            coordinates of one.\n\n        color : str\n            The string of the hex color of the vector.\n            This is only taken into consideration if\n            'vector' is not an Arrow. Defaults to YELLOW.\n\n        animate : bool\n            Whether or not to animate the addition of the vector\n            by using GrowArrow\n\n        **kwargs\n            Any valid keyword argument of Arrow.\n            These are only considered if vector is not\n            an Arrow.\n\n        Returns\n        -------\n        Arrow\n            The arrow representing the vector.\n        \"\"\"\n        if not isinstance(vector, Arrow):\n            vector = Vector(vector, color=color, **kwargs)\n        if animate:\n            self.play(GrowArrow(vector))\n        self.add(vector)\n        return vector\n\n    def write_vector_coordinates(self, vector, **kwargs):\n        \"\"\"\n        Returns a column matrix indicating the vector coordinates,\n        after writing them to the screen.\n\n        Parameters\n        ----------\n        vector : Arrow\n            The arrow representing the vector.\n\n        **kwargs\n            Any valid keyword arguments of matrix.vector_coordinate_label\n\n            integer_labels (True) : Whether or not to round the coordinates\n                                    to integers.\n            n_dim (2) : The number of dimensions of the vector.\n            color (WHITE) : The color of the label.\n\n        Returns\n        -------\n        Matrix\n            The column matrix representing the vector.\n        \"\"\"\n        coords = vector_coordinate_label(vector, **kwargs)\n        self.play(Write(coords))\n        return coords\n\n    def get_basis_vectors(self, i_hat_color=X_COLOR, j_hat_color=Y_COLOR):\n        \"\"\"\n        Returns a VGroup of the Basis Vectors (1,0) and (0,1)\n\n        Parameters\n        ----------\n        i_hat_color : str\n            The hex colour to use for the basis vector in the x direction\n\n        j_hat_color : str\n            The hex colour to use for the basis vector in the y direction\n\n        Returns\n        -------\n        VGroup\n            VGroup of the Vector Mobjects representing the basis vectors.\n        \"\"\"\n        return VGroup(\n            *[\n                Vector(vect, color=color, stroke_width=self.basis_vector_stroke_width)\n                for vect, color in [([1, 0], i_hat_color), ([0, 1], j_hat_color)]\n            ]\n        )\n\n    def get_basis_vector_labels(self, **kwargs):\n        \"\"\"\n        Returns naming labels for the basis vectors.\n\n        Parameters\n        ----------\n        **kwargs\n            Any valid keyword arguments of get_vector_label:\n                vector,\n                label (str,TexMobject)\n                at_tip (bool=False),\n                direction (str=\"left\"),\n                rotate (bool),\n                color (str),\n                label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),\n        \"\"\"\n        i_hat, j_hat = self.get_basis_vectors()\n        return VGroup(\n            *[\n                self.get_vector_label(\n                    vect, label, color=color, label_scale_factor=1, **kwargs\n                )\n                for vect, label, color in [\n                    (i_hat, \"\\\\hat{\\\\imath}\", X_COLOR),\n                    (j_hat, \"\\\\hat{\\\\jmath}\", Y_COLOR),\n                ]\n            ]\n        )\n\n    def get_vector_label(\n        self,\n        vector,\n        label,\n        at_tip=False,\n        direction=\"left\",\n        rotate=False,\n        color=None,\n        label_scale_factor=VECTOR_LABEL_SCALE_FACTOR,\n    ):\n        \"\"\"\n        Returns naming labels for the passed vector.\n\n        Parameters\n        ----------\n        vector : Vector\n            Vector Object for which to get the label.\n\n        at_tip : bool\n            Whether or not to place the label at the tip of the vector.\n\n        direction : {\"left\"}\n            If the label should be on the \"left\" or right of the vector.\n        rotate : bool\n            Whether or not to rotate it to align it with the vector.\n        color : str\n            The color to give the label.\n        label_scale_factor (Union[int,float])\n            How much to scale the label by.\n\n        Returns\n        -------\n        TexMobject\n            The TexMobject of the label.\n        \"\"\"\n        if not isinstance(label, TexMobject):\n            if len(label) == 1:\n                label = \"\\\\vec{\\\\textbf{%s}}\" % label\n            label = TexMobject(label)\n            if color is None:\n                color = vector.get_color()\n            label.set_color(color)\n        label.scale(label_scale_factor)\n        label.add_background_rectangle()\n\n        if at_tip:\n            vect = vector.get_vector()\n            vect /= get_norm(vect)\n            label.next_to(vector.get_end(), vect, buff=SMALL_BUFF)\n        else:\n            angle = vector.get_angle()\n            if not rotate:\n                label.rotate(-angle, about_point=ORIGIN)\n            if direction == \"left\":\n                label.shift(-label.get_bottom() + 0.1 * UP)\n            else:\n                label.shift(-label.get_top() + 0.1 * DOWN)\n            label.rotate(angle, about_point=ORIGIN)\n            label.shift((vector.get_end() - vector.get_start()) / 2)\n        return label\n\n    def label_vector(self, vector, label, animate=True, **kwargs):\n        \"\"\"\n        Shortcut method for creating, and animating the addition of\n        a label for the vector.\n\n        Parameters\n        ----------\n        vector : Vector\n            The vector for which the label must be added.\n\n        label : TexMobject, str\n            The TexMobject/string of the label.\n\n        animate : bool, optional\n            Whether or not to animate the labelling w/ Write\n\n        **kwargs\n            Any valid keyword argument of get_vector_label\n\n        Returns\n        -------\n        TexMobject\n            The TexMobject of the label.\n        \"\"\"\n        label = self.get_vector_label(vector, label, **kwargs)\n        if animate:\n            self.play(Write(label, run_time=1))\n        self.add(label)\n        return label\n\n    def position_x_coordinate(\n        self, x_coord, x_line, vector\n    ):  # TODO Write DocStrings for this.\n        x_coord.next_to(x_line, -np.sign(vector[1]) * UP)\n        x_coord.set_color(X_COLOR)\n        return x_coord\n\n    def position_y_coordinate(\n        self, y_coord, y_line, vector\n    ):  # TODO Write DocStrings for this.\n        y_coord.next_to(y_line, np.sign(vector[0]) * RIGHT)\n        y_coord.set_color(Y_COLOR)\n        return y_coord\n\n    def coords_to_vector(self, vector, coords_start=2 * RIGHT + 2 * UP, clean_up=True):\n        \"\"\"\n        This method writes the vector as a column matrix (henceforth called the label),\n        takes the values in it one by one, and form the corresponding\n        lines that make up the x and y components of the vector. Then, an\n        Vector() based vector is created between the lines on the Screen.\n\n        Parameters\n        ----------\n        vector : np.ndarray, list, tuple\n            The vector to show.\n\n        coords_start : np.ndarray,list,tuple, optional\n            The starting point of the location of\n            the label of the vector that shows it\n            numerically.\n            Defaults to 2 * RIGHT + 2 * UP or (2,2)\n\n        clean_up : bool, optional\n            Whether or not to remove whatever\n            this method did after it's done.\n\n        \"\"\"\n        starting_mobjects = list(self.mobjects)\n        array = Matrix(vector)\n        array.shift(coords_start)\n        arrow = Vector(vector)\n        x_line = Line(ORIGIN, vector[0] * RIGHT)\n        y_line = Line(x_line.get_end(), arrow.get_end())\n        x_line.set_color(X_COLOR)\n        y_line.set_color(Y_COLOR)\n        x_coord, y_coord = array.get_mob_matrix().flatten()\n\n        self.play(Write(array, run_time=1))\n        self.wait()\n        self.play(\n            ApplyFunction(\n                lambda x: self.position_x_coordinate(x, x_line, vector), x_coord\n            )\n        )\n        self.play(ShowCreation(x_line))\n        self.play(\n            ApplyFunction(\n                lambda y: self.position_y_coordinate(y, y_line, vector), y_coord\n            ),\n            FadeOut(array.get_brackets()),\n        )\n        y_coord, brackets = self.get_mobjects_from_last_animation()\n        self.play(ShowCreation(y_line))\n        self.play(ShowCreation(arrow))\n        self.wait()\n        if clean_up:\n            self.clear()\n            self.add(*starting_mobjects)\n\n    def vector_to_coords(self, vector, integer_labels=True, clean_up=True):\n        \"\"\"\n        This method displays vector as a Vector() based vector, and then shows\n        the corresponding lines that make up the x and y components of the vector.\n        Then, a column matrix (henceforth called the label) is created near the\n        head of the Vector.\n\n        Parameters\n        ----------\n        vector : np.ndarray, list, tuple\n            The vector to show.\n\n        integer_label : bool, optional\n            Whether or not to round the value displayed.\n            in the vector's label to the nearest integer\n\n        clean_up : bool, optional\n            Whether or not to remove whatever\n            this method did after it's done.\n\n        \"\"\"\n        starting_mobjects = list(self.mobjects)\n        show_creation = False\n        if isinstance(vector, Arrow):\n            arrow = vector\n            vector = arrow.get_end()[:2]\n        else:\n            arrow = Vector(vector)\n            show_creation = True\n        array = vector_coordinate_label(arrow, integer_labels=integer_labels)\n        x_line = Line(ORIGIN, vector[0] * RIGHT)\n        y_line = Line(x_line.get_end(), arrow.get_end())\n        x_line.set_color(X_COLOR)\n        y_line.set_color(Y_COLOR)\n        x_coord, y_coord = array.get_mob_matrix().flatten()\n        x_coord_start = self.position_x_coordinate(x_coord.copy(), x_line, vector)\n        y_coord_start = self.position_y_coordinate(y_coord.copy(), y_line, vector)\n        brackets = array.get_brackets()\n\n        if show_creation:\n            self.play(ShowCreation(arrow))\n        self.play(ShowCreation(x_line), Write(x_coord_start), run_time=1)\n        self.play(ShowCreation(y_line), Write(y_coord_start), run_time=1)\n        self.wait()\n        self.play(\n            Transform(x_coord_start, x_coord, lag_ratio=0),\n            Transform(y_coord_start, y_coord, lag_ratio=0),\n            Write(brackets, run_time=1),\n        )\n        self.wait()\n\n        self.remove(x_coord_start, y_coord_start, brackets)\n        self.add(array)\n        if clean_up:\n            self.clear()\n            self.add(*starting_mobjects)\n        return array, x_line, y_line\n\n    def show_ghost_movement(self, vector):\n        \"\"\"\n        This method plays an animation that partially shows the entire plane moving\n        in the direction of a particular vector. This is useful when you wish to\n        convey the idea of mentally moving the entire plane in a direction, without\n        actually moving the plane.\n\n        Parameters\n        ----------\n        vector : Arrow, list, tuple, np.ndarray\n            The vector which indicates the direction of movement.\n        \"\"\"\n        if isinstance(vector, Arrow):\n            vector = vector.get_end() - vector.get_start()\n        elif len(vector) == 2:\n            vector = np.append(np.array(vector), 0.0)\n        x_max = int(config[\"frame_x_radius\"] + abs(vector[0]))\n        y_max = int(config[\"frame_y_radius\"] + abs(vector[1]))\n        dots = VMobject(\n            *[\n                Dot(x * RIGHT + y * UP)\n                for x in range(-x_max, x_max)\n                for y in range(-y_max, y_max)\n            ]\n        )\n        dots.set_fill(BLACK, opacity=0)\n        dots_halfway = dots.copy().shift(vector / 2).set_fill(WHITE, 1)\n        dots_end = dots.copy().shift(vector)\n\n        self.play(Transform(dots, dots_halfway, rate_func=rush_into))\n        self.play(Transform(dots, dots_end, rate_func=rush_from))\n        self.remove(dots)",
  "class LinearTransformationScene(VectorScene):\n    \"\"\"\n    This scene contains special methods that make it\n    especially suitable for showing Linear Transformations.\n    \"\"\"\n\n    CONFIG = {\n        \"include_background_plane\": True,\n        \"include_foreground_plane\": True,\n        \"foreground_plane_kwargs\": {\n            \"x_max\": config[\"frame_width\"] / 2,\n            \"x_min\": -config[\"frame_width\"] / 2,\n            \"y_max\": config[\"frame_width\"] / 2,\n            \"y_min\": -config[\"frame_width\"] / 2,\n            \"faded_line_ratio\": 0,\n        },\n        \"background_plane_kwargs\": {\n            \"color\": GREY,\n            \"axis_config\": {\"stroke_color\": LIGHT_GREY,},\n            \"axis_config\": {\"color\": GREY,},\n            \"background_line_style\": {\"stroke_color\": GREY, \"stroke_width\": 1,},\n        },\n        \"show_coordinates\": False,\n        \"show_basis_vectors\": True,\n        \"basis_vector_stroke_width\": 6,\n        \"i_hat_color\": X_COLOR,\n        \"j_hat_color\": Y_COLOR,\n        \"leave_ghost_vectors\": False,\n        \"t_matrix\": [[3, 0], [1, 2]],\n    }\n\n    def setup(self):\n        # The has_already_setup attr is to not break all the old Scenes\n        if hasattr(self, \"has_already_setup\"):\n            return\n        self.has_already_setup = True\n        self.background_mobjects = []\n        self.foreground_mobjects = []\n        self.transformable_mobjects = []\n        self.moving_vectors = []\n        self.transformable_labels = []\n        self.moving_mobjects = []\n\n        self.t_matrix = np.array(self.t_matrix)\n        self.background_plane = NumberPlane(**self.background_plane_kwargs)\n\n        if self.show_coordinates:\n            self.background_plane.add_coordinates()\n        if self.include_background_plane:\n            self.add_background_mobject(self.background_plane)\n        if self.include_foreground_plane:\n            self.plane = NumberPlane(**self.foreground_plane_kwargs)\n            self.add_transformable_mobject(self.plane)\n        if self.show_basis_vectors:\n            self.basis_vectors = self.get_basis_vectors(\n                i_hat_color=self.i_hat_color, j_hat_color=self.j_hat_color,\n            )\n            self.moving_vectors += list(self.basis_vectors)\n            self.i_hat, self.j_hat = self.basis_vectors\n            self.add(self.basis_vectors)\n\n    def add_special_mobjects(self, mob_list, *mobs_to_add):\n        \"\"\"\n        Adds mobjects to a separate list that can be tracked,\n        if these mobjects have some extra importance.\n\n        Parameters\n        ----------\n        mob_list : list\n            The special list to which you want to add\n            these mobjects.\n\n        *mobs_to_add : Mobject\n            The mobjects to add.\n\n        \"\"\"\n        for mobject in mobs_to_add:\n            if mobject not in mob_list:\n                mob_list.append(mobject)\n                self.add(mobject)\n\n    def add_background_mobject(self, *mobjects):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.background_mobjects.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobjects to add to the list.\n        \"\"\"\n        self.add_special_mobjects(self.background_mobjects, *mobjects)\n\n    # TODO, this conflicts with Scene.add_fore\n    def add_foreground_mobject(self, *mobjects):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.foreground_mobjects.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobjects to add to the list\n        \"\"\"\n        self.add_special_mobjects(self.foreground_mobjects, *mobjects)\n\n    def add_transformable_mobject(self, *mobjects):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.transformable_mobjects.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobjects to add to the list.\n        \"\"\"\n        self.add_special_mobjects(self.transformable_mobjects, *mobjects)\n\n    def add_moving_mobject(self, mobject, target_mobject=None):\n        \"\"\"\n        Adds the mobject to the special list\n        self.moving_mobject, and adds a property\n        to the mobject called mobject.target, which\n        keeps track of what the mobject will move to\n        or become etc.\n\n        Parameters\n        ----------\n        mobject : Mobject\n            The mobjects to add to the list\n\n        target_mobject : Mobject, optional\n            What the moving_mobject goes to, etc.\n        \"\"\"\n        mobject.target = target_mobject\n        self.add_special_mobjects(self.moving_mobjects, mobject)\n\n    def get_unit_square(self, color=YELLOW, opacity=0.3, stroke_width=3):\n        \"\"\"\n        Returns a unit square for the current NumberPlane.\n\n        Parameters\n        ----------\n        color : str, optional\n            The string of the hex color code of the color wanted.\n\n        opacity : float, int, optional\n            The opacity of the square\n\n        stroke_width : int, float, optional\n            The stroke_width in pixels of the border of the square\n\n        Returns\n        -------\n        Square\n        \"\"\"\n        square = self.square = Rectangle(\n            color=color,\n            width=self.plane.get_x_unit_size(),\n            height=self.plane.get_y_unit_size(),\n            stroke_color=color,\n            stroke_width=stroke_width,\n            fill_color=color,\n            fill_opacity=opacity,\n        )\n        square.move_to(self.plane.coords_to_point(0, 0), DL)\n        return square\n\n    def add_unit_square(self, animate=False, **kwargs):\n        \"\"\"\n        Adds a unit square to the scene via\n        self.get_unit_square.\n\n        Parameters\n        ----------\n        animate (bool)\n            Whether or not to animate the addition\n            with DrawBorderThenFill.\n        **kwargs\n            Any valid keyword arguments of\n            self.get_unit_square()\n\n        Returns\n        -------\n        Square\n            The unit square.\n        \"\"\"\n        square = self.get_unit_square(**kwargs)\n        if animate:\n            self.play(\n                DrawBorderThenFill(square), Animation(Group(*self.moving_vectors))\n            )\n        self.add_transformable_mobject(square)\n        self.bring_to_front(*self.moving_vectors)\n        self.square = square\n        return self\n\n    def add_vector(self, vector, color=YELLOW, **kwargs):\n        \"\"\"\n        Adds a vector to the scene, and puts it in the special\n        list self.moving_vectors.\n\n        Parameters\n        ----------\n        vector : Arrow,list,tuple,np.ndarray\n            It can be a pre-made graphical vector, or the\n            coordinates of one.\n\n        color : str\n            The string of the hex color of the vector.\n            This is only taken into consideration if\n            'vector' is not an Arrow. Defaults to YELLOW.\n\n        **kwargs\n            Any valid keyword argument of VectorScene.add_vector.\n\n        Returns\n        -------\n        Arrow\n            The arrow representing the vector.\n        \"\"\"\n        vector = VectorScene.add_vector(self, vector, color=color, **kwargs)\n        self.moving_vectors.append(vector)\n        return vector\n\n    def write_vector_coordinates(self, vector, **kwargs):\n        \"\"\"\n        Returns a column matrix indicating the vector coordinates,\n        after writing them to the screen, and adding them to the\n        special list self.foreground_mobjects\n\n        Parameters\n        ----------\n        vector : Arrow\n            The arrow representing the vector.\n\n        **kwargs\n            Any valid keyword arguments of VectorScene.write_vector_coordinates\n\n        Returns\n        -------\n        Matrix\n            The column matrix representing the vector.\n        \"\"\"\n        coords = VectorScene.write_vector_coordinates(self, vector, **kwargs)\n        self.add_foreground_mobject(coords)\n        return coords\n\n    def add_transformable_label(\n        self, vector, label, transformation_name=\"L\", new_label=None, **kwargs\n    ):\n        \"\"\"\n        Method for creating, and animating the addition of\n        a transformable label for the vector.\n\n        Parameters\n        ----------\n        vector : Vector\n            The vector for which the label must be added.\n\n        label : TexMobject,str\n            The TexMobject/string of the label.\n\n        transformation_name : str, TexMobject, optional\n            The name to give the transformation as a label.\n\n        new_label : TexMobject,str, optional\n            What the label should display after a Linear Transformation\n\n        **kwargs\n            Any valid keyword argument of get_vector_label\n\n        Returns\n        -------\n        TexMobject\n            The TexMobject of the label.\n        \"\"\"\n        label_mob = self.label_vector(vector, label, **kwargs)\n        if new_label:\n            label_mob.target_text = new_label\n        else:\n            label_mob.target_text = \"%s(%s)\" % (\n                transformation_name,\n                label_mob.get_tex_string(),\n            )\n        label_mob.vector = vector\n        label_mob.kwargs = kwargs\n        if \"animate\" in label_mob.kwargs:\n            label_mob.kwargs.pop(\"animate\")\n        self.transformable_labels.append(label_mob)\n        return label_mob\n\n    def add_title(self, title, scale_factor=1.5, animate=False):\n        \"\"\"\n        Adds a title, after scaling it, adding a background rectangle,\n        moving it to the top and adding it to foreground_mobjects adding\n        it as a local variable of self. Returns the Scene.\n\n        Parameters\n        ----------\n        title : str,TexMobject,TextMobject\n            What the title should be.\n\n        scale_factor : int, float, optional\n            How much the title should be scaled by.\n\n        animate : bool\n            Whether or not to animate the addition.\n\n        Returns\n        -------\n        LinearTransformationScene\n            The scene with the title added to it.\n        \"\"\"\n        if not isinstance(title, Mobject):\n            title = TextMobject(title).scale(scale_factor)\n        title.to_edge(UP)\n        title.add_background_rectangle()\n        if animate:\n            self.play(Write(title))\n        self.add_foreground_mobject(title)\n        self.title = title\n        return self\n\n    def get_matrix_transformation(self, matrix):\n        \"\"\"\n        Returns a function corresponding to the linear\n        transformation represented by the matrix passed.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix.\n        \"\"\"\n        return self.get_transposed_matrix_transformation(np.array(matrix).T)\n\n    def get_transposed_matrix_transformation(self, transposed_matrix):\n        \"\"\"\n        Returns a function corresponding to the linear\n        transformation represented by the transposed\n        matrix passed.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix.\n        \"\"\"\n        transposed_matrix = np.array(transposed_matrix)\n        if transposed_matrix.shape == (2, 2):\n            new_matrix = np.identity(3)\n            new_matrix[:2, :2] = transposed_matrix\n            transposed_matrix = new_matrix\n        elif transposed_matrix.shape != (3, 3):\n            raise Exception(\"Matrix has bad dimensions\")\n        return lambda point: np.dot(point, transposed_matrix)\n\n    def get_piece_movement(self, pieces):\n        \"\"\"\n        This method returns an animation that moves an arbitrary\n        mobject in \"pieces\" to its corresponding .target value.\n        If self.leave_ghost_vectors is True, ghosts of the original\n        positions/mobjects are left on screen\n\n        Parameters\n        ----------\n        pieces : list, tuple, np.array\n            The pieces for which the movement must be shown.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        start = VGroup(*pieces)\n        target = VGroup(*[mob.target for mob in pieces])\n        if self.leave_ghost_vectors:\n            self.add(start.copy().fade(0.7))\n        return Transform(start, target, lag_ratio=0)\n\n    def get_moving_mobject_movement(self, func):\n        \"\"\"\n        This method returns an animation that moves a mobject\n        in \"self.moving_mobjects\"  to its corresponding .target value.\n        func is a function that determines where the .target goes.\n\n        Parameters\n        ----------\n\n        func : function\n            The function that determines where the .target of\n            the moving mobject goes.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for m in self.moving_mobjects:\n            if m.target is None:\n                m.target = m.copy()\n            target_point = func(m.get_center())\n            m.target.move_to(target_point)\n        return self.get_piece_movement(self.moving_mobjects)\n\n    def get_vector_movement(self, func):\n        \"\"\"\n        This method returns an animation that moves a mobject\n        in \"self.moving_vectors\"  to its corresponding .target value.\n        func is a function that determines where the .target goes.\n\n        Parameters\n        ----------\n\n        func : function\n            The function that determines where the .target of\n            the moving mobject goes.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for v in self.moving_vectors:\n            v.target = Vector(func(v.get_end()), color=v.get_color())\n            norm = get_norm(v.target.get_end())\n            if norm < 0.1:\n                v.target.get_tip().scale_in_place(norm)\n        return self.get_piece_movement(self.moving_vectors)\n\n    def get_transformable_label_movement(self):\n        \"\"\"\n        This method returns an animation that moves all labels\n        in \"self.transformable_labels\" to its corresponding .target .\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for l in self.transformable_labels:\n            l.target = self.get_vector_label(l.vector.target, l.target_text, **l.kwargs)\n        return self.get_piece_movement(self.transformable_labels)\n\n    def apply_matrix(self, matrix, **kwargs):\n        \"\"\"\n        Applies the transformation represented by the\n        given matrix to the number plane, and each vector/similar\n        mobject on it.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_transposed_matrix()\n        \"\"\"\n        self.apply_transposed_matrix(np.array(matrix).T, **kwargs)\n\n    def apply_inverse(self, matrix, **kwargs):\n        \"\"\"\n        This method applies the linear transformation\n        represented by the inverse of the passed matrix\n        to the number plane, and each vector/similar mobject on it.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix whose inverse is to be applied.\n        **kwargs\n            Any valid keyword argument of self.apply_matrix()\n        \"\"\"\n        self.apply_matrix(np.linalg.inv(matrix), **kwargs)\n\n    def apply_transposed_matrix(self, transposed_matrix, **kwargs):\n        \"\"\"\n        Applies the transformation represented by the\n        given transposed matrix to the number plane,\n        and each vector/similar mobject on it.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_function()\n        \"\"\"\n        func = self.get_transposed_matrix_transformation(transposed_matrix)\n        if \"path_arc\" not in kwargs:\n            net_rotation = np.mean(\n                [angle_of_vector(func(RIGHT)), angle_of_vector(func(UP)) - np.pi / 2]\n            )\n            kwargs[\"path_arc\"] = net_rotation\n        self.apply_function(func, **kwargs)\n\n    def apply_inverse_transpose(self, t_matrix, **kwargs):\n        \"\"\"\n        Applies the inverse of the transformation represented\n        by the given transposed matrix to the number plane and each\n        vector/similar mobject on it.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_transposed_matrix()\n        \"\"\"\n        t_inv = np.linalg.inv(np.array(t_matrix).T).T\n        self.apply_transposed_matrix(t_inv, **kwargs)\n\n    def apply_nonlinear_transformation(self, function, **kwargs):\n        \"\"\"\n        Applies the non-linear transformation represented\n        by the given function to the number plane and each\n        vector/similar mobject on it.\n\n        Parameters\n        ----------\n        function : Function\n            The function.\n        **kwargs\n            Any valid keyword argument of self.apply_function()\n        \"\"\"\n        self.plane.prepare_for_nonlinear_transform()\n        self.apply_function(function, **kwargs)\n\n    def apply_function(self, function, added_anims=[], **kwargs):\n        \"\"\"\n        Applies the given function to each of the mobjects in\n        self.transformable_mobjects, and plays the animation showing\n        this.\n\n        Parameters\n        ----------\n        function : Function\n            The function that affects each point\n            of each mobject in self.transformable_mobjects.\n\n        added_anims : list, optional\n            Any other animations that need to be played\n            simulataneously with this.\n\n        **kwargs\n            Any valid keyword argument of a self.play() call.\n        \"\"\"\n        if \"run_time\" not in kwargs:\n            kwargs[\"run_time\"] = 3\n        anims = (\n            [\n                ApplyPointwiseFunction(function, t_mob)\n                for t_mob in self.transformable_mobjects\n            ]\n            + [\n                self.get_vector_movement(function),\n                self.get_transformable_label_movement(),\n                self.get_moving_mobject_movement(function),\n            ]\n            + [Animation(f_mob) for f_mob in self.foreground_mobjects]\n            + added_anims\n        )\n        self.play(*anims, **kwargs)",
  "def add_plane(self, animate=False, **kwargs):\n        \"\"\"\n        Adds a NumberPlane object to the background.\n\n        Parameters\n        ----------\n        animate : bool, optional\n            Whether or not to animate the addition of the plane via ShowCreation.\n        **kwargs\n            Any valid keyword arguments accepted by NumberPlane.\n\n        Returns\n        -------\n        NumberPlane\n            The NumberPlane object.\n        \"\"\"\n        plane = NumberPlane(**kwargs)\n        if animate:\n            self.play(ShowCreation(plane, lag_ratio=0.5))\n        self.add(plane)\n        return plane",
  "def add_axes(self, animate=False, color=WHITE, **kwargs):\n        \"\"\"\n        Adds a pair of Axes to the Scene.\n\n        Parameters\n        ----------\n        animate : bool, optional\n            Whether or not to animate the addition of the axes through ShowCreation.\n        color : bool, optional\n            The color of the axes. Defaults to WHITE.\n        \"\"\"\n        axes = Axes(color=color, tick_frequency=1)\n        if animate:\n            self.play(ShowCreation(axes))\n        self.add(axes)\n        return axes",
  "def lock_in_faded_grid(self, dimness=0.7, axes_dimness=0.5):\n        \"\"\"\n        This method freezes the NumberPlane and Axes that were already\n        in the background, and adds new, manipulatable ones to the foreground.\n\n        Parameters\n        ----------\n        dimness : int, float, optional\n            The required dimness of the NumberPlane\n\n        axes_dimness : int, float, optional\n            The required dimness of the Axes.\n        \"\"\"\n        plane = self.add_plane()\n        axes = plane.get_axes()\n        plane.fade(dimness)\n        axes.set_color(WHITE)\n        axes.fade(axes_dimness)\n        self.add(axes)\n        self.freeze_background()",
  "def get_vector(self, numerical_vector, **kwargs):\n        \"\"\"\n        Returns an arrow on the Plane given an input numerical vector.\n\n        Parameters\n        ----------\n        numerical_vector : np.array, list, tuple\n            The Vector to plot.\n        **kwargs\n            Any valid keyword argument of Arrow.\n\n        Returns\n        -------\n        Arrow\n            The Arrow representing the Vector.\n        \"\"\"\n        return Arrow(\n            self.plane.coords_to_point(0, 0),\n            self.plane.coords_to_point(*numerical_vector[:2]),\n            buff=0,\n            **kwargs,\n        )",
  "def add_vector(self, vector, color=YELLOW, animate=True, **kwargs):\n        \"\"\"\n        Returns the Vector after adding it to the Plane.\n\n        Parameters\n        ----------\n        vector : Arrow, list, tuple, np.array\n            It can be a pre-made graphical vector, or the\n            coordinates of one.\n\n        color : str\n            The string of the hex color of the vector.\n            This is only taken into consideration if\n            'vector' is not an Arrow. Defaults to YELLOW.\n\n        animate : bool\n            Whether or not to animate the addition of the vector\n            by using GrowArrow\n\n        **kwargs\n            Any valid keyword argument of Arrow.\n            These are only considered if vector is not\n            an Arrow.\n\n        Returns\n        -------\n        Arrow\n            The arrow representing the vector.\n        \"\"\"\n        if not isinstance(vector, Arrow):\n            vector = Vector(vector, color=color, **kwargs)\n        if animate:\n            self.play(GrowArrow(vector))\n        self.add(vector)\n        return vector",
  "def write_vector_coordinates(self, vector, **kwargs):\n        \"\"\"\n        Returns a column matrix indicating the vector coordinates,\n        after writing them to the screen.\n\n        Parameters\n        ----------\n        vector : Arrow\n            The arrow representing the vector.\n\n        **kwargs\n            Any valid keyword arguments of matrix.vector_coordinate_label\n\n            integer_labels (True) : Whether or not to round the coordinates\n                                    to integers.\n            n_dim (2) : The number of dimensions of the vector.\n            color (WHITE) : The color of the label.\n\n        Returns\n        -------\n        Matrix\n            The column matrix representing the vector.\n        \"\"\"\n        coords = vector_coordinate_label(vector, **kwargs)\n        self.play(Write(coords))\n        return coords",
  "def get_basis_vectors(self, i_hat_color=X_COLOR, j_hat_color=Y_COLOR):\n        \"\"\"\n        Returns a VGroup of the Basis Vectors (1,0) and (0,1)\n\n        Parameters\n        ----------\n        i_hat_color : str\n            The hex colour to use for the basis vector in the x direction\n\n        j_hat_color : str\n            The hex colour to use for the basis vector in the y direction\n\n        Returns\n        -------\n        VGroup\n            VGroup of the Vector Mobjects representing the basis vectors.\n        \"\"\"\n        return VGroup(\n            *[\n                Vector(vect, color=color, stroke_width=self.basis_vector_stroke_width)\n                for vect, color in [([1, 0], i_hat_color), ([0, 1], j_hat_color)]\n            ]\n        )",
  "def get_basis_vector_labels(self, **kwargs):\n        \"\"\"\n        Returns naming labels for the basis vectors.\n\n        Parameters\n        ----------\n        **kwargs\n            Any valid keyword arguments of get_vector_label:\n                vector,\n                label (str,TexMobject)\n                at_tip (bool=False),\n                direction (str=\"left\"),\n                rotate (bool),\n                color (str),\n                label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),\n        \"\"\"\n        i_hat, j_hat = self.get_basis_vectors()\n        return VGroup(\n            *[\n                self.get_vector_label(\n                    vect, label, color=color, label_scale_factor=1, **kwargs\n                )\n                for vect, label, color in [\n                    (i_hat, \"\\\\hat{\\\\imath}\", X_COLOR),\n                    (j_hat, \"\\\\hat{\\\\jmath}\", Y_COLOR),\n                ]\n            ]\n        )",
  "def get_vector_label(\n        self,\n        vector,\n        label,\n        at_tip=False,\n        direction=\"left\",\n        rotate=False,\n        color=None,\n        label_scale_factor=VECTOR_LABEL_SCALE_FACTOR,\n    ):\n        \"\"\"\n        Returns naming labels for the passed vector.\n\n        Parameters\n        ----------\n        vector : Vector\n            Vector Object for which to get the label.\n\n        at_tip : bool\n            Whether or not to place the label at the tip of the vector.\n\n        direction : {\"left\"}\n            If the label should be on the \"left\" or right of the vector.\n        rotate : bool\n            Whether or not to rotate it to align it with the vector.\n        color : str\n            The color to give the label.\n        label_scale_factor (Union[int,float])\n            How much to scale the label by.\n\n        Returns\n        -------\n        TexMobject\n            The TexMobject of the label.\n        \"\"\"\n        if not isinstance(label, TexMobject):\n            if len(label) == 1:\n                label = \"\\\\vec{\\\\textbf{%s}}\" % label\n            label = TexMobject(label)\n            if color is None:\n                color = vector.get_color()\n            label.set_color(color)\n        label.scale(label_scale_factor)\n        label.add_background_rectangle()\n\n        if at_tip:\n            vect = vector.get_vector()\n            vect /= get_norm(vect)\n            label.next_to(vector.get_end(), vect, buff=SMALL_BUFF)\n        else:\n            angle = vector.get_angle()\n            if not rotate:\n                label.rotate(-angle, about_point=ORIGIN)\n            if direction == \"left\":\n                label.shift(-label.get_bottom() + 0.1 * UP)\n            else:\n                label.shift(-label.get_top() + 0.1 * DOWN)\n            label.rotate(angle, about_point=ORIGIN)\n            label.shift((vector.get_end() - vector.get_start()) / 2)\n        return label",
  "def label_vector(self, vector, label, animate=True, **kwargs):\n        \"\"\"\n        Shortcut method for creating, and animating the addition of\n        a label for the vector.\n\n        Parameters\n        ----------\n        vector : Vector\n            The vector for which the label must be added.\n\n        label : TexMobject, str\n            The TexMobject/string of the label.\n\n        animate : bool, optional\n            Whether or not to animate the labelling w/ Write\n\n        **kwargs\n            Any valid keyword argument of get_vector_label\n\n        Returns\n        -------\n        TexMobject\n            The TexMobject of the label.\n        \"\"\"\n        label = self.get_vector_label(vector, label, **kwargs)\n        if animate:\n            self.play(Write(label, run_time=1))\n        self.add(label)\n        return label",
  "def position_x_coordinate(\n        self, x_coord, x_line, vector\n    ):  # TODO Write DocStrings for this.\n        x_coord.next_to(x_line, -np.sign(vector[1]) * UP)\n        x_coord.set_color(X_COLOR)\n        return x_coord",
  "def position_y_coordinate(\n        self, y_coord, y_line, vector\n    ):  # TODO Write DocStrings for this.\n        y_coord.next_to(y_line, np.sign(vector[0]) * RIGHT)\n        y_coord.set_color(Y_COLOR)\n        return y_coord",
  "def coords_to_vector(self, vector, coords_start=2 * RIGHT + 2 * UP, clean_up=True):\n        \"\"\"\n        This method writes the vector as a column matrix (henceforth called the label),\n        takes the values in it one by one, and form the corresponding\n        lines that make up the x and y components of the vector. Then, an\n        Vector() based vector is created between the lines on the Screen.\n\n        Parameters\n        ----------\n        vector : np.ndarray, list, tuple\n            The vector to show.\n\n        coords_start : np.ndarray,list,tuple, optional\n            The starting point of the location of\n            the label of the vector that shows it\n            numerically.\n            Defaults to 2 * RIGHT + 2 * UP or (2,2)\n\n        clean_up : bool, optional\n            Whether or not to remove whatever\n            this method did after it's done.\n\n        \"\"\"\n        starting_mobjects = list(self.mobjects)\n        array = Matrix(vector)\n        array.shift(coords_start)\n        arrow = Vector(vector)\n        x_line = Line(ORIGIN, vector[0] * RIGHT)\n        y_line = Line(x_line.get_end(), arrow.get_end())\n        x_line.set_color(X_COLOR)\n        y_line.set_color(Y_COLOR)\n        x_coord, y_coord = array.get_mob_matrix().flatten()\n\n        self.play(Write(array, run_time=1))\n        self.wait()\n        self.play(\n            ApplyFunction(\n                lambda x: self.position_x_coordinate(x, x_line, vector), x_coord\n            )\n        )\n        self.play(ShowCreation(x_line))\n        self.play(\n            ApplyFunction(\n                lambda y: self.position_y_coordinate(y, y_line, vector), y_coord\n            ),\n            FadeOut(array.get_brackets()),\n        )\n        y_coord, brackets = self.get_mobjects_from_last_animation()\n        self.play(ShowCreation(y_line))\n        self.play(ShowCreation(arrow))\n        self.wait()\n        if clean_up:\n            self.clear()\n            self.add(*starting_mobjects)",
  "def vector_to_coords(self, vector, integer_labels=True, clean_up=True):\n        \"\"\"\n        This method displays vector as a Vector() based vector, and then shows\n        the corresponding lines that make up the x and y components of the vector.\n        Then, a column matrix (henceforth called the label) is created near the\n        head of the Vector.\n\n        Parameters\n        ----------\n        vector : np.ndarray, list, tuple\n            The vector to show.\n\n        integer_label : bool, optional\n            Whether or not to round the value displayed.\n            in the vector's label to the nearest integer\n\n        clean_up : bool, optional\n            Whether or not to remove whatever\n            this method did after it's done.\n\n        \"\"\"\n        starting_mobjects = list(self.mobjects)\n        show_creation = False\n        if isinstance(vector, Arrow):\n            arrow = vector\n            vector = arrow.get_end()[:2]\n        else:\n            arrow = Vector(vector)\n            show_creation = True\n        array = vector_coordinate_label(arrow, integer_labels=integer_labels)\n        x_line = Line(ORIGIN, vector[0] * RIGHT)\n        y_line = Line(x_line.get_end(), arrow.get_end())\n        x_line.set_color(X_COLOR)\n        y_line.set_color(Y_COLOR)\n        x_coord, y_coord = array.get_mob_matrix().flatten()\n        x_coord_start = self.position_x_coordinate(x_coord.copy(), x_line, vector)\n        y_coord_start = self.position_y_coordinate(y_coord.copy(), y_line, vector)\n        brackets = array.get_brackets()\n\n        if show_creation:\n            self.play(ShowCreation(arrow))\n        self.play(ShowCreation(x_line), Write(x_coord_start), run_time=1)\n        self.play(ShowCreation(y_line), Write(y_coord_start), run_time=1)\n        self.wait()\n        self.play(\n            Transform(x_coord_start, x_coord, lag_ratio=0),\n            Transform(y_coord_start, y_coord, lag_ratio=0),\n            Write(brackets, run_time=1),\n        )\n        self.wait()\n\n        self.remove(x_coord_start, y_coord_start, brackets)\n        self.add(array)\n        if clean_up:\n            self.clear()\n            self.add(*starting_mobjects)\n        return array, x_line, y_line",
  "def show_ghost_movement(self, vector):\n        \"\"\"\n        This method plays an animation that partially shows the entire plane moving\n        in the direction of a particular vector. This is useful when you wish to\n        convey the idea of mentally moving the entire plane in a direction, without\n        actually moving the plane.\n\n        Parameters\n        ----------\n        vector : Arrow, list, tuple, np.ndarray\n            The vector which indicates the direction of movement.\n        \"\"\"\n        if isinstance(vector, Arrow):\n            vector = vector.get_end() - vector.get_start()\n        elif len(vector) == 2:\n            vector = np.append(np.array(vector), 0.0)\n        x_max = int(config[\"frame_x_radius\"] + abs(vector[0]))\n        y_max = int(config[\"frame_y_radius\"] + abs(vector[1]))\n        dots = VMobject(\n            *[\n                Dot(x * RIGHT + y * UP)\n                for x in range(-x_max, x_max)\n                for y in range(-y_max, y_max)\n            ]\n        )\n        dots.set_fill(BLACK, opacity=0)\n        dots_halfway = dots.copy().shift(vector / 2).set_fill(WHITE, 1)\n        dots_end = dots.copy().shift(vector)\n\n        self.play(Transform(dots, dots_halfway, rate_func=rush_into))\n        self.play(Transform(dots, dots_end, rate_func=rush_from))\n        self.remove(dots)",
  "def setup(self):\n        # The has_already_setup attr is to not break all the old Scenes\n        if hasattr(self, \"has_already_setup\"):\n            return\n        self.has_already_setup = True\n        self.background_mobjects = []\n        self.foreground_mobjects = []\n        self.transformable_mobjects = []\n        self.moving_vectors = []\n        self.transformable_labels = []\n        self.moving_mobjects = []\n\n        self.t_matrix = np.array(self.t_matrix)\n        self.background_plane = NumberPlane(**self.background_plane_kwargs)\n\n        if self.show_coordinates:\n            self.background_plane.add_coordinates()\n        if self.include_background_plane:\n            self.add_background_mobject(self.background_plane)\n        if self.include_foreground_plane:\n            self.plane = NumberPlane(**self.foreground_plane_kwargs)\n            self.add_transformable_mobject(self.plane)\n        if self.show_basis_vectors:\n            self.basis_vectors = self.get_basis_vectors(\n                i_hat_color=self.i_hat_color, j_hat_color=self.j_hat_color,\n            )\n            self.moving_vectors += list(self.basis_vectors)\n            self.i_hat, self.j_hat = self.basis_vectors\n            self.add(self.basis_vectors)",
  "def add_special_mobjects(self, mob_list, *mobs_to_add):\n        \"\"\"\n        Adds mobjects to a separate list that can be tracked,\n        if these mobjects have some extra importance.\n\n        Parameters\n        ----------\n        mob_list : list\n            The special list to which you want to add\n            these mobjects.\n\n        *mobs_to_add : Mobject\n            The mobjects to add.\n\n        \"\"\"\n        for mobject in mobs_to_add:\n            if mobject not in mob_list:\n                mob_list.append(mobject)\n                self.add(mobject)",
  "def add_background_mobject(self, *mobjects):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.background_mobjects.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobjects to add to the list.\n        \"\"\"\n        self.add_special_mobjects(self.background_mobjects, *mobjects)",
  "def add_foreground_mobject(self, *mobjects):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.foreground_mobjects.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobjects to add to the list\n        \"\"\"\n        self.add_special_mobjects(self.foreground_mobjects, *mobjects)",
  "def add_transformable_mobject(self, *mobjects):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.transformable_mobjects.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobjects to add to the list.\n        \"\"\"\n        self.add_special_mobjects(self.transformable_mobjects, *mobjects)",
  "def add_moving_mobject(self, mobject, target_mobject=None):\n        \"\"\"\n        Adds the mobject to the special list\n        self.moving_mobject, and adds a property\n        to the mobject called mobject.target, which\n        keeps track of what the mobject will move to\n        or become etc.\n\n        Parameters\n        ----------\n        mobject : Mobject\n            The mobjects to add to the list\n\n        target_mobject : Mobject, optional\n            What the moving_mobject goes to, etc.\n        \"\"\"\n        mobject.target = target_mobject\n        self.add_special_mobjects(self.moving_mobjects, mobject)",
  "def get_unit_square(self, color=YELLOW, opacity=0.3, stroke_width=3):\n        \"\"\"\n        Returns a unit square for the current NumberPlane.\n\n        Parameters\n        ----------\n        color : str, optional\n            The string of the hex color code of the color wanted.\n\n        opacity : float, int, optional\n            The opacity of the square\n\n        stroke_width : int, float, optional\n            The stroke_width in pixels of the border of the square\n\n        Returns\n        -------\n        Square\n        \"\"\"\n        square = self.square = Rectangle(\n            color=color,\n            width=self.plane.get_x_unit_size(),\n            height=self.plane.get_y_unit_size(),\n            stroke_color=color,\n            stroke_width=stroke_width,\n            fill_color=color,\n            fill_opacity=opacity,\n        )\n        square.move_to(self.plane.coords_to_point(0, 0), DL)\n        return square",
  "def add_unit_square(self, animate=False, **kwargs):\n        \"\"\"\n        Adds a unit square to the scene via\n        self.get_unit_square.\n\n        Parameters\n        ----------\n        animate (bool)\n            Whether or not to animate the addition\n            with DrawBorderThenFill.\n        **kwargs\n            Any valid keyword arguments of\n            self.get_unit_square()\n\n        Returns\n        -------\n        Square\n            The unit square.\n        \"\"\"\n        square = self.get_unit_square(**kwargs)\n        if animate:\n            self.play(\n                DrawBorderThenFill(square), Animation(Group(*self.moving_vectors))\n            )\n        self.add_transformable_mobject(square)\n        self.bring_to_front(*self.moving_vectors)\n        self.square = square\n        return self",
  "def add_vector(self, vector, color=YELLOW, **kwargs):\n        \"\"\"\n        Adds a vector to the scene, and puts it in the special\n        list self.moving_vectors.\n\n        Parameters\n        ----------\n        vector : Arrow,list,tuple,np.ndarray\n            It can be a pre-made graphical vector, or the\n            coordinates of one.\n\n        color : str\n            The string of the hex color of the vector.\n            This is only taken into consideration if\n            'vector' is not an Arrow. Defaults to YELLOW.\n\n        **kwargs\n            Any valid keyword argument of VectorScene.add_vector.\n\n        Returns\n        -------\n        Arrow\n            The arrow representing the vector.\n        \"\"\"\n        vector = VectorScene.add_vector(self, vector, color=color, **kwargs)\n        self.moving_vectors.append(vector)\n        return vector",
  "def write_vector_coordinates(self, vector, **kwargs):\n        \"\"\"\n        Returns a column matrix indicating the vector coordinates,\n        after writing them to the screen, and adding them to the\n        special list self.foreground_mobjects\n\n        Parameters\n        ----------\n        vector : Arrow\n            The arrow representing the vector.\n\n        **kwargs\n            Any valid keyword arguments of VectorScene.write_vector_coordinates\n\n        Returns\n        -------\n        Matrix\n            The column matrix representing the vector.\n        \"\"\"\n        coords = VectorScene.write_vector_coordinates(self, vector, **kwargs)\n        self.add_foreground_mobject(coords)\n        return coords",
  "def add_transformable_label(\n        self, vector, label, transformation_name=\"L\", new_label=None, **kwargs\n    ):\n        \"\"\"\n        Method for creating, and animating the addition of\n        a transformable label for the vector.\n\n        Parameters\n        ----------\n        vector : Vector\n            The vector for which the label must be added.\n\n        label : TexMobject,str\n            The TexMobject/string of the label.\n\n        transformation_name : str, TexMobject, optional\n            The name to give the transformation as a label.\n\n        new_label : TexMobject,str, optional\n            What the label should display after a Linear Transformation\n\n        **kwargs\n            Any valid keyword argument of get_vector_label\n\n        Returns\n        -------\n        TexMobject\n            The TexMobject of the label.\n        \"\"\"\n        label_mob = self.label_vector(vector, label, **kwargs)\n        if new_label:\n            label_mob.target_text = new_label\n        else:\n            label_mob.target_text = \"%s(%s)\" % (\n                transformation_name,\n                label_mob.get_tex_string(),\n            )\n        label_mob.vector = vector\n        label_mob.kwargs = kwargs\n        if \"animate\" in label_mob.kwargs:\n            label_mob.kwargs.pop(\"animate\")\n        self.transformable_labels.append(label_mob)\n        return label_mob",
  "def add_title(self, title, scale_factor=1.5, animate=False):\n        \"\"\"\n        Adds a title, after scaling it, adding a background rectangle,\n        moving it to the top and adding it to foreground_mobjects adding\n        it as a local variable of self. Returns the Scene.\n\n        Parameters\n        ----------\n        title : str,TexMobject,TextMobject\n            What the title should be.\n\n        scale_factor : int, float, optional\n            How much the title should be scaled by.\n\n        animate : bool\n            Whether or not to animate the addition.\n\n        Returns\n        -------\n        LinearTransformationScene\n            The scene with the title added to it.\n        \"\"\"\n        if not isinstance(title, Mobject):\n            title = TextMobject(title).scale(scale_factor)\n        title.to_edge(UP)\n        title.add_background_rectangle()\n        if animate:\n            self.play(Write(title))\n        self.add_foreground_mobject(title)\n        self.title = title\n        return self",
  "def get_matrix_transformation(self, matrix):\n        \"\"\"\n        Returns a function corresponding to the linear\n        transformation represented by the matrix passed.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix.\n        \"\"\"\n        return self.get_transposed_matrix_transformation(np.array(matrix).T)",
  "def get_transposed_matrix_transformation(self, transposed_matrix):\n        \"\"\"\n        Returns a function corresponding to the linear\n        transformation represented by the transposed\n        matrix passed.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix.\n        \"\"\"\n        transposed_matrix = np.array(transposed_matrix)\n        if transposed_matrix.shape == (2, 2):\n            new_matrix = np.identity(3)\n            new_matrix[:2, :2] = transposed_matrix\n            transposed_matrix = new_matrix\n        elif transposed_matrix.shape != (3, 3):\n            raise Exception(\"Matrix has bad dimensions\")\n        return lambda point: np.dot(point, transposed_matrix)",
  "def get_piece_movement(self, pieces):\n        \"\"\"\n        This method returns an animation that moves an arbitrary\n        mobject in \"pieces\" to its corresponding .target value.\n        If self.leave_ghost_vectors is True, ghosts of the original\n        positions/mobjects are left on screen\n\n        Parameters\n        ----------\n        pieces : list, tuple, np.array\n            The pieces for which the movement must be shown.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        start = VGroup(*pieces)\n        target = VGroup(*[mob.target for mob in pieces])\n        if self.leave_ghost_vectors:\n            self.add(start.copy().fade(0.7))\n        return Transform(start, target, lag_ratio=0)",
  "def get_moving_mobject_movement(self, func):\n        \"\"\"\n        This method returns an animation that moves a mobject\n        in \"self.moving_mobjects\"  to its corresponding .target value.\n        func is a function that determines where the .target goes.\n\n        Parameters\n        ----------\n\n        func : function\n            The function that determines where the .target of\n            the moving mobject goes.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for m in self.moving_mobjects:\n            if m.target is None:\n                m.target = m.copy()\n            target_point = func(m.get_center())\n            m.target.move_to(target_point)\n        return self.get_piece_movement(self.moving_mobjects)",
  "def get_vector_movement(self, func):\n        \"\"\"\n        This method returns an animation that moves a mobject\n        in \"self.moving_vectors\"  to its corresponding .target value.\n        func is a function that determines where the .target goes.\n\n        Parameters\n        ----------\n\n        func : function\n            The function that determines where the .target of\n            the moving mobject goes.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for v in self.moving_vectors:\n            v.target = Vector(func(v.get_end()), color=v.get_color())\n            norm = get_norm(v.target.get_end())\n            if norm < 0.1:\n                v.target.get_tip().scale_in_place(norm)\n        return self.get_piece_movement(self.moving_vectors)",
  "def get_transformable_label_movement(self):\n        \"\"\"\n        This method returns an animation that moves all labels\n        in \"self.transformable_labels\" to its corresponding .target .\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for l in self.transformable_labels:\n            l.target = self.get_vector_label(l.vector.target, l.target_text, **l.kwargs)\n        return self.get_piece_movement(self.transformable_labels)",
  "def apply_matrix(self, matrix, **kwargs):\n        \"\"\"\n        Applies the transformation represented by the\n        given matrix to the number plane, and each vector/similar\n        mobject on it.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_transposed_matrix()\n        \"\"\"\n        self.apply_transposed_matrix(np.array(matrix).T, **kwargs)",
  "def apply_inverse(self, matrix, **kwargs):\n        \"\"\"\n        This method applies the linear transformation\n        represented by the inverse of the passed matrix\n        to the number plane, and each vector/similar mobject on it.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix whose inverse is to be applied.\n        **kwargs\n            Any valid keyword argument of self.apply_matrix()\n        \"\"\"\n        self.apply_matrix(np.linalg.inv(matrix), **kwargs)",
  "def apply_transposed_matrix(self, transposed_matrix, **kwargs):\n        \"\"\"\n        Applies the transformation represented by the\n        given transposed matrix to the number plane,\n        and each vector/similar mobject on it.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_function()\n        \"\"\"\n        func = self.get_transposed_matrix_transformation(transposed_matrix)\n        if \"path_arc\" not in kwargs:\n            net_rotation = np.mean(\n                [angle_of_vector(func(RIGHT)), angle_of_vector(func(UP)) - np.pi / 2]\n            )\n            kwargs[\"path_arc\"] = net_rotation\n        self.apply_function(func, **kwargs)",
  "def apply_inverse_transpose(self, t_matrix, **kwargs):\n        \"\"\"\n        Applies the inverse of the transformation represented\n        by the given transposed matrix to the number plane and each\n        vector/similar mobject on it.\n\n        Parameters\n        ----------\n        matrix : np.ndarray, list, tuple\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_transposed_matrix()\n        \"\"\"\n        t_inv = np.linalg.inv(np.array(t_matrix).T).T\n        self.apply_transposed_matrix(t_inv, **kwargs)",
  "def apply_nonlinear_transformation(self, function, **kwargs):\n        \"\"\"\n        Applies the non-linear transformation represented\n        by the given function to the number plane and each\n        vector/similar mobject on it.\n\n        Parameters\n        ----------\n        function : Function\n            The function.\n        **kwargs\n            Any valid keyword argument of self.apply_function()\n        \"\"\"\n        self.plane.prepare_for_nonlinear_transform()\n        self.apply_function(function, **kwargs)",
  "def apply_function(self, function, added_anims=[], **kwargs):\n        \"\"\"\n        Applies the given function to each of the mobjects in\n        self.transformable_mobjects, and plays the animation showing\n        this.\n\n        Parameters\n        ----------\n        function : Function\n            The function that affects each point\n            of each mobject in self.transformable_mobjects.\n\n        added_anims : list, optional\n            Any other animations that need to be played\n            simulataneously with this.\n\n        **kwargs\n            Any valid keyword argument of a self.play() call.\n        \"\"\"\n        if \"run_time\" not in kwargs:\n            kwargs[\"run_time\"] = 3\n        anims = (\n            [\n                ApplyPointwiseFunction(function, t_mob)\n                for t_mob in self.transformable_mobjects\n            ]\n            + [\n                self.get_vector_movement(function),\n                self.get_transformable_label_movement(),\n                self.get_moving_mobject_movement(function),\n            ]\n            + [Animation(f_mob) for f_mob in self.foreground_mobjects]\n            + added_anims\n        )\n        self.play(*anims, **kwargs)",
  "class Scene(Container):\n    \"\"\"\n    A Scene can be thought of as the Canvas of your animation.\n    All of your own named Scenes will be subclasses of this Scene, or\n    other named scenes.\n\n    Use a construct() function to tell Manim what should go on in the Scene.\n\n    E.G:\n\n        class MyScene(Scene):\n            def construct(self):\n                self.play(\n                    Write(Text(\"Hello World!\"))\n                )\n\n    Some important variables to note are:\n        camera: The camera object to be used for the scene.\n        file_writer : The object that writes the animations in the scene to a video file.\n        mobjects : The list of mobjects present in the scene.\n        foreground_mobjects : List of mobjects explicitly in the foreground.\n        num_plays : Number of play() functions in the scene.\n        time: time elapsed since initialisation of scene.\n        random_seed: The seed with which all random operations are done.\n    \"\"\"\n\n    CONFIG = {\n        \"camera_class\": Camera,\n        \"skip_animations\": False,\n        \"always_update_mobjects\": False,\n        \"random_seed\": 0,\n    }\n\n    def __init__(self, **kwargs):\n        Container.__init__(self, **kwargs)\n        self.camera = self.camera_class(**camera_config)\n        self.file_writer = SceneFileWriter(self, **file_writer_config,)\n\n        self.mobjects = []\n        # TODO, remove need for foreground mobjects\n        self.foreground_mobjects = []\n        self.num_plays = 0\n        self.time = 0\n        self.original_skipping_status = file_writer_config[\"skip_animations\"]\n        if self.random_seed is not None:\n            random.seed(self.random_seed)\n            np.random.seed(self.random_seed)\n\n        self.setup()\n        try:\n            self.construct()\n        except EndSceneEarlyException:\n            pass\n        self.tear_down()\n        self.file_writer.finish()\n        self.print_end_message()\n\n    def setup(self):\n        \"\"\"\n        This is meant to be implemented by any scenes which\n        are comonly subclassed, and have some common setup\n        involved before the construct method is called.\n        \"\"\"\n        pass\n\n    def tear_down(self):\n        \"\"\"\n        This is meant to be implemented by any scenes which\n        are comonly subclassed, and have some common method\n        to be invoked before the scene ends.\n        \"\"\"\n        pass\n\n    def construct(self):\n        \"\"\"\n        The primary method for constructing (i.e adding content to)\n        the Scene.\n        \"\"\"\n        pass  # To be implemented in subclasses\n\n    def __str__(self):\n        return self.__class__.__name__\n\n    def print_end_message(self):\n        \"\"\"\n        Used internally to print the number of\n        animations played after the scene ends.\n        \"\"\"\n        logger.info(\"Played {} animations\".format(self.num_plays))\n\n    def set_variables_as_attrs(self, *objects, **newly_named_objects):\n        \"\"\"\n        This method is slightly hacky, making it a little easier\n        for certain methods (typically subroutines of construct)\n        to share local variables.\n        \"\"\"\n        caller_locals = inspect.currentframe().f_back.f_locals\n        for key, value in list(caller_locals.items()):\n            for o in objects:\n                if value is o:\n                    setattr(self, key, value)\n        for key, value in list(newly_named_objects.items()):\n            setattr(self, key, value)\n        return self\n\n    def get_attrs(self, *keys):\n        \"\"\"\n        Gets attributes of a scene given the attribute's identifier/name.\n\n        Parameters\n        ----------\n        *keys : str\n            Name(s) of the argument(s) to return the attribute of.\n\n        Returns\n        -------\n        list\n            List of attributes of the passed identifiers.\n        \"\"\"\n        return [getattr(self, key) for key in keys]\n\n    # Only these methods should touch the camera\n    def set_camera(self, camera):\n        \"\"\"\n        Sets the scene's camera to be the passed Camera Object.\n\n        Parameters\n        ----------\n        camera : Camera\n            The camera object to use.\n        \"\"\"\n        self.camera = camera\n\n    def get_frame(self):\n        \"\"\"\n        Gets the current frame as NumPy array.\n\n        Returns\n        -------\n        np.array\n            NumPy array of pixel values of each pixel in screen.\n            The shape of the array is height x width x 3\n        \"\"\"\n        return np.array(self.camera.get_pixel_array())\n\n    def get_image(self):\n        \"\"\"\n        Gets current frame as PIL Image\n\n        Returns\n        -------\n        PIL.Image\n            PIL Image object of current frame.\n        \"\"\"\n        return self.camera.get_image()\n\n    def set_camera_pixel_array(self, pixel_array):\n        \"\"\"\n        Sets the camera's pixel array to the passed pixel\n        array. Does not impact what the scene currently displays.\n\n        Parameters\n        ----------\n        pixel_array: Union[np.ndarray,list,tuple]\n            Pixel array\n        \"\"\"\n        self.camera.set_pixel_array(pixel_array)\n\n    def set_camera_background(self, background):\n        \"\"\"\n        Sets the camera to display a Pixel Array\n        in the background.\n\n        Parameters\n        ----------\n        background: Union[np.ndarray,list,tuple]\n            The Pixel Array of the background.\n        \"\"\"\n        self.camera.set_background(background)\n\n    def reset_camera(self):\n        \"\"\"\n        Resets the Camera to its original configuration.\n        \"\"\"\n        self.camera.reset()\n\n    def capture_mobjects_in_camera(\n        self, mobjects, **kwargs\n    ):  # TODO Add more detail to docstring.\n        \"\"\"\n        This method is used internally.\n        \"\"\"\n        self.camera.capture_mobjects(mobjects, **kwargs)\n\n    def update_frame(  # TODO Description in Docstring\n        self,\n        mobjects=None,\n        background=None,\n        include_submobjects=True,\n        ignore_skipping=True,\n        **kwargs,\n    ):\n        \"\"\"\n        Parameters:\n        -----------\n        mobjects: list, optional\n            list of mobjects\n\n        background: np.ndarray, optional\n            Pixel Array for Background.\n\n        include_submobjects: bool, optional\n\n        ignore_skipping : bool, optional\n\n        **kwargs\n\n        \"\"\"\n        if file_writer_config[\"skip_animations\"] and not ignore_skipping:\n            return\n        if mobjects is None:\n            mobjects = list_update(self.mobjects, self.foreground_mobjects,)\n        if background is not None:\n            self.set_camera_pixel_array(background)\n        else:\n            self.reset_camera()\n\n        kwargs[\"include_submobjects\"] = include_submobjects\n        self.capture_mobjects_in_camera(mobjects, **kwargs)\n\n    def freeze_background(self):\n        self.update_frame()\n        self.set_camera(Camera(self.get_frame()))\n        self.clear()\n\n    ###\n\n    def update_mobjects(self, dt):\n        \"\"\"\n        Begins updating all mobjects in the Scene.\n\n        Parameters\n        ----------\n        dt: int or float\n            Change in time between updates. Defaults (mostly) to 1/frames_per_second\n        \"\"\"\n        for mobject in self.mobjects:\n            mobject.update(dt)\n\n    def should_update_mobjects(self):\n        \"\"\"\n        Returns True if any mobject in Scene is being updated\n        or if the scene has always_update_mobjects set to true.\n\n        Returns\n        -------\n            bool\n        \"\"\"\n        return self.always_update_mobjects or any(\n            [mob.has_time_based_updater() for mob in self.get_mobject_family_members()]\n        )\n\n    ###\n\n    def get_time(self):\n        \"\"\"\n        Returns time in seconds elapsed after initialisation of scene\n\n        Returns\n        -------\n        self.time : float\n            Returns time in seconds elapsed after initialisation of scene\n        \"\"\"\n        return self.time\n\n    def increment_time(self, d_time):\n        \"\"\"\n        Increments the time elapsed after intialisation of scene by\n        passed \"d_time\".\n\n        Parameters\n        ----------\n        d_time : int or float\n            Time in seconds to increment by.\n        \"\"\"\n        self.time += d_time\n\n    ###\n\n    def get_top_level_mobjects(self):\n        \"\"\"\n        Returns all mobjects which are not submobjects.\n\n        Returns\n        -------\n        list\n            List of top level mobjects.\n        \"\"\"\n        # Return only those which are not in the family\n        # of another mobject from the scene\n        mobjects = self.get_mobjects()\n        families = [m.get_family() for m in mobjects]\n\n        def is_top_level(mobject):\n            num_families = sum([(mobject in family) for family in families])\n            return num_families == 1\n\n        return list(filter(is_top_level, mobjects))\n\n    def get_mobject_family_members(self):\n        \"\"\"\n        Returns list of family-members of all mobjects in scene.\n        If a Circle() and a VGroup(Rectangle(),Triangle()) were added,\n        it returns not only the Circle(), Rectangle() and Triangle(), but\n        also the VGroup() object.\n\n        Returns\n        -------\n        list\n            List of mobject family members.\n        \"\"\"\n        return self.camera.extract_mobject_family_members(self.mobjects)\n\n    def add(self, *mobjects):\n        \"\"\"\n        Mobjects will be displayed, from background to\n        foreground in the order with which they are added.\n\n        Parameters\n        ---------\n        *mobjects : Mobject\n            Mobjects to add.\n\n        Returns\n        -------\n        Scene\n            The same scene after adding the Mobjects in.\n\n        \"\"\"\n        mobjects = [*mobjects, *self.foreground_mobjects]\n        self.restructure_mobjects(to_remove=mobjects)\n        self.mobjects += mobjects\n        return self\n\n    def add_mobjects_among(self, values):\n        \"\"\"\n        This is meant mostly for quick prototyping,\n        e.g. to add all mobjects defined up to a point,\n        call self.add_mobjects_among(locals().values())\n        \"\"\"\n        self.add(*filter(lambda m: isinstance(m, Mobject), values))\n        return self\n\n    def remove(self, *mobjects):\n        \"\"\"\n        Removes mobjects in the passed list of mobjects\n        from the scene and the foreground, by removing them\n        from \"mobjects\" and \"foreground_mobjects\"\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobjects to remove.\n        \"\"\"\n        for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False)\n        return self\n\n    def restructure_mobjects(\n        self, to_remove, mobject_list_name=\"mobjects\", extract_families=True\n    ):\n        \"\"\"\n        tl:wr\n            If your scene has a Group(), and you removed a mobject from the Group,\n            this dissolves the group and puts the rest of the mobjects directly\n            in self.mobjects or self.foreground_mobjects.\n\n        In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one\n        of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects\n        will be edited to contain other submobjects, but not m1, e.g. it will now\n        insert m2 and m3 to where the group once was.\n\n        Parameters\n        ----------\n        to_remove : Mobject\n            The Mobject to remove.\n\n        mobject_list_name : str, optional\n            The list of mobjects (\"mobjects\", \"foreground_mobjects\" etc) to remove from.\n\n        extract_families : bool, optional\n            Whether the mobject's families should be recursively extracted.\n\n        Returns\n        -------\n        Scene\n            The Scene mobject with restructured Mobjects.\n        \"\"\"\n        if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove):\n        \"\"\"\n        Given a list of mobjects and a list of mobjects to be removed, this\n        filters out the removable mobjects from the list of mobjects.\n\n        Parameters\n        ----------\n\n        mobjects : list\n            The Mobjects to check.\n\n        to_remove : list\n            The list of mobjects to remove.\n\n        Returns\n        -------\n        list\n            The list of mobjects with the mobjects to remove removed.\n        \"\"\"\n\n        new_mobjects = []\n\n        def add_safe_mobjects_from_list(list_to_examine, set_to_remove):\n            for mob in list_to_examine:\n                if mob in set_to_remove:\n                    continue\n                intersect = set_to_remove.intersection(mob.get_family())\n                if intersect:\n                    add_safe_mobjects_from_list(mob.submobjects, intersect)\n                else:\n                    new_mobjects.append(mob)\n\n        add_safe_mobjects_from_list(mobjects, set(to_remove))\n        return new_mobjects\n\n    # TODO, remove this, and calls to this\n    def add_foreground_mobjects(self, *mobjects):\n        \"\"\"\n        Adds mobjects to the foreground, and internally to the list\n        foreground_mobjects, and mobjects.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The Mobjects to add to the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobjects added.\n        \"\"\"\n        self.foreground_mobjects = list_update(self.foreground_mobjects, mobjects)\n        self.add(*mobjects)\n        return self\n\n    def add_foreground_mobject(self, mobject):\n        \"\"\"\n        Adds a single mobject to the foreground, and internally to the list\n        foreground_mobjects, and mobjects.\n\n        Parameters\n        ----------\n        mobject : Mobject\n            The Mobject to add to the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobject added.\n        \"\"\"\n        return self.add_foreground_mobjects(mobject)\n\n    def remove_foreground_mobjects(self, *to_remove):\n        \"\"\"\n        Removes mobjects from the foreground, and internally from the list\n        foreground_mobjects.\n\n        Parameters\n        ----------\n        *to_remove : Mobject\n            The mobject(s) to remove from the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobjects removed.\n        \"\"\"\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\")\n        return self\n\n    def remove_foreground_mobject(self, mobject):\n        \"\"\"\n        Removes a single mobject from the foreground, and internally from the list\n        foreground_mobjects.\n\n        Parameters\n        ----------\n        mobject : Mobject\n            The mobject to remove from the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobject removed.\n        \"\"\"\n        return self.remove_foreground_mobjects(mobject)\n\n    def bring_to_front(self, *mobjects):\n        \"\"\"\n        Adds the passed mobjects to the scene again,\n        pushing them to he front of the scene.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobject(s) to bring to the front of the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the mobjects brought to the front\n            of the scene.\n        \"\"\"\n        self.add(*mobjects)\n        return self\n\n    def bring_to_back(self, *mobjects):\n        \"\"\"\n        Removes the mobject from the scene and\n        adds them to the back of the scene.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobject(s) to push to the back of the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the mobjects pushed to the back\n            of the scene.\n        \"\"\"\n        self.remove(*mobjects)\n        self.mobjects = list(mobjects) + self.mobjects\n        return self\n\n    def clear(self):\n        \"\"\"\n        Removes all mobjects present in self.mobjects\n        and self.foreground_mobjects from the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with all of its mobjects in\n            self.mobjects and self.foreground_mobjects\n            removed.\n        \"\"\"\n        self.mobjects = []\n        self.foreground_mobjects = []\n        return self\n\n    def get_mobjects(self):\n        \"\"\"\n        Returns all the mobjects in self.mobjects\n\n        Returns\n        ------\n        list\n            The list of self.mobjects .\n        \"\"\"\n        return list(self.mobjects)\n\n    def get_mobject_copies(self):\n        \"\"\"\n        Returns a copy of all mobjects present in\n        self.mobjects .\n\n        Returns\n        ------\n        list\n            A list of the copies of all the mobjects\n            in self.mobjects\n        \"\"\"\n        return [m.copy() for m in self.mobjects]\n\n    def get_moving_mobjects(self, *animations):\n        \"\"\"\n        Gets all moving mobjects in the passed animation(s).\n\n        Parameters\n        ----------\n        *animations : Animation\n            The animations to check for moving mobjects.\n\n        Returns\n        ------\n        list\n            The list of mobjects that could be moving in\n            the Animation(s)\n        \"\"\"\n        # Go through mobjects from start to end, and\n        # as soon as there's one that needs updating of\n        # some kind per frame, return the list from that\n        # point forward.\n        animation_mobjects = [anim.mobject for anim in animations]\n        mobjects = self.get_mobject_family_members()\n        for i, mob in enumerate(mobjects):\n            update_possibilities = [\n                mob in animation_mobjects,\n                len(mob.get_family_updaters()) > 0,\n                mob in self.foreground_mobjects,\n            ]\n            if any(update_possibilities):\n                return mobjects[i:]\n        return []\n\n    def get_time_progression(\n        self, run_time, n_iterations=None, override_skip_animations=False\n    ):\n        \"\"\"\n        You will hardly use this when making your own animations.\n        This method is for Manim's internal use.\n\n        Returns a CommandLine ProgressBar whose fill_time\n        is dependent on the run_time of an animation,\n        the iterations to perform in that animation\n        and a bool saying whether or not to consider\n        the skipped animations.\n\n        Parameters\n        ----------\n        run_time: float\n            The run_time of the animation.\n\n        n_iterations: int, optional\n            The number of iterations in the animation.\n\n        override_skip_animations: bool, optional\n            Whether or not to show skipped animations in the progress bar.\n\n        Returns\n        ------\n        ProgressDisplay\n            The CommandLine Progress Bar.\n        \"\"\"\n        if file_writer_config[\"skip_animations\"] and not override_skip_animations:\n            times = [run_time]\n        else:\n            step = 1 / self.camera.frame_rate\n            times = np.arange(0, run_time, step)\n        time_progression = ProgressDisplay(\n            times,\n            total=n_iterations,\n            leave=file_writer_config[\"leave_progress_bars\"],\n            ascii=True if platform.system() == \"Windows\" else None,\n        )\n        return time_progression\n\n    def get_run_time(self, animations):\n        \"\"\"\n        Gets the total run time for a list of animations.\n\n        Parameters\n        ----------\n        animations: list of Animation\n            A list of the animations whose total\n            run_time is to be calculated.\n\n        Returns\n        ------\n        float\n            The total run_time of all of the animations in the list.\n        \"\"\"\n\n        return np.max([animation.run_time for animation in animations])\n\n    def get_animation_time_progression(self, animations):\n        \"\"\"\n        You will hardly use this when making your own animations.\n        This method is for Manim's internal use.\n\n        Uses get_time_progression to obtaina\n        CommandLine ProgressBar whose fill_time is\n        dependent on the qualities of the passed Animation,\n\n        Parameters\n        ----------\n        animations : list of Animation\n            The list of animations to get\n            the time progression for.\n\n        Returns\n        ------\n        ProgressDisplay\n            The CommandLine Progress Bar.\n        \"\"\"\n        run_time = self.get_run_time(animations)\n        time_progression = self.get_time_progression(run_time)\n        time_progression.set_description(\n            \"\".join(\n                [\n                    \"Animation {}: \".format(self.num_plays),\n                    str(animations[0]),\n                    (\", etc.\" if len(animations) > 1 else \"\"),\n                ]\n            )\n        )\n        return time_progression\n\n    def compile_play_args_to_animation_list(self, *args, **kwargs):\n        \"\"\"\n        Each arg can either be an animation, or a mobject method\n        followed by that methods arguments (and potentially follow\n        by a dict of kwargs for that method).\n        This animation list is built by going through the args list,\n        and each animation is simply added, but when a mobject method\n        s hit, a MoveToTarget animation is built using the args that\n        follow up until either another animation is hit, another method\n        is hit, or the args list runs out.\n\n        Parameters\n        ----------\n        *args : Animation or method of a mobject, which is followed by that method's arguments\n\n        **kwargs : any named arguments like run_time or lag_ratio.\n\n        Returns\n        -------\n        list : list of animations with the parameters applied to them.\n        \"\"\"\n        animations = []\n        state = {\n            \"curr_method\": None,\n            \"last_method\": None,\n            \"method_args\": [],\n        }\n\n        def compile_method(state):\n            if state[\"curr_method\"] is None:\n                return\n            mobject = state[\"curr_method\"].__self__\n            if state[\"last_method\"] and state[\"last_method\"].__self__ is mobject:\n                animations.pop()\n                # method should already have target then.\n            else:\n                mobject.generate_target()\n            #\n            if len(state[\"method_args\"]) > 0 and isinstance(\n                state[\"method_args\"][-1], dict\n            ):\n                method_kwargs = state[\"method_args\"].pop()\n            else:\n                method_kwargs = {}\n            state[\"curr_method\"].__func__(\n                mobject.target, *state[\"method_args\"], **method_kwargs\n            )\n            animations.append(MoveToTarget(mobject))\n            state[\"last_method\"] = state[\"curr_method\"]\n            state[\"curr_method\"] = None\n            state[\"method_args\"] = []\n\n        for arg in args:\n            if isinstance(arg, Animation):\n                compile_method(state)\n                animations.append(arg)\n            elif inspect.ismethod(arg):\n                compile_method(state)\n                state[\"curr_method\"] = arg\n            elif state[\"curr_method\"] is not None:\n                state[\"method_args\"].append(arg)\n            elif isinstance(arg, Mobject):\n                raise Exception(\n                    \"\"\"\n                    I think you may have invoked a method\n                    you meant to pass in as a Scene.play argument\n                \"\"\"\n                )\n            else:\n                raise Exception(\"Invalid play arguments\")\n        compile_method(state)\n\n        for animation in animations:\n            # This is where kwargs to play like run_time and rate_func\n            # get applied to all animations\n            animation.update_config(**kwargs)\n\n        return animations\n\n    def update_skipping_status(self):\n        \"\"\"\n        This method is used internally to check if the current\n        animation needs to be skipped or not. It also checks if\n        the number of animations that were played correspond to\n        the number of animations that need to be played, and\n        raises an EndSceneEarlyException if they don't correspond.\n        \"\"\"\n\n        if file_writer_config[\"from_animation_number\"]:\n            if self.num_plays == file_writer_config[\"from_animation_number\"]:\n                file_writer_config[\"skip_animations\"] = False\n        if file_writer_config[\"upto_animation_number\"]:\n            if self.num_plays >= file_writer_config[\"upto_animation_number\"]:\n                file_writer_config[\"skip_animations\"] = True\n                raise EndSceneEarlyException()\n\n    def handle_play_like_call(func):\n        \"\"\"\n        This method is used internally to wrap the\n        passed function, into a function that\n        actually writes to the video stream.\n        Simultaneously, it also adds to the number\n        of animations played.\n\n        Parameters\n        ----------\n        func : function\n            The play() like function that has to be\n            written to the video file stream.\n\n        Returns\n        -------\n        function\n            The play() like function that can now write\n            to the video file stream.\n        \"\"\"\n\n        def wrapper(self, *args, **kwargs):\n            self.update_skipping_status()\n            allow_write = not file_writer_config[\"skip_animations\"]\n            self.file_writer.begin_animation(allow_write)\n            func(self, *args, **kwargs)\n            self.file_writer.end_animation(allow_write)\n            self.num_plays += 1\n\n        return wrapper\n\n    def begin_animations(self, animations):\n        \"\"\"\n        This method begins the list of animations that is passed,\n        and adds any mobjects involved (if not already present)\n        to the scene again.\n\n        Parameters\n        ----------\n        animations : list\n            List of involved animations.\n\n        \"\"\"\n        curr_mobjects = self.get_mobject_family_members()\n        for animation in animations:\n            # Begin animation\n            animation.begin()\n            # Anything animated that's not already in the\n            # scene gets added to the scene\n            mob = animation.mobject\n            if mob not in curr_mobjects:\n                self.add(mob)\n                curr_mobjects += mob.get_family()\n\n    def progress_through_animations(self, animations):\n        \"\"\"\n        This method progresses through each animation\n        in the list passed and and updates the frames as required.\n\n        Parameters\n        ----------\n        animations : list\n            List of involved animations.\n        \"\"\"\n        # Paint all non-moving objects onto the screen, so they don't\n        # have to be rendered every frame\n        moving_mobjects = self.get_moving_mobjects(*animations)\n        self.update_frame(excluded_mobjects=moving_mobjects)\n        static_image = self.get_frame()\n        last_t = 0\n        for t in self.get_animation_time_progression(animations):\n            dt = t - last_t\n            last_t = t\n            for animation in animations:\n                animation.update_mobjects(dt)\n                alpha = t / animation.run_time\n                animation.interpolate(alpha)\n            self.update_mobjects(dt)\n            self.update_frame(moving_mobjects, static_image)\n            self.add_frames(self.get_frame())\n\n    def finish_animations(self, animations):\n        \"\"\"\n        This function cleans up after the end\n        of each animation in the passed list.\n\n        Parameters\n        ----------\n        animations : list\n            list of animations to finish.\n        \"\"\"\n        for animation in animations:\n            animation.finish()\n            animation.clean_up_from_scene(self)\n        self.mobjects_from_last_animation = [anim.mobject for anim in animations]\n        if file_writer_config[\"skip_animations\"]:\n            # TODO, run this call in for each animation?\n            self.update_mobjects(self.get_run_time(animations))\n        else:\n            self.update_mobjects(0)\n\n    @handle_play_like_call\n    def play(self, *args, **kwargs):\n        \"\"\"\n        This method is used to prep the animations for rendering,\n        apply the arguments and parameters required to them,\n        render them, and write them to the video file.\n\n        Parameters\n        ----------\n        *args : Animation or mobject with mobject method and params\n        **kwargs : named parameters affecting what was passed in *args e.g run_time, lag_ratio etc.\n        \"\"\"\n        if len(args) == 0:\n            warnings.warn(\"Called Scene.play with no animations\")\n            return\n        animations = self.compile_play_args_to_animation_list(*args, **kwargs)\n        self.begin_animations(animations)\n        self.progress_through_animations(animations)\n        self.finish_animations(animations)\n\n    def idle_stream(self):\n        \"\"\"\n        This method is used internally to\n        idle the video file_writer until an\n        animation etc needs to be written\n        to the video file.\n        \"\"\"\n        self.file_writer.idle_stream()\n\n    def clean_up_animations(self, *animations):\n        \"\"\"\n        This method cleans up and removes from the\n        scene all the animations that were passed\n\n        Parameters\n        ----------\n        *animations : Animation\n            Animation to clean up.\n\n        Returns\n        -------\n        Scene\n            The scene with the animations\n            cleaned up.\n\n        \"\"\"\n        for animation in animations:\n            animation.clean_up_from_scene(self)\n        return self\n\n    def get_mobjects_from_last_animation(self):\n        \"\"\"\n        This method returns the mobjects from the previous\n        played animation, if any exist, and returns an empty\n        list if not.\n\n        Returns\n        --------\n        list\n            The list of mobjects from the previous animation.\n\n        \"\"\"\n        if hasattr(self, \"mobjects_from_last_animation\"):\n            return self.mobjects_from_last_animation\n        return []\n\n    def get_wait_time_progression(self, duration, stop_condition):\n        \"\"\"\n        This method is used internally to obtain the CommandLine\n        Progressbar for when self.wait() is called in a scene.\n\n        Parameters\n        ----------\n        duration: int or float\n            duration of wait time\n\n        stop_condition : function\n            The function which determines whether to continue waiting.\n\n        Returns\n        -------\n        ProgressBar\n            The CommandLine ProgressBar of the wait time\n\n        \"\"\"\n        if stop_condition is not None:\n            time_progression = self.get_time_progression(\n                duration,\n                n_iterations=-1,  # So it doesn't show % progress\n                override_skip_animations=True,\n            )\n            time_progression.set_description(\n                \"Waiting for {}\".format(stop_condition.__name__)\n            )\n        else:\n            time_progression = self.get_time_progression(duration)\n            time_progression.set_description(\"Waiting {}\".format(self.num_plays))\n        return time_progression\n\n    @handle_play_like_call\n    def wait(self, duration=DEFAULT_WAIT_TIME, stop_condition=None):\n        \"\"\"\n        This method is used to wait, and do nothing to the scene, for some\n        duration.\n        Updaters stop updating, nothing happens.\n\n        Parameters\n        ----------\n        duration : float or int, optional\n            The duration of wait time.\n        stop_condition :\n            A function that determines whether to stop waiting or not.\n\n        Returns\n        -------\n        Scene\n            The scene, after waiting.\n        \"\"\"\n        self.update_mobjects(dt=0)  # Any problems with this?\n        if self.should_update_mobjects():\n            time_progression = self.get_wait_time_progression(duration, stop_condition)\n            # TODO, be smart about setting a static image\n            # the same way Scene.play does\n            last_t = 0\n            for t in time_progression:\n                dt = t - last_t\n                last_t = t\n                self.update_mobjects(dt)\n                self.update_frame()\n                self.add_frames(self.get_frame())\n                if stop_condition is not None and stop_condition():\n                    time_progression.close()\n                    break\n        elif file_writer_config[\"skip_animations\"]:\n            # Do nothing\n            return self\n        else:\n            self.update_frame()\n            dt = 1 / self.camera.frame_rate\n            n_frames = int(duration / dt)\n            frame = self.get_frame()\n            self.add_frames(*[frame] * n_frames)\n        return self\n\n    def wait_until(self, stop_condition, max_time=60):\n        \"\"\"\n        Like a wrapper for wait().\n        You pass a function that determines whether to continue waiting,\n        and a max wait time if that is never fulfilled.\n\n        Parameters\n        ----------\n        stop_condition : function\n            The function whose boolean return value determines whether to continue waiting\n\n        max_time : int or float, optional\n            The maximum wait time in seconds, if the stop_condition is never fulfilled.\n        \"\"\"\n        self.wait(max_time, stop_condition=stop_condition)\n\n    def force_skipping(self):\n        \"\"\"\n        This forces the skipping of animations,\n        by setting original_skipping_status to\n        whatever skip_animations was, and setting\n        skip_animations to True.\n\n        Returns\n        -------\n        Scene\n            The Scene, with skipping turned on.\n        \"\"\"\n        self.original_skipping_status = self.SKIP_ANIMATIONS\n        self.SKIP_ANIMATIONS = True\n        return self\n\n    def revert_to_original_skipping_status(self):\n        \"\"\"\n        Forces the scene to go back to its original skipping status,\n        by setting skip_animations to whatever it reads\n        from original_skipping_status.\n\n        Returns\n        -------\n        Scene\n            The Scene, with the original skipping status.\n        \"\"\"\n        if hasattr(self, \"original_skipping_status\"):\n            self.SKIP_ANIMATIONS = self.original_skipping_status\n        return self\n\n    def add_frames(self, *frames):\n        \"\"\"\n        Adds a frame to the video_file_stream\n\n        Parameters\n        ----------\n        *frames : numpy.ndarray\n            The frames to add, as pixel arrays.\n        \"\"\"\n        dt = 1 / self.camera.frame_rate\n        self.increment_time(len(frames) * dt)\n        if file_writer_config[\"skip_animations\"]:\n            return\n        for frame in frames:\n            self.file_writer.write_frame(frame)\n\n    def add_sound(self, sound_file, time_offset=0, gain=None, **kwargs):\n        \"\"\"\n        This method is used to add a sound to the animation.\n\n        Parameters\n        ----------\n        sound_file : str\n            The path to the sound file.\n\n        time_offset : int,float, optional\n            The offset in the sound file after which\n            the sound can be played.\n\n        gain :\n\n        \"\"\"\n        if self.SKIP_ANIMATIONS:\n            return\n        time = self.get_time() + time_offset\n        self.file_writer.add_sound(sound_file, time, gain, **kwargs)\n\n    def show_frame(self):\n        \"\"\"\n        Opens the current frame in the Default Image Viewer\n        of your system.\n        \"\"\"\n        self.update_frame(ignore_skipping=True)\n        self.get_image().show()",
  "class EndSceneEarlyException(Exception):\n    pass",
  "def __init__(self, **kwargs):\n        Container.__init__(self, **kwargs)\n        self.camera = self.camera_class(**camera_config)\n        self.file_writer = SceneFileWriter(self, **file_writer_config,)\n\n        self.mobjects = []\n        # TODO, remove need for foreground mobjects\n        self.foreground_mobjects = []\n        self.num_plays = 0\n        self.time = 0\n        self.original_skipping_status = file_writer_config[\"skip_animations\"]\n        if self.random_seed is not None:\n            random.seed(self.random_seed)\n            np.random.seed(self.random_seed)\n\n        self.setup()\n        try:\n            self.construct()\n        except EndSceneEarlyException:\n            pass\n        self.tear_down()\n        self.file_writer.finish()\n        self.print_end_message()",
  "def setup(self):\n        \"\"\"\n        This is meant to be implemented by any scenes which\n        are comonly subclassed, and have some common setup\n        involved before the construct method is called.\n        \"\"\"\n        pass",
  "def tear_down(self):\n        \"\"\"\n        This is meant to be implemented by any scenes which\n        are comonly subclassed, and have some common method\n        to be invoked before the scene ends.\n        \"\"\"\n        pass",
  "def construct(self):\n        \"\"\"\n        The primary method for constructing (i.e adding content to)\n        the Scene.\n        \"\"\"\n        pass",
  "def __str__(self):\n        return self.__class__.__name__",
  "def print_end_message(self):\n        \"\"\"\n        Used internally to print the number of\n        animations played after the scene ends.\n        \"\"\"\n        logger.info(\"Played {} animations\".format(self.num_plays))",
  "def set_variables_as_attrs(self, *objects, **newly_named_objects):\n        \"\"\"\n        This method is slightly hacky, making it a little easier\n        for certain methods (typically subroutines of construct)\n        to share local variables.\n        \"\"\"\n        caller_locals = inspect.currentframe().f_back.f_locals\n        for key, value in list(caller_locals.items()):\n            for o in objects:\n                if value is o:\n                    setattr(self, key, value)\n        for key, value in list(newly_named_objects.items()):\n            setattr(self, key, value)\n        return self",
  "def get_attrs(self, *keys):\n        \"\"\"\n        Gets attributes of a scene given the attribute's identifier/name.\n\n        Parameters\n        ----------\n        *keys : str\n            Name(s) of the argument(s) to return the attribute of.\n\n        Returns\n        -------\n        list\n            List of attributes of the passed identifiers.\n        \"\"\"\n        return [getattr(self, key) for key in keys]",
  "def set_camera(self, camera):\n        \"\"\"\n        Sets the scene's camera to be the passed Camera Object.\n\n        Parameters\n        ----------\n        camera : Camera\n            The camera object to use.\n        \"\"\"\n        self.camera = camera",
  "def get_frame(self):\n        \"\"\"\n        Gets the current frame as NumPy array.\n\n        Returns\n        -------\n        np.array\n            NumPy array of pixel values of each pixel in screen.\n            The shape of the array is height x width x 3\n        \"\"\"\n        return np.array(self.camera.get_pixel_array())",
  "def get_image(self):\n        \"\"\"\n        Gets current frame as PIL Image\n\n        Returns\n        -------\n        PIL.Image\n            PIL Image object of current frame.\n        \"\"\"\n        return self.camera.get_image()",
  "def set_camera_pixel_array(self, pixel_array):\n        \"\"\"\n        Sets the camera's pixel array to the passed pixel\n        array. Does not impact what the scene currently displays.\n\n        Parameters\n        ----------\n        pixel_array: Union[np.ndarray,list,tuple]\n            Pixel array\n        \"\"\"\n        self.camera.set_pixel_array(pixel_array)",
  "def set_camera_background(self, background):\n        \"\"\"\n        Sets the camera to display a Pixel Array\n        in the background.\n\n        Parameters\n        ----------\n        background: Union[np.ndarray,list,tuple]\n            The Pixel Array of the background.\n        \"\"\"\n        self.camera.set_background(background)",
  "def reset_camera(self):\n        \"\"\"\n        Resets the Camera to its original configuration.\n        \"\"\"\n        self.camera.reset()",
  "def capture_mobjects_in_camera(\n        self, mobjects, **kwargs\n    ):  # TODO Add more detail to docstring.\n        \"\"\"\n        This method is used internally.\n        \"\"\"\n        self.camera.capture_mobjects(mobjects, **kwargs)",
  "def update_frame(  # TODO Description in Docstring\n        self,\n        mobjects=None,\n        background=None,\n        include_submobjects=True,\n        ignore_skipping=True,\n        **kwargs,\n    ):\n        \"\"\"\n        Parameters:\n        -----------\n        mobjects: list, optional\n            list of mobjects\n\n        background: np.ndarray, optional\n            Pixel Array for Background.\n\n        include_submobjects: bool, optional\n\n        ignore_skipping : bool, optional\n\n        **kwargs\n\n        \"\"\"\n        if file_writer_config[\"skip_animations\"] and not ignore_skipping:\n            return\n        if mobjects is None:\n            mobjects = list_update(self.mobjects, self.foreground_mobjects,)\n        if background is not None:\n            self.set_camera_pixel_array(background)\n        else:\n            self.reset_camera()\n\n        kwargs[\"include_submobjects\"] = include_submobjects\n        self.capture_mobjects_in_camera(mobjects, **kwargs)",
  "def freeze_background(self):\n        self.update_frame()\n        self.set_camera(Camera(self.get_frame()))\n        self.clear()",
  "def update_mobjects(self, dt):\n        \"\"\"\n        Begins updating all mobjects in the Scene.\n\n        Parameters\n        ----------\n        dt: int or float\n            Change in time between updates. Defaults (mostly) to 1/frames_per_second\n        \"\"\"\n        for mobject in self.mobjects:\n            mobject.update(dt)",
  "def should_update_mobjects(self):\n        \"\"\"\n        Returns True if any mobject in Scene is being updated\n        or if the scene has always_update_mobjects set to true.\n\n        Returns\n        -------\n            bool\n        \"\"\"\n        return self.always_update_mobjects or any(\n            [mob.has_time_based_updater() for mob in self.get_mobject_family_members()]\n        )",
  "def get_time(self):\n        \"\"\"\n        Returns time in seconds elapsed after initialisation of scene\n\n        Returns\n        -------\n        self.time : float\n            Returns time in seconds elapsed after initialisation of scene\n        \"\"\"\n        return self.time",
  "def increment_time(self, d_time):\n        \"\"\"\n        Increments the time elapsed after intialisation of scene by\n        passed \"d_time\".\n\n        Parameters\n        ----------\n        d_time : int or float\n            Time in seconds to increment by.\n        \"\"\"\n        self.time += d_time",
  "def get_top_level_mobjects(self):\n        \"\"\"\n        Returns all mobjects which are not submobjects.\n\n        Returns\n        -------\n        list\n            List of top level mobjects.\n        \"\"\"\n        # Return only those which are not in the family\n        # of another mobject from the scene\n        mobjects = self.get_mobjects()\n        families = [m.get_family() for m in mobjects]\n\n        def is_top_level(mobject):\n            num_families = sum([(mobject in family) for family in families])\n            return num_families == 1\n\n        return list(filter(is_top_level, mobjects))",
  "def get_mobject_family_members(self):\n        \"\"\"\n        Returns list of family-members of all mobjects in scene.\n        If a Circle() and a VGroup(Rectangle(),Triangle()) were added,\n        it returns not only the Circle(), Rectangle() and Triangle(), but\n        also the VGroup() object.\n\n        Returns\n        -------\n        list\n            List of mobject family members.\n        \"\"\"\n        return self.camera.extract_mobject_family_members(self.mobjects)",
  "def add(self, *mobjects):\n        \"\"\"\n        Mobjects will be displayed, from background to\n        foreground in the order with which they are added.\n\n        Parameters\n        ---------\n        *mobjects : Mobject\n            Mobjects to add.\n\n        Returns\n        -------\n        Scene\n            The same scene after adding the Mobjects in.\n\n        \"\"\"\n        mobjects = [*mobjects, *self.foreground_mobjects]\n        self.restructure_mobjects(to_remove=mobjects)\n        self.mobjects += mobjects\n        return self",
  "def add_mobjects_among(self, values):\n        \"\"\"\n        This is meant mostly for quick prototyping,\n        e.g. to add all mobjects defined up to a point,\n        call self.add_mobjects_among(locals().values())\n        \"\"\"\n        self.add(*filter(lambda m: isinstance(m, Mobject), values))\n        return self",
  "def remove(self, *mobjects):\n        \"\"\"\n        Removes mobjects in the passed list of mobjects\n        from the scene and the foreground, by removing them\n        from \"mobjects\" and \"foreground_mobjects\"\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobjects to remove.\n        \"\"\"\n        for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False)\n        return self",
  "def restructure_mobjects(\n        self, to_remove, mobject_list_name=\"mobjects\", extract_families=True\n    ):\n        \"\"\"\n        tl:wr\n            If your scene has a Group(), and you removed a mobject from the Group,\n            this dissolves the group and puts the rest of the mobjects directly\n            in self.mobjects or self.foreground_mobjects.\n\n        In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one\n        of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects\n        will be edited to contain other submobjects, but not m1, e.g. it will now\n        insert m2 and m3 to where the group once was.\n\n        Parameters\n        ----------\n        to_remove : Mobject\n            The Mobject to remove.\n\n        mobject_list_name : str, optional\n            The list of mobjects (\"mobjects\", \"foreground_mobjects\" etc) to remove from.\n\n        extract_families : bool, optional\n            Whether the mobject's families should be recursively extracted.\n\n        Returns\n        -------\n        Scene\n            The Scene mobject with restructured Mobjects.\n        \"\"\"\n        if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self",
  "def get_restructured_mobject_list(self, mobjects, to_remove):\n        \"\"\"\n        Given a list of mobjects and a list of mobjects to be removed, this\n        filters out the removable mobjects from the list of mobjects.\n\n        Parameters\n        ----------\n\n        mobjects : list\n            The Mobjects to check.\n\n        to_remove : list\n            The list of mobjects to remove.\n\n        Returns\n        -------\n        list\n            The list of mobjects with the mobjects to remove removed.\n        \"\"\"\n\n        new_mobjects = []\n\n        def add_safe_mobjects_from_list(list_to_examine, set_to_remove):\n            for mob in list_to_examine:\n                if mob in set_to_remove:\n                    continue\n                intersect = set_to_remove.intersection(mob.get_family())\n                if intersect:\n                    add_safe_mobjects_from_list(mob.submobjects, intersect)\n                else:\n                    new_mobjects.append(mob)\n\n        add_safe_mobjects_from_list(mobjects, set(to_remove))\n        return new_mobjects",
  "def add_foreground_mobjects(self, *mobjects):\n        \"\"\"\n        Adds mobjects to the foreground, and internally to the list\n        foreground_mobjects, and mobjects.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The Mobjects to add to the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobjects added.\n        \"\"\"\n        self.foreground_mobjects = list_update(self.foreground_mobjects, mobjects)\n        self.add(*mobjects)\n        return self",
  "def add_foreground_mobject(self, mobject):\n        \"\"\"\n        Adds a single mobject to the foreground, and internally to the list\n        foreground_mobjects, and mobjects.\n\n        Parameters\n        ----------\n        mobject : Mobject\n            The Mobject to add to the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobject added.\n        \"\"\"\n        return self.add_foreground_mobjects(mobject)",
  "def remove_foreground_mobjects(self, *to_remove):\n        \"\"\"\n        Removes mobjects from the foreground, and internally from the list\n        foreground_mobjects.\n\n        Parameters\n        ----------\n        *to_remove : Mobject\n            The mobject(s) to remove from the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobjects removed.\n        \"\"\"\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\")\n        return self",
  "def remove_foreground_mobject(self, mobject):\n        \"\"\"\n        Removes a single mobject from the foreground, and internally from the list\n        foreground_mobjects.\n\n        Parameters\n        ----------\n        mobject : Mobject\n            The mobject to remove from the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobject removed.\n        \"\"\"\n        return self.remove_foreground_mobjects(mobject)",
  "def bring_to_front(self, *mobjects):\n        \"\"\"\n        Adds the passed mobjects to the scene again,\n        pushing them to he front of the scene.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobject(s) to bring to the front of the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the mobjects brought to the front\n            of the scene.\n        \"\"\"\n        self.add(*mobjects)\n        return self",
  "def bring_to_back(self, *mobjects):\n        \"\"\"\n        Removes the mobject from the scene and\n        adds them to the back of the scene.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobject(s) to push to the back of the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the mobjects pushed to the back\n            of the scene.\n        \"\"\"\n        self.remove(*mobjects)\n        self.mobjects = list(mobjects) + self.mobjects\n        return self",
  "def clear(self):\n        \"\"\"\n        Removes all mobjects present in self.mobjects\n        and self.foreground_mobjects from the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with all of its mobjects in\n            self.mobjects and self.foreground_mobjects\n            removed.\n        \"\"\"\n        self.mobjects = []\n        self.foreground_mobjects = []\n        return self",
  "def get_mobjects(self):\n        \"\"\"\n        Returns all the mobjects in self.mobjects\n\n        Returns\n        ------\n        list\n            The list of self.mobjects .\n        \"\"\"\n        return list(self.mobjects)",
  "def get_mobject_copies(self):\n        \"\"\"\n        Returns a copy of all mobjects present in\n        self.mobjects .\n\n        Returns\n        ------\n        list\n            A list of the copies of all the mobjects\n            in self.mobjects\n        \"\"\"\n        return [m.copy() for m in self.mobjects]",
  "def get_moving_mobjects(self, *animations):\n        \"\"\"\n        Gets all moving mobjects in the passed animation(s).\n\n        Parameters\n        ----------\n        *animations : Animation\n            The animations to check for moving mobjects.\n\n        Returns\n        ------\n        list\n            The list of mobjects that could be moving in\n            the Animation(s)\n        \"\"\"\n        # Go through mobjects from start to end, and\n        # as soon as there's one that needs updating of\n        # some kind per frame, return the list from that\n        # point forward.\n        animation_mobjects = [anim.mobject for anim in animations]\n        mobjects = self.get_mobject_family_members()\n        for i, mob in enumerate(mobjects):\n            update_possibilities = [\n                mob in animation_mobjects,\n                len(mob.get_family_updaters()) > 0,\n                mob in self.foreground_mobjects,\n            ]\n            if any(update_possibilities):\n                return mobjects[i:]\n        return []",
  "def get_time_progression(\n        self, run_time, n_iterations=None, override_skip_animations=False\n    ):\n        \"\"\"\n        You will hardly use this when making your own animations.\n        This method is for Manim's internal use.\n\n        Returns a CommandLine ProgressBar whose fill_time\n        is dependent on the run_time of an animation,\n        the iterations to perform in that animation\n        and a bool saying whether or not to consider\n        the skipped animations.\n\n        Parameters\n        ----------\n        run_time: float\n            The run_time of the animation.\n\n        n_iterations: int, optional\n            The number of iterations in the animation.\n\n        override_skip_animations: bool, optional\n            Whether or not to show skipped animations in the progress bar.\n\n        Returns\n        ------\n        ProgressDisplay\n            The CommandLine Progress Bar.\n        \"\"\"\n        if file_writer_config[\"skip_animations\"] and not override_skip_animations:\n            times = [run_time]\n        else:\n            step = 1 / self.camera.frame_rate\n            times = np.arange(0, run_time, step)\n        time_progression = ProgressDisplay(\n            times,\n            total=n_iterations,\n            leave=file_writer_config[\"leave_progress_bars\"],\n            ascii=True if platform.system() == \"Windows\" else None,\n        )\n        return time_progression",
  "def get_run_time(self, animations):\n        \"\"\"\n        Gets the total run time for a list of animations.\n\n        Parameters\n        ----------\n        animations: list of Animation\n            A list of the animations whose total\n            run_time is to be calculated.\n\n        Returns\n        ------\n        float\n            The total run_time of all of the animations in the list.\n        \"\"\"\n\n        return np.max([animation.run_time for animation in animations])",
  "def get_animation_time_progression(self, animations):\n        \"\"\"\n        You will hardly use this when making your own animations.\n        This method is for Manim's internal use.\n\n        Uses get_time_progression to obtaina\n        CommandLine ProgressBar whose fill_time is\n        dependent on the qualities of the passed Animation,\n\n        Parameters\n        ----------\n        animations : list of Animation\n            The list of animations to get\n            the time progression for.\n\n        Returns\n        ------\n        ProgressDisplay\n            The CommandLine Progress Bar.\n        \"\"\"\n        run_time = self.get_run_time(animations)\n        time_progression = self.get_time_progression(run_time)\n        time_progression.set_description(\n            \"\".join(\n                [\n                    \"Animation {}: \".format(self.num_plays),\n                    str(animations[0]),\n                    (\", etc.\" if len(animations) > 1 else \"\"),\n                ]\n            )\n        )\n        return time_progression",
  "def compile_play_args_to_animation_list(self, *args, **kwargs):\n        \"\"\"\n        Each arg can either be an animation, or a mobject method\n        followed by that methods arguments (and potentially follow\n        by a dict of kwargs for that method).\n        This animation list is built by going through the args list,\n        and each animation is simply added, but when a mobject method\n        s hit, a MoveToTarget animation is built using the args that\n        follow up until either another animation is hit, another method\n        is hit, or the args list runs out.\n\n        Parameters\n        ----------\n        *args : Animation or method of a mobject, which is followed by that method's arguments\n\n        **kwargs : any named arguments like run_time or lag_ratio.\n\n        Returns\n        -------\n        list : list of animations with the parameters applied to them.\n        \"\"\"\n        animations = []\n        state = {\n            \"curr_method\": None,\n            \"last_method\": None,\n            \"method_args\": [],\n        }\n\n        def compile_method(state):\n            if state[\"curr_method\"] is None:\n                return\n            mobject = state[\"curr_method\"].__self__\n            if state[\"last_method\"] and state[\"last_method\"].__self__ is mobject:\n                animations.pop()\n                # method should already have target then.\n            else:\n                mobject.generate_target()\n            #\n            if len(state[\"method_args\"]) > 0 and isinstance(\n                state[\"method_args\"][-1], dict\n            ):\n                method_kwargs = state[\"method_args\"].pop()\n            else:\n                method_kwargs = {}\n            state[\"curr_method\"].__func__(\n                mobject.target, *state[\"method_args\"], **method_kwargs\n            )\n            animations.append(MoveToTarget(mobject))\n            state[\"last_method\"] = state[\"curr_method\"]\n            state[\"curr_method\"] = None\n            state[\"method_args\"] = []\n\n        for arg in args:\n            if isinstance(arg, Animation):\n                compile_method(state)\n                animations.append(arg)\n            elif inspect.ismethod(arg):\n                compile_method(state)\n                state[\"curr_method\"] = arg\n            elif state[\"curr_method\"] is not None:\n                state[\"method_args\"].append(arg)\n            elif isinstance(arg, Mobject):\n                raise Exception(\n                    \"\"\"\n                    I think you may have invoked a method\n                    you meant to pass in as a Scene.play argument\n                \"\"\"\n                )\n            else:\n                raise Exception(\"Invalid play arguments\")\n        compile_method(state)\n\n        for animation in animations:\n            # This is where kwargs to play like run_time and rate_func\n            # get applied to all animations\n            animation.update_config(**kwargs)\n\n        return animations",
  "def update_skipping_status(self):\n        \"\"\"\n        This method is used internally to check if the current\n        animation needs to be skipped or not. It also checks if\n        the number of animations that were played correspond to\n        the number of animations that need to be played, and\n        raises an EndSceneEarlyException if they don't correspond.\n        \"\"\"\n\n        if file_writer_config[\"from_animation_number\"]:\n            if self.num_plays == file_writer_config[\"from_animation_number\"]:\n                file_writer_config[\"skip_animations\"] = False\n        if file_writer_config[\"upto_animation_number\"]:\n            if self.num_plays >= file_writer_config[\"upto_animation_number\"]:\n                file_writer_config[\"skip_animations\"] = True\n                raise EndSceneEarlyException()",
  "def handle_play_like_call(func):\n        \"\"\"\n        This method is used internally to wrap the\n        passed function, into a function that\n        actually writes to the video stream.\n        Simultaneously, it also adds to the number\n        of animations played.\n\n        Parameters\n        ----------\n        func : function\n            The play() like function that has to be\n            written to the video file stream.\n\n        Returns\n        -------\n        function\n            The play() like function that can now write\n            to the video file stream.\n        \"\"\"\n\n        def wrapper(self, *args, **kwargs):\n            self.update_skipping_status()\n            allow_write = not file_writer_config[\"skip_animations\"]\n            self.file_writer.begin_animation(allow_write)\n            func(self, *args, **kwargs)\n            self.file_writer.end_animation(allow_write)\n            self.num_plays += 1\n\n        return wrapper",
  "def begin_animations(self, animations):\n        \"\"\"\n        This method begins the list of animations that is passed,\n        and adds any mobjects involved (if not already present)\n        to the scene again.\n\n        Parameters\n        ----------\n        animations : list\n            List of involved animations.\n\n        \"\"\"\n        curr_mobjects = self.get_mobject_family_members()\n        for animation in animations:\n            # Begin animation\n            animation.begin()\n            # Anything animated that's not already in the\n            # scene gets added to the scene\n            mob = animation.mobject\n            if mob not in curr_mobjects:\n                self.add(mob)\n                curr_mobjects += mob.get_family()",
  "def progress_through_animations(self, animations):\n        \"\"\"\n        This method progresses through each animation\n        in the list passed and and updates the frames as required.\n\n        Parameters\n        ----------\n        animations : list\n            List of involved animations.\n        \"\"\"\n        # Paint all non-moving objects onto the screen, so they don't\n        # have to be rendered every frame\n        moving_mobjects = self.get_moving_mobjects(*animations)\n        self.update_frame(excluded_mobjects=moving_mobjects)\n        static_image = self.get_frame()\n        last_t = 0\n        for t in self.get_animation_time_progression(animations):\n            dt = t - last_t\n            last_t = t\n            for animation in animations:\n                animation.update_mobjects(dt)\n                alpha = t / animation.run_time\n                animation.interpolate(alpha)\n            self.update_mobjects(dt)\n            self.update_frame(moving_mobjects, static_image)\n            self.add_frames(self.get_frame())",
  "def finish_animations(self, animations):\n        \"\"\"\n        This function cleans up after the end\n        of each animation in the passed list.\n\n        Parameters\n        ----------\n        animations : list\n            list of animations to finish.\n        \"\"\"\n        for animation in animations:\n            animation.finish()\n            animation.clean_up_from_scene(self)\n        self.mobjects_from_last_animation = [anim.mobject for anim in animations]\n        if file_writer_config[\"skip_animations\"]:\n            # TODO, run this call in for each animation?\n            self.update_mobjects(self.get_run_time(animations))\n        else:\n            self.update_mobjects(0)",
  "def play(self, *args, **kwargs):\n        \"\"\"\n        This method is used to prep the animations for rendering,\n        apply the arguments and parameters required to them,\n        render them, and write them to the video file.\n\n        Parameters\n        ----------\n        *args : Animation or mobject with mobject method and params\n        **kwargs : named parameters affecting what was passed in *args e.g run_time, lag_ratio etc.\n        \"\"\"\n        if len(args) == 0:\n            warnings.warn(\"Called Scene.play with no animations\")\n            return\n        animations = self.compile_play_args_to_animation_list(*args, **kwargs)\n        self.begin_animations(animations)\n        self.progress_through_animations(animations)\n        self.finish_animations(animations)",
  "def idle_stream(self):\n        \"\"\"\n        This method is used internally to\n        idle the video file_writer until an\n        animation etc needs to be written\n        to the video file.\n        \"\"\"\n        self.file_writer.idle_stream()",
  "def clean_up_animations(self, *animations):\n        \"\"\"\n        This method cleans up and removes from the\n        scene all the animations that were passed\n\n        Parameters\n        ----------\n        *animations : Animation\n            Animation to clean up.\n\n        Returns\n        -------\n        Scene\n            The scene with the animations\n            cleaned up.\n\n        \"\"\"\n        for animation in animations:\n            animation.clean_up_from_scene(self)\n        return self",
  "def get_mobjects_from_last_animation(self):\n        \"\"\"\n        This method returns the mobjects from the previous\n        played animation, if any exist, and returns an empty\n        list if not.\n\n        Returns\n        --------\n        list\n            The list of mobjects from the previous animation.\n\n        \"\"\"\n        if hasattr(self, \"mobjects_from_last_animation\"):\n            return self.mobjects_from_last_animation\n        return []",
  "def get_wait_time_progression(self, duration, stop_condition):\n        \"\"\"\n        This method is used internally to obtain the CommandLine\n        Progressbar for when self.wait() is called in a scene.\n\n        Parameters\n        ----------\n        duration: int or float\n            duration of wait time\n\n        stop_condition : function\n            The function which determines whether to continue waiting.\n\n        Returns\n        -------\n        ProgressBar\n            The CommandLine ProgressBar of the wait time\n\n        \"\"\"\n        if stop_condition is not None:\n            time_progression = self.get_time_progression(\n                duration,\n                n_iterations=-1,  # So it doesn't show % progress\n                override_skip_animations=True,\n            )\n            time_progression.set_description(\n                \"Waiting for {}\".format(stop_condition.__name__)\n            )\n        else:\n            time_progression = self.get_time_progression(duration)\n            time_progression.set_description(\"Waiting {}\".format(self.num_plays))\n        return time_progression",
  "def wait(self, duration=DEFAULT_WAIT_TIME, stop_condition=None):\n        \"\"\"\n        This method is used to wait, and do nothing to the scene, for some\n        duration.\n        Updaters stop updating, nothing happens.\n\n        Parameters\n        ----------\n        duration : float or int, optional\n            The duration of wait time.\n        stop_condition :\n            A function that determines whether to stop waiting or not.\n\n        Returns\n        -------\n        Scene\n            The scene, after waiting.\n        \"\"\"\n        self.update_mobjects(dt=0)  # Any problems with this?\n        if self.should_update_mobjects():\n            time_progression = self.get_wait_time_progression(duration, stop_condition)\n            # TODO, be smart about setting a static image\n            # the same way Scene.play does\n            last_t = 0\n            for t in time_progression:\n                dt = t - last_t\n                last_t = t\n                self.update_mobjects(dt)\n                self.update_frame()\n                self.add_frames(self.get_frame())\n                if stop_condition is not None and stop_condition():\n                    time_progression.close()\n                    break\n        elif file_writer_config[\"skip_animations\"]:\n            # Do nothing\n            return self\n        else:\n            self.update_frame()\n            dt = 1 / self.camera.frame_rate\n            n_frames = int(duration / dt)\n            frame = self.get_frame()\n            self.add_frames(*[frame] * n_frames)\n        return self",
  "def wait_until(self, stop_condition, max_time=60):\n        \"\"\"\n        Like a wrapper for wait().\n        You pass a function that determines whether to continue waiting,\n        and a max wait time if that is never fulfilled.\n\n        Parameters\n        ----------\n        stop_condition : function\n            The function whose boolean return value determines whether to continue waiting\n\n        max_time : int or float, optional\n            The maximum wait time in seconds, if the stop_condition is never fulfilled.\n        \"\"\"\n        self.wait(max_time, stop_condition=stop_condition)",
  "def force_skipping(self):\n        \"\"\"\n        This forces the skipping of animations,\n        by setting original_skipping_status to\n        whatever skip_animations was, and setting\n        skip_animations to True.\n\n        Returns\n        -------\n        Scene\n            The Scene, with skipping turned on.\n        \"\"\"\n        self.original_skipping_status = self.SKIP_ANIMATIONS\n        self.SKIP_ANIMATIONS = True\n        return self",
  "def revert_to_original_skipping_status(self):\n        \"\"\"\n        Forces the scene to go back to its original skipping status,\n        by setting skip_animations to whatever it reads\n        from original_skipping_status.\n\n        Returns\n        -------\n        Scene\n            The Scene, with the original skipping status.\n        \"\"\"\n        if hasattr(self, \"original_skipping_status\"):\n            self.SKIP_ANIMATIONS = self.original_skipping_status\n        return self",
  "def add_frames(self, *frames):\n        \"\"\"\n        Adds a frame to the video_file_stream\n\n        Parameters\n        ----------\n        *frames : numpy.ndarray\n            The frames to add, as pixel arrays.\n        \"\"\"\n        dt = 1 / self.camera.frame_rate\n        self.increment_time(len(frames) * dt)\n        if file_writer_config[\"skip_animations\"]:\n            return\n        for frame in frames:\n            self.file_writer.write_frame(frame)",
  "def add_sound(self, sound_file, time_offset=0, gain=None, **kwargs):\n        \"\"\"\n        This method is used to add a sound to the animation.\n\n        Parameters\n        ----------\n        sound_file : str\n            The path to the sound file.\n\n        time_offset : int,float, optional\n            The offset in the sound file after which\n            the sound can be played.\n\n        gain :\n\n        \"\"\"\n        if self.SKIP_ANIMATIONS:\n            return\n        time = self.get_time() + time_offset\n        self.file_writer.add_sound(sound_file, time, gain, **kwargs)",
  "def show_frame(self):\n        \"\"\"\n        Opens the current frame in the Default Image Viewer\n        of your system.\n        \"\"\"\n        self.update_frame(ignore_skipping=True)\n        self.get_image().show()",
  "def is_top_level(mobject):\n            num_families = sum([(mobject in family) for family in families])\n            return num_families == 1",
  "def add_safe_mobjects_from_list(list_to_examine, set_to_remove):\n            for mob in list_to_examine:\n                if mob in set_to_remove:\n                    continue\n                intersect = set_to_remove.intersection(mob.get_family())\n                if intersect:\n                    add_safe_mobjects_from_list(mob.submobjects, intersect)\n                else:\n                    new_mobjects.append(mob)",
  "def compile_method(state):\n            if state[\"curr_method\"] is None:\n                return\n            mobject = state[\"curr_method\"].__self__\n            if state[\"last_method\"] and state[\"last_method\"].__self__ is mobject:\n                animations.pop()\n                # method should already have target then.\n            else:\n                mobject.generate_target()\n            #\n            if len(state[\"method_args\"]) > 0 and isinstance(\n                state[\"method_args\"][-1], dict\n            ):\n                method_kwargs = state[\"method_args\"].pop()\n            else:\n                method_kwargs = {}\n            state[\"curr_method\"].__func__(\n                mobject.target, *state[\"method_args\"], **method_kwargs\n            )\n            animations.append(MoveToTarget(mobject))\n            state[\"last_method\"] = state[\"curr_method\"]\n            state[\"curr_method\"] = None\n            state[\"method_args\"] = []",
  "def wrapper(self, *args, **kwargs):\n            self.update_skipping_status()\n            allow_write = not file_writer_config[\"skip_animations\"]\n            self.file_writer.begin_animation(allow_write)\n            func(self, *args, **kwargs)\n            self.file_writer.end_animation(allow_write)\n            self.num_plays += 1",
  "class ReconfigurableScene(Scene):\n    \"\"\"\n    Note, this seems to no longer work as intented.\n    \"\"\"\n\n    CONFIG = {\n        \"allow_recursion\": True,\n    }\n\n    def setup(self):\n        self.states = []\n        self.num_recursions = 0\n\n    def transition_to_alt_config(\n        self,\n        return_to_original_configuration=True,\n        transformation_kwargs=None,\n        **new_config,\n    ):\n        if transformation_kwargs is None:\n            transformation_kwargs = {}\n        original_state = self.get_state()\n        state_copy = original_state.copy()\n        self.states.append(state_copy)\n        if not self.allow_recursion:\n            return\n        alt_scene = self.__class__(\n            skip_animations=True, allow_recursion=False, **new_config\n        )\n        alt_state = alt_scene.states[len(self.states) - 1]\n\n        if return_to_original_configuration:\n            self.clear()\n            self.transition_between_states(\n                state_copy, alt_state, **transformation_kwargs\n            )\n            self.transition_between_states(\n                state_copy, original_state, **transformation_kwargs\n            )\n            self.clear()\n            self.add(*original_state)\n        else:\n            self.transition_between_states(\n                original_state, alt_state, **transformation_kwargs\n            )\n            self.__dict__.update(new_config)\n\n    def get_state(self):\n        # Want to return a mobject that maintains the most\n        # structure.  The way to do that is to extract only\n        # those that aren't inside another.\n        return Mobject(*self.get_top_level_mobjects())\n\n    def transition_between_states(self, start_state, target_state, **kwargs):\n        self.play(Transform(start_state, target_state, **kwargs))\n        self.wait()",
  "def setup(self):\n        self.states = []\n        self.num_recursions = 0",
  "def transition_to_alt_config(\n        self,\n        return_to_original_configuration=True,\n        transformation_kwargs=None,\n        **new_config,\n    ):\n        if transformation_kwargs is None:\n            transformation_kwargs = {}\n        original_state = self.get_state()\n        state_copy = original_state.copy()\n        self.states.append(state_copy)\n        if not self.allow_recursion:\n            return\n        alt_scene = self.__class__(\n            skip_animations=True, allow_recursion=False, **new_config\n        )\n        alt_state = alt_scene.states[len(self.states) - 1]\n\n        if return_to_original_configuration:\n            self.clear()\n            self.transition_between_states(\n                state_copy, alt_state, **transformation_kwargs\n            )\n            self.transition_between_states(\n                state_copy, original_state, **transformation_kwargs\n            )\n            self.clear()\n            self.add(*original_state)\n        else:\n            self.transition_between_states(\n                original_state, alt_state, **transformation_kwargs\n            )\n            self.__dict__.update(new_config)",
  "def get_state(self):\n        # Want to return a mobject that maintains the most\n        # structure.  The way to do that is to extract only\n        # those that aren't inside another.\n        return Mobject(*self.get_top_level_mobjects())",
  "def transition_between_states(self, start_state, target_state, **kwargs):\n        self.play(Transform(start_state, target_state, **kwargs))\n        self.wait()",
  "class MappingCamera(Camera):\n    \"\"\"Camera object that allows mapping\n    between objects.\n    \"\"\"\n\n    CONFIG = {\n        \"mapping_func\": lambda p: p,\n        \"min_num_curves\": 50,\n        \"allow_object_intrusion\": False,\n    }\n\n    def points_to_pixel_coords(self, points):\n        return Camera.points_to_pixel_coords(\n            self, np.apply_along_axis(self.mapping_func, 1, points)\n        )\n\n    def capture_mobjects(self, mobjects, **kwargs):\n        mobjects = self.get_mobjects_to_display(mobjects, **kwargs)\n        if self.allow_object_intrusion:\n            mobject_copies = mobjects\n        else:\n            mobject_copies = [mobject.copy() for mobject in mobjects]\n        for mobject in mobject_copies:\n            if (\n                isinstance(mobject, VMobject)\n                and 0 < mobject.get_num_curves() < self.min_num_curves\n            ):\n                mobject.insert_n_curves(self.min_num_curves)\n        Camera.capture_mobjects(\n            self, mobject_copies, include_submobjects=False, excluded_mobjects=None,\n        )",
  "class OldMultiCamera(Camera):\n    def __init__(self, *cameras_with_start_positions, **kwargs):\n        self.shifted_cameras = [\n            DictAsObject(\n                {\n                    \"camera\": camera_with_start_positions[0],\n                    \"start_x\": camera_with_start_positions[1][1],\n                    \"start_y\": camera_with_start_positions[1][0],\n                    \"end_x\": camera_with_start_positions[1][1]\n                    + camera_with_start_positions[0].get_pixel_width(),\n                    \"end_y\": camera_with_start_positions[1][0]\n                    + camera_with_start_positions[0].get_pixel_height(),\n                }\n            )\n            for camera_with_start_positions in cameras_with_start_positions\n        ]\n        Camera.__init__(self, **kwargs)\n\n    def capture_mobjects(self, mobjects, **kwargs):\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.capture_mobjects(mobjects, **kwargs)\n\n            self.pixel_array[\n                shifted_camera.start_y : shifted_camera.end_y,\n                shifted_camera.start_x : shifted_camera.end_x,\n            ] = shifted_camera.camera.pixel_array\n\n    def set_background(self, pixel_array, **kwargs):\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.set_background(\n                pixel_array[\n                    shifted_camera.start_y : shifted_camera.end_y,\n                    shifted_camera.start_x : shifted_camera.end_x,\n                ],\n                **kwargs,\n            )\n\n    def set_pixel_array(self, pixel_array, **kwargs):\n        Camera.set_pixel_array(self, pixel_array, **kwargs)\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.set_pixel_array(\n                pixel_array[\n                    shifted_camera.start_y : shifted_camera.end_y,\n                    shifted_camera.start_x : shifted_camera.end_x,\n                ],\n                **kwargs,\n            )\n\n    def init_background(self):\n        Camera.init_background(self)\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.init_background()",
  "class SplitScreenCamera(OldMultiCamera):\n    def __init__(self, left_camera, right_camera, **kwargs):\n        digest_config(self, kwargs)\n        self.left_camera = left_camera\n        self.right_camera = right_camera\n\n        half_width = self.get_pixel_width() / 2\n        for camera in [self.left_camera, self.right_camera]:\n            # TODO: Round up on one if width is odd\n            camera.reset_pixel_shape(camera.get_pixel_height(), half_width)\n\n        OldMultiCamera.__init__(\n            self, (left_camera, (0, 0)), (right_camera, (0, half_width)),\n        )",
  "def points_to_pixel_coords(self, points):\n        return Camera.points_to_pixel_coords(\n            self, np.apply_along_axis(self.mapping_func, 1, points)\n        )",
  "def capture_mobjects(self, mobjects, **kwargs):\n        mobjects = self.get_mobjects_to_display(mobjects, **kwargs)\n        if self.allow_object_intrusion:\n            mobject_copies = mobjects\n        else:\n            mobject_copies = [mobject.copy() for mobject in mobjects]\n        for mobject in mobject_copies:\n            if (\n                isinstance(mobject, VMobject)\n                and 0 < mobject.get_num_curves() < self.min_num_curves\n            ):\n                mobject.insert_n_curves(self.min_num_curves)\n        Camera.capture_mobjects(\n            self, mobject_copies, include_submobjects=False, excluded_mobjects=None,\n        )",
  "def __init__(self, *cameras_with_start_positions, **kwargs):\n        self.shifted_cameras = [\n            DictAsObject(\n                {\n                    \"camera\": camera_with_start_positions[0],\n                    \"start_x\": camera_with_start_positions[1][1],\n                    \"start_y\": camera_with_start_positions[1][0],\n                    \"end_x\": camera_with_start_positions[1][1]\n                    + camera_with_start_positions[0].get_pixel_width(),\n                    \"end_y\": camera_with_start_positions[1][0]\n                    + camera_with_start_positions[0].get_pixel_height(),\n                }\n            )\n            for camera_with_start_positions in cameras_with_start_positions\n        ]\n        Camera.__init__(self, **kwargs)",
  "def capture_mobjects(self, mobjects, **kwargs):\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.capture_mobjects(mobjects, **kwargs)\n\n            self.pixel_array[\n                shifted_camera.start_y : shifted_camera.end_y,\n                shifted_camera.start_x : shifted_camera.end_x,\n            ] = shifted_camera.camera.pixel_array",
  "def set_background(self, pixel_array, **kwargs):\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.set_background(\n                pixel_array[\n                    shifted_camera.start_y : shifted_camera.end_y,\n                    shifted_camera.start_x : shifted_camera.end_x,\n                ],\n                **kwargs,\n            )",
  "def set_pixel_array(self, pixel_array, **kwargs):\n        Camera.set_pixel_array(self, pixel_array, **kwargs)\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.set_pixel_array(\n                pixel_array[\n                    shifted_camera.start_y : shifted_camera.end_y,\n                    shifted_camera.start_x : shifted_camera.end_x,\n                ],\n                **kwargs,\n            )",
  "def init_background(self):\n        Camera.init_background(self)\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.init_background()",
  "def __init__(self, left_camera, right_camera, **kwargs):\n        digest_config(self, kwargs)\n        self.left_camera = left_camera\n        self.right_camera = right_camera\n\n        half_width = self.get_pixel_width() / 2\n        for camera in [self.left_camera, self.right_camera]:\n            # TODO: Round up on one if width is odd\n            camera.reset_pixel_shape(camera.get_pixel_height(), half_width)\n\n        OldMultiCamera.__init__(\n            self, (left_camera, (0, 0)), (right_camera, (0, half_width)),\n        )",
  "class CameraFrame(VGroup):\n    CONFIG = {\n        \"width\": config[\"frame_width\"],\n        \"height\": config[\"frame_height\"],\n        \"center\": ORIGIN,\n    }\n\n    def __init__(self, **kwargs):\n        pass",
  "class MovingCamera(Camera):\n    \"\"\"\n    Stays in line with the height, width and position of it's 'frame', which is a Rectangle\n    \"\"\"\n\n    CONFIG = {\n        \"fixed_dimension\": 0,  # width\n        \"default_frame_stroke_color\": WHITE,\n        \"default_frame_stroke_width\": 0,\n    }\n\n    def __init__(self, frame=None, **kwargs):\n        \"\"\"\n        frame is a Mobject, (should almost certainly be a rectangle)\n        determining which region of space the camera displys\n        \"\"\"\n        digest_config(self, kwargs)\n        if frame is None:\n            frame = ScreenRectangle(height=config[\"frame_height\"])\n            frame.set_stroke(\n                self.default_frame_stroke_color, self.default_frame_stroke_width,\n            )\n        self.frame = frame\n        Camera.__init__(self, **kwargs)\n\n    # TODO, make these work for a rotated frame\n    def get_frame_height(self):\n        \"\"\"Returns the height of the frame.\n\n        Returns\n        -------\n        float\n            The height of the frame.\n        \"\"\"\n        return self.frame.get_height()\n\n    def get_frame_width(self):\n        \"\"\"Returns the width of the frame\n\n        Returns\n        -------\n        float\n            The width of the frame.\n        \"\"\"\n        return self.frame.get_width()\n\n    def get_frame_center(self):\n        \"\"\"Returns the centerpoint of the frame in cartesian coordinates.\n\n        Returns\n        -------\n        np.array\n            The cartesian coordinates of the center of the frame.\n        \"\"\"\n        return self.frame.get_center()\n\n    def set_frame_height(self, frame_height):\n        \"\"\"Sets the height of the frame in MUnits.\n\n        Parameters\n        ----------\n        frame_height : int, float\n            The new frame_height.\n        \"\"\"\n        self.frame.stretch_to_fit_height(frame_height)\n\n    def set_frame_width(self, frame_width):\n        \"\"\"Sets the width of the frame in MUnits.\n\n        Parameters\n        ----------\n        frame_width : int, float\n            The new frame_width.\n        \"\"\"\n        self.frame.stretch_to_fit_width(frame_width)\n\n    def set_frame_center(self, frame_center):\n        \"\"\"Sets the centerpoint of the frame.\n\n        Parameters\n        ----------\n        frame_center : np.array, list, tuple, Mobject\n            The point to which the frame must be moved.\n            If is of type mobject, the frame will be moved to\n            the center of that mobject.\n        \"\"\"\n        self.frame.move_to(frame_center)\n\n    def capture_mobjects(self, mobjects, **kwargs):\n        # self.reset_frame_center()\n        # self.realign_frame_shape()\n        Camera.capture_mobjects(self, mobjects, **kwargs)\n\n    # Since the frame can be moving around, the cairo\n    # context used for updating should be regenerated\n    # at each frame.  So no caching.\n    def get_cached_cairo_context(self, pixel_array):\n        \"\"\"\n        Since the frame can be moving around, the cairo\n        context used for updating should be regenerated\n        at each frame.  So no caching.\n        \"\"\"\n        return None\n\n    def cache_cairo_context(self, pixel_array, ctx):\n        \"\"\"\n        Since the frame can be moving around, the cairo\n        context used for updating should be regenerated\n        at each frame.  So no caching.\n        \"\"\"\n        pass\n\n    # def reset_frame_center(self):\n    #     self.frame_center = self.frame.get_center()\n\n    # def realign_frame_shape(self):\n    #     height, width = self.frame_shape\n    #     if self.fixed_dimension == 0:\n    #         self.frame_shape = (height, self.frame.get_width())\n    #     else:\n    #         self.frame_shape = (self.frame.get_height(), width)\n    #     self.resize_frame_shape(fixed_dimension=self.fixed_dimension)\n\n    def get_mobjects_indicating_movement(self):\n        \"\"\"\n        Returns all mobjets whose movement implies that the camera\n        should think of all other mobjects on the screen as moving\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self.frame]",
  "def __init__(self, **kwargs):\n        pass",
  "def __init__(self, frame=None, **kwargs):\n        \"\"\"\n        frame is a Mobject, (should almost certainly be a rectangle)\n        determining which region of space the camera displys\n        \"\"\"\n        digest_config(self, kwargs)\n        if frame is None:\n            frame = ScreenRectangle(height=config[\"frame_height\"])\n            frame.set_stroke(\n                self.default_frame_stroke_color, self.default_frame_stroke_width,\n            )\n        self.frame = frame\n        Camera.__init__(self, **kwargs)",
  "def get_frame_height(self):\n        \"\"\"Returns the height of the frame.\n\n        Returns\n        -------\n        float\n            The height of the frame.\n        \"\"\"\n        return self.frame.get_height()",
  "def get_frame_width(self):\n        \"\"\"Returns the width of the frame\n\n        Returns\n        -------\n        float\n            The width of the frame.\n        \"\"\"\n        return self.frame.get_width()",
  "def get_frame_center(self):\n        \"\"\"Returns the centerpoint of the frame in cartesian coordinates.\n\n        Returns\n        -------\n        np.array\n            The cartesian coordinates of the center of the frame.\n        \"\"\"\n        return self.frame.get_center()",
  "def set_frame_height(self, frame_height):\n        \"\"\"Sets the height of the frame in MUnits.\n\n        Parameters\n        ----------\n        frame_height : int, float\n            The new frame_height.\n        \"\"\"\n        self.frame.stretch_to_fit_height(frame_height)",
  "def set_frame_width(self, frame_width):\n        \"\"\"Sets the width of the frame in MUnits.\n\n        Parameters\n        ----------\n        frame_width : int, float\n            The new frame_width.\n        \"\"\"\n        self.frame.stretch_to_fit_width(frame_width)",
  "def set_frame_center(self, frame_center):\n        \"\"\"Sets the centerpoint of the frame.\n\n        Parameters\n        ----------\n        frame_center : np.array, list, tuple, Mobject\n            The point to which the frame must be moved.\n            If is of type mobject, the frame will be moved to\n            the center of that mobject.\n        \"\"\"\n        self.frame.move_to(frame_center)",
  "def capture_mobjects(self, mobjects, **kwargs):\n        # self.reset_frame_center()\n        # self.realign_frame_shape()\n        Camera.capture_mobjects(self, mobjects, **kwargs)",
  "def get_cached_cairo_context(self, pixel_array):\n        \"\"\"\n        Since the frame can be moving around, the cairo\n        context used for updating should be regenerated\n        at each frame.  So no caching.\n        \"\"\"\n        return None",
  "def cache_cairo_context(self, pixel_array, ctx):\n        \"\"\"\n        Since the frame can be moving around, the cairo\n        context used for updating should be regenerated\n        at each frame.  So no caching.\n        \"\"\"\n        pass",
  "def get_mobjects_indicating_movement(self):\n        \"\"\"\n        Returns all mobjets whose movement implies that the camera\n        should think of all other mobjects on the screen as moving\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self.frame]",
  "class ThreeDCamera(Camera):\n    CONFIG = {\n        \"shading_factor\": 0.2,\n        \"distance\": 20.0,\n        \"default_distance\": 5.0,\n        \"phi\": 0,  # Angle off z axis\n        \"theta\": -90 * DEGREES,  # Rotation about z axis\n        \"gamma\": 0,  # Rotation about normal vector to camera\n        \"light_source_start_point\": 9 * DOWN + 7 * LEFT + 10 * OUT,\n        \"frame_center\": ORIGIN,\n        \"should_apply_shading\": True,\n        \"exponential_projection\": False,\n        \"max_allowable_norm\": 3 * config[\"frame_width\"],\n    }\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialises the ThreeDCamera\n\n        Parameters\n        ----------\n        *args\n            Any argument of Camera\n        *kwargs\n            Any keyword argument of Camera.\n        \"\"\"\n        Camera.__init__(self, *args, **kwargs)\n        self.phi_tracker = ValueTracker(self.phi)\n        self.theta_tracker = ValueTracker(self.theta)\n        self.distance_tracker = ValueTracker(self.distance)\n        self.gamma_tracker = ValueTracker(self.gamma)\n        self.light_source = Point(self.light_source_start_point)\n        self.frame_center = Point(self.frame_center)\n        self.fixed_orientation_mobjects = dict()\n        self.fixed_in_frame_mobjects = set()\n        self.reset_rotation_matrix()\n\n    def capture_mobjects(self, mobjects, **kwargs):\n        self.reset_rotation_matrix()\n        Camera.capture_mobjects(self, mobjects, **kwargs)\n\n    def get_value_trackers(self):\n        \"\"\"Returns list of ValueTrackers of phi, theta, distance and gamma\n\n        Returns\n        -------\n        list\n            list of ValueTracker objects\n        \"\"\"\n        return [\n            self.phi_tracker,\n            self.theta_tracker,\n            self.distance_tracker,\n            self.gamma_tracker,\n        ]\n\n    def modified_rgbas(\n        self, vmobject, rgbas\n    ):  # TODO: Write DocStrings for this method.\n        if not self.should_apply_shading:\n            return rgbas\n        if vmobject.shade_in_3d and (vmobject.get_num_points() > 0):\n            light_source_point = self.light_source.points[0]\n            if len(rgbas) < 2:\n                shaded_rgbas = rgbas.repeat(2, axis=0)\n            else:\n                shaded_rgbas = np.array(rgbas[:2])\n            shaded_rgbas[0, :3] = get_shaded_rgb(\n                shaded_rgbas[0, :3],\n                get_3d_vmob_start_corner(vmobject),\n                get_3d_vmob_start_corner_unit_normal(vmobject),\n                light_source_point,\n            )\n            shaded_rgbas[1, :3] = get_shaded_rgb(\n                shaded_rgbas[1, :3],\n                get_3d_vmob_end_corner(vmobject),\n                get_3d_vmob_end_corner_unit_normal(vmobject),\n                light_source_point,\n            )\n            return shaded_rgbas\n        return rgbas\n\n    def get_stroke_rgbas(\n        self, vmobject, background=False\n    ):  # NOTE : DocStrings From parent\n        return self.modified_rgbas(vmobject, vmobject.get_stroke_rgbas(background))\n\n    def get_fill_rgbas(self, vmobject):  # NOTE : DocStrings From parent\n        return self.modified_rgbas(vmobject, vmobject.get_fill_rgbas())\n\n    def get_mobjects_to_display(self, *args, **kwargs):  # NOTE : DocStrings From parent\n        mobjects = Camera.get_mobjects_to_display(self, *args, **kwargs)\n        rot_matrix = self.get_rotation_matrix()\n\n        def z_key(mob):\n            if not (hasattr(mob, \"shade_in_3d\") and mob.shade_in_3d):\n                return np.inf\n            # Assign a number to a three dimensional mobjects\n            # based on how close it is to the camera\n            return np.dot(mob.get_z_index_reference_point(), rot_matrix.T)[2]\n\n        return sorted(mobjects, key=z_key)\n\n    def get_phi(self):\n        \"\"\"Returns the Polar angle (the angle off Z_AXIS) phi.\n\n        Returns\n        -------\n        float\n            The Polar angle in radians.\n        \"\"\"\n        return self.phi_tracker.get_value()\n\n    def get_theta(self):\n        \"\"\"Returns the Azimuthal i.e the angle that spins the camera around the Z_AXIS.\n\n        Returns\n        -------\n        float\n            The Azimuthal angle in radians.\n        \"\"\"\n        return self.theta_tracker.get_value()\n\n    def get_distance(self):\n        \"\"\"Returns radial distance from ORIGIN.\n\n        Returns\n        -------\n        float\n            The radial distance from ORIGIN in MUnits.\n        \"\"\"\n        return self.distance_tracker.get_value()\n\n    def get_gamma(self):\n        \"\"\"Returns the rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        Returns\n        -------\n        float\n            The angle of rotation of the camera about the vector\n            from the ORIGIN to the Camera in radians\n        \"\"\"\n        return self.gamma_tracker.get_value()\n\n    def get_frame_center(self):\n        \"\"\"Returns the center of the camera frame in cartesian coordinates.\n\n        Returns\n        -------\n        np.array\n            The cartesian coordinates of the center of the camera frame.\n        \"\"\"\n        return self.frame_center.points[0]\n\n    def set_phi(self, value):\n        \"\"\"Sets the polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        Parameters\n        ----------\n        value : int, float\n            The new value of the polar angle in radians.\n        \"\"\"\n        self.phi_tracker.set_value(value)\n\n    def set_theta(self, value):\n        \"\"\"Sets the azimuthal angle i.e the angle that spins the camera around Z_AXIS in radians.\n\n        Parameters\n        ----------\n        value : int, float\n            The new value of the azimuthal angle in radians.\n        \"\"\"\n        self.theta_tracker.set_value(value)\n\n    def set_distance(self, value):\n        \"\"\"Sets the radial distance between the camera and ORIGIN.\n\n        Parameters\n        ----------\n        value : int, float\n            The new radial distance.\n        \"\"\"\n        self.distance_tracker.set_value(value)\n\n    def set_gamma(self, value):\n        \"\"\"Sets the angle of rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        Parameters\n        ----------\n        value : int, float\n            The new angle of rotation of the camera.\n        \"\"\"\n        self.gamma_tracker.set_value(value)\n\n    def set_frame_center(self, point):\n        \"\"\"Sets the camera frame center to the passed cartesian coordinate.\n\n        Parameters\n        ----------\n        point : list, tuple, np.array\n            The cartesian coordinates of the new frame center.\n        \"\"\"\n        self.frame_center.move_to(point)\n\n    def reset_rotation_matrix(self):\n        \"\"\"Sets the value of self.rotation_matrix to\n        the matrix corresponding to the current position of the camera\n        \"\"\"\n        self.rotation_matrix = self.generate_rotation_matrix()\n\n    def get_rotation_matrix(self):\n        \"\"\"Returns the matrix corresponding to the current position of the camera.\n\n        Returns\n        -------\n        np.array\n            The matrix corresponding to the current position of the camera.\n        \"\"\"\n        return self.rotation_matrix\n\n    def generate_rotation_matrix(self):\n        \"\"\"Generates a rotation matrix based off the current position of the camera.\n\n        Returns\n        -------\n        np.array\n            The matrix corresponding to the current position of the camera.\n        \"\"\"\n        phi = self.get_phi()\n        theta = self.get_theta()\n        gamma = self.get_gamma()\n        matrices = [\n            rotation_about_z(-theta - 90 * DEGREES),\n            rotation_matrix(-phi, RIGHT),\n            rotation_about_z(gamma),\n        ]\n        result = np.identity(3)\n        for matrix in matrices:\n            result = np.dot(matrix, result)\n        return result\n\n    def project_points(self, points):\n        \"\"\"Applies the current rotation_matrix as a projection\n        matrix to the passed array of points.\n\n        Parameters\n        ----------\n        points : np.array, list\n            The list of points to project.\n\n        Returns\n        -------\n        np.array\n            The points after projecting.\n        \"\"\"\n        frame_center = self.get_frame_center()\n        distance = self.get_distance()\n        rot_matrix = self.get_rotation_matrix()\n\n        points = points - frame_center\n        points = np.dot(points, rot_matrix.T)\n        zs = points[:, 2]\n        for i in 0, 1:\n            if self.exponential_projection:\n                # Proper projedtion would involve multiplying\n                # x and y by d / (d-z).  But for points with high\n                # z value that causes weird artifacts, and applying\n                # the exponential helps smooth it out.\n                factor = np.exp(zs / distance)\n                lt0 = zs < 0\n                factor[lt0] = distance / (distance - zs[lt0])\n            else:\n                factor = distance / (distance - zs)\n                factor[(distance - zs) < 0] = 10 ** 6\n                # clip_in_place(factor, 0, 10**6)\n            points[:, i] *= factor\n        points = points + frame_center\n        return points\n\n    def project_point(self, point):\n        \"\"\"Applies the current rotation_matrix as a projection\n        matrix to the passed point.\n\n        Parameters\n        ----------\n        point : list, np.array\n            The point to project.\n\n        Returns\n        -------\n        np.array\n            The point after projection.\n        \"\"\"\n        return self.project_points(point.reshape((1, 3)))[0, :]\n\n    def transform_points_pre_display(\n        self, mobject, points\n    ):  # TODO: Write Docstrings for this Method.\n        points = super().transform_points_pre_display(mobject, points)\n        fixed_orientation = mobject in self.fixed_orientation_mobjects\n        fixed_in_frame = mobject in self.fixed_in_frame_mobjects\n\n        if fixed_in_frame:\n            return points\n        if fixed_orientation:\n            center_func = self.fixed_orientation_mobjects[mobject]\n            center = center_func()\n            new_center = self.project_point(center)\n            return points + (new_center - center)\n        else:\n            return self.project_points(points)\n\n    def add_fixed_orientation_mobjects(\n        self, *mobjects, use_static_center_func=False, center_func=None\n    ):\n        \"\"\"This method allows the mobject to have a fixed orientation,\n        even when the camera moves around.\n        E.G If it was passed through this method, facing the camera, it\n        will continue to face the camera even as the camera moves.\n        Highly useful when adding labels to graphs and the like.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobject whose orientation must be fixed.\n        use_static_center_func : bool, optional\n            Whether or not to use the function that takes the mobject's\n            center as centerpoint, by default False\n        center_func : func, optional\n            The function which returns the centerpoint\n            with respect to which the mobjec will be oriented, by default None\n        \"\"\"\n        # This prevents the computation of mobject.get_center\n        # every single time a projetion happens\n        def get_static_center_func(mobject):\n            point = mobject.get_center()\n            return lambda: point\n\n        for mobject in mobjects:\n            if center_func:\n                func = center_func\n            elif use_static_center_func:\n                func = get_static_center_func(mobject)\n            else:\n                func = mobject.get_center\n            for submob in mobject.get_family():\n                self.fixed_orientation_mobjects[submob] = func\n\n    def add_fixed_in_frame_mobjects(self, *mobjects):\n        \"\"\"This method allows the mobject to have a fixed position,\n        even when the camera moves around.\n        E.G If it was passed through this method, at the top of the frame, it\n        will continue to be displayed at the top of the frame.\n\n        Highly useful when displaying Titles or formulae or the like.\n\n        Parameters\n        ----------\n        **mobjects : Mobject\n            The mobject to fix in frame.\n        \"\"\"\n        for mobject in self.extract_mobject_family_members(mobjects):\n            self.fixed_in_frame_mobjects.add(mobject)\n\n    def remove_fixed_orientation_mobjects(self, *mobjects):\n        \"\"\"If a mobject was fixed in its orientation by passing it through\n        `self.add_fixed_orientation_mobjects`, then this undoes that fixing.\n        The Mobject will no longer have a fixed orientation.\n\n        Parameters:\n        -----------\n        *mobjects : Mobject\n            The mobjects whose orientation need not be fixed any longer.\n        \"\"\"\n        for mobject in self.extract_mobject_family_members(mobjects):\n            if mobject in self.fixed_orientation_mobjects:\n                self.fixed_orientation_mobjects.remove(mobject)\n\n    def remove_fixed_in_frame_mobjects(self, *mobjects):\n        \"\"\"If a mobject was fixed in frame by passing it through\n        `self.add_fixed_in_frame_mobjects`, then this undoes that fixing.\n        The Mobject will no longer be fixed in frame.\n\n        Parameters:\n        -----------\n        *mobjects : Mobject\n            The mobjects which need not be fixed in frame any longer.\n        \"\"\"\n        for mobject in self.extract_mobject_family_members(mobjects):\n            if mobject in self.fixed_in_frame_mobjects:\n                self.fixed_in_frame_mobjects.remove(mobject)",
  "def __init__(self, *args, **kwargs):\n        \"\"\"Initialises the ThreeDCamera\n\n        Parameters\n        ----------\n        *args\n            Any argument of Camera\n        *kwargs\n            Any keyword argument of Camera.\n        \"\"\"\n        Camera.__init__(self, *args, **kwargs)\n        self.phi_tracker = ValueTracker(self.phi)\n        self.theta_tracker = ValueTracker(self.theta)\n        self.distance_tracker = ValueTracker(self.distance)\n        self.gamma_tracker = ValueTracker(self.gamma)\n        self.light_source = Point(self.light_source_start_point)\n        self.frame_center = Point(self.frame_center)\n        self.fixed_orientation_mobjects = dict()\n        self.fixed_in_frame_mobjects = set()\n        self.reset_rotation_matrix()",
  "def capture_mobjects(self, mobjects, **kwargs):\n        self.reset_rotation_matrix()\n        Camera.capture_mobjects(self, mobjects, **kwargs)",
  "def get_value_trackers(self):\n        \"\"\"Returns list of ValueTrackers of phi, theta, distance and gamma\n\n        Returns\n        -------\n        list\n            list of ValueTracker objects\n        \"\"\"\n        return [\n            self.phi_tracker,\n            self.theta_tracker,\n            self.distance_tracker,\n            self.gamma_tracker,\n        ]",
  "def modified_rgbas(\n        self, vmobject, rgbas\n    ):  # TODO: Write DocStrings for this method.\n        if not self.should_apply_shading:\n            return rgbas\n        if vmobject.shade_in_3d and (vmobject.get_num_points() > 0):\n            light_source_point = self.light_source.points[0]\n            if len(rgbas) < 2:\n                shaded_rgbas = rgbas.repeat(2, axis=0)\n            else:\n                shaded_rgbas = np.array(rgbas[:2])\n            shaded_rgbas[0, :3] = get_shaded_rgb(\n                shaded_rgbas[0, :3],\n                get_3d_vmob_start_corner(vmobject),\n                get_3d_vmob_start_corner_unit_normal(vmobject),\n                light_source_point,\n            )\n            shaded_rgbas[1, :3] = get_shaded_rgb(\n                shaded_rgbas[1, :3],\n                get_3d_vmob_end_corner(vmobject),\n                get_3d_vmob_end_corner_unit_normal(vmobject),\n                light_source_point,\n            )\n            return shaded_rgbas\n        return rgbas",
  "def get_stroke_rgbas(\n        self, vmobject, background=False\n    ):  # NOTE : DocStrings From parent\n        return self.modified_rgbas(vmobject, vmobject.get_stroke_rgbas(background))",
  "def get_fill_rgbas(self, vmobject):  # NOTE : DocStrings From parent\n        return self.modified_rgbas(vmobject, vmobject.get_fill_rgbas())",
  "def get_mobjects_to_display(self, *args, **kwargs):  # NOTE : DocStrings From parent\n        mobjects = Camera.get_mobjects_to_display(self, *args, **kwargs)\n        rot_matrix = self.get_rotation_matrix()\n\n        def z_key(mob):\n            if not (hasattr(mob, \"shade_in_3d\") and mob.shade_in_3d):\n                return np.inf\n            # Assign a number to a three dimensional mobjects\n            # based on how close it is to the camera\n            return np.dot(mob.get_z_index_reference_point(), rot_matrix.T)[2]\n\n        return sorted(mobjects, key=z_key)",
  "def get_phi(self):\n        \"\"\"Returns the Polar angle (the angle off Z_AXIS) phi.\n\n        Returns\n        -------\n        float\n            The Polar angle in radians.\n        \"\"\"\n        return self.phi_tracker.get_value()",
  "def get_theta(self):\n        \"\"\"Returns the Azimuthal i.e the angle that spins the camera around the Z_AXIS.\n\n        Returns\n        -------\n        float\n            The Azimuthal angle in radians.\n        \"\"\"\n        return self.theta_tracker.get_value()",
  "def get_distance(self):\n        \"\"\"Returns radial distance from ORIGIN.\n\n        Returns\n        -------\n        float\n            The radial distance from ORIGIN in MUnits.\n        \"\"\"\n        return self.distance_tracker.get_value()",
  "def get_gamma(self):\n        \"\"\"Returns the rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        Returns\n        -------\n        float\n            The angle of rotation of the camera about the vector\n            from the ORIGIN to the Camera in radians\n        \"\"\"\n        return self.gamma_tracker.get_value()",
  "def get_frame_center(self):\n        \"\"\"Returns the center of the camera frame in cartesian coordinates.\n\n        Returns\n        -------\n        np.array\n            The cartesian coordinates of the center of the camera frame.\n        \"\"\"\n        return self.frame_center.points[0]",
  "def set_phi(self, value):\n        \"\"\"Sets the polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        Parameters\n        ----------\n        value : int, float\n            The new value of the polar angle in radians.\n        \"\"\"\n        self.phi_tracker.set_value(value)",
  "def set_theta(self, value):\n        \"\"\"Sets the azimuthal angle i.e the angle that spins the camera around Z_AXIS in radians.\n\n        Parameters\n        ----------\n        value : int, float\n            The new value of the azimuthal angle in radians.\n        \"\"\"\n        self.theta_tracker.set_value(value)",
  "def set_distance(self, value):\n        \"\"\"Sets the radial distance between the camera and ORIGIN.\n\n        Parameters\n        ----------\n        value : int, float\n            The new radial distance.\n        \"\"\"\n        self.distance_tracker.set_value(value)",
  "def set_gamma(self, value):\n        \"\"\"Sets the angle of rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        Parameters\n        ----------\n        value : int, float\n            The new angle of rotation of the camera.\n        \"\"\"\n        self.gamma_tracker.set_value(value)",
  "def set_frame_center(self, point):\n        \"\"\"Sets the camera frame center to the passed cartesian coordinate.\n\n        Parameters\n        ----------\n        point : list, tuple, np.array\n            The cartesian coordinates of the new frame center.\n        \"\"\"\n        self.frame_center.move_to(point)",
  "def reset_rotation_matrix(self):\n        \"\"\"Sets the value of self.rotation_matrix to\n        the matrix corresponding to the current position of the camera\n        \"\"\"\n        self.rotation_matrix = self.generate_rotation_matrix()",
  "def get_rotation_matrix(self):\n        \"\"\"Returns the matrix corresponding to the current position of the camera.\n\n        Returns\n        -------\n        np.array\n            The matrix corresponding to the current position of the camera.\n        \"\"\"\n        return self.rotation_matrix",
  "def generate_rotation_matrix(self):\n        \"\"\"Generates a rotation matrix based off the current position of the camera.\n\n        Returns\n        -------\n        np.array\n            The matrix corresponding to the current position of the camera.\n        \"\"\"\n        phi = self.get_phi()\n        theta = self.get_theta()\n        gamma = self.get_gamma()\n        matrices = [\n            rotation_about_z(-theta - 90 * DEGREES),\n            rotation_matrix(-phi, RIGHT),\n            rotation_about_z(gamma),\n        ]\n        result = np.identity(3)\n        for matrix in matrices:\n            result = np.dot(matrix, result)\n        return result",
  "def project_points(self, points):\n        \"\"\"Applies the current rotation_matrix as a projection\n        matrix to the passed array of points.\n\n        Parameters\n        ----------\n        points : np.array, list\n            The list of points to project.\n\n        Returns\n        -------\n        np.array\n            The points after projecting.\n        \"\"\"\n        frame_center = self.get_frame_center()\n        distance = self.get_distance()\n        rot_matrix = self.get_rotation_matrix()\n\n        points = points - frame_center\n        points = np.dot(points, rot_matrix.T)\n        zs = points[:, 2]\n        for i in 0, 1:\n            if self.exponential_projection:\n                # Proper projedtion would involve multiplying\n                # x and y by d / (d-z).  But for points with high\n                # z value that causes weird artifacts, and applying\n                # the exponential helps smooth it out.\n                factor = np.exp(zs / distance)\n                lt0 = zs < 0\n                factor[lt0] = distance / (distance - zs[lt0])\n            else:\n                factor = distance / (distance - zs)\n                factor[(distance - zs) < 0] = 10 ** 6\n                # clip_in_place(factor, 0, 10**6)\n            points[:, i] *= factor\n        points = points + frame_center\n        return points",
  "def project_point(self, point):\n        \"\"\"Applies the current rotation_matrix as a projection\n        matrix to the passed point.\n\n        Parameters\n        ----------\n        point : list, np.array\n            The point to project.\n\n        Returns\n        -------\n        np.array\n            The point after projection.\n        \"\"\"\n        return self.project_points(point.reshape((1, 3)))[0, :]",
  "def transform_points_pre_display(\n        self, mobject, points\n    ):  # TODO: Write Docstrings for this Method.\n        points = super().transform_points_pre_display(mobject, points)\n        fixed_orientation = mobject in self.fixed_orientation_mobjects\n        fixed_in_frame = mobject in self.fixed_in_frame_mobjects\n\n        if fixed_in_frame:\n            return points\n        if fixed_orientation:\n            center_func = self.fixed_orientation_mobjects[mobject]\n            center = center_func()\n            new_center = self.project_point(center)\n            return points + (new_center - center)\n        else:\n            return self.project_points(points)",
  "def add_fixed_orientation_mobjects(\n        self, *mobjects, use_static_center_func=False, center_func=None\n    ):\n        \"\"\"This method allows the mobject to have a fixed orientation,\n        even when the camera moves around.\n        E.G If it was passed through this method, facing the camera, it\n        will continue to face the camera even as the camera moves.\n        Highly useful when adding labels to graphs and the like.\n\n        Parameters\n        ----------\n        *mobjects : Mobject\n            The mobject whose orientation must be fixed.\n        use_static_center_func : bool, optional\n            Whether or not to use the function that takes the mobject's\n            center as centerpoint, by default False\n        center_func : func, optional\n            The function which returns the centerpoint\n            with respect to which the mobjec will be oriented, by default None\n        \"\"\"\n        # This prevents the computation of mobject.get_center\n        # every single time a projetion happens\n        def get_static_center_func(mobject):\n            point = mobject.get_center()\n            return lambda: point\n\n        for mobject in mobjects:\n            if center_func:\n                func = center_func\n            elif use_static_center_func:\n                func = get_static_center_func(mobject)\n            else:\n                func = mobject.get_center\n            for submob in mobject.get_family():\n                self.fixed_orientation_mobjects[submob] = func",
  "def add_fixed_in_frame_mobjects(self, *mobjects):\n        \"\"\"This method allows the mobject to have a fixed position,\n        even when the camera moves around.\n        E.G If it was passed through this method, at the top of the frame, it\n        will continue to be displayed at the top of the frame.\n\n        Highly useful when displaying Titles or formulae or the like.\n\n        Parameters\n        ----------\n        **mobjects : Mobject\n            The mobject to fix in frame.\n        \"\"\"\n        for mobject in self.extract_mobject_family_members(mobjects):\n            self.fixed_in_frame_mobjects.add(mobject)",
  "def remove_fixed_orientation_mobjects(self, *mobjects):\n        \"\"\"If a mobject was fixed in its orientation by passing it through\n        `self.add_fixed_orientation_mobjects`, then this undoes that fixing.\n        The Mobject will no longer have a fixed orientation.\n\n        Parameters:\n        -----------\n        *mobjects : Mobject\n            The mobjects whose orientation need not be fixed any longer.\n        \"\"\"\n        for mobject in self.extract_mobject_family_members(mobjects):\n            if mobject in self.fixed_orientation_mobjects:\n                self.fixed_orientation_mobjects.remove(mobject)",
  "def remove_fixed_in_frame_mobjects(self, *mobjects):\n        \"\"\"If a mobject was fixed in frame by passing it through\n        `self.add_fixed_in_frame_mobjects`, then this undoes that fixing.\n        The Mobject will no longer be fixed in frame.\n\n        Parameters:\n        -----------\n        *mobjects : Mobject\n            The mobjects which need not be fixed in frame any longer.\n        \"\"\"\n        for mobject in self.extract_mobject_family_members(mobjects):\n            if mobject in self.fixed_in_frame_mobjects:\n                self.fixed_in_frame_mobjects.remove(mobject)",
  "def z_key(mob):\n            if not (hasattr(mob, \"shade_in_3d\") and mob.shade_in_3d):\n                return np.inf\n            # Assign a number to a three dimensional mobjects\n            # based on how close it is to the camera\n            return np.dot(mob.get_z_index_reference_point(), rot_matrix.T)[2]",
  "def get_static_center_func(mobject):\n            point = mobject.get_center()\n            return lambda: point",
  "class Camera(object):\n    \"\"\"\n    Base Camera class.\n    This is the object which takes care of what exactly is displayed\n    on screen at any given moment.\n\n    Some important CONFIG values and local variables to note are:\n\n    self.background_image : str, optional\n        The path to an image that should be the background image.\n        If not set, the background is filled with `self.background_color`\n\n    self.pixel_height\n    \"\"\"\n\n    CONFIG = {\n        \"background_image\": None,\n        \"pixel_height\": config[\"pixel_height\"],\n        \"pixel_width\": config[\"pixel_width\"],\n        \"frame_rate\": config[\"frame_rate\"],\n        # Note: frame height and width will be resized to match\n        # the pixel aspect ratio\n        \"frame_height\": config[\"frame_height\"],\n        \"frame_width\": config[\"frame_width\"],\n        \"frame_center\": ORIGIN,\n        \"background_color\": BLACK,\n        \"background_opacity\": 1,\n        # Points in vectorized mobjects with norm greater\n        # than this value will be rescaled.\n        \"max_allowable_norm\": config[\"frame_width\"],\n        \"image_mode\": \"RGBA\",\n        \"n_channels\": 4,\n        \"pixel_array_dtype\": \"uint8\",\n        # z_buff_func is only used if the flag above is set to True.\n        # round z coordinate to nearest hundredth when comparring\n        \"z_buff_func\": lambda m: np.round(m.get_center()[2], 2),\n        \"cairo_line_width_multiple\": 0.01,\n        \"use_z_index\": True,\n    }\n\n    def __init__(self, background=None, **kwargs):\n        \"\"\"Initialises the Camera.\n\n        Parameters\n        ----------\n        background : optional\n            What self.background should be, by default None as will be set later.\n        **kwargs\n            Any local variables to be set.\n        \"\"\"\n        digest_config(self, kwargs, locals())\n        self.rgb_max_val = np.iinfo(self.pixel_array_dtype).max\n        self.pixel_array_to_cairo_context = {}\n        self.init_background()\n        self.resize_frame_shape()\n        self.reset()\n\n    def __deepcopy__(self, memo):\n        # This is to address a strange bug where deepcopying\n        # will result in a segfault, which is somehow related\n        # to the aggdraw library\n        self.canvas = None\n        return copy.copy(self)\n\n    def reset_pixel_shape(self, new_height, new_width):\n        \"\"\"This method resets the height and width\n        of a single pixel to the passed new_heigh and new_width.\n\n        Parameters\n        ----------\n        new_height : int, float\n            The new height of the entire scene in pixels\n        new_width : int, float\n            The new width of the entire scene in pixels\n        \"\"\"\n        self.pixel_width = new_width\n        self.pixel_height = new_height\n        self.init_background()\n        self.resize_frame_shape()\n        self.reset()\n\n    def get_pixel_height(self):\n        \"\"\"Returns the height of the scene in\n        pixel at that moment.\n\n        Returns\n        -------\n        int\n            The height of the scene in pixels.\n        \"\"\"\n        return self.pixel_height\n\n    def get_pixel_width(self):\n        \"\"\"Returns the width of the scene in\n        pixels at that moment.\n\n        Returns\n        -------\n        int\n            The width of the scene in pixels.\n        \"\"\"\n        return self.pixel_width\n\n    def get_frame_height(self):\n        \"\"\"Returns the height of the frame\n        in MUnits. Default is 8.0\n\n        Returns\n        -------\n        float\n            The frame height\n        \"\"\"\n        return self.frame_height\n\n    def get_frame_width(self):\n        \"\"\"Returns the width of the frame\n        in MUnits.\n\n        Returns\n        -------\n        float\n            The frame width\n        \"\"\"\n        return self.frame_width\n\n    def get_frame_center(self):\n        \"\"\"Returns the absolute center of the frame as Cartesian\n        Coordinates with the unit MUnits.\n\n        Returns\n        -------\n        np.array\n            The array of x,y,z coordinates.\n        \"\"\"\n        return self.frame_center\n\n    def set_frame_height(self, frame_height):\n        \"\"\"Sets the frame height to the passed value.\n\n        Parameters\n        ----------\n        frame_height : int, float\n            The frame_height in MUnits.\n        \"\"\"\n        self.frame_height = frame_height\n\n    def set_frame_width(self, frame_width):\n        \"\"\"Sets the frame width to the passed value.\n\n        Parameters\n        ----------\n        frame_width : int, float\n            The frame_width in MUnits.\n        \"\"\"\n        self.frame_width = frame_width\n\n    def set_frame_center(self, frame_center):\n        \"\"\"Sets the center of the frame to the passed\n        cartesian coordinates.\n\n        Parameters\n        ----------\n        frame_center : np.array\n            The center of the frame.\n        \"\"\"\n        self.frame_center = frame_center\n\n    def resize_frame_shape(self, fixed_dimension=0):\n        \"\"\"\n        Changes frame_shape to match the aspect ratio\n        of the pixels, where fixed_dimension determines\n        whether frame_height or frame_width\n        remains fixed while the other changes accordingly.\n\n        Parameters\n        ----------\n        fixed_dimension : int\n            If 0, height is scaled with respect to width\n            else, width is scaled with respect to height.\n        \"\"\"\n        pixel_height = self.get_pixel_height()\n        pixel_width = self.get_pixel_width()\n        frame_height = self.get_frame_height()\n        frame_width = self.get_frame_width()\n        aspect_ratio = fdiv(pixel_width, pixel_height)\n        if fixed_dimension == 0:\n            frame_height = frame_width / aspect_ratio\n        else:\n            frame_width = aspect_ratio * frame_height\n        self.set_frame_height(frame_height)\n        self.set_frame_width(frame_width)\n\n    def init_background(self):\n        \"\"\"Initialize the background.\n        If self.background_image is the path of an image\n        the image is set as background; else, the default\n        background color fills the background.\n        \"\"\"\n        height = self.get_pixel_height()\n        width = self.get_pixel_width()\n        if self.background_image is not None:\n            path = get_full_raster_image_path(self.background_image)\n            image = Image.open(path).convert(self.image_mode)\n            # TODO, how to gracefully handle backgrounds\n            # with different sizes?\n            self.background = np.array(image)[:height, :width]\n            self.background = self.background.astype(self.pixel_array_dtype)\n        else:\n            background_rgba = color_to_int_rgba(\n                self.background_color, self.background_opacity\n            )\n            self.background = np.zeros(\n                (height, width, self.n_channels), dtype=self.pixel_array_dtype\n            )\n            self.background[:, :] = background_rgba\n\n    def get_image(self, pixel_array=None):\n        \"\"\"Returns an image from the passed\n        pixel array, or from the current frame\n        if the passed pixel array is none.\n\n        Parameters\n        ----------\n        pixel_array : np.array, list, tuple, optional\n            The pixel array from which to get an image, by default None\n\n        Returns\n        -------\n        PIL.Image\n            The PIL image of the array.\n        \"\"\"\n        if pixel_array is None:\n            pixel_array = self.pixel_array\n        return Image.fromarray(pixel_array, mode=self.image_mode)\n\n    def get_pixel_array(self):\n        \"\"\"Returns the pixel array\n        of the current frame.\n\n        Returns\n        -------\n        np.array\n            The array of RGB values of each pixel.\n        \"\"\"\n        return self.pixel_array\n\n    def convert_pixel_array(self, pixel_array, convert_from_floats=False):\n        \"\"\"Converts a pixel array from values that have floats in then\n        to proper RGB values.\n\n        Parameters\n        ----------\n        pixel_array : np.array, list, tuple\n            Pixel array to convert.\n        convert_from_floats : bool, optional\n            Whether or not to convert float values to ints, by default False\n\n        Returns\n        -------\n        np.array\n            The new, converted pixel array.\n        \"\"\"\n        retval = np.array(pixel_array)\n        if convert_from_floats:\n            retval = np.apply_along_axis(\n                lambda f: (f * self.rgb_max_val).astype(self.pixel_array_dtype),\n                2,\n                retval,\n            )\n        return retval\n\n    def set_pixel_array(self, pixel_array, convert_from_floats=False):\n        \"\"\"Sets the pixel array of the camera to the passed pixel array.\n\n        Parameters\n        ----------\n        pixel_array : np.array, list, tuple\n            The pixel array to convert and then set as the camera's pixel array.\n        convert_from_floats : bool, optional\n            Whether or not to convert float values to proper RGB values, by default False\n        \"\"\"\n        converted_array = self.convert_pixel_array(pixel_array, convert_from_floats)\n        if not (\n            hasattr(self, \"pixel_array\")\n            and self.pixel_array.shape == converted_array.shape\n        ):\n            self.pixel_array = converted_array\n        else:\n            # Set in place\n            self.pixel_array[:, :, :] = converted_array[:, :, :]\n\n    def set_background(self, pixel_array, convert_from_floats=False):\n        \"\"\"Sets the background to the passed pixel_array after converting\n        to valid RGB values.\n\n        Parameters\n        ----------\n        pixel_array : np.array, list, tuple\n            The pixel array to set the background to.\n        convert_from_floats : bool, optional\n            Whether or not to convert floats values to proper RGB valid ones, by default False\n        \"\"\"\n        self.background = self.convert_pixel_array(pixel_array, convert_from_floats)\n\n    # TODO, this should live in utils, not as a method of Camera\n    def make_background_from_func(self, coords_to_colors_func):\n        \"\"\"\n        Makes a pixel array for the background by using coords_to_colors_func to determine each pixel's color. Each input\n        pixel's color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\n        pixel coordinates), and each output is expected to be an RGBA array of 4 floats.\n\n        Parameters\n        ----------\n        coords_to_colors_func : function\n            The function whose input is an (x,y) pair of coordinats and\n            whose return values must be the colors for that point\n        Returns\n        -------\n        np.array\n            The pixel array which can then be passed to set_background.\n        \"\"\"\n\n        logger.info(\n            \"Starting set_background; for reference, the current time is \",\n            time.strftime(\"%H:%M:%S\"),\n        )\n        coords = self.get_coords_of_all_pixels()\n        new_background = np.apply_along_axis(coords_to_colors_func, 2, coords)\n        logger.info(\n            \"Ending set_background; for reference, the current time is \",\n            time.strftime(\"%H:%M:%S\"),\n        )\n\n        return self.convert_pixel_array(new_background, convert_from_floats=True)\n\n    def set_background_from_func(self, coords_to_colors_func):\n        \"\"\"\n        Sets the background to a pixel array using coords_to_colors_func to determine each pixel's color. Each input\n        pixel's color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\n        pixel coordinates), and each output is expected to be an RGBA array of 4 floats.\n\n        Parameters\n        ----------\n        coords_to_colors_func : function\n            The function whose input is an (x,y) pair of coordinats and\n            whose return values must be the colors for that point\n        \"\"\"\n        self.set_background(self.make_background_from_func(coords_to_colors_func))\n\n    def reset(self):\n        \"\"\"Resets the camera's pixel array\n        to that of the background\n\n        Returns\n        -------\n        Camera\n            The camera object after setting the pixel array.\n        \"\"\" \"\"\n        self.set_pixel_array(self.background)\n        return self\n\n    ####\n\n    # TODO, it's weird that this is part of camera.\n    # Clearly it should live elsewhere.\n    def extract_mobject_family_members(self, mobjects, only_those_with_points=False):\n        \"\"\"Returns a list of the types of mobjects and\n        their family members present.\n\n        Parameters\n        ----------\n        mobjects : Mobject\n            The Mobjects currently in the Scene\n        only_those_with_points : bool, optional\n            Whether or not to only do this for\n            those mobjects that have points. By default False\n\n        Returns\n        -------\n        list\n            list of the mobjects and family members.\n        \"\"\"\n        if only_those_with_points:\n            method = Mobject.family_members_with_points\n        else:\n            method = Mobject.get_family\n        if self.use_z_index:\n            mobjects.sort(key=lambda m: m.z_index)\n        return remove_list_redundancies(list(it.chain(*[method(m) for m in mobjects])))\n\n    def get_mobjects_to_display(\n        self, mobjects, include_submobjects=True, excluded_mobjects=None\n    ):\n        \"\"\"Used to get the list of mobjects to display\n        with the camera.\n\n        Parameters\n        ----------\n        mobjects : Mobject\n            The Mobjects\n        include_submobjects : bool, optional\n            Whether or not to include the submobjects of mobjects, by default True\n        excluded_mobjects : list, optional\n            Any mobjects to exclude, by default None\n\n        Returns\n        -------\n        list\n            list of mobjects\n        \"\"\"\n        if include_submobjects:\n            mobjects = self.extract_mobject_family_members(\n                mobjects, only_those_with_points=True,\n            )\n            if excluded_mobjects:\n                all_excluded = self.extract_mobject_family_members(excluded_mobjects)\n                mobjects = list_difference_update(mobjects, all_excluded)\n        return mobjects\n\n    def is_in_frame(self, mobject):\n        \"\"\"Checks whether the passed mobject is in\n        frame or not.\n\n        Parameters\n        ----------\n        mobject : Mobject\n            The mobject for which the checking needs to be done.\n\n        Returns\n        -------\n        bool\n            True if in frame, False otherwise.\n        \"\"\"\n        fc = self.get_frame_center()\n        fh = self.get_frame_height()\n        fw = self.get_frame_width()\n        return not reduce(\n            op.or_,\n            [\n                mobject.get_right()[0] < fc[0] - fw,\n                mobject.get_bottom()[1] > fc[1] + fh,\n                mobject.get_left()[0] > fc[0] + fw,\n                mobject.get_top()[1] < fc[1] - fh,\n            ],\n        )\n\n    def capture_mobject(\n        self, mobject, **kwargs\n    ):  # TODO Write better docstrings for this method.\n        return self.capture_mobjects([mobject], **kwargs)\n\n    def capture_mobjects(\n        self, mobjects, **kwargs\n    ):  # TODO Write better docstrings for this method.\n        mobjects = self.get_mobjects_to_display(mobjects, **kwargs)\n\n        # Organize this list into batches of the same type, and\n        # apply corresponding function to those batches\n        type_func_pairs = [\n            (VMobject, self.display_multiple_vectorized_mobjects),\n            (PMobject, self.display_multiple_point_cloud_mobjects),\n            (AbstractImageMobject, self.display_multiple_image_mobjects),\n            (Mobject, lambda batch, pa: batch),  # Do nothing\n        ]\n\n        def get_mobject_type(mobject):\n            for mobject_type, func in type_func_pairs:\n                if isinstance(mobject, mobject_type):\n                    return mobject_type\n            raise Exception(\"Trying to display something which is not of type Mobject\")\n\n        batch_type_pairs = batch_by_property(mobjects, get_mobject_type)\n\n        # Display in these batches\n        for batch, batch_type in batch_type_pairs:\n            # check what the type is, and call the appropriate function\n            for mobject_type, func in type_func_pairs:\n                if batch_type == mobject_type:\n                    func(batch, self.pixel_array)\n\n    # Methods associated with svg rendering\n\n    # NOTE: None of the methods below have been mentioned outside of their definitions. Their DocStrings are not as\n    # detailed as possible.\n\n    def get_cached_cairo_context(self, pixel_array):\n        \"\"\"Returns the cached cairo context of the passed\n        pixel array if it exists, and None if it doesn't.\n\n        Parameters\n        ----------\n        pixel_array : np.array\n            The pixel array to check.\n\n        Returns\n        -------\n        Cairo.Context.Context\n            The cached cairo context.\n        \"\"\"\n        return self.pixel_array_to_cairo_context.get(id(pixel_array), None)\n\n    def cache_cairo_context(self, pixel_array, ctx):\n        \"\"\"Caches the passed Pixel array into a Cairo Context\n\n        Parameters\n        ----------\n        pixel_array : np.array\n            The pixel array to cache\n        ctx : Cairo.Context.Context\n            The context to cache it into.\n        \"\"\"\n        self.pixel_array_to_cairo_context[id(pixel_array)] = ctx\n\n    def get_cairo_context(self, pixel_array):\n        \"\"\"Returns the cairo context for a pixel array after\n        caching it to self.pixel_array_to_cairo_context\n        If that array has already been cached, it returns the\n        cached version instead.\n\n        Parameters\n        ----------\n        pixel_array : np.array\n            The Pixel array to get the cairo context of.\n\n        Returns\n        -------\n        cairo.Context\n            The cairo context of the pixel array.\n        \"\"\"\n        cached_ctx = self.get_cached_cairo_context(pixel_array)\n        if cached_ctx:\n            return cached_ctx\n        pw = self.get_pixel_width()\n        ph = self.get_pixel_height()\n        fw = self.get_frame_width()\n        fh = self.get_frame_height()\n        fc = self.get_frame_center()\n        surface = cairo.ImageSurface.create_for_data(\n            pixel_array, cairo.FORMAT_ARGB32, pw, ph\n        )\n        ctx = cairo.Context(surface)\n        ctx.scale(pw, ph)\n        ctx.set_matrix(\n            cairo.Matrix(\n                fdiv(pw, fw),\n                0,\n                0,\n                -fdiv(ph, fh),\n                (pw / 2) - fc[0] * fdiv(pw, fw),\n                (ph / 2) + fc[1] * fdiv(ph, fh),\n            )\n        )\n        self.cache_cairo_context(pixel_array, ctx)\n        return ctx\n\n    def display_multiple_vectorized_mobjects(self, vmobjects, pixel_array):\n        \"\"\"Displays multiple VMobjects in the pixel_array\n\n        Parameters\n        ----------\n        vmobjects : list\n            list of VMobjects to display\n        pixel_array : np.array\n            The pixel array\n        \"\"\"\n        if len(vmobjects) == 0:\n            return\n        batch_file_pairs = batch_by_property(\n            vmobjects, lambda vm: vm.get_background_image_file()\n        )\n        for batch, file_name in batch_file_pairs:\n            if file_name:\n                self.display_multiple_background_colored_vmobject(batch, pixel_array)\n            else:\n                self.display_multiple_non_background_colored_vmobjects(\n                    batch, pixel_array\n                )\n\n    def display_multiple_non_background_colored_vmobjects(self, vmobjects, pixel_array):\n        \"\"\"Displays multiple VMobjects in the cairo context, as long as they don't have\n        background colors.\n\n        Parameters\n        ----------\n        vmobjects : list\n            list of the VMobjects\n        pixel_array : np.ndarray\n            The Pixel array to add the VMobjects to.\n        \"\"\"\n        ctx = self.get_cairo_context(pixel_array)\n        for vmobject in vmobjects:\n            self.display_vectorized(vmobject, ctx)\n\n    def display_vectorized(self, vmobject, ctx):\n        \"\"\"Displays a VMobject in the cairo context\n\n        Parameters\n        ----------\n        vmobject : VMobject\n            The Vectorized Mobject to display\n        ctx : cairo.Context\n            The cairo context to use.\n\n        Returns\n        -------\n        Camera\n            The camera object\n        \"\"\"\n        self.set_cairo_context_path(ctx, vmobject)\n        self.apply_stroke(ctx, vmobject, background=True)\n        self.apply_fill(ctx, vmobject)\n        self.apply_stroke(ctx, vmobject)\n        return self\n\n    def set_cairo_context_path(self, ctx, vmobject):\n        \"\"\"Sets a path for the cairo context with the vmobject passed\n\n        Parameters\n        ----------\n        ctx : cairo.Context\n            The cairo context\n        vmobject : VMobject\n            The VMobject\n\n        Returns\n        -------\n        Camera\n            Camera object after setting cairo_context_path\n        \"\"\"\n        points = self.transform_points_pre_display(vmobject, vmobject.points)\n        # TODO, shouldn't this be handled in transform_points_pre_display?\n        # points = points - self.get_frame_center()\n        if len(points) == 0:\n            return\n\n        ctx.new_path()\n        subpaths = vmobject.gen_subpaths_from_points_2d(points)\n        for subpath in subpaths:\n            quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)\n            ctx.new_sub_path()\n            start = subpath[0]\n            ctx.move_to(*start[:2])\n            for p0, p1, p2, p3 in quads:\n                ctx.curve_to(*p1[:2], *p2[:2], *p3[:2])\n            if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):\n                ctx.close_path()\n        return self\n\n    def set_cairo_context_color(self, ctx, rgbas, vmobject):\n        \"\"\"Sets the color of the cairo context\n\n        Parameters\n        ----------\n        ctx : cairo.Context\n            The cairo context\n        rgbas : np.ndarray\n            The RGBA array with which to color the context.\n        vmobject : VMobject\n            The VMobject with which to set the color.\n\n        Returns\n        -------\n        Camera\n            The camera object\n        \"\"\"\n        if len(rgbas) == 1:\n            # Use reversed rgb because cairo surface is\n            # encodes it in reverse order\n            ctx.set_source_rgba(*rgbas[0][2::-1], rgbas[0][3])\n        else:\n            points = vmobject.get_gradient_start_and_end_points()\n            points = self.transform_points_pre_display(vmobject, points)\n            pat = cairo.LinearGradient(*it.chain(*[point[:2] for point in points]))\n            step = 1.0 / (len(rgbas) - 1)\n            offsets = np.arange(0, 1 + step, step)\n            for rgba, offset in zip(rgbas, offsets):\n                pat.add_color_stop_rgba(offset, *rgba[2::-1], rgba[3])\n            ctx.set_source(pat)\n        return self\n\n    def apply_fill(self, ctx, vmobject):\n        \"\"\"Fills the cairo context\n\n        Parameters\n        ----------\n        ctx : cairo.Context\n            The cairo context\n        vmobject : VMobject\n            The VMobject\n\n        Returns\n        -------\n        Camera\n            The camera object.\n        \"\"\"\n        self.set_cairo_context_color(ctx, self.get_fill_rgbas(vmobject), vmobject)\n        ctx.fill_preserve()\n        return self\n\n    def apply_stroke(self, ctx, vmobject, background=False):\n        \"\"\"Applies a stroke to the VMobject in the cairo context.\n\n        Parameters\n        ----------\n        ctx : cairo.Context\n            The cairo context\n        vmobject : VMobject\n            The VMobject\n        background : bool, optional\n            Whether or not to consider the background when applying this\n            stroke width, by default False\n\n        Returns\n        -------\n        Camera\n            The camera object with the stroke applied.\n        \"\"\"\n        width = vmobject.get_stroke_width(background)\n        if width == 0:\n            return self\n        self.set_cairo_context_color(\n            ctx, self.get_stroke_rgbas(vmobject, background=background), vmobject\n        )\n        ctx.set_line_width(\n            width\n            * self.cairo_line_width_multiple\n            *\n            # This ensures lines have constant width\n            # as you zoom in on them.\n            (self.get_frame_width() / self.frame_width)\n        )\n        ctx.stroke_preserve()\n        return self\n\n    def get_stroke_rgbas(self, vmobject, background=False):\n        \"\"\"Get's the RGBA array for the stroke of the passed\n        VMobject.\n\n        Parameters\n        ----------\n        vmobject : VMobject\n            The VMobject\n        background : bool, optional\n            Whether or not to consider the background when getting the stroke\n            RGBAs, by default False\n\n        Returns\n        -------\n        np.ndarray\n            The RGBA array of the stroke.\n        \"\"\"\n        return vmobject.get_stroke_rgbas(background)\n\n    def get_fill_rgbas(self, vmobject):\n        \"\"\"Returns the RGBA array of the fill of the passed VMobject\n\n        Parameters\n        ----------\n        vmobject : VMobject\n            The VMobject\n\n        Returns\n        -------\n        np.array\n            The RGBA Array of the fill of the VMobject\n        \"\"\"\n        return vmobject.get_fill_rgbas()\n\n    def get_background_colored_vmobject_displayer(self):\n        \"\"\"Returns the background_colored_vmobject_displayer\n        if it exists or makes one and returns it if not.\n\n        Returns\n        -------\n        BackGroundColoredVMobjectDisplayer\n            Object that displays VMobjects that have the same color\n            as the background.\n        \"\"\"\n        # Quite wordy to type out a bunch\n        bcvd = \"background_colored_vmobject_displayer\"\n        if not hasattr(self, bcvd):\n            setattr(self, bcvd, BackgroundColoredVMobjectDisplayer(self))\n        return getattr(self, bcvd)\n\n    def display_multiple_background_colored_vmobject(self, cvmobjects, pixel_array):\n        \"\"\"Displays multiple vmobjects that have the same color as the background.\n\n        Parameters\n        ----------\n        cvmobjects : list\n            List of Colored VMobjects\n        pixel_array : np.array\n            The pixel array.\n\n        Returns\n        -------\n        Camera\n            The camera object.\n        \"\"\"\n        displayer = self.get_background_colored_vmobject_displayer()\n        cvmobject_pixel_array = displayer.display(*cvmobjects)\n        self.overlay_rgba_array(pixel_array, cvmobject_pixel_array)\n        return self\n\n    # Methods for other rendering\n\n    # NOTE: Out of the following methods, only `transform_points_pre_display` and `points_to_pixel_coords` have been mentioned outside of their definitions.\n    # As a result, the other methods do not have as detailed docstrings as would be preferred.\n\n    def display_multiple_point_cloud_mobjects(self, pmobjects, pixel_array):\n        \"\"\"Displays multiple PMobjects by modifying the passed pixel array.\n\n        Parameters\n        ----------\n        pmobjects : list\n            List of PMobjects\n        pixel_array : np.array\n            The pixel array to modify.\n        \"\"\"\n        for pmobject in pmobjects:\n            self.display_point_cloud(\n                pmobject,\n                pmobject.points,\n                pmobject.rgbas,\n                self.adjusted_thickness(pmobject.stroke_width),\n                pixel_array,\n            )\n\n    def display_point_cloud(self, pmobject, points, rgbas, thickness, pixel_array):\n        \"\"\"Displays a PMobject by modifying the Pixel array suitably..\n        TODO: Write a description for the rgbas argument.\n        Parameters\n        ----------\n        pmobject : PMobject\n            Point Cloud Mobject\n        points : list\n            The points to display in the point cloud mobject\n        rgbas : np.array\n\n        thickness : int, float\n            The thickness of each point of the PMobject\n        pixel_array : np.array\n            The pixel array to modify.\n        \"\"\"\n        if len(points) == 0:\n            return\n        pixel_coords = self.points_to_pixel_coords(pmobject, points)\n        pixel_coords = self.thickened_coordinates(pixel_coords, thickness)\n        rgba_len = pixel_array.shape[2]\n\n        rgbas = (self.rgb_max_val * rgbas).astype(self.pixel_array_dtype)\n        target_len = len(pixel_coords)\n        factor = target_len // len(rgbas)\n        rgbas = np.array([rgbas] * factor).reshape((target_len, rgba_len))\n\n        on_screen_indices = self.on_screen_pixels(pixel_coords)\n        pixel_coords = pixel_coords[on_screen_indices]\n        rgbas = rgbas[on_screen_indices]\n\n        ph = self.get_pixel_height()\n        pw = self.get_pixel_width()\n\n        flattener = np.array([1, pw], dtype=\"int\")\n        flattener = flattener.reshape((2, 1))\n        indices = np.dot(pixel_coords, flattener)[:, 0]\n        indices = indices.astype(\"int\")\n\n        new_pa = pixel_array.reshape((ph * pw, rgba_len))\n        new_pa[indices] = rgbas\n        pixel_array[:, :] = new_pa.reshape((ph, pw, rgba_len))\n\n    def display_multiple_image_mobjects(self, image_mobjects, pixel_array):\n        \"\"\"Displays multiple image mobjects by modifiying the passed pixel_array.\n\n        Parameters\n        ----------\n        image_mobjects : list\n            list of ImageMobjects\n        pixel_array : np.array\n            The pixel array to modify.\n        \"\"\"\n        for image_mobject in image_mobjects:\n            self.display_image_mobject(image_mobject, pixel_array)\n\n    def display_image_mobject(self, image_mobject, pixel_array):\n        \"\"\"Displays an ImageMobject by changing the pixel_array suitably.\n\n        Parameters\n        ----------\n        image_mobject : ImageMobject\n            The imageMobject to display\n        pixel_array : np.ndarray\n            The Pixel array to put the imagemobject in.\n        \"\"\"\n        corner_coords = self.points_to_pixel_coords(image_mobject, image_mobject.points)\n        ul_coords, ur_coords, dl_coords = corner_coords\n        right_vect = ur_coords - ul_coords\n        down_vect = dl_coords - ul_coords\n        center_coords = ul_coords + (right_vect + down_vect) / 2\n\n        sub_image = Image.fromarray(image_mobject.get_pixel_array(), mode=\"RGBA\")\n\n        # Reshape\n        pixel_width = max(int(pdist([ul_coords, ur_coords])), 1)\n        pixel_height = max(int(pdist([ul_coords, dl_coords])), 1)\n        sub_image = sub_image.resize(\n            (pixel_width, pixel_height), resample=Image.BICUBIC\n        )\n\n        # Rotate\n        angle = angle_of_vector(right_vect)\n        adjusted_angle = -int(360 * angle / TAU)\n        if adjusted_angle != 0:\n            sub_image = sub_image.rotate(\n                adjusted_angle, resample=Image.BICUBIC, expand=1\n            )\n\n        # TODO, there is no accounting for a shear...\n\n        # Paste into an image as large as the camear's pixel array\n        full_image = Image.fromarray(\n            np.zeros((self.get_pixel_height(), self.get_pixel_width())), mode=\"RGBA\"\n        )\n        new_ul_coords = center_coords - np.array(sub_image.size) / 2\n        new_ul_coords = new_ul_coords.astype(int)\n        full_image.paste(\n            sub_image,\n            box=(\n                new_ul_coords[0],\n                new_ul_coords[1],\n                new_ul_coords[0] + sub_image.size[0],\n                new_ul_coords[1] + sub_image.size[1],\n            ),\n        )\n        # Paint on top of existing pixel array\n        self.overlay_PIL_image(pixel_array, full_image)\n\n    def overlay_rgba_array(self, pixel_array, new_array):\n        \"\"\"Overlays an RGBA array on top of the given Pixel array.\n\n        Parameters\n        ----------\n        pixel_array : np.array\n            The original pixel array to modify.\n        new_array : np.array\n            The new pixel array to overlay.\n        \"\"\"\n        self.overlay_PIL_image(\n            pixel_array, self.get_image(new_array),\n        )\n\n    def overlay_PIL_image(self, pixel_array, image):\n        \"\"\"Overlays a PIL image on the passed pixel array.\n\n        Parameters\n        ----------\n        pixel_array : np.ndarray\n            The Pixel array\n        image : PIL.Image\n            The Image to overlay.\n        \"\"\"\n        pixel_array[:, :] = np.array(\n            Image.alpha_composite(self.get_image(pixel_array), image), dtype=\"uint8\"\n        )\n\n    def adjust_out_of_range_points(self, points):\n        \"\"\"If any of the points in the passed array are out of\n        the viable range, they are adjusted suitably.\n\n        Parameters\n        ----------\n        points : np.array\n            The points to adjust\n\n        Returns\n        -------\n        np.array\n            The adjusted points.\n        \"\"\"\n        if not np.any(points > self.max_allowable_norm):\n            return points\n        norms = np.apply_along_axis(get_norm, 1, points)\n        violator_indices = norms > self.max_allowable_norm\n        violators = points[violator_indices, :]\n        violator_norms = norms[violator_indices]\n        reshaped_norms = np.repeat(\n            violator_norms.reshape((len(violator_norms), 1)), points.shape[1], 1\n        )\n        rescaled = self.max_allowable_norm * violators / reshaped_norms\n        points[violator_indices] = rescaled\n        return points\n\n    def transform_points_pre_display(\n        self, mobject, points\n    ):  # TODO: Write more detailed docstrings for this method.\n        # NOTE: There seems to be an unused argument `mobject`.\n\n        # Subclasses (like ThreeDCamera) may want to\n        # adjust points futher before they're shown\n        if not np.all(np.isfinite(points)):\n            # TODO, print some kind of warning about\n            # mobject having invalid points?\n            points = np.zeros((1, 3))\n        return points\n\n    def points_to_pixel_coords(\n        self, mobject, points\n    ):  # TODO: Write more detailed docstrings for this method.\n        points = self.transform_points_pre_display(mobject, points)\n        shifted_points = points - self.get_frame_center()\n\n        result = np.zeros((len(points), 2))\n        pixel_height = self.get_pixel_height()\n        pixel_width = self.get_pixel_width()\n        frame_height = self.get_frame_height()\n        frame_width = self.get_frame_width()\n        width_mult = pixel_width / frame_width\n        width_add = pixel_width / 2\n        height_mult = pixel_height / frame_height\n        height_add = pixel_height / 2\n        # Flip on y-axis as you go\n        height_mult *= -1\n\n        result[:, 0] = shifted_points[:, 0] * width_mult + width_add\n        result[:, 1] = shifted_points[:, 1] * height_mult + height_add\n        return result.astype(\"int\")\n\n    def on_screen_pixels(self, pixel_coords):\n        \"\"\"Returns array of pixels that are on the screen from a given\n        array of pixel_coordinates\n\n        Parameters\n        ----------\n        pixel_coords : np.array\n            The pixel coords to check.\n\n        Returns\n        -------\n        np.array\n            The pixel coords on screen.\n        \"\"\"\n        return reduce(\n            op.and_,\n            [\n                pixel_coords[:, 0] >= 0,\n                pixel_coords[:, 0] < self.get_pixel_width(),\n                pixel_coords[:, 1] >= 0,\n                pixel_coords[:, 1] < self.get_pixel_height(),\n            ],\n        )\n\n    def adjusted_thickness(self, thickness):\n        \"\"\"\n\n        Parameters\n        ----------\n        thickness : int, float\n\n        Returns\n        -------\n        float\n\n        \"\"\"\n        # TODO: This seems...unsystematic\n        big_sum = op.add(\n            PRODUCTION_QUALITY_CAMERA_CONFIG[\"pixel_height\"],\n            PRODUCTION_QUALITY_CAMERA_CONFIG[\"pixel_width\"],\n        )\n        this_sum = op.add(self.get_pixel_height(), self.get_pixel_width(),)\n        factor = fdiv(big_sum, this_sum)\n        return 1 + (thickness - 1) / factor\n\n    def get_thickening_nudges(self, thickness):\n        \"\"\"\n\n        Parameters\n        ----------\n        thickness : int, float\n\n        Returns\n        -------\n        np.array\n\n        \"\"\"\n        thickness = int(thickness)\n        _range = list(range(-thickness // 2 + 1, thickness // 2 + 1))\n        return np.array(list(it.product(_range, _range)))\n\n    def thickened_coordinates(self, pixel_coords, thickness):\n        \"\"\"Returns thickened coordinates for a passed array of pixel coords and\n        a thickness to thicken by.\n\n        Parameters\n        ----------\n        pixel_coords : np.array\n            Pixel coordinates\n        thickness : int, float\n            Thickness\n\n        Returns\n        -------\n        np.array\n            Array of thickened pixel coords.\n        \"\"\"\n        nudges = self.get_thickening_nudges(thickness)\n        pixel_coords = np.array([pixel_coords + nudge for nudge in nudges])\n        size = pixel_coords.size\n        return pixel_coords.reshape((size // 2, 2))\n\n    # TODO, reimplement using cairo matrix\n    def get_coords_of_all_pixels(self):\n        \"\"\"Returns the cartesian coordinates of each pixel.\n\n        Returns\n        -------\n        np.ndarray\n            The array of cartesian coordinates.\n        \"\"\"\n        # These are in x, y order, to help me keep things straight\n        full_space_dims = np.array([self.get_frame_width(), self.get_frame_height()])\n        full_pixel_dims = np.array([self.get_pixel_width(), self.get_pixel_height()])\n\n        # These are addressed in the same y, x order as in pixel_array, but the values in them\n        # are listed in x, y order\n        uncentered_pixel_coords = np.indices(\n            [self.get_pixel_height(), self.get_pixel_width()]\n        )[::-1].transpose(1, 2, 0)\n        uncentered_space_coords = fdiv(\n            uncentered_pixel_coords * full_space_dims, full_pixel_dims\n        )\n        # Could structure above line's computation slightly differently, but figured (without much\n        # thought) multiplying by frame_shape first, THEN dividing by pixel_shape, is probably\n        # better than the other order, for avoiding underflow quantization in the division (whereas\n        # overflow is unlikely to be a problem)\n\n        centered_space_coords = uncentered_space_coords - fdiv(full_space_dims, 2)\n\n        # Have to also flip the y coordinates to account for pixel array being listed in\n        # top-to-bottom order, opposite of screen coordinate convention\n        centered_space_coords = centered_space_coords * (1, -1)\n\n        return centered_space_coords",
  "class BackgroundColoredVMobjectDisplayer(object):\n    def __init__(self, camera):\n        \"\"\"\n        Parameters\n        ----------\n        camera : Camera\n            Camera object to use.\n        \"\"\"\n        self.camera = camera\n        self.file_name_to_pixel_array_map = {}\n        self.pixel_array = np.array(camera.get_pixel_array())\n        self.reset_pixel_array()\n\n    def reset_pixel_array(self):\n        self.pixel_array[:, :] = 0\n\n    def resize_background_array(\n        self, background_array, new_width, new_height, mode=\"RGBA\"\n    ):\n        \"\"\"Resizes the pixel array represinting the background.\n\n        Parameters\n        ----------\n        background_array : np.array\n            The pixel\n        new_width : int, float\n            The new width of the background\n        new_height : int, float\n            The new height of the background\n        mode : str, optional\n            The PIL image mode, by default \"RGBA\"\n\n        Returns\n        -------\n        np.array\n            The numpy pixel array of the resized background.\n        \"\"\"\n        image = Image.fromarray(background_array)\n        image = image.convert(mode)\n        resized_image = image.resize((new_width, new_height))\n        return np.array(resized_image)\n\n    def resize_background_array_to_match(self, background_array, pixel_array):\n        \"\"\"Resizes the background array to match the passed pixel array.\n\n        Parameters\n        ----------\n        background_array : np.array\n            The prospective pixel array.\n        pixel_array : np.array\n            The pixel array whose width and height should be matched.\n\n        Returns\n        -------\n        np.array\n            The resized background array.\n        \"\"\"\n        height, width = pixel_array.shape[:2]\n        mode = \"RGBA\" if pixel_array.shape[2] == 4 else \"RGB\"\n        return self.resize_background_array(background_array, width, height, mode)\n\n    def get_background_array(self, file_name):\n        \"\"\"Gets the background array that has the passed file_name.\n\n        Parameters\n        ----------\n        file_name : str\n            The file_name of the background image.\n\n        Returns\n        -------\n        np.ndarray\n            The pixel array of the file whose file name is `file_name`\n        \"\"\"\n        if file_name in self.file_name_to_pixel_array_map:\n            return self.file_name_to_pixel_array_map[file_name]\n        full_path = get_full_raster_image_path(file_name)\n        image = Image.open(full_path)\n        back_array = np.array(image)\n\n        pixel_array = self.pixel_array\n        if not np.all(pixel_array.shape == back_array.shape):\n            back_array = self.resize_background_array_to_match(back_array, pixel_array)\n\n        self.file_name_to_pixel_array_map[file_name] = back_array\n        return back_array\n\n    def display(self, *cvmobjects):\n        \"\"\"Displays the colored VMobjects.\n\n        Parameters\n        ----------\n        *cvmobjects : VMobject\n            The VMobjects\n\n        Returns\n        -------\n        np.array\n            The pixel array with the `cvmobjects` displayed.\n        \"\"\"\n        batch_image_file_pairs = batch_by_property(\n            cvmobjects, lambda cv: cv.get_background_image_file()\n        )\n        curr_array = None\n        for batch, image_file in batch_image_file_pairs:\n            background_array = self.get_background_array(image_file)\n            pixel_array = self.pixel_array\n            self.camera.display_multiple_non_background_colored_vmobjects(\n                batch, pixel_array\n            )\n            new_array = np.array(\n                (background_array * pixel_array.astype(\"float\") / 255),\n                dtype=self.camera.pixel_array_dtype,\n            )\n            if curr_array is None:\n                curr_array = new_array\n            else:\n                curr_array = np.maximum(curr_array, new_array)\n            self.reset_pixel_array()\n        return curr_array",
  "def __init__(self, background=None, **kwargs):\n        \"\"\"Initialises the Camera.\n\n        Parameters\n        ----------\n        background : optional\n            What self.background should be, by default None as will be set later.\n        **kwargs\n            Any local variables to be set.\n        \"\"\"\n        digest_config(self, kwargs, locals())\n        self.rgb_max_val = np.iinfo(self.pixel_array_dtype).max\n        self.pixel_array_to_cairo_context = {}\n        self.init_background()\n        self.resize_frame_shape()\n        self.reset()",
  "def __deepcopy__(self, memo):\n        # This is to address a strange bug where deepcopying\n        # will result in a segfault, which is somehow related\n        # to the aggdraw library\n        self.canvas = None\n        return copy.copy(self)",
  "def reset_pixel_shape(self, new_height, new_width):\n        \"\"\"This method resets the height and width\n        of a single pixel to the passed new_heigh and new_width.\n\n        Parameters\n        ----------\n        new_height : int, float\n            The new height of the entire scene in pixels\n        new_width : int, float\n            The new width of the entire scene in pixels\n        \"\"\"\n        self.pixel_width = new_width\n        self.pixel_height = new_height\n        self.init_background()\n        self.resize_frame_shape()\n        self.reset()",
  "def get_pixel_height(self):\n        \"\"\"Returns the height of the scene in\n        pixel at that moment.\n\n        Returns\n        -------\n        int\n            The height of the scene in pixels.\n        \"\"\"\n        return self.pixel_height",
  "def get_pixel_width(self):\n        \"\"\"Returns the width of the scene in\n        pixels at that moment.\n\n        Returns\n        -------\n        int\n            The width of the scene in pixels.\n        \"\"\"\n        return self.pixel_width",
  "def get_frame_height(self):\n        \"\"\"Returns the height of the frame\n        in MUnits. Default is 8.0\n\n        Returns\n        -------\n        float\n            The frame height\n        \"\"\"\n        return self.frame_height",
  "def get_frame_width(self):\n        \"\"\"Returns the width of the frame\n        in MUnits.\n\n        Returns\n        -------\n        float\n            The frame width\n        \"\"\"\n        return self.frame_width",
  "def get_frame_center(self):\n        \"\"\"Returns the absolute center of the frame as Cartesian\n        Coordinates with the unit MUnits.\n\n        Returns\n        -------\n        np.array\n            The array of x,y,z coordinates.\n        \"\"\"\n        return self.frame_center",
  "def set_frame_height(self, frame_height):\n        \"\"\"Sets the frame height to the passed value.\n\n        Parameters\n        ----------\n        frame_height : int, float\n            The frame_height in MUnits.\n        \"\"\"\n        self.frame_height = frame_height",
  "def set_frame_width(self, frame_width):\n        \"\"\"Sets the frame width to the passed value.\n\n        Parameters\n        ----------\n        frame_width : int, float\n            The frame_width in MUnits.\n        \"\"\"\n        self.frame_width = frame_width",
  "def set_frame_center(self, frame_center):\n        \"\"\"Sets the center of the frame to the passed\n        cartesian coordinates.\n\n        Parameters\n        ----------\n        frame_center : np.array\n            The center of the frame.\n        \"\"\"\n        self.frame_center = frame_center",
  "def resize_frame_shape(self, fixed_dimension=0):\n        \"\"\"\n        Changes frame_shape to match the aspect ratio\n        of the pixels, where fixed_dimension determines\n        whether frame_height or frame_width\n        remains fixed while the other changes accordingly.\n\n        Parameters\n        ----------\n        fixed_dimension : int\n            If 0, height is scaled with respect to width\n            else, width is scaled with respect to height.\n        \"\"\"\n        pixel_height = self.get_pixel_height()\n        pixel_width = self.get_pixel_width()\n        frame_height = self.get_frame_height()\n        frame_width = self.get_frame_width()\n        aspect_ratio = fdiv(pixel_width, pixel_height)\n        if fixed_dimension == 0:\n            frame_height = frame_width / aspect_ratio\n        else:\n            frame_width = aspect_ratio * frame_height\n        self.set_frame_height(frame_height)\n        self.set_frame_width(frame_width)",
  "def init_background(self):\n        \"\"\"Initialize the background.\n        If self.background_image is the path of an image\n        the image is set as background; else, the default\n        background color fills the background.\n        \"\"\"\n        height = self.get_pixel_height()\n        width = self.get_pixel_width()\n        if self.background_image is not None:\n            path = get_full_raster_image_path(self.background_image)\n            image = Image.open(path).convert(self.image_mode)\n            # TODO, how to gracefully handle backgrounds\n            # with different sizes?\n            self.background = np.array(image)[:height, :width]\n            self.background = self.background.astype(self.pixel_array_dtype)\n        else:\n            background_rgba = color_to_int_rgba(\n                self.background_color, self.background_opacity\n            )\n            self.background = np.zeros(\n                (height, width, self.n_channels), dtype=self.pixel_array_dtype\n            )\n            self.background[:, :] = background_rgba",
  "def get_image(self, pixel_array=None):\n        \"\"\"Returns an image from the passed\n        pixel array, or from the current frame\n        if the passed pixel array is none.\n\n        Parameters\n        ----------\n        pixel_array : np.array, list, tuple, optional\n            The pixel array from which to get an image, by default None\n\n        Returns\n        -------\n        PIL.Image\n            The PIL image of the array.\n        \"\"\"\n        if pixel_array is None:\n            pixel_array = self.pixel_array\n        return Image.fromarray(pixel_array, mode=self.image_mode)",
  "def get_pixel_array(self):\n        \"\"\"Returns the pixel array\n        of the current frame.\n\n        Returns\n        -------\n        np.array\n            The array of RGB values of each pixel.\n        \"\"\"\n        return self.pixel_array",
  "def convert_pixel_array(self, pixel_array, convert_from_floats=False):\n        \"\"\"Converts a pixel array from values that have floats in then\n        to proper RGB values.\n\n        Parameters\n        ----------\n        pixel_array : np.array, list, tuple\n            Pixel array to convert.\n        convert_from_floats : bool, optional\n            Whether or not to convert float values to ints, by default False\n\n        Returns\n        -------\n        np.array\n            The new, converted pixel array.\n        \"\"\"\n        retval = np.array(pixel_array)\n        if convert_from_floats:\n            retval = np.apply_along_axis(\n                lambda f: (f * self.rgb_max_val).astype(self.pixel_array_dtype),\n                2,\n                retval,\n            )\n        return retval",
  "def set_pixel_array(self, pixel_array, convert_from_floats=False):\n        \"\"\"Sets the pixel array of the camera to the passed pixel array.\n\n        Parameters\n        ----------\n        pixel_array : np.array, list, tuple\n            The pixel array to convert and then set as the camera's pixel array.\n        convert_from_floats : bool, optional\n            Whether or not to convert float values to proper RGB values, by default False\n        \"\"\"\n        converted_array = self.convert_pixel_array(pixel_array, convert_from_floats)\n        if not (\n            hasattr(self, \"pixel_array\")\n            and self.pixel_array.shape == converted_array.shape\n        ):\n            self.pixel_array = converted_array\n        else:\n            # Set in place\n            self.pixel_array[:, :, :] = converted_array[:, :, :]",
  "def set_background(self, pixel_array, convert_from_floats=False):\n        \"\"\"Sets the background to the passed pixel_array after converting\n        to valid RGB values.\n\n        Parameters\n        ----------\n        pixel_array : np.array, list, tuple\n            The pixel array to set the background to.\n        convert_from_floats : bool, optional\n            Whether or not to convert floats values to proper RGB valid ones, by default False\n        \"\"\"\n        self.background = self.convert_pixel_array(pixel_array, convert_from_floats)",
  "def make_background_from_func(self, coords_to_colors_func):\n        \"\"\"\n        Makes a pixel array for the background by using coords_to_colors_func to determine each pixel's color. Each input\n        pixel's color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\n        pixel coordinates), and each output is expected to be an RGBA array of 4 floats.\n\n        Parameters\n        ----------\n        coords_to_colors_func : function\n            The function whose input is an (x,y) pair of coordinats and\n            whose return values must be the colors for that point\n        Returns\n        -------\n        np.array\n            The pixel array which can then be passed to set_background.\n        \"\"\"\n\n        logger.info(\n            \"Starting set_background; for reference, the current time is \",\n            time.strftime(\"%H:%M:%S\"),\n        )\n        coords = self.get_coords_of_all_pixels()\n        new_background = np.apply_along_axis(coords_to_colors_func, 2, coords)\n        logger.info(\n            \"Ending set_background; for reference, the current time is \",\n            time.strftime(\"%H:%M:%S\"),\n        )\n\n        return self.convert_pixel_array(new_background, convert_from_floats=True)",
  "def set_background_from_func(self, coords_to_colors_func):\n        \"\"\"\n        Sets the background to a pixel array using coords_to_colors_func to determine each pixel's color. Each input\n        pixel's color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\n        pixel coordinates), and each output is expected to be an RGBA array of 4 floats.\n\n        Parameters\n        ----------\n        coords_to_colors_func : function\n            The function whose input is an (x,y) pair of coordinats and\n            whose return values must be the colors for that point\n        \"\"\"\n        self.set_background(self.make_background_from_func(coords_to_colors_func))",
  "def reset(self):\n        \"\"\"Resets the camera's pixel array\n        to that of the background\n\n        Returns\n        -------\n        Camera\n            The camera object after setting the pixel array.\n        \"\"\" \"\"\n        self.set_pixel_array(self.background)\n        return self",
  "def extract_mobject_family_members(self, mobjects, only_those_with_points=False):\n        \"\"\"Returns a list of the types of mobjects and\n        their family members present.\n\n        Parameters\n        ----------\n        mobjects : Mobject\n            The Mobjects currently in the Scene\n        only_those_with_points : bool, optional\n            Whether or not to only do this for\n            those mobjects that have points. By default False\n\n        Returns\n        -------\n        list\n            list of the mobjects and family members.\n        \"\"\"\n        if only_those_with_points:\n            method = Mobject.family_members_with_points\n        else:\n            method = Mobject.get_family\n        if self.use_z_index:\n            mobjects.sort(key=lambda m: m.z_index)\n        return remove_list_redundancies(list(it.chain(*[method(m) for m in mobjects])))",
  "def get_mobjects_to_display(\n        self, mobjects, include_submobjects=True, excluded_mobjects=None\n    ):\n        \"\"\"Used to get the list of mobjects to display\n        with the camera.\n\n        Parameters\n        ----------\n        mobjects : Mobject\n            The Mobjects\n        include_submobjects : bool, optional\n            Whether or not to include the submobjects of mobjects, by default True\n        excluded_mobjects : list, optional\n            Any mobjects to exclude, by default None\n\n        Returns\n        -------\n        list\n            list of mobjects\n        \"\"\"\n        if include_submobjects:\n            mobjects = self.extract_mobject_family_members(\n                mobjects, only_those_with_points=True,\n            )\n            if excluded_mobjects:\n                all_excluded = self.extract_mobject_family_members(excluded_mobjects)\n                mobjects = list_difference_update(mobjects, all_excluded)\n        return mobjects",
  "def is_in_frame(self, mobject):\n        \"\"\"Checks whether the passed mobject is in\n        frame or not.\n\n        Parameters\n        ----------\n        mobject : Mobject\n            The mobject for which the checking needs to be done.\n\n        Returns\n        -------\n        bool\n            True if in frame, False otherwise.\n        \"\"\"\n        fc = self.get_frame_center()\n        fh = self.get_frame_height()\n        fw = self.get_frame_width()\n        return not reduce(\n            op.or_,\n            [\n                mobject.get_right()[0] < fc[0] - fw,\n                mobject.get_bottom()[1] > fc[1] + fh,\n                mobject.get_left()[0] > fc[0] + fw,\n                mobject.get_top()[1] < fc[1] - fh,\n            ],\n        )",
  "def capture_mobject(\n        self, mobject, **kwargs\n    ):  # TODO Write better docstrings for this method.\n        return self.capture_mobjects([mobject], **kwargs)",
  "def capture_mobjects(\n        self, mobjects, **kwargs\n    ):  # TODO Write better docstrings for this method.\n        mobjects = self.get_mobjects_to_display(mobjects, **kwargs)\n\n        # Organize this list into batches of the same type, and\n        # apply corresponding function to those batches\n        type_func_pairs = [\n            (VMobject, self.display_multiple_vectorized_mobjects),\n            (PMobject, self.display_multiple_point_cloud_mobjects),\n            (AbstractImageMobject, self.display_multiple_image_mobjects),\n            (Mobject, lambda batch, pa: batch),  # Do nothing\n        ]\n\n        def get_mobject_type(mobject):\n            for mobject_type, func in type_func_pairs:\n                if isinstance(mobject, mobject_type):\n                    return mobject_type\n            raise Exception(\"Trying to display something which is not of type Mobject\")\n\n        batch_type_pairs = batch_by_property(mobjects, get_mobject_type)\n\n        # Display in these batches\n        for batch, batch_type in batch_type_pairs:\n            # check what the type is, and call the appropriate function\n            for mobject_type, func in type_func_pairs:\n                if batch_type == mobject_type:\n                    func(batch, self.pixel_array)",
  "def get_cached_cairo_context(self, pixel_array):\n        \"\"\"Returns the cached cairo context of the passed\n        pixel array if it exists, and None if it doesn't.\n\n        Parameters\n        ----------\n        pixel_array : np.array\n            The pixel array to check.\n\n        Returns\n        -------\n        Cairo.Context.Context\n            The cached cairo context.\n        \"\"\"\n        return self.pixel_array_to_cairo_context.get(id(pixel_array), None)",
  "def cache_cairo_context(self, pixel_array, ctx):\n        \"\"\"Caches the passed Pixel array into a Cairo Context\n\n        Parameters\n        ----------\n        pixel_array : np.array\n            The pixel array to cache\n        ctx : Cairo.Context.Context\n            The context to cache it into.\n        \"\"\"\n        self.pixel_array_to_cairo_context[id(pixel_array)] = ctx",
  "def get_cairo_context(self, pixel_array):\n        \"\"\"Returns the cairo context for a pixel array after\n        caching it to self.pixel_array_to_cairo_context\n        If that array has already been cached, it returns the\n        cached version instead.\n\n        Parameters\n        ----------\n        pixel_array : np.array\n            The Pixel array to get the cairo context of.\n\n        Returns\n        -------\n        cairo.Context\n            The cairo context of the pixel array.\n        \"\"\"\n        cached_ctx = self.get_cached_cairo_context(pixel_array)\n        if cached_ctx:\n            return cached_ctx\n        pw = self.get_pixel_width()\n        ph = self.get_pixel_height()\n        fw = self.get_frame_width()\n        fh = self.get_frame_height()\n        fc = self.get_frame_center()\n        surface = cairo.ImageSurface.create_for_data(\n            pixel_array, cairo.FORMAT_ARGB32, pw, ph\n        )\n        ctx = cairo.Context(surface)\n        ctx.scale(pw, ph)\n        ctx.set_matrix(\n            cairo.Matrix(\n                fdiv(pw, fw),\n                0,\n                0,\n                -fdiv(ph, fh),\n                (pw / 2) - fc[0] * fdiv(pw, fw),\n                (ph / 2) + fc[1] * fdiv(ph, fh),\n            )\n        )\n        self.cache_cairo_context(pixel_array, ctx)\n        return ctx",
  "def display_multiple_vectorized_mobjects(self, vmobjects, pixel_array):\n        \"\"\"Displays multiple VMobjects in the pixel_array\n\n        Parameters\n        ----------\n        vmobjects : list\n            list of VMobjects to display\n        pixel_array : np.array\n            The pixel array\n        \"\"\"\n        if len(vmobjects) == 0:\n            return\n        batch_file_pairs = batch_by_property(\n            vmobjects, lambda vm: vm.get_background_image_file()\n        )\n        for batch, file_name in batch_file_pairs:\n            if file_name:\n                self.display_multiple_background_colored_vmobject(batch, pixel_array)\n            else:\n                self.display_multiple_non_background_colored_vmobjects(\n                    batch, pixel_array\n                )",
  "def display_multiple_non_background_colored_vmobjects(self, vmobjects, pixel_array):\n        \"\"\"Displays multiple VMobjects in the cairo context, as long as they don't have\n        background colors.\n\n        Parameters\n        ----------\n        vmobjects : list\n            list of the VMobjects\n        pixel_array : np.ndarray\n            The Pixel array to add the VMobjects to.\n        \"\"\"\n        ctx = self.get_cairo_context(pixel_array)\n        for vmobject in vmobjects:\n            self.display_vectorized(vmobject, ctx)",
  "def display_vectorized(self, vmobject, ctx):\n        \"\"\"Displays a VMobject in the cairo context\n\n        Parameters\n        ----------\n        vmobject : VMobject\n            The Vectorized Mobject to display\n        ctx : cairo.Context\n            The cairo context to use.\n\n        Returns\n        -------\n        Camera\n            The camera object\n        \"\"\"\n        self.set_cairo_context_path(ctx, vmobject)\n        self.apply_stroke(ctx, vmobject, background=True)\n        self.apply_fill(ctx, vmobject)\n        self.apply_stroke(ctx, vmobject)\n        return self",
  "def set_cairo_context_path(self, ctx, vmobject):\n        \"\"\"Sets a path for the cairo context with the vmobject passed\n\n        Parameters\n        ----------\n        ctx : cairo.Context\n            The cairo context\n        vmobject : VMobject\n            The VMobject\n\n        Returns\n        -------\n        Camera\n            Camera object after setting cairo_context_path\n        \"\"\"\n        points = self.transform_points_pre_display(vmobject, vmobject.points)\n        # TODO, shouldn't this be handled in transform_points_pre_display?\n        # points = points - self.get_frame_center()\n        if len(points) == 0:\n            return\n\n        ctx.new_path()\n        subpaths = vmobject.gen_subpaths_from_points_2d(points)\n        for subpath in subpaths:\n            quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)\n            ctx.new_sub_path()\n            start = subpath[0]\n            ctx.move_to(*start[:2])\n            for p0, p1, p2, p3 in quads:\n                ctx.curve_to(*p1[:2], *p2[:2], *p3[:2])\n            if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):\n                ctx.close_path()\n        return self",
  "def set_cairo_context_color(self, ctx, rgbas, vmobject):\n        \"\"\"Sets the color of the cairo context\n\n        Parameters\n        ----------\n        ctx : cairo.Context\n            The cairo context\n        rgbas : np.ndarray\n            The RGBA array with which to color the context.\n        vmobject : VMobject\n            The VMobject with which to set the color.\n\n        Returns\n        -------\n        Camera\n            The camera object\n        \"\"\"\n        if len(rgbas) == 1:\n            # Use reversed rgb because cairo surface is\n            # encodes it in reverse order\n            ctx.set_source_rgba(*rgbas[0][2::-1], rgbas[0][3])\n        else:\n            points = vmobject.get_gradient_start_and_end_points()\n            points = self.transform_points_pre_display(vmobject, points)\n            pat = cairo.LinearGradient(*it.chain(*[point[:2] for point in points]))\n            step = 1.0 / (len(rgbas) - 1)\n            offsets = np.arange(0, 1 + step, step)\n            for rgba, offset in zip(rgbas, offsets):\n                pat.add_color_stop_rgba(offset, *rgba[2::-1], rgba[3])\n            ctx.set_source(pat)\n        return self",
  "def apply_fill(self, ctx, vmobject):\n        \"\"\"Fills the cairo context\n\n        Parameters\n        ----------\n        ctx : cairo.Context\n            The cairo context\n        vmobject : VMobject\n            The VMobject\n\n        Returns\n        -------\n        Camera\n            The camera object.\n        \"\"\"\n        self.set_cairo_context_color(ctx, self.get_fill_rgbas(vmobject), vmobject)\n        ctx.fill_preserve()\n        return self",
  "def apply_stroke(self, ctx, vmobject, background=False):\n        \"\"\"Applies a stroke to the VMobject in the cairo context.\n\n        Parameters\n        ----------\n        ctx : cairo.Context\n            The cairo context\n        vmobject : VMobject\n            The VMobject\n        background : bool, optional\n            Whether or not to consider the background when applying this\n            stroke width, by default False\n\n        Returns\n        -------\n        Camera\n            The camera object with the stroke applied.\n        \"\"\"\n        width = vmobject.get_stroke_width(background)\n        if width == 0:\n            return self\n        self.set_cairo_context_color(\n            ctx, self.get_stroke_rgbas(vmobject, background=background), vmobject\n        )\n        ctx.set_line_width(\n            width\n            * self.cairo_line_width_multiple\n            *\n            # This ensures lines have constant width\n            # as you zoom in on them.\n            (self.get_frame_width() / self.frame_width)\n        )\n        ctx.stroke_preserve()\n        return self",
  "def get_stroke_rgbas(self, vmobject, background=False):\n        \"\"\"Get's the RGBA array for the stroke of the passed\n        VMobject.\n\n        Parameters\n        ----------\n        vmobject : VMobject\n            The VMobject\n        background : bool, optional\n            Whether or not to consider the background when getting the stroke\n            RGBAs, by default False\n\n        Returns\n        -------\n        np.ndarray\n            The RGBA array of the stroke.\n        \"\"\"\n        return vmobject.get_stroke_rgbas(background)",
  "def get_fill_rgbas(self, vmobject):\n        \"\"\"Returns the RGBA array of the fill of the passed VMobject\n\n        Parameters\n        ----------\n        vmobject : VMobject\n            The VMobject\n\n        Returns\n        -------\n        np.array\n            The RGBA Array of the fill of the VMobject\n        \"\"\"\n        return vmobject.get_fill_rgbas()",
  "def get_background_colored_vmobject_displayer(self):\n        \"\"\"Returns the background_colored_vmobject_displayer\n        if it exists or makes one and returns it if not.\n\n        Returns\n        -------\n        BackGroundColoredVMobjectDisplayer\n            Object that displays VMobjects that have the same color\n            as the background.\n        \"\"\"\n        # Quite wordy to type out a bunch\n        bcvd = \"background_colored_vmobject_displayer\"\n        if not hasattr(self, bcvd):\n            setattr(self, bcvd, BackgroundColoredVMobjectDisplayer(self))\n        return getattr(self, bcvd)",
  "def display_multiple_background_colored_vmobject(self, cvmobjects, pixel_array):\n        \"\"\"Displays multiple vmobjects that have the same color as the background.\n\n        Parameters\n        ----------\n        cvmobjects : list\n            List of Colored VMobjects\n        pixel_array : np.array\n            The pixel array.\n\n        Returns\n        -------\n        Camera\n            The camera object.\n        \"\"\"\n        displayer = self.get_background_colored_vmobject_displayer()\n        cvmobject_pixel_array = displayer.display(*cvmobjects)\n        self.overlay_rgba_array(pixel_array, cvmobject_pixel_array)\n        return self",
  "def display_multiple_point_cloud_mobjects(self, pmobjects, pixel_array):\n        \"\"\"Displays multiple PMobjects by modifying the passed pixel array.\n\n        Parameters\n        ----------\n        pmobjects : list\n            List of PMobjects\n        pixel_array : np.array\n            The pixel array to modify.\n        \"\"\"\n        for pmobject in pmobjects:\n            self.display_point_cloud(\n                pmobject,\n                pmobject.points,\n                pmobject.rgbas,\n                self.adjusted_thickness(pmobject.stroke_width),\n                pixel_array,\n            )",
  "def display_point_cloud(self, pmobject, points, rgbas, thickness, pixel_array):\n        \"\"\"Displays a PMobject by modifying the Pixel array suitably..\n        TODO: Write a description for the rgbas argument.\n        Parameters\n        ----------\n        pmobject : PMobject\n            Point Cloud Mobject\n        points : list\n            The points to display in the point cloud mobject\n        rgbas : np.array\n\n        thickness : int, float\n            The thickness of each point of the PMobject\n        pixel_array : np.array\n            The pixel array to modify.\n        \"\"\"\n        if len(points) == 0:\n            return\n        pixel_coords = self.points_to_pixel_coords(pmobject, points)\n        pixel_coords = self.thickened_coordinates(pixel_coords, thickness)\n        rgba_len = pixel_array.shape[2]\n\n        rgbas = (self.rgb_max_val * rgbas).astype(self.pixel_array_dtype)\n        target_len = len(pixel_coords)\n        factor = target_len // len(rgbas)\n        rgbas = np.array([rgbas] * factor).reshape((target_len, rgba_len))\n\n        on_screen_indices = self.on_screen_pixels(pixel_coords)\n        pixel_coords = pixel_coords[on_screen_indices]\n        rgbas = rgbas[on_screen_indices]\n\n        ph = self.get_pixel_height()\n        pw = self.get_pixel_width()\n\n        flattener = np.array([1, pw], dtype=\"int\")\n        flattener = flattener.reshape((2, 1))\n        indices = np.dot(pixel_coords, flattener)[:, 0]\n        indices = indices.astype(\"int\")\n\n        new_pa = pixel_array.reshape((ph * pw, rgba_len))\n        new_pa[indices] = rgbas\n        pixel_array[:, :] = new_pa.reshape((ph, pw, rgba_len))",
  "def display_multiple_image_mobjects(self, image_mobjects, pixel_array):\n        \"\"\"Displays multiple image mobjects by modifiying the passed pixel_array.\n\n        Parameters\n        ----------\n        image_mobjects : list\n            list of ImageMobjects\n        pixel_array : np.array\n            The pixel array to modify.\n        \"\"\"\n        for image_mobject in image_mobjects:\n            self.display_image_mobject(image_mobject, pixel_array)",
  "def display_image_mobject(self, image_mobject, pixel_array):\n        \"\"\"Displays an ImageMobject by changing the pixel_array suitably.\n\n        Parameters\n        ----------\n        image_mobject : ImageMobject\n            The imageMobject to display\n        pixel_array : np.ndarray\n            The Pixel array to put the imagemobject in.\n        \"\"\"\n        corner_coords = self.points_to_pixel_coords(image_mobject, image_mobject.points)\n        ul_coords, ur_coords, dl_coords = corner_coords\n        right_vect = ur_coords - ul_coords\n        down_vect = dl_coords - ul_coords\n        center_coords = ul_coords + (right_vect + down_vect) / 2\n\n        sub_image = Image.fromarray(image_mobject.get_pixel_array(), mode=\"RGBA\")\n\n        # Reshape\n        pixel_width = max(int(pdist([ul_coords, ur_coords])), 1)\n        pixel_height = max(int(pdist([ul_coords, dl_coords])), 1)\n        sub_image = sub_image.resize(\n            (pixel_width, pixel_height), resample=Image.BICUBIC\n        )\n\n        # Rotate\n        angle = angle_of_vector(right_vect)\n        adjusted_angle = -int(360 * angle / TAU)\n        if adjusted_angle != 0:\n            sub_image = sub_image.rotate(\n                adjusted_angle, resample=Image.BICUBIC, expand=1\n            )\n\n        # TODO, there is no accounting for a shear...\n\n        # Paste into an image as large as the camear's pixel array\n        full_image = Image.fromarray(\n            np.zeros((self.get_pixel_height(), self.get_pixel_width())), mode=\"RGBA\"\n        )\n        new_ul_coords = center_coords - np.array(sub_image.size) / 2\n        new_ul_coords = new_ul_coords.astype(int)\n        full_image.paste(\n            sub_image,\n            box=(\n                new_ul_coords[0],\n                new_ul_coords[1],\n                new_ul_coords[0] + sub_image.size[0],\n                new_ul_coords[1] + sub_image.size[1],\n            ),\n        )\n        # Paint on top of existing pixel array\n        self.overlay_PIL_image(pixel_array, full_image)",
  "def overlay_rgba_array(self, pixel_array, new_array):\n        \"\"\"Overlays an RGBA array on top of the given Pixel array.\n\n        Parameters\n        ----------\n        pixel_array : np.array\n            The original pixel array to modify.\n        new_array : np.array\n            The new pixel array to overlay.\n        \"\"\"\n        self.overlay_PIL_image(\n            pixel_array, self.get_image(new_array),\n        )",
  "def overlay_PIL_image(self, pixel_array, image):\n        \"\"\"Overlays a PIL image on the passed pixel array.\n\n        Parameters\n        ----------\n        pixel_array : np.ndarray\n            The Pixel array\n        image : PIL.Image\n            The Image to overlay.\n        \"\"\"\n        pixel_array[:, :] = np.array(\n            Image.alpha_composite(self.get_image(pixel_array), image), dtype=\"uint8\"\n        )",
  "def adjust_out_of_range_points(self, points):\n        \"\"\"If any of the points in the passed array are out of\n        the viable range, they are adjusted suitably.\n\n        Parameters\n        ----------\n        points : np.array\n            The points to adjust\n\n        Returns\n        -------\n        np.array\n            The adjusted points.\n        \"\"\"\n        if not np.any(points > self.max_allowable_norm):\n            return points\n        norms = np.apply_along_axis(get_norm, 1, points)\n        violator_indices = norms > self.max_allowable_norm\n        violators = points[violator_indices, :]\n        violator_norms = norms[violator_indices]\n        reshaped_norms = np.repeat(\n            violator_norms.reshape((len(violator_norms), 1)), points.shape[1], 1\n        )\n        rescaled = self.max_allowable_norm * violators / reshaped_norms\n        points[violator_indices] = rescaled\n        return points",
  "def transform_points_pre_display(\n        self, mobject, points\n    ):  # TODO: Write more detailed docstrings for this method.\n        # NOTE: There seems to be an unused argument `mobject`.\n\n        # Subclasses (like ThreeDCamera) may want to\n        # adjust points futher before they're shown\n        if not np.all(np.isfinite(points)):\n            # TODO, print some kind of warning about\n            # mobject having invalid points?\n            points = np.zeros((1, 3))\n        return points",
  "def points_to_pixel_coords(\n        self, mobject, points\n    ):  # TODO: Write more detailed docstrings for this method.\n        points = self.transform_points_pre_display(mobject, points)\n        shifted_points = points - self.get_frame_center()\n\n        result = np.zeros((len(points), 2))\n        pixel_height = self.get_pixel_height()\n        pixel_width = self.get_pixel_width()\n        frame_height = self.get_frame_height()\n        frame_width = self.get_frame_width()\n        width_mult = pixel_width / frame_width\n        width_add = pixel_width / 2\n        height_mult = pixel_height / frame_height\n        height_add = pixel_height / 2\n        # Flip on y-axis as you go\n        height_mult *= -1\n\n        result[:, 0] = shifted_points[:, 0] * width_mult + width_add\n        result[:, 1] = shifted_points[:, 1] * height_mult + height_add\n        return result.astype(\"int\")",
  "def on_screen_pixels(self, pixel_coords):\n        \"\"\"Returns array of pixels that are on the screen from a given\n        array of pixel_coordinates\n\n        Parameters\n        ----------\n        pixel_coords : np.array\n            The pixel coords to check.\n\n        Returns\n        -------\n        np.array\n            The pixel coords on screen.\n        \"\"\"\n        return reduce(\n            op.and_,\n            [\n                pixel_coords[:, 0] >= 0,\n                pixel_coords[:, 0] < self.get_pixel_width(),\n                pixel_coords[:, 1] >= 0,\n                pixel_coords[:, 1] < self.get_pixel_height(),\n            ],\n        )",
  "def adjusted_thickness(self, thickness):\n        \"\"\"\n\n        Parameters\n        ----------\n        thickness : int, float\n\n        Returns\n        -------\n        float\n\n        \"\"\"\n        # TODO: This seems...unsystematic\n        big_sum = op.add(\n            PRODUCTION_QUALITY_CAMERA_CONFIG[\"pixel_height\"],\n            PRODUCTION_QUALITY_CAMERA_CONFIG[\"pixel_width\"],\n        )\n        this_sum = op.add(self.get_pixel_height(), self.get_pixel_width(),)\n        factor = fdiv(big_sum, this_sum)\n        return 1 + (thickness - 1) / factor",
  "def get_thickening_nudges(self, thickness):\n        \"\"\"\n\n        Parameters\n        ----------\n        thickness : int, float\n\n        Returns\n        -------\n        np.array\n\n        \"\"\"\n        thickness = int(thickness)\n        _range = list(range(-thickness // 2 + 1, thickness // 2 + 1))\n        return np.array(list(it.product(_range, _range)))",
  "def thickened_coordinates(self, pixel_coords, thickness):\n        \"\"\"Returns thickened coordinates for a passed array of pixel coords and\n        a thickness to thicken by.\n\n        Parameters\n        ----------\n        pixel_coords : np.array\n            Pixel coordinates\n        thickness : int, float\n            Thickness\n\n        Returns\n        -------\n        np.array\n            Array of thickened pixel coords.\n        \"\"\"\n        nudges = self.get_thickening_nudges(thickness)\n        pixel_coords = np.array([pixel_coords + nudge for nudge in nudges])\n        size = pixel_coords.size\n        return pixel_coords.reshape((size // 2, 2))",
  "def get_coords_of_all_pixels(self):\n        \"\"\"Returns the cartesian coordinates of each pixel.\n\n        Returns\n        -------\n        np.ndarray\n            The array of cartesian coordinates.\n        \"\"\"\n        # These are in x, y order, to help me keep things straight\n        full_space_dims = np.array([self.get_frame_width(), self.get_frame_height()])\n        full_pixel_dims = np.array([self.get_pixel_width(), self.get_pixel_height()])\n\n        # These are addressed in the same y, x order as in pixel_array, but the values in them\n        # are listed in x, y order\n        uncentered_pixel_coords = np.indices(\n            [self.get_pixel_height(), self.get_pixel_width()]\n        )[::-1].transpose(1, 2, 0)\n        uncentered_space_coords = fdiv(\n            uncentered_pixel_coords * full_space_dims, full_pixel_dims\n        )\n        # Could structure above line's computation slightly differently, but figured (without much\n        # thought) multiplying by frame_shape first, THEN dividing by pixel_shape, is probably\n        # better than the other order, for avoiding underflow quantization in the division (whereas\n        # overflow is unlikely to be a problem)\n\n        centered_space_coords = uncentered_space_coords - fdiv(full_space_dims, 2)\n\n        # Have to also flip the y coordinates to account for pixel array being listed in\n        # top-to-bottom order, opposite of screen coordinate convention\n        centered_space_coords = centered_space_coords * (1, -1)\n\n        return centered_space_coords",
  "def __init__(self, camera):\n        \"\"\"\n        Parameters\n        ----------\n        camera : Camera\n            Camera object to use.\n        \"\"\"\n        self.camera = camera\n        self.file_name_to_pixel_array_map = {}\n        self.pixel_array = np.array(camera.get_pixel_array())\n        self.reset_pixel_array()",
  "def reset_pixel_array(self):\n        self.pixel_array[:, :] = 0",
  "def resize_background_array(\n        self, background_array, new_width, new_height, mode=\"RGBA\"\n    ):\n        \"\"\"Resizes the pixel array represinting the background.\n\n        Parameters\n        ----------\n        background_array : np.array\n            The pixel\n        new_width : int, float\n            The new width of the background\n        new_height : int, float\n            The new height of the background\n        mode : str, optional\n            The PIL image mode, by default \"RGBA\"\n\n        Returns\n        -------\n        np.array\n            The numpy pixel array of the resized background.\n        \"\"\"\n        image = Image.fromarray(background_array)\n        image = image.convert(mode)\n        resized_image = image.resize((new_width, new_height))\n        return np.array(resized_image)",
  "def resize_background_array_to_match(self, background_array, pixel_array):\n        \"\"\"Resizes the background array to match the passed pixel array.\n\n        Parameters\n        ----------\n        background_array : np.array\n            The prospective pixel array.\n        pixel_array : np.array\n            The pixel array whose width and height should be matched.\n\n        Returns\n        -------\n        np.array\n            The resized background array.\n        \"\"\"\n        height, width = pixel_array.shape[:2]\n        mode = \"RGBA\" if pixel_array.shape[2] == 4 else \"RGB\"\n        return self.resize_background_array(background_array, width, height, mode)",
  "def get_background_array(self, file_name):\n        \"\"\"Gets the background array that has the passed file_name.\n\n        Parameters\n        ----------\n        file_name : str\n            The file_name of the background image.\n\n        Returns\n        -------\n        np.ndarray\n            The pixel array of the file whose file name is `file_name`\n        \"\"\"\n        if file_name in self.file_name_to_pixel_array_map:\n            return self.file_name_to_pixel_array_map[file_name]\n        full_path = get_full_raster_image_path(file_name)\n        image = Image.open(full_path)\n        back_array = np.array(image)\n\n        pixel_array = self.pixel_array\n        if not np.all(pixel_array.shape == back_array.shape):\n            back_array = self.resize_background_array_to_match(back_array, pixel_array)\n\n        self.file_name_to_pixel_array_map[file_name] = back_array\n        return back_array",
  "def display(self, *cvmobjects):\n        \"\"\"Displays the colored VMobjects.\n\n        Parameters\n        ----------\n        *cvmobjects : VMobject\n            The VMobjects\n\n        Returns\n        -------\n        np.array\n            The pixel array with the `cvmobjects` displayed.\n        \"\"\"\n        batch_image_file_pairs = batch_by_property(\n            cvmobjects, lambda cv: cv.get_background_image_file()\n        )\n        curr_array = None\n        for batch, image_file in batch_image_file_pairs:\n            background_array = self.get_background_array(image_file)\n            pixel_array = self.pixel_array\n            self.camera.display_multiple_non_background_colored_vmobjects(\n                batch, pixel_array\n            )\n            new_array = np.array(\n                (background_array * pixel_array.astype(\"float\") / 255),\n                dtype=self.camera.pixel_array_dtype,\n            )\n            if curr_array is None:\n                curr_array = new_array\n            else:\n                curr_array = np.maximum(curr_array, new_array)\n            self.reset_pixel_array()\n        return curr_array",
  "def get_mobject_type(mobject):\n            for mobject_type, func in type_func_pairs:\n                if isinstance(mobject, mobject_type):\n                    return mobject_type\n            raise Exception(\"Trying to display something which is not of type Mobject\")",
  "class MultiCamera(MovingCamera):\n    \"\"\"Camera Object that allows for multiple perspectives.\n    \"\"\"\n\n    CONFIG = {\n        \"allow_cameras_to_capture_their_own_display\": False,\n    }\n\n    def __init__(self, *image_mobjects_from_cameras, **kwargs):\n        \"\"\"Initalises the MultiCamera\n\n        Parameters:\n        -----------\n        *image_mobjects_from_cameras : ImageMobject\n\n        **kwargs\n            Any valid keyword arguments of MovingCamera.\n        \"\"\"\n        self.image_mobjects_from_cameras = []\n        for imfc in image_mobjects_from_cameras:\n            self.add_image_mobject_from_camera(imfc)\n        MovingCamera.__init__(self, **kwargs)\n\n    def add_image_mobject_from_camera(self, image_mobject_from_camera):\n        \"\"\"Adds an ImageMobject that's been obtained from the camera\n        into the list `self.image_mobject_from_cameras`\n\n        Parameters\n        ----------\n        image_mobject_from_camera : ImageMobject\n            The ImageMobject to add to self.image_mobject_from_cameras\n        \"\"\"\n        # A silly method to have right now, but maybe there are things\n        # we want to guarantee about any imfc's added later.\n        imfc = image_mobject_from_camera\n        assert isinstance(imfc.camera, MovingCamera)\n        self.image_mobjects_from_cameras.append(imfc)\n\n    def update_sub_cameras(self):\n        \"\"\" Reshape sub_camera pixel_arrays \"\"\"\n        for imfc in self.image_mobjects_from_cameras:\n            pixel_height, pixel_width = self.get_pixel_array().shape[:2]\n            imfc.camera.frame_shape = (\n                imfc.camera.frame.get_height(),\n                imfc.camera.frame.get_width(),\n            )\n            imfc.camera.reset_pixel_shape(\n                int(pixel_height * imfc.get_height() / self.get_frame_height()),\n                int(pixel_width * imfc.get_width() / self.get_frame_width()),\n            )\n\n    def reset(self):\n        \"\"\"Resets the MultiCamera.\n\n        Returns\n        -------\n        MultiCamera\n            The reset MultiCamera\n        \"\"\"\n        for imfc in self.image_mobjects_from_cameras:\n            imfc.camera.reset()\n        MovingCamera.reset(self)\n        return self\n\n    def capture_mobjects(self, mobjects, **kwargs):\n        self.update_sub_cameras()\n        for imfc in self.image_mobjects_from_cameras:\n            to_add = list(mobjects)\n            if not self.allow_cameras_to_capture_their_own_display:\n                to_add = list_difference_update(to_add, imfc.get_family())\n            imfc.camera.capture_mobjects(to_add, **kwargs)\n        MovingCamera.capture_mobjects(self, mobjects, **kwargs)\n\n    def get_mobjects_indicating_movement(self):\n        \"\"\"Returns all mobjets whose movement implies that the camera\n        should think of all other mobjects on the screen as moving\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self.frame] + [\n            imfc.camera.frame for imfc in self.image_mobjects_from_cameras\n        ]",
  "def __init__(self, *image_mobjects_from_cameras, **kwargs):\n        \"\"\"Initalises the MultiCamera\n\n        Parameters:\n        -----------\n        *image_mobjects_from_cameras : ImageMobject\n\n        **kwargs\n            Any valid keyword arguments of MovingCamera.\n        \"\"\"\n        self.image_mobjects_from_cameras = []\n        for imfc in image_mobjects_from_cameras:\n            self.add_image_mobject_from_camera(imfc)\n        MovingCamera.__init__(self, **kwargs)",
  "def add_image_mobject_from_camera(self, image_mobject_from_camera):\n        \"\"\"Adds an ImageMobject that's been obtained from the camera\n        into the list `self.image_mobject_from_cameras`\n\n        Parameters\n        ----------\n        image_mobject_from_camera : ImageMobject\n            The ImageMobject to add to self.image_mobject_from_cameras\n        \"\"\"\n        # A silly method to have right now, but maybe there are things\n        # we want to guarantee about any imfc's added later.\n        imfc = image_mobject_from_camera\n        assert isinstance(imfc.camera, MovingCamera)\n        self.image_mobjects_from_cameras.append(imfc)",
  "def update_sub_cameras(self):\n        \"\"\" Reshape sub_camera pixel_arrays \"\"\"\n        for imfc in self.image_mobjects_from_cameras:\n            pixel_height, pixel_width = self.get_pixel_array().shape[:2]\n            imfc.camera.frame_shape = (\n                imfc.camera.frame.get_height(),\n                imfc.camera.frame.get_width(),\n            )\n            imfc.camera.reset_pixel_shape(\n                int(pixel_height * imfc.get_height() / self.get_frame_height()),\n                int(pixel_width * imfc.get_width() / self.get_frame_width()),\n            )",
  "def reset(self):\n        \"\"\"Resets the MultiCamera.\n\n        Returns\n        -------\n        MultiCamera\n            The reset MultiCamera\n        \"\"\"\n        for imfc in self.image_mobjects_from_cameras:\n            imfc.camera.reset()\n        MovingCamera.reset(self)\n        return self",
  "def capture_mobjects(self, mobjects, **kwargs):\n        self.update_sub_cameras()\n        for imfc in self.image_mobjects_from_cameras:\n            to_add = list(mobjects)\n            if not self.allow_cameras_to_capture_their_own_display:\n                to_add = list_difference_update(to_add, imfc.get_family())\n            imfc.camera.capture_mobjects(to_add, **kwargs)\n        MovingCamera.capture_mobjects(self, mobjects, **kwargs)",
  "def get_mobjects_indicating_movement(self):\n        \"\"\"Returns all mobjets whose movement implies that the camera\n        should think of all other mobjects on the screen as moving\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self.frame] + [\n            imfc.camera.frame for imfc in self.image_mobjects_from_cameras\n        ]",
  "class UpdateFromFunc(Animation):\n    \"\"\"\n    update_function of the form func(mobject), presumably\n    to be used when the state of one mobject is dependent\n    on another simultaneously animated mobject\n    \"\"\"\n\n    CONFIG = {\n        \"suspend_mobject_updating\": False,\n    }\n\n    def __init__(self, mobject, update_function, **kwargs):\n        self.update_function = update_function\n        super().__init__(mobject, **kwargs)\n\n    def interpolate_mobject(self, alpha):\n        self.update_function(self.mobject)",
  "class UpdateFromAlphaFunc(UpdateFromFunc):\n    def interpolate_mobject(self, alpha):\n        self.update_function(self.mobject, alpha)",
  "class MaintainPositionRelativeTo(Animation):\n    def __init__(self, mobject, tracked_mobject, **kwargs):\n        self.tracked_mobject = tracked_mobject\n        self.diff = op.sub(mobject.get_center(), tracked_mobject.get_center(),)\n        super().__init__(mobject, **kwargs)\n\n    def interpolate_mobject(self, alpha):\n        target = self.tracked_mobject.get_center()\n        location = self.mobject.get_center()\n        self.mobject.shift(target - location + self.diff)",
  "def __init__(self, mobject, update_function, **kwargs):\n        self.update_function = update_function\n        super().__init__(mobject, **kwargs)",
  "def interpolate_mobject(self, alpha):\n        self.update_function(self.mobject)",
  "def interpolate_mobject(self, alpha):\n        self.update_function(self.mobject, alpha)",
  "def __init__(self, mobject, tracked_mobject, **kwargs):\n        self.tracked_mobject = tracked_mobject\n        self.diff = op.sub(mobject.get_center(), tracked_mobject.get_center(),)\n        super().__init__(mobject, **kwargs)",
  "def interpolate_mobject(self, alpha):\n        target = self.tracked_mobject.get_center()\n        location = self.mobject.get_center()\n        self.mobject.shift(target - location + self.diff)",
  "class AnimationGroup(Animation):\n    CONFIG = {\n        # If None, this defaults to the sum of all\n        # internal animations\n        \"run_time\": None,\n        \"rate_func\": linear,\n        # If 0, all animations are played at once.\n        # If 1, all are played successively.\n        # If >0 and <1, they start at lagged times\n        # from one and other.\n        \"lag_ratio\": 0,\n        \"group\": None,\n    }\n\n    def __init__(self, *animations, **kwargs):\n        digest_config(self, kwargs)\n        self.animations = animations\n        if self.group is None:\n            self.group = Group(\n                *remove_list_redundancies([anim.mobject for anim in animations])\n            )\n        self.init_run_time()\n        Animation.__init__(self, self.group, **kwargs)\n\n    def get_all_mobjects(self):\n        return self.group\n\n    def begin(self):\n        for anim in self.animations:\n            anim.begin()\n        # self.init_run_time()\n\n    def finish(self):\n        for anim in self.animations:\n            anim.finish()\n\n    def clean_up_from_scene(self, scene):\n        for anim in self.animations:\n            anim.clean_up_from_scene(scene)\n\n    def update_mobjects(self, dt):\n        for anim in self.animations:\n            anim.update_mobjects(dt)\n\n    def init_run_time(self):\n        self.build_animations_with_timings()\n        if self.anims_with_timings:\n            self.max_end_time = np.max([awt[2] for awt in self.anims_with_timings])\n        else:\n            self.max_end_time = 0\n        if self.run_time is None:\n            self.run_time = self.max_end_time\n\n    def build_animations_with_timings(self):\n        \"\"\"\n        Creates a list of triplets of the form\n        (anim, start_time, end_time)\n        \"\"\"\n        self.anims_with_timings = []\n        curr_time = 0\n        for anim in self.animations:\n            start_time = curr_time\n            end_time = start_time + anim.get_run_time()\n            self.anims_with_timings.append((anim, start_time, end_time))\n            # Start time of next animation is based on\n            # the lag_ratio\n            curr_time = interpolate(start_time, end_time, self.lag_ratio)\n\n    def interpolate(self, alpha):\n        # Note, if the run_time of AnimationGroup has been\n        # set to something other than its default, these\n        # times might not correspond to actual times,\n        # e.g. of the surrounding scene.  Instead they'd\n        # be a rescaled version.  But that's okay!\n        time = alpha * self.max_end_time\n        for anim, start_time, end_time in self.anims_with_timings:\n            anim_time = end_time - start_time\n            if anim_time == 0:\n                sub_alpha = 0\n            else:\n                sub_alpha = np.clip((time - start_time) / anim_time, 0, 1)\n            anim.interpolate(sub_alpha)",
  "class Succession(AnimationGroup):\n    CONFIG = {\n        \"lag_ratio\": 1,\n    }\n\n    def begin(self):\n        assert len(self.animations) > 0\n        self.init_run_time()\n        self.active_animation = self.animations[0]\n        self.active_animation.begin()\n\n    def finish(self):\n        self.active_animation.finish()\n\n    def update_mobjects(self, dt):\n        self.active_animation.update_mobjects(dt)\n\n    def interpolate(self, alpha):\n        index, subalpha = integer_interpolate(0, len(self.animations), alpha)\n        animation = self.animations[index]\n        if animation is not self.active_animation:\n            self.active_animation.finish()\n            animation.begin()\n            self.active_animation = animation\n        animation.interpolate(subalpha)",
  "class LaggedStart(AnimationGroup):\n    CONFIG = {\n        \"lag_ratio\": DEFAULT_LAGGED_START_LAG_RATIO,\n    }",
  "class LaggedStartMap(LaggedStart):\n    CONFIG = {\n        \"run_time\": 2,\n    }\n\n    def __init__(self, AnimationClass, mobject, arg_creator=None, **kwargs):\n        args_list = []\n        for submob in mobject:\n            if arg_creator:\n                args_list.append(arg_creator(submob))\n            else:\n                args_list.append((submob,))\n        anim_kwargs = dict(kwargs)\n        if \"lag_ratio\" in anim_kwargs:\n            anim_kwargs.pop(\"lag_ratio\")\n        animations = [AnimationClass(*args, **anim_kwargs) for args in args_list]\n        super().__init__(*animations, **kwargs)",
  "def __init__(self, *animations, **kwargs):\n        digest_config(self, kwargs)\n        self.animations = animations\n        if self.group is None:\n            self.group = Group(\n                *remove_list_redundancies([anim.mobject for anim in animations])\n            )\n        self.init_run_time()\n        Animation.__init__(self, self.group, **kwargs)",
  "def get_all_mobjects(self):\n        return self.group",
  "def begin(self):\n        for anim in self.animations:\n            anim.begin()",
  "def finish(self):\n        for anim in self.animations:\n            anim.finish()",
  "def clean_up_from_scene(self, scene):\n        for anim in self.animations:\n            anim.clean_up_from_scene(scene)",
  "def update_mobjects(self, dt):\n        for anim in self.animations:\n            anim.update_mobjects(dt)",
  "def init_run_time(self):\n        self.build_animations_with_timings()\n        if self.anims_with_timings:\n            self.max_end_time = np.max([awt[2] for awt in self.anims_with_timings])\n        else:\n            self.max_end_time = 0\n        if self.run_time is None:\n            self.run_time = self.max_end_time",
  "def build_animations_with_timings(self):\n        \"\"\"\n        Creates a list of triplets of the form\n        (anim, start_time, end_time)\n        \"\"\"\n        self.anims_with_timings = []\n        curr_time = 0\n        for anim in self.animations:\n            start_time = curr_time\n            end_time = start_time + anim.get_run_time()\n            self.anims_with_timings.append((anim, start_time, end_time))\n            # Start time of next animation is based on\n            # the lag_ratio\n            curr_time = interpolate(start_time, end_time, self.lag_ratio)",
  "def interpolate(self, alpha):\n        # Note, if the run_time of AnimationGroup has been\n        # set to something other than its default, these\n        # times might not correspond to actual times,\n        # e.g. of the surrounding scene.  Instead they'd\n        # be a rescaled version.  But that's okay!\n        time = alpha * self.max_end_time\n        for anim, start_time, end_time in self.anims_with_timings:\n            anim_time = end_time - start_time\n            if anim_time == 0:\n                sub_alpha = 0\n            else:\n                sub_alpha = np.clip((time - start_time) / anim_time, 0, 1)\n            anim.interpolate(sub_alpha)",
  "def begin(self):\n        assert len(self.animations) > 0\n        self.init_run_time()\n        self.active_animation = self.animations[0]\n        self.active_animation.begin()",
  "def finish(self):\n        self.active_animation.finish()",
  "def update_mobjects(self, dt):\n        self.active_animation.update_mobjects(dt)",
  "def interpolate(self, alpha):\n        index, subalpha = integer_interpolate(0, len(self.animations), alpha)\n        animation = self.animations[index]\n        if animation is not self.active_animation:\n            self.active_animation.finish()\n            animation.begin()\n            self.active_animation = animation\n        animation.interpolate(subalpha)",
  "def __init__(self, AnimationClass, mobject, arg_creator=None, **kwargs):\n        args_list = []\n        for submob in mobject:\n            if arg_creator:\n                args_list.append(arg_creator(submob))\n            else:\n                args_list.append((submob,))\n        anim_kwargs = dict(kwargs)\n        if \"lag_ratio\" in anim_kwargs:\n            anim_kwargs.pop(\"lag_ratio\")\n        animations = [AnimationClass(*args, **anim_kwargs) for args in args_list]\n        super().__init__(*animations, **kwargs)",
  "class MoveCar(ApplyMethod):\n    CONFIG = {\n        \"moving_forward\": True,\n        \"run_time\": 5,\n    }\n\n    def __init__(self, car, target_point, **kwargs):\n        self.check_if_input_is_car(car)\n        self.target_point = target_point\n        super().__init__(car.move_to, target_point, **kwargs)\n\n    def check_if_input_is_car(self, car):\n        if not isinstance(car, Car):\n            raise Exception(\"MoveCar must take in Car object\")\n\n    def begin(self):\n        super().begin()\n        car = self.mobject\n        distance = get_norm(\n            op.sub(self.target_mobject.get_right(), self.starting_mobject.get_right(),)\n        )\n        if not self.moving_forward:\n            distance *= -1\n        tire_radius = car.get_tires()[0].get_width() / 2\n        self.total_tire_radians = -distance / tire_radius\n\n    def interpolate_mobject(self, alpha):\n        ApplyMethod.interpolate_mobject(self, alpha)\n        if alpha == 0:\n            return\n        radians = alpha * self.total_tire_radians\n        for tire in self.mobject.get_tires():\n            tire.rotate_in_place(radians)",
  "class Broadcast(LaggedStart):\n    CONFIG = {\n        \"small_radius\": 0.0,\n        \"big_radius\": 5,\n        \"n_circles\": 5,\n        \"start_stroke_width\": 8,\n        \"color\": WHITE,\n        \"remover\": True,\n        \"lag_ratio\": 0.2,\n        \"run_time\": 3,\n        \"remover\": True,\n    }\n\n    def __init__(self, focal_point, **kwargs):\n        digest_config(self, kwargs)\n        circles = VGroup()\n        for x in range(self.n_circles):\n            circle = Circle(radius=self.big_radius, stroke_color=BLACK, stroke_width=0,)\n            circle.add_updater(lambda c: c.move_to(focal_point))\n            circle.save_state()\n            circle.set_width(self.small_radius * 2)\n            circle.set_stroke(self.color, self.start_stroke_width)\n            circles.add(circle)\n        animations = [Restore(circle) for circle in circles]\n        super().__init__(*animations, **kwargs)",
  "def __init__(self, car, target_point, **kwargs):\n        self.check_if_input_is_car(car)\n        self.target_point = target_point\n        super().__init__(car.move_to, target_point, **kwargs)",
  "def check_if_input_is_car(self, car):\n        if not isinstance(car, Car):\n            raise Exception(\"MoveCar must take in Car object\")",
  "def begin(self):\n        super().begin()\n        car = self.mobject\n        distance = get_norm(\n            op.sub(self.target_mobject.get_right(), self.starting_mobject.get_right(),)\n        )\n        if not self.moving_forward:\n            distance *= -1\n        tire_radius = car.get_tires()[0].get_width() / 2\n        self.total_tire_radians = -distance / tire_radius",
  "def interpolate_mobject(self, alpha):\n        ApplyMethod.interpolate_mobject(self, alpha)\n        if alpha == 0:\n            return\n        radians = alpha * self.total_tire_radians\n        for tire in self.mobject.get_tires():\n            tire.rotate_in_place(radians)",
  "def __init__(self, focal_point, **kwargs):\n        digest_config(self, kwargs)\n        circles = VGroup()\n        for x in range(self.n_circles):\n            circle = Circle(radius=self.big_radius, stroke_color=BLACK, stroke_width=0,)\n            circle.add_updater(lambda c: c.move_to(focal_point))\n            circle.save_state()\n            circle.set_width(self.small_radius * 2)\n            circle.set_stroke(self.color, self.start_stroke_width)\n            circles.add(circle)\n        animations = [Restore(circle) for circle in circles]\n        super().__init__(*animations, **kwargs)",
  "class GrowFromPoint(Transform):\n    CONFIG = {\n        \"point_color\": None,\n    }\n\n    def __init__(self, mobject, point, **kwargs):\n        self.point = point\n        super().__init__(mobject, **kwargs)\n\n    def create_target(self):\n        return self.mobject\n\n    def create_starting_mobject(self):\n        start = super().create_starting_mobject()\n        start.scale(0)\n        start.move_to(self.point)\n        if self.point_color:\n            start.set_color(self.point_color)\n        return start",
  "class GrowFromCenter(GrowFromPoint):\n    def __init__(self, mobject, **kwargs):\n        point = mobject.get_center()\n        super().__init__(mobject, point, **kwargs)",
  "class GrowFromEdge(GrowFromPoint):\n    def __init__(self, mobject, edge, **kwargs):\n        point = mobject.get_critical_point(edge)\n        super().__init__(mobject, point, **kwargs)",
  "class GrowArrow(GrowFromPoint):\n    def __init__(self, arrow, **kwargs):\n        point = arrow.get_start()\n        super().__init__(arrow, point, **kwargs)",
  "class SpinInFromNothing(GrowFromCenter):\n    CONFIG = {\n        \"path_arc\": PI,\n    }",
  "def __init__(self, mobject, point, **kwargs):\n        self.point = point\n        super().__init__(mobject, **kwargs)",
  "def create_target(self):\n        return self.mobject",
  "def create_starting_mobject(self):\n        start = super().create_starting_mobject()\n        start.scale(0)\n        start.move_to(self.point)\n        if self.point_color:\n            start.set_color(self.point_color)\n        return start",
  "def __init__(self, mobject, **kwargs):\n        point = mobject.get_center()\n        super().__init__(mobject, point, **kwargs)",
  "def __init__(self, mobject, edge, **kwargs):\n        point = mobject.get_critical_point(edge)\n        super().__init__(mobject, point, **kwargs)",
  "def __init__(self, arrow, **kwargs):\n        point = arrow.get_start()\n        super().__init__(arrow, point, **kwargs)",
  "class FocusOn(Transform):\n    CONFIG = {\n        \"opacity\": 0.2,\n        \"color\": GREY,\n        \"run_time\": 2,\n        \"remover\": True,\n    }\n\n    def __init__(self, focus_point, **kwargs):\n        self.focus_point = focus_point\n        # Initialize with blank mobject, while create_target\n        # and create_starting_mobject handle the meat\n        super().__init__(VMobject(), **kwargs)\n\n    def create_target(self):\n        little_dot = Dot(radius=0)\n        little_dot.set_fill(self.color, opacity=self.opacity)\n        little_dot.add_updater(lambda d: d.move_to(self.focus_point))\n        return little_dot\n\n    def create_starting_mobject(self):\n        return Dot(\n            radius=config[\"frame_x_radius\"] + config[\"frame_y_radius\"],\n            stroke_width=0,\n            fill_color=self.color,\n            fill_opacity=0,\n        )",
  "class Indicate(Transform):\n    CONFIG = {\n        \"rate_func\": there_and_back,\n        \"scale_factor\": 1.2,\n        \"color\": YELLOW,\n    }\n\n    def create_target(self):\n        target = self.mobject.copy()\n        target.scale_in_place(self.scale_factor)\n        target.set_color(self.color)\n        return target",
  "class Flash(AnimationGroup):\n    CONFIG = {\n        \"line_length\": 0.2,\n        \"num_lines\": 12,\n        \"flash_radius\": 0.3,\n        \"line_stroke_width\": 3,\n        \"run_time\": 1,\n    }\n\n    def __init__(self, point, color=YELLOW, **kwargs):\n        self.point = point\n        self.color = color\n        digest_config(self, kwargs)\n        self.lines = self.create_lines()\n        animations = self.create_line_anims()\n        super().__init__(\n            *animations, group=self.lines, **kwargs,\n        )\n\n    def create_lines(self):\n        lines = VGroup()\n        for angle in np.arange(0, TAU, TAU / self.num_lines):\n            line = Line(ORIGIN, self.line_length * RIGHT)\n            line.shift((self.flash_radius - self.line_length) * RIGHT)\n            line.rotate(angle, about_point=ORIGIN)\n            lines.add(line)\n        lines.set_color(self.color)\n        lines.set_stroke(width=3)\n        lines.add_updater(lambda l: l.move_to(self.point))\n        return lines\n\n    def create_line_anims(self):\n        return [ShowCreationThenDestruction(line) for line in self.lines]",
  "class CircleIndicate(Indicate):\n    CONFIG = {\n        \"rate_func\": there_and_back,\n        \"remover\": True,\n        \"circle_config\": {\"color\": YELLOW,},\n    }\n\n    def __init__(self, mobject, **kwargs):\n        digest_config(self, kwargs)\n        circle = self.get_circle(mobject)\n        super().__init__(circle, **kwargs)\n\n    def get_circle(self, mobject):\n        circle = Circle(**self.circle_config)\n        circle.add_updater(lambda c: c.surround(mobject))\n        return circle\n\n    def interpolate_mobject(self, alpha):\n        super().interpolate_mobject(alpha)\n        self.mobject.set_stroke(opacity=alpha)",
  "class ShowPassingFlash(ShowPartial):\n    CONFIG = {\n        \"time_width\": 0.1,\n        \"remover\": True,\n    }\n\n    def get_bounds(self, alpha):\n        tw = self.time_width\n        upper = interpolate(0, 1 + tw, alpha)\n        lower = upper - tw\n        upper = min(upper, 1)\n        lower = max(lower, 0)\n        return (lower, upper)\n\n    def finish(self):\n        super().finish()\n        for submob, start in self.get_all_families_zipped():\n            submob.pointwise_become_partial(start, 0, 1)",
  "class ShowCreationThenDestruction(ShowPassingFlash):\n    CONFIG = {\n        \"time_width\": 2.0,\n        \"run_time\": 1,\n    }",
  "class ShowCreationThenFadeOut(Succession):\n    CONFIG = {\n        \"remover\": True,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        super().__init__(ShowCreation(mobject), FadeOut(mobject), **kwargs)",
  "class AnimationOnSurroundingRectangle(AnimationGroup):\n    CONFIG = {\n        \"surrounding_rectangle_config\": {},\n        # Function which takes in a rectangle, and spits\n        # out some animation.  Could be some animation class,\n        # could be something more\n        \"rect_animation\": Animation,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        digest_config(self, kwargs)\n        if \"surrounding_rectangle_config\" in kwargs:\n            kwargs.pop(\"surrounding_rectangle_config\")\n        self.mobject_to_surround = mobject\n\n        rect = self.get_rect()\n        rect.add_updater(lambda r: r.move_to(mobject))\n\n        super().__init__(self.rect_animation(rect, **kwargs),)\n\n    def get_rect(self):\n        return SurroundingRectangle(\n            self.mobject_to_surround, **self.surrounding_rectangle_config\n        )",
  "class ShowPassingFlashAround(AnimationOnSurroundingRectangle):\n    CONFIG = {\"rect_animation\": ShowPassingFlash}",
  "class ShowCreationThenDestructionAround(AnimationOnSurroundingRectangle):\n    CONFIG = {\"rect_animation\": ShowCreationThenDestruction}",
  "class ShowCreationThenFadeAround(AnimationOnSurroundingRectangle):\n    CONFIG = {\"rect_animation\": ShowCreationThenFadeOut}",
  "class ApplyWave(Homotopy):\n    CONFIG = {\n        \"direction\": UP,\n        \"amplitude\": 0.2,\n        \"run_time\": 1,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        digest_config(self, kwargs, locals())\n        left_x = mobject.get_left()[0]\n        right_x = mobject.get_right()[0]\n        vect = self.amplitude * self.direction\n\n        def homotopy(x, y, z, t):\n            alpha = (x - left_x) / (right_x - left_x)\n            power = np.exp(2.0 * (alpha - 0.5))\n            nudge = there_and_back(t ** power)\n            return np.array([x, y, z]) + nudge * vect\n\n        super().__init__(homotopy, mobject, **kwargs)",
  "class WiggleOutThenIn(Animation):\n    CONFIG = {\n        \"scale_value\": 1.1,\n        \"rotation_angle\": 0.01 * TAU,\n        \"n_wiggles\": 6,\n        \"run_time\": 2,\n        \"scale_about_point\": None,\n        \"rotate_about_point\": None,\n    }\n\n    def get_scale_about_point(self):\n        if self.scale_about_point is None:\n            return self.mobject.get_center()\n\n    def get_rotate_about_point(self):\n        if self.rotate_about_point is None:\n            return self.mobject.get_center()\n\n    def interpolate_submobject(self, submobject, starting_sumobject, alpha):\n        submobject.points[:, :] = starting_sumobject.points\n        submobject.scale(\n            interpolate(1, self.scale_value, there_and_back(alpha)),\n            about_point=self.get_scale_about_point(),\n        )\n        submobject.rotate(\n            wiggle(alpha, self.n_wiggles) * self.rotation_angle,\n            about_point=self.get_rotate_about_point(),\n        )",
  "class TurnInsideOut(Transform):\n    CONFIG = {\n        \"path_arc\": TAU / 4,\n    }\n\n    def create_target(self):\n        return self.mobject.copy().reverse_points()",
  "def __init__(self, focus_point, **kwargs):\n        self.focus_point = focus_point\n        # Initialize with blank mobject, while create_target\n        # and create_starting_mobject handle the meat\n        super().__init__(VMobject(), **kwargs)",
  "def create_target(self):\n        little_dot = Dot(radius=0)\n        little_dot.set_fill(self.color, opacity=self.opacity)\n        little_dot.add_updater(lambda d: d.move_to(self.focus_point))\n        return little_dot",
  "def create_starting_mobject(self):\n        return Dot(\n            radius=config[\"frame_x_radius\"] + config[\"frame_y_radius\"],\n            stroke_width=0,\n            fill_color=self.color,\n            fill_opacity=0,\n        )",
  "def create_target(self):\n        target = self.mobject.copy()\n        target.scale_in_place(self.scale_factor)\n        target.set_color(self.color)\n        return target",
  "def __init__(self, point, color=YELLOW, **kwargs):\n        self.point = point\n        self.color = color\n        digest_config(self, kwargs)\n        self.lines = self.create_lines()\n        animations = self.create_line_anims()\n        super().__init__(\n            *animations, group=self.lines, **kwargs,\n        )",
  "def create_lines(self):\n        lines = VGroup()\n        for angle in np.arange(0, TAU, TAU / self.num_lines):\n            line = Line(ORIGIN, self.line_length * RIGHT)\n            line.shift((self.flash_radius - self.line_length) * RIGHT)\n            line.rotate(angle, about_point=ORIGIN)\n            lines.add(line)\n        lines.set_color(self.color)\n        lines.set_stroke(width=3)\n        lines.add_updater(lambda l: l.move_to(self.point))\n        return lines",
  "def create_line_anims(self):\n        return [ShowCreationThenDestruction(line) for line in self.lines]",
  "def __init__(self, mobject, **kwargs):\n        digest_config(self, kwargs)\n        circle = self.get_circle(mobject)\n        super().__init__(circle, **kwargs)",
  "def get_circle(self, mobject):\n        circle = Circle(**self.circle_config)\n        circle.add_updater(lambda c: c.surround(mobject))\n        return circle",
  "def interpolate_mobject(self, alpha):\n        super().interpolate_mobject(alpha)\n        self.mobject.set_stroke(opacity=alpha)",
  "def get_bounds(self, alpha):\n        tw = self.time_width\n        upper = interpolate(0, 1 + tw, alpha)\n        lower = upper - tw\n        upper = min(upper, 1)\n        lower = max(lower, 0)\n        return (lower, upper)",
  "def finish(self):\n        super().finish()\n        for submob, start in self.get_all_families_zipped():\n            submob.pointwise_become_partial(start, 0, 1)",
  "def __init__(self, mobject, **kwargs):\n        super().__init__(ShowCreation(mobject), FadeOut(mobject), **kwargs)",
  "def __init__(self, mobject, **kwargs):\n        digest_config(self, kwargs)\n        if \"surrounding_rectangle_config\" in kwargs:\n            kwargs.pop(\"surrounding_rectangle_config\")\n        self.mobject_to_surround = mobject\n\n        rect = self.get_rect()\n        rect.add_updater(lambda r: r.move_to(mobject))\n\n        super().__init__(self.rect_animation(rect, **kwargs),)",
  "def get_rect(self):\n        return SurroundingRectangle(\n            self.mobject_to_surround, **self.surrounding_rectangle_config\n        )",
  "def __init__(self, mobject, **kwargs):\n        digest_config(self, kwargs, locals())\n        left_x = mobject.get_left()[0]\n        right_x = mobject.get_right()[0]\n        vect = self.amplitude * self.direction\n\n        def homotopy(x, y, z, t):\n            alpha = (x - left_x) / (right_x - left_x)\n            power = np.exp(2.0 * (alpha - 0.5))\n            nudge = there_and_back(t ** power)\n            return np.array([x, y, z]) + nudge * vect\n\n        super().__init__(homotopy, mobject, **kwargs)",
  "def get_scale_about_point(self):\n        if self.scale_about_point is None:\n            return self.mobject.get_center()",
  "def get_rotate_about_point(self):\n        if self.rotate_about_point is None:\n            return self.mobject.get_center()",
  "def interpolate_submobject(self, submobject, starting_sumobject, alpha):\n        submobject.points[:, :] = starting_sumobject.points\n        submobject.scale(\n            interpolate(1, self.scale_value, there_and_back(alpha)),\n            about_point=self.get_scale_about_point(),\n        )\n        submobject.rotate(\n            wiggle(alpha, self.n_wiggles) * self.rotation_angle,\n            about_point=self.get_rotate_about_point(),\n        )",
  "def create_target(self):\n        return self.mobject.copy().reverse_points()",
  "def homotopy(x, y, z, t):\n            alpha = (x - left_x) / (right_x - left_x)\n            power = np.exp(2.0 * (alpha - 0.5))\n            nudge = there_and_back(t ** power)\n            return np.array([x, y, z]) + nudge * vect",
  "class ShowPartial(Animation):\n    \"\"\"\n    Abstract class for ShowCreation and ShowPassingFlash\n    \"\"\"\n\n    def interpolate_submobject(self, submob, start_submob, alpha):\n        submob.pointwise_become_partial(start_submob, *self.get_bounds(alpha))\n\n    def get_bounds(self, alpha):\n        raise Exception(\"Not Implemented\")",
  "class ShowCreation(ShowPartial):\n    CONFIG = {\n        \"lag_ratio\": 1,\n    }\n\n    def get_bounds(self, alpha):\n        return (0, alpha)",
  "class Uncreate(ShowCreation):\n    CONFIG = {\"rate_func\": lambda t: smooth(1 - t), \"remover\": True}",
  "class DrawBorderThenFill(Animation):\n    CONFIG = {\n        \"run_time\": 2,\n        \"rate_func\": double_smooth,\n        \"stroke_width\": 2,\n        \"stroke_color\": None,\n        \"draw_border_animation_config\": {},\n        \"fill_animation_config\": {},\n    }\n\n    def __init__(self, vmobject, **kwargs):\n        self.check_validity_of_input(vmobject)\n        super().__init__(vmobject, **kwargs)\n\n    def check_validity_of_input(self, vmobject):\n        if not isinstance(vmobject, VMobject):\n            raise Exception(\"DrawBorderThenFill only works for VMobjects\")\n\n    def begin(self):\n        self.outline = self.get_outline()\n        super().begin()\n\n    def get_outline(self):\n        outline = self.mobject.copy()\n        outline.set_fill(opacity=0)\n        for sm in outline.family_members_with_points():\n            sm.set_stroke(color=self.get_stroke_color(sm), width=self.stroke_width)\n        return outline\n\n    def get_stroke_color(self, vmobject):\n        if self.stroke_color:\n            return self.stroke_color\n        elif vmobject.get_stroke_width() > 0:\n            return vmobject.get_stroke_color()\n        return vmobject.get_color()\n\n    def get_all_mobjects(self):\n        return [*super().get_all_mobjects(), self.outline]\n\n    def interpolate_submobject(self, submob, start, outline, alpha):\n        index, subalpha = integer_interpolate(0, 2, alpha)\n        if index == 0:\n            submob.pointwise_become_partial(outline, 0, subalpha)\n            submob.match_style(outline)\n        else:\n            submob.interpolate(outline, start, subalpha)",
  "class Write(DrawBorderThenFill):\n    CONFIG = {\n        # To be figured out in\n        # set_default_config_from_lengths\n        \"run_time\": None,\n        \"lag_ratio\": None,\n        \"rate_func\": linear,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        digest_config(self, kwargs)\n        self.set_default_config_from_length(mobject)\n        super().__init__(mobject, **kwargs)\n\n    def set_default_config_from_length(self, mobject):\n        length = len(mobject.family_members_with_points())\n        if self.run_time is None:\n            if length < 15:\n                self.run_time = 1\n            else:\n                self.run_time = 2\n        if self.lag_ratio is None:\n            self.lag_ratio = min(4.0 / length, 0.2)",
  "class ShowIncreasingSubsets(Animation):\n    CONFIG = {\n        \"suspend_mobject_updating\": False,\n        \"int_func\": np.floor,\n    }\n\n    def __init__(self, group, **kwargs):\n        self.all_submobs = list(group.submobjects)\n        super().__init__(group, **kwargs)\n\n    def interpolate_mobject(self, alpha):\n        n_submobs = len(self.all_submobs)\n        index = int(self.int_func(alpha * n_submobs))\n        self.update_submobject_list(index)\n\n    def update_submobject_list(self, index):\n        self.mobject.submobjects = self.all_submobs[:index]",
  "class AddTextLetterByLetter(ShowIncreasingSubsets):\n    \"\"\"\n        Add a Text Object letter by letter on the scene. Use time_per_char to change frequency of appearance of the letters. \n    \"\"\"\n\n    CONFIG = {\n        \"suspend_mobject_updating\": False,\n        \"int_func\": np.ceil,\n        \"rate_func\": linear,\n        \"time_per_char\": 0.1,\n    }\n\n    def __init__(self, text, **kwargs):\n        digest_config(self, kwargs)\n\n        self.run_time = np.max((0.06, self.time_per_char)) * len(\n            text\n        )  # Time_per_char must be above 0.06. Otherwise the animation doesn't finish.\n        super().__init__(text, **kwargs)",
  "class ShowSubmobjectsOneByOne(ShowIncreasingSubsets):\n    CONFIG = {\n        \"int_func\": np.ceil,\n    }\n\n    def __init__(self, group, **kwargs):\n        new_group = Group(*group)\n        super().__init__(new_group, **kwargs)\n\n    def update_submobject_list(self, index):\n        # N = len(self.all_submobs)\n        if index == 0:\n            self.mobject.submobjects = []\n        else:\n            self.mobject.submobjects = self.all_submobs[index - 1]",
  "class AddTextWordByWord(Succession):\n    CONFIG = {\n        # If given a value for run_time, it will\n        # override the time_per_char\n        \"run_time\": None,\n        \"time_per_char\": 0.06,\n    }\n\n    def __init__(self, text_mobject, **kwargs):\n        digest_config(self, kwargs)\n        tpc = self.time_per_char\n        anims = it.chain(\n            *[\n                [\n                    ShowIncreasingSubsets(word, run_time=tpc * len(word)),\n                    Animation(word, run_time=0.005 * len(word) ** 1.5),\n                ]\n                for word in text_mobject\n            ]\n        )\n        super().__init__(*anims, **kwargs)",
  "def interpolate_submobject(self, submob, start_submob, alpha):\n        submob.pointwise_become_partial(start_submob, *self.get_bounds(alpha))",
  "def get_bounds(self, alpha):\n        raise Exception(\"Not Implemented\")",
  "def get_bounds(self, alpha):\n        return (0, alpha)",
  "def __init__(self, vmobject, **kwargs):\n        self.check_validity_of_input(vmobject)\n        super().__init__(vmobject, **kwargs)",
  "def check_validity_of_input(self, vmobject):\n        if not isinstance(vmobject, VMobject):\n            raise Exception(\"DrawBorderThenFill only works for VMobjects\")",
  "def begin(self):\n        self.outline = self.get_outline()\n        super().begin()",
  "def get_outline(self):\n        outline = self.mobject.copy()\n        outline.set_fill(opacity=0)\n        for sm in outline.family_members_with_points():\n            sm.set_stroke(color=self.get_stroke_color(sm), width=self.stroke_width)\n        return outline",
  "def get_stroke_color(self, vmobject):\n        if self.stroke_color:\n            return self.stroke_color\n        elif vmobject.get_stroke_width() > 0:\n            return vmobject.get_stroke_color()\n        return vmobject.get_color()",
  "def get_all_mobjects(self):\n        return [*super().get_all_mobjects(), self.outline]",
  "def interpolate_submobject(self, submob, start, outline, alpha):\n        index, subalpha = integer_interpolate(0, 2, alpha)\n        if index == 0:\n            submob.pointwise_become_partial(outline, 0, subalpha)\n            submob.match_style(outline)\n        else:\n            submob.interpolate(outline, start, subalpha)",
  "def __init__(self, mobject, **kwargs):\n        digest_config(self, kwargs)\n        self.set_default_config_from_length(mobject)\n        super().__init__(mobject, **kwargs)",
  "def set_default_config_from_length(self, mobject):\n        length = len(mobject.family_members_with_points())\n        if self.run_time is None:\n            if length < 15:\n                self.run_time = 1\n            else:\n                self.run_time = 2\n        if self.lag_ratio is None:\n            self.lag_ratio = min(4.0 / length, 0.2)",
  "def __init__(self, group, **kwargs):\n        self.all_submobs = list(group.submobjects)\n        super().__init__(group, **kwargs)",
  "def interpolate_mobject(self, alpha):\n        n_submobs = len(self.all_submobs)\n        index = int(self.int_func(alpha * n_submobs))\n        self.update_submobject_list(index)",
  "def update_submobject_list(self, index):\n        self.mobject.submobjects = self.all_submobs[:index]",
  "def __init__(self, text, **kwargs):\n        digest_config(self, kwargs)\n\n        self.run_time = np.max((0.06, self.time_per_char)) * len(\n            text\n        )  # Time_per_char must be above 0.06. Otherwise the animation doesn't finish.\n        super().__init__(text, **kwargs)",
  "def __init__(self, group, **kwargs):\n        new_group = Group(*group)\n        super().__init__(new_group, **kwargs)",
  "def update_submobject_list(self, index):\n        # N = len(self.all_submobs)\n        if index == 0:\n            self.mobject.submobjects = []\n        else:\n            self.mobject.submobjects = self.all_submobs[index - 1]",
  "def __init__(self, text_mobject, **kwargs):\n        digest_config(self, kwargs)\n        tpc = self.time_per_char\n        anims = it.chain(\n            *[\n                [\n                    ShowIncreasingSubsets(word, run_time=tpc * len(word)),\n                    Animation(word, run_time=0.005 * len(word) ** 1.5),\n                ]\n                for word in text_mobject\n            ]\n        )\n        super().__init__(*anims, **kwargs)",
  "class Rotating(Animation):\n    CONFIG = {\n        \"axis\": OUT,\n        \"radians\": TAU,\n        \"run_time\": 5,\n        \"rate_func\": linear,\n        \"about_point\": None,\n        \"about_edge\": None,\n    }\n\n    def interpolate_mobject(self, alpha):\n        self.mobject.become(self.starting_mobject)\n        self.mobject.rotate(\n            alpha * self.radians,\n            axis=self.axis,\n            about_point=self.about_point,\n            about_edge=self.about_edge,\n        )",
  "class Rotate(Transform):\n    CONFIG = {\n        \"about_point\": None,\n        \"about_edge\": None,\n    }\n\n    def __init__(self, mobject, angle=PI, axis=OUT, **kwargs):\n        if \"path_arc\" not in kwargs:\n            kwargs[\"path_arc\"] = angle\n        if \"path_arc_axis\" not in kwargs:\n            kwargs[\"path_arc_axis\"] = axis\n        self.angle = angle\n        self.axis = axis\n        super().__init__(mobject, **kwargs)\n\n    def create_target(self):\n        target = self.mobject.copy()\n        target.rotate(\n            self.angle,\n            axis=self.axis,\n            about_point=self.about_point,\n            about_edge=self.about_edge,\n        )\n        return target",
  "def interpolate_mobject(self, alpha):\n        self.mobject.become(self.starting_mobject)\n        self.mobject.rotate(\n            alpha * self.radians,\n            axis=self.axis,\n            about_point=self.about_point,\n            about_edge=self.about_edge,\n        )",
  "def __init__(self, mobject, angle=PI, axis=OUT, **kwargs):\n        if \"path_arc\" not in kwargs:\n            kwargs[\"path_arc\"] = angle\n        if \"path_arc_axis\" not in kwargs:\n            kwargs[\"path_arc_axis\"] = axis\n        self.angle = angle\n        self.axis = axis\n        super().__init__(mobject, **kwargs)",
  "def create_target(self):\n        target = self.mobject.copy()\n        target.rotate(\n            self.angle,\n            axis=self.axis,\n            about_point=self.about_point,\n            about_edge=self.about_edge,\n        )\n        return target",
  "class ChangingDecimal(Animation):\n    CONFIG = {\n        \"suspend_mobject_updating\": False,\n    }\n\n    def __init__(self, decimal_mob, number_update_func, **kwargs):\n        self.check_validity_of_input(decimal_mob)\n        self.yell_about_depricated_configuration(**kwargs)\n        self.number_update_func = number_update_func\n        super().__init__(decimal_mob, **kwargs)\n\n    def check_validity_of_input(self, decimal_mob):\n        if not isinstance(decimal_mob, DecimalNumber):\n            raise Exception(\"ChangingDecimal can only take \" \"in a DecimalNumber\")\n\n    def yell_about_depricated_configuration(self, **kwargs):\n        # Obviously this would optimally be removed at\n        # some point.\n        for attr in [\"tracked_mobject\", \"position_update_func\"]:\n            if attr in kwargs:\n                warnings.warn(\n                    \"\"\"\n                    Don't use {} for ChangingDecimal,\n                    that functionality has been depricated\n                    and you should use a mobject updater\n                    instead\n                \"\"\".format(\n                        attr\n                    )\n                )\n\n    def interpolate_mobject(self, alpha):\n        self.mobject.set_value(self.number_update_func(alpha))",
  "class ChangeDecimalToValue(ChangingDecimal):\n    def __init__(self, decimal_mob, target_number, **kwargs):\n        start_number = decimal_mob.number\n        super().__init__(\n            decimal_mob, lambda a: interpolate(start_number, target_number, a), **kwargs\n        )",
  "def __init__(self, decimal_mob, number_update_func, **kwargs):\n        self.check_validity_of_input(decimal_mob)\n        self.yell_about_depricated_configuration(**kwargs)\n        self.number_update_func = number_update_func\n        super().__init__(decimal_mob, **kwargs)",
  "def check_validity_of_input(self, decimal_mob):\n        if not isinstance(decimal_mob, DecimalNumber):\n            raise Exception(\"ChangingDecimal can only take \" \"in a DecimalNumber\")",
  "def yell_about_depricated_configuration(self, **kwargs):\n        # Obviously this would optimally be removed at\n        # some point.\n        for attr in [\"tracked_mobject\", \"position_update_func\"]:\n            if attr in kwargs:\n                warnings.warn(\n                    \"\"\"\n                    Don't use {} for ChangingDecimal,\n                    that functionality has been depricated\n                    and you should use a mobject updater\n                    instead\n                \"\"\".format(\n                        attr\n                    )\n                )",
  "def interpolate_mobject(self, alpha):\n        self.mobject.set_value(self.number_update_func(alpha))",
  "def __init__(self, decimal_mob, target_number, **kwargs):\n        start_number = decimal_mob.number\n        super().__init__(\n            decimal_mob, lambda a: interpolate(start_number, target_number, a), **kwargs\n        )",
  "class Homotopy(Animation):\n    CONFIG = {\n        \"run_time\": 3,\n        \"apply_function_kwargs\": {},\n    }\n\n    def __init__(self, homotopy, mobject, **kwargs):\n        \"\"\"\n        Homotopy is a function from\n        (x, y, z, t) to (x', y', z')\n        \"\"\"\n        self.homotopy = homotopy\n        super().__init__(mobject, **kwargs)\n\n    def function_at_time_t(self, t):\n        return lambda p: self.homotopy(*p, t)\n\n    def interpolate_submobject(self, submob, start, alpha):\n        submob.points = start.points\n        submob.apply_function(\n            self.function_at_time_t(alpha), **self.apply_function_kwargs\n        )",
  "class SmoothedVectorizedHomotopy(Homotopy):\n    def interpolate_submobject(self, submob, start, alpha):\n        Homotopy.interpolate_submobject(self, submob, start, alpha)\n        submob.make_smooth()",
  "class ComplexHomotopy(Homotopy):\n    def __init__(self, complex_homotopy, mobject, **kwargs):\n        \"\"\"\n        Complex Hootopy a function Cx[0, 1] to C\n        \"\"\"\n\n        def homotopy(x, y, z, t):\n            c = complex_homotopy(complex(x, y), t)\n            return (c.real, c.imag, z)\n\n        Homotopy.__init__(self, homotopy, mobject, **kwargs)",
  "class PhaseFlow(Animation):\n    CONFIG = {\n        \"virtual_time\": 1,\n        \"rate_func\": linear,\n        \"suspend_mobject_updating\": False,\n    }\n\n    def __init__(self, function, mobject, **kwargs):\n        self.function = function\n        super().__init__(mobject, **kwargs)\n\n    def interpolate_mobject(self, alpha):\n        if hasattr(self, \"last_alpha\"):\n            dt = self.virtual_time * (alpha - self.last_alpha)\n            self.mobject.apply_function(lambda p: p + dt * self.function(p))\n        self.last_alpha = alpha",
  "class MoveAlongPath(Animation):\n    CONFIG = {\n        \"suspend_mobject_updating\": False,\n    }\n\n    def __init__(self, mobject, path, **kwargs):\n        self.path = path\n        super().__init__(mobject, **kwargs)\n\n    def interpolate_mobject(self, alpha):\n        point = self.path.point_from_proportion(alpha)\n        self.mobject.move_to(point)",
  "def __init__(self, homotopy, mobject, **kwargs):\n        \"\"\"\n        Homotopy is a function from\n        (x, y, z, t) to (x', y', z')\n        \"\"\"\n        self.homotopy = homotopy\n        super().__init__(mobject, **kwargs)",
  "def function_at_time_t(self, t):\n        return lambda p: self.homotopy(*p, t)",
  "def interpolate_submobject(self, submob, start, alpha):\n        submob.points = start.points\n        submob.apply_function(\n            self.function_at_time_t(alpha), **self.apply_function_kwargs\n        )",
  "def interpolate_submobject(self, submob, start, alpha):\n        Homotopy.interpolate_submobject(self, submob, start, alpha)\n        submob.make_smooth()",
  "def __init__(self, complex_homotopy, mobject, **kwargs):\n        \"\"\"\n        Complex Hootopy a function Cx[0, 1] to C\n        \"\"\"\n\n        def homotopy(x, y, z, t):\n            c = complex_homotopy(complex(x, y), t)\n            return (c.real, c.imag, z)\n\n        Homotopy.__init__(self, homotopy, mobject, **kwargs)",
  "def __init__(self, function, mobject, **kwargs):\n        self.function = function\n        super().__init__(mobject, **kwargs)",
  "def interpolate_mobject(self, alpha):\n        if hasattr(self, \"last_alpha\"):\n            dt = self.virtual_time * (alpha - self.last_alpha)\n            self.mobject.apply_function(lambda p: p + dt * self.function(p))\n        self.last_alpha = alpha",
  "def __init__(self, mobject, path, **kwargs):\n        self.path = path\n        super().__init__(mobject, **kwargs)",
  "def interpolate_mobject(self, alpha):\n        point = self.path.point_from_proportion(alpha)\n        self.mobject.move_to(point)",
  "def homotopy(x, y, z, t):\n            c = complex_homotopy(complex(x, y), t)\n            return (c.real, c.imag, z)",
  "class Transform(Animation):\n    CONFIG = {\n        \"path_arc\": 0,\n        \"path_arc_axis\": OUT,\n        \"path_func\": None,\n        \"replace_mobject_with_target_in_scene\": False,\n    }\n\n    def __init__(self, mobject, target_mobject=None, **kwargs):\n        super().__init__(mobject, **kwargs)\n        self.target_mobject = target_mobject\n        self.init_path_func()\n\n    def init_path_func(self):\n        if self.path_func is not None:\n            return\n        elif self.path_arc == 0:\n            self.path_func = straight_path\n        else:\n            self.path_func = path_along_arc(self.path_arc, self.path_arc_axis,)\n\n    def begin(self):\n        # Use a copy of target_mobject for the align_data\n        # call so that the actual target_mobject stays\n        # preserved.\n        self.target_mobject = self.create_target()\n        self.check_target_mobject_validity()\n        self.target_copy = self.target_mobject.copy()\n        # Note, this potentially changes the structure\n        # of both mobject and target_mobject\n        self.mobject.align_data(self.target_copy)\n        super().begin()\n\n    def create_target(self):\n        # Has no meaningful effect here, but may be useful\n        # in subclasses\n        return self.target_mobject\n\n    def check_target_mobject_validity(self):\n        if self.target_mobject is None:\n            message = \"{}.create_target not properly implemented\"\n            raise Exception(message.format(self.__class__.__name__))\n\n    def clean_up_from_scene(self, scene):\n        super().clean_up_from_scene(scene)\n        if self.replace_mobject_with_target_in_scene:\n            scene.remove(self.mobject)\n            scene.add(self.target_mobject)\n\n    def update_config(self, **kwargs):\n        Animation.update_config(self, **kwargs)\n        if \"path_arc\" in kwargs:\n            self.path_func = path_along_arc(\n                kwargs[\"path_arc\"], kwargs.get(\"path_arc_axis\", OUT)\n            )\n\n    def get_all_mobjects(self):\n        return [\n            self.mobject,\n            self.starting_mobject,\n            self.target_mobject,\n            self.target_copy,\n        ]\n\n    def get_all_families_zipped(self):\n        return zip(\n            *[\n                mob.family_members_with_points()\n                for mob in [self.mobject, self.starting_mobject, self.target_copy,]\n            ]\n        )\n\n    def interpolate_submobject(self, submob, start, target_copy, alpha):\n        submob.interpolate(start, target_copy, alpha, self.path_func)\n        return self",
  "class ReplacementTransform(Transform):\n    CONFIG = {\n        \"replace_mobject_with_target_in_scene\": True,\n    }",
  "class TransformFromCopy(Transform):\n    \"\"\"\n    Performs a reversed Transform\n    \"\"\"\n\n    def __init__(self, mobject, target_mobject, **kwargs):\n        super().__init__(target_mobject, mobject, **kwargs)\n\n    def interpolate(self, alpha):\n        super().interpolate(1 - alpha)",
  "class ClockwiseTransform(Transform):\n    CONFIG = {\"path_arc\": -np.pi}",
  "class CounterclockwiseTransform(Transform):\n    CONFIG = {\"path_arc\": np.pi}",
  "class MoveToTarget(Transform):\n    def __init__(self, mobject, **kwargs):\n        self.check_validity_of_input(mobject)\n        super().__init__(mobject, mobject.target, **kwargs)\n\n    def check_validity_of_input(self, mobject):\n        if not hasattr(mobject, \"target\"):\n            raise Exception(\n                \"MoveToTarget called on mobject\" \"without attribute 'target'\"\n            )",
  "class ApplyMethod(Transform):\n    def __init__(self, method, *args, **kwargs):\n        \"\"\"\n        method is a method of Mobject, *args are arguments for\n        that method.  Key word arguments should be passed in\n        as the last arg, as a dict, since **kwargs is for\n        configuration of the transform itself\n\n        Relies on the fact that mobject methods return the mobject\n        \"\"\"\n        self.check_validity_of_input(method)\n        self.method = method\n        self.method_args = args\n        super().__init__(method.__self__, **kwargs)\n\n    def check_validity_of_input(self, method):\n        if not inspect.ismethod(method):\n            raise Exception(\n                \"Whoops, looks like you accidentally invoked \"\n                \"the method you want to animate\"\n            )\n        assert isinstance(method.__self__, Mobject)\n\n    def create_target(self):\n        method = self.method\n        # Make sure it's a list so that args.pop() works\n        args = list(self.method_args)\n\n        if len(args) > 0 and isinstance(args[-1], dict):\n            method_kwargs = args.pop()\n        else:\n            method_kwargs = {}\n        target = method.__self__.copy()\n        method.__func__(target, *args, **method_kwargs)\n        return target",
  "class ApplyPointwiseFunction(ApplyMethod):\n    CONFIG = {\"run_time\": DEFAULT_POINTWISE_FUNCTION_RUN_TIME}\n\n    def __init__(self, function, mobject, **kwargs):\n        super().__init__(mobject.apply_function, function, **kwargs)",
  "class ApplyPointwiseFunctionToCenter(ApplyPointwiseFunction):\n    def __init__(self, function, mobject, **kwargs):\n        self.function = function\n        super().__init__(mobject.move_to, **kwargs)\n\n    def begin(self):\n        self.method_args = [self.function(self.mobject.get_center())]\n        super().begin()",
  "class FadeToColor(ApplyMethod):\n    def __init__(self, mobject, color, **kwargs):\n        super().__init__(mobject.set_color, color, **kwargs)",
  "class ScaleInPlace(ApplyMethod):\n    def __init__(self, mobject, scale_factor, **kwargs):\n        super().__init__(mobject.scale, scale_factor, **kwargs)",
  "class ShrinkToCenter(ScaleInPlace):\n    def __init__(self, mobject, **kwargs):\n        super().__init__(mobject, 0, **kwargs)",
  "class Restore(ApplyMethod):\n    def __init__(self, mobject, **kwargs):\n        super().__init__(mobject.restore, **kwargs)",
  "class ApplyFunction(Transform):\n    def __init__(self, function, mobject, **kwargs):\n        self.function = function\n        super().__init__(mobject, **kwargs)\n\n    def create_target(self):\n        target = self.function(self.mobject.copy())\n        if not isinstance(target, Mobject):\n            raise Exception(\n                \"Functions passed to ApplyFunction must return object of type Mobject\"\n            )\n        return target",
  "class ApplyMatrix(ApplyPointwiseFunction):\n    def __init__(self, matrix, mobject, **kwargs):\n        matrix = self.initialize_matrix(matrix)\n\n        def func(p):\n            return np.dot(p, matrix.T)\n\n        super().__init__(func, mobject, **kwargs)\n\n    def initialize_matrix(self, matrix):\n        matrix = np.array(matrix)\n        if matrix.shape == (2, 2):\n            new_matrix = np.identity(3)\n            new_matrix[:2, :2] = matrix\n            matrix = new_matrix\n        elif matrix.shape != (3, 3):\n            raise Exception(\"Matrix has bad dimensions\")\n        return matrix",
  "class ApplyComplexFunction(ApplyMethod):\n    def __init__(self, function, mobject, **kwargs):\n        self.function = function\n        method = mobject.apply_complex_function\n        super().__init__(method, function, **kwargs)\n\n    def init_path_func(self):\n        func1 = self.function(complex(1))\n        self.path_arc = np.log(func1).imag\n        super().init_path_func()",
  "class CyclicReplace(Transform):\n    CONFIG = {\n        \"path_arc\": 90 * DEGREES,\n    }\n\n    def __init__(self, *mobjects, **kwargs):\n        self.group = Group(*mobjects)\n        super().__init__(self.group, **kwargs)\n\n    def create_target(self):\n        target = self.group.copy()\n        cycled_targets = [target[-1], *target[:-1]]\n        for m1, m2 in zip(cycled_targets, self.group):\n            m1.move_to(m2)\n        return target",
  "class Swap(CyclicReplace):\n    pass",
  "class TransformAnimations(Transform):\n    CONFIG = {\"rate_func\": squish_rate_func(smooth)}\n\n    def __init__(self, start_anim, end_anim, **kwargs):\n        digest_config(self, kwargs, locals())\n        if \"run_time\" in kwargs:\n            self.run_time = kwargs.pop(\"run_time\")\n        else:\n            self.run_time = max(start_anim.run_time, end_anim.run_time)\n        for anim in start_anim, end_anim:\n            anim.set_run_time(self.run_time)\n\n        if (\n            start_anim.starting_mobject.get_num_points()\n            != end_anim.starting_mobject.get_num_points()\n        ):\n            start_anim.starting_mobject.align_data(end_anim.starting_mobject)\n            for anim in start_anim, end_anim:\n                if hasattr(anim, \"target_mobject\"):\n                    anim.starting_mobject.align_data(anim.target_mobject)\n\n        Transform.__init__(self, start_anim.mobject, end_anim.mobject, **kwargs)\n        # Rewire starting and ending mobjects\n        start_anim.mobject = self.starting_mobject\n        end_anim.mobject = self.target_mobject\n\n    def interpolate(self, alpha):\n        self.start_anim.interpolate(alpha)\n        self.end_anim.interpolate(alpha)\n        Transform.interpolate(self, alpha)",
  "def __init__(self, mobject, target_mobject=None, **kwargs):\n        super().__init__(mobject, **kwargs)\n        self.target_mobject = target_mobject\n        self.init_path_func()",
  "def init_path_func(self):\n        if self.path_func is not None:\n            return\n        elif self.path_arc == 0:\n            self.path_func = straight_path\n        else:\n            self.path_func = path_along_arc(self.path_arc, self.path_arc_axis,)",
  "def begin(self):\n        # Use a copy of target_mobject for the align_data\n        # call so that the actual target_mobject stays\n        # preserved.\n        self.target_mobject = self.create_target()\n        self.check_target_mobject_validity()\n        self.target_copy = self.target_mobject.copy()\n        # Note, this potentially changes the structure\n        # of both mobject and target_mobject\n        self.mobject.align_data(self.target_copy)\n        super().begin()",
  "def create_target(self):\n        # Has no meaningful effect here, but may be useful\n        # in subclasses\n        return self.target_mobject",
  "def check_target_mobject_validity(self):\n        if self.target_mobject is None:\n            message = \"{}.create_target not properly implemented\"\n            raise Exception(message.format(self.__class__.__name__))",
  "def clean_up_from_scene(self, scene):\n        super().clean_up_from_scene(scene)\n        if self.replace_mobject_with_target_in_scene:\n            scene.remove(self.mobject)\n            scene.add(self.target_mobject)",
  "def update_config(self, **kwargs):\n        Animation.update_config(self, **kwargs)\n        if \"path_arc\" in kwargs:\n            self.path_func = path_along_arc(\n                kwargs[\"path_arc\"], kwargs.get(\"path_arc_axis\", OUT)\n            )",
  "def get_all_mobjects(self):\n        return [\n            self.mobject,\n            self.starting_mobject,\n            self.target_mobject,\n            self.target_copy,\n        ]",
  "def get_all_families_zipped(self):\n        return zip(\n            *[\n                mob.family_members_with_points()\n                for mob in [self.mobject, self.starting_mobject, self.target_copy,]\n            ]\n        )",
  "def interpolate_submobject(self, submob, start, target_copy, alpha):\n        submob.interpolate(start, target_copy, alpha, self.path_func)\n        return self",
  "def __init__(self, mobject, target_mobject, **kwargs):\n        super().__init__(target_mobject, mobject, **kwargs)",
  "def interpolate(self, alpha):\n        super().interpolate(1 - alpha)",
  "def __init__(self, mobject, **kwargs):\n        self.check_validity_of_input(mobject)\n        super().__init__(mobject, mobject.target, **kwargs)",
  "def check_validity_of_input(self, mobject):\n        if not hasattr(mobject, \"target\"):\n            raise Exception(\n                \"MoveToTarget called on mobject\" \"without attribute 'target'\"\n            )",
  "def __init__(self, method, *args, **kwargs):\n        \"\"\"\n        method is a method of Mobject, *args are arguments for\n        that method.  Key word arguments should be passed in\n        as the last arg, as a dict, since **kwargs is for\n        configuration of the transform itself\n\n        Relies on the fact that mobject methods return the mobject\n        \"\"\"\n        self.check_validity_of_input(method)\n        self.method = method\n        self.method_args = args\n        super().__init__(method.__self__, **kwargs)",
  "def check_validity_of_input(self, method):\n        if not inspect.ismethod(method):\n            raise Exception(\n                \"Whoops, looks like you accidentally invoked \"\n                \"the method you want to animate\"\n            )\n        assert isinstance(method.__self__, Mobject)",
  "def create_target(self):\n        method = self.method\n        # Make sure it's a list so that args.pop() works\n        args = list(self.method_args)\n\n        if len(args) > 0 and isinstance(args[-1], dict):\n            method_kwargs = args.pop()\n        else:\n            method_kwargs = {}\n        target = method.__self__.copy()\n        method.__func__(target, *args, **method_kwargs)\n        return target",
  "def __init__(self, function, mobject, **kwargs):\n        super().__init__(mobject.apply_function, function, **kwargs)",
  "def __init__(self, function, mobject, **kwargs):\n        self.function = function\n        super().__init__(mobject.move_to, **kwargs)",
  "def begin(self):\n        self.method_args = [self.function(self.mobject.get_center())]\n        super().begin()",
  "def __init__(self, mobject, color, **kwargs):\n        super().__init__(mobject.set_color, color, **kwargs)",
  "def __init__(self, mobject, scale_factor, **kwargs):\n        super().__init__(mobject.scale, scale_factor, **kwargs)",
  "def __init__(self, mobject, **kwargs):\n        super().__init__(mobject, 0, **kwargs)",
  "def __init__(self, mobject, **kwargs):\n        super().__init__(mobject.restore, **kwargs)",
  "def __init__(self, function, mobject, **kwargs):\n        self.function = function\n        super().__init__(mobject, **kwargs)",
  "def create_target(self):\n        target = self.function(self.mobject.copy())\n        if not isinstance(target, Mobject):\n            raise Exception(\n                \"Functions passed to ApplyFunction must return object of type Mobject\"\n            )\n        return target",
  "def __init__(self, matrix, mobject, **kwargs):\n        matrix = self.initialize_matrix(matrix)\n\n        def func(p):\n            return np.dot(p, matrix.T)\n\n        super().__init__(func, mobject, **kwargs)",
  "def initialize_matrix(self, matrix):\n        matrix = np.array(matrix)\n        if matrix.shape == (2, 2):\n            new_matrix = np.identity(3)\n            new_matrix[:2, :2] = matrix\n            matrix = new_matrix\n        elif matrix.shape != (3, 3):\n            raise Exception(\"Matrix has bad dimensions\")\n        return matrix",
  "def __init__(self, function, mobject, **kwargs):\n        self.function = function\n        method = mobject.apply_complex_function\n        super().__init__(method, function, **kwargs)",
  "def init_path_func(self):\n        func1 = self.function(complex(1))\n        self.path_arc = np.log(func1).imag\n        super().init_path_func()",
  "def __init__(self, *mobjects, **kwargs):\n        self.group = Group(*mobjects)\n        super().__init__(self.group, **kwargs)",
  "def create_target(self):\n        target = self.group.copy()\n        cycled_targets = [target[-1], *target[:-1]]\n        for m1, m2 in zip(cycled_targets, self.group):\n            m1.move_to(m2)\n        return target",
  "def __init__(self, start_anim, end_anim, **kwargs):\n        digest_config(self, kwargs, locals())\n        if \"run_time\" in kwargs:\n            self.run_time = kwargs.pop(\"run_time\")\n        else:\n            self.run_time = max(start_anim.run_time, end_anim.run_time)\n        for anim in start_anim, end_anim:\n            anim.set_run_time(self.run_time)\n\n        if (\n            start_anim.starting_mobject.get_num_points()\n            != end_anim.starting_mobject.get_num_points()\n        ):\n            start_anim.starting_mobject.align_data(end_anim.starting_mobject)\n            for anim in start_anim, end_anim:\n                if hasattr(anim, \"target_mobject\"):\n                    anim.starting_mobject.align_data(anim.target_mobject)\n\n        Transform.__init__(self, start_anim.mobject, end_anim.mobject, **kwargs)\n        # Rewire starting and ending mobjects\n        start_anim.mobject = self.starting_mobject\n        end_anim.mobject = self.target_mobject",
  "def interpolate(self, alpha):\n        self.start_anim.interpolate(alpha)\n        self.end_anim.interpolate(alpha)\n        Transform.interpolate(self, alpha)",
  "def func(p):\n            return np.dot(p, matrix.T)",
  "class Animation(object):\n    CONFIG = {\n        \"run_time\": DEFAULT_ANIMATION_RUN_TIME,\n        \"rate_func\": smooth,\n        \"name\": None,\n        # Does this animation add or remove a mobject form the screen\n        \"remover\": False,\n        # If 0, the animation is applied to all submobjects\n        # at the same time\n        # If 1, it is applied to each successively.\n        # If 0 < lag_ratio < 1, its applied to each\n        # with lagged start times\n        \"lag_ratio\": DEFAULT_ANIMATION_LAG_RATIO,\n        \"suspend_mobject_updating\": True,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        assert isinstance(mobject, Mobject)\n        digest_config(self, kwargs)\n        self.mobject = mobject\n\n    def __str__(self):\n        if self.name:\n            return self.name\n        return self.__class__.__name__ + str(self.mobject)\n\n    def begin(self):\n        # This is called right as an animation is being\n        # played.  As much initialization as possible,\n        # especially any mobject copying, should live in\n        # this method\n        self.starting_mobject = self.create_starting_mobject()\n        if self.suspend_mobject_updating:\n            # All calls to self.mobject's internal updaters\n            # during the animation, either from this Animation\n            # or from the surrounding scene, should do nothing.\n            # It is, however, okay and desirable to call\n            # the internal updaters of self.starting_mobject,\n            # or any others among self.get_all_mobjects()\n            self.mobject.suspend_updating()\n        self.interpolate(0)\n\n    def finish(self):\n        self.interpolate(1)\n        if self.suspend_mobject_updating:\n            self.mobject.resume_updating()\n\n    def clean_up_from_scene(self, scene):\n        if self.is_remover():\n            scene.remove(self.mobject)\n\n    def create_starting_mobject(self):\n        # Keep track of where the mobject starts\n        return self.mobject.copy()\n\n    def get_all_mobjects(self):\n        \"\"\"\n        Ordering must match the ording of arguments to interpolate_submobject\n        \"\"\"\n        return self.mobject, self.starting_mobject\n\n    def get_all_families_zipped(self):\n        return zip(\n            *[mob.family_members_with_points() for mob in self.get_all_mobjects()]\n        )\n\n    def update_mobjects(self, dt):\n        \"\"\"\n        Updates things like starting_mobject, and (for\n        Transforms) target_mobject.  Note, since typically\n        (always?) self.mobject will have its updating\n        suspended during the animation, this will do\n        nothing to self.mobject.\n        \"\"\"\n        for mob in self.get_all_mobjects_to_update():\n            mob.update(dt)\n\n    def get_all_mobjects_to_update(self):\n        # The surrounding scene typically handles\n        # updating of self.mobject.  Besides, in\n        # most cases its updating is suspended anyway\n        return list(filter(lambda m: m is not self.mobject, self.get_all_mobjects()))\n\n    def copy(self):\n        return deepcopy(self)\n\n    def update_config(self, **kwargs):\n        digest_config(self, kwargs)\n        return self\n\n    # Methods for interpolation, the mean of an Animation\n    def interpolate(self, alpha):\n        alpha = np.clip(alpha, 0, 1)\n        self.interpolate_mobject(self.rate_func(alpha))\n\n    def update(self, alpha):\n        \"\"\"\n        This method shouldn't exist, but it's here to\n        keep many old scenes from breaking\n        \"\"\"\n        self.interpolate(alpha)\n\n    def interpolate_mobject(self, alpha):\n        families = list(self.get_all_families_zipped())\n        for i, mobs in enumerate(families):\n            sub_alpha = self.get_sub_alpha(alpha, i, len(families))\n            self.interpolate_submobject(*mobs, sub_alpha)\n\n    def interpolate_submobject(self, submobject, starting_sumobject, alpha):\n        # Typically ipmlemented by subclass\n        pass\n\n    def get_sub_alpha(self, alpha, index, num_submobjects):\n        # TODO, make this more understanable, and/or combine\n        # its functionality with AnimationGroup's method\n        # build_animations_with_timings\n        lag_ratio = self.lag_ratio\n        full_length = (num_submobjects - 1) * lag_ratio + 1\n        value = alpha * full_length\n        lower = index * lag_ratio\n        return np.clip((value - lower), 0, 1)\n\n    # Getters and setters\n    def set_run_time(self, run_time):\n        self.run_time = run_time\n        return self\n\n    def get_run_time(self):\n        return self.run_time\n\n    def set_rate_func(self, rate_func):\n        self.rate_func = rate_func\n        return self\n\n    def get_rate_func(self):\n        return self.rate_func\n\n    def set_name(self, name):\n        self.name = name\n        return self\n\n    def is_remover(self):\n        return self.remover",
  "def __init__(self, mobject, **kwargs):\n        assert isinstance(mobject, Mobject)\n        digest_config(self, kwargs)\n        self.mobject = mobject",
  "def __str__(self):\n        if self.name:\n            return self.name\n        return self.__class__.__name__ + str(self.mobject)",
  "def begin(self):\n        # This is called right as an animation is being\n        # played.  As much initialization as possible,\n        # especially any mobject copying, should live in\n        # this method\n        self.starting_mobject = self.create_starting_mobject()\n        if self.suspend_mobject_updating:\n            # All calls to self.mobject's internal updaters\n            # during the animation, either from this Animation\n            # or from the surrounding scene, should do nothing.\n            # It is, however, okay and desirable to call\n            # the internal updaters of self.starting_mobject,\n            # or any others among self.get_all_mobjects()\n            self.mobject.suspend_updating()\n        self.interpolate(0)",
  "def finish(self):\n        self.interpolate(1)\n        if self.suspend_mobject_updating:\n            self.mobject.resume_updating()",
  "def clean_up_from_scene(self, scene):\n        if self.is_remover():\n            scene.remove(self.mobject)",
  "def create_starting_mobject(self):\n        # Keep track of where the mobject starts\n        return self.mobject.copy()",
  "def get_all_mobjects(self):\n        \"\"\"\n        Ordering must match the ording of arguments to interpolate_submobject\n        \"\"\"\n        return self.mobject, self.starting_mobject",
  "def get_all_families_zipped(self):\n        return zip(\n            *[mob.family_members_with_points() for mob in self.get_all_mobjects()]\n        )",
  "def update_mobjects(self, dt):\n        \"\"\"\n        Updates things like starting_mobject, and (for\n        Transforms) target_mobject.  Note, since typically\n        (always?) self.mobject will have its updating\n        suspended during the animation, this will do\n        nothing to self.mobject.\n        \"\"\"\n        for mob in self.get_all_mobjects_to_update():\n            mob.update(dt)",
  "def get_all_mobjects_to_update(self):\n        # The surrounding scene typically handles\n        # updating of self.mobject.  Besides, in\n        # most cases its updating is suspended anyway\n        return list(filter(lambda m: m is not self.mobject, self.get_all_mobjects()))",
  "def copy(self):\n        return deepcopy(self)",
  "def update_config(self, **kwargs):\n        digest_config(self, kwargs)\n        return self",
  "def interpolate(self, alpha):\n        alpha = np.clip(alpha, 0, 1)\n        self.interpolate_mobject(self.rate_func(alpha))",
  "def update(self, alpha):\n        \"\"\"\n        This method shouldn't exist, but it's here to\n        keep many old scenes from breaking\n        \"\"\"\n        self.interpolate(alpha)",
  "def interpolate_mobject(self, alpha):\n        families = list(self.get_all_families_zipped())\n        for i, mobs in enumerate(families):\n            sub_alpha = self.get_sub_alpha(alpha, i, len(families))\n            self.interpolate_submobject(*mobs, sub_alpha)",
  "def interpolate_submobject(self, submobject, starting_sumobject, alpha):\n        # Typically ipmlemented by subclass\n        pass",
  "def get_sub_alpha(self, alpha, index, num_submobjects):\n        # TODO, make this more understanable, and/or combine\n        # its functionality with AnimationGroup's method\n        # build_animations_with_timings\n        lag_ratio = self.lag_ratio\n        full_length = (num_submobjects - 1) * lag_ratio + 1\n        value = alpha * full_length\n        lower = index * lag_ratio\n        return np.clip((value - lower), 0, 1)",
  "def set_run_time(self, run_time):\n        self.run_time = run_time\n        return self",
  "def get_run_time(self):\n        return self.run_time",
  "def set_rate_func(self, rate_func):\n        self.rate_func = rate_func\n        return self",
  "def get_rate_func(self):\n        return self.rate_func",
  "def set_name(self, name):\n        self.name = name\n        return self",
  "def is_remover(self):\n        return self.remover",
  "class FadeOut(Transform):\n    CONFIG = {\n        \"remover\": True,\n        \"lag_ratio\": DEFAULT_FADE_LAG_RATIO,\n    }\n\n    def create_target(self):\n        return self.mobject.copy().fade(1)\n\n    def clean_up_from_scene(self, scene=None):\n        super().clean_up_from_scene(scene)\n        self.interpolate(0)",
  "class FadeIn(Transform):\n    CONFIG = {\n        \"lag_ratio\": DEFAULT_FADE_LAG_RATIO,\n    }\n\n    def create_target(self):\n        return self.mobject\n\n    def create_starting_mobject(self):\n        start = super().create_starting_mobject()\n        start.fade(1)\n        if isinstance(start, VMobject):\n            start.set_stroke(width=0)\n            start.set_fill(opacity=0)\n        return start",
  "class FadeInFrom(Transform):\n    CONFIG = {\n        \"direction\": DOWN,\n        \"lag_ratio\": DEFAULT_ANIMATION_LAG_RATIO,\n    }\n\n    def __init__(self, mobject, direction=None, **kwargs):\n        if direction is not None:\n            self.direction = direction\n        super().__init__(mobject, **kwargs)\n\n    def create_target(self):\n        return self.mobject.copy()\n\n    def begin(self):\n        super().begin()\n        self.starting_mobject.shift(self.direction)\n        self.starting_mobject.fade(1)",
  "class FadeInFromDown(FadeInFrom):\n    \"\"\"\n    Identical to FadeInFrom, just with a name that\n    communicates the default\n    \"\"\"\n\n    CONFIG = {\n        \"direction\": DOWN,\n        \"lag_ratio\": DEFAULT_ANIMATION_LAG_RATIO,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        super().__init__(mobject, direction=DOWN, **kwargs)\n        logger.warning(\n            \"FadeInFromDown is deprecated and will eventually disappear. Please use FadeInFrom(<mobject>, direction=DOWN, <other_args>) instead.\"\n        )",
  "class FadeOutAndShift(FadeOut):\n    CONFIG = {\n        \"direction\": DOWN,\n    }\n\n    def __init__(self, mobject, direction=None, **kwargs):\n        if direction is not None:\n            self.direction = direction\n        super().__init__(mobject, **kwargs)\n\n    def create_target(self):\n        target = super().create_target()\n        target.shift(self.direction)\n        return target",
  "class FadeOutAndShiftDown(FadeOutAndShift):\n    \"\"\"\n    Identical to FadeOutAndShift, just with a name that\n    communicates the default\n    \"\"\"\n\n    CONFIG = {\n        \"direction\": DOWN,\n    }\n\n    def __init__(self, mobject, **kwargs):\n        super().__init__(mobject, direction=DOWN, **kwargs)\n        logger.warning(\n            \"FadeOutAndShiftDown is deprecated and will eventually disappear. Please use FadeOutAndShift(<mobject>, direction=DOWN, <other_args>) instead.\"\n        )",
  "class FadeInFromPoint(FadeIn):\n    def __init__(self, mobject, point, **kwargs):\n        self.point = point\n        super().__init__(mobject, **kwargs)\n\n    def create_starting_mobject(self):\n        start = super().create_starting_mobject()\n        start.scale(0)\n        start.move_to(self.point)\n        return start",
  "class FadeInFromLarge(FadeIn):\n    CONFIG = {\n        \"scale_factor\": 2,\n    }\n\n    def __init__(self, mobject, scale_factor=2, **kwargs):\n        if scale_factor is not None:\n            self.scale_factor = scale_factor\n        super().__init__(mobject, **kwargs)\n\n    def create_starting_mobject(self):\n        start = super().create_starting_mobject()\n        start.scale(self.scale_factor)\n        return start",
  "class VFadeIn(Animation):\n    \"\"\"\n    VFadeIn and VFadeOut only work for VMobjects,\n    \"\"\"\n\n    CONFIG = {\n        \"suspend_mobject_updating\": False,\n    }\n\n    def interpolate_submobject(self, submob, start, alpha):\n        submob.set_stroke(opacity=interpolate(0, start.get_stroke_opacity(), alpha))\n        submob.set_fill(opacity=interpolate(0, start.get_fill_opacity(), alpha))",
  "class VFadeOut(VFadeIn):\n    CONFIG = {\"remover\": True}\n\n    def interpolate_submobject(self, submob, start, alpha):\n        super().interpolate_submobject(submob, start, 1 - alpha)",
  "class VFadeInThenOut(VFadeIn):\n    CONFIG = {\n        \"rate_func\": there_and_back,\n        \"remover\": True,\n    }",
  "def create_target(self):\n        return self.mobject.copy().fade(1)",
  "def clean_up_from_scene(self, scene=None):\n        super().clean_up_from_scene(scene)\n        self.interpolate(0)",
  "def create_target(self):\n        return self.mobject",
  "def create_starting_mobject(self):\n        start = super().create_starting_mobject()\n        start.fade(1)\n        if isinstance(start, VMobject):\n            start.set_stroke(width=0)\n            start.set_fill(opacity=0)\n        return start",
  "def __init__(self, mobject, direction=None, **kwargs):\n        if direction is not None:\n            self.direction = direction\n        super().__init__(mobject, **kwargs)",
  "def create_target(self):\n        return self.mobject.copy()",
  "def begin(self):\n        super().begin()\n        self.starting_mobject.shift(self.direction)\n        self.starting_mobject.fade(1)",
  "def __init__(self, mobject, **kwargs):\n        super().__init__(mobject, direction=DOWN, **kwargs)\n        logger.warning(\n            \"FadeInFromDown is deprecated and will eventually disappear. Please use FadeInFrom(<mobject>, direction=DOWN, <other_args>) instead.\"\n        )",
  "def __init__(self, mobject, direction=None, **kwargs):\n        if direction is not None:\n            self.direction = direction\n        super().__init__(mobject, **kwargs)",
  "def create_target(self):\n        target = super().create_target()\n        target.shift(self.direction)\n        return target",
  "def __init__(self, mobject, **kwargs):\n        super().__init__(mobject, direction=DOWN, **kwargs)\n        logger.warning(\n            \"FadeOutAndShiftDown is deprecated and will eventually disappear. Please use FadeOutAndShift(<mobject>, direction=DOWN, <other_args>) instead.\"\n        )",
  "def __init__(self, mobject, point, **kwargs):\n        self.point = point\n        super().__init__(mobject, **kwargs)",
  "def create_starting_mobject(self):\n        start = super().create_starting_mobject()\n        start.scale(0)\n        start.move_to(self.point)\n        return start",
  "def __init__(self, mobject, scale_factor=2, **kwargs):\n        if scale_factor is not None:\n            self.scale_factor = scale_factor\n        super().__init__(mobject, **kwargs)",
  "def create_starting_mobject(self):\n        start = super().create_starting_mobject()\n        start.scale(self.scale_factor)\n        return start",
  "def interpolate_submobject(self, submob, start, alpha):\n        submob.set_stroke(opacity=interpolate(0, start.get_stroke_opacity(), alpha))\n        submob.set_fill(opacity=interpolate(0, start.get_fill_opacity(), alpha))",
  "def interpolate_submobject(self, submob, start, alpha):\n        super().interpolate_submobject(submob, start, 1 - alpha)",
  "class Container(object):\n    \"\"\"\n    Base class for Scenes and Mobjects. Generic container.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n\n    def add(self, *items):\n        \"\"\"\n        Generic method to add items to Container.\n        Must be implemented by subclasses.\n        \"\"\"\n        raise Exception(\n            \"Container.add is not implemented; it is up to derived classes to implement\"\n        )\n\n    def remove(self, *items):\n        \"\"\"\n        Generic method to remove items from Container.\n        Must be implemented by subclasses.\n        \"\"\"\n        raise Exception(\n            \"Container.remove is not implemented; it is up to derived classes to implement\"\n        )",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)",
  "def add(self, *items):\n        \"\"\"\n        Generic method to add items to Container.\n        Must be implemented by subclasses.\n        \"\"\"\n        raise Exception(\n            \"Container.add is not implemented; it is up to derived classes to implement\"\n        )",
  "def remove(self, *items):\n        \"\"\"\n        Generic method to remove items from Container.\n        Must be implemented by subclasses.\n        \"\"\"\n        raise Exception(\n            \"Container.remove is not implemented; it is up to derived classes to implement\"\n        )",
  "def add_extension_if_not_present(file_name, extension):\n    # This could conceivably be smarter about handling existing differing extensions\n    if file_name[-len(extension) :] != extension:\n        return file_name + extension\n    else:\n        return file_name",
  "def guarantee_existence(path):\n    if not os.path.exists(path):\n        os.makedirs(path)\n    return os.path.abspath(path)",
  "def seek_full_path_from_defaults(file_name, default_dir, extensions):\n    possible_paths = [file_name]\n    possible_paths += [\n        os.path.join(default_dir, file_name + extension)\n        for extension in [\"\", *extensions]\n    ]\n    for path in possible_paths:\n        if os.path.exists(path):\n            return path\n    raise IOError(\"File {} not Found\".format(file_name))",
  "def get_sorted_integer_files(\n    directory,\n    min_index=0,\n    max_index=np.inf,\n    remove_non_integer_files=False,\n    remove_indices_greater_than=None,\n    extension=None,\n):\n    indexed_files = []\n    for file in os.listdir(directory):\n        if \".\" in file:\n            index_str = file[: file.index(\".\")]\n        else:\n            index_str = file\n\n        full_path = os.path.join(directory, file)\n        if index_str.isdigit():\n            index = int(index_str)\n            if remove_indices_greater_than is not None:\n                if index > remove_indices_greater_than:\n                    os.remove(full_path)\n                    continue\n            if extension is not None and not file.endswith(extension):\n                continue\n            if index >= min_index and index < max_index:\n                indexed_files.append((index, file))\n        elif remove_non_integer_files:\n            os.remove(full_path)\n    indexed_files.sort(key=lambda p: p[0])\n    return list(map(lambda p: os.path.join(directory, p[1]), indexed_files))",
  "def bezier(points):\n    n = len(points) - 1\n    return lambda t: sum(\n        [\n            ((1 - t) ** (n - k)) * (t ** k) * choose(n, k) * point\n            for k, point in enumerate(points)\n        ]\n    )",
  "def partial_bezier_points(points, a, b):\n    \"\"\"\n    Given an array of points which define\n    a bezier curve, and two numbers 0<=a<b<=1,\n    return an array of the same size, which\n    describes the portion of the original bezier\n    curve on the interval [a, b].\n\n    This algorithm is pretty nifty, and pretty dense.\n    \"\"\"\n    if a == 1:\n        return [points[-1]] * len(points)\n\n    a_to_1 = np.array([bezier(points[i:])(a) for i in range(len(points))])\n    end_prop = (b - a) / (1.0 - a)\n    return np.array([bezier(a_to_1[: i + 1])(end_prop) for i in range(len(points))])",
  "def interpolate(start, end, alpha):\n    return (1 - alpha) * start + alpha * end",
  "def integer_interpolate(start, end, alpha):\n    \"\"\"\n    alpha is a float between 0 and 1.  This returns\n    an integer between start and end (inclusive) representing\n    appropriate interpolation between them, along with a\n    \"residue\" representing a new proportion between the\n    returned integer and the next one of the\n    list.\n\n    For example, if start=0, end=10, alpha=0.46, This\n    would return (4, 0.6).\n    \"\"\"\n    if alpha >= 1:\n        return (end - 1, 1.0)\n    if alpha <= 0:\n        return (start, 0)\n    value = int(interpolate(start, end, alpha))\n    residue = ((end - start) * alpha) % 1\n    return (value, residue)",
  "def mid(start, end):\n    return (start + end) / 2.0",
  "def inverse_interpolate(start, end, value):\n    return np.true_divide(value - start, end - start)",
  "def match_interpolate(new_start, new_end, old_start, old_end, old_value):\n    return interpolate(\n        new_start, new_end, inverse_interpolate(old_start, old_end, old_value)\n    )",
  "def get_smooth_handle_points(points):\n    points = np.array(points)\n    num_handles = len(points) - 1\n    dim = points.shape[1]\n    if num_handles < 1:\n        return np.zeros((0, dim)), np.zeros((0, dim))\n    # Must solve 2*num_handles equations to get the handles.\n    # l and u are the number of lower an upper diagonal rows\n    # in the matrix to solve.\n    l, u = 2, 1\n    # diag is a representation of the matrix in diagonal form\n    # See https://www.particleincell.com/2012/bezier-splines/\n    # for how to arive at these equations\n    diag = np.zeros((l + u + 1, 2 * num_handles))\n    diag[0, 1::2] = -1\n    diag[0, 2::2] = 1\n    diag[1, 0::2] = 2\n    diag[1, 1::2] = 1\n    diag[2, 1:-2:2] = -2\n    diag[3, 0:-3:2] = 1\n    # last\n    diag[2, -2] = -1\n    diag[1, -1] = 2\n    # This is the b as in Ax = b, where we are solving for x,\n    # and A is represented using diag.  However, think of entries\n    # to x and b as being points in space, not numbers\n    b = np.zeros((2 * num_handles, dim))\n    b[1::2] = 2 * points[1:]\n    b[0] = points[0]\n    b[-1] = points[-1]\n\n    def solve_func(b):\n        return linalg.solve_banded((l, u), diag, b)\n\n    use_closed_solve_function = is_closed(points)\n    if use_closed_solve_function:\n        # Get equations to relate first and last points\n        matrix = diag_to_matrix((l, u), diag)\n        # last row handles second derivative\n        matrix[-1, [0, 1, -2, -1]] = [2, -1, 1, -2]\n        # first row handles first derivative\n        matrix[0, :] = np.zeros(matrix.shape[1])\n        matrix[0, [0, -1]] = [1, 1]\n        b[0] = 2 * points[0]\n        b[-1] = np.zeros(dim)\n\n        def closed_curve_solve_func(b):\n            return linalg.solve(matrix, b)\n\n    handle_pairs = np.zeros((2 * num_handles, dim))\n    for i in range(dim):\n        if use_closed_solve_function:\n            handle_pairs[:, i] = closed_curve_solve_func(b[:, i])\n        else:\n            handle_pairs[:, i] = solve_func(b[:, i])\n    return handle_pairs[0::2], handle_pairs[1::2]",
  "def diag_to_matrix(l_and_u, diag):\n    \"\"\"\n    Converts array whose rows represent diagonal\n    entries of a matrix into the matrix itself.\n    See scipy.linalg.solve_banded\n    \"\"\"\n    l, u = l_and_u\n    dim = diag.shape[1]\n    matrix = np.zeros((dim, dim))\n    for i in range(l + u + 1):\n        np.fill_diagonal(\n            matrix[max(0, i - u) :, max(0, u - i) :], diag[i, max(0, u - i) :]\n        )\n    return matrix",
  "def is_closed(points):\n    return np.allclose(points[0], points[-1])",
  "def solve_func(b):\n        return linalg.solve_banded((l, u), diag, b)",
  "def closed_curve_solve_func(b):\n            return linalg.solve(matrix, b)",
  "def print_family(mobject, n_tabs=0):\n    \"\"\"For debugging purposes\"\"\"\n    print(\"\\t\" * n_tabs, mobject, id(mobject))\n    for submob in mobject.submobjects:\n        print_family(submob, n_tabs + 1)",
  "def get_submobject_index_labels(mobject, label_height=0.15):\n    labels = VGroup()\n    for n, submob in enumerate(mobject):\n        label = Integer(n)\n        label.set_height(label_height)\n        label.move_to(submob)\n        label.set_stroke(BLACK, 5, background=True)\n        labels.add(label)\n    return labels",
  "def get_all_descendent_classes(Class):\n    awaiting_review = [Class]\n    result = []\n    while awaiting_review:\n        Child = awaiting_review.pop()\n        awaiting_review += Child.__subclasses__()\n        result.append(Child)\n    return result",
  "def filtered_locals(caller_locals):\n    result = caller_locals.copy()\n    ignored_local_args = [\"self\", \"kwargs\"]\n    for arg in ignored_local_args:\n        result.pop(arg, caller_locals)\n    return result",
  "def digest_config(obj, kwargs, caller_locals={}):\n    \"\"\"\n    Sets init args and CONFIG values as local variables\n\n    The purpose of this function is to ensure that all\n    configuration of any object is inheritable, able to\n    be easily passed into instantiation, and is attached\n    as an attribute of the object.\n    \"\"\"\n\n    # Assemble list of CONFIGs from all super classes\n    classes_in_hierarchy = [obj.__class__]\n    static_configs = []\n    while len(classes_in_hierarchy) > 0:\n        Class = classes_in_hierarchy.pop()\n        classes_in_hierarchy += Class.__bases__\n        if hasattr(Class, \"CONFIG\"):\n            static_configs.append(Class.CONFIG)\n\n    # Order matters a lot here, first dicts have higher priority\n    caller_locals = filtered_locals(caller_locals)\n    all_dicts = [kwargs, caller_locals, obj.__dict__]\n    all_dicts += static_configs\n    obj.__dict__ = merge_dicts_recursively(*reversed(all_dicts))",
  "def merge_dicts_recursively(*dicts):\n    \"\"\"\n    Creates a dict whose keyset is the union of all the\n    input dictionaries.  The value for each key is based\n    on the first dict in the list with that key.\n\n    dicts later in the list have higher priority\n\n    When values are dictionaries, it is applied recursively\n    \"\"\"\n    result = dict()\n    all_items = it.chain(*[d.items() for d in dicts])\n    for key, value in all_items:\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = merge_dicts_recursively(result[key], value)\n        else:\n            result[key] = value\n    return result",
  "def soft_dict_update(d1, d2):\n    \"\"\"\n    Adds key values pairs of d2 to d1 only when d1 doesn't\n    already have that key\n    \"\"\"\n    for key, value in list(d2.items()):\n        if key not in d1:\n            d1[key] = value",
  "def digest_locals(obj, keys=None):\n    caller_locals = filtered_locals(inspect.currentframe().f_back.f_locals)\n    if keys is None:\n        keys = list(caller_locals.keys())\n    for key in keys:\n        setattr(obj, key, caller_locals[key])",
  "class DictAsObject(object):\n    def __init__(self, dict):\n        self.__dict__ = dict",
  "def __init__(self, dict):\n        self.__dict__ = dict",
  "def get_norm(vect):\n    return sum([x ** 2 for x in vect]) ** 0.5",
  "def quaternion_mult(q1, q2):\n    w1, x1, y1, z1 = q1\n    w2, x2, y2, z2 = q2\n    return np.array(\n        [\n            w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2,\n            w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2,\n            w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2,\n            w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2,\n        ]\n    )",
  "def quaternion_from_angle_axis(angle, axis):\n    return np.append(np.cos(angle / 2), np.sin(angle / 2) * normalize(axis))",
  "def angle_axis_from_quaternion(quaternion):\n    axis = normalize(quaternion[1:], fall_back=np.array([1, 0, 0]))\n    angle = 2 * np.arccos(quaternion[0])\n    if angle > TAU / 2:\n        angle = TAU - angle\n    return angle, axis",
  "def quaternion_conjugate(quaternion):\n    result = np.array(quaternion)\n    result[1:] *= -1\n    return result",
  "def rotate_vector(vector, angle, axis=OUT):\n    if len(vector) == 2:\n        # Use complex numbers...because why not\n        z = complex(*vector) * np.exp(complex(0, angle))\n        return np.array([z.real, z.imag])\n    elif len(vector) == 3:\n        # Use quaternions...because why not\n        quat = quaternion_from_angle_axis(angle, axis)\n        quat_inv = quaternion_conjugate(quat)\n        product = reduce(quaternion_mult, [quat, np.append(0, vector), quat_inv])\n        return product[1:]\n    else:\n        raise Exception(\"vector must be of dimension 2 or 3\")",
  "def thick_diagonal(dim, thickness=2):\n    row_indices = np.arange(dim).repeat(dim).reshape((dim, dim))\n    col_indices = np.transpose(row_indices)\n    return (np.abs(row_indices - col_indices) < thickness).astype(\"uint8\")",
  "def rotation_matrix(angle, axis):\n    \"\"\"\n    Rotation in R^3 about a specified axis of rotation.\n    \"\"\"\n    about_z = rotation_about_z(angle)\n    z_to_axis = z_to_vector(axis)\n    axis_to_z = np.linalg.inv(z_to_axis)\n    return reduce(np.dot, [z_to_axis, about_z, axis_to_z])",
  "def rotation_about_z(angle):\n    return [\n        [np.cos(angle), -np.sin(angle), 0],\n        [np.sin(angle), np.cos(angle), 0],\n        [0, 0, 1],\n    ]",
  "def z_to_vector(vector):\n    \"\"\"\n    Returns some matrix in SO(3) which takes the z-axis to the\n    (normalized) vector provided as an argument\n    \"\"\"\n    norm = get_norm(vector)\n    if norm == 0:\n        return np.identity(3)\n    v = np.array(vector) / norm\n    phi = np.arccos(v[2])\n    if any(v[:2]):\n        # projection of vector to unit circle\n        axis_proj = v[:2] / get_norm(v[:2])\n        theta = np.arccos(axis_proj[0])\n        if axis_proj[1] < 0:\n            theta = -theta\n    else:\n        theta = 0\n    phi_down = np.array(\n        [[np.cos(phi), 0, np.sin(phi)], [0, 1, 0], [-np.sin(phi), 0, np.cos(phi)]]\n    )\n    return np.dot(rotation_about_z(theta), phi_down)",
  "def angle_between(v1, v2):\n    return np.arccos(np.dot(v1 / get_norm(v1), v2 / get_norm(v2)))",
  "def angle_of_vector(vector):\n    \"\"\"\n    Returns polar coordinate theta when vector is project on xy plane\n    \"\"\"\n    z = complex(*vector[:2])\n    if z == 0:\n        return 0\n    return np.angle(complex(*vector[:2]))",
  "def angle_between_vectors(v1, v2):\n    \"\"\"\n    Returns the angle between two 3D vectors.\n    This angle will always be btw 0 and pi\n    \"\"\"\n    return np.arccos(fdiv(np.dot(v1, v2), get_norm(v1) * get_norm(v2)))",
  "def project_along_vector(point, vector):\n    matrix = np.identity(3) - np.outer(vector, vector)\n    return np.dot(point, matrix.T)",
  "def normalize(vect, fall_back=None):\n    norm = get_norm(vect)\n    if norm > 0:\n        return np.array(vect) / norm\n    else:\n        if fall_back is not None:\n            return fall_back\n        else:\n            return np.zeros(len(vect))",
  "def cross(v1, v2):\n    return np.array(\n        [\n            v1[1] * v2[2] - v1[2] * v2[1],\n            v1[2] * v2[0] - v1[0] * v2[2],\n            v1[0] * v2[1] - v1[1] * v2[0],\n        ]\n    )",
  "def get_unit_normal(v1, v2):\n    return normalize(cross(v1, v2))",
  "def compass_directions(n=4, start_vect=RIGHT):\n    angle = TAU / n\n    return np.array([rotate_vector(start_vect, k * angle) for k in range(n)])",
  "def complex_to_R3(complex_num):\n    return np.array((complex_num.real, complex_num.imag, 0))",
  "def R3_to_complex(point):\n    return complex(*point[:2])",
  "def complex_func_to_R3_func(complex_func):\n    return lambda p: complex_to_R3(complex_func(R3_to_complex(p)))",
  "def center_of_mass(points):\n    points = [np.array(point).astype(\"float\") for point in points]\n    return sum(points) / len(points)",
  "def midpoint(point1, point2):\n    return center_of_mass([point1, point2])",
  "def line_intersection(line1, line2):\n    \"\"\"\n    return intersection point of two lines,\n    each defined with a pair of vectors determining\n    the end points\n    \"\"\"\n    x_diff = (line1[0][0] - line1[1][0], line2[0][0] - line2[1][0])\n    y_diff = (line1[0][1] - line1[1][1], line2[0][1] - line2[1][1])\n\n    def det(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    div = det(x_diff, y_diff)\n    if div == 0:\n        raise Exception(\"Lines do not intersect\")\n    d = (det(*line1), det(*line2))\n    x = det(d, x_diff) / div\n    y = det(d, y_diff) / div\n    return np.array([x, y, 0])",
  "def get_winding_number(points):\n    total_angle = 0\n    for p1, p2 in adjacent_pairs(points):\n        d_angle = angle_of_vector(p2) - angle_of_vector(p1)\n        d_angle = ((d_angle + PI) % TAU) - PI\n        total_angle += d_angle\n    return total_angle / TAU",
  "def det(a, b):\n        return a[0] * b[1] - a[1] * b[0]",
  "class TexTemplateFromFile:\n    \"\"\"\n    Class representing a TeX template file\n    \"\"\"  # TODO: attributes, dataclasses stuff\n\n    CONFIG = {\n        \"use_ctex\": False,\n        \"filename\": \"tex_template.tex\",\n        \"text_to_replace\": \"YourTextHere\",\n    }\n    body = \"\"\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        self.rebuild_cache()\n\n    def rebuild_cache(self):\n        \"\"\"For faster access, the LaTeX template's code is cached.\n        If the base file is modified, the cache needs to be rebuilt.\n        \"\"\"\n        with open(self.filename, \"r\") as infile:\n            self.body = infile.read()\n\n    def get_text_for_text_mode(self, expression):\n        \"\"\"Inserting expression verbatim into TeX template.\n\n        Parameters\n        ----------\n        expression : :class:`str`\n            String containing the expression to be typeset, e.g. `\"foo\"`\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on the template containing the given expression and ready for typesetting.\n        \"\"\"\n        return self.body.replace(self.text_to_replace, expression)\n\n    def get_text_for_env(self, environment, expression):\n        \"\"\"Inserts an expression into the TeX template, surrounded\n        by `\\\\begin{<environment>} ... \\\\end{<environment>}` for a certain environment.\n\n        Parameters\n        ----------\n        environment : :class:`str`\n            The environment in which we should wrap the expression.\n        expression : :class:`str`\n            The string containing the expression to be typeset, e.g. $\\\\sqrt{2}$\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on template, containing the given expression and ready for typesetting\n        \"\"\"\n        begin = r\"\\begin{\" + environment + \"}\"\n        end = r\"\\end{\" + environment + \"}\"\n        return self.body.replace(\n            self.text_to_replace, \"{0}\\n{1}\\n{2}\".format(begin, expression, end)\n        )\n\n    def get_text_for_tex_mode(self, expression):\n        \"\"\"Inserts an expression into the TeX template, surrounded\n        by `\\\\begin{align*} ... \\\\end{align*}` for math mode.\n\n        Parameters\n        ----------\n        expression : :class:`str`\n            The string containing the (math) expression to be typeset, e.g. $\\\\sqrt{2}$\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on template, containing the given expression and ready for typesetting\n        \"\"\"\n        return self.get_text_for_env(\"align*\", expression)",
  "class TexTemplate(TexTemplateFromFile):\n    \"\"\"\n    Class for dynamically managing a TeX template\n    \"\"\"  # TODO: Add attributes (when dataclasses are implemented)\n\n    CONFIG = {\n        \"documentclass\": [\"standalone\", [\"preview\"]],\n        \"common_packages\": [\n            [\"babel\", [\"english\"]],\n            \"amsmath\",\n            \"amssymb\",\n            \"dsfont\",\n            \"setspace\",\n            \"tipa\",\n            \"relsize\",\n            \"textcomp\",\n            \"mathrsfs\",\n            \"calligra\",\n            \"wasysym\",\n            \"ragged2e\",\n            \"physics\",\n            \"xcolor\",\n            \"microtype\",\n        ],\n        \"tex_packages\": [],\n        \"ctex_packages\": [[\"ctex\", [\"UTF8\"]]],\n        \"common_preamble_text\": r\"\\linespread{1}\" \"\\n\",\n        \"tex_preamble_text\": r\"\\DisableLigatures{encoding = *, family = *}\" \"\\n\",\n        \"ctex_preamble_text\": \"\",\n        \"document_prefix\": \"\",\n        \"document_suffix\": \"\",\n    }\n\n    def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        self.rebuild_cache()\n\n    def rebuild_cache(self):\n        \"\"\"For faster access, the LaTeX template's code is cached.\n        If the base file is modified, the cache needs to be rebuilt.\"\"\"\n        tpl = self.generate_tex_command(\n            \"documentclass\",\n            required_params=[self.documentclass[0]],\n            optional_params=self.documentclass[1],\n        )\n        for pkg in self.common_packages:\n            tpl += self.generate_usepackage(pkg)\n\n        if self.use_ctex:\n            for pkg in self.ctex_packages:\n                tpl += self.generate_usepackage(pkg)\n        else:\n            for pkg in self.tex_packages:\n                tpl += self.generate_usepackage(pkg)\n\n        tpl += self.common_preamble_text\n        if self.use_ctex:\n            tpl += self.ctex_preamble_text\n        else:\n            tpl += self.tex_preamble_text\n\n        tpl += \"\\n\" r\"\\begin{document}\" \"\\n\"\n        tpl += f\"\\n{self.text_to_replace}\\n\"\n        tpl += \"\\n\" r\"\\end{document}\"\n\n        self.body = tpl\n\n    def prepend_package(self, pkg):\n        \"\"\"Adds a new package (or several new packages)\n        before all other packages. Sometimes, the order of\n        the `\\\\usepackage` directives is relevant.\n\n        Parameters\n        ----------\n        pkg : :class:`str`\n            The package name, e.g. \"siunitx\"\n        \"\"\"\n        self.common_packages.insert(0, pkg)\n        self.rebuild_cache()\n\n    def append_package(self, pkg):\n        \"\"\"Adds a new package (or several new packages)\n        after all other packages. Sometimes, the order of\n        the `\\\\usepackage` directives is relevant.\n\n        Parameters\n        ----------\n        pkg : :class:`str`\n            The package name, e.g. \"siunitx\"\n        \"\"\"\n        self.common_packages.append(pkg)\n        self.rebuild_cache()\n\n    def append_to_preamble(self, text):\n        \"\"\"Adds commands (e.g. macro definitions) at the end of the preamble.\n\n        Parameters\n        ----------\n        text : :class:`str`\n            The text to be included, e.g. \"\\\\newcommand{\\\\R}{\\\\mathbb{Q}}\"\n        \"\"\"\n        if self.use_ctex:\n            self.ctex_preamble_text += text\n        else:\n            self.tex_preamble_text += text\n        self.rebuild_cache()\n        pass\n\n    def clear_preamble(self):\n        \"\"\"Removes custom definitions from the LaTeX preamble.\n        This does not affect the imported packages or documentclass.\"\"\"\n        self.common_preamble_text = \"\"\n        self.ctex_preamble_text = \"\"\n        self.tex_preamble_text = \"\"\n        self.rebuild_cache()\n        pass\n\n    def generate_tex_command(self, command, *, required_params, optional_params=[]):\n        \"\"\"\n        Function for creating LaTeX command strings with or without options.\n        Internally used to generate `\\\\usepackage{...}`\n\n        Parameters\n        ----------\n        command : :class:`str`\n            The command, e.g. `\"usepackage\"`\n        required_params : Iterable[:class:`str`]\n            The required parameters of this command, each wrapped in `{}`s.\n        optional_params : Iterable[:class:`str`]\n             The optional parameters of this command, each separated by a comma inside one `[]`.\n\n        Examples\n        --------\n        ::\n            generate_tex_command(\"usepackage\", required_params=[\"packagename\"], optional_params=[\"option1\", \"option2\"])\n\n        Returns\n        -------\n        :class:`str`\n            The generated command.\n        \"\"\"\n        optional_params = list(optional_params)  # so we can measure its length\n        return r\"\\{0}{1}{2}\".format(\n            command,\n            f\"[{','.join(optional_params)}]\" if optional_params else \"\",\n            \"\".join(\"{\" + param + \"}\" for param in required_params),\n        )\n\n    def generate_usepackage(self, pkg):\n        if isinstance(pkg, list):\n            return self.generate_tex_command(\n                \"usepackage\", required_params=[pkg[0]], optional_params=pkg[1]\n            )\n        else:\n            return self.generate_tex_command(\"usepackage\", required_params=[pkg])\n\n    def get_text_for_text_mode(self, expression):\n        \"\"\"Inserts an expression verbatim into the TeX template.\n\n        Parameters\n        ----\u2013-----\n        expression : :class:`str`\n            The expression to be typeset, e.g. `\"foo\"`\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on the template, containing the given expression and ready for typesetting\n        \"\"\"\n        return self.body.replace(self.text_to_replace, expression)\n\n    def get_text_for_env(self, environment, expression):\n        \"\"\"Inserts an expression into the TeX template, surrounded\n        by `\\\\begin{<environment>} ... \\\\end{<environment>}` for a certain environment.\n\n        Parameters\n        ----------\n        environment : :class:`str`\n            The environment in which we should wrap the expression.\n        expression : :class:`str`\n            The string containing the expression to be typeset, e.g. $\\\\sqrt{2}$\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on template, containing the given expression and ready for typesetting\n        \"\"\"\n        begin = r\"\\begin{\" + environment + \"}\"\n        end = r\"\\end{\" + environment + \"}\"\n        return self.body.replace(\n            self.text_to_replace, \"{0}\\n{1}\\n{2}\".format(begin, expression, end)\n        )\n\n    def get_text_for_tex_mode(self, expression):\n        \"\"\"Inserts an expression into the TeX template, surrounded\n        by `\\\\begin{align*} ... \\\\end{align*}` for math mode.\n\n        Parameters\n        ----------\n        expression : :class:`str`\n            The string containing the (math) expression to be typeset, e.g. $\\\\sqrt{2}$\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on template, containing the given expression and ready for typesetting\n        \"\"\"\n        return self.get_text_for_env(\"align*\", expression)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        self.rebuild_cache()",
  "def rebuild_cache(self):\n        \"\"\"For faster access, the LaTeX template's code is cached.\n        If the base file is modified, the cache needs to be rebuilt.\n        \"\"\"\n        with open(self.filename, \"r\") as infile:\n            self.body = infile.read()",
  "def get_text_for_text_mode(self, expression):\n        \"\"\"Inserting expression verbatim into TeX template.\n\n        Parameters\n        ----------\n        expression : :class:`str`\n            String containing the expression to be typeset, e.g. `\"foo\"`\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on the template containing the given expression and ready for typesetting.\n        \"\"\"\n        return self.body.replace(self.text_to_replace, expression)",
  "def get_text_for_env(self, environment, expression):\n        \"\"\"Inserts an expression into the TeX template, surrounded\n        by `\\\\begin{<environment>} ... \\\\end{<environment>}` for a certain environment.\n\n        Parameters\n        ----------\n        environment : :class:`str`\n            The environment in which we should wrap the expression.\n        expression : :class:`str`\n            The string containing the expression to be typeset, e.g. $\\\\sqrt{2}$\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on template, containing the given expression and ready for typesetting\n        \"\"\"\n        begin = r\"\\begin{\" + environment + \"}\"\n        end = r\"\\end{\" + environment + \"}\"\n        return self.body.replace(\n            self.text_to_replace, \"{0}\\n{1}\\n{2}\".format(begin, expression, end)\n        )",
  "def get_text_for_tex_mode(self, expression):\n        \"\"\"Inserts an expression into the TeX template, surrounded\n        by `\\\\begin{align*} ... \\\\end{align*}` for math mode.\n\n        Parameters\n        ----------\n        expression : :class:`str`\n            The string containing the (math) expression to be typeset, e.g. $\\\\sqrt{2}$\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on template, containing the given expression and ready for typesetting\n        \"\"\"\n        return self.get_text_for_env(\"align*\", expression)",
  "def __init__(self, **kwargs):\n        digest_config(self, kwargs)\n        self.rebuild_cache()",
  "def rebuild_cache(self):\n        \"\"\"For faster access, the LaTeX template's code is cached.\n        If the base file is modified, the cache needs to be rebuilt.\"\"\"\n        tpl = self.generate_tex_command(\n            \"documentclass\",\n            required_params=[self.documentclass[0]],\n            optional_params=self.documentclass[1],\n        )\n        for pkg in self.common_packages:\n            tpl += self.generate_usepackage(pkg)\n\n        if self.use_ctex:\n            for pkg in self.ctex_packages:\n                tpl += self.generate_usepackage(pkg)\n        else:\n            for pkg in self.tex_packages:\n                tpl += self.generate_usepackage(pkg)\n\n        tpl += self.common_preamble_text\n        if self.use_ctex:\n            tpl += self.ctex_preamble_text\n        else:\n            tpl += self.tex_preamble_text\n\n        tpl += \"\\n\" r\"\\begin{document}\" \"\\n\"\n        tpl += f\"\\n{self.text_to_replace}\\n\"\n        tpl += \"\\n\" r\"\\end{document}\"\n\n        self.body = tpl",
  "def prepend_package(self, pkg):\n        \"\"\"Adds a new package (or several new packages)\n        before all other packages. Sometimes, the order of\n        the `\\\\usepackage` directives is relevant.\n\n        Parameters\n        ----------\n        pkg : :class:`str`\n            The package name, e.g. \"siunitx\"\n        \"\"\"\n        self.common_packages.insert(0, pkg)\n        self.rebuild_cache()",
  "def append_package(self, pkg):\n        \"\"\"Adds a new package (or several new packages)\n        after all other packages. Sometimes, the order of\n        the `\\\\usepackage` directives is relevant.\n\n        Parameters\n        ----------\n        pkg : :class:`str`\n            The package name, e.g. \"siunitx\"\n        \"\"\"\n        self.common_packages.append(pkg)\n        self.rebuild_cache()",
  "def append_to_preamble(self, text):\n        \"\"\"Adds commands (e.g. macro definitions) at the end of the preamble.\n\n        Parameters\n        ----------\n        text : :class:`str`\n            The text to be included, e.g. \"\\\\newcommand{\\\\R}{\\\\mathbb{Q}}\"\n        \"\"\"\n        if self.use_ctex:\n            self.ctex_preamble_text += text\n        else:\n            self.tex_preamble_text += text\n        self.rebuild_cache()\n        pass",
  "def clear_preamble(self):\n        \"\"\"Removes custom definitions from the LaTeX preamble.\n        This does not affect the imported packages or documentclass.\"\"\"\n        self.common_preamble_text = \"\"\n        self.ctex_preamble_text = \"\"\n        self.tex_preamble_text = \"\"\n        self.rebuild_cache()\n        pass",
  "def generate_tex_command(self, command, *, required_params, optional_params=[]):\n        \"\"\"\n        Function for creating LaTeX command strings with or without options.\n        Internally used to generate `\\\\usepackage{...}`\n\n        Parameters\n        ----------\n        command : :class:`str`\n            The command, e.g. `\"usepackage\"`\n        required_params : Iterable[:class:`str`]\n            The required parameters of this command, each wrapped in `{}`s.\n        optional_params : Iterable[:class:`str`]\n             The optional parameters of this command, each separated by a comma inside one `[]`.\n\n        Examples\n        --------\n        ::\n            generate_tex_command(\"usepackage\", required_params=[\"packagename\"], optional_params=[\"option1\", \"option2\"])\n\n        Returns\n        -------\n        :class:`str`\n            The generated command.\n        \"\"\"\n        optional_params = list(optional_params)  # so we can measure its length\n        return r\"\\{0}{1}{2}\".format(\n            command,\n            f\"[{','.join(optional_params)}]\" if optional_params else \"\",\n            \"\".join(\"{\" + param + \"}\" for param in required_params),\n        )",
  "def generate_usepackage(self, pkg):\n        if isinstance(pkg, list):\n            return self.generate_tex_command(\n                \"usepackage\", required_params=[pkg[0]], optional_params=pkg[1]\n            )\n        else:\n            return self.generate_tex_command(\"usepackage\", required_params=[pkg])",
  "def get_text_for_text_mode(self, expression):\n        \"\"\"Inserts an expression verbatim into the TeX template.\n\n        Parameters\n        ----\u2013-----\n        expression : :class:`str`\n            The expression to be typeset, e.g. `\"foo\"`\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on the template, containing the given expression and ready for typesetting\n        \"\"\"\n        return self.body.replace(self.text_to_replace, expression)",
  "def get_text_for_env(self, environment, expression):\n        \"\"\"Inserts an expression into the TeX template, surrounded\n        by `\\\\begin{<environment>} ... \\\\end{<environment>}` for a certain environment.\n\n        Parameters\n        ----------\n        environment : :class:`str`\n            The environment in which we should wrap the expression.\n        expression : :class:`str`\n            The string containing the expression to be typeset, e.g. $\\\\sqrt{2}$\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on template, containing the given expression and ready for typesetting\n        \"\"\"\n        begin = r\"\\begin{\" + environment + \"}\"\n        end = r\"\\end{\" + environment + \"}\"\n        return self.body.replace(\n            self.text_to_replace, \"{0}\\n{1}\\n{2}\".format(begin, expression, end)\n        )",
  "def get_text_for_tex_mode(self, expression):\n        \"\"\"Inserts an expression into the TeX template, surrounded\n        by `\\\\begin{align*} ... \\\\end{align*}` for math mode.\n\n        Parameters\n        ----------\n        expression : :class:`str`\n            The string containing the (math) expression to be typeset, e.g. $\\\\sqrt{2}$\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on template, containing the given expression and ready for typesetting\n        \"\"\"\n        return self.get_text_for_env(\"align*\", expression)",
  "def get_full_raster_image_path(image_file_name):\n    return seek_full_path_from_defaults(\n        image_file_name,\n        default_dir=os.path.join(\"assets\", \"raster_images\"),\n        extensions=[\".jpg\", \".png\", \".gif\"],\n    )",
  "def drag_pixels(frames):\n    curr = frames[0]\n    new_frames = []\n    for frame in frames:\n        curr += (curr == 0) * np.array(frame)\n        new_frames.append(np.array(curr))\n    return new_frames",
  "def invert_image(image):\n    arr = np.array(image)\n    arr = (255 * np.ones(arr.shape)).astype(arr.dtype) - arr\n    return Image.fromarray(arr)",
  "def linear(t):\n    return t",
  "def smooth(t, inflection=10.0):\n    error = sigmoid(-inflection / 2)\n    return np.clip((sigmoid(inflection * (t - 0.5)) - error) / (1 - 2 * error), 0, 1,)",
  "def rush_into(t, inflection=10.0):\n    return 2 * smooth(t / 2.0, inflection)",
  "def rush_from(t, inflection=10.0):\n    return 2 * smooth(t / 2.0 + 0.5, inflection) - 1",
  "def slow_into(t):\n    return np.sqrt(1 - (1 - t) * (1 - t))",
  "def double_smooth(t):\n    if t < 0.5:\n        return 0.5 * smooth(2 * t)\n    else:\n        return 0.5 * (1 + smooth(2 * t - 1))",
  "def there_and_back(t, inflection=10.0):\n    new_t = 2 * t if t < 0.5 else 2 * (1 - t)\n    return smooth(new_t, inflection)",
  "def there_and_back_with_pause(t, pause_ratio=1.0 / 3):\n    a = 1.0 / pause_ratio\n    if t < 0.5 - pause_ratio / 2:\n        return smooth(a * t)\n    elif t < 0.5 + pause_ratio / 2:\n        return 1\n    else:\n        return smooth(a - a * t)",
  "def running_start(t, pull_factor=-0.5):\n    return bezier([0, 0, pull_factor, pull_factor, 1, 1, 1])(t)",
  "def not_quite_there(func=smooth, proportion=0.7):\n    def result(t):\n        return proportion * func(t)\n\n    return result",
  "def wiggle(t, wiggles=2):\n    return there_and_back(t) * np.sin(wiggles * np.pi * t)",
  "def squish_rate_func(func, a=0.4, b=0.6):\n    def result(t):\n        if a == b:\n            return a\n\n        if t < a:\n            return func(0)\n        elif t > b:\n            return func(1)\n        else:\n            return func((t - a) / (b - a))\n\n    return result",
  "def lingering(t):\n    return squish_rate_func(lambda t: t, 0, 0.8)(t)",
  "def exponential_decay(t, half_life=0.1):\n    # The half-life should be rather small to minimize\n    # the cut-off error at the end\n    return 1 - np.exp(-t / half_life)",
  "def result(t):\n        return proportion * func(t)",
  "def result(t):\n        if a == b:\n            return a\n\n        if t < a:\n            return func(0)\n        elif t > b:\n            return func(1)\n        else:\n            return func((t - a) / (b - a))",
  "def is_valid_style(style):\n    \"\"\"Checks whether the entered color is a valid color according to rich\n    Parameters\n    ----------\n    style : :class:`str`\n        The style to check whether it is valid.\n    Returns\n    -------\n    Boolean\n        Returns whether it is valid style or not according to rich.\n    \"\"\"\n    try:\n        Style.parse(style)\n        return True\n    except StyleSyntaxError:\n        return False",
  "def replace_keys(default):\n    \"\"\"Replaces _ to . and viceversa in a dictionary for rich\n    Parameters\n    ----------\n    default : :class:`dict`\n        The dictionary to check and replace\n    Returns\n    -------\n    :class:`dict`\n        The dictionary which is modified by replcaing _ with . and viceversa\n    \"\"\"\n    for key in default:\n        if \"_\" in key:\n            temp = default[key]\n            del default[key]\n            key = key.replace(\"_\", \".\")\n            default[key] = temp\n        else:\n            temp = default[key]\n            del default[key]\n            key = key.replace(\".\", \"_\")\n            default[key] = temp\n    return default",
  "def main():\n    config = _run_config()[1]\n    console = Console()\n    default = config[\"logger\"]\n    console.print(TITLE_TEXT, justify=\"center\")\n    console.print(INTRO_INSTRUCTIONS)\n    default = replace_keys(default)\n    for key in default:\n        console.print(\"Enter the Style for %s\" % key + \":\", style=key, end=\"\")\n        temp = input()\n        if temp:\n            while not is_valid_style(temp):\n                console.print(INVALID_STYLE_MSG)\n                console.print(\"Enter the Style for %s\" % key + \":\", style=key, end=\"\")\n                temp = input()\n            else:\n                default[key] = temp\n    default = replace_keys(default)\n    config[\"logger\"] = default\n    console.print(\n        \"Do you want to save this as the default for this User?(y/n)[[n]]\",\n        style=\"dim purple\",\n        end=\"\",\n    )\n    save_to_userpath = input()\n    config_paths = _paths_config_file() + [os.path.abspath(\"manim.cfg\")]\n    if save_to_userpath.lower() == \"y\":\n        if not os.path.exists(os.path.abspath(os.path.join(config_paths[1], \"..\"))):\n            os.makedirs(os.path.abspath(os.path.join(config_paths[1], \"..\")))\n        with open(config_paths[1], \"w\") as fp:\n            config.write(fp)\n        console.print(\n            f\"\"\"A configuration file called [yellow]{config_paths[1]}[/yellow] has been created with your required changes.\nThis will be used when running the manim command. If you want to override this config,\nyou will have to create a manim.cfg in the local directory, where you want those changes to be overridden.\"\"\"\n        )\n    else:\n        with open(config_paths[2], \"w\") as fp:\n            config.write(fp)\n        console.print(\n            f\"\"\"A configuration file called [yellow]{config_paths[2]}[/yellow] has been created.\nTo save your theme please save that file and place it in your current working directory, from where you run the manim command.\"\"\"\n        )",
  "def straight_path(start_points, end_points, alpha):\n    \"\"\"\n    Same function as interpolate, but renamed to reflect\n    intent of being used to determine how a set of points move\n    to another set.  For instance, it should be a specific case\n    of path_along_arc\n    \"\"\"\n    return interpolate(start_points, end_points, alpha)",
  "def path_along_arc(arc_angle, axis=OUT):\n    \"\"\"\n    If vect is vector from start to end, [vect[:,1], -vect[:,0]] is\n    perpendicular to vect in the left direction.\n    \"\"\"\n    if abs(arc_angle) < STRAIGHT_PATH_THRESHOLD:\n        return straight_path\n    if get_norm(axis) == 0:\n        axis = OUT\n    unit_axis = axis / get_norm(axis)\n\n    def path(start_points, end_points, alpha):\n        vects = end_points - start_points\n        centers = start_points + 0.5 * vects\n        if arc_angle != np.pi:\n            centers += np.cross(unit_axis, vects / 2.0) / np.tan(arc_angle / 2)\n        rot_matrix = rotation_matrix(alpha * arc_angle, unit_axis)\n        return centers + np.dot(start_points - centers, rot_matrix.T)\n\n    return path",
  "def clockwise_path():\n    return path_along_arc(-np.pi)",
  "def counterclockwise_path():\n    return path_along_arc(np.pi)",
  "def path(start_points, end_points, alpha):\n        vects = end_points - start_points\n        centers = start_points + 0.5 * vects\n        if arc_angle != np.pi:\n            centers += np.cross(unit_axis, vects / 2.0) / np.tan(arc_angle / 2)\n        rot_matrix = rotation_matrix(alpha * arc_angle, unit_axis)\n        return centers + np.dot(start_points - centers, rot_matrix.T)",
  "def to_camel_case(name):\n    return \"\".join(\n        [\n            [\n                c for c in part if c not in string.punctuation + string.whitespace\n            ].capitalize()\n            for part in name.split(\"_\")\n        ]\n    )",
  "def initials(name, sep_values=[\" \", \"_\"]):\n    return \"\".join([(s[0] if s else \"\") for s in re.split(\"|\".join(sep_values), name)])",
  "def camel_case_initials(name):\n    return [c for c in name if c.isupper()]",
  "def complex_string(complex_num):\n    return [c for c in str(complex_num) if c not in \"()\"]",
  "def split_string_to_isolate_substrings(full_string, *substrings_to_isolate):\n    \"\"\"\n    Given a string, and an arbitrary number of possible substrings, returns a list\n    of strings which would concatenate to make the full string, and in which\n    these special substrings appear as their own elements.\n\n    For example, split_string_to_isolate_substrings(\"to be or not to be\", \"to\", \"be\") would\n    return [\"to\", \" \", \"be\", \" or not \", \"to\", \" \", \"be\"]\n    \"\"\"\n    if len(substrings_to_isolate) == 0:\n        return [full_string]\n    substring_to_isolate = substrings_to_isolate[0]\n    all_substrings = list(\n        it.chain(\n            *list(\n                zip(\n                    full_string.split(substring_to_isolate),\n                    it.repeat(substring_to_isolate),\n                )\n            )\n        )\n    )\n    all_substrings.pop(-1)\n    all_substrings = [s for s in all_substrings if s != \"\"]\n    return split_string_list_to_isolate_substrings(\n        all_substrings, *substrings_to_isolate[1:]\n    )",
  "def split_string_list_to_isolate_substrings(string_list, *substrings_to_isolate):\n    \"\"\"\n    Similar to split_string_to_isolate_substrings, but the first argument\n    is a list of strings, thought of as something already broken up a bit.\n    \"\"\"\n    return list(\n        it.chain(\n            *[\n                split_string_to_isolate_substrings(s, *substrings_to_isolate)\n                for s in string_list\n            ]\n        )\n    )",
  "def play_chord(*nums):\n    commands = (\n        [\"play\", \"-n\", \"-c1\", \"--no-show-progress\", \"synth\",]\n        + [\"sin %-\" + str(num) for num in nums]\n        + [\"fade h 0.5 1 0.5\", \">\", os.devnull]\n    )\n    try:\n        os.system(\" \".join(commands))\n    except:\n        pass",
  "def play_error_sound():\n    play_chord(11, 8, 6, 1)",
  "def play_finish_sound():\n    play_chord(12, 9, 5, 2)",
  "def get_full_sound_file_path(sound_file_name):\n    return seek_full_path_from_defaults(\n        sound_file_name,\n        default_dir=os.path.join(\"assets\", \"sounds\"),\n        extensions=[\".wav\", \".mp3\"],\n    )",
  "def sigmoid(x):\n    return 1.0 / (1 + np.exp(-x))",
  "def choose_using_cache(n, r):\n    if n not in CHOOSE_CACHE:\n        CHOOSE_CACHE[n] = {}\n    if r not in CHOOSE_CACHE[n]:\n        CHOOSE_CACHE[n][r] = choose(n, r, use_cache=False)\n    return CHOOSE_CACHE[n][r]",
  "def choose(n, r, use_cache=True):\n    if use_cache:\n        return choose_using_cache(n, r)\n    if n < r:\n        return 0\n    if r == 0:\n        return 1\n    denom = reduce(op.mul, range(1, r + 1), 1)\n    numer = reduce(op.mul, range(n, n - r, -1), 1)\n    return numer // denom",
  "def get_num_args(function):\n    return len(get_parameters(function))",
  "def get_parameters(function):\n    return inspect.signature(function).parameters",
  "def clip_in_place(array, min_val=None, max_val=None):\n    if max_val is not None:\n        array[array > max_val] = max_val\n    if min_val is not None:\n        array[array < min_val] = min_val\n    return array",
  "def fdiv(a, b, zero_over_zero_value=None):\n    if zero_over_zero_value is not None:\n        out = np.full_like(a, zero_over_zero_value)\n        where = np.logical_or(a != 0, b != 0)\n    else:\n        out = None\n        where = True\n\n    return np.true_divide(a, b, out=out, where=where)",
  "def binary_search(function, target, lower_bound, upper_bound, tolerance=1e-4):\n    lh = lower_bound\n    rh = upper_bound\n    while abs(rh - lh) > tolerance:\n        mh = np.mean([lh, rh])\n        lx, mx, rx = [function(h) for h in (lh, mh, rh)]\n        if lx == target:\n            return lx\n        if rx == target:\n            return rx\n\n        if lx <= target and rx >= target:\n            if mx > target:\n                rh = mh\n            else:\n                lh = mh\n        elif lx > target and rx < target:\n            lh, rh = rh, lh\n        else:\n            return None\n    return mh",
  "def tex_hash(expression):\n    id_str = str(expression)\n    hasher = hashlib.sha256()\n    hasher.update(id_str.encode())\n    # Truncating at 16 bytes for cleanliness\n    return hasher.hexdigest()[:16]",
  "def tex_to_svg_file(expression, source_type):\n    tex_template = config[\"tex_template\"]\n    tex_file = generate_tex_file(expression, tex_template, source_type)\n    dvi_file = tex_to_dvi(tex_file, tex_template.use_ctex)\n    return dvi_to_svg(dvi_file, use_ctex=tex_template.use_ctex)",
  "def generate_tex_file(expression, tex_template, source_type):\n    if source_type == \"text\":\n        output = tex_template.get_text_for_text_mode(expression)\n    elif source_type == \"tex\":\n        output = tex_template.get_text_for_tex_mode(expression)\n\n    result = os.path.join(file_writer_config[\"tex_dir\"], tex_hash(output)) + \".tex\"\n    if not os.path.exists(result):\n        logger.info('Writing \"%s\" to %s' % (\"\".join(expression), result))\n        with open(result, \"w\", encoding=\"utf-8\") as outfile:\n            outfile.write(output)\n    return result",
  "def tex_to_dvi(tex_file, use_ctex=False):\n    result = tex_file.replace(\".tex\", \".dvi\" if not use_ctex else \".xdv\")\n    result = Path(result).as_posix()\n    tex_file = Path(tex_file).as_posix()\n    tex_dir = Path(file_writer_config[\"tex_dir\"]).as_posix()\n    if not os.path.exists(result):\n        commands = (\n            [\n                \"latex\",\n                \"-interaction=batchmode\",\n                \"-halt-on-error\",\n                '-output-directory=\"{}\"'.format(tex_dir),\n                '\"{}\"'.format(tex_file),\n                \">\",\n                os.devnull,\n            ]\n            if not use_ctex\n            else [\n                \"xelatex\",\n                \"-no-pdf\",\n                \"-interaction=batchmode\",\n                \"-halt-on-error\",\n                '-output-directory=\"{}\"'.format(tex_dir),\n                '\"{}\"'.format(tex_file),\n                \">\",\n                os.devnull,\n            ]\n        )\n        exit_code = os.system(\" \".join(commands))\n        if exit_code != 0:\n            log_file = tex_file.replace(\".tex\", \".log\")\n            raise Exception(\n                (\n                    \"LaTeX error converting to dvi. \"\n                    if not use_ctex\n                    else \"XeLaTeX error converting to xdv. \"\n                )\n                + f\"See log output above or the log file: {log_file}\"\n            )\n    return result",
  "def dvi_to_svg(dvi_file, use_ctex=False, regen_if_exists=False):\n    \"\"\"\n    Converts a dvi, which potentially has multiple slides, into a\n    directory full of enumerated pngs corresponding with these slides.\n    Returns a list of PIL Image objects for these images sorted as they\n    where in the dvi\n    \"\"\"\n    result = dvi_file.replace(\".dvi\" if not use_ctex else \".xdv\", \".svg\")\n    result = Path(result).as_posix()\n    dvi_file = Path(dvi_file).as_posix()\n    if not os.path.exists(result):\n        commands = [\n            \"dvisvgm\",\n            '\"{}\"'.format(dvi_file),\n            \"-n\",\n            \"-v\",\n            \"0\",\n            \"-o\",\n            '\"{}\"'.format(result),\n            \">\",\n            os.devnull,\n        ]\n        os.system(\" \".join(commands))\n    return result",
  "def _parse_file_writer_config(config_parser, args):\n    \"\"\"Parse config files and CLI arguments into a single dictionary.\"\"\"\n    # By default, use the CLI section of the digested .cfg files\n    default = config_parser[\"CLI\"]\n\n    # This will be the final file_writer_config dict exposed to the user\n    fw_config = {}\n\n    # Handle input files and scenes.  Note these cannot be set from\n    # the .cfg files, only from CLI arguments\n    fw_config[\"input_file\"] = args.file\n    fw_config[\"scene_names\"] = args.scene_names if args.scene_names is not None else []\n    fw_config[\"output_file\"] = args.output_file\n\n    # Handle all options that are directly overridden by CLI\n    # arguments.  Note ConfigParser options are all strings and each\n    # needs to be converted to the appropriate type. Thus, we do this\n    # in batches, depending on their type: booleans and strings\n    for boolean_opt in [\n        \"preview\",\n        \"show_file_in_finder\",\n        \"quiet\",\n        \"sound\",\n        \"leave_progress_bars\",\n        \"write_to_movie\",\n        \"save_last_frame\",\n        \"save_pngs\",\n        \"save_as_gif\",\n        \"write_all\",\n    ]:\n        attr = getattr(args, boolean_opt)\n        fw_config[boolean_opt] = (\n            default.getboolean(boolean_opt) if attr is None else attr\n        )\n    # for str_opt in ['media_dir', 'video_dir', 'tex_dir', 'text_dir']:\n    for str_opt in [\"media_dir\"]:\n        attr = getattr(args, str_opt)\n        fw_config[str_opt] = os.path.relpath(default[str_opt]) if attr is None else attr\n    dir_names = {\"video_dir\": \"videos\", \"tex_dir\": \"Tex\", \"text_dir\": \"texts\"}\n    for name in dir_names:\n        fw_config[name] = os.path.join(fw_config[\"media_dir\"], dir_names[name])\n\n    # Handle the -s (--save_last_frame) flag: invalidate the -w flag\n    # At this point the save_last_frame option has already been set by\n    # both CLI and the cfg file, so read the config dict directly\n    if fw_config[\"save_last_frame\"]:\n        fw_config[\"write_to_movie\"] = False\n\n    # Handle the -t (--transparent) flag.  This flag determines which\n    # section to use from the .cfg file.\n    section = config_parser[\"transparent\"] if args.transparent else default\n    for opt in [\"png_mode\", \"movie_file_extension\", \"background_opacity\"]:\n        fw_config[opt] = section[opt]\n\n    # Handle the -n flag.  Read first from the cfg and then override with CLI.\n    # These two are integers -- use getint()\n    for opt in [\"from_animation_number\", \"upto_animation_number\"]:\n        fw_config[opt] = default.getint(opt)\n    if fw_config[\"upto_animation_number\"] == -1:\n        fw_config[\"upto_animation_number\"] = float(\"inf\")\n    nflag = args.from_animation_number\n    if nflag is not None:\n        if \",\" in nflag:\n            start, end = nflag.split(\",\")\n            fw_config[\"from_animation_number\"] = int(start)\n            fw_config[\"upto_animation_number\"] = int(end)\n        else:\n            fw_config[\"from_animation_number\"] = int(nflag)\n\n    # Handle the --dry_run flag.  This flag determines which section\n    # to use from the .cfg file.  All options involved are boolean.\n    # Note this overrides the flags -w, -s, -a, -g, and -i.\n    if args.dry_run:\n        for opt in [\n            \"write_to_movie\",\n            \"save_last_frame\",\n            \"save_pngs\",\n            \"save_as_gif\",\n            \"write_all\",\n        ]:\n            fw_config[opt] = config_parser[\"dry_run\"].getboolean(opt)\n\n    # Read in the streaming section -- all values are strings\n    fw_config[\"streaming\"] = {\n        opt: config_parser[\"streaming\"][opt]\n        for opt in [\n            \"live_stream_name\",\n            \"twitch_stream_key\",\n            \"streaming_protocol\",\n            \"streaming_ip\",\n            \"streaming_protocol\",\n            \"streaming_client\",\n            \"streaming_port\",\n            \"streaming_port\",\n            \"streaming_console_banner\",\n        ]\n    }\n\n    # For internal use (no CLI flag)\n    fw_config[\"skip_animations\"] = any(\n        [fw_config[\"save_last_frame\"], fw_config[\"from_animation_number\"]]\n    )\n\n    return fw_config",
  "def _parse_cli(arg_list, input=True):\n    parser = argparse.ArgumentParser(\n        description=\"Animation engine for explanatory math videos\",\n        epilog=\"Made with <3 by the manim community devs\",\n    )\n    if input:\n        parser.add_argument(\n            \"file\", help=\"path to file holding the python code for the scene\",\n        )\n        parser.add_argument(\n            \"scene_names\",\n            nargs=\"*\",\n            help=\"Name of the Scene class you want to see\",\n            default=[\"\"],\n        )\n        parser.add_argument(\n            \"-o\",\n            \"--output_file\",\n            help=\"Specify the name of the output file, if \"\n            \"it should be different from the scene class name\",\n            default=\"\",\n        )\n\n    # The following use (action='store_const', const=True) instead of\n    # the built-in (action='store_true').  This is because the latter\n    # will default to False if not specified, while the former sets no\n    # default value.  Since we want to set the default value in\n    # manim.cfg rather than here, we use the former.\n    parser.add_argument(\n        \"-p\",\n        \"--preview\",\n        action=\"store_const\",\n        const=True,\n        help=\"Automatically open the saved file once its done\",\n    )\n    parser.add_argument(\n        \"-f\",\n        \"--show_file_in_finder\",\n        action=\"store_const\",\n        const=True,\n        help=\"Show the output file in finder\",\n    )\n    parser.add_argument(\n        \"-q\", \"--quiet\", action=\"store_const\", const=True, help=\"Quiet mode\",\n    )\n    parser.add_argument(\n        \"--sound\",\n        action=\"store_const\",\n        const=True,\n        help=\"Play a success/failure sound\",\n    )\n    parser.add_argument(\n        \"--leave_progress_bars\",\n        action=\"store_const\",\n        const=True,\n        help=\"Leave progress bars displayed in terminal\",\n    )\n    parser.add_argument(\n        \"-a\",\n        \"--write_all\",\n        action=\"store_const\",\n        const=True,\n        help=\"Write all the scenes from a file\",\n    )\n    parser.add_argument(\n        \"-w\",\n        \"--write_to_movie\",\n        action=\"store_const\",\n        const=True,\n        help=\"Render the scene as a movie file\",\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--save_last_frame\",\n        action=\"store_const\",\n        const=True,\n        help=\"Save the last frame (and do not save movie)\",\n    )\n    parser.add_argument(\n        \"-g\",\n        \"--save_pngs\",\n        action=\"store_const\",\n        const=True,\n        help=\"Save each frame as a png\",\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--save_as_gif\",\n        action=\"store_const\",\n        const=True,\n        help=\"Save the video as gif\",\n    )\n\n    # The default value of the following is set in manim.cfg\n    parser.add_argument(\n        \"-c\", \"--color\", help=\"Background color\",\n    )\n    parser.add_argument(\n        \"--background_opacity\", help=\"Background opacity\",\n    )\n    parser.add_argument(\n        \"--media_dir\", help=\"directory to write media\",\n    )\n    # video_group = parser.add_mutually_exclusive_group()\n    # video_group.add_argument(\n    #     \"--video_dir\",\n    #     help=\"directory to write file tree for video\",\n    # )\n    # parser.add_argument(\n    #     \"--tex_dir\",\n    #     help=\"directory to write tex\",\n    # )\n    # parser.add_argument(\n    #     \"--text_dir\",\n    #     help=\"directory to write text\",\n    # )\n    parser.add_argument(\n        \"--tex_template\", help=\"Specify a custom TeX template file\",\n    )\n\n    # All of the following use (action=\"store_true\"). This means that\n    # they are by default False.  In contrast to the previous ones that\n    # used (action=\"store_const\", const=True), the following do not\n    # correspond to a single configuration option.  Rather, they\n    # override several options at the same time.\n\n    # The following overrides -w, -a, -g, and -i\n    parser.add_argument(\n        \"--dry_run\",\n        action=\"store_true\",\n        help=\"Do a dry run (render scenes but generate no output files)\",\n    )\n\n    # The following overrides PNG_MODE, MOVIE_FILE_EXTENSION, and\n    # BACKGROUND_OPACITY\n    parser.add_argument(\n        \"-t\",\n        \"--transparent\",\n        action=\"store_true\",\n        help=\"Render to a movie file with an alpha channel\",\n    )\n\n    # The following are mutually exclusive and each overrides\n    # FRAME_RATE, PIXEL_HEIGHT, and PIXEL_WIDTH,\n    parser.add_argument(\n        \"-l\",\n        \"--low_quality\",\n        action=\"store_true\",\n        help=\"Render at low quality (for fastest rendering)\",\n    )\n    parser.add_argument(\n        \"-m\",\n        \"--medium_quality\",\n        action=\"store_true\",\n        help=\"Render at medium quality (for much faster rendering)\",\n    )\n    parser.add_argument(\n        \"-e\",\n        \"--high_quality\",\n        action=\"store_true\",\n        help=\"Render at high quality (for slightly faster rendering)\",\n    )\n    parser.add_argument(\n        \"-k\",\n        \"--fourk_quality\",\n        action=\"store_true\",\n        help=\"Render at 4K quality (slower rendering)\",\n    )\n\n    # This overrides any of the above\n    parser.add_argument(\n        \"-r\", \"--resolution\", help='Resolution, passed as \"height,width\"',\n    )\n\n    # This sets FROM_ANIMATION_NUMBER and UPTO_ANIMATION_NUMBER\n    parser.add_argument(\n        \"-n\",\n        \"--from_animation_number\",\n        help=\"Start rendering not from the first animation, but\"\n        \"from another, specified by its index.  If you pass\"\n        'in two comma separated values, e.g. \"3,6\", it will end'\n        \"the rendering at the second value\",\n    )\n\n    # Specify the manim.cfg file\n    parser.add_argument(\n        \"--config_file\", help=\"Specify the configuration file\",\n    )\n\n    return parser.parse_args(arg_list)",
  "def _init_dirs(config):\n    # Make sure all folders exist\n    for folder in [\n        config[\"media_dir\"],\n        config[\"video_dir\"],\n        config[\"tex_dir\"],\n        config[\"text_dir\"],\n    ]:\n        if not os.path.exists(folder):\n            os.makedirs(folder)",
  "def _from_command_line():\n    \"\"\"Determine if manim was called from the command line.\"\"\"\n    # Manim can be called from the command line in three different\n    # ways.  The first two involve using the manim or manimcm commands\n    prog = os.path.split(sys.argv[0])[-1]\n    from_cli_command = prog in [\"manim\", \"manimcm\"]\n\n    # The third way involves using `python -m manim ...`.  In this\n    # case, the CLI arguments passed to manim do not include 'manim',\n    # 'manimcm', or even 'python'.  However, the -m flag will always\n    # be the first argument.\n    from_python_m = sys.argv[0] == \"-m\"\n\n    return from_cli_command or from_python_m",
  "def _paths_config_file():\n    library_wide = os.path.abspath(\n        os.path.join(os.path.dirname(__file__), \"..\", \"default.cfg\")\n    )\n    if sys.platform.startswith(\"linux\"):\n        user_wide = os.path.expanduser(\n            os.path.join(\"~\", \".config\", \"manim\", \"manim.cfg\")\n        )\n    elif sys.platform.startswith(\"darwin\"):\n        user_wide = os.path.expanduser(\n            os.path.join(\"~\", \"Library\", \"Application Support\", \"Manim\", \"manim.cfg\")\n        )\n    elif sys.platform.startswith(\"win32\"):\n        user_wide = os.path.expanduser(\n            os.path.join(\"~\", \"AppData\", \"Roaming\", \"Manim\", \"manim.cfg\")\n        )\n    else:\n        user_wide = os.path.expanduser(\n            os.path.join(\"~\", \".config\", \"manim\", \"manim.cfg\")\n        )\n    return [library_wide, user_wide]",
  "def _run_config():\n    # Config files to be parsed, in ascending priority\n    config_files = _paths_config_file()\n    if _from_command_line():\n        args = _parse_cli(sys.argv[1:])\n        if args.config_file is not None:\n            if os.path.exists(args.config_file):\n                config_files.append(args.config_file)\n            else:\n                raise FileNotFoundError(f\"Config file {args.config_file} doesn't exist\")\n        else:\n            script_directory_file_config = os.path.join(\n                os.path.dirname(args.file), \"manim.cfg\"\n            )\n            if os.path.exists(script_directory_file_config):\n                config_files.append(script_directory_file_config)\n\n    else:\n        # In this case, we still need an empty args object.\n        args = _parse_cli([], input=False)\n        # Need to populate the options left out\n        args.file, args.scene_names, args.output_file = \"\", \"\", \"\"\n\n    config_parser = configparser.ConfigParser()\n    successfully_read_files = config_parser.read(config_files)\n\n    # this is for internal use when writing output files\n    file_writer_config = _parse_file_writer_config(config_parser, args)\n    return args, config_parser, file_writer_config, successfully_read_files",
  "def color_to_rgb(color):\n    if isinstance(color, str):\n        return hex_to_rgb(color)\n    elif isinstance(color, Color):\n        return np.array(color.get_rgb())\n    else:\n        raise Exception(\"Invalid color type\")",
  "def color_to_rgba(color, alpha=1):\n    return np.array([*color_to_rgb(color), alpha])",
  "def rgb_to_color(rgb):\n    try:\n        return Color(rgb=rgb)\n    except:\n        return Color(WHITE)",
  "def rgba_to_color(rgba):\n    return rgb_to_color(rgba[:3])",
  "def rgb_to_hex(rgb):\n    return \"#\" + \"\".join(\"%02x\" % int(255 * x) for x in rgb)",
  "def hex_to_rgb(hex_code):\n    hex_part = hex_code[1:]\n    if len(hex_part) == 3:\n        \"\".join([2 * c for c in hex_part])\n    return np.array([int(hex_part[i : i + 2], 16) / 255 for i in range(0, 6, 2)])",
  "def invert_color(color):\n    return rgb_to_color(1.0 - color_to_rgb(color))",
  "def color_to_int_rgb(color):\n    return (255 * color_to_rgb(color)).astype(\"uint8\")",
  "def color_to_int_rgba(color, opacity=1.0):\n    alpha = int(255 * opacity)\n    return np.append(color_to_int_rgb(color), alpha)",
  "def color_gradient(reference_colors, length_of_output):\n    if length_of_output == 0:\n        return reference_colors[0]\n    rgbs = list(map(color_to_rgb, reference_colors))\n    alphas = np.linspace(0, (len(rgbs) - 1), length_of_output)\n    floors = alphas.astype(\"int\")\n    alphas_mod1 = alphas % 1\n    # End edge case\n    alphas_mod1[-1] = 1\n    floors[-1] = len(rgbs) - 2\n    return [\n        rgb_to_color(interpolate(rgbs[i], rgbs[i + 1], alpha))\n        for i, alpha in zip(floors, alphas_mod1)\n    ]",
  "def interpolate_color(color1, color2, alpha):\n    rgb = interpolate(color_to_rgb(color1), color_to_rgb(color2), alpha)\n    return rgb_to_color(rgb)",
  "def average_color(*colors):\n    rgbs = np.array(list(map(color_to_rgb, colors)))\n    mean_rgb = np.apply_along_axis(np.mean, 0, rgbs)\n    return rgb_to_color(mean_rgb)",
  "def random_bright_color():\n    color = random_color()\n    curr_rgb = color_to_rgb(color)\n    new_rgb = interpolate(curr_rgb, np.ones(len(curr_rgb)), 0.5)\n    return Color(rgb=new_rgb)",
  "def random_color():\n    return random.choice(list(COLOR_MAP.values()))",
  "def get_shaded_rgb(rgb, point, unit_normal_vect, light_source):\n    to_sun = normalize(light_source - point)\n    factor = 0.5 * np.dot(unit_normal_vect, to_sun) ** 3\n    if factor < 0:\n        factor *= 0.5\n    result = rgb + factor\n    clip_in_place(rgb + factor, 0, 1)\n    return result",
  "def remove_list_redundancies(l):\n    \"\"\"\n    Used instead of list(set(l)) to maintain order\n    Keeps the last occurance of each element\n    \"\"\"\n    reversed_result = []\n    used = set()\n    for x in reversed(l):\n        if x not in used:\n            reversed_result.append(x)\n            used.add(x)\n    reversed_result.reverse()\n    return reversed_result",
  "def list_update(l1, l2):\n    \"\"\"\n    Used instead of list(set(l1).update(l2)) to maintain order,\n    making sure duplicates are removed from l1, not l2.\n    \"\"\"\n    return [e for e in l1 if e not in l2] + list(l2)",
  "def list_difference_update(l1, l2):\n    return [e for e in l1 if e not in l2]",
  "def all_elements_are_instances(iterable, Class):\n    return all([isinstance(e, Class) for e in iterable])",
  "def adjacent_n_tuples(objects, n):\n    return zip(*[[*objects[k:], *objects[:k]] for k in range(n)])",
  "def adjacent_pairs(objects):\n    return adjacent_n_tuples(objects, 2)",
  "def batch_by_property(items, property_func):\n    \"\"\"\n    Takes in a list, and returns a list of tuples, (batch, prop)\n    such that all items in a batch have the same output when\n    put into property_func, and such that chaining all these\n    batches together would give the original list (i.e. order is\n    preserved)\n    \"\"\"\n    batch_prop_pairs = []\n\n    def add_batch_prop_pair(batch):\n        if len(batch) > 0:\n            batch_prop_pairs.append((batch, property_func(batch[0])))\n\n    curr_batch = []\n    curr_prop = None\n    for item in items:\n        prop = property_func(item)\n        if prop != curr_prop:\n            add_batch_prop_pair(curr_batch)\n            curr_prop = prop\n            curr_batch = [item]\n        else:\n            curr_batch.append(item)\n    add_batch_prop_pair(curr_batch)\n    return batch_prop_pairs",
  "def tuplify(obj):\n    if isinstance(obj, str):\n        return (obj,)\n    try:\n        return tuple(obj)\n    except TypeError:\n        return (obj,)",
  "def stretch_array_to_length(nparray, length):\n    curr_len = len(nparray)\n    if curr_len > length:\n        raise Warning(\"Trying to stretch array to a length shorter than its own\")\n    indices = np.arange(length) / float(length)\n    indices *= curr_len\n    return nparray[indices.astype(\"int\")]",
  "def make_even(iterable_1, iterable_2):\n    list_1, list_2 = list(iterable_1), list(iterable_2)\n    length = max(len(list_1), len(list_2))\n    return (\n        [list_1[(n * len(list_1)) // length] for n in range(length)],\n        [list_2[(n * len(list_2)) // length] for n in range(length)],\n    )",
  "def make_even_by_cycling(iterable_1, iterable_2):\n    length = max(len(iterable_1), len(iterable_2))\n    cycle1 = it.cycle(iterable_1)\n    cycle2 = it.cycle(iterable_2)\n    return (\n        [next(cycle1) for x in range(length)],\n        [next(cycle2) for x in range(length)],\n    )",
  "def remove_nones(sequence):\n    return [x for x in sequence if x]",
  "def concatenate_lists(*list_of_lists):\n    return [item for l in list_of_lists for item in l]",
  "def add_batch_prop_pair(batch):\n        if len(batch) > 0:\n            batch_prop_pairs.append((batch, property_func(batch[0])))",
  "class Thumbnail(GraphScene):\n    CONFIG = {\n        \"y_max\": 8,\n        \"y_axis_height\": 5,\n    }\n\n    def construct(self):\n        self.show_function_graph()\n\n    def show_function_graph(self):\n        self.setup_axes(animate=False)\n        def func(x):\n            return 0.1 * (x + 3-5) * (x - 3-5) * (x-5) + 5\n\n        def rect(x):\n            return 2.775*(x-1.5)+3.862\n        recta = self.get_graph(rect,x_min=-1,x_max=5)\n        graph = self.get_graph(func,x_min=0.2,x_max=9)\n        graph.set_color(NEW_BLUE)\n        input_tracker_p1 = ValueTracker(1.5)\n        input_tracker_p2 = ValueTracker(3.5)\n\n        def get_x_value(input_tracker):\n            return input_tracker.get_value()\n\n        def get_y_value(input_tracker):\n            return graph.underlying_function(get_x_value(input_tracker))\n\n        def get_x_point(input_tracker):\n            return self.coords_to_point(get_x_value(input_tracker), 0)\n\n        def get_y_point(input_tracker):\n            return self.coords_to_point(0, get_y_value(input_tracker))\n\n        def get_graph_point(input_tracker):\n            return self.coords_to_point(get_x_value(input_tracker), get_y_value(input_tracker))\n\n        def get_v_line(input_tracker):\n            return DashedLine(get_x_point(input_tracker), get_graph_point(input_tracker), stroke_width=2)\n\n        def get_h_line(input_tracker):\n            return DashedLine(get_graph_point(input_tracker), get_y_point(input_tracker), stroke_width=2)\n        # \n        input_triangle_p1 = RegularPolygon(n=3, start_angle=TAU / 4)\n        output_triangle_p1 = RegularPolygon(n=3, start_angle=0)\n        for triangle in input_triangle_p1, output_triangle_p1:\n            triangle.set_fill(WHITE, 1)\n            triangle.set_stroke(width=0)\n            triangle.scale(0.1)\n        # \n        input_triangle_p2 = RegularPolygon(n=3, start_angle=TAU / 4)\n        output_triangle_p2 = RegularPolygon(n=3, start_angle=0)\n        for triangle in input_triangle_p2, output_triangle_p2:\n            triangle.set_fill(WHITE, 1)\n            triangle.set_stroke(width=0)\n            triangle.scale(0.1)\n        \n        # \n        x_label_p1 = TexMobject(\"a\")\n        output_label_p1 = TexMobject(\"f(a)\")\n        x_label_p2 = TexMobject(\"b\")\n        output_label_p2 = TexMobject(\"f(b)\")\n        v_line_p1 = get_v_line(input_tracker_p1)\n        v_line_p2 = get_v_line(input_tracker_p2)\n        h_line_p1 = get_h_line(input_tracker_p1)\n        h_line_p2 = get_h_line(input_tracker_p2)\n        graph_dot_p1 = Dot(color=WHITE)\n        graph_dot_p2 = Dot(color=WHITE)\n\n        # reposition mobjects\n        x_label_p1.next_to(v_line_p1, DOWN)\n        x_label_p2.next_to(v_line_p2, DOWN)\n        output_label_p1.next_to(h_line_p1, LEFT)\n        output_label_p2.next_to(h_line_p2, LEFT)\n        input_triangle_p1.next_to(v_line_p1, DOWN, buff=0)\n        input_triangle_p2.next_to(v_line_p2, DOWN, buff=0)\n        output_triangle_p1.next_to(h_line_p1, LEFT, buff=0)\n        output_triangle_p2.next_to(h_line_p2, LEFT, buff=0)\n        graph_dot_p1.move_to(get_graph_point(input_tracker_p1))\n        graph_dot_p2.move_to(get_graph_point(input_tracker_p2))\n\n\n        #\n        self.play(\n            ShowCreation(graph),\n        )\n        # Animacion del punto a\n        self.add_foreground_mobject(graph_dot_p1)\n        self.add_foreground_mobject(graph_dot_p2)\n        self.play(\n            DrawBorderThenFill(input_triangle_p1),\n            Write(x_label_p1),\n            ShowCreation(v_line_p1),\n            GrowFromCenter(graph_dot_p1),\n            ShowCreation(h_line_p1),\n            Write(output_label_p1),\n            DrawBorderThenFill(output_triangle_p1),\n            DrawBorderThenFill(input_triangle_p2),\n            Write(x_label_p2),\n            ShowCreation(v_line_p2),\n            GrowFromCenter(graph_dot_p2),\n            ShowCreation(h_line_p2),\n            Write(output_label_p2),\n            DrawBorderThenFill(output_triangle_p2),\n            run_time=0.5\n        )\n        self.add(\n            input_triangle_p2,\n            x_label_p2,\n            graph_dot_p2,\n            v_line_p2,\n            h_line_p2,\n            output_triangle_p2,\n            output_label_p2,\n        )\n        ###################\n        pendiente_recta = self.get_secant_slope_group(\n            1.9, recta, dx = 1.4,\n            df_label = None,\n            dx_label = None,\n            dx_line_color = PURPLE,\n            df_line_color= ORANGE,\n            )\n        grupo_secante = self.get_secant_slope_group(\n            1.5, graph, dx = 2,\n            df_label = None,\n            dx_label = None,\n            dx_line_color = \"#942357\",\n            df_line_color= \"#3f7d5c\",\n            secant_line_color = RED,\n        )\n\n\n        self.add(\n            input_triangle_p2,\n            graph_dot_p2,\n            v_line_p2,\n            h_line_p2,\n            output_triangle_p2,\n        )\n        self.play(FadeIn(grupo_secante))\n\n        kwargs = {\n            \"x_min\" : 4,\n            \"x_max\" : 9,\n            \"fill_opacity\" : 0.75,\n            \"stroke_width\" : 0.25,\n        }\n        self.graph=graph\n        iteraciones=6\n\n\n        self.rect_list = self.get_riemann_rectangles_list(\n            graph, iteraciones,start_color=PURPLE,end_color=ORANGE, **kwargs\n        )\n        flat_rects = self.get_riemann_rectangles(\n            self.get_graph(lambda x : 0), dx = 0.5,start_color=invert_color(PURPLE),end_color=invert_color(ORANGE),**kwargs\n        )\n        rects = self.rect_list[0]\n        self.transform_between_riemann_rects(\n            flat_rects, rects, \n            replace_mobject_with_target_in_scene = True,\n            run_time=0.9\n        )\n\n        # adding manim\n        picture = Group(*self.mobjects)\n        picture.scale(0.6).to_edge(LEFT, buff=SMALL_BUFF)\n        manim = TextMobject(\"Manim\").set_height(1.5) \\\n                                    .next_to(picture, RIGHT) \\\n                                    .shift(DOWN * 0.7)\n        self.add(manim)",
  "def construct(self):\n        self.show_function_graph()",
  "def show_function_graph(self):\n        self.setup_axes(animate=False)\n        def func(x):\n            return 0.1 * (x + 3-5) * (x - 3-5) * (x-5) + 5\n\n        def rect(x):\n            return 2.775*(x-1.5)+3.862\n        recta = self.get_graph(rect,x_min=-1,x_max=5)\n        graph = self.get_graph(func,x_min=0.2,x_max=9)\n        graph.set_color(NEW_BLUE)\n        input_tracker_p1 = ValueTracker(1.5)\n        input_tracker_p2 = ValueTracker(3.5)\n\n        def get_x_value(input_tracker):\n            return input_tracker.get_value()\n\n        def get_y_value(input_tracker):\n            return graph.underlying_function(get_x_value(input_tracker))\n\n        def get_x_point(input_tracker):\n            return self.coords_to_point(get_x_value(input_tracker), 0)\n\n        def get_y_point(input_tracker):\n            return self.coords_to_point(0, get_y_value(input_tracker))\n\n        def get_graph_point(input_tracker):\n            return self.coords_to_point(get_x_value(input_tracker), get_y_value(input_tracker))\n\n        def get_v_line(input_tracker):\n            return DashedLine(get_x_point(input_tracker), get_graph_point(input_tracker), stroke_width=2)\n\n        def get_h_line(input_tracker):\n            return DashedLine(get_graph_point(input_tracker), get_y_point(input_tracker), stroke_width=2)\n        # \n        input_triangle_p1 = RegularPolygon(n=3, start_angle=TAU / 4)\n        output_triangle_p1 = RegularPolygon(n=3, start_angle=0)\n        for triangle in input_triangle_p1, output_triangle_p1:\n            triangle.set_fill(WHITE, 1)\n            triangle.set_stroke(width=0)\n            triangle.scale(0.1)\n        # \n        input_triangle_p2 = RegularPolygon(n=3, start_angle=TAU / 4)\n        output_triangle_p2 = RegularPolygon(n=3, start_angle=0)\n        for triangle in input_triangle_p2, output_triangle_p2:\n            triangle.set_fill(WHITE, 1)\n            triangle.set_stroke(width=0)\n            triangle.scale(0.1)\n        \n        # \n        x_label_p1 = TexMobject(\"a\")\n        output_label_p1 = TexMobject(\"f(a)\")\n        x_label_p2 = TexMobject(\"b\")\n        output_label_p2 = TexMobject(\"f(b)\")\n        v_line_p1 = get_v_line(input_tracker_p1)\n        v_line_p2 = get_v_line(input_tracker_p2)\n        h_line_p1 = get_h_line(input_tracker_p1)\n        h_line_p2 = get_h_line(input_tracker_p2)\n        graph_dot_p1 = Dot(color=WHITE)\n        graph_dot_p2 = Dot(color=WHITE)\n\n        # reposition mobjects\n        x_label_p1.next_to(v_line_p1, DOWN)\n        x_label_p2.next_to(v_line_p2, DOWN)\n        output_label_p1.next_to(h_line_p1, LEFT)\n        output_label_p2.next_to(h_line_p2, LEFT)\n        input_triangle_p1.next_to(v_line_p1, DOWN, buff=0)\n        input_triangle_p2.next_to(v_line_p2, DOWN, buff=0)\n        output_triangle_p1.next_to(h_line_p1, LEFT, buff=0)\n        output_triangle_p2.next_to(h_line_p2, LEFT, buff=0)\n        graph_dot_p1.move_to(get_graph_point(input_tracker_p1))\n        graph_dot_p2.move_to(get_graph_point(input_tracker_p2))\n\n\n        #\n        self.play(\n            ShowCreation(graph),\n        )\n        # Animacion del punto a\n        self.add_foreground_mobject(graph_dot_p1)\n        self.add_foreground_mobject(graph_dot_p2)\n        self.play(\n            DrawBorderThenFill(input_triangle_p1),\n            Write(x_label_p1),\n            ShowCreation(v_line_p1),\n            GrowFromCenter(graph_dot_p1),\n            ShowCreation(h_line_p1),\n            Write(output_label_p1),\n            DrawBorderThenFill(output_triangle_p1),\n            DrawBorderThenFill(input_triangle_p2),\n            Write(x_label_p2),\n            ShowCreation(v_line_p2),\n            GrowFromCenter(graph_dot_p2),\n            ShowCreation(h_line_p2),\n            Write(output_label_p2),\n            DrawBorderThenFill(output_triangle_p2),\n            run_time=0.5\n        )\n        self.add(\n            input_triangle_p2,\n            x_label_p2,\n            graph_dot_p2,\n            v_line_p2,\n            h_line_p2,\n            output_triangle_p2,\n            output_label_p2,\n        )\n        ###################\n        pendiente_recta = self.get_secant_slope_group(\n            1.9, recta, dx = 1.4,\n            df_label = None,\n            dx_label = None,\n            dx_line_color = PURPLE,\n            df_line_color= ORANGE,\n            )\n        grupo_secante = self.get_secant_slope_group(\n            1.5, graph, dx = 2,\n            df_label = None,\n            dx_label = None,\n            dx_line_color = \"#942357\",\n            df_line_color= \"#3f7d5c\",\n            secant_line_color = RED,\n        )\n\n\n        self.add(\n            input_triangle_p2,\n            graph_dot_p2,\n            v_line_p2,\n            h_line_p2,\n            output_triangle_p2,\n        )\n        self.play(FadeIn(grupo_secante))\n\n        kwargs = {\n            \"x_min\" : 4,\n            \"x_max\" : 9,\n            \"fill_opacity\" : 0.75,\n            \"stroke_width\" : 0.25,\n        }\n        self.graph=graph\n        iteraciones=6\n\n\n        self.rect_list = self.get_riemann_rectangles_list(\n            graph, iteraciones,start_color=PURPLE,end_color=ORANGE, **kwargs\n        )\n        flat_rects = self.get_riemann_rectangles(\n            self.get_graph(lambda x : 0), dx = 0.5,start_color=invert_color(PURPLE),end_color=invert_color(ORANGE),**kwargs\n        )\n        rects = self.rect_list[0]\n        self.transform_between_riemann_rects(\n            flat_rects, rects, \n            replace_mobject_with_target_in_scene = True,\n            run_time=0.9\n        )\n\n        # adding manim\n        picture = Group(*self.mobjects)\n        picture.scale(0.6).to_edge(LEFT, buff=SMALL_BUFF)\n        manim = TextMobject(\"Manim\").set_height(1.5) \\\n                                    .next_to(picture, RIGHT) \\\n                                    .shift(DOWN * 0.7)\n        self.add(manim)",
  "def func(x):\n            return 0.1 * (x + 3-5) * (x - 3-5) * (x-5) + 5",
  "def rect(x):\n            return 2.775*(x-1.5)+3.862",
  "def get_x_value(input_tracker):\n            return input_tracker.get_value()",
  "def get_y_value(input_tracker):\n            return graph.underlying_function(get_x_value(input_tracker))",
  "def get_x_point(input_tracker):\n            return self.coords_to_point(get_x_value(input_tracker), 0)",
  "def get_y_point(input_tracker):\n            return self.coords_to_point(0, get_y_value(input_tracker))",
  "def get_graph_point(input_tracker):\n            return self.coords_to_point(get_x_value(input_tracker), get_y_value(input_tracker))",
  "def get_v_line(input_tracker):\n            return DashedLine(get_x_point(input_tracker), get_graph_point(input_tracker), stroke_width=2)",
  "def get_h_line(input_tracker):\n            return DashedLine(get_graph_point(input_tracker), get_y_point(input_tracker), stroke_width=2)"
]